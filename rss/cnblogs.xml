<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>证明：辗转相除法与更相减损术 - pycr</title>
<link>http://www.cnblogs.com/pycr/p/14288188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pycr/p/14288188.html</guid>
<description>&lt;center&gt;&lt;span&gt;辗转相除法与更相减损术的证明&lt;/span&gt;&lt;/center&gt;

&lt;ul&gt;&lt;li&gt;这两种方法都是用来求两个数的最大公约数，但是从时间复杂度的角度来讲，辗转相除法的效率会高于更相减损术，尤其是在两数相差比较大的时候。&lt;/li&gt;
&lt;li&gt;两者证明方法类似，但因为更相减损术的证明更为简单，并且有了其基础也能更快地去理解辗转相除法，故先证明更相减损术。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;4.78125&quot;&gt;
&lt;p&gt;更相减损术是出自《&lt;a href=&quot;https://baike.baidu.com/item/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%9C%AF/348232&quot; target=&quot;_blank&quot;&gt;九章算术&lt;/a&gt;》的一种求&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/869308&quot; target=&quot;_blank&quot;&gt;最大公约数&lt;/a&gt;的算法，它原本是为&lt;a href=&quot;https://baike.baidu.com/item/%E7%BA%A6%E5%88%86/10107157&quot; target=&quot;_blank&quot;&gt;约分&lt;/a&gt;而设计的，但它&lt;a href=&quot;https://baike.baidu.com/item/%E9%80%82%E7%94%A8&quot; target=&quot;_blank&quot;&gt;适用&lt;/a&gt;于任何需要求最大公约数的场合。——百度百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;description&quot;&gt;Description:&lt;/h2&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;\[\forall a,b\in \mathbb{N},a\geq b\:\Rightarrow gcd(a,b)=gcd(b,a-b)=gcd(a,a-b) \]&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;\[\forall a,b\in \mathbb{N}\:\Rightarrow gcd(2a,2b)=2\cdot gcd(a,b) \]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;前置芝士：&quot;&gt;前置芝士：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(a|b\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; 的约数。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(gcd(a,b)\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 的最大公约数。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(a\:mod\:b\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 除以 &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; 取余数。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;证明：&quot;&gt;证明：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;显然，根据最大公约数的定义，后者是成立的，主要证明前者。&lt;/li&gt;
&lt;li&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 的&lt;strong&gt;任意&lt;/strong&gt;公约数 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; ，因为 &lt;span class=&quot;math inline&quot;&gt;\(d|a,d|b\)&lt;/span&gt; ，所以 &lt;span class=&quot;math inline&quot;&gt;\(d|(a-b)\)&lt;/span&gt; 。（不妨设 &lt;span class=&quot;math inline&quot;&gt;\(a=x\cdot d,b=y\cdot d\)&lt;/span&gt; ，那么 &lt;span class=&quot;math inline&quot;&gt;\(a-b=x\cdot d-y\cdot d=(x-y)\cdot d\)&lt;/span&gt; ，显然 &lt;span class=&quot;math inline&quot;&gt;\((x-y)\cdot d\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 的倍数）&lt;/li&gt;
&lt;li&gt;因为 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 是任意取的，所以可以取到整个 &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 的公约数集合。故 &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 的公约数集合与 &lt;span class=&quot;math inline&quot;&gt;\(b,a-b\)&lt;/span&gt; 的公约数集合相同，于是他们的最大公约数自然也相等。对于 &lt;span class=&quot;math inline&quot;&gt;\(a,a-b\)&lt;/span&gt; 同理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;证毕。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;辗转相除法，即欧几里得算法，同样是一种用来求两个数的最大公约数的算法，但是要比更相减损术更加高效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;description-1&quot;&gt;Description:&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;\[\forall a,b\in \mathbb{N},b\neq 0\Rightarrow gcd(a,b)=gcd(b,a\:mod\:b) \]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;前置芝士：-1&quot;&gt;前置芝士：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;熟悉更相减损术的证明以及取模运算的意义。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;证明：-1&quot;&gt;证明：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(a&amp;lt;b\)&lt;/span&gt; ，则 &lt;span class=&quot;math inline&quot;&gt;\(gcd(b,a\:mod\:b)=gcd(b,a)=gcd(a,b)\)&lt;/span&gt; ，命题得证。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(a\geq b\)&lt;/span&gt; ，则不妨设 &lt;span class=&quot;math inline&quot;&gt;\(a=q\times b+r\)&lt;/span&gt; ，其中 &lt;span class=&quot;math inline&quot;&gt;\(0\leq r&amp;lt;b\)&lt;/span&gt; ，显然 &lt;span class=&quot;math inline&quot;&gt;\(r=a\:mod\:b\)&lt;/span&gt; 。对于 &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 的&lt;strong&gt;任意&lt;/strong&gt;公约数 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; ，因为 &lt;span class=&quot;math inline&quot;&gt;\(d|a,d|(q\times b)\)&lt;/span&gt; ，所以 &lt;span class=&quot;math inline&quot;&gt;\(d|(a-q\times b)\)&lt;/span&gt; ，即 &lt;span class=&quot;math inline&quot;&gt;\(d|r\)&lt;/span&gt; ，因此 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 也是 &lt;span class=&quot;math inline&quot;&gt;\(b,r\)&lt;/span&gt; 的公约数。&lt;/li&gt;
&lt;li&gt;故 &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 的公约数集合与 &lt;span class=&quot;math inline&quot;&gt;\(b,a\:mod\:b\)&lt;/span&gt; 的公约数集合相同，于是他们的最大公约数自然也相等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;证毕。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;&lt;em&gt;2021年1月17日&lt;br/&gt;——pycr&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Jan 2021 00:27:00 +0000</pubDate>
<dc:creator>pycr</dc:creator>
<og:description>辗转相除法与更相减损术的证明 前言 这两种方法都是用来求两个数的最大公约数，但是从时间复杂度的角度来讲，辗转相除法的效率会高于更相减损术，尤其是在两数相差比较大的时候。 两者证明方法类似，但因为更相减</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pycr/p/14288188.html</dc:identifier>
</item>
<item>
<title>python中re模块的使用（正则表达式） - Elite-Wang</title>
<link>http://www.cnblogs.com/Elite-Wang/p/14288152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Elite-Wang/p/14288152.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;span&gt;正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个模式(规则)的文本。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1.表示字符&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt;：匹配任意除换行符'\n'外的字符，但是在DOTALL模式中也可以匹配换行符'\n'&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\&lt;/strong&gt;：转义字符，使后一个字符改变原来的意思，如果字符串中想匹配*，可以使用\*，也可以使用字符集[*]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;[...]&lt;/strong&gt;：字符集，匹配字符集中列出的任意字符。字符可以逐个列出，也可以给出范围，比如[a-z]，[0-9]，第一个字符是^表示取反。所有特殊字符在字符集中都失去其原有的特殊含义。如果想使用']','-'或者'^'，可以在前面加上\，或者将]或者-放在首位，将^放在非首位&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2.预定义字符集（可写在字符集[]中）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;\d&lt;/strong&gt;：数字[0-9]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\D&lt;/strong&gt;：非数字[^0-9]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\s&lt;/strong&gt;：空白字符[&amp;lt;空格&amp;gt;，\t,\n,\r,\f,\v]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\S&lt;/strong&gt;：非空白字符[^\s]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\w&lt;/strong&gt;：单词字符[a-zA-Z0-9_]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\W&lt;/strong&gt;：非单词字符[^\w]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3.表示数量&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;*&lt;/strong&gt;：匹配前一个字符0次或无限次，即可有可无&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;+&lt;/strong&gt;：匹配前一个字符出现1次或者无限次，即至少有1次&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;{m}&lt;/strong&gt;：匹配前一个字符出现m次&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;{m,}&lt;/strong&gt;：匹配前一个字符至少出现m次&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;{,n}&lt;/strong&gt;：匹配前一个字符至多出现n次&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;{m,n}&lt;/strong&gt;：匹配前一个字符出现从m到n次&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;4.表示边界&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;^&lt;/strong&gt;：匹配字符串开头。在多行模式中匹配每一行的开头&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;$&lt;/strong&gt;：匹配字符串结尾。在多行模式中匹配每一行的结尾&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\A&lt;/strong&gt;：仅匹配字符串开头&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\Z&lt;/strong&gt;：仅匹配字符串结尾&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\b&lt;/strong&gt;：匹配单词边界，\w和\W之间&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\B&lt;/strong&gt;：匹配非单词边界，[^\b]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;5.匹配分组&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;|&lt;/strong&gt;：匹配左右任意一个表达式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;(...)&lt;/strong&gt;：被括起来的表达式作为一个分组，从表达式左边开始，每遇到一个'('，编号+1。分组表达式作为一个整体，后面可接数量词。表达式中的|仅在该分组中有效&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;(?P&amp;lt;name&amp;gt;)&lt;/strong&gt;：分组，除了原有的编号以外，再给分组取一个别名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;(?P=&amp;lt;name&amp;gt;)&lt;/strong&gt;：引用别名为&amp;lt;name&amp;gt;的分组匹配到的字符串&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;\&amp;lt;number&amp;gt;&lt;/strong&gt;：引用编号为&amp;lt;number&amp;gt;的分组匹配到的字符串&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;6.特殊构造(不作为分组)&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;(?:...)&lt;/strong&gt;：(...)的不分组版本，用于使用'|'或后面接上数量词，比如(?:[1-9]?\d|100)表示匹配数字0-100，(?:abc){2}表示匹配abcabc&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;剩下的一些不常见，略&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;在 Python中，我们可以使用内置的 re 模块来使用正则表达式。与大多数编程语言相同，正则表达式里使用'\'作为转义字符，这就可能造成反斜杠困扰。Python里的原生字符串很好地解决了这个问题，只需要在字符串前面加上'r'前缀。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;re模块的一般使用步骤：&lt;/h2&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;使用 &lt;code&gt;compile()&lt;/code&gt; 函数将正则表达式的字符串形式编译为一个 &lt;code&gt;Pattern&lt;/code&gt; 对象&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;通过 &lt;code&gt;Pattern&lt;/code&gt; 对象提供的一系列方法对文本进行匹配查找&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;1.compile函数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;compile 函数用于编译正则表达式，生成一个 Pattern 对象。必须传入的第一个参数是'规则字符串'，另外可以通过第二个参数(flags)来指定匹配模式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;常见的匹配模式：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;re.I(re.IGNORECASE): 忽略大小写&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;re.M(MULTILINE): 多行模式，改变’^’和’$’的行为&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;&lt;span&gt;re.S(DOTALL): 点任意匹配模式，改变’.’的行为，可以匹配'\n'&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将正则表达式编译成 Pattern对象，并指定匹配模式为点任意匹配模式&lt;/span&gt;
pattern = re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\d+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,re.S)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;2.Pattern 对象的一些常用方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;match方法&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;search方法&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;findall方法&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;finditer方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;finditer 方法的行为跟 findall 的行为类似，也是搜索整个字符串，获得所有匹配的结果。但它返回一个顺序访问每一个匹配结果（Match 对象）的迭代器。&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;&lt;span&gt;举例：&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [1]: &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re

In [&lt;/span&gt;2]: pattern = re.compile(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\d+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;3]: iter = pattern.finditer(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello123world456  haha789&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;4&lt;span&gt;]: iter
Out[&lt;/span&gt;4]: &amp;lt;callable_iterator at 0x7fb824fe2a90&amp;gt;&lt;span&gt;

In [&lt;/span&gt;5]: &lt;span&gt;for&lt;/span&gt; m &lt;span&gt;in&lt;/span&gt;&lt;span&gt; iter:
   ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(m.group())
   ...: 
&lt;/span&gt;123
456
789
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;split方法&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;sub方法&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;贪婪模式：在整个表达式匹配成功的前提下，尽可能多的匹配&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;非贪婪模式：在整个表达式匹配成功的前提下，尽可能少的匹配&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;&lt;span&gt;在表示数量的&quot;*&quot;,&quot;?&quot;,&quot;+&quot;,&quot;{m,n}&quot;后面加上？，使贪婪变成非贪婪&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [1]: &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re

In [&lt;/span&gt;2]: pattern = re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\d+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;3]: pattern.match(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).group()
Out[&lt;/span&gt;3]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;4]: pattern = re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\d+?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭贪婪模式&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;5]: pattern.match(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;非贪婪模式下，?只匹配一个字符&lt;/span&gt;
Out[5]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;6]: pattern = re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;.*&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;7]: pattern.match(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;test1&amp;lt;/div&amp;gt;bb&amp;lt;div&amp;gt;test2&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).group()
Out[&lt;/span&gt;7]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;test1&amp;lt;/div&amp;gt;bb&amp;lt;div&amp;gt;test2&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;8]: pattern = re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;.*?&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭贪婪模式&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;9]: pattern.match(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;test1&amp;lt;/div&amp;gt;bb&amp;lt;div&amp;gt;test2&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).group()
Out[&lt;/span&gt;9]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;test1&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 16 Jan 2021 19:37:00 +0000</pubDate>
<dc:creator>Elite-Wang</dc:creator>
<og:description>一、什么是正则表达式？ 正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Elite-Wang/p/14288152.html</dc:identifier>
</item>
<item>
<title>SpringBoot整合Swagger2 - 赵小胖0914</title>
<link>http://www.cnblogs.com/Sky0914/p/14288128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sky0914/p/14288128.html</guid>
<description>&lt;p&gt;首先遵循SpringBoot的三板斧&lt;/p&gt;
&lt;p&gt;第一步添加依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-pom&quot;&gt;&amp;lt;!-- SwaggerUI 接口文档 http://{ip}:{prot}/swagger-ui.html --&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;{version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;{version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步添加注解&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@EnableSwagger2 //启动SwaggerUI，在启动类或Swagger配置类上添加该注解
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步写配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket api() {

/*
        //可以添加多个header或参数
        ParameterBuilder aParameterBuilder = new ParameterBuilder();
        aParameterBuilder
                //参数类型支持header, cookie, body, query etc
                .parameterType(&quot;header&quot;)
                //参数名
                .name(&quot;user-token&quot;)
                //默认值
                .defaultValue(&quot;t122222&quot;)
                .description(&quot;用户登录凭证&quot;)
                //指定参数值的类型
                .modelRef(new ModelRef(&quot;string&quot;))
                //非必需，这里是全局配置
                .required(false).build();
        List&amp;lt;Parameter&amp;gt; aParameters = new ArrayList&amp;lt;&amp;gt;();
        aParameters.add(aParameterBuilder.build());
*/

        return new Docket(DocumentationType.SWAGGER_2)
//        return new Docket(DocumentationType.SPRING_WEB)
                .apiInfo(apiInfo())
                .pathMapping(&quot;/&quot;)
                .select()// 选择那些路径和api会生成document
                .apis(RequestHandlerSelectors.any())// 对所有api进行监控
                // 不显示错误的接口地址
                .paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;)))// 错误error路径不监控
                .paths(Predicates.not(PathSelectors.regex(&quot;/actuator.*&quot;)))// 错误error路径不监控
                .paths(PathSelectors.regex(&quot;/.*&quot;))// 对根下所有路径进行监控
                .paths(PathSelectors.any())   // 对所有路径进行监控
                // 自行修改为自己的包路径
//                .apis(RequestHandlerSelectors.basePackage(&quot;com.happyloves.zc.service.account.api&quot;))
                .build()
//                .globalOperationParameters(aParameters)
                .enable(true);
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title(&quot;API接口&quot;)
                .description(&quot;API接口文档&quot;)
                //服务条款网址
//                .termsOfServiceUrl(&quot;https://www.google.com&quot;)
                .version(&quot;1.0&quot;)
//                .contact(new Contact(&quot;啦啦啦&quot;, &quot;url&quot;, &quot;email&quot;))
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩展：swagger-bootstrap-ui是springfox-swagger的增强UI实现，为Java开发者在使用Swagger的时候，能拥有一份简洁、强大的接口文档体验&lt;br/&gt;&lt;strong&gt;项目地址&lt;/strong&gt;&lt;br/&gt;码云：&lt;a href=&quot;https://gitee.com/xiaoym/swagger-bootstrap-ui&quot; target=&quot;_blank&quot;&gt;https://gitee.com/xiaoym/swagger-bootstrap-ui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub:&lt;a href=&quot;https://github.com/xiaoymin/Swagger-Bootstrap-UI&quot; target=&quot;_blank&quot;&gt;https://github.com/xiaoymin/Swagger-Bootstrap-UI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在线体验：&lt;a href=&quot;http://swagger-bootstrap-ui.xiaominfo.com/doc.html&quot; target=&quot;_blank&quot;&gt;http://swagger-bootstrap-ui.xiaominfo.com/doc.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目文档：&lt;a href=&quot;http://www.xiaominfo.com/swagger-bootstrap-ui/&quot; target=&quot;_blank&quot;&gt;http://www.xiaominfo.com/swagger-bootstrap-ui/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码集成示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot在线demo地址：&lt;a href=&quot;https://gitee.com/xiaoym/swagger-bootstrap-ui-demo&quot; target=&quot;_blank&quot;&gt;https://gitee.com/xiaoym/swagger-bootstrap-ui-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spring Mvc在线demo地址：&lt;a href=&quot;https://gitee.com/xiaoym/swagger-bootstrap-ui-demo/tree/master/swagger-bootstrap-ui-demo-mvc&quot; target=&quot;_blank&quot;&gt;https://gitee.com/xiaoym/swagger-bootstrap-ui-demo/tree/master/swagger-bootstrap-ui-demo-mvc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-pom&quot;&gt;&amp;lt;!-- swagger-bootstrap-ui是 Swagger 的增强UI 实现，使文档更友好一点儿 http://{ip}:{prot}/doc.html --&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;com.github.xiaoymin&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;swagger-bootstrap-ui&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.9.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://zc.happyloves.cn:4443/wordpress/&quot; target=&quot;_blank&quot;&gt;赵小胖个人博客：https://zc.happyloves.cn:4443/wordpress/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Jan 2021 18:34:00 +0000</pubDate>
<dc:creator>赵小胖0914</dc:creator>
<og:description>首先遵循SpringBoot的三板斧 第一步添加依赖 &amp;amp;lt;!-- SwaggerUI 接口文档 http://{ip}:{prot}/swagger-ui.html --&amp;amp;gt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Sky0914/p/14288128.html</dc:identifier>
</item>
<item>
<title>行业动态 | 利用Cassandra数据库揭开家族祖先的秘密 - DataStax</title>
<link>http://www.cnblogs.com/datastax/p/14288126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datastax/p/14288126.html</guid>
<description>&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;frhuu-0-0&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;frhuu-0-0&quot;&gt;&lt;span data-offset-key=&quot;frhuu-0-0&quot;&gt;&lt;span data-offset-key=&quot;frhuu-0-0&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2111170/202101/2111170-20210117023005476-1761813346.png&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;309&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;frhuu-0-0&quot;&gt;FamilySearch选择了基于Apache Cassandra的DataStax Enterprise (DSE)来加速用户增长，并通过更快的反应时间、高可用性以及零数据库宕机来提供强大的线上用户体验。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;ett08-0-0&quot; readability=&quot;8&quot;&gt;

&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;ett08-0-0&quot;&gt;自从采用了DSE，FamilySearch可以专注于构建和提高他们的应用程序，从而致力于联结不同代际的家庭成员的使命。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;eb477-0-0&quot;&gt;“在家族树(Family Tree)这个App火了之后，我们收到了来自顾客的巨大反响。不过，为了提供出色的客户体验，我们需要一个伸缩性更好的数据库来防止宕机的发生，并且这个数据库应该还能够让我们向我们的用户提供更多的特性和功能。”&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span data-offset-key=&quot;eb477-0-0&quot;&gt;——FamilySearch软件开发经理Michael Nelson&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;2gubo-0-0&quot;&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;2gubo-0-0&quot;&gt;一分钟案例速读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;1bi1o-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1bi1o-0-0&quot;&gt;系谱学&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;fcc98-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;fcc98-0-0&quot;&gt;解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;342n8-0-0&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;342n8-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;342n8-0-0&quot;&gt;用户可以享受到更快的反应速度、高可用性以及零数据库宕机&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;d1c0s-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;d1c0s-0-0&quot;&gt;高峰使用期每小时例行处理1.25亿笔交易&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;ah1io-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ah1io-0-0&quot;&gt;能够将像是资料提示(Record Hints)一类的新功能推向市场&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;5o06k-0-0&quot;&gt;01 &lt;span data-offset-key=&quot;5o06k-0-1&quot;&gt;关于FamilySearch&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;8sfsm-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8sfsm-0-0&quot;&gt;FamilySearch是世界上最大的系谱学组织。通过利用强大且用户友好的在线搜索功能访问历史资料，FamilySearch帮助人们揭示与自己及家族有关的新发现。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;42jn7-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;42jn7-0-0&quot;&gt;数百万人使用FamilySearch的资料、资源和服务来更多地了解自己的家族史。为了帮助人们实现这些，100多年来，FamilySearch及其前身一直在全球范围内积极收集并保存和共享家谱资料。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;a5nh3-0-0&quot; readability=&quot;10&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;a5nh3-0-0&quot;&gt;通过FamilySearch的网站和分布在129个国家的4,921个家族史中心（包括位于美国犹他州盐湖城的主家族史博物馆），顾客们可以免费获取FamilySearch的服务和资源。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-4553bbfb5c78dce315e8e6ac9283ee77_720w.png&quot; width=&quot;505&quot; height=&quot;153&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;528&quot; data-rawheight=&quot;160&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-4553bbfb5c78dce315e8e6ac9283ee77.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-fd709c6a5f220a708a0803f16579ca4b.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;fghjc-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;02 &lt;span data-offset-key=&quot;fghjc-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;家族树(Family Tree)使得揭示新发现变得前所未有的容易&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;4g06l-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4g06l-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;家族树这个App让用户能够与他人合作编辑和删除错误的数据，从而为有共同祖先的其他人保留新的发现。家族树提供了直观而丰富的客户体验，包括了能让用户更容易地发现并将其他人的资料联结到自己的家族树中的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;f8s43-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f8s43-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;FamilySearch还积极地代用户们寻找相关的资料，帮助他们揭示新的发现。这些相关的资料会通过一个叫资料提示(Record Hints)的功能展示给用户。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;8gsho-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8gsho-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;仰赖于FamilySearch在全球范围内为资料保存所做的努力，每周都会有海量的历史资料添加到网站上。当用户在这些资料中搜寻的时候，资料提示功能的提示会为用户提供更多的信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;9e69n-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;03 &lt;span data-offset-key=&quot;9e69n-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;日益流行的App驱动了用户的大幅增长&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;jh1e-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;jh1e-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;家族树这个App非常之流行，超过50万用户产生了大量的需求。在过去一年间，FamilySearch因他们之前的数据库技术而感到纠结，因为该技术难以负荷他们的用户对于使用体验的预期。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;bb8ae-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bb8ae-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;随着家族树App越来越流行，FamilySearch意识到他们之前已经在成本效率允许的情况下尽可能地垂直扩展了他们的数据库，但是他们仍然最多只能负荷家族树App每小时产生6000万次事务——这一技术瓶颈阻碍了未来的用户增长。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;841p-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;04 &lt;span data-offset-key=&quot;841p-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;DataStax Enterprise助力用户增长和出色的用户体验&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;bkoqj-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bkoqj-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;FamilySearch预计在未来的三年中，网站使用量将会有10-100倍的增长。他们希望能够为这个快速增长做好准备。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;830ag-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;830ag-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;FamilySearch曾经深入地且一对一地对比了几个不同的关系型和NoSQL数据库，其中包括了开源版本的Cassandra和DSE。为了支持日益增长的用户需求，FamilySearch最终因伸缩性和高性能选择了DataStax Enterprise (DSE)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;4dvs6-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4dvs6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;DSE的无主架构提供了让人100%满意的可用性和零宕机时间——即使是在流量激增或集群维护时依然如此。作为一个分布式的、响应式的智慧型数据库，FamilySearch的家庭树App选择将DSE作为它建构和运行的基础。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;8c76e-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8c76e-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;FamilySearch在每周日的流量通常是最大的，在他们的数据库迁移之前，他们的数据库每周都会接近其处理能力的极限。幸运的是FamilySearch及时地做出了改变。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;5a5dm-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5a5dm-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在使用DSE不到两周的时候，他们的数据库流量达到了之前系统的处理能力的极限。但是这时他们已经能够无缝地持续提供他们的用户所需的客户体验。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;1qil2-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1qil2-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;现在，FamilySearch在高峰使用期每小时例行处理1.25亿笔交易，并且还有着大量的未来增长的空间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;adii9-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;05 &lt;span data-offset-key=&quot;adii9-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;主要成果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;6c3oo-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6c3oo-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;选择DataStax Enterprise，FamilySearch通往未来增长的道路变得坚实可靠——客户们会体验到更快地响应时间、高可用性以及零数据库宕机时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;31nqj-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;31nqj-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;不仅如此，DSE还帮助FamilySearch向市场推出了一些新功能。比如像是可以帮用户揭示新发现的新应用——资料提示(Record Hints)，FamilySearch之前的基础设施是不可能负荷的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;b1jmr-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b1jmr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;自从采用了DSE，FamilySearch可以专注于构建和提高他们的应用程序，从而致力于联结不同代际的家庭成员的使命。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;5h2li&quot; data-offset-key=&quot;2to9s-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;2to9s-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;“FamilySearch帮助我们的客户寻找他们的祖先，并为他们的家族历史做出贡献。DataStax Enterprise提供的可伸缩的数据平台，正是我们扩大产品范围和持续为客户提供出色的体验所需要的。”&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span data-offset-key=&quot;2to9s-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;——FamilySearch软件开发经理Michael Nelson&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-4992921dde6833002aa3094208d88165_720w.png&quot; width=&quot;395&quot; height=&quot;395&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;445&quot; data-rawheight=&quot;445&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-4992921dde6833002aa3094208d88165.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-60ef808742311663c327a5309671b559.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Sat, 16 Jan 2021 18:31:00 +0000</pubDate>
<dc:creator>DataStax</dc:creator>
<og:description>FamilySearch选择了基于Apache Cassandra的DataStax Enterprise (DSE)来加速用户增长，并通过更快的反应时间、高可用性以及零数据库宕机来提供强大的线上用户</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/datastax/p/14288126.html</dc:identifier>
</item>
<item>
<title>Java并发包源码学习系列：详解Condition条件队列、signal和await - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/14288122.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/14288122.html</guid>
<description>&lt;p&gt;系列传送门：&lt;/p&gt;
&lt;h2 id=&quot;condition接口&quot;&gt;Condition接口&lt;/h2&gt;
&lt;p&gt;Contition是一种广义上的条件队列，它利用await()和signal()为线程提供了一种&lt;strong&gt;更为灵活的等待/通知模式&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;图源：《Java并发编程的艺术》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202101/1771072-20210117022439963-979264559.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Condition必须要配合Lock一起使用，因为对共享状态变量的访问发生在多线程环境下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个Condition的实例必须与一个Lock绑定，因此await和signal的调用必须在lock和unlock之间&lt;/strong&gt;，&lt;strong&gt;有锁之后，才能使用condition&lt;/strong&gt;嘛。以ReentrantLock为例，简单使用如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConditionTest {

    public static void main(String[] args) {
        final ReentrantLock lock = new ReentrantLock();
        final Condition condition = lock.newCondition();

        Thread thread1 = new Thread(() -&amp;gt; {
            String name = Thread.currentThread().getName();

            lock.lock();
            System.out.println(name + &quot; &amp;lt;==成功获取到锁&quot; + lock);
            try {
                System.out.println(name + &quot; &amp;lt;==进入条件队列等待&quot;);
                condition.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(name + &quot; &amp;lt;==醒了&quot;);
            lock.unlock();
            System.out.println(name + &quot; &amp;lt;==释放锁&quot;);
        }, &quot;等待线程&quot;);

        thread1.start();

        Thread thread2 = new Thread(() -&amp;gt; {
            String name = Thread.currentThread().getName();

            lock.lock();
            System.out.println(name + &quot; ==&amp;gt;成功获取到锁&quot; + lock);
            try {
                System.out.println(&quot;========== 这里演示await中的线程没有被signal的时候会一直等着 ===========&quot;);
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(name + &quot; ==&amp;gt;通知等待队列的线程&quot;);
            condition.signal();
            lock.unlock();
            System.out.println(name + &quot; ==&amp;gt;释放锁&quot;);
        }, &quot;通知线程&quot;);

        thread2.start();
    }
}
等待线程 &amp;lt;==成功获取到锁java.util.concurrent.locks.ReentrantLock@3642cea8[Locked by thread 等待线程]
等待线程 &amp;lt;==进入条件队列等待
通知线程 ==&amp;gt;成功获取到锁java.util.concurrent.locks.ReentrantLock@3642cea8[Locked by thread 通知线程]
========== 这里演示await中的线程没有被signal的时候会一直等着 ===========
通知线程 ==&amp;gt;通知等待队列的线程
通知线程 ==&amp;gt;释放锁
等待线程 &amp;lt;==醒了
等待线程  &amp;lt;==释放锁
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们将从源码的角度分析上面这个流程，理解所谓条件队列的内涵。&lt;/p&gt;
&lt;h2 id=&quot;aqs条件变量的支持之conditionobject内部类&quot;&gt;AQS条件变量的支持之ConditionObject内部类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AQS，Lock,Condition，ConditionObject&lt;/code&gt;之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConditionObject是AQS的内部类，实现了Condition接口&lt;/strong&gt;，Lock中提供newCondition()方法，委托给内部AQS的实现Sync来创建ConditionObject对象，享受AQS对Condition的支持。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    // ReentrantLock#newCondition
        public Condition newCondition() {
        return sync.newCondition();
    }
        // Sync#newCondition
    final ConditionObject newCondition() {
        // 返回Contition的实现，定义在AQS中
        return new ConditionObject();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConditionObject用来结合锁实现线程同步，&lt;strong&gt;ConditionObject可以直接访问AQS对象内部的变量，比如state状态值和AQS队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202101/1771072-20210117022449641-1445038832.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConditionObject是条件变量，每个条件变量对应一个&lt;strong&gt;条件队列&lt;/strong&gt;（单向链表队列），其用来存放调用条件变量的await方法后被阻塞的线程，ConditionObject维护了首尾节点，没错这里的Node就是我们之前在学习AQS的时候见到的那个Node，我们会在下面回顾：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConditionObject implements Condition, java.io.Serializable {
    private static final long serialVersionUID = 1173984872572414699L;
    /** 条件队列的第一个节点. */
    private transient Node firstWaiter;
    /** 条件队列的最后一个节点. */
    private transient Node lastWaiter;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里我们需要明确&lt;strong&gt;这里的条件队列和我们之前说的AQS同步队列是不一样&lt;/strong&gt;的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AQS维护的是当前在等待资源的队列，Condition维护的是在等待signal信号的队列。&lt;/li&gt;
&lt;li&gt;每个线程会存在上述两个队列中的一个，lock与unlock对应在AQS队列，signal与await对应条件队列，线程节点在他们之间反复横跳。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里着重说明一下，接下来的源码学习部分，我们会将两个队列进行区分，涉及到同步队列和阻塞队列的描述，意味着是AQS的同步队列，而条件队列指的是Condition队列，望读者知晓。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们针对上面的demo来分析一下会更好理解一些：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为了简化，接下来我将&lt;strong&gt;用D表示等待线程，用T表示通知线程&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;【D】先调用&lt;code&gt;lock.lock()&lt;/code&gt;方法，此时无竞争，【D】被加入到AQS同步队列中。&lt;/li&gt;
&lt;li&gt;【D】调用&lt;code&gt;condition.await()&lt;/code&gt;方法，此时【D】被构建为等待节点并加入到condition对应的条件等待队列中，并从AQS同步队列中移除。&lt;/li&gt;
&lt;li&gt;【D】陷入等待之后，【T】启动，由于AQS队列中的【D】已经被移除，此时【T】也很快获取到锁，相应的，【T】也被加入到AQS同步队列中。&lt;/li&gt;
&lt;li&gt;【T】接着调用&lt;code&gt;condition.signal()&lt;/code&gt;方法，这时condition对应的条件队列中只有一个节点【D】，于是【D】被取出，并被再次加入AQS的等待队列中。此时【D】并没有被唤醒，只是单纯换了个位置。&lt;/li&gt;
&lt;li&gt;接着【T】执行&lt;code&gt;lock.unlock()&lt;/code&gt;，释放锁锁之后，会唤醒AQS队列中的【D】，此时【D】真正被唤醒且执行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;OK，&lt;code&gt;lock -&amp;gt; await -&amp;gt; signal -&amp;gt; unlock&lt;/code&gt;这一套流程相信已经大概能够理解，接下来我们试着看看源码吧。&lt;/p&gt;
&lt;h2 id=&quot;回顾aqs中的node&quot;&gt;回顾AQS中的Node&lt;/h2&gt;
&lt;p&gt;我们这里再简单回顾一下AQS中Node类与Condition相关的字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        // 记录当前线程的等待状态，
        volatile int waitStatus;

        // 前驱节点
        volatile Node prev;

        // 后继节点
        volatile Node next;

        // node存储的线程
        volatile Thread thread;
                
        // 当前节点在Condition中等待队列上的下一个节点
        Node nextWaiter;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;waitStatus可以取五种状态：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化为0，啥也不表示，之后会被置signal。&lt;/li&gt;
&lt;li&gt;1表示cancelled，取消当前线程对锁的争夺。&lt;/li&gt;
&lt;li&gt;-1表示signal，表示当前节点释放锁后需要唤醒后面可被唤醒的节点。&lt;/li&gt;
&lt;li&gt;-2表示condition，我们这篇的重点，&lt;strong&gt;表示当前节点在条件队列中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;-3表示propagate，表示释放共享资源的时候会向后传播释放其他共享节点。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然，除了-2这个condition状态，其他的等待状态我们之前都或多或少分析过，今天着重学习condition这个状态的意义。&lt;/p&gt;
&lt;p&gt;我们还可以看到一个Node类型的nextWaiter，它表示&lt;strong&gt;条件队列中当前节点的下一个节点&lt;/strong&gt;，可以看出用以实现条件队列的单向链表。&lt;/p&gt;
&lt;h2 id=&quot;void-await&quot;&gt;void await()&lt;/h2&gt;
&lt;p&gt;调用Condition的await()方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。&lt;/p&gt;
&lt;p&gt;其实就是从AQS同步队列的首节点，注意不是head，而是获取了锁的节点，移动到Condition的等待队列中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202101/1771072-20210117022458710-77104802.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解这些之后，我们直接来看看具体方法的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        public final void await() throws InterruptedException {
            // 这个方法是响应中断的
            if (Thread.interrupted())
                throw new InterruptedException();
            // 添加到条件队列中
            Node node = addConditionWaiter();
            // 释放同步资源，也就是释放锁
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            // 如果这个节点的线程不在同步队列中，说明该线程还不具备竞争锁的资格
            while (!isOnSyncQueue(node)) {
                // 挂起线程
                LockSupport.park(this);
                // 如果线程中断，退出
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            // 上面的循环退出有两种情况：
            // 1. isOnSyncQueue(node) 为true，即当前的node已经转移到阻塞队列了
            // 2. checkInterruptWhileWaiting != 0, 表示线程中断
            
            // 退出循环，被唤醒之后，进入阻塞队列，等待获取锁 acquireQueued
            if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加到条件队列&quot;&gt;添加到条件队列&lt;/h3&gt;
&lt;h4 id=&quot;node-addconditionwaiter&quot;&gt;Node addConditionWaiter()&lt;/h4&gt;
&lt;p&gt;addConditionWaiter() 是将当前节点加入到条件队列中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        private Node addConditionWaiter() {
            Node t = lastWaiter;
            // 如果lastWaiter被取消了，将其清除
            if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
                // 遍历整个条件队列，将已取消的所有节点清除出列
                unlinkCancelledWaiters();
                        // t重新赋值一下，因为last可能改变了
                t = lastWaiter;
            }
            //注意这里，node在初始化的时候，会指定ws为CONDITION
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
            // t == null 表示队列此时为空，初始化firstWaiter
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;// 入队尾
            lastWaiter = node;// 将尾指针指向新建的node
            return node;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;void-unlinkcancelledwaiters&quot;&gt;void unlinkCancelledWaiters()&lt;/h4&gt;
&lt;p&gt;unlinkCancelledWaiters用于清除队列中已经取消等待的节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        
                private void unlinkCancelledWaiters() {
            Node t = firstWaiter;
            // trail这里表示取消节点的前驱节点
            Node trail = null;
            // t会从头到尾遍历这个单链表
            while (t != null) {
                // next用于保存下一个
                Node next = t.nextWaiter;
                // 如果发现当前这个节点 不是 condition了， 那么考虑移除它
                // 下面是单链表的移除节点操作 简单来说就是 trail.next = t.next
                if (t.waitStatus != Node.CONDITION) {
                    t.nextWaiter = null;
                    // 说明first就是不是condition了
                    if (trail == null)
                        firstWaiter = next;
                    else
                        //trail.next = t.next
                        trail.nextWaiter = next;
                    // trail后面没东西，自然trail就是lastWaiter了
                    if (next == null)
                        lastWaiter = trail;
                }
                // 当前节点是一直跟到不是condition节点的上一个
                else
                    trail = t;
                // 向后遍历 t = t.next
                t = next;
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下addConditionWaiter的过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先判断条件队列的尾节点是否被取消了，这里用last.ws != CONDITION来判断，如果是的话，就需要从头到尾遍历，消除被不是condition的节点。&lt;/li&gt;
&lt;li&gt;接着将当前线程包装为Node，指定ws为CONDITION。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;完全释放独占锁&quot;&gt;完全释放独占锁&lt;/h3&gt;
&lt;p&gt;将节点加入等待队列中后，就需要完全释放线程拥有的独占锁了，&lt;strong&gt;完全释放&lt;/strong&gt;针对重入锁的情况。我们可以拉到await()方法中看看，将会调用：&lt;code&gt;int savedState = fullyRelease(node);&lt;/code&gt;，这句话有什么内涵呢？&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;我们看到这个方法返回了一个savedState变量，简单的理解就是保存状态。我们知道重入锁的state由重入的次数，如果一个state为N，我们可以认为它持有N把锁。&lt;/p&gt;
&lt;p&gt;await()方法必须将state置0，也就是完全释放锁，后面的线程才能获取到这把锁，置0之后，我们需要用个变量标记一下，也就是这里的savedState。&lt;/p&gt;
&lt;p&gt;这样它被重新唤醒的时候，我们就知道，他需要获取savedState把锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;int-fullyreleasenode-node&quot;&gt;int fullyRelease(Node node)&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            // 获取当前的state值，重入次数
            int savedState = getState();
            // 释放N = savedState资源
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            // 如果获取失败，将会将节点设置为取消状态，并抛出异常
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里其实我们就会明白开头说的：如果某个线程没有获取lock，就直接调用condition的await()方法，结果是什么呢，在release的时候抛出异常，然后节点被取消，之后节点进来的时候，将它清理掉。&lt;/p&gt;
&lt;h3 id=&quot;等待进入阻塞队列&quot;&gt;等待进入阻塞队列&lt;/h3&gt;
&lt;p&gt;ok，完全释放锁之后，将会来到这几步，如果这个节点的线程不在同步队列中，说明该线程还不具备竞争锁的资格，将被一直挂起，这里的同步队列指的是AQS的阻塞队列。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;            int interruptMode = 0;
            // 如果这个节点的线程不在同步队列中，说明该线程还不具备竞争锁的资格，会一直挂起
            while (!isOnSyncQueue(node)) {
                // 挂起线程
                LockSupport.park(this);
                // 如果线程中断，退出
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;boolean-isonsyncqueuenode-node&quot;&gt;boolean isOnSyncQueue(Node node)&lt;/h4&gt;
&lt;p&gt;下面这个方法会&lt;strong&gt;判断节点是不是已经到阻塞队列中了，如果是的话，就直接返回true&lt;/strong&gt;，这个方法的必要性是什么呢？&lt;/p&gt;
&lt;p&gt;其实啊，这里需要提前说一下signal()方法，signal的作用和await()方法，将在等待队列中阻塞的节点移动到AQS同步队列中，这个方法就是说判断一下这个节点是不是移过去了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final boolean isOnSyncQueue(Node node) {
        // 1. 节点的等待状态还是condition表示还在等待队列中
        // 2. node.prev == null 表示还没移到阻塞队列中[prev和next都是阻塞队列中用的]

        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
     
        // 如果node已经有了后继节点，表示已经在阻塞队列中了
        if (node.next != null) // If has successor, it must be on queue
            return true;
        /*
         * node.prev can be non-null, but not yet on queue because
         * the CAS to place it on queue can fail. So we have to
         * traverse from tail to make sure it actually made it.  It
         * will always be near the tail in calls to this method, and
         * unless the CAS failed (which is unlikely), it will be
         * there, so we hardly ever traverse much.
         */
        // 来到这里的情况：ws != condition &amp;amp;&amp;amp; node.prev != null &amp;amp;&amp;amp; node.next == null
        
                // 想想：为什么node.prev != null不能作为判断不在阻塞队列的依据呢？
        // CAS首先设置node.prev 指向tail，这个时候node.prev 是不为null的，但CAS可能会失败
        return findNodeFromTail(node);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;为什么node.prev != null不能作为判断不在阻塞队列的依据呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方给出了解答: 因为CAS的入队操作中，首先设置node.prev 指向tail，这个时候node.prev 是不为null的。你能够说他入队成功一定成功吗？不一定，因为CAS可能会失败，所以要findNodeFromTail(node)。&lt;/p&gt;
&lt;h4 id=&quot;boolean-findnodefromtailnode-node&quot;&gt;boolean findNodeFromTail(Node node)&lt;/h4&gt;
&lt;p&gt;从阻塞队列的尾部向前遍历，如果找到这个node，表示它已经在了，那就返回true。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private boolean findNodeFromTail(Node node) {
        Node t = tail;
        for (;;) {
            // 已经有了
            if (t == node)
                return true;
            // 尾都没有，找啥呢，返回false
            if (t == null)
                return false;
            // 一直往前找
            t = t.prev;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;void-signal&quot;&gt;void signal()&lt;/h2&gt;
&lt;p&gt;由于之前节点被加入等待队列将会一直阻塞，为了连贯性，我们来看看唤醒它的signal方法吧：&lt;/p&gt;
&lt;p&gt;之前说到，如果这个线程会在等待队列中等待，那么唤醒它的signal方法的流程是怎么样的呢，前面其实已经说了一丢丢了，我们猜测，signal会将isOnSyncQueue方法的循环打破，接下来看看是不是这样子的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        public final void signal() {
            // 一样的，必须占有当前这个锁才能用signal方法
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                doSignal(first);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202101/1771072-20210117022542645-1961901612.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;唤醒节点&quot;&gt;唤醒节点&lt;/h3&gt;
&lt;p&gt;该方法会从头到尾遍历条件队列，找到需要移到同步队列的节点。&lt;/p&gt;
&lt;h4 id=&quot;void-dosignalnode-first&quot;&gt;void doSignal(Node first)&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        private void doSignal(Node first) {
            do {
                // firstWaiter 指向first的下一个
                if ( (firstWaiter = first.nextWaiter) == null)
                    // 如果first是最后一个且要被移除了，就将last置null
                    lastWaiter = null;
                // first断绝与条件队列的连接
                first.nextWaiter = null;
                // fisrt转移失败，就看看后面是不是需要的
            } while (!transferForSignal(first) &amp;amp;&amp;amp;
                     (first = firstWaiter) != null);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的while循环表示，如果first没有转移成功，就接着判断first后面的节点是不是需要转移。&lt;/p&gt;
&lt;h4 id=&quot;boolean-transferforsignalnode-node&quot;&gt;boolean transferForSignal(Node node)&lt;/h4&gt;
&lt;p&gt;该方法将节点从条件队列转移到阻塞队列。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final boolean transferForSignal(Node node) {
        /*
         * CAS操作尝试将Condition的节点的ws改为0
         * 如果失败，意味着：节点的ws已经不是CONDITION，说明节点已经被取消了
         * 如果成功，则该节点的状态ws被改为0了
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        /*
         * 通过enq方法将node自旋的方式加入同步队列队尾
         * 这里放回的p是node在同步队列的前驱节点
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        // ws大于0 的情况只有 cancenlled，表示node的前驱节点取消了争取锁，那直接唤醒node线程
        // ws &amp;lt;= 0 会使用cas操作将前驱节点的ws置为signal，如果cas失败也会唤醒node
        if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }
        // 自旋的方式入队
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    // 返回的是node的前驱节点
                    return t;
                }
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;检查中断状态&quot;&gt;检查中断状态&lt;/h3&gt;
&lt;p&gt;ok，一旦signal之后，节点被成功转移到同步队列后，这时下面这个循环就会退出了，继续回到这里：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;            int interruptMode = 0;
            // 如果这个节点的线程不在同步队列中，说明该线程还不具备竞争锁的资格，会一直挂起
            while (!isOnSyncQueue(node)) {
                // 挂起线程
                LockSupport.park(this);
                // 如果线程中断，退出
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;interruptMode可以有以下几种取值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        /** await 返回的时候，需要重新设置中断状态 */
        private static final int REINTERRUPT =  1;
        /** await 返回的时候，需要抛出 InterruptedException 异常 */
        private static final int THROW_IE    = -1;
                
                /** interruptMode取0的时候表示在await()期间，没有发生中断 */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说到这里我们需要明白，&lt;code&gt;LockSupport.park(this)&lt;/code&gt;挂起的线程是什么时候唤醒的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;signal方法将节点转移到同步队列中，且获取到了锁或者对前驱节点的cas操作失败，调用了&lt;code&gt;LockSupport.unpark(node.thread);&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;在park的时候，另外一个线程对挂起的线程进行了中断。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;唤醒之后，我们可以看到调用checkInterruptWhileWaiting方法检查等待期间是否发生了中断，如果不为0表示确实在等待期间发生了中断。&lt;/p&gt;
&lt;p&gt;但其实这个方法的返回结果用interruptMode变量接收，拥有更加丰富的内涵，它还能够判断中断的时机是否在signal之前。&lt;/p&gt;
&lt;h4 id=&quot;int-checkinterruptwhilewaitingnode-node&quot;&gt;int checkInterruptWhileWaiting(Node node)&lt;/h4&gt;
&lt;p&gt;该方法用于判断该线程是否在挂起期间发生了中断。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        private int checkInterruptWhileWaiting(Node node) {
            return Thread.interrupted() ?// 如果处于中断状态，返回true，且将重置中断状态
                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :// 如果中断了，判断何时中断
                0; // 没有中断， 返回0
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;boolean-transferaftercancelledwaitnode-node&quot;&gt;boolean transferAfterCancelledWait(Node node)&lt;/h4&gt;
&lt;p&gt;该方法判断何时中断，是否在signal之前。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final boolean transferAfterCancelledWait(Node node) {
        // 尝试使用CAS操作将node 的ws设置为0
        // 如果成功，说明在signal方法之前中断就已经发生：
        // 原因在于：signal如果在此之前发生，必然已经cas操作将ws设置为0了，这里不可能设置成功
        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
            // 就算中断了，也将节点入队
            enq(node);
            return true;
        }
        /*
         * If we lost out to a signal(), then we can't proceed
         * until it finishes its enq().  Cancelling during an
         * incomplete transfer is both rare and transient, so just
         * spin.
         * 这里就是signal之后发生的中断
         * 但是signal可能还在进行转移中，这边自旋等一下它完成
         */
        while (!isOnSyncQueue(node))
            Thread.yield();
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的话，我们还是稍微总结一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;await()中的节点中断之后，被唤醒有多种情况：
&lt;ul&gt;&lt;li&gt;无中断的情况：signal方法成功将节点移入同步队列且节点成功获取资源，唤醒该线程，此时退出的时候interruptMode为0。&lt;/li&gt;
&lt;li&gt;有中断的情况：
&lt;ul&gt;&lt;li&gt;signal之前中断，interruptMode设置为THROW_IE。&lt;/li&gt;
&lt;li&gt;signal之后中断，interruptMode设置为REINTERRUPT。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中断时，无论signal之前或之后，节点无论如何都会进入阻塞队列。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;处理中断状态&quot;&gt;处理中断状态&lt;/h3&gt;
&lt;p&gt;接下来三个部分我将一一说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;            // 第一部分
                        if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
                        // 第二部分
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters(); // 清除取消的节点
                        // 第三部分
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第一部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;signal唤醒的线程并不会立即获取到资源，从while循环退出后，会通过acquireQueued方法加入获取同步状态的竞争中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;            // 第一部分
                        if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;acquireQueued(node, savedState)&lt;/code&gt;中node此时已经被加入同步队列了，savedState是之前存储的state。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted; // 
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;acquireQueued方法返回时，表示已经获取到了锁，且返回的是interrupted值，如果返回true，表示已经被中断。&lt;/p&gt;
&lt;p&gt;接着判断&lt;code&gt;interruptMode != THROW_IE&lt;/code&gt;表示是在signal之后发生的中断，需要重新中断当前线程，将interruptMode设置为REINTERRUPT。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二部分&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                       // 第二部分
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters(); // 清除取消的节点
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面说了，signal会将节点移到同步队列中，最后一步需要和条件队列断开关系，也就是：&lt;code&gt;node.nextWaiter = null&lt;/code&gt;，但这是想象中比较正常的情况，如果在signal之前被中断，节点也会被加入同步队列中，这时其实是没有调用这个断开关系的。&lt;/p&gt;
&lt;p&gt;因此这边做一点处理， &lt;code&gt;unlinkCancelledWaiters()&lt;/code&gt;逻辑上面也说过了，可以回过头去看看，主要是清除队列中已经取消等待的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后一个部分，就是对两种interruptMode的情况进行处理，看看代码就知道了：&lt;/p&gt;
&lt;h4 id=&quot;void-reportinterruptafterwaitinterruptmode&quot;&gt;void reportInterruptAfterWait(interruptMode)&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        private void reportInterruptAfterWait(int interruptMode)
            throws InterruptedException {
            // signal 之前的中断， 需要抛出异常
            if (interruptMode == THROW_IE)
                throw new InterruptedException();
            // signal 之后发生的中断， 需要重新中断
            else if (interruptMode == REINTERRUPT)
                selfInterrupt();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;带超机制的void-await&quot;&gt;带超机制的void await()&lt;/h2&gt;
&lt;p&gt;带超时机制的await()方法有以下几个，简单看下即可：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;long awaitNanos(long nanosTimeout)&lt;/li&gt;
&lt;li&gt;boolean awaitUntil(Date deadline)&lt;/li&gt;
&lt;li&gt;boolean await(long time, TimeUnit unit)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们选最后一个来看看，主要看看和之前await()方法不一样的地方：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        public final boolean await(long time, TimeUnit unit)
                throws InterruptedException {
            // 计算等待的时间
            long nanosTimeout = unit.toNanos(time);
            if (Thread.interrupted())
                throw new InterruptedException();
            Node node = addConditionWaiter();
            int savedState = fullyRelease(node);
            // 截止时间
            final long deadline = System.nanoTime() + nanosTimeout;
            // 表示是否超时
            boolean timedout = false;
            int interruptMode = 0;
            while (!isOnSyncQueue(node)) {
                // 等待时间到了
                if (nanosTimeout &amp;lt;= 0L) {
                    // 这个方法返回true表示在这个方法内，已经将节点转移到阻塞队列中
                    // 返回false，表示signal已经发生，表示没有超时
                    timedout = transferAfterCancelledWait(node);
                    break;
                }
                //spinForTimeoutThreshold 是AQS中的一个字段，如果超过1ms，使用parkNonos
                if (nanosTimeout &amp;gt;= spinForTimeoutThreshold)
                    LockSupport.parkNanos(this, nanosTimeout);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
                // 更新一下还需要等待多久
                nanosTimeout = deadline - System.nanoTime();
            }
            if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null)
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
            return !timedout;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;不抛出interruptedexception的await&quot;&gt;不抛出InterruptedException的await&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        public final void awaitUninterruptibly() {
            Node node = addConditionWaiter();
            int savedState = fullyRelease(node);
            boolean interrupted = false;
            while (!isOnSyncQueue(node)) {
                LockSupport.park(this);
                if (Thread.interrupted())
                    interrupted = true;
            }
            // 相比await() 针对中断少了抛出异常的操作，而是直接进行中断
            if (acquireQueued(node, savedState) || interrupted)
                selfInterrupt();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;condition的使用&quot;&gt;Condition的使用&lt;/h2&gt;
&lt;p&gt;最后以一个Java doc给的例子结尾吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class BoundedBuffer {
    final Lock lock = new ReentrantLock();
    // condition 依赖于 lock 来产生
    final Condition notFull = lock.newCondition();
    final Condition notEmpty = lock.newCondition();

    final Object[] items = new Object[100];
    int putptr, takeptr, count;

    // 生产
    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                notFull.await();  // 队列已满，等待，直到 not full 才能继续生产
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal(); // 生产成功，队列已经 not empty 了，发个通知出去
        } finally {
            lock.unlock();
        }
    }

    // 消费
    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await(); // 队列为空，等待，直到队列 not empty，才能继续消费
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal(); // 被我消费掉一个，队列 not full 了，发个通知出去
            return x;
        } finally {
            lock.unlock();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实这个之前也说过，ArrayBlockingQueue就是采用了这种方式实现的生产者-消费者模式，如果你感兴趣，可以看看具体的实现细节哦。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Condition的await()和signal()基于Lock，相比于基于Object的wait()和notify()方法，它提供更加灵活的等待通知的机制。&lt;/li&gt;
&lt;li&gt;支持丰富的功能如：带超时机制的await()，不响应中断的await()，以及多个等待的条件队列。&lt;/li&gt;
&lt;li&gt;Condition的await()方法会&lt;strong&gt;将线程包装为等待节点，加入等待队列中，并将AQS同步队列中的节点移除&lt;/strong&gt;，接着不断检查&lt;code&gt;isOnSyncQueue(Node node)&lt;/code&gt;，如果在等待队列中，就一直等着，如果signal将它移到AQS队列中，则退出循环。&lt;/li&gt;
&lt;li&gt;Condition的signal()方法则是先检查当前线程是否获取了锁，接着将等待队列中的节点通过Node的操作&lt;strong&gt;直接&lt;/strong&gt;加入AQS队列。线程并不会立即获取到资源，从while循环退出后，会通过acquireQueued方法加入获取同步状态的竞争中。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;
</description>
<pubDate>Sat, 16 Jan 2021 18:27:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>系列传送门： Java并发包源码学习系列：AbstractQueuedSynchronizer Java并发包源码学习系列：CLH同步队列及同步资源获取与释放 Java并发包源码学习系列：AQS共享式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/14288122.html</dc:identifier>
</item>
<item>
<title>RecyclerView 源码分析（一） —— 绘制流程解析 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/14252980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/14252980.html</guid>
<description>&lt;p&gt;对于 RecyclerView 是那么熟悉又那么陌生。熟悉是因为作为一名 Android 开发者，RecyclerView 是经常会在项目里面用到的，陌生是因为只是知道怎么用，但是却不知道 RecyclerView 的内部实现机制。&lt;/p&gt;
&lt;p&gt;但凡是一位有所追求的开发者，都不会只让自己停留在只会使用上，而是会研读相关源码，知其然知其所以然。&lt;/p&gt;
&lt;p&gt;对于 RecyclerView 的源码解析一篇文章肯定是不够的，后续有时间会继续更新。每一篇都会有自己的主题。RecyclerView 的使用，本文也就不讲了，具体可以查看之前的文章：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/huansky/p/7327229.html&quot;&gt;RecyclerView 使用指南&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于用过 RecyclerView 的开发者来说，这个 View 的功能确实强大，可以在日常开发的很多场景都可以使用。在讲解 RecyclerView 绘制源码的时候，我希望大家去思考一些问题：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;如果是你，你会怎么来设计 RecyclerView 的绘制过程，和普通的 View 一样？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;RecyclerView 可以支持不同的流式布局，一列，多列，所以里面的绘制逻辑它是如何设计的？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;分割线是可以定制的，那我要如何设计这块的代码？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实也还有其他的问题，但是本文只讲绘制流程，因此，其他问题就在其他模块去思考。要是在以前呢，我也是为了分析源码而分析源码，然后把文章发出去。很少去思考源码背后的一些东西。直到最近自己需要去重构一个模块的时候，发现设计一个技术方案是多么的难。&lt;/p&gt;
&lt;p&gt;本文源码版本：androidx.recyclerView:1.1.0 &lt;/p&gt;

&lt;p&gt;对于 view 来说，必有的三大流程：测量，布局，绘制。因此 RecyclerView 也是一样。如果你现在还是对 View 的绘制流程，不了解可以推荐看文章：&lt;/p&gt;
&lt;p&gt; 下面进入正题，首先来看下 RecyclerView 类的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RecyclerView &lt;span&gt;extends&lt;/span&gt; ViewGroup &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ScrollingView,
        NestedScrollingChild2, NestedScrollingChild3 {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ......  &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到 RecyclerView 是一个 ViewGroup，也就是说，RecyclerView 本质是一个自定义 view，需要自己去管理绘制流程。对于了解自定义 View 来说，其实就是需要重写 onMeasure 方法。&lt;/p&gt;
&lt;p&gt;在 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/huansky/p/11808234.html&quot;&gt;Android 自定义 View 详解&lt;/a&gt; 一文中总结了 onMeausre 的具体逻辑，到这里，依然可以做个参考：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;super.onMeasure 会先计算自定义 view 的大小；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用 measureChild 对子 View 进行测量；&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;自定义 view 设置的宽高参数不是 MeasureSpec.EXACTLY 的话，对于子 View 是 match_parent 需要额外处理，同时也需要对 MeasureSpec.AT_MOST 情况进行额外处理。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt; 当自定义View 的大小确定后，在对子 View 是 match_parent 重新测量；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面来看下 RecyclerView 的 onMeausre 代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightSpec) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mLayout == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一种情况&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mLayout.isAutoMeasureEnabled()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二种情况&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三种情况&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;30&quot;&gt;
&lt;p&gt;&lt;code&gt;onMeasure&lt;/code&gt;方法还是有点长，这里我将它分为3种情况，我将简单解释这三种情况：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;mLayout &lt;/code&gt;即 &lt;code&gt;LayoutManager &lt;/code&gt;的对象。我们知道，当 &lt;code&gt;RecyclerView &lt;/code&gt;的 &lt;code&gt;LayoutManager &lt;/code&gt;为空时，&lt;code&gt;RecyclerView &lt;/code&gt;不能显示任何的数据，在这里我们找到答案。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;LayoutManager &lt;/code&gt;开启了自动测量时，这是一种情况。在这种情况下，有可能会测量两次。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;第三种情况就是没有开启自动测量的情况，这种情况比较少，因为 &lt;code&gt;RecyclerView 为了&lt;/code&gt;支持 &lt;code&gt;warp_content &lt;/code&gt;属性，系统提供的 &lt;code&gt;LayoutManager &lt;/code&gt;都开启自动测量的，不过还是要分析的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先我们来第一种情况。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;1、LayoutManager == null&lt;/h2&gt;
&lt;p&gt;这种情况下比较简单，我们来看看源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;if&lt;/span&gt; (mLayout == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            defaultOnMeasure(widthSpec, heightSpec);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是调用了 defaultOnMeasure 方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt; defaultOnMeasure(&lt;span&gt;int&lt;/span&gt; widthSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightSpec) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; calling LayoutManager here is not pretty but that API is already public and it is better
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; than creating another method since this is internal.&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; width =&lt;span&gt; LayoutManager.chooseSize(widthSpec,
                getPaddingLeft() &lt;/span&gt;+&lt;span&gt; getPaddingRight(),
                ViewCompat.getMinimumWidth(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; LayoutManager.chooseSize(heightSpec,
                getPaddingTop() &lt;/span&gt;+&lt;span&gt; getPaddingBottom(),
                ViewCompat.getMinimumHeight(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));

        setMeasuredDimension(width, height);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;code&gt;defaultOnMeasure &lt;/code&gt;方法里面，主要是通过 &lt;code&gt;LayoutManager &lt;/code&gt;的 &lt;code&gt;chooseSize &lt;/code&gt;方法来计算宽高，最后调用 &lt;code&gt;setMeasuredDimension &lt;/code&gt;方法来设置宽高。下面来看下 chooseSize 的具体逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; chooseSize(&lt;span&gt;int&lt;/span&gt; spec, &lt;span&gt;int&lt;/span&gt; desired, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; min) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mode =&lt;span&gt; View.MeasureSpec.getMode(spec);
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; View.MeasureSpec.getSize(spec);
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (mode) {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; View.MeasureSpec.EXACTLY:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; View.MeasureSpec.AT_MOST:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.min(size, Math.max(desired, min));
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; View.MeasureSpec.UNSPECIFIED:
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.max(desired, min);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里主要是根据不同的设置，来返回最终的大小。这块逻辑不是很懂的读者可以阅读前面提到的文章，里面详细解读了。但是这里有个问题需要指出来的就是没有测量子 view 的大小，这也是白屏的原因。因为 RecyclerView 的绘制其实是委托给 LayoutManager 来管理呢，LayoutManager = null 的情况下测量子 view 没有任何的意义。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、&lt;/span&gt;LayoutManager 开启了自动测量&lt;/h2&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;在分析这种情况之前，我们先对了解几个东西。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;code&gt;RecyclerView &lt;/code&gt;的测量分为两步，分别调用 &lt;code&gt;dispatchLayoutStep1 &lt;/code&gt;和 &lt;code&gt;dispatchLayoutStep2&lt;/code&gt;。同时，了解过 &lt;code&gt;RecyclerView &lt;/code&gt;源码的同学应该知道在 &lt;code&gt;RecyclerView &lt;/code&gt;的源码里面还一个&lt;code&gt;dispatchLayoutStep3 &lt;/code&gt;方法。这三个方法的方法名比较接近，所以容易让人搞混淆。本文会详细的讲解这三个方法的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  由于在这种情况下，只会调用 &lt;code&gt;dispatchLayoutStep1 &lt;/code&gt;和 &lt;code&gt;dispatchLayoutStep2 &lt;/code&gt;这两个方法，所以这里会重点的讲解这两个方法。而 &lt;code&gt;dispatchLayoutStep3 &lt;/code&gt;方法的调用在&lt;code&gt;RecyclerView &lt;/code&gt;的 &lt;code&gt;onLayout &lt;/code&gt;方法里面，所以在后面分析 &lt;code&gt;onLayout &lt;/code&gt;方法时再来看 &lt;code&gt;dispatchLayoutStep3 &lt;/code&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  我们在分析之前，先来看一个东西 —— &lt;code&gt;mState.mLayoutStep&lt;/code&gt;。这个变量有几个取值情况。我们分别来看看：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;取值&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;State.STEP_START&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;mState.mLayoutStep &lt;/code&gt;的默认值，这种情况下，表示 RecyclerView 还未经历 &lt;code&gt;dispatchLayoutStep1&lt;/code&gt;，因为 &lt;code&gt;dispatchLayoutStep1 &lt;/code&gt;调用之后&lt;code&gt;mState.mLayoutStep &lt;/code&gt;会变为 &lt;code&gt;State.STEP_LAYOUT&lt;/code&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;State.STEP_LAYOUT&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;当 &lt;code&gt;mState.mLayoutStep &lt;/code&gt;为 &lt;code&gt;State.STEP_LAYOUT &lt;/code&gt;时，表示此时处于 layout 阶段，这个阶段会调用 &lt;code&gt;dispatchLayoutStep2 &lt;/code&gt;方法 &lt;code&gt;layout&lt;/code&gt; &lt;code&gt;RecyclerView &lt;/code&gt;的&lt;code&gt;children&lt;/code&gt;。调用 &lt;code&gt;dispatchLayoutStep2 &lt;/code&gt;方法之后，此时 &lt;code&gt;mState.mLayoutStep &lt;/code&gt;变为了 &lt;code&gt;State.STEP_ANIMATIONS&lt;/code&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;State.STEP_ANIMATIONS&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;当 &lt;code&gt;mState.mLayoutStep&lt;/code&gt;为 &lt;code&gt;State.STEP_ANIMATIONS &lt;/code&gt;时，表示 &lt;code&gt;RecyclerView &lt;/code&gt;处于第三个阶段，也就是执行动画的阶段，也就是调用 &lt;code&gt;dispatchLayoutStep3&lt;/code&gt;方法。当 &lt;code&gt;dispatchLayoutStep3 &lt;/code&gt;方法执行完毕之后，&lt;code&gt;mState.mLayoutStep &lt;/code&gt;又变为了 &lt;code&gt;State.STEP_START&lt;/code&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从上表中，我们了解到 &lt;code&gt;mState.mLayoutStep &lt;/code&gt;的三个状态对应着不同的 &lt;code&gt;dispatchLayoutStep &lt;/code&gt;方法。这一点，我们必须清楚，否则接下来的代码将难以理解。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mLayout.isAutoMeasureEnabled()) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; widthMode =&lt;span&gt; MeasureSpec.getMode(widthSpec);
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; heightMode =&lt;span&gt; MeasureSpec.getMode(heightSpec);

            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * This specific call should be considered deprecated and replaced with
             * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #defaultOnMeasure(int, int)}. It can't actually be replaced as it could
             * break existing third party code but all documentation directs developers to not
             * override {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; LayoutManager#onMeasure(int, int)} when
             * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; LayoutManager#isAutoMeasureEnabled()} returns true.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);

            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; measureSpecModeIsExactly =&lt;span&gt;
                    widthMode &lt;/span&gt;== MeasureSpec.EXACTLY &amp;amp;&amp;amp; heightMode ==&lt;span&gt; MeasureSpec.EXACTLY;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (measureSpecModeIsExactly || mAdapter == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
&lt;span&gt;　　　　　　　// 开始测量
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mState.mLayoutStep ==&lt;span&gt; State.STEP_START) {
                dispatchLayoutStep1();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set dimensions in 2nd step. Pre-layout should happen with old dimensions for
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; consistency&lt;/span&gt;
&lt;span&gt;            mLayout.setMeasureSpecs(widthSpec, heightSpec);
            mState.mIsMeasuring &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;span&gt;　　　　　　　// 第二次
&lt;/span&gt;            dispatchLayoutStep2();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; now we can get the width and height from the children.&lt;/span&gt;
&lt;span&gt;            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if RecyclerView has non-exact width and height and if there is at least one child
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; which also has non-exact width &amp;amp; height, we have to re-measure.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mLayout.shouldMeasureTwice()) {
                mLayout.setMeasureSpecs(
                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
                mState.mIsMeasuring &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                dispatchLayoutStep2();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; now we can get the width and height from the children.&lt;/span&gt;
&lt;span&gt;                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 首先，我们来看看 &lt;code&gt;onMeasure &lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(@NonNull Recycler recycler, @NonNull State state, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; widthSpec,
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightSpec) {
            mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;发现调用的 &lt;code&gt;RecyclerView &lt;/code&gt;的 &lt;code&gt;defaultOnMeasure &lt;/code&gt;方法，其实就是前面我们介绍过的自定义 View 的三个步骤：先是测量自己本身的大小。&lt;/p&gt;
&lt;h3&gt;dispatchLayoutStep1&lt;/h3&gt;
&lt;p&gt;咱们再接着往下走，看看 dispatchLayoutStep1() 方法的具体逻辑：&lt;/p&gt;
&lt;div readability=&quot;30.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The first step of a layout where we;
     * - process adapter updates
     * - decide which animation should run
     * - save information about current views
     * - If necessary, run predictive layout and save its information
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispatchLayoutStep1() {&lt;br/&gt;&lt;span&gt;　　　　　// 这里还用到了断言
&lt;/span&gt;        mState.assertLayoutStep(State.STEP_START);
        fillRemainingScrollValues(mState);
        mState.mIsMeasuring &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        startInterceptRequestLayout();
        mViewInfoStore.clear();
        onEnterLayoutOrScroll();&lt;br/&gt;&lt;span&gt;　　　　　// 处理 adapter 更新
&lt;/span&gt;        processAdapterUpdatesAndSetAnimationFlags();
        saveFocusInfo();
        mState.mTrackOldChangeHolders &lt;/span&gt;= mState.mRunSimpleAnimations &amp;amp;&amp;amp;&lt;span&gt; mItemsChanged;
        mItemsAddedOrRemoved &lt;/span&gt;= mItemsChanged = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        mState.mInPreLayout &lt;/span&gt;=&lt;span&gt; mState.mRunPredictiveAnimations;
        mState.mItemCount &lt;/span&gt;=&lt;span&gt; mAdapter.getItemCount();
        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);
&lt;span&gt;　　　　　// 是否要运行动画
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mState.mRunSimpleAnimations) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Step 0: Find out where all non-removed items are, pre-layout&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; mChildHelper.getChildCount();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; ++&lt;span&gt;i) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ViewHolder holder =&lt;span&gt; getChildViewHolderInt(mChildHelper.getChildAt(i));
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder.shouldIgnore() || (holder.isInvalid() &amp;amp;&amp;amp; !&lt;span&gt;mAdapter.hasStableIds())) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ItemHolderInfo animationInfo =&lt;span&gt; mItemAnimator
                        .recordPreLayoutInformation(mState, holder,
                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),
                                holder.getUnmodifiedPayloads());
                mViewInfoStore.addToPreLayout(holder, animationInfo);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mState.mTrackOldChangeHolders &amp;amp;&amp;amp; holder.isUpdated() &amp;amp;&amp;amp; !&lt;span&gt;holder.isRemoved()
                        &lt;/span&gt;&amp;amp;&amp;amp; !holder.shouldIgnore() &amp;amp;&amp;amp; !&lt;span&gt;holder.isInvalid()) {
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; key =&lt;span&gt; getChangedHolderKey(holder);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is NOT the only place where a ViewHolder is added to old change holders
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; list. There is another case where:
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    * A VH is currently hidden but not deleted
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    * The hidden item is changed in the adapter
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    * Layout manager decides to layout the item in the pre-Layout pass (step1)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; When this case is detected, RV will un-hide that view and add to the old
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; change holders list.&lt;/span&gt;
&lt;span&gt;                    mViewInfoStore.addToOldChangeHolders(key, holder);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mState.mRunPredictiveAnimations) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Step 1: run prelayout: This will use the old positions of items. The layout manager
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is expected to layout everything, even removed items (though not to add removed
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; items back to the container). This gives the pre-layout position of APPEARING views
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; which come into existence as part of the real layout.

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Save old positions so that LayoutManager can run its mapping logic.&lt;/span&gt;
&lt;span&gt;            saveOldPositions();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; didStructureChange =&lt;span&gt; mState.mStructureChanged;
            mState.mStructureChanged &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; temporarily disable flag because we are asking for previous layout&lt;/span&gt;
&lt;span&gt;            mLayout.onLayoutChildren(mRecycler, mState);
            mState.mStructureChanged &lt;/span&gt;=&lt;span&gt; didStructureChange;

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; mChildHelper.getChildCount(); ++&lt;span&gt;i) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; View child =&lt;span&gt; mChildHelper.getChildAt(i);
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ViewHolder viewHolder =&lt;span&gt; getChildViewHolderInt(child);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (viewHolder.shouldIgnore()) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mViewInfoStore.isInPreLayout(viewHolder)) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; flags =&lt;span&gt; ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);
                    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; wasHidden =&lt;span&gt; viewHolder
                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;wasHidden) {
                        flags &lt;/span&gt;|=&lt;span&gt; ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;
                    }
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ItemHolderInfo animationInfo =&lt;span&gt; mItemAnimator.recordPreLayoutInformation(
                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (wasHidden) {
                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we don't process disappearing list because they may re-appear in post layout pass.&lt;/span&gt;
&lt;span&gt;            clearOldPositions();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            clearOldPositions();
        }
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;&lt;span&gt;　　　　　// 上面的执行完以后，改变状态
&lt;/span&gt;        mState.mLayoutStep &lt;/span&gt;=&lt;span&gt; State.STEP_LAYOUT;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 其实最上面的方法注释，已经把这个方法所做的事情都总结好了，该方法主要工作如下：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;处理 &lt;code&gt;Adapter &lt;/code&gt;更新;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;决定执行哪一种动画&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;保存每个 &lt;code&gt;ItemView &lt;/code&gt;的信息&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;有必要的话，会进行预布局，并把相关信息保存下来。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;可以看到整个方法内部调用的方法还是很多，导致你会觉得这个方法的逻辑很复杂。不过既然是源码阅读，咱们只关注一些重要的点，在众多被调用的方法中 &lt;/span&gt;processAdapterUpdatesAndSetAnimationFlags 是需要点进去看看里面的逻辑的，后续的 if else 逻辑其实都是在该方法里面决定的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Consumes adapter updates and calculates which type of animations we want to run.
     * Called in onMeasure and dispatchLayout.
     * &amp;lt;p&amp;gt;
     * This method may process only the pre-layout state of updates or all of them.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processAdapterUpdatesAndSetAnimationFlags() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mDataSetHasChangedAfterLayout) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Processing these items have no value since data set changed unexpectedly.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instead, we just reset it.&lt;/span&gt;
&lt;span&gt;            mAdapterHelper.reset();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mDispatchItemsChangedEvent) {
                mLayout.onItemsChanged(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; simple animations are a subset of advanced animations (which will cause a
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre-layout step)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If layout supports predictive animations, pre-process to decide if we want to run them&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (predictiveItemAnimationsEnabled()) {
            mAdapterHelper.preProcess();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            mAdapterHelper.consumeUpdatesInOnePass();
        }
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; animationTypeSupported = mItemsAddedOrRemoved ||&lt;span&gt; mItemsChanged;
        mState.mRunSimpleAnimations &lt;/span&gt;=&lt;span&gt; mFirstLayoutComplete
                &lt;/span&gt;&amp;amp;&amp;amp; mItemAnimator != &lt;span&gt;null&lt;/span&gt;
                &amp;amp;&amp;amp;&lt;span&gt; (mDataSetHasChangedAfterLayout
                &lt;/span&gt;||&lt;span&gt; animationTypeSupported
                &lt;/span&gt;||&lt;span&gt; mLayout.mRequestedSimpleAnimations)
                &lt;/span&gt;&amp;amp;&amp;amp; (!&lt;span&gt;mDataSetHasChangedAfterLayout
                &lt;/span&gt;||&lt;span&gt; mAdapter.hasStableIds());
        mState.mRunPredictiveAnimations &lt;/span&gt;=&lt;span&gt; mState.mRunSimpleAnimations
                &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; animationTypeSupported
                &lt;/span&gt;&amp;amp;&amp;amp; !&lt;span&gt;mDataSetHasChangedAfterLayout
                &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; predictiveItemAnimationsEnabled();
    }&lt;/span&gt;&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;18.5&quot;&gt;
&lt;p&gt;这里我们的重心放在 &lt;code&gt;mFirstLayoutComplete &lt;/code&gt;变量里面，我们发现 &lt;code&gt;mRunSimpleAnimations &lt;/code&gt;的值与&lt;code&gt;mFirstLayoutComplete&lt;/code&gt;有关，&lt;code&gt;mRunPredictiveAnimations&lt;/code&gt;同时跟&lt;code&gt;mRunSimpleAnimations&lt;/code&gt;有关。所以这里我们可以得出一个结论，当&lt;code&gt;RecyclerView&lt;/code&gt;第一次加载数据时，是不会执行的动画？那到底会不会呢，这里先卖个关子。&lt;/p&gt;
&lt;p&gt;
&lt;h3&gt;&lt;span&gt;dispatchLayoutStep2&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;p&gt;接下来我们看看 &lt;code&gt;dispatchLayoutStep2 &lt;/code&gt;方法，这个方法是真正布局 &lt;code&gt;children&lt;/code&gt;。上代码：&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The second layout step where we do the actual layout of the views for the final state.
     * This step might be run multiple times if necessary (e.g. measure).
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispatchLayoutStep2() {
        startInterceptRequestLayout();
        onEnterLayoutOrScroll();
        mState.assertLayoutStep(State.STEP_LAYOUT &lt;/span&gt;|&lt;span&gt; State.STEP_ANIMATIONS);
        mAdapterHelper.consumeUpdatesInOnePass();
        mState.mItemCount &lt;/span&gt;=&lt;span&gt; mAdapter.getItemCount();
        mState.mDeletedInvisibleItemCountSincePreviousLayout &lt;/span&gt;= 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Step 2: Run layout&lt;/span&gt;
        mState.mInPreLayout = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        mLayout.onLayoutChildren(mRecycler, mState);

        mState.mStructureChanged &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        mPendingSavedState &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; onLayoutChildren may have caused client code to disable item animations; re-check&lt;/span&gt;
        mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;amp;&amp;amp; mItemAnimator != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        mState.mLayoutStep &lt;/span&gt;=&lt;span&gt; State.STEP_ANIMATIONS;
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到的是，这里的逻辑似乎简单很多，那是因为这里把对子 view 的绘制逻辑放到 LayoutManager 中去了。到这里，state 的状态已经改变了，变成了 State.STEP_LAYOUT | State.STEP_ANIMATIONS。&lt;/p&gt;
&lt;div readability=&quot;21.5&quot;&gt;
&lt;p&gt;系统的 &lt;code&gt;LayoutManager &lt;/code&gt;的 &lt;code&gt;onLayoutChildren &lt;/code&gt;方法是一个空方法，所以需要 &lt;code&gt;LayoutManager &lt;/code&gt;的子类自己来实现。&lt;/p&gt;
&lt;p&gt;这里先不做过多介绍，不同的 LayoutManager 有不同的实现。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;3、没有开启自动测量&lt;/h2&gt;
&lt;p&gt;还是先来看看这一块的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mHasFixedSize) {
                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; custom onMeasure&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mAdapterUpdateDuringMeasure) {
                startInterceptRequestLayout();
                onEnterLayoutOrScroll();
                processAdapterUpdatesAndSetAnimationFlags();
                onExitLayoutOrScroll();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mState.mRunPredictiveAnimations) {
                    mState.mInPreLayout &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; consume remaining updates to provide a consistent state with the layout pass.&lt;/span&gt;
&lt;span&gt;                    mAdapterHelper.consumeUpdatesInOnePass();
                    mState.mInPreLayout &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                mAdapterUpdateDuringMeasure &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                stopInterceptRequestLayout(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mState.mRunPredictiveAnimations) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this means there is already an onMeasure() call performed to handle the pending
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; because getViewForPosition() will crash when LM uses a child to measure.&lt;/span&gt;
&lt;span&gt;                setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mAdapter != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                mState.mItemCount &lt;/span&gt;=&lt;span&gt; mAdapter.getItemCount();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                mState.mItemCount &lt;/span&gt;= 0&lt;span&gt;;
            }
            startInterceptRequestLayout();
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);
            stopInterceptRequestLayout(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            mState.mInPreLayout &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clear&lt;/span&gt;
        } 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里主要做了两件事，其实跟第二个步骤很像，最终都会调用 &lt;code&gt;LayoutManager &lt;/code&gt;的 &lt;code&gt;onMeasure &lt;/code&gt;方法来进行测量。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;32.5&quot;&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果&lt;code&gt;mHasFixedSize&lt;/code&gt;为true(也就是调用了&lt;code&gt;setHasFixedSize&lt;/code&gt;方法)，将直接调用&lt;code&gt;LayoutManager&lt;/code&gt;的&lt;code&gt;onMeasure&lt;/code&gt;方法进行测量。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果&lt;code&gt;mHasFixedSize&lt;/code&gt;为false，同时此时如果有数据更新，先处理数据更新的事务，然后调用&lt;code&gt;LayoutManager&lt;/code&gt;的&lt;code&gt;onMeasure&lt;/code&gt;方法进行测量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;到这里，关于测量的逻辑就讲完了，接下去开始看 layout 逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onLayout(&lt;span&gt;boolean&lt;/span&gt; changed, &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; t, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
        TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);
        dispatchLayout();
        TraceCompat.endSection();
        mFirstLayoutComplete &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先会调用 dispatchLayout 进行 layout 操作，可以看到前面关注过的一个变量 mFirstLayoutComplete 赋值变为 true 。&lt;/p&gt;
&lt;p&gt;下面主要看 dispatchLayout 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispatchLayout() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mAdapter == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Log.e(TAG, &lt;/span&gt;&quot;No adapter attached; skipping layout&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; leave the state in START&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mLayout == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Log.e(TAG, &lt;/span&gt;&quot;No layout manager attached; skipping layout&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; leave the state in START&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        mState.mIsMeasuring &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mState.mLayoutStep ==&lt;span&gt; State.STEP_START) {
            dispatchLayoutStep1();
            mLayout.setExactMeasureSpecsFrom(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            dispatchLayoutStep2();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mAdapterHelper.hasUpdates() || mLayout.getWidth() !=&lt;span&gt; getWidth()
                &lt;/span&gt;|| mLayout.getHeight() !=&lt;span&gt; getHeight()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; First 2 steps are done in onMeasure but looks like we have to run again due to
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; changed size.&lt;/span&gt;
            mLayout.setExactMeasureSpecsFrom(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            dispatchLayoutStep2();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; always make sure we sync them (to ensure mode is exact)&lt;/span&gt;
            mLayout.setExactMeasureSpecsFrom(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        dispatchLayoutStep3();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;71.5&quot;&gt;
&lt;p&gt;&lt;code&gt;dispatchLayout &lt;/code&gt;方法也是非常的简单，这个方法保证 &lt;code&gt;RecyclerView &lt;/code&gt;必须经历三个过程 —— &lt;code&gt;dispatchLayoutStep1&lt;/code&gt;、&lt;code&gt;dispatchLayoutStep2&lt;/code&gt;、&lt;code&gt;dispatchLayoutStep3&lt;/code&gt;。同时，如果在这时候，发现子 view 宽高参数发生变化后，会再次调用 dispatchLayoutStep2() 方法。&lt;/p&gt;
&lt;p&gt;最后，来看下千呼万唤使出来的 dispatchLayoutStep3 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The final step of the layout where we save the information about views for animations,
     * trigger animations and do any necessary cleanup.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispatchLayoutStep3() {&lt;br/&gt;&lt;span&gt;　　　　　// 动画
&lt;/span&gt;        mState.assertLayoutStep(State.STEP_ANIMATIONS);
        startInterceptRequestLayout();
        onEnterLayoutOrScroll();&lt;br/&gt;&lt;span&gt;　　　　　// 标记进行复位
&lt;/span&gt;        mState.mLayoutStep &lt;/span&gt;=&lt;span&gt; State.STEP_START;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mState.mRunSimpleAnimations) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Step 3: Find out where things are now, and process change animations.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; traverse list in reverse because we may call animateChange in the loop which may
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove the target view holder.&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = mChildHelper.getChildCount() - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
                ViewHolder holder &lt;/span&gt;=&lt;span&gt; getChildViewHolderInt(mChildHelper.getChildAt(i));
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (holder.shouldIgnore()) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; key =&lt;span&gt; getChangedHolderKey(holder);
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ItemHolderInfo animationInfo =&lt;span&gt; mItemAnimator
                        .recordPostLayoutInformation(mState, holder);
                ViewHolder oldChangeViewHolder &lt;/span&gt;=&lt;span&gt; mViewInfoStore.getFromOldChangeHolders(key);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldChangeViewHolder != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;oldChangeViewHolder.shouldIgnore()) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; run a change animation

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If an Item is CHANGED but the updated version is disappearing, it creates
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a conflicting case.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Since a view that is marked as disappearing is likely to be going out of
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bounds, we run a change animation. Both views will be cleaned automatically
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; once their animations finish.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; On the other hand, if it is the same view holder instance, we run a
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; disappearing animation instead because we are not going to rebind the updated
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; VH unless it is enforced by the layout manager.&lt;/span&gt;
                    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; oldDisappearing =&lt;span&gt; mViewInfoStore.isDisappearing(
                            oldChangeViewHolder);
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; newDisappearing =&lt;span&gt; mViewInfoStore.isDisappearing(holder);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldDisappearing &amp;amp;&amp;amp; oldChangeViewHolder ==&lt;span&gt; holder) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; run disappear animation instead of change&lt;/span&gt;
&lt;span&gt;                        mViewInfoStore.addToPostLayout(holder, animationInfo);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ItemHolderInfo preInfo =&lt;span&gt; mViewInfoStore.popFromPreLayout(
                                oldChangeViewHolder);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we add and remove so that any post info is merged.&lt;/span&gt;
&lt;span&gt;                        mViewInfoStore.addToPostLayout(holder, animationInfo);
                        ItemHolderInfo postInfo &lt;/span&gt;=&lt;span&gt; mViewInfoStore.popFromPostLayout(holder);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (preInfo == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);
                        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            animateChange(oldChangeViewHolder, holder, preInfo, postInfo,
                                    oldDisappearing, newDisappearing);
                        }
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    mViewInfoStore.addToPostLayout(holder, animationInfo);
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Step 4: Process view info lists and trigger animations 做动画&lt;/span&gt;
&lt;span&gt;            mViewInfoStore.process(mViewInfoProcessCallback);
        }

        mLayout.removeAndRecycleScrapInt(mRecycler);&lt;br/&gt;&lt;span&gt;　　　　　// 记录数据，并把之前用到一些标志位复位
&lt;/span&gt;        mState.mPreviousLayoutItemCount &lt;/span&gt;=&lt;span&gt; mState.mItemCount;
        mDataSetHasChangedAfterLayout &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        mDispatchItemsChangedEvent &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        mState.mRunSimpleAnimations &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        mState.mRunPredictiveAnimations &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        mLayout.mRequestedSimpleAnimations &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mRecycler.mChangedScrap != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mRecycler.mChangedScrap.clear();
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mLayout.mPrefetchMaxObservedInInitialPrefetch) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initial prefetch has expanded cache, so reset until next prefetch.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This prevents initial prefetches from expanding the cache permanently.&lt;/span&gt;
            mLayout.mPrefetchMaxCountObserved = 0&lt;span&gt;;
            mLayout.mPrefetchMaxObservedInInitialPrefetch &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            mRecycler.updateViewCacheSize();
        }

        mLayout.onLayoutCompleted(mState);
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        mViewInfoStore.clear();&lt;br/&gt;//
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1&lt;span&gt;])) {
            dispatchOnScrolled(&lt;/span&gt;0, 0&lt;span&gt;);
        }
        recoverFocusFromState();
        resetFocusInfo();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;从上面的逻辑可以看出 dispatchLayoutStep3 &lt;/code&gt;主要是做 Item 的动画，本文不对动画进行展开，所以先省略动画部分。然后就是对一些标志位复位。清除一些状态。&lt;/p&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;这里对这三个方法做一个小结，方便大家记住这几个方法的作用：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;dispatchLayoutStep1&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;本方法的作用主要有三点：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;处理 &lt;code&gt;Adapter &lt;/code&gt;更新;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;决定执行哪一种动画&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;保存每个 &lt;code&gt;ItemView &lt;/code&gt;的信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;有必要的话，会进行预布局，并把相关信息保存下来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dispatchLayoutStep2&lt;/td&gt;
&lt;td&gt;在这个方法里面，真正进行 &lt;code&gt;children &lt;/code&gt;的测量和布局。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;dispatchLayoutStep3&lt;/td&gt;
&lt;td&gt;这个方法的作用执行在 &lt;code&gt;dispatchLayoutStep1 &lt;/code&gt;方法里面保存的动画信息。本方法不是本文的介绍重点&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;接下来，我们来分析三大流程的最后一个阶段 —— &lt;code&gt;draw。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面来看看 RecyclerView 的 draw() 和 onDraw() 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; draw(Canvas c) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.draw(c);

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; mItemDecorations.size();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
            mItemDecorations.get(i).onDrawOver(c, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, mState);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ......&lt;/span&gt;
}    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 真是考虑周到啊。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDraw(Canvas c) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onDraw(c);

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; mItemDecorations.size();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
            mItemDecorations.get(i).onDraw(c, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, mState);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现这里并没有做太多，只是调用 &lt;code&gt;ItemDecoration &lt;/code&gt;的 &lt;code&gt;onDraw 和 &lt;/code&gt;onDrawOver 方法。这样就将分割线添加到其中。&lt;/p&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;前面在介绍 &lt;code&gt;dispatchLayoutStep2 &lt;/code&gt;方法时，只是简单的介绍了，&lt;code&gt;RecyclerView &lt;/code&gt;通过调用 &lt;code&gt;LayoutManager &lt;/code&gt;的 &lt;code&gt;onLayoutChildren &lt;/code&gt;方法。&lt;code&gt;LayoutManager &lt;/code&gt;本身对这个方法没有进行实现，所以必须得看看它的子类，这里以 LinearLayoutManager 来举例说明：&lt;/p&gt;
&lt;p&gt;
&lt;h3&gt;&lt;span&gt;onLayoutChildren&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ......&lt;/span&gt;&lt;span&gt;

        ensureLayoutState();
        mLayoutState.mRecycle &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; resolve layout direction&lt;/span&gt;
&lt;span&gt;        resolveShouldLayoutReverse();&lt;br/&gt;&lt;span&gt;　　　　　// ...... &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　// calculate anchor position and coordinate&lt;/span&gt;&lt;br/&gt;　　　　　updateAnchorInfoForLayout(recycler, state, mAnchorInfo);&lt;br/&gt;　　　　　mAnchorInfo.mValid = true;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; noRecycleSpace not needed: recycling doesn't happen in below's fill
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; invocations because mScrollingOffset is set to SCROLLING_OFFSET_NaN&lt;/span&gt;
        mLayoutState.mNoRecycleSpace = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mAnchorInfo.mLayoutFromEnd) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fill towards start&lt;/span&gt;
&lt;span&gt;            updateLayoutStateToFillStart(mAnchorInfo);
            mLayoutState.mExtraFillSpace &lt;/span&gt;=&lt;span&gt; extraForStart;
            fill(recycler, mLayoutState, state, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            startOffset &lt;/span&gt;=&lt;span&gt; mLayoutState.mOffset;
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; firstElement =&lt;span&gt; mLayoutState.mCurrentPosition;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mLayoutState.mAvailable &amp;gt; 0&lt;span&gt;) {
                extraForEnd &lt;/span&gt;+=&lt;span&gt; mLayoutState.mAvailable;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fill towards end&lt;/span&gt;
&lt;span&gt;            updateLayoutStateToFillEnd(mAnchorInfo);
            mLayoutState.mExtraFillSpace &lt;/span&gt;=&lt;span&gt; extraForEnd;
            mLayoutState.mCurrentPosition &lt;/span&gt;+=&lt;span&gt; mLayoutState.mItemDirection;
            fill(recycler, mLayoutState, state, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            endOffset &lt;/span&gt;=&lt;span&gt; mLayoutState.mOffset;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mLayoutState.mAvailable &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end could not consume all. add more items towards start&lt;/span&gt;
                extraForStart =&lt;span&gt; mLayoutState.mAvailable;
                updateLayoutStateToFillStart(firstElement, startOffset);
                mLayoutState.mExtraFillSpace &lt;/span&gt;=&lt;span&gt; extraForStart;
                fill(recycler, mLayoutState, state, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                startOffset &lt;/span&gt;=&lt;span&gt; mLayoutState.mOffset;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fill towards end&lt;/span&gt;
&lt;span&gt;            updateLayoutStateToFillEnd(mAnchorInfo);
            mLayoutState.mExtraFillSpace &lt;/span&gt;=&lt;span&gt; extraForEnd;
            fill(recycler, mLayoutState, state, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            endOffset &lt;/span&gt;=&lt;span&gt; mLayoutState.mOffset;
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastElement =&lt;span&gt; mLayoutState.mCurrentPosition;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mLayoutState.mAvailable &amp;gt; 0&lt;span&gt;) {
                extraForStart &lt;/span&gt;+=&lt;span&gt; mLayoutState.mAvailable;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fill towards start&lt;/span&gt;
&lt;span&gt;            updateLayoutStateToFillStart(mAnchorInfo);
            mLayoutState.mExtraFillSpace &lt;/span&gt;=&lt;span&gt; extraForStart;
            mLayoutState.mCurrentPosition &lt;/span&gt;+=&lt;span&gt; mLayoutState.mItemDirection;
            fill(recycler, mLayoutState, state, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            startOffset &lt;/span&gt;=&lt;span&gt; mLayoutState.mOffset;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mLayoutState.mAvailable &amp;gt; 0&lt;span&gt;) {
                extraForEnd &lt;/span&gt;=&lt;span&gt; mLayoutState.mAvailable;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; start could not consume all it should. add more items towards end&lt;/span&gt;
&lt;span&gt;                updateLayoutStateToFillEnd(lastElement, endOffset);
                mLayoutState.mExtraFillSpace &lt;/span&gt;=&lt;span&gt; extraForEnd;
                fill(recycler, mLayoutState, state, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                endOffset &lt;/span&gt;=&lt;span&gt; mLayoutState.mOffset;
            }
        }

       &lt;/span&gt;&lt;span&gt;
        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;state.isPreLayout()) {
            mOrientationHelper.onLayoutComplete();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            mAnchorInfo.reset();
        }
        mLastStackFromEnd &lt;/span&gt;=&lt;span&gt; mStackFromEnd;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG) {
            validateChildOrder();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onLayoutChildren 方法很长，因此省略一些无关的代码。其实主要是做两件事&lt;span&gt;确定锚点的信息，这里面的信息包括：&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;code&gt;Children &lt;/code&gt;&lt;span&gt;的布局方向，有 start 和 end 两个方向；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;mPosition &lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;mCoordinate&lt;/code&gt;&lt;span&gt;，分别表示 &lt;/span&gt;&lt;code&gt;Children &lt;/code&gt;&lt;span&gt;开始填充的 position 和坐标。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div readability=&quot;12&quot;&gt;
&lt;div readability=&quot;17.5&quot;&gt;
&lt;p&gt;&lt;span&gt;根据锚点信息，调用 &lt;code&gt;fill &lt;/code&gt;方法进行 &lt;code&gt;Children &lt;/code&gt;的填充。这个过程中根据锚点信息的不同，可能会调用两次 &lt;code&gt;fill &lt;/code&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;updateAnchorInfoForLayout&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要想看锚点信息的计算过程，我们可以从 &lt;code&gt;updateAnchorInfoForLayout &lt;/code&gt;方法里面来找出答案，我们来看看 &lt;code&gt;updateAnchorInfoForLayout &lt;/code&gt;方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateAnchorInfoForLayout(RecyclerView.Recycler recycler, RecyclerView.State state,
            AnchorInfo anchorInfo) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (updateAnchorFromPendingData(state, anchorInfo)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG) {
                Log.d(TAG, &lt;/span&gt;&quot;updated anchor info from pending information&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (updateAnchorFromChildren(recycler, state, anchorInfo)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG) {
                Log.d(TAG, &lt;/span&gt;&quot;updated anchor info from existing children&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG) {
            Log.d(TAG, &lt;/span&gt;&quot;deciding anchor info for fresh state&quot;&lt;span&gt;);
        }
        anchorInfo.assignCoordinateFromPadding();
        anchorInfo.mPosition &lt;/span&gt;= mStackFromEnd ? state.getItemCount() - 1 : 0&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;26&quot;&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;我相信通过上面的代码注释，大家都能明白 &lt;code&gt;updateAnchorInfoForLayout &lt;/code&gt;方法到底干了嘛，这里我简单分析一下这三种确定所做的含义，具体是怎么做的，这里就不讨论。&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;第一种计算方式，表示含义有两种：1. &lt;code&gt;RecyclerView &lt;/code&gt;被重建，期间回调了 &lt;code&gt;onSaveInstanceState &lt;/code&gt;方法，所以目的是为了恢复上次的布局；2. &lt;code&gt;RecyclerView &lt;/code&gt;调用了&lt;code&gt;scrollToPosition &lt;/code&gt;之类的方法，所以目的是让&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;RecyclerView &lt;/code&gt;滚到准确的位置上去。所以，锚点的信息根据上面的两种情况来计算。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;第二种计算方法，从&lt;code&gt;C hildren &lt;/code&gt;上面来计算锚点信息。这种计算方式也有两种情况：1. 如果当前有拥有焦点的 &lt;code&gt;Child&lt;/code&gt;，那么有当前有焦点的 Child 的位置来计算锚点；2. 如果没有 child 拥有焦点，那么根据布局方向(此时布局方向由 &lt;code&gt;mLayoutFromEnd &lt;/code&gt;来决定)获取可见的第一个 &lt;code&gt;ItemView &lt;/code&gt;或者最后一个 &lt;code&gt;ItemView&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果前面两种方式都计算失败了，那么采用第三种计算方式，也就是默认的计算方式。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;fill 填充布局&lt;/h3&gt;
&lt;p&gt;然后就是调用 &lt;code&gt;fill &lt;/code&gt;方法来填充 &lt;code&gt;Children&lt;/code&gt;。在正式分析填充过程时，我们先来看一张图片：&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-container-fill&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202101/916005-20210117001349549-950961153.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;275&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上图形象的展现出三种&lt;code&gt;fill&lt;/code&gt;的情况。其中，我们可以看到第三种情况，&lt;code&gt;fill &lt;/code&gt;方法被调用了两次。&lt;/p&gt;
&lt;p&gt;我们看看 &lt;code&gt;fill &lt;/code&gt;方法:&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; stopOnFocusable) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ······&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; ((layoutState.mInfinite || remainingSpace &amp;gt; 0) &amp;amp;&amp;amp;&lt;span&gt; layoutState.hasMore(state)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ······&lt;/span&gt;
&lt;span&gt;            layoutChunk(recycler, state, layoutState, layoutChunkResult);

        }
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ······&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;49&quot;&gt;
&lt;p&gt;&lt;code&gt;fill &lt;/code&gt;方法的代码比较长，其实都是来计算可填充的空间，真正填充 &lt;code&gt;Child &lt;/code&gt;的地方是 &lt;code&gt;layoutChunk &lt;/code&gt;方法。我们来看看 &lt;code&gt;layoutChunk &lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
        LayoutState layoutState, LayoutChunkResult result) {
    View view &lt;/span&gt;=&lt;span&gt; layoutState.next(recycler);
    ...
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (layoutState.mScrapList == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mShouldReverseLayout ==&lt;span&gt; (layoutState.mLayoutDirection
                &lt;/span&gt;==&lt;span&gt; LayoutState.LAYOUT_START)) {
            addView(view);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            addView(view, &lt;/span&gt;0&lt;span&gt;);
        }
    }
    ...
    measureChildWithMargins(view, &lt;/span&gt;0, 0&lt;span&gt;);
    ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We calculate everything with View's bounding box (which includes decor and margins)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; To calculate correct layout position, we subtract margins.&lt;/span&gt;
    layoutDecorated(view, left + params.leftMargin, top +&lt;span&gt; params.topMargin,
            right &lt;/span&gt;- params.rightMargin, bottom -&lt;span&gt; params.bottomMargin);
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提醒下别小看这个 &lt;code&gt;next &lt;/code&gt;方法，&lt;code&gt;RecyclerView &lt;/code&gt;缓存机制的起点就是从这个方法开始，可想而知，这个方法到底为我们做了多少事情。&lt;/p&gt;
&lt;p&gt;这里的 addView() 方法，其实就是 ViewGroup 的 addView() 方法；measureChildWithMargins() 方法看名字就知道是用于测量子控件大小的，这里我先跳过这个方法的解释，放在后面来做，目前就简单地理解为测量子控件大小就好了。下面是 layoutDecoreated() 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; layoutDecorated(@NonNull View child, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt; top, &lt;span&gt;int&lt;/span&gt; right, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bottom) {&lt;br/&gt;&lt;span&gt;　　　　　　　// 将分割线考虑进去
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Rect insets =&lt;span&gt; ((LayoutParams) child.getLayoutParams()).mDecorInsets;
            child.layout(left &lt;/span&gt;+ insets.left, top + insets.top, right -&lt;span&gt; insets.right,
                    bottom &lt;/span&gt;-&lt;span&gt; insets.bottom);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结上面代码，在 RecyclerView 的 measure 及 layout 阶段，填充 ItemView 的算法为：向父容器增加子控件，测量子控件大小，布局子控件，布局锚点向当前布局方向平移子控件大小，重复上诉步骤至 RecyclerView 可绘制空间消耗完毕或子控件已全部填充。&lt;/p&gt;
&lt;p&gt;这样所有的子控件的 measure 及 layout 过程就完成了。回到 RecyclerView 的 onMeasure 方法，执行 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec) 这行代码的作用就是根据子控件的大小，设置 RecyclerView 的大小。至此，RecyclerView 的 measure 和 layout 实际上已经完成了。&lt;/p&gt;
&lt;p&gt;但是，你有可能已经发现上面过程中的问题了：如何确定 RecyclerView 的可绘制空间？不过，如果你熟悉 android 控件的绘制机制的话，这就不是问题。其实，这里的可绘制空间，可以简单地理解为父容器的大小；更准确的描述是，父容器对 RecyclerView 的布局大小的要求，可以通过 MeasureSpec.getSize() 方法获得。&lt;/p&gt;

&lt;p&gt;到这里，关于 RecyclerView 的绘制流程就讲完了，由于主打绘制流程，没有分析其他，可能会导致整个逻辑有些跳跃，但不妨碍理解整个绘制过程。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最后回到文章前面的问题上，可以发现 RecyclerView 将绘制过程其实是委托给 layoutManager 来操作，这和普通自定义 view 是很不一样的。这样的灵活操作，可以让使用者自定义各种样式，使得 RecyclerView 使用场景变得更加丰富。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其次在于分割线的处理上，它并不把分割线当做是子 view 来处理，而是在布局子 view 的时候，将分割线考虑进去给留下间隙。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;参考文章&lt;/h3&gt;
&lt;h3 class=&quot;_1RuRku&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/61fe3f3bb7ec&quot; target=&quot;_blank&quot;&gt;RecyclerView 源码分析(一) - RecyclerView的三大流程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;articleContentId&quot; class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/ztchun/article/details/61967031&quot; target=&quot;_blank&quot;&gt;Android中RecyclerView源码解析&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Sat, 16 Jan 2021 16:43:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>概述 对于 RecyclerView 是那么熟悉又那么陌生。熟悉是因为作为一名 Android 开发者，RecyclerView 是经常会在项目里面用到的，陌生是因为只是知道怎么用，但是却不知道&amp;#1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/14252980.html</dc:identifier>
</item>
<item>
<title>【分布式锁的演化】终章！手撸ZK分布式锁! - 程序员老猫</title>
<link>http://www.cnblogs.com/kdaddy/p/14287983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kdaddy/p/14287983.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;这应该是分布式锁演化的最后一个章节了，相信很多小伙伴们看完这个章节之后在应对高并发的情况下，如何保证线程安全心里肯定也会有谱了。在实际的项目中也可以参考一下老猫的github上的例子，当然代码没有经过特意的封装，需要小伙伴们自己再好好封装一下。那么接下来，就和大家分享一下基于zookeeper的分布式锁，由于此篇主要分享的是zk的分布式锁，所以对于zk本身的相关知识点，并不会涉及很多。和分布式锁实现有关的zk知识点会提及。&lt;/p&gt;
&lt;h3 id=&quot;zookeeper实现分布式锁&quot;&gt;Zookeeper实现分布式锁&lt;/h3&gt;
&lt;p&gt;何为ZK?（为了打字简单，后续老猫均以ZK来代替zookeeper），相信很多接触到Dubbo框架的小伙伴可能听说过ZK，但是具体也没有详细地去学习ZK。那么又如何利用ZK来实现分布式锁呢？以下我们一个个来看。&lt;/p&gt;
&lt;h4 id=&quot;什么是zk&quot;&gt;什么是ZK?&lt;/h4&gt;
&lt;p&gt;对于没有接触过ZK的小伙伴，老猫给个非专业但是挺实用的解释，ZK是一个分布式协调服务，该服务由N多个节点构成，每个节点均可存储数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在了解锁原理之前我们先来看一下ZK的数据结构，具体如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2200669/202101/2200669-20210117000546115-582158588.png&quot; alt=&quot;ZK数据结构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Zookeeper 中，每一个数据节点都是一个 ZNode，上图根目录下有两个节点，分别是：app1 和 app2，其中 app1 下面又有三个子节点。那么我们来看看 ZNode 数据结构到底是什么样子的呢。首先我们来了解 ZNode 的类型。&lt;/p&gt;
&lt;p&gt;Zookeeper 节点类型可以分为三大类：持久性节点（Persistent）、瞬时性节点（Ephemeral）、顺序性节点（Sequential）。现实开发中在创建节点的时候通过组合可以生成以下四种节点类型：持久节点、持久顺序节点、瞬时节点、瞬时有序节点。&lt;/p&gt;
&lt;p&gt;（1） 持久节点：节点被创建后会一直存在服务器，直到删除操作主动清除，这种节点也是最常见的类型。&lt;/p&gt;
&lt;p&gt;（2） 持久顺序节点：有顺序的持久节点，节点特性和持久节点是一样的，只是额外特性表现在顺序上。顺序特性实质是在创建节点的时候，会在节点名后面加上一个数字后缀，来表示其顺序。&lt;/p&gt;
&lt;p&gt;（3） 瞬时节点：会被自动清理掉的节点，它的生命周期和客户端会话绑在一起，客户端会话结束，节点会被删除掉。与持久性节点不同的是，临时节点不能创建子节点。&lt;/p&gt;
&lt;p&gt;（4）瞬时有顺序节点：有顺序的临时节点，和持久顺序节点相同，在其创建的时候会在名字后面加上数字后缀。&lt;/p&gt;
&lt;p&gt;那么此次我们的ZK分布式锁就是基于ZK的临时有序节点实现的，也就是上述的第四种节点。当然光凭借第四种临时有序节点是不够的，我们还需要用到ZK的另外一个比较重要的概念，那就是“ZK观察器”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ZK观察器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ZK观察器可以监测到节点的变动，如果节点发生变更会通知到客户端。我们可以设置观察器的三个方法：getData()，getChildrean(),exists()。观察器有一个比较重要的特性就是只能监控一次，再监控需要重新设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）利用ZK的瞬时有序节点的特性。&lt;/p&gt;
&lt;p&gt;（2）多线程并发创建瞬时节点时，得到有序的序列。&lt;/p&gt;
&lt;p&gt;（3）序号最小的线程获得锁。&lt;/p&gt;
&lt;p&gt;（4）其他的线程则监听自己节点序号的前一个序号。&lt;/p&gt;
&lt;p&gt;（5）前一个线程执行完成，删除自己序号的节点。&lt;/p&gt;
&lt;p&gt;（6）下一个序号的线程得到通知，继续执行。&lt;/p&gt;
&lt;p&gt;（7）依次类推&lt;/p&gt;
&lt;p&gt;通过上述流程大家就会发现，其实在创建节点的时候，就已经确定了线程的执行顺序。大家看完这个流程可能有点模糊，咱们继续看下面的图解，老猫相信大家心里就会有一个更加清晰的认知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2200669/202101/2200669-20210117000619620-1117578866.png&quot; alt=&quot;ZK节点监听执行&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【流程一】我们有四个线程，分别是线程A、线程B、线程C、线程D。此时线程并发运行，这样就会在我们的ZK中创建四个临时有序节点，按照先来后到的顺序分别是1、2、3、4。此时按照我们流程描述中的第三点描述由于线程A对应的序号最小，所以A优先获取锁。&lt;/p&gt;
&lt;p&gt;【流程二】再依次看第二个流程，此时当A获取锁之后，线程B的监听器会去监听1节点的执行情况，线程C的监听器会去监听2节点的执行情况，线程D的监听器会去监听3节点的执行情况依次类推。&lt;/p&gt;
&lt;p&gt;【流程三】当线程A执行完毕之后会删除相关的节点1，此时会被线程B监听到，于是线程B开始执行，有线程C监听等待着线程B节点的释放，依次类推，直到这四个线程都执行完毕。&lt;/p&gt;
&lt;p&gt;通过以上的图解，老猫觉得很多小伙伴对ZK锁的实现原理应该已经知道了，当然对ZK还是比较陌生的小伙伴也可以专门抽时间去熟悉一下ZK。接下来就和老猫一起来看一下具体的代码又是如何实现的吧。&lt;/p&gt;
&lt;h3 id=&quot;纯手撸zk分布式锁代码&quot;&gt;纯手撸ZK分布式锁代码&lt;/h3&gt;
&lt;p&gt;基于上述的流程，我们手撸一下核心的代码，首先我们搭建的zk服务器必须和项目中使用的pom依赖是同一版本，这样也才能够避免出问题，由于老猫使用的是zk的3.6.2版本，所以老猫引入的pom如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;       &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.6.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手写zk锁的逻辑主要也是根据上述原理实现，代码中有比较晦涩难懂的地方，老猫也写了详细的备注，还有不 明白的铁子可以给老猫留言：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2021/1/16 10:25
 * @公众号 程序员老猫
 */
@Slf4j
@Service
public class ZKLockUtil implements AutoCloseable, Watcher {
    private ZooKeeper zooKeeper;
    private String zNode;
    public ZKLockUtil() throws Exception {
        this.zooKeeper = new ZooKeeper(&quot;localhost:2181&quot;,100000,this);
    }
    public boolean getLock(String businessCode){
        try {
            // 首先创建业务根节点，类比之前的redis锁的key以及mysql锁的businessCode
            Stat stat = zooKeeper.exists(&quot;/&quot;+businessCode,false);
            if(stat == null){
                //表示创建一个业务根目录，此节点为持久节点，另外的由于在本地搭建的zk没有设置密码，所以采用OPEN_ACL_UNSAFE模式
                zooKeeper.create(&quot;/&quot; +businessCode,businessCode.getBytes(),
                        ZooDefs.Ids.OPEN_ACL_UNSAFE,
                        CreateMode.PERSISTENT);
            }
            //创建该目录下的有序瞬时节点，假如我们的订单业务编号是&quot;order&quot;，那么第一个有序瞬时节点应该是/order/order_0000001
            zNode =zooKeeper.create(&quot;/&quot; + businessCode + &quot;/&quot; + businessCode + &quot;_&quot;, businessCode.getBytes(),
                    ZooDefs.Ids.OPEN_ACL_UNSAFE,
                    CreateMode.EPHEMERAL_SEQUENTIAL);
            /**
             * 按照之前原理的时候的逻辑，
             * 我们会对所有的节点进行排序并且序号最小的那个节点优先获取锁，
             * 其他节点处于监听状态
             */
            //此处获取所有子节点，注：之前文章中提及的getData()，getChildrean(),exists()的第二个参数表示是否设置观察器，ture为设置，false表示不设置
            List&amp;lt;String&amp;gt; childrenNodes = zooKeeper.getChildren(&quot;/&quot;+businessCode,false);
            //子节点排序
            Collections.sort(childrenNodes);
            //获取序号最小的子节点
            String minNode = childrenNodes.get(0);

            //如果创建的节点是最小序号的节点，那么就获得锁
            if(zNode.endsWith(minNode)){
                return true;
            }
            //否则监听前一个节点的情况
            /**
             * 到这里说明创建的zNode为第二个或者第三第四个等节点
             * 此处比较晦涩用代入法去理解
             * 如果zNode是第二个节点，那么监听的就是第一个最小节点，
             * 如果zNode是第三个节点，那么此时上一个节点就是循环中的当前那个节点。
             * 需要细品
             */
            String lastNode = minNode;
            for (String node : childrenNodes){
                //如果瞬时节点为非第一个节点，那么监听前一个节点
                if(zNode.endsWith(node)){
                    zooKeeper.exists(&quot;/&quot;+businessCode+&quot;/&quot;+lastNode,true);
                    break;
                }else {
                    lastNode = node;
                }
            }
            //并发情况下wait方法让出锁，但是由于并发情景下，为了避免释放的时候错乱因此加上synchronized
            synchronized (this){
                wait();
            }
            //当被唤起的时候相当于轮到了，当前拿到了锁，所以return true
            return true;

        }catch (Exception e){
            e.printStackTrace();
        }
        return false;
    }
    @Override
    public void process(WatchedEvent watchedEvent) {
        //如果监听到节点被删除，那么则会通知下一个线程
        if(watchedEvent.getType() == Event.EventType.NodeDeleted){
            synchronized (this){
                notify();
            }
        }
    }
    @Override
    public void close() throws Exception {
        zooKeeper.delete(zNode,-1);
        zooKeeper.close();
        log.info(&quot;我已经释放了锁！&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体service层的代码老猫也做了更改，由于只看锁，所以在此老猫将相关落订单的逻辑去除了，对于上述工具类，可以进行如下使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2021/1/16 10:25
 * @公众号 程序员老猫
 */
@Service
@Slf4j
public class ZKLockService {
    @Autowired
    private ZKLockUtil zkLockUtil;
    private String ORDER_KEY = &quot;order_kd&quot;;
    public  Integer createOrder() throws Exception{
        log.info(&quot;进入了方法&quot;);
        try {
            if (zkLockUtil.getLock(ORDER_KEY)) {
                log.info(&quot;拿到了锁&quot;);
                //此处为了手动演示并发，所以我们暂时在这里休眠
                Thread.sleep(6000);
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            zkLockUtil.close();
        }
        log.info(&quot;方法执行完毕&quot;);
        return 1;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述即为实现代码，相关的逻辑，老猫也在代码的备注中阐释。如果还有不清楚的小伙伴可以给老猫留言。当然想要完整测试代码也可以去老猫的github地址下载。地址：&lt;a href=&quot;https://github.com/maoba/kd-distribute&quot; target=&quot;_blank&quot;&gt;https://github.com/maoba/kd-distribute&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;curator客户端的使用&quot;&gt;curator客户端的使用&lt;/h3&gt;
&lt;p&gt;相信有很多还是会有很多小伙伴会说，上述的流程逻辑比较绕，太让人头疼了。那么福利来了，其实关于ZK锁的话还有可以用封装比较完善的客户端，那就是curator。这个客户端本身就已经实现了ZK的分布式锁，咱们开箱调用即可。如果有更多的小伙伴想要了解curator，也可以去官网去研究一番，具体的地址为：&lt;a href=&quot;http://curator.apache.org/%E3%80%82%E5%BD%93%E7%84%B6%E8%80%81%E7%8C%AB%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B9%9F%E6%98%AF%E6%A0%B9%E6%8D%AE%E5%AE%98%E7%BD%91%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%86%99%E5%87%BA%E6%9D%A5%E7%9A%84%E3%80%82%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A&quot; target=&quot;_blank&quot;&gt;http://curator.apache.org/。当然老猫下面的代码也是根据官网的步骤写出来的。具体代码实现如下：&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt; &amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;curator-recipes&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;4.3.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于curator每次启动都要连接zk，所以老猫干脆将其放在springboot的启动中。其实上面手写的通过构造方法连接zk的方式也可以做一下改造。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author ktdaddy
 * @公众号 程序员老猫
 */
@SpringBootApplication
@MapperScan(&quot;com.kd.distribute.dao&quot;)
public class DistributeApplication {
    public static void main(String[] args) {
        SpringApplication.run(DistributeApplication.class, args);
    }
    //启动服务的时候连接zk，并且指定开始使用和结束使用的方法
    @Bean(initMethod=&quot;start&quot;,destroyMethod = &quot;close&quot;)
    public CuratorFramework getCuratorFramework() {
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;localhost:2181&quot;, retryPolicy);
        return client;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体锁的使用代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2021/1/16 22:49
 * @公众号 程序员老猫
 */
@Service
@Slf4j
public class CuratorLockService {
    private String ORDER_KEY = &quot;order_kd&quot;;
    @Autowired
    private CuratorFramework client;
    public  Integer createOrder() throws Exception{
        log.info(&quot;进入了方法&quot;);
        InterProcessMutex lock = new InterProcessMutex(client, &quot;/&quot;+ORDER_KEY);
        try {
            if (lock.acquire(30, TimeUnit.SECONDS)) {
                log.info(&quot;拿到了锁&quot;);
                //此处为了手动演示并发，所以我们暂时在这里休眠6s
                Thread.sleep(6000);
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            try {
                log.info(&quot;我释放了锁！！&quot;);
                lock.release();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        log.info(&quot;方法执行完毕&quot;);
        return 1;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相当简单，当然有兴趣研究源码实现的小伙伴也可以查看一下InterProcessMutex的相关的源码。在此老猫不赘述。&lt;/p&gt;
&lt;h3 id=&quot;分布式锁的对比&quot;&gt;分布式锁的对比&lt;/h3&gt;
&lt;p&gt;到此，我们将分布式系统的锁的解决方案都已经和大家分享过了，最终咱们来进行一个对比，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2200669/202101/2200669-20210117000652125-407490718.png&quot; alt=&quot;分布式锁的对比&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看了上面这个比较之后，其实在我们的实际项目中，还是推荐现成的 curator 实现方式以及redisson实现方式，因为毕竟目前来说是相当成熟的方案，不推荐由我们自己的代码去实现。所以小伙伴们在选择的时候就不用纠结了。&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;p&gt;老猫花了将近半个月的时候整理和输出了单体锁演化到分布式锁的解决方案，熬了比较多的夜，如果能给大家带来收获，那是再好不过的了。当然看到这里也希望能得到你的点赞、关注和转发。你的支持，是老猫原创的最大动力，后面老猫会带给大家更多分布式系统的解决方案。也希望能得到你的持续关注。更多精彩欢迎大家关注公众号“程序员老猫”&lt;/p&gt;
</description>
<pubDate>Sat, 16 Jan 2021 16:09:00 +0000</pubDate>
<dc:creator>程序员老猫</dc:creator>
<og:description>分布式锁系列终章，ZK锁的实现，不会的小伙伴请上车~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kdaddy/p/14287983.html</dc:identifier>
</item>
<item>
<title>SpringSecurity应用篇  - 童话述说我的结局</title>
<link>http://www.cnblogs.com/xing1/p/14287978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing1/p/14287978.html</guid>
<description>&lt;p&gt;前面吹水原理吹了一篇幅了，现在讲解下应用篇幅，前面说过，如果要用SpringSecurity的话要先导入一个包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要更改默认的帐号密码的话就配置如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
spring.security.user.name=&lt;span&gt;admin
spring.security.user.password&lt;/span&gt;=admin
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过前面的分析知道了修改默认一个是在配置文件中修改，另一个是自定义SpringSecurity配置类，重写配置类方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebSecurityConfig extends WebSecurityConfigurerAdapter {



    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configure(AuthenticationManagerBuilder auth) throws Exception {
         auth.inMemoryAuthentication()
                .withUser(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .password(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{noop}admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不加密&lt;/span&gt;
                .authorities(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ADMIN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义过滤器链&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configure(HttpSecurity httpSecurity) throws Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用默认的过滤器链&lt;/span&gt;
&lt;span&gt;        super.configure(httpSecurity);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的配置虽然达到了修改帐号密码及权限的目的，但是有一个问题，那就是现在一切都是写死的，而在真实环境中这些数据来源都是数据库，所以如果想要了解怎么从数据库中动态获取用户信息，那就要先从认证的源码进行分析起，有上篇的原码篇说明，可以很清楚的知道认证的过滤器是UsernamePasswordAuthenticationFilter类，从下面源码可以看到默认的表单传递过来帐号密码这里都有接收，这个认证的过滤器他继承了AbstractAuthenticationProcessingFilter这个过滤器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UsernamePasswordAuthenticationFilter extends
        AbstractAuthenticationProcessingFilter {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ~ Static fields/initializers
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =====================================================================================&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final String SPRING_SECURITY_FORM_USERNAME_KEY = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final String SPRING_SECURITY_FORM_PASSWORD_KEY = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String usernameParameter =&lt;span&gt; SPRING_SECURITY_FORM_USERNAME_KEY;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String passwordParameter =&lt;span&gt; SPRING_SECURITY_FORM_PASSWORD_KEY;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; boolean postOnly = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ~ Constructors
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ===================================================================================================&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UsernamePasswordAuthenticationFilter() {
        super(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; AntPathRequestMatcher(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ~ Methods
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ========================================================================================================&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Authentication attemptAuthentication(HttpServletRequest request,
            HttpServletResponse response) throws AuthenticationException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (postOnly &amp;amp;&amp;amp; !request.getMethod().equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenticationServiceException(
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication method not supported: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; request.getMethod());
        }

        String username &lt;/span&gt;=&lt;span&gt; obtainUsername(request);
        String password &lt;/span&gt;=&lt;span&gt; obtainPassword(request);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (username == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            username &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (password == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            password &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        username &lt;/span&gt;=&lt;span&gt; username.trim();

        UsernamePasswordAuthenticationToken authRequest &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UsernamePasswordAuthenticationToken(
                username, password);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Allow subclasses to set the &quot;details&quot; property&lt;/span&gt;
&lt;span&gt;        setDetails(request, authRequest);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getAuthenticationManager().authenticate(authRequest);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Enables subclasses to override the composition of the password, such as by
     * including additional values and a separator.
     * &amp;lt;p&amp;gt;
     * This might be used for example if a postcode/zipcode was required in addition to
     * the password. A delimiter such as a pipe (|) should be used to separate the
     * password and extended value(s). The &amp;lt;code&amp;gt;AuthenticationDao&amp;lt;/code&amp;gt; will need to
     * generate the expected password in a corresponding manner.
     * &amp;lt;/p&amp;gt;
     *
     * @param request so that request attributes can be retrieved
     *
     * @return the password that will be presented in the &amp;lt;code&amp;gt;Authentication&amp;lt;/code&amp;gt;
     * request token to the &amp;lt;code&amp;gt;AuthenticationManager&amp;lt;/code&amp;gt;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Nullable
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String obtainPassword(HttpServletRequest request) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; request.getParameter(passwordParameter);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Enables subclasses to override the composition of the username, such as by
     * including additional values and a separator.
     *
     * @param request so that request attributes can be retrieved
     *
     * @return the username that will be presented in the &amp;lt;code&amp;gt;Authentication&amp;lt;/code&amp;gt;
     * request token to the &amp;lt;code&amp;gt;AuthenticationManager&amp;lt;/code&amp;gt;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Nullable
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String obtainUsername(HttpServletRequest request) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; request.getParameter(usernameParameter);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Provided so that subclasses may configure what is put into the authentication
     * request's details property.
     *
     * @param request that an authentication request is being created for
     * @param authRequest the authentication request object that should have its details
     * set
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDetails(HttpServletRequest request,
            UsernamePasswordAuthenticationToken authRequest) {
        authRequest.setDetails(authenticationDetailsSource.buildDetails(request));
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Sets the parameter name which will be used to obtain the username from the login
     * request.
     *
     * @param usernameParameter the parameter name. Defaults to &quot;username&quot;.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsernameParameter(String usernameParameter) {
        Assert.hasText(usernameParameter, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Username parameter must not be empty or null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.usernameParameter =&lt;span&gt; usernameParameter;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Sets the parameter name which will be used to obtain the password from the login
     * request..
     *
     * @param passwordParameter the parameter name. Defaults to &quot;password&quot;.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPasswordParameter(String passwordParameter) {
        Assert.hasText(passwordParameter, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Password parameter must not be empty or null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.passwordParameter =&lt;span&gt; passwordParameter;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Defines whether only HTTP POST requests will be allowed by this filter. If set to
     * true, and an authentication request is received which is not a POST request, an
     * exception will be raised immediately and authentication will not be attempted. The
     * &amp;lt;tt&amp;gt;unsuccessfulAuthentication()&amp;lt;/tt&amp;gt; method will be called as if handling a failed
     * authentication.
     * &amp;lt;p&amp;gt;
     * Defaults to &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; but may be overridden by subclasses.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPostOnly(boolean postOnly) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.postOnly =&lt;span&gt; postOnly;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; final String getUsernameParameter() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; usernameParameter;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; final String getPasswordParameter() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; passwordParameter;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入AbstractAuthenticationProcessingFilter过滤器；里面有个doFilter方法，具体的就看这个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;105&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbstractAuthenticationProcessingFilter extends GenericFilterBean
        implements ApplicationEventPublisherAware, MessageSourceAware {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ~ Static fields/initializers
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =====================================================================================

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ~ Instance fields
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ================================================================================================&lt;/span&gt;

    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ApplicationEventPublisher eventPublisher;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; AuthenticationDetailsSource&amp;lt;HttpServletRequest, ?&amp;gt; authenticationDetailsSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebAuthenticationDetailsSource();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AuthenticationManager authenticationManager;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; MessageSourceAccessor messages =&lt;span&gt; SpringSecurityMessageSource.getAccessor();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; RememberMeServices rememberMeServices = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullRememberMeServices();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RequestMatcher requiresAuthenticationRequestMatcher;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; boolean continueChainBeforeSuccessfulAuthentication = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SessionAuthenticationStrategy sessionStrategy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullAuthenticatedSessionStrategy();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; boolean allowSessionCreation = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; AuthenticationSuccessHandler successHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SavedRequestAwareAuthenticationSuccessHandler();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; AuthenticationFailureHandler failureHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleUrlAuthenticationFailureHandler();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ~ Constructors
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ===================================================================================================&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * @param defaultFilterProcessesUrl the default value for &amp;lt;tt&amp;gt;filterProcessesUrl&amp;lt;/tt&amp;gt;.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AbstractAuthenticationProcessingFilter(String defaultFilterProcessesUrl) {
        setFilterProcessesUrl(defaultFilterProcessesUrl);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Creates a new instance
     *
     * @param requiresAuthenticationRequestMatcher the {@link RequestMatcher} used to
     * determine if authentication is required. Cannot be null.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AbstractAuthenticationProcessingFilter(
            RequestMatcher requiresAuthenticationRequestMatcher) {
        Assert.notNull(requiresAuthenticationRequestMatcher,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;requiresAuthenticationRequestMatcher cannot be null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.requiresAuthenticationRequestMatcher =&lt;span&gt; requiresAuthenticationRequestMatcher;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ~ Methods
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ========================================================================================================&lt;/span&gt;
&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterPropertiesSet() {
        Assert.notNull(authenticationManager, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authenticationManager must be specified&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Invokes the
     * {@link #requiresAuthentication(HttpServletRequest, HttpServletResponse)
     * requiresAuthentication} method to determine whether the request is for
     * authentication and should be handled by this filter. If it is an authentication
     * request, the
     * {@link #attemptAuthentication(HttpServletRequest, HttpServletResponse)
     * attemptAuthentication} will be invoked to perform the authentication. There are
     * then three possible outcomes:
     * &amp;lt;ol&amp;gt;
     * &amp;lt;li&amp;gt;An &amp;lt;tt&amp;gt;Authentication&amp;lt;/tt&amp;gt; object is returned. The configured
     * {@link SessionAuthenticationStrategy} will be invoked (to handle any
     * session-related behaviour such as creating a new session to protect against
     * session-fixation attacks) followed by the invocation of
     * {@link #successfulAuthentication(HttpServletRequest, HttpServletResponse, FilterChain, Authentication)}
     * method&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;An &amp;lt;tt&amp;gt;AuthenticationException&amp;lt;/tt&amp;gt; occurs during authentication. The
     * {@link #unsuccessfulAuthentication(HttpServletRequest, HttpServletResponse, AuthenticationException)
     * unsuccessfulAuthentication} method will be invoked&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Null is returned, indicating that the authentication process is incomplete. The
     * method will then return immediately, assuming that the subclass has done any
     * necessary work (such as redirects) to continue the authentication process. The
     * assumption is that a later request will be received by this method where the
     * returned &amp;lt;tt&amp;gt;Authentication&amp;lt;/tt&amp;gt; object is not null.
     * &amp;lt;/ol&amp;gt;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest request &lt;/span&gt;=&lt;span&gt; (HttpServletRequest) req;
        HttpServletResponse response &lt;/span&gt;=&lt;span&gt; (HttpServletResponse) res;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;requiresAuthentication(request, response)) {
            chain.doFilter(request, response);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Request is to process authentication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        Authentication authResult;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;//attemptAuthentication是过滤认证信息的，这个方法是上层的抽象方法，是交给子类去实现的
            authResult &lt;/span&gt;=&lt;span&gt; attemptAuthentication(request, response);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (authResult == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return immediately as subclass has indicated that it hasn't completed
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; authentication&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            sessionStrategy.onAuthentication(authResult, request, response);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InternalAuthenticationServiceException failed) {
            logger.error(
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An internal error occurred while trying to authenticate the user.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    failed);
            unsuccessfulAuthentication(request, response, failed);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException failed) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Authentication failed&lt;/span&gt;
&lt;span&gt;            unsuccessfulAuthentication(request, response, failed);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Authentication success&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (continueChainBeforeSuccessfulAuthentication) {
            chain.doFilter(request, response);
        }

        successfulAuthentication(request, response, chain, authResult);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Indicates whether this filter should attempt to process a login request for the
     * current invocation.
     * &amp;lt;p&amp;gt;
     * It strips any parameters from the &quot;path&quot; section of the request URL (such as the
     * jsessionid parameter in &amp;lt;em&amp;gt;&lt;/span&gt;&lt;span&gt;https://host/myapp/index.html&lt;/span&gt;&lt;span&gt;;jsessionid=blah&amp;lt;/em&amp;gt;)
     * before matching against the &amp;lt;code&amp;gt;filterProcessesUrl&amp;lt;/code&amp;gt; property.
     * &amp;lt;p&amp;gt;
     * Subclasses may override for special requirements, such as Tapestry integration.
     *
     * @return &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt; if the filter should attempt authentication,
     * &amp;lt;code&amp;gt;false&amp;lt;/code&amp;gt; otherwise.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; boolean requiresAuthentication(HttpServletRequest request,
            HttpServletResponse response) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; requiresAuthenticationRequestMatcher.matches(request);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Performs actual authentication.
     * &amp;lt;p&amp;gt;
     * The implementation should do one of the following:
     * &amp;lt;ol&amp;gt;
     * &amp;lt;li&amp;gt;Return a populated authentication token for the authenticated user, indicating
     * successful authentication&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Return null, indicating that the authentication process is still in progress.
     * Before returning, the implementation should perform any additional work required to
     * complete the process.&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Throw an &amp;lt;tt&amp;gt;AuthenticationException&amp;lt;/tt&amp;gt; if the authentication process fails&amp;lt;/li&amp;gt;
     * &amp;lt;/ol&amp;gt;
     *
     * @param request from which to extract parameters and perform the authentication
     * @param response the response, which may be needed if the implementation has to do a
     * redirect as part of a multi-stage authentication process (such as OpenID).
     *
     * @return the authenticated user token, or null if authentication is incomplete.
     *
     * @throws AuthenticationException if authentication fails.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; Authentication attemptAuthentication(HttpServletRequest request,
            HttpServletResponse response) throws AuthenticationException, IOException,
            ServletException;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Default behaviour for successful authentication.
     * &amp;lt;ol&amp;gt;
     * &amp;lt;li&amp;gt;Sets the successful &amp;lt;tt&amp;gt;Authentication&amp;lt;/tt&amp;gt; object on the
     * {@link SecurityContextHolder}&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Informs the configured &amp;lt;tt&amp;gt;RememberMeServices&amp;lt;/tt&amp;gt; of the successful login&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Fires an {@link InteractiveAuthenticationSuccessEvent} via the configured
     * &amp;lt;tt&amp;gt;ApplicationEventPublisher&amp;lt;/tt&amp;gt;&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Delegates additional behaviour to the {@link AuthenticationSuccessHandler}.&amp;lt;/li&amp;gt;
     * &amp;lt;/ol&amp;gt;
     *
     * Subclasses can override this method to continue the {@link FilterChain} after
     * successful authentication.
     * @param request
     * @param response
     * @param chain
     * @param authResult the object returned from the &amp;lt;tt&amp;gt;attemptAuthentication&amp;lt;/tt&amp;gt;
     * method.
     * @throws IOException
     * @throws ServletException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; successfulAuthentication(HttpServletRequest request,
            HttpServletResponse response, FilterChain chain, Authentication authResult)
            throws IOException, ServletException {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication success. Updating SecurityContextHolder to contain: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    +&lt;span&gt; authResult);
        }

        SecurityContextHolder.getContext().setAuthentication(authResult);

        rememberMeServices.loginSuccess(request, response, authResult);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fire event&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.eventPublisher != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            eventPublisher.publishEvent(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InteractiveAuthenticationSuccessEvent(
                    authResult, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass()));
        }

        successHandler.onAuthenticationSuccess(request, response, authResult);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Default behaviour for unsuccessful authentication.
     * &amp;lt;ol&amp;gt;
     * &amp;lt;li&amp;gt;Clears the {@link SecurityContextHolder}&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Stores the exception in the session (if it exists or
     * &amp;lt;tt&amp;gt;allowSesssionCreation&amp;lt;/tt&amp;gt; is set to &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt;)&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Informs the configured &amp;lt;tt&amp;gt;RememberMeServices&amp;lt;/tt&amp;gt; of the failed login&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Delegates additional behaviour to the {@link AuthenticationFailureHandler}.&amp;lt;/li&amp;gt;
     * &amp;lt;/ol&amp;gt;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unsuccessfulAuthentication(HttpServletRequest request,
            HttpServletResponse response, AuthenticationException failed)
            throws IOException, ServletException {
        SecurityContextHolder.clearContext();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication request failed: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; failed.toString(), failed);
            logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Updated SecurityContextHolder to contain null Authentication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delegating to authentication failure handler &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; failureHandler);
        }

        rememberMeServices.loginFail(request, response);

        failureHandler.onAuthenticationFailure(request, response, failed);
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AuthenticationManager getAuthenticationManager() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; authenticationManager;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAuthenticationManager(AuthenticationManager authenticationManager) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.authenticationManager =&lt;span&gt; authenticationManager;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Sets the URL that determines if authentication is required
     *
     * @param filterProcessesUrl
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setFilterProcessesUrl(String filterProcessesUrl) {
        setRequiresAuthenticationRequestMatcher(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AntPathRequestMatcher(
                filterProcessesUrl));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRequiresAuthenticationRequestMatcher(
            RequestMatcher requestMatcher) {
        Assert.notNull(requestMatcher, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;requestMatcher cannot be null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.requiresAuthenticationRequestMatcher =&lt;span&gt; requestMatcher;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RememberMeServices getRememberMeServices() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rememberMeServices;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRememberMeServices(RememberMeServices rememberMeServices) {
        Assert.notNull(rememberMeServices, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rememberMeServices cannot be null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rememberMeServices =&lt;span&gt; rememberMeServices;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Indicates if the filter chain should be continued prior to delegation to
     * {@link #successfulAuthentication(HttpServletRequest, HttpServletResponse, FilterChain, Authentication)}
     * , which may be useful in certain environment (such as Tapestry applications).
     * Defaults to &amp;lt;code&amp;gt;false&amp;lt;/code&amp;gt;.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setContinueChainBeforeSuccessfulAuthentication(
            boolean continueChainBeforeSuccessfulAuthentication) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.continueChainBeforeSuccessfulAuthentication =&lt;span&gt; continueChainBeforeSuccessfulAuthentication;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eventPublisher =&lt;span&gt; eventPublisher;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAuthenticationDetailsSource(
            AuthenticationDetailsSource&lt;/span&gt;&amp;lt;HttpServletRequest, ?&amp;gt;&lt;span&gt; authenticationDetailsSource) {
        Assert.notNull(authenticationDetailsSource,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationDetailsSource required&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.authenticationDetailsSource =&lt;span&gt; authenticationDetailsSource;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMessageSource(MessageSource messageSource) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.messages = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageSourceAccessor(messageSource);
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; boolean getAllowSessionCreation() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; allowSessionCreation;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAllowSessionCreation(boolean allowSessionCreation) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.allowSessionCreation =&lt;span&gt; allowSessionCreation;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * The session handling strategy which will be invoked immediately after an
     * authentication request is successfully processed by the
     * &amp;lt;tt&amp;gt;AuthenticationManager&amp;lt;/tt&amp;gt;. Used, for example, to handle changing of the
     * session identifier to prevent session fixation attacks.
     *
     * @param sessionStrategy the implementation to use. If not set a null implementation
     * is used.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSessionAuthenticationStrategy(
            SessionAuthenticationStrategy sessionStrategy) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sessionStrategy =&lt;span&gt; sessionStrategy;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Sets the strategy used to handle a successful authentication. By default a
     * {@link SavedRequestAwareAuthenticationSuccessHandler} is used.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAuthenticationSuccessHandler(
            AuthenticationSuccessHandler successHandler) {
        Assert.notNull(successHandler, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;successHandler cannot be null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.successHandler =&lt;span&gt; successHandler;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAuthenticationFailureHandler(
            AuthenticationFailureHandler failureHandler) {
        Assert.notNull(failureHandler, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;failureHandler cannot be null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.failureHandler =&lt;span&gt; failureHandler;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AuthenticationSuccessHandler getSuccessHandler() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; successHandler;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AuthenticationFailureHandler getFailureHandler() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; failureHandler;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击attemptAuthentication，进入UsernamePasswordAuthenticationFilter方法的attemptAuthentication类中；这里面就是密码验证的逻辑了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Authentication attemptAuthentication(HttpServletRequest request,
            HttpServletResponse response) throws AuthenticationException {&lt;br/&gt;//验证提交方式
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (postOnly &amp;amp;&amp;amp; !request.getMethod().equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenticationServiceException(
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication method not supported: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; request.getMethod());
        }
        //获取帐号密码
        String username &lt;/span&gt;=&lt;span&gt; obtainUsername(request);
        String password &lt;/span&gt;=&lt;span&gt; obtainPassword(request);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (username == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            username &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (password == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            password &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        username &lt;/span&gt;=&lt;span&gt; username.trim();
          //封装到Token对象中
        UsernamePasswordAuthenticationToken authRequest &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UsernamePasswordAuthenticationToken(
                username, password);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Allow subclasses to set the &quot;details&quot; property&lt;/span&gt;
&lt;span&gt;        setDetails(request, authRequest);
          //认证；认证是在AuthenticationManager中做的，实现是authenticate
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getAuthenticationManager().authenticate(authRequest);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击authenticate，进入他的ProviderManager类中的authenticate方法中看认证的过程 ，这个类中定义了一个private List&amp;lt;AuthenticationProvider&amp;gt; providers = Collections.emptyList();属性，表示认证方式有多种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Authentication authenticate(Authentication authentication)
            throws AuthenticationException {
        Class&lt;/span&gt;&amp;lt;? extends Authentication&amp;gt; toTest =&lt;span&gt; authentication.getClass();
        AuthenticationException lastException &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        AuthenticationException parentException &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Authentication result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Authentication parentResult &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        boolean debug &lt;/span&gt;=&lt;span&gt; logger.isDebugEnabled();
        //针对多种认证做循环，取出每一种provider
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (AuthenticationProvider provider : getProviders()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;provider.supports(toTest)) {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
                logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication attempt using &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                        +&lt;span&gt; provider.getClass().getName());
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;//每一种取出来后做认证，所以要想继续看每种是怎么认证的就要跟进这个方法了
                result &lt;/span&gt;=&lt;span&gt; provider.authenticate(authentication);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    copyDetails(authentication, result);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (AccountStatusException |&lt;span&gt; InternalAuthenticationServiceException e) {
                prepareException(e, authentication);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SEC-546: Avoid polling additional providers if auth failure is due to
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; invalid account status&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException e) {
                lastException &lt;/span&gt;=&lt;span&gt; e;
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Allow the parent to try.&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                result &lt;/span&gt;= parentResult =&lt;span&gt; parent.authenticate(authentication);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ProviderNotFoundException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ignore as we will throw below if no other exception occurred prior to
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; calling parent and the parent
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; may throw ProviderNotFound even though a provider in the child already
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; handled the request&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException e) {
                lastException &lt;/span&gt;= parentException =&lt;span&gt; e;
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (eraseCredentialsAfterAuthentication
                    &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; (result instanceof CredentialsContainer)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Authentication is complete. Remove credentials and other secret data
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; from authentication&lt;/span&gt;
&lt;span&gt;                ((CredentialsContainer) result).eraseCredentials();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the parent AuthenticationManager was attempted and successful then it will publish an AuthenticationSuccessEvent
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This check prevents a duplicate AuthenticationSuccessEvent if the parent AuthenticationManager already published it&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (parentResult == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                eventPublisher.publishAuthenticationSuccess(result);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parent was null, or didn't authenticate (or throw an exception).&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (lastException == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            lastException &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProviderNotFoundException(messages.getMessage(
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProviderManager.providerNotFound&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[] { toTest.getName() },
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No AuthenticationProvider found for {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the parent AuthenticationManager was attempted and failed then it will publish an AbstractAuthenticationFailureEvent
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This check prevents a duplicate AbstractAuthenticationFailureEvent if the parent AuthenticationManager already published it&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (parentException == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            prepareException(lastException, authentication);
        }

        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; lastException;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 点击authenticate进入 AuthenticationProvider类，这是一个抽象类，所以要找authenticate的实现，这里面它的实现是AbstractUserDetailsAuthenticationProvider；这里面如果不懂为什么就打断点看类图，进入AbstractUserDetailsAuthenticationProvider类中的authenticate方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Authentication authenticate(Authentication authentication)
            throws AuthenticationException {
        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, authentication,
                () &lt;/span&gt;-&amp;gt;&lt;span&gt; messages.getMessage(
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.onlySupports&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Only UsernamePasswordAuthenticationToken is supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
         //获取凭证
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine username&lt;/span&gt;
        String username = (authentication.getPrincipal() == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NONE_PROVIDED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                : authentication.getName();

        boolean cacheWasUsed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;//从缓存中取数据
        UserDetails user &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userCache.getUserFromCache(username);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            cacheWasUsed &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;//对帐号进行验证,进去看下帐号验证做了啥
                user &lt;/span&gt;=&lt;span&gt; retrieveUser(username,
                        (UsernamePasswordAuthenticationToken) authentication);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UsernameNotFoundException notFound) {
                logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + username + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' not found&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hideUserNotFoundExceptions) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BadCredentialsException(messages.getMessage(
                            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.badCredentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bad credentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; notFound;
                }
            }

            Assert.notNull(user,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;retrieveUser returned null - a violation of the interface contract&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            preAuthenticationChecks.check(user);&lt;br/&gt;//对密码做一个匹配
            additionalAuthenticationChecks(user,
                    (UsernamePasswordAuthenticationToken) authentication);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException exception) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cacheWasUsed) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; There was a problem, so try again after checking
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we're using latest data (i.e. not from the cache)&lt;/span&gt;
                cacheWasUsed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                user &lt;/span&gt;=&lt;span&gt; retrieveUser(username,
                        (UsernamePasswordAuthenticationToken) authentication);
                preAuthenticationChecks.check(user);
                additionalAuthenticationChecks(user,
                        (UsernamePasswordAuthenticationToken) authentication);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; exception;
            }
        }

        postAuthenticationChecks.check(user);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cacheWasUsed) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userCache.putUserInCache(user);
        }

        Object principalToReturn &lt;/span&gt;=&lt;span&gt; user;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (forcePrincipalAsString) {
            principalToReturn &lt;/span&gt;=&lt;span&gt; user.getUsername();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createSuccessAuthentication(principalToReturn, authentication, user);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击进入DaoAuthenticationProvider类的retrieveUser方法中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; final UserDetails retrieveUser(String username,
            UsernamePasswordAuthenticationToken authentication)
            throws AuthenticationException {
        prepareTimingAttackProtection();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;//根据名称去加载用户对象
            UserDetails loadedUser &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getUserDetailsService().loadUserByUsername(username);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadedUser == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalAuthenticationServiceException(
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UserDetailsService returned null, which is an interface contract violation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loadedUser;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UsernameNotFoundException ex) {
            mitigateAgainstTimingAttack(authentication);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InternalAuthenticationServiceException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalAuthenticationServiceException(ex.getMessage(), ex);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;点击看loadUserByUsername加载看了啥事，会发现下面只有一个接口然后一个&lt;/span&gt;loadUserByUsername实现
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDetailsService {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ~ Methods
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ========================================================================================================&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Locates the user based on the username. In the actual implementation, the search
     * may possibly be case sensitive, or case insensitive depending on how the
     * implementation instance is configured. In this case, the &amp;lt;code&amp;gt;UserDetails&amp;lt;/code&amp;gt;
     * object that comes back may have a username that is of a different case than what
     * was actually requested..
     *
     * @param username the username identifying the user whose data is required.
     *
     * @return a fully populated user record (never &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;)
     *
     * @throws UsernameNotFoundException if the user could not be found or the user has no
     * GrantedAuthority
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击看他的众多实现，会发现里在面有一个InMemoryUserDetailsManager实现，&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210116231004251-944466683.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt; 点击进入 ，这个接口会实现验证的逻辑&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDetails loadUserByUsername(String username)
            throws UsernameNotFoundException {
        UserDetails user &lt;/span&gt;= users.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(username.toLowerCase());

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UsernameNotFoundException(username);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User(user.getUsername(), user.getPassword(), user.isEnabled(),
                user.isAccountNonExpired(), user.isCredentialsNonExpired(),
                user.isAccountNonLocked(), user.getAuthorities());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;到了这一步，其实就很明显了，既然你实现 他的接口，如果我想实现从数据进行匹配的话，我实现你的接口不就完事了吗，&lt;/span&gt;那么我们如果要实现自定义的认证流程也只需要实现UserDetailsService接口重写loadUserByUsernameInMemoryUserDetailsManager就可以了
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserService  extends UserDetailsService {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import com.example.demo.user.service.UserService;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;

import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserServiceImpl implements UserService {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 自已定义的认证逻辑方法，如果不懂看我写的原理篇
     *
     * @param username
     * @return
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDetails loadUserByUsername(String username) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保证权限的集合&lt;/span&gt;
        List&amp;lt;GrantedAuthority&amp;gt; authorities = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产中是从数据库拿的&lt;/span&gt;
        SimpleGrantedAuthority auth = &lt;span&gt;new&lt;/span&gt; SimpleGrantedAuthority(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ROLE_ROOT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        authorities.add(auth);
        UserDetails user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User(username
                , &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{noop}admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                , authorities);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后在SpringSecurity的配置文件中再修改一下写活就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import com.example.demo.user.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.User;

@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebSecurityConfig extends WebSecurityConfigurerAdapter {


   @Autowired
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configure(AuthenticationManagerBuilder auth) throws Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         auth.inMemoryAuthentication()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .withUser(&quot;admin&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .password(&quot;{noop}admin&quot;)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不加密
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .authorities(&quot;ADMIN&quot;);&lt;/span&gt;
&lt;span&gt;        auth.userDetailsService(userService);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义过滤器链&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configure(HttpSecurity httpSecurity) throws Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用默认的过滤器链&lt;/span&gt;
&lt;span&gt;        super.configure(httpSecurity);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这一步密码的自定义就实现了，有兴趣的可以自己启动试下；这个过程将帐号密码及权限的获取改成动态了，到这里可能有的人会想，我们自定义的类只实现了帐号的验证，但并没有看到密码的验证，其实前面我已经提到了密码的验证了，代码回退到AbstractUserDetailsAuthenticationProvider方法的authenticate类，其中的 preAuthenticationChecks.check(user);就是认证检查的前置处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Authentication authenticate(Authentication authentication)
            throws AuthenticationException {
        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, authentication,
                () &lt;/span&gt;-&amp;gt;&lt;span&gt; messages.getMessage(
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.onlySupports&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Only UsernamePasswordAuthenticationToken is supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine username&lt;/span&gt;
        String username = (authentication.getPrincipal() == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NONE_PROVIDED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                : authentication.getName();

        boolean cacheWasUsed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        UserDetails user &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userCache.getUserFromCache(username);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            cacheWasUsed &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                user &lt;/span&gt;=&lt;span&gt; retrieveUser(username,
                        (UsernamePasswordAuthenticationToken) authentication);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UsernameNotFoundException notFound) {
                logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + username + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' not found&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hideUserNotFoundExceptions) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BadCredentialsException(messages.getMessage(
                            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.badCredentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bad credentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; notFound;
                }
            }

            Assert.notNull(user,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;retrieveUser returned null - a violation of the interface contract&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            preAuthenticationChecks.check(user);
            additionalAuthenticationChecks(user,
                    (UsernamePasswordAuthenticationToken) authentication);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException exception) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cacheWasUsed) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; There was a problem, so try again after checking
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we're using latest data (i.e. not from the cache)&lt;/span&gt;
                cacheWasUsed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                user &lt;/span&gt;=&lt;span&gt; retrieveUser(username,
                        (UsernamePasswordAuthenticationToken) authentication);
                preAuthenticationChecks.check(user);
                additionalAuthenticationChecks(user,
                        (UsernamePasswordAuthenticationToken) authentication);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; exception;
            }
        }

        postAuthenticationChecks.check(user);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cacheWasUsed) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userCache.putUserInCache(user);
        }

        Object principalToReturn &lt;/span&gt;=&lt;span&gt; user;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (forcePrincipalAsString) {
            principalToReturn &lt;/span&gt;=&lt;span&gt; user.getUsername();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createSuccessAuthentication(principalToReturn, authentication, user);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击check进入UserDetailsChecker类看它的处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDetailsChecker {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Examines the User
     * @param toCheck the UserDetails instance whose status should be checked.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; check(UserDetails toCheck);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选择它的AbstractUserDetailsAuthenticationProvider实现类，进入AbstractUserDetailsAuthenticationProvider类的check方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultPreAuthenticationChecks implements UserDetailsChecker {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; check(UserDetails user) {&lt;br/&gt;//帐号是否被锁定
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;user.isAccountNonLocked()) {
                logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User account is locked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LockedException(messages.getMessage(
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.locked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User account is locked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            }
             //是否可用
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;user.isEnabled()) {
                logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User account is disabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DisabledException(messages.getMessage(
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.disabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User is disabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            } 
             //是否过期
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;user.isAccountNonExpired()) {
                logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User account is expired&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AccountExpiredException(messages.getMessage(
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.expired&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User account has expired&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一步看完后再回退到AbstractUserDetailsAuthenticationProvider方法的authenticate类，前置处理完后的additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication);就是密码的效验了；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Authentication authenticate(Authentication authentication)
            throws AuthenticationException {
        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, authentication,
                () &lt;/span&gt;-&amp;gt;&lt;span&gt; messages.getMessage(
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.onlySupports&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Only UsernamePasswordAuthenticationToken is supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine username&lt;/span&gt;
        String username = (authentication.getPrincipal() == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NONE_PROVIDED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                : authentication.getName();

        boolean cacheWasUsed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        UserDetails user &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userCache.getUserFromCache(username);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            cacheWasUsed &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                user &lt;/span&gt;=&lt;span&gt; retrieveUser(username,
                        (UsernamePasswordAuthenticationToken) authentication);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UsernameNotFoundException notFound) {
                logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + username + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' not found&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hideUserNotFoundExceptions) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BadCredentialsException(messages.getMessage(
                            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.badCredentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bad credentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; notFound;
                }
            }

            Assert.notNull(user,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;retrieveUser returned null - a violation of the interface contract&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            preAuthenticationChecks.check(user);
            additionalAuthenticationChecks(user,
                    (UsernamePasswordAuthenticationToken) authentication);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException exception) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cacheWasUsed) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; There was a problem, so try again after checking
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we're using latest data (i.e. not from the cache)&lt;/span&gt;
                cacheWasUsed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                user &lt;/span&gt;=&lt;span&gt; retrieveUser(username,
                        (UsernamePasswordAuthenticationToken) authentication);
                preAuthenticationChecks.check(user);
                additionalAuthenticationChecks(user,
                        (UsernamePasswordAuthenticationToken) authentication);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; exception;
            }
        }

        postAuthenticationChecks.check(user);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cacheWasUsed) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userCache.putUserInCache(user);
        }

        Object principalToReturn &lt;/span&gt;=&lt;span&gt; user;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (forcePrincipalAsString) {
            principalToReturn &lt;/span&gt;=&lt;span&gt; user.getUsername();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createSuccessAuthentication(principalToReturn, authentication, user);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击additionalAuthenticationChecks进入DaoAuthenticationProvider类的additionalAuthenticationChecks方法看它是怎么进行密码效验的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; additionalAuthenticationChecks(UserDetails userDetails,
            UsernamePasswordAuthenticationToken authentication)
            throws AuthenticationException {&lt;br/&gt;//先判断有没有密码
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (authentication.getCredentials() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication failed: no credentials provided&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BadCredentialsException(messages.getMessage(
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.badCredentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bad credentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }
        //获取凭证
        String presentedPassword &lt;/span&gt;=&lt;span&gt; authentication.getCredentials().toString();
         //做密码的匹配，这两个密码一个是表单提交的密码一个是从数据库查出来的密码
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {
            logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication failed: password does not match stored value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BadCredentialsException(messages.getMessage(
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AbstractUserDetailsAuthenticationProvider.badCredentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bad credentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看上面的matches方法，进入PasswordEncoder类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PasswordEncoder {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Encode the raw password. Generally, a good encoding algorithm applies a SHA-1 or
     * greater hash combined with an 8-byte or greater randomly generated salt.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String encode(CharSequence rawPassword);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Verify the encoded password obtained from storage matches the submitted raw
     * password after it too is encoded. Returns true if the passwords match, false if
     * they do not. The stored password itself is never decoded.
     *
     * @param rawPassword the raw password to encode and match
     * @param encodedPassword the encoded password from storage to compare with
     * @return true if the raw password, after encoding, matches the encoded password from
     * storage
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    boolean matches(CharSequence rawPassword, String encodedPassword);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Returns true if the encoded password should be encoded again for better security,
     * else false. The default implementation always returns false.
     * @param encodedPassword the encoded password to check
     * @return true if the encoded password should be encoded again for better security,
     * else false.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;default&lt;/span&gt;&lt;span&gt; boolean upgradeEncoding(String encodedPassword) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210116233847010-676753411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean matches(CharSequence rawPassword, String prefixEncodedPassword) {&lt;br/&gt;//判断前缀
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rawPassword == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; prefixEncodedPassword == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        String id &lt;/span&gt;=&lt;span&gt; extractId(prefixEncodedPassword);
        PasswordEncoder &lt;/span&gt;&lt;span&gt;delegate&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;.idToPasswordEncoder.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;delegate&lt;/span&gt; == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultPasswordEncoderForMatches
                .matches(rawPassword, prefixEncodedPassword);
        }
        String encodedPassword &lt;/span&gt;=&lt;span&gt; extractEncodedPassword(prefixEncodedPassword);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;.matches(rawPassword, encodedPassword);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们在实际生产中不可能用明文传递密码，所以接下来要聊的就是加密喽，在SpringSecurity的官网中他推荐的加密方式是BCryptPasswordEncoder方式进行加密，刚刚在上面截图中也看到了，所以接着改下项目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import com.example.demo.user.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
 
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import javax.annotation.Resource;

@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebSecurityConfig extends WebSecurityConfigurerAdapter {


   @Autowired
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;

   @Resource
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BCryptPasswordEncoder bCryptPasswordEncoder;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configure(AuthenticationManagerBuilder auth) throws Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         auth.inMemoryAuthentication()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .withUser(&quot;admin&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .password(&quot;{noop}admin&quot;)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不加密
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .authorities(&quot;ADMIN&quot;);&lt;/span&gt;
&lt;span&gt;        auth.userDetailsService(userService).passwordEncoder(bCryptPasswordEncoder);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义过滤器链&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configure(HttpSecurity httpSecurity) throws Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用默认的过滤器链&lt;/span&gt;
&lt;span&gt;        super.configure(httpSecurity);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BCryptPasswordEncoder bCryptPasswordEncoder(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BCryptPasswordEncoder();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后UserServiceImpl里面就不能用明文了，要用密文了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserServiceImpl implements UserService {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 自已定义的认证逻辑方法，如果不懂看我写的原理篇
     *
     * @param username
     * @return
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDetails loadUserByUsername(String username) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保证权限的集合&lt;/span&gt;
        List&amp;lt;GrantedAuthority&amp;gt; authorities = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产中是从数据库拿的&lt;/span&gt;
        SimpleGrantedAuthority auth = &lt;span&gt;new&lt;/span&gt; SimpleGrantedAuthority(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ROLE_ROOT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        authorities.add(auth);
        UserDetails user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User(username
                , &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$2a$10$YOWyHqvtg.gqrbiSTlYQx.nu2j0psWsrs/JIiuzav7IDX7r93WGIe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                , authorities);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.1、认证状态判断&lt;/h2&gt;
&lt;p&gt;在实际项目中因为用户的不同操作，可能会给出不同的状态，比如正常、冻结等。SpringSecurity也支持&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210116235557942-226738005.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在User对象的属性中定义如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210116235632332-473071924.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;好久没写前端代码了，为了偷懒，用thymeleaf来写吧，先导包&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
       &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;搞个登录页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/1999/xhtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; xmlns:th=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.thymeleaf.org&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;登录管理&amp;lt;/h1&amp;gt;

    &amp;lt;form th:action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@{/login.do}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        账号:&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;br&amp;gt;&lt;span&gt;
        密码:&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;br&amp;gt;
        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再搞个异常页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;错误页面&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController {
    @GetMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String loginPage(){
         
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

    @GetMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String index(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

    @GetMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String basePage(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

    @GetMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/error.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String error(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/error.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要使用自定义页面的话就要修改掉默认的页面，修改WebSecurityConfig类&lt;/p&gt;

</description>
<pubDate>Sat, 16 Jan 2021 16:07:00 +0000</pubDate>
<dc:creator>童话述说我的结局</dc:creator>
<og:description>前面吹水原理吹了一篇幅了，现在讲解下应用篇幅，前面说过，如果要用SpringSecurity的话要先导入一个包 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xing1/p/14287978.html</dc:identifier>
</item>
<item>
<title>根据业务摸索出的一个selenium代码模版（python） - Json-Eri</title>
<link>http://www.cnblogs.com/jsoneri/p/14287930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsoneri/p/14287930.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;总算入行上班几个月了，不得不说业务是真的不消停啊。。&lt;br/&gt;本人工作上经常遇到一种场景：为甲方做自动化接口处理工具，登录需要短信验证码，，&lt;br/&gt;嘛算是摸索出了一套selenium代码模板，主要解决如下痛点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会话超时/断开时，又要找甲方问短信等验证码登录&lt;/li&gt;
&lt;li&gt;调试途中增减修改功能，算是调试中热更新&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分享一下&lt;/p&gt;
&lt;h2 id=&quot;模板代码&quot;&gt;模板代码&lt;/h2&gt;
&lt;h3 id=&quot;apppy&quot;&gt;app.py&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/python
# -*- coding: utf-8 -*-
import os
import importlib
from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import backend

basepath = os.path.abspath(os.path.dirname(__file__))
driver_path = os.path.join(basepath, 'chromedriver.exe')
logger = backend.logger


def init_browser(driver_path=None):
    options = webdriver.ChromeOptions()
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-gpu')
    prefs = {
        'profile.default_content_setting_values': {
            'notifications': 2
        }}
    options.add_experimental_option('prefs', prefs)
    options.add_experimental_option('excludeSwitches', ['enable-automation'])
    options.add_experimental_option(&quot;useAutomationExtension&quot;, False)
    browser = webdriver.Chrome(options=options, executable_path=driver_path)
    browser.maximize_window()
    browser.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, {
        &quot;source&quot;: &quot;&quot;&quot;
        Object.defineProperty(navigator, 'webdriver', {
          get: () =&amp;gt; undefined
        })
      &quot;&quot;&quot;
    })
    return browser


def jump_security(wait, mouse):
    wait.until(EC.presence_of_element_located((By.ID, 'details-button'))).click()
    ele = wait.until(EC.presence_of_element_located((By.ID, 'proceed-link')))
    mouse.move_to_element(ele).click().perform()


def init_login(driver, wait, mouse):
    username_inp = wait.until(EC.presence_of_element_located((By.ID, &quot;username&quot;)))
    username_inp.send_keys(&quot;user&quot;)
    password_inp = driver.find_element_by_id(&quot;password&quot;)
    password_inp.send_keys(&quot;password&quot;)


class App(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
            cls.error_num = 0
            cls.driver = init_browser(driver_path)
            cls.wait = WebDriverWait(cls.driver, 20)
            cls.mouse = ActionChains(cls.driver)
            cls.driver.get('https://www.target.com/login')
            # jump_security(cls.wait, cls.mouse)
            init_login(cls.driver, cls.wait, cls.mouse)
            cls._instance = object.__new__(cls)
        return cls._instance


# 模式1：client无限循环
def run_unlimited():
    while True:
        try:
            obj = App()
            input('等待登录并进入目标页面后，回此处按回车 &amp;gt;&amp;gt;&amp;gt; ')
            back = backend.Backend(obj)
            results = back.main()
        except Exception as e:
            pass
        finally:
            mode = input('供backend修改的阻塞暂停')
            importlib.reload(backend)


# 模式2：构建本地api服务
from flask import Flask
app = Flask(__name__)


@app.route(&quot;/&quot;, methods=[&quot;GET&quot;])
def main():
    importlib.reload(backend)
    back = backend.Backend(App())
    results = back.main()


if __name__ == '__main__':
    os.system('taskkill /im chromedriver.exe /F')       # win专用，清残留进程
    os.system('taskkill /im chrome.exe /F')
    run_unlimited()
    # app.run()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前端有两部分，一是单例的selenium，二是此自动化处理工具的形式：client循环形式 / api服务形式&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;单例的 _&lt;em&gt;new&lt;/em&gt;_ 里init一些属性，处理登录那部分也可以放后台&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;两种形式其实就是看形式是要主动触发还是被动触发，至于具体做什么就放后台&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;backendpy&quot;&gt;backend.py&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/python
# -*- coding: utf-8 -*-
import json
import os
import re
from concurrent.futures import ThreadPoolExecutor, as_completed
import requests
import simplejson
from loguru import logger
from retry import retry
from tqdm import tqdm, trange
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

basepath = os.path.abspath('./')
logger.add(f'{basepath}/logs/{os.path.basename(__file__)[:-3]}.log',
           format=&quot;{level} | {time:YYYY-MM-DD HH:mm:ss} | {function}:{line} - {message}&quot;,
           level=&quot;INFO&quot;, retention='5 days')


class Backend(object):
    def __init__(self, obj):
        self.sess = requests.session()
        self.driver = obj.driver
        self.sess.headers = {'Accept': 'application/json, text/javascript, */*; q=0.01',
                             'Accept-Encoding': 'gzip, deflate',
                             'Accept-Language': 'zh-Hans-CN, zh-Hans; q=0.5',
                             'Cache-Control': 'no-cache',
                             'Connection': 'Keep-Alive',
                             'Content-Length': '561',
                             'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                             'Cookie': 'SESSION=abcdefg',
                             'Host': 'www.target.com',
                             'Referer': 'https://www.target.com/path',
                             'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko',
                             'X-Requested-With': 'XMLHttpRequest'
                             }

    def get_cookie(self):
        self.driver.find_element_by_xpath('//input[@class=&quot;e.g:trigger btn&quot;]').click()
        cookies = {_[&quot;name&quot;]: _[&quot;value&quot;] for _ in self.driver.get_cookies()}
        return cookies

    def get_headers(self):
        cookies = self.get_cookie()
        token = self.driver.execute_script('return window.sessionStorage.getItem(&quot;token&quot;)')
        self.sess.headers.update({
            'Authorization': token,
            'Cookie': f'SESSION={cookies[&quot;SESSION&quot;]}; acw_tc={cookies[&quot;acw_tc&quot;]}'
        })

    @retry((json.decoder.JSONDecodeError, simplejson.errors.JSONDecodeError, KeyError, ValueError), tries=3, delay=1)
    def do_api(self):
        url = 'https://www.target.com/api/path'
        payload = {
            'params': '31b1xu0',
        }
        self.get_headers()
        resp = self.sess.post(url, json=payload, verify=False, timeout=10)
        if resp.status_code == 200:
            self.pre_api_task(resp.json())  # do what you need todo
        else:
            raise ValueError(f'do_api failed:: {resp.text}')

    def do_selenium_command(self):
        self.driver.execute_script(&quot;$('p[class=imgShow]').click()&quot;)
        self.driver.execute_script(&quot;document.getElementsByClassName('supportRadioOptional1 checked')[0].click();&quot;)
        pagenum = int(re.search(r'共 (\d+) 页', self.driver.page_source).group(1))
        for _ in trange(pagenum, ncols=40):
            self.pre_page_task()                        # do what you need todo
            self.driver.execute_script(f&quot;PaginationpageTable.gotoPage('next', '{_+2}', '50');&quot;)

    def main(self):
        self.do_selenium_command()
        self.do_api()


if __name__ == '__main__':
    requests.get('127.0.0.1:5000')

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于前面说的短信验证码，让甲方登录后selenium一顿操作就把api的headers补完了，可以愉快地请求接口了&lt;/p&gt;
&lt;p&gt;需要js取参数的话可以这样写&lt;code&gt;token = self.driver.execute_script('return window.sessionStorage.getItem(&quot;token&quot;)')&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;目前遇到的一些注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;渲染的页面带frame，需要switch_to再xpath等处理，可把&lt;code&gt;driver.page_source&lt;/code&gt;写进文件判断是否该目标页顺带测定位&lt;/li&gt;
&lt;li&gt;有时&lt;code&gt;driver.find_element_by_*&lt;/code&gt;无法定位，试试用js；有些JS/Jquery功能在老版IE上用不了，回用mouse处理（套娃呢喂）；连续使用js时要注意响应等待时间&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;basepath处用&lt;code&gt;'./'&lt;/code&gt;取巧了一下(与pyinstaller打包有关)，可以基于此变量做一些本地文件处理&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;last&quot;&gt;Last&lt;/h2&gt;
&lt;p&gt;毕竟最终是为甲方做的，程序要以甲方设备为准 &lt;span class=&quot;heimu&quot; title=&quot;你知道的太多了&quot;&gt;即使它是win7,用pywin32定位句柄出现兼容问题即使业务网站只兼容IE内核，js部分功能无法用头发掉光了啊&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;毕竟是个人摸索出的，可能有更优解，如大佬路过还请不要吝啬交&lt;s&gt;(p)&lt;/s&gt;流&lt;s&gt;(y)&lt;/s&gt;一下心得&lt;/p&gt;
</description>
<pubDate>Sat, 16 Jan 2021 15:52:00 +0000</pubDate>
<dc:creator>Json-Eri</dc:creator>
<og:description>前言 总算入行上班几个月了，不得不说业务是真的不消停啊。。 本人工作上经常遇到一种场景：为甲方做自动化接口处理工具，登录需要短信验证码，， 嘛算是摸索出了一套selenium代码模板，主要解决如下痛点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jsoneri/p/14287930.html</dc:identifier>
</item>
<item>
<title>使用Jenkins+Pipline 持续构建自动化部署之安卓源码打包、测试、邮件通知 - 尘世风</title>
<link>http://www.cnblogs.com/feng0815/p/14287056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feng0815/p/14287056.html</guid>
<description>&lt;p&gt;Jenkins 2.x的精髓是Pipeline as Code，那为什么要用Pipeline呢？jenkins1.0也能实现自动化构建，但Pipeline能够将以前project中的配置信息以steps的方式放在一个脚本里，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程，形成流水式发布，构建步骤视图化。简单来说，Pipeline适用的场景更广泛，能胜任更复杂的发布流程。举个例子，job构建工作在master节点，自动化测试脚本在slave节点，这时候jenkins1.0就无法同时运行两个节点，而Pipeline可以。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Stage: 阶段，一个Pipeline可以划分为若干个Stage，每个Stage代表一组操作。注意，Stage是一个逻辑分组的概念，可以跨多个Node。&lt;/li&gt;
&lt;li&gt;Node: 节点，一个Node就是一个Jenkins节点，或者是Master，或者是slave，是执行Step的具体运行期环境。&lt;/li&gt;
&lt;li&gt;Step: 步骤，Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenkins Plugin提供。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.Pipeline支持两种语法：Declarative Pipeline（在Pipeline 2.5中引入，结构化方式）和Scripted Pipeline，两者都支持建立连续输送的Pipeline。&lt;br/&gt;共同点：&lt;br/&gt;两者都是pipeline代码的持久实现，都能够使用pipeline内置的插件或者插件提供的steps，两者都可以利用共享库扩展。&lt;br/&gt;区别：&lt;br/&gt;两者不同之处在于语法和灵活性。Declarative pipeline对用户来说，语法更严格，有固定的组织结构，更容易生成代码段，使其成为用户更理想的选择。但是Scripted pipeline更加灵活，因为Groovy本身只能对结构和语法进行限制，对于更复杂的pipeline来说，用户可以根据自己的业务进行灵活的实现和扩展。下面介绍中使用Scripted Pipeline语法。&lt;/p&gt;

&lt;h2 id=&quot;1新建一个流水线的job&quot;&gt;1.新建一个“流水线”的job&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210116194957412-677619859.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2配置pipeline脚本。&quot;&gt;2.配置Pipeline脚本。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210116234255672-138460377.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;上图是以执行git仓库的脚本文件配置的Pipline脚本，也可以选择第一种方式，直接输入以下脚本也是可以的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pipeline{
    agent {
        label 'master'
    }

    stages{
        stage('安卓程序源码同步') {
            steps {
                sh 'mkdir -p AndroidSampleApp'        
                dir(&quot;AndroidSampleApp&quot;){
                    git branch:'master', url:'https://gitee.com/sfboy/AndroidSampleApp.git'
                }

            }
        }

        stage('安卓编译打包') {
            steps {
                sh '''
                    . ~/.bash_profile
                    cd AndroidSampleApp
                    sh gradlew clean assembleDebug
                '''
            }
        }


        stage('安卓部署') {
            steps {
                sh '''
                    . ~/.bash_profile
                    cd AndroidSampleApp
                    apk=app/build/outputs/apk/debug/app-debug.apk
                    {
                        #try: 卸载现有的安卓app
                        adb uninstall com.appsflyer.androidsampleapp
                    } || {
                        #catch
                        echo 'no com.appsflyer.androidsampleapp package'
                    }

                    #安装安卓app
                    adb install $apk
                '''
            }
        }

        stage('自动测试程序源码同步') {
            steps {
                sh 'mkdir -p iAppBVT_Python'
                dir(&quot;iAppBVT_Python&quot;){
                    git branch:'master', url:'https://gitee.com/sfboy/iAppBVT_Python.git'
                }
            }
        }

        stage('运行自动化测试') {
            steps {
                sh '''
                    . ~/.bash_profile

                    cd iAppBVT_Python

                    #更新python依赖库
                    pip3 install -r requirements.txt

                    #运行自动化测试
                    pytest -sv test/bvt_test.py --tc-file  iAppBVT_Python.json --tc-format json
                '''
            }
        }

        stage('发布测试包') {
            steps {
                archiveArtifacts artifacts: 'AndroidSampleApp/app/build/outputs/apk/debug/app-debug.apk'
            }
        }

        stage('通知邮件') {
            steps {
                emailext body: '$DEFAULT_CONTENT', recipientProviders: [[$class: 'RequesterRecipientProvider']], subject: '$DEFAULT_SUBJECT'
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后保存即可，Pipline的配置相对还是比较简单的，构建结果如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210116234809142-1591536532.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Pipeline可以很方便实现流水式的持续交付，执行阶段通过视图一目了然。更过详细的资料可以访问官方文档 &lt;a href=&quot;https://jenkins.io/doc/book/pipeline/&quot; target=&quot;_blank&quot;&gt;https://jenkins.io/doc/book/pipeline/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Jan 2021 15:49:00 +0000</pubDate>
<dc:creator>尘世风</dc:creator>
<og:description>#一、引言 Jenkins 2.x的精髓是Pipeline as Code，那为什么要用Pipeline呢？jenkins1.0也能实现自动化构建，但Pipeline能够将以前project中的配置信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feng0815/p/14287056.html</dc:identifier>
</item>
</channel>
</rss>