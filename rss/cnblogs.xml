<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>粉丝请看 | 里程碑以及未来的方向 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/11796230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/11796230.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;感谢有你，我们一起创造了传奇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;去年七月开始写微信公众号，截至昨天一共发了63篇文章，实现了当初定下的粉丝5000的目标，今天想和大家一起分享这份快乐，顺便聊一聊公众号未来的发展方向&lt;/p&gt;
&lt;h2 id=&quot;了解套路如何快速涨粉&quot;&gt;了解套路，如何快速涨粉&lt;/h2&gt;
&lt;p&gt;曾见到很多技术方向公众号，在一年的时间内做到粉丝数万，看了所发我文章，觉得不可思议，偶然机会，听一分享，得到快速涨粉的秘诀&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每天输出优质内容&lt;/li&gt;
&lt;li&gt;各公众号之间互推&lt;/li&gt;
&lt;li&gt;通过第三方引流&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;各公众号主之间互推是涨粉最快的方式，所以会经常看到不同的公众号都在发推荐其他公众号的文章，其中原因便在这里&lt;/p&gt;
&lt;p&gt;写原创文章，耗时耗力，很难保证每天更新，因此会有号主联盟这样的组织存在，大家互相推荐优质文章，所以会在不同的公众号看到相同内容的文章&lt;/p&gt;
&lt;p&gt;第三方引流就是通过第三方渠道往公众号引流，例如某些网站必须要关注公众号才能登陆，或者是你的内容同时发在多个平台上，文章内引导用户关注公众号，前者门槛较高，后者效果不好&lt;/p&gt;
&lt;h2 id=&quot;初心不改坚持内容为王&quot;&gt;初心不改，坚持内容为王&lt;/h2&gt;
&lt;p&gt;了解清楚套路后，仔细审视了下自己的情况，运维咖啡吧&lt;strong&gt;坚持内容为王&lt;/strong&gt;，在创建之初就定下了只发原创文章的规则，所以不考虑转发文章，这也是我更新频率不高的原因，做到每周更新已耗费了很大的精力&lt;/p&gt;
&lt;p&gt;但我深知一个人的能力是有限的，大家的能力才是无穷的，未来不会一味的坚持个人原创，如果有些内容确实很棒，我也会联系作者，征得同意后分享，但会原创为主，控制分享和原创的比例，希望不是一种打扰&lt;/p&gt;
&lt;p&gt;针对公众号之间的互推，个人觉得第一很难找到方向匹配又内容精良的公众号，第二对读者也是一种打扰，所以至今也是一次都没有互推过&lt;/p&gt;
&lt;p&gt;未来依然也会坚持这个原则，为读者负责，不会随意互推，如果有一天推荐了垃圾的内容，那或许是向生活低了头，取关随意，感恩支持&lt;/p&gt;
&lt;p&gt;依然坚持，不发广告，不写软文&lt;/p&gt;
&lt;h2 id=&quot;跳出技术聊聊诗和远方&quot;&gt;跳出技术，聊聊诗和远方&lt;/h2&gt;
&lt;p&gt;当我向朋友推荐我的公众号时，朋友告诉我，全是硬核技术干货，虽写的细致，但枯燥乏味，想了一下确实如此，生活不只能有技术，还应包含诗和远方，有态度，有温度&lt;/p&gt;
&lt;p&gt;试着推荐一些自己用的顺手的工具，讲讲自己平淡却不平凡成长，亦或是聊一些琐碎的日常，这些可能都会成为未来运维咖啡吧内容的一部分&lt;/p&gt;
&lt;p&gt;努力让咖啡吧变得有趣，努力成为你公众号列表里必读的那个&lt;/p&gt;
&lt;h2 id=&quot;靠爱发电感恩大家支持&quot;&gt;靠爱发电，感恩大家支持&lt;/h2&gt;
&lt;p&gt;有很多小伙伴非常好奇，写公众号赚钱吗？持续输出的动力在哪里？&lt;/p&gt;
&lt;p&gt;赚钱吗？赚啊！公众号粉丝超过500可以开通流量主，开通之后可以选择在文章中间或者文章底部加入广告，广告有点击，就会有收入&lt;/p&gt;
&lt;p&gt;为了尽量减少对读者的打扰，我只开通了文章底部的广告，截至目前，运维咖啡吧的广告收入总计是561.44元&lt;/p&gt;
&lt;p&gt;虽然这些收入还抵不上一天的工资，但它确带给了我满满的成就感，这就像你在Github开源的项目获得了star一样，是对成果的肯定&lt;/p&gt;
&lt;p&gt;相信有写过博客的朋友都知道，靠爱发电，很难坚持，有些外在的激励是很有必要的，所以在这里我也厚着脸皮请求各位，如果觉得文章不错，对自己有帮助，还请选择自己能够接收的方式不吝支持，或点赞，或转发，或赞赏&lt;/p&gt;
&lt;p&gt;我会把大家的所有鼓励和支持都装进行囊&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;坚持内容为王不变，持续多元输出，运维咖啡吧，背上行囊，继续前行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/wx.qrcode.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Nov 2019 00:32:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>感谢有你，我们一起创造了传奇 去年七月开始写微信公众号，截至昨天一共发了63篇文章，实现了当初定下的粉丝5000的目标，今天想和大家一起分享这份快乐，顺便聊一聊公众号未来的发展方向 了解套路，如何快速</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/37Y37/p/11796230.html</dc:identifier>
</item>
<item>
<title>大家都说好用的 Python 命令行库：click - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11795284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11795284.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201911/759200-20191104220305180-1564290170.jpg&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;br/&gt;作者：HelloGitHub-&lt;strong&gt;Prodesire&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 的《讲解开源项目》系列，项目地址：https://github.com/HelloGitHub-Team/Article&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;在本系列前面几篇文章中，我们分别介绍了 &lt;code&gt;argparse&lt;/code&gt; 和 &lt;code&gt;docopt&lt;/code&gt; 的主要功能和用法。它们各具特色，都能出色地完成命令行任务。&lt;code&gt;argparse&lt;/code&gt; 是面向过程的，需要先设置解析器，再定义参数，再解析命令行，最后实现业务逻辑。而 &lt;code&gt;docopt&lt;/code&gt; 先用声明式的语法定义出参数，再过程式地解析命令行和实现业务逻辑。在一些人看来，这些方式都不够优雅。&lt;/p&gt;
&lt;p&gt;而今天要介绍的 &lt;a href=&quot;https://click.palletsprojects.com/&quot;&gt;click&lt;/a&gt; 则是用一种你很熟知的方式来玩转命令行。命令行程序本质上是定义参数和处理参数，而处理参数的逻辑一定是与所定义的参数有关联的。那可不可以用函数和装饰器来实现处理参数逻辑与定义参数的关联呢？而 &lt;code&gt;click&lt;/code&gt; 正好就是以这种方式来使用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;本系列文章默认使用 Python 3 作为解释器进行讲解。
若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二介绍&quot;&gt;二、介绍&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://click.palletsprojects.com/&quot;&gt;click&lt;/a&gt; 是一个以尽可能少的代码、以组合的方式创建优美的命令行程序的 Python 包。它有很高的可配置性，同时也能开箱即用。&lt;/p&gt;
&lt;p&gt;它旨在让编写命令行工具的过程既快速又有趣，还能防止由于无法实现预期的 CLI API 所产生挫败感。它有如下三个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任意嵌套命令&lt;/li&gt;
&lt;li&gt;自动生成帮助&lt;/li&gt;
&lt;li&gt;支持运行时延迟加载子命令&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三快速开始&quot;&gt;三、快速开始&lt;/h2&gt;
&lt;h3 id=&quot;业务逻辑&quot;&gt;3.1 业务逻辑&lt;/h3&gt;
&lt;p&gt;首先定义业务逻辑，是不是感觉到有些难以置信呢？&lt;/p&gt;
&lt;p&gt;不论是 &lt;code&gt;argparse&lt;/code&gt; 还是 &lt;code&gt;docopt&lt;/code&gt;，业务逻辑都是被放在最后一步，但 &lt;code&gt;click&lt;/code&gt; 却是放在第一步。细想想 &lt;code&gt;click&lt;/code&gt; 的这种方式才更符合人的思维吧？不论用什么命令行框架，我们最终关心的就是实现业务逻辑，其它的能省则省。&lt;/p&gt;
&lt;p&gt;我们以官方示例为例，来介绍 &lt;code&gt;click&lt;/code&gt; 的用法和哲学。假设命令行程序的输入是 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;count&lt;/code&gt;，功能是打印指定次数的名字。&lt;/p&gt;
&lt;p&gt;那么在 &lt;code&gt;hello.py&lt;/code&gt; 中，很容易写出如下代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def hello(count, name):
    &quot;&quot;&quot;Simple program that greets NAME for a total of COUNT times.&quot;&quot;&quot;
    for x in range(count):
        click.echo('Hello %s!' % name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的逻辑很简单，就是循环 &lt;code&gt;count&lt;/code&gt; 次，使用 &lt;code&gt;click.echo&lt;/code&gt; 打印 &lt;code&gt;name&lt;/code&gt;。其中，&lt;code&gt;click.echo&lt;/code&gt; 和 &lt;code&gt;print&lt;/code&gt; 的作用相似，但功能更加强大，能处理好 Unicode 和 二进制数据的情况。&lt;/p&gt;
&lt;h3 id=&quot;定义参数&quot;&gt;3.2 定义参数&lt;/h3&gt;
&lt;p&gt;很显然，我们需要针对 &lt;code&gt;count&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 来定义它们所对应的参数信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;count&lt;/code&gt; 对应为命令行选项 &lt;code&gt;--count&lt;/code&gt;，类型为数字，我们希望在不提供参数时，其默认值是 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; 对应为命令行选项 &lt;code&gt;--name&lt;/code&gt;，类型为字符串，我们希望在不提供参数时，能给人提示&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用 &lt;code&gt;click&lt;/code&gt;，就可以写成下面这样：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from click import click

@click.command()
@click.option('--count', default=1, help='Number of greetings.')
@click.option('--name', prompt='Your name',
              help='The person to greet.')
def hello(count, name):
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的示例中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用装饰器的方式，即定义了参数，又将之与处理逻辑绑定，这真是优雅。和 &lt;code&gt;argparse&lt;/code&gt;、&lt;code&gt;docopt&lt;/code&gt; 比起来，就少了一步绑定过程&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;click.command&lt;/code&gt; 表示 &lt;code&gt;hello&lt;/code&gt; 是对命令的处理&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;click.option&lt;/code&gt; 来定义参数选项
&lt;ul&gt;&lt;li&gt;对于 &lt;code&gt;--count&lt;/code&gt; 来说，使用 &lt;code&gt;default&lt;/code&gt; 来指定默认值。而由于默认值是数字，进而暗示 &lt;code&gt;--count&lt;/code&gt; 选项的类型为数字&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;--name&lt;/code&gt; 来说，使用 &lt;code&gt;prompt&lt;/code&gt; 来指定未输入该选项时的提示语&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;help&lt;/code&gt; 来指定帮助信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不论是装饰器的方式、还是各种默认行为，&lt;code&gt;click&lt;/code&gt; 都是像它的介绍所说的那样，让人尽可能少地编写代码，让整个过程变得快速而有趣。&lt;/p&gt;
&lt;h3 id=&quot;代码梳理&quot;&gt;3.3 代码梳理&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;click&lt;/code&gt; 的方式非常简单，我们将上文的代码汇总下，以有一个更清晰的认识：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# hello.py
import click

@click.command()
@click.option('--count', default=1, help='Number of greetings.')
@click.option('--name', prompt='Your name',
              help='The person to greet.')
def hello(count, name):
    &quot;&quot;&quot;Simple program that greets NAME for a total of COUNT times.&quot;&quot;&quot;
    for x in range(count):
        click.echo('Hello %s!' % name)

if __name__ == '__main__':
    hello()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若我们指定次数和名字：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3 hello.py --count 2 --name Eric
Hello Eric!
Hello Eric!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若我们什么都不指定，则会提示输入名字，并默认输出一次：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3 hello.py
Your name: Eric
Hello Eric!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以通过 &lt;code&gt;--help&lt;/code&gt; 参数查看自动生成的帮助信息：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Usage: hello.py [OPTIONS]

  Simple program that greets NAME for a total of COUNT times.

Options:
  --count INTEGER  Number of greetings.
  --name TEXT      The person to greet.
  --help           Show this message and exit.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;click&lt;/code&gt; 的思路非常简单，定义处理函数，通过它的装饰器来定义参数。使用装饰器的绝妙之处就在于把定义和绑定这两个步骤合为一个步骤，使得整个过程变得如丝般顺滑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;click&lt;/code&gt; 除了以 &lt;code&gt;Pythonic&lt;/code&gt; 的方式让命令行程序的实现变得更加优雅和好用外，还提供了比 &lt;code&gt;argparse&lt;/code&gt; 和 &lt;code&gt;docopt&lt;/code&gt; 都要强大的功能。在接下来几节中，我们将会逐步揭开它的面纱。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;『讲解开源项目系列』&lt;/strong&gt;——让对开源项目感兴趣的人不再畏惧、让开源项目的发起者不再孤单。跟着我们的文章，你会发现编程的乐趣、使用和发现参与开源项目如此简单。欢迎留言联系我们、加入我们，让更多人爱上开源、贡献开源～&lt;/p&gt;
</description>
<pubDate>Tue, 05 Nov 2019 00:31:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub Prodesire HelloGitHub 的《讲解开源项目》系列，项目地址：https://github.com/HelloGitHub Team/Article 一、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11795284.html</dc:identifier>
</item>
<item>
<title>kaldi中CD-DNN-HMM网络参数更新公式手写推导 - davidtym</title>
<link>http://www.cnblogs.com/talkaudiodev/p/11692611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/talkaudiodev/p/11692611.html</guid>
<description>&lt;p&gt;在基于DNN-HMM的语音识别中，DNN的作用跟GMM是一样的，即它是取代GMM的，具体作用是算特征值对每个三音素状态的概率，算出来哪个最大这个特征值就对应哪个状态。只不过以前是用GMM算的，现在用DNN算了。这是典型的多分类问题，所以输出层用的激活函数是softmax，损失函数用的是cross entropy（交叉熵）。不用均方差做损失函数的原因是在分类问题上它是非凸函数，不能保证全局最优解（只有凸函数才能保证全局最优解）。Kaldi中也支持DNN-HMM，它还依赖于上下文（context dependent, CD）,所以叫CD-DNN-HMM。在kaldi的nnet1中，特征提取用filterbank,每帧40维数据，默认取当前帧前后5帧加上当前帧共11帧作为输入，所以输入层维数是440(440 = 40*11)。同时默认有4个隐藏层，每层1024个网元，激活函数是sigmoid。今天我们看看网络的各种参数是怎么得到的（手写推导）。由于真正的网络比较复杂，为了推导方便这里对其进行了简化，只有一个隐藏层，每层的网元均为3，同时只有weight没有bias。这样网络如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191017184720130-1669196220.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中输入层3个网元为i1/i2/i3（i表示input），隐藏层3个网元为h1/h2/h3（h表示hidden），输出层3个网元为o1/o2/o3（o表示output）。隐藏层h1的输入为&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191024154855147-1820450960.jpg&quot; alt=&quot;&quot;/&gt; (q11等表示输入层和隐藏层之间的权值)，输出为&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191024154957007-1275613978.jpg&quot; alt=&quot;&quot;/&gt;。输出层o1的输入为&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191024155034451-521661749.jpg&quot; alt=&quot;&quot;/&gt;（w11等表示隐藏层和输出层之间的权值），输出为&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191024155121223-272449695.jpg&quot; alt=&quot;&quot;/&gt;。其他可类似推出。损失函数用交叉熵。今天我们看看网络参数（以隐藏层和输出层之间的w11以及输入层和隐藏层之间的q11为例）在每次迭代训练后是怎么更新的。先看隐藏层和输出层之间的w11。&lt;/p&gt;

&lt;p&gt;1，隐藏层和输出层之间的w11的更新&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191024180521440-1516355668.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 先分别求三个导数的值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191024180535257-1894303111.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191024180556809-735449767.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 所以最终的w11更新公式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191024180608525-1366208718.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2，输入层和隐藏层之间的q11的更新&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191025104114561-376181619.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先分别求三个导数的值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191025104131973-2058480796.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191025104144867-469655228.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以最终的q11更新公式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201910/1181527-20191025104156990-319569837.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上的公式推导中如有错误，烦请指出，非常感谢！&lt;/p&gt;
</description>
<pubDate>Tue, 05 Nov 2019 00:16:00 +0000</pubDate>
<dc:creator>davidtym</dc:creator>
<og:description>在基于DNN-HMM的语音识别中，DNN的作用跟GMM是一样的，即它是取代GMM的，具体作用是算特征值对每个三音素状态的概率，算出来哪个最大这个特征值就对应哪个状态。只不过以前是用GMM算的，现在用D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/talkaudiodev/p/11692611.html</dc:identifier>
</item>
<item>
<title>【java基础之异常】死了都要try，不淋漓尽致地catch我不痛快！ - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11796126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11796126.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;

&lt;h2 id=&quot;异常概念&quot;&gt;1.1 异常概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;异常&lt;/strong&gt; ：简单说就是不正常运行，最终导致JVM的非正常停止。&lt;/p&gt;
&lt;p&gt;在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;异常体系&quot;&gt;1.2 异常体系&lt;/h2&gt;
&lt;p&gt;异常机制其实是帮助我们&lt;strong&gt;找到&lt;/strong&gt;程序中的问题，异常的根类是&lt;code&gt;java.lang.Throwable&lt;/code&gt;，其下有两个子类：&lt;code&gt;java.lang.Error&lt;/code&gt;与&lt;code&gt;java.lang.Exception&lt;/code&gt;，平常所说的异常指&lt;code&gt;java.lang.Exception&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191006090230495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-A0NGTCB9-1570323592244)(img\异常体系.png)]&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Throwable中的常用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、 &lt;code&gt;public void printStackTrace()&lt;/code&gt;:打印异常的详细信息。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;2、 &lt;code&gt;public String getMessage()&lt;/code&gt;:获取发生异常的原因。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;提示给用户的时候,就提示错误原因。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;3、 &lt;code&gt;public String toString()&lt;/code&gt;:获取异常的类型和异常描述信息(不用)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出现异常,最简单的方式就是把异常的简单类名,拷贝到API中去查。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019101716021431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;异常分类&quot;&gt;1.3 异常分类&lt;/h2&gt;
&lt;p&gt;我们平常说的异常就是指&lt;code&gt;Exception&lt;/code&gt;，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常(Exception)的分类&lt;/strong&gt;:根据在编译时期还是运行时期去检查异常?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;编译时期异常&lt;/strong&gt;:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行时期异常&lt;/strong&gt;:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191006153720391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191006090354107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;​ [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yWbBNQxN-1570323592247)(img\异常的分类.png)]&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;异常的产生过程解析&quot;&gt;1.4 异常的产生过程解析&lt;/h2&gt;
&lt;p&gt;先运行下面的程序，程序会产生一个数组索引越界异常&lt;code&gt;ArrayIndexOfBoundsException&lt;/code&gt;。我们通过图解来解析下异常产生的过程。&lt;/p&gt;
&lt;p&gt;工具类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ArrayTools {
    // 对给定的数组通过给定的角标获取元素。
    public static int getElement(int[] arr, int index) {
        int element = arr[index];
        return element;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ExceptionDemo {
    public static void main(String[] args) {
        int[] arr = { 34, 12, 67 };
        intnum = ArrayTools.getElement(arr, 4)
        System.out.println(&quot;num=&quot; + num);
        System.out.println(&quot;over&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述程序执行过程图解：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191006090436252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Java异常处理的五个关键字：&lt;code&gt;try&lt;/code&gt;、&lt;code&gt;catch&lt;/code&gt;、&lt;code&gt;finally&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt;、&lt;code&gt;throws&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;抛出异常throw&quot;&gt;2.1 抛出异常throw&lt;/h2&gt;
&lt;p&gt;在编写程序时，作为一个优秀的程序员必须要考虑程序出现问题的情况。举个栗子，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。这个时候throw就派上用场了！&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;在java中，提供了一个&lt;strong&gt;throw&lt;/strong&gt;关键字，Throw用来抛出一个指定的异常对象。从而可以&lt;/p&gt;
&lt;p&gt;1、创建一个异常对象。封装一些提示信息(信息可以自己编写)。&lt;/p&gt;
&lt;p&gt;2、通过关键字&lt;code&gt;throw&lt;/code&gt;就可以将这个异常对象告知给调用者，还可以将这个异常对象传递到调用者处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;throw小结&quot;&gt;&lt;span&gt;throw小结&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;throw&lt;/code&gt;&lt;strong&gt;用在方法内&lt;/strong&gt;，后面接一个&lt;strong&gt;异常对象&lt;/strong&gt;，使用格式为&lt;code&gt;throw new 异常类名(参数);&lt;/code&gt;，将这个异常对象传递到调用者处，并结束当前方法的执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;throw使用的格式如下&lt;/strong&gt;：&lt;br/&gt;~~~java&lt;br/&gt;throw new NullPointerException(&quot;要访问的arr数组不存在&quot;);&lt;/p&gt;
&lt;p&gt;throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;);&lt;br/&gt;~~~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用throw的实例使用&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThrowDemo {
    public static void main(String[] args) {
        //创建一个数组 
        int[] arr = {2,4,52,2};
        //根据索引找对应的元素 
        int index = 4;
        int element = getElement(arr, index);

        System.out.println(element);
        System.out.println(&quot;over&quot;);
    }
    /*
     * 根据 索引找到数组中对应的元素
     */
    public static int getElement(int[] arr,int index){ 
        //判断  索引是否越界
        if(index&amp;lt;0 || index&amp;gt;arr.length-1){
             /*
             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。
             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 
              */
             throw new ArrayIndexOutOfBoundsException(&quot;哥们，角标越界了~~~&quot;);
        }
        int element = arr[index];
        return element;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;throw&lt;/code&gt;运行效果分析：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191006105950311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;再来看看不使用throw的实例使用的运行&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  public static void main(String[] args) {
        //创建一个数组
        int[] arr = {2,4,52,2};
        //根据索引找对应的元素
        int index = 4; //注意索引4已经越界了
        int ele=arr[index];

        System.out.println(ele);
        System.out.println(&quot;over&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191006110517797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这样一对比&lt;code&gt;throw&lt;/code&gt;的优势就不言而喻了~&lt;/p&gt;
&lt;h2 id=&quot;objects非空判断&quot;&gt;2.2 Objects非空判断&lt;/h2&gt;
&lt;p&gt;还记得&lt;code&gt;Objects&lt;/code&gt;类吗，曾经提到过它由一些静态的实用方法组成，这些方法是&lt;code&gt;null-save&lt;/code&gt;（空指针安全的）或&lt;code&gt;null-tolerant&lt;/code&gt;（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; T requireNonNull(T obj)&lt;/code&gt;:查看指定引用对象不是null。&lt;/p&gt;
&lt;p&gt;查看源码发现这里对为null的进行了抛出异常操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static &amp;lt;T&amp;gt; T requireNonNull(T obj) {
    if (obj == null)
        throw new NullPointerException();
    return obj;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;声明异常throws&quot;&gt;2.3 声明异常throws&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果产生了问题，我们就会&lt;code&gt;throw&lt;/code&gt;将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。&lt;/p&gt;
&lt;p&gt;那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用&lt;code&gt;throws&lt;/code&gt;声明处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;声明异常&lt;/strong&gt;：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。&lt;/p&gt;
&lt;h4 id=&quot;throws小结&quot;&gt;&lt;span&gt;throws小结&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;关键字&lt;strong&gt;throws&lt;/strong&gt;运用于&lt;strong&gt;方法声明之上&lt;/strong&gt;,&lt;code&gt;throws&lt;/code&gt;格式为&lt;code&gt;修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{ }&lt;/code&gt;，用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;声明异常的代码演示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThrowsDemo {
    public static void main(String[] args) throws FileNotFoundException {
        read(&quot;a.txt&quot;);
    }

    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明
    public static void read(String path) throws FileNotFoundException {
        if (!path.equals(&quot;a.txt&quot;)) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException(&quot;文件不存在&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;throws&lt;/code&gt;用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在&lt;code&gt;throws&lt;/code&gt;后面可以写多个异常类，用逗号隔开。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThrowsDemo2 {
    public static void main(String[] args) throws IOException {
        read(&quot;a.txt&quot;);
    }

    public static void read(String path)throws FileNotFoundException, IOException {
        if (!path.equals(&quot;a.txt&quot;)) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException(&quot;文件不存在&quot;);
        }
        if (!path.equals(&quot;b.txt&quot;)) {
            throw new IOException();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;throw-和-throws-的区别小结&quot;&gt;&lt;span&gt;throw 和 throws 的区别小结&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;throw：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、表示方法内抛出某种异常对象&lt;br/&gt;2、如果异常对象是&lt;code&gt;非 RuntimeException&lt;/code&gt; 则需要在方法申明时加上该异常的抛出 即需要加上 &lt;code&gt;throws&lt;/code&gt; 语句 或者 在方法体内 &lt;code&gt;try catch&lt;/code&gt; 处理该异常，否则编译报错&lt;br/&gt;3、执行到 &lt;code&gt;throw&lt;/code&gt; 语句则后面的语句块不再执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;throws：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1、方法的定义上使用 &lt;code&gt;throws&lt;/code&gt; 表示这个方法可能抛出某种异常&lt;br/&gt;2、需要由方法的调用者进行异常处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;捕获异常trycatch&quot;&gt;2.4 捕获异常try…catch&lt;/h2&gt;
&lt;p&gt;如果异常出现的话,会立刻终止程序,所以我们得处理异常:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;该方法不处理,而是声明抛出,由该方法的调用者来处理(&lt;code&gt;throws&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;在方法中使用&lt;code&gt;try-catch&lt;/code&gt;的语句块来处理异常。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;try-catch&lt;/strong&gt;的方式就是捕获异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;捕获异常&lt;/strong&gt;：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。&lt;/p&gt;
&lt;p&gt;捕获异常语法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try{
     编写可能会出现异常的代码
}catch(异常类型  e){
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;：该代码块中编写可能产生异常的代码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;catch&lt;/code&gt;：用来进行某种异常的捕获，实现对捕获到的异常进行处理。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意:&lt;code&gt;try&lt;/code&gt;和&lt;code&gt;catch&lt;/code&gt;都不能单独使用,必须连用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;演示如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TryCatchDemo {
    public static void main(String[] args) {
        try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。
            read(&quot;b.txt&quot;);
        } catch (FileNotFoundException e) {// 括号中需要定义什么呢？
            //try中抛出的是什么异常，在括号中就定义什么异常类型
            System.out.println(e);
        }
        System.out.println(&quot;over&quot;);
    }
    /*
     *
     * 我们 当前的这个方法中 有异常  有编译期异常
     */
    public static void read(String path) throws FileNotFoundException {
        if (!path.equals(&quot;a.txt&quot;)) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException(&quot;文件不存在&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何获取异常信息：&lt;/p&gt;
&lt;p&gt;Throwable类中定义了一些查看方法:&lt;/p&gt;
&lt;p&gt;1、 &lt;code&gt;public String getMessage()&lt;/code&gt;:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。&lt;/p&gt;
&lt;p&gt;2、 &lt;code&gt;public String toString()&lt;/code&gt;:获取异常的类型和异常描述信息(不用)。&lt;/p&gt;
&lt;p&gt;3、 &lt;code&gt;public void printStackTrace()&lt;/code&gt;:打印异常的跟踪栈信息并输出到控制台。&lt;/p&gt;
&lt;p&gt;​ &lt;em&gt;包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;finally-代码块&quot;&gt;2.4 finally 代码块&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;finally&lt;/strong&gt;：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而&lt;code&gt;finally&lt;/code&gt;就是解决这个问题的，在&lt;code&gt;finally&lt;/code&gt;代码块中存放的代码都是一定会被执行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么时候的代码必须最终执行？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们在&lt;code&gt;try&lt;/code&gt;语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;finally的语法:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;try...catch....finally&lt;/code&gt;:自身需要处理异常,最终还得关闭资源。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意:&lt;code&gt;finally&lt;/code&gt;不能单独使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如在&lt;code&gt;IO&lt;/code&gt;流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finally&lt;/code&gt;代码参考如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TryCatchDemo4 {
    public static void main(String[] args) {
        try {
            read(&quot;a.txt&quot;);
        } catch (FileNotFoundException e) {
            //抓取到的是编译期异常  抛出去的是运行期 
            throw new RuntimeException(e);
        } finally {
            System.out.println(&quot;不管程序怎样，这里都将会被执行。&quot;);
        }
        System.out.println(&quot;over&quot;);
    }
    /*
     *
     * 我们 当前的这个方法中 有异常  有编译期异常
     */
    public static void read(String path) throws FileNotFoundException {
        if (!path.equals(&quot;a.txt&quot;)) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException(&quot;文件不存在&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;finally-代码块与return语句&quot;&gt;2.5 finally 代码块与return语句&lt;/h2&gt;
&lt;p&gt;还有个特别重要的点就是在&lt;code&gt;try&lt;/code&gt;块或&lt;code&gt;catch&lt;/code&gt;块中遇到&lt;code&gt;return&lt;/code&gt;语句时，&lt;span&gt;f&lt;strong&gt;inally语句块将在方法返回之前被执行&lt;/strong&gt;&lt;/span&gt;，另外&lt;code&gt;finally&lt;/code&gt;语句中也可以有&lt;code&gt;return&lt;/code&gt;语句，但是尽量避免有&lt;code&gt;return&lt;/code&gt;语句（会报警告）&lt;/p&gt;
&lt;h2 id=&quot;异常注意事项&quot;&gt;2.6 异常注意事项&lt;/h2&gt;
&lt;p&gt;多个异常使用捕获又该如何处理呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;多个异常分别处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;多个异常一次捕获，多次处理。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;多个异常一次捕获一次处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;一般我们是使用一次捕获多次处理方式，格式如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try{
     编写可能会出现异常的代码
}catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意:这种异常处理方式，要求多个&lt;code&gt;catch&lt;/code&gt;中的异常不能相同，并且若&lt;code&gt;catch&lt;/code&gt;中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的&lt;code&gt;catch&lt;/code&gt;处理，父类异常在下面的&lt;code&gt;catch&lt;/code&gt;处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;异常注意小结&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运行时异常被抛出可以不处理。即不捕获也不声明抛出。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果&lt;code&gt;finally&lt;/code&gt;有&lt;code&gt;return&lt;/code&gt;语句,永远返回&lt;code&gt;finally&lt;/code&gt;中的结果,避免该情况. 上面也提到过！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;概述&quot;&gt;3.1 概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么需要自定义异常类:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;中不同的异常类,分别表示着某一种具体的异常情况,在开发中总是有些异常情况是&lt;code&gt;SUN&lt;/code&gt;没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如程序员头发数为负数、小明考试成绩负数问题等等。&lt;/p&gt;
&lt;p&gt;在之前程序代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如程序员老婆数量为负数、程序员老王智商为负数问题.那么能不能自己定义异常呢？答案是能滴！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是自定义异常类:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开发中根据自己业务的异常情况来定义异常类.&lt;/p&gt;
&lt;p&gt;自定义一个业务逻辑异常: &lt;strong&gt;RegisterException&lt;/strong&gt;。一个注册异常类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常类如何定义:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自定义一个编译期异常: 自定义类 并继承于&lt;code&gt;java.lang.Exception&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;自定义一个运行时期的异常类:自定义类 并继承于&lt;code&gt;java.lang.RuntimeException&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;自定义异常练习&quot;&gt;3.2 自定义异常练习&lt;/h2&gt;
&lt;p&gt;比如说我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。&lt;/p&gt;
&lt;p&gt;首先定义一个登陆异常类&lt;code&gt;RegisterException&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 业务逻辑异常
public class RegisterException extends Exception {
    /**
     * 空参构造
     */
    public RegisterException() {
    }

    /**
     *
     * @param message 表示异常提示
     */
    public RegisterException(String message) {
        super(message);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo {
    // 模拟数据库中已存在账号
    private static String[] names = {&quot;bill&quot;,&quot;hill&quot;,&quot;jill&quot;};
   
    public static void main(String[] args) {     
        //调用方法
        try{
              // 可能出现异常的代码
            checkUsername(&quot;nill&quot;);
            System.out.println(&quot;注册成功&quot;);//如果没有异常就是注册成功
        }catch(RegisterException e){
            //处理异常
            e.printStackTrace();
        }
    }

    //判断当前注册账号是否存在
    //因为是编译期异常，又想调用者去处理 所以声明该异常
    public static boolean checkUsername(String uname) throws RegisterException {
        for (String name : names) {
            if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常
                throw new RegisterException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;);
            }
        }
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户名不存在，登录成功，效果分析如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191006161603347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;用户名存在，登录失败，效果分析如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191006161040730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;来和异常大干一场&quot;&gt;4、来！和异常大干一场&lt;/h2&gt;
&lt;p&gt;本篇文章到这里基本就看完了，博主我也不知道各位吸收了多少，我得对各位们负责鸭，不能讲完就完事了，于是还是觉得让各位巩固巩固一下比较好，如果各位能够做出下面这道典型的异常题，说明异常方面的知识对你来说就没多大问题了，如果觉得哪里还不是特别懂，可以及时告诉我，凡是看到了都会第一时间回复。好了，试想一下下面程序运行结果是啥~&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.Expetion;

public class TestException {
    public TestException() {
    }
    boolean testEx() throws Exception {
        boolean ret = true;
        try {
            ret = testEx1();
        } catch (Exception e) {
            System.out.println(&quot;testEx, catch exception&quot;);
            ret = false;
            throw e;
        } finally {
            System.out.println(&quot;testEx, finally; return value=&quot; + ret);
            return ret;
        }
    }
 
    boolean testEx1() throws Exception {
        boolean ret = true;
        try {
            ret = testEx2();
            if (!ret) {
                return false;
            }
            System.out.println(&quot;testEx1111, at the end of try&quot;);
            return ret;
        } catch (Exception e) {
            System.out.println(&quot;testEx1111, catch exception&quot;);
            ret = false;
            throw e;
        } finally {
            System.out.println(&quot;testEx1111, finally; return value=&quot; + ret);
            return ret;
        }
    }
 
    boolean testEx2() throws Exception {
        boolean ret = true;
        try {
            int b = 12;
            int c;
            for (int i = 2; i &amp;gt;= -2; i--) {
                c = b / i;
                System.out.println(&quot;i=&quot; + i);
            }
            return true;
        } catch (Exception e) {
            System.out.println(&quot;testEx2222, catch exception&quot;);
            ret = false;
            throw e;
        } finally {
            System.out.println(&quot;testEx2222, finally; return value=&quot; + ret);
            return ret;
        }
    }
 
    public static void main(String[] args) {
        TestException testException1 = new TestException();
        try {
            testException1.testEx();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;i=2
i=1
testEx2222, catch exception
testEx2222, finally; return value=false
testEx1111, finally; return value=false
testEx, finally; return value=false&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果觉得哪里还不是特别懂，可以及时告诉我，凡是看到了都会第一时间回复！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到这里，很多小白同学依旧木有感受到博主“死了都要try，不淋漓尽致地catch我不痛快！”的那个feel，对咩？行，博主就满足满足小白的那个feel，feelfeel一下 ~=感受感受一下~&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; /**
     * 把多条数据的ResultSet的结果放到 List&amp;lt;T&amp;gt;中
     * @param rs  ResultSet结果集
     * @param obj java类的class
     * @return
     */
    public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; getResult(ResultSet rs, Class&amp;lt;T&amp;gt; obj) {
        try {
            List&amp;lt;T&amp;gt; list = new ArrayList&amp;lt;T&amp;gt;();
            //ResultSetMetaData 有关 ResultSet 中列的名称和类型的信息。
            ResultSetMetaData metaData = rs.getMetaData();
            //获取总的列数
            int count = metaData.getColumnCount();
            //遍历ResultSet
            while (rs.next()) {
                //---创建对象实例
                T instance = obj.newInstance();
                for (int i = 1; i &amp;lt;= count; i++) {
                    //---获取列名
                    String name = metaData.getColumnName(i);
                    // 改变列名格式成 java 命名格式 主要是针对 _ 分割的情况  如user_id
                    name = toJavaField(name);
                    //---获取类型
                    Class&amp;lt;?&amp;gt; type = obj.getDeclaredField(name).getType();
                    //---获取setter方法
                    // 首字母大写
                    String replace = name.substring(0, 1).toUpperCase() + name.substring(1);
                    Method setMethod = obj.getMethod(&quot;set&quot; + replace, type);

                    //---判断读取数据的类型
                    if (type.isAssignableFrom(String.class)) {
                        setMethod.invoke(instance, rs.getString(i));
                    } else if (type.isAssignableFrom(int.class) || type.isAssignableFrom(Integer.class)) {
                        setMethod.invoke(instance, rs.getInt(i));
                    } else if (type.isAssignableFrom(Boolean.class) || type.isAssignableFrom(boolean.class)) {
                        setMethod.invoke(instance, rs.getBoolean(i));
                    } else if (type.isAssignableFrom(Date.class)) {
                        setMethod.invoke(instance, rs.getDate(i));
                    }
                }
                list.add(instance);
            }
            return list;

        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (InstantiationException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (SecurityException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IllegalArgumentException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (Exception e) {
            // TODO: handle exception
        }

        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先不说看不看得懂了，以上代码设计&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102410482&quot;&gt;反射&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102175114&quot;&gt;泛型&lt;/a&gt;、异常~也就是try..catch~ 、String类、jdbc相关的知识，这些知识我大部分都写过文章了，有兴趣的小白同学就直接点蓝色字体进入文章。咳咳...言归正传，有木有发现以上代码中使用的就是一次捕获多次处理方式，格式如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try{
     编写可能会出现异常的代码
}catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意:这种异常处理方式，要求多个&lt;code&gt;catch&lt;/code&gt;中的异常不能相同，并且若&lt;code&gt;catch&lt;/code&gt;中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的&lt;code&gt;catch&lt;/code&gt;处理，父类异常在下面的&lt;code&gt;catch&lt;/code&gt;处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这已经是第二次写到了，所以各位找到不淋漓尽致地catch不痛快的feel了咩？&lt;/p&gt;
&lt;p&gt;最后，推荐阅读本专栏的下两篇java文章~有兴趣的同学可以了解一下~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102409146&quot;&gt;【java基础之多态】理解多态的向上向下转型从“妈妈我想吃烤山药”讲起&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102375196&quot;&gt;【java基础】java继承从“我爸是李刚”讲起&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028085725979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Nov 2019 23:55:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>@[toc] 1、异常 1.1 异常概念 异常 ：简单说就是不正常运行，最终导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11796126.html</dc:identifier>
</item>
<item>
<title>消息队列的一些知识 - 杨冠标</title>
<link>http://www.cnblogs.com/yanggb/p/11722407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanggb/p/11722407.html</guid>
<description>&lt;p&gt;这里总结一些MQ（Message Queue，消息队列）的相关知识。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;消息队列的优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解耦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在传统模式下，系统之间的耦合性太强，比如系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码。&lt;/p&gt;
&lt;p&gt;如果将消息写入消息队列，需要消息的系统自己从消息队列中订阅，在D系统接入的时候系统A也不需要做任何修改，达到了解耦的效果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;异步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在传统模式下，一些非必要的业务逻辑以同步的方式运行，需要等待上一个业务逻辑执行完毕才能开始执行下一个业务逻辑，耗费等待的时间。&lt;/p&gt;
&lt;p&gt;如果将消息写入消息队列，非必要的业务逻辑就可以以异步的方式运行，加快了服务响应的速度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;削峰&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在传统模式下，当并发量大的时候，所有的请求都会直接怼到数据库，造成数据库连接异常，甚至宕机。&lt;/p&gt;
&lt;p&gt;如果将消息写入消息队列，则系统A可以慢慢地按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;消息队列的缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。一个使用了MQ的项目，如果连MQ的缺点都没有考虑过，就把MQ引进去了，那就会给自己的项目带来风险。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统可用性降低&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，系统也就挂了。用专业的术语来解释，就是系统的可用性降低了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统复杂性增加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;加了MQ之后要多考虑很多方面的问题，比如数据的一致性问题、如何避免消息被重复消费，如何保证消息可靠传输等。因此，需要考虑的东西更多，系统复杂性也就随着增加了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;消息队列的选型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然在项目中用了MQ，肯定事先要对业界流行的MQ进行调研，如果连每种MQ的优缺点都没了解清楚，随便选用了某种MQ，就容易给项目挖坑。另外，如果面试官问为什么项目上选用这种MQ的时候，你直接回答是领导决定的，这种回答就很LOW了。所以了解一下各种MQ的优缺点和使用的场景还是有必要的。&lt;/p&gt;
&lt;p&gt;这里只简单说一下ActiveMQ、RabbitMQ、RocketMQ和Kafka四种MQ框架。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更新频率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要了解各个MQ方案的更新频率，可以上各个MQ的官方社区去看。&lt;/p&gt;
&lt;p&gt;简单了解一下就是，ActiveMQ几个月才发一次版本，据说研究重心在他们的下一代产品Apollo；RabbitMQ的版本发布比ActiveMQ频繁很多；RocketMQ和Kafka也比ActiveMQ活跃的多。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性能对比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用一个表格简单比较下各个MQ的性能。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;开发语言&lt;/td&gt;
&lt;td&gt;java&lt;/td&gt;
&lt;td&gt;erlang&lt;/td&gt;
&lt;td&gt;java&lt;/td&gt;
&lt;td&gt;scala&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;单机吞吐量&lt;/td&gt;
&lt;td&gt;万级&lt;/td&gt;
&lt;td&gt;万级&lt;/td&gt;
&lt;td&gt;10万级&lt;/td&gt;
&lt;td&gt;10万级&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;时效性&lt;/td&gt;
&lt;td&gt;ms级&lt;/td&gt;
&lt;td&gt;us级&lt;/td&gt;
&lt;td&gt;ms级&lt;/td&gt;
&lt;td&gt;ms级以内&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;可用性&lt;/td&gt;
&lt;td&gt;高(主从架构)&lt;/td&gt;
&lt;td&gt;高(主从架构)&lt;/td&gt;
&lt;td&gt;非常高(分布式架构)&lt;/td&gt;
&lt;td&gt;非常高(分布式架构)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;10&quot;&gt;&lt;td&gt;功能特性&lt;/td&gt;
&lt;td&gt;成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好&lt;/td&gt;
&lt;td&gt;基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富&lt;/td&gt;
&lt;td&gt;MQ功能比较完备，扩展性佳&lt;/td&gt;
&lt;td&gt;只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;MQ选型的简单总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.中小型软件公司，建议选RabbitMQ。一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。但是虽然RabbitMQ是开源的，国内能定制化开发erlang的程序员却很少。所幸的是RabbitMQ的社区十分活跃，通过社区可以解决开发过程中遇到的大部分Bug，这点对于中小型公司来说十分重要。不考虑RocketMQ和Kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以Kafka排除。不考虑RocketMQ的原因是，RocketMQ是阿里出品，一旦哪一天阿里放弃维护RocketMQ，中小型公司一般是抽不出人来进行RocketMQ的定制化开发的，因此不推荐。&lt;/p&gt;
&lt;p&gt;2.大型软件公司，根据具体使用在RocketMQ和Kafka之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对RocketMQ，大型软件公司也可以抽出人手对RocketMQ进行定制化开发，毕竟国内有能力改Java源码的人，还是相当多的。至于Kafka，根据业务场景选择，如果有日志采集功能，肯定是首选Kafka了。具体该选哪个，还是要看具体的使用场景。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;保证消息队列的高可用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前面说过了，引入消息队列后，系统的可用性会降低。在生产中，没人会使用单机模式的消息队列，因此了解消息队列的高可用是很必要的。实际上，要保证消息队列的高可用，需要对消息队列的集群模式有深刻了解。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RocketMQ保证消息队列的高可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以RocketMQ为例，他的集群就有多master模式、多master多slave异步复制模式和多master多slave同步双写模式。&lt;/p&gt;
&lt;p&gt;下面是一张RocketMQ多master多slave模式部署的架构图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842514/201911/842514-20191104222835503-2075740197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的实现方式其实和Kafka很像，只是Name Server集群在Kafka中是用Zookeeper代替，都是用来保存和发现Master和Slave用的。通信过程如下：Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server集群获取Topic路由信息，并向提供Topic服务的Broker Master建立长连接，且定时向Broker发送消息。Producer只能将消息发送到Broker Master，但是Consumer则不一样，它同时和提供Topic服务的Master和Slave建立长连接，既可以从Broker Master订阅消息，也可以从Broker Slave订阅消息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kafka保证消息队列的高可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直接上Kafka的拓补架构图来看Kafka的集群模式。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/842514/201911/842514-20191104223254995-225361607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干Broker（Kafka支持水平扩展，一般来说，Broker的数量越多，集群的吞吐率就越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举Leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到Broker，Consumer使用pull模式从broker订阅并消费消息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RabbitMQ保证消息队列的高可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;RabbitMQ也有普通集群和镜像集群模式，比较简单。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保证消息队列高可用性的简单总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要保证消息队列的高可用，需要从集群上入手，具体就是当消息队列中的一个节点炸了，其他的节点还能继续运行，保证消息队列整体能正常运行。&lt;/p&gt;
&lt;p&gt;另外，如果有相关的面试题，需要了解MQ集群架构并能叙述清楚架构中的逻辑关系。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;保证消息不被重复消费&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;保证消息不被重复消费，也就是保证消息队列的幂等性。这个问题可以认为是消息队列领域的基本问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;消息被重复消费的原因&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;无论是哪一种消息队列，造成消息被重复消费的原因都是类似的。在正常的情况下，消费者在消费消息完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同，例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，Kafka则实际上是有个offset的概念（每一个消息都有一个offset，Kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了）。而造成重复消费的原因，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;消息被重复消费的解决方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决方法有很多，其实就是单机服务里幂等性的问题，这里简单列举几个方法。&lt;/p&gt;
&lt;p&gt;1.唯一索引。如果拿到的消息是做数据库的insert操作，可以给这个消息做一个唯一主键，那么就算出现重复消费的情况，也会因为主键冲突而取消操作，有效避免数据库出现脏数据。&lt;/p&gt;
&lt;p&gt;2.原生幂等。如果拿到的消息是做Redis的set的操作，因为在Redis中set操作本来就算幂等操作，即无论set几次结果都是一样的，也就不怕消息被重复消费的问题了。&lt;/p&gt;
&lt;p&gt;3.全局状态机。准备一个第三方介质，来做一个消息消费的记录。以Redis为例，给消息分配一个全局id，只要消费过该消息，将&amp;lt;id,message&amp;gt;以K-V的形式写入Redis。在消费者开始消费前，先去Redis中查询有没有消费记录即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;保证消息消费的可靠性传输&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。如果无法做到可靠性传输，可能给公司带来千万级别的财产损失。&lt;/p&gt;
&lt;p&gt;而要保证消息消费的可靠性传输，每种MQ都要从三个角度来分析，分别是生产者弄丢数据、消息队列弄丢数据和消费者弄丢数据。&lt;/p&gt;
&lt;p&gt;这个内容太复杂了，暂时玩不转，等以后再补充，嘿嘿。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;保证消息的顺序性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要保证消息的顺序性，可以通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中（Kafka中就是Partition，RabbitMQ中就是Queue），然后只用一个消费者去消费该队列即可。&lt;/p&gt;
&lt;p&gt;另外，如果为了吞吐量，有多个消费者去消费，这时候要保证消息的顺序性，其实只要一个简单的重试就好了。比如微博，可以分为发微博、写评论和删除微博这三个异步操作。如果这时候有一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，就可以等一段时间再重试。等另一个消费者，先执行发微博的操作后，再执行写评论的操作，就可以成功。&lt;/p&gt;
&lt;p&gt;实际上，要保证消息的顺序性，大多数情况下只需要保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定的套路。&lt;/p&gt;

&lt;p&gt;&quot;慢慢大家会明白的，无法跟喜欢的人在一起，其实是人生的常态。&quot;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Nov 2019 23:43:00 +0000</pubDate>
<dc:creator>杨冠标</dc:creator>
<og:description>这里总结一些MQ（Message Queue，消息队列）的相关知识。 消息队列的优点 解耦 在传统模式下，系统之间的耦合性太强，比如系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanggb/p/11722407.html</dc:identifier>
</item>
<item>
<title>Rust入坑指南：有条不紊 - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/11795935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/11795935.html</guid>
<description>&lt;p&gt;随着我们的坑越来越多，越来越大，我们必须要对各种坑进行管理了。Rust为我们提供了一套坑务管理系统，方便大家有条不紊的寻找、管理、填埋自己的各种坑。&lt;/p&gt;
&lt;p&gt;Rust提供给我们一些管理代码的特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Packages：&lt;/strong&gt;Cargo的一个特性，帮助你进行构建、测试和共享crates&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Crates：&lt;/strong&gt;生成库或可执行文件的模块树&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modules&lt;/strong&gt;和&lt;strong&gt;use：&lt;/strong&gt;用于控制代码组织、范围和隐私路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Paths：&lt;/strong&gt;struct、function和module的命名方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们来具体看一下这些特性是如何帮助我们组织代码的。&lt;/p&gt;
&lt;h3 id=&quot;packages和crates&quot;&gt;Packages和Crates&lt;/h3&gt;
&lt;p&gt;package可以理解为一个项目，而crate可以理解为一个代码库。crate可以供多个项目使用。那我们的项目中package和crate是怎么定义的呢？&lt;/p&gt;
&lt;p&gt;之前我们总是通过IDEA来新建项目，今天我们换个方法，在命令行中使用cargo命令来创建。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cargo new hello-world
     Created binary (application) `hello-world` package
$ ls hello-world
Cargo.toml
src
$ ls hello-world/src
main.rs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们使用cargo创建项目后，只有两个文件，Cargo.toml和src目录下的main.rs。&lt;/p&gt;
&lt;p&gt;Cargo.toml是管理项目依赖的文件，每个Cargo.toml定义一个package。main.rs文件的存在表示package中包含一个二进制crate，它是二进制crate的入口文件，crate的名称和package相同。如果src目录下存在lib.rs文件，说明package中包含一个和package名称相同的库crate。&lt;/p&gt;
&lt;p&gt;一个package可以包含多个二进制crate，它们由src/lib目录下的文件定义。如果你的项目想引用他人的crate，可以在Cargo.toml文件中增加依赖。每个crate都有自己的命名空间，因此如果你引入了一个crate里面定义了一个名为hello的函数，你仍然可以在自己的crate中再定义一个名为hello的函数。&lt;/p&gt;
&lt;h3 id=&quot;module&quot;&gt;Module&lt;/h3&gt;
&lt;p&gt;Module帮助我们在crate中组织代码，同时Module也是封装代码的重要工具。接下来还是通过一个栗子来详细了解Module。&lt;/p&gt;
&lt;p&gt;前面我们说过，库crate定义在src/lib.rs文件中。这里首先创建一个包含了库crate的package:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cargo new --lib restaurant&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在src中定义一些module和函数。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们使用关键字&lt;code&gt;mod&lt;/code&gt;来定义Module，Module中可以继续定义Module或函数。这样我们就可以比较方便的把相关的函数放到一个Module中，并为Module命名，提高代码的可读性。另外Module中还可以定义struct和枚举。由于Module中可以嵌套定义子Module，最终我们定义出来的代码类似一个树形。&lt;/p&gt;
&lt;p&gt;那么如何访问Module中的函数呢？这就要提到Path了。这部分比较好理解，Module树相当于系统文件目录，而Path则是目录的路径。&lt;/p&gt;
&lt;h3 id=&quot;path&quot;&gt;Path&lt;/h3&gt;
&lt;p&gt;这里的路径和系统文件路径一样，都分为相对路径和绝对路径两种。其中绝对路径必须以&lt;code&gt;crate&lt;/code&gt;开头，因为它代码整个Module树的根节点。路径之间使用的是双冒号来表示引用。&lt;/p&gt;
&lt;p&gt;现在我来尝试在一个函数中调用add_to_waitlist函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1572276180/Blog/rust/05/rust5-1.png&quot; alt=&quot;05-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里不管用绝对路径还是相对路径都报错了，错误信息是模块hosting和函数add_to_waitlist是私有（private）的。我们先暂时放下这个错误，根据这里的错误提示，我们知道了当我们定义一个module时，默认情况下是私有的，我们可以通过这种方法来封装一些代码的实现细节。&lt;/p&gt;
&lt;p&gt;OK，回到刚才的问题，那我们怎么才能解决这个错误呢？地球人都知道应该把对应的模块与函数公开出来。Rust中标识模块或函数为公有的关键字是&lt;code&gt;pub&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们用pub关键字来把对应的模块和函数公开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1572277111/Blog/rust/05/rust5-2.png&quot; alt=&quot;05-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就可以在module外来调用module内的函数了。&lt;/p&gt;
&lt;h4 id=&quot;rust中的私有规则&quot;&gt;Rust中的私有规则&lt;/h4&gt;
&lt;p&gt;现在我们再回过头来看Rust中的一些私有规则，如果你试验了上面的例子，也许会有一些发现。&lt;/p&gt;
&lt;p&gt;Rust中私有规则适用于所有项（函数、方法、结构体、枚举、模块和常量），它们默认都是私有的。父模块中的项不能访问子模块中的私有项，而子模块中的项可以访问其祖辈（父模块及以上）中的项。&lt;/p&gt;
&lt;h4 id=&quot;struct和enum的私有性&quot;&gt;Struct和Enum的私有性&lt;/h4&gt;
&lt;p&gt;Struct和Enum的私有性略有不同，对于Struct来讲，我可以只将其中的某些字段设置为公有的，其他字段可以仍然保持私有。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;amp;str) -&amp;gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Change our mind about what bread we'd like
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而对于Enum，如果一个Enum是公有的，那么它的所有值都是公有的，因为私有的值没有意义。&lt;/p&gt;
&lt;h4 id=&quot;相对路径和绝对路径的选择&quot;&gt;相对路径和绝对路径的选择&lt;/h4&gt;
&lt;p&gt;这种选择不存在正确与否，只有是否合适。因此这里我们只是举例说明一些合适的情况。&lt;/p&gt;
&lt;p&gt;我们仍以上述代码为例，如果我们可以预见到以后需要把front_of_house模块和eat_at_restaurant函数移动到一个新的名为customer_experience的模块中，就应该使用相对路径，这样我们就对其进行调整。&lt;/p&gt;
&lt;p&gt;类似的，如果我们需要把eat_at_restaurant函数移动到dining模块中，那么我们选择绝对路径的话就不需要做调整。&lt;/p&gt;
&lt;p&gt;综上，我们需要对代码的优化方向有一些前瞻性，并以此来判断需要使用相对路径还是绝对路径。&lt;/p&gt;
&lt;p&gt;相对路径除了以当前模块开头外，还可以以super开头。它表示的是父级模块，类似于文件系统中的两个点(&lt;code&gt;..&lt;/code&gt;)。&lt;/p&gt;
&lt;h3 id=&quot;use关键字&quot;&gt;use关键字&lt;/h3&gt;
&lt;p&gt;绝对路径和相对路径可以帮助我们找到指定的函数，但用起来也非常的麻烦，每次都要写一大长串路径。还好Rust为我们提供了use关键字。在很多语言中都有import关键字，这里的use就有些类似于import。不过Rust会提供更加丰富的用法。&lt;/p&gt;
&lt;p&gt;use最基本的用法就是引入一个路径。我们就可以更加方便的使用这个路径下的一些方法：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个路径可以是绝对路径，也可以是相对路径，但如果是相对路径，就必须要以self开头。上面的例子可以写成：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;use self::front_of_house::hosting;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这与我们前面讲的相对路径似乎有些矛盾，Rust官方说会在之后的版本处理这个问题。&lt;/p&gt;
&lt;p&gt;use还可以更进一步，直接指向具体的函数或Struct或Enum。但习惯上我们使用函数时，use后面使用的是路径，这样可以在调用函数时知道它属于哪个模块；而在使用Struct/Enum时，则具体指向它们。当然，这只是官方建议的编程习惯，你也可以有自己的习惯，不过最好还是按照官方推荐或者是项目约定的规范比较好。&lt;/p&gt;
&lt;p&gt;对于同一路径下的某些子模块，在引入时可以合并为一行，例如：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;use std::io;
use std::cmp::Ordering;
// 等价于
use std::{cmp::Ordering, io};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有时我们还会遇到引用不同包下相同名称Struct的情况，这时有两种解决办法，一是不指定到具体的Struct，在使用时加上不同的路径；二是使用&lt;code&gt;as&lt;/code&gt;关键字，为Struct起一个别名。&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;use std::fmt;
use std::io;

fn function1() -&amp;gt; fmt::Result {
    // --snip--
}

fn function2() -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    // --snip--
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&amp;gt; Result {
    // --snip--
}

fn function2() -&amp;gt; IoResult&amp;lt;()&amp;gt; {
    // --snip--
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要导入某个路径下的全部模块或函数，可以使用&lt;code&gt;*&lt;/code&gt;来表示。当然我是非常不建议使用这种方法的，因为导入全部的话，如果出现名称冲突就会很难排查问题。&lt;/p&gt;
&lt;p&gt;对于外部的依赖包，我们需要先在Cargo.toml文件中添加依赖，然后就可以在代码中使用use来引入依赖库中的路径。Rust提供了一些标准库，即std下的库。在使用这些标准库时是不需要添加依赖的。&lt;/p&gt;
&lt;p&gt;有些同学看到这里可能要开始抱怨了，说好了介绍怎么拆分文件，到现在还是在一个文件里玩，这不是欺骗读者嘛。&lt;/p&gt;
&lt;p&gt;别急，这就开始拆分。&lt;/p&gt;
&lt;h3 id=&quot;开始拆分&quot;&gt;开始拆分&lt;/h3&gt;
&lt;p&gt;我们拿刚才的一段代码为例&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们可以把front_of_house模块下的内容拆分出去，需要在src目录下新建一个front_of_house.rs文件，然后把front_of_house模块下的内容写到文件中。lib.rs文件中，只需要声明front_of_house模块即可，不需要具体的定义。声明模块时，将花括号即内容改为分号就可以了。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;mod front_of_house;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以继续拆分front_of_house模块下的hosting模块和serving模块，这时需要新建一个名为front_of_house的文件件，在该文件夹下放置要拆分的模块的同名文件，把模块定义的内容写在文件中，front_of_house.rs文件同样只保留声明即可。&lt;/p&gt;
&lt;p&gt;拆分后的文件目录如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1572367091/Blog/rust/05/rust5-3.png&quot; alt=&quot;rust05-3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲了Rust中Package、Crate、Module、Path的概念和用法，有了这些基础，我们后面才有可能开发一些比较大的项目。&lt;/p&gt;
&lt;p&gt;ps：本文的代码示例均来自&lt;a href=&quot;https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html&quot;&gt;the book&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Mon, 04 Nov 2019 16:32:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>随着我们的坑越来越多，越来越大，我们必须要对各种坑进行管理了。Rust为我们提供了一套坑务管理系统，方便大家有条不紊的寻找、管理、填埋自己的各种坑。&lt;! more Rust提供给我们一些管理代码的特性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/11795935.html</dc:identifier>
</item>
<item>
<title>spring-boot-plus V1.4.0发布 集成用户角色权限部门管理 - spring-boot-plus</title>
<link>http://www.cnblogs.com/springbootplus/p/11795882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/springbootplus/p/11795882.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用户角色权限部门管理核心接口介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;shiro权限配置&quot;&gt;Shiro权限配置&lt;/h2&gt;
&lt;h2 id=&quot;数据库模型图&quot;&gt;数据库模型图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://spring-boot-plus.gitee.io/img/spring-boot-plus-db-diagram.png&quot; alt=&quot;spring-boot-plus数据库模型图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取验证码&quot;&gt;获取验证码&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;可配置是否启用验证码&lt;/li&gt;
&lt;li&gt;默认未启用&lt;/li&gt;
&lt;li&gt;如已启用验证码校验，登陆时，需传入verifyToken和code&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;验证码演示&quot;&gt;&lt;a href=&quot;http://localhost:8888/static/verifyCode.html&quot;&gt;验证码演示&lt;/a&gt;&lt;/h4&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring-boot-plus:
  # 是否启用ansi控制台输出有颜色的字体
  enable-ansi: true
  # 是否启用验证码
  enable-verify-code: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;enable-verify-code&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 启用验证码验证&lt;/p&gt;
&lt;h4 id=&quot;两种方式获取验证码&quot;&gt;两种方式获取验证码&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;验证码后台保存在Redis中，过期时间默认为5分钟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://springboot.plus/img/rbac/rbac-verification.png&quot; alt=&quot;验证码Swagger&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;方式一&quot;&gt;方式一：&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输出图片流到浏览器，验证码token输出到响应头&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;http://localhost:8888/verificationCode/getImage&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://spring-boot-plus.gitee.io/img/verifyCode.png&quot; alt=&quot;验证码图片&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;Response Headers
HTTP/1.1 200
verifyToken: 6515b4b798ce49e68b1e40f98ff8eb19&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;方式二&quot;&gt;方式二：&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;获取Base64编码图片和验证码token&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;http://localhost:8888/verificationCode/getBase64Image&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;code&quot;: 200,
  &quot;msg&quot;: &quot;操作成功&quot;,
  &quot;success&quot;: true,
  &quot;data&quot;: {
    &quot;image&quot;: &quot;data:image/png;base64,/9j/4AAQSkZJRgABAgAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAmAG4DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD1eQO6eakrSJknb8ynrjHy+nuCetV/tQRGcrPEOqyeYZEIzjk/MAfw/Gud1PxppdvqNzAba6EsLmN3EaEMynHc9OOv6cVV/wCE30ZNzRLqgY9QBGoP5GhUp22JSfY6tIrJ1LLP5RHG5dikfRgP5HvTJNLuHG5L6SUdUDORj0Oec/kPwqBNOljPmAGRdvPlsB0PQgjnp0xVeeNrK3luY/PKxRs7mM7DwM7TjOOn69PXNyS1uLR7MtKmoQuTcXEkQQHEgj8wED1xz34z709Gunb55oLpARuKoHC574BH6DoT6CqOm6lNe6XFcNPJGWBZEIDHIYj7x/z1H1Vl+ZseUGAysgTac+2OPpkDpng0oyU1zLZha6LIjuC7mGWCSJ85jXeAO2SoOf50iafuUobe3d8F1aOUjcMngZBHH9RUHnzqdyqjITkqxLAn15J5rlLz4kafaarLBNbXRMErRyYQMGwcHhn56D06Ct6dGpUdoK4npudY1mY5Ar6fcYPJKMGwPwWo1jtzLtQTO4PRYVb/ANm5rG0f4iaVqt2LZZ5bGV2CxiWPKtnPA+cgdB6dQBXUyXMc8CxvcQ3Azk7o2U/gR0PapqQqU3acbD5kyo8iQjMlnKRjOWt0T9Np9R+dVvtALKG8kDI3Yt1zj8qn3uHVommiRG3BQ24L1zjp69PrzWHrfjuw0SZ4L66S8uFAJthDuwOxHQA4JPJBxj1FJa6GsITm7QVzeICoGk+QdMtZIBn0yal8uA/8vkH/AIBisXw74msvE8c1zY2pWS3ADoiFGQtuxnDDOdp6E+netMrLGvmvO9ru4I8to89eu1cGj3thSjKL5ZaMn1hNC06xutQu9NsWkUniSFd0sh5Azg5J6559T0NefeHNGPiPWZ55Yo47OMmWZIgQBnJVFUc4yOg7A8g4qbxlrLatrrWgZoLa3fyWEh+XeCQXIXPTJHfj64rotM1jwtpdhFaw6hC+0fO8lk53N3PTPPuT2Hat4qVOnpe7J1jHTc6SOK1ut32dhBcD7wQ8r0zgdv0Pr3FQX4ntrC7nQ7bmKB3Em9gRgZ4ByGH+PIFS3zuI4/tdqsm05MkQ3BO3Rhj8P/rVkXc9s2iXkYkmQiGTGG+ViQxAwSSOOOPU5rin8DaJ1tck0e5mv9Ghu7yYSSSbtxaMIDhiAM8Bug4yOnetK3iYt5ZlDMowEmTIJx78j+oGfUDnvDsrRaJbLG8YZtxI3sh4c9TkA/n+vXRLxZwpEMka8HcGGfbAPvznPTnipopypRd+i/IE1axbUJbyPE6ujbzmSN/mReMfUdBz/M4HiYlsIfiJeS6m8b2a3lwZGljLhuXxlcE8nFeziS4k3KVS5+VQrkgHOcKffBJ+ueeteP2tlaap8Tbu1v4ttvLeXJeMlhjG8gfLz1Ar18uSSqN7W6bkzWqsVrX7LeeP7d9JgH2X7WkiJjaCqkMxAJ4HDED04wOlezyGykJ8nbDIBkkgsp/r+nb887TtGs9JthBpcdsqSkcYHmscnALH5uM9zj0NW1REj811ljCnqBu8th6+nPbII/njiq/tpLlWiVvP5jScSysXmBUhaaMxjdt3b068EbT69SAcZrx2LWrTw3421+5vbRri5M83kSRuCVJZsg56bgcE9RgjHJFd74xubzTvCF9dWcux02bbiDqpZ1UnPVeCQOntXHWkfhS3+HkyzPYTX8tuziTpOsx+6oHLAAgDjAIBPQmsI7XPQwcYqDk02pO1l95r/D7Qnjjn8QFrZJ70nyYbcnESE5IAGRycDHVdvPfHoEcmpJDuikMq5xuUh+f1P9K4T4Zwy2/hV5WjVfNuXlRz82VwqcjkY3AjkZru0hmGJ4mlWNlADR/vGP1xj6fgKme+plim/bST1LNzoWmyTNO9lbF5HBYm3jJJJ5OSvXJzVJvDulC7jhezg2kYBWFB6kZ+X0Vs/h+BRWalLucd2aEtkbc+akjGNEO7kBhj04+vp9ea4bUvErPb3lg0G9vMdFlZhwM+mMg4HZutFFcGPqzp004u1wk3y3NbTrN7Pw/bl5MuyLIoX7uHywzx1wDx+tSq/mAgADOAcgdevp7UUV30FahH0X5I1T90kV4nUIAzcZJYAYPtioI9J021m+2Cwtmn3M5k8oK5z1+YeuTzj+dFFaqTWzM572LJVG80l5VY84yH3fU8dx/nFNUvChZZSrj7u1R+PPUdP85oopN2dhqTuQMElEwnJIkVlYY3B8jkMD1BBOetYUPgrw2siMumLvVsjMrspxzyCxBFFFXfRm7nKmnyNo3lAtQqW6LDGgGxI+AmOw9qlgnKE7WkRj/EjY/z2ooqVsczk7XP/9k=&quot;,
    &quot;verifyToken&quot;: &quot;42ba8abde7bc47b2b1397b4d6676956a&quot;
  },
  &quot;time&quot;: &quot;2019-11-01 22:40:37&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;系统用户登陆&quot;&gt;系统用户登陆&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://springboot.plus/img/rbac/rbac-login.png&quot; alt=&quot;验证码Swagger&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;POST请求，Content-Type: &lt;code&gt;application/json&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;http://127.0.0.1:8888/login&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;请求参数&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;code&quot;: &quot;验证码&quot;,
  &quot;password&quot;: &quot;123456&quot;,
  &quot;username&quot;: &quot;admin&quot;,
  &quot;verifyToken&quot;: &quot;验证码token&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;注意&quot;&gt;注意&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果没有启用验证码登陆，则只需传入&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;前端应将密码加密后进行传输&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;登陆成功&quot;&gt;登陆成功&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;返回登陆用户信息：部门/角色/权限&lt;/li&gt;
&lt;li&gt;返回用户token&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;code&quot;: 200,
  &quot;msg&quot;: &quot;登陆成功&quot;,
  &quot;success&quot;: true,
  &quot;data&quot;: {
    &quot;token&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJ3ZWIiLCJpc3MiOiJzcHJpbmctYm9vdC1wbHVzIiwiZXhwIjoxNTcyNjIzMDE5LCJpYXQiOjE1NzI2MTk0MTksImp0aSI6IjdlZmVlM2UwMjc2MTRiYTc5M2I2YmYwZmE4NTgzYmUwIiwidXNlcm5hbWUiOiJhZG1pbiJ9.O3w7CNRqw_Miwp8MDzPND6w490c9Q7yFlKpFJK9ubSU&quot;,
    &quot;loginSysUserVo&quot;: {
      &quot;id&quot;: &quot;1&quot;,
      &quot;username&quot;: &quot;admin&quot;,
      &quot;nickname&quot;: &quot;管理员&quot;,
      &quot;gender&quot;: 1,
      &quot;state&quot;: 1,
      &quot;departmentId&quot;: &quot;1&quot;,
      &quot;departmentName&quot;: &quot;管理部&quot;,
      &quot;roleId&quot;: &quot;1&quot;,
      &quot;roleName&quot;: &quot;管理员&quot;,
      &quot;roleCode&quot;: &quot;admin&quot;,
      &quot;permissionCodes&quot;: [
        &quot;sys:permission:codes&quot;,
        &quot;system:management&quot;,
        &quot;sys:department:update&quot;,
        &quot;sys:department:page&quot;,
        &quot;sys:role:management&quot;,
        &quot;sys:permission:add&quot;,
        &quot;sys:user:add&quot;,
        &quot;sys:role:page&quot;,
        &quot;sys:permission:page&quot;,
        &quot;sys:department:delete&quot;,
        &quot;sys:permission:management&quot;,
        &quot;sys:user:delete&quot;,
        &quot;sys:department:management&quot;,
        &quot;sys:user:page&quot;,
        &quot;sys:user:update&quot;,
        &quot;sys:user:update:password&quot;,
        &quot;sys:user:update:head&quot;,
        &quot;sys:role:add&quot;,
        &quot;sys:permission:menu:tree&quot;,
        &quot;sys:department:info&quot;,
        &quot;sys:permission:all:menu:list&quot;,
        &quot;sys:permission:info&quot;,
        &quot;sys:role:info&quot;,
        &quot;sys:permission:all:menu:tree&quot;,
        &quot;sys:permission:update&quot;,
        &quot;sys:permission:menu:list&quot;,
        &quot;sys:role:update&quot;,
        &quot;sys:user:info&quot;,
        &quot;sys:user:management&quot;,
        &quot;sys:role:delete&quot;,
        &quot;sys:permission:delete&quot;
      ]
    }
  },
  &quot;time&quot;: &quot;2019-11-01 22:43:39&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;token默认失效时间为1个小时&lt;/li&gt;
&lt;li&gt;设置JWT Token失效时间&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;  ############################ JWT start #############################
  jwt:
    # 默认过期时间1小时，单位：秒
    expire-second: 3600&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;后台使用Redis缓存登陆用户信息&lt;/li&gt;
&lt;li&gt;redis key&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;login:user:admin&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;其它需要授权访问的接口请求头需携带token&quot;&gt;其它需要授权访问的接口，请求头需携带token&lt;/h5&gt;
&lt;h2 id=&quot;部门树形列表&quot;&gt;部门树形列表&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;部门可以设置为N级，后台使用递归将部门列表转换为树形列表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://springboot.plus/img/rbac/rbac-sys-department.png&quot; alt=&quot;验证码Swagger&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SysDepartmentServiceImpl&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public List&amp;lt;SysDepartmentTreeVo&amp;gt; getAllDepartmentTree() {
        List&amp;lt;SysDepartment&amp;gt; sysDepartmentList = getAllDepartmentList();
        if (CollectionUtils.isEmpty(sysDepartmentList)) {
            throw new IllegalArgumentException(&quot;SysDepartment列表不能为空&quot;);
        }
        List&amp;lt;SysDepartmentTreeVo&amp;gt; list = SysDepartmentConvert.INSTANCE.listToTreeVoList(sysDepartmentList);
        List&amp;lt;SysDepartmentTreeVo&amp;gt; treeVos = new ArrayList&amp;lt;&amp;gt;();
        for (SysDepartmentTreeVo treeVo : list) {
            if (treeVo.getParentId() == null) {
                treeVos.add(findChildren(treeVo, list));
            }
        }
        return treeVos;
    }

    /**
     * 递归获取树形结果列表
     *
     * @param tree
     * @param list
     * @return
     */
    public SysDepartmentTreeVo findChildren(SysDepartmentTreeVo tree, List&amp;lt;SysDepartmentTreeVo&amp;gt; list) {
        for (SysDepartmentTreeVo vo : list) {
            if (tree.getId().equals(vo.getParentId())) {
                if (tree.getChildren() == null) {
                    tree.setChildren(new ArrayList&amp;lt;&amp;gt;());
                }
                tree.getChildren().add(findChildren(vo, list));
            }
        }
        return tree;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;前端JSON结构&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;http://127.0.0.1:8888/sysDepartment/getAllDepartmentTree&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;角色管理&quot;&gt;角色管理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://springboot.plus/img/rbac/rbac-sys-role.png&quot; alt=&quot;验证码Swagger&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置角色权限&quot;&gt;设置角色权限&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;核心代码，删除角色权限，新增角色权限&lt;/li&gt;
&lt;li&gt;求集合的差集&lt;/li&gt;
&lt;li&gt;SysRolePermissionServiceImpl&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Transactional(rollbackFor = Exception.class)
    @Override
    public boolean updateSysRole(UpdateSysRoleParam updateSysRoleParam) throws Exception {
        Long roleId = updateSysRoleParam.getId();
        List&amp;lt;Long&amp;gt; permissionIds = updateSysRoleParam.getPermissionIds();
        // 校验角色是否存在
        SysRole sysRole = getById(roleId);
        if (sysRole == null) {
            throw new BusinessException(&quot;该角色不存在&quot;);
        }
        // 校验权限列表是否存在
        if (!sysPermissionService.isExistsByPermissionIds(permissionIds)) {
            throw new BusinessException(&quot;权限列表id匹配失败&quot;);
        }

        // 修改角色
        sysRole.setName(updateSysRoleParam.getName())
                .setType(updateSysRoleParam.getType())
                .setRemark(updateSysRoleParam.getRemark())
                .setState(updateSysRoleParam.getState())
                .setUpdateTime(new Date());
        boolean updateResult = updateById(sysRole);
        if (!updateResult) {
            throw new DaoException(&quot;修改系统角色失败&quot;);
        }

        // 获取之前的权限id集合
        List&amp;lt;Long&amp;gt; beforeList = sysRolePermissionService.getPermissionIdsByRoleId(roleId);
        // 差集计算
        // before：1,2,3,4,5,6
        // after： 1,2,3,4,7,8
        // 删除5,6 新增7,8
        // 此处真实删除，去掉deleted字段的@TableLogic注解
        Set&amp;lt;Long&amp;gt; beforeSet = new HashSet&amp;lt;&amp;gt;(beforeList);
        Set&amp;lt;Long&amp;gt; afterSet = new HashSet&amp;lt;&amp;gt;(permissionIds);
        SetUtils.SetView deleteSet = SetUtils.difference(beforeSet, afterSet);
        SetUtils.SetView addSet = SetUtils.difference(afterSet, beforeSet);
        log.debug(&quot;deleteSet = &quot; + deleteSet);
        log.debug(&quot;addSet = &quot; + addSet);

        // 删除权限关联
        UpdateWrapper updateWrapper = new UpdateWrapper();
        updateWrapper.eq(&quot;role_id&quot;,roleId);
        updateWrapper.in(&quot;permission_id&quot;,deleteSet);
        boolean deleteResult = sysRolePermissionService.remove(updateWrapper);
        if (!deleteResult) {
            throw new DaoException(&quot;删除角色权限关系失败&quot;);
        }
        // 新增权限关联
        boolean addResult = sysRolePermissionService.saveSysRolePermissionBatch(roleId, addSet);
        if (!addResult) {
            throw new DaoException(&quot;新增角色权限关系失败&quot;);
        }
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;权限管理&quot;&gt;权限管理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://springboot.plus/img/rbac/rbac-sys-permission.png&quot; alt=&quot;验证码Swagger&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;权限树形列表&quot;&gt;权限树形列表&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;用户设置角色权限时，选择权限菜单&lt;/li&gt;
&lt;li&gt;权限分为菜单和功能权限&lt;/li&gt;
&lt;li&gt;后台获取三层权限树&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public List&amp;lt;SysPermissionTreeVo&amp;gt; getAllMenuTree() throws Exception {
        List&amp;lt;SysPermission&amp;gt; list = getAllMenuList();
        // 转换成树形菜单
        List&amp;lt;SysPermissionTreeVo&amp;gt; treeVos = convertSysPermissionTreeVoList(list);
        return treeVos;
    }

    @Override
    public List&amp;lt;SysPermissionTreeVo&amp;gt; convertSysPermissionTreeVoList(List&amp;lt;SysPermission&amp;gt; list) {
        if (CollectionUtils.isEmpty(list)) {
            throw new IllegalArgumentException(&quot;SysPermission列表不能为空&quot;);
        }
        // 按level分组获取map
        Map&amp;lt;Integer, List&amp;lt;SysPermission&amp;gt;&amp;gt; map = list.stream().collect(Collectors.groupingBy(SysPermission::getLevel));
        List&amp;lt;SysPermissionTreeVo&amp;gt; treeVos = new ArrayList&amp;lt;&amp;gt;();
        // 循环获取三级菜单树形集合
        for (SysPermission one : map.get(LevelEnum.ONE.getKey())) {
            SysPermissionTreeVo oneVo = SysPermissionConvert.INSTANCE.permissionToTreeVo(one);
            Long oneParentId = oneVo.getParentId();
            if (oneParentId == null || oneParentId == 0) {
                treeVos.add(oneVo);
            }
            List&amp;lt;SysPermission&amp;gt; twoList = map.get(LevelEnum.TWO.getKey());
            if (CollectionUtils.isNotEmpty(twoList)) {
                for (SysPermission two : twoList) {
                    SysPermissionTreeVo twoVo = SysPermissionConvert.INSTANCE.permissionToTreeVo(two);
                    if (two.getParentId().equals(one.getId())) {
                        oneVo.getChildren().add(twoVo);
                    }
                    List&amp;lt;SysPermission&amp;gt; threeList = map.get(LevelEnum.THREE.getKey());
                    if (CollectionUtils.isNotEmpty(threeList)) {
                        for (SysPermission three : threeList) {
                            if (three.getParentId().equals(two.getId())) {
                                SysPermissionTreeVo threeVo = SysPermissionConvert.INSTANCE.permissionToTreeVo(three);
                                twoVo.getChildren().add(threeVo);
                            }
                        }
                    }
                }
            }

        }
        return treeVos;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;前端JSON格式&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;http://127.0.0.1:8888/sysPermission/getAllMenuTree&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;权限编码列表&quot;&gt;权限编码列表&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;返回当前用户所有的权限编码，方便前端展示导航菜单和功能按钮&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;http://127.0.0.1:8888/sysPermission/getPermissionCodesByUserId/1&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;code&quot;: 200,
  &quot;msg&quot;: &quot;操作成功&quot;,
  &quot;success&quot;: true,
  &quot;data&quot;: [
    &quot;system:management&quot;,
    &quot;system:management&quot;,
    &quot;sys:user:management&quot;,
    &quot;sys:user:management&quot;,
    &quot;sys:role:management&quot;,
    &quot;sys:permission:management&quot;,
    &quot;sys:department:management&quot;,
    &quot;sys:user:add&quot;,
    &quot;sys:user:add&quot;,
    &quot;sys:user:update&quot;,
    &quot;sys:user:update&quot;,
    &quot;sys:user:delete&quot;,
    &quot;sys:user:delete&quot;,
    &quot;sys:user:info&quot;,
    &quot;sys:user:info&quot;,
    &quot;sys:user:page&quot;,
    &quot;sys:user:page&quot;,
    &quot;sys:user:update:password&quot;,
    &quot;sys:user:update:head&quot;,
    &quot;sys:role:add&quot;,
    &quot;sys:role:update&quot;,
    &quot;sys:role:delete&quot;,
    &quot;sys:role:info&quot;,
    &quot;sys:role:page&quot;,
    &quot;sys:permission:add&quot;,
    &quot;sys:permission:update&quot;,
    &quot;sys:permission:delete&quot;,
    &quot;sys:permission:info&quot;,
    &quot;sys:permission:page&quot;,
    &quot;sys:permission:all:menu:list&quot;,
    &quot;sys:permission:all:menu:tree&quot;,
    &quot;sys:permission:menu:list&quot;,
    &quot;sys:permission:menu:tree&quot;,
    &quot;sys:permission:codes&quot;,
    &quot;sys:department:update&quot;,
    &quot;sys:department:delete&quot;,
    &quot;sys:department:info&quot;,
    &quot;sys:department:page&quot;
  ],
  &quot;time&quot;: &quot;2019-11-02 00:32:17&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注意-1&quot;&gt;注意&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用Shiro注解@RequiresPermissions进行controller方法权限过滤&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequiresPermissions(&quot;sys:department:add&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;生成代码时，可配置生成RequiresPermissions注解&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        // 是否生成Shiro RequiresPermissions注解
        codeGenerator.setRequiresPermissions(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;生成或新增的controller方法，需要进行权限管理，需要到sys_permission表新增权限编码记录，并给相应角色赋予权限&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 04 Nov 2019 16:08:00 +0000</pubDate>
<dc:creator>spring-boot-plus</dc:creator>
<og:description>RBAC用户角色权限 用户角色权限部门管理核心接口介绍 Shiro权限配置 👉 'Shiro权限配置' 数据库模型图 👉 'spring boot plus初始化SQL下载' 获取验证码 可配置是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/springbootplus/p/11795882.html</dc:identifier>
</item>
<item>
<title>【Redis深度历险】那些年Redis的数据结构 - amberbar</title>
<link>http://www.cnblogs.com/amberbar/p/11795805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amberbar/p/11795805.html</guid>
<description>&lt;h2 id=&quot;redis端口号6379的来源&quot;&gt;Redis端口号6379的来源&lt;/h2&gt;
&lt;p&gt;Redis的端口号是6379,但这个端口号并不是随机选择的,源于&quot;MERZ&quot;,这个单词在手机当中的对应数字就是6379。&quot;MERZ&quot;在Redis作者Antirez的好友圈当中代表愚蠢的意思。&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;Redis的key只能是字符串，value可以是String,Hash,List,Sorted Set(Zset)。&lt;/p&gt;
&lt;h3 id=&quot;string&quot;&gt;String&lt;/h3&gt;
&lt;p&gt;Redis的字符串是动态字符串（SDS Simple Dynamic String ）,内部结构有点儿类似于java的ArrayList,都是采取预分配来减少内存的频繁扩容。如图len是实际字符串的长度，capacity是预分配的空间(数组容量)。创建字符串时,len和capacity一样长，使用字节数组存放内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct SDS&amp;lt;T&amp;gt; {
    T capacity; // 数组容量
    T len; // 数组长度
    byte flags; // 特殊标识位
    byte[] content; // 数组内容
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445322/201911/1445322-20191104234143949-660105983.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果在1M以内，都是加倍扩充容量&lt;/li&gt;
&lt;li&gt;如果超过1M则，每次扩容1M&lt;/li&gt;
&lt;li&gt;字符串的最大容量是512M&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445322/201911/1445322-20191104234155445-633580015.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;string的一些基础操作&quot;&gt;String的一些基础操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;普通get set&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set name amber
OK
127.0.0.1:6379&amp;gt; get name
&quot;amber&quot;
127.0.0.1:6379&amp;gt; exists name
(integer) 1
127.0.0.1:6379&amp;gt; del name
(integer) 1
127.0.0.1:6379&amp;gt; get name
(nil)
127.0.0.1:6379&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;批量mset,mget&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set name amber
OK
127.0.0.1:6379&amp;gt; set name2 nick
OK
127.0.0.1:6379&amp;gt; mget name name2
1) &quot;amber&quot;
2) &quot;nick&quot;
127.0.0.1:6379&amp;gt; mset name3 wade name4 hellen
OK
127.0.0.1:6379&amp;gt; mget name name2 name3 name4
1) &quot;amber&quot;
2) &quot;nick&quot;
3) &quot;wade&quot;
4) &quot;hellen&quot;
127.0.0.1:6379&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;设置过期时间&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;第一种 expire&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set name amber
OK
127.0.0.1:6379&amp;gt; expire name 5
(integer) 1
127.0.0.1:6379&amp;gt; get name
&quot;amber&quot;
//等待5s
127.0.0.1:6379&amp;gt; get name
(nil)
127.0.0.1:6379&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;利用setex&lt;br/&gt;setex name 时间 value&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; setex name 5 amber
OK
127.0.0.1:6379&amp;gt; get name
&quot;amber&quot;
127.0.0.1:6379&amp;gt; get name
(nil)
127.0.0.1:6379&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;自增自减&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set age 18
OK
127.0.0.1:6379&amp;gt; incr age
(integer) 19
127.0.0.1:6379&amp;gt; incrby age 5
(integer) 24
127.0.0.1:6379&amp;gt; incrby age -5
(integer) 19
127.0.0.1:6379&amp;gt; decr age
(integer) 18
127.0.0.1:6379&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;list&quot;&gt;List&lt;/h3&gt;
&lt;p&gt;Redis的list结构有点像Java中的LinkedList,但实际上地产不仅仅是简单的linkedlist,底层是quicklist（太深入了等待作者以后学习...）&lt;/p&gt;
&lt;h4 id=&quot;特点&quot;&gt;特点&lt;/h4&gt;
&lt;p&gt;list的插入删除效率很高，时间复杂度为O(1),但是索引的定位就很慢，即O(n)&lt;/p&gt;
&lt;h4 id=&quot;操作&quot;&gt;操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;左进右出(队列)&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lpush names amber nick wade
(integer) 3
127.0.0.1:6379&amp;gt; rpop names
&quot;amber&quot;
127.0.0.1:6379&amp;gt; rpop names
&quot;nick&quot;
127.0.0.1:6379&amp;gt; rpop names
&quot;wade&quot;
127.0.0.1:6379&amp;gt; rpop names
(nil)
127.0.0.1:6379&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然你也可以左近左出（栈）,可以自己实验一下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;索引操作&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;lindex相当于java的get(int index)根据索引取值，但是因为要遍历链表，如果数据很大，导致开销增大&lt;/li&gt;
&lt;li&gt;ltrim key index1 index2 保留index1和index2之间的数据&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lpush names amber nick wade
(integer) 3
127.0.0.1:6379&amp;gt; lindex names 0
&quot;wade&quot;
127.0.0.1:6379&amp;gt; lindex names 1
&quot;nick&quot;
127.0.0.1:6379&amp;gt; lindex names 2
&quot;amber&quot;
127.0.0.1:6379&amp;gt; ltrim names 0 1
127.0.0.1:6379&amp;gt; lindex names 0
&quot;wade&quot;
127.0.0.1:6379&amp;gt; lindex names 1
&quot;nick&quot;
127.0.0.1:6379&amp;gt; lindex names 2
(nil)
127.0.0.1:6379&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hash散列&quot;&gt;hash(散列)&lt;/h3&gt;
&lt;p&gt;Redis的hash类似java中的HashMap&lt;/p&gt;
&lt;h4 id=&quot;特点-1&quot;&gt;特点&lt;/h4&gt;
&lt;p&gt;Redis中的Hash进行rehash时区别于java中的HashMap。&lt;br/&gt;在redis进行rehash时会同时保留新旧两个结构，并在后续的定时任务当中慢慢把旧的数据移动到新数据。&lt;/p&gt;
&lt;h4 id=&quot;操作-1&quot;&gt;操作&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hmset person name amber age 18
OK
127.0.0.1:6379&amp;gt; hgetall person
1) &quot;name&quot;
2) &quot;amber&quot;
3) &quot;age&quot;
4) &quot;18&quot;
127.0.0.1:6379&amp;gt; hget person name
&quot;amber&quot;
127.0.0.1:6379&amp;gt; hset person gender 1
(integer) 1
127.0.0.1:6379&amp;gt; hgetall person
1) &quot;name&quot;
2) &quot;amber&quot;
3) &quot;age&quot;
4) &quot;18&quot;
5) &quot;gender&quot;
6) &quot;1&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;set&quot;&gt;set&lt;/h3&gt;
&lt;p&gt;Redis中的set相当于java中的HashSet,内部相当于实现了一个字典&lt;/p&gt;
&lt;h4 id=&quot;特点-2&quot;&gt;特点&lt;/h4&gt;
&lt;p&gt;value唯一&lt;/p&gt;
&lt;h4 id=&quot;操作-2&quot;&gt;操作&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sadd names amber
(integer) 1
127.0.0.1:6379&amp;gt; sadd names amber
(integer) 0
127.0.0.1:6379&amp;gt; sadd names nick wade
(integer) 2
127.0.0.1:6379&amp;gt; smembers names
1) &quot;amber&quot;
2) &quot;wade&quot;
3) &quot;nick&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zsetsorted-set&quot;&gt;zset(sorted set)&lt;/h3&gt;
&lt;p&gt;Redis中的zset相当于java中sorted set和HashMap的结合。在set的基础上还可以给value赋予score(排序的权重)&lt;/p&gt;
&lt;h4 id=&quot;特点-3&quot;&gt;特点&lt;/h4&gt;
&lt;p&gt;zset因为有score需要排序，但是采用普通的链表查找销量过低。因此zst采用层级制度。有点类似于国家-&amp;gt;省级-&amp;gt;市-&amp;gt;xxx。最底层的乡镇肯帝就是我们的L0层级了，所有的元素都串联在一起，每个几个元素就选出市位于L2,同样的道理每隔几个L2层级的元素就选出省位于L3层级。当我们插入新的节点的时候，只需要从最顶层开始进行查找定位到相应位置就行了。是不是有点儿像数组的二分查找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445322/201911/1445322-20191104234057693-1679043719.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;操作-3&quot;&gt;操作&lt;/h3&gt;
&lt;p&gt;其实还有一些操作，不过这里就不展示了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zadd names 2 amber
(integer) 1
127.0.0.1:6379&amp;gt; zadd names 3 wade
(integer) 1
127.0.0.1:6379&amp;gt; zadd names 1 nick
(integer) 1
127.0.0.1:6379&amp;gt; zrange names 0 2
1) &quot;nick&quot;
2) &quot;amber&quot;
3) &quot;wade&quot;
127.0.0.1:6379&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据结构知识点拓展&quot;&gt;数据结构知识点拓展&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;redis的所有数据结构都可以设置时间&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;1. 设置时间
expire key 时间
2. 查看时间
ttl key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445322/201910/1445322-20191031151606959-1312910059.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Nov 2019 15:43:00 +0000</pubDate>
<dc:creator>amberbar</dc:creator>
<og:description>Redis端口号6379的来源 Redis的端口号是6379,但这个端口号并不是随机选择的,源于'MERZ',这个单词在手机当中的对应数字就是6379。'MERZ'在Redis作者Antirez的好友</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/amberbar/p/11795805.html</dc:identifier>
</item>
<item>
<title>C语言存储类别和链接 - #搬砖仔</title>
<link>http://www.cnblogs.com/TJTO/p/11795786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TJTO/p/11795786.html</guid>
<description>&lt;p&gt;​ 最近详细的复习C语言，看到存储类别的时候总感觉一些概念模糊不清，现在认真的梳理一下。C语言的优势之一能够让程序员恰到好处的控制程序，可以通过C语言的内存管理系统指定变量的作用域和生存周期，实现对程序的控制。&lt;/p&gt;
&lt;h2 id=&quot;存储类别&quot;&gt;存储类别&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;基本概念&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt;：在C语言中所有的数据都会被存储到内存中，被存储的值会占用一定的物理内存，这样的一块内存被称为&lt;em&gt;对象&lt;/em&gt;，它可以储存一个或者多个值，在储存适当的值时一定具有相应的大小。（C语言对象不同于面向对象语言的对象）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标识符&lt;/strong&gt;：程序需要一种方法来访问对象，这就需要声明变量来实现，例如: &lt;code&gt;int identifier = 1&lt;/code&gt;,在这里&lt;code&gt;identifier&lt;/code&gt;就是一个标识符，标识符是一个名称并遵循变量的命名规则。所以在本例中&lt;code&gt;identifier&lt;/code&gt;即是C程序指定硬件内存中的对象的方式并提供了存储的值的大小“1”。在其它的情况中 &lt;code&gt;int * pt&lt;/code&gt;、&lt;code&gt;int arr[10]&lt;/code&gt;,pt就是一个标志符，它指定了储存地址的变量，但是表达式*p不是一个标志符，因为它不是一个名称。&lt;code&gt;arr&lt;/code&gt;的声明创建了一个可容纳10个&lt;code&gt;int&lt;/code&gt;类型元素的对象，该数组的每一个元素也是一个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用域&lt;/strong&gt;：描述程序中可访问标识符的区域。因为一个C变量的作用域可以是块作用域、函数作用域、文件作用域和函数原型作用域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;块作用域&lt;/strong&gt;：简单来说块作用域就是一对花括号括起来的代码区域。定义在块中的变量具有块作用域，范围是定义处到包含该定义块的末尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数原型作用域&lt;/strong&gt;：范围是从形参定义处到函数原型声明的结束。我们知道编译器在处理函数形参时只关心它的类型，而形参的名字通常无关紧要。例如：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void fun(int n,double m);     同样可以声明为

void fun(int ,double );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一点要注意的是函数体的形参虽然声明在函数的左花括号之前但是它具有的是块作用域属于函数体这个块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件作用域&lt;/strong&gt;：变量的定义在所有函数的外面，从它的定义处到该文件的末尾处均可见称这个变量拥有文件作用域。所以文件作用域变量也被称为全局变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链接&lt;/strong&gt;：C变量有三种链接属性：内部链接、外部链接和无链接。具有块作用域、函数原型作用域的变量都是无链接变量，这就意味这他们属于定义他们的块或者函数原型私有。文件作用域变量可以是外部链接或是内部链接，外部链接可以在多个文件中使用，内部链接只能定义它的文件单元中使用。&lt;/p&gt;
&lt;h2 id=&quot;存储期&quot;&gt;存储期&lt;/h2&gt;
&lt;p&gt;指对象在内存中保留了多长时间，作用域和链接描述了对象的可见性。存储期则描述了标识符访问对象的生存期。&lt;/p&gt;
&lt;p&gt;C对象有4种存储期：&lt;/p&gt;
&lt;p&gt;1) 静态存储期：如果一个对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期，注意关键字&lt;code&gt;static&lt;/code&gt;表明的是链接属性而不是存储期。以&lt;code&gt;static&lt;/code&gt;声明的文件作用域变量具有内部链接，无论具有内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。&lt;/p&gt;
&lt;p&gt;还有一种情况块作用域变量也可以拥有静态存储期，把变量声明在块中并在变量名前加&lt;code&gt;static&lt;/code&gt;关键字，例：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int fun(int num)
{
    static int Index;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里变量&lt;code&gt;Index&lt;/code&gt;就被存储在静态内存中，从程序被载入到程序结束都会存在，但是只有程序进入这个块中才会访问它指定的对象。&lt;/p&gt;
&lt;p&gt;2) 线程存储期：用于并发程序设计，一个程序的执行可以分为多个线程，具有线程存储期的变量从被声明时到线程结束一直存在。以关键字&lt;code&gt;_Thread_local&lt;/code&gt;声明一个对象时，每个线程都获得该变量的私有备份。&lt;/p&gt;
&lt;p&gt;3) 自动存储期：块作用域变量通常具有自动存储期，当程序进入定义这些变量的块时，会为这些变量分配内存，当程序离开这个块时会自动释放变量占用的内存，这种做法相当于把自动变量占用的内存视为可重复利用的工作区或暂存区。&lt;/p&gt;
&lt;p&gt;4) 动态分配存储期&lt;/p&gt;
&lt;h2 id=&quot;五种存储类别&quot;&gt;五种存储类别&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;五种存储类别&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;自动&lt;/td&gt;
&lt;td&gt;自动&lt;/td&gt;
&lt;td&gt;块&lt;/td&gt;
&lt;td&gt;无链接&lt;/td&gt;
&lt;td&gt;块内&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;寄存器&lt;/td&gt;
&lt;td&gt;自动&lt;/td&gt;
&lt;td&gt;块&lt;/td&gt;
&lt;td&gt;无链接&lt;/td&gt;
&lt;td&gt;块内 关键字&lt;code&gt;regsiter&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;静态外部链接&lt;/td&gt;
&lt;td&gt;静态&lt;/td&gt;
&lt;td&gt;文件&lt;/td&gt;
&lt;td&gt;外部&lt;/td&gt;
&lt;td&gt;所有函数外&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;静态内部链接&lt;/td&gt;
&lt;td&gt;静态&lt;/td&gt;
&lt;td&gt;文件&lt;/td&gt;
&lt;td&gt;外部&lt;/td&gt;
&lt;td&gt;所有函数外 关键字&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;静态无链接&lt;/td&gt;
&lt;td&gt;静态&lt;/td&gt;
&lt;td&gt;块&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;块内 关键字&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;自动变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自动变量属于自动识别的变量具有自动存储期，块作用域且无链接。可以显示的使用&lt;code&gt;auto&lt;/code&gt;关键字进行声明。&lt;/p&gt;
&lt;p&gt;注意： auto是&lt;em&gt;存储类别说明符&lt;/em&gt;和C++中的auto用法完全不同&lt;/p&gt;
&lt;p&gt;一个变量具有自动存储期就意味着当程序进入这个块时变量存在，退出块时变量消失，原来变量占用的内存另作他用。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void hiding()
{
    int x = 30;
    printf(&quot;x in outer block: %d at %p\n&quot;, x, &amp;amp;x);
    {
        x = 77;
        printf(&quot;x in inner block: %d at %p\n&quot;, x, &amp;amp;x);
    }
    // 块中内存被释放隐藏的x恢复 x = 30
    printf(&quot;x in outer block: %d at %p\n&quot;, x, &amp;amp;x);

    while (x++ &amp;lt; 33)
    {
        int x = 100;
        x++;
        printf(&quot;x in while loop: %d at %p\n&quot;, x, &amp;amp;x);
    }
    printf(&quot;x in outer block: %d at %p\n&quot;, x, &amp;amp;x);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有花括号时&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void forc()
{
    int n = 8;
    printf(&quot;  Initially, n = %d at %p\n&quot;, n, &amp;amp;n);
    for (int n = 1; n &amp;lt; 3; ++n)
        printf(&quot;      loop 1:n = %d at %p\n&quot;, n &amp;amp;n);
    // 离开循环后原始的你又起作用了
    printf(&quot;After loop 1:n = %d at %p\n&quot;, n &amp;amp;n);
    for (int n = 1; n &amp;lt; 3; ++n)
    {
        printf(&quot;loop 2 index n = %d at %p\n&quot;, n, &amp;amp;n);
        // 重新初始化的自动变量，作用域没有到循环里的n
        int n = 6;
        printf(&quot;      loop 2:n = %d at %p\n&quot;, n, &amp;amp;n);
        // 起作用的仍然是循环中的n
        n++;
    }
    // 离开循环后原始的n又起作用了
    printf(&quot;      loop 2:n = %d at %p\n&quot;, n, &amp;amp;n);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1766430/201911/1766430-20191104233811046-1935941204.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;寄存器变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用关键字register，储存在CPU的寄存器中，存储在最快的可用内存中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;块作用域的静态变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​ 首先要明确概念静态变量并不是指值不改变的变量，而是指它在内存中的位置不变。具有文件作用域的静态变量自动具有静态存储期。&lt;/p&gt;
&lt;p&gt;前面提到我们可以创建一个静态存储期，块作用域的局部变量，这种变量和自动变量一样具有相同的作用域，但是在程序离开块时并不会消失，&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void trystat();

int main()
{
    int count = 1;
    for (count = 1; count &amp;lt;= 3; count++)
    {
        printf(&quot;Here comes iteration %d:\n&quot;, count);
        trystat();
    }
    trystat();
    return 0;
}

void trystat()
{
    int fade = 1;
    static int stay = 1;
    printf(&quot; fade = %d and stay = %d\n&quot;, fade++, stay++);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1766430/201911/1766430-20191104233911024-920789692.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 可以看出每次离开块fade变量的值都会被重新的初始化，而stay只是在编译函数&lt;code&gt;void trystat()&lt;/code&gt;的时候被初始化了一次,在离开自己函数体的块和for循环块之后都会递增，说明stay访问的对象一直存在并没有像自动变量一样被释放掉。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外部链接的静态变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​ 具有外部链接、静态存储期和文件作用域，属于该类别的变量属于外部变量。只需要把变量的声明放在所有函数的外面就创建了一个外部变量。为了表明该函数使用了外部变量，需要使用关键字&lt;code&gt;extern&lt;/code&gt;来再次申明。如果在一个源文件中使用的外部变量声明在了另一个源文件中，则必须要使用extern来申明。&lt;/p&gt;
&lt;p&gt;外部变量可以显示初始化，如果没有则会被默认初始化为0。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内部链接的静态变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具有文件作用域、静态存储期和内部链接，在所有函数外用&lt;code&gt;static&lt;/code&gt;来声明一个变量就是内部链接的静态变量。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static int val = 1;
int main()
{
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;普通的外部变量可以用于程序中的任意一个函数处，但是内部链接的静态变量只能用于同一个文件中的函数。都可以使用&lt;code&gt;extern&lt;/code&gt;说明符，在函数中重复任何声明文件作用域变量并不会改变他们的链接属性。&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int global = 1;
static int local_global = 2;
int main
{
    extern int global = 1;
    extern int local_global = 2;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有在多文件中才能区别内部链接和外部链接的重要性。&lt;/p&gt;
&lt;p&gt;总结一下存储类别的说明符中关键字共有六个&lt;code&gt;auto&lt;/code&gt;、&lt;code&gt;register&lt;/code&gt;、&lt;code&gt;_Thread_local&lt;/code&gt;、&lt;code&gt;static&lt;/code&gt;、&lt;code&gt;extern&lt;/code&gt;和&lt;code&gt;typedef&lt;/code&gt; ，其中&lt;code&gt;static&lt;/code&gt;和&lt;code&gt;extern&lt;/code&gt;的含义取决于上下文，&lt;/p&gt;
</description>
<pubDate>Mon, 04 Nov 2019 15:37:00 +0000</pubDate>
<dc:creator>#搬砖仔</dc:creator>
<og:description>[TOC] C语言存储类别和链接 ​ 最近详细的复习C语言，看到存储类别的时候总感觉一些概念模糊不清，现在认真的梳理一下。C语言的优势之一能够让程序员恰到好处的控制程序，可以通过C语言的内存管理系统指</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TJTO/p/11795786.html</dc:identifier>
</item>
<item>
<title>设计模式之访问者模式 - _我在清水河边</title>
<link>http://www.cnblogs.com/wzqshb/p/11795787.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzqshb/p/11795787.html</guid>
<description>&lt;h2 id=&quot;访问者模式的实现&quot;&gt;访问者模式的实现&lt;/h2&gt;
&lt;p&gt;访问者模式就是针对不同的资源设置不同的访问权限, 反转这访问权限的设置位置,从而达到不修改资源来控制访问权限的目的.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先设置一个元素材资源和元访问权限&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class unionLevel {


    public String getLevelName(unionVisitor visitor){
        return &quot;see union level&quot;;
    };

}

public interface unionVisitor {
    /**
     * 看第一级素材
     * @return
     */
    default String seeLevelOne(unionLevel level){
        return level+&quot;  forbidden&quot;;
    }
    /**
     * level two
     * @return
     */
    default String seeLevelTwo(unionLevel level){
        return level+&quot; forbidden&quot;;
    }
    /**
     * level three
     * @return
     */
    default String seeLevelThree(unionLevel level)
    {
        return level+&quot; forbidden&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;设置多级素材继承元素材&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LevelOne extends unionLevel{

    @Override
    public String getLevelName(unionVisitor visitor) {
        System.out.println(visitor.seeLevelOne(this));
        return super.getLevelName(visitor);
    }

    @Override
    public String toString() {
        return &quot;levelone&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;设置多级权限实现元权限&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class VisitorOne implements unionVisitor{

    /**
     * 看第一级素材
     *
     * @return
     */
    @Override
    public String seeLevelOne(unionLevel level) {
        return &quot;VisitorOne can see &quot;+level;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;写个测试类(其他元素和素材照着上面demo写就行)&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class start {

    public static void main(String[] args) {

        LevelTwo two  =  new LevelTwo();
        two.getLevelName(new VisitorOne());
        two.getLevelName(new VisitorTwo());
        two.getLevelName(new VisitorThree());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;平常不怎么喜欢写总结的，但是说要是使用的时候还是会去翻一下他的定义。以免自己弄错了都不知道，其实对于访问者模式来说，最大的好处就是对权限这边的解放（不过你要是资源级别会随意变动而权限设置不会随便变动的话，可以将这个设计反过来。毕竟设计是死的而人是活的。肯定要写成对实现更加方便的代码出来）&lt;/p&gt;
&lt;h3 id=&quot;访问者模式&quot;&gt;访问者模式&lt;/h3&gt;
&lt;p&gt;是23种基本设计模式中的一种，属于行为型设计模式。&lt;a href=&quot;https://en.wikipedia.org/wiki/Visitor_pattern&quot;&gt;维基百科&lt;/a&gt;定义：Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.（表示要在对象结构的元素上执行的操作。访问者可让您定义新操作，而无需更改其所操作元素的类）&lt;/p&gt;
&lt;h3 id=&quot;适用范围&quot;&gt;适用范围&lt;/h3&gt;
&lt;p&gt;Use the Visitor pattern when&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li&gt;an object structure contains many classes of objects with differing interfaces, and you want to perform operations on these objects that depend on their concrete classes&lt;/li&gt;
&lt;li&gt;many distinct and unrelated operations need to be performed on objects in an object structure, and you want to avoid &quot;polluting&quot; their classes with these operations. Visitor lets you keep related operations together by defining them in one class. When the object structure is shared by many applications, use Visitor to put operations in just those applications that need them&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;the classes defining the object structure rarely change, but you often want to define new operations over the structure. Changing the object structure classes requires redefining the interface to all visitors, which is potentially costly. If the object structure classes change often, then it's probably better to define the operations in those classes&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;          在以下情况下使用访问者模式 
          * 一个对象结构包含许多具有不同接口的对象类，并且您希望根据这些对象的具体类对这些对象执行操作 
          * 需要对对象结构中的对象执行许多不同且不相关的操作，并且您要避免使用这些操作“污染”它们的类。访客可以通过在一个类中定义相关操作来将它们保持在一起。
          * 当许多应用程序共享对象结构时，请使用Visitor将操作仅放在需要它们的应用程序中 定义对象结构的类很少更改，但是您经常想在该结构上定义新的操作。更改对象结构类需要重新定义所有访问者的接口，这可能会导致成本高昂。如果对象结构类经常更改，那么最好在这些类中定义操作&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;https://github.com/fulln&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 04 Nov 2019 15:37:00 +0000</pubDate>
<dc:creator>_我在清水河边</dc:creator>
<og:description>访问者模式的实现 访问者模式就是针对不同的资源设置不同的访问权限, 反转这访问权限的设置位置,从而达到不修改资源来控制访问权限的目的. 先设置一个元素材资源和元访问权限 设置多级素材继承元素材 设置多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wzqshb/p/11795787.html</dc:identifier>
</item>
</channel>
</rss>