<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一个研发出身创业者的2019年收获与感悟 - 虚生</title>
<link>http://www.cnblogs.com/dylancao/p/12150372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dylancao/p/12150372.html</guid>
<description>&lt;h4 id=&quot;关于技术&quot;&gt;关于技术&lt;/h4&gt;
&lt;p&gt;  技术创业者，很容易陷入唯技术论。认为越先进的技术越好，越容易卖钱。刚出来的时候，我们做产品，就瞄准了刚出来的技术难度有点高的产品，一个产品做下来，本身技术难度大，配合又不到位，导致产品研发了大半年，等研发出来之后，才发现没有市场，这个市场没有起来，后来发现市场上有同类的产品，成本居然也不高，我们只需要拿来卖了一些了。后面又做了几款产品，发现只能是你的技术能够降低成本，或者把用户的痛点以低一些的成本满足，这个才算是有市场的。说白了，就是技术能够降低成本，一个是增加有价值的功能，除此之外，再牛逼的技术也没有价值的。过分的求新求奇是一个十分危险的信号。&lt;br/&gt;  技术创业者非常容易拍脑袋做决策，观察了很多，发现很多像我这样的创业者，很多都是拍脑袋做决策的。客观原因信息获取渠道不够，导致获取的信息有偏差，最重要的是缺乏一个系统性的市场调研方法和调研的商业习惯。以为市场调研就是浪费时间，也懒得去跑出去看看。为了避免后面少走弯路，一定要找到自己的商业调研方法并反复实战，这个才能找到制胜的法宝，不然，全凭拍脑袋说白了就是靠运气来，这个在这个残酷的市场上，是输不起的。&lt;/p&gt;
&lt;h4 id=&quot;关于赛道&quot;&gt;关于赛道&lt;/h4&gt;
&lt;p&gt;  像我们这种十个人以内的团队，做产品方向的时候一定要注意一个问题，就是你的赛道是否会被大公司盯上呢？被大公司盯上了赛道之后，日子就难过了。千万不要相信所谓电视剧中的一些情节，几个梁山好汉可以力战千军万马。特别是传统的软件领域或者工程领域，一个牛逼的人可以抵得上100个人，但是，你能顶得上1000个人吗？肯定是不行的，千万不要低估了那些所谓大科技公司的实力，他们可是经历过各种残酷战斗的，他们要钱有钱，要人有人。一般的创业公司和他们竞争，大多是会成为炮灰的。只要他们想做的方向，就是他们做不成，也会把这个市场做的稀巴烂，国内这样的搅屎棍不在少数。所以，选择创业方向，一定要避开那些大公司的赛道，哪怕这个领域是你擅长的也不行，这个是我们今年实践出来的又一个教训吧。这个也就是华为出来的创业成功率偏低的原因之一吧，他们一般会选择和华为同样赛道的市场，这种，有华为在，别的公司喝汤的机会都很少啊。&lt;/p&gt;
&lt;h4 id=&quot;关于营销&quot;&gt;关于营销&lt;/h4&gt;
&lt;p&gt;  做技术的人，估计大多数持有这个观点--酒香不怕巷子深。可是，现实的情况是，假如你没有很好的营销自己的团队和产品。客户都无法找到你，谈什么卖点呢？好的是，现在的网络发达了，只要你很好的营销自己，还是不少能够让大家找到你的途经的。比如，微信公众号，淘宝，博客园，知乎，百度圈子，还有各种专业的论坛。记得常常发一些本产品相关的咨询和情况手册，多写一些相关专业的文章，让别人知道你的专业，最重要的是让有需求的朋友能够找到你。还有线下的就是各种展会和沙了，线下的展会是一个非常能够结识专业人员的地方，所以，多参加同类的展会，多和同类客户交流，绝对能够提升你对整个行业需求的了解。&lt;br/&gt;  今年，我们虽然产品倒腾出了不少，但是营销实在太差了，基本上没在公众场出现过，没人知道我们做什么，更没有客户能够通过有效的途径找到我们。我们通过的唯一营销途径就是做了一款让大家都知道的产品，不过，该产品还是仅仅局限于圈子内的厂家，外面的客户是不知道的，所以说，做tuB的产品。依靠产品传播的途径也非常有限啊。无论怎么样，接下来的一年中，虽然小团队没钱打广告，但是营销还是必不可少的。多写一些博客，多发一些帖子，多走访一些客户，多参加一些展会，这些，都会让你成就不一样的自己的，为自己的产品打广告，时刻记得营销自己，营销自己的产品。&lt;/p&gt;
&lt;h4 id=&quot;关于市场&quot;&gt;关于市场&lt;/h4&gt;
&lt;p&gt;  市场就是一个调研的过程，一定要充分的调研市场，从几个层面，终端网点的销售人员，竞品分析，潜在的客户的走访及谈论。记得，千万不要认为你是只做技术的，你做出来的东西，假如市场上没有需求，或者你的产品定义无法满足市场的需求，一切都是枉然。不仅仅是你，你们一个团队的辛勤劳动都是白费啊。今年为什么做的那么累？还不是因为你一直追求新的产品，追求高大上的产品，没有去了解市场及客户的需求。这个教训还不够深刻吗千万不要以为你只是一个执行者，这个社会，只有自己动脑筋了，自己思考出来的东西才最可靠，即使错了，你还有下次修正的空间，假如一味的道听途说，你永远只能受制于人。劳力者治于人。这个是亘古不变的真理。&lt;br/&gt;  技术要能满足客户的需求，解决客户的痛点，这个就要多和客户交流。多到市场上看同类的产品，看看哪些值得去做。越先进的东西失败率越高，很多都是伪需求，客户无法为这种市场的东西来买单。一个产品，先自己使用，然后让周围的人使用，最后才是让广大客户使用，假如你做产品的时候没有这个决心，估计你也不会能把产品做的很好，一个自己都不愿意使用的产品，能会成为热销产品吗？肯定不会的。&lt;/p&gt;
&lt;h4 id=&quot;关于合作&quot;&gt;关于合作&lt;/h4&gt;
&lt;p&gt;  选择合作伙伴，像结婚一样，门当户对。保持开放的策略。切忌不要迷信所谓的大公司，一个大公司能够找你小公司合作，大多数情况下，里面都是有猫腻的，他们是想套路你的技术？还是想挖你的墙角呢？很多时候，在公司没有成长成为大公司之前，还是脚踏实地，把一些能够出货的中小公司服务好才是王道。也是生存之道啊。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jan 2020 00:29:00 +0000</pubDate>
<dc:creator>虚生</dc:creator>
<og:description>关于技术 &amp;amp;emsp; 技术创业者，很容易陷入唯技术论。认为越先进的技术越好，越容易卖钱。刚出来的时候，我们做产品，就瞄准了刚出来的技术难度有点高的产品，一个产品做下来，本身技术难度大，配合又</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dylancao/p/12150372.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL 与 WebVR 3D 虚实现实的可视化培训系统 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12154649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12154649.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2019 年 &lt;strong&gt;VR&lt;/strong&gt;, &lt;strong&gt;AR&lt;/strong&gt;, &lt;strong&gt;XR&lt;/strong&gt;, &lt;strong&gt;5G&lt;/strong&gt;, &lt;strong&gt;工业互联网&lt;/strong&gt;等名词频繁出现在我们的视野中，信息的分享与虚实的结合已经成为大势所趋，&lt;strong&gt;5G&lt;/strong&gt; 是新一代信息通信技术升级的重要方向，工业互联网是制造业转型升级的发展趋势。本文所讲的 &lt;strong&gt;VR&lt;/strong&gt; 是机械制造业与设备的又一次交流，当技术新星遇上制造潮流，无疑将成为制造业，工控业等行业数字化转型的重要驱动力。&lt;strong&gt;“5G + VR + 工业互联网”&lt;/strong&gt;必将成为新的一年不变的话题，如何将当前工业中遇到的问题通过&lt;strong&gt;虚拟现实&lt;/strong&gt;结合起来，让我们可以更近的去交流，去感受技术带给我们的变化。在今年苹果的发布会上，相信大家都知道苹果的 &lt;strong&gt;5G&lt;/strong&gt; 手机没有问世，说明 &lt;strong&gt;5G&lt;/strong&gt; 的应用和发展还处在快速发展的阶段，但是手机结合 &lt;strong&gt;AR&lt;/strong&gt; 功能的 APP 已经早就问世，&lt;strong&gt;5G&lt;/strong&gt; 的速度加上 &lt;strong&gt;AR, VR&lt;/strong&gt; 的身临其境，让我们感受到的不仅仅是技术的革新，更是让我们感受到技术在不同领域的实际应用场景，我相信 2020 年新的一年必定是 &lt;strong&gt;“5G + VR + 工业互联网”&lt;/strong&gt; 应用的又一个新的开始，本文接下来所讲的就是 &lt;strong&gt;&lt;a href=&quot;https://hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT for Web&lt;/a&gt; &lt;/strong&gt;结合 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;WebVR&lt;/strong&gt;&lt;/a&gt; 开发的具体应用案例。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统预览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;预览地址：&lt;strong&gt;&lt;a href=&quot;http://www.hightopo.com/demo/vr-training/&quot; target=&quot;_blank&quot;&gt;基于 HTML5 WebGL 与 WebVR 3D 虚实现实的可视化培训系统&lt;/a&gt;   &lt;/strong&gt;&lt;a href=&quot;http://www.hightopo.com/demo/vr-training/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;http://www.hightopo.com/demo/vr-training/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;VR 拆解还原&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142740798-574522666.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;VR 操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142752415-1341192767.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;VR 场景切换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142800168-40154469.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;PC 端拆解还原&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142811234-1780951321.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;PC 端考试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142823944-1537887484.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该系统共分为三个实际应用层面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;三维培训:&lt;/strong&gt; 用户通过 mb 端手指触摸或者 pc 端鼠标拖拽可以将设备拆解开来，之后可以通过一键还原来将设备还原到最初的状态，或者可以通过拆解 or 还原按钮查看设备自动拆解的过程以及拆解之后自动还原的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;考试系统:&lt;/strong&gt; 这部分是考验你对设备拆解的熟悉程度，在第一步的三维培训之后，可以在该系统中考核你对拆解过程的了解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VR 模式:&lt;/strong&gt; 该部分便是三维场景结合 WebVR 的具体实现应用，在进入 VR 之后可以通过操作 VR 手柄，进行设备的拆解还原。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文章主要讲解第三部分的 &lt;strong&gt;VR&lt;/strong&gt; 模式，让我们了解如何结合 &lt;strong&gt;HT&lt;/strong&gt; 来搭建 &lt;strong&gt;VR&lt;/strong&gt; 场景。下面描述了 &lt;strong&gt;VR&lt;/strong&gt; 中的主要操作，没有进入 &lt;strong&gt;VR&lt;/strong&gt; 的时候不会出现如下所说的六个按钮操作，在点击进入 &lt;strong&gt;WebVR&lt;/strong&gt; 时，系统自动显示出 &lt;strong&gt;VR&lt;/strong&gt; 场景里的六个操作按钮，反之退出 &lt;strong&gt;VR&lt;/strong&gt; 时，系统也会自动隐藏三维中的六个操作按钮，&lt;strong&gt;VR&lt;/strong&gt; 中的主要操作如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;设备切换:&lt;/strong&gt; 顾名思义，可以通过手柄射线对准场景中左侧列表，按动板机进行场景设备切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作切换:&lt;/strong&gt; VR 中对设备有如下两种操作，可以通过右下角的模式按钮点击切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平移模式:&lt;/strong&gt; 该模式下，用户可以对准设备并且按动板机将设备从一个位置移动到另一个位置，并且可以通过触摸触摸板来拉近和拉远设备零件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抓取模式:&lt;/strong&gt; 该模式下，用户可以对准设备并且按动板机将设备抓取过来，抓取过来之后，可以通过触摸触摸板来旋转以及放大或者缩小零件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一键还原:&lt;/strong&gt; 将设备各部分零件还原到最初始的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆解动画:&lt;/strong&gt; 将设备的各部分零件通过之前预定好的位置按步骤一步一步拆解开来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;还原动画:&lt;/strong&gt; 该操作可以理解为拆解动画的倒放，即将拆解的过程逆序还原。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线框切换:&lt;/strong&gt; HT 支持将设备节点的三角面表示出来，可以具体的看到该设备的线框轮廓。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统开发&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三维场景&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;HT&lt;/strong&gt; 支持 &lt;strong&gt;obj&lt;/strong&gt; 模型的导入，&lt;strong&gt;VR&lt;/strong&gt; 场景所出现的设备零件均为 obj 模型，由于需要在之后进行设备的拆解，所以建模的时候需要分别对设备的各部分零件进行建模，而不是对设备整体进行建模，如果对设备整体建模那么在 HT 的场景中就是一个 &lt;strong&gt;Data&lt;/strong&gt; 节点，从而不能对零件进行拆解，如果拆解开来，那么在 HT 中可以加载多个 obj 则就有多个 Data 节点，有多个零件的 Data 节点之后就可以对设备零件进行移动或者其它旋转操作，具体的 Data 在 HT 的含义可以参考 &lt;strong&gt;&lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/datamodel/ht-datamodel-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 数据模型手册&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下为导入场景中的 &lt;strong&gt;obj&lt;/strong&gt; 模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105143425677-1331933726.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出我们导入 &lt;strong&gt;obj&lt;/strong&gt; 之后零件之间是分散的，所以需要对零件的初始位置进行调整，从而调整出一个由许多零件构成的完整设备，当然调整不可能通过代码来调整，对应的有三维编辑器可以调整，进行拖拖拽拽将不同零件拼凑起来，如下为组合之后的设备整体：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105143443083-1142217726.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;VR 搭建&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;VR&lt;/strong&gt; 场景的搭建是在第一步的基础上进行搭建，上面所说的只在 VR 场景中显示的按钮也是在场景中进行搭建，在正常的场景时候我们可以隐藏掉对应的节点，&lt;strong&gt;node.s('3d.visible', false)&lt;/strong&gt; 上面的代码就是 HT 中在三维下面隐藏三维节点的代码，因为进入 VR 和离开 VR 的时候，HT 内部会派发出对应的状态告诉用户此时已经进入 VR 或者此时已经离开 VR，相应伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; graph3dView 为 HT 中的三维场景视图容器&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; vr 获取挂载在 graph3dView 上的 vr 对象&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; vr =&lt;span&gt; graph3dView.vr;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; vr.mp(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; property 对应的 vr 事件类型，detail 此时事件的状态&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; property =&lt;span&gt; e.property;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; detail =&lt;span&gt; e.newValue;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; present 代表此时进入或者离开 VR 场景&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (property === 'present'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时 detail 为 true 表示进入 vr，false 表示离开 vr&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (detail) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行显示 vr 场景中需要显示的节点操作&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行隐藏 vr 场景中需要隐藏的节点操作&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面 property 在 &lt;strong&gt;HT&lt;/strong&gt; 总共会派发出以下几种类型，主要是包括 &lt;strong&gt;VR&lt;/strong&gt; 的状态和手柄的操作类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;enable:&lt;/strong&gt; vr 的 enable 信息发生变化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;present:&lt;/strong&gt; vr 的 present 信息发生变化，表明进出 vr 世界&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.pose:&lt;/strong&gt; 手柄位置或旋转发生变动，参数 id，position，rotation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.axes:&lt;/strong&gt; 手柄中间的转盘触摸点位变动，参数 id，axes；其中 axes 格式形如：[ 0.2, 0.7 ]，分辨表示横纵百分比&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.button.thumbpad:&lt;/strong&gt; thumbpad 按键被按下，参数 id，state，其中 state 包含 down 跟 up 两种&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.button.trigger:&lt;/strong&gt; trigger 按键被按下，参数 id，state，其中 state 包含 down 跟 up 两种&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.button.grips:&lt;/strong&gt; grips 按键被按下，参数 id，state，其中 state 包含 down 跟 up 两种&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.button.menu:&lt;/strong&gt; menu 按键被按下，参数 id，state，其中 state 包含 down 跟 up 两种&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;VR 中有一个关键的配置就是&lt;strong&gt;比例尺&lt;/strong&gt;，因为 VR 里面的单位是和现实中的长度单位是一致的，我们戴着头盔往前走 1m 那么对应在 HT 三维场景中需要往前走多远这需要一个对应关系，HT 提供的 VR 插件中会提供一个 &lt;strong&gt;measureOflength&lt;/strong&gt; 的配置项，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; vr_config =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     measureOflength: 0.01&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面 0.01 代表的意思就是 HT 场景中的单位长度 1 代表现实场景的 0.01 米，所以如果此时现实场景你戴着头盔往前移动 1m，那么 HT 中对应的视角会往前移动 100 个单位，所以如果需要搭建 VR 场景要注意场景的模型建模比例和现实世界是相差多少，按照统一的比例来建模，不然在 VR 场景中会出现设备大小不一的问题，导致出现错觉，如下对比图，左侧是 0.01 的比例，射线的小点很小，右侧是是 0.001 的比例导致射线的小点变大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105143842424-724429196.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HT&lt;/strong&gt; 中已经对浏览器提供的 &lt;strong&gt;WebVR&lt;/strong&gt; 相关接口的 API 进行了封装，包括获取设备 &lt;strong&gt;navigator.getVRDisplays()&lt;/strong&gt; 这是进入 VR 世界的第一步，如果此时执行此代码返回的结果为空代表获取 VR 设备失败，那么之后更不用说了，以及获取手柄信息 &lt;strong&gt;navigator.getGamepads()&lt;/strong&gt;，用户可以通过在浏览器控制台敲入上面两行代码，查看浏览器是否已经获取到了 VR 设备信息和 VR 手柄信息，如果返回为空则说明获取失败。HT 只要通过执行 &lt;strong&gt;graph3dView.vr.enable = true&lt;/strong&gt; 就可以开启 &lt;strong&gt;VR&lt;/strong&gt;，当然用户不用执行该代码，HT 提供的 &lt;strong&gt;VR 插件&lt;/strong&gt;也会提供对应的配置项 &lt;strong&gt;vrEnable: true&lt;/strong&gt; 来代表开启 VR，对应的配置也挂在在上面的 &lt;strong&gt;vr_config&lt;/strong&gt; 对象内，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; vr_config =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     measureOflength: 0.01&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     vrEnable: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代表开启 VR&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在该展示的系统中有直接在 &lt;strong&gt;VR 中切换场景&lt;/strong&gt;的功能，由于每个场景的 &lt;strong&gt;vr_config&lt;/strong&gt; 中的&lt;strong&gt;配置项值&lt;/strong&gt;可能会有差别，例如第一个场景的 &lt;strong&gt;measureOflength&lt;/strong&gt; 比例尺的大小为 0.01，可能第二个场景的比例尺大小 &lt;strong&gt;measureOflength&lt;/strong&gt; 就变成了 0.02，所以 VR 插件提供一个&lt;strong&gt;销毁的功能&lt;/strong&gt;，用来销毁上一个场景的资源，销毁场景的资源&lt;strong&gt;包括清空上一个场景的所有节点&lt;/strong&gt;，所以在加载新的场景时，&lt;strong&gt;不需要再执行清空场景节点的操作，即不需要执行 dataModel.clear()&lt;/strong&gt;，因为 VR 提供的销毁功能已经都清空了，手柄和射线都是场景中的一个 Data 节点，所以在新的场景不需要额外的清除手柄和射线这两个节点，故插件帮你管理场景的节点。在调用销毁功能之后，可以调用 &lt;strong&gt;graph3dView&lt;/strong&gt; 的序列化函数 &lt;strong&gt;graph3dView.deserialize('场景资源json地址')&lt;/strong&gt; 来序列化新的场景 json 文件，在序列化完成的回调函数中，可以根据新的场景修改此时 &lt;strong&gt;vr_config&lt;/strong&gt; 的值，然后再次调用 &lt;strong&gt;graph3dView.initVRForScene()&lt;/strong&gt; 来再次初始化 &lt;strong&gt;VR&lt;/strong&gt; 场景。相关的步骤伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window.GVR 是在调用 graph3dView.initVRForScene() 之后初始化的一个全局 VR 插件变量 用于用户获取插件对象&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;window.GVR.destory();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行新的场景序列化操作&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; graph3dView.deserialize('场景资源json地址'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(json, dm, g3d, datas) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改新的场景比例尺为 0.02&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     window.vr_config.measureOflength = 0.02&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改新的 VR 场景初始化视角&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     window.vr_config.vrEye =&lt;span&gt; ht.Default.clone(g3d.getEye());;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再次初始化 VR 场景&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    graph3dView.initVRForScene()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然 HT 提供的 VR 插件还有很多的配置项，方便用户更好的调整 VR 场景，包括刷地形，场景移动方式，场景操作方式都可以通过配置进行配置，利用 HT 进行 VR 搭建主要流程如下流程图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105144250023-798470602.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的流程图，我们大体可以了解配合 HT 提供的 VR 插件如何进行快速的搭建 VR 场景。&lt;/p&gt;
&lt;p&gt;目前谷歌浏览器和火狐浏览器都很友好的支持 VR，可以通过火狐官网提供的 &lt;strong&gt;&lt;a href=&quot;https://mdn.github.io/webvr-tests/raw-webgl-controller-example/&quot; target=&quot;_blank&quot;&gt;WebVR Demo&lt;/a&gt;&lt;/strong&gt; 在线感受下官方提供的 VR 场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;拆解规则&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;从文章前面的部分效果图可以看到我们每个场景的设备都有拆解，并且每个设备的零件数量，零件位置，零件拆解的方向，偏移的长短都是不一致的，所以不可能通过代码来将上面的偏移长短，偏移方向写死，需要制定一套拆解规则来帮助我们可以更方便制作每个场景的拆解动画，这样只需要设计师根据与程序约定好的拆解规则进行配置就可以配置出不同场景不同设备的拆解动画。该系统的拆解分为两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单体移动:&lt;/strong&gt; 单个设备零件沿着父节点位置和该节点位置的连接线方向移动&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合移动:&lt;/strong&gt; 多个设备零件的组合沿着某个方向移动，组合移动之后，设备零件可以在组合移动之后的位置进行再沿着某个方向进行移动，可以无限进行嵌套，即组合之后还可以组合移动，或者单体移动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单体移动示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105144416446-2116016256.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;组合移动示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105144424686-1193050562.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 HT 中可以通过 &lt;strong&gt;data.setDisplayName('名称')&lt;/strong&gt; 来给节点设置名称，这里约定通过不同设备的名称，来获取到不同设备的偏移信息，例如 &lt;strong&gt;data.setDisplayName('1-0.5-1000')&lt;/strong&gt; 该名称就是和设计师约定好的配置规则，&lt;strong&gt;1&lt;/strong&gt; 代表拆解步骤的第一步执行，当然场景中可以有多个 1，即第一步同时拆解这些零件 &lt;strong&gt;0.5&lt;/strong&gt; 代表朝着父节点的方向偏移自己位置和父节点位置连接线长度的 &lt;strong&gt;50%&lt;/strong&gt;。&lt;strong&gt;1000&lt;/strong&gt; 代表偏移的过程持续 &lt;strong&gt;1000&lt;/strong&gt; 毫秒，当然之后可以约定旋转以及旋转的角度等信息。设计师知道这些配置规则之后便可以通过可视化编辑器进行不同零件的配置，这样程序方面只需要写一套通用的逻辑就可以对不同的设备进行拆解和还原。&lt;/p&gt;
&lt;p&gt;系统中维护了一个&lt;strong&gt;队列&lt;/strong&gt;和一个&lt;strong&gt;栈&lt;/strong&gt;，&lt;strong&gt;队列&lt;/strong&gt;用来记录&lt;strong&gt;拆解顺序&lt;/strong&gt;，&lt;strong&gt;栈&lt;/strong&gt;用来记录&lt;strong&gt;还原顺序&lt;/strong&gt;。拆解的过程通过配置的序号，按顺序推进队列，采用队列的数据结构便是因为队列&lt;strong&gt;先进先出&lt;/strong&gt;的特点，第一个压入队列的零件则第一个执行，最后压入队列的零件最后一个执行拆解顺序。拆解出队列的零件则同时压入栈，采用&lt;strong&gt;栈&lt;/strong&gt;记录还原顺序是因为&lt;strong&gt;先进后出&lt;/strong&gt;的特点，即第一个执行完拆解的零件，在还原的时候却是最后一个执行还原的动作。所以上述采用的不同数据结构便是为了更好的记录数据。以下为相关 js 伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录拆解顺序&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; const queue =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录还原顺序&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; const stack =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; each 循环中用来记录拆解队列 queue 顺序&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; dataModel.each((node) = &amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     const displayName =&lt;span&gt; node.getDisplayName();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (displayName) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         const[index, distancePer, during] = displayName.split('-'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (index !== &lt;span&gt;void&lt;/span&gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (queue[index]) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (queue[index] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Array) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    queue[index].push(node);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     const tempNode =&lt;span&gt; queue[index];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     queue[index] =&lt;span&gt; [tempNode, node];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 queue[index] =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相关逻辑如下流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105144657640-773804926.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的约定，设计师可以使用可视化编辑器来配置不同零件的移动规则，大大提高了动画的制作效率。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码分析&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;该部分主要对拆解还原动画的代码进行分析，主要采用&lt;strong&gt;向量&lt;/strong&gt;和部分&lt;strong&gt;三角函数&lt;/strong&gt;的概念来计算不同零件在三维空间的位置，初始的时候需要记录下每个零件在前面所有组合移动之后的初始移动位置向量，以及零件没有组合移动之前的初始位置向量，获取这两个位置向量目的是一是为了零件拆解在前面所说组合之后移动，和零件在拆解之后恢复到一整个设备形态的初始位置，两个位置向量都有重要的作用，以下为相关伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vector3 为 HT 封装的三维向量&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; const Vector3 =&lt;span&gt; ht.Math.Vector3;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录第一个重要位置向量&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; node.a('relativeP3Vec', &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vector3(node.p3()));
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; node 当前零件节点&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; moveQueue 为移动顺序在 node 之前的，并且为 node 节点的祖先节点&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (let i = 0, l = moveQueue.length; i &amp;lt; l; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     const moveNode =&lt;span&gt; moveQueue[i],
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     parentMoveNode =&lt;span&gt; moveNode.getParent();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (parentMoveNode) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         const[, distancePer] = moveNode.getDisplayName().split('-'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         moveNode.a('defP3', moveNode.p3()) moveNode.p3(&lt;span&gt;new&lt;/span&gt; Vector3().lerpVectors(&lt;span&gt;new&lt;/span&gt; Vector3(moveNode.p3()), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vector3(parentMoveNode.p3()), distancePer).toArray());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录组合节点移动之后的第二个重要相对位置向量&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; node.a('relativeP3Vec', &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vector3(node.p3()));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 逆序还原组合的父节点位置&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (let i = moveQueue.length - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     const moveNode =&lt;span&gt; moveQueue[i];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     moveNode.p3(moveNode.a('defP3'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     moveNode.a('defP3'&lt;span&gt;, undefined);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于在场景拆解过程中需要设置设备零件节点不可选择，所以需要记录下不可选择之前的零件是否可选择状态，用来恢复节点初始状态，相关伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; dm3d.each((node) = &amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     node.a('defSelectable', node.s('3d.selectable'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文中所示的线框效果为 HT 核心包支持的线框模式，可以通过如下代码进行配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
dm3d.each((data) = &amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.s('shape3d') &amp;amp;&amp;amp; data.s('shape3d').startsWith('models/'&lt;span&gt;)) {
        data.s({
            &lt;/span&gt;'shape3d.transparent': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;'shape3d.opacity': 0, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目的为隐藏原本的模型&lt;/span&gt;
            'wf.geometry': &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启线框模式&lt;/span&gt;
            'wf.combineTriangle': 2, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线框三角面合并类型&lt;/span&gt;
            'wf.color': 'rgba(96,172,252,0.3)' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线框颜色&lt;/span&gt;
&lt;span&gt;        });
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述 &lt;strong&gt;wf.combineTriangle&lt;/strong&gt; 主要包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;false,0:&lt;/strong&gt; 不合并三角形&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;true,1:&lt;/strong&gt; 合并相邻三角为四边面，原来的效果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2:&lt;/strong&gt; 融合所有联通的共面三角面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3:&lt;/strong&gt; 根据法线信息融合所有平滑三角面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VR 软件以及硬件安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本系统采用的 &lt;strong&gt;VR&lt;/strong&gt; 硬件设备为 &lt;strong&gt;HTC VIVE&lt;/strong&gt; 接下来讲的是&lt;strong&gt;安装 HTC VIVE&lt;/strong&gt; 的过程和步骤。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一步：撮合 HTC VIVE 和电脑主机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到 &lt;strong&gt;&lt;a href=&quot;http://dl4.htc.com/web_materials/Manual/Vive/Vive_User_Guide_CHS.pdf?_ga=1.149353653.2032797701.1485487239&quot; target=&quot;_blank&quot;&gt;HTC&lt;/a&gt;&lt;/strong&gt; 官网找到连接指南，然后按照步骤安装即可，我们只需看以下截图部分的目录即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145036715-2070027276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：下载软件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到 &lt;a href=&quot;https://store.steampowered.com/steamvr&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Steam&lt;/strong&gt;&lt;/a&gt; 官网下载 Steam，下载完 Steam 可以在 Steam 中下载 Stream VR。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三步：打开 Stream VR 检查设备状态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开 Stream VR，会出现以下画面，这是用来表示 HTC VIVE 头显的工作状态的，通过图标我们即可查看头显、手柄控制器和定位器等配件的工作情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145114732-1920946188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四步：选择房间设置模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果您的房间位置比较大可以选择第一项，我选择的模式为第二项，站立模式。建议选择一种房间规模，可以完整的进行设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145129413-365702223.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第五步：将头盔、两个手柄控制器放置在两个定位器可视范围内，建立定位&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145145432-1249286427.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第六步：校准头盔中心点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该步为设置头盔默认的朝向。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145159214-1567347883.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第七步：定位地面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将两个手柄控制器放置在定位器可视范围内，然后点击电脑屏幕上的按钮“校准地面”，等待系统校准&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145213015-1912931312.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第八步：进入 Steam VR 自带房间进行测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设置完毕之后可以进入 Steam VR 自带的房间进行体验。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;当人们谈起 &lt;strong&gt;5G&lt;/strong&gt; 时代的新应用，&lt;strong&gt;VR、AR&lt;/strong&gt; 总是一大热门话题。4G 时代移动网络已经足以承载起高清视频，那么 5G 时代理所当然就能传输数据量更大的沉浸式 VR、AR 影像。因此，不少人将 5G 视为 VR、AR 崛起的踏板，随时随地&lt;strong&gt;身临&lt;/strong&gt;天涯海角，似乎并非是遥不可及的梦。当前 4G 网络应用在 VR/AR 上会带来大约 70ms 的时延，这个时延会导致体验者存在眩晕感，而 5G 数据传输的延迟可达到毫秒级，可以有效解决数据时延带来的眩晕感，有助于 VR/AR 的大规模应用。目前随着 5G 网络的逐渐普及，VR/AR 产业正逐步走向复苏，市场热情在逐渐升温，虚拟现实游戏、虚拟现实现场直播等都是 5G 在 VR/AR 上的具体应用。在科技进步的今天，安全也是一个重要的话题，VR 结合&lt;strong&gt;仿真&lt;/strong&gt;的应用也是大势所趋，&lt;strong&gt;仿真&lt;/strong&gt;可以让用户真实切身感受，例如&lt;strong&gt;消防预警&lt;/strong&gt;，&lt;strong&gt;管道预警&lt;/strong&gt;，可以让用户在 VR 世界中体验消防灭火等消防员的操作，让用户沉浸在 VR 世界中感受到火灾来临时怎么进行实际操作。所以 VR 带来的应用远远不止仿真，模拟等体验，更多带来的是能为人们提供真实的实际作用，而不是噱头。&lt;/p&gt;
&lt;p&gt;程序手机端运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145334221-547944883.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145343983-1500045311.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jan 2020 00:28:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 2019 年 VR, AR, XR, 5G, 工业互联网等名词频繁出现在我们的视野中，信息的分享与虚实的结合已经成为大势所趋，5G&amp;#160;是新一代信息通信技术升级的重要方向，工业互联网是制造</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12154649.html</dc:identifier>
</item>
<item>
<title>java poi ppt 接口的基本操作 - Cheney.Zhong.ZCY</title>
<link>http://www.cnblogs.com/zhongchengyi/p/12151756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhongchengyi/p/12151756.html</guid>
<description>&lt;h2&gt;依赖&lt;/h2&gt;
&lt;p&gt;在 pom.xml中增加以下依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.poi&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;poi-ooxml&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.1.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：很多博客，教我们用以下依赖，是没有XSSF相关内容的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 &amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.apache.poi&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;poi&amp;lt;/artifactId&amp;gt;
       &amp;lt;version&amp;gt;3.14&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; version 版本&lt;/h3&gt;
&lt;p&gt;poi的版本可以在 &lt;a href=&quot;https://mvnrepository.com/artifact/org.apache.poi/poi&quot;&gt;https://mvnrepository.com/artifact/org.apache.poi/poi&lt;/a&gt; 进行查询。&lt;/p&gt;
&lt;p&gt;找到想要依赖的版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/625732/202001/625732-20200105110337357-302634339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 点击进入后，可以直接复制里面的依赖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/625732/202001/625732-20200105110501264-1109311859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;初始化 &lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
import org.apache.poi.sl.usermodel.SlideShow;
import org.apache.poi.sl.usermodel.SlideShowFactory;

SlideShow slideShow = SlideShowFactory.create(new File(&quot;./res/1.pptx&quot;));　　
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;如果文件不存在或文件正在使用，create 方法抛出 IOException 异常&lt;/li&gt;
&lt;li&gt;如果文件损坏，create 方法抛出 EncryptedDocumentException 异常&lt;/li&gt;
&lt;li&gt; 返回值 SlideShow 代表整个ppt文档，可以通过 SlieShow.getSlides() 获取每张幻灯片进行操作，以及获取整个ppt的信息，如页面大小(getPageSize, setPageSize)，图片数据(getPictureData, setPictureData)，字体，输出到流等&lt;/li&gt;
&lt;li&gt;通过SlideShow.getSlides()后操作Slide都可以反应到SlideShow。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Slide&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt; slide代表幻灯片的一页&lt;/li&gt;
&lt;li&gt;也是代表open-xml中  /ppt/sliders/*.xml 中的一个xml文档&lt;/li&gt;
&lt;li&gt;Slide只有一个实现类 XSLFSlide&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;获取方法&lt;/h3&gt;
&lt;p&gt;XSLFSlide未提供public的构造函数，获取只能通过SlideShow中提供的createSlide, getSlides方法获取。&lt;/p&gt;
&lt;p&gt;如图：XSLFSlide的构造函数，都是私有的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/625732/202001/625732-20200105115041235-2057255696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;如图：SlideShow中提供的Slide获取方法， 由于 Slide 接口只有一个实现(XLSFSlide)，所以可以直接转换成实现类(XLSFSlide)操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/625732/202001/625732-20200105114534438-1821577658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;常用操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;获取所有的备注&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
XSLFNotes notes = slider.getNotes();
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;获取所有的批注&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
List&amp;lt;XSLFComment&amp;gt; comments = slider.getComments();
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;获取所有的关联部分，包括：备注，批注，图片，图表，母版等&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
List&amp;lt;POIXMLDocumentPart.RelationPart&amp;gt; relationParts = slider.getRelationParts();
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;获取备注，批注都是从 getRelationParts中获取的&lt;/li&gt;
&lt;li&gt;除了图形的获取，其他元素的获取都可以通过此方法获取（通过遍历判断类型）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;获取所有的图形&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
List&amp;lt;XSLFShape&amp;gt; shapes = slider.getShapes();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;POIXMLDocumentPart&lt;/h2&gt;
&lt;p&gt;POIXMLDocmentPart是一个ppt关联的部分的具体内容，包括：备注、批注、图片、图表、母版等。&lt;/p&gt;
&lt;p&gt;通过 &lt;span class=&quot;cnblogs_code&quot;&gt;POIXMLDocumentPart documentPart = POIXMLDocumentPart.RelationPart.getDocumentPart()&lt;/span&gt; 获取。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;批注部分， 与 slider.getComments() 对应&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (documentPart &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; XSLFComments) {
    XSLFComments comments1 &lt;/span&gt;=&lt;span&gt; (XSLFComments) documentPart;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (documentPart &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; XSLFChart) {
    XSLFChart chart &lt;/span&gt;=&lt;span&gt; (XSLFChart) documentPart;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (documentPart &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; XSLFNotes) {
          XSLFNotes notes1 &lt;/span&gt;=&lt;span&gt; (XSLFNotes) documentPart;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;获取备注的一行文本&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本段落，一行为一段&lt;/span&gt;
List&amp;lt;List&amp;lt;XSLFTextParagraph&amp;gt;&amp;gt; textParagraphs =&lt;span&gt; notes1.getTextParagraphs();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一行的所有文本，包含文本样式&lt;/span&gt;
List&amp;lt;XSLFTextRun&amp;gt; textRuns = textParagraphs.get(0).get(0&lt;span&gt;).getTextRuns();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一行的文本内容&lt;/span&gt;
String text = textParagraphs.get(0).get(0&lt;span&gt;).getText();
 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;
&lt;pre&gt;
母版，只有一个
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (documentPart &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; XSLFSlideLayout) {
   XSLFSlideLayout relation1 &lt;/span&gt;=&lt;span&gt; (XSLFSlideLayout) documentPart;
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;XSLFShape&lt;/h2&gt;
&lt;p&gt;获取 shape 的文本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (XSLFShape shape : shapes) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (shape &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; XSLFTextShape) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有文本的 sharpe&lt;/span&gt;
                    XSLFTextShape textShape =&lt;span&gt; (XSLFTextShape) shape;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本段落，一行为一段&lt;/span&gt;
                    List&amp;lt;XSLFTextParagraph&amp;gt; textParagraphs =&lt;span&gt; textShape.getTextParagraphs();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一行的所有文本，包含文本样式&lt;/span&gt;
                    List&amp;lt;XSLFTextRun&amp;gt; textRuns = textParagraphs.get(0&lt;span&gt;).getTextRuns();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一行的文本内容&lt;/span&gt;
                    String text = textParagraphs.get(0&lt;span&gt;).getText();
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (shape &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; XSLFGroupShape) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图形组合&lt;/span&gt;
                    XSLFGroupShape groupShape =&lt;span&gt; (XSLFGroupShape) shape;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图形组合下的图形，可以与 slider.getShapes() 获取的list一样操作&lt;/span&gt;
                    List&amp;lt;XSLFShape&amp;gt; groupShapeShapes =&lt;span&gt; groupShape.getShapes();
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 06 Jan 2020 00:24:00 +0000</pubDate>
<dc:creator>Cheney.Zhong.ZCY</dc:creator>
<og:description>依赖 在 pom.xml中增加以下依赖 注：很多博客，教我们用以下依赖，是没有XSSF相关内容的 version 版本 poi的版本可以在&amp;#160;https://mvnrepository.com</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhongchengyi/p/12151756.html</dc:identifier>
</item>
<item>
<title>【超详细】一文学会链表解题 - ErnestEvan</title>
<link>http://www.cnblogs.com/xiekun/p/12154631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiekun/p/12154631.html</guid>
<description>&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。 因为像堆，栈，对，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就来看看链表的基本操作及其在面试中的常见解题思路,本文将从以下几个点来讲解链表的核心知识&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;什么是链表，链表的优缺点&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;链表的表示及基本操作&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;面试中链表的常见解题思路---翻转&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;面试中链表的常见解题思路---快慢指针&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是链表&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家已经开始迫不及待地想用链表解题了，不过在开始之前我们还是要先来温习下链表的定义，以及它的优势与劣势，磨刀不误砍柴功！&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;链表的定义&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表是物理存储单元上&lt;strong&gt;非连续&lt;/strong&gt;的、&lt;strong&gt;非顺序&lt;/strong&gt;的存储结构，它是由一个个结点，通过指针来联系起来的，其中每个结点包括数据和指针。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782de0fa258ad?w=549&amp;amp;h=96&amp;amp;f=png&amp;amp;s=7045&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表的&lt;strong&gt;非连续&lt;/strong&gt;，&lt;strong&gt;非顺序&lt;/strong&gt;，对应数组的&lt;strong&gt;连续&lt;/strong&gt;，&lt;strong&gt;顺序&lt;/strong&gt;，我们来看看整型数组 1，2，3，4 在内存中是如何表示的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/5/16f75d44d900b2e3?w=564&amp;amp;h=170&amp;amp;f=png&amp;amp;s=11612&quot; alt=&quot;&quot;/&gt; 可以看到数组的每个元素都是连续紧邻分配的，这叫连续性，同时由于数组的元素占用的大小是一样的，在 Java 中 int 型大小固定为 4 个字节,所以如果数组的起始地址是 100， 由于这些元素在内存中都是连续紧邻分配的，大小也一样，可以很容易地找出数组中任意一个元素的位置，比如数组中的第三个元素起始地址为 100 + 2 * 4 = 108,这就叫顺序性。查找的时间复杂度是O(1),效率很高！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那链表在内存中是怎么表示的呢&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782de104136ab?w=1286&amp;amp;h=222&amp;amp;f=png&amp;amp;s=24232&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到每个结点都分配在&lt;strong&gt;非连续&lt;/strong&gt;的位置，结点与结点之间通过指针连在了一起，所以如果我们要找比如值为 3 的结点时，只能通过结点 1 从头到尾遍历寻找，如果元素少还好，如果元素太多（比如超过一万个），每个元素的查找都要从头开始查找，时间复杂度是O(n)，比起数组的 O(1)，差距不小。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了查找性能链表不如数组外，还有一个优势让数组的性能高于链表,这里引入&lt;strong&gt;程序局部性原理&lt;/strong&gt;，啥叫程序局部性原理。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道 CPU 运行速度是非常快的，如果 CPU 每次运算都要到内存里去取数据无疑是很耗时的，所以在 CPU 与内存之间往往集成了挺多层级的缓存，这些缓存越接近CPU，速度越快，所以如果能提前把内存中的数据加载到如下图中的 L1, L2, L3 缓存中，那么下一次 CPU 取数的话直接从这些缓存里取即可，能让CPU执行速度加快，那什么情况下内存中的数据会被提前加载到 L1,L2,L3 缓存中呢，答案是当某个元素被用到的时候，那么这个元素地址附近的的元素会被提前加载到缓存中&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782de11e40e1e?w=1080&amp;amp;h=555&amp;amp;f=png&amp;amp;s=104408&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上文整型数组 1，2，3，4为例，当程序用到了数组中的第一个元素（即 1）时，由于 CPU 认为既然 1 被用到了，那么紧邻它的元素 2，3，4 被用到的概率会很大，所以会提前把 2，3，4 加到 L1,L2,L3 缓存中去，这样 CPU 再次执行的时候如果用到 2，3，4，直接从 L1,L2,L3 缓存里取就行了，能提升不少性能&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;画外音：如果把CPU的一个时种看成一秒，则从 L1 读取数据需要 3 秒，从 L2 读取需要 11 秒，L3读取需要 25秒，而从内存读取呢，需要 1 分 40 秒，所以程序局部性原理能对 CPU 执行性能有很大的提升&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而链表呢，由于链表的每个结点在内存里都是随机分布的，只是通过指针联系在一起，所以这些结点的地址并不相邻，自然无法利用 &lt;strong&gt;程序局部性原理&lt;/strong&gt; 来提前加载到 L1,L2,L3 缓存中来提升程序性能。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;画外音：程序局部性原理是计算机中非常重要的原理，这里不做展开，建议大家查阅相关资料详细了解一下&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所述，相比数组，链表的&lt;strong&gt;非连续&lt;/strong&gt;，&lt;strong&gt;非顺序&lt;/strong&gt;确实让它在性能上处于劣势，那什么情况下该使用链表呢？考虑以下情况&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;大内存空间分配&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于数组空间的&lt;strong&gt;连续性&lt;/strong&gt;，如果要为数组分配 500M 的空间，这 500M 的空间必须是&lt;strong&gt;连续的&lt;/strong&gt;，未使用的，所以在内存空间的分配上数组的要求会比较严格，如果内存碎片太多，分配连续的大空间很可能导致失败。而链表由于是非连续的，所以这种情况下选择链表更合适。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;元素频繁删除和插入&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果涉及到元素的频繁删除和插入，用链表就会高效很多，对于数组来说，如果要在元素间插入一个元素，需要把其余元素一个个往后移（如图示），以为新元素腾空间（同理，如果是删除则需要把被删除元素之后的元素一个个往前移），效率上无疑是比较低的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782de10ed4bbb?w=478&amp;amp;h=98&amp;amp;f=gif&amp;amp;s=3408&quot; alt=&quot;&quot;/&gt; (在 1，2 间插入 5，需要把2，3，4 同时往后移一位)&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而链表的插入删除相对来说就比较简单了，修改指针位置即可，其他元素无需做任何移动操作（如图示：以插入为例） &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782de16bc1e00?w=1122&amp;amp;h=320&amp;amp;f=gif&amp;amp;s=71787&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述：如果数据以查为主，很少涉及到增和删，选择数组，如果数据涉及到频繁的插入和删除，或元素所需分配空间过大，倾向于选择链表。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多理论，相信读者对数组和链表的区别应该有了更深刻地认识了，尤其是 &lt;strong&gt;程序局部性原理&lt;/strong&gt;，是不是开了不少眼界^_^，如果面试中问到数组和链表的区别能回答到程序局部性原理，会是一个&lt;strong&gt;非常大的亮点&lt;/strong&gt;！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看看链表的表现形式和解题技巧&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要说明的是有些代码像打印链表等限于篇幅的关系没有在文中展示，我把文中所有相关代码都放到 github 中了，大家如果需要，可以访问我的 github 地址: https://github.com/allentofight/algorithm 下载运行（微信不支持外链，建议大家 copy 之后浏览器打开再下载运行），文中所有代码均已用 Java 实现并运行通过&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;链表的表示&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于链表的特点（查询或删除元素都要从头结点开始）,所以我们只要在链表中定义头结点即可,另外如果要频繁用到链表的长度，还可以额外定义一个变量来表示。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是这个头结点的定义是有讲究的，一般来说头结点有两种定义形式，一种是直接以某个元素结点为头结点,如下&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782de0e69f0a2?w=608&amp;amp;h=119&amp;amp;f=png&amp;amp;s=8159&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种是以一个虚拟的节点作为头结点，即我们常说的&lt;strong&gt;哨兵&lt;/strong&gt;，如下&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782dec672b68a?w=641&amp;amp;h=117&amp;amp;f=png&amp;amp;s=8256&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义这个哨兵有啥好处呢，假设我们不定义这个哨兵，来看看链表及添加元素的基本操作怎么定义的&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; data;
    Node next = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; data)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.data = data;
    }
}


&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LinkedList&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; 
    Node head = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;; 

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;addNode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (head == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
            head = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node(val);
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
            Node tmp = head;
            &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (tmp.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
                tmp = tmp.next;
            }
            tmp.next = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node(val);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现问题了吗，注意看下面代码 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782dec5469770?w=273&amp;amp;h=127&amp;amp;f=png&amp;amp;s=11975&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两个问题：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;每插入一个元素都要对头结点进行判空比较，如果一个链表有很多元素需要插入，就需要进行很多次的判空处理，不是那么高效&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;头结点与其他结点插入逻辑不统一（一个需要判空后再插入，一个不需要判空直接插入）,从程序逻辑性来说不是那么合理（因为结点与结点是平级，添加逻辑理应相同）&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果定义了哨兵结点，以上两个问题都可解决，来看下使用哨兵结点的链表定义&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LinkedList&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; 
    Node head = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;); 
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;addNode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;{
        Node tmp = head;
        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (tmp.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
            tmp = tmp.next;
        }
        tmp.next = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node(val);
        length++
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，定义了哨兵结点的链表逻辑上清楚了很多,不用每次插入元素都对头结点进行判空，也统一了每一个结点的添加逻辑。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以之后的习题讲解中我们使用的链表都是使用定义了哨兵结点的形式。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做了这么多前期的准备工作，终于要开始我们的正餐了：链表解题常用套路--翻转！&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;链表常见解题套路--翻转&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;热身赛&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们要用链表解题，那我们首先就构造一个链表吧 题目：给定数组 1，2，3，4 构造成如下链表 head--&amp;gt;4----&amp;gt;3----&amp;gt;2----&amp;gt;1&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看清楚了，是逆序构造链表！顺序构造我们都知道怎么构造，对每个元素持续调用上文代码定义的 addNode 方法即可（即尾插法），与尾插法对应的，是&lt;strong&gt;头插法&lt;/strong&gt;，即把每一个元素插到头节点后面即可，这样就能做到逆序构造链表，如图示（以插入1，2 为例）&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782decc8b4cee?w=492&amp;amp;h=141&amp;amp;f=gif&amp;amp;s=5011&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;头插法比较简单，直接上代码,直接按以上动图的步骤来完成逻辑，如下&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LinkedList&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; 
    Node head = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;); 
    
     
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;headInsert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;{
        
        Node newNode = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node(val);
        
        newNode.next = head.next;
        
        head.next = newNode;
        length++
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{
        LinkedList linkedList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LinkedList();
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] arr = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;};
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++) {
            linkedList.headInsert(arr[i]);
        }
        
        linkedList.printList();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小试牛刀&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们加大一下难度，来看下曾经的 Google 面试题： 给定单向链表的头指针和一个节点指针，定义一个函数在 O(1) 内删除这个节点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782dee402614d?w=648&amp;amp;h=275&amp;amp;f=png&amp;amp;s=13143&quot; alt=&quot;&quot;/&gt; 如图示：即给定值为 2 的结点，如何把 2 给删了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，如果给定一个结点要删除它的后继结点是很简单的，只要把这个结点的指针指向后继结点的后继结点即可&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782dee4282d74?w=377&amp;amp;h=264&amp;amp;f=png&amp;amp;s=10363&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图示：给定结点 2，删除它的后继结点 3， 把结点 2 的 next 指针指向 3 的后继结点 4 即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但给定结点 2，该怎么删除结点 2 本身呢，注意题目没有规定说不能改变结点中的值，所以有一种很巧妙的方法，狸猫换太子！我们先通过结点 2 找到结点 3，再把节点 3 的值赋给结点 2，此时结点 2 的值变成了 3，这时候问题就转化成了上图这种比较简单的需求，即根据结点 2 把结点 3 移除即可，看图&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782def95ded31?w=1008&amp;amp;h=904&amp;amp;f=png&amp;amp;s=56586&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过需要注意的是这种解题技巧只适用于被删除的指定结点是中间结点的情况，如果指定结点是尾结点，还是要老老实实地找到尾结点的前继结点，再把尾结点删除，代码如下&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;removeSelectedNode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Node deletedNode)&lt;/span&gt; &lt;/span&gt;{
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (deletedNode.next == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        Node tmp = head;
        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (tmp.next != deletedNode) {
            tmp = tmp.next;
        }
        
        tmp.next = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;
    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
        Node nextNode = deletedNode.next;
        
        deletedNode.data = nextNode.data;
        
        deletedNode.next = nextNode.next;
        nextNode.next = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;入门到进阶:链表翻转&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们会重点看一下链表的翻转，链表的翻转可以衍生出很多的变形，是面试中非常热门的考点，基本上考链表必考翻转！所以掌握链表的翻转是必修课！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是链表的翻转:给定链表 &lt;strong&gt;head--&amp;gt;4---&amp;gt;3--&amp;gt;2--&amp;gt;1&lt;/strong&gt;，将其翻转成 &lt;strong&gt;head--&amp;gt;1--&amp;gt;2--&amp;gt;3--&amp;gt;4&lt;/strong&gt; ，由于翻转链表是如此常见，如此重要，所以我们分别详细讲解下如何用递归和非递归这两种方式来解题&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;递归翻转&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于递归的文章之前写了三篇，如果之前没读过的，强烈建议点击&lt;a href=&quot;https://mp.weixin.qq.com/s/yslcZ-KoVnDD27A1VpJs2w&quot;&gt;这里&lt;/a&gt;查看，总结了递归的常见解题套路,给出了递归解题的常见四步曲，如果看完对以下递归的解题套路会更加深刻，这里不做赘述了，我们直接套递归的解题思路：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们要查看翻转链表是否符合递归规律：问题可以分解成&lt;strong&gt;具有相同解决思路&lt;/strong&gt;的子问题，子子问题...，直到最终的子问题再也无法分解。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要翻转 head---&amp;gt;4---&amp;gt;3--&amp;gt;2--&amp;gt;1 链表，不考虑 head 结点，分析 4---&amp;gt;3--&amp;gt;2--&amp;gt;1，仔细观察我们发现只要先把 3--&amp;gt;2--&amp;gt;1 翻转成 3&amp;lt;----2&amp;lt;----1，之后再把 3 指向 4 即可（如下图示）&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782df6b23d3fe?w=818&amp;amp;h=552&amp;amp;f=png&amp;amp;s=40521&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图：翻转链表主要三步骤&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要按以上步骤定义好这个翻转函数的功能即可， 这样由于子问题与最初的问题具有&lt;strong&gt;相同的解决思路&lt;/strong&gt;，拆分后的子问题持续调用这个翻转函数即可达到目的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意看上面的步骤1，问题的规模是不是缩小了（如下图），从翻转整个链表变成了只翻转部分链表！问题与子问题都是从某个结点开始翻转，具有&lt;strong&gt;相同的解决思路&lt;/strong&gt;，另外当缩小到只翻转一个结点时，显然是终止条件，符合递归的条件！之后的翻转 3--&amp;gt;2--&amp;gt;1, 2--&amp;gt;1 持续调用这个定义好的递归函数即可！&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782df6398e500?w=452&amp;amp;h=341&amp;amp;f=png&amp;amp;s=17786&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然符合递归的条件，那我们就可以套用&lt;a href=&quot;https://mp.weixin.qq.com/s/Hew44D8rdXb3pf8mZGk67w&quot;&gt;递归四步曲&lt;/a&gt;来解题了（注意翻转之后 head 的后继节点变了，需要重新设置！别忘了这一步）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、定义递归函数,明确函数的功能 根据以上分析，这个递归函数的功能显然是翻转某个节点开始的链表，然后返回新的头结点&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;invertLinkedList&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Node node)&lt;/span&gt; &lt;/span&gt;{
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、寻找递推公式 上文中已经详细画出了翻转链表的步骤，简单总结一下递推步骤如下&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;针对结点 node (值为 4), 先翻转 node 之后的结点 invert(node-&amp;gt;next) ,翻转之后 4---&amp;gt;&lt;strong&gt;3---&amp;gt;2---&amp;gt;1&lt;/strong&gt; 变成了 4---&amp;gt;&lt;strong&gt;3&amp;lt;---2&amp;lt;---1&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;再把 node 节点的下个节点（3）指向 node，node 的后继节点设置为空（避免形成环），此时变成了 4&amp;lt;---3&amp;lt;---2&amp;lt;---1&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;返回新的头结点，因为此时新的头节点从原来的 4 变成了 1，需要重新设置一下 head&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、将递推公式代入第一步定义好的函数中，如下 (invertLinkedList)&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;invertLinkedList&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Node node)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (node.next == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; node;
    }

    
    Node newHead = invertLinkedList(node.next);

    
    node.next.next = node;
    node.next = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; newHead;
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{
    LinkedList linkedList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LinkedList();
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] arr = {&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;};
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++) {
        linkedList.addNode(arr[i]);
    }
    Node newHead = linkedList.invertLinkedList(linkedList.head.next);
    
    linkedList.head.next = newHead;
    linkedList.printList();      
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画外音：翻转后由于 head 的后继结点变了，别忘了重新设置哦！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、计算时间/空间复杂度 由于递归调用了 n 次 invertLinkedList 函数，所以时间复杂度显然是 O(n), 空间复杂度呢，没有用到额外的空间，但是由于递归调用了 n 次 invertLinkedList 函数，压了 n 次栈，所以空间复杂度也是 O(n)。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归一定要从&lt;strong&gt;函数的功能&lt;/strong&gt;去理解，从函数的功能看，定义的递归函数清晰易懂，定义好了之后，由于问题与被拆分的子问题具有相同的解决思路，所以子问题只要持续调用定义好的功能函数即可，切勿层层展开子问题，此乃递归常见的陷阱！仔细看函数的功能，其实就是按照下图实现的。(对照着代码看，是不是清晰易懂^_^)&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782df6f2cc203?w=850&amp;amp;h=560&amp;amp;f=png&amp;amp;s=41295&quot; alt=&quot;&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;非递归翻转链表（迭代解法）&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道递归比较容易造成栈溢出，所以如果有其他时间/空间复杂度相近或更好的算法，应该优先选择非递归的解法,那我们看看如何用迭代来翻转链表，主要思路如下&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782df74df05f8?w=399&amp;amp;h=327&amp;amp;f=png&amp;amp;s=15174&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤 1： 定义两个节点：pre, cur ，其中 cur 是 pre 的后继结点，如果是首次定义， 需要把 pre 指向 cur 的指针去掉，否则由于之后链表翻转，cur 会指向 pre， 就进行了一个环(如下)，这一点需要注意 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782df96f93431?w=652&amp;amp;h=164&amp;amp;f=png&amp;amp;s=10748&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤2：知道了 cur 和 pre,翻转就容易了，把 cur 指向 pre 即可，之后把 cur 设置为 pre ，cur 的后继结点设置为 cur 一直往前重复此步骤即可,完整动图如下&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782dfb8ab7ef5?w=670&amp;amp;h=166&amp;amp;f=gif&amp;amp;s=35505&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：同递归翻转一样，迭代翻转完了之后 head 的后继结点从 4 变成了 1，记得重新设置一下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了解题思路，实现代码就容易多了，直接上代码&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;iterationInvertLinkedList&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    
    Node pre = head.next;
    Node cur = pre.next;
    pre.next = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (cur != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        
        Node next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    
    head.next = pre;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用迭代的思路来做由于循环了 n 次，显然时间复杂度为 O(n),另外由于没有额外的空间使用，也未像递归那样调用递归函数不断压栈，所以空间复杂度是 O(1),对比递归，显然应该使用迭代的方式来处理！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;花了这么大的精力我们总算把翻转链表给搞懂了，如果大家看了之后几道翻转链表的变形，会发现我们花了这么大篇幅讲解翻转链表是值得的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看看链表翻转的变形&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变形题 1： 给定一个链表的头结点 head,以及两个整数 from 和 to ,在链表上把第 from 个节点和第 to 个节点这一部分进行翻转。 例如：给定如下链表，from = 2, to = 4 head--&amp;gt;5--&amp;gt;&lt;strong&gt;4--&amp;gt;3--&amp;gt;2&lt;/strong&gt;--&amp;gt;1 将其翻转后，链表变成 head--&amp;gt;5---&amp;gt;&lt;strong&gt;2--&amp;gt;3--&amp;gt;4&lt;/strong&gt;--&amp;gt;1&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了之前翻转整个链表的解题思路，现在要翻转部分链表就相对简单多了,主要步骤如下:&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;根据 from 和 to 找到 from-1, from, to, to+1 四个结点(注意&lt;strong&gt;临界条件&lt;/strong&gt;，如果 from 从头结点开始，则 from-1 结点为空, 翻转后需要把 to 设置为头结点的后继结点， from 和 to 结点也可能超过尾结点,这两种情况不符合条件不翻转)。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;对 from 到 to 的结点进行翻转&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;将 from-1 节点指向 to 结点，将 from 结点指向 to + 1 结点&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782e0296dc850?w=990&amp;amp;h=822&amp;amp;f=png&amp;amp;s=50530&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了以上的思路，代码就简单了,按上面的步骤1，2，3 实现，注释也写得很详细，看以下代码（对 from 到 to 结点的翻转我们使用迭代翻转，当然使用递归也是可以的，限于篇幅关系不展开，大家可以尝试一下）。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;iterationInvertLinkedList&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; fromIndex, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; toIndex)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{

    Node fromPre = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;            
    Node from = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;               
    Node to = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;                 
    Node toNext = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;             

    
    Node tmp = head.next;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; curIndex = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;      
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (tmp != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (curIndex == fromIndex-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {
            fromPre = tmp;
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (curIndex == fromIndex) {
            from = tmp;
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (curIndex == toIndex) {
            to = tmp;
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (curIndex == toIndex+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {
            toNext = tmp;
        }
        tmp = tmp.next;
        curIndex++;
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (from == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; || to == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Exception(&lt;span class=&quot;hljs-string&quot;&gt;&quot;不符合条件&quot;&lt;/span&gt;);
    }

    
    Node pre = from;
    Node cur = pre.next;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (cur != toNext) {
        Node next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (fromPre != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        fromPre.next = to;
    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
        head.next = to;
    }
    from.next = toNext;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变形题 2： 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 : 给定这个链表：head--&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 当 k = 2 时，应当返回: head--&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5 当 k = 3 时，应当返回: head--&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5 说明 :&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;你的算法只能使用常数的额外空间。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题是 LeetCode 的原题,属于 hard 级别，如果这一题你懂了，那对链表的翻转应该基本没问题了，有了之前的翻转链表基础，相信这题不难。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要我们能找到翻一组 k 个结点的方法，问题就解决了（之后只要重复对 k 个结点一组的链表进行翻转即可）。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们以以下链表为例 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782e019e83659?w=816&amp;amp;h=210&amp;amp;f=png&amp;amp;s=15441&quot; alt=&quot;&quot;/&gt; 来看看怎么翻转 3 个一组的链表（此例中 k = 3）&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;0.5&quot;&gt;
&lt;section readability=&quot;7&quot;&gt;&lt;p&gt;首先，我们要记录 3 个一组这一段链表的前继结点,定义为 startKPre,然后再定义一个 step, 从这一段的头结点 (1）开始遍历 2 次，找出这段链表的起始和终止结点，如下图示 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782e01740726b?w=850&amp;amp;h=364&amp;amp;f=gif&amp;amp;s=31812&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;找到 startK 和 endK 之后，根据之前的迭代翻转法对 startK 和 endK 的这段链表进行翻转 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782e0351f5896?w=882&amp;amp;h=250&amp;amp;f=png&amp;amp;s=24761&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;section readability=&quot;4&quot;&gt;&lt;p&gt;然后将 startKPre 指向 endK,将 startK 指向 endKNext，即完成了对 k 个一组结点的翻转。 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782e040209a42?w=1122&amp;amp;h=356&amp;amp;f=png&amp;amp;s=29520&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了一组 k 个怎么翻转，之后只要重复对 k 个结点一组的链表进行翻转即可，对照图示看如下代码应该还是比较容易理解的&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;iterationInvertLinkedListEveryK&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;{
    Node tmp = head.next;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; step = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;               

    Node startK = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;         
    Node startKPre = head;      
    Node endK;                  
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (tmp != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        
        Node tmpNext = tmp.next;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (step == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {
            
            startK = tmp;
            step++;
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (step == k-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {
            
            endK = tmp;
            Node pre = startK;
            Node cur = startK.next;
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (cur == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;
            }
            Node endKNext = endK.next;
            &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (cur != endKNext) {
                Node next = cur.next;
                cur.next = pre;
                pre = cur;
                cur = next;
            }
            
            startKPre.next = endK;
            startK.next = endKNext;

            
            startKPre = startK;
            step = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
            step++;
        }
        tmp = tmpNext;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间复杂度是多少呢，对链表从头到尾循环了 n 次，同时每 k 个结点翻转一次，可以认为总共翻转了 n 次，所以时间复杂度是O(2n),去掉常数项，即为 O(n)。 注：这题时间复杂度比较误认为是O(k * n),实际上并不是每一次链表的循环都会翻转链表，只是在循环链表元素每 k 个结点的时候才会翻转&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变形3: 变形 2 针对的是顺序的 k 个一组翻转，那如何逆序 k 个一组进行翻转呢&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：给定如下链表， head--&amp;gt;1--&amp;gt;2--&amp;gt;3--&amp;gt;4--&amp;gt;5 逆序 k 个一组翻转后，链表变成（k = 2 时） head--&amp;gt;1---&amp;gt;3--&amp;gt;2--&amp;gt;5--&amp;gt;4&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题是字节跳动的面试题，确实够变态的，顺序 k 个一组翻转都已经属于 hard 级别了，逆序 k 个一组翻转更是属于 super hard 级别了，不过其实有了之前知识的铺垫，应该不难，只是稍微变形了一下，只要对链表做如下变形即可&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782e064c363ef?w=1182&amp;amp;h=862&amp;amp;f=png&amp;amp;s=62648&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的每一步其实都是用了我们之前实现好的函数，所以我们之前做的每一步都是有伏笔的哦！就是为了解决字节跳动这道终极面试题！&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reverseIterationInvertLinkedListEveryK&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;{
    
    iterationInvertLinkedList();
    
    iterationInvertLinkedListEveryK(k);
    
    iterationInvertLinkedList();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，掌握基本的链表翻转非常重要！难题多是在此基础了做了相应的变形而已&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;链表解题利器---快慢指针&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快慢指针在面试中出现的概率也很大，也是务必要掌握的一个要点，本文总结了市面上常见的快慢指针解题技巧，相信看完后此类问题能手到擒来。本文将详细讲述如何用快慢指针解决以下两大类问题&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;寻找/删除第 K 个结点&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;有关链表环问题的相关解法&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;寻找/删除第 K 个结点&lt;/span&gt;&lt;/h3&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小试牛刀之一&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;LeetCode 876：给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解法一&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要知道链表的中间结点，首先我们需要知道链表的长度，说到链表长度大家想到了啥，还记得我们在&lt;a href=&quot;https://mp.weixin.qq.com/s/Thxzq5JBWVsKNGWYSH6sDA&quot;&gt;上文&lt;/a&gt;中说过哨兵结点可以保存链表的长度吗，这样直接 &lt;strong&gt;从 head 的后继结点&lt;/strong&gt; 开始遍历 &lt;strong&gt;链表长度 / 2&lt;/strong&gt; 次即可找到中间结点。为啥中间结点是 链表长度/2，我们仔细分析一下&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;假如链表长度是奇数: head---&amp;gt;1---&amp;gt;2---&amp;gt;3---&amp;gt;4---&amp;gt;5, 从 1 开始遍历 5/2 = 2 （取整）次，到达 3，3确实是中间结点&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;假如链表长度是偶数: head---&amp;gt;1---&amp;gt;2---&amp;gt;3---&amp;gt;4---&amp;gt;5---&amp;gt;6, 从 1 开始遍历 6/2 = 3次，到达 4，4 确实是中间结点的第二个结点&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;画外音：多画画图，举举例，能看清事情的本质！&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨后结点的长度派上用场了，这种方式最简单，直接上代码&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;findMiddleNode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    Node tmp = head.next;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; middleLength = length / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (middleLength &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {
        tmp = tmp.next;
        middleLength--;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; tmp;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解法二&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果哨兵结点里没有定义长度呢，那就要遍历一遍链表拿到链表长度（定义为 length）了，然后再从头结点开始遍历 length / 2 次即为中间结点&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;findMiddleNodeWithoutHead&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    Node tmp = head.next;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (tmp.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        tmp = tmp.next;
        length++;
    }

    
    tmp = head.next;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; middleLength = length / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (middleLength &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {
        tmp = tmp.next;
        middleLength--;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; tmp;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解法三&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解法二由于要遍历两次链表，显得不是那么高效，那能否只遍历一次链表就能拿到中间结点呢。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就引入我们的快慢指针了，主要有三步 1、 快慢指针同时指向 head 的后继结点 2、 慢指针走一步，快指针走两步 3、 不断地重复步骤2，什么时候停下来呢，这取决于链表的长度是奇数还是偶数&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;section readability=&quot;4&quot;&gt;&lt;p&gt;如果链表长度为奇数,当 fast.next = null 时,slow 为中间结点 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/4/16f701380fa65c9d?w=1041&amp;amp;h=169&amp;amp;f=gif&amp;amp;s=41822&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;section readability=&quot;7&quot;&gt;&lt;p&gt;如果链表长度为偶数,当 fast = null 时,slow 为中间结点 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/4/16f70137b38538f7?w=1240&amp;amp;h=216&amp;amp;f=gif&amp;amp;s=59198&quot; alt=&quot;&quot;/&gt; 由以上分析可知:当 fast = null 或者 fast.next = null 时，此时的 slow 结点即为我们要求的中间结点,否则不断地重复步骤 2， 知道了思路，代码实现就简单了&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;findMiddleNodeWithSlowFastPointer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    Node slow = head.next;
    Node fast = head.next;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (fast != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; fast.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        
        fast = fast.next.next;
        
        slow = slow.next;
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; slow;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了上面的基础，我们现在再大一下难度，看下下面这道题&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;输入一个链表，输出该链表中的倒数第 k 个结点。比如链表为 head--&amp;gt;1--&amp;gt;2--&amp;gt;3--&amp;gt;4--&amp;gt;5。求倒数第三个结点（即值为 3 的节点）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：我们知道如果要求顺序的第 k 个结点还是比较简单的，从 head 开始遍历 k 次即可，如果要求逆序的第 k 个结点，常规的做法是先顺序遍历一遍链表，拿到链表长度，然后再遍历 链表长度-k 次即可，这样要遍历两次链表，不是那么高效，如何只遍历一次呢，还是用我们的说的快慢指针解法&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;首先让快慢指针同时指向 head 的后继结点&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;快指针往前走 k- 1 步,先走到第 k 个结点&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;快慢指针同时往后走一步，不断重复此步骤，直到快指针走到尾结点,此时的 slow 结点即为我们要找的倒序第 k 个结点&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/4/16f701375b4835c6?w=962&amp;amp;h=267&amp;amp;f=gif&amp;amp;s=53172&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：需要注意临界情况：k 大于链表的长度，这种异常情况应该&lt;strong&gt;抛异常&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;findKthToTail&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{
    Node slow = head.next;
    Node fast = head.next;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; tmpK = k - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (tmpK &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; fast != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        fast = fast.next;
        tmpK--;
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (fast == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Exception(&lt;span class=&quot;hljs-string&quot;&gt;&quot;K结点不存在异常&quot;&lt;/span&gt;);
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (fast.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        slow = slow.next;
        fast = fast.next;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; slow;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了如何求倒序第 k 个结点，再来看看下面这道题&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;给定一个单链表，设计一个算法实现链表向右旋转 K 个位置。举例： 给定 head-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, K=3,右旋后即为 head-&amp;gt;3-&amp;gt;4-&amp;gt;5--&amp;gt;1-&amp;gt;2-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：这道题其实是对求倒序第 K 个位置的的一个变形，主要思路如下&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;先找到倒数第 K+1 个结点, 此结点的后继结点即为倒数第 K 个结点&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;将倒数第 K+1 结点的的后继结点设置为 null&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;将 head 的后继结点设置为以上所得的倒数第 K 个结点，将原尾结点的后继结点设置为原 head 的后继结点&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/4/16f7013758e73889?w=992&amp;amp;h=316&amp;amp;f=gif&amp;amp;s=44769&quot; alt=&quot;&quot;/&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reversedKthToTail&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{
    
    Node KPreNode = findKthToTail(k+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    
    Node kNode = KPreNode.next;
    Node headNext = head.next;

    KPreNode.next = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;
    head.next = kNode;

    
    Node tmp = kNode;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (tmp.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        tmp = tmp.next;
    }
    
    tmp.next = headNext;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了上面两道题的铺垫，相信下面这道题不是什么难事，限于篇幅关系，这里不展开，大家可以自己试试&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;输入一个链表，删除该链表中的倒数第 k 个结点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小试牛刀之二&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;判断两个单链表是否相交及找到第一个交点,要求空间复杂度 O(1)。 如图示：如果两个链表相交，5为这两个链表相交的第一个交点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/4/16f70137511a2251?w=1201&amp;amp;h=298&amp;amp;f=png&amp;amp;s=21269&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;画外音：如果没有空间复杂度O(1)的限制，其实有多种解法，一种是遍历链表 1，将链表 1 的所有的结点都放到一个 set 中，再次遍历链表 2，每遍历一个结点，就判断这个结点是否在 set，如果发现结点在这个 set 中，则这个结点就是链表第一个相交的结点&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：首先我们要明白，由于链表本身的性质，如果有一个结点相交，那么相交结点之后的所有结点都是这两个链表共用的，也就是说两个链表的长度主要相差在相交结点之前的结点长度，于是我们有以下思路&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、如果链表没有定义长度，则我们先遍历这两个链表拿到两个链表长度，假设分别为 L1, L2 (L1 &amp;gt;= L2), 定义 p1, p2 指针分别指向各自链表 head 结点，然后 p1 先往前走 L1 - L2 步。这一步保证了 p1，p2 指向的指针与相交结点(如果有的话)一样近。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/4/16f70137b9646b35?w=1070&amp;amp;h=452&amp;amp;f=gif&amp;amp;s=46209&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 然后 p1,p2 不断往后遍历，每次走一步，边遍历边判断相应结点是否相等，如果相等即为这两个链表的相交结点&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;detectCommonNode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(LinkedList list1, LinkedList list2)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length1 = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;        
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length2 = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;        

    Node p1 = list1.head;
    Node p2 = list2.head;

    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (p1.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        length1++;
        p1 = p1.next;
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (p2.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        length2++;
        p2 = p2.next;
    }

    p1 = list1.head;
    p2 = list2.head;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (length1 &amp;gt;= length2) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; diffLength = length1-length2;
        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (diffLength &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {
            p1 = p1.next;
            diffLength--;
        }
    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; diffLength = length2-length1;
        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (diffLength &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {
            p2 = p2.next;
            diffLength--;
        }
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (p1 != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; p2.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        p1 = p1.next;
        p2 = p2.next;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (p1.data == p2.data) {
            
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; p1;
        }
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进阶&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看如何用快慢指针来判断链表是否有环,这是快慢指针最常见的用法&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;判断链表是否有环，如果有，找到环的入口位置（下图中的 2），要求空间复杂度为O(1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/4/16f701390186aa96?w=671&amp;amp;h=393&amp;amp;f=png&amp;amp;s=19392&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们要看如果链表有环有什么规律，如果从 head 结点开始遍历，则这个遍历指针一定会在以上的环中绕圈子，所以我们可以分别定义快慢指针，慢指针走一步，快指针走两步， 由于最后快慢指针在遍历过程中一直会在圈中里绕，且快慢指针每次的遍历步长不一样，所以它们在里面不断绕圈子的过程一定会相遇，就像 5000 米长跑，一人跑的快，一人快的慢，跑得快的人一定会追上跑得慢的（即套圈）。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还不明白？那我们简单证明一下&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 假如快指针离慢指针相差一个结点,则再一次遍历，慢指针走一步，快指针走两步，相遇&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/4/16f701391f4d5c8c?w=689&amp;amp;h=442&amp;amp;f=png&amp;amp;s=19287&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 假如快指针离慢指针相差两个结点,则再一次遍历，慢指针走一步，快指针走两步，相差一个结点，转成上述 1 的情况&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、 假如快指针离慢指针相差 N 个结点（N大于2），则下一次遍历由于慢指针走一步，快指针走两步，所以相差 N+1-2 = N-1 个结点，发现了吗，相差的结点从 N 变成了 N-1,缩小了！不断地遍历，相差的结点会不断地缩小，当 N 缩小为 2 时，即转为上述步骤 2 的情况，由此得证，如果有环，快慢指针一定会相遇！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**画外音：如果慢指针走一步，快指针走的不是两步，而是大于两步，会有什么问题，大家可以考虑一下 **&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;detectCrossNode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    Node slow = head;
    Node fast = head;

    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (fast != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; fast.next != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        fast = fast.next.next;
        slow = slow.next;
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (fast == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (slow.data == fast.data) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; slow;
        }
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断有环为啥要返回相遇的结点，而不是返回 true 或 false 呢。 因为题目中还有一个要求，判断环的入口位置，就是为了这个做铺垫的,一起来看看怎么找环的入口，需要一些分析的技巧&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/4/16f701393d68d74f?w=831&amp;amp;h=594&amp;amp;f=png&amp;amp;s=39029&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设上图中的 7 为快慢指针相遇的结点，不难看出慢指针走了 L + S 步，快指针走得比慢指针更快，它除了走了 L + S 步外，还额外在环里绕了 n 圈，所以快指针走了 L+S+nR 步（R为图中环的长度）,另外我们知道每遍历一次，慢指针走了一步，快指针走了两步，所以快指针走的路程是慢指针的两倍,即 2 (L+S) = L+S+nR，即 L+S = nR&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;当 n = 1 时，则 L+S = R 时,则从相遇点 7 开始遍历走到环入口点 2 的距离为 R - S = L，刚好是环的入口结点,而 head 与环入口点 2 的距离恰好也为 L，所以只要在头结点定义一个指针，在相遇点（7）定义另外一个指针，两个指针同时遍历，每次走一步，必然在环的入口位置 2 相遇&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;当 n &amp;gt; 1 时，L + S = nR,即 L = nR - S, nR-S 怎么理解？可以看作是指针从结点 7 出发，走了 n 圈后，回退 S 步，此时刚好指向&lt;strong&gt;环入口位置&lt;/strong&gt;，也就是说如果设置一个指针指向 head（定义为p1）, 另设一个指针指向 7（定义为p2），不断遍历，p2 走了 nR-S 时（即环的入口位置），p1也刚好走到这里（此时 p1 走了 nR-S = L步，刚好是环入口位置），即两者相遇！&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，要找到入口结点，只需定义两个指针，一个指针指向head, 一个指针指向快慢指向的相遇点，然后这两个指针不断遍历（同时走一步），当它们指向同一个结点时即是环的入口结点&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;getRingEntryNode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        
        Node crossNode = detectCrossNode();

        
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (crossNode == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;
        }

        
        Node tmp1 = head;
        Node tmp2 = crossNode;

        
        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (tmp1.data != tmp2.data) {
            tmp1 = tmp1.next;
            tmp2 = tmp2.next;
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; tmp1;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考题：知道了环的入口结点，怎么求环的长度？&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文详细讲解了链表与数组的本质区别，相信大家对两者的区别应该有了比较深刻的认识，尤其是程序局部性原理，相信大家看了应该会眼前一亮，之后通过对链表的翻转由浅入深地介绍，相信之后的链表翻转对大家应该不是什么难事了，之后再介绍了链表的另一个重要的解题技巧：快慢指针，这两大类是面试的高频题，大家一定要掌握！建议大家亲自实现一遍文中的代码哦，这样印象会更深刻一些！有一些看起来思路是这么一回事，但真正操作起来还是会有不少坑，纸上得来终觉浅，绝知此事要躬行！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中的所有代码均已更新在我的 github 地址上: https://github.com/allentofight/algorithm,大家如果需要，可以下载运行&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/6/16f782e0e23117f5?w=1002&amp;amp;h=270&amp;amp;f=jpeg&amp;amp;s=59118&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Mon, 06 Jan 2020 00:09:00 +0000</pubDate>
<dc:creator>ErnestEvan</dc:creator>
<og:description>前言 如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。 因为像堆，栈，对，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。 今天就来看看链表的基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiekun/p/12154631.html</dc:identifier>
</item>
<item>
<title>机器学习回顾篇（13）：集成学习之AdaBoost - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/12154623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/12154623.html</guid>
<description>[unable to retrieve full-text content]在上一篇博客中，我们总结了集成学习的原理，并展开介绍了集成学习中Bagging和随机森林这一分枝算法，在本篇博客中，我们继续介绍另一个分枝——Boosting，并对Boosting系列中的经典算法Adaboost展开分析。</description>
<pubDate>Sun, 05 Jan 2020 23:57:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<dc:identifier>http://www.cnblogs.com/chenhuabin/p/12154623.html</dc:identifier>
</item>
<item>
<title>MySQL基础篇(04)：存储过程和视图，用法和特性详解 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12154620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12154620.html</guid>
<description>&lt;blockquote readability=&quot;1.8269230769231&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/mysql-data-base&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://github.com/cicadasmile/mysql-data-base&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;概念简介&quot;&gt;1、概念简介&lt;/h2&gt;
&lt;p&gt;存储程序是被存储在服务器中的组合SQL语句，经编译创建并保存在数据库中，用户可通过存储过程的名字调用执行。存储过程核心思想就是数据库SQL语言层面的封装与重用性。使用存储过程可以较少应用系统的业务复杂性，但是会增加数据库服务器系统的负荷，所以在使用时需要综合业务考虑。&lt;/p&gt;
&lt;h2 id=&quot;基本语法格式&quot;&gt;2、基本语法格式&lt;/h2&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE PROCEDURE sp_name ([proc_parameter[,...]])
    [characteristic ...] routine_body&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;案例一：计算消费折扣&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 创建存储过程
DROP PROCEDURE IF EXISTS p01_discount ;
CREATE PROCEDURE p01_discount(IN consume NUMERIC(5,2),OUT payfee NUMERIC(5,2))
BEGIN
    -- 判断收费方式
    IF(consume&amp;gt;100.00 AND consume&amp;lt;=300.00) THEN
        SET payfee=consume*0.8;
    ELSEIF (consume&amp;gt;300.00) THEN 
        SET payfee=consume*0.6;
    ELSE 
        SET payfee = consume;
    END IF;
    SELECT payfee AS result;
END ;
-- 调用存储过程
CALL p01_discount(100.0,@discount);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;案例二：While..Do写数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;提供一张数据表&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `t03_proced` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `temp_name` varchar(20) DEFAULT NULL COMMENT '名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='触发器写数据';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;存储程序&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据传入的参数，判断写入t03_proced表的数据条数。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DROP PROCEDURE IF EXISTS p02_batch_add ;
CREATE PROCEDURE p02_batch_add(IN count INT(11))
BEGIN
    DECLARE temp int default 0;
    WHILE temp &amp;lt; count DO
        INSERT INTO t03_proced(temp_name) VALUES ('pro_name');
        SET temp = temp+1 ;
    END WHILE;
END ;

-- 测试：写入10条数据
call p02_batch_add(10);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;3、注意事项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;业务场景&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;存储过程在实际开发中的应用不是很广泛，通常复杂的业务场景都在应用层面开发，可以更好的管理维护和优化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行速度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假如在单表数据写入的简单场景下，基于应用程序写入，或者数据库连接的客户端写入，相比存储过程写入的速度就会慢很多，存储过程在很大程度上没有网络通信开销，解析开销，优化器开销等。&lt;/p&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;1、基本概念&lt;/h2&gt;
&lt;p&gt;视图本身是一张虚拟表，不存放任何数据。在使用SQL语句访问视图的时候，获取的数据是MySQL从其它表中生成的，视图和表在同一个命名空间。视图查询数据相对安全，视可以隐藏一些数据和结构，只让用户看见权限内的数据，使复杂的查询易于理解和使用。&lt;/p&gt;
&lt;h2 id=&quot;视图用法&quot;&gt;2、视图用法&lt;/h2&gt;
&lt;p&gt;现在基于用户和订单管理演示视图的基本用法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础表结构&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE v01_user (
    id INT(11) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  user_name VARCHAR(20) DEFAULT NULL COMMENT '用户名',
    phone VARCHAR(20) DEFAULT NULL COMMENT '手机号',
    pass_word VARCHAR(64) DEFAULT NULL COMMENT '密码',
    card_id VARCHAR(18) DEFAULT NULL COMMENT '身份证ID',
    pay_card VARCHAR(25) DEFAULT NULL COMMENT '卡号',
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '用户表';

CREATE TABLE v02_order (
    id INT(11) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    user_id INT(11) NOT NULL COMMENT '用户ID',
    order_no VARCHAR(32) DEFAULT NULL COMMENT '订单编号',
    good_name VARCHAR(60) DEFAULT NULL COMMENT '商品名称',
    good_id INT(11) DEFAULT NULL COMMENT '商品ID',
    num INT(11) DEFAULT NULL COMMENT '购买数量',
    total_price DECIMAL(10,2) DEFAULT NULL COMMENT '总价格',
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '订单表';&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;基本语法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE OR REPLACE VIEW view_name 
AS select_statement&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：表和视图共享数据库中相同的名称空间，因此，数据库不能包含具有相同名称的表和视图。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户订单视图&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE OR REPLACE 
VIEW user_order_view AS SELECT
    t1.id,t1.user_name,t2.order_no,t2.good_id,
    t2.good_name,t2.num,t2.total_price
FROM v01_user t1
LEFT JOIN v02_order t2 ON t2.user_id = t1.id;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;视图调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里和MySQL的表查询基本一致，可以使用各种查询条件。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT * FROM user_order_view WHERE user_name='Cicada';&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看视图&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SHOW CREATE VIEW user_order_view ;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改视图&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER VIEW view_name AS select_statement ;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;删除视图&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DROP VIEW [IF EXISTS] view_name ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;视图更新&quot;&gt;3、视图更新&lt;/h2&gt;
&lt;p&gt;在指定条件允许的情况下，可以通过在视图上操作更新，删除，甚至写入数据，进而更新视图所涉及的相关表。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;UPDATE user_order_view SET user_name='smile' WHERE id='1';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就通过对视图执行更新操作，进而更新&lt;code&gt;v01_user&lt;/code&gt;表数据。如果视图定义时使用聚合函数，分组等特殊操作，则无法更新。MySQL不支持在视图上创建触发器。&lt;/p&gt;
&lt;h2 id=&quot;视图实现&quot;&gt;4、视图实现&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;临时表算法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;服务器会把视图查询SQL的数据保存在临时表中，临时表的结构和视图字段结构一致，这样是SQL查询优化中最忌讳的操作，数据量稍微偏大，就会严重影响性能。如果视图无法和原有表产生一对一的映射关系，就会产生临时表，由此也可见视图并不是很简单，甚至是非常复杂的功能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;合并算法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;服务器基于视图中使用的表执行查询，最后把查询结构合并后返回给客户端。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;区别方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行如下查询语句，可以分析执行的性能参数。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;EXPLAIN SELECT * FROM user_order_view ; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察查询结果中&lt;code&gt;select_type&lt;/code&gt;字段，如果是&lt;code&gt;DERIVED&lt;/code&gt;则说明使用临时表。这里SQL执行分析的语法后面优化部分再详解。&lt;/p&gt;
&lt;h2 id=&quot;注意事项-1&quot;&gt;5、注意事项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;性能问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MySQL并不支持在视图中创建索引，使用视图的时候可能会引发很多查询性能问题，所以建议使用的时候要慎重，多角度审视和测试。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特殊用法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于视图的查询，可以修改部分表结构，只要不是在视图中使用的字段，就不会影响视图的查询。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/mysql-data-base
GitEE·地址
https://gitee.com/cicadasmile/mysql-data-base&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 Jan 2020 23:50:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、存储过程 1、概念简介 存储程序是被存储在服务器中的组合SQL语句，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12154620.html</dc:identifier>
</item>
<item>
<title>看了多篇2019年的面经后的个人总结 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/11819648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/11819648.html</guid>
<description>&lt;p&gt;　　最近阅读了多篇从面试官的角度看面试的文章，全部记录在了&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/daily/blob/master/article/2019.md&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Github&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;上，看完后就想结合自己的经历总结一下，如有不当之处，欢迎留言讨论。本文将分为五部分：简历、自我介绍、问答、提问和2019年求职分析。&lt;/p&gt;

&lt;p&gt;　　简历是一种为了让招聘方能了解自己的载体，传递的信息包括个人的优势、亮点和价值等，其存在地目的就是为了能获得面试机会以及在面试过程中的谈资。简历包括基本信息、工作履历、项目经验、教育背景等部分，那些配色简洁、主题突出、与岗位要求高度匹配和有量化数据的简历会更受面试官青睐。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）基本信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　基本信息包括姓名、联系电话、电子邮箱、性别、出生日期、学历、工作年限、照片等。有些人不喜欢QQ邮箱，那可以用其它邮箱替代；照片要放的话，最好是用职业的证件照，比较正式点；工作年限对于能力高的人来说，是加分项，反之则是减分项。&lt;/p&gt;
&lt;p&gt;　　GitHub上高star的开源项目是加分项，用代码最能证明程序员的能力；高质量的博客也是加分项，说明求职者有总结提炼的好习惯，并且从博文中还能了解他的沟通和表达能力。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）工作履历&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　工作履历可按倒序的方式写，通常是某年某月到另一个时间，在某家公司担任何职。&lt;/p&gt;
&lt;p&gt;　　负责内容可随着工作年限的上升而递进，例如第一年能借助jQuery实现简单的前端交互、第二年能独立布局并封装插件等，这样既能营造出不断进步的氛围，也能让面试官了解你的成长轨迹。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）技术能力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　经常在技术能力一栏中看到了解、熟悉和精通三个动词，关于这三者的定义可以参考《&lt;span&gt;&lt;a href=&quot;https://juejin.im/post/5d1d52aff265da1bb2774de0&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;面试官想看的简历&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》一文中的描述：&lt;/p&gt;
&lt;p&gt;　　（1）&lt;strong&gt;了解&lt;/strong&gt;：使用过某一项技术，能在别人指导下完成工作，但不能胜任复杂工作，也不能独立解决问题。&lt;/p&gt;
&lt;p&gt;　　（2）&lt;strong&gt;熟悉&lt;/strong&gt;：大量运用过的某一项技术，能独立完成工作，且能独立完成有一定复杂度的工作，在技术的应用层面不会有太大问题，甚至理解一点原理。&lt;/p&gt;
&lt;p&gt;　　（3）&lt;strong&gt;精通&lt;/strong&gt;：不仅可以运用某一门技术完成复杂项目，而且理解这项技术背后的原理，可以对此技术进行二次开发，甚至本身就是技术源码的贡献者。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）项目经验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　列出的项目得能够证明自己的能力，不仅要表现负责的内容（不要展开业务细节），还得把用到的技术（挑自己擅长的）、项目难点和达成效果写上，最好再把能量化的数据也带上，例如（有不合适的地方可指正）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负责内容&lt;/strong&gt;：协助销售搭建广告品牌页。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目难点&lt;/strong&gt;：上线时间紧，活动形式多样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术实现&lt;/strong&gt;：通过Gulp自动化构建流程，将Jade编译成HTML，结合Babel将ES6语法降为ES5语法，利用webpack合并脚本，基于SASS编自制PrimusUI库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;达成效果&lt;/strong&gt;：在采用PrimusUI库，封装表单验证、弹框等插件，划分数据通信、基础信息等模块后，抽象出了品牌页的通用部分，将研发时间缩短到一至两天。&lt;/p&gt;
&lt;p&gt;　　涉及的技术栈求精不求多，以免被问到时出现语塞尬场的情况。项目经验不是向面试官汇报自己的工作任务，而是突出项目所涉及的技术以及解决相关难题的思路，和面试官引起共鸣，打开话题。&lt;/p&gt;
&lt;p&gt;　　项目经验可以根据招聘方的岗位要求做适当的调整，列些相匹配并且你熟悉的技术，因为面试官的侧重点很大概率就是写的那些，从而就能有更多的话题聊，并且还能引导面试官到你熟悉的领域。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）注意事项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　简历的长度最好控制在一页，简历突出的就是“简”。在细节方面，中英文标点符号不要混用，单词拼写不要错误，避免错别字，排版要工整，配色不超过3种，建议简历命名采用姓名+工作年限+岗位的格式。&lt;/p&gt;
&lt;p&gt;　　当遇到自己不懂的问题时，可以主动描述自己的理解，说明大概的实现思路；有些面经也建议爽快点回不清楚，继续下面的问答。&lt;/p&gt;
&lt;p&gt;　　在投递简历时，尽量用pdf格式的简历，这样既可以避免打开文件时的格式错乱，也可以在浏览器中直接打开。&lt;/p&gt;
&lt;p&gt;　　选择合适自己的公司，能更大概率的拿到offer，在《&lt;span&gt;&lt;a href=&quot;https://juejin.im/post/5d6baf43e51d453bb13b6674&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;面试官角度看应聘&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》一文中曾将企业对人才的需求分为三类：&lt;/p&gt;
&lt;p&gt;（1）当公司处于创业期时，其内部团队的要求是强执行，对人的需要是资源型重执行人才。&lt;/p&gt;
&lt;p&gt;（2）当公司处于快速发展期时，开始体系化建设，需要能帮助体系化落地的人才。&lt;/p&gt;
&lt;p&gt;（3）当公司业务处于稳定期时，体系化建设、人才梯队也较为完善，此阶段的人员储备会更多元化，要求也会更高。&lt;/p&gt;
&lt;p&gt;　　关于自我评价，有些面经建议不写，有些面经分享了自我评价的注意点，加不加这版块就看个人喜好了。&lt;/p&gt;

&lt;p&gt;　　自我介绍既能让面试官有时间快速浏览简历，也能让自己热身。自我介绍包括姓名、目前的工作岗位等信息，概述自己的特点，并设法刻意的引起面试官的兴趣，例如介绍一个项目遇到的难点、如何攻克、有何收获等。&lt;/p&gt;
&lt;p&gt;　　下面是一段自己编写的自我介绍，圆括号中的例如可以在陈述时不说，如果面试官问的话，可以举这些例子，如有问题，欢迎指正。&lt;/p&gt;
&lt;p&gt;　　我的名字叫XX，目前从事前端岗位。在项目结束后，喜欢做些简单的总结（例如&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5155042.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;touch事件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;、&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5204082.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;伸缩盒布局&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;、&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/category/816532.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;CreateJS&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）和思想沉淀（例如&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5347551.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;榫卯思想&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，搜集或自研小巧、功能单一的库，拿来即用），并将相关内容记录到自己的博客中。平时也喜欢读些技术书，读后会做些记录总结（例如归纳了《软技能》其中&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/9851665.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;三章的内容&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;；有时还会实践，验证书中内容的准确性，例如《CSS Secrets》中的&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5423084.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;渐变用法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）。当项目中遇到重复的业务时，喜欢自己造轮子，（例如&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5297491.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Slider滑动插件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5536321.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;PrimusUI&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/6801453.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;表单验证&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;等）。有个图像裁剪的功能，当时给我制造了不少的麻烦，最后用HTML5的方式解决了相关问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）技能清单&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　此处只是做个演示，可根据自己的情况挑选技能，主要列出了自己熟悉和使用过的技能。&lt;/p&gt;
&lt;p&gt;（1）后端开发：PHP、C#&lt;/p&gt;
&lt;p&gt;（2）后端框架：Zend Framework、CodeIgniter&lt;/p&gt;
&lt;p&gt;（3）前端框架：Bootstrap、Matrix&lt;/p&gt;
&lt;p&gt;（4）前端类库：React、Vue、jQuery、Zepto、Underscore&lt;/p&gt;
&lt;p&gt;（5）前端插件：Swiper、RequireJS、CreateJS&lt;/p&gt;
&lt;p&gt;（6）构建工具：Webpack、Gulp&lt;/p&gt;
&lt;p&gt;（7）前端工具：Fiddler、Babel、npm、WebPageTest、Wireshark&lt;/p&gt;
&lt;p&gt;（8）预编译语言：Typescript、Sass、Jade、ES6&lt;/p&gt;
&lt;p&gt;（9）数据库：MySQL、MongoDB、MsSQL&lt;/p&gt;
&lt;p&gt;（10）版本系统：SVN、Git&lt;/p&gt;
&lt;p&gt;（11）单元测试：Jasmine、PHPUnit&lt;/p&gt;
&lt;p&gt;（12）其它：小程序、Jekyll、快应用&lt;/p&gt;

&lt;p&gt;　　通常面试官会挑选简历上的某些内容提问，首先让求职者叙述一些项目背景，例如具体业务、开发周期、人员规模、个人角色、开发了哪些功能、遇到的问题等；然后针对某个具体的技术或业务发问，让求职者给出解答或方案；接着进一步提问，深挖原理或扩展方案，面试官应该都比较想听到多种选型的对比和技术取舍。&lt;/p&gt;
&lt;p&gt;　　而在回答问题的时候，还可以反客为主，既能引导话题走向自己熟悉的领域，也能进一步打开话匣，例如在《&lt;span&gt;&lt;a href=&quot;https://juejin.im/post/5d30c0cd6fb9a07efd474427&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;问答中的面试技巧&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》一文中曾提到，当面试官问“Vue如何实现双向绑定的？”时，在老实的回答后可以加一句“Vue 3.0则选择了更好用的Proxy来替代object.defineproperty()”，此时，面试官大概率会问“Proxy好在哪？”。&lt;/p&gt;
&lt;p&gt;　　性能与体验的优化、场景设计和得意项目是面试中常见的会涉及到的问题，如果在面试前不准备，往往会处于比较被动的局面。下面是针对性能优化，准备的一点内容，如有问题，欢迎指正。&lt;/p&gt;
&lt;p&gt;　　自己平时很注意性能与体验优化，已将优化散入到各个项目中，例如在页面加载时出现&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/4551818.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Loading加载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5475758.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;压缩图像&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，采用&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/6228339.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;惰性模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;减少代码分支、异步加载第三方代码等。记得有个答题活动，包含120多张图片，由于一下子加载会让页面卡顿，因此使用&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5372694.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;预加载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;的方式，并且用Chrome模拟了2G、3G和4G的加载时间，分别是20s、8s和4s，其实还有很大的优化空间。还有个&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/6232591.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转盘抽奖&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;的活动，利用Chrome的性能工具，能看到优化前的转盘在转动时会不断的重绘，有些比较老的手机甚至会出现卡顿情况；后面将rotate()改成rotate3d()新增一个渲染层，就只会重绘一次。还曾在本地搭建过&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/category/980651.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;WebPageTest&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;用来测试性能，但没有大规模使用过。&lt;/p&gt;
&lt;p&gt;　　再针对得意项目，也准备一点内容，如有问题，欢迎指正。&lt;/p&gt;
&lt;p&gt;　　其实这不是一个单独的项目，而是结合了几个项目，主要是不断优化图片裁剪的功能。首先是上传，弃用了form和iframe配合的&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/3814872.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;无刷新上传&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，改用&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5181701.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;HTML5&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;提供的便捷上传，涉及File对象、Base64位格式等内容；然后利用&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5183570.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Canvas&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;实现预览与合成，并通过计算三角函数来实现旋转，期间碰到了iOS图片不正和画布污染的问题，最后还在封装的&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/6758356.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;裁剪插件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中内置简单的手势操作。&lt;/p&gt;
&lt;p&gt;　　在面试过程中表现出优于别人的亮点，可让面试官加很多分，例如懂得代码扩展性、可深入框架原理、具有优化意识、有多种途径发现问题、新技术上手快、主动思考、技术攻坚人、分析问题善抓重点、注意业务细节、思维活络、总结沉淀，能给出通用解决方案推广到团队中，这类人也俗称经验丰富的人。&lt;/p&gt;
&lt;p&gt;　　打铁还需自身硬，只有当自身基本功扎实，项目经验丰富，并且在某一领域有一定的知识储备时，才能在面试现场胸有成竹、对答如流。&lt;/p&gt;

&lt;p&gt;　　通过最后的提问能更多地了解关于这次面试、这家公司、这份工作的相关信息，例如企业文化、部门之间的同事情况、企业发展等。可以提一些这个职位的具体工作、发展机会等相关的问题，例如&lt;/p&gt;
&lt;p&gt;（1）目前这个职位最紧要的任务是什么？&lt;/p&gt;
&lt;p&gt;（2）你们是如何管理项目的？&lt;/p&gt;
&lt;p&gt;（3）公司常用的技术栈是什么？&lt;/p&gt;
&lt;p&gt;（4）当前团队的规模和配置是怎么样的？&lt;/p&gt;
&lt;p&gt;（5）这个岗位可以为公司业务带来什么价值？&lt;/p&gt;
&lt;p&gt;（6）你们为什么要招聘这个职位？&lt;/p&gt;
&lt;p&gt;（7）这个岗位需要具备哪些素质？&lt;/p&gt;
&lt;p&gt;（8）未来打算采用哪些新技术？&lt;/p&gt;
&lt;p&gt;　　切忌提一些容易暴露自己缺点、不自信的问题，例如“我不是名牌大学毕业的，你们会要吗？”，也不要问面试结果、工资、技术等当前面试官无法回答的问题。&lt;/p&gt;

&lt;p&gt;　　此次从自己搜集的《&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/daily/blob/master/article/2019.md#%E9%9D%A2%E8%AF%95%E5%92%8C%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;面试和技术总结&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》中挑选了其中的十多篇，从求职者的角度，对涉及的公司信息、面试流程、面试题目等方面做数据分析。由于采样有限，分析结果不会很准确，纯属娱乐，大家有异议或补充的，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;　　公司信息包括规模、上市情况、是否融资，主要参考拉勾网中的公司介绍，&lt;span&gt;&lt;a href=&quot;https://tushuo.baidu.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;在线生成图表&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。由下面的三张饼图可知，大家趋向于找上规模、资金充足的大公司，而这些公司往往面试流程至少二面，并且有些还包含笔试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201911/211606-20191114161402718-1710327065.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　面试题目不包括基础的JavaScript、CSS、项目经验和场景设计，React和Vue仍旧瞩目，关于两者之间的对比出现频率很高（图中两者对比一栏），TypeScript的使用率正在逐步上升，webpack和Node.js的关注度依然没有减弱，基础的ES6、网络、算法以及各类优化还是面试中的常客，在平时工作中还得注意安全问题，并且可以深入到框架原理中，知其然而所以然。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201911/211606-20191114161614600-843197926.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在文章的最后，套用一句《火蓝刀锋》中的台词来勉励自己，“如果你想得到你从未有过的东西，那么你就要去做你从未做过的事情”。&lt;/p&gt;


&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d1d52aff265da1bb2774de0&quot; target=&quot;_blank&quot;&gt;面试官到底想看什么样的简历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d6fa5f9f265da03b57469e7&quot; target=&quot;_blank&quot;&gt;面试之前，简历之上：给前端校招同学的简历建议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000020322946&quot; target=&quot;_blank&quot;&gt;如何写一份好的前端面试简历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d1dc5ee51882561b52b7013&quot; target=&quot;_blank&quot;&gt;面试官教你写简历之「中高级开发者简历指南」&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/JavaArchitect/p/11057596.html&quot; target=&quot;_blank&quot;&gt;简历上如果出现过于高大上的项目，反而过犹不及：再论如何通过项目引出技术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/JavaArchitect/p/10948328.html&quot; target=&quot;_blank&quot;&gt;分析若干没面试机会和没体现实力的简历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/JavaArchitect/p/8249594.html&quot; target=&quot;_blank&quot;&gt;你的简历能帮你争取到面试机会吗&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d6baf43e51d453bb13b6674&quot; target=&quot;_blank&quot;&gt;面试官角度看应聘：问题到底出在哪？（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d7062adf265da03ee6a776b&quot; target=&quot;_blank&quot;&gt;面试官角度看应聘：问题到底出在哪？（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d30c0cd6fb9a07efd474427&quot; target=&quot;_blank&quot;&gt;「技术面试」问答中有什么十分实用的面试技巧?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d2fd172f265da1b8b2b9533&quot; target=&quot;_blank&quot;&gt;作为面试官的一点小感悟&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/JavaArchitect/p/7586949.html&quot; target=&quot;_blank&quot;&gt;如何在面试中介绍自己的项目经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000019962292&quot; target=&quot;_blank&quot;&gt;如何招聘一名优秀的前端&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000020017980&quot; target=&quot;_blank&quot;&gt;大揭秘！“恐怖”的阿里一面，我究竟想问什么&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d6f54e9f265da03f66ddf65&quot; target=&quot;_blank&quot;&gt;面试招聘：2 年招到 18 个前端教你怎么招人&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yifeikong/reverse-interview-zh/blob/master/README.md&quot; target=&quot;_blank&quot;&gt;技术面试最后反问面试官的话&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d3fdffbf265da03c502e9ab&quot; target=&quot;_blank&quot;&gt;面试时，最该问面试官什么问题？&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 05 Jan 2020 23:46:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>最近阅读了多篇从面试官的角度看面试的文章，全部记录在了Github上，看完后就想结合自己的经历总结一下，如有不当之处，欢迎留言讨论。本文将分为五部分：简历、自我介绍、问答、提问和2019年求职分析。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/11819648.html</dc:identifier>
</item>
<item>
<title>asp.net core 3.x 通用主机原理及使用 - jionsoft</title>
<link>http://www.cnblogs.com/jionsoft/p/12154519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jionsoft/p/12154519.html</guid>
<description>&lt;p&gt;只是讲asp.net core 3.x通用主机的大致原理，这些东西是通过查看源码以及自己根据经验总结得来的，在文章中不会深入源码，因为个人觉得懂原理就晓得扩展点，后期碰到有需求的时候再仔细去研究源码也不迟。&lt;br/&gt;阅读前你应该先去了解下（&lt;a href=&quot;https://www.cnblogs.com/artech/&quot; target=&quot;_blank&quot;&gt;推荐博客园老A的博客&lt;/a&gt;）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;asp.net core中的依赖注入、&lt;/li&gt;
&lt;li&gt;配置，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;讲解的方式是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;逐一介绍核心类及扩展方式&lt;/li&gt;
&lt;li&gt;通常我们如何使用&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/350763/202001/350763-20200106011134412-1833846205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以前的控制台应用程序、winform程序启动时main首先被执行，后续都是我们自己的代码来实现框架和业务上的东东，比如我们要使用配置就ConfigurationManager.AppSettings... 若想使用依赖注入则需要引入第三方框架，比如autofact。asp.net framework时代也类似&lt;/p&gt;
&lt;p&gt;在.net core 3.0之前的版本默认使用的是IWebHost，它内部定义了IOC容器（服务注册体现在Startup.ConfigServices），和各种配置源的设置（体现在Program配置主机时），我们后续的Controler、View、包括业务代码可以很容易做依赖注入和获取配置信息（包括运用选项模式）&lt;/p&gt;
&lt;p&gt;有时候我们希望写一个服务，但是这个服务并不是用来做api/web，处理http请求的，比如想做一个物联网的后端采集服务，一直等待远端硬件设备提交实时数据过来，后端进行处理。但是又希望使用asp.net core提供的 配置、依赖注入、日志 和其它功能。后来微软就将asp.net core中的这套东西抽离出来了，叫做通用主机，用来承载任何服务，这些自定义服务中就可以很方便地使用配置、依赖注入、日志、和其它功能。现在asp.net core只是由通用主机承载的其中一种服务。&lt;/p&gt;
&lt;h2&gt;2.1、默认情况下主要的实现思路是：&lt;/h2&gt;
&lt;h3&gt;2.1.1、定义（微软定义好的）：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;定义HOST，它包含IOC根容器、主机和应用程序的生命周期事件定定义、IHostedService集合（一个实例就是一个服务或者叫应用，asp.net core就是一个这样的实例）&lt;/li&gt;
&lt;li&gt;允许调用方提供一堆委托来向IOC中注册服务、和设置主机和应用的“配置源”&lt;/li&gt;
&lt;li&gt;提供向主机添加IHostedService的实现对象的方法&lt;/li&gt;
&lt;li&gt;允许调用方注册主机和应用在启动和停止阶段触发的相应事件&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2.1.2、配置（我们的代码，微软定义很多辅助方法）：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建IHost实例&lt;/li&gt;
&lt;li&gt;向Host的IOC容器中注册各种服务&lt;/li&gt;
&lt;li&gt;配置主机和应用程序的“配置源&lt;/li&gt;
&lt;li&gt;向主机内部添加IHostedService实例（也就是我们最终的服务）&lt;/li&gt;
&lt;li&gt;主机和应用的生命周期事件，来实现一些特殊任务&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2.1.3、启动阶段（微软定义好的）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;上面所谓的配置基本都是通过委托实现的（通常微软提供的各种扩展方法最终也是执行委托），回调这些委托以设置“配置源”和注册服务&lt;/li&gt;
&lt;li&gt;最后遍历启动HostedService&lt;/li&gt;
&lt;li&gt;在启动过程中还会回调相应的生命周期事件&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2.2、啥是应用？&lt;/h2&gt;
&lt;p&gt;上面提了几次“应用”，现在对于主机来说asp.net core框架就是一个应用、我们上面举例说的&quot;物联网后端服务&quot;是另一个应用。从代码上来说就是一个IHostedService的实现。&lt;br/&gt;主机和应用是一对多的关系，多个应用可以共享主机的信息，如：主机的IOC容器、主机的配置。应用配置。应用当然也可以自己去创建自己的IOC根容器和配置对象&lt;/p&gt;
&lt;p&gt;主机配置和应用配置有关系？这两个配置对象都存在于Host中，主机配置是只跟主机相关的配置，应用配置是主机中多个应用共享的配置，如果主机中只有一个应用，那么完全可以拿它做最终的应用配置。另外应用配置包含主机配置&lt;/p&gt;
&lt;p&gt;注意：在理解时要记住我们现在的目的是讲解通用主机，意思是可以承载你自己定义的服务的主机，别去想什么mvc controller action 路由之类的&lt;/p&gt;

&lt;p&gt;下面分别介绍下主机中的几个核心默认实现类，几乎每个类都有对应的接口，为了缩短篇幅、便于理解就不讲接口了。&lt;/p&gt;
&lt;h2&gt;3.1、Host&lt;/h2&gt;
&lt;p&gt;它代表主机，用来宿主（承载）我们应用（一个IHostedService的实现）。&lt;br/&gt;主要包含：日志、主机和应用的生命周期事件、IOC根容器、主机的选项对象、启动停止/停止方法。&lt;br/&gt;接口中只定义了：IOC根容器 + Start + Stop方法&lt;br/&gt;它在Program.Main中被创建、配置和启动&lt;/p&gt;
&lt;p&gt;默认实现Microsoft.Extensions.Hosting.Internal.Host，它是一个internal的类，这个主机将来被启动时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;触发主机的WaitForStartAsync事件&lt;/li&gt;
&lt;li&gt;逐一启动主机累不的hostedService&lt;/li&gt;
&lt;li&gt;触发_applicationLifetime?.NotifyStarted();事件&lt;/li&gt;
&lt;li&gt;停止时就反过来，先逐一停止hostedService，触发响应事件、最后停止主机&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;扩展：&lt;/p&gt;
&lt;p&gt;因为默认Host是internal修饰的，所以无法继承&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自定义实现IHost；（这不说了，你可以随心所欲）&lt;/li&gt;
&lt;li&gt;订阅主机和应用的生命周期事件（实现IHostLifetime、IHostApplicationLifetime并添加到IOC容器）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大部分情况下方式2实现起来更容易也更常见&lt;/p&gt;
&lt;p&gt;提一嘴，asp.net core 3.x现在也是使用的这个默认主机，只是在上面做了根web相关的配置，将在下一篇讲解&lt;/p&gt;
&lt;h2&gt;3.2、HostBuilder&lt;/h2&gt;
&lt;p&gt;Host的职责只是完成主机该有的功能，那么它的创建及配置最好另外定义一个类HostBuilder，它是Host的创建器（工厂），我们通常&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在系统启动时（Program.Man）先创建HostBuilder，&lt;/li&gt;
&lt;li&gt;然后进行配置（向IOC容器注册服务，设置主机和应用的&quot;配置源&quot;），&lt;/li&gt;
&lt;li&gt;最后调用Build方法生成我们最终的Host&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过接口IHostBuilder源码可以初略看出它（通过委托的方式）提供以下功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置主机和应用的“配置源”&lt;/li&gt;
&lt;li&gt;配置IOC容器本身&lt;/li&gt;
&lt;li&gt;想IOC容器添加服务&lt;/li&gt;
&lt;li&gt;根据以后配置创建Host&lt;/li&gt;
&lt;li&gt;有个Properties属性，是个字典类型，可以在构建Host的多个步骤中传递数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;扩展：&lt;/p&gt;
&lt;p&gt;对于我们使用者来说主要是通过它的方法向内部塞入各种委托，以达到向IOC容器注册服务和设置主机和应用的“配置源”&lt;br/&gt;也可以但估计很少去实现主机的IHostBuilder；继承HostBuilder意义也不大，因为它没有提供抽象和虚方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认Build流程&lt;/strong&gt;&lt;br/&gt;初始化主机配置对象IConfiguration，主要是回调，主机没有做其它的&lt;br/&gt;初始化主机环境对象_hostingEnvironment&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用程序名字从上一步的主机配置里来&lt;/li&gt;
&lt;li&gt;环境名(开发？调试？)从配置里来，若没有则默认是生产模式&quot;Production&quot;&lt;/li&gt;
&lt;li&gt;内容根也从配置里来，若没有则是当前程序路径&lt;/li&gt;
&lt;li&gt;根据内容跟创建一个ContentRootFileProvider 实现类是PhysicalFileProvider&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;初始化HostBuilderContext，根据上面的配置和环境创建这个上下文（这里只是暂时用的主机配置，下面会被替换成应用的配置）&lt;br/&gt;初始化应用配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以上面的内容根作为配置查找的根（若将来提供物理文件作为配置源时需要此属性）&lt;/li&gt;
&lt;li&gt;将主机配置塞入这个应用配置，所以应用配置=主机配置+回调后的配置&lt;/li&gt;
&lt;li&gt;最后将HostBuilderContext的Configuration替换为此配置对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建IOC容器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建ServiceCollection，并将上面的几个对象以单利模式放入进去&lt;/li&gt;
&lt;li&gt;还要放入IHostApplicationLifetime和IHostLifetime和Host&lt;/li&gt;
&lt;li&gt;开启选项模式，注册日志&lt;/li&gt;
&lt;li&gt;回调configureServicesAction&lt;/li&gt;
&lt;li&gt;调用工厂_serviceProviderFactory创建ServiceProvider&lt;/li&gt;
&lt;li&gt;回调_configureContainerActions&lt;/li&gt;
&lt;li&gt;最后返回容器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用容器解析并返回Host&lt;/p&gt;
&lt;h2&gt;3.3、HostBuilder的工厂方法Host.CreateDefaultBuilder&lt;/h2&gt;
&lt;p&gt;上面有了Host，也有了对应的创建器HostBuilder，为啥还要再提供一个工厂方法呢？&lt;br/&gt;因为职责分离原则，Host只负责承载应用并提供容器和设置配置源；HostBuilder只是负责配置并创建Host，尽可能提供一些默认值（前提时将来调用方未提供那些参数）。此时我们可以直接用HostBuilder来创建Host并启动它，但别忘了.net core是一个通用框架，它应提供一个更简洁的方式来创建最终的Host，因此它提供了静态方法Host.CreateDefaultBuilder，它尽可能提供更多的默认值，核心任务如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;new HostBuilder&lt;/li&gt;
&lt;li&gt;设置程序的当前目录为内容根&lt;/li&gt;
&lt;li&gt;为主机配置 设置 环境变量作为配置源（只关注前缀DOTNET_的环境变量）&lt;/li&gt;
&lt;li&gt;为应用配置设置 以“appsettings.json”和“appsettings.{env.EnvironmentName}.json”作为配置源；同时也将环境变量加入到应用的配置源；最后将命令行参数加入到配置源&lt;/li&gt;
&lt;li&gt;配置日志&lt;/li&gt;
&lt;li&gt;若是开发模式，还会配置依赖注入的范围验证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过自定义实现IHostedService的类来实现我们的服务，我们的服务中的类可以&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接使用依赖注入，&lt;/li&gt;
&lt;li&gt;也可以通过依赖注入获取主机配置和全局应用配置对象，或者更方便的是进一步使用选项模式&lt;/li&gt;
&lt;li&gt;我们也可以注入日志记录器&lt;/li&gt;
&lt;li&gt;由于主机创建过程的相关数据几乎都放进了IOC容器中，因此我们也可以通过依赖注入拿到&lt;/li&gt;
&lt;li&gt;其它...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Program.man调用Host.CreateDefaultBuilder，如果需要，提供相应的委托来注册服务和设置主机和应用的“配置源”，最好是通过相关扩展方法和自定义扩展方法。重点是记得注入我们自己的服务实现类&lt;/p&gt;

&lt;p&gt;.net core为我们提供了新的承载应用（包括但不仅限于asp.net core）的方式--&amp;gt;通用主机，通过它我们可以很容易的在自己的应用中使用依赖注入、配置、日志等，你可以发挥想象实现很多牛B的框架。&lt;br/&gt;asp.net core 3.x开始默认也是使用它来承载的&lt;br/&gt;核心的Host、HostBuilder、Host.CreateDefaultBuilder实现了通用主机，并提供了扩展点&lt;/p&gt;
&lt;p&gt;最后我想说如果在.net core上提供一个默认的aop方案就更完美了。&lt;br/&gt;下一篇试试说下asp.net &lt;em id=&quot;__mceDel&quot;&gt;core是如何承载到通用主机上的&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;uploading_image_8679&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 05 Jan 2020 17:22:00 +0000</pubDate>
<dc:creator>jionsoft</dc:creator>
<og:description>一、前言 只是讲asp.net core 3.x通用主机的大致原理，这些东西是通过查看源码以及自己根据经验总结得来的，在文章中不会深入源码，因为个人觉得懂原理就晓得扩展点，后期碰到有需求的时候再仔细去</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jionsoft/p/12154519.html</dc:identifier>
</item>
<item>
<title>如何选择编程入门语言？一个让很多人纠结的问题 - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/12154492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/12154492.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;用心分享，共同成长&lt;/p&gt;
&lt;p&gt;没有什么比你每天进步一点点更实在了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt;本文已经收录至我的github,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/midou-tech/articles&quot; target=&quot;_blank&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;点关注，不迷路！！！&lt;/span&gt;&lt;/h4&gt;

&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;为什么会出这样一篇文章？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 本来想写点最近学习的东西，但是最近好多粉丝再问我一个问题。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gals2bdst5j30wq0fwn05.jpg&quot; alt=&quot;image-20200105164345384&quot; title=&quot;image-20200105164345384&quot;/&gt;image-20200105164345384
&lt;p&gt;于是我决定把我这个过来人的一些建议给到你们，希望大家少一些不必要的迷茫，多花点时间去学习该学习的东西，去做一些重要的事情。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;刚开始学习编程的困惑&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 在刚开始学习语言的时候我也很纠结学什么语言好？这个问题我相信很多人在最开始学习编程的时候都会纠结，到底选择一门什么样的语言才能使自己在千军万马的工作大军中出奇制胜呢？总害怕选错了语言导致自己未来竞争不占优势。&lt;/p&gt;
&lt;p&gt; 我把各个语言的热度榜拉出来看了。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga73pl239qj30sn0c43z6.jpg&quot; alt=&quot;img&quot; title=&quot;img&quot;/&gt;img&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1ga73q85flcj30w70f2n0y.jpg&quot; alt=&quot;topn10走势&quot; title=&quot;topn10走势&quot;/&gt;topn10走势
&lt;p&gt; 其实看来看去都差不多，主流语言就那些。像极了股票市场的涨跌图，起起伏伏。不过编程语言的起伏波动没那么大。&lt;/p&gt;
&lt;p&gt; 就这个问题，我还问了一些工作的学长学姐，看看他们这些过来人都有什么样的见解。还好我人缘好，他们都很耐心的给我讲了很多，以下是他们给我的建议。&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;过来人的一些建议&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 一个在京东做云计算的学长语重心长的这样和我说，学习语言要看你以后准备做什么？ 和你未来工作方向有关。简单列几个未来方向供你参考&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果你想从事和你自己专业(我的专业是电子信息工程)相关的方向工作的话，你可以好好学习C语言，汇编语言。因为你的专业以后工作方向在嵌入式和硬件编程方面较多。嵌入式编程讲究的是嵌入，所以一定要小巧和轻量，C语言符合这个场景需要。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果未来工作做纯软件的行业的话，你不应该局限于选择怎样的语言，工作需要什么你就学习什么语言，或者说项目需要什么语言你就必须很快学习这个语言，不过在学校学习还是建议学好一门高级编程语言。学好指的是学到精通，精通就不用解释了。你要对语言有所见解，而不是简单会用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果你未来想算法一类的工作，你就应该把精力放在算法钻研上，而不是语言本身。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;code&gt;语言只是工具，就好比计算器一样的工具，用计算器算题和设计、制造计算器是完全不一样的。&lt;/code&gt;大多数都是计算器的使用者，而不是设计生产制造者。完成一件事情可以选择很多种工具，就好比学生喜欢科学计算器，仓库老板喜欢那种很大声的简单加减乘除计算器就OK了。&lt;/p&gt;
&lt;p&gt;一个阿里的学长告诉我&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;主流语言随便选&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;学一门精一门，其他的都是触类旁通&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;注重工具思想，同时也要注意工具出了问题该如何处理&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 看了他们对我的话语，我得到的理解是，选择语言之前你要确定好你的未来工作方向(工作还是很宽泛的一个词语，人的一生大致可分为学习、生活和工作三件事，这三件事将伴随我们一生。学习和生活我们都能很好的理解，但是工作这件事大家可能会觉得有些不符合，有些人就是一生不工作，其实不然，&quot;一个人的工作是他在社会中所扮演的角色。&quot;)，这样有目标的学习一门语言才能更好的帮助你未来工作，当然同时也不要局限于一门语言，毕竟技多不压身。 &lt;strong&gt;求点赞👍&lt;/strong&gt; &lt;strong&gt;求关注❤️&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 还有一个问题，当我们不是很明确未来到底从事什么工作方向时，我们可以去找寻下自己的兴趣，其实大学很重要的一点就是找到自己的兴趣方向，尽量让自己的兴趣和自己工作方向相结合，能拿兴趣作为工作方向是再好不过的了。就像两个相爱的人在一起，每天都会是开开心的。如果是因为某些原因让两个没有感情基础的人在一起，那只能靠在一起之后才慢慢培养相爱的感觉。后者固然是不好的，但是为了生活很多人还是被迫选择了后者，趁年轻，趁还有机会，我希望你能选择前者。&lt;/p&gt;
&lt;p&gt; 当然还有很多其他的学长学姐给了我很多不一样的建议，但是总结下来就如下几点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;找一门和未来工作相关的语言开始学，一定要学到精通。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;要有工具思想，语言只是工具，工具是用来解决问题的。我们要做的灵活运用工具，了解工具的特性，顺便如果工具除了出了问题你会修理工具，那就再好不过了。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不要在选择语言上浪费太多时间，而应该在选择工作方向上找到自己的兴趣。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多花时间在工作方向上需要的其他技能上。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;结合过来人建议之后我的选择&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 听了过来人的建议之后，这几句经典涌上我的心头 &quot;林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。&quot;&lt;/p&gt;
&lt;p&gt; 我的工作方向是后端开发，我也比较喜欢后端开发，加上大学本来就会开设C语言和C++语言。于是我很顺理成章的选择了C语言作为我的编程入门首选语言。&lt;/p&gt;
&lt;p&gt; 现在作为过来人说说吧。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从学术研究上看，编程语言语法都差不多。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;从原理上看，编程语言都类似，对一门编程语言掌握到透彻后，再学习其它编程语言可以触类旁通。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;针对的是学习能力较强的人。有一定基础之后，可以快速的学习另一门技术。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 选择语言没必要那么纠结，但是编程入门我首推C语言，既有低级语言的高效，又有高级语言的抽象。C语言有很多特性，比如小巧，对操作系统很友好特别是linux操作系统(不要害怕linux，你工作以后100%会接触linux，不管你从事互联网什么行业，你都会或多或少的接触到linux)，运行速度快，支持汇编级别优化，可移植性好等等其他特性。当然也有缺点，比如开源框架少、不是很适合写业务系统，面向对象支持不是很好。C语言作为入门语言会有助于你去了解操作系统的运行原理，内存控制原理，对这些的了解有助于你学习其他任何高级编程语言。至于学完C语言之后，你不用纠结接下来学什么，接下来毫不犹豫用C语言把数据结构与算这本书学完并实现常用的数据结构与算法。&lt;/p&gt;
&lt;p&gt; 说下为什么学完C语言一定要去学习数据结构与算法，有以下几点原因。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;趁热打铁，刚好巩固C语言的语法和一些特性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据结构与算法是一门必修课，与未来从事什么方向无关(不要拿一些特殊职业出来钻牛角尖奥)。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 为什么我首推C语言作为编程入门的语言，而不是其他语言，并不是我觉得其他语言怎么的。除了以上说到的C语言的特性之外，还有一个很重要的原因，C语言几乎是所有计算机专业和相关专业都会开设的课程，作为入门语言，学习成本小，和同学、老师交流起来方便。这些因素会促使你很快学精C语言。&lt;/p&gt;
&lt;p&gt; 再陈述一段事实给大家。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;linux操作系统是C语言写的；流行的PHP、python只是C语言的一个扩展库；Java和Go起初也是用C/C++编写；以后会用到的mysql、redis、nginx都是yongC语言实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网上看到一段有意思的评论，分享下。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gam5rra9oij30z008e3z9.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; 语言只是工具，更重要的是在于使用工具的人。C语言在大牛手里可以写出来一个操作系统，在小白手里只能写Hello World。&lt;/p&gt;
&lt;p&gt; 学完这些之后，你需要学习和你未来方向相关的技能了，比如未来是做前端、后台、算法、AL等大领域里面的小领域。扯远了😁，继续说选语言的事，作为一个过来人很正式的告诉你，你需要学好一门面向对象语言即可，其他的语言只需要在工作中用到的情况下花几天时间就可以搞定，或者现学现用。因为你只要把握了一门C语言+一门面向对象的高级语言，其他语言的学习会触类旁通，学习成本会非常小。&lt;strong&gt;学通&lt;/strong&gt;了C语言，意味着你对变量类型、逻辑结构、函数栈、内存模型，程序编译原理、汇编级别优化都会掌握(看我的关键词&quot;学通&quot;，不是简单的学个hello world)。学完一门面向对象的高级语言，意味着你对面向对象的三大特性（继承、封装、多态）、抽象、设计模式有了很好的把握，这个时候工具使用已经到了很熟练的状态了，可以试着用工具去创造内容了，比如去&lt;a href=&quot;https://github.com/midou-tech/articles&quot;&gt;github&lt;/a&gt;找几个项目练练手，或者用编程解决日常生活中遇到的问题。 &lt;strong&gt;求点赞👍&lt;/strong&gt; &lt;strong&gt;求关注❤️&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 只要你是方向上没错，选择语言很so easy。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gaf6qcyx41j3073073mx4.jpg&quot; alt=&quot;img&quot; title=&quot;img&quot;/&gt;img
&lt;p&gt; 我总结了一份C语言的知识点思维导图，后期的文章会写一写关于C语言中的难点内容，比如程序的编译运行原理、函数栈调用过程、指针、内存管理等。github上有我的写作大纲，喜欢的可以star 和 issues。github：&lt;a href=&quot;https://github.com/midou-tech/articles&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;。大家在看的过程中遇到任何问题都可以给我发mail：2507367760@qq.com 或者 longyueshier@163.com 或者 longyueshier@gmail.com 我会每周三和周六的时候回复大家的邮件问题(工作繁忙，自己也需要沉淀，多理解下)。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1galrky9xobj30u01dl4dv.jpg&quot; alt=&quot;C语言知识点思维导图&quot; title=&quot;C语言知识点思维导图&quot;/&gt;C语言知识点思维导图
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我喜欢那些闪光的东西，比如冬日的雪花，天上的星星，还有你的眼睛。&lt;/p&gt;
&lt;p&gt;都看到这里了，奋斗中的你还不为同行点个赞， &lt;strong&gt;求点赞👍&lt;/strong&gt; &lt;strong&gt;求关注❤️&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;&lt;span&gt;求点赞👍 求关注❤️&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;龙跃十二更多精彩文章:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/nMTsD2y_drV971RxdE1a5g&quot;&gt;学习linux命令，看这篇2w多字的命令详解就够了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/V0_fcjr9t-lyqy2qyg6MWw&quot;&gt;HTTP就是这么简单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/OZRGLGk3MkdkwaNliITTUQ&quot;&gt;Redis基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Sel5ySSh0YJXdQ6KExQxyw&quot;&gt;顶级程序员工具集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/pcMWdKh9cFMS75sAxgCrWg&quot;&gt;二十多个免费高清图片素材网站送给你&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;如果有人想发文章，我这里有偿征稿(具体细则请微信联系),欢迎投稿或推荐你的项目。提供以下几种方式投稿&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;去我的github提交 issue:&lt;/code&gt; https://github.com/midou-tech/articles&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;发送到邮箱:&lt;/code&gt; 2507367760@qq.com 或者 longyueshier@163.com 或者 longyueshier@gmail.com&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;微信发送: 扫描下面二维码，公众号里面有作者微信号。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;精选文章都同步在公众号里面，公众号看起会更方便，随时随地想看就看。微信搜索 龙跃十二 或者扫码即可订阅。&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1galsp9a07kj30p00dwae3.jpg&quot; alt=&quot;龙跃十二&quot; title=&quot;龙跃十二&quot;/&gt;龙跃十二</description>
<pubDate>Sun, 05 Jan 2020 16:54:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>刚准备进入编程世界的人，难免会因为选择一门什么样的编程语言而纠结。最近也是很多粉丝问到我这个问题，所以我不得不花点时间以一个过来人的身份给大家一些建议。本文将围绕如何选择一门编程语言深度解析，解开你的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/12154492.html</dc:identifier>
</item>
<item>
<title>我的代码真的没有bug，稍等，先试试小黄鸭调试法 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/rubber-duck-debugging.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/rubber-duck-debugging.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天测试同学为了赶进度，加班去测试我的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为我的代码都写完了，也没有陪测的必要，所以就没去了~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下午第一个问题提过来，根据经验，这个应该是测试的逻辑问题，最后他自己也发现了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;过了一会，提了第二个问题，说是本该命中条件进入某个等级的，没有进入，跳到下个等级了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拥有几年开发经验的我，此时当然不会说“我的代码没有bug，你再试一遍”。说出这句话的成本近乎为0，但是脸要是打起来，那是真的疼啊~~~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;脑海中快速思考下，发现不是靠脑海中演练就能给出答案的，于是乖乖的，掀开电脑盖，指纹解锁，连接VPN，查看日志，一气呵成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为这个需求指标巨多，流程相对较长，所以我已经在代码的关键节点打印了数据日志。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，想要的信息，日志都是有的。只是，仔细看了下日志的数据，又认真的比对了测试同学给出的测试数据。讲道理，这确实应该命中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可是事实就是没有命中，于是开始排查。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;&quot;&gt;&lt;span&gt;查看配置中心&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;因为指标多，每个指标都有阈值，首先第一反应当时是别人的锅，所以我不放心的看了看是不是测试同学调整的参数阈值有问题，看完后，我有点愧疚，这不是测试同学的问题，指标都对上了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是还是不死心，是不是没有按照我给他说的要点选热加载选项，导致指标没生效。想到这里，我有点小激动，没错，我又可以表面轻描淡写，实则内心激动的告诉他真相：你这个是配置忘记勾选了吧（怎么回事，又是你的问题）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想归想，想要趾高气昂就要有底气，要底气就得拿证据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的配置中心做的就是这么贴心，每一次操作都可以查看历史记录。赶紧点一下，然后截个图，甩给他。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等等，这个，没想到啊，测试同学居然这么严谨，选项勾选了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;emmm&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;-1&quot;&gt;&lt;span&gt;调整策略&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;从日志来看，测试的数据没有问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从配置中心来看，配置也勾上了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试排除嫌疑，真相只有一个，是我的问题（自己打自己脸，下手可以轻点）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然家里连上了VPN，也可以看日志、发布项目，但是本地启动服务不好使，UT也跑不通。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那只能看代码了，要知道，近朱者赤近墨者黑，找别人缺点，那是章口就莱，一莱一个准。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找自己的问题？首先得否定自己，知道自己原来也是有瑕疵的，这是多么难的事儿，但是我做到了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了给测试同学一个交代，我开始老老实实的研读自己的代码，企图一眼就发现自己的不足~（太南了&lt;/span&gt;&lt;/p&gt;


&lt;h3 id=&quot;-2&quot;&gt;&lt;span&gt;失策了&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;涉及测试点的代码逻辑也不复杂。大概过程是这样的&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;上游并发调用获取各个指标的当前值 -&amp;gt; 在规则层过滤 -&amp;gt; 如果命中两个规则条件则视为命中，否则未命中&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;于是，按照测试同学提供的两个指标以及提供的测试数据比对两个规则的阈值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从日志来看，上游的数据是没有问题的，从数据比对来说，应该是比对通过了，但是没有命中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是开始仔细检查这两个规则相关的代码，以防出现，手抖把&quot;!=&quot;写成&quot;==&quot;的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很遗憾，在我认为比较关键的地方查看后，发现我的代码就是这么严谨，找不出任何破绽。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了不让测试同学hang在我这个线程上划水、摸鱼，我得先释放锁：“代码看着没啥问题，你先测试其他逻辑，我再看看。”&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;-3&quot;&gt;&lt;span&gt;小黄鸭救了我&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我心里清楚，虽然我有一点散光，但是眼睛还没瞎。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以即使再比对十遍八遍，肯定也还是找不到bug。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是时候换一种思路了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面说了，上游代码排除嫌疑，涉事代码本身排除嫌疑，当然，测试同学也排除嫌疑，更别说下游代码，下游完全不知情啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;仔细想想，两个规则之前还有有其他代码的，虽然也是一个规则。我决定擦亮双眼，人肉找bug。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把自己当做一台没有感情的机器，一遍读这我写的工整简洁的代码，一遍计算代码的结果，再到排除嫌疑。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;上游赋值没有问题！
变量初始化和结果返回没有问题！
第一个规则没有问题！
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个规则没有问题！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他初始变量赋值和返回没有问题！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后开始过第一个规则和第二个规则之间的中间规则代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在方法返回的时候好像没有返回期望的值啊？！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没错，我把本来应该不管命中与否都要返回的一个变量值，只在命中的条件里赋值返回了。如果没有命中这个规则，则没有赋值，那实际上返回的是这个变量的类型默认值，也就是0，归零了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;趾高气昂只会迟到，但永远都不会缺席。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我告知测试同学，我应该知道原因了，我修复下，一会再试下，后面的“英雄事迹”就不多介绍了。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;-4&quot;&gt;&lt;span&gt;总结盘点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;虽然不是什么大问题，也不是什么线上大事故。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只是想表达，几乎没有人敢说自己写的代码0bug，写完就可以上线。曾经有跟我这么承诺和标榜的人，最终都是难逃翻车和打脸的命运。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有问题，理性分析最重要，从涉及bug的方方面面，包括经手的人和代码本身，都有可能出问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时候，如果发现是自己的问题，但是又迟迟找不到原因，不要一个人闷着头苦苦思索，找个同事来帮你一起找。有时候就在你准备让别人一起来看看，你开始描述问题的诡异之处，还没说完，你就突然知道了原因。不知道你遇到过没有，反正我有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天回过头想想，哪些被我叫来的人其实就是工具人，他们和小黄鸭无异。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是小黄鸭和小黄鸭调试法呢，参见百度词条&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;此概念是参照于一个来自《程序员修炼之道》书中的一个故事。传说中程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码  。
　　许多程序员都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题，就在解释的过程中击中了问题的解决方案。一边阐述代码的意图一边观察它实际上的意图并做调试，这两者之间的任何不协调会变得很明显，并且更容易发现自己的错误。如果没有玩具小鸭子也可以考虑向其它东西倾诉，比如桌上的花花草草，键盘鼠标。
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似这样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/202001/619240-20200105231417004-585307182.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者这样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/202001/619240-20200105231426252-885242452.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找不到鸭子，找同事也一样~&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的&lt;strong&gt;“推荐”&lt;/strong&gt;将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;/p&gt;
&lt;pre&gt;
&lt;em&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/619240/201505/162205410643708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 05 Jan 2020 15:17:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>bug难寻找，小黄鸭是法宝~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigdataZJ/p/rubber-duck-debugging.html</dc:identifier>
</item>
</channel>
</rss>