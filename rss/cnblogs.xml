<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>浅析Kubernrtes服务类型（Service Types） - 空壳先生</title>
<link>http://www.cnblogs.com/scofield666/p/13733728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scofield666/p/13733728.html</guid>
<description>&lt;p&gt;先上图&lt;br/&gt;&lt;img src=&quot;http://showdoc.ieasou.cn/server/index.php?s=/api/attachment/visitFile/sign/dc02e242c425c10877fa69c1f6bcda9e&amp;amp;showdoc=.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Kubernetes集群中，service通过标签选择器选着对应的pod，然后对请求进行转发，看个动画，能直接了当体会到便签选择器&lt;br/&gt;&lt;img src=&quot;http://showdoc.ieasou.cn/server/index.php?s=/api/attachment/visitFile/sign/cd38218168ec358a525d5a8ad1e68c20&amp;amp;showdoc=.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;pod，endpoints，service三者关系&quot;&gt;pod，endpoints，service三者关系&lt;/h3&gt;
&lt;p&gt;1、举个栗子说明&lt;br/&gt;先看部署文件，主要看注释部分。因为文件太长，本文删除了yaml文件的部分字段&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: gogs
  labels:       # 定义StatefulSet的标签，为后面Service选择器提供标签
    app: gogs
spec:
  serviceName: gogs
  replicas: 1
  selector:
    matchLabels:  # 标签选择器，StatefulSet通过该标签选择pod
      app: gogs
  template:
    metadata:
      labels:    # 定义pod的标签
        app: gogs
    spec:
      terminationGracePeriodSeconds: 180
.......
---
apiVersion: v1
kind: Service
metadata:
  name: gogs
  labels:
    app: gogs
spec:
  type: NodePort
  ports:
  - port: 3000
    targetPort: 3000
  selector:      # 标签匹配器，Service通过该标签匹配到对应的Pod
    app: gogs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、查看运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@k8s-node001 ~]# kubectl  get po,ep,svc
NAME                                READY   STATUS    RESTARTS   AGE
pod/gogs-0                          1/1     Running   0          3d1h

NAME                   ENDPOINTS                                                        AGE
endpoints/gogs         100.68.150.197:3000                                              3d1h

NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
service/gogs         NodePort    10.106.102.74   &amp;lt;none&amp;gt;        3000:30526/TCP   3d1h
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、通过kubectl describe来查看pod，endpoints，service详情&lt;br/&gt;&lt;img src=&quot;http://showdoc.ieasou.cn/server/index.php?s=/api/attachment/visitFile/sign/0c3fe46a3ed0d990904e18cb901042a7&amp;amp;showdoc=.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4、从上图可以看出关联信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;1、Pod和Endpoint的的IP是一致的，Endpoint是用来映射那些能对外提供服务的pod，如果pod运行状态不是running,就不会产出Endpoint
2、StatefulSet 和 Pod 的关系是通过 label-selector 来关联的
3、 Service可以简单理解为 Kubernetes 内置的一个 LoadBalancer，它的作用就是给多个 Pod 提供负载均衡。
4、Service通过标签 app: gogs来匹配它所要做负载均衡的 Pod
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，对pod，endpoints，service三者关系做了简单介绍，接下来我们来介绍Kubernetes中的几种Service Type&lt;/p&gt;
&lt;h3 id=&quot;clusterip&quot;&gt;ClusterIP&lt;/h3&gt;
&lt;p&gt;通过集群的内部 IP 暴露服务，选择该值，服务只能够在集群内部可以访问，这也是默认的 ServiceType&lt;br/&gt;缺点：服务只能够在集群内部可以访问&lt;br/&gt;栗子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: gogs-clusterip
spec:
  type: ClusterIP
  ports:
  - port: 3000
    targetPort: 3000
  selector:
    app: gogs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
gogs-clusterip   ClusterIP   10.104.1.9      &amp;lt;none&amp;gt;        3000/TCP         2m11s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到10.104.1.9是集群内部的一个IP，在集群外是无法访问到的&lt;/p&gt;
&lt;h3 id=&quot;nodeport&quot;&gt;NodePort&lt;/h3&gt;
&lt;p&gt;如果将 type 字段设置为 NodePort，则 Kubernetes将在指定的范围内分配端口（默认值：30000-32767）。 每个节点将随机分配的端口代理到服务中。&lt;br/&gt;举栗子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: gogs
spec:
  type: NodePort
  ports:
  - port: 3000
    targetPort: 3000
  selector:
    app: gogs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
gogs             NodePort    10.106.102.74   &amp;lt;none&amp;gt;        3000:30526/TCP   3d2h
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到，随机分配了端口30526，现在可以通过集群任意节点的IP+30526访问到该服务&lt;/p&gt;
&lt;h3 id=&quot;ingress&quot;&gt;Ingress&lt;/h3&gt;
&lt;p&gt;Ingress 公开了从集群外部到集群内服务的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。&lt;br/&gt;可以将 Ingress 配置为服务提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及提供基于名称的虚拟主机等能力。 Ingress 控制器 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。&lt;br/&gt;栗子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: gogs-gogs
  annotations:
    kubernetes.io/ingress.class: nginx
spec:
  rules:
  - host: gogs.test.cn
    http:
      paths:
      - path: /
        backend:
          serviceName: gogs
          servicePort: 3000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;NAME    CLASS    HOSTS             ADDRESS       PORTS   AGE
gogs-gogs   &amp;lt;none&amp;gt;    gogs.test.cn   10.26.25.21   80      3d19h
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在通过域名gogs.test.cn就可以访问到gogs了&lt;br/&gt;注意，gogs.test.cn需要自行添加DNS解析到ingress所在机器的IP&lt;/p&gt;
&lt;h3 id=&quot;loadbalancer&quot;&gt;LoadBalancer&lt;/h3&gt;
&lt;p&gt;创建服务时，你可以选择自动创建云网络负载均衡器。这提供了一个外部可访问的 IP 地址， 可将流量分配到集群节点上的正确端口上，LoadBalancer一般都是公有云厂商提供，不需要自建，这里就介绍了。&lt;br/&gt;&lt;img src=&quot;http://showdoc.ieasou.cn/server/index.php?s=/api/attachment/visitFile/sign/99e25dd69f442ef7c95e7c5a8eca1a81&amp;amp;showdoc=.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Sep 2020 00:48:00 +0000</pubDate>
<dc:creator>空壳先生</dc:creator>
<og:description>先上图 在Kubernetes集群中，service通过标签选择器选着对应的pod，然后对请求进行转发，看个动画，能直接了当体会到便签选择器 pod，endpoints，service三者关系 1、举</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/scofield666/p/13733728.html</dc:identifier>
</item>
<item>
<title>Alink漫谈(二十二) ：源码分析之聚类评估 - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13733182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13733182.html</guid>
<description>&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文和上文将带领大家来分析Alink中 聚类评估 的实现。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;395.76310569566&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文和上文将带领大家来分析Alink中 聚类评估 的实现。&lt;/p&gt;
&lt;h2 id=&quot;0x01-背景概念&quot;&gt;0x01 背景概念&lt;/h2&gt;
&lt;h3 id=&quot;11-什么是聚类&quot;&gt;1.1 什么是聚类&lt;/h3&gt;
&lt;p&gt;聚类(Clustering)，用通俗的话来说，就是物以类聚，人以群分。&lt;/p&gt;
&lt;p&gt;聚类是观察式学习，而不是示例式的学习。聚类能够作为一个独立的工具获得数据的分布状况，观察每一簇数据的特征，集中对特定的聚簇集合作进一步地分析。&lt;/p&gt;
&lt;p&gt;聚类分析还可以作为其他数据挖掘任务（如分类、关联规则）的预处理步骤。&lt;/p&gt;
&lt;h3 id=&quot;12-聚类分析的方法&quot;&gt;1.2 聚类分析的方法&lt;/h3&gt;
&lt;p&gt;聚类分析可以大致分为如下方法：&lt;/p&gt;
&lt;p&gt;划分方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Construct various partitions and then evaluate them by some criterion,e.g.,minimizing the sum of square errors&lt;/li&gt;
&lt;li&gt;Typical methods:k-means,k-medoids,CLARANS&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;层次方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Create a hierarchical decomposition of the set of data (or objects) using some criterion&lt;/li&gt;
&lt;li&gt;Typical methods: Diana,Agnes,BIRCH,CAMELEON&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;基于密度的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Based on connectivity and density functions&lt;/li&gt;
&lt;li&gt;Typical methods: DBSCAN,OPTICS,DenClue&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;基于网格的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Based on multiple-level granularity structure&lt;/li&gt;
&lt;li&gt;Typical methods: STING,WaveCluster,CLIQUE&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;基于模型的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;A model is hypothesized for each of the clusters and tries to find the best fit of that model to each other&lt;/li&gt;
&lt;li&gt;Typical methods: EM,SOM,COBWEB&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;基于频繁模式的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Based on the analysis of frequent patterns&lt;/li&gt;
&lt;li&gt;Typical methods: p-Cluster&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;基于约束的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Clustering by considering user-specified or application-specific constraints&lt;/li&gt;
&lt;li&gt;Typical methods: COD(obstacles),constrained clustering&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;基于链接的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Objects are often linked together in various ways&lt;/li&gt;
&lt;li&gt;Massive links can be used to cluster objects: SimRank,LinkClus&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;13-聚类评估&quot;&gt;1.3 聚类评估&lt;/h3&gt;
&lt;p&gt;聚类评估估计在数据集上进行聚类的可行性和被聚类方法产生的结果的质量。聚类评估主要包括：估计聚类趋势、确定数据集中的簇数、测定聚类质量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;估计聚类趋势&lt;/strong&gt;：对于给定的数据集，评估该数据集是否存在非随机结构。盲目地在数据集上使用聚类方法将返回一些簇，所挖掘的簇可能是误导。数据集上的聚类分析是有意义的，仅当数据中存在非随机结构。&lt;/p&gt;
&lt;p&gt;聚类趋势评估确定给定的数据集是否具有可以导致有意义的聚类的非随机结构。一个没有任何非随机结构的数据集，如数据空间中均匀分布的点，尽管聚类算法可以为该数据集返回簇，但这些簇是随机的，没有任何意义。聚类要求数据的非均匀分布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测定聚类质量&lt;/strong&gt;：在数据集上使用聚类方法之后，需要评估结果簇的质量。&lt;/p&gt;
&lt;p&gt;具体有两类方法：外在方法和内在方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外在方法：有监督的方法，需要基准数据。用一定的度量评判聚类结果与基准数据的符合程度。&lt;/li&gt;
&lt;li&gt;内在方法：无监督的方法，无需基准数据。类内聚集程度和类间离散程度。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x02-alink支持的评估指标&quot;&gt;0x02 Alink支持的评估指标&lt;/h2&gt;
&lt;p&gt;Alink文档中如下：聚类评估是对聚类算法的预测结果进行效果评估，支持下列评估指标。但是实际从其测试代码中可以发现更多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Compactness(CP),&lt;/strong&gt; CP越低意味着类内聚类距离越近&lt;/p&gt;
&lt;p&gt;\[\overline{CP_i}=\dfrac{1}{|C_i|}\sum_{x \in C_i}\|x_i-u_i\| \]&lt;/p&gt;
&lt;p&gt;\[\overline{CP}=\dfrac{1}{k}\sum_{i=1}^{k}\overline{CP_k} \]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seperation(SP)&lt;/strong&gt;, SP越高意味类间聚类距离越远&lt;/p&gt;
&lt;p&gt;\[SP=\dfrac{2}{k^2-k}\sum_{i=1}^{k}\sum_{j=i+1}^{k}\|u_i-u_j\| \]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Davies-Bouldin Index(DB)&lt;/strong&gt;, DB越小意味着类内距离越小 同时类间距离越大&lt;/p&gt;
&lt;p&gt;\[DB=\dfrac{1}{k}\sum_{i=1}^{k}max(\dfrac{\overline{CP_i}+\overline{CP_j}}{\|u_i-u_j\|}), i \not= j \]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Calinski-Harabasz Index(VRC)&lt;/strong&gt;, VRC越大意味着聚类质量越好&lt;/p&gt;
&lt;p&gt;\[SSB=\sum_{i=1}^{k}n_i\|u_i-u\|^2 \]&lt;/p&gt;
&lt;p&gt;\[SSW=\sum_{i=1}^{k}\sum_{x \in C_i}\|x_i-u_i\| \]&lt;/p&gt;
&lt;p&gt;\[VRC=\dfrac{SSB}{SSW}*\dfrac{N-k}{k-1} \]&lt;/p&gt;
&lt;p&gt;从其测试代码中，我们可以发现更多指标:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Assert.assertEquals(metrics.getCalinskiHarabaz(), 12150.00, 0.01);
Assert.assertEquals(metrics.getCompactness(), 0.115, 0.01);
Assert.assertEquals(metrics.getCount().intValue(), 6);
Assert.assertEquals(metrics.getDaviesBouldin(), 0.014, 0.01);
Assert.assertEquals(metrics.getSeperation(), 15.58, 0.01);
Assert.assertEquals(metrics.getK().intValue(), 2);
Assert.assertEquals(metrics.getSsb(), 364.5, 0.01);
Assert.assertEquals(metrics.getSsw(), 0.119, 0.01);
Assert.assertEquals(metrics.getPurity(), 1.0, 0.01);
Assert.assertEquals(metrics.getNmi(), 1.0, 0.01);
Assert.assertEquals(metrics.getAri(), 1.0, 0.01);
Assert.assertEquals(metrics.getRi(), 1.0, 0.01);
Assert.assertEquals(metrics.getSilhouetteCoefficient(), 0.99,0.01);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要介绍几个指标&lt;/p&gt;
&lt;h3 id=&quot;21-轮廓系数（silhouette-coefficient）：&quot;&gt;2.1 轮廓系数（silhouette coefficient）：&lt;/h3&gt;
&lt;p&gt;对于D中的每个对象o，计算：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a(o) : o与o所属的簇内其他对象之间的平均距离a(o) 。&lt;/li&gt;
&lt;li&gt;b(o) : 是o到不包含o的所有簇的最小平均距离。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;得到轮廓系数定义为：&lt;/p&gt;
&lt;p&gt;\[s(o)=\dfrac{b(o)-a(o)}{max\{a(o),b(o)\}} \]&lt;/p&gt;
&lt;p&gt;轮廓系数的值在-1和1之间。&lt;/p&gt;
&lt;p&gt;a(o)的值反映o所属的簇的紧凑性。该值越小，簇越紧凑。&lt;/p&gt;
&lt;p&gt;b(o)的值捕获o与其他簇的分离程度。b(o)的值越大，o与其他簇越分离。&lt;/p&gt;
&lt;p&gt;当o的轮廓系数值接近1时，包含o的簇是紧凑的，并且o远离其他簇，这是一种可取的情况。&lt;/p&gt;
&lt;p&gt;当轮廓系数的值为负时，这意味在期望情况下，o距离其他簇的对象比距离与自己同在簇的对象更近，许多情况下，这很糟糕，应当避免。&lt;/p&gt;
&lt;h3 id=&quot;22-calinski-harabaz（ch）&quot;&gt;2.2 Calinski-Harabaz（CH）&lt;/h3&gt;
&lt;p&gt;CH指标通过计算类中各点与类中心的距离平方和来度量类内的紧密度，通过计算各类中心点与数据集中心点距离平方和来度量数据集的分离度，CH指标由分离度与紧密度的比值得到。从而，CH越大代表着类自身越紧密，类与类之间越分散，即更优的聚类结果。&lt;/p&gt;
&lt;p&gt;CH和轮廓系数适用于实际类别信息未知的情况。&lt;/p&gt;
&lt;h3 id=&quot;23-davies-bouldin指数dbi&quot;&gt;2.3 Davies-Bouldin指数(Dbi)&lt;/h3&gt;
&lt;p&gt;戴维森堡丁指数(DBI)，又称为分类适确性指标，是由大卫&lt;em&gt;L·&lt;/em&gt;戴维斯和唐纳德&lt;em&gt;·Bouldin&lt;/em&gt;提出的一种评估聚类算法优劣的指标。&lt;/p&gt;
&lt;p&gt;这个DBI就是计算类内距离之和与类外距离之比，来优化k值的选择，避免K-means算法中由于只计算目标函数Wn而导致局部最优的情况。&lt;/p&gt;
&lt;h3 id=&quot;24-rand-index兰德指数ri-、adjusted-rand-index调整兰德指数ari&quot;&gt;2.4 Rand index(兰德指数)(RI) 、Adjusted Rand index(调整兰德指数)(ARI)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160903164214309&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中C表示实际类别信息，K表示聚类结果，a表示在C与K中都是同类别的元素对数，b表示在C与K中都是不同类别的元素对数。&lt;/p&gt;
&lt;p&gt;RI取值范围为[0,1]，值越大意味着聚类结果与真实情况越吻合。RI越大表示聚类效果准确性越高 同时每个类内的纯度越高&lt;/p&gt;
&lt;p&gt;为了实现“在聚类结果随机产生的情况下，指标应该接近零”，调整兰德系数（Adjusted rand index）被提出，它具有更高的区分度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160903164236481&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ARI取值范围为[−1,1]，值越大意味着聚类结果与真实情况越吻合。从广义的角度来讲，ARI衡量的是两个数据分布的吻合程度。&lt;/p&gt;
&lt;h2 id=&quot;0x03-示例代码&quot;&gt;0x03 示例代码&lt;/h2&gt;
&lt;p&gt;聚类评估示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class EvalClusterBatchOpExp {
    public static void main(String[] args) throws Exception {
        Row[] rows = new Row[] {
                Row.of(0, &quot;0,0,0&quot;),
                Row.of(0, &quot;0.1,0.1,0.1&quot;),
                Row.of(0, &quot;0.2,0.2,0.2&quot;),
                Row.of(1, &quot;9,9,9&quot;),
                Row.of(1, &quot;9.1,9.1,9.1&quot;),
                Row.of(1, &quot;9.2,9.2,9.2&quot;)
        };

        MemSourceBatchOp inOp = new MemSourceBatchOp(Arrays.asList(rows), new String[] {&quot;label&quot;, &quot;Y&quot;});

        KMeans train = new KMeans()
                .setVectorCol(&quot;Y&quot;)
                .setPredictionCol(&quot;pred&quot;)
                .setK(2);

        ClusterMetrics metrics = new EvalClusterBatchOp()
                .setPredictionCol(&quot;pred&quot;)
                .setVectorCol(&quot;Y&quot;)
                .setLabelCol(&quot;label&quot;)
                .linkFrom(train.fit(inOp).transform(inOp))
                .collectMetrics();

        System.out.println(metrics.getCalinskiHarabaz());
        System.out.println(metrics.getCompactness());
        System.out.println(metrics.getCount());
        System.out.println(metrics.getDaviesBouldin());
        System.out.println(metrics.getSeperation());
        System.out.println(metrics.getK());
        System.out.println(metrics.getSsb());
        System.out.println(metrics.getSsw());
        System.out.println(metrics.getPurity());
        System.out.println(metrics.getNmi());
        System.out.println(metrics.getAri());
        System.out.println(metrics.getRi());
        System.out.println(metrics.getSilhouetteCoefficient());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;12150.000000000042
0.11547005383792497
6
0.014814814814814791
15.588457268119896
2
364.5
0.1199999999999996
1.0
1.0
1.0
1.0
0.9997530305375205
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-总体逻辑&quot;&gt;0x04 总体逻辑&lt;/h2&gt;
&lt;p&gt;代码整体逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;label 相关指标计算操作
&lt;ul&gt;&lt;li&gt;使用 calLocalPredResult 对每个分区操作
&lt;ul&gt;&lt;li&gt;flatMap 1 是打散Row，得到 Label y&lt;/li&gt;
&lt;li&gt;flatMap 2 是打散Row，得到 y_hat，所以前两步是得到 y 和 y_hat 的映射 map。这两个会广播给 CalLocalPredResult 使用。&lt;/li&gt;
&lt;li&gt;调用 CalLocalPredResult 建立混淆矩阵&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用 reduce 归并这些分区操作结果。&lt;/li&gt;
&lt;li&gt;使用 extractParamsFromConfusionMatrix 根据混淆矩阵计算 purity, NMI等指标&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector相关指标计算操作
&lt;ul&gt;&lt;li&gt;对数据按照类别进行分组&lt;/li&gt;
&lt;li&gt;分组归并，调用 CalcClusterMetricsSummary分布式计算向量相关的指标
&lt;ul&gt;&lt;li&gt;遍历 rows，累积到 sumVector&lt;/li&gt;
&lt;li&gt;循环，计算出若干统计信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用 ReduceBaseMetrics，再归并，形成一个BaseMetricsSummary&lt;/li&gt;
&lt;li&gt;调用 calSilhouetteCoefficient 来计算 SilhouetteCoefficient&lt;/li&gt;
&lt;li&gt;把数据存储为Params&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;合并输出
&lt;ul&gt;&lt;li&gt;做了一个 union，把 labelMetrics 和 vectorMetrics 联合起来，再归并输出到最后的表中&lt;/li&gt;
&lt;li&gt;分组归并&lt;/li&gt;
&lt;li&gt;输出到最后表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public EvalClusterBatchOp linkFrom(BatchOperator&amp;lt;?&amp;gt;... inputs) {
    BatchOperator in = checkAndGetFirst(inputs);
    String labelColName = this.getLabelCol();
    String predResultColName = this.getPredictionCol();
    String vectorColName = this.getVectorCol();
    DistanceType distanceType = getDistanceType();
    ContinuousDistance distance = distanceType.getFastDistance();

    DataSet&amp;lt;Params&amp;gt; empty = MLEnvironmentFactory.get(getMLEnvironmentId()).getExecutionEnvironment().fromElements(
        new Params());
    DataSet&amp;lt;Params&amp;gt; labelMetrics = empty, vectorMetrics;

    if (null != labelColName) { // 针对 label 操作
        // 获取数据
        DataSet&amp;lt;Row&amp;gt; data = in.select(new String[] {labelColName, predResultColName}).getDataSet();
        // 使用 calLocalPredResult 对每个分区操作
        labelMetrics = calLocalPredResult(data)
            .reduce(new ReduceFunction&amp;lt;LongMatrix&amp;gt;() { // 使用 reduce 归并这些分区操作结果
                @Override
                public LongMatrix reduce(LongMatrix value1, LongMatrix value2) {
                    value1.plusEqual(value2);
                    return value1;
                }
            })
            .map(new MapFunction&amp;lt;LongMatrix, Params&amp;gt;() { 
                @Override
                public Params map(LongMatrix value) {
                    // 使用  extractParamsFromConfusionMatrix 根据混淆矩阵计算 purity, NMI等指标
                    return ClusterEvaluationUtil.extractParamsFromConfusionMatrix(value);
                }
            });
    }
    if (null != vectorColName) {
        // 获取数据
        DataSet&amp;lt;Row&amp;gt; data = in.select(new String[] {predResultColName, vectorColName}).getDataSet();
      
        DataSet&amp;lt;BaseMetricsSummary&amp;gt; metricsSummary = data
            .groupBy(0) // 对数据按照类别进行分组
            .reduceGroup(new CalcClusterMetricsSummary(distance)) // 分布式计算向量相关的指标
            .reduce(new EvaluationUtil.ReduceBaseMetrics());// 归并
        DataSet&amp;lt;Tuple1&amp;lt;Double&amp;gt;&amp;gt; silhouetteCoefficient = data.map(  // 计算silhouette
            new RichMapFunction&amp;lt;Row, Tuple1&amp;lt;Double&amp;gt;&amp;gt;() {
                @Override
                public Tuple1&amp;lt;Double&amp;gt; map(Row value) {
                    List&amp;lt;BaseMetricsSummary&amp;gt; list = getRuntimeContext().getBroadcastVariable(METRICS_SUMMARY);
                    return ClusterEvaluationUtil.calSilhouetteCoefficient(value,
                        (ClusterMetricsSummary)list.get(0));
                }
            }).withBroadcastSet(metricsSummary, METRICS_SUMMARY)
            .aggregate(Aggregations.SUM, 0);

        // 把数据存储为Params
        vectorMetrics = metricsSummary.map(new ClusterEvaluationUtil.SaveDataAsParams()).withBroadcastSet( 
            silhouetteCoefficient, SILHOUETTE_COEFFICIENT);
    } else {
        vectorMetrics = in.select(predResultColName)
            .getDataSet()
            .reduceGroup(new BasicClusterParams());
    }

    DataSet&amp;lt;Row&amp;gt; out = labelMetrics
        .union(vectorMetrics) // 把 labelMetrics 和 vectorMetrics 联合起来
        .reduceGroup(new GroupReduceFunction&amp;lt;Params, Row&amp;gt;() { // 分组归并
            @Override
            public void reduce(Iterable&amp;lt;Params&amp;gt; values, Collector&amp;lt;Row&amp;gt; out) {
                Params params = new Params();
                for (Params p : values) {
                    params.merge(p);
                }
                out.collect(Row.of(params.toJson()));
            }
        });
    // 输出到最后表
    this.setOutputTable(DataSetConversionUtil.toTable(getMLEnvironmentId(),
        out, new TableSchema(new String[] {EVAL_RESULT}, new TypeInformation[] {Types.STRING}) 
    ));
    return this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x05-针对-label-操作&quot;&gt;0x05 针对 label 操作&lt;/h2&gt;
&lt;h3 id=&quot;51-callocalpredresult&quot;&gt;5.1 calLocalPredResult&lt;/h3&gt;
&lt;p&gt;因为前面有 &lt;code&gt;DataSet&amp;lt;Row&amp;gt; data = in.select(new String[] {labelColName, predResultColName}).getDataSet();&lt;/code&gt;，所以这里处理的就是 y 和 y_hat。&lt;/p&gt;
&lt;p&gt;有两个 flatMap 串起来。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;flatMap 1 是打散Row，得到 Label y&lt;/li&gt;
&lt;li&gt;flatMap 2 是打散Row，得到 y_hat&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两个 flatMap 都接了 DistinctLabelIndexMap 和 project(0)，DistinctLabelIndexMap 作用是 &lt;code&gt;Give each label an ID, return a map of label and ID.&lt;/code&gt;，就是给每一个 ID 一个 label。project(0)就是提取出 label。&lt;/p&gt;
&lt;p&gt;所以前两步是得到 y 和 y_hat 的映射 map。这两个会广播给 CalLocalPredResult 使用。&lt;/p&gt;
&lt;p&gt;第三步是调用 CalLocalPredResult 建立混淆矩阵。&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static DataSet&amp;lt;LongMatrix&amp;gt; calLocalPredResult(DataSet&amp;lt;Row&amp;gt; data) {

    // 打散Row，得到 Label y
    DataSet&amp;lt;Tuple1&amp;lt;Map&amp;lt;String, Integer&amp;gt;&amp;gt;&amp;gt; labels = data.flatMap(new FlatMapFunction&amp;lt;Row, String&amp;gt;() {
        @Override
        public void flatMap(Row row, Collector&amp;lt;String&amp;gt; collector) {
            if (EvaluationUtil.checkRowFieldNotNull(row)) {
                collector.collect(row.getField(0).toString());
            }
        }
    }).reduceGroup(new EvaluationUtil.DistinctLabelIndexMap(false, null)).project(0);
    // 打散Row，得到 y_hat
    DataSet&amp;lt;Tuple1&amp;lt;Map&amp;lt;String, Integer&amp;gt;&amp;gt;&amp;gt; predictions = data.flatMap(new FlatMapFunction&amp;lt;Row, String&amp;gt;() {
        @Override
        public void flatMap(Row row, Collector&amp;lt;String&amp;gt; collector) {
            if (EvaluationUtil.checkRowFieldNotNull(row)) {
                collector.collect(row.getField(1).toString());
            }
        }
    }).reduceGroup(new EvaluationUtil.DistinctLabelIndexMap(false, null)).project(0);

    // 前两步是得到 y 和 y_hat 的映射 map。这两个会广播给 CalLocalPredResult 使用
    // Build the confusion matrix.
    DataSet&amp;lt;LongMatrix&amp;gt; statistics = data
        .rebalance()
        .mapPartition(new CalLocalPredResult())
        .withBroadcastSet(labels, LABELS)
        .withBroadcastSet(predictions, PREDICTIONS);

    return statistics;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CalLocalPredResult 建立混淆矩阵。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;open函数中，会从系统中获取 y 和 y_hat。&lt;/li&gt;
&lt;li&gt;mapPartition函数中，建立混淆矩阵。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;matrix = {long[2][]@10707} 
 0 = {long[2]@10709} 
  0 = 0
  1 = 0
 1 = {long[2]@10710} 
  0 = 1
  1 = 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static class CalLocalPredResult extends RichMapPartitionFunction&amp;lt;Row, LongMatrix&amp;gt; {
    private Map&amp;lt;String, Integer&amp;gt; labels, predictions;

    @Override
    public void open(Configuration parameters) throws Exception {
        List&amp;lt;Tuple1&amp;lt;Map&amp;lt;String, Integer&amp;gt;&amp;gt;&amp;gt; list = getRuntimeContext().getBroadcastVariable(LABELS);
        this.labels = list.get(0).f0;
        list = getRuntimeContext().getBroadcastVariable(PREDICTIONS);
        this.predictions = list.get(0).f0;
    }

    @Override
    public void mapPartition(Iterable&amp;lt;Row&amp;gt; rows, Collector&amp;lt;LongMatrix&amp;gt; collector) {
        long[][] matrix = new long[predictions.size()][labels.size()];
        for (Row r : rows) {
            if (EvaluationUtil.checkRowFieldNotNull(r)) {
                int label = labels.get(r.getField(0).toString());
                int pred = predictions.get(r.getField(1).toString());
                matrix[pred][label] += 1;
            }
        }
        collector.collect(new LongMatrix(matrix));
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;extractParamsFromConfusionMatrix 这里就是根据混淆矩阵计算 purity, NMI 等一系列指标。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static Params extractParamsFromConfusionMatrix(LongMatrix longMatrix) {
    long[][] matrix = longMatrix.getMatrix();
    long[] actualLabel = longMatrix.getColSums();
    long[] predictLabel = longMatrix.getRowSums();
    long total = longMatrix.getTotal();

    double entropyActual = 0.0;
    double entropyPredict = 0.0;
    double mutualInfor = 0.0;
    double purity = 0.0;
    long tp = 0L;
    long tpFpSum = 0L;
    long tpFnSum = 0L;
    for (long anActualLabel : actualLabel) {
        entropyActual += entropy(anActualLabel, total);
        tpFpSum += combination(anActualLabel);
    }
    entropyActual /= -Math.log(2);
    for (long aPredictLabel : predictLabel) {
        entropyPredict += entropy(aPredictLabel, total);
        tpFnSum += combination(aPredictLabel);
    }
    entropyPredict /= -Math.log(2);
    for (int i = 0; i &amp;lt; matrix.length; i++) {
        long max = 0;
        for (int j = 0; j &amp;lt; matrix[0].length; j++) {
            max = Math.max(max, matrix[i][j]);
            mutualInfor += (0 == matrix[i][j] ? 0.0 :
                1.0 * matrix[i][j] / total * Math.log(1.0 * total * matrix[i][j] / predictLabel[i] / actualLabel[j]));
            tp += combination(matrix[i][j]);
        }
        purity += max;
    }
    purity /= total;
    mutualInfor /= Math.log(2);
    long fp = tpFpSum - tp;
    long fn = tpFnSum - tp;
    long totalCombination = combination(total);
    long tn = totalCombination - tp - fn - fp;
    double expectedIndex = 1.0 * tpFpSum * tpFnSum / totalCombination;
    double maxIndex = 1.0 * (tpFpSum + tpFnSum) / 2;
    double ri = 1.0 * (tp + tn) / (tp + tn + fp + fn);
    return new Params()
        .set(ClusterMetrics.NMI, 2.0 * mutualInfor / (entropyActual + entropyPredict))
        .set(ClusterMetrics.PURITY, purity)
        .set(ClusterMetrics.RI, ri)
        .set(ClusterMetrics.ARI, (tp - expectedIndex) / (maxIndex - expectedIndex));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x06-vector相关&quot;&gt;0x06 Vector相关&lt;/h2&gt;
&lt;p&gt;前两步是分布式计算 以及 归并：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;DataSet&amp;lt;BaseMetricsSummary&amp;gt; metricsSummary = data
    .groupBy(0)
    .reduceGroup(new CalcClusterMetricsSummary(distance))
    .reduce(new EvaluationUtil.ReduceBaseMetrics());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;61-calcclustermetricssummary&quot;&gt;6.1 CalcClusterMetricsSummary&lt;/h3&gt;
&lt;p&gt;调用了 ClusterEvaluationUtil.getClusterStatistics 来进行计算。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static class CalcClusterMetricsSummary implements GroupReduceFunction&amp;lt;Row, BaseMetricsSummary&amp;gt; {
    private ContinuousDistance distance;

    public CalcClusterMetricsSummary(ContinuousDistance distance) {
        this.distance = distance;
    }

    @Override
    public void reduce(Iterable&amp;lt;Row&amp;gt; rows, Collector&amp;lt;BaseMetricsSummary&amp;gt; collector) {
        collector.collect(ClusterEvaluationUtil.getClusterStatistics(rows, distance));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ClusterEvaluationUtil.getClusterStatistics如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ClusterMetricsSummary getClusterStatistics(Iterable&amp;lt;Row&amp;gt; rows, ContinuousDistance distance) {
    List&amp;lt;Vector&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    int total = 0;
    String clusterId;
    DenseVector sumVector;

    Iterator&amp;lt;Row&amp;gt; iterator = rows.iterator();
    Row row = null;
    while (iterator.hasNext() &amp;amp;&amp;amp; !EvaluationUtil.checkRowFieldNotNull(row)) {
        // 取出第一个不为空的item
        row = iterator.next();
    }
    if (EvaluationUtil.checkRowFieldNotNull(row)) {
        clusterId = row.getField(0).toString(); // 取出 clusterId
        Vector vec = VectorUtil.getVector(row.getField(1)); // 取出 Vector
        sumVector = DenseVector.zeros(vec.size()); // 初始化
    } else {
        return null;
    }

    while (null != row) { // 遍历 rows，累积到 sumVector
        if (EvaluationUtil.checkRowFieldNotNull(row)) {
            Vector vec = VectorUtil.getVector(row.getField(1));
            list.add(vec);
            if (distance instanceof EuclideanDistance) {
                sumVector.plusEqual(vec);
            } else {
                vec.scaleEqual(1.0 / vec.normL2());
                sumVector.plusEqual(vec);
            }
            total++;
        }
        row = iterator.hasNext() ? iterator.next() : null;
    }

    DenseVector meanVector = sumVector.scale(1.0 / total); // 取mean

// runtime变量，这里示例是第二组的向量  
list = {ArrayList@10654}  size = 3
 0 = {DenseVector@10661} &quot;9.0 9.0 9.0&quot;
 1 = {DenseVector@10662} &quot;9.1 9.1 9.1&quot;
 2 = {DenseVector@10663} &quot;9.2 9.2 9.2&quot;  
  
    double distanceSum = 0.0;
    double distanceSquareSum = 0.0;
    double vectorNormL2Sum = 0.0;
    for (Vector vec : list) { // 循环，计算出几个统计信息
        double d = distance.calc(meanVector, vec);
        distanceSum += d;
        distanceSquareSum += d * d;
        vectorNormL2Sum += vec.normL2Square();
    }
  
// runtime变量
sumVector = {DenseVector@10656} &quot;27.3 27.3 27.3&quot;
meanVector = {DenseVector@10657} &quot;9.1 9.1 9.1&quot;
distanceSum = 0.34641016151377424
distanceSquareSum = 0.059999999999999575
vectorNormL2Sum = 745.3499999999999  
  
    return new ClusterMetricsSummary(clusterId, total, distanceSum / total, distanceSquareSum, vectorNormL2Sum,
        meanVector, distance);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;62-reducebasemetrics&quot;&gt;6.2 ReduceBaseMetrics&lt;/h3&gt;
&lt;p&gt;这里是进行归并，形成一个BaseMetricsSummary。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Merge the BaseMetrics calculated locally.
 */
public static class ReduceBaseMetrics implements ReduceFunction&amp;lt;BaseMetricsSummary&amp;gt; {
    @Override
    public BaseMetricsSummary reduce(BaseMetricsSummary t1, BaseMetricsSummary t2) throws Exception {
        return null == t1 ? t2 : t1.merge(t2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;63-calsilhouettecoefficient&quot;&gt;6.3 calSilhouetteCoefficient&lt;/h3&gt;
&lt;p&gt;第三步是调用 calSilhouetteCoefficient 来计算 SilhouetteCoefficient。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;vectorMetrics = metricsSummary.map(new ClusterEvaluationUtil.SaveDataAsParams()).withBroadcastSet(
        silhouetteCoefficient, SILHOUETTE_COEFFICIENT);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就是和公式一样的处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static Tuple1&amp;lt;Double&amp;gt; calSilhouetteCoefficient(Row row, ClusterMetricsSummary clusterMetricsSummary) {
    if (!EvaluationUtil.checkRowFieldNotNull(row)) {
        return Tuple1.of(0.);
    }
    String clusterId = row.getField(0).toString();
    Vector vec = VectorUtil.getVector(row.getField(1));
    double currentClusterDissimilarity = 0.0;
    double neighboringClusterDissimilarity = Double.MAX_VALUE;
    if (clusterMetricsSummary.distance instanceof EuclideanDistance) {
        double normSquare = vec.normL2Square();
        for (int i = 0; i &amp;lt; clusterMetricsSummary.k; i++) {
            double dissimilarity = clusterMetricsSummary.clusterCnt.get(i) * normSquare
                - 2 * clusterMetricsSummary.clusterCnt.get(i) * MatVecOp.dot(vec, clusterMetricsSummary.meanVector.get(i)) + clusterMetricsSummary.vectorNormL2Sum.get(i);
            if (clusterId.equals(clusterMetricsSummary.clusterId.get(i))) {
                if (clusterMetricsSummary.clusterCnt.get(i) &amp;gt; 1) {
                    currentClusterDissimilarity = dissimilarity / (clusterMetricsSummary.clusterCnt.get(i) - 1);
                }
            } else {
                neighboringClusterDissimilarity = Math.min(neighboringClusterDissimilarity,
                    dissimilarity / clusterMetricsSummary.clusterCnt.get(i));
            }
        }
    } else {
        for (int i = 0; i &amp;lt; clusterMetricsSummary.k; i++) {
            double dissimilarity = 1.0 - MatVecOp.dot(vec, clusterMetricsSummary.meanVector.get(i));
            if (clusterId.equals(clusterMetricsSummary.clusterId.get(i))) {
                if (clusterMetricsSummary.clusterCnt.get(i) &amp;gt; 1) {
                    currentClusterDissimilarity = dissimilarity * clusterMetricsSummary.clusterCnt.get(i) / (clusterMetricsSummary.clusterCnt.get(i) - 1);
                }
            } else {
                neighboringClusterDissimilarity = Math.min(neighboringClusterDissimilarity,
                    dissimilarity);
            }
        }
    }
    return Tuple1.of(currentClusterDissimilarity &amp;lt; neighboringClusterDissimilarity ?
        1 - (currentClusterDissimilarity / neighboringClusterDissimilarity) :
        (neighboringClusterDissimilarity / currentClusterDissimilarity) - 1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;64-savedataasparams&quot;&gt;6.4 SaveDataAsParams&lt;/h3&gt;
&lt;p&gt;第四步是把数据存储为Params&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static class SaveDataAsParams extends RichMapFunction&amp;lt;BaseMetricsSummary, Params&amp;gt; {
    @Override
    public Params map(BaseMetricsSummary t) throws Exception {
        Params params = t.toMetrics().getParams();
        List&amp;lt;Tuple1&amp;lt;Double&amp;gt;&amp;gt; silhouetteCoefficient = getRuntimeContext().getBroadcastVariable(
            EvalClusterBatchOp.SILHOUETTE_COEFFICIENT);
        params.set(ClusterMetrics.SILHOUETTE_COEFFICIENT,
            silhouetteCoefficient.get(0).f0 / params.get(ClusterMetrics.COUNT));
        return params;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x06-合并输出&quot;&gt;0x06 合并输出&lt;/h2&gt;
&lt;p&gt;这一步做了一个 union，把 labelMetrics 和 vectorMetrics 联合起来，再归并输出到最后的表中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;DataSet&amp;lt;Row&amp;gt; out = labelMetrics
    .union(vectorMetrics)
    .reduceGroup(new GroupReduceFunction&amp;lt;Params, Row&amp;gt;() {
        @Override
        public void reduce(Iterable&amp;lt;Params&amp;gt; values, Collector&amp;lt;Row&amp;gt; out) {
            Params params = new Params();
            for (Params p : values) {
                params.merge(p);
            }
            out.collect(Row.of(params.toJson()));
        }
    });

this.setOutputTable(DataSetConversionUtil.toTable(getMLEnvironmentId(),
    out, new TableSchema(new String[] {EVAL_RESULT}, new TypeInformation[] {Types.STRING})
));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/czhwust/p/mlclusterpre.html&quot;&gt;聚类算法及其评估指标&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53840697&quot;&gt;[ML] 聚类评价指标&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/bydream/p/6964883.html&quot;&gt;聚类结果的评价指标&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hxsyl/p/5091179.html&quot;&gt;聚类评价指标&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19635522&quot;&gt;如何评价聚类结果的好坏？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wangxiaopeng0329/article/details/53542606&quot;&gt;聚类评估算法-轮廓系数（Silhouette Coefficient ）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chixujohnny/article/details/51852633&quot;&gt;聚类效果好坏的评价指标&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qtlyx/article/details/52678895&quot;&gt;ARI聚类效果评价指标&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a841454735/article/details/80237257&quot;&gt;聚类算法评价指标——Davies-Bouldin指数(Dbi)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_65c8baf901016flh.html&quot;&gt;【每周一博】浅说Davies-Bouldin指数（DBI）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_33363493/article/details/52496011&quot;&gt;聚类算法评价指标&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/alice-wayne/p/7049363.html&quot;&gt;聚类模型性能评价指标&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 26 Sep 2020 00:41:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文和上文将带领大家来分析Alink中 聚类评估 的实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13733182.html</dc:identifier>
</item>
<item>
<title>golang开发:select多路选择 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/13733679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/13733679.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;select 是 Golang 中的一个控制结构，语法上类似于switch 语句，只不过select是用于 goroutine 间通信的 ，每个 case 必须是一个通信操作，要么是发送要么是接收，select 会随机执行一个可运行的 case。如果没有 case 可运行，goroutine 将阻塞，直到有 case 可运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;select-多路选择&quot;&gt;select 多路选择&lt;/h3&gt;
&lt;p&gt;select写法上跟switch case的写法基本一致，只不过golang的select是通信控制语句。select的执行必须有通信的发送或者接受，如果没有就一直阻塞。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     ch := make(chan bool, 0)
        ch1 := make(chan bool, 0)
        select {
                case ret := &amp;lt;-ch:
                        fmt.Println(ret)
                case ret := &amp;lt;-ch1:
                        fmt.Println(ret)
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果ch和ch1都没有通信数据发送，select就一直阻塞，直到ch或者ch1有数据发送，select就执行相应的case来接受数据。&lt;/p&gt;
&lt;h3 id=&quot;select-实现超时控制&quot;&gt;select 实现超时控制&lt;/h3&gt;
&lt;p&gt;我们可以利用select机制实现一种简单的超时控制。&lt;br/&gt;先看下程序完整执行的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;func service(ch chan bool) {
        time.Sleep(time.Second*3)
        ch&amp;lt;-true
}
func main() {
        ch := make(chan bool, 0)
        go service(ch)
        select {
                case ret := &amp;lt;-ch:
                        fmt.Println(ret)
                case &amp;lt;-time.After(time.Second*5):
                        fmt.Println(&quot;timeout&quot;)
        }
}

___go_build_main_go #gosetup
true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到使用time.After超时定义了5S，service程序执行3S，所以肯定没有超时，跟预想的一致。&lt;br/&gt;我们再看看超时的执行，我们将service程序执行时间该为6S。超时控制继续是5S，再看下执行效果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;func service(ch chan bool) {
        time.Sleep(time.Second*6)
        ch&amp;lt;-true
}
func main() {
        ch := make(chan bool, 0)
        go service(ch)
        select {
                case ret := &amp;lt;-ch:
                        fmt.Println(ret)
                case &amp;lt;-time.After(time.Second*5):
                        fmt.Println(&quot;timeout&quot;)
        }
}

___go_build_main_go #gosetup
timeout
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行到了超时的case，跟预想的其实是一致的。&lt;/p&gt;
&lt;h3 id=&quot;select-判断channel是否关闭&quot;&gt;select 判断channel是否关闭&lt;/h3&gt;
&lt;p&gt;先看下接受数据的语法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val,ok &amp;lt;- ch
ok true 正常接收数据
ok false 通道关闭
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到接受数据其实有两个参数，第二个bool值会反应channel是否关闭，是否可以正常接受数据。&lt;/p&gt;
&lt;p&gt;看下测试代码&lt;br/&gt;我们写了一个数据发送者，两个数据接收者，当发送者关闭channel的时候，两个接收者的 goroutine 可以通过以上的语法判断channel是否关闭，决定自己的 goroutine 是否结束。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;func sender(ch chan int, wg *sync.WaitGroup) {
        for i:=0;i&amp;lt;10;i++ {
                ch&amp;lt;-i
        }
        close(ch)
        wg.Done()
}
func receiver(ch chan int, wg *sync.WaitGroup) {
        for {
                if val,ok := &amp;lt;-ch;ok {
                        fmt.Println(fmt.Sprintf(&quot;%d,%s&quot;,val, &quot;revevier&quot;))
                } else {
                        fmt.Println(&quot;quit recevier&quot;)
                        break;
                }
        }
        wg.Done()
}
func receiver2(ch chan int, wg *sync.WaitGroup) {
        for {
                if val,ok := &amp;lt;-ch;ok {
                        fmt.Println(fmt.Sprintf(&quot;%d,%s&quot;,val, &quot;revevier2&quot;))
                } else {
                        fmt.Println(&quot;quit recevier2&quot;)
                        break;
                }
        }
        wg.Done()
}
func main() {
        ch := make(chan int, 0)
        wg := &amp;amp;sync.WaitGroup{}
        wg.Add(1)
        go sender(ch, wg)
        wg.Add(1)
        go receiver(ch, wg)
        wg.Add(1)
        go receiver2(ch, wg)
        wg.Wait()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;0,revevier2
2,revevier2
3,revevier2
4,revevier2
5,revevier2
6,revevier2
7,revevier2
1,revevier
9,revevier
quit recevier
8,revevier2
quit recevier2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到一个数据发送者，两个数据接收者，当channel关闭的时候，两个数据接收者都收到了channel关闭的通知。&lt;br/&gt;需要注意的是，给一个已经关闭的channel发送数据，程序会panic，从一个已经关闭的channel接收数据，会接收到没有参考意义的channel类型的0值数据，Int是0，string是空...&lt;/p&gt;
&lt;h3 id=&quot;select-退出计时器等程序&quot;&gt;select 退出计时器等程序&lt;/h3&gt;
&lt;p&gt;开发中经常会经常会使用轮训计时器，但是当程序退出时，轮训计时器无法关闭的问题。其实select是可以解决这个问题的。&lt;br/&gt;如果我们有一个轮训任务，需要一个timer，每隔3S执行逻辑，过完10S之后关闭这个timer。&lt;/p&gt;
&lt;p&gt;看下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;func TimeTick(wg *sync.WaitGroup,q chan bool) {
        defer wg.Done()
        t := time.NewTicker(time.Second*3)
        defer t.Stop()
        for {
                select {
                case &amp;lt;-q:
                        fmt.Println(&quot;quit&quot;)
                        return
                case &amp;lt;-t.C:
                        fmt.Println(&quot;seconds timer&quot;)
                }
        }
}
func main() {
        q := make(chan bool)
        wg := new(sync.WaitGroup)
        wg.Add(1)
        go TimeTick(wg,q)
        time.Sleep(time.Second*10)
        close(q)
        wg.Wait()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;seconds timer
seconds timer
seconds timer
quit
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很优雅的通过关闭channel退出了轮训计时器 goroutine，&lt;/p&gt;
</description>
<pubDate>Sat, 26 Sep 2020 00:18:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>select 是 Golang 中的一个控制结构，语法上类似于switch 语句，只不过select是用于 goroutine 间通信的 ，每个 case 必须是一个通信操作，要么是发送要么是接收，s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feixiangmanon/p/13733679.html</dc:identifier>
</item>
<item>
<title>没有公网IP？使用Ngrok将局域网服务映射到公网 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13733675.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13733675.html</guid>
<description>[unable to retrieve full-text content]这篇文章将为大家介绍ngrok，如何安装，配置以及在什么场景下需要使用ngrok。在没有使用过Ngrok之前，您可能会遇到过这样一些情况 你需要向客户演示你们正在研发的项目，所以你要求开发人员帮助你，在你的资源有限的笔记本电脑上部署一套用于给客户演示的环境。当下一次另一个同事需要去为客户演示的时候，</description>
<pubDate>Sat, 26 Sep 2020 00:14:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>select 是 Golang 中的一个控制结构，语法上类似于switch 语句，只不过select是用于 goroutine 间通信的 ，每个 case 必须是一个通信操作，要么是发送要么是接收，s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feixiangmanon/p/13733679.html</dc:identifier>
</item>
<item>
<title>Combine 框架，从0到1  —— 5.Combine 中的 Subjects - Ficow</title>
<link>http://www.cnblogs.com/ficow/p/13733661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ficow/p/13733661.html</guid>
<description>
&lt;p&gt;本文首发于 &lt;a href=&quot;https://ficowshen.com&quot;&gt;Ficow Shen's Blog&lt;/a&gt;，原文地址： &lt;a href=&quot;https://blog.ficowshen.com/page/post/22&quot;&gt;Combine 框架，从0到1 —— 5.Combine 中的 Subjects&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;内容概览&quot;&gt;内容概览&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;PassthroughSubject&lt;/li&gt;
&lt;li&gt;CurrentValueSubject&lt;/li&gt;
&lt;li&gt;Subject 作为订阅者&lt;/li&gt;
&lt;li&gt;常见用法&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;正所谓，工欲善其事，必先利其器。在开始使用 &lt;code&gt;Combine&lt;/code&gt; 进行响应式编程之前，建议您先了解 &lt;code&gt;Combine&lt;/code&gt; 为您提供的各种发布者(Publishers)、操作符(Operators)、订阅者(Subscribers)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Subject&lt;/code&gt; 是一类比较特殊的发布者，因为它同时也是订阅者。&lt;code&gt;Combine&lt;/code&gt; 提供了两类 &lt;code&gt;Subject&lt;/code&gt; ：&lt;code&gt;PassthroughSubject&lt;/code&gt; 和 &lt;code&gt;CurrentValueSubject&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果您想了解更多 Publishers 的用法和注意事项，可以阅读：&lt;a href=&quot;https://blog.ficowshen.com/page/post/21&quot;&gt;Combine 框架，从0到1 —— 5.Combine 提供的发布者(Publishers)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;passthroughsubject&quot;&gt;PassthroughSubject&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/passthroughsubject&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PassthroughSubject&lt;/code&gt; 可以向下游订阅者广播发送元素。使用 &lt;code&gt;PassthroughSubject&lt;/code&gt; 可以很好地适应命令式编程场景。&lt;/p&gt;
&lt;p&gt;如果没有订阅者，或者需求为0，&lt;code&gt;PassthroughSubject&lt;/code&gt; 就会丢弃元素。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;final class SubjectsDemo {
    
    private var cancellable: AnyCancellable?
    private let passThroughtSubject = PassthroughSubject&amp;lt;Int, Never&amp;gt;()
    
    func passThroughtSubjectDemo() {
        cancellable = passThroughtSubject
            .sink {
                print(#function, $0)
            }
        passThroughtSubject.send(1)
        passThroughtSubject.send(2)
        passThroughtSubject.send(3)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;passThroughtSubjectDemo() 1&lt;br/&gt;passThroughtSubjectDemo() 2&lt;br/&gt;passThroughtSubjectDemo() 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;currentvaluesubject&quot;&gt;CurrentValueSubject&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/currentvaluesubject&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CurrentValueSubject&lt;/code&gt; 包装一个值，当这个值发生改变时，它会发布一个新的元素给下游订阅者。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CurrentValueSubject&lt;/code&gt; 需要在初始化时提供一个默认值，您可以通过 &lt;code&gt;value&lt;/code&gt; 属性访问这个值。在调用 &lt;code&gt;send(_:)&lt;/code&gt; 方法发送元素后，这个缓存值也会被更新。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;final class SubjectsDemo {
    
    private var cancellable: AnyCancellable?
    private let currentValueSubject = CurrentValueSubject&amp;lt;Int, Never&amp;gt;(1)
    
    func currentValueSubjectDemo() {
        cancellable = currentValueSubject
            .sink { [unowned self] in
                print(#function, $0)
                print(&quot;Value of currentValueSubject:&quot;, self.currentValueSubject.value)
            }
        currentValueSubject.send(2)
        currentValueSubject.send(3)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;currentValueSubjectDemo() 1&lt;br/&gt;Value of currentValueSubject: 1&lt;br/&gt;currentValueSubjectDemo() 2&lt;br/&gt;Value of currentValueSubject: 2&lt;br/&gt;currentValueSubjectDemo() 3&lt;br/&gt;Value of currentValueSubject: 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;subject-作为订阅者&quot;&gt;Subject 作为订阅者&lt;/h2&gt;

&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;final class SubjectsDemo {
    
    private var cancellable1: AnyCancellable?
    private var cancellable2: AnyCancellable?
    
    private let optionalCurrentValueSubject = CurrentValueSubject&amp;lt;Int?, Never&amp;gt;(nil)
    
    private func subjectSubscriber() {
        cancellable1 = optionalCurrentValueSubject
            .sink {
                print(#function, $0)
            }
        cancellable2 = [1, 2, 3].publisher
            .subscribe(optionalCurrentValueSubject)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;optionalCurrentValueSubject&lt;/code&gt; 可以作为一个订阅者去订阅序列发布者 &lt;code&gt;[1, 2, 3].publisher&lt;/code&gt; 发送的元素。&lt;/p&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;subjectSubscriber() nil&lt;br/&gt;subjectSubscriber() Optional(1)&lt;br/&gt;subjectSubscriber() Optional(2)&lt;br/&gt;subjectSubscriber() Optional(3)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;常见用法&quot;&gt;常见用法&lt;/h2&gt;

&lt;p&gt;在使用 &lt;code&gt;Subject&lt;/code&gt; 时，我们往往不会将其暴露给调用方。这时候，可以使用 &lt;code&gt;eraseToAnyPublisher&lt;/code&gt; 操作符来隐藏内部的 &lt;code&gt;Subject&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;    struct Model {
        let id: UUID
        let name: String
    }
    
    final class ViewModel {
        private let modelSubject = CurrentValueSubject&amp;lt;Model?, Never&amp;gt;(nil)
        var modelPublisher: AnyPublisher&amp;lt;Model?, Never&amp;gt; {
            return modelSubject.eraseToAnyPublisher()
        }
        
        func updateName(_ name: String) {
            modelSubject.send(.init(id: UUID(), name: name))
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;外部调用者无法直接操控 &lt;code&gt;ViewModel&lt;/code&gt; 内部的 &lt;code&gt;Subject&lt;/code&gt;，这样可以让 &lt;code&gt;ViewModel&lt;/code&gt; 更好地面对将来可能的改动。&lt;br/&gt;外部调用者只需要知道 &lt;code&gt;modelPublisher&lt;/code&gt; 是 &lt;code&gt;AnyPublisher&amp;lt;Model?, Never&amp;gt;&lt;/code&gt; 类型的发布者即可，无论内部采用了 &lt;code&gt;CurrentValueSubject&lt;/code&gt; 还是 &lt;code&gt;PassthroughSubject&lt;/code&gt; 甚至是其他的发布者。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;相比于其他的发布者来说， &lt;code&gt;Subject&lt;/code&gt; 是比较容易理解的，而且也是最常用到的。&lt;br/&gt;只可惜，对比 &lt;code&gt;Rx&lt;/code&gt; 提供的 Subject，Combine 中的 Subject 无法设置缓冲的大小。也许某天苹果会对此做出调整吧~&lt;/p&gt;

</description>
<pubDate>Sat, 26 Sep 2020 00:07:00 +0000</pubDate>
<dc:creator>Ficow</dc:creator>
<og:description>本文首发于 Ficow Shen&amp;amp;#39;s Blog，原文地址： Combine 框架，从0到1 —— 5.Combine 中的 Subjects。 内容概览 前言 PassthroughS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ficow/p/13733661.html</dc:identifier>
</item>
<item>
<title>JVM性能调优（2） —— 垃圾回收器和回收策略 - bojiangzhou</title>
<link>http://www.cnblogs.com/chiangchou/p/jvm-2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiangchou/p/jvm-2.html</guid>
<description>&lt;p&gt;介绍了JVM垃圾回收机制、垃圾回收算法、垃圾回收器，如何设置内存和查看GC日志，通过GC日志结合代码一步步分析内存分配和垃圾回收策略。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;882.00825820463&quot;&gt;
&lt;h2&gt;一、垃圾回收机制&lt;/h2&gt;
&lt;h3&gt;1、为什么需要垃圾回收&lt;/h3&gt;
&lt;p&gt;Java 程序在虚拟机中运行，是会占用内存资源的，比如创建的对象、加载的类型数据等，而且内存资源都是有限的。当创建的对象不再被引用时，就需要被回收掉，释放内存资源，这个时候就会用到JVM的垃圾回收机制。&lt;/p&gt;
&lt;p&gt;JVM 启动时就提供了一个垃圾回收线程来跟踪每一块分配出去的内存空间，并定期清理需要被回收的对象。Java 程序无法强制执行垃圾回收，我们可以通过调用 System.gc 方法来&quot;建议&quot;执行垃圾回收，但是否可执行，什么时候执行，是不可预期的。&lt;/p&gt;
&lt;h3&gt;2、垃圾回收发生在哪里&lt;/h3&gt;
&lt;p&gt;JVM内存模型中，程序计数器、虚拟机栈、本地方法栈这 3 个区域是线程私有的，随着线程的创建而创建，销毁而销毁。栈中的栈帧随着方法的调用而入栈，随着方法的退出而出栈，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的。因此这三个区域的内存分配和回收都具有确定性。&lt;/p&gt;
&lt;p&gt;而堆和方法区这两个区域则有着显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾回收的重点就是关注堆和方法区中的内存，堆中的回收主要是垃圾对象的回收，方法区的回收主要是废弃常量和无用的类的回收。&lt;/p&gt;
&lt;h3 id=&quot;1051-1585031201936&quot;&gt;3、对象在什么时候可以被回收 &lt;/h3&gt;
&lt;p&gt;一般一个对象不再被引用，就代表该对象可以被回收。主流的虚拟机一般都是使用 可达性分析算法 来判断该对象是否可以被回收，有些内存管理系统也是用 引用计数法 来判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）引用计数算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种算法是通过在对象中添加一个引用计数器来判断该对象是否被引用了。每当对象被引用，计数器就加 1；每当引用失效，计数器就减 1。当对象的引用计数器的值为 0 时，就说明该对象不再被引用，可以被回收了。&lt;/p&gt;
&lt;p&gt;引用计数算法实现简单，判断效率也很高，但它无法解决对象之间相互循环引用的问题。两个对象若互相引用，但没有任何其它对象引用他们，而它们的引用计数器都不为零，就无法被回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）可达性分析算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GC  Roots  是该算法的基础，GC Roots 是所有对象的根对象。在垃圾回收时，会从这些 GC Roots 根对象开始向下搜索，在搜索的这个引用链上的对象，就是可达的对象；而一个对象到 GC Roots 没有任何引用链相连时，就证明此对象是不可达的，可以被回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Java中，可作为 GC Roots 对象的一般包括如下几种：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java虚拟机栈中的引用的对象，如方法参数、局部变量、临时变量等 &lt;/li&gt;
&lt;li&gt;方法区中的类静态属性引用的对象 &lt;/li&gt;
&lt;li&gt;方法区中的常量引用的对象，如字符串常量池的引用 &lt;/li&gt;
&lt;li&gt;本地方法栈中JNI的引用的对象&lt;/li&gt;
&lt;li&gt;Java虚拟机内部的引用，如基本数据类型的 Class 对象，系统类加载器等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如下面的代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200916010325204-1952299661.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，类静态变量 MAPPER，loadAccount 方法的局部变量 account1、account2、accountList 都可以作为 GC Roots（ArrayList 内部是用 Object[] elementData 数组来存放元素的）。&lt;/p&gt;
&lt;p&gt;在调用 loadAccount 方法时，堆中的对象都是可达的，因为有 GC Roots 直接或间接引用到这些对象，此时若发生垃圾回收，这些对象是不可被回收的。loadAccount 执行完后，弹出栈帧，方法内的局部变量都被回收了，虽然堆中 ArrayList 对象还指向 elementData 数组，而 elementData 指向 Account 对象，但没有任何 GC Roots 的引用链能达到这些对象，因此这些对象将变为垃圾对象，被垃圾回收器回收掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200916005633852-1871770429.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4、回收方法区&lt;/h3&gt;
&lt;p&gt;方法区垃圾回收的“性价比”通常是比较低的，方法区的垃圾回收主要回收两部分内容：废弃的常量和不再使用的类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）废弃的常量：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如常量池中废弃的字面量，字段、方法的符号引用等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）不再使用的类型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;判定一个类型是否属于“不再被使用的类”需要同时满足三个条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该类所有的实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例&lt;/li&gt;
&lt;li&gt;加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。&lt;/li&gt;
&lt;li&gt;该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。&lt;/p&gt;
&lt;h3&gt;5、Java中的引用类型&lt;/h3&gt;
&lt;p&gt;Java 中有四种不同的引用类型：强引用、软引用、弱引用、虚引用，这4种引用强度依次逐渐减弱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）强引用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强引用是最普遍的引用方式，如在方法中定义：Object obj = new Object()。只要引用还在，垃圾回收器就不会回收被引用的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）软引用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软引用是用来描述一些有用但非必须的对象，可以使用 SoftReference 类来实现软引用。对于软引用关联着的对象，在系统将要发生内存溢出异常之前（一般发生老年代GC时），会把这些对象列进回收范围之中。如果回收之后内存还是不足，才会报内存溢出的异常。&lt;/p&gt;
&lt;p&gt;这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现内存缓存，当内存快满时，就回收掉这些软引用的对象，然后需要的时候再重新查询。比如下面的代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200916224433577-938667348.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）弱引用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;弱引用是用来描述非必须的对象，可以使用 WeakReference 类来实现弱引用。它只能生存到下一次垃圾回收发生之前（一般发生年轻代GC时），当垃圾回收机制开始时，无论是否会内存溢出，都将回收掉被弱引用关联的对象。&lt;/p&gt;
&lt;p&gt;需注意的是，我们使用 SoftReference 来创建软引用对象，使用 WeakReference 来创建弱引用对象，垃圾回收时，是回收它们关联的对象，而不是 Reference 本身。同时，如果 Reference 关联的对象被其它 GC Roots 引用着，也是不能被回收的。如下面的代码，在垃圾回收时，只有 T002 这个 Account 对象能被回收，回收后 reference2.get() 返回值为 null，account、reference1、reference2 所指向的对象都不能被回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200916223404930-1044715441.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）虚引用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最没有存在感的一种引用关系，可以使用 PhantomReference 类来实现虚引用。存在不存在几乎没影响，也不能通过虚引用来获取一个对象实例，存在的唯一目的是被垃圾回收器回收后可以收到一条系统通知。&lt;/p&gt;
&lt;h2&gt;二、垃圾回收算法&lt;/h2&gt;
&lt;h3&gt;1、分代收集理论&lt;/h3&gt;
&lt;p&gt;大部分虚拟机的垃圾回收器都是遵循“分代收集”的理论进行设计的，它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般至少将堆划分为新生代和老年代两个区域，然后可以根据不同代的特点采取最适合的回收算法。在新生代中，每次垃圾回收时都有大量对象死去，因为程序创建的绝大部分对象的生命周期都很短，朝生夕灭。而新生代每次回收后存活的少量对象，将会逐步晋升到老年代中存放。老年代每次垃圾收集时只有少量对象需要被回收，因为老年代的大部分对象一般都是全局变量引用的，生命周期一般都比较长。&lt;/p&gt;
&lt;p&gt;在Java堆划分出不同的区域之后，垃圾回收器就可以每次只回收其中某一个或者某些部分的区域，因而也有了“Young GC”、“Old GC”、“Full GC”这样的回收类型的划分。也能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾回收算法，因而发展出了“标记-复制算法”、“标记-清除算法”、“标记-整理算法”等针对性的垃圾回收算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GC类型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。&lt;/li&gt;
&lt;li&gt;老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。&lt;/li&gt;
&lt;li&gt;混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。&lt;/li&gt;
&lt;li&gt;整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集，包括新生代、老年代、方法区的回收，一般 Full GC 等价于 Old GC。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;经典分代模型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200923164538763-1215733806.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、标记-清除算法（Mark-Sweep）&lt;/h3&gt;
&lt;p&gt;标记-清除算法 分为“标记”和“清除”两个阶段，首先从 GC Roots 进行扫描，对存活的对象进行标记，标记完后，再统一回收所有未被标记的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标记-清除算法不需要进行对象的移动，只需回收未标记的垃圾对象，在存活对象比较多的情况下极为高效。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标记-清除算法执行效率不稳定，如果堆中对象很多，而且大部分都是要回收的对象，就必须要进行大量的标记和清除动作，导致标记、清除两个过程的效率随着对象数量增长而降低。&lt;/li&gt;
&lt;li&gt;标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200918101845971-1852712158.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、标记-复制算法（Copying）&lt;/h3&gt;
&lt;p&gt;标记-复制算法简称为复制算法，复制算法主要是为了解决标记-清除算法在存在大量可回收对象时执行效率低下和内存碎片的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）半区复制算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存满了，就从 GC Roots 开始扫描，将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每次都是针对整个半区进行内存回收，清理速度快，没有内存碎片产生&lt;/li&gt;
&lt;li&gt;每次回收后，对象有序排列到另一个空闲区域，分配内存时也就不用考虑有空间碎片的复杂情况&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销&lt;/li&gt;
&lt;li&gt;复制回收算法将可用内存缩小为了原来的一半，内存使用率低&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200923164046380-153604737.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）复制算法的优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数对象都是朝生夕灭，新生代中98%的对象几乎都熬不过第一轮回收，因此并不需要按照 1∶1 的比例来划分新生代的内存空间。&lt;/p&gt;
&lt;p&gt;因此新生代复制算法一般是把新生代分为一块较大的 Eden 区和两块较小的 Survivor（survivor0、survivor1） 区，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾回收时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间，如此往复。当对象经过垃圾回收的次数超过一定阀值还未被回收掉时，就会进入老年代，有些大对象也可以直接进入老年代。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200923163932532-1767700431.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相比半区复制算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8 &lt;strong&gt;:&lt;/strong&gt; 1 &lt;strong&gt;:&lt;/strong&gt; 1，新生代与老年代的比例大概是 1 &lt;strong&gt;:&lt;/strong&gt; 2。内存空间利用率高，只会有 10% 的空闲空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;有可能一次 Young GC 后存活的对象超过一个 survivor 区的大小，这时候会依赖其它内存区域进行分配担保，让这部分存活下来的对象直接进入另一个区域，一般就是老年代。&lt;/p&gt;
&lt;h3&gt;4、标记-整理算法（Mark-Compact）&lt;/h3&gt;
&lt;p&gt;复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。&lt;/p&gt;
&lt;p&gt;标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，它不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200918143652497-1813249068.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;没有内存碎片产生，适合老年代垃圾回收&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;会有对象的移动，老年代存活对象多，移动对象还需要更新指针，因此成本会更高&lt;/p&gt;
&lt;h3&gt;5、总结对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200924141304035-1021200659.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、垃圾回收器&lt;/h2&gt;
&lt;p&gt;垃圾回收算法是内存回收的方法论，垃圾回收器是内存回收的实践者。不同的垃圾回收器有不同的特性，并没有一个万能或最好的垃圾回收器，只能根据不同的业务场景选择最合适的垃圾回收器，所以这节就来了解下各个垃圾回收器的特性。&lt;/p&gt;
&lt;h3&gt;1、Stop The World（STW）&lt;/h3&gt;
&lt;p&gt;先看看jvm的 “Stop The World” 问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）STW：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可达性分析算法从 GC Roots 集合找引用链时，需要枚举根节点，然后从根节点标记存活的对象，根节点枚举以及整理内存碎片时，都会发生 Stop The World，此时 jvm 会直接暂停应用程序的所有用户线程，然后进行垃圾回收。因为垃圾回收时如果还在继续创建对象或更新对象引用，就会导致这些对象可能无法跟踪和回收、跟节点不断变化等比较复杂的问题，因此垃圾回收过程必须暂停所有用户线程，进入 STW 状态。垃圾回收完成后，jvm 会恢复应用程序的所有用户线程。&lt;/p&gt;
&lt;p&gt;所有垃圾回收器都无法避免 STW，只能尽量缩短用户线程的停顿时间。系统停顿期间，无法处理任何请求，所有用户请求都会出现短暂的卡顿。如果因为内存分配不合理或垃圾回收器使用不合理，导致频繁的垃圾回收，而且每次回收系统停顿时间过长，这会让用户体验极差。jvm 最重要的一个优化就是通过合理的内存分配，使用合适的垃圾回收器，使得垃圾回收频率最小、停顿时间最短，避免影响系统正常运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）安全点（Safe Point）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。安全点可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停。&lt;/p&gt;
&lt;p&gt;安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。&lt;/p&gt;
&lt;p&gt;jvm 采用主动式中断的方式，在垃圾回收发生时让所有线程都跑到最近的安全点。主动式中断的思想是当垃圾回收需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）安全区域（Safe Region）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾回收过程的安全点。但是，程序“不执行”的时候，线程就无法响应虚拟机的中断请求，如用户线程处于Sleep状态或者Blocked状态，这个时候就没法再走到安全的地方去中断挂起自己。这就需要安全区域来解决了。&lt;/p&gt;
&lt;p&gt;安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾回收都是安全的。当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾回收时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了需要暂停用户线程的阶段，如果完成了，那线程就继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。&lt;/p&gt;
&lt;h3&gt;2、Serial 垃圾回收器&lt;/h3&gt;
&lt;p&gt;Serial 垃圾回收器是一个单线程回收器，它进行垃圾回收时，必须暂停其他所有用户线程，直到它回收结束。Serial 主要用于新生代垃圾回收，采用复制算法实现。&lt;/p&gt;
&lt;p&gt;服务端程序几乎不会使用 Serial 回收器，服务端程序一般会分配较大的内存，可能几个G，如果使用 Serial 回收器，由于是单线程，标记、清理阶段就会花费很长的时间，就会导致系统较长时间的停顿。&lt;/p&gt;
&lt;p&gt;Serial 一般用在客户端程序或占用内存较小的微服务，因为客户端程序一般分配的内存都比较小，可能几十兆或一两百兆，回收时的停顿时间是完全可以接受的。而且 Serial 是所有回收器里额外消耗内存最小的，也没有线程切换的开销，非常简单高效。&lt;/p&gt;
&lt;h3&gt;3、Serial Old 垃圾回收器&lt;/h3&gt;
&lt;p&gt;Serial Old 是 Serial 的老年代版本，它同样是一个单线程回收器，主要用于客户端程序。Serial Old 用于老年代垃圾回收，采用标记-整理算法实现。&lt;/p&gt;
&lt;p&gt;Serial Old 也可以用在服务端程序，主要有两种用途：一种是与 Parallel Scavenge 回收器搭配使用，另外一种就是作为 CMS 回收器发生失败时的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。&lt;/p&gt;
&lt;h3&gt;4、ParNew 垃圾回收器&lt;/h3&gt;
&lt;p&gt;ParNew 回收器实质上是 Serial 回收器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为都与 Serial 回收完全一致，控制参数、回收算法、对象分配规则等都是一致的。除了 Serial 回收器外，目前只有 ParNew 回收器能与 CMS 回收器配合工作，ParNew 是激活CMS后的默认新生代回收器。&lt;/p&gt;
&lt;p&gt;ParNew 默认开启的回收线程数与处理器核心数量相同，在处理器核心非常多的环境中，可以使用 -XX&lt;strong&gt;:&lt;/strong&gt; ParallelGCThreads 参数来限制垃圾回收的线程数。&lt;/p&gt;
&lt;h3&gt;5、Parallel Scavenge 垃圾回收器&lt;/h3&gt;
&lt;p&gt;Parallel Scavenge是新生代回收器，采用复制算法实现，也是能够并行回收的多线程回收器。Parallel Scavenge 主要关注可控制的吞吐量，其它回收器的关注点是尽可能地缩短垃圾回收时的停顿时间。吞吐量就是处理器用于运行程序代码的时间与处理器总消耗时间的比值，总消耗时间等于运行程序代码的时间加上垃圾回收的时间。&lt;/p&gt;
&lt;p&gt;Parallel Scavenge 提供了两个参数用于精确控制吞吐量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-XX&lt;strong&gt;:&lt;/strong&gt; MaxGCPauseMillis：控制最大垃圾回收停顿时间，参数值是一个大于0的毫秒数，回收器将尽力保证垃圾回收花费的时间不超过这个值。&lt;/li&gt;
&lt;li&gt;-XX&lt;strong&gt;:&lt;/strong&gt; GCTimeRatio：直接设置吞吐量大小，参数值是一个大于0小于100的整数，就是垃圾回收时间占总时间的比率。默认值为 99，即允许最大1%（即1/(1+99)）的垃圾收集时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Parallel Scavenge 还有一个参数 -XX&lt;strong&gt;:&lt;/strong&gt; +UseAdaptiveSizePolicy，当设置这个参数之后，就不需要人工指定新生代的大小、Eden与Survivor区的比例等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。&lt;/p&gt;
&lt;h3&gt;6、Parallel Old 垃圾回收器&lt;/h3&gt;
&lt;p&gt;Parallel Old 是 Parallel Scavenge 的老年代版本，支持多线程并发回收，采用标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，可以优先考虑 Parallel Scavenge 加 Parallel Old 这个组合。&lt;/p&gt;
&lt;h3&gt;7、CMS 垃圾回收器&lt;/h3&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的回收器。CMS 用于老年代垃圾回收，采用标记-清除算法实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）CMS 回收过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CMS 垃圾回收整个过程分为四个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）初始标记：初始标记需要 Stop The World，初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快。&lt;/li&gt;
&lt;li&gt;2）并发标记：并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象引用链的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾回收线程一起并发运行。&lt;/li&gt;
&lt;li&gt;3）重新标记：重新标记需要 Stop The World，重新标记阶段是为了修正并发标记期间，因程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。&lt;/li&gt;
&lt;li&gt;4）并发清除：清除阶段是清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发进行的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最耗时的并发标记和并发清除阶段是和用户线程并发进行的，总体上来说，CMS 回收过程是与用户线程一起并发执行的，是一款并发低停顿的回收器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）CMS 的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① 并发回收导致CPU资源紧张：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默认启动的回收线程数是：（CPU核数 + 3）/ 4，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② 无法清理浮动垃圾：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在CMS的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ 并发失败（Concurrent Mode Failure）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于在垃圾回收阶段用户线程还在并发运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。默认情况下，当老年代使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 -XX&lt;strong&gt;:&lt;/strong&gt; CMSInitiatingOccupancyFraction 参数来设置。&lt;/p&gt;
&lt;p&gt;这里会有一个风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了。所以参数 -XX&lt;strong&gt;:&lt;/strong&gt; CMSInitiatingOccupancyFraction 设置得太高将会很容易导致大量的并发失败产生，性能反而降低；太低又可能频繁触发CMS回收，所以在生产环境中应根据实际应用情况来权衡设置。&lt;/p&gt;
&lt;p&gt;-XX: CMSInitiatingOccupancyFraction 参数值默认为-1，计算出来的阀值是92%，也可以自己指定值，同时还需要设置 -XX:+UseCMSInitiatingOccupancyOnly，让JVM使用设定的回收阈值，如果不设置，JVM仅在第一次使用设定值，后续则自动调整。&lt;/p&gt;
&lt;p&gt;而且，CMS并不是时时刻刻都在执行GC的，可以通过 -XX:CMSWaitDuration 参数设置CMS GC线程的间隔时间，默认值为2000毫秒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④ 内存碎片问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，CMS收集器提供了一个 -XX&lt;strong&gt;:&lt;/strong&gt;+UseCMSCompactAtFullCollection 开关参数（默认开启），用于在 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的，这样停顿时间就会变长。还有另外一个参数 -XX&lt;strong&gt;:&lt;/strong&gt;CMSFullGCsBeforeCompaction，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。&lt;/p&gt;
&lt;h3&gt;8、G1 垃圾回收器&lt;/h3&gt;
&lt;p&gt;G1（Garbage First）回收器采用面向局部收集的设计思路和基于Region的内存布局形式，是一款主要面向服务端应用的垃圾回收器。G1设计初衷就是替换 CMS，成为一种全功能收集器。G1 在JDK9 之后成为服务端模式下的默认垃圾回收器，取代了 Parallel Scavenge 加 Parallel Old 的默认组合，而 CMS 被声明为不推荐使用的垃圾回收器。G1从整体来看是基于 标记-整理 算法实现的回收器，但从局部（两个Region之间）上看又是基于 标记-复制 算法实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）G1 回收器的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② 可预期的回收停顿时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;G1 可以指定垃圾回收的停顿时间，通过 -XX: MaxGCPauseMillis 参数指定，默认为 200 毫秒。这个值不宜设置过低，否则会导致每次回收只占堆内存很小的一部分，回收器的回收速度逐渐赶不上对象分配速度，导致垃圾慢慢堆积，最终占满堆内存导致 Full GC 反而降低性能。&lt;/p&gt;
&lt;p&gt;G1之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次回收到的内存空间都是 Region 大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾回收。G1会去跟踪各个Region的垃圾回收价值，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的回收停顿时间，优先处理回收价值收益最大的那些Region。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1回收器在有限的时间内得到尽可能高的回收效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ 占用更高的内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于Region数量比传统回收器的分代数量明显要多得多，因此G1回收器要比其他的传统垃圾回收器有着更高的内存占用负担。G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持回收器工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）G1内存布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;G1不再是固定大小以及固定数量的分代区域划分，而是把堆划分为多个大小相等的Region，每个Region的大小默认情况下是堆内存大小除以2048，因为JVM最多可以有2048个Region，而且每个Region的大小必须是2的N次冥。每个Region的大小也可以通过参数 -XX:G1HeapRegionSize 设定，取值范围为1MB～32MB，且应为2的N次幂。&lt;/p&gt;
&lt;p&gt;G1也有新生代和老年代的概念，不过是逻辑上的区分，每一个 Region 都可以根据需要，作为新生代的Eden空间、Survivor空间，或者老年代空间。新生代默认占堆内存的5%，但最多不超过60%，这个最大值可以通过 -XX:G1MaxNewSizePercent 参数设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）大对象Region&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Region中还有一类特殊的 Humongous 区域，专门用来存储大对象，而不是直接进入老年代的Region。G1认为一个对象只要大小超过了一个Region容量的一半就判定为大对象。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的 Humongous Region 之中，G1的大多数行为都把 Humongous Region 作为老年代的一部分来看待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）G1 回收过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;G1 回收器的运作过程大致可分为四个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。&lt;/li&gt;
&lt;li&gt;并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。&lt;/li&gt;
&lt;li&gt;最终标记：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。&lt;/li&gt;
&lt;li&gt;混合回收：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4）G1混合回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;G1有一个参数，-XX:InitiatingHeapOccupancyPercent，它的默认值是45%，就是如果老年代占堆内存45%的Region的时候，此时就会触发一次年轻代+老年代的混合回收。&lt;/p&gt;
&lt;p&gt;混合回收阶段，因为我们设定了最大停顿时间，所以 G1 会从新生代、老年代、大对象里挑选一些 Region，保证指定的时间内回收尽可能多的垃圾。所以 G1 可能一次无法将所有Region回收完，它就会执行多次混合回收，先停止程序，执行一次混合回收回收掉一些Region，接着恢复系统运行，然后再次停止系统运行，再执行一次混合回收回收掉一些Region。可以通过参数 -XX:G1MixedGCCountTarget 设置一次回收的过程中，最后一个阶段最多执行几次混合回收，默认值是8次。通过这种反复回收的方式，避免系统长时间的停顿。&lt;/p&gt;
&lt;p&gt;G1还有一个参数 -XX:G1HeapWastePercent，默认值是 5%。就是在混合回收时，Region回收后，就会不断的有新的Region空出来，一旦空闲出来的Region数量超过堆内存的5%，就会立即停止混合回收，即本次混合回收就结束了。&lt;/p&gt;
&lt;p&gt;G1还有一个参数 -XX:G1MixedGCLiveThresholdPercent，默认值是85%。意思是必须要回收Region的时候，必须存活对象低于Region大小的85%时才可以进行回收，一个Region存活对象超过85%，就不必回收它了，因为要复制大部分存活对象到别的Region，这个成本是比较高的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5）回收失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① 并发回收失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在并发标记阶段，用户线程还在并发运行，程序继续运行就会持续有新对象产生，也需要预留足够的空间提供给用户线程使用。G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。如果内存回收的速度赶不上内存分配的速度，跟CMS会发生并发失败一样，G1也要被迫暂停程序，导致 Full GC 而产生长时间 Stop The World。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② 混合回收失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;混合回收阶段，年轻代和老年代都是基于复制算法进行回收，复制的过程中如果没有空闲的Region了，就会触发失败。一旦失败，就会停止程序，然后采用单线程标记、清理和内存碎片整理，然后空闲出来一批Region。这个过程是很慢的，因此要尽量调优避免混合回收失败的发生。&lt;/p&gt;
&lt;h3&gt;9、总结对比&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）垃圾回收器间的配合使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200924162814504-1336212118.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）各个垃圾回收器对比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200926042129070-1643341761.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;10、GC性能衡量指标&lt;/h3&gt;
&lt;p&gt;一个垃圾收集器在不同场景下表现出的性能也不一样，我们可以借助下面的一些指标来衡量GC的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;吞吐量是指应用程序所花费的时间和系统总运行时间的比值。系统总运行时间 = 应用程序耗时 +GC 耗时。如果系统运行了 100 分钟，GC 耗时 1 分钟，则系统吞吐量为 99%。GC 的吞吐量一般不能低于 95%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）停顿时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指垃圾收集器正在运行时，应用程序的暂停时间。对于串行回收器而言，停顿时间可能会比较长；而使用并发回收器，由于垃圾收集器和应用程序交替运行，程序的停顿时间就会变短，但其效率很可能不如独占垃圾收集器，系统的吞吐量也很可能会降低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）垃圾回收频率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常垃圾回收的频率越低越好，增大堆内存空间可以有效降低垃圾回收发生的频率，但同时也意味着堆积的回收对象越多，最终也会增加回收时的停顿时间。所以我们只要适当地增大堆内存空间，保证正常的垃圾回收频率即可。&lt;/p&gt;
&lt;h2&gt;四、内存设置和查看GC日志&lt;/h2&gt;
&lt;h3&gt;1、设置JVM内存&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）JVM内存分配有如下一些参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-Xms：堆内存大小&lt;/li&gt;
&lt;li&gt;-Xmx：堆内存最大大小&lt;/li&gt;
&lt;li&gt;-Xmn：新生代大小，扣除新生代剩下的就是老年代大小&lt;/li&gt;
&lt;li&gt;-Xss：线程栈大小&lt;/li&gt;
&lt;li&gt;-XX:NewSize：初始新生代大小&lt;/li&gt;
&lt;li&gt;-XX:MaxNewSize：最大新生代大小&lt;/li&gt;
&lt;li&gt;-XX:InitialHeapSize：初始堆大小&lt;/li&gt;
&lt;li&gt;-XX:MaxHeapSize：最大堆大小&lt;/li&gt;
&lt;li&gt;-XX:MetaspaceSize：元空间（永久代）大小，jdk1.8 之前用 -XX:PermSize 设置&lt;/li&gt;
&lt;li&gt;-XX:MaxMetaspaceSize：元空间（永久代）最大大小，jdk8 之前用 -XX:MaxPermSize 设置&lt;/li&gt;
&lt;li&gt;-XX:SurvivorRatio：新生代 Eden 区和 Survivor 区的比例，默认为 8，即 8&lt;strong&gt;:&lt;/strong&gt;1&lt;strong&gt;:&lt;/strong&gt;1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般 -Xms 和 -Xmx 设置一样的大小，-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置一样的大小。-Xms 等价于 -XX:InitialHeapSize，-Xmx等价于-XX:MaxHeapSize；-Xmn等价于-XX:MaxNewSize。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）在IDEA中可以按照如下方式设置JVM参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200925131103321-1880146800.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）命令行启动时可以按照如下格式设置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
java -jar -Xms1G -Xmx1G -Xmn512M -Xss1M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M app.jar
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、查看GC日志&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）设置GC参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在启动时加上如下参数来查看GC日志：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-XX:+PrintGC：打印GC日志&lt;/li&gt;
&lt;li&gt;-XX:+PrintGCDetails：打印详细的GC日志&lt;/li&gt;
&lt;li&gt;-XX:+PrintGCTimeStamps：打印每次GC发生的时间&lt;/li&gt;
&lt;li&gt;-Xloggc:./gc.log：设置GC日志文件的路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，我在IDEA中添加了如下JVM启动参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-&lt;span&gt;Xms1G
&lt;/span&gt;-&lt;span&gt;Xmx1G
&lt;/span&gt;-&lt;span&gt;Xmn512M
&lt;/span&gt;-&lt;span&gt;Xss1M
&lt;/span&gt;-XX:MetaspaceSize=&lt;span&gt;128M
&lt;/span&gt;-XX:MaxMetaspaceSize=&lt;span&gt;128M
&lt;/span&gt;-XX:SurvivorRatio=8
-XX:+&lt;span&gt;PrintGC
&lt;/span&gt;-XX:+&lt;span&gt;PrintGCDetails
&lt;/span&gt;-XX:+&lt;span&gt;PrintGCDateStamps
&lt;/span&gt;-Xloggc:./gc.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动程序之后打印出了如下的一些日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Java HotSpot(TM) 64-Bit Server VM (25.191-b12) &lt;span&gt;for&lt;/span&gt; windows-amd64 JRE (1.8.0_191-b12), built on Oct  6 2018 09:29:03 by &quot;java_re&quot; with MS VC++ 10.0&lt;span&gt; (VS2010)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Memory: 4k page, physical 33408872k(22219844k free), swap 35506024k(21336808k free)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; CommandLine flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CompressedClassSpaceSize=125829120 -XX:InitialHeapSize=1073741824 -XX:+ManagementServer -XX:MaxHeapSize=1073741824 -XX:MaxMetaspaceSize=134217728 -XX:MaxNewSize=536870912 -XX:MetaspaceSize=134217728 -XX:NewSize=536870912 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:ThreadStackSize=1024 -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+&lt;span&gt;UseParallelGC 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 2020-09-25T13:00:41.631+0800: 4.013: [GC (Allocation Failure) [PSYoungGen: 419840K-&amp;gt;20541K(472064K)] 419840K-&amp;gt;20573K(996352K), 0.0118345 secs] [Times: user=0.00 sys=0.00, real=0.01&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 2020-09-25T13:00:44.252+0800: 6.633: [GC (Allocation Failure) [PSYoungGen: 440381K-&amp;gt;39872K(472064K)] 440413K-&amp;gt;39928K(996352K), 0.0180292 secs] [Times: user=0.08 sys=0.08, real=0.02&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 2020-09-25T13:00:45.509+0800: 7.891: [GC (Allocation Failure) [PSYoungGen: 459712K-&amp;gt;45102K(472064K)] 459768K-&amp;gt;45174K(996352K), 0.0181544 secs] [Times: user=0.01 sys=0.00, real=0.02&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 2020-09-25T13:00:46.809+0800: 9.191: [GC (Allocation Failure) [PSYoungGen: 464942K-&amp;gt;48670K(472064K)] 465014K-&amp;gt;48785K(996352K), 0.0214228 secs] [Times: user=0.16 sys=0.00, real=0.02&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 2020-09-25T13:00:48.425+0800: 10.807: [GC (Allocation Failure) [PSYoungGen: 468510K-&amp;gt;52207K(472064K)] 468625K-&amp;gt;57076K(996352K), 0.0218655 secs] [Times: user=0.17 sys=0.00, real=0.02&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 2020-09-25T13:06:58.361+0800: 380.743: [GC (Allocation Failure) [PSYoungGen: 422656K-&amp;gt;14159K(472064K)] 610503K-&amp;gt;204082K(996352K), 0.0111278 secs] [Times: user=0.16 sys=0.00, real=0.01&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  PSYoungGen      total 472064K, used 406352K [0x00000000e0000000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   eden space 419840K, 93% used [0x00000000e0000000,0x00000000f7f00528,0x00000000f9a00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   from space 52224K, 27% used [0x00000000f9a00000,0x00000000fa7d3d70,0x00000000fcd00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   to   space 52224K, 0% used [0x00000000fcd00000,0x00000000fcd00000,0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;  ParOldGen       total 524288K, used 189923K [0x00000000c0000000, 0x00000000e0000000, 0x00000000e0000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   object space 524288K, 36% used [0x00000000c0000000,0x00000000cb978d08,0x00000000e0000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; Metaspace       used 111852K, capacity 117676K, committed 117888K, reserved 1153024K
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 13876K, capacity 14914K, committed 14976K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从第三行 CommandLine flags 可以得到如下的信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-XX:InitialHeapSize=1073741824：初始堆大小为1G（等于 -Xms 设置的值）&lt;/li&gt;
&lt;li&gt;-XX:MaxHeapSize=1073741824：最大堆内存 1G（等于 -Xmx 设置的值）&lt;/li&gt;
&lt;li&gt;-XX:NewSize=536870912：新生代初始大小 512M（等于 -Xmn 设置的值）&lt;/li&gt;
&lt;li&gt;-XX:MaxNewSize=536870912：最新生代初始大小 512M（等于 -Xmn 设置的值）&lt;/li&gt;
&lt;li&gt;-XX:MetaspaceSize=134217728：元空间大小 128M&lt;/li&gt;
&lt;li&gt;-XX:MaxMetaspaceSize=134217728：最大元空间 128M&lt;/li&gt;
&lt;li&gt;-XX:SurvivorRatio=8：新生代 Eden 和 Survivor 的比例&lt;/li&gt;
&lt;li&gt;-XX:ThreadStackSize=1024：线程栈的大小 1M&lt;/li&gt;
&lt;li&gt;-XX:+UseParallelGC：默认使用 年轻代 Parallel Scavenge + 老年代 Parallel Old 的垃圾回收器组合。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）查看默认参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要查看JVM的默认参数，就可以通过给JVM加打印GC日志的参数，就可以在GC日志中看到JVM的默认参数了。&lt;/p&gt;
&lt;p&gt;还可以在启动参数中添加 -XX:+PrintFlagsFinal 参数，将会打印系统的所有参数，就可以看到自己配置的参数或系统的默认参数了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200926043034541-356210399.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）GC日志：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之后的日志就是每次垃圾回收时产生的日志，每行日志说明了这次GC的执行情况，例如第四行GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
2020-09-25T13:00:41.631+0800: 4.013: [GC (Allocation Failure) [PSYoungGen: 419840K-&amp;gt;20541K(472064K)] 419840K-&amp;gt;20573K(996352K), 0.0118345 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细内容如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2020-09-25T13:00:41.631+0800：GC发生的时间点。&lt;/li&gt;
&lt;li&gt;4.013：系统运行多久之后发生的GC，单位秒，这里就是系统运行 4.013 秒后发生了一次GC。&lt;/li&gt;
&lt;li&gt;GC (Allocation Failure)：说明了触发GC的原因，这里是指对象分配失败导致的GC。&lt;/li&gt;
&lt;li&gt;PSYoungGen：指触发的是年轻代的垃圾回收，使用的是 Parallel Scavenge 垃圾回收器。&lt;/li&gt;
&lt;li&gt;419840K-&amp;gt;20541K：对年轻代执行了一次GC，GC之前年轻代使用了 419840K，GC之后有 20541K 的对象活下来了。&lt;/li&gt;
&lt;li&gt;(472064K)：年轻代可用空间是 472064K，即 461 M，为什么是461M呢？因为新生代大小为 512M，Eden 区占 409.6M，两块 Survivor 区各占 51.2M，所以年轻代的可用空间为 Eden+1个Survivor的大小，即460.8M，约为461M。&lt;/li&gt;
&lt;li&gt;419840K-&amp;gt;20573K：GC前整个堆内存使用了 419840K，GC之后堆内存使用了 20573K。&lt;/li&gt;
&lt;li&gt;(996352K)：整个堆的大小是 996352K，即 973M，其实就是年轻代的 461M + 老年代的 512 M&lt;/li&gt;
&lt;li&gt;0.0118345 secs：本次GC耗费的时间&lt;/li&gt;
&lt;li&gt;Times: user=0.00 sys=0.00, real=0.01 secs：本次GC耗费的时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4）JVM退出时的GC情况：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序结束运行后，还会打印一些日志，就是第12行之后的日志，这部分展示的是当前堆内存的使用情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  PSYoungGen      total 472064K, used 406352K [0x00000000e0000000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   eden space 419840K, 93% used [0x00000000e0000000,0x00000000f7f00528,0x00000000f9a00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   from space 52224K, 27% used [0x00000000f9a00000,0x00000000fa7d3d70,0x00000000fcd00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   to   space 52224K, 0% used [0x00000000fcd00000,0x00000000fcd00000,0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  ParOldGen       total 524288K, used 189923K [0x00000000c0000000, 0x00000000e0000000, 0x00000000e0000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   object space 524288K, 36% used [0x00000000c0000000,0x00000000cb978d08,0x00000000e0000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt; Metaspace       used 111852K, capacity 117676K, committed 117888K, reserved 1153024K
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 13876K, capacity 14914K, committed 14976K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细内容如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PSYoungGen total 472064K, used 406352K：指 Parallel Scavenge 回收器负责的年轻代总共有 472064K（461M）内存，目前使用了 406352K （396.8M）。&lt;/li&gt;
&lt;li&gt;eden space 419840K, 93% used：Eden 区的空间为 419840K（410M），已经使用了 93%。&lt;/li&gt;
&lt;li&gt;from space 52224K, 27% used：From Survivor 区的空间为 52224K（51M），已经使用了 27%。&lt;/li&gt;
&lt;li&gt;to space 52224K, 0% used：To Survivor 区的空间为 52224K（51M），使用了 0%，就是完全空闲的。&lt;/li&gt;
&lt;li&gt;ParOldGen total 524288K, used 189923K：指 Parallel Old 回收器负责的老年代总共有 524288K（512M），目前使用了 189923K（185.4M）。&lt;/li&gt;
&lt;li&gt;object space 524288K, 36% used：老年代空间总大小 524288K（512M），使用了 36%。&lt;/li&gt;
&lt;li&gt;Metaspace &amp;amp; class space：Metaspace 元数据空间和Class空间，总容量、使用的内存等。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;五、内存分配与回收策略&lt;/h2&gt;
&lt;p&gt;接下来我们就通过一些demo结合着GC日志分析下什么时候会触发GC，以及对象在堆中如何分配流转的。&lt;/p&gt;
&lt;h3&gt;1、对象首先分配到Eden区&lt;/h3&gt;
&lt;p&gt;我们通过如下这段程序来验证下对象首先是分配到 Eden 区的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GCMain {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _1M = 1024 * 1024&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jvm参数设置为如下：堆200M，年轻代 100M，Eden区占 80M，Survivor 各占 10M，老年代100M。使用默认的 Parallel Scavenge + Parallel Old 回收器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-Xms200M -Xmx200M -Xmn100M -XX:SurvivorRatio=8 -XX:+UseParallelGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./gc.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序运行结束后，查看运行的GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Java HotSpot(TM) 64-Bit Server VM (25.191-b12) &lt;span&gt;for&lt;/span&gt; windows-amd64 JRE (1.8.0_191-b12), built on Oct  6 2018 09:29:03 by &quot;java_re&quot; with MS VC++ 10.0&lt;span&gt; (VS2010)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Memory: 4k page, physical 33408872k(23013048k free), swap 35506024k(22095152k free)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; CommandLine flags: -XX:InitialHeapSize=209715200 -XX:MaxHeapSize=209715200 -XX:MaxNewSize=104857600 -XX:NewSize=104857600 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+&lt;span&gt;UseParallelGC 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  PSYoungGen      total 92160K, used 68062K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   eden space 81920K, 83% used [0x00000000f9c00000,0x00000000fde77ba0,0x00000000fec00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   from space 10240K, 0% used [0x00000000ff600000,0x00000000ff600000,0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   to   space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  ParOldGen       total 102400K, used 0K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   object space 102400K, 0% used [0x00000000f3800000,0x00000000f3800000,0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; Metaspace       used 3048K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从第5行可以看出，年轻代总共可用空间为 92160K（90M），已经使用了 68062K（66.4M）。代码中创建了两个30M的byte数组，为何会占用66.4M呢？多出来的这部分对象可以认为是对象数组本身额外需要占用的内存空间以及程序运行时所创建的一些额外的对象，就称为未知对象吧。&lt;/p&gt;
&lt;p&gt;从第6行之后可以看出，Eden 使用了 83%，From Survivor、To Survivor、老年代使用率均为 0%。可以确认对象首先是分配到 Eden 区的。&lt;/p&gt;
&lt;h3&gt;2、Eden 区满了触发 Minior GC&lt;/h3&gt;
&lt;p&gt;使用如下jvm参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-Xms200M -Xmx200M -Xmn100M -XX:SurvivorRatio=8 -XX:+UseParallelGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./gc.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行如下代码，第2、3、4行将产生60M的垃圾对象，第6行再分配时，eden 区空间就不够分配了，此时就会触发一次 YoungGC：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     b1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看GC日志可以发现触发了一次 Young GC：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 2020-09-26T00:14:16.832+0800: 0.194: [GC (Allocation Failure) [PSYoungGen: 66424K-&amp;gt;815K(92160K)] 66424K-&amp;gt;823K(194560K), 0.0010813 secs] [Times: user=0.08 sys=0.08, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  PSYoungGen      total 92160K, used 33993K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   eden space 81920K, 40% used [0x00000000f9c00000,0x00000000fbc66800,0x00000000fec00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   from space 10240K, 7% used [0x00000000fec00000,0x00000000feccbca0,0x00000000ff600000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   to   space 10240K, 0% used [0x00000000ff600000,0x00000000ff600000,0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  ParOldGen       total 102400K, used 8K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   object space 102400K, 0% used [0x00000000f3800000,0x00000000f3802000,0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; Metaspace       used 3048K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第1行可以看出，由于内存分配失败触发了一次YoungGC，回收前内存占用 66424K，回收后只有 815K 了。整个堆回收前占用 66424K，回收后存活 823K。&lt;/p&gt;
&lt;p&gt;第3行可以看出，程序结束后，新生代使用了 33993K，其中就包括最后一个 b2 对象。&lt;/p&gt;
&lt;p&gt;第5行可以看出，Young GC后，存活的  815K 对象进入了 from survivor 区，占用 7% 的空间。&lt;/p&gt;
&lt;p&gt;从上面的分析可以确认 eden 区快满了，无法给新生对象分配内存时，将触发一次 Young GC，并把存活的对象复制到一个 survivor 区中。&lt;/p&gt;
&lt;h3&gt;3、大对象将直接进入老年代&lt;/h3&gt;
&lt;p&gt;要控制大对象的阀值可以通过 -XX:PretenureSizeThreshold 参数设置，但是它只对 Serial 和 ParNew 回收器生效，对 Parallel Scavenge 不生效，所以这里我们使用 ParNew + CMS 的回收器组合，并设置大对象阀值为4M：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-Xms200M -Xmx200M -Xmn100M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=40M -XX:+UseConcMarkSweepGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./gc.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行如下的代码，直接创建一个 40M 的对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 40&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Java HotSpot(TM) 64-Bit Server VM (25.191-b12) &lt;span&gt;for&lt;/span&gt; windows-amd64 JRE (1.8.0_191-b12), built on Oct  6 2018 09:29:03 by &quot;java_re&quot; with MS VC++ 10.0&lt;span&gt; (VS2010)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Memory: 4k page, physical 33408872k(22977952k free), swap 35506024k(21515696k free)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; CommandLine flags: -XX:InitialHeapSize=209715200 -XX:MaxHeapSize=209715200 -XX:MaxNewSize=104857600 -XX:NewSize=104857600 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=41943040 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+&lt;span&gt;UseParNewGC 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  par &lt;span&gt;new&lt;/span&gt; generation   total 92160K, used 6622K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   eden space 81920K,   8% used [0x00000000f3800000, 0x00000000f3e77b80, 0x00000000f8800000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   from space 10240K,   0% used [0x00000000f8800000, 0x00000000f8800000, 0x00000000f9200000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   to   space 10240K,   0% used [0x00000000f9200000, 0x00000000f9200000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  concurrent mark-sweep generation total 102400K, used 40960K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; Metaspace       used 3046K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第3、5、9行可以看出， -XX:+UseConcMarkSweepGC 参数默认启用的是 ParNew + CMS 的回收器。&lt;/p&gt;
&lt;p&gt;第5、6行可以看出，eden 区还是会有6M左右的未知对象。&lt;/p&gt;
&lt;p&gt;第9行可以看出，CMS 负责的老年代内存大小为 102400K（100M），使用了 40960K（40M），就是代码中创建的 b1 对象。&lt;/p&gt;
&lt;p&gt;因此可以确认，超过 -XX:PretenureSizeThreshold 参数设置的大对象将直接进入老年代。&lt;/p&gt;
&lt;h3&gt;4、长期存活的对象将进入老年代&lt;/h3&gt;
&lt;p&gt;对象诞生在eden区中，eden区满了之后，就会触发YoungGC，将eden区存活的对象复制到survivor中，此时对象的GC年龄设为1岁。对象每熬过一次GC，GC年龄就增加1岁，当它超过一定阀值的时候就会被晋升到老年代。GC年龄的阀值可以通过参数 -XX:MaxTenuringThreshold 设置，默认为 15。&lt;/p&gt;
&lt;p&gt;设置如下JVM参数：eden 区80M，survivor 各占10M，GC年龄阀值为2。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-Xms200M -Xmx200M -Xmn100M -XX:MaxTenuringThreshold=2 -XX:PretenureSizeThreshold=40M -XX:+UseConcMarkSweepGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./gc.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先运行如下代码，第4、5、6行将在eden区产生70M的垃圾对象，第8行再创建一个35M的对象时，eden区空间不足，将触发第一次YoungGC：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 2]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b1 为长期存活对象 占 2M&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     b2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b3 = new byte[_1M * 35];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b3 = null;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte[] b4 = new byte[_1M * 35];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b4 = new byte[_1M * 35];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b4 = null;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte[] bx = new byte[_1M * 2];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte[] b5 = new byte[_1M * 35];&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 2020-09-25T23:47:20.648+0800: 0.198: [GC (Allocation Failure) 2020-09-25T23:47:20.648+0800: 0.198: [ParNew: 78712K-&amp;gt;2769K(92160K), 0.0013440 secs] 78712K-&amp;gt;2769K(194560K), 0.0014923 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  par &lt;span&gt;new&lt;/span&gt; generation   total 92160K, used 41067K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   eden space 81920K,  46% used [0x00000000f3800000, 0x00000000f5d66800, 0x00000000f8800000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   from space 10240K,  27% used [0x00000000f9200000, 0x00000000f94b4600, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   to   space 10240K,   0% used [0x00000000f8800000, 0x00000000f8800000, 0x00000000f9200000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  concurrent mark-sweep generation total 102400K, used 0K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt; Metaspace       used 3047K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，第一次YoungGC后还存活2769K的对象，然后复制到 from survivor 区，占 27% 的空间大小，包含2M的b1对象+700K左右的未知对象。此时 b1 对象GC年龄为1。&lt;/p&gt;
&lt;p&gt;再运行如下代码，同理，运行到第12行时，将触发第二次 YoungGC：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 2]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b1 为长期存活对象 占 2M&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     b2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     b3 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b4 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b4 = new byte[_1M * 35];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b4 = null;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte[] bx = new byte[_1M * 2];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte[] b5 = new byte[_1M * 35];&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 2020-09-25T23:53:57.325+0800: 0.196: [GC (Allocation Failure) 2020-09-25T23:53:57.325+0800: 0.196: [ParNew: 78712K-&amp;gt;2770K(92160K), 0.0014935 secs] 78712K-&amp;gt;2770K(194560K), 0.0016180 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 2020-09-25T23:53:57.331+0800: 0.201: [GC (Allocation Failure) 2020-09-25T23:53:57.331+0800: 0.201: [ParNew: 77693K-&amp;gt;2888K(92160K), 0.0013393 secs] 77693K-&amp;gt;2888K(194560K), 0.0013890 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  par &lt;span&gt;new&lt;/span&gt; generation   total 92160K, used 40367K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   eden space 81920K,  45% used [0x00000000f3800000, 0x00000000f5c99b30, 0x00000000f8800000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   from space 10240K,  28% used [0x00000000f8800000, 0x00000000f8ad2130, 0x00000000f9200000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   to   space 10240K,   0% used [0x00000000f9200000, 0x00000000f9200000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  concurrent mark-sweep generation total 102400K, used 0K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; Metaspace       used 3048K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，第二次YoungGC后，还存活2888K对象，此时复制到另一块 survivor 区，占 28% 的内存，包含2M的b1对象+700K左右的未知对象。此时 b2 对象GC年龄加1，为2。&lt;/p&gt;
&lt;p&gt;再运行如下代码，第17行将触发第三次YoungGC：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 2]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b1 为长期存活对象 占 2M&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     b2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     b3 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b4 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     b4 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     b4 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] bx = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b5 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 2020-09-26T00:00:39.242+0800: 0.188: [GC (Allocation Failure) 2020-09-26T00:00:39.243+0800: 0.188: [ParNew: 78712K-&amp;gt;2749K(92160K), 0.0012472 secs] 78712K-&amp;gt;2749K(194560K), 0.0013625 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 2020-09-26T00:00:39.247+0800: 0.193: [GC (Allocation Failure) 2020-09-26T00:00:39.247+0800: 0.193: [ParNew: 77672K-&amp;gt;2867K(92160K), 0.0013000 secs] 77672K-&amp;gt;2867K(194560K), 0.0013396 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 2020-09-26T00:00:39.252+0800: 0.197: [GC (Allocation Failure) 2020-09-26T00:00:39.252+0800: 0.197: [ParNew: 78732K-&amp;gt;2048K(92160K), 0.0031018 secs] 78732K-&amp;gt;4716K(194560K), 0.0031488 secs] [Times: user=0.02 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  par &lt;span&gt;new&lt;/span&gt; generation   total 92160K, used 38707K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   eden space 81920K,  44% used [0x00000000f3800000, 0x00000000f5bcce50, 0x00000000f8800000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   from space 10240K,  20% used [0x00000000f9200000, 0x00000000f9400010, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   to   space 10240K,   0% used [0x00000000f8800000, 0x00000000f8800000, 0x00000000f9200000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  concurrent mark-sweep generation total 102400K, used 2668K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; Metaspace       used 3048K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，第三次YoungGC后，年轻代还存活 2048K（2M），其实就是 bx 这个对象，bx 被复制到 from survivor 区，from survivor 占用刚好20%（2M）。而此时老年代使用了 2668K，就是2M的 b1 对象+600K左右的未知对象。&lt;/p&gt;
&lt;p&gt;所以可以判断出，第三次YoungGC时，在要复制 eden区+from survivor 区的存活对象时，发现 survivor 区存活对象的GC年龄已经超过设置的阀值了，这时就会将超过阀值的对象复制到老年代。&lt;/p&gt;
&lt;h3&gt;5、动态对象年龄判断&lt;/h3&gt;
&lt;p&gt;动态对象年龄判断是指，在复制前，如果 survivior 区域内年龄1+年龄2+年龄3+...+年龄n的对象总和大于survivor区的50%时，年龄n及以上的对象就会进入老年代，不一定要达到15岁。&lt;/p&gt;
&lt;p&gt;设置如下JVM参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
-Xms200M -Xmx200M -Xmn100M -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=40M -XX:+UseConcMarkSweepGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./gc.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] x1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     b1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发一次GC&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] x2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     b2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发一次GC
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte[] x3 = new byte[_1M];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b3 = new byte[_1M * 30];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b3 = null;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte[] b4 = new byte[_1M * 30]; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发一次GC&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 2020-09-26T00:50:51.099+0800: 0.211: [GC (Allocation Failure) 2020-09-26T00:50:51.099+0800: 0.211: [ParNew: 69496K-&amp;gt;3787K(92160K), 0.0020708 secs] 69496K-&amp;gt;3787K(194560K), 0.0021864 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 2020-09-26T00:50:51.104+0800: 0.217: [GC (Allocation Failure) 2020-09-26T00:50:51.104+0800: 0.217: [ParNew: 70513K-&amp;gt;6007K(92160K), 0.0030657 secs] 70513K-&amp;gt;6007K(194560K), 0.0031105 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  par &lt;span&gt;new&lt;/span&gt; generation   total 92160K, used 38366K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   eden space 81920K,  39% used [0x00000000f3800000, 0x00000000f5799b30, 0x00000000f8800000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   from space 10240K,  58% used [0x00000000f8800000, 0x00000000f8dddf18, 0x00000000f9200000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   to   space 10240K,   0% used [0x00000000f9200000, 0x00000000f9200000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  concurrent mark-sweep generation total 102400K, used 0K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; Metaspace       used 3048K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结合代码和GC日志可以分析出，代码运行到第15行之后，触发了两次GC，这时 x1 的GC年龄为2，x2的GC年龄为1。from survivor 占了 58%了，从这里也可以看出是在复制前来判断动态年龄规则的。&lt;/p&gt;
&lt;p&gt;再运行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] x1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     b1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发一次GC&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] x2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     b2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发一次GC&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] x3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[_1M];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     b3 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b4 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发一次GC&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 2020-09-26T00:57:03.279+0800: 0.197: [GC (Allocation Failure) 2020-09-26T00:57:03.279+0800: 0.197: [ParNew: 69496K-&amp;gt;3785K(92160K), 0.0020626 secs] 69496K-&amp;gt;3785K(194560K), 0.0021906 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 2020-09-26T00:57:03.285+0800: 0.203: [GC (Allocation Failure) 2020-09-26T00:57:03.285+0800: 0.203: [ParNew: 70511K-&amp;gt;5980K(92160K), 0.0028174 secs] 70511K-&amp;gt;5980K(194560K), 0.0028673 secs] [Times: user=0.16 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 2020-09-26T00:57:03.290+0800: 0.208: [GC (Allocation Failure) 2020-09-26T00:57:03.290+0800: 0.208: [ParNew: 70832K-&amp;gt;3072K(92160K), 0.0031929 secs] 70832K-&amp;gt;6764K(194560K), 0.0032401 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  par &lt;span&gt;new&lt;/span&gt; generation   total 92160K, used 34611K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   eden space 81920K,  38% used [0x00000000f3800000, 0x00000000f56cce50, 0x00000000f8800000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   from space 10240K,  30% used [0x00000000f9200000, 0x00000000f9500020, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   to   space 10240K,   0% used [0x00000000f8800000, 0x00000000f8800000, 0x00000000f9200000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  concurrent mark-sweep generation total 102400K, used 3692K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; Metaspace       used 3048K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结合代码和GC日志可以分析出，代码运行到第22行时，触发了第三次GC，第三次GC复制时，survivor 中年龄为1的 x2 对象（2M）+年龄为2的 x1 对象（3M）+ 年龄为2的未知对象 已经超过 survivor 的50%了，此时就触发动态年龄判定规则，将年龄为2以上的对象晋升到老年代。&lt;/p&gt;
&lt;p&gt;从第7行看出，survivor 区还有30%（3M）的对象，就是回收后还存活的 x2（2M）+ x3（1M）。&lt;/p&gt;
&lt;p&gt;从第9行看出，老年代使用了 3692K（3.6M），说明 x1（3M）+ 未知对象（500K左右）通过动态年龄判断晋升到老年代了。&lt;/p&gt;
&lt;h3&gt;6、无法放入Survivor区直接进入老年代&lt;/h3&gt;
&lt;p&gt;YoungGC时，如果eden区+ from survivor 区存活的对象无法放到 to survivor 区了，这个时候会直接将部分对象放入到老年代。&lt;/p&gt;
&lt;p&gt;使用如下jvm参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-Xms200M -Xmx200M -Xmn100M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=40M -XX:+UseConcMarkSweepGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./gc.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 8&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     b3 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b4 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发GC&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 2020-09-26T01:20:03.727+0800: 0.186: [GC (Allocation Failure) 2020-09-26T01:20:03.727+0800: 0.186: [ParNew: 77688K-&amp;gt;3799K(92160K), 0.0059624 secs] 77688K-&amp;gt;11993K(194560K), 0.0060861 secs] [Times: user=0.00 sys=0.00, real=0.01&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  par &lt;span&gt;new&lt;/span&gt; generation   total 92160K, used 36977K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   eden space 81920K,  40% used [0x00000000f3800000, 0x00000000f5866800, 0x00000000f8800000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   from space 10240K,  37% used [0x00000000f9200000, 0x00000000f95b5e00, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   to   space 10240K,   0% used [0x00000000f8800000, 0x00000000f8800000, 0x00000000f9200000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  concurrent mark-sweep generation total 102400K, used 8194K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt; Metaspace       used 3048K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结合代码和GC日志可以看出，YoungGC后，存活的对象无法复制到一个 survivor 区中了，因此有部分对象直接晋升到老年代了。from survivor 区占了 37%（3.7M），可以认为是 b1对象（3M）+ 700K左右未知对象；老年代使用了 8194K（8M），就是b2对象（8M）。&lt;/p&gt;
&lt;p&gt;需要注意的是，并不是把全部存活的对象晋升到老年代，而是把部分对象晋升到老年代，部分复制到 survivor 区中。&lt;/p&gt;
&lt;h3&gt;7、老年代空间分配担保原则&lt;/h3&gt;
&lt;p&gt;如果YougGC时新生代有大量对象存活下来，而 survivor 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。&lt;/p&gt;
&lt;p&gt;在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代 YoungGC 后，所有对象都存活下来了，而 survivor 区又放不下，那可能所有对象都要进入老年代了。这个时候如果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽快这次YoungGC是有风险的。如果小于，或者 -XX:HandlePromotionFailure 参数不允许担保失败，这时就会进行一次 Full GC。&lt;/p&gt;
&lt;p&gt;在允许担保失败并尝试进行YoungGC后，可能会出现三种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;① YoungGC后，存活对象小于survivor大小，此时存活对象进入survivor区中&lt;/li&gt;
&lt;li&gt;② YoungGC后，存活对象大于survivor大小，但是小于老年大可用空间大小，此时直接进入老年代。&lt;/li&gt;
&lt;li&gt;③ YoungGC后，存活对象大于survivor大小，也大于老年大可用空间大小，老年代也放不下这些对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过下图来了解空间分配担保原则：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200926023252933-333022612.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分配担保规则在JDK7之后有些变化，不再判断 -XX:HandlePromotionFailure 参数。YoungGC发生时，只要老年代的连续空间大于新生代对象总大小，或者大于历次晋升的平均大小，就可以进行 YoungGC，否则就进行 FullGC。&lt;/p&gt;
&lt;p&gt;下面来结合GC日志实际观察下，设置如下jvm参数：老年代100M，eden区80M，survivor区10M，大对象阀值为35M。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-Xms200M -Xmx200M -Xmn100M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=35M -XX:+UseConcMarkSweepGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./gc.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 35&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     b3 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b4 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发GC&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 2020-09-26T02:53:17.908+0800: 0.210: [GC (Allocation Failure) 2020-09-26T02:53:17.909+0800: 0.210: [ParNew: 66424K-&amp;gt;707K(92160K), 0.0008820 secs] 138104K-&amp;gt;72387K(194560K), 0.0010026 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 2020-09-26T02:53:17.911+0800: 0.213: [GC (CMS Initial Mark) [1 CMS-initial-mark: 71680K(102400K)] 103107K(194560K), 0.0002821 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 2020-09-26T02:53:17.912+0800: 0.213: [CMS-concurrent-mark-&lt;span&gt;start]
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 2020-09-26T02:53:17.912+0800: 0.213: [CMS-concurrent-mark: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 2020-09-26T02:53:17.912+0800: 0.213: [CMS-concurrent-preclean-&lt;span&gt;start]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 2020-09-26T02:53:17.912+0800: 0.213: [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 2020-09-26T02:53:17.912+0800: 0.213: [CMS-concurrent-abortable-preclean-&lt;span&gt;start]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Heap
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  par &lt;span&gt;new&lt;/span&gt; generation   total 92160K, used 33885K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   eden space 81920K,  40% used [0x00000000f3800000, 0x00000000f5866800, 0x00000000f8800000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   from space 10240K,   6% used [0x00000000f9200000, 0x00000000f92b0f48, 0x00000000f9c00000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   to   space 10240K,   0% used [0x00000000f8800000, 0x00000000f8800000, 0x00000000f9200000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  concurrent mark-sweep generation total 102400K, used 71680K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; Metaspace       used 3047K, capacity 4556K, committed 4864K, reserved 1056768K
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b1、b2 两个对象超过大对象阀值，将直接进入老年代，因此可以认为历次进入老年大对象的平均大小为35M。此时老年代还剩余30M。&lt;/p&gt;
&lt;p&gt;代码第5、6、7行将产生60M垃圾对象，到第9行时 eden 区不足，这时判断老年代剩余空间（30M）是否大于新生代所有对象大小（60M），明显是否；再判断老年代大小（30M）是否大于历次晋升对象的平均大小（35M），也是否。&lt;/p&gt;
&lt;p&gt;因此这时就触发了 Full GC，GC日志中第1行发生了一次YoungGC，第2~7行是CMS的OldGC。&lt;/p&gt;
&lt;h3&gt;8、CMS触发OldGC&lt;/h3&gt;
&lt;p&gt;CMS回收器有个参数 -XX:CMSInitiatingOccupancyFraction 来控制当老年代内存占用超过这个比例后，就触发CMS回收。因为CMS要预留一些空间保证在回收期间，可以让对象进入老年代。&lt;/p&gt;
&lt;p&gt;设置如下jvm参数：当老年代超过80%时，触发CMS回收，CMS GC线程每个2秒检查一次是否回收。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
-Xms200M -Xmx200M -Xmn100M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=15M -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSWaitDuration=2000 &lt;br/&gt;-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./gc.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;[] b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     b3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1M * 20&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Thread.sleep(3000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
2020-09-26T04:13:52.245+0800: 2.083: [GC (CMS Initial Mark) [1 CMS-initial-mark: 81920K(102400K)] 86904K(194560K), 0.0006366 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;2020-09-26T04:13:52.245+0800: 2.084: [CMS-concurrent-mark-&lt;span&gt;start]
&lt;/span&gt;2020-09-26T04:13:52.245+0800: 2.084: [CMS-concurrent-mark: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;2020-09-26T04:13:52.245+0800: 2.084: [CMS-concurrent-preclean-&lt;span&gt;start]
&lt;/span&gt;2020-09-26T04:13:52.246+0800: 2.084: [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00&lt;span&gt; secs] 
&lt;/span&gt;2020-09-26T04:13:52.246+0800: 2.084: [CMS-concurrent-abortable-preclean-&lt;span&gt;start]
Heap
 par &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; generation   total 92160K, used 6622K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000&lt;span&gt;)
  eden space 81920K,   &lt;/span&gt;8% used [0x00000000f3800000, 0x00000000f3e77b80, 0x00000000f8800000&lt;span&gt;)
  from space 10240K,   &lt;/span&gt;0% used [0x00000000f8800000, 0x00000000f8800000, 0x00000000f9200000&lt;span&gt;)
  to   space 10240K,   &lt;/span&gt;0% used [0x00000000f9200000, 0x00000000f9200000, 0x00000000f9c00000&lt;span&gt;)
 concurrent mark&lt;/span&gt;-sweep generation total 102400K, used 81920K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000&lt;span&gt;)
 Metaspace       used 3048K, capacity 4556K, committed 4864K, reserved 1056768K
  &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; space    used 322K, capacity 392K, committed 512K, reserved 1048576K
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，老年代超过80%后，触发了一次CMS老年代回收，注意并不是Full GC，只是老年代回收。&lt;/p&gt;
&lt;p&gt;还需注意的是，并不是超过80%就立即触发CMS回收，CMS自己有个间隔时间，通过 -XX:CMSWaitDuration 参数设置，其默认值为2000毫秒，从这里也可以看出，程序运行2秒后才触发了CMS的回收。&lt;/p&gt;
&lt;h3&gt;9、总结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）内存参数设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200926045752277-8329966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）垃圾回收触发时机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202009/856154-20200926052528780-675048017.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;本文是学习、参考了如下书籍和课程，再通过自己的总结和实践总结而来。如果想了解更多深入的细节，建议阅读原著。&lt;/p&gt;
&lt;p&gt;《深入理解Java虚拟机：JVM高级特性与最佳实践 第三版》&lt;/p&gt;
&lt;p&gt;《极客时间：Java性能调优实战》&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d0ef9900e896_MyDfcJi8/6&quot; target=&quot;_blank&quot;&gt;从 0 开始带你成为JVM实战高手&lt;/a&gt;》&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 25 Sep 2020 21:27:00 +0000</pubDate>
<dc:creator>bojiangzhou</dc:creator>
<og:description>介绍了JVM垃圾回收机制、垃圾回收算法、垃圾回收器，如何设置内存和查看GC日志，通过GC日志结合代码一步步分析内存分配和垃圾回收策略。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chiangchou/p/jvm-2.html</dc:identifier>
</item>
<item>
<title>详细分析 Java 中实现多线程的方法有几种?(从本质上出发) - 踏雪彡寻梅</title>
<link>http://www.cnblogs.com/txxunmei/p/13733332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/txxunmei/p/13733332.html</guid>
<description>&lt;h2 id=&quot;正确的说法从本质上出发&quot;&gt;正确的说法(从本质上出发)&lt;/h2&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;实现多线程的官方正确方法: 2 种。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Oracle 官网的文档说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200926005926464.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法小结&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * &amp;lt;p&amp;gt;
 * 实现 Runnable 接口的方式创建线程
 * &amp;lt;/p&amp;gt;
 *
 * @author 踏雪彡寻梅
 * @version 1.0
 * @date 2020/9/7 - 00:34
 * @since JDK1.8
 */
public class RunnableStyle implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;用 Runnable 方式实现线程~~~&quot;);
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new RunnableStyle());
        thread.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * &amp;lt;p&amp;gt;
 * 继承 Thread 类的方式创建线程
 * &amp;lt;/p&amp;gt;
 *
 * @author 踏雪彡寻梅
 * @version 1.0
 * @date 2020/9/7 - 00:37
 * @since JDK1.8
 */
public class ThreadStyle extends Thread {
    @Override
    public void run() {
        System.out.println(&quot;用 Thread 方式实现线程~~~&quot;);
    }

    public static void main(String[] args) {
        new ThreadStyle().start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两种方式的对比&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;两种方式的本质区别&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;方法一: 最终调用 &lt;code&gt;target.run;&lt;/code&gt; ，通过以下两图可以知道使用这个方法时实际上是传递了一个 target 对象，执行了这个对象的 run 方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200926010328443.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200926010343165.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;方法二: run() 整个都被重写。一旦子类重写了父类的方法，原有方法会被覆盖被抛弃，即以下代码不会被这次调用所采纳。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200926010458379.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;综上，两种方法都是执行了 run 方法，只不过 run 方法的来源不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;同时使用两种方法会怎样?&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;代码演示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* &amp;lt;p&amp;gt;
* 同时使用 Runnable 和 Thread 两种实现线程的方式
* &amp;lt;/p&amp;gt;
*
* @author 踏雪彡寻梅
* @version 1.0
* @date 2020/9/7 - 22:38
* @since JDK1.8
*/
@SuppressWarnings(&quot;all&quot;)
public class BothRunnableThread {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;我来自 Runnable。。。&quot;);
            }
        }) {
            @Override
            public void run() {
                System.out.println(&quot;我来自 Thread。。。&quot;);
            }
        }.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200926010711647.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先创建了一个匿名内部类 Thread。传入了一个 Runnable 对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;然后重写了 Thread 的 run 方法。最后启动线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因为重写了 Thread 的 run 方法，所以它父类的 run 方法就被覆盖掉了，所以即便传入了 Runnable 对象也不会执行它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从以上的分析中，准确的讲创建线程只有一种方式那就是构造 Thread 类，而实现线程的执行单元有两种方式（run 方法的两种不同实现情况）。
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;方法一: 实现 Runnable 接口的 run 方法，并把 Runnable 实例传给 Thread 类，再让 Thread 类去执行这个 run 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法二: 重写 Thread 的 run 方法（继承 Thread 类）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;经典错误说法从本质上出发&quot;&gt;经典错误说法(从本质上出发)&lt;/h2&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;”线程池创建线程也算是一种新建线程的方式。“&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;线程池创建线程代码示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
* &amp;lt;p&amp;gt;
* 线程池创建线程的方法
* &amp;lt;/p&amp;gt;
*
* @author 踏雪彡寻梅
* @version 1.0
* @date 2020/9/7 - 23:05
* @since JDK1.8
*/
public class ThreadPools {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &amp;lt; 1000; i++) {
            // 添加任务
            executorService.submit(new Task() {});
        }
    }
}

class Task implements Runnable {
    @Override
    public void run() {
        try {
            Thread.sleep(500);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName());
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程池创建线程源码(DefaultThreadFactory 中)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3f1d2806ac3a60b60182120b0394eab1.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过线程池中的源码，可以知道线程池创建线程的方式本质上也是通过构造 Thread 的方式创建的。所以线程池创建线程的本质和上文中是一样的。所以不能简单的认为线程池也是一种新的创建线程的方式。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;”通过 Callable 和 FutureTask 创建线程，也算是一种新建线程的方式。“&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;类图展示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5f5950419bde7d035af61798f2094561.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/6acaae561ab64209293d17f595c84a22.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从类图中可以知道这两个创建线程的本质也是和之前的一样的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;”无返回值是实现 Runnable 接口，有返回值是实现 Callable 接口，所以 Callable 是新的实现线程的方式。“&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和第 2 点差不多。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定时器是新的实现线程的方式。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;定时器实现线程代码示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.Timer;
import java.util.TimerTask;

/**
* &amp;lt;p&amp;gt;
* 定时器创建线程
* &amp;lt;/p&amp;gt;
*
* @author 踏雪彡寻梅
* @version 1.0
* @date 2020/9/7 - 23:48
* @since JDK1.8
*/
public class DemoTimmerTask {
    public static void main(String[] args) {
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        }, 1000, 1000);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和前面几点一样，定时器创建线程的方法最终本质也离不开上文中的那两类方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;匿名内部类和 Lambda 表达式的方式创建线程是新的创建线程方式。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实际上也和前面几点一样是一个表面现象，本质上还是那两种方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;使用方式代码示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* &amp;lt;p&amp;gt;
* 匿名内部类创建线程
* &amp;lt;/p&amp;gt;
*
* @author 踏雪彡寻梅
* @version 1.0
* @date 2020/9/7 - 23:54
* @since JDK1.8
*/
public class AnonymousInnerClassDemo {
    public static void main(String[] args) {
        // 第一种
        new Thread() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        }.start();

        // 第二种
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        }).start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* &amp;lt;p&amp;gt;
* Lambda 表达式创建线程
* &amp;lt;/p&amp;gt;
*
* @author 踏雪彡寻梅
* @version 1.0
* @date 2020/9/7 - 23:58
* @since JDK1.8
*/
public class LambdaDemo {
    public static void main(String[] args) {
        new Thread(() -&amp;gt; System.out.println(Thread.currentThread().getName())).start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/6bd1712ca242a3bb740519c57d146bc2.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e340d301e6753926506362073334bfe2.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;总结
&lt;ul&gt;&lt;li&gt;多线程的实现方式，在代码中写法千变万化，但其本质万变不离其宗。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;常见面试问题&quot;&gt;常见面试问题&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;如有写的不足的，请见谅，请大家多多指教。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 25 Sep 2020 17:38:00 +0000</pubDate>
<dc:creator>踏雪彡寻梅</dc:creator>
<og:description>详细分析 Java 中实现多线程的方法有几种?(从本质上出发) 正确的说法(从本质上出发) 实现多线程的官方正确方法: 2 种。 Oracle 官网的文档说明 方法小结 方法一: 实现 Runnabl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/txxunmei/p/13733332.html</dc:identifier>
</item>
<item>
<title>centos 端口测试之nc使用 - 钢铁侠的知识库</title>
<link>http://www.cnblogs.com/jiba/p/13733303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiba/p/13733303.html</guid>
<description>&lt;p&gt;服务器端口测试是否正常，运维一般使用telnet来检查，但它有局限性，服务器的端口必须存在服务运行。&lt;br/&gt;这时使用nc可以在服务端模拟开启一个端口，再通过nc测试此端口，好用！&lt;br/&gt;nc是netcat工具的简称，一个网络工具，可以用来端口扫描、文件传输等功能。&lt;br/&gt;centos上面安装也很简单：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;yum install nc -y&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;nc常用功能&quot;&gt;nc常用功能&lt;/h2&gt;
&lt;p&gt;1、实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口&lt;br/&gt;2、端口的扫描，nc可以作为client发起TCP或UDP连接&lt;br/&gt;3、机器之间传输文件&lt;br/&gt;4、机器之间网络测速&lt;/p&gt;
&lt;p&gt;一般nc只用来做TCP/UDP协议的端口测试，其它功能少用！&lt;/p&gt;
&lt;h3 id=&quot;nc帮助说明&quot;&gt;nc帮助说明&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# nc --help 
Ncat 7.50 ( https://nmap.org/ncat )
Usage: ncat [options] [hostname] [port]

Options taking a time assume seconds. Append 'ms' for milliseconds,
's' for seconds, 'm' for minutes, or 'h' for hours (e.g. 500ms).
  -4                         Use IPv4 only
  -6                         Use IPv6 only
  -U, --unixsock             Use Unix domain sockets only
  -C, --crlf                 Use CRLF for EOL sequence
  -c, --sh-exec &amp;lt;command&amp;gt;    Executes the given command via /bin/sh
  -e, --exec &amp;lt;command&amp;gt;       Executes the given command
      --lua-exec &amp;lt;filename&amp;gt;  Executes the given Lua script
  -g hop1[,hop2,...]         Loose source routing hop points (8 max)
  -G &amp;lt;n&amp;gt;                     Loose source routing hop pointer (4, 8, 12, ...)
  -m, --max-conns &amp;lt;n&amp;gt;        Maximum &amp;lt;n&amp;gt; simultaneous connections
  -h, --help                 Display this help screen
  -d, --delay &amp;lt;time&amp;gt;         Wait between read/writes
  -o, --output &amp;lt;filename&amp;gt;    Dump session data to a file
  -x, --hex-dump &amp;lt;filename&amp;gt;  Dump session data as hex to a file
  -i, --idle-timeout &amp;lt;time&amp;gt;  Idle read/write timeout
  -p, --source-port port     Specify source port to use
  -s, --source addr          Specify source address to use (doesn't affect -l)
  -l, --listen               Bind and listen for incoming connections
  -k, --keep-open            Accept multiple connections in listen mode
  -n, --nodns                Do not resolve hostnames via DNS
  -t, --telnet               Answer Telnet negotiations
  -u, --udp                  Use UDP instead of default TCP
      --sctp                 Use SCTP instead of default TCP
  -v, --verbose              Set verbosity level (can be used several times)
  -w, --wait &amp;lt;time&amp;gt;          Connect timeout
  -z                         Zero-I/O mode, report connection status only
      --append-output        Append rather than clobber specified output files
      --send-only            Only send data, ignoring received; quit on EOF
      --recv-only            Only receive data, never send anything
      --allow                Allow only given hosts to connect to Ncat
      --allowfile            A file of hosts allowed to connect to Ncat
      --deny                 Deny given hosts from connecting to Ncat
      --denyfile             A file of hosts denied from connecting to Ncat
      --broker               Enable Ncat's connection brokering mode
      --chat                 Start a simple Ncat chat server
      --proxy &amp;lt;addr[:port]&amp;gt;  Specify address of host to proxy through
      --proxy-type &amp;lt;type&amp;gt;    Specify proxy type (&quot;http&quot; or &quot;socks4&quot; or &quot;socks5&quot;)
      --proxy-auth &amp;lt;auth&amp;gt;    Authenticate with HTTP or SOCKS proxy server
      --ssl                  Connect or listen with SSL
      --ssl-cert             Specify SSL certificate file (PEM) for listening
      --ssl-key              Specify SSL private key (PEM) for listening
      --ssl-verify           Verify trust and domain name of certificates
      --ssl-trustfile        PEM file containing trusted SSL certificates
      --ssl-ciphers          Cipherlist containing SSL ciphers to use
      --version              Display Ncat's version information and exit
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;nc常用案例&quot;&gt;nc常用案例&lt;/h2&gt;
&lt;h3 id=&quot;tcp监听测试&quot;&gt;TCP监听测试&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;nc可作为server端&lt;code&gt;192.168.10.11&lt;/code&gt;启动一个tcp的监听&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;nc -l 80&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;客户端测试方法：直接telnet该机器ip+端口&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;telnet 192.168.10.11 80&lt;br/&gt;或：nmap 192.168.10.11 -p 80&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;udp监听测试&quot;&gt;UDP监听测试&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;nc作为server端启动一个udp的监听&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;nc -lu 80&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过netstat可以看到udp协议已经监听：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;&amp;gt; # netstat -tunlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address   Foreign Address   State  PID/Program name   
udp        0      0 0.0.0.0:80      0.0.0.0:*                15401/nc  
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;客户端测试方法：（telnet只能测试tcp协议）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;nc -vuz 192.168.10.11 80&lt;br/&gt;（u表示udp端口，v表示可视化输出，z表示扫描时不发送数据）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用nc传输文件&quot;&gt;使用nc传输文件&lt;/h3&gt;
&lt;p&gt;使用nc传输文件不用scp或rsync那种输入密码的操作，当然也存在一定安全性。&lt;/p&gt;
&lt;p&gt;例如：要把A机器上的一个sql文件发送到B机器上&lt;br/&gt;（需要先开启侦听B机器端口，再到A机器发送数据到该端口）&lt;/p&gt;
&lt;p&gt;步骤1，先在B机器上启动一个接收文件的监听，格式如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nc -l 888 &amp;gt; zabbix.sql&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;步骤2，在A机器上往B机器的888端口发送数据，把下面sql包发送过去&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;nc 192.168.10.11 888 &amp;lt; zabbix.sql&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;也可通过nc传输目录，但这里不推荐使用，暂不举例。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;网络测试&quot;&gt;网络测试&lt;/h3&gt;
&lt;p&gt;这里也不推荐使用nc，直接使用speedtest，简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py
chmod +x speedtest-cli
./speedtest-cli
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解决telnet-无法断开问题&quot;&gt;解决telnet 无法断开问题&lt;/h3&gt;
&lt;p&gt;用&lt;code&gt;CTRL+]&lt;/code&gt;键，这时会强制退到telnet命令界面下，再输入&lt;code&gt;quit&lt;/code&gt;退出就行。&lt;/p&gt;
&lt;p&gt;----by 钢铁 648403020@qq.com&lt;/p&gt;
</description>
<pubDate>Fri, 25 Sep 2020 17:05:00 +0000</pubDate>
<dc:creator>钢铁侠的知识库</dc:creator>
<og:description>服务器端口测试是否正常，运维一般使用telnet来检查，但它有局限性，服务器的端口必须存在服务运行。 这时使用nc可以在服务端模拟开启一个端口，再通过nc测试此端口，好用！ nc是netcat工具的简</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiba/p/13733303.html</dc:identifier>
</item>
<item>
<title>利用 esp8266 搭建简单物联网项目 - 你好我叫郑某人</title>
<link>http://www.cnblogs.com/ZhengBlogs/p/esp8266_2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhengBlogs/p/esp8266_2.html</guid>
<description>&lt;p&gt;云端数据监控：DHT11 + NodeMcu +Dweet.io， 远程控制物联网设备：NodeMcu + PubSubClient + aREST， 连接OLED屏&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;130.26788708776&quot;&gt;
&lt;p&gt;接&lt;a href=&quot;https://www.cnblogs.com/ZhengBlogs/p/esp8266_1.html&quot;&gt;上一篇博客&lt;/a&gt;，这次还是关于 &lt;strong&gt;esp8266&lt;/strong&gt; --&amp;gt; &lt;strong&gt;物联网&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;接上一篇博客的接线及相关配置不变( DHT11 + NodeMcu )&lt;/li&gt;
&lt;li&gt;配置 &lt;a href=&quot;http://dweet.io/&quot;&gt;Dweet.io&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Dweet.io 是一个可以通过非常简易的方式为物联网设备提供通信服务（包括报警等）的云端平台。它不需要任何的设置或注册步骤，只要终端设备连接上互联网，即可直接发布或订阅数据。&lt;br/&gt;通过 Dweet.io 提供的云端服务，可以很方便的将传感器数据发布到在线平台并实时地进行远程监控。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;$ http -b &quot;https://dweet.io/get/dweets/for/rollingstarky&quot;
{
    &quot;by&quot;: &quot;getting&quot;,
    &quot;the&quot;: &quot;dweets&quot;,
    &quot;this&quot;: &quot;succeeded&quot;,
    &quot;with&quot;: [
        {
            &quot;content&quot;: {
                &quot;foo&quot;: &quot;bar&quot;,
                &quot;hello&quot;: &quot;world&quot;
            },
            &quot;created&quot;: &quot;2020-09-25T16:30:34.524Z&quot;,
            &quot;thing&quot;: &quot;rollingstarky&quot;
        },
        {
            &quot;content&quot;: {
                &quot;foo&quot;: &quot;bar&quot;,
                &quot;hello&quot;: &quot;world&quot;
            },
            &quot;created&quot;: &quot;2020-09-25T16:10:46.694Z&quot;,
            &quot;thing&quot;: &quot;rollingstarky&quot;
        }
    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;项目代码&lt;br/&gt;把上篇博客的数据传送到 Dweet.io 云端平台&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;ESP8266WiFi.h&amp;gt;
#include &quot;DHT.h&quot;

// WiFi parameters
const char* ssid = &quot;wifi-name&quot;;
const char* password = &quot;wifi-password&quot;;

#define DHTPIN 5

#define DHTTYPE DHT11

// Initialize DHT sensor
DHT dht(DHTPIN, DHTTYPE, 15);

const char* host = &quot;dweet.io&quot;;

void setup() {
  
  Serial.begin(115200);
  delay(10);
  
  dht.begin();

  // Connecting to a WiFi network
  Serial.println();
  Serial.println();
  Serial.print(&quot;Connecting to &quot;);
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(&quot;.&quot;);
  }

  Serial.println(&quot;&quot;);
  Serial.println(&quot;WiFi connected&quot;);  
  Serial.println(&quot;IP address: &quot;);
  Serial.println(WiFi.localIP());
}

void loop() {

  Serial.print(&quot;Connecting to &quot;);
  Serial.println(host);
  
  // Use WiFiClient class to create TCP connections
  WiFiClient client;
  const int httpPort = 80;
  if (!client.connect(host, httpPort)) {
    Serial.println(&quot;connection failed&quot;);
    return;
  }
    
  // Reading temperature and humidity
  float h = dht.readHumidity();
  float t = dht.readTemperature();
  
  while (isnan(h) || isnan(t)) {
    Serial.println(&quot;Failed to read from DHT sensor!&quot;);
    delay(2000);
    
    // Get the measurements once more
    h = dht.readHumidity(); 
    t = dht.readTemperature();
  }
  
    Serial.println();
    Serial.println(&quot;The temperature and humidity are:&quot;);
    Serial.println(t);
    Serial.println(h);
  
    // Send the request to the server
    client.print(String(&quot;GET /dweet/for/rollingstarkyesp8266?temperature=&quot;) + String(t) + &quot;&amp;amp;humidity=&quot; + String(h) + &quot; HTTP/1.1\r\n&quot; +
                 &quot;Host: &quot; + host + &quot;\r\n&quot; + 
                 &quot;Connection: close\r\n\r\n&quot;);
    unsigned long timeout = millis();
    while (client.available() == 0) {
      if (millis() - timeout &amp;gt; 5000) {
        Serial.println(&quot;&amp;gt;&amp;gt;&amp;gt; Client Timeout !&quot;);
        client.stop();
        return;
    }
  }
  
    // Read all the lines of the reply from server and print them to Serial
    while(client.available()){
      String line = client.readStringUntil('\r');
      Serial.print(line);
    }
    Serial.println();
    Serial.println(&quot;closing connection&quot;);
    Serial.println();
  
  // Repeat every 10 seconds
  delay(10000);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;访问最新更新的数据：&lt;code&gt;https://dweet.io/get/latest/dweet/for/rollingstarkyesp8266&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;{&quot;this&quot;:&quot;succeeded&quot;,&quot;by&quot;:&quot;getting&quot;,&quot;the&quot;:&quot;dweets&quot;,&quot;with&quot;:[{&quot;thing&quot;:&quot;rollingstarkyesp8266&quot;,&quot;created&quot;:&quot;2020-09-25T09:27:22.823Z&quot;,&quot;content&quot;:{&quot;temperature&quot;:28,&quot;humidity&quot;:61}}]}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;访问全部数据：&lt;code&gt;https://dweet.io/get/dweets/for/rollingstarkyesp8266&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;30&quot;&gt;
&lt;p&gt;{&quot;this&quot;:&quot;succeeded&quot;,&quot;by&quot;:&quot;getting&quot;,&quot;the&quot;:&quot;dweets&quot;,&quot;with&quot;:[{&quot;thing&quot;:&quot;rollingstarkyesp8266&quot;,&quot;created&quot;:&quot;2020-09-25T09:17:04.292Z&quot;,&quot;content&quot;:{&quot;temperature&quot;:27.9,&quot;humidity&quot;:58}},{&quot;thing&quot;:&quot;rollingstarkyesp8266&quot;,&quot;created&quot;:&quot;2020-09-25T09:15:08.961Z&quot;,&quot;content&quot;:{&quot;temperature&quot;:27.9,&quot;humidity&quot;:59}},{&quot;thing&quot;:&quot;rollingstarkyesp8266&quot;,&quot;created&quot;:&quot;2020-09-25T09:13:16.383Z&quot;,&quot;content&quot;:{&quot;temperature&quot;:27.9,&quot;humidity&quot;:58}},{&quot;thing&quot;:&quot;rollingstarkyesp8266&quot;,&quot;created&quot;:&quot;2020-09-25T09:11:30.363Z&quot;,&quot;content&quot;:{&quot;temperature&quot;:27.9,&quot;humidity&quot;:57}},{&quot;thing&quot;:&quot;rollingstarkyesp8266&quot;,&quot;created&quot;:&quot;2020-09-25T09:09:43.309Z&quot;,&quot;content&quot;:{&quot;temperature&quot;:27.9,&quot;humidity&quot;:57}}]}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;访问可视化图表：&lt;code&gt;http://dweet.io/follow/rollingstarkyesp8266&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;这里有点见鬼，出不来，单数据应该是都到云端了，可以查到 Json 数据（假装有图有真相）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2162843/202009/2162843-20200925183107322-736023562.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;链接 freeboard 平台（仪表盘）&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;注册&lt;/li&gt;
&lt;li&gt;懂点英语，稍微摸索一下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2162843/202009/2162843-20200925184332036-553973380.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.准备工具&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;aREST 框架可以为一些常见的嵌入式开发板提供 RESTful 接口，支持通过串口、Wi-Fi、以太网、蓝牙等硬件发送命令至开发板，激发特定的操作，并将数据以 JSON 的格式返回给控制端用户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;PubSubClient 库&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;源代码&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// Import required libraries
#include &amp;lt;ESP8266WiFi.h&amp;gt;
#include &amp;lt;PubSubClient.h&amp;gt;
#include &amp;lt;aREST.h&amp;gt;

// Clients
WiFiClient espClient;
PubSubClient client(espClient);

// Create aREST instance
aREST rest = aREST(client);

// Unique ID to identify the device for cloud.arest.io
char* device_id = &quot;wuwu380&quot;;

// WiFi parameters
const char* ssid = &quot;wifi-name&quot;;
const char* password = &quot;wifi-password&quot;;

// Callback functions
void callback(char* topic, byte* payload, unsigned int length);

void setup(void)
{
  // Start Serial
  Serial.begin(115200);

  // Set callback
  client.setCallback(callback);

  // Give name and ID to device
  rest.set_id(device_id);
  rest.set_name(&quot;devices_control&quot;);

  // Connect to WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(&quot;.&quot;);
  }
  Serial.println(&quot;&quot;);
  Serial.println(&quot;WiFi connected&quot;);

  // Set output topic
  char* out_topic = rest.get_topic();
}

void loop() {

  // Connect to the cloud
  rest.handle(client);
}

// Handles message arrived on subscribed topic(s)
void callback(char* topic, byte* payload, unsigned int length) {
  rest.handle_callback(client, topic, payload, length);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;运行结果&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7.682119205298&quot;&gt;
&lt;p&gt;$ http -b &lt;a href=&quot;https://cloud.arest.io/wuwu380/name&quot;&gt;https://cloud.arest.io/wuwu380/name&lt;/a&gt;&lt;br/&gt;{&lt;br/&gt;&quot;connected&quot;: true,&lt;br/&gt;&quot;hardware&quot;: &quot;esp8266&quot;,&lt;br/&gt;&quot;id&quot;: &quot;wuwu380&quot;,&lt;br/&gt;&quot;name&quot;: &quot;devices_control&quot;,&lt;br/&gt;&quot;variables&quot;: {}&lt;br/&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7.7456647398844&quot;&gt;
&lt;p&gt;$ http -b &lt;a href=&quot;https://cloud.arest.io/wuwu380/mode/5/o&quot;&gt;https://cloud.arest.io/wuwu380/mode/5/o&lt;/a&gt;&lt;br/&gt;{&lt;br/&gt;&quot;connected&quot;: true,&lt;br/&gt;&quot;hardware&quot;: &quot;esp8266&quot;,&lt;br/&gt;&quot;id&quot;: &quot;wuwu380&quot;,&lt;br/&gt;&quot;message&quot;: &quot;Pin D5 set to output&quot;,&lt;br/&gt;&quot;name&quot;: &quot;devices_control&quot;&lt;br/&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7.5438596491228&quot;&gt;
&lt;p&gt;$ http -b &lt;a href=&quot;https://cloud.arest.io/wuwu380/digital/5/1&quot;&gt;https://cloud.arest.io/wuwu380/digital/5/1&lt;/a&gt;&lt;br/&gt;{&lt;br/&gt;&quot;connected&quot;: true,&lt;br/&gt;&quot;hardware&quot;: &quot;esp8266&quot;,&lt;br/&gt;&quot;id&quot;: &quot;wuwu380&quot;,&lt;br/&gt;&quot;message&quot;: &quot;Pin D5 set to 1&quot;,&lt;br/&gt;&quot;name&quot;: &quot;devices_control&quot;&lt;br/&gt;}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我一开始就想做这个了hhh，今天先做个hello world&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;必要组件&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;U8G2 屏幕驱动库&lt;/li&gt;
&lt;li&gt;可以去 Ardunio 下载，也可以把 &lt;a href=&quot;https://wwa.lanzous.com/iYHA3gxaigd&quot;&gt;U8g2.rar&lt;/a&gt; 解压到 &lt;strong&gt;libraries&lt;/strong&gt; 文件夹&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;接线&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;| OLED | NodeMcu |&lt;br/&gt;| : - : | : - : |&lt;br/&gt;| GND | GND |&lt;br/&gt;| VCC | 3V3/5V |&lt;br/&gt;| SCL | D1 |&lt;br/&gt;| SDA | D2 |&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;载入程序&lt;br/&gt;&lt;strong&gt;文件&lt;/strong&gt; - &lt;strong&gt;示例&lt;/strong&gt; - &lt;strong&gt;U8G2&lt;/strong&gt; - &lt;strong&gt;full_buffer&lt;/strong&gt; - 任意打开一个，去除下行代码的注释&lt;br/&gt;&lt;code&gt;U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, /* clock=*/ SCL, /* data=*/ SDA, /* reset=*/ U8X8_PIN_NONE); // All Boards without Reset of the Display&lt;/code&gt;&lt;br/&gt;写入程序&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2162843/202009/2162843-20200925232632026-1932158583.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一切的学习，都是从 hello world 开始的[Doge]&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 25 Sep 2020 15:28:00 +0000</pubDate>
<dc:creator>你好我叫郑某人</dc:creator>
<og:description>云端数据监控：DHT11 + NodeMcu +Dweet.io， 远程控制物联网设备：NodeMcu + PubSubClient + aREST， 连接OLED屏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhengBlogs/p/esp8266_2.html</dc:identifier>
</item>
<item>
<title>树的基本概念 - 不二尘</title>
<link>http://www.cnblogs.com/chenpt/p/13728973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenpt/p/13728973.html</guid>
<description>&lt;h2&gt;树：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;树是一种递归数据结构，包含一个或多个数据节点的集合，其中一个节点被指定为树的根节点，而其余节点被称为根的子节点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;除根节点以外的其他节点均被划分为多个非空集，其中每个空集都称为子树。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;树的节点或者在它们之间保持父子关系，或者它们是姐妹节点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在一般树中，一个节点可以有任意数量的子节点，但只能有一个父节点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;下图显示了一棵树，其中节点A是树的根节点，而其他节点可以看作是A的孩子。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326194/202009/1326194-20200925142859042-697159826.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2 class=&quot;h2&quot;&gt;&lt;span&gt;基本术语&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;根节点&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;-根节点是树层次结构中的最高节点。换句话说，根节点是没有任何父节点的节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子树&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;-如果根节点不为空，则树T1，T2和T3被称为根节点的子树。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶子节点&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;-没有任何子节点的树的节点称为叶子节点。&lt;/span&gt;&lt;span&gt;叶节点是树的最底部节点。&lt;/span&gt;&lt;span&gt;普通树中可以有任意数量的叶节点。&lt;/span&gt;&lt;span&gt;叶节点也可以称为外部节点。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;程度&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;-节点的程度等于节点具有的子代数。&lt;/span&gt;&lt;span&gt;在上图所示的树中，节点B的度为2。叶节点的度始终为0，而​​在完整的二叉树中，每个节点的度均等于2。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二叉树：&lt;/h2&gt;
&lt;p&gt;每个节点最多有2个节点的树；&lt;/p&gt;
&lt;h2 class=&quot;h2&quot;&gt;&lt;span&gt;二叉树的类型&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;h3&quot;&gt;&lt;span&gt;1.严格二叉树&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;每个非叶节点都包含非空的左右子树&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326194/202009/1326194-20200925144757997-1863522460.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3 class=&quot;h3&quot;&gt;&lt;span&gt;2.满二叉树（特殊的完全二叉树）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;所有的叶子节点都位于同一级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326194/202009/1326194-20200925144926421-7840093.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;二叉排序树：&lt;/h2&gt;
&lt;p&gt;二叉树的基础上满足如下特性则为二叉排序树；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若它的左子树不为空，则左子树的所有节点的值均小于它的根节点。&lt;/li&gt;
&lt;li&gt;若它的右子树不为空，则右子树的所有节点的值均大于它的根节点。&lt;/li&gt;
&lt;li&gt;它的左右子树也分别为二叉排序树。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326194/202009/1326194-20200925145325480-302127608.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 优点：&lt;/h2&gt;
&lt;ol class=&quot;points&quot;&gt;&lt;li&gt;&lt;span&gt;在二叉搜索树中搜索变得非常有效，因为我们在每一步都得到了提示，即哪个子树包含所需的元素。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;与数组和链表相比，二进制搜索树被认为是有效的数据结构。&lt;/span&gt;&lt;span&gt;在搜索过程中，它会在每个步骤中删除一半的子树。&lt;/span&gt;&lt;span&gt;在二叉搜索树中搜索元素需要o（log &lt;/span&gt;&lt;/span&gt;&lt;sub&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;&lt;span&gt;&lt;span&gt; n）时间。&lt;/span&gt;&lt;span&gt;在最坏的情况下，搜索元素所需的时间为0（n）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;与数组和链表中的插入和删除操作相比，它还加快了插入和删除操作的速度。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;二叉平衡树（AVL）：&lt;/h2&gt;
&lt;p&gt;所有节点的左右子树的高度差小于1的二叉排序树；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326194/202009/1326194-20200925150432991-1989083917.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;B树：&lt;/h2&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;Ｂ树出现是因为磁盘ＩＯ。ＩＯ操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘ＩＯ操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。&lt;/strong&gt;&lt;br/&gt;　　所以，我们为了减少磁盘ＩＯ的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B 树又叫平衡多路查找树。一棵m阶的B 树 (m叉树)的特性如下：&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ol class=&quot;points&quot;&gt;&lt;li&gt;&lt;span&gt;根节点必须至少含有2个节点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;除了根节点和叶节点之外，B树中的每个节点至少包含m / 2个子节点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;B树中的每个节点最多包含m个子节点&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有叶节点必须处于同一级别。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;下图显示了4阶AB树。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326194/202009/1326194-20200925155131342-1984066028.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;h2&gt;B+树：&lt;/h2&gt;
&lt;p&gt;B +树是B树的扩展，它允许有效的插入，删除和搜索操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在B树中，键和记录都可以存储在内部节点和叶节点中。&lt;/span&gt;&lt;span&gt;而在B +树中，记录（数据）只能存储在叶节点上，而内部节点只能存储键值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B +树的叶节点以单链接列表的形式链接在一起，以使搜索查询更高效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B +树用于存储无法存储在主存储器中的大量数据。&lt;/span&gt;&lt;span&gt;由于总是限制主存储器的大小，因此B +树的内部节点（访问记录的键）存储在主存储器中，而叶节点存储在辅助存储器中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;B +树的内部节点通常称为索引节点。&lt;/span&gt;&lt;span&gt;下图显示了3级的B +树。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326194/202009/1326194-20200925160728216-1276986419.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h2 class=&quot;h2&quot;&gt;&lt;span&gt;B +树的优势&lt;/span&gt;&lt;/h2&gt;
&lt;ol class=&quot;points&quot;&gt;&lt;li&gt;&lt;span&gt;可以以相同数量的磁盘访问来获取记录。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;与B树相比，树的高度保持平衡并且较小。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;我们可以依次或直接访问存储在B +树中的数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;键用于索引。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于数据仅存储在叶节点上，因此搜索查询速度更快。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 class=&quot;h2&quot;&gt;&lt;span&gt;B树VS B +树&lt;/span&gt;&lt;/h2&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td&gt;SN&lt;/td&gt;
&lt;td&gt;B树&lt;/td&gt;
&lt;td&gt;B +树&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;1个&lt;/td&gt;
&lt;td&gt;搜索键不能重复存储。&lt;/td&gt;
&lt;td&gt;可能存在冗余搜索键。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;数据可以存储在叶节点以及内部节点中&lt;/td&gt;
&lt;td&gt;数据只能存储在叶节点上。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;搜索一些数据的过程较慢，因为可以在内部节点以及叶节点上找到数据。&lt;/td&gt;
&lt;td&gt;由于只能在叶节点上找到数据，因此搜索相对较快。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;内部节点的删除是如此复杂且耗时。&lt;/td&gt;
&lt;td&gt;删除绝不会是一个复杂的过程，因为元素总是会从叶节点中删除。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;叶节点不能链接在一起。&lt;/td&gt;
&lt;td&gt;叶节点链接在一起，使搜索操作更高效。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h2&gt;红黑树：&lt;/h2&gt;
&lt;p&gt; 红黑树是一棵二叉搜索树，它在每个节点上增加了一个存储位来表示节点的颜色，可以是Red或Black。&lt;/p&gt;
&lt;p&gt;通过对任意一条从根到叶子的简单路径上各个节点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，因而是近似平衡的。&lt;/p&gt;
&lt;h3&gt;特性：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;每个节点要么是红色，要么是黑色。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;根节点是黑色。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;叶子节点是黑色。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;相邻的两个节点不能同时位红色。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;任意节点到其所有后代叶子节点的路径上，都包含相同数目的黑色节点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;插入的节点一定是红色。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1326194/202009/1326194-20200925221213390-534465719.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 从某个节点x出发（不含该节点）到达一个叶节点的任意一条简单路径上的黑色节点个数成为该节点的&lt;strong&gt;黑高；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; （以上如有错误或理解不到位地方欢迎指正）&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
</description>
<pubDate>Fri, 25 Sep 2020 14:28:00 +0000</pubDate>
<dc:creator>不二尘</dc:creator>
<og:description>树： 树是一种递归数据结构，包含一个或多个数据节点的集合，其中一个节点被指定为树的根节点，而其余节点被称为根的子节点。 除根节点以外的其他节点均被划分为多个非空集，其中每个空集都称为子树。 树的节点或</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenpt/p/13728973.html</dc:identifier>
</item>
</channel>
</rss>