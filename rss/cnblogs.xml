<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>CF538B Quasi Binary 思维题 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/13776224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/13776224.html</guid>
<description>&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给出一个数 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，你需要将 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 写成若干个数的和，其中每个数的十进制表示中仅包含&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;问最少需要多少个数&lt;/p&gt;
&lt;h2 id=&quot;输入输出格式&quot;&gt;输入输出格式&lt;/h2&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;输入格式：&lt;/h3&gt;
&lt;p&gt;一行 一个数 &lt;span class=&quot;math inline&quot;&gt;\(n(1≤n≤10^6)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;输出格式：&quot;&gt;输出格式：&lt;/h3&gt;
&lt;p&gt;最少的数的个数，并给出一种方案。&lt;/p&gt;
&lt;h2 id=&quot;输入输出样例&quot;&gt;输入输出样例&lt;/h2&gt;
&lt;h3 id=&quot;输入-1&quot;&gt;输入 #1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;输出-1&quot;&gt;输出 #1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;9&lt;br/&gt;1 1 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;输入-2&quot;&gt;输入 #2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;32&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;输出-2&quot;&gt;输出 #2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;3&lt;br/&gt;10 11 11&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;很显然，对于任何一个数，我们把它分成只包含 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的数字，这样的最小划分数一定不大于 &lt;span class=&quot;math inline&quot;&gt;\(9\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此在划分的过程中一定不会出现借位的情况&lt;/p&gt;
&lt;p&gt;因为如果出现借位的情况，那么要想把借的那一位消去，至少需要 &lt;span class=&quot;math inline&quot;&gt;\(10\)&lt;/span&gt; 次操作&lt;/p&gt;
&lt;p&gt;所以对于当前的数,我们可以存一下每一位能划分出多少 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后按照划分出 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的个数从小到大排一下序&lt;/p&gt;
&lt;p&gt;如果当前的个数不为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;,那么我们就从当前这一位开始一直到最后都减去当前的个数&lt;/p&gt;
&lt;p&gt;这样到最后，所有位上的数量都会变成 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析-2&quot;&gt;分析&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
const int maxn=15;
struct asd{
        int num,id;
        asd(){}
        asd(int aa,int bb){
                num=aa,id=bb;
        }
}b[maxn];
bool cmp(asd aa,asd bb){
        return aa.num&amp;lt;bb.num;
}
int n,cnt,sta[maxn],top;
int main(){
        scanf(&quot;%d&quot;,&amp;amp;n);
        int cs=1;
        while(n){
                b[++cnt]=asd(n%10,cs);
                n/=10;
                cs*=10;
        }
        std::sort(b+1,b+1+cnt,cmp);
        int head=1;
        while(head&amp;lt;=cnt){
                int now=0;
                while(b[head].num==0 &amp;amp;&amp;amp; head&amp;lt;=cnt) head++;
                for(int i=head+1;i&amp;lt;=cnt;i++){
                        now+=b[i].id;
                        b[i].num-=b[head].num;
                }
                now+=b[head].id;
                for(int i=1;i&amp;lt;=b[head].num;i++){
                        sta[++top]=now;
                }
                b[head].num=0;
        }
        printf(&quot;%d\n&quot;,top);
        for(int i=1;i&amp;lt;=top;i++){
                printf(&quot;%d &quot;,sta[i]);
        }
        printf(&quot;\n&quot;);
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 06 Oct 2020 23:16:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>题目描述 给出一个数 \(n\)，你需要将 \(n\) 写成若干个数的和，其中每个数的十进制表示中仅包含$0$和$1$。 问最少需要多少个数 输入输出格式 输入格式： 一行 一个数 \(n(1≤n≤1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/13776224.html</dc:identifier>
</item>
<item>
<title>Hyper-V Server + Windows Admin Center - HOYU_Z</title>
<link>http://www.cnblogs.com/hoyu/p/Hyper-V-Server-Windows-Admin-Center.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hoyu/p/Hyper-V-Server-Windows-Admin-Center.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;2020年的十一黄金周是双节，偶然间得知再出现双节可能要几十年之后了，很可惜我并没有出去游玩的打算。所以假期没什么事，就来研究下Hyper Server + Windows Admin Center。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前就搭建过自己的NAS服务器，实现方式是一台PVE+LEDE+虚拟机若干。当时选择这个方案的原因是因为，PVE的资源占用非常少，还可以Web管理，使用起来总比一台Win10/Windows Server+各种虚拟机的方案要清爽一些。&lt;/p&gt;
&lt;p&gt;但使用以上方案也是没有办法的办法，这样做其实有另一个问题是这个方案的移动性是非常差的，如果我要用到这个环境里的某个虚拟机就必须带着整台电脑走。&lt;/p&gt;
&lt;p&gt;偶然间看到巨硬（微软）也有类似于ESXI的技术方案：Hyper-V Server+Windows Admin Center。&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;无论你是软件开发人员、IT 专业人员还是技术爱好者，你们中的许多人都需要运行多个操作系统。 Hyper-V 让你可以在 Windows 上以虚拟机形式运行多个操作系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说白了Hyper-V就是微软自己的虚拟技术，可以运行多个虚拟机，当然对自家的Windows支持是最好的，不过Linux也不差。&lt;/p&gt;
&lt;p&gt;值得说的一点是，在使用Hyper-V的时候，如果资源分配的合理，几乎感受不到的他的存在，不像VMWare那样关机要等好半天。&lt;/p&gt;
&lt;p&gt;另外就是我个人比较喜欢他的虚拟交换机，配置起来通俗易懂。&lt;/p&gt;
&lt;p&gt;在了解到Hyper-V Server 之前我觉得这个完意有一个致命的问题就是我必须得装一台Windows10 pro才可以愉快的玩耍。然而Windows占用的资源对我来说毫无价值，完全浪费。&lt;/p&gt;
&lt;p&gt;所以，如果Hyper-V能像ESXI那样安装在电脑上只有一个虚拟机运行软件的话， 就非常完美，显然Hyper-V Server就是这个完意了。&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://www.microsoft.com/zh-cn/evalcenter/evaluate-hyper-v-server-2019&quot;&gt;Hyper-V Server 2019下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hyper-V Server的安装和系统安装一样。我用Rufus将下载的镜像烧进U盘作为启动盘，接下来就正常安装步骤了。&lt;/p&gt;
&lt;p&gt;安装完之后，画面非常简洁只有两个命令行 ， 是的，它没有GUI ：）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/HoYu/blog-images/raw/master/img/20201006155424.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Windows Admin Center 是一个在本地部署的基于浏览器的新管理工具集，让你能够管理 Windows Server，而无需依赖 Azure 或云。 利用 Windows Admin Center，你可以完全控制服务器基础结构的各个方面，对于在未连接到 Internet 的专用网络上管理服务器特别有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官网说这个玩意可以通过Web像Hyper-V管理器一样管理虚拟机。可以安装在Windows10、Windows Server、Windows Server Core上。&lt;/p&gt;
&lt;p&gt;机缘巧合，在一个论坛里看到曾有人讨论过，是否可以在Hyper-V Server上安装Windows Admin Center。看了好多博客，感觉这是一个可行性很高的方案，可以玩一玩。&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://www.microsoft.com/en-us/evalcenter/evaluate-windows-admin-center&quot;&gt;Windows Admin Center 下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只有命令行我应该怎么下载呢？于是只能用最传统的方式在另一台电脑下载软件到U盘里，然后插到Hyper-V Server上用命令行安装就行了。&lt;br/&gt;以下是安装命令，具体说明可以&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows-server/manage/windows-admin-center/deploy/install&quot;&gt;参见官网&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;msiexec /i &amp;lt;WindowsAdminCenterInstallerName&amp;gt;.msi /qn /L*v log.txt SME_PORT=&amp;lt;port&amp;gt; SSL_CERTIFICATE_OPTION=generate

//我设置的商品号是6515，然后用另一台电脑访问https://{ServerIP}:6515，访问成功。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/HoYu/blog-images/raw/master/img/20201006144040.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;装完后，我意识到，应该可以不用U盘传安装文件的，在命令行中设置共享文件夹应该就可以了吧。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;简单熟悉这个完意后，安装虚拟机的操作方式大致一样，可以通过Web上传镜像，然后安装。&lt;/p&gt;
&lt;p&gt;这里要说的是，整个安装过程中确实没有PVE操作方便，不过也无伤大雅，并且官方文档也说了，WAC暂时并不能取代Hyper-V管理工具。&lt;/p&gt;
&lt;p&gt;需要用的虚拟机安装完之后，开始组网，当然还是我比较喜欢的独臂路由，利用虚拟交换机创建两块虚拟网卡。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;内部网络：用于连接LEDE与各个虚拟机。&lt;/li&gt;
&lt;li&gt;外部网络：让LEDE连接外网。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;新建的网卡都要开启MAC欺骗&lt;/strong&gt;，这么做的具体原因我也不太明白，只记得之前就是这样搭建的，另外为LEDE接入这两个网卡时，应该先接&lt;strong&gt;内部&lt;/strong&gt;再接&lt;strong&gt;外部&lt;/strong&gt;。大概结构如下图，但真正的结构和这个还是有点区别的，这个下面再说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/HoYu/blog-images/raw/master/img/20201007003043.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建外部网络的时候有个选项&lt;strong&gt;允许管理操作系统共享此网络适配器&lt;/strong&gt;，这个完意我的建议是还是勾选上比较好，必竟如果LEDE崩了的话还可以通过远程方式来解决，不然就只有去角落里打开这台电脑解决了。&lt;/p&gt;
&lt;p&gt;我这里踩的坑就比较搞笑了，我给LEDE接完虚拟网卡后，没有测试就想当然的把允许管理操作系统共享此网络适配器的选项取掉了。结果Hyper-V Server失控了，失控的原因也比较好理解，LEDE中没映射对应的端口。&lt;/p&gt;
&lt;p&gt;我当时的解决方法也比较愚蠢，打开电脑用PowerShell删除所有虚拟网卡后，重新创建上面的两张网卡。现在想如果SSH到LEDE后添加一个端口映射就好了。&lt;/p&gt;
&lt;p&gt;所以如果勾选上面的选项的话,我们是可以通过路由器直接访问Hyper-V Server的，结构如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/HoYu/blog-images/raw/master/img/20201007003359.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写这篇博客也是波折多多，我也来学学知乎上的朋友们复盘一下整个过程。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;博客内容是放在GitHub上的，不想这些内容出现在我的电脑里，所以放在了Hyper-V Server下的Ubuntu里。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;VS Code远程到Ubuntu上写内容没什么问题，但在使用VIM插件的时候每次退出编辑模式之后，输入法依然保留在中文状态，所以下载了im-select.exe并为VS Code添加如下配置：
&lt;pre&gt;
&lt;code&gt;  &quot;vim.autoSwitchInputMethod.enable&quot;: true,
  &quot;vim.autoSwitchInputMethod.defaultIM&quot;: &quot;1033&quot;, //1033对应的输入法是英文
  &quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;: &quot;C:\\Users\\hoyu_\\AppData\\im-select.exe&quot;,
  &quot;vim.autoSwitchInputMethod.switchIMCmd&quot;: &quot;C:\\Users\\hoyu_\\AppData\\im-select.exe {im}&quot;,
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;发现我的七牛云图床不能用了，又在Gitee重新搭建了个图床。&lt;/li&gt;
&lt;li&gt;VS Code序列图插件PlantUML需要所在环境有Java JDK，预览要装PlantUML Previewer。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 06 Oct 2020 17:04:00 +0000</pubDate>
<dc:creator>HOYU_Z</dc:creator>
<og:description>Hyper-V Server + Windows Admin Center</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hoyu/p/Hyper-V-Server-Windows-Admin-Center.html</dc:identifier>
</item>
<item>
<title>学习从拥有一支好笔开始 - 不作声</title>
<link>http://www.cnblogs.com/bzsheng/p/13776017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bzsheng/p/13776017.html</guid>
<description>&lt;p&gt;有段时间没有更新内容，思前想后还是觉得应该整理分类文章，决定了接下来的文章思路。语文一直是比较差的，上学期间也都是勉强及格，所以可能可读性较差，但会尽量通过一些别的方式提高可读性，在漫长的文章路上提高自己的文笔。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工欲善其事，必先利其器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个合格的程序员，必须会使用一些工具，来使自己学习工作变得舒服流畅，从而给自己一个正反馈的效果。&lt;/p&gt;
&lt;p&gt;程序员必会工具、插件系列：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码编辑器；&lt;/li&gt;
&lt;li&gt;命令行命令；&lt;/li&gt;
&lt;li&gt;版本控制工具；&lt;/li&gt;
&lt;li&gt;浏览器调试知识；&lt;/li&gt;
&lt;li&gt;Markdown编辑器；&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以该系列的文章主要是一些工具之类，让自己码的舒服。同时也希望读者(主要是萌新小白)会有良好的编码习惯，久而久之，敲代码将会变成一件令人愉悦的事情。&lt;/p&gt;
&lt;h2 id=&quot;代码编辑器&quot;&gt;代码编辑器&lt;/h2&gt;
&lt;p&gt;现在流行的代码编辑器有很多，我们应当是根据业务需求选择语言，根据语言选择编译器。按道理来讲，只要可以输入文本就可以写代码，起初人们就是使用记事本来写代码的。但是不同编译器的出现就是为了解决各种不方便的事情，使写代码变得方便更高效，所以我们应当选择合适的代码编辑器。&lt;/p&gt;
&lt;p&gt;我使用的是&lt;strong&gt;VScode+vim插件&lt;/strong&gt;，所以放在第一个介绍，官网：&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;https://code.visualstudio.com/&lt;/a&gt;。VScode功能很丰富，可以自定义配置，同时下载不同的语言插件，就可以使用不同的语言编程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/bzsheng/p/vscode.png&quot; alt=&quot;vscode界面&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左侧有文件目录，插件，github连接，远程编程，docker等功能，功能齐全。由于是自己使用，所以会再专门写一篇文章介绍一些插件及其使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vim和Emacs&lt;/strong&gt;是类Vi文本编辑器的两个派系。Vim最大的优势是它最常用的命令都是简单的字符，比起组合控制键要快很多，极大程度减少了鼠标的使用时间。Emacs也是著名的集成开发环境和文本编辑器，它的快捷键也很方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jetbrains全家桶&lt;/strong&gt;，地址：&lt;a href=&quot;https://www.jetbrains.com/zh-cn/&quot;&gt;https://www.jetbrains.com/zh-cn/&lt;/a&gt;。不同的语言可以选择不同的软件，如最常用的java使用IDEA，Python使用PC（PyChram），go使用GoLand等。这里就不得不diss一下某种用PyChram写nodejs项目的行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Visual Studio&lt;/strong&gt;，微软集成开发环境，包括了整个软件生命周期中所需要的大部分工具，如UML工具，代码管控工具等等。&lt;/p&gt;
&lt;p&gt;还有其他很多的代码编辑器，如&lt;strong&gt;sublime，Notepad&lt;/strong&gt;等，不多介绍，其他编辑器可以查阅文档资料使用。&lt;/p&gt;
&lt;h2 id=&quot;命令行命令&quot;&gt;命令行命令&lt;/h2&gt;
&lt;p&gt;命令行命令有各种用途的，除了系统自带的，还有很多项目通过命令行命令启动，数据库SQL语句等。&lt;/p&gt;
&lt;p&gt;生活中Windows系统较多，开发中项目多在Linux系统中运行。不同操作系统的命令行命令也有差别。&lt;/p&gt;
&lt;p&gt;我的电脑是win10系统，服务器是Linux系统，而且在云服务器没有界面，只有命令行，查看服务器性能空间等，全都需要使用命令行。&lt;/p&gt;
&lt;p&gt;在Github添加work flow也需要使用Github Actions，在yaml文件中添加命令行。&lt;/p&gt;
&lt;p&gt;项目启动命令如，&lt;code&gt;npm run dev&lt;/code&gt;或者是&lt;code&gt;scrapy crawl&lt;/code&gt;等。&lt;/p&gt;
&lt;h2 id=&quot;版本控制工具&quot;&gt;版本控制工具&lt;/h2&gt;
&lt;p&gt;版本控制工具的目的是为了&lt;strong&gt;记录和跟踪项目中各文件内容的修改变化&lt;/strong&gt;。使用版本控制工具，可以做数据备份，提高代码质量，提高多人开发时的效率，明确分工责任等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最常用的版本控制工具是Git&lt;/strong&gt;。Git是一个免费的开源分布式版本控制系统，旨在高效快速的处理从小型到大型项目的所有事务。使用GIt，可以将代码托管到远程Github代码仓库，十分的方便，这是一个程序员必须掌握的内容，同时也可以根据Github中的代码量来衡量一个人的工作经验。&lt;/p&gt;
&lt;p&gt;TortoiseSVN是一款集中式版本控制工具，采用分支管理系统的高效管理，简而言之就是用于多个人共同开发一个项目，实现共享资源，实现最终集中式的管理。&lt;/p&gt;
&lt;h2 id=&quot;浏览器调试知识&quot;&gt;浏览器调试知识&lt;/h2&gt;
&lt;p&gt;浏览器调试针对web端应用，在浏览器中的&lt;strong&gt;开发者工具&lt;/strong&gt;中。我使用的是Chrome浏览器，使用&lt;code&gt;Ctrl+Shift+i&lt;/code&gt;进入开发者调试面板。&lt;/p&gt;
&lt;p&gt;开发者调试有多个面板，如Element、Console、Network等，对应不同的内容。该部分内容有一篇专门的文章。&lt;/p&gt;
&lt;h2 id=&quot;markdown&quot;&gt;Markdown&lt;/h2&gt;
&lt;p&gt;Markdown是一种轻量级标记语言，应用场景也很多，最主要的就是项目的README文件和博文。&lt;/p&gt;
&lt;p&gt;Markdown有自己的语法格式，对图片，图表，表达式等都有支持，所以得到各种网站的广泛使用。&lt;/p&gt;
&lt;p&gt;md文件的编辑器也有很多，也可以在记事本操作，使用md语法写完文本，更改文件后缀。&lt;/p&gt;
&lt;p&gt;我使用的是&lt;strong&gt;Typora&lt;/strong&gt;，地址：&lt;a href=&quot;https://www.cnblogs.com/bzsheng/p/typora.io&quot;&gt;typora.io&lt;/a&gt;。这是一款免费的、支持实时预览的Markdown文本编辑器。Typora界面简洁，是我最喜欢它的一点，同时在偏好设置中可以增加自己编辑体验，有多种主题可以选择。&lt;/p&gt;
&lt;p&gt;选择打字机模式，使得自己正在编辑的一行永远处在屏幕正中间；选择专注模式，使得自己编辑的一行保留颜色，其他行全部为灰色。&lt;/p&gt;
&lt;p&gt;在插入图片时，可以在本地保存一份备份，将文章push到Github时，图片也会一起push。&lt;/p&gt;
&lt;p&gt;Typora还支持emoji表情，可以使用&lt;code&gt;:emoji:&lt;/code&gt;的方式加入emoji表情😂。&lt;/p&gt;
&lt;p&gt;关注公众号&lt;strong&gt;前端大合集&lt;/strong&gt;看更多文章。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Oct 2020 15:52:00 +0000</pubDate>
<dc:creator>不作声</dc:creator>
<og:description>工欲善其事必先利其器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bzsheng/p/13776017.html</dc:identifier>
</item>
<item>
<title>Shiro入门学习---使用自定义Realm完成认证|练气中期 - 赖柄沣</title>
<link>http://www.cnblogs.com/bingfengdev/p/13775968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingfengdev/p/13775968.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;https://www.cnblogs.com/bingfengdev/p/13768829.html&quot;&gt;《shiro认证流程源码分析--练气初期》&lt;/a&gt;当中，我们简单分析了一下shiro的认证流程。不难发现，如果我们需要使用其他数据源的信息完成认证操作，我们需要自定义Realm继承AuthorizingRealm类，并实现两个方法，分别对应授权和认证。&lt;/p&gt;
&lt;p&gt;在这一篇文章当中，我们将介绍如何自定义Realm对象，完成认证信息数据源的切换。&lt;/p&gt;
&lt;h2 id=&quot;自定义reaml&quot;&gt;自定义Reaml&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**自定义Realm对象
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/10/4 11:00
 */
public class MySqlRealm extends AuthorizingRealm {

    /**授权，今天暂不实现
     * @author 赖柄沣 bingfengdev@aliyun.com
     * @date 2020-10-04 11:01:50
     * @param principalCollection
     * @return org.apache.shiro.authz.AuthorizationInfo
     * @throws AuthenticationException
     * @version 1.0
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {

        return null;
    }

    /**认证
     * @author 赖柄沣 bingfengdev@aliyun.com
     * @date 2020-10-04 11:01:50
     * @param authenticationToken
     * @return org.apache.shiro.authz.AuthorizationInfo
     * @throws AuthenticationException
     * @version 1.0
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        // 1. 从token中获取用户名
        String principal = (String) authenticationToken.getPrincipal();

        //2. 根据用户名查询数据库(模拟)
        if (principal == &quot;xiangbei&quot;) {
            AuthenticationInfo authInfo = new SimpleAuthenticationInfo(&quot;xiangbei&quot;,&quot;123&quot;,this.getName());
            return authInfo;
        }
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在认证器中使用自定义realm进行认证&quot;&gt;在认证器中使用自定义Realm进行认证&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**认证管理器
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/10/4 11:11
 */
public class CurrentSystemAuthenticator {
    private DefaultSecurityManager securityManager;
    public CurrentSystemAuthenticator() {
        //创建安全管理器
        securityManager = new DefaultSecurityManager();

        //设置自定义realm
        this.securityManager.setRealm(new MySqlRealm());

        //将安全管理器设置到安全工具类中
        SecurityUtils.setSecurityManager(securityManager);

    }

    public void authenticate(String username,String password){
        //获取当前登录主题
        Subject subject = SecurityUtils.getSubject();

        //生成toeken
        UsernamePasswordToken token = new UsernamePasswordToken(username, password);

        //进行认证
        try {
            subject.login(token);
        }catch (UnknownAccountException | IncorrectCredentialsException e) {
            System.out.println(&quot;用户名或密码不正确&quot;);
        }


        //打印认证状态
        if (subject.isAuthenticated()){
            System.out.println(token.getPrincipal()+&quot; 认证通过！&quot;);
        }else {
            System.out.println(token.getPrincipal()+&quot; 认证未通过！&quot;);
        }


    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进行测试&quot;&gt;进行测试&lt;/h2&gt;
&lt;h3 id=&quot;认证通过的情况&quot;&gt;认证通过的情况&lt;/h3&gt;
&lt;h4 id=&quot;用例代码&quot;&gt;用例代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;/**测试认证
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/9/21 0:49
 */
public class TestAuthenticator {
    private  Authenticator authenticator=null;

    @Before
    public void init() {
        authenticator = new Authenticator();
    }

    @Test
    public void testAuth(){

        authenticator.authenticate(&quot;xiangbei&quot;,&quot;123&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;输出&quot;&gt;输出&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;xiangbei 认证通过！
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;认证不通过的情况&quot;&gt;认证不通过的情况&lt;/h3&gt;
&lt;p&gt;认证不通过的情况在shiro当中分为几种情况，具体可以查看我的上一篇文章&lt;a href=&quot;https://juejin.im/post/6879409669224267783&quot;&gt;《shiro认证流程源码分析--练气初期》&lt;/a&gt; 关于shiro认证异常的分析，常用的有如下几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;账户不正确（不存在）&lt;/li&gt;
&lt;li&gt;密码错误&lt;/li&gt;
&lt;li&gt;账户被锁定&lt;/li&gt;
&lt;li&gt;密码过期&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在实际项目中为了安全起见，账户不正确和密码错误统一返回“用户名或密码不正确”类似的的提示，避免造成账户泄露。&lt;/p&gt;
&lt;p&gt;下面针对这种情况给予演示&lt;/p&gt;
&lt;h4 id=&quot;用例代码-2&quot;&gt;用例代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/10/4 11:20
 */
public class AuthcTest {
    private CurrentSystemAuthenticator authenticator;
    @Before
    public void init() {
        this.authenticator = new CurrentSystemAuthenticator();
    }

    @Test
    public void testAuthc(){
        this.authenticator.authenticate(&quot;xiangbei&quot;,&quot;13&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;输出-2&quot;&gt;输出&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;用户名或密码不正确
xiangbei 认证未通过！
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;这一篇文章主要是带领大家了解一下如何通过自定义Realm对象完成shiro认证数据源的切换。对于MySQL的集成，我们将在后面的文章当中集成SpringBoot时介绍。&lt;/p&gt;
&lt;p&gt;下一篇文章将简单介绍shiro中的密码加密以及如何配置使用。&lt;/p&gt;
&lt;p&gt;本文所涉及的代码下载地址：&lt;a href=&quot;https://github.com/code81192/art-demo/tree/master/shiro-authc-mysql&quot;&gt;https://github.com/code81192/art-demo/tree/master/shiro-authc-mysql&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Oct 2020 15:31:00 +0000</pubDate>
<dc:creator>赖柄沣</dc:creator>
<og:description>写在前面 在上一篇文章《shiro认证流程源码分析--练气初期》当中，我们简单分析了一下shiro的认证流程。不难发现，如果我们需要使用其他数据源的信息完成认证操作，我们需要自定义Realm继承Aut</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingfengdev/p/13775968.html</dc:identifier>
</item>
<item>
<title>python单元测试框架pytest - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/13773717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/13773717.html</guid>
<description>&lt;p&gt;首先祝大家国庆节日快乐，这个假期因为我老婆要考注会，我也跟着天天去图书馆学了几天，学习的感觉还是非常不错的，这是一篇总结。&lt;/p&gt;

&lt;p&gt;这篇博客准备讲解一下pytest测试框架，这个框架是当前最流行的python语言最流行的单测框架，不掌握可不行，首先这个框架属于第三方模块，需要通过pip安装即可&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
pip install pytest
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我们进入正题&lt;/p&gt;
&lt;h3&gt;一、介绍pytest的运行规则&lt;/h3&gt;
&lt;p&gt;1、测试文件的名称必须要以test_*.py的格式，或者*_test.py的格式&lt;/p&gt;
&lt;p&gt;2、测试类的名称必须要以Test开头，且这个类还不能有构造方法（__init__）&lt;/p&gt;
&lt;p&gt;3、测试函数的名称必须要以test开头&lt;/p&gt;

&lt;p&gt;pytest默认的就按照上面的三条规则来执行案例，当然我们可以自定义运行规则，这个我们后面在讲，这个不重要，看一个最简单的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import os
import pytest

# pytest是python的单元测试框架

def func(x):
    return x + 1


def test_a():
    print(&quot;____test_a____&quot;)
    assert func(2) == 5

def test_b():
    print(&quot;____test_b____&quot;)
    assert func(2) == 3

if __name__ == '__main__':
    pytest.main([&quot;-s&quot;,&quot;pytest1.py&quot;])
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二、介绍pytest的前置条件和后置条件，类似unittest的testfixture（测试固件）&lt;/h3&gt;
&lt;p&gt;如果同学们之前用过unittest测试框架，对测试固件这个这个名词就不会陌生了，如果不清楚，可以看下之前我写的unittest测试框架的博客（https://www.cnblogs.com/bainianminguo/p/11616526.html）&lt;/p&gt;
&lt;p&gt;pytest框架的测试固件有两种，一种函数级别的，一种是类级别，执行的顺序如下&lt;/p&gt;
&lt;p&gt;a、执行类的前置条件&lt;/p&gt;
&lt;p&gt;b、执行函数的前置条件&lt;/p&gt;
&lt;p&gt;c、执行函数的后置条件&lt;/p&gt;
&lt;p&gt;d、执行类的后置条件&lt;/p&gt;

&lt;p&gt;使用也非常简单，当时函数的命名一定要和我下面的备注保持完全一致&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# pytest的前置和后置条件

# 1、函数级别  setup  teardown
# 运行于测试方法的开始和结束
# 运行一个测试用例，会运行一次setup和teardown

# 2、类级 setup_class    teardown_class
# 运行于测试类的开始和结束
# 一个测试类只运行一次setup_class  teardown_class
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;1、函数式的案例--函数级别的前置条件&amp;amp;后置条件　&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import os
import pytest

def func(x):
    return x + 1


def test_a():
    print(&quot;____test_a____&quot;)
    assert func(2) == 5

def test_b():
    print(&quot;____test_b____&quot;)
    assert func(2) == 3


def setup():
    print(&quot;函数级别的前置&quot;)

def teardown():
    print(&quot;函数级别的后置&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1101486/202010/1101486-20201006230140729-1466588616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;2、类式的案例--函数级别的前置条件&amp;amp;后置条件&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Testclass:
    def test_a(self):
        print(&quot;____test_a____&quot;)
        assert func(2) == 5

    def test_b(self):
        print(&quot;____test_b____&quot;)
        assert func(2) == 3

    def setup(self):
        print(&quot;函数级别的前置&quot;)

    def teardown(self):
        print(&quot;函数级别的后置&quot;)
if __name__ == '__main__':
    pytest.main([&quot;-s&quot;,&quot;pytest2.py&quot;])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1101486/202010/1101486-20201006230507501-1028246254.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;3、类级别的前置条件&amp;amp;后台置条件&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import pytest

def func(x):
    return x + 1


class Testclass:
    def test_a(self):
        print(&quot;____test_a____&quot;)
        assert func(2) == 5

    def test_b(self):
        print(&quot;____test_b____&quot;)
        assert func(2) == 3

    def setup(self):
        print(&quot;函数级别的前置&quot;)

    def teardown(self):
        print(&quot;函数级别的后置&quot;)
    
    def setup_class(self):
        print(&quot;类级别的前置&quot;)

    def teardown_class(self):
        print(&quot;类级别的后置&quot;)
if __name__ == '__main__':
    pytest.main([&quot;-s&quot;,&quot;pytest3.py&quot;])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1101486/202010/1101486-20201006230730541-129758824.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;三、介绍如何修改pytest的配置文件&lt;/h3&gt;
&lt;p&gt;我们在博客的第一部分介绍了pytest框架的运行规则，这里我们可以修改pytest的配置文件，改变框架运行规则&lt;/p&gt;
&lt;p&gt;首先我们要在案例的目录下创建一个pytest.ini的配置文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1101486/202010/1101486-20201006230923663-2083241791.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 创建pytest.ini文件
# [pytest]
# addopts=-s
#这个先这样写，这个主要是执行参数


# testpaths = testcase
# 只执行这个目录下的文件
#
# python_files = test_*.py
#执行的文件的名字


# python_classes = Test_*
#执行类的名字

# python_functions = test_*
# 执行函数的名字
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置文件截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1101486/202010/1101486-20201006231145802-2027252438.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;通过上面的步骤，我们就可以改变pytest的运行规则&lt;/p&gt;


&lt;h3&gt;四、介绍pytest的断言&lt;/h3&gt;
&lt;p&gt;pytest的断言是用python的断言，他不像unittest框架，他自己实现了断言&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# -*- coding:utf-8 -*-

# pytest是使用python自带的断言
import pytest

def func(x):
    return x + 1


def test_a():
    print(&quot;____test_a____&quot;)
    assert func(2) == 5

def test_b():
    print(&quot;____test_b____&quot;)
    assert not func(2) == 3

def test_c():
    print(&quot;____test_b____&quot;)
    assert func(2) in [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]


def test_d():
    print(&quot;____test_b____&quot;)
    assert func(2) not in [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]


if __name__ == '__main__':
    pytest.main([&quot;-s&quot;,&quot;pytest5.py&quot;])
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;五、介绍pytest的标记（mark）&lt;/h3&gt;
&lt;h4&gt; 1、可以实现给函数打标记，实现哪些标记执行，哪些标记不执行&lt;/h4&gt;
&lt;p&gt;一个函数可以打多个标记，一个标记同时可以给多个函数打标记。只需要让这个标记的装饰器函数装饰我们的测试类或者测试函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Test_mark():
    @pytest.mark.test01
    def test_a(self):
        print(&quot;mark  test a&quot;)

    @pytest.mark.test02
    def test_b(self):
        print(&quot;mark test b&quot;)


if __name__ == '__main__':
    pytest.main(['-s',&quot;pytest6.py&quot;])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还有其它的执行方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# pytest -m test01

# pytest -n &quot;test01 or test02&quot;

# pytest -m &quot;not test01&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2、标记可以实现不跳过某个、某些案例的作用&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# -*- coding:utf-8 -*-

import pytest

# skip跳过执行某个案例
@pytest.mark.skip(reson=&quot;只是这个函数用例不执行&quot;)
def test_a():

    print(&quot;testa&quot;)


def test_b():
    print(&quot;testb&quot;)


@pytest.mark.skip(reson=&quot;整个类下的案例都不会执行&quot;)
class Test_skip():
    def test_a(self):
        print(&quot;testa&quot;)

    def test_b(self):
        print(&quot;testb&quot;)


# 可以根据条件判断，为真，则不执行
@pytest.mark.skipif(1 &amp;gt; 2,reson=&quot;整个类下的案例满足条件都不会执行&quot;)
class Test_skipif():
    def test_a(self):
        print(&quot;testa&quot;)

    def test_b(self):
        print(&quot;testb&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;六、介绍pytest的数据参数化&lt;/h3&gt;
&lt;h4&gt;1、传入单个参数&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# pytest的数据参数化

# 1、传入单个参数
#
# pytest.mark.parametrize(argnames,argvalues)
# argnames   参数的名称
#
# argvalues  参数对应的值，类型必须是可迭代的类型，一般使用list


@pytest.mark.skip(reson=&quot;只是这个函数用例不执行&quot;)
def test_a():
    print(&quot;testa&quot;)


@pytest.mark.parametrize(&quot;name&quot;,[&quot;cui1&quot;,&quot;cui2&quot;,&quot;cui3&quot;,&quot;cui4&quot;])
def test_b(name):
    print(&quot;testb-----&amp;gt;{name}&quot;.format(name = name))

if __name__ == '__main__':
    pytest.main([&quot;-s&quot;, &quot;pytest8.py&quot;])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实现的效果name作为参数的名称，这个案例会执行4次，参数分别是name=“cui1”\name=&quot;cui2&quot;\....&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1101486/202010/1101486-20201006232241016-1492374721.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;2、传入多个参数&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import pytest


# pytest的数据参数化

# 1、传入多个参数
#
# pytest.mark.parametrize((argnames1,argnames2),[(argvalues1,argvalues1),(argvalues1,argvalues1)],(argvalues1,argvalues1)]])


@pytest.mark.skip(reson=&quot;只是这个函数用例不执行&quot;)
def test_a():
    print(&quot;testa&quot;)


@pytest.mark.parametrize((&quot;name&quot;,&quot;age&quot;),[(&quot;cui1&quot;,12),(&quot;cui2&quot;,13),(&quot;cui3&quot;,14)])
def test_b(name,age):
    print(&quot;testb-----&amp;gt;{name}-----&amp;gt;{age}&quot;.format(name = name,age = age))

if __name__ == '__main__':
    pytest.main([&quot;-s&quot;, &quot;pytest9.py&quot;])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实现的效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1101486/202010/1101486-20201006232345522-1675551051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h3&gt; 七、介绍pyest的常用第三方插件&lt;/h3&gt;
&lt;h4&gt;1、美化pytest的输出报告插件&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# pip install pytest-html

# 用来美化输出报告的插件
# 只需要在配置文件中加这个配置即可
#
# addopts=-s --html=report.html
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1101486/202010/1101486-20201006232701276-841096298.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1101486/202010/1101486-20201006232636421-480061050.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;2、失败案例重试插件，下面的示例实现的就是失败重启3，失败后间隔2s在进行重试&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# pip install pytest-rerunfailures
# 失败重试的第三方插件
# 只需要在配置文件中加这个配置即
# --reruns 3 --reruns-delay 2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至此，pytest的框架基本使用已经讲解清楚，小伙伴们还有不清楚的吗？欢迎大家来沟通！！！&lt;/p&gt;

</description>
<pubDate>Tue, 06 Oct 2020 15:30:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<og:description>首先祝大家国庆节日快乐，这个假期因为我老婆要考注会，我也跟着天天去图书馆学了几天，学习的感觉还是非常不错的，这是一篇总结。 这篇博客准备讲解一下pytest测试框架，这个框架是当前最流行的python</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bainianminguo/p/13773717.html</dc:identifier>
</item>
<item>
<title>大话Python类语义 - 北门吹雪</title>
<link>http://www.cnblogs.com/2bjiujiu/p/13775937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/2bjiujiu/p/13775937.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　物以类聚，人以群分，就是相同特征的人和事物会自动聚集在一起，核心驱动点就是&lt;strong&gt;具有相同特征或相类似的特征&lt;/strong&gt;，我们把具有相同特征或相似特征的事物放在一起，被称为分类，把&lt;strong&gt;分类依据的特征称为类属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　计算机中&lt;strong&gt;分类的思想叫做面向对象&lt;/strong&gt;，Python中把数据抽象成对象，通过对象或对象间的关系来描叙数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们把一些相似事物的共同特征通过一个方式描叙出来，也就是说，你是按什么标准对事物进行分类，相似点是什么，计算机&lt;strong&gt;把对相似事物的特征数据进行描叙称为类定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算机中&lt;strong&gt;类的三大特征&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1. &lt;strong&gt;封装&lt;/strong&gt; 对&lt;strong&gt;数据的可见性&lt;/strong&gt;进行约束，分为&lt;strong&gt;公有public、私有private、非公有&lt;/strong&gt;， 公有数据可以直接通过属性访问语法 obj.attr 直接访问，但是私有、非公有则通过方法进行访问，访问行为其实就是SQL中的增删改查，查称为读，增删改称为写，在Python中类的数据称为数据属性，类中定义的函数称为方法，方法是关联对象的函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Person:
    &quot;&quot;&quot;数据封装实现&quot;&quot;&quot;
    def __init__(self, name, age, sex):
        &quot;&quot;&quot;名字是公开的， 性别是非公有， 年龄是私有&quot;&quot;&quot;
        # 现在给实例插入数据
        # 公有数据
        self.name = name
        # 非公有使用一个下划线
        self._sex = sex
        # 私有变量使用两个下划线
        self.__age = age

    def get_name(self):
        &quot;&quot;&quot;通过方法读取名称&quot;&quot;&quot;
        return self.name

    def set_age(self, value):
        &quot;&quot;&quot;对年龄进行修改&quot;&quot;&quot;
        self.__age == value

    def get_age(self):
        &quot;&quot;&quot;通过方法获取私有属性年龄&quot;&quot;&quot;
        return self.__age


if __name__ == '__main__':
    # 类的实例话类似函数调用，也可以使用关键字参数和位置参数
    p = Person(&quot;北门吹雪&quot;, 20, &quot;male&quot;)
    # 通过 obj.name 属性访问语言访问实例的属性，这个饭方法只能访问公有属性
    print(p.name)

    # 通过方法修改年龄
    p.set_age(22)
    # 通过方法访问私有属性
    print(p.get_age())
    pass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　2. &lt;strong&gt;继承&lt;/strong&gt; 需要理清几个概念，&lt;strong&gt;父类、子类、基类、派生类&lt;/strong&gt;，父类就是基类，子类就是派生类。继承是建立在类的基础上，子类完全继承父类的所有属性以及控制属性访问的方法。继承要理清&lt;strong&gt;差异共相同点&lt;/strong&gt;，对依据对事物进行分类的特征要非常确定才能写计算机中的类，不然不是分类，&lt;strong&gt;分类的前提是公共特征，继承的前提是共性与差异&lt;/strong&gt;，如果不理解共同特征你就无法分类，你不理解同一类的共性与差异你无法写出继承，继承强调的是公共特征，包括属性和方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Human(object):
    &quot;&quot;&quot;定义人类， 每个人类都有名字和国家， 都会说话&quot;&quot;&quot;
    def __init__(self, name, country):
        self.name = name
        self.country = country

    def say(self, language):
        &quot;&quot;&quot;交流说话&quot;&quot;&quot;
        print(f&quot;{self.name} 能说 {language}&quot;)


class Chinese(Human):
    &quot;&quot;&quot;定义一个中国人，继承人类

     Human被称为这个类的基类或这个类的父类，Chinese被成为Human的派生类&quot;&quot;&quot;

    def __init__(self, name, country, skin):
        &quot;&quot;&quot;中国人和外国人最大的不同是肤色&quot;&quot;&quot;
        # 调用父类的构造函数
        super(Chinese, self).__init__(name, country)
        self.skin = skin


if __name__ == '__main__':
    c = Chinese(&quot;北门吹雪&quot;, 20, &quot;yellow&quot;)
    print(c.skin)
    c.say(&quot;中文&quot;)
    pass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;　&lt;/span&gt;&lt;span&gt;3.&lt;/span&gt; &lt;strong&gt;多态&lt;/strong&gt; &lt;span&gt;同一个行为具有不同表现形式或形态的能力，计算机中最接近多态的是&lt;/span&gt;&lt;strong&gt;接口interface&lt;/strong&gt;&lt;span&gt;，接口定义相同行为，然后我们对接口行为的分类，就产生所谓的抽象基类，通过继承机制，然后子类&lt;strong&gt;重写&lt;/strong&gt;方法从而实现多态，说白了就是同一个方法中有不同的实现，再说漏骨一点就是函数的名称相同，函数的形参相同，函数的返回值相同，但是函数体内的语句逻辑不一样，这个函数体不同被称为多态。多态是建立在继承的基础上然后对方法进行重写，其实能重写(又称为重载)的只有函数体，&lt;/span&gt;&lt;strong&gt;多态强调的是方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class HumanInterface(object):
    &quot;&quot;&quot;定义一个人类的抽象接口，用于实现多态, 多态强调的是方法

    定义了两个接口，一个是吃 一个是说
    &quot;&quot;&quot;
    def say(self, language):
        &quot;&quot;&quot;说&quot;&quot;&quot;
        pass

    def eat(self, what):
        &quot;&quot;&quot;吃&quot;&quot;&quot;
        pass


class Chinese(HumanInterface):
    &quot;&quot;&quot;定义一个中国人，继承人类&quot;&quot;&quot;

    def __init__(self, name, country):
        &quot;&quot;&quot;中国人和外国人最大的不同是肤色&quot;&quot;&quot;
        # 调用父类的构造函数
        self.name = name
        self.country = country

    def eat(self, what):
        &quot;&quot;&quot;重载或重写 父类中的方法，实现多态&quot;&quot;&quot;
        print(f&quot;{self.name} 正在吃{what}ing&quot;)
        pass

    def say(self, language):
        print(f&quot;{self.name} 能说 {language}&quot;)
        pass


class American(HumanInterface):
    &quot;&quot;&quot;美国人&quot;&quot;&quot;
    def __init__(self, name, country):
        &quot;&quot;&quot;中国人和外国人最大的不同是肤色&quot;&quot;&quot;
        # 调用父类的构造函数
        self.name = name
        self.country = country

    def eat(self, what):
        &quot;&quot;&quot;重载或重写 父类中的方法，实现多态&quot;&quot;&quot;
        print(f&quot;{self.name}吃{what}再跳舞&quot;)
        pass

    def say(self, language):
        print(f&quot;{self.name} 不仅能说 {language}， 还会其他国家语言&quot;)
        pass

if __name__ == '__main__':
    c = Chinese(&quot;北门吹雪&quot;, &quot;中国&quot;)
    a = American(&quot;alex&quot;, &quot;美国&quot;)
    c.eat(&quot;大米&quot;)
    a.eat(&quot;汉堡包&quot;)

    c.say(&quot;中文&quot;)
    a.say(&quot;英语&quot;)
    # 你会发现他们方法名相同，但是输出不同，也就是形态不同
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Python中类定义&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;类定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Name:
    pass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　# &lt;strong&gt;定义是可执行的语句&lt;/strong&gt;，在被import语句导入或以main文件执行时，定义就会被执行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# 类定义的执行，首先会在当前作用域引入一个用于存储类中属性的命名空间。然后把这个类命名空间封装成对象返回，并把这个类对象绑定到class关键字指定的名称，这个名称又被绑定到class关键子所在的命名空间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# &lt;strong&gt;Name -&amp;gt; 类对象 &amp;gt; 类命名空间&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# 其实类定义中包含的一般是函数定义，函数定义的第一个参数其实时实例本身，通过实例本身就可以访问实例中的数据属性和方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;类对象&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　# 支持两种操作：&lt;strong&gt;属性引用 和 实例化&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# 属性引用使用Python标准属性引用语法 &lt;strong&gt;obj.name&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# 实例化: &lt;strong&gt;类的实例化，类似于函数调用&lt;/strong&gt;，把括号里的参数传递给类的__init__方法，通过__init__方法为类的新实例初始化特定的属性，这个init方法又被称为工厂函数， 其他语言中的类通过new关键字创建。Python中通过函数调用传参的形式实现类的实例化&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Person(object):
    &quot;&quot;&quot;人类&quot;&quot;&quot;
    # 能说话
    can_say = True
    # 能吃
    can_eat = True
    # 能睡觉
    can_sleep = True

    def __init__(self, name, age, country):
        self.name = name
        self.__age = age
        self.country = country

    def show_country(self):
        &quot;&quot;&quot;显示国籍&quot;&quot;&quot;
        print(f&quot;{self.name}的国籍是: {self.country}&quot;)


if __name__ == '__main__':
    # 属性引用
    print(Person.can_eat)
    print(Person.can_sleep)
    print(Person.can_sleep)

    # 实例化
    c = Person(&quot;北门吹雪&quot;, 20, &quot;中国&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实例对象&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　# 支持唯一的操作就是&lt;strong&gt;属性引用&lt;/strong&gt;， 其实和普通的变量引用一样，只是多个归属前缀而已，通过方法对实例里的变量进行修改，实际上在函数封装过程的基础上再把数据和函数绑定起来&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Person(object):
    &quot;&quot;&quot;人类&quot;&quot;&quot;
    # 能说话
    can_say = True
    # 能吃
    can_eat = True
    # 能睡觉
    can_sleep = True

    def __init__(self, name, age, country):
        self.name = name
        self.__age = age
        self.country = country

    def show_country(self):
        &quot;&quot;&quot;显示国籍&quot;&quot;&quot;
        print(f&quot;{self.name}的国籍是: {self.country}&quot;)

    def set_age(self, value):
        &quot;&quot;&quot;修改年龄&quot;&quot;&quot;
        self.__age = value

    def get_age(self):
        &quot;&quot;&quot;获取年龄&quot;&quot;&quot;
        return self.__age


if __name__ == '__main__':
    # 实例化
    user = Person(&quot;北门吹雪&quot;, 20, &quot;中国&quot;)
    # 属性引用
    user_age = user.get_age()
    print(user_age)

    # 设置年龄
    user.set_age(22)
    print(user.get_age())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法对象&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　# &lt;strong&gt;方法是从属某个对象的函数&lt;/strong&gt;，类中的函数定义了类的实例所拥有的方法，也就是说对象的类型决定了对象支持的操作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# 方法对比函数，函数定义在模块或函数中，方法定义在类定义中，方法的第一个参数固定时实例对象&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类和实例变量&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　# &lt;strong&gt;实例变量是每个实例的唯一数据，而类变量是该类的所有实例共享的属性和方法&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# 相同属性名称出现在类和实例中，首先被找到的时实例属性&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Person(object):
    &quot;&quot;&quot;人类&quot;&quot;&quot;
    # 该类被实例化多少次
    object_count = 0

    # 默认全球通用语言是英语
    language = &quot;En&quot;

    def __init__(self, name, age, country, language):
        self.name = name
        self.__age = age
        self.country = country
        self.language = language

    def show_country(self):
        &quot;&quot;&quot;显示国籍&quot;&quot;&quot;
        print(f&quot;{self.name}的国籍是: {self.country}&quot;)

    def set_age(self, value):
        &quot;&quot;&quot;修改年龄&quot;&quot;&quot;
        self.__age = value

    def get_age(self):
        &quot;&quot;&quot;获取年龄&quot;&quot;&quot;
        return self.__age

    @classmethod
    def add_obj(cls):
        cls.object_count += 1


if __name__ == '__main__':
    # 实例化
    user = Person(&quot;北门吹雪&quot;, 20, &quot;中国&quot;, &quot;Cn&quot;)
    # 实例化一次则类变量增加一次
    Person.add_obj()

    user_two = Person(&quot;alex&quot;, 30, &quot;美国&quot;, &quot;En&quot;)
    Person.add_obj()

    # 打印被实例化几次
    print(Person.object_count)

    # 类变量和属性同名访问，优先选择实例
    print(user.language)
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Tue, 06 Oct 2020 15:20:00 +0000</pubDate>
<dc:creator>北门吹雪</dc:creator>
<og:description>类 物以类聚，人以群分，就是相同特征的人和事物会自动聚集在一起，核心驱动点就是具有相同特征或相类似的特征，我们把具有相同特征或相似特征的事物放在一起，被称为分类，把分类依据的特征称为类属性 计算机中分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/2bjiujiu/p/13775937.html</dc:identifier>
</item>
<item>
<title>Nuget管理自己的项目库 - 晨曦001</title>
<link>http://www.cnblogs.com/chenxi001/p/13775838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxi001/p/13775838.html</guid>
<description>&lt;blockquote readability=&quot;7.7525773195876&quot;&gt;
&lt;p&gt;Nuget 是一种 Visual Studio 扩展工具，它能够简化在 Visual Studio 项目中添加、更新和删除库（部署为程序包）的操作。（&lt;a href=&quot;https://docs.microsoft.com/zh-cn/nuget/&quot;&gt;官方地址&lt;/a&gt;）相信大家对这个应该还是很熟悉的，没有序列化包大家第一时间就是搜索一个辅助包进行引用，大家有没有想过这些帮助包是哪里来的呢？ （绝对不是天上掉下来的）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223629463-1311018267.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么使用nuget&quot;&gt;为什么使用Nuget&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当我们需要使用序列的时候，如果不使用Nuget中优秀的辅助包，我们就需要自己去实现一个序列话帮助类，这样我们就不能安安心心搬砖了，全部都写帮助类库了，当然我们有现成的轮子直接使用就可以了（自己费老大劲写出来的轮子可能还有bug）。&lt;/li&gt;
&lt;li&gt;当然我们也不是不能写，我之前负责过一个项目，我们的架构师写了一套核心帮助类，但是没有使用Nuget进行管理，项目的体量就非常非常大了，一个项目27个类库如果我们采用这种方式进行管理话我们项目也会变的更简单。&lt;/li&gt;
&lt;li&gt;当新项目开始的时候我们也不需要把帮助类库粘贴复制过来了，直接引用项目类库就完事了，简单的让自己飘飘乎。&lt;/li&gt;
&lt;li&gt;还有Nuget也可以搭建自己的私有帮助类，因为有些公司内部的信息不方便公开，也可以使用这种方案。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;怎么使用nuget&quot;&gt;怎么使用NuGet&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在NuGet官网上注册并获取API Key
&lt;ul&gt;&lt;li&gt;首先，你需要到&lt;a href=&quot;https://www.nuget.org/&quot;&gt;NuGet&lt;/a&gt;上注册一个新的账号，然后在My Account页面，获取一个API Key。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223644035-1683759366.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223653775-1043094569.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;下载NuGet.exe
&lt;ul&gt;&lt;li&gt;使用之前，需要先下载&lt;a href=&quot;https://www.nuget.org/downloads&quot;&gt;NuGet.exe&lt;/a&gt;,为了方便使用，设置机器的PATH环境变量，将其NuGet.exe的路径添加到PATH变量中。我放在F:\Program files下，所以路径为F:\Program files。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设置API Key&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223703797-1896437030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;ul&gt;&lt;li&gt;我们现在就是复制秘钥，设置到电脑中（nuget setApiKey 你的秘钥）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223711985-1455621007.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;创建清单
&lt;ul&gt;&lt;li&gt;创建一个自己的类库，然后进入项目目录中使用nuget spec命令创建一个清单.nuspec&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223718646-1817769833.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;标记&lt;/th&gt;
&lt;th&gt;源&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(id\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;程序集名称。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(title\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;AssemblyTitleAttribute 中指定的程序集标题。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(version\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;程序集的 AssemblyVersionAttribute 中指定的程序集版本。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(author\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;AssemblyCompanyAttribute 中指定的公司。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(description\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;AssemblyDescriptionAttribute 中指定的描述。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ol start=&quot;4&quot; readability=&quot;-2&quot;&gt;&lt;li&gt;创建程序包&lt;br/&gt;&lt;strong&gt;我们在发布之前可以先修改类库的信息&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223729709-1566720465.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;ul&gt;&lt;li&gt;如果同一个目录中只有一个项目文件，则在运行命令时可以省略项目文件名称。 nuget pack ProjectName.csproj&lt;/li&gt;
&lt;li&gt;如果尚未编译项目，可先用 Build 标记编译项目，然后压缩它。 这将在运行 pack 命令之前编译项目。 nuget pack ProjectName.csproj -Build&lt;br/&gt;   此命令将生成名为 ProjectName.{version}. nupkg 的文件，其中，{version} 的值与 AssemblyVersionAttribute 中指定的值相同。 例如，如果版本是 1.0.0，您的程序包将命名为 ProjectName.1.0.0. nupkg。&lt;/li&gt;
&lt;li&gt;为了方便开发人员安装您的程序包，请考虑使用 Symbols 标记创建带调试器符号的程序包：nuget pack ProjectName.csproj -Build -Symbols除了主程序包之外，此命令还创建符号程序包。 这使安装您的程序包的其他人在调试其应用程序时能够单步执行程序包代码。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223738969-1788562985.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223744773-2048500207.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;发布程序包（需要进入.nupkg文件目录中执行）
&lt;ul&gt;&lt;li&gt;当我们完成了上述所有的操作就已经完成了所有操作， 如果你希望你的成果可以帮助其他人你就可以执行此命令上 nuget push dcl.1.0.0.1.nupkg -source nuget.org 程序上传&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223753736-1285809265.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202010/1808958-20201006223800063-1694441495.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;测试以及更新类库包
&lt;ul&gt;&lt;li&gt;在解决方案中右键解决方案—-管理解决方案的NuGet程序包—-联机，输入自己的类库包名。安装就可以了。然后是更新，更新的时候记得更改的版本号的信息，然后再重新运行一遍下面的cmd&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;  nuget pack *.csproj
  nuget push *.nupkg
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 06 Oct 2020 14:46:00 +0000</pubDate>
<dc:creator>晨曦001</dc:creator>
<og:description>Nuget是什么 Nuget 是一种 Visual Studio 扩展工具，它能够简化在 Visual Studio 项目中添加、更新和删除库（部署为程序包）的操作。（官方地址）相信大家对这个应该还是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenxi001/p/13775838.html</dc:identifier>
</item>
<item>
<title>Blend学习之Loading加载动画 - 害羞的青蛙</title>
<link>http://www.cnblogs.com/ShyFrog/p/13775823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ShyFrog/p/13775823.html</guid>
<description>&lt;h2&gt;  介绍：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; Blend for visual studio 与 visual studio 是有区别的 两者虽然是IDEA 但是专注的方向是不同的，前者是专注UI后者专注业务逻辑，当然你要用blend for visual studio 去开发也行，不过blend for visual studio在UI上面是能体现出强大的优势，尤其是在WPF的动画上，你可以不用写代码就能做出动画来 就如制作Flash动画一样 你可以对动画的每一帧都能进行精确的控制，好了废话不多说 我们来实操&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;使用方法：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;打开blend for visual studio（就以2019为例子）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006204326153-2103911687.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建新项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006204451390-1908641257.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 给项目命名（我们就以加载动画为例子进行学习使用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006204748445-772997784.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 创建完成后的主界面是这个样子的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006205031023-400579655.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 我们这时看到的主要五个板块就如我图上框出来的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1：解决方案是当前的项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2：资产为当前项目之默认提供给你的一下能是用的基础控件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006205311126-677464101.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3：状态（本人没试用过，可以自己尝试摸索）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4：触发器，就是帮你完成一系列动作的事件（本人是这么理解的）。下图右上角即为创建触发器的按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006210440707-1152004707.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 5：数据（暂时我们用不到）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006210826222-1224425293.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现Loading动画：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1：给Window个背景色 #7F1F1F1F&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2：给Grid中加入一个圆 大小为10 圆角为5的Border，Grid大小给100，让Border以Grid的中心点进行旋转位移快捷键为Ctrl+鼠标左键（点击圆点进行拖动，拖到Grid的中心上，如红色的框框中），此时你对Border进行旋转即为以Grid的中心点进行旋转&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006212814382-1034094576.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3：创建触发器，点击触发器进行添加，由于我们这时初始化加载动画那么我们对于的属性为Loaded&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006213321027-2064383518.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4：由于我是作用在Window页面那么我们设置Window的Loaded属性让其加载就进行动画&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006213718799-1281382269.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5：上图为有三个框框从左往右依次对于的东西为 Window（当前控件）、属性（当前控件的属性）、创建关键帧按钮（即为你看到的添加新操作）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6：点击创建关键帧（添加新操作）按钮，此时系统提示你没有要开始或控制的情节提要，将创建一个。此时我们点击确定按钮即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006214229225-1095813428.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7：此时系统界面会出现一个面板如图，一个是对象个时间线一个是时间线录制已打开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006214416296-50871403.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 8：我们开始拖动对象个事件线中的黄线（0~1~2~3~指的是以秒为单位的关键帧时间线，我们将其拖到2的位置，同时设置当前的Border圆的旋转角度为360度&lt;/span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006220556399-1140988706.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 9：由于我们需要当前的圆持续旋转我们需要将Storyboard的RepeatBehavior属性设置为Forever，代表是无限制旋转&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006220840310-255948497.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10：启动当前项目你会发现你的圆已经在无限制的旋转（此时你离你的加载动画还差点善后，我们要让你的动画更加顺滑有动画的感觉我们需要多加几个圆）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11：再加上四个圆（为了偷懒 我将其命名为border——border4，大家不要学我，好好命名）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12：我们Copy DoubleAnimationUsingKeyFrames 这一块代码 跟别对应于每个控件（border——border4），对于的属性为 Storyboard.TargetName，他的值为（border——border4）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;13：为了让我们的圆不一起旋转，我们给个时间差，每个间隔一毫秒，在DoubleAnimationUsingKeyFrames中设置BeginTime=&quot;0:0:0.1&quot;  每个DoubleAnimationUsingKeyFrames依次累加如border2对应的为BeginTime=&quot;0:0:0.2&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699486/202010/1699486-20201006223155686-787894785.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 14：启动项目集合看到好看的加载动画啦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &amp;lt;Window.Resources&amp;gt;
        &amp;lt;Storyboard x:Key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OnLoaded1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; RepeatBehavior=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Forever&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;
            &amp;lt;DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(UIElement.RenderTransform).(TransformGroup.Children)[2].(RotateTransform.Angle)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Storyboard.TargetName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;EasingDoubleKeyFrame KeyTime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:0:1.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;360&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                    &amp;lt;EasingDoubleKeyFrame.EasingFunction&amp;gt;
                        &amp;lt;SineEase EasingMode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EaseInOut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
                    &amp;lt;/EasingDoubleKeyFrame.EasingFunction&amp;gt;
                &amp;lt;/EasingDoubleKeyFrame&amp;gt;
            &amp;lt;/DoubleAnimationUsingKeyFrames&amp;gt;
            &amp;lt;DoubleAnimationUsingKeyFrames BeginTime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:0:0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  Storyboard.TargetProperty=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(UIElement.RenderTransform).(TransformGroup.Children)[2].(RotateTransform.Angle)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Storyboard.TargetName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;EasingDoubleKeyFrame KeyTime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:0:1.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;360&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                    &amp;lt;EasingDoubleKeyFrame.EasingFunction&amp;gt;
                        &amp;lt;SineEase EasingMode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EaseInOut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
                    &amp;lt;/EasingDoubleKeyFrame.EasingFunction&amp;gt;
                &amp;lt;/EasingDoubleKeyFrame&amp;gt;
            &amp;lt;/DoubleAnimationUsingKeyFrames&amp;gt;
            &amp;lt;DoubleAnimationUsingKeyFrames BeginTime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:0:0.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Storyboard.TargetProperty=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(UIElement.RenderTransform).(TransformGroup.Children)[2].(RotateTransform.Angle)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Storyboard.TargetName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;EasingDoubleKeyFrame KeyTime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:0:1.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;360&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                    &amp;lt;EasingDoubleKeyFrame.EasingFunction&amp;gt;
                        &amp;lt;SineEase EasingMode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EaseInOut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
                    &amp;lt;/EasingDoubleKeyFrame.EasingFunction&amp;gt;
                &amp;lt;/EasingDoubleKeyFrame&amp;gt;
            &amp;lt;/DoubleAnimationUsingKeyFrames&amp;gt;
            &amp;lt;DoubleAnimationUsingKeyFrames BeginTime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:0:0.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Storyboard.TargetProperty=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(UIElement.RenderTransform).(TransformGroup.Children)[2].(RotateTransform.Angle)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Storyboard.TargetName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;EasingDoubleKeyFrame KeyTime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:0:1.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;360&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                    &amp;lt;EasingDoubleKeyFrame.EasingFunction&amp;gt;
                        &amp;lt;SineEase EasingMode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EaseInOut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
                    &amp;lt;/EasingDoubleKeyFrame.EasingFunction&amp;gt;
                &amp;lt;/EasingDoubleKeyFrame&amp;gt;
            &amp;lt;/DoubleAnimationUsingKeyFrames&amp;gt;
            &amp;lt;DoubleAnimationUsingKeyFrames BeginTime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:0:0.4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Storyboard.TargetProperty=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(UIElement.RenderTransform).(TransformGroup.Children)[2].(RotateTransform.Angle)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Storyboard.TargetName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;EasingDoubleKeyFrame KeyTime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:0:1.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  Value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;360&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                    &amp;lt;EasingDoubleKeyFrame.EasingFunction&amp;gt;
                        &amp;lt;SineEase EasingMode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EaseInOut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
                    &amp;lt;/EasingDoubleKeyFrame.EasingFunction&amp;gt;
                &amp;lt;/EasingDoubleKeyFrame&amp;gt;
            &amp;lt;/DoubleAnimationUsingKeyFrames&amp;gt;
        &amp;lt;/Storyboard&amp;gt;
    &amp;lt;/Window.Resources&amp;gt;
    &amp;lt;Window.Triggers&amp;gt;
        &amp;lt;EventTrigger RoutedEvent=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FrameworkElement.Loaded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;BeginStoryboard x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OnLoaded1_BeginStoryboard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Storyboard=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource OnLoaded1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
        &amp;lt;/EventTrigger&amp;gt;
    &amp;lt;/Window.Triggers&amp;gt;
    &amp;lt;Grid Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;Border x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CornerRadius=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Background=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; RenderTransformOrigin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.5,5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;Border.RenderTransform&amp;gt;
                &amp;lt;TransformGroup&amp;gt;
                    &amp;lt;ScaleTransform/&amp;gt;
                    &amp;lt;SkewTransform/&amp;gt;
                    &amp;lt;RotateTransform/&amp;gt;
                    &amp;lt;TranslateTransform/&amp;gt;
                &amp;lt;/TransformGroup&amp;gt;
            &amp;lt;/Border.RenderTransform&amp;gt;
        &amp;lt;/Border&amp;gt;
        &amp;lt;Border x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CornerRadius=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Background=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; RenderTransformOrigin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.5,5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;Border.RenderTransform&amp;gt;
                &amp;lt;TransformGroup&amp;gt;
                    &amp;lt;ScaleTransform/&amp;gt;
                    &amp;lt;SkewTransform/&amp;gt;
                    &amp;lt;RotateTransform/&amp;gt;
                    &amp;lt;TranslateTransform/&amp;gt;
                &amp;lt;/TransformGroup&amp;gt;
            &amp;lt;/Border.RenderTransform&amp;gt;
        &amp;lt;/Border&amp;gt;
        &amp;lt;Border x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CornerRadius=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Background=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; RenderTransformOrigin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.5,5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;Border.RenderTransform&amp;gt;
                &amp;lt;TransformGroup&amp;gt;
                    &amp;lt;ScaleTransform/&amp;gt;
                    &amp;lt;SkewTransform/&amp;gt;
                    &amp;lt;RotateTransform/&amp;gt;
                    &amp;lt;TranslateTransform/&amp;gt;
                &amp;lt;/TransformGroup&amp;gt;
            &amp;lt;/Border.RenderTransform&amp;gt;
        &amp;lt;/Border&amp;gt;
        &amp;lt;Border x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CornerRadius=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Background=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; RenderTransformOrigin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.5,5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;Border.RenderTransform&amp;gt;
                &amp;lt;TransformGroup&amp;gt;
                    &amp;lt;ScaleTransform/&amp;gt;
                    &amp;lt;SkewTransform/&amp;gt;
                    &amp;lt;RotateTransform/&amp;gt;
                    &amp;lt;TranslateTransform/&amp;gt;
                &amp;lt;/TransformGroup&amp;gt;
            &amp;lt;/Border.RenderTransform&amp;gt;
        &amp;lt;/Border&amp;gt;
        &amp;lt;Border x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CornerRadius=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Background=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; RenderTransformOrigin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.5,5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;Border.RenderTransform&amp;gt;
                &amp;lt;TransformGroup&amp;gt;
                    &amp;lt;ScaleTransform/&amp;gt;
                    &amp;lt;SkewTransform/&amp;gt;
                    &amp;lt;RotateTransform/&amp;gt;
                    &amp;lt;TranslateTransform/&amp;gt;
                &amp;lt;/TransformGroup&amp;gt;
            &amp;lt;/Border.RenderTransform&amp;gt;
        &amp;lt;/Border&amp;gt;
    &amp;lt;/Grid&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/span&gt;：代码和教材提供学习，不允许拿去CSDN混分，本人最讨厌这种人 盗窃别人的劳动成功，鄙视 (#‵′)凸&lt;/p&gt;
</description>
<pubDate>Tue, 06 Oct 2020 14:38:00 +0000</pubDate>
<dc:creator>害羞的青蛙</dc:creator>
<og:description>介绍： Blend for visual studio&amp;#160;与&amp;#160;visual studio&amp;#160;是有区别的&amp;#160;两者虽然是IDEA&amp;#160;但是专注的方向是不同的，前者是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ShyFrog/p/13775823.html</dc:identifier>
</item>
<item>
<title>手把手教你AspNetCore WebApi：增删改查 - 深度码农</title>
<link>http://www.cnblogs.com/zcqiand/p/13775810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zcqiand/p/13775810.html</guid>
<description>&lt;p&gt;小明已经创建与运行了WebApi项目，了解项目结构有哪些组成，并学会了怎么发布到IIS。基础已经建好，从现在开始要真正实现待办事项的功能了。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;CREATE TABLE [dbo].[Todo](
        [Id] [uniqueidentifier] NOT NULL,
        [Name] [nvarchar](100) NULL,
 CONSTRAINT [PK_Todo] PRIMARY KEY CLUSTERED 
(
        [Id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zcqiand/self-media/raw/master/assets/img/200929/20200929175439.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;在“解决方案资源管理器”中，右键单击项目。 选择“添加” &amp;gt; “新建文件夹”。 将文件夹命名为 Models。&lt;/li&gt;
&lt;li&gt;右键单击 Models 文件夹，然后选择“添加” &amp;gt; “类” 。 将类命名为 Todo，然后选择“添加”。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;using System;
namespace App001.Models
{
    public class Todo
    {
        public Guid Id { get; set; }
        public string Name { get; set; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;右键单击 Models 文件夹，然后选择“添加” &amp;gt; “类” 。 将类命名为 TodoContext，然后单击“添加”。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;using Microsoft.EntityFrameworkCore;
namespace App001.Models
{
    public class TodoContext : DbContext
    {
        public TodoContext(DbContextOptions&amp;lt;TodoContext&amp;gt; options)
            : base(options)
        {
        }
        public DbSet&amp;lt;Todo&amp;gt; Todos { get; set; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在 ASP.NET Core 中，服务（如数据库上下文）必须向依赖关系注入 (DI) 容器进行注册。 该容器向控制器提供服务。&lt;/p&gt;
&lt;p&gt;在Startup.cs文件中增加services.AddDbContext，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext&amp;lt;TodoContext&amp;gt;(opt =&amp;gt;opt.UseSqlServer(Configuration.GetConnectionString(&quot;TodoContext&quot;)));
    services.AddControllers();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在appsettings.json文件中增加ConnectionStrings，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;ConnectionStrings&quot;: {
    &quot;TodoContext&quot;: &quot;server=.\\SQLEXPRESS;database=App001;uid=sa;pwd=123456;Pooling='true';Min Pool Size=3;&quot;
},
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;右键单击 Controllers 文件夹。&lt;/li&gt;
&lt;li&gt;选择“添加”&amp;gt;“新建构建项” 。&lt;/li&gt;
&lt;li&gt;选择“其操作使用实体框架的 API 控制器”，然后选择“添加” 。&lt;/li&gt;
&lt;li&gt;在“添加其操作使用实体框架的 API 控制器”对话框中：&lt;/li&gt;
&lt;li&gt;在“模型类”中选择“Todo (App001.Models)” 。&lt;/li&gt;
&lt;li&gt;在“数据上下文类”中选择“TodoContext (App001.Models)” 。&lt;/li&gt;
&lt;li&gt;选择“添加”。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using App001.Models;
namespace App001.Controllers
{
    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class TodosController : ControllerBase
    {
        private readonly TodoContext context;
        public TodosController(TodoContext context)
        {
            this.context = context;
        }
        /// &amp;lt;summary&amp;gt;
        /// 获取所有待办事项
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        [HttpGet]
        public async Task&amp;lt;ActionResult&amp;lt;IEnumerable&amp;lt;Todo&amp;gt;&amp;gt;&amp;gt; GetTodos()
        {
            return await context.Todo.ToListAsync();
        }
        /// &amp;lt;summary&amp;gt;
        /// 按ID获取项
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        [HttpGet(&quot;{id}&quot;)]
        public async Task&amp;lt;ActionResult&amp;lt;Todo&amp;gt;&amp;gt; GetTodo(Guid id)
        {
            var todo = await context.Todo.FindAsync(id);
            if (todo == null)
            {
                return NotFound();
            }
            return todo;
        }
        /// &amp;lt;summary&amp;gt;
        /// 添加新项
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;todo&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        [HttpPost]
        public async Task&amp;lt;ActionResult&amp;lt;Todo&amp;gt;&amp;gt; PostTodo(Todo todo)
        {
            todo.Id = Guid.NewGuid();
            context.Todo.Add(todo);
            await context.SaveChangesAsync();
            return CreatedAtAction(&quot;GetTodo&quot;, new { id = todo.Id }, todo);
        }
        /// &amp;lt;summary&amp;gt;
        /// 更新现有项
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;todo&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        [HttpPut(&quot;{id}&quot;)]
        public async Task&amp;lt;ActionResult&amp;lt;Todo&amp;gt;&amp;gt; PutTodo(Guid id, Todo todo)
        {
            var oldTodo = await context.Todo.FindAsync(id);
            oldTodo.Name = todo.Name;
            context.Entry(oldTodo).State = EntityState.Modified;
            await context.SaveChangesAsync();
            return oldTodo;
        }
        /// &amp;lt;summary&amp;gt;
        /// 删除项
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        [HttpDelete(&quot;{id}&quot;)]
        public async Task&amp;lt;ActionResult&amp;lt;Todo&amp;gt;&amp;gt; DeleteTodo(Guid id)
        {
            var todo = await context.Todo.FindAsync(id);
            if (todo == null)
            {
                return NotFound();
            }
            context.Todo.Remove(todo);
            await context.SaveChangesAsync();
            return todo;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;创建新请求。&lt;/li&gt;
&lt;li&gt;将 HTTP 方法设置为“POST”。&lt;/li&gt;
&lt;li&gt;将请求 URI 设置为 &lt;a href=&quot;https://localhost:44342/api/todos%E3%80%82&quot;&gt;https://localhost:44342/api/todos。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;选择“正文”选项卡。&lt;/li&gt;
&lt;li&gt;选择“原始”单选按钮。&lt;/li&gt;
&lt;li&gt;将类型设置为 JSON (application/json)&lt;/li&gt;
&lt;li&gt;在请求正文中，输入待办事项的 JSON：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;{
    &quot;Name&quot;:&quot;遛狗&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;选择Send。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/zcqiand/self-media/raw/master/assets/img/200930/20200930100100.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;目前为止，小明已经实现“待办事项”的增删改查，心里洋洋得意，摸了摸光滑的脑袋，小明美滋滋找小红去对接了。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Oct 2020 14:35:00 +0000</pubDate>
<dc:creator>深度码农</dc:creator>
<og:description>前言 小明已经创建与运行了WebApi项目，了解项目结构有哪些组成，并学会了怎么发布到IIS。基础已经建好，从现在开始要真正实现待办事项的功能了。 新建表 CREATE TABLE [dbo].[To</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zcqiand/p/13775810.html</dc:identifier>
</item>
<item>
<title>认证授权：IdentityServer4 - 数据持久化 - cwsheng</title>
<link>http://www.cnblogs.com/cwsheng/p/13737196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwsheng/p/13737196.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　前面的文章中IdentityServer4 配置内容都存储到内存中，本篇文章开始把配置信息存储到数据库中；本篇文章继续基于&lt;a href=&quot;https://github.com/cwsheng/IdentityServer.Demo.git&quot; target=&quot;_blank&quot;&gt;github的代码&lt;/a&gt;来实现配置数据持久化到MySQL中&lt;/p&gt;
&lt;h2&gt;一、基于EFCore持久化IdentityServer数据&lt;/h2&gt;
&lt;h3&gt;　1、数据库上下文(DbContext )&lt;/h3&gt;
&lt;p&gt;　　　在前面使用IDS4时，配置的一些基础：如Api资源、客户端等数据；以及在使用过程中授权后发放的token、授权、授权码等操作数据。如果持久化如何处理呢？IDS4已经提供了对应的方式 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;&lt;strong&gt;ConfigurationDbContext&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;_mce_tagged_br&quot;&gt;　　　　　　主要负责数据库对客户端、标识资源、Api资源和CORS等的配置存储&lt;/p&gt;
&lt;ul class=&quot;_mce_tagged_br&quot;&gt;&lt;li&gt;
&lt;ul class=&quot;_mce_tagged_br&quot;&gt;&lt;li&gt;&lt;strong&gt;PersistedGrantDbContext &lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　　　　　主要存储操作数据，如：授权码、访问令牌、刷新令牌等相关操作数据 &lt;/p&gt;
&lt;h3&gt;　2、在&lt;span&gt;cz.IdentityServer&lt;span&gt;中添加Nuget包：IdentityServer4.EntityFramework以及EF相关包&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Install-Package IdentityServer4.EntityFramework
&lt;/pre&gt;
&lt;pre&gt;
Install-Package Microsoft.EntityFrameworkCore
&lt;/pre&gt;
&lt;pre&gt;
Install-Package &lt;em&gt;Microsoft.EntityFrameworkCore.Tools&lt;br/&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
Install-Package &lt;em&gt;&lt;em&gt;Microsoft.EntityFrameworkCore.Design&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
Install-Package Pomelo.EntityFrameworkCore.MySql 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　3、修改Startup文件中ConfigureServices方法中IdentityServer4配置内容如下：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IConfiguration _configuration;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
    {
        _configuration &lt;/span&gt;=&lt;span&gt; configuration;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; For more information on how to configure your application, visit &lt;/span&gt;&lt;span&gt;https://go.microsoft.com/fwlink/?LinkID=398940&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        services.AddControllersWithViews();

        services.Configure&lt;/span&gt;&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;&lt;span&gt;
        {
            options.MinimumSameSitePolicy &lt;/span&gt;=&lt;span&gt; SameSiteMode.Strict;
        });
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取连接串&lt;/span&gt;
&lt;strong&gt;        &lt;span&gt;string connString = _configuration.GetConnectionString(&quot;Default&quot;);&lt;br/&gt;　　　　 string migrationsAssembly = Assembly.GetEntryAssembly().GetName().Name;
        //添加IdentityServer服务
        services.AddIdentityServer()
            //添加这配置数据(客户端、资源)
            .AddConfigurationStore(opt =&amp;gt;
            {
                opt.ConfigureDbContext = c =&amp;gt;
                {
                    c.UseMySql(connString, sql =&amp;gt; sql.MigrationsAssembly(migrationsAssembly));
                };
            })
            //添加操作数据(codes、tokens、consents)
            .AddOperationalStore(opt =&amp;gt;
            {
                opt.ConfigureDbContext = c =&amp;gt;
                {
                    c.UseMySql(connString, sql =&amp;gt; sql.MigrationsAssembly(migrationsAssembly));
                };
                //token自动清理
                opt.EnableTokenCleanup = true;
                ////token自动清理间隔：默认1H
                //opt.TokenCleanupInterval=3600;
                ////token自动清理每次数量
                //opt.TokenCleanupBatchSize = 100;
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;            })&lt;br/&gt;　　　　　　　 //用户默认依旧采用内存用户，可用Identity替换&lt;br/&gt;　　　　　　　.AddTestUsers(InMemoryConfig.Users().ToList());&lt;/span&gt;&lt;/strong&gt;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {&lt;br/&gt;　　　　  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;//初始化数据(内容后面描述)&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;　　　　　SeedData.InitData(app);&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseRouting();

        app.UseStaticFiles();
        app.UseCookiePolicy();
        app.UseIdentityServer();

        app.UseAuthentication();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用默认UI，必须添加&lt;/span&gt;
&lt;span&gt;        app.UseAuthorization();

        app.UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            endpoints.MapControllerRoute(name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, pattern: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　4、迁移数据&lt;/h3&gt;
&lt;p&gt;　　迁移方式有多种方式：&lt;/p&gt;
&lt;p&gt;　　1、打开包控制台，执行以下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; add-migration InitialPersistedGrantDb -c PersistedGrantDbContext -o Migrations/IdentityServer/&lt;span&gt;PersistedGrantDb 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; add-migration InitialConfigurationDb -c ConfigurationDbContext -o Migrations/IdentityServer/&lt;span&gt;ConfigurationDb
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; update-database -&lt;span&gt;c PersistedGrantDbContext   
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; update-database -c ConfigurationDbContext   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 　  2、在项目路径中执行命令行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; dotnet ef migrations add InitialPersistedGrantDb -c PersistedGrantDbContext -o Migrations/IdentityServer/&lt;span&gt;PersistedGrantDb
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; dotnet ef migrations add InitialConfigurationDb -c ConfigurationDbContext -o Migrations/IdentityServer/ConfigurationDb&lt;br/&gt;3 dotnet ef &lt;em&gt;database &lt;/em&gt;update &lt;em&gt;&lt;em&gt;-c PersistedGrantDbContext &lt;br/&gt;&lt;/em&gt;&lt;/em&gt;4 dotnet ef &lt;em&gt;database &lt;/em&gt;update &lt;em&gt;-c &lt;/em&gt;ConfigurationDbContext &lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;二、数据表含义&lt;/h2&gt;
&lt;p&gt;　　  &lt;strong&gt;数据结构迁移完成我们来看下创建了那些表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201006202711507-2066645275.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;根据不同的数据库上下文划分如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201006153109787-1062809439.png&quot; alt=&quot;&quot; width=&quot;1177&quot; height=&quot;666&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、初始化数据&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;1、创建文件SeedData.cs文件用于初始化基础数据：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SeedData
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitData(IApplicationBuilder serviceProvider)
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始创建初始化数据...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; scope =&lt;span&gt; serviceProvider.ApplicationServices.CreateScope())
        {
            scope.ServiceProvider.GetRequiredService&lt;/span&gt;&amp;lt;PersistedGrantDbContext&amp;gt;&lt;span&gt;().Database.Migrate();
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context = scope.ServiceProvider.GetRequiredService&amp;lt;ConfigurationDbContext&amp;gt;&lt;span&gt;();
                context.Database.Migrate();
                EnsureSeedData(context);
            }
        }
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;初始化数据创建完成.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EnsureSeedData(ConfigurationDbContext context)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;context.Clients.Any())
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Clients 正在初始化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client &lt;span&gt;in&lt;/span&gt;&lt;span&gt; InMemoryConfig.GetClients())
            {
                context.Clients.Add(client.ToEntity());
            }
            context.SaveChanges();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;context.IdentityResources.Any())
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityResources 正在初始化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; resource &lt;span&gt;in&lt;/span&gt;&lt;span&gt; InMemoryConfig.GetIdentityResources())
            {
                context.IdentityResources.Add(resource.ToEntity());
            }
            context.SaveChanges();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;context.ApiResources.Any())
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiResources 正在初始化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; resource &lt;span&gt;in&lt;/span&gt;&lt;span&gt; InMemoryConfig.GetApiResources())
            {
                context.ApiResources.Add(resource.ToEntity());
            }
            context.SaveChanges();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;context.ApiScopes.Any())
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiScopes 正在初始化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; resource &lt;span&gt;in&lt;/span&gt;&lt;span&gt; InMemoryConfig.GetApiScopes())
            {
                context.ApiScopes.Add(resource.ToEntity());
            }
            context.SaveChanges();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2、并在Startup文件中添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化数据(内容后面描述)&lt;/span&gt;
SeedData.InitData(app);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　程序运行如下：　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201006210844039-799294943.png&quot; alt=&quot;&quot; width=&quot;725&quot; height=&quot;379&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 　3、初始化主要数据结果如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201006212529006-455408173.png&quot; alt=&quot;&quot; width=&quot;915&quot; height=&quot;531&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　4、运行效果同上一篇文章效果相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201006213057984-1770463624.png&quot; alt=&quot;&quot; width=&quot;1070&quot; height=&quot;586&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; 四、其他&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;本篇主要介绍了简单使用IdentityServer4.EntityFramework持久化存储相关配置数据和操作数据；本篇中用户信息未持久化存储未介绍，因为IdentityServer4本就支持了接入其他认证方式，如 ： NetCore 官方的 Identity，可以快速实现用户管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Github：&lt;a href=&quot;https://github.com/cwsheng/IdentityServer.Demo&quot;&gt;https://github.com/cwsheng/IdentityServer.Demo&lt;/a&gt;　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Oct 2020 13:37:00 +0000</pubDate>
<dc:creator>cwsheng</dc:creator>
<og:description>前言： 前面的文章中IdentityServer4 配置内容都存储到内存中，本篇文章开始把配置信息存储到数据库中；本篇文章继续基于github的代码来实现配置数据持久化到MySQL中 一、基于EFCo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cwsheng/p/13737196.html</dc:identifier>
</item>
</channel>
</rss>