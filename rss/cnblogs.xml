<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用杜教筛求解数论函数前缀和 - wxyww</title>
<link>http://www.cnblogs.com/wxyww/p/dujiaoshai.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxyww/p/dujiaoshai.html</guid>
<description>&lt;p&gt;杜教筛用来求数论函数&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;前缀和。复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n^{\frac{2}{3}})\)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果我们要求&lt;span class=&quot;math inline&quot;&gt;\(S(n)=\sum\limits_{i=1}^nf(i)\)&lt;/span&gt;，那么需要找到一个数论函数&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;，满足&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;的前缀和可以非常快速的求出来，并且&lt;span class=&quot;math inline&quot;&gt;\(g*f\)&lt;/span&gt;的前缀和可以非常快速的求出来。&lt;/p&gt;

&lt;p&gt;既然&lt;span class=&quot;math inline&quot;&gt;\(g*f\)&lt;/span&gt;的前缀和可以非常快速的求出来，我们就求&lt;span class=&quot;math inline&quot;&gt;\(g*f\)&lt;/span&gt;的前缀和。&lt;/p&gt;
&lt;p&gt;即&lt;span class=&quot;math inline&quot;&gt;\(\sum\limits_{i=1}^n\sum\limits_{d|i}g(\frac{i}{d})f(d)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后我们想得到的是&lt;span class=&quot;math inline&quot;&gt;\(\sum\limits_{i=1}^nf(i)\)&lt;/span&gt;。所以我们让上面的式子减去一个&lt;span class=&quot;math inline&quot;&gt;\(\sum\limits_{i=1}^n\sum\limits_{d|i,d\neq i}g(\frac{i}{d})f(d)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于后面这个式子,我们用&lt;span class=&quot;math inline&quot;&gt;\(\frac{n}{d}\)&lt;/span&gt;来代替&lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;，就变成了&lt;/p&gt;
&lt;p&gt;\[\sum\limits_{i=1}^n\sum\limits_{d\neq 1,d|i}g(d)f(\frac{i}{d}) \]&lt;/p&gt;
&lt;p&gt;\[=\sum\limits_{d=2}^n g(d)\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}f(i) \]&lt;/p&gt;
&lt;p&gt;\[=\sum\limits_{d=2}^n g(d)S(\lfloor\frac{n}{d}\rfloor) \]&lt;/p&gt;
&lt;p&gt;因为&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;的前缀和可以快速求出，所以直接数论分块，后面的&lt;span class=&quot;math inline&quot;&gt;\(S(\frac{n}{d})\)&lt;/span&gt;直接递归就好了。&lt;/p&gt;
&lt;p&gt;这样我们得到的是&lt;span class=&quot;math inline&quot;&gt;\(\sum\limits_{i=1}^ng(1)f(i)=g(1)\sum\limits_{i=1}^n f(i)\)&lt;/span&gt;，所以答案除以&lt;span class=&quot;math inline&quot;&gt;\(g(1)\)&lt;/span&gt;（一般为1）就好了。&lt;/p&gt;

&lt;p&gt;以求&lt;span class=&quot;math inline&quot;&gt;\(\varphi\)&lt;/span&gt;的前缀和为例。因为&lt;span class=&quot;math inline&quot;&gt;\(f*1=Id\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(Id\)&lt;/span&gt;的前缀和都非常好求，所以我们令&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;即可。&lt;/p&gt;
&lt;p&gt;\[S(n)=\sum\limits_{i=1}^n\sum\limits_{d|i}\varphi(d)-\sum\limits_{i=1}^n\sum\limits_{d|i,d\neq i}\varphi(d)\\ = \sum\limits_{i=1}^ni-\sum\limits_{i=1}^n\sum\limits_{d|i,d\neq 1}\varphi(\frac{n}{d})\\ =\frac{n(n+1)}{2}-\sum\limits_{d=2}^n\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(i)\\ = \frac{n(n+1}{2}-\sum\limits_{d=2}^nS(\lfloor\frac{n}{d}\rfloor) \]&lt;/p&gt;
&lt;p&gt;再来推一下&lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt;的前缀和。因为&lt;span class=&quot;math inline&quot;&gt;\(\mu * 1= \epsilon\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;的前缀和都非常好求，所以还是令&lt;span class=&quot;math inline&quot;&gt;\(g=1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;\[S(n)=\sum\limits_{i=1}^n\sum\limits_{d|i}\mu(d)-\sum\limits_{i=1}^n\sum\limits_{d|i,d\neq i}\mu(d)\\ =1-\sum\limits_{d=2}^n\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(i)\\ = 1-\sum\limits_{d=2}^nS(\lfloor\frac{n}{d}\rfloor) \]&lt;/p&gt;

&lt;p&gt;这样直接搜的复杂度是&lt;span class=&quot;math inline&quot;&gt;\(O(n^{\frac{3}{4}})\)&lt;/span&gt;，为了使复杂度更优，我们需要先预处理出一部分答案，如果我们预处理除了&lt;span class=&quot;math inline&quot;&gt;\([1,K]\)&lt;/span&gt;的答案，当计算&lt;span class=&quot;math inline&quot;&gt;\([1,K]\)&lt;/span&gt;中的结果时，直接返回即可。&lt;/p&gt;
&lt;p&gt;可以证明当&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;取&lt;span class=&quot;math inline&quot;&gt;\(n^{\frac{2}{3}}\)&lt;/span&gt;时，复杂度最优秀为&lt;span class=&quot;math inline&quot;&gt;\(n^{\frac{2}{3}}\)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;为了让复杂度是正确的，我们肯定要将每次算出的结果记忆化下来。因为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;比较大，所以需要用&lt;span class=&quot;math inline&quot;&gt;\(map\)&lt;/span&gt;来记忆化。这样复杂度就会多个&lt;span class=&quot;math inline&quot;&gt;\(log\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还有一种方法，因为我们每次递归到的&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;肯定满足:所有满足&lt;span class=&quot;math inline&quot;&gt;\(\frac{n}{y}=\frac{n}{x}\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;中，只有&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;会被计算到。所以我们可以用一个数组ma记忆化，当查询的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;小于等于&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;时，我们直接范围答案，当查询的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;大于&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;时，我们查看&lt;span class=&quot;math inline&quot;&gt;\(ma[\lfloor \frac{n}{K}\rfloor]\)&lt;/span&gt;中的值即可。&lt;/p&gt;
&lt;p&gt;当有多次询问时，第二种方法需要清空，复杂度可能不如第一种。&lt;/p&gt;

&lt;p&gt;以求&lt;span class=&quot;math inline&quot;&gt;\(\varphi\)&lt;/span&gt;的前缀和为例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void pre() {
        phi[1] = 1;
        for(int i = 2;i &amp;lt; N;++i) {
                if(!vis[i]) {
                        prime[++tot] = i;
                        phi[i] = i - 1;
                }
                for(int j = 1;j &amp;lt;= tot &amp;amp;&amp;amp; prime[j] * i &amp;lt; N;++j) {
                        vis[prime[j] * i] = 1;
                        if(i % prime[j]) {
                                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
                        }
                        else {
                                phi[i * prime[j]] = phi[i] * prime[j];
                                break;
                        }
                }
        }
        for(int i = 2;i &amp;lt; N;++i) phi[i] = (phi[i] + phi[i - 1]) % mod;
}
ll MAX;

ll PHI(ll n) {
        if(n &amp;lt; N) return phi[n];
        
        if(vis[MAX / n]) return maphi[MAX / n];
        vis[MAX / n] = 1;
        ll ret = (n % mod) * ((n + 1) % mod) % mod * inv % mod;

        for(ll l = 2,r;l &amp;lt;= n;l = r + 1) {
                r = n / (n / l);
                ret -= ((r - l + 1) % mod) * PHI(n / l) % mod;
                ret %= mod;
        }
        return maphi[MAX / n] = ret;
}

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 25 Apr 2020 00:26:00 +0000</pubDate>
<dc:creator>wxyww</dc:creator>
<og:description>杜教筛用来求数论函数$f$前缀和。复杂度为$O(n^{\frac{2}{3}})$ 前提 如果我们要求$S(n)=\sum\limits_{i=1}^nf(i)$，那么需要找到一个数论函数$g$，满足</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wxyww/p/dujiaoshai.html</dc:identifier>
</item>
<item>
<title>从“股票问题”谈动态规划问题的解决思路 - wunsiang</title>
<link>http://www.cnblogs.com/wunsiang/p/12771442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wunsiang/p/12771442.html</guid>
<description>&lt;p&gt;股票问题应该算是比较复杂的动态规划问题了，笔者在研究了多次之后记录下一点心得体会。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;173.09362218814&quot;&gt;
&lt;h2 id=&quot;总体思路&quot;&gt;总体思路&lt;/h2&gt;
&lt;p&gt;    有过在Leetcode上练习经历的同学们对股票问题肯定不会感到陌生，动态规划问题的核心在于寻找&lt;strong&gt;状态转移方程&lt;/strong&gt;，对于常规的动态规划问题，如零钱问题、背包问题，我们可能会觉得状态转移方程找起来并不费劲，但对于股票问题，可能很多同学都觉得状态转移方程难找。在我对股票问题进行了反复研究之后，我发现其实之所以股票系列分析存在这种困难，并不是“转移方程难找”，而是其具有多个维度的“&lt;strong&gt;状态&lt;/strong&gt;”，其状态的复杂性导致我们在没有处理好状态的情况下便谈不上解决“转移方程”的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;状态的确定与处理？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们要考虑的是状态有哪些，具体到本题，共有三个维度的状态：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;天数&lt;/li&gt;
&lt;li&gt;允许交易的最大次数&lt;/li&gt;
&lt;li&gt;用户账户当前状态（持有或者未持有股票）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其次是如何处理状态，其实大家可以细细回想，对于动态规划问题我们处理状态，虽然你可能没有注意，其实使用的是“&lt;strong&gt;穷举&lt;/strong&gt;”思想，比如说背包问题中的物品数量和背包容量。至于怎么枚举，看下面的伪代码你肯定就明白啦！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该伪代码参考自&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/&quot;&gt;Leetcode&lt;/a&gt;，个人认为这个状态枚举思路的伪代码写的非常好，但是作者对于股票问题状态划分有些复杂。&lt;br/&gt;那具体到本题，我们的状态框架如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;dp[i][k][0 or 1] //前面说了三个维度，自然dp数组也是三维的
for(int i = 0;i &amp;lt; n;i++)
    for(int j = 0;j &amp;lt; k;j++)
        dp[i][j][0] 取优
        dp[i][j][1] 取优//账户状态这个维度只有两种可能，就直接计算就好啦。
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;那我们接下里将通过对股票问题的具体实例讲解的方式来介绍具体解法，目前剩下的其实就是个状态转移方程的事情啦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;各个击破&quot;&gt;各个击破&lt;/h2&gt;
&lt;h3 id=&quot;k--1的情况&quot;&gt;k = 1的情况&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/%22%3Ehttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/&quot;&gt;121. 买卖股票的最佳时机&lt;/a&gt;&lt;br/&gt;k = 1是思路很清晰，其实只需要直接一趟遍历，并且记录下当前元素之前的最小元素并利用其计算当前天卖出最大收益即可。这个其实感觉不算典型动态规划。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null || prices.length == 0)
            return 0;
        int min = prices[0],max = 0;
        for(int i = 1;i &amp;lt; prices.length;i++){
            max = Math.max(max,prices[i] - min);
            min = Math.min(min,prices[i]);
            
        }
        return max;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;k值不受限&quot;&gt;k值不受限&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/%22%3Ehttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/&quot;&gt;122. 买卖股票的最佳时机 II&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;枚举框架&quot;&gt;枚举框架&lt;/h4&gt;
&lt;p&gt;按照我们最开始的状态枚举框架，k不受限即从前向后遍历（了解完全背包问题的同学肯定熟悉），并且不设置k维度即可（只有天数、账户状态两个维度）。&lt;/p&gt;
&lt;h4 id=&quot;状态转移方程&quot;&gt;状态转移方程&lt;/h4&gt;
&lt;p&gt;当前天未持有，则有两种情况：&lt;br/&gt;1、昨天就未持有，今天也不买，则为&lt;code&gt;dp[i - 1][0]&lt;/code&gt;&lt;br/&gt;2、昨天持有，今天卖出，则为&lt;code&gt;dp[i - 1][1] + prices[i])&lt;/code&gt;&lt;br/&gt;综上，二者取优&lt;br/&gt;&lt;code&gt;dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][1] + prices[i]);&lt;/code&gt;&lt;br/&gt;同样，当前天持有也是两种情况：&lt;br/&gt;1、昨天持有，则为&lt;code&gt;dp[i - 1][1]&lt;/code&gt;&lt;br/&gt;2、昨天未持有，今天买入&lt;code&gt;dp[i - 1][0] - prices[i]&lt;/code&gt;&lt;br/&gt;综上，二者取优&lt;br/&gt;&lt;code&gt;dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - prices[i]);&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];//0为未持有，1为持有
        dp[0][0] = 0;
        dp[0][1] = 0 - prices[0];
        for(int i = 1;i &amp;lt; prices.length;i++){
            dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - prices[i]);
        }
        return dp[prices.length - 1][0];
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;k值不受限且包含冷冻期&quot;&gt;k值不受限且包含冷冻期&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/%22%3Ehttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&quot;&gt;309. 最佳买卖股票时机含冷冻期&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;枚举框架-2&quot;&gt;枚举框架&lt;/h4&gt;
&lt;p&gt;按照我们最开始的状态枚举框架，k不受限即从前向后遍历（了解完全背包问题的同学肯定熟悉），并且不设置k维度即可（只有天数、账户状态两个维度）。&lt;/p&gt;
&lt;h4 id=&quot;状态转移方程-2&quot;&gt;状态转移方程&lt;/h4&gt;
&lt;p&gt;当前天未持有，则有两种情况：&lt;br/&gt;1、昨天就未持有，今天也不买，则为&lt;code&gt;dp[i - 1][0]&lt;/code&gt;&lt;br/&gt;2、昨天持有，今天卖出，则为&lt;code&gt;dp[i - 1][1] + prices[i - 1])&lt;/code&gt;，注意，price从0开始索引&lt;br/&gt;综上，二者取优&lt;br/&gt;&lt;code&gt;dp[i][0] = Math.max(dp[i - 1][1] + prices[i - 1],dp[i - 1][0]);&lt;/code&gt;&lt;br/&gt;同样，当前天持有也是两种情况，但由于存在冷冻期，买出的话需要从i-2转移过来：&lt;br/&gt;1、昨天持有，则为&lt;code&gt;dp[i - 1][1]&lt;/code&gt;&lt;br/&gt;2、昨天未持有，今天买入&lt;code&gt;dp[i - 2][0] - prices[i - 1]&lt;/code&gt;&lt;br/&gt;综上，二者取优&lt;br/&gt;&lt;code&gt;dp[i][1] = Math.max(dp[i - 1][1],i - 2 &amp;gt;= 0 ? dp[i - 2][0] - prices[i - 1]: 0 - prices[i - 1])&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length + 1][2];
        dp[0][1] = Integer.MIN_VALUE;
        for(int i = 1;i &amp;lt;= prices.length;i++){
            dp[i][0] = Math.max(dp[i - 1][1] + prices[i - 1],dp[i - 1][0]);
            dp[i][1] = Math.max(dp[i - 1][1],i - 2 &amp;gt;= 0 ? dp[i - 2][0] - prices[i - 1]: 0 - prices[i - 1]);
        }
        return dp[prices.length][0];
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;k值不受限且包含手续费&quot;&gt;k值不受限且包含手续费&lt;/h3&gt;
&lt;p&gt;状态转移方程与k值不受限完全相同，只是卖出时要减手续费即可&lt;/p&gt;
&lt;h4 id=&quot;枚举框架-3&quot;&gt;枚举框架&lt;/h4&gt;
&lt;p&gt;按照我们最开始的状态枚举框架，k不受限即从前向后遍历（了解完全背包问题的同学肯定熟悉），并且不设置k维度即可（只有天数、账户状态两个维度）。&lt;/p&gt;
&lt;h4 id=&quot;状态转移方程-3&quot;&gt;状态转移方程&lt;/h4&gt;
&lt;p&gt;当前天未持有，则有两种情况：&lt;br/&gt;1、昨天就未持有，今天也不买，则为&lt;code&gt;dp[i - 1][0]&lt;/code&gt;&lt;br/&gt;2、昨天持有，今天卖出，则为&lt;code&gt;dp[i - 1][1] + prices[i] - fee)&lt;/code&gt;&lt;br/&gt;综上，二者取优&lt;br/&gt;&lt;code&gt;dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][1] + prices[i] - fee);&lt;/code&gt;&lt;br/&gt;同样，当前天持有也是两种情况：&lt;br/&gt;1、昨天持有，则为&lt;code&gt;dp[i - 1][1]&lt;/code&gt;&lt;br/&gt;2、昨天未持有，今天买入&lt;code&gt;dp[i - 1][0] - prices[i]&lt;/code&gt;&lt;br/&gt;综上，二者取优&lt;br/&gt;&lt;code&gt;dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - prices[i]);&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[][] dp = new int[prices.length][2];//0为未持有，1为持有
        dp[0][0] = 0;
        dp[0][1] = 0 - prices[0];
        for(int i = 1;i &amp;lt; prices.length;i++){
            dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][1] + prices[i] - fee);
            dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - prices[i]);
        }
        return dp[prices.length - 1][0];
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;k为任意整数&quot;&gt;k为任意整数&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/&quot;&gt;188. 买卖股票的最佳时机 IV&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;枚举框架-4&quot;&gt;枚举框架&lt;/h4&gt;
&lt;p&gt;枚举框架与本文最开始分析的思路完全相同，只需要对天、最大交易次数、账户状态这三个维度进行枚举即可。&lt;/p&gt;
&lt;h4 id=&quot;状态转移方程-4&quot;&gt;状态转移方程&lt;/h4&gt;
&lt;p&gt;当前天未持有，则有两种情况：&lt;br/&gt;1、昨天就未持有，今天也不买，且显然这种情况不会增加交易次数，则为&lt;code&gt;dp[i - 1][j][0]&lt;/code&gt;&lt;br/&gt;2、昨天持有，今天卖出，卖出操作并不会增加交易次数，仍然是本交易次数维度进行转移，为&lt;code&gt;dp[i - 1][j][1] + prices[i]&lt;/code&gt;&lt;br/&gt;综上，二者取优&lt;br/&gt;&lt;code&gt;dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);&lt;/code&gt;&lt;br/&gt;同样，当前天持有也是两种情况：&lt;br/&gt;1、昨天持有，则为&lt;code&gt;dp[i - 1][j][1]&lt;/code&gt;&lt;br/&gt;2、昨天未持有，今天买入，注意买入会引起交易次数变化，所以为&lt;code&gt;dp[i - 1][j - 1][0] - prices[i]&lt;/code&gt;&lt;br/&gt;综上，二者取优&lt;br/&gt;&lt;code&gt;dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices == null || prices.length &amp;lt; 2)
            return 0;
        int[][][] dp = new int[prices.length][k + 1][2];//0是未持有，1是持有
        for(int i = 0;i &amp;lt;= k;i++){//第一天base case
            dp[0][i][1] = 0 - prices[0];
        }
        for(int i = 1;i &amp;lt; prices.length;i++){
            for(int j = 1;j &amp;lt;= k;j++){
                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
            }
        }
        return dp[prices.length - 1][k][0];
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;看到这里，其实我们就会明白，动态规划其实要确定的三部分就是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;dp语义&lt;/li&gt;
&lt;li&gt;状态枚举框架&lt;/li&gt;
&lt;li&gt;转移方程&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;确定了这三样，一切便都迎刃而解了。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 25 Apr 2020 00:16:00 +0000</pubDate>
<dc:creator>wunsiang</dc:creator>
<og:description>股票问题应该算是比较复杂的动态规划问题了，笔者在研究了多次之后记录下一点心得体会。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wunsiang/p/12771442.html</dc:identifier>
</item>
<item>
<title>IDEA惊天bug：进程已结束,退出代码-1073741819 (0xC0000005) - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12771440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12771440.html</guid>
<description>&lt;p&gt;由于昨天要写的文章没有写完，于是今天早上我四点半就“自然醒”了，心里面有事，睡觉也不安稳。洗漱完毕后，我打开电脑，正襟危坐，摆出一副要干架的态势，不能再拖了。&lt;/p&gt;
&lt;p&gt;要写的文章中涉及到一串代码，关于 Undertow 的一个入门示例，贴出来大家看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;UndertowTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Undertow server = Undertow.builder()&lt;br/&gt;.addHttpListener(&lt;span class=&quot;hljs-number&quot;&gt;8080&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;)&lt;br/&gt;.setHandler(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HttpHandler() {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; HttpServerExchange exchange)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, &lt;span class=&quot;hljs-string&quot;&gt;&quot;text/plain&quot;&lt;/span&gt;);&lt;br/&gt;exchange.getResponseSender().send(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}).build();&lt;br/&gt;server.start();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Undertow 是大名鼎鼎的 Red Hat（红帽子）公司开发的一款基于 NIO 的高性能 Web 服务器软件，不需要单独安装软件，只需要几行代码就可以在 Java 应用程序中启动一个 Web 服务，就像上面那段代码。&lt;/p&gt;
&lt;p&gt;前提条件是你已经在 pom.xml 文件中引入了 Undertow 的依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.undertow&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;undertow-core&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.28.Final&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没想到，代码在 IDEA 中运行后，竟然非正常退出了！&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;没有任何错误提示，真的是郁闷。主机名 localhost 没有问题，端口 8080 也没有被占用，但 main 方法在没有任何外力的因素下直接结束了。在浏览器地址栏中输入 &lt;code&gt;http://localhost:8080&lt;/code&gt; 自然也无法显示“Hello World”。&lt;/p&gt;
&lt;p&gt;回看 Run 面板中的输出信息，唯一让我感到疑惑的就是下面这行：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;进程已结束,退出代码-1073741819 (0xC0000005)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正常来说，程序执行的输出结果如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;进程已结束,退出代码0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;退出代码是 0，表示程序正常结束；退出代码是 1073741819，它代表什么意思呢？&lt;/p&gt;
&lt;p&gt;肯定是非正常呗。我第一时间想到的原因是，会不会是我代码写错了？于是查看了 Undertow 的官网，一个单词一个单词的检查，甚至上了 beyond compare 进行比较，也没有找到任何可疑之处。&lt;/p&gt;
&lt;p&gt;折腾得够呛，于是不得不上了谷歌大法：&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;换了各种关键词，查阅了各种文章，没有找到可行的解决办法。谷歌无果，我想那就试试某度吧，结果搜到了游戏，天地良心啊。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;搜索引擎靠不住，那就只能靠自己了。于是我写下了这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestClose&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;Thread.sleep(&lt;span class=&quot;hljs-number&quot;&gt;10000000&lt;/span&gt;);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果大吃一惊。我揉了好几次眼睛，甚至上了倍清亮眼药水，结果也是非正常退出，错误代码和之前的 Undertow 一致。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;搞什么嘛，这可是 &lt;code&gt;Thread.sleep(10000000)&lt;/code&gt; 休眠大法啊，也能在一秒内结束，那一定不是 Undertow 的代码示例写错了，而是 IDEA 在作妖。&lt;/p&gt;
&lt;p&gt;事到如今，我想起了被打入冷宫的 Eclipse。同样的代码，进程没有立即结束掉。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;Undertow 的代码示例也没有问题，程序没有立即结束。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-06.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;在浏览器中输入 &lt;code&gt;http://localhost:8080&lt;/code&gt; 也能正常访问。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-07.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;对比之后，问题就很确定了，出在 IDEA 身上，一定是它哪根神经错乱了。于是换了一下谷歌搜索的关键词，结果如下所示。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-08.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;果然也有同行遇到了类似的问题，但文章中提到的原因竟然是金山词霸的划词翻译，这有点太扯了吧？&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-09.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;虽然有点扯，但的确值得试一试，毕竟山穷水尽了啊，况且我的电脑上真的安装了金山词霸，并且是打开状态。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-10.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;那就退出试试呗，结果。。。。。。。。。。真的有用啊。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-11.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这次，进程没有主动结束，这是什么神奇的操作啊？人生第一次开始怀疑科学了！&lt;/p&gt;
&lt;p&gt;既然和金山词霸有关系，那么我就脑洞打开了，是不是因为我装了汉化插件的关系？于是我把 IDEA 的汉化插件禁用，并且在重启之前打开了金山词霸。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-12.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;结果证明没关系，进程主动结束了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-idea-bug-13.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;于是只好再次退出金山词霸。没想到，当我点击 Run 的小图标再次运行程序时，IDEA 竟然闪退了。看来它们之间的确有着不可告人的秘密，具体原因未知。&lt;/p&gt;
&lt;p&gt;不管怎么说，这个莫名其妙的 bug 是解决了，有必要总结一波经验心得了，希望能够给小伙伴们在开发中一些启发。因为作为程序员，面对不会说话的计算机，有时候，真的会遇到一些难以名状的错误，把我们折腾得够呛。&lt;/p&gt;
&lt;p&gt;经验一：保持冷静，切勿暴躁，心态失衡时容易捶鼠标，捶键盘，捶坏了，还得买新的。&lt;/p&gt;
&lt;p&gt;经验二：先从自身代码找原因，复制粘贴有时候也会出现偏差，这时候，最好就和源头对比一下。如果肉眼发现不了，上比较工具，靠谱。&lt;/p&gt;
&lt;p&gt;经验三：问谷歌，不要问某度。这年头，经常听到一些小伙伴们抱怨说，公司不允许上网，遇到问题时真的无从下手，我只能说这样的公司真的是闭关锁国啊。&lt;/p&gt;
&lt;p&gt;经验四：换个环境试一试。同样的代码，环境不同，运行后的解决真有可能不同。IDEA 中出错，放 Eclipse 中试试；Windows 下出错，放 Linux 下试试；自己的环境有问题，放同事的环境下试试。&lt;/p&gt;
&lt;p&gt;经验五：搜索的时候换一下关键词，真的是“柳暗花明又一村”啊。&lt;/p&gt;
&lt;p&gt;经验六：重复以上。&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;鸣谢&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;好了，我亲爱的读者朋友，以上就是本文的全部内容了。看完之后，再遇到面试官问 Java 到底是值传递还是引用传递时，就不用担心被刁难了。我是沉默王二，一枚有趣的程序员。&lt;strong&gt;原创不易，莫要白票，请你为本文点赞个吧&lt;/strong&gt;，这将是我写作更多优质文章的最强动力。&lt;/p&gt;
&lt;blockquote readability=&quot;6.8390804597701&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读，回复【&lt;strong&gt;666&lt;/strong&gt;】更有我为你精心准备的 500G 高清教学视频（已分门别类）。本文 &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;GitHub&lt;/a&gt; 已经收录，有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 25 Apr 2020 00:14:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>由于昨天要写的文章没有写完，于是今天早上我四点半就“自然醒”了，心里面有事，睡觉也不安稳。洗漱完毕后，我打开电脑，正襟危坐，摆出一副要干架的态势，不能再拖了。 要写的文章中涉及到一串代码，关于 Und</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12771440.html</dc:identifier>
</item>
<item>
<title>01、Hibernate安装配置 - Pluto_H</title>
<link>http://www.cnblogs.com/CSAH/p/12771345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CSAH/p/12771345.html</guid>
<description>&lt;p&gt;1、查看你的Eclipse的版本：Help | About Eclipse&lt;/p&gt;
&lt;p&gt;      Version: 2018-12 (4.10.0)&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200425024436766-1181204811.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;2、HibernateTools的下载地址为：http://www.jboss.org/tools/download/&lt;/p&gt;
&lt;p&gt;！！！注意Eclipse版本号 Version: 2018-12 (4.10.0)表示适用于 Version: 2018-12 (4.10.0)及更新版本&lt;br/&gt;选择右边的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200425024759458-1010009992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 点击Download后进入一下页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200425024817471-528092681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;点击Update Site 即可获取下载地址  http://download.jboss.org/jbosstools/oxygen/stable/updates/    复制下载地址&lt;br/&gt;打开Eclipse   -&amp;gt; Help | Install New Software | Add&lt;br/&gt;输入name：Hibernate&lt;br/&gt;粘贴  http://download.jboss.org/jbosstools/oxygen/stable/updates/&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200425024838501-230643366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击ok -&amp;gt;选择JBoss Web and Java EE Development 下的 Hibernate Tools   -&amp;gt;Next&lt;/p&gt;
&lt;p&gt;接受协议，便可以开始安装了&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200425024926552-1013646335.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;重启Eclipse&lt;/p&gt;
&lt;p&gt;file |  new | Other |输入Hiber&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200425024944557-1350081837.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt; 说明HibernateTools插件安装成功&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;原文链接：https://blog.csdn.net/FJJ543/java/article/details/79766457&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 24 Apr 2020 18:55:00 +0000</pubDate>
<dc:creator>Pluto_H</dc:creator>
<og:description>1、查看你的Eclipse的版本：Help | About Eclipse Version: 2018-12 (4.10.0) 2、HibernateTools的下载地址为：http://www.jb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CSAH/p/12771345.html</dc:identifier>
</item>
<item>
<title> IO多路复用小故事 - 烟草的香味</title>
<link>http://www.cnblogs.com/hujingnb/p/12771338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujingnb/p/12771338.html</guid>
<description>&lt;p&gt;小王住在某城市, 生活并长大. 最近, 小城引进了一个企业, 邮局. 这个邮局可了不得, 只要你花上几角钱, 就可以将一封信送到千里之外的朋友手中. 小王也趁机体验了一把, 得劲.&lt;/p&gt;
&lt;p&gt;这天, 小王躺在床上想, 既然这个邮局这么好, 咱何不从中分一杯羹呢? 但是现在人家邮局基本都可以说是垄断了, 咱这刚刚起步又能如何呢? 哎, 有了, 既然他把信都收集起来, 那总归是要送出去的吧, 我就把送信的给包下来. 想到就做到, 第二天, 小王就去邮局谈这个事情, 经过一番协商, 将送往京津冀的信件包了下来.&lt;/p&gt;

&lt;p&gt;包下来之后, 简单注册了一下, 小公司正式成立了. 先招个人来, 毕竟咱也是老板了. 招聘信息发出后, 第二天新员工小张就到了. 正式开工了.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;王总: 小张, 去邮局把北京的信件拿回来
小张: 好嘞
没多大一会, 小张回来了, 还带回来了一堆信件
王总: 嗯, 不错. 再去把天津的信件拿回来吧. 
这次, 一直等到第五天, 小张回来了, 同时也把信件带回来了. 
王总: 小张, 怎么这么慢啊? 奖金还想不想要了? 
小张: 没办法啊, 王总. 邮局那边的人说了, 没有信件, 就不让我回来. 
王总: 但是已经有用户投诉了, 送往河北的信已经发出好几天了, 还没送到, 咱们想个解决办法吧. 
小张: 王总, 既然这样, 那就只能在招人了, 一个人负责取一个地方的信件, 这样才能保证信件到了之后可以立马拿回来啊. 
王总: 行吧, 这也是没有办法的办法了. 
于是, 又招来了两个员工, 每个员工负责一个地区的信件, 不停的去邮局取信. 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是最古老的版本了, 多线程阻塞式读取. 很显然, 耗费大量人力.&lt;/p&gt;

&lt;p&gt;就这样过了两个月, 小王的业务是越做越大, 在原来京津冀的基础上, 又承包了内蒙地区. 所以, 需要为内蒙地区再招一个人进来. 王总是越想越不对劲, 那岂不是以后再扩展业务, 都要频繁的招人嘛? 不行, 我得找邮局聊聊. 于是, 王总找到了邮局局长.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;王总: 局长, 听说我的人去邮局拿信, 没有信就不让人走? 这是什么道理? 
局长: 什么? 还有这种事情, 王总莫急, 我回去问问. 
王总: 那真是辛苦局长了. 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这局长办事, 效率就是不一样, 第二天消息回来了. 以后邮局不许把收信的人扣下. 小王心中的小算盘得逞了. 你想啊, 原本需要4个人干的活, 现在一个人就干了. 只要不停的去邮局取信就行了. 小张跟自己的时间最长, 王总考虑之后, 还是决定把小张留下.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;王总: 小张啊, 看你最近表现不错, 我决定工资给你翻一倍. 
小张: 谢谢王总. 听说最近邮局出了新政策, 我每次取信的时候, 貌似都没有人留我了. 
王总: 嗯, 没错. 经过我与邮局领导讨论, 决定废除之前留人的规定. 所以我决定公司取信的员工只留你一个人. 
这下可把小张坑惨了, 他需要不停的取邮局取信, 不管有没有, 都要回来汇报一下, 然后继续去取下一个地方的信件. 
但是公司现在只需要一个人就可以了, 嗯, 省钱. 

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是在之前基础上, 稍加改进之后的: 非阻塞式轮训读取.&lt;/p&gt;

&lt;p&gt;最然公司现在只需要一个人了, 但是小张这每天跑来跑去的给累够呛. 现在是4个地方的信件, 全部拿回来, 小张就需要往邮局跑4趟, 本来一趟就能拿回来, 这不多此一举么? 费时费力的. 想到这, 小张发现了这个规则需要改进的地方, 但是他又不知道如何跟邮局高层反应, 只好告诉王总. 王总一听, 嗯, 有道理. 如果可以这样的话, 那拿信件的速度不就更快了么, 用户体验上更上一层楼啊, 得赶快落实下来.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;王总: 局长啊, 我觉得现在的规定有些可以改进的地方. 
局长: 嗯? 我觉得挺好啊, 有什么问题你说说看. 
王总: 现在我们的人去取信, 每次只能取一个地方的信, 但是我承包了4个城市, 能不能取信的时候可以一次性把4个城市的信件都给我啊. 
局长: 嗯, 你的建议很好, 不过我还要开会讨论一下. 
王总悄悄的留下一个红包, 走了. 
没过几天, 邮局传来消息, 王总之前提的已经下发了最新命令. 允许取信人批量获取. 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从此, 从邮局取信更快捷了.&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;select&lt;/strong&gt;版本. 可以一次性批量向系统提出查询, 然后批量返回.&lt;/p&gt;

&lt;p&gt;就这样又安稳的过了五个月, 随着业务的不断长大, 王总已经接下了全国40多个地区的信件. 但是随着地区的增加, 小张去取信的速度也变慢了, 王总心里不得劲了, 这个小张变的懒惰了, 回头要好好说说他.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;王总: 小张啊, 公司慢慢壮大了, 怎么你取信的速度变得慢了不少, 倒也没见你信件多拿回来啊. 
小张: 王总, 你是不知道. 每次我去取信, 都要邮局的人一个城市一个城市的找, 之前只有4个城市, 找的自然快. 现在几十个城市, 自然就变慢了. 
王总: 嗯, 这倒是个问题, 那有没有什么好的想法呢? 
小张: 王总, 其实我已经想过了. 现在我去拿信, 不光他们找的慢, 还可能找到最后一封信件都没有. 之前我一天可能要往邮局跑几百趟, 很多其实都没有拿到信件.
    当时我就想, 如果每次等有信件了, 我再去拿, 那我就可以少跑几次了. 所以, 如果邮局那边有新的信件, 打电话告诉我一下, 然后我去拿回来就完美了. 
王总: 嗯, 也好, 之前总让你跑, 确实不是个办法. 
经过与邮局的一番协商, 这个新的方案再度落实了. 这次小张倒落得清闲, 有信件的时候就去拿, 没有的时候喝喝茶等着就是了. 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从此, 王总的公司日渐壮大, 小张也平步青云.&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;epoll&lt;/strong&gt;版本, 将需要的数据绑定, 交由系统管理, 新消息是由系统通知.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以上是将一篇历史文章简单故事化, 查看历史文章: &lt;a href=&quot;https://www.cnblogs.com/hujingnb/p/12439661.html&quot;&gt;redis的多路复用是什么鬼&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Apr 2020 18:32:00 +0000</pubDate>
<dc:creator>烟草的香味</dc:creator>
<og:description>背景故事 小王住在某城市, 生活并长大. 最近, 小城引进了一个企业, 邮局. 这个邮局可了不得, 只要你花上几角钱, 就可以将一封信送到千里之外的朋友手中. 小王也趁机体验了一把, 得劲. 这天,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hujingnb/p/12771338.html</dc:identifier>
</item>
<item>
<title>JDBC教程——检视阅读 - 卡斯特梅的雨伞</title>
<link>http://www.cnblogs.com/castamere/p/12771313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/castamere/p/12771313.html</guid>
<description>&lt;p&gt;JDBC教程——检视阅读&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;JDBC教程——W3Cschool&lt;/p&gt;
&lt;p&gt;JDBC教程——一点教程，有高级部分&lt;/p&gt;
&lt;p&gt;JDBC教程——易百&lt;/p&gt;
&lt;p&gt;JDBC入门教程 – 终极指南&lt;/p&gt;
&lt;p&gt;略读&lt;/p&gt;
&lt;p&gt;三层架构详解，JDBC在数据访问层：&lt;/p&gt;
&lt;p&gt;UI(表现层): 主要是指与用户交互的界面。用于接收用户输入的数据和显示处理后用户需要的数据。&lt;/p&gt;
&lt;p&gt;BLL:(业务逻辑层): UI层和DAL层之间的桥梁。实现业务逻辑。业务逻辑具体包含：验证、计算、业务规则等等。&lt;/p&gt;
&lt;p&gt;DAL:(数据访问层): 与数据库打交道。主要实现对数据的增、删、改、查。将存储在数据库中的数据提交给业务层，同时将业务层处理的数据保存到数据库。（当然这些操作都是基于UI层的。用户的需求反映给界面（UI），UI反映给BLL，BLL反映给DAL，DAL进行数据的操作，操作后再一一返回，直到将用户所需数据反馈给用户）&lt;/p&gt;
&lt;p&gt;使用三层架构的目的：解耦 。&lt;/p&gt;
&lt;p&gt;三层架构详解&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;驱动程序（Drivers）&lt;/p&gt;
&lt;p&gt;JDBC驱动管理器（java.sql.DriverManager）是JDBC API中最重要的元素之一。 它是用来处理一系列JDBC驱动程序的基本服务。它含有很多机制和对象，能够将Java应用程序连接到所需的JDBC驱动程序。它负责管理这些不同类型的JDBC数据库驱动程序。总结一下驱动管理器的主要功能就是：获取当前可用的驱动列表；处理特定的的驱动程序和数据库之间的连接。&lt;/p&gt;
&lt;p&gt;我们通过方法DriverManager.registerDriver()来注册驱动程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new org.hsqldb.jdbc.JDBCDriver();
DriverManager.registerDriver( new org.hsqldb.jdbc.JDBCDriver() );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也可以调用方法Class.forName() 加载驱动程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Loading the HSQLDB JDBC driver
Class.forName( &quot;org.hsqldb.jdbc.JDBCDriver&quot; );

// connection to JDBC using mysql driver
Class.forName( &quot;com.mysql.jdbc.Driver&quot; );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这二者的主要区别是：前者方法registerDerver()需要保证驱动程序在编译时就是可用的；后者加载驱动程序类文件的方式，不需要驱动程序在编译时是可用的。JDBC 4版本后，实际上没有必要调用这些方法，应用程序不需要单独注册这些驱动，也不需要加载驱动类。我们也不推荐使用方法registerDriver()来手动加载驱动程序。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;JDBC 指南&lt;/p&gt;
&lt;p&gt;JDBC 简介&lt;/p&gt;
&lt;p&gt;什么是 JDBC？&lt;/p&gt;
&lt;p&gt;JDBC (Java Database Connectivity )指 Java 数据库连接，是一种标准Java应用编程接口（ JAVA API），用来连接 Java 编程语言和广泛的数据库。&lt;/p&gt;
&lt;p&gt;JDBC API 库包含下面提到的每个任务，都是与数据库相关的常用用法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;制作到数据库的连接。&lt;/li&gt;
&lt;li&gt;创建 SQL 或 MySQL 语句。&lt;/li&gt;
&lt;li&gt;执行 SQL 或 MySQL 查询数据库。&lt;/li&gt;
&lt;li&gt;查看和修改所产生的记录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从根本上来说，JDBC 是一种规范，它提供了一套完整的接口，允许便携式访问到底层数据库，因此可以用 Java 编写不同类型的可执行文件.&lt;/p&gt;
&lt;p&gt;JDBC 架构&lt;/p&gt;
&lt;p&gt;JDBC 的 API 支持两层和三层处理模式进行数据库访问，但一般的 JDBC 架构由两层处理模式组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDBC API: 提供了应用程序对 JDBC 管理器的连接（crud数据库操作）。&lt;/li&gt;
&lt;li&gt;JDBC Driver API: 提供了 JDBC 管理器对驱动程序连接(驱动连接)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JDBC API 使用驱动程序管理器和数据库特定的驱动程序来提供各种各样的 （heterogeneous）数据库的透明连接。&lt;/p&gt;
&lt;p&gt;JDBC 驱动程序管理器可确保正确的驱动程序来访问每个数据源。该驱动程序管理器能够支持连接到多个各种各样的数据库的多个并发的驱动程序。&lt;/p&gt;
&lt;p&gt;以下是结构图，其中显示了驱动程序管理器相对于在 JDBC 驱动程序和 Java 应用程序所处的位置。&lt;/p&gt;
&lt;p&gt;常见的 JDBC 组件&lt;/p&gt;
&lt;p&gt;JDBC 的 API 提供了以下接口和类：&lt;/p&gt;
&lt;p&gt;DriverManager ：这个类管理一系列数据库驱动程序。匹配连接使用通信子协议从 JAVA 应用程序中请求合适的数据库驱动程序。识别 JDBC 下某个子协议的第一驱动程序将被用于建立数据库连接。&lt;/p&gt;
&lt;p&gt;Driver : 这个接口处理与数据库服务器的通信**。你将很少直接与驱动程序互动。相反，你使用 DriverManager 中的对象，它管理此类型的对象。它也抽象与驱动程序对象工作相关的详细信息。&lt;/p&gt;
&lt;p&gt;Connection : 此接口具有接触数据库的所有方法。该连接对象表示通信上下文，即，所有与数据库的通信仅通过这个连接对象进行。&lt;/p&gt;
&lt;p&gt;Statement : 使用创建于这个接口的对象将 SQL 语句提交到数据库。除了执行存储过程以外，一些派生的接口也接受参数。&lt;/p&gt;
&lt;p&gt;ResultSet : 在你使用语句对象执行 SQL 查询后，这些对象保存从数据获得的数据。它作为一个迭代器，让您可以通过它的数据来移动。&lt;/p&gt;
&lt;p&gt;SQLException : 这个类处理发生在数据库应用程序的任何错误。&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JDBCTest {

    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;

    private static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/hello_mybatis&quot;;

    private static final String USER = &quot;root&quot;;

    private static final String PASSWORD = &quot;123456&quot;;

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //STEP 2: Register JDBC driver
        Class.forName(JDBC_DRIVER);
        ResultSet rs = null;
        Connection conn = null;
        Statement stmt = null;
        try {
            //STEP 3: Open a connection
            conn = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

            //STEP 4: Execute a query
            stmt = conn.createStatement();
            String sql;
            sql = &quot;SELECT id, name, dept, phone FROM t_user&quot;;
            rs = stmt.executeQuery(sql);

            //STEP 5: Extract data from result set
            //调用rs.next()时，执行this.thisRow = this.rowData.next();
            //这时候返回值会把当前行数据指向游标的下一行数据
            while (rs.next()) {
                //Retrieve by column name 通过列名获取值
            /*    int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                String dept = rs.getString(&quot;dept&quot;);
                String phone = rs.getString(&quot;phone&quot;);*/

                //Retrieve by columnIndex 通过列的下标获取值
                int id = rs.getInt(1);
                String name = rs.getString(2);
                String dept = rs.getString(3);
                String phone = rs.getString(4);
                //Display values
                System.out.println(&quot;id: &quot; + id + &quot;name: &quot; + name + &quot;dept: &quot; + dept + &quot;phone: &quot; + phone);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            rs.close();
            stmt.close();
            conn.close();
        }
        System.out.println(&quot;over !&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;id: 1name: 大青山dept: amy empirephone: 18956563228
id: 2name: 艾米哈珀dept: amy empirephone: 18956563228
id: 3name: 池寒枫dept: amy empirephone: 22056545
id: 4name: 霍恩斯dept: 森林矮人王国phone: 852-253521
over !
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报错：&lt;/p&gt;
&lt;p&gt;1、java.sql.SQLException: Column Index out of range, 0 &amp;lt; 1.&lt;/p&gt;
&lt;p&gt;这是因为ResultSet结果集是获取列是从1开始的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; int id = rs.getInt(0);//java.sql.SQLException: Column Index out of range, 0 &amp;lt; 1. 
 //正确操作如下：
 int id = rs.getInt(1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 驱动类型&lt;/p&gt;
&lt;p&gt;什么是 JDBC 驱动程序？&lt;/p&gt;
&lt;p&gt;JDBC 驱动实现了 JDBC API 中定义的接口，该接口用于与数据库服务器进行交互。&lt;/p&gt;
&lt;p&gt;例如，使用 JDBC 驱动程序可以让你打开数据库连接，并通过发送 SQL 或数据库命令，然后通过 Java 接收结果。&lt;/p&gt;
&lt;p&gt;java.sql 包中附带的 JDK，包含了定义各种类与他们的行为和实际实现，这些类都在第三方驱动程序中完成。第三方供应商在他们的数据库驱动程序中都实现了 java.sql.Driver 接口。&lt;/p&gt;
&lt;p&gt;JDBC 驱动程序类型&lt;/p&gt;
&lt;p&gt;JDBC 驱动程序的实现，因为各种各样的操作系统和 Java 运行在硬件平台的不同而不同。Sun 公司将实现类型分为四类：类型1，2，3，4，其解释如下.&lt;/p&gt;
&lt;p&gt;类型1：JDBC-ODBC 桥驱动程序：&lt;/p&gt;
&lt;p&gt;在类型1驱动程序中，一个 JDBC 桥接器是用来访问安装在每个客户机上的 ODBC 驱动程序。为了使用 ODBC，需要在目标数据库上配置系统数据源名称（DSN）。&lt;/p&gt;
&lt;p&gt;当 Java 刚出来时，这是一个很有用的驱动程序，因为大多数的数据库只支持 ODBC 访问，但现在此类型的驱动程序仅适用于实验用途或在没有其他选择的情况。&lt;/p&gt;
&lt;p&gt;自带 JDK 1.2 中的 JDBC-ODBC 桥是这类驱动程序的一个很好的例子。&lt;/p&gt;
&lt;p&gt;类型2：JDBC-Native API&lt;/p&gt;
&lt;p&gt;在类型2驱动程序中，JDBC API 调用转换成原生的 C/C++ API 调用，这对于数据库来说具有唯一性。这些驱动程序通常由数据库供应商提供，并和 JDBC-ODBC 桥驱动程序同样的方式使用。该供应商的驱动程序必须安装在每台客户机上。&lt;/p&gt;
&lt;p&gt;如果我们改变了当前数据库，我们必须改变原生 API ，因为它是具体到某一个数据库，并且他们大多已经失效了。即使这样用类型2驱动程序也能提高一些速度，因为他消除了 ODBC 的开销。&lt;/p&gt;
&lt;p&gt;Oracle 调用接口（OCI）驱动程序是一个类型2驱动程序的示例。&lt;/p&gt;
&lt;p&gt;类型3：JDBC-Net 纯 Java&lt;/p&gt;
&lt;p&gt;在类型3驱动程序中，一般用三层方法来访问数据库。JDBC 客户端使用标准的网络套接字与中间件应用服务器进行通信。套接字的相关信息被中间件应用服务器转换为数据库管理系统所要求的的调用格式，并转发到数据库服务器。&lt;/p&gt;
&lt;p&gt;这种驱动程序是非常灵活的，因为它不需要在客户端上安装代码，而且单个驱动程序能提供访问多个数据库。&lt;/p&gt;
&lt;p&gt;你可以将应用服务器作为一个 JDBC “代理”，这意味着它会调用客户端应用程序。因此，你需要一些有关服务器配置方面的知识，这样可以高效地使用此驱动程序类型。&lt;/p&gt;
&lt;p&gt;你的应用服务器可能使用类型1，2，或4驱动程序与数据库进行通信，了解它们的细微之处将会很有帮助。&lt;/p&gt;
&lt;p&gt;类型4：100％纯 Java&lt;/p&gt;
&lt;p&gt;在类型4驱动程序中，一个纯粹的基于 Java 的驱动程序通过 socket 连接与供应商的数据库进行通信。这是可用于数据库的最高性能的驱动程序，并且通常由供应商自身提供。&lt;/p&gt;
&lt;p&gt;这种驱动器是非常灵活的，你不需要在客户端或服务端上安装特殊的软件。此外，这些驱动程序是可以动态下载的。&lt;/p&gt;
&lt;p&gt;MySQL Connector/J 的驱动程序是一个类型4驱动程序。因为它们的网络协议的专有属性，数据库供应商通常提供类型4的驱动程序。&lt;/p&gt;
&lt;p&gt;该使用哪种驱动程序？&lt;/p&gt;
&lt;p&gt;如果你正在访问一个数据库，如 Oracle，Sybase 或 IBM，首选的驱动程序是类型4。&lt;/p&gt;
&lt;p&gt;如果你的 Java 应用程序同时访问多个数据库类型，类型3是首选的驱动程序。&lt;/p&gt;
&lt;p&gt;类型2驱动程序是在你的数据库没有提供类型3或类型4驱动程序时使用的。&lt;/p&gt;
&lt;p&gt;类型1驱动程序不被认为是部署级的驱动程序，它存在的目的通常仅用于开发和测试。&lt;/p&gt;
&lt;p&gt;JDBC 连接数据库&lt;/p&gt;
&lt;p&gt;连接数据库&lt;/p&gt;
&lt;p&gt;在你安装相应的驱动程序后，就可以用 JDBC 建立一个数据库连接。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;5.1.31&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写建立一个 JDBC 连接的程序是相当简单的。下面是简单的四个步骤:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导入 JDBC 包：在你的 Java 代码中，用 import 语句添加你所需的类。&lt;/li&gt;
&lt;li&gt;注册 JDBC 驱动程序：这一步会导致 JVM 加载所需的驱动程序到内存中执行，因此它可以实现你的 JDBC 请求。&lt;/li&gt;
&lt;li&gt;数据库 URL 制定：这是用来创建格式正确的地址指向你想要连接的数据库。&lt;/li&gt;
&lt;li&gt;创建连接对象：最后，代码调用 DriverManager 对象的 getConnection() 方法来建立实际的数据库连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;导入包：&lt;/p&gt;
&lt;p&gt;注册 JDBC 驱动程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//方法1 - Class.forName()
//这种方法更优越一些，因为它允许你对驱动程序的注册信息进行配置，便于移植。
 Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);//推荐
Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;).newInstance();

//方法2 - DriverManager.registerDriver()
//如果你使用的是不兼容 JVM 的非 JDK，比如微软提供的，你必须使用 registerDriver() 方法。
 Driver myDriver = new oracle.jdbc.driver.OracleDriver();
 DriverManager.registerDriver( myDriver );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库 URL 制定&lt;/p&gt;
&lt;p&gt;当你加载了驱动程序之后，你可以通过 DriverManager.getConnection() 方法建立一个连接。为方便参考，以下列出了三个加载 DriverManager.getConnection() 方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getConnection(String url)&lt;/li&gt;
&lt;li&gt;getConnection(String url, Properties prop)&lt;/li&gt;
&lt;li&gt;getConnection(String url, String user, String password)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下表列出了常用的 JDBC 驱动程序名和数据库URL。&lt;/p&gt;
&lt;p&gt;RDBMS JDBC 驱动程序名称 URL 格式&lt;br/&gt;MySQL com.mysql.jdbc.Driver jdbc:mysql://hostname/ databaseName&lt;br/&gt;ORACLE oracle.jdbc.driver.OracleDriver jdbc:oracle:thin:@hostname:port Number:databaseName&lt;br/&gt;DB2 COM.ibm.db2.jdbc.net.DB2Driver jdbc:db2:hostname:port Number/databaseName&lt;br/&gt;Sybase com.sybase.jdbc.SybDriver jdbc:sybase:Tds:hostname: port Number/databaseName&lt;/p&gt;
&lt;p&gt;URL 格式所有加粗的部分都是静态的，你需要将剩余部分按照你的数据库实际情况进行设置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //使用数据库 URL 和 Properties 对象
 Properties info = new Properties();
 info.put(&quot;user&quot;, USER);
 info.put(&quot;password&quot;, PASSWORD);
 conn = DriverManager.getConnection(DATABASE_URL, info);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关闭 JDBC 连接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//Java 垃圾收集器也会关闭连接，它会完全清除过期的对象。但最好用try finally来关闭连接。
conn.close();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC Statement 对象&lt;/p&gt;
&lt;p&gt;Statement 对象&lt;/p&gt;
&lt;p&gt;一旦我们获得了数据库的连接，我们就可以和数据库进行交互。JDBC 的 Statement，CallableStatement 和 PreparedStatement 接口定义的方法和属性，可以让你发送 SQL 命令或 PL/SQL 命令到数据库，并从你的数据库接收数据。&lt;/p&gt;
&lt;p&gt;下表提供了每个接口的用途概要，根据实际目的决定使用哪个接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;StatementImpl stmt = new StatementImpl(this.getLoadBalanceSafeProxy(), this.database);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口 推荐使用&lt;br/&gt;Statement 可以正常访问数据库，适用于运行静态 SQL 语句。 Statement 接口不接受参数。&lt;br/&gt;PreparedStatement 计划多次使用 SQL 语句， PreparedStatement 接口运行时接受输入的参数。&lt;br/&gt;CallableStatement 适用于当你要访问数据库存储过程的时候， CallableStatement 接口运行时也接受输入的参数。&lt;/p&gt;
&lt;p&gt;当你创建了一个 Statement 对象之后，你可以用它的三个执行方法的任一方法来执行 SQL 语句。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;boolean execute(String SQL) : 如果 ResultSet 对象可以被检索，则返回的布尔值为 true ，否则返回 false 。当你需要使用真正的动态 SQL 时，可以使用这个方法来执行 SQL DDL 语句。&lt;/li&gt;
&lt;li&gt;int executeUpdate(String SQL) : 返回执行 SQL 语句影响的行的数目。使用该方法来执行 SQL 语句，是希望得到一些受影响的行的数目，例如，INSERT，UPDATE 或 DELETE 语句。&lt;/li&gt;
&lt;li&gt;ResultSet executeQuery(String SQL) : 返回一个 ResultSet 对象。当你希望得到一个结果集时使用该方法，就像你使用一个 SELECT 语句。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关闭 Statement 对象&lt;/p&gt;
&lt;p&gt;正如你关闭一个 Connection 对象来节约数据库资源，出于同样的原因你也应该关闭 Statement 对象。&lt;/p&gt;
&lt;p&gt;简单的调用 close() 方法就可以完成这项工作。如果你关闭了 Connection 对象，那么它也会关闭 Statement 对象。然而，你应该始终明确关闭 Statement 对象，以确保真正的清除。&lt;/p&gt;
&lt;p&gt;PreparedStatement 对象&lt;/p&gt;
&lt;p&gt;PreparedStatement 接口扩展了 Statement 接口，它让你用一个常用的 Statement 对象增加几个高级功能。&lt;/p&gt;
&lt;p&gt;JDBC 中所有的参数都被用 ? 符号表示，这是已知的参数标记。在执行 SQL 语句之前，你必须赋予每一个参数确切的数值。&lt;/p&gt;
&lt;p&gt;setXXX() 方法将值绑定到参数，其中 XXX 表示你希望绑定到输入参数的 Java 数据类型。如果你忘了赋予值，你将收到一个 SQLException。&lt;/p&gt;
&lt;p&gt;每个参数标记映射它的序号位置。第一标记表示位置 1 ，下一个位置为 2 .&lt;/p&gt;
&lt;p&gt;prepareStatement对象防止sql注入的方式是把用户非法输入的单引号用\反斜杠做了转义，从而达到了防止sql注入的目的 。&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JDBCTest2 {

    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;

    private static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/hello_mybatis&quot;;

    private static final String USER = &quot;root&quot;;

    private static final String PASSWORD = &quot;123456&quot;;

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //STEP 2: Register JDBC driver
        Class.forName(JDBC_DRIVER);
        ResultSet rs = null;
        Connection conn = null;
        PreparedStatement pstmt = null;
        PreparedStatement pstmtUp = null;
        try {
            //STEP 3: Open a connection
            //conn = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

            //使用数据库 URL 和 Properties 对象
            Properties info = new Properties();
            info.put(&quot;user&quot;, USER);
            info.put(&quot;password&quot;, PASSWORD);
            conn = DriverManager.getConnection(DATABASE_URL, info);

            pstmtUp = conn.prepareStatement(&quot;UPDATE t_user SET phone = ? WHERE id = ?&quot;);
            pstmtUp.setString(1,&quot;13565422554&quot;);
            pstmtUp.setInt(2,2);
            int execute = pstmtUp.executeUpdate();
            System.out.println(&quot;execute update :&quot;+execute);
            //STEP 4: Execute a query
            pstmt = conn.prepareStatement(&quot;SELECT id, name, dept, phone FROM t_user WHERE id = ? and name = ?&quot;);
            pstmt.setInt(1,2);
            pstmt.setString(2,&quot;艾米哈珀&quot;);
            rs = pstmt.executeQuery();
            while (rs.next()) {
                //Retrieve by column name 通过列名获取值
                int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                String dept = rs.getString(&quot;dept&quot;);
                String phone = rs.getString(&quot;phone&quot;);
                //Display values
                System.out.println(&quot;id: &quot; + id + &quot;name: &quot; + name + &quot;dept: &quot; + dept + &quot;phone: &quot; + phone);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            rs.close();
            //关闭 PreparedStatement 对象
            pstmt.close();
            pstmtUp.close();
            conn.close();
        }
        System.out.println(&quot;over !&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;execute update :1
id: 2name: 艾米哈珀dept: amy empirephone: 13565422554
over !
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CallableStatement 对象&lt;/p&gt;
&lt;p&gt;CallableStatement是创建被用来执行调用数据库存储过程的 CallableStatement 对象。&lt;/p&gt;
&lt;p&gt;三种类型的参数有：IN，OUT 和 INOUT。PreparedStatement 对象只使用 IN 参数。CallableStatement 对象可以使用所有的三个参数。&lt;/p&gt;
&lt;p&gt;这里是每个参数的定义：&lt;/p&gt;
&lt;p&gt;参数 描述&lt;br/&gt;IN 在 SQL 语句创建的时候该参数是未知的。你可以用 setXXX() 方法将值绑定到IN参数中。&lt;br/&gt;OUT 该参数由 SQL 语句的返回值提供。你可以用 getXXX() 方法获取 OUT 参数的值。&lt;br/&gt;INOUT 该参数同时提供输入输出的值。你可以用 setXXX() 方法将值绑定参数，并且用 getXXX() 方法获取值。&lt;/p&gt;
&lt;p&gt;前提：&lt;/p&gt;
&lt;p&gt;存储过程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DELIMITER $$

DROP PROCEDURE IF EXISTS `hello_mybatis`.`getNameById` $$
CREATE PROCEDURE `hello_mybatis`.`getNameById` 
   (IN USER_ID INT, OUT USER_NAME varchar(64))
BEGIN
   SELECT NAME INTO USER_NAME
   FROM t_user
   WHERE ID = USER_ID;
END $$

DELIMITER ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JDBCTest3 {

    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;

    private static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/hello_mybatis&quot;;

    private static final String USER = &quot;root&quot;;

    private static final String PASSWORD = &quot;123456&quot;;

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //STEP 2: Register JDBC driver
        Class.forName(JDBC_DRIVER);
        Connection conn = null;
        CallableStatement cstmt= null;
        try {
            //STEP 3: Open a connection
            //conn = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

            //使用数据库 URL 和 Properties 对象
            Properties info = new Properties();
            info.put(&quot;user&quot;, USER);
            info.put(&quot;password&quot;, PASSWORD);
            conn = DriverManager.getConnection(DATABASE_URL, info);
            //注意，不管是入参出参都有有？占位符，否则会执行失败
            String sql =&quot;{call getNameById (?,?)}&quot;;
            cstmt = conn.prepareCall(sql);
            cstmt.setInt(&quot;USER_ID&quot;,2);
            cstmt.registerOutParameter(&quot;USER_NAME&quot;,Types.VARCHAR);
            //也可以根据列的索引，1，2这样进行设置参数
            cstmt.execute();
            String userName = cstmt.getString(&quot;USER_NAME&quot;);
            System.out.println(&quot;CallableStatement userName: &quot;+userName);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            cstmt.close();
            conn.close();
        }
        System.out.println(&quot;over !&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CallableStatement userName: 艾米哈珀
over !
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报错：&lt;/p&gt;
&lt;p&gt;java.sql.SQLException: Can't find local placeholder mapping for parameter named &quot;USER_NAME&quot;.&lt;/p&gt;
&lt;p&gt;这是因为执行存储过程时，不管是入参出参都有有？占位符，否则会执行失败&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//错误
 String sql =&quot;{call getNameById (?)}&quot;;
//正确
String sql =&quot;{call getNameById (?,?)}&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CallableStatement参考&lt;/p&gt;
&lt;p&gt;JDBC 结果集&lt;/p&gt;
&lt;p&gt;SQL 语句从数据库查询中获取数据，并将数据返回到结果集中。SELECT 语句是一种标准的方法，它从一个数据库中选择行记录，并显示在一个结果集中。 java.sql.ResultSet 接口表示一个数据库查询的结果集。&lt;/p&gt;
&lt;p&gt;一个 ResultSet 对象控制一个光标指向当前行的结果集。术语“结果集”是指包含在 ResultSet 对象中的行和列的数据。&lt;/p&gt;
&lt;p&gt;ResultSet 接口的方法可细分为三类-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导航方法：用于移动光标。&lt;/li&gt;
&lt;li&gt;获取方法：用于查看当前行被光标所指向的列中的数据。&lt;/li&gt;
&lt;li&gt;更新方法：用于更新当前行的列中的数据。这些更新也会更新数据库中的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;光标的移动基于 ResultSet 的属性。用相应的语句生成 ResultSet 对象时，同时生成 ResultSet 的属性。&lt;/p&gt;
&lt;p&gt;JDBC 提供了连接方法通过下列创建语句来生成你所需的 ResultSet 对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;createStatement(int RSType, int RSConcurrency);&lt;/li&gt;
&lt;li&gt;prepareStatement(String SQL, int RSType, int RSConcurrency);&lt;/li&gt;
&lt;li&gt;prepareCall(String sql, int RSType, int RSConcurrency);&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个参数表示 ResultSet 对象的类型，第二个参数是两个 ResultSet 常量之一，该常量用于判断该结果集是只读的还是可修改的。&lt;/p&gt;
&lt;p&gt;ResultSet 的类型&lt;/p&gt;
&lt;p&gt;可能的 RSType 如下所示。如果你不指定 ResultSet 类型，将自动获得的值是 TYPE_FORWARD_ONLY。&lt;/p&gt;
&lt;p&gt;类型 描述&lt;br/&gt;ResultSet.TYPE_FORWARD_ONLY 光标只能在结果集中向前移动。&lt;br/&gt;ResultSet.TYPE_SCROLL_INSENSITIVE 光标可以向前和向后移动。当结果集创建后，其他人对数据库的操作不会影响结果集的数据。&lt;br/&gt;ResultSet.TYPE_SCROLL_SENSITIVE. 光标可以向前和向后移动。当结果集创建后，其他人对数据库的操作会影响结果集的数据。&lt;/p&gt;
&lt;p&gt;ResultSet 的并发性&lt;/p&gt;
&lt;p&gt;RSConcurrency 的值如下所示，如果你不指定并发类型，将自动获得的值是 CONCUR_READ_ONLY。&lt;/p&gt;
&lt;p&gt;并发性 描述&lt;br/&gt;ResultSet.CONCUR_READ_ONLY 创建一个只读结果集，这是默认的值。&lt;br/&gt;ResultSet.CONCUR_UPDATABLE 创建一个可修改的结果集。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//默认初始化一个 Statement 对象来创建一个只能前进，而且只读的 ResultSet 对象。
conn.createStatement();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 ResultSet 接口中包括如下几种方法涉及移动光标：&lt;/p&gt;
&lt;p&gt;S.N. 方法 &amp;amp; 描述&lt;br/&gt;1 public void beforeFirst() throws SQLException将光标移动到第一行之前。&lt;br/&gt;2 public void afterLast() throws SQLException将光标移动到最后一行之后。&lt;br/&gt;3 public boolean first() throws SQLException将光标移动到第一行。&lt;br/&gt;4 public void last() throws SQLException将光标移动到最后一行。&lt;br/&gt;5 public boolean absolute(int row) throws SQLException将光标移动到指定的第 row 行。&lt;br/&gt;6 public boolean relative(int row) throws SQLException将光标移动到当前指向的位置往前或往后第 row 行的位置。&lt;br/&gt;7 public boolean previous() throws SQLException将光标移动到上一行，如果超过结果集的范围则返回 false。&lt;br/&gt;8 public boolean next() throws SQLException将光标移动到下一行，如果是结果集的最后一行则返回 false。&lt;br/&gt;9 public int getRow() throws SQLException返回当前光标指向的行数的值。&lt;br/&gt;10 public void moveToInsertRow() throws SQLException将光标移动到结果集中指定的行，可以在数据库中插入新的一行。当前光标位置将被记住。&lt;br/&gt;11 public void moveToCurrentRow() throws SQLException如果光标处于插入行，则将光标返回到当前行，其他情况下，这个方法不执行任何操作。&lt;/p&gt;
&lt;p&gt;查看结果集&lt;/p&gt;
&lt;p&gt;ResultSet接口中含有几十种从当前行获取数据的方法。&lt;/p&gt;
&lt;p&gt;每个可能的数据类型都有一个 get 方法，并且每个 get 方法有两个版本-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个需要列名。&lt;/li&gt;
&lt;li&gt;一个需要列的索引。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，如果你想查看的列包含一个 int 类型，你需要在 ResultSet 中调用 getInt()方法-&lt;/p&gt;
&lt;p&gt;S.N. 方法 &amp;amp; 描述&lt;br/&gt;1 public int getInt(String columnName) throws SQLException返回当前行中名为 columnName 的列的 int 值。&lt;br/&gt;2 public int getInt(int columnIndex) throws SQLException返回当前行中指定列的索引的 int 值。列索引从 1 开始，意味着行中的第一列是 1 ，第二列是 2 ，以此类推。&lt;/p&gt;
&lt;p&gt;同样的，在 ResultSet 接口中还有获取八个 Java 原始类型的 get 方法，以及常见的类型。&lt;/p&gt;
&lt;p&gt;更新的结果集（一般不这样更新，了解）&lt;/p&gt;
&lt;p&gt;ResultSet 接口包含了一系列的更新方法，该方法用于更新结果集中的数据。&lt;/p&gt;
&lt;p&gt;用 updateString 方法可以有两个更新方法来更新任一数据类型-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个需要列名。&lt;/li&gt;
&lt;li&gt;一个需要列的索引。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，要更新一个结果集的当前行的 String 列，你可以使用任一如下所示的 updateString()方法-&lt;/p&gt;
&lt;p&gt;S.N. 方法 &amp;amp; 描述&lt;br/&gt;1 public void updateString(int columnIndex, String s) throws SQLException将指定列的字符串的值改为 s。&lt;br/&gt;2 public void updateString(String columnName, String s) throws SQLException类似于前面的方法，不同之处在于指定的列是用名字来指定的，而不是它的索引。&lt;/p&gt;
&lt;p&gt;八个原始数据类型都有其更新方法，比如 String，Object，URL，和在 java.sql 包中的 SQL 数据类型。&lt;/p&gt;
&lt;p&gt;更新结果集中的行将改变当前行的列中的 ResultSet 对象，而不是基础数据库中的数据。要更新数据库中一行的数据，你需要调用以下的任一方法。&lt;/p&gt;
&lt;p&gt;S.N. 方法 &amp;amp; 描述&lt;br/&gt;1 public void updateRow()通过更新数据库中相对应的行来更新当前行。&lt;br/&gt;2 public void deleteRow()从数据库中删除当前行。&lt;br/&gt;3 public void refreshRow()在结果集中刷新数据，以反映数据库中最新的数据变化。&lt;br/&gt;4 public void cancelRowUpdates()取消对当前行的任何修改。&lt;br/&gt;5 public void insertRow()在数据库中插入一行。本方法只有在光标指向插入行的时候才能被调用。&lt;/p&gt;
&lt;p&gt;当使用ResultSet的时候，当查询出来的数据集记录很多，有一千万条的时候，那rs所指的对象是否会占用很多内存，如果记录过多，那程序会不会把系统的内存用光呢 ? 　　&lt;/p&gt;
&lt;p&gt;不会，ResultSet表面看起来是一个记录集，其实这个对象中只是记录了结果集的相关信息，具体的记录并没有存放在对象中，具体的记录内容直到你通过next方法提取的时候，再通过相关的getXXXXX方法提取字段内容的时候才能从数据库中得到，这些并不会占用内存，具体消耗内存是由于你将记录集中的数据提取出来加入到你自己的集合中的时候才会发生，如果你没有使用集合记录所有的记录就不会发生消耗内存厉害的情况。&lt;/p&gt;
&lt;p&gt;JDBC 数据类型&lt;/p&gt;
&lt;p&gt;JDBC 驱动程序在将 Java 数据类型发送到数据库之前，会将其转换为相应的 JDBC 类型。对于大多数数据类型都采用了默认的映射关系。例如，一个 Java int 数据类型转换为 SQL INTEGER。通过默认的映射关系来提供驱动程序之间的一致性。&lt;/p&gt;
&lt;p&gt;ResultSet 对象为任一数据类型提供相应的 getXXX()方法，该方法可以获取任一数据类型的列值。上述任一方法的使用需要列名或它的顺序位置。&lt;/p&gt;
&lt;p&gt;SQL JDBC/Java setXXX getXXX&lt;br/&gt;VARCHAR java.lang.String setString getString&lt;br/&gt;CHAR java.lang.String setString getString&lt;br/&gt;LONGVARCHAR java.lang.String setString getString&lt;br/&gt;BIT boolean setBoolean getBoolean&lt;br/&gt;NUMERIC java.math.BigDecimal setBigDecimal getBigDecimal&lt;br/&gt;TINYINT byte setByte getByte&lt;br/&gt;SMALLINT short setShort getShort&lt;br/&gt;INTEGER int setInt getInt&lt;br/&gt;BIGINT long setLong getLong&lt;br/&gt;REAL float setFloat getFloat&lt;br/&gt;FLOAT float setFloat getFloat&lt;br/&gt;DOUBLE double setDouble getDouble&lt;br/&gt;VARBINARY byte[ ] setBytes getBytes&lt;br/&gt;BINARY byte[ ] setBytes getBytes&lt;br/&gt;DATE java.sql.Date setDate getDate&lt;br/&gt;TIME java.sql.Time setTime getTime&lt;br/&gt;TIMESTAMP java.sql.Timestamp setTimestamp getTimestamp&lt;br/&gt;CLOB java.sql.Clob setClob getClob&lt;br/&gt;BLOB java.sql.Blob setBlob getBlob&lt;br/&gt;ARRAY java.sql.Array setARRAY getARRAY&lt;br/&gt;REF java.sql.Ref SetRef getRef&lt;br/&gt;STRUCT java.sql.Struct SetStruct getStruct&lt;/p&gt;
&lt;p&gt;处理 NULL 值&lt;/p&gt;
&lt;p&gt;SQL 使用 NULL 值和 Java 使用 null 是不同的概念。那么，你可以使用三种策略来处理 Java 中的 SQL NULL 值-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;避免使用返回原始数据类型的 getXXX()方法。&lt;/li&gt;
&lt;li&gt;使用包装类的基本数据类型，并使用 ResultSet 对象的 wasNull()方法来测试收到 getXXX()方法返回的值是否为 null，如果是 null，该包装类变量则被设置为 null。&lt;/li&gt;
&lt;li&gt;使用原始数据类型和 ResultSet 对象的 wasNull()方法来测试通过 getXXX()方法返回的值，如果是 null，则原始变量应设置为可接受的值来代表 NULL。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JDBC 事务&lt;/p&gt;
&lt;p&gt;如果你的 JDBC 连接是处于自动提交模式下，该模式为默认模式，那么每句 SQL 语句都是在其完成时提交到数据库。&lt;/p&gt;
&lt;p&gt;对简单的应用程序来说这种模式相当好，但有三个原因你可能想关闭自动提交模式，并管理你自己的事务-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为了提高性能&lt;/li&gt;
&lt;li&gt;为了保持业务流程的完整性&lt;/li&gt;
&lt;li&gt;使用分布式事务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JDBC 驱动程序默认使用的自动提交模式 ，需要conn.setAutoCommit(false);关闭自动提交模式 .&lt;/p&gt;
&lt;p&gt;提交和回滚&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;conn.commit( );
conn.rollback( );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还原点&lt;/p&gt;
&lt;p&gt;Connection 对象有两个新的方法来管理还原点-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setSavepoint(String savepointName): 定义了一个新的还原点。它也返回一个 Savepoint 对象。&lt;/li&gt;
&lt;li&gt;releaseSavepoint(Savepoint savepointName): 删除一个还原点。请注意，它需要一个作为参数的 Savepoint 对象。这个对象通常是由 setSavepoint() 方法生成的一个还原点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有一个 rollback (String savepointName) 方法，该方法可以回滚到指定的还原点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JDBCTranctionTest {

    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;

    private static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/hello_mybatis&quot;;

    private static final String USER = &quot;root&quot;;

    private static final String PASSWORD = &quot;123456&quot;;

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //STEP 2: Register JDBC driver
        Class.forName(JDBC_DRIVER);
        ResultSet rs = null;
        Connection conn = null;
        PreparedStatement pstmt = null;
        PreparedStatement pstmtUp = null;
        Savepoint savepoint = null;
        try {
            //STEP 3: Open a connection
            //conn = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

            //使用数据库 URL 和 Properties 对象
            Properties info = new Properties();
            info.put(&quot;user&quot;, USER);
            info.put(&quot;password&quot;, PASSWORD);
            conn = DriverManager.getConnection(DATABASE_URL, info);
            //关闭自动提交模式
            conn.setAutoCommit(false);
            pstmtUp = conn.prepareStatement(&quot;UPDATE t_user SET phone = ? WHERE id = ?&quot;);
            pstmtUp.setString(1,&quot;22025555&quot;);
            pstmtUp.setInt(2,2);
            int execute = pstmtUp.executeUpdate();
            System.out.println(&quot;execute update1 :&quot;+execute);
            //想回滚到还原点，那么之前执行的sql要提交事务，否则这个还原点就没有意义，因为一整个事务都没有提交
            conn.commit();
            //创建还原点
            savepoint = conn.setSavepoint(&quot;updateSavepoint1&quot;);

            pstmtUp.setString(1,&quot;22026666&quot;);
            pstmtUp.setInt(2,2);
            execute = pstmtUp.executeUpdate();
            System.out.println(&quot;execute update2 :&quot;+execute);
            //报错
            //System.out.println(1/0);

            //STEP 4: Execute a query
            pstmt = conn.prepareStatement(&quot;SELECT id, name, dept, phone FROM t_user WHERE id = ? and name = ?&quot;);
            pstmt.setInt(1,2);
            pstmt.setString(2,&quot;艾米哈珀&quot;);
            rs = pstmt.executeQuery();
            while (rs.next()) {
                //Retrieve by column name 通过列名获取值
                int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                String dept = rs.getString(&quot;dept&quot;);
                String phone = rs.getString(&quot;phone&quot;);
                //Display values
                System.out.println(&quot;id: &quot; + id + &quot;name: &quot; + name + &quot;dept: &quot; + dept + &quot;phone: &quot; + phone);
            }
            //提交事务
            conn.commit();
            //当我们设置不提交时，虽然查出来的是最新更改的值，但数据库其实并没有更改，因为我们没有手动提交
            //查出来的是最新更改的值是事务隔离类型的原因
        } catch (SQLException e) {
            //回滚事务
            //conn.rollback();
            //回滚到还原点
            e.printStackTrace();
            conn.rollback(savepoint);
        } finally {
            //关闭 PreparedStatement 对象
            pstmt.close();
            pstmtUp.close();
            conn.close();
        }
        System.out.println(&quot;over !&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：还原点使用特别注意。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //想回滚到还原点，那么之前执行的sql要提交事务，否则这个还原点就没有意义，因为一整个事务都没有提交
 conn.commit();
 //创建还原点
 savepoint = conn.setSavepoint(&quot;updateSavepoint1&quot;);
 
  //回滚到还原点
conn.rollback(savepoint);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 批处理&lt;/p&gt;
&lt;p&gt;Statement不能执行带参数占位符？的sql语句。&lt;/p&gt;
&lt;p&gt;批处理注意用于增删改，因为返回的不是对象。&lt;/p&gt;
&lt;p&gt;批处理是指你将关联的 SQL 语句组合成一个批处理，并将他们当成一个调用提交给数据库。&lt;/p&gt;
&lt;p&gt;当你一次发送多个 SQL 语句到数据库时，可以减少通信的资源消耗，从而提高了性能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDBC 驱动程序不一定支持该功能。你可以使用 DatabaseMetaData.supportsBatchUpdates() 方法来确定目标数据库是否支持批处理更新。如果你的JDBC驱动程序支持此功能，则该方法返回值为 true。&lt;/li&gt;
&lt;li&gt;Statement，PreparedStatement 和 CallableStatement 的 addBatch() 方法用于添加单个语句到批处理。&lt;/li&gt;
&lt;li&gt;executeBatch() 方法用于启动执行所有组合在一起的语句。&lt;/li&gt;
&lt;li&gt;executeBatch() 方法返回一个整数数组，数组中的每个元素代表了各自的更新语句的更新数目。&lt;/li&gt;
&lt;li&gt;正如你可以添加语句到批处理中，你也可以用 clearBatch() 方法删除它们。此方法删除所有用 addBatch() 方法添加的语句。但是，你不能有选择性地选择要删除的语句。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;批处理和 Statement 对象&lt;/p&gt;
&lt;p&gt;注意可以不手动控制事务。&lt;/p&gt;
&lt;p&gt;使用 Statement 对象来使用批处理所需要的典型步骤如下所示-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 createStatement() 方法创建一个 Statement 对象。&lt;/li&gt;
&lt;li&gt;使用 setAutoCommit() 方法将自动提交设为 false。&lt;/li&gt;
&lt;li&gt;被创建的 Statement 对象可以使用 addBatch() 方法来添加你想要的所有SQL语句。&lt;/li&gt;
&lt;li&gt;被创建的 Statement 对象可以用 executeBatch() 将所有的 SQL 语句执行。&lt;/li&gt;
&lt;li&gt;最后，使用 commit() 方法提交所有的更改。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;批处理和 PrepareStatement 对象&lt;/p&gt;
&lt;p&gt;使用 prepareStatement 对象来使用批处理需要的典型步骤如下所示-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用占位符创建 SQL 语句。&lt;/li&gt;
&lt;li&gt;使用任一 prepareStatement() 方法创建 prepareStatement 对象。&lt;/li&gt;
&lt;li&gt;使用 setAutoCommit() 方法将自动提交设为 false。&lt;/li&gt;
&lt;li&gt;被创建的 Statement 对象可以使用 addBatch() 方法来添加你想要的所有 SQL 语句。&lt;/li&gt;
&lt;li&gt;被创建的 Statement 对象可以用 executeBatch() 将所有的 SQL 语句执行。&lt;/li&gt;
&lt;li&gt;最后，使用 commit() 方法提交所有的更改。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JDBCBatchTest {

    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;

    private static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/hello_mybatis&quot;;

    private static final String USER = &quot;root&quot;;

    private static final String PASSWORD = &quot;123456&quot;;

    public static void main1(String[] args) throws ClassNotFoundException, SQLException {
        //STEP 2: Register JDBC driver
        Class.forName(JDBC_DRIVER);
        Connection conn = null;
        PreparedStatement pstmtUp = null;
        try {
            //STEP 3: Open a connection
            //conn = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

            //使用数据库 URL 和 Properties 对象
            Properties info = new Properties();
            info.put(&quot;user&quot;, USER);
            info.put(&quot;password&quot;, PASSWORD);
            conn = DriverManager.getConnection(DATABASE_URL, info);
            //关闭自动提交模式
            //conn.setAutoCommit(false);
            pstmtUp = conn.prepareStatement(&quot;UPDATE t_user SET phone = ? WHERE id = ?&quot;);
            pstmtUp.setString(1,&quot;22025555&quot;);
            pstmtUp.setInt(2,2);
            pstmtUp.addBatch();

            pstmtUp.setString(1,&quot;22026666&quot;);
            pstmtUp.setInt(2,1);
            pstmtUp.addBatch();

            pstmtUp.setString(1,&quot;22027777&quot;);
            pstmtUp.setInt(2,3);
            pstmtUp.addBatch();
            int[] ints = pstmtUp.executeBatch();
            System.out.println(Arrays.toString(ints));
            //提交事务
            //conn.commit();
            //当我们设置不提交时，虽然查出来的是最新更改的值，但数据库其实并没有更改，因为我们没有手动提交
            //查出来的是最新更改的值是事务隔离类型的原因
        } catch (Exception e) {
            //回滚事务
            //conn.rollback();
            //回滚到还原点
            e.printStackTrace();
        } finally {
            //关闭 PreparedStatement 对象
            pstmtUp.close();
            conn.close();
        }
        System.out.println(&quot;over !&quot;);
    }

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //STEP 2: Register JDBC driver
        Class.forName(JDBC_DRIVER);
        Connection conn = null;
        Statement stmt = null;
        try {
            //STEP 3: Open a connection
            //conn = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

            //使用数据库 URL 和 Properties 对象
            Properties info = new Properties();
            info.put(&quot;user&quot;, USER);
            info.put(&quot;password&quot;, PASSWORD);
            conn = DriverManager.getConnection(DATABASE_URL, info);
            //关闭自动提交模式
            //conn.setAutoCommit(false);
            //Statement只能执行不带参数的sql
            stmt = conn.createStatement();
            String sql;
            sql = &quot;UPDATE t_user SET phone = '123456' WHERE id = 1&quot;;
            stmt.addBatch(sql);
            sql = &quot;UPDATE t_user SET phone = '123456' WHERE id = 2&quot;;
            stmt.addBatch(sql);
            sql = &quot;UPDATE t_user SET phone = '123456' WHERE id = 3&quot;;
            stmt.addBatch(sql);
            //批量处理
            int[] ints = stmt.executeBatch();
            System.out.println(Arrays.toString(ints));
            //提交事务
            //conn.commit();
            //当我们设置不提交时，虽然查出来的是最新更改的值，但数据库其实并没有更改，因为我们没有手动提交
            //查出来的是最新更改的值是事务隔离类型的原因
        } catch (Exception e) {
            //回滚事务
            //conn.rollback();
            //回滚到还原点
            e.printStackTrace();
        } finally {
            //关闭 PreparedStatement 对象
            stmt.close();
            conn.close();
        }
        System.out.println(&quot;over !&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 流数据&lt;/p&gt;
&lt;p&gt;PreparedStatement 对象必须具备使用输入和输出流来提供参数数据的能力。这使你能够将整个文件存储到数据库列中，这样数据库就能存储大型数据，例如 CLOB 和 BLOB 数据类型。&lt;/p&gt;
&lt;p&gt;用于流数据有下列几种方法-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setAsciiStream(): 该方法是用来提供较大的 ASCII 值。&lt;/li&gt;
&lt;li&gt;setCharacterStream(): 该方法是用来提供较大的 UNICODE 值。&lt;/li&gt;
&lt;li&gt;setBinaryStream(): 该方法是用来提供较大的二进制值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;setXXXStream()方法需要一个额外的参数，该参数是除了参数占位符的文件大小。这个参数通知驱动程序通过使用流有多少数据被发送到数据库中。&lt;/p&gt;
&lt;p&gt;一般不会用这个，都是直接把数据转为String类型直接存到text字段里吧？&lt;/p&gt;
&lt;p&gt;JDBC 创建数据库实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stmt = conn.createStatement();
String sql = &quot;CREATE DATABASE hello_spring&quot;;
stmt.executeUpdate(sql);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 删除数据库实例&lt;/p&gt;
&lt;p&gt;使用的用户必须拥有删除数据库的权限，这也侧面反映当我们给项目设置数据库访问用户时，要注意权限的赋予，像数据库操作、DDL这样的权限是不应该有的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stmt = conn.createStatement();
String sql = &quot;DROP DATABASE STUDENTS&quot;;
stmt.executeUpdate(sql);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 创建表实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stmt = conn.createStatement();
String sql = &quot;CREATE TABLE REGISTRATION &quot; +
&quot;(id INTEGER not NULL, &quot; +
&quot; first VARCHAR(255), &quot; + 
&quot; last VARCHAR(255), &quot; + 
&quot; age INTEGER, &quot; + 
&quot; PRIMARY KEY ( id ))&quot;; 
stmt.executeUpdate(sql);
System.out.println(&quot;Create
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 删除表实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stmt = conn.createStatement();
String sql = &quot;DROP TABLE REGISTRATION &quot;;
stmt.executeUpdate(sql);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 插入记录实例&lt;/p&gt;
&lt;p&gt;下面这个示例在项目运用中其实应该使用PreparedStatement来插入数据，用占位符的形式来创建sql。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; pstmtUp = conn.prepareStatement(&quot;INSERT INTO Registration &quot; +
&quot;VALUES (?, ?, ?, ?)&quot;);

stmt = conn.createStatement();
String sql = &quot;INSERT INTO Registration &quot; +
&quot;VALUES (100, 'Zara', 'Ali', 18)&quot;;
stmt.executeUpdate(sql);
sql = &quot;INSERT INTO Registration &quot; +
&quot;VALUES (101, 'Mahnaz', 'Fatma', 25)&quot;;
stmt.executeUpdate(sql);
sql = &quot;INSERT INTO Registration &quot; +
&quot;VALUES (102, 'Zaid', 'Khan', 30)&quot;;
stmt.executeUpdate(sql);
sql = &quot;INSERT INTO Registration &quot; +
&quot;VALUES(103, 'Sumit', 'Mittal', 28)&quot;;
stmt.executeUpdate(sql);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 查询记录实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pstmt = conn.prepareStatement(&quot;SELECT id, name, dept, phone FROM t_user WHERE id = ? and name = ?&quot;);
pstmt.setInt(1,2);
pstmt.setString(2,&quot;艾米哈珀&quot;);
rs = pstmt.executeQuery();
while (rs.next()) {
    //Retrieve by column name 通过列名获取值
    int id = rs.getInt(&quot;id&quot;);
    String name = rs.getString(&quot;name&quot;);
    String dept = rs.getString(&quot;dept&quot;);
    String phone = rs.getString(&quot;phone&quot;);
    //Display values
    System.out.println(&quot;id: &quot; + id + &quot;name: &quot; + name + &quot;dept: &quot; + dept + &quot;phone: &quot; + phone);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 更新记录实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pstmtUp = conn.prepareStatement(&quot;UPDATE t_user SET phone = ? WHERE id = ?&quot;);
pstmtUp.setString(1,&quot;22025555&quot;);
pstmtUp.setInt(2,2);
int execute = pstmtUp.executeUpdate();
System.out.println(&quot;execute update1 :&quot;+execute);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 删除记录实例&lt;/p&gt;
&lt;p&gt;应该使用PreparedStatement来删除数据，用占位符的形式来创建sql。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stmt = conn.createStatement();
String sql = &quot;DELETE FROM Registration &quot; +
&quot;WHERE id = 101&quot;;
stmt.executeUpdate(sql);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC LIKE 子句实例&lt;/p&gt;
&lt;p&gt;LIKE查询推荐使用：%放在占位符中或使用concat函数。&lt;/p&gt;
&lt;p&gt;1：%放在占位符中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;          parameters.add(&quot;%&quot;+familyMemberQueryBean.getFullName()+&quot;%&quot;);

          sql+=&quot; and t.full_name like ?&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2：使用concat函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            parameters.add(familyMemberQueryBean.getFullName());

            sql+=&quot; and t.full_name like concat('%',?,'%')&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3：使用转义字符\，百分号直接写在sql语句中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            parameters.add(familyMemberQueryBean.getFullName());

            sql+=&quot; and t.full_name like \&quot;%\&quot;?\&quot;%\&quot;&quot;;

  直接查询的SQL语句如下：SELECT id,full_name,email,phone,remark FROM family_member t WHERE 1 = 1

                                            AND t.full_name LIKE &quot;%&quot;'李'&quot;%&quot; AND t.email LIKE &quot;%&quot;'qq'&quot;%&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4：直接拼接SQL&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            sql+=&quot; and t.full_name like '%&quot;+familyMemberQueryBean.getFullName()+&quot;%'&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：JDBC模糊查询的4种方式&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JDBCTranctionTest {

    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;

    private static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/hello_mybatis&quot;;

    private static final String USER = &quot;root&quot;;

    private static final String PASSWORD = &quot;123456&quot;;

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //STEP 2: Register JDBC driver
        Class.forName(JDBC_DRIVER);
        ResultSet rs = null;
        Connection conn = null;
        PreparedStatement pstmt = null;
        PreparedStatement pstmtUp = null;
        Savepoint savepoint = null;
        try {
            //STEP 3: Open a connection
            //conn = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

            //使用数据库 URL 和 Properties 对象
            Properties info = new Properties();
            info.put(&quot;user&quot;, USER);
            info.put(&quot;password&quot;, PASSWORD);
            conn = DriverManager.getConnection(DATABASE_URL, info);
            //关闭自动提交模式
            conn.setAutoCommit(false);
            pstmtUp = conn.prepareStatement(&quot;UPDATE t_user SET phone = ? WHERE id = ?&quot;);
            pstmtUp.setString(1,&quot;22025555&quot;);
            pstmtUp.setInt(2,2);
            int execute = pstmtUp.executeUpdate();
            System.out.println(&quot;execute update1 :&quot;+execute);
            //想回滚到还原点，那么之前执行的sql要提交事务，否则这个还原点就没有意义，因为一整个事务都没有提交
            conn.commit();
            //创建还原点
            savepoint = conn.setSavepoint(&quot;updateSavepoint1&quot;);

            pstmtUp.setString(1,&quot;22026666&quot;);
            pstmtUp.setInt(2,2);
            execute = pstmtUp.executeUpdate();
            System.out.println(&quot;execute update2 :&quot;+execute);
            //报错
            //System.out.println(1/0);

            //STEP 4: Execute a query
            //pstmt = conn.prepareStatement(&quot;SELECT id, name, dept, phone FROM t_user WHERE id = ? and name = ?&quot;);

            //JDBC模糊查询的4种方式
            //1、%放在占位符中
    /*        pstmt = conn.prepareStatement(&quot;SELECT id, name, dept, phone FROM t_user WHERE id = ? and name like ? &quot;);
            pstmt.setInt(1,1);
            String userName = &quot;青&quot;;
            pstmt.setString(2,&quot;%&quot; + userName + &quot;%&quot;);
            rs = pstmt.executeQuery();*/

            //2、使用concat函数
           /* pstmt = conn.prepareStatement(&quot;SELECT id, name, dept, phone FROM t_user WHERE id = ? and name like concat('%',?,'%')&quot;);
            pstmt.setInt(1,1);
            String userName = &quot;青&quot;;
            pstmt.setString(2,userName);
            rs = pstmt.executeQuery();*/

            //3、使用转义字符\，百分号直接写在sql语句中
            /*pstmt = conn.prepareStatement(&quot;SELECT id, name, dept, phone FROM t_user WHERE id = ? and name like  \&quot;%\&quot;?\&quot;%\&quot;&quot;);
            pstmt.setInt(1,1);
            String userName = &quot;青&quot;;
            pstmt.setString(2,userName);
            rs = pstmt.executeQuery();*/

            //4、直接拼接SQL
            Statement stmt = conn.createStatement();
            String sql =&quot;SELECT id, name, dept, phone FROM t_user WHERE id = 1 and name like '%青%' &quot;;
            rs = stmt.executeQuery(sql);
            while (rs.next()) {
                //Retrieve by column name 通过列名获取值
                int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                String dept = rs.getString(&quot;dept&quot;);
                String phone = rs.getString(&quot;phone&quot;);
                //Display values
                System.out.println(&quot;id: &quot; + id + &quot;name: &quot; + name + &quot;dept: &quot; + dept + &quot;phone: &quot; + phone);
            }
            //提交事务
            conn.commit();
            //当我们设置不提交时，虽然查出来的是最新更改的值，但数据库其实并没有更改，因为我们没有手动提交
            //查出来的是最新更改的值是事务隔离类型的原因
        } catch (Exception e) {
            //回滚事务
            //conn.rollback();
            //回滚到还原点
            e.printStackTrace();
            conn.rollback(savepoint);
        } finally {
            //关闭 PreparedStatement 对象
            pstmt.close();
            pstmtUp.close();
            conn.close();
        }
        System.out.println(&quot;over !&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDBC 排序实例&lt;/p&gt;
&lt;p&gt;sql语句加入 order by column desc 或 order by column asc;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  stmt = conn.createStatement();
String sql = &quot;SELECT id, first, last, age FROM Registration&quot; +
&quot; ORDER BY first ASC&quot;;
ResultSet rs = stmt.executeQuery(sql);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;疑问：&lt;/p&gt;
&lt;p&gt;Q:ResultSet 这个结果集是个怎么样的结构，为什么要这样设计，内部是什么容器？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ResultSet rs = stmt.executeQuery(sql);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Q:PreparedStatement计划多次使用 SQL 语句的时候使用是什么意思？每条sql都会被多次使用啊？&lt;/p&gt;
&lt;p&gt;Q:conn.createStatement();默认初始化一个 Statement 对象来创建一个只能前进，而且只读的 ResultSet 对象。那为什么可以使用这些前后移动的方法呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rs.previous();
rs.absolute(1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Q:JDBC 流数据还有用到么？什么场景里会用？一般不会用这个，都是直接把数据转为String类型直接存到text字段里吧？&lt;/p&gt;
</description>
<pubDate>Fri, 24 Apr 2020 17:53:00 +0000</pubDate>
<dc:creator>卡斯特梅的雨伞</dc:creator>
<og:description>JDBC教程——检视阅读 参考 JDBC教程——W3Cschool JDBC教程——一点教程，有高级部分 JDBC教程——易百 JDBC入门教程 – 终极指南 略读 三层架构详解，JDBC在数据访问层</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/castamere/p/12771313.html</dc:identifier>
</item>
<item>
<title>负载均衡服务之HAProxy基础配置（二） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12770930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12770930.html</guid>
<description>&lt;p&gt;　　前文我们聊了下haproxy的global配置段中的常用参数的说明以及使用，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12763245.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12763245.html&lt;/a&gt;；今天我们来说说haproxy的代理配置段中比较重要的参数配置的用法；&lt;/p&gt;
&lt;p&gt;　　代理配置段中分三段配置，第一段是defaults配置段，这一段我们在上一篇博客中也说过，主要用于定义一些默认参数配置；第二段是frontend配置段，该段主要用来定义haporxy面向客户端怎样提供服务的；比如监听在那个地址的那个端口啊，调度那个后端服务器组呀等等；第三段就是后端服务器的配置段，通常frontend和backend是联合使用，也就是说frontend必须调用一个已经定义好的backend这样才能够完全的把用户的请求调度到对应服务器或者服务器组上；而对于listen来讲，它更像一个代理的角色，它既可以定义前端对于用户端监听地址信息，同时它也能定义后端server的属性；简单讲listen指令融合了frontend和backend的功能；了解了如何定义前端监听地址以及后端被代理的server的方式后，接下来我们一一来看下代理配置段中的配置；&lt;/p&gt;
&lt;p&gt;　　defaults里的配置&lt;/p&gt;
&lt;p&gt;　　mode：该指令用于指定haporxy的工作类型的；http表示haproxy基于http协议代理后端服务器，这也是默认haproxy的工作类型；如果我们在后端backend或listen中没有配置haporxy的工作类型，默认就会继承defaults里的配置；tcp表示haproxy基于tcp协议代理后端服务器响应客户端请求；&lt;/p&gt;
&lt;p&gt;　　option redispatch ：当后端server宕机后，强制把请求定向到其他健康的服务器上；正是因为这个参数，就确保了用户端请求不会被调度到一个宕机的服务器上；&lt;/p&gt;
&lt;p&gt;　　示例：我们把option redispatch 这个配置注释掉，重启haproxy，然后把后端容器给停掉一台，看看haproxy会不会把对应的请求调度到停掉的server上呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424204227983-27827283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：我们只是注释了option redispatch 这段配置；对于后端服务器并没有人为手动的去修改；正常情况下，三台服务器如果都是正常的情况，是能够轮询的方式响应客户端请求的；现在我们把后端服务器停一台看看用户的请求会不会调度到停掉的那台服务器上呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424204647204-1970036165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：现在我们可以看到web2的状态是退出状态，不能够响应客户端的请求的；接下来我们用浏览器访问haproxy对外提服务的IP地址和端口；看看是否把用户请求调度到宕机的主机上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424205032653-1741483515.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到haproxy还是把用户端请求往宕机的主机上调度；我们把option  redispatch 配置打开，然后重启haproxy，在看看会不会把用户请求调度到宕机的主机上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424205327860-1542704131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：我们打开option redispatch 配置，然后重启haproxy；对于web2现在还是宕机的状态，我们再用浏览器访问，看看这次会不会把用户请求调度到宕机的web2上呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424205701351-306508942.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：我们把option redispatch 配置加上后，我们用浏览器访问haproxy的80端口，它不会把用户端请求调度到web2上去，原因就是因为检测web2没有通过，强制把请求调度到下一个服务器上去了；之所以我们看到中间有一段时间要等，是因为haproxy在对web2进行检测；&lt;/p&gt;
&lt;p&gt;　　option abortonclose：当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接；&lt;/p&gt;
&lt;p&gt;　　option http-keep-alive 60：开启会话保持，并设置时长为60s&lt;/p&gt;
&lt;p&gt;　　option forwardfor：开启IP透传；这个参数的意思是把客户端的源ip信息通过X-Forwarded-For首部传给后端server，后端server可通过扑捉haproxy发来的请求报文，把对应X-Forwarded-For首部的值记录下来；通常需要后端服务器更改日志格式，把对应首部的值加入到日志中显示；&lt;/p&gt;
&lt;p&gt;　　示例：配置后端server记录haproxy发来的请求报文中X-Forwarded-For首部的值；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424212659478-1684403628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：我们在web1上修改了httpd的日志格式，让第一个字段记录X-Forwarded-For首部的值；然后让httpd重读配置文件；接下来我们就可以用浏览器访问haproxy，看看web1是否能够把客户端的源ip记录下来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424213314500-2123980933.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当haproxy把我们的请求调度到web1上时，对应web1的日志就会把X-Forwarded-For的值记录下来；这个首部的值就是记录客户端的源ip地址的；这样一来我们后端server上的日志就不再只有haproxy代理的的地址了；&lt;/p&gt;
&lt;p&gt;　　timeout connect 60s：转发客户端请求到后端server的最长连接时间；这个时间是定义代理连接后端服务器的超时时长；&lt;/p&gt;
&lt;p&gt;　　timeout server 600s ：转发客户端请求到后端服务端的超时超时时长；这个时间是服务端响应代理的超时时长；&lt;/p&gt;
&lt;p&gt;　　timeout client 600s ：与客户端的最长空闲时间；&lt;/p&gt;
&lt;p&gt;　　timeout http-keep-alive 120s：session 会话保持超时时间，范围内会转发到相同的后端服务器；&lt;/p&gt;
&lt;p&gt;　　timeout check 5s：对后端服务器的检测超时时间；&lt;/p&gt;
&lt;p&gt;　　retries 3：定义重试次数；&lt;/p&gt;
&lt;p&gt;　　maxconn  3000：server的最大连接数（通常这个会配置在各server后面，用来指定该server的最大连接数）&lt;/p&gt;
&lt;p&gt;　　以上就是haproxy defaults配置段的常用配置说明和使用；接下来我们来说一下frontend 配置段和backend配置段&lt;/p&gt;
&lt;p&gt;　　frontend配置段里的指令配置&lt;/p&gt;
&lt;p&gt;　　bind:该指令用于指定绑定IP和端口的，通常用于frontend配置段中或listen配置段中；用法是bind [IP]:&amp;lt;PORT&amp;gt;,……&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424214926341-1110395814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示前端监听80端口和8080端口，这两个端口都可以把用户端请求代理到后端指定的服务器组上进行响应；&lt;/p&gt;
&lt;p&gt;　　测试：重启haproxy 用浏览器访问192.168.0.22：8080端口，看看是否能够响应？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424215445679-2099107016.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们用浏览器访问8080也是能够正常响应的；&lt;/p&gt;
&lt;p&gt;　　除此以外，前端监听端口我们也可以不用bind参数指定 我们直接在frontend 或listen名字后面加要监听的地址和端口即可，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424215939795-831173341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：listen的配置也是支持以上两种的形式去监听端口的；通常不写IP地址表示监听本机所以ip地址对应的端口；&lt;/p&gt;
&lt;p&gt;　　balance：指定后端服务器组内的服务器调度算法；这个指令只能用于listen和backend或者defaults配置段中；&lt;/p&gt;
&lt;p&gt;　　　　roundrobin：动态轮询；支持权重的运行时调整，支持慢启动，每个后端中最多支持4095个server；什么意思呢？动态调整权重就是说不重启服务的情况下调整权重；慢启动说的是，前端的流量不会一下子全部给打进来，而是一部分一部分的打到后端服务器上；这样可以有效防止流量过大时一下子把后端服务器压垮的情况；后端最多支持4095个server表示在一个backend或listen中使用该算法最多只能定义4095个server；通常对于生产环境这个也是够用了；&lt;/p&gt;
&lt;p&gt;　　　　static-rr：静态轮询，不支持权重的运行时调整，不支持慢启动；这也是静态算法的确定；但这种算法对后端server没有限制；&lt;/p&gt;
&lt;p&gt;　　　　leastconn：最少连接算法；该算法本质上同static-rr没有太多的不同，通常情况下static-rr用于短连接场景中；而leastconn多用于长连接的场景中，如MySQL、LDAP等；&lt;/p&gt;
&lt;p&gt;　　　　first：根据服务器在列表中的位置，自上而下进行调度；前面服务器的连接数达到上限，新请求才会分配给下一台服务；&lt;/p&gt;
&lt;p&gt;　　　　source：源地址hash算法；类似LVS中的sh算法；hash类的算法动态与否取决于hash-type的值；如果我们定义hash-type的值为map-based（除权取余法）就表示该算法是静态算法，静态算法就不支持慢启动，动态调整权重；如果hash-type的值是consistent（一致性哈希）就表示该算法是动态算法，支持慢启动，动态权重调整；&lt;/p&gt;
&lt;p&gt;　　　　uri：对URI的左半部分做hash计算，并由服务器总权重相除以后派发至某挑出的服务器；这里说一下一个完整的rul的格式；&amp;lt;scheme&amp;gt;://[user:password@]&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;[/path][;params][?query][#frag]其中scheme，host，port这三项是必须有的，其他可有可无；这里说的uri就是指[/path][;params][?query][#frag]这一部分，而uri的左半部份指的是[/path][;params]；所以uri算法是对用户请求的资源路径+参数做hash计算；&lt;/p&gt;
&lt;p&gt;　　　　url_param：对用户请求的uri的&amp;lt;params&amp;gt;部分中的参数的值作hash计算，并由服务器总权重相除以后派发至某挑出的服务器；通常用于追踪用户，以确保来自同一个用户的请求始终发往同一个Backend Server；&lt;/p&gt;
&lt;p&gt;　　　　hdr(&amp;lt;name&amp;gt;)：对于每个http请求，此处由&amp;lt;name&amp;gt;指定的http首部将会被取出做hash计算； 并由服务器总权重相除以后派发至某挑出的服务器；没有有效值的会被轮询调度； 如hdr(Cookie)使用cookie首部做hash，把同一cookie的访问始终调度到某一台后端服务器上；&lt;/p&gt;
&lt;p&gt;　　示例：使用uri算法，并指定使用一致性hash算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424224415147-456920093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这样配置后，用户访问80端口的某一个uri始终会发往同一台服务器上；不管是那个用户去访问都会被调度到同一台服务器上进行响应&lt;/p&gt;
&lt;p&gt;　　我们在后端服务器上提供一些默认的页面，分别用不同的客户主机去访问相同的rul看看haproxy会怎么调度？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424224931669-223926859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：在三个容器内部分别新建了一个test.html的文件，其内容都是不相同的；接下来我们用浏览器访问/test.html看看会怎么调度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424225336640-1031818999.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们不管是用windows上的浏览器访问还是用Linux中的curl访问 都是被调度到web1上去了；其他算法我这里就不过多去测试了，有兴趣的小伙伴可自己动手去试试，看看效果；&lt;/p&gt;
&lt;p&gt;　　default_backend &amp;lt;backend&amp;gt;：设定默认的backend，用于frontend中；&lt;/p&gt;
&lt;p&gt;　　use_backend &amp;lt;backend&amp;gt;：调用对应的backend，用于frontend中；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424230058892-1209768316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示用户访问80端口或8081端口，都会被调度到webservs这个后端服务器组上进行响应；&lt;/p&gt;
&lt;p&gt;　　server &amp;lt;name&amp;gt; &amp;lt;address&amp;gt;[:[port]] [param*]：定义后端主机的各服务器及其选项；name表示服务器在haproxy上的内部名称；出现在日志及警告信息中；address表示服务器地址，支持使用主机名；port：端口映射；省略时，表示同bind中绑定的端口；param表示参数；常用的参数有如下几个：&lt;/p&gt;
&lt;p&gt;　　maxconn &amp;lt;maxconn&amp;gt;：当前server的最大并发连接数；&lt;/p&gt;
&lt;p&gt;　　backlog &amp;lt;backlog&amp;gt;：当前server的连接数达到上限后的后援队列长度；&lt;/p&gt;
&lt;p&gt;　　backup：设定当前server为备用服务器；和nginx里的sorry server 是一样的；&lt;/p&gt;
&lt;p&gt;　　cookie &amp;lt;value&amp;gt;：为当前server指定其cookie值，用于实现基于cookie的会话黏性；&lt;/p&gt;
&lt;p&gt;　　disabled：标记为不可用；相当于nginx里的down;&lt;/p&gt;
&lt;p&gt;　　redir &amp;lt;prefix&amp;gt;：将发往此server的所有GET和HEAD类的请求重定向至指定的URL；&lt;/p&gt;
&lt;p&gt;　　weight &amp;lt;weight&amp;gt;：权重，默认为1; &lt;/p&gt;
&lt;p&gt;　　on-error &amp;lt;mode&amp;gt;：后端服务故障时采取的行动策略；策略有如下几种：&lt;/p&gt;
&lt;p&gt;　　　　fastinter：表示缩短健康状态检测间的时长；&lt;/p&gt;
&lt;p&gt;　　　　fail-check：表示即健康状态检测失败，也要检测；这是默认策略；&lt;/p&gt;
&lt;p&gt;　　　　sudden-death:模拟一个致命前的失败的健康检查，一个失败的检查将标记服务器关闭，强制fastinter&lt;/p&gt;
&lt;p&gt;　　　　mark-down：立即标记服务器不可用，并强制fastinter；&lt;/p&gt;
&lt;p&gt;　　check：对当前server做健康状态检测；&lt;br/&gt;　　　　addr ：检测时使用的IP地址；&lt;br/&gt;　　　　port ：针对此端口进行检测；&lt;br/&gt;　　　　inter &amp;lt;delay&amp;gt;：连续两次检测之间的时间间隔，默认为2000ms;&lt;br/&gt;　　　　rise &amp;lt;count&amp;gt;：连续多少次检测结果为“成功”才标记服务器为可用；默认为2；&lt;br/&gt;　　　　fall &amp;lt;count&amp;gt;：连续多少次检测结果为“失败”才标记服务器为不可用；默认为3；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424234406772-1800193906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示对web1进行健康状态检测 每隔3000毫秒检测一次，检测2次失败就立刻标记为不可用，并强制缩短检测间隔时长；权重为2，意思是该服务器被调度两次，其他服务器调度一次；最大连接为1000；web2配置为backup角色，只有当web1和web3宕机后，web2才被调度；访问web3的请求直接重定向到http://nginx.org上响应；接下来我们如果访问haproxy的80或8081端口，应该是可以访问到web1和web3；如果web1和web3宕机后，web2就会被调度；&lt;/p&gt;
&lt;p&gt;　　测试：在web1和web3都正常的情况下，看看web2是否被调度？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424235336696-284261483.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到web2是没有被调度的，web1被调度两次后，直接跳过web2，调度web3去了；&lt;/p&gt;
&lt;p&gt;　　测试：把web1和web3停了，看看web2是否被调度？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425002245622-674021112.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：我们把web1和web3给停了，用浏览器访问，它还是跳转了；这说明redir不关心所在server是否存活；要想backup被激活必须让haproxy知道对应后端服务器组里是否有活跃的服务器，如果有，它就不会激活backup，如果没有就会激活；但现在haproxy不知道，原因是web3压根没有做健康状态检测；所以要想激活backup，我们需要在web3上配置一个check即可；但是这样一来，跳转就失效了；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425012437149-1390036504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：我们在web3上加入健康状态检测后服务能够正常起来；用浏览器访问backup是被激活了，但是web3上线后，对应跳转就失效了；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425012838011-1878553900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　总结一点：redir和check不能同时使用，同时使用redir优先级小于check；&lt;/p&gt;
</description>
<pubDate>Fri, 24 Apr 2020 17:43:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊了下haproxy的global配置段中的常用参数的说明以及使用，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/12763245.html；今天我们来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12770930.html</dc:identifier>
</item>
<item>
<title>C# 基础知识系列- 13 常见类库介绍（一） - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/12771247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/12771247.html</guid>
<description>&lt;p&gt;每篇一个前言，介绍一下这一篇的内容。之前的内容都是针对某些知识点进行的介绍，这篇内容介绍一下实际开发中常用的一些类和命名空间。这一篇是个连续剧，大概有个三四集。嗯，就是这样。&lt;/p&gt;

&lt;p&gt;System空间，是C#的基础命名空间，里面定义了常用值和数据类型以及各种类型的基类，当然也包括了很多C#程序运行中用到类，具体可以访问微软的官方API说明。这里简单介绍一下 我们在开发中最常用到的几个类。&lt;/p&gt;
&lt;h2 id=&quot;11-console&quot;&gt;1.1 Console&lt;/h2&gt;
&lt;p&gt;Console 控制台类，表示一个控制台应用程序的标准输入流、输出流和错误流。这是微软官方文档给的内容。实际上，Console类在一些其他类型的项目中也可以使用。因为Console类是程序与终端的交互，所以当程序持有一个终端的时候，该类就可以正确输出内容。&lt;/p&gt;
&lt;p&gt;照例，我们先看一下它的声明：&lt;code&gt;public static class Console&lt;/code&gt; 。可知这是一个静态类，需要明确一个概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在C#甚至大多数编程语言（支持静态类）中，静态类不可被继承，而且静态类的方法都是工具方法；&lt;/li&gt;
&lt;li&gt;静态类没有构造方法，也不能构造对象；&lt;/li&gt;
&lt;li&gt;静态类里的方法都是静态方法&lt;/li&gt;
&lt;li&gt;访问一个类的静态方法需要通过&lt;code&gt;类名.方法名&lt;/code&gt;来访问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我们可以使用：&lt;code&gt;Console.方法名&lt;/code&gt;来调用Console的方法。&lt;/p&gt;
&lt;p&gt;我们来看看Console在开发中常用的方法有哪些：&lt;/p&gt;
&lt;ol readability=&quot;20&quot;&gt;&lt;li readability=&quot;21&quot;&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static void Write (&amp;lt;T&amp;gt; value); //T 表示类型
public static void Write (string format, params object[] arg);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Write方法一共有17个重载版本，其中有常用的有以上两钟（不是两个版本）。其中第一中写法，T 代表C#的基础数据类型中的10种，再加一个Object。&lt;/p&gt;
&lt;p&gt;作用是将参数转成字符串打印到控制台中，所以效果与先将对象转成字符串然后再打印一样，所以第二种调用方式参数类型与 &lt;code&gt;String.Format&lt;/code&gt;是一致的。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        Console.Write(&quot;打印测试...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200425005214346-599969592.png&quot; alt=&quot;image-20200424164707972&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，会出现一个黑色背景的图框，然后显示打印的内容。&lt;/p&gt;
&lt;p&gt;C# 关于控制台的输出还有一个方法：&lt;code&gt;WriteLine&lt;/code&gt;，从名字来看是写一行的意思，实际表现也是如此，该方法每次输出都会产生新的一行内容，而&lt;code&gt;Write&lt;/code&gt;只会在上一次输出的结尾继续输出。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        Console.Write(&quot;打印测试...&quot;);
        Console.Write(&quot;Write输出测试&quot;);
        Console.WriteLine();
        Console.WriteLine(&quot;这行是调用WriteLine&quot;);
        Console.WriteLine(&quot;这行也是调用WriteLine输出的&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200425005214491-264258178.png&quot; alt=&quot;image-20200424165458931&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;Write&lt;/code&gt;不同的地方是，&lt;code&gt;WriteLine&lt;/code&gt;允许无参调用，表示输出一个空行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;获取用户输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static int Read ();
public static string ReadLine ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Console在读这方面就没有写那么花里胡哨了，只有两个是我们常用的读。第一个是，从输入流中读取一个字符，如果没有输入则返回-1；第二个是读取输入的一行字符。&lt;/p&gt;
&lt;p&gt;关于输入流以及流没有内容时返回-1这个问题就不在这里做介绍了。有追更的小伙伴可以等待《IO篇》的更新。&lt;/p&gt;
&lt;p&gt;第二个，就很有意思了，获取输入的一行内容，而不是一个字符，也就是说当用户决定这行内容输入完成点击换行后程序就能读取到输入的结果。&lt;/p&gt;
&lt;p&gt;来，看一下示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine(&quot;Read 测试&quot;);
        Console.WriteLine(&quot;请输入一个任意内容并按回车：&quot;);
        var key = Console.Read();
        Console.WriteLine($&quot;输入的是：{key}&quot;);
        Console.WriteLine();
        Console.ReadLine();
        key = Console.Read();
        Console.WriteLine($&quot;输入的是：{key}&quot;);
        Console.ReadLine();
        Console.WriteLine(&quot;ReadLine 测试&quot;);
        Console.WriteLine(&quot;请输入任意内容，并换行：&quot;);
        var line = Console.ReadLine();
        Console.WriteLine($&quot;输入的是：{line}&quot;);
        Console.WriteLine(&quot;示例结束&quot;);

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200425005214660-1746326.png&quot; alt=&quot;image-20200424210005278&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例中，我在每次调用Read前，都调用了一个ReadLine，这是因为在控制台中一次输入字符，然后按下回车并换行，这是有两个输入，所以在第二次Read时会将上次未读取的继续读取出来，所以我利用ReadLine的特性将未读取的内容一次性读取出来，保证下次调用都必须从控制台读取用户输入。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然，Console类并不是只有这些内容，只是这些是我们最常接触的方法。&lt;/p&gt;
&lt;h2 id=&quot;12-math&quot;&gt;1.2 Math&lt;/h2&gt;
&lt;p&gt;C#中的数学工具类，为三角函数、对数函数和其他通用数学函数提供常数和静态方法。这个类也是一个静态类，当然这不会影响我们对它的好奇。&lt;/p&gt;
&lt;p&gt;来，让我们一起看看里面有些什么方法吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static T Abs (&amp;lt;T&amp;gt; value);//T 代表 decimal, int,double,flout,long,sbyte,short，返回绝对值
public static double Acos (double d);//返回余弦值为指定数字的角度。
public static double Acosh (double d);//返回双曲余弦值为指定数字的角度。
public static double Asin (double d);// 返回正弦值为指定数字的角度。
public static double Asinh (double d);// 返回双曲正弦值为指定数字的角度。
public static double Atan (double d);// 返回正切值为指定数字的角度。
public static double Atan2 (double y, double x);// 返回正切值为两个指定数字的商的角度。
public static long BigMul (int a, int b);// 生成两个 32 位数字的完整乘积。
public static double BitDecrement (double x);// 返回小于 x 的下一个最小值。
public static double BitIncrement (double x);// 返回大于 x 的下一个最大值。
public static double Cbrt (double d);// 返回指定数字的立方根。
public static T Ceiling (&amp;lt;T&amp;gt; d); //T 代表 decimal、double，返回大于或等于指定数字的最小整数值。
public static double Cos (double d);// 返回指定角度的余弦值。
public static int DivRem (int a, int b, out int result);// 计算两个数字的商，并在输出参数中返回余数。result为余数
public static double Exp (double d);//返回 e 的指定次幂，e 指自然对数的底
public static T Floor (&amp;lt;T&amp;gt; d); //T 代表 decimal、double，返回小于或等于指定双精度浮点数的最大整数值。
public static int ILogB (double x);// 返回指定数字以 2 为底的整数对数。
public static double Log (double d);//返回指定数字的自然对数（底为 e）。
public static double Log (double a, double newBase);// 返回指定数字在使用指定底时的对数。newBase为底
public static double Log10 (double d);//返回指定数字以 10 为底的对数
public static double Log2 (double x);//返回指定数字以 2 为底的对数。
public static T Max(&amp;lt;T&amp;gt; t1,&amp;lt;T&amp;gt; t2);// T 代表 decimal, int,double,flout,long,sbyte,short，返回两者中较大的那个
public static T Min(&amp;lt;T&amp;gt; t1,&amp;lt;T&amp;gt; t2);// T 代表 decimal, int,double,flout,long,sbyte,short，返回两者中较小的那个
public static double Pow (double x, double y);// 返回指定数字的指定次幂。
public static double Round (double a);// 将双精度浮点值舍入到最接近的整数值，并将中点值舍入到最接近的偶数。
public static double ScaleB (double x, int n);//返回有效计算的 x * 2^n。
public static int Sign (&amp;lt;T&amp;gt; value); // T 代表 decimal,double,flout,int,long,sbyte,short，返回指示数字符号的整数。
public static double Sin (double a);// 返回指定角度的正弦值。
public static double Sinh (double value);//返回指定角度的双曲正弦值。
public static double Sqrt (double d);//返回指定数字的平方根。
public static double Tan (double a);//返回指定角度的正切值。
public static double Tanh (double value);//返回指定角度的双曲正切值。
public static T Truncate (&amp;lt;T&amp;gt; d);//T 代表 decimal、double，计算一个数字的整数部分。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嗯，密密麻麻的一大堆，方法虽多，但值得注意的方法只有以下几个：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static T Ceiling (&amp;lt;T&amp;gt; d); //T 代表 decimal、double，返回大于或等于指定数字的最小整数值。
public static T Floor (&amp;lt;T&amp;gt; d); //T 代表 decimal、double，返回小于或等于指定双精度浮点数的最大整数值。
public static T Truncate (&amp;lt;T&amp;gt; d);//T 代表 decimal、double，计算一个数字的整数部分。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这三个方法计算的结果都是整数，但返回类型并不是整数，所以在使用的时候需要我们进行一次类型转换。Math类还有两个值得注意的字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public const double E = 2.7182818284590451;// 表示自然对数的底，它由常数 e 指定。
public const double PI = 3.1415926535897931;// 表示圆的周长与其直径的比值，由常数 π 指定。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个也是Math里唯一的两个字段，这是数学中著名的两个无理数，这里只截取了一部分有效值。&lt;/p&gt;
&lt;h2 id=&quot;13-random&quot;&gt;1.3 Random&lt;/h2&gt;
&lt;p&gt;C# 中Random表示伪随机数生成器，这是一种能够产生满足某些随机性统计要求的数字序列的算法。这里大概讲解一下Random的使用，具体的原理等我研究一下哈。&lt;/p&gt;
&lt;p&gt;Random是一个类，所以与之前的两个类不同地方就是使用Random生成随机数需要事先构造一个Random对象。Random常用的方法有以下几组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual int Next ();// 返回一个整型的随机数
public virtual int Next (int maxValue);//返回一个小于所指定最大值的非负随机整数
public virtual int Next (int minValue, int maxValue);//返回在指定范围内的任意整数。
public virtual double NextDouble ();//返回一个大于或等于 0.0 且小于 1.0 的随机浮点数。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先演示一下Random的基本应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        Random rand = new Random();
        for(int i = 0;i&amp;lt; 10; i++)
        {
            Console.WriteLine($&quot;第{i + 1}次生成：{rand.Next()}&quot;);
        }
        Console.ReadLine();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200425005214799-1528569650.png&quot; alt=&quot;image-20200424225811906&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出直接Next返回的结果数字都比较大，所以在使用的时候，一般会使用&lt;code&gt;Next (int minValue, int maxValue)&lt;/code&gt; 限定返回值。&lt;/p&gt;
&lt;p&gt;回到开头，Random是一个类，每次初始化的时候系统会自动计算一个种子给它，如果快速重复构建Random对象，可能会生成一个重复序列，即每次调用的结果一致。（当然，官方说可以，实际我在net core 3.1的环境里没测出来）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        for(int i = 0;i&amp;lt; 5; i++)
        {
            Random rand = new Random();
            for(int j = 0; j &amp;lt; 10; j++)
            {
                Console.WriteLine($&quot;第{i}个Random 第{j}次生成：{rand.Next()}&quot;);
            }
        }
        Console.ReadLine();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是测试代码，有兴趣的小伙伴可以自己试试。&lt;/p&gt;
&lt;blockquote readability=&quot;3.3333333333333&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://blogs.attachie.club&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200425005215049-2105285534.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Apr 2020 16:52:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0. 前言 每篇一个前言，介绍一下这一篇的内容。之前的内容都是针对某些知识点进行的介绍，这篇内容介绍一下实际开发中常用的一些类和命名空间。这一篇是个连续剧，大概有个三四集。嗯，就是这样。 1. Sys</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/12771247.html</dc:identifier>
</item>
<item>
<title>kafka高吞吐量之消息压缩 - 李福春</title>
<link>http://www.cnblogs.com/snidget/p/12771030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snidget/p/12771030.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200424235650461-236581712.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;保证kafka高吞吐量的另外一大利器就是消息压缩。就像上图中的压缩饼干。&lt;/p&gt;
&lt;p&gt;压缩即空间换时间，通过空间的压缩带来速度的提升，即通过少量的cpu消耗来减少磁盘和网络传输的io。&lt;/p&gt;

&lt;p&gt;消息格式V1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200424235650782-1478890240.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;kafka不会直接操作单条消息，而是直接操作一个消息集合。&lt;/p&gt;
&lt;p&gt;消息格式V2:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200424235650983-1990915829.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1, 抽取了消息的公共部分放到消息集合中；去掉每条消息的公共部分，减少了总体积。&lt;/p&gt;
&lt;p&gt;2，消息的CRC校验由对每一条消息，移动到了对消息集合进行校验，减少了校验次数，节省了cpu;&lt;/p&gt;
&lt;p&gt;3, 对单个消息进行压缩，放到消息的body字段 pk 对消息集合整个进行压缩 更好的压缩效果；&lt;/p&gt;
&lt;p&gt;压缩过程模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200424235651189-26912743.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如何衡量一个压缩算法的好坏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200424235651359-1708820053.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常见的压缩算法对比：&lt;/p&gt;
&lt;p&gt;Zstandard 算法（简写为 zstd）。它是 Facebook 开源的一个压缩算法，能够提供超高的压缩比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200424235651526-1674761809.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启用压缩场景&lt;/p&gt;
&lt;p&gt;如果cpu负载比较高，不适合启用压缩；&lt;/p&gt;
&lt;p&gt;如果带宽不足，而cpu负载不高，最适合启用压缩，节约大量的带宽；&lt;/p&gt;
&lt;p&gt;尽量避免消息格式不一致带来的解压缩消耗。&lt;/p&gt;

&lt;p&gt;压缩的目的是较少空间占用，带来传输速度的提升，但是需要消耗一定的cpu ；&lt;/p&gt;
&lt;p&gt;是一种提高kafka消息吞吐量的有效办法。&lt;/p&gt;
&lt;p&gt;本节回顾了新版的kafka是如何对消息进行压缩的，压缩和解压缩的流程是怎样的，&lt;/p&gt;
&lt;p&gt;然后对比了常见的4种压缩算法，根据具体的使用场景来选择是否启用压缩，以及选择合适的压缩算法。&lt;/p&gt;
&lt;p&gt;然后给出了压缩的配置参数，在producer和borker端都可以使用compression.type来设置。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;原创不易，点赞关注支持一下吧！转载请注明出处，让我们互通有无，共同进步，欢迎沟通交流。&lt;br/&gt;我会持续分享Java软件编程知识和程序员发展职业之路，欢迎关注，我整理了这些年编程学习的各种资源，关注公众号‘李福春持续输出’，发送'学习资料'分享给你！&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200424235651729-817123692.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 24 Apr 2020 15:57:00 +0000</pubDate>
<dc:creator>李福春</dc:creator>
<og:description>背景 保证kafka高吞吐量的另外一大利器就是消息压缩。就像上图中的压缩饼干。 压缩即空间换时间，通过空间的压缩带来速度的提升，即通过少量的cpu消耗来减少磁盘和网络传输的io。 消息压缩模型 消息格</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snidget/p/12771030.html</dc:identifier>
</item>
<item>
<title>PHP反序列化漏洞总结 - 一条没有梦想的咸鱼TvT</title>
<link>http://www.cnblogs.com/Lee-404/p/12771032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lee-404/p/12771032.html</guid>
<description>&lt;h2&gt;写在前边&lt;/h2&gt;
&lt;p&gt;　　做了不少PHP反序列化的题了，是时候把坑给填上了。参考了一些大佬们的博客，自己再做一下总结&lt;/p&gt;
&lt;p&gt;
&lt;h3&gt;1.面向对象&lt;br/&gt;2.PHP序列化和反序列化&lt;br/&gt;3.PHP反序列化漏洞实例&lt;/h3&gt;
&lt;/p&gt;
&lt;h2&gt;1.面向对象&lt;/h2&gt;
&lt;p&gt;　　在了解序列化和反序列化之前，先简单了解一下PHP的面向对象。&lt;/p&gt;
&lt;p&gt;　　万物皆可对象。根据官方手册，PHP中，以关键字class定义一个类，一个类可以包含有属于自己的常量，变量（称为“属性”）以及函数（称为“方法”）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明属性&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;$name&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; eat()
    {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;name.&quot;在吃饭&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在已经定义好了一个类，接下来用关键字new来实例化这个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$people_1&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; People();　　//实例化对象
&lt;/span&gt;&lt;span&gt;$people_1&lt;/span&gt;-&amp;gt;name = '张三'&lt;span&gt;;　　//属性赋值
&lt;/span&gt;&lt;span&gt;$people_1&lt;/span&gt;-&amp;gt;Eat();　　　　　　//调用方法
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　完整代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$name&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; eat()
    {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;name.&quot;在吃饭&quot;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;$people_1&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; People();
&lt;/span&gt;&lt;span&gt;$people_1&lt;/span&gt;-&amp;gt;name = '张三'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$people_1&lt;/span&gt;-&amp;gt;&lt;span&gt;Eat();

&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　效果：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1678972/202004/1678972-20200424204844402-973073691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.PHP序列化和反序列化&lt;/h2&gt;
&lt;p&gt;　　根据官方手册，所有php里面的值都可以使用函数serialize()&lt;span class=&quot;function&quot;&gt;来返回一个包含字节流的字符串来表示。unserialize()&lt;span class=&quot;function&quot;&gt;函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。emmmm。。。。个人理解其实就是为了解决PHP在执行当前脚本需要跨脚本文件传递某些变量内容时，但因为之前脚本执行完后把内容释放掉从而无法获取的问题。serialize可以将变量转换为字符串，并且在转换的过程中可以保存当前变量的值，而unserialize则可以将serialize生成的字符串转换回变量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;function&quot;&gt;根据之前的例子，再添加个age属性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$name&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$age&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新加属性 &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Eat()
    {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;name.&quot;在吃饭&amp;lt;/br&amp;gt;&quot;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;$people_1&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; People();
&lt;/span&gt;&lt;span&gt;$people_1&lt;/span&gt;-&amp;gt;name = '张三'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$people_1&lt;/span&gt;-&amp;gt;age = 18&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$people_1&lt;/span&gt;-&amp;gt;&lt;span&gt;Eat();　　

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列化&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;serialize&lt;/span&gt;(&lt;span&gt;$people_1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　效果：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1678972/202004/1678972-20200424211101526-695366817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　O:6:&quot;People&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;张三&quot;;s:3:&quot;age&quot;;i:18;}就是当前people_1这个对象序列化后的形式。&quot;O&quot;表示对象，“6”表示对象所属的类长度为6，“People”为类名，“2”表示有2个参数。“{}”里面是参数的key和value，s:4:&quot;name&quot;表示这个参数的string类型，长度为4，key值是name。后面以此类推，i表示int类型&lt;/p&gt;
&lt;p&gt;　　然后反序列化这段，新建一个文件test2.php&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$name&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$age&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; eat()
    {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;name.&quot;在吃饭&amp;lt;/br&amp;gt;&quot;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重建对象&lt;/span&gt;
&lt;span&gt;$usr&lt;/span&gt; = &lt;span&gt;unserialize&lt;/span&gt;('O:6:&quot;People&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;张三&quot;;s:3:&quot;age&quot;;i:18;}'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出&lt;/span&gt;
&lt;span&gt;$usr&lt;/span&gt;-&amp;gt;&lt;span&gt;eat();&lt;br/&gt;&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1678972/202004/1678972-20200424213155688-1179686465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　其实吧，个人感觉序列化和反序列化就类似于存取数组。举个不恰当的例子，就像积木，序列化一个把搭建好后的积木收拾好，反序列化就是把收拾好的积木再按照原来的图纸搭起来。接下来说到的反序列化漏洞就类似于把原来的积木换了个颜色，某块积木形状对的但颜色不对，按照图纸搭起来就是感觉违和。&lt;/p&gt;

&lt;h2&gt;3.PHP反序列化漏洞&lt;/h2&gt;
&lt;p&gt;　　了解了什么是序列化和反序列化后，是时候研究一下PHP反序列化漏洞了，实际上，PHP反序列化漏洞利用的条件在实际环境中比较苛刻，但是如果可以利用一般都会产生很严重的后果&lt;/p&gt;
&lt;h3&gt;　　该漏洞需要有以下条件：　&lt;/h3&gt;
&lt;p&gt;　　　　1.unserialize函数的参数可控&lt;/p&gt;
&lt;p&gt;　　　　2.所写的内容需要有对象中的成员变量的值&lt;/p&gt;
&lt;p&gt;　　　　3.脚本中存在一个构造函数（__construct()）、析构函数（__destruct()）、__wakeup()函数中有向php文件中写数据的操作的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    __construct()当一个对象创建时被调用

    __destruct()当一个对象销毁时被调用

    __toString()当一个对象被当作一个字符串使用

    __sleep() 在对象在被序列化之前运行

    __wakeup将在序列化之后立即被调用所写的内容需要有对象中的成员变量的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里先借大佬的举个的例子（后续再填坑）&lt;/p&gt;
&lt;p&gt;　　创建test3.php&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;$test&lt;/span&gt; = &quot;123&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; __wakeup(){
        &lt;/span&gt;&lt;span&gt;$fp&lt;/span&gt; = &lt;span&gt;fopen&lt;/span&gt;(&quot;test.php&quot;, 'w'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;fwrite&lt;/span&gt;(&lt;span&gt;$fp&lt;/span&gt;, &lt;span&gt;$this&lt;/span&gt; -&amp;gt;&lt;span&gt; test);
        &lt;/span&gt;&lt;span&gt;fclose&lt;/span&gt;(&lt;span&gt;$fp&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;$test1&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;['test'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;$test1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;&amp;lt;br /&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$seri&lt;/span&gt; = &lt;span&gt;unserialize&lt;/span&gt;(&lt;span&gt;$test1&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;require&lt;/span&gt; &quot;test.php&quot;&lt;span&gt;;

&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　先盲目分析一波，Test这类有个重写的__wakeup()这个魔术方法，当序列化后，打开test.php，权限为写，将$test值重写到test.php,用GET方式将值传入$test1,然后反序列化。就是我们如果传入一个序列化后的EXP传入，text.php就会变成我们出传入内容&lt;/p&gt;
&lt;p&gt;      当值为空时，访问http://本地环境/test3.php?test=　　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1678972/202004/1678972-20200424225533019-615499027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　根据刚刚的方法，新建一个脚本，序列化一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;$test&lt;/span&gt; = &quot;123&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; __wakeup(){
        &lt;/span&gt;&lt;span&gt;$fp&lt;/span&gt; = &lt;span&gt;fopen&lt;/span&gt;(&quot;test.php&quot;, 'w'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;fwrite&lt;/span&gt;(&lt;span&gt;$fp&lt;/span&gt;, &lt;span&gt;$this&lt;/span&gt; -&amp;gt;&lt;span&gt; test);
        &lt;/span&gt;&lt;span&gt;fclose&lt;/span&gt;(&lt;span&gt;$fp&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;$test&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;serialize&lt;/span&gt;(&lt;span&gt;$test&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1678972/202004/1678972-20200424233456930-2090730392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后我们跟上参数 O:4:&quot;Test&quot;:1:{s:4:&quot;test&quot;;s:3:&quot;123&quot;;}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1678972/202004/1678972-20200424233856214-175709187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　发现不但页面更改了而且连原文件都被重写了，这时一个PHP反序列化漏洞就产生了&lt;/p&gt;
&lt;p&gt;　　（目前只是简单总结，实战方面先挖个坑，后续再补）&lt;/p&gt;

&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;https://www.freebuf.com/articles/web/167721.html&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/be6de8511cb9&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;如有错误还请指出，谢谢&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 24 Apr 2020 15:57:00 +0000</pubDate>
<dc:creator>一条没有梦想的咸鱼TvT</dc:creator>
<og:description>写在前边 做了不少PHP反序列化的题了，是时候把坑给填上了。参考了一些大佬们的博客，自己再做一下总结 1.面向对象2.PHP序列化和反序列化3.PHP反序列化漏洞实例 1.面向对象 在了解序列化和反序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lee-404/p/12771032.html</dc:identifier>
</item>
</channel>
</rss>