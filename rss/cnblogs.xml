<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>zuul+security跨域Cors问题解决 - Purgeyao</title>
<link>http://www.cnblogs.com/Purgeyao/p/12038077.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Purgeyao/p/12038077.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在服务后台都会出现跨域cors问题，不过一般spring解决起来比较方便，在框架+框架的基础上，问题就显得特别明显了，各种冲突，不了解源码的运行原理，解决起来也是有心无力。&lt;/p&gt;
&lt;p&gt;这里介绍的是zuul配置了跨域，在前端调用仍然会出现跨域的问题。&lt;/p&gt;
&lt;p&gt;一般没有权限的接口加上cors配置就会通过跨域的问题。不过在服务间调用具有权限的功能，莫名的报跨域问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;post特殊请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在解决问题时发现 &lt;code&gt;post&lt;/code&gt; 请求也有点特殊，这里也需要处理一下。&lt;/p&gt;
&lt;p&gt;post请求分为简单请求和复杂请求。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;CORS&lt;/code&gt; 中，可以使用 &lt;code&gt;OPTIONS&lt;/code&gt; 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 首部字段告知服务器实际请求所使用的 &lt;code&gt;HTTP&lt;/code&gt; 方法；&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。&lt;/p&gt;
&lt;p&gt;以及 &lt;code&gt;OPTIONS&lt;/code&gt; 未携带任何权限相关的内容，会被认证拦截，我们也得放开 &lt;code&gt;OPTIONS&lt;/code&gt; 类型请求&lt;/p&gt;
&lt;h2 id=&quot;功能使用&quot;&gt;功能使用&lt;/h2&gt;
&lt;h3 id=&quot;cross-解决&quot;&gt;Cross 解决&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1766679/201912/1766679-20191214085220260-309949780.png&quot; alt=&quot;cross&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前设置很简单，习惯操作把之前的代码复制了过来，第一次操作是创建了一个 &lt;code&gt;CorsFilter&lt;/code&gt; bean，但是简单的请求确实通过了，不过权限接口过不了，于是按照一些资料配置了下面的代码 注入了 &lt;code&gt;FilterRegistrationBean&lt;/code&gt; bean 还设置了 order 加载顺序。&lt;/p&gt;
&lt;p&gt;解决后无果 仍然和之前的效果一致。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 跨域配置 C - Cross  O - Origin  R - Resource  S - Sharing
 *
 * @author purgeyao
 * @since 1.0
 */
@Configuration
//@Order(Ordered.HIGHEST_PRECEDENCE)
public class CorsConfig {

  @Bean
  public FilterRegistrationBean filterRegistrationBean() {
    final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    final CorsConfiguration config = new CorsConfiguration();

    config.setAllowCredentials(true);
    config.setAllowedOrigins(Arrays.asList(&quot;*&quot;));
    config.setAllowedHeaders(Arrays.asList(&quot;*&quot;));
    config.setAllowedMethods(Arrays.asList(&quot;*&quot;));
    config.setMaxAge(300L);

    source.registerCorsConfiguration(&quot;/**&quot;, config);
    CorsFilter corsFilter = new CorsFilter(source);
    FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(corsFilter);
    filterRegistrationBean.setOrder(0);
    return filterRegistrationBean;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一些资料+源码的帮助下，尝试了下面代码：&lt;/p&gt;
&lt;p&gt;这次实现了 &lt;code&gt;CorsFilter&lt;/code&gt; 类 加载了 &lt;code&gt;@Order&lt;/code&gt; 顺序为 &lt;code&gt;(Ordered.HIGHEST_PRECEDENCE)&lt;/code&gt; 最优先。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 解决 zuul+oauth2 跨域配置 C - Cross  O - Origin  R - Resource  S - Sharing
 *
 * @author purgeyao
 * @since 1.0
 */
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class AjaxCorsFilter extends CorsFilter {

  public AjaxCorsFilter() {
    super(configurationSource());
  }

  private static UrlBasedCorsConfigurationSource configurationSource() {
    CorsConfiguration corsConfig = new CorsConfiguration();
//        List&amp;lt;String&amp;gt; allowedHeaders = Arrays.asList(&quot;x-auth-token&quot;, &quot;content-type&quot;, &quot;X-Requested-With&quot;, &quot;XMLHttpRequest&quot;);
    List&amp;lt;String&amp;gt; exposedHeaders = Arrays
        .asList(&quot;x-auth-token&quot;, &quot;content-type&quot;, &quot;X-Requested-With&quot;, &quot;XMLHttpRequest&quot;);
//        List&amp;lt;String&amp;gt; allowedMethods = Arrays.asList(&quot;POST&quot;, &quot;GET&quot;, &quot;DELETE&quot;, &quot;PUT&quot;, &quot;OPTIONS&quot;);

    List&amp;lt;String&amp;gt; allowedHeaders = Arrays.asList(&quot;*&quot;);
    List&amp;lt;String&amp;gt; allowedMethods = Arrays.asList(&quot;*&quot;);
    List&amp;lt;String&amp;gt; allowedOrigins = Arrays.asList(&quot;*&quot;);
    corsConfig.setAllowedHeaders(allowedHeaders);
    corsConfig.setAllowedMethods(allowedMethods);
    corsConfig.setAllowedOrigins(allowedOrigins);
    corsConfig.setExposedHeaders(exposedHeaders);
    corsConfig.setMaxAge(36000L);
    corsConfig.setAllowCredentials(true);

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration(&quot;/**&quot;, corsConfig);
    return source;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈哈，解决了，但是有没有感觉到莫名其妙啊，经过了解&lt;/p&gt;
&lt;p&gt;发现其实只是一个加载顺序的问题，我们上面注入的 &lt;code&gt;FilterRegistrationBean&lt;/code&gt; 也可以使用的，只是在设置order的时候有点问题 需要设置比 &lt;code&gt;security&lt;/code&gt; 优先级高，改为 &lt;code&gt;Ordered.HIGHEST_PRECEDENCE&lt;/code&gt; 发现成功可以通过跨域了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 跨域配置 C - Cross  O - Origin  R - Resource  S - Sharing
 *
 * @author purgeyao
 * @since 1.0
 */
@Configuration
//@Order(Ordered.HIGHEST_PRECEDENCE)
public class CorsConfig {

  @Bean
  public FilterRegistrationBean filterRegistrationBean() {
    final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    final CorsConfiguration config = new CorsConfiguration();

    config.setAllowCredentials(true);
    config.setAllowedOrigins(Arrays.asList(&quot;*&quot;));
    config.setAllowedHeaders(Arrays.asList(&quot;*&quot;));
    config.setAllowedMethods(Arrays.asList(&quot;*&quot;));
    config.setMaxAge(300L);

    source.registerCorsConfiguration(&quot;/**&quot;, config);
    CorsFilter corsFilter = new CorsFilter(source);
    FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(corsFilter);
    // 设置为 Ordered.HIGHEST_PRECEDENCE
    filterRegistrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE);
    return filterRegistrationBean;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决解决。。。&lt;/p&gt;
&lt;h3 id=&quot;options请求解决&quot;&gt;OPTIONS请求解决&lt;/h3&gt;
&lt;p&gt;有关 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS&quot;&gt;OPTIONS(NDN&lt;br/&gt;web docs)&lt;/a&gt; 介绍。&lt;/p&gt;
&lt;p&gt;在发送 post 请求 会发现在真正发送之前会有一个 &lt;code&gt;OPTIONS&lt;/code&gt; 请求。&lt;/p&gt;
&lt;p&gt;因 &lt;code&gt;OPTIONS&lt;/code&gt; 为携带任何有状态的认证信息，被权限拦截下来异常，就没有之后的真正请求了。&lt;/p&gt;
&lt;p&gt;我们只需要吧 &lt;code&gt;OPTIONS&lt;/code&gt; 请求放开 返回200状态即可。&lt;/p&gt;
&lt;p&gt;有很多办法做到，可以在zuul网关放过，也可以通过 &lt;code&gt;security&lt;/code&gt; 添加 忽略拦截列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    ...
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        ...
        // 添加忽略拦截OPTIONS 类型的请求
        http.authorizeRequests().antMatchers(HttpMethod.OPTIONS).permitAll();
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1766679/201912/1766679-20191214085222770-1730348929.png&quot; alt=&quot;options&quot;/&gt;&lt;/p&gt;
&lt;p&gt;万事大吉。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;简单的bug解决起来简单点，不过遇到交集的bug，有心无力的感觉，莫名其妙的问题，需要耐心观察源码运行原理。&lt;/p&gt;
&lt;blockquote readability=&quot;2.96875&quot;&gt;
&lt;p&gt;示例代码地址:&lt;a href=&quot;https://github.com/purgeteam/middleware-spring-boot-example/tree/master/spring-cloud-example/zuul/src/main/java/com/purgeteam/spring/cloud/zuul&quot;&gt;zuul-security&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;3.8235294117647&quot;&gt;
&lt;p&gt;作者GitHub:&lt;br/&gt;&lt;a href=&quot;https://github.com/purgeyao&quot;&gt;Purgeyao&lt;/a&gt; 欢迎关注&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;qq交流群: &lt;code&gt;812321371&lt;/code&gt; 微信交流群: &lt;code&gt;MercyYao&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1766679/201912/1766679-20191214085223322-523549007.jpg&quot; alt=&quot;微信公众号二维码&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 00:52:00 +0000</pubDate>
<dc:creator>Purgeyao</dc:creator>
<og:description>zuul+security跨域Cors问题解决 简介 场景 在服务后台都会出现跨域cors问题，不过一般spring解决起来比较方便，在框架+框架的基础上，问题就显得特别明显了，各种冲突，不了解源码的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Purgeyao/p/12038077.html</dc:identifier>
</item>
<item>
<title>DRF Django REST framework 之 认证组件（五） - Nolinked</title>
<link>http://www.cnblogs.com/pungchur/p/12028381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pungchur/p/12028381.html</guid>
<description>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;很久很久以前，Web站点只是作为浏览服务器资源（数据）和其他资源的工具，甚少有什么用户交互之类的烦人的事情需要处理，所以，Web站点的开发这根本不关心什么人在什么时候访问了什么资源，不需要记录任何数据，有客户端请求，我即返回数据，简单方便，每一个http请求都是新的，响应之后立即断开连接。&lt;/p&gt;
&lt;p&gt;而如今，互联网的世界发生了翻天覆地的变化，用户不仅仅需要跟其他用户沟通交流，还需要跟服务器交互，不管是论坛类、商城类、社交类、门户类还是其他各类Web站点，大家都非常重视用户交互，只有跟用户交互了，才能进一步留住用户，只有留住了用户，才能知道用户需求，知道了用户需求，才会产生商机，有了用户，就等于有了流量，才能够骗到…额…是融到钱，有了资金企业才能继续发展，可见，用户交互是非常重要的，甚至可以说是至关重要的一个基础功能。&lt;/p&gt;
&lt;p&gt;而谈到用户交互，则必须要谈到我们今天所要学习的知识点，认证、权限和频率。首先我们来看看认证。&lt;/p&gt;
&lt;h2&gt;认证组件&lt;/h2&gt;
&lt;h3&gt;使用token&lt;/h3&gt;
&lt;p&gt;大部分人都知道cookie和session这两种方式可以保存用户信息，这两种方式不同的是cookie保存在客户端浏览器中，而session保存在服务器中，他们各有优缺点，配合起来使用，可将重要的敏感的信息存储在session中，而在cookie中可以存储不太敏感的数据。&lt;/p&gt;
&lt;p&gt;而token称之为令牌。cookie、session和token都有其应用场景，没有谁好谁坏，不过开发数据接口类的Web应用，目前用token还是比较多的。&lt;/p&gt;
&lt;p&gt;token认证的大致步骤是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户登录，服务器端获取用户名密码，查询用户表，如果存在该用户且第一次登录（或者token过期），生成token，否则返回错误信息&lt;/li&gt;
&lt;li&gt;如果不是第一次登录，且token未过期，更新token值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;定义 &lt;span class=&quot;cnblogs_code&quot;&gt;url&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path, re_path

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; DrfOne &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views&lt;/span&gt;&lt;span&gt;

urlpatterns &lt;/span&gt;=&lt;span&gt; [

    path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;books/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, views.BookView.as_view({
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    })),
    re_path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;books/(?P&amp;lt;pk&amp;gt;\d+)/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.BookView.as_view({
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;retrieve&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;put&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    })),

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 登陆&lt;/span&gt;
    path(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.LoginView.as_view()),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建两个 &lt;span class=&quot;cnblogs_code&quot;&gt;model&lt;/span&gt; ，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo(models.Model):
    username &lt;/span&gt;= models.CharField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, max_length=32&lt;span&gt;)
    password &lt;/span&gt;= models.CharField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, max_length=32&lt;span&gt;)
    age &lt;/span&gt;= models.IntegerField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    gender &lt;/span&gt;= models.SmallIntegerField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;性别&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, choices=((1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), (2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)), default=1&lt;span&gt;)
    user_type_entry &lt;/span&gt;= ((1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;普通用户&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), (2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VIP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), (3, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SVIP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    user_type &lt;/span&gt;= models.SmallIntegerField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户级别&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, choices=&lt;span&gt;user_type_entry)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.username


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserToken(models.Model):
    user &lt;/span&gt;= models.ForeignKey(to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UserInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, on_delete=&lt;span&gt;models.CASCADE)
    token &lt;/span&gt;= models.CharField(max_length=128)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;post&lt;/span&gt; 方法接口，视图类如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.http &lt;span&gt;import&lt;/span&gt;&lt;span&gt; JsonResponse

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIView

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; DrfTwo.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; UserInfo, UserToken


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginView(APIView):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self, request):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义返回信息&lt;/span&gt;
        ret =&lt;span&gt; dict()
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义需要的信息&lt;/span&gt;
            fields = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个用户信息字典&lt;/span&gt;
            user_info =&lt;span&gt; dict()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断fields是否是request.data的子集&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; fields.issubset(set(request.data.keys())):
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fields:
                    user_info[key] &lt;/span&gt;=&lt;span&gt; request.data.get(key)

            user_instance &lt;/span&gt;= UserInfo.objects.filter(**&lt;span&gt;user_info).first()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户验证&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; user_instance:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自定义generate_token()方法，获取token值，在后面&lt;/span&gt;
                access_token =&lt;span&gt; generate_token()
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户登陆成功，创建token，token存在更新token, defaults为更新内容&lt;/span&gt;
                UserToken.objects.update_or_create(user=user_instance, defaults=&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: access_token
                })
                ret[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = 200&lt;span&gt;
                ret[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status_message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                ret[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; access_token
                ret[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user_role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; user_instance.get_user_type_display()

            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                ret[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = 201&lt;span&gt;
                ret[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status_message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败，用户名或密码错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            ret[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = 202&lt;span&gt;
            ret[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status_message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; str(e)


        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JsonResponse(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单写了个获取随机字符串的方法用来生成token值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; uuid


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; generate_token():
    random_str &lt;/span&gt;= str(uuid.uuid4()).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; random_str
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就是token的简单生成方式，当然，在生产环境中不会如此简单，关于token也有相关的库，然后在构造几条数据之后，可以通过POSTMAN工具来创建几个用户的token信息。&lt;/p&gt;

&lt;p&gt;接下来，如何对已经登录成功的用户实现访问授权呢？也就是说，只有登录过的用户（有token值）才能访问特定的数据，该DRF的认证组件出场了&lt;/p&gt;
&lt;h3&gt;认证组件的使用&lt;/h3&gt;
&lt;p&gt;首先，新建一个认证类，之后的认证逻辑就包含在这个类里面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.定义认证类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAuth(object):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 认证逻辑&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; authenticate(self, request):
        user_token &lt;/span&gt;= request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        token_object &lt;/span&gt;= UserToken.objects.filter(token=&lt;span&gt;user_token).first()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; token_object:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; token_object.user.username, token_object.token
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; APIException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;认证失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现方式看上去非常简单，到 &lt;span class=&quot;cnblogs_code&quot;&gt;token&lt;/span&gt; 表里面查看 &lt;span class=&quot;cnblogs_code&quot;&gt;token&lt;/span&gt; 是否存在，然后根据这个信息，返回对应信息即可，然后，在需要认证通过才能访问的数据接口里面注册认证类即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.viewsets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ModelViewSet
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIException

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; DrfOne.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Book, UserToken
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; DrfOne.drf_serializers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BookSerializer


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.定义认证类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAuth(object):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 认证逻辑&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; authenticate(self, request):
        user_token &lt;/span&gt;= request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        token_object &lt;/span&gt;= UserToken.objects.filter(token=&lt;span&gt;user_token).first()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; token_object:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; token_object.user.username, token_object.token
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; APIException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;认证失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookView(ModelViewSet):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.指定认证类，固定写法&lt;/span&gt;
    authentication_classes =&lt;span&gt; [UserAuth]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取数据源, 固定写法&lt;/span&gt;
    queryset =&lt;span&gt; Book.objects.all()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 序列化类, 固定写法&lt;/span&gt;
    serializer_class = BookSerializer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;序列类 &lt;span class=&quot;cnblogs_code&quot;&gt;BookSerializer&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7f880310-3807-4913-8142-508f8e870ca7')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_7f880310-3807-4913-8142-508f8e870ca7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7f880310-3807-4913-8142-508f8e870ca7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7f880310-3807-4913-8142-508f8e870ca7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7f880310-3807-4913-8142-508f8e870ca7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework &lt;span&gt;import&lt;/span&gt;&lt;span&gt; serializers

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; DrfOne &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookSerializer(serializers.ModelSerializer):
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        model &lt;/span&gt;=&lt;span&gt; models.Book
        fields &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

        extra_kwargs &lt;/span&gt;=&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 仅写&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publish&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;write_only&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;write_only&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True},
        }

    publish_name &lt;/span&gt;= serializers.CharField(max_length=32, read_only=True, source=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publish.name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    publish_address &lt;/span&gt;= serializers.CharField(max_length=32, read_only=True, source=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publish.address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    author_name &lt;/span&gt;=&lt;span&gt; serializers.SerializerMethodField()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_author_name(self, book_obj):
        author_list &lt;/span&gt;=&lt;span&gt; list()
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; author &lt;span&gt;in&lt;/span&gt;&lt;span&gt; book_obj.authors.all():
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意列表添加字段，author.name而不是author&lt;/span&gt;
&lt;span&gt;            author_list.append(author.name)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; author_list
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;类BookSerializer&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;多个认证类&lt;/h3&gt;
&lt;p&gt;需要注意的是，如果需要返回什么数据，请在最后一个认证类中返回，因为如果在前面返回，在源码的 &lt;span class=&quot;cnblogs_code&quot;&gt;self._authentication()&lt;/span&gt; 方法中会对返回值进行判断，如果不为空，认证的过程就会中止，多个认证类的实现方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.定义认证类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAuth(object):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 认证逻辑&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; authenticate(self, request):
        user_token &lt;/span&gt;= request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        token_object &lt;/span&gt;= UserToken.objects.filter(token=&lt;span&gt;user_token).first()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; token_object:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; token_object.user.username, token_object.token
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; APIException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;认证失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAuthTwo(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; authenticate(self, request):
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; APIException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;就是这么简单！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookView(ModelViewSet):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.指定认证类，固定写法&lt;/span&gt;
    authentication_classes =&lt;span&gt; [UserAuth, UserAuthTwo]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取数据源, 固定写法&lt;/span&gt;
    queryset =&lt;span&gt; models.Book.objects.all()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 序列化类, 固定写法&lt;/span&gt;
    serializer_class = BookSerializer
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;全局认证&lt;/h3&gt;
&lt;p&gt;如果希望所有的数据接口都需要认证怎么办？很简单，如果认证类自己没有 &lt;span class=&quot;cnblogs_code&quot;&gt;authentication_classes&lt;/span&gt; ，就会到 &lt;span class=&quot;cnblogs_code&quot;&gt;settings&lt;/span&gt; 中去找，通过这个机制，我们可以将认证类写入到 &lt;span class=&quot;cnblogs_code&quot;&gt;settings&lt;/span&gt; 文件中即可实现全局认证：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
REST_FRAMEWORK =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEFAULT_AUTHENTICATION_CLASSES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: (
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authenticator.utils.authentication.UserAuth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authenticator.utils.authentication.UserAuth2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    ),
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;~&amp;gt;.&amp;lt;~&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 00:52:00 +0000</pubDate>
<dc:creator>Nolinked</dc:creator>
<og:description>引言 很久很久以前，Web站点只是作为浏览服务器资源（数据）和其他资源的工具，甚少有什么用户交互之类的烦人的事情需要处理，所以，Web站点的开发这根本不关心什么人在什么时候访问了什么资源，不需要记录任</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pungchur/p/12028381.html</dc:identifier>
</item>
<item>
<title>为什么每一个爬虫工程师都应该学习 Kafka - 青南</title>
<link>http://www.cnblogs.com/xieqiankun/p/use_kafka_in_spider.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieqiankun/p/use_kafka_in_spider.html</guid>
<description>&lt;p&gt;这篇文章不会涉及到Kafka 的具体操作，而是告诉你 Kafka 是什么，以及它能在爬虫开发中扮演什么重要角色。&lt;/p&gt;
&lt;h2 id=&quot;一个简单的需求&quot;&gt;一个简单的需求&lt;/h2&gt;
&lt;p&gt;假设我们需要写一个微博爬虫，老板给的需求如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-35-25.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开发爬虫对你来说非常简单，于是三下五除二你就把爬虫开发好了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-39-18.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来开始做报警功能，逻辑也非常简单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-52-50.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看看统计关键词的功能，这个功能背后有一个网页，会实时显示抓取数据量的变化情况，可以显示每分钟、每小时的某个关键词的抓取量。&lt;/p&gt;
&lt;p&gt;这个功能对你来说也挺简单，于是你实现了如下逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-17-16-03.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一个需求，对微博数据进行情感分析。情感分析的模块有别的部门同事开发，你要做的就是每个小时拉取一批数据，发送到接口，获取返回，然后存入后端需要的数据库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-17-12-52.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;任务完成，于是你高兴地回家睡觉了。&lt;/p&gt;
&lt;h2 id=&quot;困难接踵而至&quot;&gt;困难接踵而至&lt;/h2&gt;
&lt;h3 id=&quot;爬虫变慢了&quot;&gt;爬虫变慢了&lt;/h3&gt;
&lt;p&gt;随着老板逐渐增加新的关键词，你发现每一次完整抓取的时间越来越长，一开始是2分钟抓取一轮，后来变成10分钟一轮，然后变成30分钟一轮，接下来变成1小时才能抓取一轮。随着延迟越来越高，你的报警越来越不准确，微博都发出来一小时了，你的报警还没有发出来，因为那一条微博还没有来得及入库。&lt;/p&gt;
&lt;p&gt;你的爬虫技术非常好，能绕过所有反爬虫机制，你有无限个代理 IP，于是你轻轻松松就把爬虫提高到了每秒一百万并发。现在只需要1分钟你就能完成全部数据的抓取。这下没问题了吧。&lt;/p&gt;
&lt;p&gt;可是报警还是没有发出来。这是怎么回事？&lt;/p&gt;
&lt;h3 id=&quot;数据库撑不住了&quot;&gt;数据库撑不住了&lt;/h3&gt;
&lt;p&gt;经过排查，你发现了问题。数据抓取量上来了，但是 MongoDB 却无法同时接收那么多的数据写入。数据写入速度远远小于爬取数据，大量的数据堆积在内存中。于是你的服务器爆炸了。&lt;/p&gt;
&lt;p&gt;你紧急搭建了100个数据库并编号0-99，对于抓取到的微博，先把每一条微博的 ID对100求余数，然后把数据存入余数对应的 MongoDB 中。每一台 MongoDB 的压力下降到了原来的1%。数据终于可以即时存进数据库里面了。&lt;/p&gt;
&lt;p&gt;可是报警还是没有发出来，不仅如此，现在实时抓取量统计功能也不能用了，还有什么问题？&lt;/p&gt;
&lt;h3 id=&quot;查询来不及了&quot;&gt;查询来不及了&lt;/h3&gt;
&lt;p&gt;现在报警程序要遍历100个数据库最近5分钟里面的每一条数据，确认是否有需要报警的内容。但是这个遍历过程就远远超过5分钟。&lt;/p&gt;
&lt;h3 id=&quot;时间错开了&quot;&gt;时间错开了&lt;/h3&gt;
&lt;p&gt;由于微博的综合搜索功能不是按照时间排序的，那么就会出现这样一种情况，早上10:01发的微博，你在12:02的时候才抓到。&lt;/p&gt;
&lt;p&gt;不论你是在报警的时候筛选数据，还是筛选数据推送给 NLP 分析接口，如果你是以微博的发布时间来搜索，那么这一条都会被你直接漏掉——当你在10:05的时候检索10:00-10:05这5分钟发表的微博，由于这一条微博没有抓到，你自然搜索不到。&lt;/p&gt;
&lt;p&gt;当你12:05开始检索12:00-12:05的数据时，你搜索的是发布时间为12:00-12:05的数据，于是10:01这条数据虽然是在12:02抓到的，但你也无法筛选出来。&lt;/p&gt;
&lt;p&gt;那么是不是可以用抓取时间来搜索呢？例如10:05开始检索在10:00-10:05抓取到的数据，无论它的发布时间是多少，都检索出来。&lt;/p&gt;
&lt;p&gt;这样做确实可以保证不漏掉数据，但这样做的代价是你必需保存、检索非常非常多的数据。例如每次抓取，只要发布时间是最近10小时的，都要保存下来。于是报警程序在检索数据时，就需要检索这5分钟入库的，实际上发布时间在10小时内的全部数据。&lt;/p&gt;
&lt;p&gt;什么，你说每次保存之前检查一下这条微博是否已经存在，如果存在就不保存？别忘了批量写入时间都不够了，你还准备分一些时间去查询？&lt;/p&gt;
&lt;h3 id=&quot;脏数据来了&quot;&gt;脏数据来了&lt;/h3&gt;
&lt;p&gt;老板突然来跟你说，关键词“篮球”里面有大量的关于 蔡徐坤的内容，所以要你把所有包含蔡徐坤的数据全部删掉。&lt;/p&gt;
&lt;p&gt;那么，这个过滤逻辑放在哪里？放在爬虫的 pipelines.py 里面吗？那你要重新部署所有爬虫。今天是过滤蔡徐坤，明天是过滤范层层，后天是过滤王一博，每天增加关键词，你每天都得重新部署爬虫？&lt;/p&gt;
&lt;p&gt;那你把关键词放在 Redis 或者 MongoDB 里面，每次插入数据前，读取所有关键词，看微博里面不包含再存。&lt;/p&gt;
&lt;p&gt;还是那个问题，插入时间本来就不够了，你还要查数据库？&lt;/p&gt;
&lt;p&gt;好，关键词过滤不放在爬虫里面了。你写了一个脚本，每分钟检查一次MongoDB新增的数据，如果发现包含 不需要的关键词，就把他删除。&lt;/p&gt;
&lt;p&gt;现在问题来了，删除数据的程序每分钟检查一次，报警程序每5分钟检查一次。中间必定存在某些数据，还没有来得及删除，报警程序就报警了，老板收到报警来看数据，而你的删除程序又在这时把这个脏数据删了。&lt;/p&gt;
&lt;p&gt;这下好了，天天报假警，狼来了的故事重演了。&lt;/p&gt;
&lt;h2 id=&quot;个问题1个救星&quot;&gt;5个问题1个救星&lt;/h2&gt;
&lt;p&gt;如果你在爬虫开发的过程中遇到过上面的诸多问题，那么，你就应该试一试使用 Kafka。一次性解决上面的所有问题。&lt;/p&gt;
&lt;p&gt;把 Kafka 加入到你的爬虫流程中，那么你的爬虫架构变成了下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-34-55.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这看起来似乎和数据直接写进 MongoDB 里面，然后各个程序读取 MongoDB 没什么区别啊？那 Kafka 能解决什么问题？&lt;/p&gt;
&lt;p&gt;我们来看看，在这个爬虫架构里面，我们将会用到的 Kafka 的特性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-39-28.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与其说 Kafka 在这个爬虫架构中像 MongoDB，不如说更像 Redis 的列表。&lt;/p&gt;
&lt;p&gt;现在来简化一下我们的模型，如果现在爬虫只有一个需求，就是搜索，然后报警。那么我们可以这样设计：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-46-23.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;爬虫爬下来的数据，直接塞进 Redis 的列表右侧。报警程序从 Redis 列表左侧一条一条读取。读取一条检视一条，如果包含报警关键词，就报警。然后读取下一条。&lt;/p&gt;
&lt;p&gt;这样做有什么好处？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-50-27.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为报警程序直接从 Redis 里面一条一条读取，不存在按时间搜索数据的过程，所以不会有数据延迟的问题。由于 Redis 是单线程数据库，所以可以同时启动很多个报警程序。由于 lpop 读取一条就删除一条，如果报警程序因为某种原因崩溃了，再把它启动起来即可，它会接着工作，不会重复报警。&lt;/p&gt;
&lt;p&gt;但使用 Redis 列表的优势也是劣势：列表中的信息只能消费1次，被弹出了就没有了。&lt;/p&gt;
&lt;p&gt;所以如果既需要报警，还需要把数据存入 MongoDB 备份，那么只有一个办法，就是报警程序检查完数据以后，把数据存入 MongoDB。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可我只是一个哨兵，为什么要让我做后勤兵的工作？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个报警程序，让它做报警的事情就好了，它不应该做储存数据的事情。&lt;/p&gt;
&lt;p&gt;而使用 Kafka，它有 Redis 列表的这些好处，但又没有 Redis 列表的弊端！&lt;/p&gt;
&lt;p&gt;我们完全可以分别实现4个程序，不同程序之间消费数据的快慢互不影响。但同一个程序，无论是关闭再打开，还是同时运行多次，都不会重复消费。&lt;/p&gt;
&lt;h3 id=&quot;程序1报警&quot;&gt;程序1：报警&lt;/h3&gt;
&lt;p&gt;从 Kafka 中一条一条读取数据，做报警相关的工作。程序1可以同时启动多个。关了再重新打开也不会重复消费。&lt;/p&gt;
&lt;h3 id=&quot;程序2储存原始数据&quot;&gt;程序2：储存原始数据&lt;/h3&gt;
&lt;p&gt;这个程序从 Kafka 中一条一条读取数据，每凑够1000条就批量写入到 MongoDB 中。这个程序不要求实时储存数据，有延迟也没关系。 存入MongoDB中也只是原始数据存档。一般情况下不会再从 MongoDB 里面读取出来。&lt;/p&gt;
&lt;h3 id=&quot;程序3统计&quot;&gt;程序3：统计&lt;/h3&gt;
&lt;p&gt;从 Kafka 中读取数据，记录关键词、发布时间。按小时和分钟分别对每个关键词的微博计数。最后把计数结果保存下来。&lt;/p&gt;
&lt;h3 id=&quot;程序4情感分析&quot;&gt;程序4：情感分析&lt;/h3&gt;
&lt;p&gt;从 Kafka 中读取每一条数据，凑够一批发送给 NLP 分析接口。拿到结果存入后端数据库中。&lt;/p&gt;
&lt;h3 id=&quot;如果要清洗数据怎么办&quot;&gt;如果要清洗数据怎么办&lt;/h3&gt;
&lt;p&gt;4个需求都解决了，那么如果还是需要你首先移除脏数据，再分析怎么办呢？实际上非常简单，你加一个 Kafka（Topic） 就好了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-21-11-27.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;大批量通用爬虫&quot;&gt;大批量通用爬虫&lt;/h2&gt;
&lt;p&gt;除了上面的微博例子以外，我们再来看看在开发通用爬虫的时候，如何应用 Kafka。&lt;/p&gt;
&lt;p&gt;在任何时候，无论是 XPath 提取数据还是解析网站返回的 JSON，都不是爬虫开发的主要工作。爬虫开发的主要工作一直是爬虫的调度和反爬虫的开发。&lt;/p&gt;
&lt;p&gt;我们现在写 Scrapy 的时候，处理反爬虫的逻辑和提取数据的逻辑都是写在一个爬虫项目中的，那么在开发的时候实际上很难实现多人协作。&lt;/p&gt;
&lt;p&gt;现在我们把网站内容的爬虫和数据提取分开，实现下面这样一个爬虫架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-21-22-51.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;爬虫开发技术好的同学，负责实现绕过反爬虫，获取网站的内容，无论是 HTML 源代码还是接口返回的JSON。拿到以后，直接塞进 Kafka。&lt;/p&gt;
&lt;p&gt;爬虫技术相对一般的同学、实习生，需要做的只是从 Kafka 里面获取数据，不需要关心这个数据是来自于 Scrapy 还是 Selenium。他们要做的只是把这些HTML 或者JSON 按照产品要求解析成格式化的数据，然后塞进 Kafka，供后续数据分析的同学继续读取并使用。&lt;/p&gt;
&lt;p&gt;如此一来，一个数据小组的工作就分开了，每个人做各自负责的事情，约定好格式，同步开发，互不影响。&lt;/p&gt;
&lt;h2 id=&quot;为什么是-kafka-而不是其他&quot;&gt;为什么是 Kafka 而不是其他&lt;/h2&gt;
&lt;p&gt;上面描述的功能，实际上有不少 MQ 都能实现。但为什么是 Kafka 而不是其他呢？因为Kafka 集群的性能非常高，在垃圾电脑上搭建的集群能抗住每秒10万并发的数据写入量。而如果选择性能好一些的服务器，每秒100万的数据写入也能轻松应对。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章通过两个例子介绍了 Kafka 在爬虫开发中的作用。作为一个爬虫工程师，作为我的读者。请一定要掌握 Kafka。&lt;/p&gt;
&lt;p&gt;下一篇文章，我们来讲讲如何使用 Kafka。比你在网上看到的教程会更简单，更容易懂。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关注本公众号，回复“爬虫与Kafka”获取本文对应的思维导图原图。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 00:46:00 +0000</pubDate>
<dc:creator>青南</dc:creator>
<og:description>这篇文章不会涉及到Kafka 的具体操作，而是告诉你 Kafka 是什么，以及它能在爬虫开发中扮演什么重要角色。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xieqiankun/p/use_kafka_in_spider.html</dc:identifier>
</item>
<item>
<title>使用.NET Core创建Windows服务 - 使用.NET Core工作器方式 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/12038062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/12038062.html</guid>
<description>&lt;blockquote readability=&quot;4.3272727272727&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://dotnetcoretutorials.com/2019/12/07/creating-windows-services-in-net-core-part-3-the-net-core-worker-way/&quot;&gt;Creating Windows Services In .NET Core – Part 3 – The “.NET Core Worker” Way&lt;/a&gt;&lt;br/&gt;作者：Dotnet Core Tutorials&lt;br/&gt;译者：Lamond Lu&lt;br/&gt;译文：使用.NET Core创建Windows服务 - 使用.NET Core工作器方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191005211343706-2050001309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用.NET Core创建Windows服务&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;这里首先你要确保你已经安装了.NET Core 3.0或以上版本。在我编写这篇文章的时候， .NET Core 3.1刚刚发布，Visual Studio应该会提示你升级到最新版本。但是如果你想要在.NET Core 2.x项目中使用这个方式，应该是行不通的。&lt;/p&gt;
&lt;p&gt;如果你喜欢使用命令行创建项目，你就需要使用工作器(worker)类型创建项目：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;dotnet new worker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你是一个和我一样喜欢使用Visual Studio的开发人员，那么你可以在Visual Studio中使用项目模板完成相同的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201912/65831-20191214083435124-1006535101.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样做将创建出一个包含两个文件的项目。其中&lt;code&gt;Program.cs&lt;/code&gt;文件是应用的启动“引导程序”。另外一个文件是&lt;code&gt;worker.cs&lt;/code&gt;文件，在这个文件中，你可以编写你的服务逻辑。&lt;/p&gt;
&lt;p&gt;这看起来应该是相当的容易，但是为这个程序添加额外的并行后台服务，你还需要添加一个类，并让它继承&lt;code&gt;BackgroundService&lt;/code&gt;类:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyNewBackgroundWorker : BackgroundService
{    
    protected override Task ExecuteAsync(CancellationToken stoppingToken)    
    {        
        //Do something.     
    }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;Program.cs&lt;/code&gt;中，我们要做的只是把当前的Worker注册到服务集合(Service Collection)中即可。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;.ConfigureServices((hostContext, services) =&amp;gt;
{
    services.AddHostedService&amp;lt;Worker&amp;gt;();
    services.AddHostedService&amp;lt;MyNewBackgroundWorker&amp;gt;();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上作为“后台服务”任务的运行程序，&lt;code&gt;AddHostedService&lt;/code&gt;方法已经在框架中存在了很长时间了。在之前我们已经完成的一篇关于&lt;a href=&quot;https://dotnetcoretutorials.com/2019/01/13/hosted-services-in-asp-net-core/&quot;&gt;ASP.NET Core托管服务&lt;/a&gt;的文章， 但是在当时场景中，我们托管是是整个应用，而非一个在你应用程序幕后运行的东西。&lt;/p&gt;

&lt;p&gt;在默认的工作器(worker)模板中，已经包含了一个后台服务，这个服务可以将当前时间输出到控制台窗口。下面让我们点击F5来运行程序，看看我们能得到什么。&lt;/p&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;info: CoreWorkerService.Worker[0]      
      Worker running at: 12/07/2019 08:20:30 +13:00
info: Microsoft.Hosting.Lifetime[0]      
      Application started. Press Ctrl+C to shut down.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们启动程序之后，程序立刻就运行了！我们可以保持控制台的打开状态来调试应用，或者直接关闭窗口退出。相较于使用&quot;Microsoft&quot;方式来调试一个Windows服务，这简直就是天堂。&lt;/p&gt;
&lt;p&gt;这里我们需要注意的另外一件事情是编写控制台程序的平台。在最后，我们不仅在控制台窗口输出了时间，还通过依赖注入创建了一个托管worker. 我们也可以使用依赖注入容器来注入仓储，配置环境变量，获取配置等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但这里我们还没有做的事情是，将这个应用转换为Windows服务&lt;/strong&gt;。。&lt;/p&gt;

&lt;p&gt;为了将应用转换成Windows服务，我们需要使用如下命令引入一个包。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;Install-Package Microsoft.Extensions.Hosting.WindowsServices&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下一步，我们需要修改&lt;code&gt;Program.cs&lt;/code&gt;文件，添加&lt;code&gt;UseWindowsService()&lt;/code&gt;方法的调用。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; 
    Host.CreateDefaultBuilder(args)    
        .ConfigureServices((hostContext, services) =&amp;gt;    
        {        
            services.AddHostedService&amp;lt;Worker&amp;gt;();   
         })
         .UseWindowsService();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是所有需要变更的代码。&lt;/p&gt;
&lt;p&gt;运行我们的程序，你会发现和之前的效果完全样。但是这里最大的区别是，我们可以将当前应用以Windows服务的形式安装了。&lt;/p&gt;
&lt;p&gt;为了实现这一目的，我们需要发布当前项目。在当前项目目录中，我们可以运行以下命令：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;dotnet publish -r win-x64 -c Release&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们就可以借助标准的Windows服务安装器来安装当前服务了。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;sc create TestService BinPath=C:\full\path\to\publish\dir\WindowsServiceExample.exe&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前，你也可以使用Windows服务安装器的其他命令。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;sc start TestServicesc stop TestServicesc delete TestService&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后检查一下我们的服务面板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201912/65831-20191214083446395-754761263.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务已经正常工作了。&lt;/p&gt;

&lt;p&gt;老实说，我没有太多的Linux经验，但是终归是需要了解一下...&lt;/p&gt;
&lt;p&gt;在Linux系统中, 如果你希望我们编写的“Windows”服务在Linux系统中作为服务运行，你需要做以下2步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;Microsoft.Extensions.Hosting.Systemd&lt;/code&gt;替换之前的&lt;code&gt;Microsoft.Extensions.Hosting.WindowsServices&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;UseSystemd()&lt;/code&gt;替换&lt;code&gt;UseWindowsService()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到现在为止，我们已经介绍了借助3种不同的方式来创建Windows服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你可能会问“好吧，那我到底应该选择哪一种？”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里呢，我们可以首先把&quot;Microsoft&quot;这种老派学院式的方式抛弃。以为它的调试实在是太麻烦了，而且没有什么实际的用处。&lt;/p&gt;
&lt;p&gt;然后剩下的就是&lt;code&gt;Topshelf&lt;/code&gt;和.NET Core工作器两种方式了。在我看来，.NET Core工作器，已经很好的融入.NET Core生态系统，如果你正在开发ASP.NET Core应用，那么使用.NET Core工作器就很有意义。最重要的是，当你创建一个后台服务的时候，你可以让它在一个ASP.NET Core网站中的任意位置运行，这非常的方便。但是缺点是安装。你必须使用&lt;code&gt;SC&lt;/code&gt;命令来安装服务。这一部分&lt;code&gt;Topshelf&lt;/code&gt;可能更胜一筹。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Topshelf&lt;/code&gt;总体上将非常的友好，并且具有最好的安装方式，但是使用额外的库，也增加了学习的成本。&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;Topshelf&lt;/code&gt;和.NET Core工作器，大家可以自行选择，都是不错的方案。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 00:36:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文： 'Creating Windows Services In .NET Core – Part 3 – The “.NET Core Worker” Way' 作者：Dotnet Core Tu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/12038062.html</dc:identifier>
</item>
<item>
<title>上手spring boot项目(二)之spring boot整合shiro安全框架 - 程序猿修炼之道</title>
<link>http://www.cnblogs.com/Code-Handling/p/12038054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Code-Handling/p/12038054.html</guid>
<description>&lt;p&gt;&lt;strong&gt;题记&lt;/strong&gt;：在学习了springboot和thymeleaf之后，想完成一个项目练练手，于是使用springboot+mybatis和thymeleaf完成一个博客系统，在完成的过程中出现的一些问题，将这些问题记录下来，作为自己的学习心得。在这先感谢群主TyCoding的Tumo项目，虽然本人实在太菜了，好些地方看不懂，但还是使我受益匪浅。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;shiro作为一个小巧灵活的安全框架，在认证和授权方面简约但又不简单，十分容易上手使用。下面是整合shiro的具体流程。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 &amp;lt;!--shiro和spring整合--&amp;gt;
 2 &amp;lt;dependency&amp;gt;
 3       &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt;
 4       &amp;lt;artifactId&amp;gt;shiro-spring&amp;lt;/artifactId&amp;gt;
 5       &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
 6 &amp;lt;/dependency&amp;gt;
 7 &amp;lt;!--shiro核心包--&amp;gt;
 8 &amp;lt;dependency&amp;gt;
 9       &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt;
10        &amp;lt;artifactId&amp;gt;shiro-core&amp;lt;/artifactId&amp;gt;
11        &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
12 &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于本人实在粗心，用try,catch将这个错误包起来了，所以找了一个下午的bug才发现。如果是用ssm整合shiro也大致一样，只不过需要在web.xml中添加一些配置信息。&lt;/p&gt;
&lt;p&gt;具体流程大同小异。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@SpringBootApplication(scanBasePackages = &quot;cn.zhq&quot;&lt;span&gt;)
@EntityScan(&quot;cn.zhq.system.entity&quot;&lt;span&gt;)
public class&lt;span&gt; MyBlogApplication {
    public static void&lt;span&gt; main(String[] args) {
        SpringApplication.run(MyBlogApplication.class&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;个人觉得realm就相当于一个数据源 ，shiro从realm中去获取一些数据，验证用户的认证和授权。&lt;/p&gt;
&lt;h2&gt;3.1 usermapper接口&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Mapper
public interface&lt;span&gt; UserMapper {

    /**
     * 根据Name查询用户数据
     */&lt;span&gt;
    SysUser findByName(String username);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2 配置文件usermapper.xml&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;
&amp;lt;mapper namespace=&quot;cn.zhq.system.mapper.UserMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;findByName&quot; resultType=&quot;sysuser&quot; parameterType=&quot;String&quot;&amp;gt;&lt;span&gt;
      select * from tb_user where username =&lt;span&gt; #{username}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.3 编写自定义realm并继承AuthorizingRealm&lt;/h2&gt;
&lt;p&gt;这里只贴出认证的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Autowired
    private&lt;span&gt; UserMapper userMapper;

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws&lt;span&gt; AuthenticationException {
        //1.获取登录的用户名密码（token）
        UsernamePasswordToken upToken =&lt;span&gt; (UsernamePasswordToken) authenticationToken;
        String username =&lt;span&gt; upToken.getUsername();
        String password = new&lt;span&gt; String( upToken.getPassword());
        //2.根据用户名查询数据库
        SysUser user =&lt;span&gt; userMapper.findByName(username);
        //3.判断用户是否存在或者密码是否一致
        if(user != null &amp;amp;&amp;amp;&lt;span&gt; user.getPassword().equals(password)) {
            //4.如果一致返回安全数据
            //构造方法：安全数据，密码，realm域名
            SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user,user.getPassword(),this&lt;span&gt;.getName());
            return&lt;span&gt; info;
        }
        //5.不一致，返回null（抛出异常）
        return null&lt;span&gt;;
    }    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4.1 安全管理器&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    //配置自定义的Realm
&lt;span&gt;    @Bean
    public&lt;span&gt; AuthRealm getRealm() {
        return new&lt;span&gt; AuthRealm();
    }

    //配置安全管理器
&lt;span&gt;    @Bean
    public&lt;span&gt; SecurityManager securityManager(AuthRealm realm) {
        //使用默认的安全管理器
        DefaultWebSecurityManager securityManager = new&lt;span&gt; DefaultWebSecurityManager(realm);
        //将自定义的realm交给安全管理器统一调度管理
&lt;span&gt;        securityManager.setRealm(realm);
        return&lt;span&gt; securityManager;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.2 配置过滤器工厂&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
    public&lt;span&gt; ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        //1.创建过滤器工厂
        ShiroFilterFactoryBean filterFactory = new&lt;span&gt; ShiroFilterFactoryBean();
        //2.设置安全管理器
&lt;span&gt;        filterFactory.setSecurityManager(securityManager);
        //3.通用配置（跳转登录页面，为授权跳转的页面）
        filterFactory.setLoginUrl(&quot;#&quot;);//跳转url地址
        filterFactory.setUnauthorizedUrl(&quot;#&quot;);//未授权的url
        return&lt;span&gt; filterFactory;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value=&quot;/login&quot;&lt;span&gt;)
    @ResponseBody
    public&lt;span&gt; String login(String username,String password) {
        try&lt;span&gt;{
            Subject subject =&lt;span&gt; SecurityUtils.getSubject();
            UsernamePasswordToken uptoken = new&lt;span&gt; UsernamePasswordToken(username,password);
            subject.login(uptoken);
            return &quot;登录成功&quot;&lt;span&gt;;
        }catch&lt;span&gt; (Exception e) {
            return &quot;用户名或密码错误&quot;&lt;span&gt;;
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;6.1 获取md5加密的密码&lt;/h2&gt;
&lt;p&gt;由于密码是使用shiro提供的Md5加密方式。为了避免麻烦就直接打印加密之后的密码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Md5Hash的参数代表的含义分别是 加密的内容 | 盐(加密的混淆字符串) | 加密次数
&lt;/pre&gt;
&lt;pre&gt;
System.out.println(new Md5Hash(&quot;123456&quot;,&quot;zhangbo&quot;,3).toString());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1747551/201911/1747551-20191124100817534-1001283906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1747551/201911/1747551-20191124101614104-1397911957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看到使用加密过的密码是可以登陆成功的，但使用原始密码是无法登陆成功的，&lt;/strong&gt;可以在具体的业务逻辑层中添加用户时将密码进行加密处理。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 00:20:00 +0000</pubDate>
<dc:creator>程序猿修炼之道</dc:creator>
<og:description>题记：在学习了springboot和thymeleaf之后，想完成一个项目练练手，于是使用springboot+mybatis和thymeleaf完成一个博客系统，在完成的过程中出现的一些问题，将这些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Code-Handling/p/12038054.html</dc:identifier>
</item>
<item>
<title>Java中的等待唤醒机制—至少50%的工程师还没掌握！ - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/12038007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/12038007.html</guid>
<description>&lt;p&gt;这是一篇走心的填坑笔记，自学Java的几年总是在不断学习新的技术，一路走来发现自己踩坑无数，而填上的坑却屈指可数。突然发现，有时候真的不是几年工作经验的问题，有些东西即使工作十年，没有用心去学习过也不过是一个10年大坑罢了（真实感受）。&lt;/p&gt;
&lt;p&gt;刚开始接触多线程时，就知道有等待/唤醒这个东西，写过一个demo就再也没有看过了，至于它到底是个什么东西，或者说它能解决什么样的问题，估计大多数人和我一样都是模棱两可。这次笔者就尝试带你搞懂等待/唤醒机制，读完本文你将get到以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;循环等待带来什么样的问题&lt;/li&gt;
&lt;li&gt;用等待唤醒机制优化循环等待&lt;/li&gt;
&lt;li&gt;等待唤醒机制中的被忽略的细节&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;一循环等待问题&quot;&gt;一,循环等待问题&lt;/h2&gt;
&lt;p&gt;假设今天要发工资，强老板要去吃一顿好的，整个就餐流程可以分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;点餐&lt;/li&gt;
&lt;li&gt;窗口等待出餐&lt;/li&gt;
&lt;li&gt;就餐&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public static void main(String[] args) {
     // 是否还有包子
        AtomicBoolean hasBun = new AtomicBoolean();
        
        // 包子铺老板
        new Thread(() -&amp;gt; {
            try {
                // 一直循环查看是否还有包子
                while (true) {
                    if (hasBun.get()) {
                        System.out.println(&quot;老板：检查一下是否还剩下包子...&quot;);
                        Thread.sleep(3000);
                    } else {
                        System.out.println(&quot;老板：没有包子了, 马上开始制作...&quot;);
                        Thread.sleep(1000);
                        System.out.println(&quot;老板：包子出锅咯....&quot;);
                        hasBun.set(true);
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();


        new Thread(() -&amp;gt; {
            System.out.println(&quot;小强：我要买包子...&quot;);
            try {
                // 每隔一段时间询问是否完成
                while (!hasBun.get()) {
                    System.out.println(&quot;小强：包子咋还没做好呢~&quot;);
                    Thread.sleep(3000);
                }
                System.out.println(&quot;小强：终于吃上包子了....&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912140042_561.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上文代码中存在一个很大的问题，就是老板需要不断的去检查是否还有包子，而客户则需要隔一段时间去看催一下老板，这显然时不合理的，这就是典型的循环等待问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912132338_507.jpg?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种问题的代码中通常是如下这种模式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   while (条件不满足) {
       Thread.sleep(3000);
   }
   doSomething();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应到计算机中，则暴露了一个问题：&lt;strong&gt;不断通过轮询机制来检测条件是否成立， 如果轮询时间过小则会浪费CPU资源，如果间隔过大，又导致不能及时获取想要的资源&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二等待唤醒机制&quot;&gt;二，等待/唤醒机制&lt;/h2&gt;
&lt;p&gt;为了&lt;strong&gt;解决循环等待消耗CPU以及信息及时性问题&lt;/strong&gt;，Java中提供了等待唤醒机制。通俗来讲就是&lt;strong&gt;由主动变为被动&lt;/strong&gt;， 当条件成立时，主动通知对应的线程，而不是让线程本身来询问。&lt;/p&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;2.1 基本概念&lt;/h3&gt;
&lt;p&gt;等待/唤醒机制，又叫等待通知（笔者更喜欢叫唤醒而非通知），是指线程A调用了对象O的wait()方法进入了等待状态，而另一个线程调用了O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。&lt;/p&gt;
&lt;p&gt;上诉过程是通过对象O，使得线程A和线程B之间进行通信, 在线程中调用了对象O的wait()方法后线程久进入了阻塞状态，而在其他线程中对象O调用notify()或notifyAll方法时，则会唤醒对应的阻塞线程。&lt;/p&gt;
&lt;h3 id=&quot;基本api&quot;&gt;2.2 基本API&lt;/h3&gt;
&lt;p&gt;等待/唤醒机制的相关方法时任意Java对象具备的，因为这些方法被定义在所有Java对象的超类Object中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notify&lt;/strong&gt;： 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提时该线程获取到对象的锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notifyAll&lt;/strong&gt;: 通知所有等待在该对象上的线程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wait&lt;/strong&gt;: 调用此方法的线程进入阻塞等待状态，只有等待另外线程的&lt;strong&gt;通知或者被中断&lt;/strong&gt;才会返回，调用&lt;strong&gt;wait方法会释放对象的锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wait(long)&lt;/strong&gt; : 等待超过一段时间没有被唤醒就超时自动返回，单位时毫秒。&lt;/p&gt;
&lt;h3 id=&quot;用等待唤醒机制优化循环等待&quot;&gt;2.3 用等待唤醒机制优化循环等待&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
   // 是否还有包子
        AtomicBoolean hasBun = new AtomicBoolean();
        // 锁对象
        Object lockObject = new Object();

        // 包子铺老板
        new Thread(() -&amp;gt; {
            try {
                while (true) {
                    synchronized (lockObject) {
                        if (hasBun.get()) {
                            System.out.println(&quot;老板：包子够卖了，打一把王者荣耀&quot;);
                            lockObject.wait(); 
                        } else {
                            System.out.println(&quot;老板：没有包子了, 马上开始制作...&quot;);
                            Thread.sleep(3000);
                            System.out.println(&quot;老板：包子出锅咯....&quot;);
                            hasBun.set(true);
                            // 通知等待的食客
                            lockObject.notifyAll();
                        }
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();


        new Thread(() -&amp;gt; {
            System.out.println(&quot;小强：我要买包子...&quot;);
            try {
                synchronized (lockObject) {
                    if (!hasBun.get()) {
                        System.out.println(&quot;小强：看一下有没有做好， 看公众号cruder有没有新文章&quot;);
                        lockObject.wait(); 
                    } else {
                        System.out.println(&quot;小强：包子终于做好了，我要吃光它们....&quot;);
                        hasBun.set(false);
                        lockObject.notifyAll();
                        System.out.println(&quot;小强：一口气把店里包子吃光了， 快快乐乐去板砖了~~&quot;);
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912132357_184.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述流程，减少了轮询检查的操作，并且线程调用wait()方法后，会释放锁，不会消耗CPU资源，进而提高了程序的性能。&lt;/p&gt;
&lt;h2 id=&quot;三等待唤醒机制的基本范式&quot;&gt;三，等待唤醒机制的基本范式&lt;/h2&gt;
&lt;p&gt;等待、唤醒是线程间通信的手段之一，用来协调多个线程操作同一个数据源。实际应用中通常用来优化循环等待的问题，针对等待方和通知方，可以提炼出如下的经典范式。&lt;/p&gt;
&lt;p&gt;需要注意的是，在等待方执行的逻辑中，一定要用while循环来判断等待条件，因为执行&lt;strong&gt;notify/notifyAll方法时只是让等待线程从wait方法返回，而非重新进入临界区&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 等待方执行的逻辑
 * 1. 获取对象的锁
 * 2. 检查条件，如果条件不满足，调用对象的wait方法，被通知后重新检查条件
 * 3. 条件满足则执行对应的逻辑
 */
synchronized(对象){
    while(条件不满足){
        对象.wait()
    }
    doSomething();
}
/**
 * ！！ 通知方执行的逻辑
 * 1. 获取对象的锁
 * 2. 改变条件
 * 3. 通知(所有)等待在对象上的线程
 */
synchronized(对象){
    条件改变
    对象.notify();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个编程范式通常是针对典型的通知方和等待方，有时双方可能具有双重身份，即使等待方又是通知方，正如我们上文中的案例一样。&lt;/p&gt;
&lt;h2 id=&quot;四notifynotifyall不释放锁&quot;&gt;四，notify/notifyAll不释放锁&lt;/h2&gt;
&lt;p&gt;相信这个问题有半数工程师都不知道，&lt;strong&gt;当执行wait()方法，锁自动被释放；但执行完notify()方法后，锁不会释放，而是要执行notify()方法所在的synchronized代码块后才会释放。&lt;/strong&gt;这一点很重要，也是很多工程师容易忽略的地方。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;lockObject.notifyAll();
System.out.println(&quot;小强：一口气把店里包子吃光了， 快快乐乐去板砖了~~&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;案例代码中，故意设置成先notifyAll，然后在打印；上文图中的结果也印证了了我们的描述，感兴趣的小伙伴可以动手执行一下案例代码哦。&lt;/p&gt;
&lt;h2 id=&quot;五等待唤醒必须先获取锁&quot;&gt;五，等待、唤醒必须先获取锁&lt;/h2&gt;
&lt;p&gt;在等待、唤醒编程范式中的&lt;strong&gt;wait，notify，notifyAll方法往往不能直接调用， 需要在获取锁之后的临界区执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;并且只能唤醒等待在同一把锁上的线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当线程调用wait方法时会被加入到一个等待队列，当执行notify时会唤醒队列中第一个等待线程(等待时间最长的线程)，而调用notifyAll时则会唤醒等待线程中所有的等待线程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912140038_610.jpg?ERROR&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六sleep不释放锁-而wait-释放&quot;&gt;六，sleep不释放锁 而wait 释放&lt;/h2&gt;
&lt;p&gt;在用等待唤醒机制优化循环等待的过程中，有一个重要的特征就是原本的sleep()方法用wait()方法取代，他们的最大的区别在于&lt;strong&gt;wait方法会释放锁，而sleep不会&lt;/strong&gt;，除此之外，还有个重要的区别，&lt;strong&gt;sleep是Thread的方法，可以在任意地方执行；而wait是Object对象的方法，必须在synchronized代码块中执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912140139_583.png?ERROR&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Dec 2019 17:53:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>这是一篇走心的填坑笔记，自学Java的几年总是在不断学习新的技术，一路走来发现自己踩坑无数，而填上的坑却屈指可数。突然发现，有时候真的不是几年工作经验的问题，有些东西即使工作十年，没有用心去学习过也不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/12038007.html</dc:identifier>
</item>
<item>
<title>Spring源码学习笔记之基于ClassPathXmlApplicationContext进行bean标签解析 - 城序猿</title>
<link>http://www.cnblogs.com/cheng21553516/p/12032881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cheng21553516/p/12032881.html</guid>
<description>&lt;p&gt; bean 标签在spring的配置文件中, 是非常重要的一个标签, 即便现在boot项目比较流行, 但是还是有必要理解bean标签的解析流程,有助于我们进行&lt;/p&gt;
&lt;p&gt; 基于注解配置, 也知道各个标签的作用,以及是怎样被spring识别的, 以及配置的时候需要注意的点.&lt;/p&gt;
&lt;p&gt;传统的spring项目,spring内部启动的方式是基于ClassPathXmlApplicationContext启动的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;87.5&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1() {&lt;br/&gt;&lt;span&gt;//传入spring的配置文件路径&lt;/span&gt;
        ApplicationContext classPathXmlApplicationContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;spring.xml&quot;&lt;span&gt;);
        
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span readability=&quot;3&quot;&gt;);
    }&lt;p&gt;&lt;span&gt;// 调用有参构造,设置spring配置文件的位置&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
  public ClassPathXmlApplicationContext(String configLocation) throws BeansException {&lt;br/&gt;this(new String[] {configLocation}, true, null);&lt;br/&gt;}&lt;p&gt;&lt;span&gt;//进一步跟进&lt;/span&gt;&lt;br/&gt;public ClassPathXmlApplicationContext(
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;em readability=&quot;6&quot;&gt;      String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)&lt;br/&gt;throws BeansException {&lt;br/&gt;&lt;span&gt;// 此处parent 为null&lt;/span&gt; &lt;br/&gt;super(parent);&lt;p&gt;&lt;span&gt;//创建解析器，解析configLocations&lt;/span&gt;&lt;br/&gt;setConfigLocations(configLocations);&lt;br/&gt;// refresh = true &lt;br/&gt;if (refresh) {&lt;br/&gt;&lt;span&gt;//刷新spring容器,bean标签的核心方法&lt;/span&gt;&lt;br/&gt;refresh();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//进一步跟进refresh 方法&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;54&quot;&gt;
public Collection&amp;lt;ApplicationListener&amp;lt;?&amp;gt;&amp;gt; getApplicationListeners() {&lt;br/&gt;return this.applicationListeners;&lt;br/&gt;}&lt;p&gt;&lt;span&gt;/*&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * 该方法是spring容器初始化的核心方法。是spring容器初始化的核心流程，是一个典型的父类模板设计模式的运用&lt;/span&gt;&lt;br/&gt;&lt;span&gt; *    根据不同的上下文对象，会掉到不同的上下文对象子类方法中&lt;/span&gt;&lt;br/&gt;&lt;span&gt; *&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * 核心上下文子类有：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * ClassPathXmlApplicationContext&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * FileSystemXmlApplicationContext&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * AnnotationConfigApplicationContext&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * EmbeddedWebApplicationContext(springboot)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; *&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * 方法重要程度：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; *  0：不重要，可以不看&lt;/span&gt;&lt;br/&gt;&lt;span&gt; *  1：一般重要，可看可不看&lt;/span&gt;&lt;br/&gt;&lt;span&gt; *  5：非常重要，一定要看&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * */&lt;/span&gt;&lt;br/&gt;@Override&lt;br/&gt;public void refresh() throws BeansException, IllegalStateException {&lt;br/&gt;synchronized (this.startupShutdownMonitor) {&lt;br/&gt;&lt;span&gt; //为容器初始化做准备，重要程度：0&lt;/span&gt;&lt;br/&gt;// Prepare this context for refreshing.&lt;br/&gt;prepareRefresh();&lt;/p&gt;&lt;p&gt;&lt;span&gt; /*&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         重要程度：5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        1、创建BeanFactory对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      * 2、xml解析&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      *  传统标签解析：bean、import等&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      *  自定义标签解析 如：&amp;lt;context:component-scan base-package=&quot;com.xiangxue.jack&quot;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      *  自定义标签解析流程：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      *     a、根据当前解析标签的头信息找到对应的namespaceUri&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      *     b、加载spring所以jar中的spring.handlers文件。并建立映射关系&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      *     c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      *     d、调用类的init方法，init方法是注册了各种自定义标签的解析类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      *     e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      *&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      * 3、把解析出来的xml标签封装成BeanDefinition对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      * */&lt;/span&gt;&lt;br/&gt;// Tell the subclass to refresh the internal bean factory.&lt;br/&gt;&lt;span&gt;//&lt;strong&gt;此处创建bean 工厂, 解析bean 标签以及处理 component-scan 标签的核心方法&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();&lt;/p&gt;&lt;p&gt;// Prepare the bean factory for use in this context.&lt;br/&gt;prepareBeanFactory(beanFactory);&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;// Allows post-processing of the bean factory in context subclasses.&lt;br/&gt;postProcessBeanFactory(beanFactory);&lt;/p&gt;&lt;p&gt;// Invoke factory processors registered as beans in the context.&lt;br/&gt;invokeBeanFactoryPostProcessors(beanFactory);&lt;/p&gt;&lt;p&gt;// Register bean processors that intercept bean creation.&lt;br/&gt;registerBeanPostProcessors(beanFactory);&lt;/p&gt;&lt;p&gt;// Initialize message source for this context.&lt;br/&gt;initMessageSource();&lt;/p&gt;&lt;p&gt;// Initialize event multicaster for this context.&lt;br/&gt;initApplicationEventMulticaster();&lt;/p&gt;&lt;p&gt;// Initialize other special beans in specific context subclasses.&lt;br/&gt;onRefresh();&lt;/p&gt;&lt;p&gt;// Check for listener beans and register them.&lt;br/&gt;registerListeners();&lt;/p&gt;&lt;p&gt;// Instantiate all remaining (non-lazy-init) singletons.&lt;br/&gt;finishBeanFactoryInitialization(beanFactory);&lt;/p&gt;&lt;p&gt;// Last step: publish corresponding event.&lt;br/&gt;finishRefresh();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;catch (BeansException ex) {&lt;br/&gt;if (logger.isWarnEnabled()) {&lt;br/&gt;logger.warn(&quot;Exception encountered during context initialization - &quot; +&lt;br/&gt;&quot;cancelling refresh attempt: &quot; + ex);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// Destroy already created singletons to avoid dangling resources.&lt;br/&gt;destroyBeans();&lt;/p&gt;&lt;p&gt;// Reset 'active' flag.&lt;br/&gt;cancelRefresh(ex);&lt;/p&gt;&lt;p&gt;// Propagate exception to caller.&lt;br/&gt;throw ex;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;finally {&lt;br/&gt;// Reset common introspection caches in Spring's core, since we&lt;br/&gt;// might not ever need metadata for singleton beans anymore...&lt;br/&gt;resetCommonCaches();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//进一步跟进创建bean工厂的方法obtainFreshBeanFactory,研究bean 标签的解析逻辑&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;&lt;span&gt;   //核心方法，必须读，重要程度：5&lt;/span&gt;&lt;br/&gt;refreshBeanFactory();&lt;br/&gt;return getBeanFactory();&lt;br/&gt;}&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;em&gt;//再一步跟进&lt;/em&gt;&lt;em&gt;refreshBeanFactory 方法&lt;br/&gt;跟到这里,我们发现分叉了, 有 多个实现类, 那么是跟哪一个呢?&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191213004927948-512577398.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;这个是使我们看一下类的继承关系图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191213005050079-1929358821.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;
&lt;/pre&gt;

&lt;p&gt; 很明显这个时候我们再次跟进的时候需要看的跟的就是org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory ,我们再次跟踪&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50.5&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; refreshBeanFactory() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;span&gt;如果BeanFactory不为空，则清除BeanFactory和里面的实例&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;        &lt;span&gt;// 由于我们的容器刚启动,所以这里自然也是false&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasBeanFactory()) {
            destroyBeans();
            closeBeanFactory();
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建DefaultListableBeanFactory&lt;/span&gt;
            DefaultListableBeanFactory beanFactory =&lt;span&gt; createBeanFactory();&lt;br/&gt;beanFactory.setSerializationId(getId());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置是否可以循环依赖 allowCircularReferences
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否允许使用相同名称重新注册不同的bean实现.&lt;/span&gt;
&lt;span&gt;            customizeBeanFactory(beanFactory);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析xml，并把xml中的标签封装成BeanDefinition对象&lt;/span&gt;
&lt;span&gt;            loadBeanDefinitions(beanFactory);
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactoryMonitor) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.beanFactory =&lt;span&gt; beanFactory;
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; +&lt;span readability=&quot;2&quot;&gt; getDisplayName(), ex);
        }
    }&lt;p&gt;&lt;span&gt;// 进一步跟进spring容器加载beandefinition对象的过程&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;16&quot;&gt;
@Override&lt;br/&gt;protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {&lt;br/&gt;// Create a new XmlBeanDefinitionReader for the given BeanFactory.&lt;br/&gt;&lt;span&gt;//创建xml的解析器，这里是一个委托模式&lt;/span&gt;&lt;br/&gt;XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);&lt;p&gt;// Configure the bean definition reader with this context's&lt;br/&gt;// resource loading environment.&lt;br/&gt;beanDefinitionReader.setEnvironment(this.getEnvironment());&lt;/p&gt;&lt;p&gt;&lt;span&gt;//这里传一个this进去，因为ApplicationContext是实现了ResourceLoader接口的&lt;/span&gt;&lt;br/&gt;beanDefinitionReader.setResourceLoader(this);&lt;br/&gt;beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));&lt;/p&gt;&lt;p&gt;// Allow a subclass to provide custom initialization of the reader,&lt;br/&gt;// then proceed with actually loading the bean definitions.&lt;br/&gt;initBeanDefinitionReader(beanDefinitionReader);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//主要看这个方法  重要程度 5&lt;/span&gt;&lt;br/&gt;loadBeanDefinitions(beanDefinitionReader);&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;设置资源加载器设置了this 对象象,这是因为当前对象是.AbstractRefreshableApplicationContext,继承自DefaultResourceLoader,&lt;/p&gt;
&lt;p&gt;而DefaultResourceLoader 实现了Resourloader 接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191213010121983-1105706288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;接着上面的源码,进一步跟进核心方法loadBeanDefinitions :&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; //这里需要我们回忆一下我们最初的构造器,参数是设置到 configLocation 里面去了,所以这里设置核心关注点在从configLocations 中解析xml文件,解析bean标签&lt;/span&gt;&lt;br/&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; loadBeanDefinitions(XmlBeanDefinitionReader reader) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException, IOException {
        Resource[] configResources &lt;/span&gt;=&lt;span&gt; getConfigResources();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (configResources != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            reader.loadBeanDefinitions(configResources);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取需要加载的xml配置文件&lt;/span&gt;
        String[] configLocations =&lt;span&gt; getConfigLocations();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (configLocations != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            reader.loadBeanDefinitions(configLocations);
        }
    }&lt;p&gt;&lt;span&gt;//进一步跟进&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;loadBeanDefinitions(String args) 这个方法&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
@Override&lt;br/&gt;public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;&lt;em&gt;   Assert.notNull(locations, &quot;Location array must not be null&quot;);&lt;br/&gt;int count = 0;&lt;br/&gt;&lt;span&gt;//配置文件有多个，加载多个配置文件&lt;/span&gt;&lt;br/&gt;for (String location : locations) {&lt;br/&gt;&lt;span&gt;//这里的数量是beandefination的数量&lt;/span&gt;&lt;br/&gt;count += loadBeanDefinitions(location);&lt;br/&gt;}&lt;br/&gt;return count;&lt;br/&gt;}&lt;p&gt;&lt;span&gt;//再进一步跟进&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
@Override&lt;br/&gt;public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {&lt;br/&gt;return loadBeanDefinitions(location, null);&lt;br/&gt;}&lt;p&gt;&lt;span&gt;//在进一步跟进&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;18&quot;&gt;
public int loadBeanDefinitions(String location, @Nullable Set&amp;lt;Resource&amp;gt; actualResources) throws BeanDefinitionStoreException {&lt;br/&gt;ResourceLoader resourceLoader = getResourceLoader();&lt;br/&gt;if (resourceLoader == null) {&lt;br/&gt;throw new BeanDefinitionStoreException(&lt;br/&gt;&quot;Cannot load bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);&lt;br/&gt;}&lt;p&gt;if (resourceLoader instanceof ResourcePatternResolver) {&lt;br/&gt;// Resource pattern matching available.&lt;br/&gt;try {&lt;br/&gt;&lt;span&gt;//把字符串类型的xml文件路径，形如：classpath*:user/**/*-context.xml,转换成Resource对象类型，其实就是用流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         //的方式加载配置文件，然后封装成Resource对象，不重要，可以不看&lt;/span&gt;&lt;br/&gt;Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);&lt;/p&gt;&lt;p&gt;&lt;span&gt; //主要看这个方法 ** 重要程度 5&lt;/span&gt;&lt;br/&gt;int count = loadBeanDefinitions(resources);&lt;br/&gt;if (actualResources != null) {&lt;br/&gt;Collections.addAll(actualResources, resources);&lt;br/&gt;}&lt;br/&gt;if (logger.isTraceEnabled()) {&lt;br/&gt;logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);&lt;br/&gt;}&lt;br/&gt;return count;&lt;br/&gt;}&lt;br/&gt;catch (IOException ex) {&lt;br/&gt;throw new BeanDefinitionStoreException(&lt;br/&gt;&quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;else {&lt;br/&gt;// Can only load single resources by absolute URL.&lt;br/&gt;Resource resource = resourceLoader.getResource(location);&lt;br/&gt;int count = loadBeanDefinitions(resource);&lt;br/&gt;if (actualResources != null) {&lt;br/&gt;actualResources.add(resource);&lt;br/&gt;}&lt;br/&gt;if (logger.isTraceEnabled()) {&lt;br/&gt;logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);&lt;br/&gt;}&lt;br/&gt;return count;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 再进一步跟踪loadBeanDefinitions 方法&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;18&quot;&gt;
public int loadBeanDefinitions(String location, @Nullable Set&amp;lt;Resource&amp;gt; actualResources) throws BeanDefinitionStoreException {&lt;br/&gt;ResourceLoader resourceLoader = getResourceLoader();&lt;br/&gt;if (resourceLoader == null) {&lt;br/&gt;throw new BeanDefinitionStoreException(&lt;br/&gt;&quot;Cannot load bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);&lt;br/&gt;}&lt;p&gt;if (resourceLoader instanceof ResourcePatternResolver) {&lt;br/&gt;// Resource pattern matching available.&lt;br/&gt;try {&lt;br/&gt;&lt;span&gt; //把字符串类型的xml文件路径，形如：classpath*:user/**/*-context.xml,转换成Resource对象类型，其实就是用流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         //的方式加载配置文件，然后封装成Resource对象，不重要，可以不看&lt;/span&gt;&lt;br/&gt;Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//主要看这个方法 ** 重要程度 5&lt;/span&gt;&lt;br/&gt;int count = loadBeanDefinitions(resources);&lt;br/&gt;if (actualResources != null) {&lt;br/&gt;Collections.addAll(actualResources, resources);&lt;br/&gt;}&lt;br/&gt;if (logger.isTraceEnabled()) {&lt;br/&gt;logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);&lt;br/&gt;}&lt;br/&gt;return count;&lt;br/&gt;}&lt;br/&gt;catch (IOException ex) {&lt;br/&gt;throw new BeanDefinitionStoreException(&lt;br/&gt;&quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;else {&lt;br/&gt;// Can only load single resources by absolute URL.&lt;br/&gt;Resource resource = resourceLoader.getResource(location);&lt;br/&gt;int count = loadBeanDefinitions(resource);&lt;br/&gt;if (actualResources != null) {&lt;br/&gt;actualResources.add(resource);&lt;br/&gt;}&lt;br/&gt;if (logger.isTraceEnabled()) {&lt;br/&gt;logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);&lt;br/&gt;}&lt;br/&gt;return count;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 进一步跟踪loadBeanDefinitions(resources) 方法&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于代码很深, 跟着跟着很有可能就跟丢了,这个时候debug 一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191213014138560-1246861393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;那么我们继续&lt;/p&gt;
&lt;pre&gt;
// 进一步跟踪&lt;em&gt;loadBeanDefinitions(resources) 方法&lt;br/&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;130&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; loadBeanDefinitions(Resource... resources) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
        Assert.notNull(resources, &lt;/span&gt;&quot;Resource array must not be null&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Resource resource : resources) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模板设计模式，调用到子类中的方法&lt;/span&gt;
            count +=&lt;span&gt; loadBeanDefinitions(resource);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;// 再 进一步跟踪&lt;/span&gt;&lt;br/&gt;@Override&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
&lt;/pre&gt;
&lt;pre readability=&quot;16&quot;&gt;
&lt;span&gt;   //EncodedResource带编码的对Resource对象的封装&lt;/span&gt;&lt;br/&gt;return loadBeanDefinitions(new EncodedResource(resource));&lt;br/&gt;}&lt;p&gt;public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {&lt;br/&gt;Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);&lt;br/&gt;if (logger.isTraceEnabled()) {&lt;br/&gt;logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;Set&amp;lt;EncodedResource&amp;gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();&lt;br/&gt;if (currentResources == null) {&lt;br/&gt;currentResources = new HashSet&amp;lt;&amp;gt;(4);&lt;br/&gt;this.resourcesCurrentlyBeingLoaded.set(currentResources);&lt;br/&gt;}&lt;br/&gt;if (!currentResources.add(encodedResource)) {&lt;br/&gt;throw new BeanDefinitionStoreException(&lt;br/&gt;&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);&lt;br/&gt;}&lt;br/&gt;try {&lt;br/&gt;&lt;span&gt;//获取Resource对象中的xml文件流对象&lt;/span&gt;&lt;br/&gt;InputStream inputStream = encodedResource.getResource().getInputStream();&lt;br/&gt;try {&lt;br/&gt;&lt;span&gt; //InputSource是jdk中的sax xml文件解析对象&lt;/span&gt;&lt;br/&gt;InputSource inputSource = new InputSource(inputStream);&lt;br/&gt;if (encodedResource.getEncoding() != null) {&lt;br/&gt;inputSource.setEncoding(encodedResource.getEncoding());&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//主要看这个方法 **  重要程度 5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         // 这里才是真正开始解析,封装beanDifination对象&lt;/span&gt;&lt;br/&gt;return doLoadBeanDefinitions(inputSource, encodedResource.getResource());&lt;br/&gt;}&lt;br/&gt;finally {&lt;br/&gt;inputStream.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;catch (IOException ex) {&lt;br/&gt;throw new BeanDefinitionStoreException(&lt;br/&gt;&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);&lt;br/&gt;}&lt;br/&gt;finally {&lt;br/&gt;currentResources.remove(encodedResource);&lt;br/&gt;if (currentResources.isEmpty()) {&lt;br/&gt;this.resourcesCurrentlyBeingLoaded.remove();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;&lt;span&gt;//进一步跟踪如下&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 加载xml,解析document,将其中的元素封装为beandefinition 并注册&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
&lt;/pre&gt;
&lt;pre readability=&quot;15.5&quot;&gt;
&lt;em readability=&quot;25&quot;&gt;      throws BeanDefinitionStoreException {&lt;p&gt;try {&lt;br/&gt;&lt;span&gt;//把inputSource 封装成Document文件对象，这是jdk的API&lt;/span&gt;&lt;br/&gt;Document doc = doLoadDocument(inputSource, resource);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//主要看这个方法，根据解析出来的document对象，拿到里面的标签元素封装成BeanDefinition&lt;/span&gt;&lt;br/&gt;int count = registerBeanDefinitions(doc, resource);&lt;br/&gt;if (logger.isDebugEnabled()) {&lt;br/&gt;logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource);&lt;br/&gt;}&lt;br/&gt;return count;&lt;br/&gt;}&lt;br/&gt;catch (BeanDefinitionStoreException ex) {&lt;br/&gt;throw ex;&lt;br/&gt;}&lt;br/&gt;catch (SAXParseException ex) {&lt;br/&gt;throw new XmlBeanDefinitionStoreException(resource.getDescription(),&lt;br/&gt;&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);&lt;br/&gt;}&lt;br/&gt;catch (SAXException ex) {&lt;br/&gt;throw new XmlBeanDefinitionStoreException(resource.getDescription(),&lt;br/&gt;&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);&lt;br/&gt;}&lt;br/&gt;catch (ParserConfigurationException ex) {&lt;br/&gt;throw new BeanDefinitionStoreException(resource.getDescription(),&lt;br/&gt;&quot;Parser configuration exception parsing XML from &quot; + resource, ex);&lt;br/&gt;}&lt;br/&gt;catch (IOException ex) {&lt;br/&gt;throw new BeanDefinitionStoreException(resource.getDescription(),&lt;br/&gt;&quot;IOException parsing XML document from &quot; + resource, ex);&lt;br/&gt;}&lt;br/&gt;catch (Throwable ex) {&lt;br/&gt;throw new BeanDefinitionStoreException(resource.getDescription(),&lt;br/&gt;&quot;Unexpected exception parsing XML document from &quot; + resource, ex);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//进一步跟踪源代码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 创建reader 读取document,并将其封装为 beandefination,以及并注册&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/em&gt;public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
&lt;/pre&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;em readability=&quot;2&quot;&gt;&lt;span&gt;   //又来一记委托模式，BeanDefinitionDocumentReader委托这个类进行document的解析&lt;/span&gt;&lt;br/&gt;BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();&lt;br/&gt;int countBefore = getRegistry().getBeanDefinitionCount();&lt;br/&gt;&lt;span&gt;//主要看这个方法，createReaderContext(resource) XmlReaderContext上下文，封装了XmlBeanDefinitionReader对象&lt;/span&gt;&lt;br/&gt;documentReader.registerBeanDefinitions(doc, createReaderContext(resource));&lt;br/&gt;return getRegistry().getBeanDefinitionCount() - countBefore;&lt;br/&gt;}&lt;p&gt;&lt;span&gt;其中部分调用方法简单做一下分析&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;6&quot;&gt;
//public XmlReaderContext createReaderContext(Resource resource) {&lt;br/&gt;//   return new XmlReaderContext(resource, this.problemReporter, this.eventListener,&lt;br/&gt;&lt;span&gt; //获取命名空间解析器,后续用来判断是否默认的名称空间, 针对不同的名称空间进行处理&lt;/span&gt;&lt;br/&gt;//         this.sourceExtractor, this, getNamespaceHandlerResolver());&lt;br/&gt;//}&lt;p&gt;&lt;span&gt;// 回到主流程进行进一步分析,以及跟踪&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
@Override&lt;br/&gt;public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {&lt;br/&gt;this.readerContext = readerContext;&lt;br/&gt;&lt;span&gt;//主要看这个方法，把root节点传进去&lt;/span&gt;&lt;br/&gt;doRegisterBeanDefinitions(doc.getDocumentElement());&lt;br/&gt;}&lt;p&gt;&lt;span&gt;// 此时传入的元素为根元素&lt;/span&gt;&lt;br/&gt;protected void doRegisterBeanDefinitions(Element root) {
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;   // Any nested &amp;lt;beans&amp;gt; elements will cause recursion in this method. In&lt;br/&gt;// order to propagate and preserve &amp;lt;beans&amp;gt; default-* attributes correctly,&lt;br/&gt;// keep track of the current (parent) delegate, which may be null. Create&lt;br/&gt;// the new (child) delegate with a reference to the parent for fallback purposes,&lt;br/&gt;// then ultimately reset this.delegate back to its original (parent) reference.&lt;br/&gt;// this behavior emulates a stack of delegates without actually necessitating one.&lt;br/&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
//创建BeanDefinitionParser 的委托类,并进行默认属性的的设置&lt;br/&gt;// 如果bean的属性没有设置,则使用默认值得默认属性  &lt;br/&gt;&lt;em&gt;  BeanDefinitionParserDelegate parent = this.delegate;&lt;br/&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;     this.delegate = createDelegate(getReaderContext(), root, parent);&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot; readability=&quot;4&quot;&gt;&lt;em readability=&quot;8&quot;&gt;&lt;br/&gt;&lt;span&gt;//判断是否默认的命名空间的依据是否是beans开始的,开始的则是默认的命名空间 否则就不是&lt;/span&gt;&lt;br/&gt;if (this.delegate.isDefaultNamespace(root)) {&lt;br/&gt;String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);&lt;br/&gt;if (StringUtils.hasText(profileSpec)) {&lt;br/&gt;String[] specifiedProfiles = StringUtils.tokenizeToStringArray(&lt;br/&gt;profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);&lt;br/&gt;// We cannot use Profiles.of(...) since profile expressions are not supported&lt;br/&gt;// in XML config. See SPR-12458 for details.&lt;br/&gt;if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {&lt;br/&gt;if (logger.isDebugEnabled()) {&lt;br/&gt;logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +&lt;br/&gt;&quot;] not matching: &quot; + getReaderContext().getResource());&lt;br/&gt;}&lt;br/&gt;return;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;p&gt;&lt;span&gt;// 前置处理&lt;/span&gt;&lt;br/&gt;preProcessXml(root);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//主要看这个方法，标签具体解析过程&lt;/span&gt;&lt;br/&gt;parseBeanDefinitions(root, this.delegate);&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 后置处理 模板设计模式 , springmvc 中的interceptor&lt;/span&gt;&lt;br/&gt;postProcessXml(root);&lt;/p&gt;&lt;p&gt;this.delegate = parent;&lt;br/&gt;}&lt;/p&gt;&lt;/em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;
&lt;/pre&gt;
&lt;p&gt; 在这里我们需要留意一下创建解析方法,其中有做默认属性的处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191214010232603-1057306664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191214010403657-189283170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191214010844681-909272847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;211&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始解析元素, 根据命名空间是否默认命名空间,解析方式不一样
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其中涉及到bean 解析的其实是两种都有设计到, bean 标签没带前缀,为默认命名空
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启注解的&amp;lt;context:component-scan= &quot;basepacakge &quot;&amp;gt; 非默认的命名空间
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们的bean 标签不属于自定义标签&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(root)) {
      NodeList nl &lt;/span&gt;=&lt;span&gt; root.getChildNodes();
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nl.getLength(); i++&lt;span&gt;) {
         Node node &lt;/span&gt;=&lt;span&gt; nl.item(i);
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Element) {
            Element ele &lt;/span&gt;=&lt;span&gt; (Element) node;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(ele)) {

               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认标签解析&lt;/span&gt;
&lt;span&gt;               parseDefaultElement(ele, delegate);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义标签解析&lt;/span&gt;
&lt;span&gt;               delegate.parseCustomElement(ele);
            }
         }
      }
   }
   &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      delegate.parseCustomElement(root);
   }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里我们先跟踪bean 基于xml的bean 标签解析
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bean 标签属于默认标签&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;import标签解析  重要程度 1 ，可看可不看&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
      importBeanDefinitionResource(ele);
   }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;alias标签解析 别名标签  重要程度 1 ，可看可不看&lt;/span&gt;
   &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
      processAliasRegistration(ele);
   }
   &lt;/span&gt;&lt;span&gt;//bean标签，重要程度  5，必须看
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是bean 标签,则进步解析为beanDefinition 对象&lt;/span&gt;
   &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
      processBeanDefinition(ele, delegate);
   }
   &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; recurse&lt;/span&gt;
&lt;span readability=&quot;2&quot;&gt;      doRegisterBeanDefinitions(ele);
   }
}&lt;p&gt;&lt;span&gt;//解析bean 标签并封装成beandefinitionHolder  对象&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;15&quot;&gt;
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {&lt;br/&gt;&lt;span&gt;//重点看这个方法，重要程度 5 ，解析document，封装成BeanDefinition&lt;/span&gt;&lt;br/&gt;BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);&lt;br/&gt;if (bdHolder != null) {&lt;p&gt;&lt;span&gt;//该方法功能不重要，设计模式重点看一下，装饰者设计模式，加上SPI设计思想&lt;/span&gt;&lt;br/&gt;bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);&lt;br/&gt;try {&lt;/p&gt;&lt;p&gt;&lt;span&gt;//完成document到BeanDefinition对象转换后，对BeanDefinition对象进行缓存注册&lt;/span&gt;&lt;br/&gt;// Register the final decorated instance.&lt;br/&gt;BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());&lt;br/&gt;}&lt;br/&gt;catch (BeanDefinitionStoreException ex) {&lt;br/&gt;getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +&lt;br/&gt;bdHolder.getBeanName() + &quot;'&quot;, ele, ex);&lt;br/&gt;}&lt;br/&gt;// Send registration event.&lt;br/&gt;getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//进一步跟踪&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
@Nullable&lt;br/&gt;public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {&lt;br/&gt;return parseBeanDefinitionElement(ele, null);&lt;br/&gt;}&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//进一步跟踪&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;37&quot;&gt;
@Nullable&lt;br/&gt;public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {&lt;br/&gt;String id = ele.getAttribute(ID_ATTRIBUTE);&lt;br/&gt;String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);&lt;p&gt;List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;if (StringUtils.hasLength(nameAttr)) {&lt;br/&gt;String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);&lt;br/&gt;aliases.addAll(Arrays.asList(nameArr));&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;String beanName = id;&lt;br/&gt;&lt;span&gt;// 当bean 为空, 并且 别名不为空的情况下, 取第一个别名作为bean的别名&lt;/span&gt;&lt;br/&gt;if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) {&lt;br/&gt;beanName = aliases.remove(0);&lt;br/&gt;if (logger.isTraceEnabled()) {&lt;br/&gt;logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName +&lt;br/&gt;&quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt; //检查beanName是否重复&lt;/span&gt;&lt;br/&gt;if (containingBean == null) {&lt;br/&gt;checkNameUniqueness(beanName, aliases, ele);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 核心方法.解析元素封装为beandefinition对象&lt;/span&gt;&lt;br/&gt;AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);&lt;br/&gt;if (beanDefinition != null) {&lt;br/&gt;if (!StringUtils.hasText(beanName)) {&lt;br/&gt;try {&lt;br/&gt;if (containingBean != null) {&lt;br/&gt;beanName = BeanDefinitionReaderUtils.generateBeanName(&lt;br/&gt;beanDefinition, this.readerContext.getRegistry(), true);&lt;br/&gt;}&lt;br/&gt;else {&lt;br/&gt;&lt;span&gt;// 如果即没有name 属性也没有id 属性,此时bean没有名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               // 这里生成beanName &lt;/span&gt;&lt;br/&gt;&lt;span&gt;              // xml 方式的beanName 为 全限定命名#数字 如果 com.test.Student#0&lt;/span&gt;&lt;br/&gt;beanName = this.readerContext.generateBeanName(beanDefinition);&lt;br/&gt;// Register an alias for the plain bean class name, if still possible,&lt;br/&gt;// if the generator returned the class name plus a suffix.&lt;br/&gt;// This is expected for Spring 1.2/2.0 backwards compatibility.&lt;br/&gt;String beanClassName = beanDefinition.getBeanClassName();&lt;br/&gt;if (beanClassName != null &amp;amp;&amp;amp;&lt;br/&gt;beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp;&lt;br/&gt;!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {&lt;br/&gt;aliases.add(beanClassName);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;if (logger.isTraceEnabled()) {&lt;br/&gt;logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; +&lt;br/&gt;&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;catch (Exception ex) {&lt;br/&gt;error(ex.getMessage(), ele);&lt;br/&gt;return null;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;String[] aliasesArray = StringUtils.toStringArray(aliases);&lt;br/&gt;return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;return null;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//进一步跟踪封装成为beanDefinition对象的全过程&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;13&quot;&gt;
public AbstractBeanDefinition parseBeanDefinitionElement(&lt;br/&gt;Element ele, String beanName, @Nullable BeanDefinition containingBean) {&lt;p&gt;this.parseState.push(new BeanEntry(beanName));&lt;/p&gt;&lt;p&gt;String className = null;&lt;br/&gt;&lt;span&gt; // 获取class 属性&lt;/span&gt;&lt;br/&gt;if (ele.hasAttribute(CLASS_ATTRIBUTE)) {&lt;br/&gt;className = ele.getAttribute(CLASS_ATTRIBUTE).trim();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 获取parent 属性&lt;/span&gt;&lt;br/&gt;String parent = null;&lt;br/&gt;if (ele.hasAttribute(PARENT_ATTRIBUTE)) {&lt;br/&gt;parent = ele.getAttribute(PARENT_ATTRIBUTE);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;&lt;span&gt; //创建GenericBeanDefinition对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      // 这里的beandefinition 对象是&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;GenericBeanDefinition&lt;/span&gt;  &lt;br/&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;     AbstractBeanDefinition bd = createBeanDefinition(className, parent);&lt;/em&gt;&lt;/em&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;em readability=&quot;17&quot;&gt;&lt;em readability=&quot;34&quot;&gt;&lt;span&gt;      //解析bean标签的属性，并把解析出来的属性设置到BeanDefinition对象中&lt;/span&gt;&lt;br/&gt;parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);&lt;br/&gt;bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));&lt;p&gt;&lt;span&gt;//解析bean中的meta标签&lt;/span&gt;&lt;br/&gt;parseMetaElements(ele, bd);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//解析bean中的lookup-method标签  重要程度：2，可看可不看&lt;/span&gt;&lt;br/&gt;parseLookupOverrideSubElements(ele, bd.getMethodOverrides());&lt;/p&gt;&lt;p&gt;&lt;span&gt;//解析bean中的replaced-method标签  重要程度：2，可看可不看&lt;/span&gt;&lt;br/&gt;parseReplacedMethodSubElements(ele, bd.getMethodOverrides());&lt;/p&gt;&lt;p&gt;&lt;span&gt;//解析bean中的constructor-arg标签  重要程度：2，可看可不看&lt;/span&gt;&lt;br/&gt;parseConstructorArgElements(ele, bd);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//解析bean中的property标签  重要程度：2，可看可不看&lt;/span&gt;&lt;br/&gt;parsePropertyElements(ele, bd);&lt;/p&gt;&lt;p&gt;&lt;span&gt;//可以不看，用不到&lt;/span&gt;&lt;br/&gt;parseQualifierElements(ele, bd);&lt;/p&gt;&lt;p&gt;bd.setResource(this.readerContext.getResource());&lt;br/&gt;bd.setSource(extractSource(ele));&lt;/p&gt;&lt;p&gt;return bd;&lt;br/&gt;}&lt;br/&gt;catch (ClassNotFoundException ex) {&lt;br/&gt;error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);&lt;br/&gt;}&lt;br/&gt;catch (NoClassDefFoundError err) {&lt;br/&gt;error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);&lt;br/&gt;}&lt;br/&gt;catch (Throwable ex) {&lt;br/&gt;error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);&lt;br/&gt;}&lt;br/&gt;finally {&lt;br/&gt;this.parseState.pop();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;return null;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 属性解析的逻辑&lt;/span&gt;&lt;/p&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;51&quot;&gt;
public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,&lt;br/&gt;@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {&lt;p&gt;if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {&lt;br/&gt;error(&quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration&quot;, ele);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt; // 解析scope 属性&lt;/span&gt;&lt;br/&gt;else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {&lt;br/&gt;bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));&lt;br/&gt;}&lt;br/&gt;else if (containingBean != null) {&lt;br/&gt;// Take default from containing bean in case of an inner bean definition.&lt;br/&gt;bd.setScope(containingBean.getScope());&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 解析abstract 属性&lt;/span&gt;&lt;br/&gt;if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {&lt;br/&gt;bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 从解析委托类中获取默认属性值lazy_init&lt;/span&gt;&lt;br/&gt;String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);&lt;br/&gt;if (DEFAULT_VALUE.equals(lazyInit)) {&lt;br/&gt;lazyInit = this.defaults.getLazyInit();&lt;br/&gt;}&lt;br/&gt;bd.setLazyInit(TRUE_VALUE.equals(lazyInit));&lt;/p&gt;&lt;p&gt;String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);&lt;br/&gt;bd.setAutowireMode(getAutowireMode(autowire));&lt;br/&gt;&lt;span&gt;// depends-on 属性&lt;/span&gt;&lt;br/&gt;if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {&lt;br/&gt;String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);&lt;br/&gt;bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);&lt;br/&gt;if (&quot;&quot;.equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {&lt;br/&gt;String candidatePattern = this.defaults.getAutowireCandidates();&lt;br/&gt;if (candidatePattern != null) {&lt;br/&gt;String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);&lt;br/&gt;bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;else {&lt;br/&gt;bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//这个primary 属性&lt;/span&gt;&lt;br/&gt;if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {&lt;br/&gt;bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;// init-method 属性&lt;/span&gt;&lt;br/&gt;if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {&lt;br/&gt;String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);&lt;br/&gt;bd.setInitMethodName(initMethodName);&lt;br/&gt;}&lt;br/&gt;else if (this.defaults.getInitMethod() != null) {&lt;br/&gt;bd.setInitMethodName(this.defaults.getInitMethod());&lt;br/&gt;bd.setEnforceInitMethod(false);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt; //destory-method&lt;/span&gt; &lt;br/&gt;if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {&lt;br/&gt;String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);&lt;br/&gt;bd.setDestroyMethodName(destroyMethodName);&lt;br/&gt;}&lt;br/&gt;else if (this.defaults.getDestroyMethod() != null) {&lt;br/&gt;bd.setDestroyMethodName(this.defaults.getDestroyMethod());&lt;br/&gt;bd.setEnforceDestroyMethod(false);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt; //factory-method&lt;/span&gt; &lt;br/&gt;if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {&lt;br/&gt;bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//factory-bean 属性&lt;/span&gt;&lt;br/&gt;if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {&lt;br/&gt;bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;return bd;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//到此,spring 解析bean 标签基本完后,我们在回过去看bean标签解析完成后,做了什么处理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//beandefinition 解析完成后,注册到bean 注册中心中去,后续实例化的时候再去取用&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;17&quot;&gt;
public static void registerBeanDefinition(&lt;br/&gt;BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)&lt;br/&gt;throws BeanDefinitionStoreException {&lt;p&gt;// Register bean definition under primary name.&lt;br/&gt;String beanName = definitionHolder.getBeanName();&lt;/p&gt;&lt;p&gt;&lt;span&gt;//完成BeanDefinition的注册，重点看，重要程度 5&lt;/span&gt;&lt;br/&gt;registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());&lt;/p&gt;&lt;p&gt;&lt;span&gt;//建立别名和 id的映射，这样就可以根据别名获取到id&lt;/span&gt;&lt;br/&gt;// Register aliases for bean name, if any.&lt;br/&gt;String[] aliases = definitionHolder.getAliases();&lt;br/&gt;if (aliases != null) {&lt;br/&gt;for (String alias : aliases) {&lt;br/&gt;registry.registerAlias(beanName, alias);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 注册beandefinitionholder 到bean 注册中心中&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;15&quot;&gt;
public static void registerBeanDefinition(&lt;br/&gt;BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)&lt;br/&gt;throws BeanDefinitionStoreException {&lt;p&gt;// Register bean definition under primary name.&lt;br/&gt;String beanName = definitionHolder.getBeanName();&lt;/p&gt;&lt;p&gt;&lt;span&gt;//完成BeanDefinition的注册，重点看，重要程度 5&lt;/span&gt;&lt;br/&gt;registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());&lt;/p&gt;&lt;p&gt;&lt;span&gt;//建立别名和 id的映射，这样就可以根据别名获取到id&lt;/span&gt;&lt;br/&gt;// Register aliases for bean name, if any.&lt;br/&gt;String[] aliases = definitionHolder.getAliases();&lt;br/&gt;if (aliases != null) {&lt;br/&gt;for (String alias : aliases) {&lt;br/&gt;registry.registerAlias(beanName, alias);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;至此,bean 标签的解析流程基本结束, 如果用流程图表示整个过程的话,整个过程的整体流程如图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191214013642309-458396506.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;后续会继续完善开启注解扫描部分的讲解.即&amp;lt;context:component-scan=&quot;basepackage&quot;&amp;gt; 标签的解析流程.&lt;/strong&gt;&lt;/p&gt;




&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;/&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 13 Dec 2019 17:40:00 +0000</pubDate>
<dc:creator>城序猿</dc:creator>
<og:description>bean 标签在spring的配置文件中, 是非常重要的一个标签, 即便现在boot项目比较流行, 但是还是有必要理解bean标签的解析流程,有助于我们进行 基于注解配置, 也知道各个标签的作用,以及</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cheng21553516/p/12032881.html</dc:identifier>
</item>
<item>
<title>Spring Cloud进阶篇之Eureka原理分析 - 毛毛向前冲</title>
<link>http://www.cnblogs.com/fengfujie/p/12037895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengfujie/p/12037895.html</guid>
<description>&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/13/16efffc572e92504?w=1024&amp;amp;h=768&amp;amp;f=png&amp;amp;s=978634&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h2 id=&quot;h-3&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;之前写了几篇Spring Cloud的小白教程，相信看过的朋友对Spring Cloud中的一些应用有了简单的了解，写小白篇的目的就是为初学者建立一个基本概念，让初学者在学习的道路上建立一定的基础。&lt;/p&gt;
&lt;p&gt;从今天开始，我会持续更新几篇Spring Cloud的进阶教程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;heureka&quot;&gt;&lt;span&gt;Eureka简介&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Eureka是Netflix开发的服务发现框架，本身就是一个基于REST的服务。Spring Cloud将它集成在其子项目spring-cloud-netflix中，用来实现服务的注册与发现功能。&lt;/p&gt;
&lt;h3 id=&quot;heureka-1&quot;&gt;&lt;span&gt;Eureka总体架构图&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/13/16efffab010c54ed?w=2086&amp;amp;h=836&amp;amp;f=png&amp;amp;s=190201&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;heureka-2&quot;&gt;&lt;span&gt;Eureka组件介绍&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;服务注册中心集群&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;分别部署在IDC1、IDC2、IDC3中心&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;服务提供者&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;服务提供者一个部署在IDC1，一个部署在IDC3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;服务消费者&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;服务消费者一个部署在IDC1，一个部署在IDC2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;组件之间的调用关系&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;h&quot;&gt;&lt;span&gt;服务提供者&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;启动服务&lt;/strong&gt;：服务提供者会向服务注册中心发起Register请求，注册服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行过程中&lt;/strong&gt;：服务提供者会定时向注册中心发送Renew心跳，告诉它“我还活着”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;停止服务提供&lt;/strong&gt;：服务提供者会向服务注册中心发送Cancel请求，告诉它清空当前服务注册信息。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h-1&quot;&gt;&lt;span&gt;服务消费者&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;启动后&lt;/strong&gt;：从服务注册中心拉取服务注册信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行过程中&lt;/strong&gt;：定时更新服务注册信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发起远程调用&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;span&gt;- 服务消费者会从服务注册中心选择同机房的服务提供者，然后发起远程调用，只有同机房的服务提供者宕机才会去选择其他机房的服务提供者。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果服务消费者发现同机房没有服务提供者，则会按照负载均衡算法 选择其他机房的服务提供者，然后发起远程调用。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h-2&quot;&gt;&lt;span&gt;注册中心&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;启动后：从其他节点拉取服务注册信息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;运行过程中：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;- 定时运行Evict任务，定时清理没有按时发送Renew的服务提供者，这里的清理会将非常正常停止、网络异常等其他因素引起的所有服务。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;接收到的Register、Renew、Cancel请求，都会同步到其他的注册中心节点。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Eureka Server会通过Register、Renew、Get Registry等接口提供服务的注册、发现和心跳检测等。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端本身也内置了负载均衡器（默认使用round-robin方式），在启动后会向Eureka Server发送心跳检测，默认周期为30s，Eureka Server如果在多个心跳周期内没有接收到Eureka client的某一个节点的心跳请求，Eureka Server会从服务注册中心清理到对应的Eureka Client的服务节点（默认90s）。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;数据结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;服务存储的数据结构可以简单的理解为是一个两层的HashMap结构（为了保证线程安全使用的ConcurrentHashMap），具体的我们可以查看源码中的&lt;em&gt;AbstractInstanceRegistry&lt;/em&gt;类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt;&amp;gt; registry = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一层ConcurrentHashMap的key=spring.application.name，也就是应用名称，value为ConcurrentHashMap。&lt;/p&gt;
&lt;p&gt;第二层ConcurrentHashMap的key=instanceId，也就是服务的唯一实例id，value为Lease对象，也就是具体的服务。Lease其实就是对InstanceInfo的包装，里面保存了实例信息、服务注册的时间等。具体的我们可以查看&lt;em&gt;InstanceInfo&lt;/em&gt;源码。&lt;/p&gt;
&lt;h3 id=&quot;h-6&quot;&gt;&lt;span&gt;数据存储过程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Eureka是通过REST接口对外提供服务的。&lt;/p&gt;
&lt;p&gt;这里我以注册为例（&lt;em&gt;ApplicationResource&lt;/em&gt;），首先将PeerAwareInstanceRegistry的实例注入到ApplicationResource的成员变量的registry里。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;ApplicationResource接收到请求后，对调用registry.register()方法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@POST&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Consumes&lt;/span&gt;({&lt;span class=&quot;hljs-string&quot;&gt;&quot;application/json&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/xml&quot;&lt;/span&gt;})&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Response &lt;span class=&quot;hljs-title&quot;&gt;addInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(InstanceInfo info,&lt;br/&gt;@HeaderParam(PeerEurekaNode.HEADER_REPLICATION)&lt;/span&gt; String isReplication) &lt;/span&gt;{&lt;br/&gt;logger.debug(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Registering instance {} (replication={})&quot;&lt;/span&gt;, info.getId(), isReplication);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isBlank(info.getId())) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Response.status(&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;).entity(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Missing instanceId&quot;&lt;/span&gt;).build();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isBlank(info.getHostName())) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Response.status(&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;).entity(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Missing hostname&quot;&lt;/span&gt;).build();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isBlank(info.getIPAddr())) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Response.status(&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;).entity(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Missing ip address&quot;&lt;/span&gt;).build();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isBlank(info.getAppName())) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Response.status(&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;).entity(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Missing appName&quot;&lt;/span&gt;).build();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!appName.equals(info.getAppName())) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Response.status(&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;).entity(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Mismatched appName, expecting &quot;&lt;/span&gt; + appName + &lt;span class=&quot;hljs-string&quot;&gt;&quot; but was &quot;&lt;/span&gt; + info.getAppName()).build();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (info.getDataCenterInfo() == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Response.status(&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;).entity(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Missing dataCenterInfo&quot;&lt;/span&gt;).build();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (info.getDataCenterInfo().getName() == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Response.status(&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;).entity(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Missing dataCenterInfo Name&quot;&lt;/span&gt;).build();&lt;br/&gt;}&lt;p&gt;&lt;br/&gt;DataCenterInfo dataCenterInfo = info.getDataCenterInfo();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (dataCenterInfo &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; UniqueIdentifier) {&lt;br/&gt;String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isBlank(dataCenterInfoId)) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; experimental = &lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;.equalsIgnoreCase(serverConfig.getExperimental(&lt;span class=&quot;hljs-string&quot;&gt;&quot;registration.validation.dataCenterInfoId&quot;&lt;/span&gt;));&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (experimental) {&lt;br/&gt;String entity = &lt;span class=&quot;hljs-string&quot;&gt;&quot;DataCenterInfo of type &quot;&lt;/span&gt; + dataCenterInfo.getClass() + &lt;span class=&quot;hljs-string&quot;&gt;&quot; must contain a valid id&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Response.status(&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;).entity(entity).build();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (dataCenterInfo &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; AmazonInfo) {&lt;br/&gt;AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;&lt;br/&gt;String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (effectiveId == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;logger.warn(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Registering DataCenterInfo of type {} without an appropriate id&quot;&lt;/span&gt;, dataCenterInfo.getClass());&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;registry.register(info, &lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;.equals(isReplication));&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Response.status(&lt;span class=&quot;hljs-number&quot;&gt;204&lt;/span&gt;).build();  &lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;AbstractInstanceRegistry在register方法里完成对服务信息的存储。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre readability=&quot;19&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;32&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(InstanceInfo registrant, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; leaseDuration, &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; isReplication)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;read.lock();&lt;br/&gt;Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt; gMap = registry.get(registrant.getAppName());&lt;br/&gt;REGISTER.increment(isReplication);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (gMap == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt; gNewMap = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt;();&lt;br/&gt;gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (gMap == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;gMap = gNewMap;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;Lease&amp;lt;InstanceInfo&amp;gt; existingLease = gMap.get(registrant.getId());&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (existingLease != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (existingLease.getHolder() != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;)) {&lt;br/&gt;Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();&lt;br/&gt;Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();&lt;br/&gt;logger.debug(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Existing lease found (existing={}, provided={}&quot;&lt;/span&gt;, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (existingLastDirtyTimestamp &amp;gt; registrationLastDirtyTimestamp) {&lt;br/&gt;logger.warn(&lt;span class=&quot;hljs-string&quot;&gt;&quot;There is an existing lease and the existing lease's dirty timestamp {} is greater&quot;&lt;/span&gt; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; than the one that is being registered {}&quot;&lt;/span&gt;, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);&lt;br/&gt;logger.warn(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Using the existing instanceInfo instead of the new instanceInfo as the registrant&quot;&lt;/span&gt;);&lt;br/&gt;registrant = existingLease.getHolder();&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (lock) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.expectedNumberOfClientsSendingRenews &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.expectedNumberOfClientsSendingRenews = &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.expectedNumberOfClientsSendingRenews + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;updateRenewsPerMinThreshold();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;logger.debug(&lt;span class=&quot;hljs-string&quot;&gt;&quot;No previous lease information found; it is new registration&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;Lease&amp;lt;InstanceInfo&amp;gt; lease = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Lease&amp;lt;InstanceInfo&amp;gt;(registrant, leaseDuration);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (existingLease != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());&lt;br/&gt;}&lt;br/&gt;gMap.put(registrant.getId(), lease);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (recentRegisteredQueue) {&lt;br/&gt;recentRegisteredQueue.add(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Pair&amp;lt;Long, String&amp;gt;(&lt;br/&gt;System.currentTimeMillis(),&lt;br/&gt;registrant.getAppName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;(&quot;&lt;/span&gt; + registrant.getId() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;)&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) {&lt;br/&gt;logger.debug(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Found overridden status {} for instance {}. Checking to see if needs to be add to the &quot;&lt;/span&gt;&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot;overrides&quot;&lt;/span&gt;, registrant.getOverriddenStatus(), registrant.getId());&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!overriddenInstanceStatusMap.containsKey(registrant.getId())) {&lt;br/&gt;logger.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Not found overridden id {} and hence adding it&quot;&lt;/span&gt;, registrant.getId());&lt;br/&gt;overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overriddenStatusFromMap != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;logger.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Storing overridden status {} from map&quot;&lt;/span&gt;, overriddenStatusFromMap);&lt;br/&gt;registrant.setOverriddenStatus(overriddenStatusFromMap);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);&lt;br/&gt;registrant.setStatusWithoutDirty(overriddenInstanceStatus);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (InstanceStatus.UP.equals(registrant.getStatus())) {&lt;br/&gt;lease.serviceUp();&lt;br/&gt;}&lt;br/&gt;registrant.setActionType(ActionType.ADDED);&lt;br/&gt;recentlyChangedQueue.add(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RecentlyChangedItem(lease));&lt;br/&gt;registrant.setLastUpdatedTimestamp();&lt;br/&gt;invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());&lt;br/&gt;logger.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Registered instance {}/{} with status {} (replication={})&quot;&lt;/span&gt;,&lt;br/&gt;registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;read.unlock();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码中不难看出存储的数据结构是双层的HashMap。&lt;/p&gt;
&lt;p&gt;Eureka还实现了二级缓存来保证即将对外传输的服务信息，&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;一级缓存：本质还是HashMap，没有过期时间，保存服务信息的对外输出的数据结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;Key, Value&amp;gt; readOnlyCacheMap = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;Key, Value&amp;gt;();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;二级缓存：是guava的缓存，包含失效机制，保存服务信息的对外输出的数据结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; LoadingCache&amp;lt;Key, Value&amp;gt; readWriteCacheMap;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存的更新：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li&gt;
&lt;p&gt;删除二级缓存：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;- client端发送register、renew、cancel请求并更新register注册表之后会删除二级缓存；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;server端自身的Evict任务剔除服务后会删除二级缓存；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;二级缓存本事设置的失效机制（指的是guava实现的readWriteCacheMap），&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载二级缓存：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;- client发送Get registry请求后，如果二级缓存中没有，就会触发guava的load机制，从registry中获取原始的服务信息后进行加工处理，然后放入二级缓存中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;server端更新一级缓存的时候，如果二级缓存没有数据也会触发guava的load机制；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新一级缓存：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;- server端内置了一个time task会定时将二级缓存中的数据同步到一级缓存中，这其中包括了删除和更新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;缓存的机制可以查看ResponseCacheImpl源码。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Eureka的数据结构简单总结为：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/13/16efffb872a4ce22?w=310&amp;amp;h=600&amp;amp;f=png&amp;amp;s=37429&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h-7&quot;&gt;&lt;span&gt;服务注册机制&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;服务注册中心、服务提供者、服务消费者在启动后都会向服务注册中心发起注册服务的请求（前提是配置了注册服务）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注册中心接到register请求后：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将服务信息保存到registry中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;更新队列，将该事件添加到更新队列中，给Eureka client增量同步服务信息使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;清空二级缓存，用于保证数据的一致性；（即清空的是：&lt;em&gt;readWriteCacheMap&lt;/em&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新阈值；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步服务信息；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;h-8&quot;&gt;&lt;span&gt;服务续约&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;服务注册后，要定时发送续约请求（心跳检查），证明我还活着，不要清空我的服务信息，定时时间默认30s，可以通过配置：&lt;strong&gt;eureka.instance.lease-renewal-interval-in-seconds&lt;/strong&gt;来修改。&lt;/p&gt;
&lt;p&gt;注册中心接收到续约请求后（&lt;strong&gt;renew&lt;/strong&gt;）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更新服务对象的最近续约时间（&lt;strong&gt;lastUpdateTimestamp&lt;/strong&gt;）；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将信息同步给其他的节点；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h-9&quot;&gt;&lt;span&gt;服务注销&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;正常的服务停止之前会发送注销服务请求，通知注册中心我要下线了。&lt;/p&gt;
&lt;p&gt;注册中心接收到注销请求后（&lt;strong&gt;cancel&lt;/strong&gt;）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将服务信息从registry中删除；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;更新队列；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;清空二级缓存；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;更新阈值；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;同步信息给其他节点；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明：只有服务正常停止才会发送cancel请求，非正常停止的会通过Eureka Server的主动剔除机制进行删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h-10&quot;&gt;&lt;span&gt;服务剔除&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;服务剔除其实是一个兜底的方案，目的就是解决非正常情况下的服务宕机或其他因素导致不能发送cancel请求的服务信息清理的策略。&lt;/p&gt;
&lt;p&gt;服务剔除分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;判断剔除条件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;找出过期服务&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;清理过期服务&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;剔除条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;关闭自我保护&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自我保护如果开启，会先判断是server还是client出现问题，如果是client的问题就会进行删除；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自我保护机制：Eureka的自我保护机制是为了防止误杀服务提供的一种保护机制。Eureka的自我保护机制认为如果有大量的服务都续约失败，则认为自己出现了问题（例如：自己断网了），也就不剔除了。反之，则是它人的问题，就进行剔除。&lt;/p&gt;
&lt;p&gt;自我保护的阈值分为server和client，如果超出阈值就是表示大量服务可用，部分服务不可用，这判定为client端出现问题。如果未超出阈值就是表示大量服务不可用，则判定是自己出现了问题。&lt;/p&gt;
&lt;p&gt;阈值的计算：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;自我保护阈值 = 服务总数 * 每分钟续约数 * 自我保护阈值因子；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每分钟续约数 = （60s / 客户端续约时间）；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;过期服务：&lt;/p&gt;
&lt;p&gt;找出过期服务会遍历所有的服务，判断上次续约时间距离当前时间大于阈值就标记为过期，同时会将这些过期的服务保存的过期的服务集合中。&lt;/p&gt;
&lt;p&gt;剔除服务：&lt;/p&gt;
&lt;p&gt;剔除服务之前会先计算要是剔除的服务数量，然后遍历过期服务，通过洗牌算法确保每次都公平的选择出要剔除的服务，然后进行剔除。&lt;/p&gt;
&lt;p&gt;执行剔除服务后：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;从register中删除服务信息；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;更新队列；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;清空二级缓存，保证数据的一致性；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;h-11&quot;&gt;&lt;span&gt;服务获取&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Eureka Client服务的获取都是从缓存中获取，如果缓存中没有，就加载数据到缓存中，然后在从缓存中取。服务的获取方式分为全量同步和增量同步两种。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;registry中只保存数据结构，缓存中存ready的服务信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;先读取一级缓存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;先判断是否开启一级缓存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果开启一级缓存，就从一级缓存中取，如果一级缓存中没有，则从二级缓存中取；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果没有开启一级缓存，则直接从二级缓存中取；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;再读取二级缓存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果二级缓存中存在，则直接返回；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果二级缓存中不存在，则先将数据加载到二级缓存中，然后再读取二级缓存中的数据。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：加载二级缓存的时候需要判断是全量还是增量，如果是增量的话，就从&lt;em&gt;recentlyChangedQueue&lt;/em&gt;中加载，如果是全量的话就从&lt;em&gt;registry&lt;/em&gt;中加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h-12&quot;&gt;&lt;span&gt;服务同步&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;服务同步是Server节点之间的数据同步。分为启动时同步，运行时同步。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;启动同步&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;启动同步时，会先遍历Applications中获取的服务信息，并将服务信息注册到registry中。可以参考&lt;em&gt;PeerAwareInstanceRegistryImpl&lt;/em&gt;类中的&lt;em&gt;syncUp&lt;/em&gt;方法：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;syncUp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; count = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; ((i &amp;lt; serverConfig.getRegistrySyncRetries()) &amp;amp;&amp;amp; (count == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)); i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;logger.warn(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Interrupted during registry transfer..&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;Applications apps = eurekaClient.getApplications();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Application app : apps.getRegisteredApplications()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (InstanceInfo instance : app.getInstances()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isRegisterable(instance)) {&lt;br/&gt;register(instance, instance.getLeaseInfo().getDurationInSecs(), &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;count++;&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;logger.error(&lt;span class=&quot;hljs-string&quot;&gt;&quot;During DS init copy&quot;&lt;/span&gt;, t);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; count;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这个方法使用类两层for循环，第一次循环时保证自己已经拉取到服务信息，第二层循环是遍历拉取到服务注册信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;运行时同步&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;server端当有reigster、renew、cancel请求进来时，会将这些请求封装到一个task中，然后放到一个队列当中，然后经过一系列的处理后，在放到另一个队列中。 可以查看&lt;em&gt;PeerAwareInstanceRegistryImpl&lt;/em&gt;类中的&lt;em&gt;BatchWorkerRunnable&lt;/em&gt;类，这里就不再贴源码了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h-13&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Eureka的原理接介绍到这里，从整体上看似简单，但实现细节相关复杂。得多看几遍源码才能猜透他们的设计思路。&lt;/p&gt;
&lt;p&gt;Eureka作为服务的注册与发现，它实际的设计原则是遵循AP原则，也就是“数据的最终一致性”。现在还有好多公司使用zk、nacos来作为服务的注册中心，后续会简单更新一篇关于服务注册中心的对比，这里就不过多阐述。&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;写作不易，转载请注明出处，喜欢的小伙伴可以关注公众号查看更多喜欢的文章。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;联系方式：4272231@163.com QQ:95472323&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/23/16d5d09acd65b7d2?w=2172&amp;amp;h=800&amp;amp;f=png&amp;amp;s=231696&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 13 Dec 2019 16:11:00 +0000</pubDate>
<dc:creator>毛毛向前冲</dc:creator>
<og:description>前言 之前写了几篇Spring Cloud的小白教程，相信看过的朋友对Spring Cloud中的一些应用有了简单的了解，写小白篇的目的就是为初学者建立一个基本概念，让初学者在学习的道路上建立一定的基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fengfujie/p/12037895.html</dc:identifier>
</item>
<item>
<title>Spring Boot应用使用Validation校验入参，现有注解不满足，我是怎么暴力扩展validation注解的 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/12037311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/12037311.html</guid>
<description>&lt;p&gt;昨天，我开发的代码，又收获了一个bug，说是界面上列表查询时，正常情况下，可以根据某个关键字keyword模糊查询，后台会去数据库 %keyword%查询（非互联网项目，没有使用es，只能这样了）；但是，当输入%字符时，可以模糊匹配出所有的记录，就好像，好像这个条件没进行过滤一样。&lt;/p&gt;
&lt;p&gt;原因很简单，当输入%时，最终出来的sql，就是%%%这样的。&lt;/p&gt;
&lt;p&gt;我们用的&lt;code&gt;mybatis plus&lt;/code&gt;，写法如下，看来这样是有问题的（bug警告）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;QueryWrapper&amp;lt;QueryUserListReqVO&amp;gt; wrapper = new QueryWrapper&amp;lt;&amp;gt;();
if (StringUtils.isNotBlank(reqVO.getIncidentNumber())) {
  // 如果传入的条件不为空，需要模糊查询
  wrapper.and(i -&amp;gt; i.like(&quot;i.incident_number&quot;, reqVO.getIncidentNumber()));
}
//根据wrapper去查询
return this.baseMapper.getAppealedNormalIncidentList( wrapper);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mapper&lt;/code&gt;层代码如下（以下仅为演示，单表肯定不直接写sql了，哈哈）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IncidentAppealInformationMapper extends BaseMapper&amp;lt;IncidentAppealInformation&amp;gt; {

    @Select(&quot;SELECT \n&quot; +
            &quot;  * \n&quot;
            &quot; FROM\n&quot; +
            &quot;  incident_appeal_information a ${ew.customSqlSegment}&quot;)
    List&amp;lt;GetAppealedNormalIncidentListRespVO&amp;gt; getAppealedNormalIncidentList(@Param(Constants.WRAPPER)QueryWrapper wrapper);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当输入的条件为&lt;code&gt;%&lt;/code&gt;时，我们看看console打印的sql：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191213175715105-1307746950.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题找到了，看看怎么改吧。&lt;/p&gt;
&lt;p&gt;项目源码在（建议先看代码，再看本文，会容易一些）：&lt;br/&gt;&lt;a href=&quot;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/spring-boot-validation-demo&quot; class=&quot;uri&quot;&gt;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/spring-boot-validation-demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;闲言少叙，我想的办法是，判断请求参数，正常情况下，请求参数里都不会有这种%字符。问题是，我们有很多地方的列表查询有这个问题，懒得一个一个写&lt;code&gt;if/else&lt;/code&gt;，作为懒人，肯定要想想办法了，那就是使用&lt;code&gt;java ee&lt;/code&gt;规范里的&lt;code&gt;validation&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;spring validation&lt;/code&gt;的demo，可以看看博主的码云：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/spring-boot-validation-demo&quot; class=&quot;uri&quot;&gt;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/spring-boot-validation-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的使用方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191213190442768-2085187213.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我解决这个问题的办法就是，自定义一个注解，加在支持模糊查询的字段上，在该注解的处理handler中，判断是否包含了特殊字符%，如果包含了，直接给客户端抛错误码。&lt;/p&gt;
&lt;p&gt;定了方向，说干就干，我这里没有第一时间去搜索答案，因为感觉也不是很难，好像自己可以搞定的样子，哈哈。&lt;/p&gt;
&lt;p&gt;那就开始吧。&lt;/p&gt;

&lt;p&gt;因为，我知道这类validation注解，主要是在validation-api的包里，maven坐标：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.validation&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;validation-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后呢，这个包是java ee 规范的，只定义，不实现，实现的话，hibernate对这个进行了实现，spring-boot-starter-web里默认也引了这个依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191213191221852-2051841431.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，大家可以这么理解，&lt;code&gt;validation-api&lt;/code&gt;定义了基本的注解，然后&lt;code&gt;hibernate-validator&lt;/code&gt;进行了实现，并且，扩展了一部分注解，我随便找了两个，比如&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;org.hibernate.validator.constraints.Length，校验字符串长度是否在指定的范围内&lt;/p&gt;
&lt;p&gt;org.hibernate.validator.constraints.Email，校验指定字符串为一个有效的email地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我本地工程都是maven管理，且下载了源码的，所以直接查找 &lt;code&gt;org.hibernate.validator.constraints.Email&lt;/code&gt;的引用的地方，即发现了下面这个代码&lt;code&gt;org.hibernate.validator.internal.metadata.core.ConstraintHelper&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191213192320373-257673829.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们只要想办法，在这里面加上我们自己的一条记录就行了，最简单的办法是，把代码给它覆盖了，但是，我还是有底线的，能扩展就扩展，实在不行了，再覆盖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i01piccdn.sogoucdn.com/d1404614ed2b8c65&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析了一下，这个地方，是&lt;code&gt;org.hibernate.validator.internal.metadata.core.ConstraintHelper&lt;/code&gt;的构造函数里，先是new了一个hashmap，把这些注解和注解处理器put进去后，再用下面的代码赋给了类中的field：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 一个map，key：注解class，value：能够处理该注解class的handler的描述符
@Immutable
private final Map&amp;lt;Class&amp;lt;? extends Annotation&amp;gt;, List&amp;lt;? extends ConstraintValidatorDescriptor&amp;lt;?&amp;gt;&amp;gt;&amp;gt; builtinConstraints;

public ConstraintHelper() {
    Map&amp;lt;Class&amp;lt;? extends Annotation&amp;gt;, List&amp;lt;ConstraintValidatorDescriptor&amp;lt;?&amp;gt;&amp;gt;&amp;gt; tmpConstraints = new HashMap&amp;lt;&amp;gt;();

    // Bean Validation constraints
    putConstraint( tmpConstraints, Email.class, EmailValidator.class );
    this.builtinConstraints = Collections.unmodifiableMap( tmpConstraints );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，我的思路是，等这个类的构造函数被调用后，修改下这个map。那，先得看看怎么操纵这个类的构造函数在哪被调用的？经过查找，发现是在&lt;code&gt;org.hibernate.validator.internal.engine.ValidatorFactoryImpl#ValidatorFactoryImpl&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ValidatorFactoryImpl(ConfigurationState configurationState) {
        ClassLoader externalClassLoader = getExternalClassLoader( configurationState );

        this.valueExtractorManager = new ValueExtractorManager( configurationState.getValueExtractors() );
        this.beanMetaDataManagers = new ConcurrentHashMap&amp;lt;&amp;gt;();
        // 这里new了一个上面类的实例
        this.constraintHelper = new ConstraintHelper();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续追踪，发现在&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;## org.hibernate.validator.HibernateValidator
public class HibernateValidator implements ValidationProvider&amp;lt;HibernateValidatorConfiguration&amp;gt; {
    ...
      
    @Override
    public ValidatorFactory buildValidatorFactory(ConfigurationState configurationState) {
        // 这里new了该类的实例  
        return new ValidatorFactoryImpl( configurationState );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们可以在上面这里，打个断点，看看什么场景下，会走到这里来了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191213200414096-1267694019.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;走到上图的最后一步时，会进入到单独的线程来做以上动作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;org.springframework.boot.autoconfigure.BackgroundPreinitializer.ValidationInitializer
/**
 * Early initializer for javax.validation.
 */
private static class ValidationInitializer implements Runnable {

  @Override
  public void run() {
    Configuration&amp;lt;?&amp;gt; configuration = Validation.byDefaultProvider().configure();
    configuration.buildValidatorFactory().getValidator();
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们接着看，看什么情况会走到我们之前的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;## org.hibernate.validator.HibernateValidator
public class HibernateValidator implements ValidationProvider&amp;lt;HibernateValidatorConfiguration&amp;gt; {
    ...
      
    @Override
    public ValidatorFactory buildValidatorFactory(ConfigurationState configurationState) {
        // 这里new了该类的实例  
        return new ValidatorFactoryImpl( configurationState );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过跟踪，发现在以下地方进入的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final ValidatorFactory buildValidatorFactory() {
      loadValueExtractorsFromServiceLoader();
      parseValidationXml();

      for ( ValueExtractorDescriptor valueExtractorDescriptor : valueExtractorDescriptors.values() ) {
        validationBootstrapParameters.addValueExtractorDescriptor( valueExtractorDescriptor );
      }

      ValidatorFactory factory = null;
      if ( isSpecificProvider() ) {
        factory = validationBootstrapParameters.getProvider().buildValidatorFactory( this );
      }
      else {
          //如果没有指定validator，则会进入该分支，一般默认都进入该分支了
          final Class&amp;lt;? extends ValidationProvider&amp;lt;?&amp;gt;&amp;gt; providerClass = validationBootstrapParameters.getProviderClass();
          if ( providerClass != null ) {
            for ( ValidationProvider&amp;lt;?&amp;gt; provider : providerResolver.getValidationProviders() ) {
              if ( providerClass.isAssignableFrom( provider.getClass() ) ) {
                factory = provider.buildValidatorFactory( this );
                break;
              }
            }
            if ( factory == null ) {
              throw LOG.getUnableToFindProviderException( providerClass );
            }
          }
          else {
            //进入这里，是因为，参数里没指定provider class，provider class可以在classpath下的META-              INF/validation.xml中指定
            
            // 这里，providerResolver会去根据自己的规则，获取validationProvider class集合
            List&amp;lt;ValidationProvider&amp;lt;?&amp;gt;&amp;gt; providers = providerResolver.getValidationProviders();               // 取第一个集合中的provider，这里的providers.get(0)一般就会取到前面我们说的                         // HibernateValidator
            factory = providers.get( 0 ).buildValidatorFactory( this );
          }
        
      }

        return factory;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段逻辑，还是有点绕的，先说说，频繁出现的provider是啥意思？&lt;/p&gt;
&lt;p&gt;我先来，其实，这就是个工厂。&lt;/p&gt;
&lt;p&gt;然后，让api来话事，这个类，&lt;code&gt;javax.validation.spi.ValidationProvider&lt;/code&gt;出现在&lt;code&gt;validation-api&lt;/code&gt;包里。我们说了，这个包，只管定接口，不管实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ValidationProvider&amp;lt;T extends Configuration&amp;lt;T&amp;gt;&amp;gt; {
    ... 

    /**
     * 构造一个ValidatorFactory并返回
     * 
     * Build a {@link ValidatorFactory} using the current provider implementation.
     * &amp;lt;p&amp;gt;
     * The {@code ValidatorFactory} is assembled and follows the configuration passed
     * via {@link ConfigurationState}.
     * &amp;lt;p&amp;gt;
     * The returned {@code ValidatorFactory} is properly initialized and ready for use.
     *
     * @param configurationState the configuration descriptor
     * @return the instantiated {@code ValidatorFactory}
     * @throws ValidationException if the {@code ValidatorFactory} cannot be built
     */
    ValidatorFactory buildValidatorFactory(ConfigurationState configurationState);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然说了，这个接口，只管接口，不管实现；那么实现在哪指定呢？&lt;/p&gt;
&lt;p&gt;这个是利用了SPI机制，javax.validation.spi.ValidationProvider的实现在下面这个地方指定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191213205921261-1750421289.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，我再画个图来说，前面查找provider的简易流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191213233900554-308492788.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，大家如果对SPI机制有了解的话，那么我们可以在classpath下，自定义一个ValidationProvider，比如像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191213234106612-1893970256.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里看看我们是怎么自定义&lt;code&gt;com.example.webdemo.config.CustomHibernateValidator&lt;/code&gt;的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.webdemo.config;

import lombok.extern.slf4j.Slf4j;
import org.hibernate.validator.HibernateValidator;
import org.hibernate.validator.internal.engine.ValidatorFactoryImpl;

import javax.validation.ValidatorFactory;
import javax.validation.spi.ConfigurationState;
import java.lang.reflect.Field;

@Slf4j
public class CustomHibernateValidator extends HibernateValidator{

    @Override
    public ValidatorFactory buildValidatorFactory(ConfigurationState configurationState) {
        ValidatorFactoryImpl validatorFactory = new ValidatorFactoryImpl(configurationState);
        // 修改validatorFactory中原有的ConstraintHelper
        CustomConstraintHelper customConstraintHelper = new CustomConstraintHelper();
        try {
            Field field = validatorFactory.getClass().getDeclaredField(&quot;constraintHelper&quot;);
            field.setAccessible(true);
            field.set(validatorFactory,customConstraintHelper);
        } catch (IllegalAccessException | NoSuchFieldException e) {
            log.error(&quot;{}&quot;,e);
        }
        // 我们自定义的CustomConstraintHelper，继承了原有的
        // org.hibernate.validator.internal.metadata.core.ConstraintHelper,这里对
        // 原有类中的注解--》注解处理器map进行修改，放进我们自定义的注解和注解处理器
        customConstraintHelper.moidfy();

        return validatorFactory;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义的customconstrainthelper&quot;&gt;自定义的CustomConstraintHelper&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.webdemo.config;

import com.example.webdemo.annotation.SpecialCharNotAllowed;
import com.example.webdemo.annotation.SpecialCharValidator;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.validator.internal.engine.constraintvalidation.ConstraintValidatorDescriptor;
import org.hibernate.validator.internal.metadata.core.ConstraintHelper;

import javax.validation.ConstraintValidator;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
public class CustomConstraintHelper extends ConstraintHelper {

    public CustomConstraintHelper() {
        super();
    }

    void moidfy(){
        Field field = null;
        try {
            field = this.getClass().getSuperclass().getDeclaredField(&quot;builtinConstraints&quot;);
            field.setAccessible(true);

            Object o = field.get(this);

            // 因为field被定义为了private final，且实际类型为
            // this.builtinConstraints = Collections.unmodifiableMap( tmpConstraints );
            // 因为不能修改，所以我这里只能拷贝到一个新的hashmap，再反射设置回去
            Map&amp;lt;Class&amp;lt;? extends Annotation&amp;gt;, List&amp;lt;? extends ConstraintValidatorDescriptor&amp;lt;?&amp;gt;&amp;gt;&amp;gt; modifiedMap = new HashMap&amp;lt;&amp;gt;();
            modifiedMap.putAll((Map&amp;lt;? extends Class&amp;lt;? extends Annotation&amp;gt;, ? extends List&amp;lt;? extends ConstraintValidatorDescriptor&amp;lt;?&amp;gt;&amp;gt;&amp;gt;) o);
            // 在这里注册我们自定义的注解和注解处理器
            modifiedMap.put( SpecialCharNotAllowed.class,
                    Collections.singletonList( ConstraintValidatorDescriptor.forClass( SpecialCharValidator.class, SpecialCharNotAllowed.class ) ) );

            /**
             * 设置回field
             */
            field.set(this,modifiedMap);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            log.error(&quot;{}&quot;,e);
        }

    }


    private static &amp;lt;A extends Annotation&amp;gt; void putConstraint(Map&amp;lt;Class&amp;lt;? extends Annotation&amp;gt;, List&amp;lt;ConstraintValidatorDescriptor&amp;lt;?&amp;gt;&amp;gt;&amp;gt; validators,
                                                             Class&amp;lt;A&amp;gt; constraintType, Class&amp;lt;? extends ConstraintValidator&amp;lt;A, ?&amp;gt;&amp;gt; validatorType) {
        validators.put( constraintType, Collections.singletonList( ConstraintValidatorDescriptor.forClass( validatorType, constraintType ) ) );
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义的注解和处理器&quot;&gt;自定义的注解和处理器&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.webdemo.annotation;

import javax.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 注解，主要验证是否有特殊字符
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface SpecialCharNotAllowed {
//    String message() default &quot;{javax.validation.constraints.Min.message}&quot;;
    String message() default &quot;special char like '%' is illegal&quot;;

    Class&amp;lt;?&amp;gt;[] groups() default { };

    Class&amp;lt;? extends Payload&amp;gt;[] payload() default { };

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.webdemo.annotation;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;


public class SpecialCharValidator implements ConstraintValidator&amp;lt;SpecialCharNotAllowed, Object&amp;gt; {

    @Override
    public boolean isValid(Object object, ConstraintValidatorContext constraintValidatorContext) {
        if (object == null) {
            return true;
        }
        if (object instanceof String) {
            String str = (String) object;
            if (str.contains(&quot;%&quot;)) {
                return false;
            }
        }
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;其实，扩展不需要这么麻烦，官方提供了扩展点，我也是写完后，查了下才发现的。&lt;/p&gt;
&lt;p&gt;不过，本文只是给一个思路，和一些我用到的方法吧，希望能抛砖引玉。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Dec 2019 16:09:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>前言 昨天，我开发的代码，又收获了一个bug，说是界面上列表查询时，正常情况下，可以根据某个关键字keyword模糊查询，后台会去数据库 %keyword%查询（非互联网项目，没有使用es，只能这样了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/12037311.html</dc:identifier>
</item>
<item>
<title>详解TCP连接的“三次握手”与“四次挥手”(下) - AhuntSun</title>
<link>http://www.cnblogs.com/AhuntSun-blog/p/12037852.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AhuntSun-blog/p/12037852.html</guid>
<description>&lt;blockquote readability=&quot;1.025641025641&quot;&gt;
&lt;p&gt;上文链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/AhuntSun-blog/p/12028636.html&quot;&gt;详解TCP连接的“三次握手”与“四次挥手”(上)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四tcp的四次挥手four-way-wavehand&quot;&gt;四、TCP的四次挥手（Four-Way Wavehand）&lt;/h2&gt;
&lt;h3 id=&quot;前言&quot;&gt;0.前言&lt;/h3&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;对于&quot;三次握手&quot;我们耳熟能详，因为其相对的简单。但是，我们却不常听见“四次挥手”，就算听过也未必能详细地说明白它的具体过程。下面就为大家详尽，直观，完整地介绍“四次挥手”的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;四次挥手的详解&quot;&gt;1.“四次挥手”的详解&lt;/h3&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。以下为客户端主动发起释放连接的图解：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1845293/201912/1845293-20191213234439862-587275161.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;挥手之前主动释放连接的客户端结束ESTABLISHED阶段。随后开始“四次挥手”：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;首先客户端&lt;strong&gt;想要释放连接&lt;/strong&gt;，向服务器端发送一段TCP报文，其中：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记位&lt;/strong&gt;为FIN，表示“请求释放连接“；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;为Seq=U；&lt;/p&gt;
&lt;p&gt;随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;服务器端接收到从客户端发出的TCP报文之后，&lt;strong&gt;确认了客户端想要释放连接&lt;/strong&gt;，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记位&lt;/strong&gt;为ACK，表示“接收到客户端发送的释放连接的请求”；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;为Seq=V；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确认号&lt;/strong&gt;为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；&lt;/p&gt;
&lt;p&gt;随后服务器端开始准备释放服务器端到客户端方向上的连接。&lt;/p&gt;
&lt;p&gt;客户端收到从服务器端发出的TCP报文之后，&lt;strong&gt;确认了服务器收到了客户端发出的释放连接请求&lt;/strong&gt;，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;前两次挥手既让服务器端知道了客户端想要释放连接也让客户端知道了服务器端了解了自己想要释放连接的请求于是可以确认关闭客户端到服务器端方向上的连接了&quot;&gt;前&quot;两次挥手&quot;既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;（3）&lt;/strong&gt;服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，&lt;strong&gt;做好了释放服务器端到客户端方向上的连接准备&lt;/strong&gt;，再次向客户端发出一段TCP报文，其中：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记位&lt;/strong&gt;为FIN，ACK，表示“已经准备好释放连接了”。&lt;strong&gt;注意：&lt;/strong&gt;这里的ACK并不是确认收到服务器端报文的确认报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;为Seq=W；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确认号&lt;/strong&gt;为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。&lt;/p&gt;
&lt;p&gt;随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）&lt;/strong&gt;客户端收到从服务器端发出的TCP报文，&lt;strong&gt;确认了服务器端已做好释放连接的准备&lt;/strong&gt;，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记位&lt;/strong&gt;为ACK，表示“接收到服务器准备好释放连接的信号”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确认号&lt;/strong&gt;为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。&lt;/p&gt;
&lt;p&gt;随后客户端开始在TIME-WAIT阶段等待&lt;strong&gt;2MSL&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么要客户端要等待2MSL呢？见后文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器端到客户端方向上的连接。&lt;/p&gt;
&lt;p&gt;客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;后两次挥手既让客户端知道了服务器端准备好释放连接了也让服务器端知道了客户端了解了自己准备好释放连接了于是可以确认关闭服务器端到客户端方向上的连接了由此完成四次挥手&quot;&gt;后“两次挥手”既让客户端知道了服务器端准备好释放连接了，也让服务器端知道了客户端了解了自己准备好释放连接了。于是，可以确认关闭服务器端到客户端方向上的连接了，由此完成“四次挥手”。&lt;/h4&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续&quot;挥手&quot;，以此确保了&quot;四次挥手&quot;的顺利完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;四次挥手的动态过程&quot;&gt;2.”四次挥手“的动态过程&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://media.giphy.com/media/kcxT7i564dhk6YZHAC/giphy.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四次挥手的通俗理解&quot;&gt;3.“四次挥手”的通俗理解&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1845293/201912/1845293-20191213234811404-903775722.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;举个栗子：把客户端比作男孩，服务器比作女孩。通过他们的分手来说明“四次挥手”过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&quot;第一次挥手&quot;：日久见人心，男孩发现女孩变成了自己讨厌的样子，忍无可忍，于是决定分手，随即写了一封信告诉女孩。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;“第二次挥手”：女孩收到信之后，&lt;strong&gt;知道了男孩要和自己分手&lt;/strong&gt;，怒火中烧，心中暗骂：你算什么东西，当初你可不是这个样子的！于是立马给男孩写了一封回信：分手就分手，给我点时间，我要把你的东西整理好，全部还给你！&lt;/p&gt;
&lt;p&gt;男孩收到女孩的第一封信之后，&lt;strong&gt;明白了女孩知道自己要和她分手&lt;/strong&gt;。随后等待女孩把自己的东西收拾好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;“第三次挥手”：过了几天，女孩把男孩送的东西都整理好了，于是再次写信给男孩：你的东西我整理好了，快把它们拿走，从此你我恩断义绝！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;“第四次挥手”：男孩收到女孩第二封信之后，&lt;strong&gt;知道了女孩收拾好东西了，可以正式分手了&lt;/strong&gt;，于是再次写信告诉女孩：我知道了，这就去拿回来！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里双方都有各自的坚持。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;女孩自发出第二封信开始，限定一天内收不到男孩回信，就会再发一封信催促男孩来取东西！&lt;/li&gt;
&lt;li&gt;男孩自发出第二封信开始，限定两天内没有再次收到女孩的信就认为，女孩收到了自己的第二封信；若两天内再次收到女孩的来信，就认为自己的第二封信女孩没收到，需要再写一封信，再等两天.....&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;倘若双方信都能正常收到，最少只用四封信就能彻底分手！这就是“四次挥手”。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么握手是三次挥手却要四次&quot;&gt;4.为什么“握手”是三次，“挥手”却要四次？&lt;/h3&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;TCP建立连接时之所以只需要&quot;三次握手&quot;，是因为在第二次&quot;握手&quot;过程中，服务器端发送给客户端的TCP报文是以&lt;strong&gt;SYN与ACK&lt;/strong&gt;作为&lt;strong&gt;标志位&lt;/strong&gt;的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即SYN建立连接报文与ACK确认接收报文是在同一次&quot;握手&quot;当中传输的&lt;/strong&gt;，所以&quot;三次握手&quot;不多也不少，正好让双方明确彼此信息互通。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;TCP释放连接时之所以需要“四次挥手”,是因为&lt;strong&gt;FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次&quot;握手&quot;传输的&lt;/strong&gt;。为何建立连接时一起传输，释放连接时却要分开传输？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。&lt;/li&gt;
&lt;li&gt;释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;所以是“三次握手”，“四次挥手”。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么客户端在time-wait阶段要等2msl&quot;&gt;5.为什么客户端在TIME-WAIT阶段要等2MSL?&lt;/h3&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;为的是确认服务器端是否收到客户端发出的ACK确认报文&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；&lt;/li&gt;
&lt;li&gt;否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;抓包验证&quot;&gt;6.抓包验证&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1845293/201912/1845293-20191213234909815-1157756064.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;图中显示的就是完整的TCP连接释放的”四次挥手”过程。在 80 -&amp;gt; 55389 中，假设80是本地(客户端)端口，55389是服务器端口。80端口与55389之间的四次来回就是&quot;四次挥手&quot;过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;”第一次挥手”客户端发送的FIN请求释放连接报文以[FIN，ACK]作为标志位，其中报文序号Seq=2445；确认号Ack=558；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：这里与“第三次握手”的ACK并不是表示确认的ACK报文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;”第二次挥手”服务器端返回的ACK确认报文以[ACK]作为标志位；其中报文序号Seq=558；确认号Ack=2246；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;”第三次挥手”服务器端继续返回的FIN同意释放连接报文以[FIN，ACK]作为标志位；其中报文序号Seq=558；确认号Ack=2246；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;”第四次挥手”客户端发出的ACK确认接收报文以[ACK]作为标志位；其中报文序号Seq=2446；确认号Ack=559；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;后一次“挥手”传输报文中的序号Seq值等于前一次&quot;握手&quot;传输报文中的确认号Ack值；&lt;/p&gt;
&lt;p&gt;后一次“挥手”传输报文中的确认号Ack值等于前一次&quot;握手&quot;传输报文中的序号Seq值；&lt;/p&gt;
&lt;p&gt;故这是连续的“四次挥手”过程，与前面的分析相符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.73469387755102&quot;&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38950316/article/details/81087809&quot;&gt;TCP的三次握手与四次挥手理解及面试题（很全面）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/alva-rabbit-hole/p/10081169.html&quot;&gt;深入浅出图解【计算机网络】 之 【TCP可靠传输的实现: 三次握手+滑动窗口】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.bubuko.com/infodetail-2526697.html&quot;&gt;使用 WireShark 分析 TCP/IP 三次握手 和 四次挥手&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 13 Dec 2019 16:05:00 +0000</pubDate>
<dc:creator>AhuntSun</dc:creator>
<og:description>上文链接： '详解TCP连接的“三次握手”与“四次挥手”(上)' 四、TCP的四次挥手（Four Way Wavehand） 0.前言 对于'三次握手'我们耳熟能详，因为其相对的简单。但是，我们却不常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AhuntSun-blog/p/12037852.html</dc:identifier>
</item>
</channel>
</rss>