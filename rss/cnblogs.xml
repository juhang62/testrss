<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JVM 第五篇：命令行 JVM 故障处理工具 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/13806788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/13806788.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/java_header.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文内容过于硬核，建议有 Java 相关经验人士阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-引言&quot;&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;虽然我们前面介绍了各种图形化 JVM 故障处理工具，但是很多情况下，我们在处理问题的时候并没有图形化的操作环境可以使用，这时候，就需要用到 JDK 为我们提供的命令行工具了。&lt;/p&gt;
&lt;h2 id=&quot;2-jps-虚拟机进程状况工具&quot;&gt;2. jps: 虚拟机进程状况工具&lt;/h2&gt;
&lt;p&gt;jps 绝对是使用频率最高的 JDK 命令行工具，它的作用是可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（ Main Class ， main() 函数所在的类）名称以及这些进程的本地虚拟机唯一 ID （ LVMID ， LocalVirtual Machine Identifier ）。&lt;/p&gt;
&lt;p&gt;命令格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jps [options ] [ hostid ] 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行样例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;PS D:\&amp;gt; jps -l
5200 org.jetbrains.jps.cmdline.Launcher
16868 jdk.jcmd/sun.tools.jps.Jps
19368 org.jetbrains.idea.maven.server.RemoteMavenServer36
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我本机，有三个 JVM 进程， 5200 和 19368 是软件 IDEA 的进程，从类名上是可以看出来的，还有一个是 jps 本身的这个 JVM 进程。&lt;/p&gt;
&lt;p&gt;列举一些常用参数：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;可选项&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;输出完全的包名，应用主类名，jar的完全路径名。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;-q&lt;/td&gt;
&lt;td&gt;仅输出 VM 标识符，不包括 classname , jar name , arguments in main method 。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;输出 main method 的参数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;输出 JVM 参数。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;3-jstat-虚拟机统计信息监视工具&quot;&gt;3. jstat: 虚拟机统计信息监视工具&lt;/h2&gt;
&lt;p&gt;jstat（JVM Statistics Monitoring Tool） 是用于监视虚拟机各种运行状态信息的命令行工具。&lt;/p&gt;
&lt;p&gt;位于 JDK 的 bin 目录下，主要利用 JVM 内建的指令对 Java 应用程序的资源和性能进行实时的命令行的监控，包括了对 Heap size 和垃圾回收状况的监控。&lt;/p&gt;
&lt;p&gt;jstat 工具特别强大，有众多的可选项，详细查看堆内各个部分的使用量，以及加载类的数量。使用时，需加上查看进程的进程 id ，和所选参数。参考格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jstat -options 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以列出当前 JVM 版本支持的选项，常见的有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-class (类加载器)&lt;/li&gt;
&lt;li&gt;-compiler (JIT)&lt;/li&gt;
&lt;li&gt;-gc (GC堆状态)&lt;/li&gt;
&lt;li&gt;-gccapacity (各区大小)&lt;/li&gt;
&lt;li&gt;-gccause (最近一次GC统计和原因)&lt;/li&gt;
&lt;li&gt;-gcnew (新区统计)&lt;/li&gt;
&lt;li&gt;-gcnewcapacity (新区大小)&lt;/li&gt;
&lt;li&gt;-gcold (老区统计)&lt;/li&gt;
&lt;li&gt;-gcoldcapacity (老区大小)&lt;/li&gt;
&lt;li&gt;-gcpermcapacity (永久区大小)&lt;/li&gt;
&lt;li&gt;-gcutil (GC统计汇总)&lt;/li&gt;
&lt;li&gt;-printcompilation (HotSpot编译统计)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如我想查看一下我本地的 IDEA 进程的 GC 情况汇总，可以使用命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PS D:\&amp;gt; jstat -gcutil 5200
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT
  0.00  43.29  20.83   0.08  97.05  93.67      1    0.003     0    0.000     -        -    0.003
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询结果表明：&lt;/p&gt;
&lt;p&gt;我的 IDEA 的新生代 Eden 区（ E ，表示 Eden ）使用了 20.83% 的空间， 2 个 Survivor 区（ S0 、 S1 ，表示 Survivor0 、 Survivor1 ），S0 是空的，而 S1 使用了 43.29% ，老年代（ O ，表示 Old ）使用了 0.08% 的空间，元空间（ M ， 表示 Metaspace ）使用了 97.05% 的空间。&lt;/p&gt;
&lt;p&gt;程序运行以来共发生 Minor GC （ YGC ，表示 Young GC ） 1 次，总耗时 0.003 秒，发生 Full GC （ FGC ，表示 Full GC ）0 次，总耗时（ FGCT ，表示 Full GC Time ）为 0 秒，所有 GC 总耗时（ GCT ，表示 GC Time ）为 0.003 秒。&lt;/p&gt;
&lt;h2 id=&quot;4-jinfo-java-配置信息工具&quot;&gt;4. jinfo: Java 配置信息工具&lt;/h2&gt;
&lt;p&gt;jinfo（Configuration Info for Java）可以用来查看正在运行的 Java 应用程序的扩展参数，包括 Java System 属性和 JVM 命令行参数；也可以动态的修改正在运行的 JVM 一些参数。当系统崩溃时， jinfo 可以从 core 文件里面知道崩溃的 Java 应用程序的配置信息。&lt;/p&gt;
&lt;p&gt;使用 jps 命令的 -v 参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用 jinfo 的 -flag 选项进行查询了。&lt;/p&gt;
&lt;p&gt;jinfo 命令格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jinfo [option] pid
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询样例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PS D:\&amp;gt; jinfo -flags 5200
VM Flags:
-XX:CICompilerCount=4 -XX:InitialHeapSize=268435456 -XX:MaxHeapSize=734003200 -XX:MaxNewSize=244318208 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=89128960 -XX:OldSize=179306496 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5-jmap-java-内存映像工具&quot;&gt;5. jmap: Java 内存映像工具&lt;/h2&gt;
&lt;p&gt;jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为 heapdump 或 dump 文件）。&lt;/p&gt;
&lt;p&gt;它也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。&lt;/p&gt;
&lt;p&gt;jmap 命令格式:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jinfo [option] pid
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;option 可选的参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;no option： 查看进程的内存映像信息,类似 Solaris pmap 命令。&lt;/li&gt;
&lt;li&gt;heap： 显示 Java 堆详细信息&lt;/li&gt;
&lt;li&gt;histo[:live]： 显示堆中对象的统计信息&lt;/li&gt;
&lt;li&gt;clstats：打印类加载器信息&lt;/li&gt;
&lt;li&gt;finalizerinfo： 显示在 F-Queue 队列等待 Finalizer 线程执行 finalizer 方法的对象&lt;/li&gt;
&lt;li&gt;dump:：生成堆转储快照&lt;/li&gt;
&lt;li&gt;F： 当 -dump 没有响应时，使用 -dump 或者 -histo 参数. 在这个模式下, live 子参数无效.&lt;/li&gt;
&lt;li&gt;help：打印帮助信息&lt;/li&gt;
&lt;li&gt;J：指定传递给运行 jmap 的 JVM 的参数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PS D:\&amp;gt; jmap -dump:format=b,file=idea.bin 5200
Dumping heap to D:\idea.bin ...
Heap dump file created
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6-jhat-虚拟机堆转储快照分析工具&quot;&gt;6. jhat: 虚拟机堆转储快照分析工具&lt;/h2&gt;
&lt;p&gt;JDK 提供jhat（JVM Heap Analysis Tool）命令与 jmap 搭配使用，来分析 jmap 生成的堆转储快照。 jhat 内置了一个微型的 HTTP/Web 服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。&lt;/p&gt;
&lt;p&gt;使用命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PS D:\&amp;gt; jhat idea.bin
Reading from idea.bin...
Dump file created Thu Oct 08 18:54:37 CST 2020
Snapshot read, resolving...
Resolving 147921 objects...
Chasing references, expect 29 dots.............................
Eliminating duplicate references.............................
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在浏览器上访问地址 &lt;a href=&quot;http://localhost:7000/&quot;&gt;http://localhost:7000/&lt;/a&gt; 可以看到分析结果，不过这个分析工具一般没什么人会用，因为功能太过简陋了。&lt;/p&gt;
&lt;p&gt;相比较而言，我们可以使用 VisualVM 或者 Eclipse Memory Analyzer 再或者 IBM HeapAnalyzer 等工具分析刚才 jmap 产生的 dump 文件。&lt;/p&gt;
&lt;h2 id=&quot;7-jstack-java-堆栈跟踪工具&quot;&gt;7. jstack: Java 堆栈跟踪工具&lt;/h2&gt;
&lt;p&gt;jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为 threaddump 或者 javacore 文件）。&lt;/p&gt;
&lt;p&gt;线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。&lt;/p&gt;
&lt;p&gt;jstack 命令格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jstack [option] pid
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;option 的可选参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-F: 当正常输出的请求不被响应时，强制输出线程堆栈。&lt;/li&gt;
&lt;li&gt;-l: 除堆栈外，显示关于锁的附加信息。&lt;/li&gt;
&lt;li&gt;-m: 如果调用到本地方法的话，可以显示 C/C++ 的堆栈。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PS D:\&amp;gt; jstack -l 5200
2020-10-08 19:03:39
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):

&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x00000000037b8000 nid=0x3f20 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
        - None
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 13 Oct 2020 00:55:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>本文内容过于硬核，建议有 Java 相关经验人士阅读。 1. 引言 虽然我们前面介绍了各种图形化 JVM 故障处理工具，但是很多情况下，我们在处理问题的时候并没有图形化的操作环境可以使用，这时候，就需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/13806788.html</dc:identifier>
</item>
<item>
<title>.NET Standard 来日苦短去日长 - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/13806646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13806646.html</guid>
<description>&lt;blockquote readability=&quot;3.7671232876712&quot;&gt;
&lt;p&gt;作者：Richard&lt;br/&gt;翻译：精致码农-王亮&lt;br/&gt;原文：&lt;a href=&quot;http://dwz.win/Q4h&quot;&gt;http://dwz.win/Q4h&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自从 &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/introducing-net-5/&quot;&gt;.NET 5 宣贯&lt;/a&gt;以来，很多人都在问这对 .NET Standard 意味着什么，它是否仍然重要。在这篇文章中，我将解释 .NET 5 是如何改进代码共用并取代 .NET Standard 的，我还将介绍什么情况下你仍然需要 .NET Standard。&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;
&lt;p&gt;.NET 5 将是一个具有统一功能和 API 的单一产品，可用于 Windows 桌面应用程序、跨平台移动应用程序、控制台应用程序、云服务和网站。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202010/191097-20201013083252194-349045795.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了更好地说明这一点，我们更新了这篇&lt;sup&gt;[1]&lt;/sup&gt;关于 TFM (Target Framework Names) 介绍的文章（译文：&lt;a href=&quot;https://mp.weixin.qq.com/s/hVjfxaJkULZDFlmlofADQA&quot;&gt;.NET 5 中 Target Framework 详解&lt;/a&gt;），现支持的 TFM 如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;.net5.0&lt;/code&gt;，表示代码可在任意平台运行，它合并并替换了 &lt;code&gt;netcoreapp&lt;/code&gt; 和 &lt;code&gt;netstandard&lt;/code&gt; 这两个名称。这个 TFM 通常只包括跨平台的技术（除了一些为了满足实用性而作出让步的 API，就像我们在 .NET Standard 中所做的那样）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net5.0-windows&lt;/code&gt;（还有后面会增加的&lt;code&gt;net6.0-android&lt;/code&gt; 和 &lt;code&gt;net6.0-ios&lt;/code&gt;），这些 TFM 表示 .NET 5 特定于操作系统的风格，包含 &lt;code&gt;net5.0&lt;/code&gt; 和特定于操作系统的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们&lt;strong&gt;不会再发布 .NET Standard 的新版本&lt;/strong&gt;，但是 .NET 5 和所有未来的版本将继续支持 .NET Standard 2.1 和更早的版本。你应该将 &lt;code&gt;net5.0&lt;/code&gt;（和未来的版本）视为共享代码的基础。&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;net5.0&lt;/code&gt; 是所有这些新 TFM 的共用的基础，这意味着运行时、库和新的语言特性都会围绕这个版本号进行协调。例如，为了使用 C# 9，你需要使用 &lt;code&gt;net5.0&lt;/code&gt; 或 &lt;code&gt;net5.0-windows&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;如何选择-target&quot;&gt;如何选择 Target&lt;/h2&gt;
&lt;p&gt;.NET 5 和所有未来的版本将继续支持 .NET Standard 2.1 和更早的版本，从 .NET Standard 重新 Target 到 .NET 5 的唯一原因是为了获得更多运行时特性、语言特性或 API 支持。所以，你可以把 .NET 5 想象成 .NET Standard 的 vNext。&lt;/p&gt;
&lt;p&gt;那新代码呢？该从 .NET Standard 2.0 开始还是直接从 .NET 5 开始？这得视情况而定。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;应用程序组件&lt;/strong&gt;，如果你要将你的应用程序以类库的形式分解成多个组件，我建议将 &lt;code&gt;netX.Y&lt;/code&gt; 作为 TFM，&lt;code&gt;netX.Y&lt;/code&gt; 中的 &lt;code&gt;X.Y&lt;/code&gt; 是应用程序（或多个应用程序）的 .NET 最低版本号。为了简单起见，你可能希望所有组成你的应用程序的 Project 都使用相同的 .NET 版本，因为这样可以保证各处的代码都可以使用相同的 BCL 特性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可重用库&lt;/strong&gt;，如果你正在构建计划在 NuGet 上发布的可重用库，你将需要考虑适用范围和可用新特性之间的权衡。.NET Standard 2.0 是 .NET Framework 支持的最高 .NET Standard 版本，所以它可以满足你的大部分使用场景。我们通常建议不要将 Target 锁定在 .NET Standard 1.x 上，因为不值得再为此增添不必要的麻烦。如果你不需要支持 .NET Framwork，那么你可以选择 .NET Standard 2.1 或者 .NET 5，大多数代码可能可以跳过 .NET Standard 2.1 直接转到 .NET 5。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，你应该怎么做呢？我的建议是，已被广泛使用的库可能需要同时提供 .NET Standard 2.0 和 .NET 5 支持。支持 .NET Standard 2.0 将使你的库适用性更广，而支持 .NET 5 则确保你可以为已经在 .NET 5 上的用户使用最新的平台特性。&lt;/p&gt;
&lt;p&gt;几年后，可重用库的选择将只涉及 &lt;code&gt;netX.Y&lt;/code&gt; 版本，这基本上是构建 .NET 库的一惯做法——你通常要支持一段时间较老的版本，以确保没有升级最新 .NET 版本的用户依然可以使用你的库。&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 .NET Framework 和所有其他平台之间共享代码，使用 &lt;code&gt;netstandard2.0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 Mono、Xamarin 和 .NET Core 3.x 之间共享代码，使用 &lt;code&gt;netstandard2.1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;往后的共享代码，使用 &lt;code&gt;net5.0&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;net-5-如何解决-net-standard-存在的问题&quot;&gt;.NET 5 如何解决 .NET Standard 存在的问题&lt;/h2&gt;
&lt;p&gt;.NET Standard 使得创建适用于所有 .NET 平台的库变得更加容易，但是 .NET Standard 仍然存在三个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它的版本更新很慢&lt;sup&gt;[2]&lt;/sup&gt;，这意味着你不能轻松地使用最新的特性。&lt;/li&gt;
&lt;li&gt;它需要一个解码环&lt;sup&gt;[3]&lt;/sup&gt;来将版本映射到 .NET 实现。&lt;/li&gt;
&lt;li&gt;它公开了特定于平台的特性&lt;sup&gt;[4]&lt;/sup&gt;，这意味着你不能静态地验证代码是否真正可移植。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;让我们看看 .NET 5 将如何解决这三个问题。&lt;/p&gt;
&lt;h2 id=&quot;问题-1：net-standard-版本更新慢&quot;&gt;问题 1：.NET Standard 版本更新慢&lt;/h2&gt;
&lt;p&gt;在设计 .NET Standard&lt;sup&gt;[5]&lt;/sup&gt; 时，.NET 平台还没有在实现层次上融合，这使得编写需要在不同环境下工作的代码变得困难，因为不同的工作代码使用的是不同的 .NET 实现。&lt;/p&gt;
&lt;p&gt;.NET Standard 的目标是统一基础类库(BCL)的特性集，这样你就可以编写一个可以在任何地方运行的单一库。这为我们提供了很好的服务：前 1000 个软件包中有超过 77% 支持 .NET Standard。如果我们看看 NuGet.org 上所有在过去 6 个月里更新过的软件包，采用率是 58%。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202010/191097-20201013083339856-1706372255.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是只标准化 API 就会产生额外的付出，它要求我们在添加新 API 时进行协调——这一直在发生。.NET 开源社区（包括.NET 团队）通过提供新的语言特性、可用性改进、新的交叉(cross-cutting)功能（如 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;）或支持新的数据格式或网络协议，不断对 BCL 进行创新。&lt;/p&gt;
&lt;p&gt;而我们虽然可以以 NuGet 包的形式提供新的类型，但不能以这种方式在现有类型上提供新的 API。所以，从一般意义上讲，BCL 的创新需要发布新版本的 .NET 标准。&lt;/p&gt;
&lt;p&gt;在 .NET Standard 2.0 之前，这并不是一个真正的问题，因为我们只对现有的 API 进行标准化。但在 .NET Standard 2.1 中，我们对全新的 API 进行了标准化，这也是我们看到相当多摩擦的地方。&lt;/p&gt;
&lt;p&gt;这种摩擦从何而来？&lt;/p&gt;
&lt;p&gt;.NET 标准是一个 API 集，所有的.NET 实现都必须支持，所以它有一个编辑方面&lt;sup&gt;[6]&lt;/sup&gt;的问题，所有的 API 必须由 .NET Standard 审查委员会&lt;sup&gt;[7]&lt;/sup&gt;审查。该委员会由 .NET 平台实现者以及 .NET 社区的代表组成。其目标是只对我们能够真正在所有当前和未来的 .NET 平台中实现的 API 进行标准化。这些审查是必要的，因为 .NET 协议栈有不同的实现，有不同的限制。&lt;/p&gt;
&lt;p&gt;我们预测到了这种类型的摩擦，这就是为什么我们很早就说过，.NET 标准将只对至少一个 .NET 实现中已经推出的 API 进行标准化。这乍一看似乎很合理，但随后你就会意识到，.NET Standard 不可能频繁地更新。所以，如果一个功能错过了某个特定的版本，你可能要等上几年才能使用，甚至可能要等更久，直到这个版本的 .NET Standard 得到广泛支持。&lt;/p&gt;
&lt;p&gt;我们觉得对于某些特性来说，机会损失太大，所以我们做了一些不自然的行为，将还没有推出的 API 标准化（比如 &lt;code&gt;AsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;）。对所有的功能都这样做实在是太昂贵了，这也是为什么有不少功能还是错过了 .NET Standard 2.1 这趟列车的原因（比如新的硬件特性）。&lt;/p&gt;
&lt;p&gt;但如果有一个单一的代码库呢？如果这个代码库必须支持所有与 .NET 至今所实现功能有所不同的特性，比如同时支持及时编译（JIT）和超前编译（AOT）呢？&lt;/p&gt;
&lt;p&gt;与其在事后才进行这些审查，不如从一开始就将所有这些方面作为功能设计的一部分。在这样的世界里，标准化的 API 集从构造上来说，就是通用的 API 集。当一个功能实现后，因为代码库是共享的，所以大家就已经可以使用了。&lt;/p&gt;
&lt;h2 id=&quot;问题-2：net-standard-需要解码环&quot;&gt;问题 2：.NET Standard 需要解码环&lt;/h2&gt;
&lt;p&gt;将 API 集与它的实现分离，不仅仅是减缓了 API 的可用性，这也意味着我们需要将 .NET Standard 版本映射到它们的实现上&lt;sup&gt;[3]&lt;/sup&gt;。作为一个长期以来不得不向许多人解释这个表格的人，我已经意识到这个看似简单的想法是多么复杂。我们已经尽力让它变得更简单，但最终，这种复杂性是与生俱来的，因为 API 集和实现是独立发布的。&lt;/p&gt;
&lt;p&gt;我们统一了 .NET 平台，在它们下面又增加了一个合成平台，代表了通用的 API 集。从很现实的意义上来说，这幅漫画是很到位的表达了这个痛点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202010/191097-20201013083430367-1482509685.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不能实现真正意义上的合并，我们就无法解决这个问题，这正是 .NET 5 所做的：它提供了一个统一的实现，各方都建立在相同的基础上，从而得到相同的 API 和版本号。&lt;/p&gt;
&lt;h2 id=&quot;问题-3：net-standard-公开了特定平台-api&quot;&gt;问题 3：.NET Standard 公开了特定平台 API&lt;/h2&gt;
&lt;p&gt;当我们设计 .NET Standard 时，为了避免过多地破坏库的生态系统，我们不得不做出让步&lt;sup&gt;[4]&lt;/sup&gt;。也就是说，我们不得不包含一些 Windows 专用的 API（如文件系统 ACL、注册表、WMI 等）。今后，我们将避免在 &lt;code&gt;net5.0&lt;/code&gt;、&lt;code&gt;net6.0&lt;/code&gt; 和未来的版本中加入特定平台的 API。然而，我们不可能预测未来。例如，我们最近为 Blazor WebAssembly 增加了一个新的 .NET 运行环境，在这个环境中，一些原本跨平台的 API（如线程或进程控制）无法在浏览器的沙箱中得到支持。&lt;/p&gt;
&lt;p&gt;很多人抱怨说，这类 API 感觉就像“地雷”--代码编译时没有错误，因此看起来可以移植到任何平台上，但当运行在一个没有给定 API 实现的平台上时，就会出现运行时错误。&lt;/p&gt;
&lt;p&gt;从 .NET 5 开始，我们将提供随 SDK 发布的默认开启的分析器和代码修复器。它包含平台兼容性分析器，可以检测无意中使用了目标平台并不支持的 API。这个功能取代了 &lt;code&gt;Microsoft.DotNet.Analyzers.Compatibility&lt;/code&gt; NuGet 包。&lt;/p&gt;
&lt;p&gt;让我们先来看看 Windows 特有的 API。&lt;/p&gt;
&lt;h3 id=&quot;处理-windows-特定-api&quot;&gt;处理 Windows 特定 API&lt;/h3&gt;
&lt;p&gt;当你创建一个 Target 为 &lt;code&gt;net5.0&lt;/code&gt; 为目标的项目时，你可以引用 &lt;code&gt;Microsoft.Win32.Registry&lt;/code&gt; 包。但当你开始使用它时：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;private static string GetLoggingDirectory()
{
    using (RegistryKey key = Registry.CurrentUser.OpenSubKey(@&quot;Software\Fabrikam&quot;))
    {
        if (key?.GetValue(&quot;LoggingDirectoryPath&quot;) is string configuredPath)
            return configuredPath;
    }

    string exePath = Process.GetCurrentProcess().MainModule.FileName;
    string folder = Path.GetDirectoryName(exePath);
    return Path.Combine(folder, &quot;Logging&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会得到以下警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;CA1416: 'RegistryKey.OpenSubKey(string)' is supported on 'windows'
CA1416: 'Registry.CurrentUser' is supported on 'windows'
CA1416: 'RegistryKey.GetValue(string?)' is supported on 'windows'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你有三个选择来处理这些警告。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;调用保护：在调用 API 之前，你可以使用 &lt;code&gt;OperatingSystem.IsWindows()&lt;/code&gt; 来检查当前运行环境是否是 Windows 系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将调用标记为 Windows 专用：在某些情况下，通过 &lt;code&gt;[SupportedOSPlatform(&quot;windows&quot;)]&lt;/code&gt; 将调用成员标记为特定平台也有一定的意义。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;删除代码：一般来说，这不是你想要的，因为这意味着当你的代码被 Windows 用户使用时，你会失去保真度(fidelity)。但对于存在跨平台替代方案的情况，你应该尽可能使用跨平台方案，而不是平台特定的 API。例如，你可以使用一个 XML 配置文件来代替使用注册表。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;抑制警告：当然，你可以通过 &lt;code&gt;.editorconfig&lt;/code&gt; 或 &lt;code&gt;#pragma warning disable&lt;/code&gt; 来抑制警告。然而，当使用特定平台的 API 时，你应该更喜欢选项 (1) 和 (2)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了调用保护，可以使用 &lt;code&gt;System.OperatingSystem&lt;/code&gt; 类上的新静态方法，示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;private static string GetLoggingDirectory()
{
    if (OperatingSystem.IsWindows())
    {
        using (RegistryKey key = Registry.CurrentUser.OpenSubKey(@&quot;Software\Fabrikam&quot;))
        {
            if (key?.GetValue(&quot;LoggingDirectoryPath&quot;) is string configuredPath)
                return configuredPath;
        }
    }

    string exePath = Process.GetCurrentProcess().MainModule.FileName;
    string folder = Path.GetDirectoryName(exePath);
    return Path.Combine(folder, &quot;Logging&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要将你的代码标记为 Windows 专用，请应用新的 &lt;code&gt;SupportedOSPlatform&lt;/code&gt; 属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[SupportedOSPlatform(&quot;windows&quot;)]
private static string GetLoggingDirectory()
{
    using (RegistryKey key = Registry.CurrentUser.OpenSubKey(@&quot;Software\Fabrikam&quot;))
    {
        if (key?.GetValue(&quot;LoggingDirectoryPath&quot;) is string configuredPath)
            return configuredPath;
    }

    string exePath = Process.GetCurrentProcess().MainModule.FileName;
    string folder = Path.GetDirectoryName(exePath);
    return Path.Combine(folder, &quot;Logging&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这两种情况下，使用注册表的警告都会消失。&lt;/p&gt;
&lt;p&gt;关键的区别在于，在第二个例子中，分析器现在会对 &lt;code&gt;GetLoggingDirectory()&lt;/code&gt; 的调用发出警告，因为它现在被认为是 Windows 特有的 API。换句话说，你把平台检查的要求转给调用者放去做了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[SupportedOSPlatform]&lt;/code&gt; 属性可以应用于成员、类型和程序集级别。这个属性也被 BCL 本身使用，例如，程序集 &lt;code&gt;Microsoft.Win32.Registry&lt;/code&gt; 就应用了这个属性，这也是分析器最先就知道注册表是 Windows 特定 API 方法的原因。&lt;/p&gt;
&lt;p&gt;请注意，如果你的目标是 &lt;code&gt;net5.0-windows&lt;/code&gt;，这个属性会自动应用到你的程序集中。这意味着使用 &lt;code&gt;net5.0-windows&lt;/code&gt; 的 Windows 专用 API 永远不会产生任何警告，因为你的整个程序集被认为是 Windows 专用的。&lt;/p&gt;
&lt;h3 id=&quot;处理-blazor-webassembly-不支持的-api&quot;&gt;处理 Blazor WebAssembly 不支持的 API&lt;/h3&gt;
&lt;p&gt;Blazor WebAssembly 项目在浏览器沙盒内运行，这限制了你可以使用的 API。例如，虽然线程和进程创建都是跨平台的 API，但我们无法让这些 API 在 Blazor WebAssembly 中工作，它们会抛出 &lt;code&gt;PlatformNotSupportedException&lt;/code&gt;。我们已经用 &lt;code&gt;[UnsupportedOSPlatform(&quot;browser&quot;)]&lt;/code&gt; 标记了这些 API。&lt;/p&gt;
&lt;p&gt;假设你将 &lt;code&gt;GetLoggingDirectory()&lt;/code&gt; 方法复制并粘贴到 Blazor WebAssembly 应用程序中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;private static string GetLoggingDirectory()
{
    //...

    string exePath = Process.GetCurrentProcess().MainModule.FileName;
    string folder = Path.GetDirectoryName(exePath);
    return Path.Combine(folder, &quot;Logging&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你将得到以下警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;CA1416 'Process.GetCurrentProcess()' is unsupported on 'browser'
CA1416 'Process.MainModule' is unsupported on 'browser'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以用与 Windows 特定 API 基本相同的做法来处理这些警告。&lt;/p&gt;
&lt;p&gt;你可以对调用进行保护：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;private static string GetLoggingDirectory()
{
    //...

    if (!OperatingSystem.IsBrowser())
    {
        string exePath = Process.GetCurrentProcess().MainModule.FileName;
        string folder = Path.GetDirectoryName(exePath);
        return Path.Combine(folder, &quot;Logging&quot;);
    }
    else
    {
        return string.Empty;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者你可以将该成员标记为不被 Blazor WebAssembly 支持：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[UnsupportedOSPlatform(&quot;browser&quot;)]
private static string GetLoggingDirectory()
{
    //...

    string exePath = Process.GetCurrentProcess().MainModule.FileName;
    string folder = Path.GetDirectoryName(exePath);
    return Path.Combine(folder, &quot;Logging&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于浏览器沙盒的限制性相当大，所以并不是所有的类库和 NuGet 包都能在 Blazor WebAssembly 中运行。此外，绝大多数的库也不应该支持在 Blazor WebAssembly 中运行。&lt;/p&gt;
&lt;p&gt;这就是为什么针对 &lt;code&gt;net5.0&lt;/code&gt; 的普通类库不会看到不支持 Blazor WebAssembly API 的警告。你必须在项目文件中添加 &lt;code&gt;&amp;lt;SupportedPlatform&amp;gt;&lt;/code&gt; 项，明确表示你打算在 Blazor WebAssembly 中支持您的项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net5.0&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;SupportedPlatform Include=&quot;browser&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你正在构建一个 Blazor WebAssembly 应用程序，你不必这样做，因为 &lt;code&gt;Microsoft.NET.Sdk.BlazorWebAssembly&lt;/code&gt; SDK 会自动做到这一点。&lt;/p&gt;
&lt;h2 id=&quot;net-5-是-net-standard-和-net-core-的结合&quot;&gt;.NET 5 是 .NET Standard 和 .NET Core 的结合&lt;/h2&gt;
&lt;p&gt;.NET 5 及后续版本将是一个单一的代码库，支持桌面应用、移动应用、云服务、网站以及未来的任何 .NET 运行环境。&lt;/p&gt;
&lt;p&gt;你可能会想“等等，这听起来很不错，但如果有人想创建一个全新的实现呢”。这也是可以的。但几乎没有人会从头开始一个新的实现。最有可能的是，它将是当前代码库（dotnet/runtime&lt;sup&gt;[8]&lt;/sup&gt;）的一个分支。例如，Tizen（三星智能家电平台）使用的是 .NET Core，只做了细小的改动，并在上面使用了三星特有的应用模型。&lt;/p&gt;
&lt;p&gt;Fork 保留了合并关系，这使得维护者可以不断从 dotnet/runtime&lt;sup&gt;[8]&lt;/sup&gt; 仓库中拉取新的变化，在不受其变化影响的领域受益于 BCL 创新，这和 Linux 发行版的工作方式非常相似。&lt;/p&gt;
&lt;p&gt;当然，在某些情况下，人们可能希望创建一个非常不同的“种类”的 .NET，比如一个没有当前 BCL 的最小运行时。但这意味着它不能利用现有的 .NET 库生态系统，它也不会实现 .NET Standard。我们一般对这个方向的追求不感兴趣，但 .NET Standard 和 .NET Core 的结合并不妨碍这一点，也不会增加难度。&lt;/p&gt;
&lt;h2 id=&quot;net-版本&quot;&gt;.NET 版本&lt;/h2&gt;
&lt;p&gt;作为一个库作者，你可能想知道 .NET 5 什么时候能得到广泛支持。今后，我们将在每年的 11 月发布 .NET 新版本，每隔一年发布一次长期支持（LTS）版本。&lt;/p&gt;
&lt;p&gt;.NET 5 将在 2020 年 11 月正式发布，而 .NET 6 将在 2021 年 11 月作为 LTS 发布。我们创建了这个固定的时间表，使你更容易规划您的更新（如果你是应用程序开发人员），并预测对支持的 .NET 版本的需求（如果你是库开发人员）。&lt;/p&gt;
&lt;p&gt;得益于 .NET Core 的并行安装（译注：一台机器可同时安装多个 .NET Core 版本，且向下兼容），它的新版本被采用速度相当快，其中 LTS 版本最受欢迎。事实上，.NET Core 3.1 是有史以来采用最快的 .NET 版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202010/191097-20201013083538446-1264174310.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的期望是，每次发布（大版本）时，我们都会把所有框架名称连在一起发布。例如，它可能看起来像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202010/191097-20201013083547955-737087131.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这意味着你心里可以有个预期，无论我们在 BCL 中做了什么创新，你都能在所有的应用模型中使用它，无论它们运行在哪个平台上。这也意味着，只要你运行最新版本的库，你总是可以在所有的应用模型消费最新的 &lt;code&gt;net&lt;/code&gt; 框架带来的库。&lt;/p&gt;
&lt;p&gt;这种模式消除了围绕 .NET Standard 版本的复杂性，因为每次我们发布时，你都可以假设所有的平台都会立即和完全支持新版本，而我们通过使用前缀命名惯例来巩固这一承诺。&lt;/p&gt;
&lt;p&gt;.NET 的新版本可能会添加对其他平台的支持。例如，我们将通过 .NET 6 增加对 Android 和 iOS 的支持。相反，我们可能会停止支持那些不再相关的平台。这一点可以通过在 .NET 6 中不存在的 &lt;code&gt;net5.0-someoldos&lt;/code&gt; 目标框架来说明。我们目前没有放弃一个平台支持的计划，那将是一个大问题，这不是预期的，若有我们会提前很久宣布。这也是我们对 .NET Standard 的模式，例如，没有新版本的 Windows Phone 实现了后面的 .NET Standard 版本。&lt;/p&gt;
&lt;h2 id=&quot;为什么没有-webassembly-的-tfm&quot;&gt;为什么没有 WebAssembly 的 TFM&lt;/h2&gt;
&lt;p&gt;我们最初考虑为 WebAssembly 添加 TFM，如 &lt;code&gt;net5.0-wasm&lt;/code&gt;。后来我们决定不这么做，原因如下：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;WebAssembly 更像是一个指令集（如 x86 或 x64），而不是像一个操作系统，而且我们一般不提供不同架构之间有分歧的 API。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;WebAssembly 在浏览器沙箱中的执行模型是一个关键的差异化，但我们决定只将其建模为运行时检查更有意义。类似于你对 Windows 和 Linux 的检查方式，你可以使用 OperatingSystem 类型。由于与指令集无关，所以该方法被称为 &lt;code&gt;IsBrowser()&lt;/code&gt; 而不是 &lt;code&gt;IsWebAssembly()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;WebAssembly 有运行时标识符(RID)&lt;sup&gt;[9]&lt;/sup&gt;，称为 &lt;code&gt;browser&lt;/code&gt; 和 &lt;code&gt;browser-wasm&lt;/code&gt;。它们允许包的作者在浏览器中针对 WebAssembly 部署不同的二进制文件。这对于需要事先编译成 WebAssembly 的本地代码特别有用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上所述，我们已经标记了在浏览器沙盒中不支持的 API，例如 &lt;code&gt;System.Diagnostics.Process&lt;/code&gt;。如果你从浏览器应用内部使用这些 API，你会得到一个警告，告诉你这个 API 是不支持的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;net5.0&lt;/code&gt; 是为能在任何平台运行的代码而设计的，它结合并取代了 &lt;code&gt;netcoreapp&lt;/code&gt; 和 &lt;code&gt;netstandard&lt;/code&gt; 名称。我们还有针对特定平台的框架，比如 &lt;code&gt;net5.0-windows&lt;/code&gt;（后面还有 &lt;code&gt;net6.0-android&lt;/code&gt;，&lt;code&gt;net6.0-ios&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;由于标准和它的实现之间没有区别，你将能够比使用 .NET Standard 更快地利用新功能。而且由于命名惯例，你将能够很容易地知道谁可以使用一个给定的库--而无需查阅 .NET Standard 版本表。&lt;/p&gt;
&lt;p&gt;虽然 .NET Standard 2.1 将是 .NET Standard 的最后一个版本，但 .NET 5 和所有未来的版本将继续支持.NET Standard 2.1 和更早的版本。你应该将 &lt;code&gt;net5.0&lt;/code&gt;（以及未来的版本）视为未来共享代码的基础。&lt;/p&gt;
&lt;p&gt;祝，编码愉快！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;文中相关链接：&lt;/p&gt;
&lt;p&gt;[1].&lt;a href=&quot;https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md&quot;&gt;https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md&lt;/a&gt;&lt;br/&gt;[2].&lt;a href=&quot;https://github.com/dotnet/standard/tree/master/docs/governance#process&quot;&gt;https://github.com/dotnet/standard/tree/master/docs/governance#process&lt;/a&gt;&lt;br/&gt;[3].&lt;a href=&quot;https://dotnet.microsoft.com/platform/dotnet-standard#versions&quot;&gt;https://dotnet.microsoft.com/platform/dotnet-standard#versions&lt;/a&gt;&lt;br/&gt;[4].&lt;a href=&quot;https://github.com/dotnet/standard/blob/master/docs/faq.md#why-do-you-include-apis-that-dont-work-everywhere&quot;&gt;https://github.com/dotnet/standard/blob/master/docs/faq.md#why-do-you-include-apis-that-dont-work-everywhere&lt;/a&gt;&lt;br/&gt;[5].&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/introducing-net-standard/&quot;&gt;https://devblogs.microsoft.com/dotnet/introducing-net-standard/&lt;/a&gt;&lt;br/&gt;[6].&lt;a href=&quot;https://github.com/dotnet/standard/tree/master/docs/governance#process&quot;&gt;https://github.com/dotnet/standard/tree/master/docs/governance#process&lt;/a&gt;&lt;br/&gt;[7].&lt;a href=&quot;https://github.com/dotnet/standard/blob/master/docs/governance/board.md&quot;&gt;https://github.com/dotnet/standard/blob/master/docs/governance/board.md&lt;/a&gt;&lt;br/&gt;[8].&lt;a href=&quot;https://github.com/dotnet/runtime&quot;&gt;https://github.com/dotnet/runtime&lt;/a&gt;&lt;br/&gt;[9].&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/rid-catalog&quot;&gt;https://docs.microsoft.com/en-us/dotnet/core/rid-catalog&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Oct 2020 00:32:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>作者：Richard 翻译：精致码农-王亮 原文：http://dwz.win/Q4h 自从 .NET 5 宣贯以来，很多人都在问这对 .NET Standard 意味着什么，它是否仍然重要。在这篇文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13806646.html</dc:identifier>
</item>
<item>
<title>HttpReports 2.0 发布了 ！！！ - SpringLeee</title>
<link>http://www.cnblogs.com/myshowtime/p/13806631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myshowtime/p/13806631.html</guid>
<description>&lt;h2 id=&quot;-前言介绍&quot;&gt;🍀 前言介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HttpReports&lt;/strong&gt; 是基于.Net Core 开发的APM监控系统，使用MIT开源协议，主要功能包括，统计, 分析, 可视化， 监控，追踪等，适合在微服务环境中使用。&lt;/p&gt;
&lt;p&gt;Github地址：&lt;strong&gt;&lt;a href=&quot;https://github.com/dotnetcore/HttpReports&quot;&gt;https://github.com/dotnetcore/HttpReports&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在线预览： &lt;strong&gt;&lt;a href=&quot;http://122.51.188.23:8080&quot;&gt;http://122.51.188.23:8080&lt;/a&gt;&lt;/strong&gt; (带宽有限，第一次会有点慢)&lt;/p&gt;
&lt;p&gt;在线文档： &lt;strong&gt;&lt;a href=&quot;https://www.yuque.com/httpreports/docs&quot;&gt;https://www.yuque.com/httpreports/docs&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;账号: &lt;strong&gt;admin&lt;/strong&gt; 密码 &lt;strong&gt;123456&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开源不易，感兴趣的同学还希望点个Star，支持下&lt;/p&gt;
&lt;h2 id=&quot;-简单架构&quot;&gt;🍉 简单架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/jiagou.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-主要功能&quot;&gt;🍌 主要功能&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;接口调用指标分析&lt;/li&gt;
&lt;li&gt;多服务节点数据聚合分析&lt;/li&gt;
&lt;li&gt;慢请求，错误请求分析&lt;/li&gt;
&lt;li&gt;接口调用日志查询&lt;/li&gt;
&lt;li&gt;多类型预警监控&lt;/li&gt;
&lt;li&gt;HTTP,Grpc 调用分析&lt;/li&gt;
&lt;li&gt;分布式追踪&lt;/li&gt;
&lt;li&gt;多数据库支持，集成方便&lt;/li&gt;
&lt;li&gt;程序性能监控&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;20-更新&quot;&gt;2.0 更新&lt;/h2&gt;
&lt;p&gt;HttpReports 上一次发布HttpReports 还是在3个月前，HttpReports 2.0 版本的改动还是挺大的，所以建议老版本的升级前，还是先看下文档，本次更新主要以下几个方面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目结构调整,统一使用 HttpTransport&lt;/li&gt;
&lt;li&gt;使用 Vue + Antv + ElementUI 重构了Dashboard&lt;/li&gt;
&lt;li&gt;使用FreeSql ORM重构了存储层，之前兼容多数据库是个很头疼的问题，要写很多sql，FreeSql兼容的很好，现在项目里面你找不到一行sql， 用起来非常方便，性能也有提升，这里给叶老板点个赞&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;-预览&quot;&gt;🍍 预览&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/index1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/v2.0_service.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/v2.0_relatela.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/v2.0_alarm3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;引用-httpreportsdashboard&quot;&gt;引用 HttpReports.Dashboard&lt;/h2&gt;
&lt;p&gt;首先，需要创建Dashboard 项目来接收，处理和展示数据，Dashboard 使用了 Vue + Antv +ElementUI 构建页面并打包到程序集，只需要Web项目引用 Nuget包安装即可，非常方便。&lt;/p&gt;
&lt;p&gt;新建一个 .Net Core 的空Web项目，支持 2.1 及以上版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/create.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建完成后，通过Nuget包分别安装 HttpReports.Dashboard ，HttpReports.MySQL（或者是HttpReports.SqlServer, HttpReports.PostgreSQL）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/UseDashboard.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/UseDashboardMySql.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引用完成后，简单配置一下， 修改项目的 appsetting.json 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
 &quot;HttpReportsDashboard&quot;: { 
    &quot;ExpireDay&quot;: 3,
    &quot;Storage&quot;: {
      &quot;ConnectionString&quot;: &quot;DataBase=HttpReports;Data Source=localhost;User Id=root;Password=123456;&quot;, 
      &quot;DeferSecond&quot;: 10,
      &quot;DeferThreshold&quot;: 100
    },
    &quot;Mail&quot;: {
      &quot;Server&quot;: &quot;smtp.163.com&quot;,
      &quot;Port&quot;: 465,
      &quot;Account&quot;: &quot;HttpReports@qq.com&quot;,
      &quot;Password&quot;: &quot;*******&quot;,
      &quot;EnableSsL&quot;: true,
      &quot;Switch&quot;: true
    }
  } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数介绍：&lt;br/&gt;ExpireDay - 数据过期天数，默认3天，HttpReports 会自动清除过期的数据&lt;br/&gt;Storage - 存储信息&lt;br/&gt;DeferSecond - 批量数据入库的秒数，建议值 5-60&lt;br/&gt;DeferThreshold - 批量数据入库的数量，建议值100-1000&lt;br/&gt;Mail - 邮箱信息，配置监控的话，可以发告警邮件&lt;/p&gt;
&lt;p&gt;修改完成后，我们接着修改 Dahboard 项目的 Startup.cs 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;public void ConfigureServices(IServiceCollection services)
{ 
        services.AddHttpReportsDashboard().UseMySqlStorage(); 
} 
 
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{ 
        app.UseHttpReportsDashboard(); 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把Dashboard 程序启动起来，如果没有问题的话，会跳转到Dashboard的登陆页面 默认账号：admin 密码: 123456&lt;/p&gt;
&lt;p&gt;现在可视化有了，但是没有数据，我们还需要 给服务端程序，添加 HttpReports 来收集信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/v2.0_login.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;引用httpreports&quot;&gt;引用HttpReports&lt;/h2&gt;
&lt;p&gt;我新建一个WebAPI 项目 UserService ，来充当用户服务，然后安装 HttpReports，当然你可以在你的项目中直接使用&lt;/p&gt;
&lt;p&gt;Nuget 引用 HttpReports , HttpReports.Transport.Http&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/UseHttpReports.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改 appsettings.json，简单配置一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
 &quot;HttpReports&quot;: {
   &quot;Transport&quot;: {
     &quot;CollectorAddress&quot;: &quot;http://localhost:5000/&quot;,
     &quot;DeferSecond&quot;: 10,
     &quot;DeferThreshold&quot;: 10
   },
   &quot;Server&quot;: &quot;http://localhost:7000&quot;,
   &quot;Service&quot;: &quot;User&quot;,
   &quot;Switch&quot;: true,
   &quot;RequestFilter&quot;: [ &quot;/api/Helath/*&quot;, &quot;/HttpReports*&quot; ],
   &quot;WithRequest&quot;: true,
   &quot;WithResponse&quot;: true,
   &quot;WithCookie&quot;: true,
   &quot;WithHeader&quot;: true
 }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数介绍：&lt;/p&gt;
&lt;p&gt;Transport -&lt;br/&gt;CollectorAddress - 数据发送的地址，配置Dashboard 的项目地址即可&lt;br/&gt;DeferSecond - 批量数据入库的秒数，建议值 5-60&lt;br/&gt;DeferThreshold - 批量数据入库的数量，建议值100-1000&lt;/p&gt;
&lt;p&gt;Server - 服务的地址,&lt;br/&gt;Service - 服务的名称&lt;br/&gt;Switch - 是否开启收集数据&lt;br/&gt;RequestFilter - 数据过滤，用 * 来模糊匹配&lt;br/&gt;WithRequest - 是否记录接口的入参&lt;br/&gt;WithResponse - 是否记录接口的出参&lt;br/&gt;WithCookie - 是否记录Cookie 信息&lt;br/&gt;WithHeader - 是否记录请求Header信息&lt;/p&gt;
&lt;p&gt;修改完成后，我们接着修改 UserService 项目的 Startup.cs 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
     services.AddHttpReports().UseHttpTransport();
     services.AddControllers();
}

        
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
     app.UseHttpReports();
     ....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 UserService 项目的启动端口为7000， 然后 VS 设置多项目启动， 同时运行 UserService 和Dashboard&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
    Host.CreateDefaultBuilder(args)
    .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                     webBuilder.UseStartup&amp;lt;Startup&amp;gt;().UseUrls(&quot;http://localhost:7000&quot;);
                });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刷新下 UserService 的接口，再回到Dashboard的页面上面，已经可以看到数据了，一个简单的服务接入HttpReports，已经完成了，是不是很简单!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/index.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置ip和端口--server&quot;&gt;配置IP和端口 Server&lt;/h4&gt;
&lt;p&gt;HttpReports 需要显式指定Web程序的IP和端口，当然这个地址用外网和内网的都可以，在微服务环境中， 一个服务会开启多个实例， HttpReports 通过IP和端口来区分不同的程序实例。&lt;/p&gt;
&lt;h4 id=&quot;在appsettingjson-中配置&quot;&gt;在appsetting.json 中配置&lt;/h4&gt;
&lt;p&gt;我们直接在 appsetting.json 中设置 Urls 属性，你可以设置 &quot;Server&quot;: &quot;&lt;a href=&quot;http://127.0.0.1:3000&quot;&gt;http://127.0.0.1:3000&lt;/a&gt;&quot;&lt;br/&gt;在命令行参数中配置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet UserService.dll --urls=&quot;http://127.0.0.1:3000&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet UserService.dll --HttpReports:Server=&quot;http://127.0.0.1:5000&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流沟通&quot;&gt;交流沟通&lt;/h2&gt;
&lt;p&gt;贡献的最简单的方法之一就是是参与讨论和讨论问题（issue）。你也可以通过提交的 Pull Request 代码变更作出贡献。&lt;/p&gt;
&lt;p&gt;可以添加QQ群沟通，也可以添加的微信，我拉你进微信群&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://httpreports2-1259586045.cos.ap-shanghai.myqcloud.com/goutong.jpeg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;HttpReports 从第一次提交代码到现在已经10个月了，兼职开源，占据了生活很大一部分的时间， 一个个版本迭代到现在，2.0 不是最终版，未来可能会有 3.0 5.0，我看支持的同学也有很多，有很多人提了很多意见，感谢各位的支持，让我们觉得做这件事是有意义的，一定会把 HttpReports 做的越来越好&lt;/p&gt;
</description>
<pubDate>Tue, 13 Oct 2020 00:19:00 +0000</pubDate>
<dc:creator>SpringLeee</dc:creator>
<og:description>&amp;amp;#127808; 前言介绍 HttpReports 是基于.Net Core 开发的APM监控系统，使用MIT开源协议，主要功能包括，统计, 分析, 可视化， 监控，追踪等，适合在微服务环境</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myshowtime/p/13806631.html</dc:identifier>
</item>
<item>
<title>Flink深入浅出: 资源管理(v1.11) - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/13806624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/13806624.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4PPc462eOOPtdLVtNgBOmakV7gaElDPTjWViapmicR9OruxaWU4ddCNVFbuicDJlxFSkUibIjWeW5ibzT7Bj0JxZ2Qw/640?wx_fmt=jpeg&quot; class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5453125&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;—— 图片来自 《国家地理中文网》——&lt;/p&gt;
&lt;p&gt;往期推荐：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;amp;mid=2247484987&amp;amp;idx=1&amp;amp;sn=cc08ab620f15d510a7c3c0700651e013&amp;amp;chksm=fbc0ab7dccb7226b8aa0d8b31f62cd4847a70beb43f67c7982d14b005b9873972027ab68178f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Flink深入浅出：部署模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;amp;mid=2247484974&amp;amp;idx=1&amp;amp;sn=f02489295de20d1398b38f2ee0e939ab&amp;amp;chksm=fbc0ab68ccb7227e243ab7db77bde55bec5c9ba5ef0a7940eb5a14000c150c3723aab30f4c5a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Flink深入浅出：内存模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;amp;mid=2247484547&amp;amp;idx=1&amp;amp;sn=eaab22866f7e0fa492f79349f38604e6&amp;amp;chksm=fbc0a9c5ccb720d3c7b18de81c88f6175cb1f83286b82b253e73268a2eeb4b2a3cd5e73ab748&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Flink深入浅出：JDBC Source从理论到实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;amp;mid=2247484529&amp;amp;idx=1&amp;amp;sn=2dbdb75daad3f248ededd88449d77f02&amp;amp;chksm=fbc0a937ccb72021a5f06a70609b9d87f043c8fd33f423a0079885da3acf7cecd14d49f2dff4&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Flink深入浅出：Sql Gateway源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;amp;mid=2247484513&amp;amp;idx=1&amp;amp;sn=0402cb44d2ad55cde6b3990010e3b59d&amp;amp;chksm=fbc0a927ccb72031d94d26fe7d43fb66be7e2059fab599b35055e8d257cd21feecbc0a15b476&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Flink深入浅出：JDBC Connector源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;amp;mid=2247484952&amp;amp;idx=1&amp;amp;sn=b1c9b8220a207e41effd2004bae2fa95&amp;amp;chksm=fbc0ab5eccb72248cc010d0ab1940c53e9bf1aa2986fcf69567f4ba158e37e3cdc42f5d564dc&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;什么是Flink 之 架构篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;amp;mid=2247484959&amp;amp;idx=1&amp;amp;sn=72f546e72c6d1e5fc8e17c991a593a88&amp;amp;chksm=fbc0ab59ccb7224fdf88edbbe92ed504a2bf47561fa8a0602639b56038da89c80c231b936747&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;什么是Flink 之 应用篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Flink在资源管理上可以分为两层：&lt;strong&gt;集群资源&lt;/strong&gt;和&lt;strong&gt;自身资源&lt;/strong&gt;。集群资源支持主流的资源管理系统，如yarn、mesos、k8s等，也支持独立启动的standalone集群。自身资源涉及到每个子task的资源使用，由Flink自身维护。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1 集群架构剖析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flink的运行主要由 客户端、一个JobManager（后文简称JM）和 一个以上的TaskManager（简称TM或Worker）组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4PPc462eOOPtdLVtNgBOmakV7gaElDPTvakOegRvHhmpegLicqDBKNtvXfLLSl5Rpib5vNgYyFLwc1icOMwkeguxg/640?wx_fmt=png&quot; class=&quot;rich_pages&quot; data-ratio=&quot;0.725&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端主要用于提交任务到集群，在Session或Per Job模式中，客户端程序还要负责解析用户代码，生成JobGraph；在Application模式中，直接提交用户jar和执行参数即可。客户端一般支持两种模式：detached模式，客户端提交后自动退出。attached模式，客户端提交后阻塞等待任务执行完毕再退出。 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JobManager&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JM负责决定应用何时调度task，在task执行结束或失败时如何处理，协调检查点、故障恢复。该进程主要由下面几个部分组成：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 ResourceManager&lt;/strong&gt;，负责资源的申请和释放、管理slot（Flink集群中最细粒度的资源管理单元）。Flink实现了多种RM的实现方案以适配多种资源管理框架，如yarn、mesos、k8s或standalone。在standalone模式下，RM只能分配slot，而不能启动新的TM。注意：这里所说的RM跟Yarn的RM不是一个东西，这里的RM是JM中的一个独立的服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 Dispatcher&lt;/strong&gt;，提供Flink提交任务的rest接口，为每个提交的任务启动新的JobMaster，为所有的任务提供web ui，查询任务执行状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 JobMaster&lt;/strong&gt;，负责管理执行单个JobGraph，多个任务可以同时在一个集群中启动，每个都有自己的JobMaster。注意这里的JobMaster和JobManager的区别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TaskManager&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TM也叫做worker，用于执行数据流图中的任务，缓存并交换数据。集群至少有一个TM，TM中最小的资源管理单元是Slot，每个Slot可以执行一个Task，因此TM中slot的数量就代表同时可以执行任务的数量。&lt;/p&gt;

&lt;h2&gt;2 Slot与资源管理&lt;/h2&gt;

&lt;p&gt;每个TM是一个独立的JVM进程，内部基于独立的线程执行一个或多个任务。TM为了控制每个任务的执行资源，使用task slot来进行管理。每个task slot代表TM中的一部分固定的资源，比如一个TM有3个slot，每个slot将会得到TM的1/3内存资源。不同任务之间不会进行资源的抢占，注意GPU目前没有进行隔离，目前slot只能划分内存资源。&lt;/p&gt;

&lt;p&gt;比如下面的数据流图，在扩展成并行流图后，同一的task可能分拆成多个任务并行在集群中执行。操作链可以把多个不同的任务进行合并，从而支持在一个线程中先后执行多个任务，无需频繁释放申请线程。同时操作链还可以统一缓存数据，增加数据处理吞吐量，降低处理延迟。&lt;/p&gt;

&lt;p&gt;在Flink中，想要不同子任务合并需要满足几个条件：下游节点的入边是1（保证不存在数据的shuffle）；子任务的上下游不为空；连接策略总是ALWAYS；分区类型为ForwardPartitioner；并行度一致；当前Flink开启Chain特性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4PPc462eOOPtdLVtNgBOmakV7gaElDPTXN1Q6BekV4CqDgOfXXCiaTTDtldjiaG4LIN7g5nibyqUPeM1iaYeicoZehA/640?wx_fmt=png&quot; class=&quot;rich_pages&quot; data-ratio=&quot;0.66721044045677&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;613&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在集群中的执行图可能如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4PPc462eOOPtdLVtNgBOmakV7gaElDPT5dYqyKgqJxNlOGw0YMBwkwOVORmyW6OyppAuDIffKnh69oE9WtF9ibw/640?wx_fmt=png&quot; class=&quot;rich_pages&quot; data-ratio=&quot;0.327991452991453&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flink也支持slot的共享，即把不同任务根据任务的依赖关系分配到同一个Slot中。这样带来几个好处：方便统计当前任务所需的最大资源配置（某个子任务的最大并行度）；避免Slot的过多申请与释放，提升Slot的使用效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4PPc462eOOPtdLVtNgBOmakV7gaElDPTTSwSq9CZjOiakD8d1b5PtyaFlbKnGU4OG0F15KczhG79EgzZuicWyxgg/640?wx_fmt=png&quot; class=&quot;rich_pages&quot; data-ratio=&quot;0.47103004291845496&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;932&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过Slot共享，就有可能某个Slot中包含完整的任务执行链路。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;3 应用执行&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个Flink应用就是用户编写的main函数，其中可能包含一个或多个Flink的任务。这些任务可以在本地执行，也可以在远程集群启动，集群既可以长期运行，也支持独立启动。下面是目前支持的任务提交方案：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Session集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;：集群事先创建并长期运行，客户端提交任务时与该集群连接。即使所有任务都执行完毕，集群仍会保持运行，除非手动停止。因此集群的生命周期与任务无关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源隔离&lt;/strong&gt;：TM的slot由RM申请，当上面的任务执行完毕会自动进行释放。由于多个任务会共享相同的集群，因此任务间会存在竞争，比如网络带宽等。如果某个TM挂掉，上面的所有任务都会失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他方面&lt;/strong&gt;：拥有提前创建的集群，可以避免每次使用的时候过多考虑集群问题。比较适合那些执行时间很短，对启动时间有比较高的要求的场景，比如交互式查询分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Per Job集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;：为每个提交的任务单独创建一个集群，客户端在提交任务时，直接与ClusterManager沟通申请创建JM并在内部运行提交的任务。TM则根据任务运行需要的资源延迟申请。一旦任务执行完毕，集群将会被回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源隔离&lt;/strong&gt;：任务如果出现致命问题，仅会影响自己的任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他方面&lt;/strong&gt;：由于RM需要申请和等待资源，因此启动时间会稍长，适合单个比较大、长时间运行、需要保证长期的稳定性、不在乎启动时间的任务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Application集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;：与Per Job类似，只是main()方法运行在集群中。任务的提交程序很简单，不需要启动或连接集群，而是直接把应用程序打包到资源管理系统中并启动对应的EntryPoint，在EntryPoint中调用用户程序的main()方法，解析生成JobGraph，然后启动运行。集群的生命周期与应用相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源隔离&lt;/strong&gt;：RM和Dispatcher是应用级别。 &lt;/p&gt;

</description>
<pubDate>Tue, 13 Oct 2020 00:13:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<og:description>—— 图片来自 《国家地理中文网》—— 往期推荐： Flink深入浅出：部署模式 Flink深入浅出：内存模型 Flink深入浅出：JDBC Source从理论到实战 Flink深入浅出：Sql Ga</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xing901022/p/13806624.html</dc:identifier>
</item>
<item>
<title>如何快速构建React组件库 - jdf2e</title>
<link>http://www.cnblogs.com/jdrdfe/p/13805669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jdrdfe/p/13805669.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;俗话说：“麻雀虽小，五脏俱全”，搭建一个组件库，知之非难，行之不易，涉及到的技术方方面面，犹如海面风平浪静，实则暗礁险滩，处处惊险～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前团队内已经有较为成熟的 Vue 技术栈的 &lt;a href=&quot;http://nutui.jd.com/#/index&quot;&gt;NutUI 组件库&lt;/a&gt;[1] 和 React 技术栈的 &lt;a href=&quot;http://yep-react.jd.com/#/&quot;&gt;yep-react 组件库&lt;/a&gt;[2]。然而这些组件库大都从零开始搭建，包括 Webpack 的繁杂配置，Markdown 文件转 Vue 文件功能的开发，单元测试功能的开发、按需加载的 Babel 插件开发等等，完成整个组件库项目实属不易，也是一个浩大的工程。如果我们想快速搭建一个组件库，大可不必如此耗费精力，可以借助业内专业的相关库，经过拼装调试，快速实现一个组件库。&lt;br/&gt;本篇文章就来给大家介绍一下使用 create-react-app 脚手架、docz 文档生成器、node-sass、结合 Netlify 部署项目的整个开发组件库的流程，本着包教包会，不会没有退费的原则，来一场手摸手式教学，话不多说，让我们进入正题：&lt;/p&gt;
&lt;p&gt;首先看一下组件库的最终效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/140939/29/4093/150666/5f226b00E7e6992d6/78a95d4b8f525de2.png&quot; alt=&quot;组件库界面&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文将从以下步骤介绍如何搭建一个 React 组件库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img11.360buyimg.com/imagetools/jfs/t1/112907/10/14445/25118/5f30b668E8f85dca0/ee665bd4619fde7a.png&quot; alt=&quot;文章结构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、构建本地开发环境&quot;&gt;一、构建本地开发环境&lt;/h3&gt;
&lt;p&gt;开发一个组件库的首要步骤就是调试本地 React 环境，我们直接使用 React 官方脚手架 &lt;code&gt;create-react-app&lt;/code&gt;，可以省去从底层配置 Webpack+TypeScript+React 的摧残：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、使用 create-react-app 初始化脚手架，并且安装 TypeScript&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npx create-react-app myapp --typescript&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意使用 node 为较高版本 &amp;gt;10.15.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、配置 eslint 进行格式化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于安装最新的 create-react-app 结合 VScode 编辑器即可支持 eslit，但是需要在项目根目录中要添加 .env 这个配置文件，设置 &lt;code&gt;EXTEND_ESLINT=true&lt;/code&gt; 这样才会启用 eslint 检测，注意要 &lt;strong&gt;重启 vscode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、组件库系统文件结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建 styles 文件夹，包含了基本样式文件，结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;|-styles
| |-variables.scss // 各种变量以及可配置设置
| |-mixins.scss    // 全局 mixins
| |-index.scss    // 引入全部的 scss 文件，向外抛出样式入口
|-components
| |-Button
|   |-button.scss // 组件的单独样式
|   |-button.mdx // 组件的文档
|   |-button.tsx // 组件的核心代码
|   |-button.test.tsx // 组件的单元测试文件
|  |-index.tsx  // 组件对外入口
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、安装 node-sass 处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装 node-sass 用来编译 SCSS 样式文件：&lt;code&gt;npm i node-sass -D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样最基本的 react 开发环境就完成了，可以开心的开发组件了。&lt;/p&gt;
&lt;h3 id=&quot;二、组件库打包编译&quot;&gt;二、组件库打包编译&lt;/h3&gt;
&lt;p&gt;本地调试完组件库之后，需要打包压缩编译代码，供其他用户使用，这里我们用的 TypeScript 编写的代码，所以使用 Typescript 来编译项目：&lt;br/&gt;首先在每个组件中新建 index.tsx 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import Button from './button'
export default Button 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 index.tsx 文件，导入导出各个模块&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;export { default as Button } from './components/Button'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在根目录新建 tsconfig.build.json，对 .tsx 文件进行编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;{
  &quot;compilerOptions&quot;: {
    &quot;outDir&quot;: &quot;dist&quot;,// 生成目录
    &quot;module&quot;: &quot;esnext&quot;,// 格式
    &quot;target&quot;: &quot;es5&quot;,// 版本
    &quot;declaration&quot;: true,// 为每一个 ts 文件生成 .d.ts 文件
    &quot;jsx&quot;: &quot;react&quot;,
    &quot;moduleResolution&quot;:&quot;Node&quot;,// 规定寻找引入文件的路径为 node 标准
    &quot;allowSyntheticDefaultImports&quot;: true,
  },
  &quot;include&quot;: [// 要编译哪些文件
    &quot;src&quot;
  ],
  &quot;exclude&quot;: [// 排除不需要编译的文件
    &quot;src/**/*.test.tsx&quot;,
    &quot;src/**/*.stories.tsx&quot;,
    &quot;src/setupTests.ts&quot;,
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于样式文件，使用 node-sass 编译 SCSS，抽取所有 SCSS 文件生成 CSS 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;&quot;script&quot;:{
    &quot;build-css&quot;: &quot;node-sass ./src/styles/index.scss ./dist/index.css&quot;,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且修改 build 命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;&quot;script&quot;:{
    &quot;clean&quot;: &quot;rimraf ./dist&quot;,// 跨平台的兼容
    &quot;build&quot;: &quot;npm run clean &amp;amp;&amp;amp; npm run build-ts &amp;amp;&amp;amp; npm run build-css&quot;,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，执行 &lt;code&gt;npm run build&lt;/code&gt; 之后，就可以生成对应的组件 JS 和 CSS 文件，为后面使用者按需加载和部署到 npm 上提供准备。&lt;/p&gt;
&lt;h3 id=&quot;三、本地调试组件库&quot;&gt;三、本地调试组件库&lt;/h3&gt;
&lt;p&gt;本地完成组件库的开发之后，在发布到 npm 前，需要先在本地调试，避免带着问题上传到 npm 上。这时就需要使用 npm link 出马了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是 npm link&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本地开发 npm 模块的时候，我们可以使用 npm link 命令，将 npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设组件库是 reactui 文件夹，要在本地的 demo 项目中使用组件。则在组件库中（要被 link 的地方）执行 &lt;code&gt;npm link&lt;/code&gt;，则生成从本机的 &lt;code&gt;node_modules/reactui&lt;/code&gt; 到 &lt;code&gt;组件库的路径 / reactui&lt;/code&gt; 中的映射关系。&lt;br/&gt;然后在要使用组件库的文件夹 demo 中执行 &lt;code&gt;npm link reactui&lt;/code&gt; 则生成以下对应链条：&lt;/p&gt;
&lt;p&gt;在要使用组件的文件夹 demo 中 -[映射到]—&amp;gt; 本机的 &lt;code&gt;node_modules/reactui&lt;/code&gt; —[映射到]-&amp;gt; 开发组件库 reactui 的文件夹 /reactui&lt;/p&gt;
&lt;p&gt;需要修改组件库的 package.json 文件来设置入口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;{
  &quot;name&quot;: &quot;reactui&quot;,
  &quot;main&quot;: &quot;dist/index.js&quot;,
  &quot;module&quot;: &quot;dist/index.js&quot;,
  &quot;types&quot;: &quot;dist/index.d.ts&quot;,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在要使用组件的 demo 项目的依赖中添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;&quot;dependencies&quot;:{
  &quot;reactui&quot;:&quot;0.0.1&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，此时并不用安装依赖，之所以写上该依赖，是为了方便在项目中使用的时候可以有代码提示功能。&lt;br/&gt;然后在 demo 项目中使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import { Button } from 'reactui'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 index.tsx 中引入 CSS 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import 'reactui/build/index.css'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正当以为大功告成的时候，下面这个报错犹如一盆冷水从天而降：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/148314/6/4090/76920/5f23b0bfE521bc482/19521727a4fdda60.jpg&quot; alt=&quot;错误提示&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过各种问题排查，在 &lt;a href=&quot;https://reactjs.org/warnings/invalid-hook-call-warning.html&quot;&gt;react 官方网站&lt;/a&gt;[3] 上查到以下说法：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;🔴 Do not call Hooks in class components.&lt;br/&gt;🔴 Do not call in event handlers.&lt;br/&gt;🔴 Do not call Hooks inside functions passed to useMemo, useReducer, or useEffect.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说的很明白：&lt;/p&gt;
&lt;p&gt;原因 1: React 和 React DOM 的版本不一样的问题&lt;br/&gt;原因 2: 可能打破了 Hooks 的规则&lt;br/&gt;原因 3: 在同一个项目中使用了多个版本的 React&lt;/p&gt;
&lt;p&gt;官网很贴心，给出了解决方法：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;This problem can also come up when you use npm link or an equivalent. In that case, your bundler might “see” two Reacts — one in application folder and one in your library folder. Assuming myapp and mylib are sibling folders, one possible fix is to run npm link ../myapp/node_modules/react from mylib. This should make the library use the application’s React copy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;核心思想在组件库中使用 &lt;code&gt;npm link&lt;/code&gt; 方式，引到 demo 项目中的 react； 所以在组件库中执行： &lt;code&gt;npm link ../demo/node_modules/react&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在代码库 reactui 中执行 &lt;code&gt;npm link&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在代码库 reactui 中执行 &lt;code&gt;npm link ../../demo/node_modules/react&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在项目 demo 中执行 &lt;code&gt;npm link reactui&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如此可以解决上面 react 冲突问题；于是可以在本地一边快乐的调试组件库，一边快乐的在使用组件的项目中看到最终效果了。&lt;/p&gt;
&lt;h3 id=&quot;四、组件库发布到-npm&quot;&gt;四、组件库发布到 npm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;该过程一定要注意使用的是 npm 源！！[非常重要]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先确定自己是否已经登录了 npm：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;npm adduser
// 填入用户名；密码；email
npm whoami // 查看当前登录名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改组件库的 package.json ，注意 files 配置；以及 dependencies 文件的化简:&lt;br/&gt;react 依赖原本是要放在 dependencies 中的，但是可能会和用户安装的 react 版本冲突，所以放在了 devDependencies 中，但是这样话用户如果没有安装 react 则无法使用组件库，所以要在 peerDependencies 中定义前置依赖 peerDependencies，告诉用户 react 和 react-dom 是必要的前置依赖:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;&quot;main&quot;: &quot;dist/index.js&quot;,
&quot;module&quot;: &quot;dist/index.js&quot;,
&quot;types&quot;: &quot;dist/index.d.ts&quot;,
&quot;files&quot;: [ // 把哪些文件上传到 npm
  &quot;dist&quot;
],
&quot;dependencies&quot;: {  // 执行 npm i 的时候会安装这些依赖到 node_modules 中
  &quot;axios&quot;: &quot;^0.19.1&quot;,// 发送请求
  &quot;classnames&quot;: &quot;^2.2.6&quot;,//
  &quot;react-transition-group&quot;: &quot;^4.3.0&quot;
},
&quot;peerDependencies&quot;: { // 重要！！，提醒使用者，组件库的核心依赖，必须先安装这些依赖才能使用
  &quot;react&quot;: &quot;&amp;gt;=16.8.0&quot;,  // 在 16.8 之后 才引入了 hooks
  &quot;react-dom&quot;: &quot;&amp;gt;=16.8.0&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，整个组件库经过上述过程，基本上各个功能已经有了，提及一句：由于组件库使用的是 create-react-app 脚手架，最新的版本已经集成了单元测试功能。还有配置 husky 等规范代码提交，在这里不在做赘述，读者可以自行配置。&lt;/p&gt;
&lt;h3 id=&quot;五、生成说明文档&quot;&gt;五、生成说明文档&lt;/h3&gt;
&lt;p&gt;目前生成说明文档较好的工具有 &lt;a href=&quot;https://storybook.js.org/&quot;&gt;storybook&lt;/a&gt;[4]、&lt;a href=&quot;https://www.docz.site/&quot;&gt;docz&lt;/a&gt;[5] 等工具，两者都是很优秀的文档生成工具，但是尺有所短，寸有所长，经过认真调研比较，最终选择了 docz。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;工具名称&lt;/th&gt;
&lt;th&gt;区别一&lt;/th&gt;
&lt;th&gt;区别二&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;storybook&lt;/td&gt;
&lt;td&gt;使用特有的API开发文档说明，可以引入markdown文件&lt;/td&gt;
&lt;td&gt;生成文档的界面带有storybook的痕迹较多一些&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;docz&lt;/td&gt;
&lt;td&gt;完美的结合了react和markdown语法开发文档&lt;/td&gt;
&lt;td&gt;生成的文档界面是常规的文档界面&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;1、确定选型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）storybook 的常用编译文档规范相对 docz 而言，略有繁琐&lt;/p&gt;
&lt;p&gt;storybook 的编译文档规范如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;//省略 import 引入的代码
storiesOf('Buttons', module)
.addDecorator(storyFn =&amp;gt; &amp;lt;div style={{ textAlign: 'center' }}&amp;gt;{storyFn()}&amp;lt;/div&amp;gt;)
.add('with text', () =&amp;gt; (
&amp;lt;Button onClick={action('clicked')}&amp;gt;Hello Button111&amp;lt;/Button&amp;gt;
),{
notes:{markdown}   // 将会渲染 markdown 内容
}) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对比 docz 的开发文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markdown&quot;&gt;# Button 组件

使用方式如下所示：
import { Playground, Props } from 'docz';
import Button from './index.tsx';

## 按钮组件

&amp;lt;Playground&amp;gt;
    &amp;lt;Button btnWidth=&quot;100&quot;&amp;gt;我是按钮&amp;lt;/Button&amp;gt;
&amp;lt;/Playground&amp;gt;

** 基本属性 **

| 属性名称 | 说明 | 默认值 |
|--|--|--|
|btnType | 按钮类型 |--|
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;众所周知，Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。团队成员在开发文档时，熟练使用 markdown 语法，开发 docz 文档的 mdx 文件，结合了 Markdown 和 React 语法，相比 storybook 要使用很多的 API 来编写文档的方式，无疑减少了很多的学习 storybook 语法的成本。&lt;/p&gt;
&lt;p&gt;2）docz 生成的文档样式更加符合个人审美&lt;/p&gt;
&lt;p&gt;storybook 生成的文档样式，带有 storybook 的痕迹更为严重一些， 其生成文档界面如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img13.360buyimg.com/imagetools/jfs/t1/125708/23/8306/50657/5f22701fEaf5cde34/ff4027b8ff6c6625.png&quot; alt=&quot;storybook生成界面&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;docz 生成的文档图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img11.360buyimg.com/imagetools/jfs/t1/132451/34/5413/81872/5f22701aEbdf0390c/f9ca2524119e8dc5.png&quot; alt=&quot;docz生成界面&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图对比可以看出，docz 生成的界面更加简介，较为常规。&lt;br/&gt;综上，结合默认文档开发习惯和界面风格，我选择了docz，当然仁者见仁、智者见智，读者也可以使用同为优秀的 storybook 尝试，这都不是事儿～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、使用 docz 开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确定了 docz 进行开发后，根据官网介绍，在 create-react-app 生成的组件库中进行了安装配置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install docz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装成功后，就会向 package.json 文件中添加如下配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;{
  &quot;scripts&quot;: {
    &quot;docz:dev&quot;: &quot;docz dev&quot;,
    &quot;docz:build&quot;: &quot;docz build&quot;,
    &quot;docz:serve&quot;: &quot;docz build &amp;amp;&amp;amp; docz serve&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时还需要在项目的根目录下新建 doczrc.js 文件，对 docz 进行配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;export default {
  files: ['./src/components/**/*.mdx','./src/*.mdx'], 
  dest: 'docsite', // 打包 docz 文档到哪个文件夹下
  title: '组件库左上角标题',  // 设置文档的标题
  typescript: true, // 支持 typescript 语法
  themesDir: 'theme', // 主题样式放在哪个文件夹下，后面会讲
  menu: ['快速上手', '业务组件'] // 生成文档的左侧菜单分类
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 files 规定了 docz 去对哪些文件进行编译生成文档，如果不做限制，会搜索项目中所有的 md、mdx 为后缀的文件生成文档，因此我在该文件中做了范围限制，避免一些 &lt;code&gt;README.md&lt;/code&gt; 文件也被生成到文档中。&lt;/p&gt;
&lt;p&gt;此外还需要注意到两点：&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;menu: ['快速上手', '业务组件']&lt;/code&gt; 对应着组件库左侧的菜单栏分类，比如在 mdx 文档中在最上面设置组件所属的菜单 &lt;code&gt;menu: 业务组件&lt;/code&gt; , 则 Button 组件属于 &quot;业务组件&quot; 的分类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markdown&quot;&gt;---
name: Button
route: /button
menu: 业务组件
---
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 src 中新建欢迎页，路由为跟路径，所属菜单为“快速上手”；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markdown&quot;&gt;---
name: 快速上手
route: /
---
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行 &lt;code&gt;npm run docz:dev&lt;/code&gt;，就可以打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img13.360buyimg.com/imagetools/jfs/t1/111949/36/14393/44763/5f30df4bE8703242c/ae38f3880e4578a8.png&quot; alt=&quot;路由配置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;介绍到这里，估计有小伙伴会有疑问了，这样生成的网站千篇一律，能否随心所欲的自定义网站的样式和功能呢？当初我也有这种疑问，经过多次尝试，皇天不负苦心人，终于摸索出如下方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、修改 docz 文档本身的样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据 docz 官方文档中&lt;a href=&quot;https://www.docz.site/docs/gatsby-theme&quot;&gt;增加 logo 的方法&lt;/a&gt;[6]，可以通过自定义组件覆盖原有组件的形式：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Example: If you're using our gatsby-theme-docz which has a Header component located at src/components/Header/index.js you can override the component by creating src/gatsby-theme-docz/components/Header/index.js. Cool right?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以根据 docz 源代码主题部分代码： &lt;code&gt;https://github.com/doczjs/docz/tree/master/core/gatsby-theme-docz/src&lt;/code&gt;，找到对应的文档组件的代码结构，在组件库项目根目录新建同名称的文件夹：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;|-theme
|  |-gatsby-theme-docz
|     |-components
|     |-Header
|       |-index.js // 在这里修改自定义的文档组件
|       |-styles.js // 在这里修改生成的样式文件
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在执行 &lt;code&gt;npm run docz:dev&lt;/code&gt; 的时候，就会把自定义的代码覆盖原有样式，实现文档的多样化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、修改 markdown 文档样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事情到这里就结束了吗？不！我们的目标不仅如此，因为我发现自动生成的 markdown 格式，并不符合我的审美，比如生成的表格文字居左对齐，并且整个表格样式单一，但是这里属于 markdown 样式的范畴，修改上述文档组件中并不包括这里的代码，那么如何修改 markdown 生成文档的样式呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/117423/9/13652/45654/5f227adfEa857ba90/094c9543a38758c8.jpg&quot; alt=&quot;docz默认生成表格样式&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过我灵机一动又一动，发现既然在上面修改文档组件样式的时候，重写了 component/Header/styles.js 文件，是否可以在该文件中引入自定义的样式呢？文件结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;|-theme
|  |-gatsby-theme-docz
|     |-components
|     |-Header
|       |-index.js // 在这里修改自定义的文档组件
|       |-styles.js // 在这里修改生成的样式文件
|       |-base.css  // 这里修改 markdown 生成文档的样式
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样修改后的表格样式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img14.360buyimg.com/imagetools/jfs/t1/146970/22/4101/41432/5f227adfE93691424/3deb79390ef6b1f4.jpg&quot; alt=&quot;修改docz表格样式&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来各位小主可以根据自己的审美或者视觉设计的要求自定义文档的样式了。&lt;/p&gt;
&lt;h3 id=&quot;六、部署文档到服务器&quot;&gt;六、部署文档到服务器&lt;/h3&gt;
&lt;p&gt;生成的组件库文档只在本地显示是没有意义的，所以需要部署到服务器上，于是第一时间想到的是放在 github 进行托管，打开 github 中的 setting 设置选项，GitHub Pages 设置配置的分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/150087/19/4164/50237/5f2380dcE3d8103ab/b253298c0acfd582.jpg&quot; alt=&quot;设置分支&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时默认打开的首页路径为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://plusui.github.io/plusReact/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但实际上页面有效的访问地址是带有文件夹 docsite 路径的：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://plusui.github.io/plusReact/docsite/button/index.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此外，页面引入的其他资源路径，都是绝对路径，如下图资源路径所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img11.360buyimg.com/imagetools/jfs/t1/113606/30/13681/95663/5f237355Eb84f4a64/e10b76a0bc45a653.png&quot; alt=&quot;引入资源路径&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以直接把打包后的资源放在 github 上是无法访问各种资源的。&lt;br/&gt;这时我们只好把网站部署到云服务器上了，考虑到服务器配置的繁琐，这里给大家提供一个简便的部署网站：&lt;a href=&quot;https://app.netlify.com/teams/zhenyulei/sites&quot;&gt;Netlify&lt;/a&gt;[7]&lt;/p&gt;
&lt;p&gt;Netlify 是一个提供静态网站托管的服务，提供 CI 服务，能够将托管 GitHub，GitLab 等网站上的 Jekyll，Hexo，Hugo 等静态网站。&lt;/p&gt;
&lt;p&gt;部署项目的过程也很简单，傻瓜式的点击选择 github 网站中代码路径，以及配置文件夹跟路径，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img14.360buyimg.com/imagetools/jfs/t1/150046/40/5112/119951/5f30e02fE1e9f9666/6e656e7a3ac32c30.png&quot; alt=&quot;配置文件夹路径&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就可以点击生成的网站 url，访问到部署的网站了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img13.360buyimg.com/imagetools/jfs/t1/119732/6/13015/58243/5f30e0b0E23e941e6/ebacc0096600b409.jpg&quot; alt=&quot;部署网站&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且很方便的是，一旦完成部署之后，之后再次向代码库中提交代码，Netlify 会自动更新网站。&lt;br/&gt;此外，如果想自定义 url，那么就只能去申请域名了，在自己的云服务器上，解析域名即可。下面简单说一下配置步骤：&lt;/p&gt;
&lt;p&gt;1）首先在 Netlify 网站上，选择组件库对应的 Domain settings 下 Custom domains，增加自己的域名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/129556/28/9451/40735/5f30e145E9a7d9b0f/a05c2ef63298be6c.png&quot; alt=&quot;配置域名&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）然后打开云服务器中的域名解析中的解析设置，将该域名指向 Netlify：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/149292/6/5068/24313/5f30e1ebE409ef7df/45493029c951364c.png&quot; alt=&quot;云服务器上增加域名&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）最后打开设置的网址，就可以访问到组件库了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/150167/40/4155/60237/5f238c70Eb6e14729/bd30d96e25bfcb37.jpg&quot; alt=&quot;最终效果&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;七、组件按需加载&quot;&gt;七、组件按需加载&lt;/h3&gt;
&lt;p&gt;好了，经过上面的流程，可以在 demo 项目中使用组件库了，但是在 demo 项目中，执行 &lt;code&gt;npm run build&lt;/code&gt; ，就会发现生成的静态资源中即使只使用了一个组件，也会把 reactui 组件库中所有的组件打包进来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以如何进行按需加载呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按需加载首先映入脑海的是使用 &lt;code&gt;babel-plugin-import&lt;/code&gt; 插件, 该插件可以在 Babel 配置中针对组件库进行按需加载.&lt;/p&gt;
&lt;p&gt;用户需要安装 &lt;code&gt;babel-plugin-impor&lt;/code&gt; 插件，然后在 plugins 中加入配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;&quot;plugins&quot;: [
  [
    &quot;import&quot;,
    {
      &quot;libraryName&quot;: &quot;reactui&quot;, // 转换组件库的名字
      &quot;libraryDirectory&quot;: &quot;dist/components&quot;, // 转换的路径
      &quot;camel2DashComponentName&quot;:false,  // 设置为 false 来阻止组件名称的转换
      &quot;style&quot;:true
    }
  ]
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在 demo 项目中使用如下方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import { Button } from 'reactui';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就会在 babel 中编译成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import { Button } from 'reactui/dist/components/Button';
require('reactui/dist/components/Button/style');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样还有些弊端：&lt;/p&gt;
&lt;p&gt;1、 用户在使用组件库的时候还需要安装 &lt;code&gt;babel-plugin-import&lt;/code&gt;， 并做相关 plugins 配置；&lt;/p&gt;
&lt;p&gt;2、 开发组件库的时候组件对应的样式文件还需要放在 style 文件夹下；&lt;/p&gt;
&lt;p&gt;那有没有更为简单的方法呢？在 ant-design 中寻找答案，发现这样一句话 “antd 的 JS 代码默认支持基于 ES modules 的 tree shaking”。 对呀！还可以使用 webpack 的新技术“tree shaking”。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;什么是 tree shaking？ AST 对 JS 代码进行语法分析后得出的语法树 (Abstract Syntax Tree)。AST 语法树可以把一段 JS 代码的每一个语句都转化为树中的一个节点。DCE Dead Code Elimination，在保持代码运行结果不变的前提下，去除无用的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;webpack 4x 中已经使用了 tree shaking 技术，我们只需要在 package.json 文件中配置参数 &lt;code&gt;&quot;sideEffects&quot;: false&lt;/code&gt;，来告诉 webpack 打包的时候可以大胆的去掉没有用到的模块即可。这时用户在 demo 项目中使用组件库的时候不需要做任何处理，就可以按需引用 JS 资源了。&lt;br/&gt;不知道大家在看到这里时，是否发现这样配置还是有问题的：即 sideEffects 配置成 false 是有问题的。&lt;br/&gt;因为按照上述配置，就会发现组件的样式不见了！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/142050/12/4193/209796/5f23d240Ed774ec10/b10a332b84096951.png&quot; alt=&quot;样式无效&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过排查，原因是引入 CSS 样式的代码：&lt;code&gt;import './button.scss'&lt;/code&gt;，可以看到相当于只是引入了样式，并不像其他 JS 模块后面做了调用，在 tree shaking 的时候，会把 css 样式去掉。所以在配置 sideEffects 就要把 CSS 文件排除掉：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;&quot;sideEffects&quot;: [
  &quot;*.scss&quot;
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述 tree shaking 的方法，可以实现组件库的按需加载功能，打包的文件去除了没有用到的组件代码，同时省去了用户的配置。&lt;/p&gt;
&lt;h3 id=&quot;八、样式按需加载&quot;&gt;八、样式按需加载&lt;/h3&gt;
&lt;p&gt;通常来说，组件库的 JS 是按需加载的，但是样式文件一般只输出一个文件，即把组件库中的所有文件打包编译成一个 index.css 文件，用户在项目中引入即可；但是如果就是想做按需加载组件的样式文件，该如何去做呢？&lt;/p&gt;
&lt;p&gt;这里我提供一种思路，由于 .tsx 文件是由 TS 编译器打包编译的，并没有处理 SCSS，所以我使用了 node-sass 来编译 SCSS 文件，如果需要按需加载 SCSS 文件，则每个组件的 index.tsx 文件中就需要引入对应的 SCSS 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import Button from './button';
import './button.scss';
export default Button;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的 SCSS 文件也需要打包到每个组件中，而不是生成到一个文件中：&lt;/p&gt;
&lt;p&gt;所以使用了 node-sass 中的 sass.render 函数，抽取每个文件中的样式文件，并打包编译到对应的文件中，代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;//省略 import 引入,核心代码如下
function createCss(name){
    const lowerName = name.toLowerCase();
    sass.render({ // 调用 node-sass 函数方法，编译指定的 scss 文件到指定的路径下
        file: currPath(`../src/components/${name}/${lowerName}.scss`),
        outputStyle: 'compressed', // 进行压缩
        sourceMap: true,
    },(err,result)=&amp;gt;{
        if(err){
            console.log(err);
        }
        const stylePath = `../dist/components/${name}/`;
        fs.writeFile(currPath(stylePath+`/${lowerName}.scss`), result.css, function(err){
            if(err){
                console.log(err);
            }
        });
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就在生成的 dist 文件中的每个组件中增加了 SCSS 文件，用户通过“按需加载小节”中的方法在引入组件的时候，会调用对应的 index 文件，在 index.js 文件中就会调用对应的 SCSS 文件，从而也实现了样式文件的按需加载。&lt;/p&gt;
&lt;p&gt;但是这样还有一个问题，就是在开发组件库的时候每个组件中的 index.tsx 文件中引入的是 SCSS 文件 &lt;code&gt;import './button.scss';&lt;/code&gt; ，所以 node-sass 编译后的文件需要是 SCSS 后缀的文件（虽然已经是 CSS 格式），如果生成的是 CSS 文件，则用户在使用组件的时候就会因找不到 SCSS 文件而报错，也就是用户在使用组件的时候，也需要安装 node-sass 插件。&lt;br/&gt;不知大家有没有更好的办法，在组件库开发的时候使用的是 SCSS 文件，编译后生成的是 CSS 后缀的文件，在用户使用组件的中调用的也是 CSS 文件呢？欢迎在文末留言讨论～&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;以上就是整个搭建组件库的过程，从一开始决定使用现有的 create-react-app 脚手架和 docz 来构成核心功能，到文档的网站部署和 npm 资源的发布，最初感觉应该能够快速完成整个组件库的搭建，实际上如果要想改动这些现有的库来实现自己想要的效果，还是经历了一些探索，不过整个摸索过程也是一种收获和乐趣所在，愿走过路过的小伙伴能有所收获～&lt;/p&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;p&gt;[1] NutUI 组件库: &lt;a href=&quot;http://nutui.jd.com/#/index&quot;&gt;http://nutui.jd.com/#/index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] yep-react 组件库: &lt;a href=&quot;http://yep-react.jd.com&quot;&gt;http://yep-react.jd.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] react 官方网站: &lt;a href=&quot;https://reactjs.org/warnings/invalid-hook-call-warning.html&quot;&gt;https://reactjs.org/warnings/invalid-hook-call-warning.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] storybook: &lt;a href=&quot;https://storybook.js.org/&quot;&gt;https://storybook.js.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5] docz: &lt;a href=&quot;https://www.docz.site/&quot;&gt;https://www.docz.site/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6] docz 官方文档: &lt;a href=&quot;https://www.docz.site/docs/gatsby-theme&quot;&gt;https://www.docz.site/docs/gatsby-theme&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7] Netlify: &lt;a href=&quot;https://app.netlify.com/teams/zhenyulei/sites&quot;&gt;https://app.netlify.com/teams/zhenyulei/sites&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[8]基于 Storybook 5 打造组件库开发与文档站建设小结: &lt;a href=&quot;http://jelly.jd.com/article/5f06fe8505541b015b6a708a&quot;&gt;http://jelly.jd.com/article/5f06fe8505541b015b6a708a&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Oct 2020 00:08:00 +0000</pubDate>
<dc:creator>jdf2e</dc:creator>
<og:description>前言 俗话说：“麻雀虽小，五脏俱全”，搭建一个组件库，知之非难，行之不易，涉及到的技术方方面面，犹如海面风平浪静，实则暗礁险滩，处处惊险～ 目前团队内已经有较为成熟的 Vue 技术栈的 NutUI 组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jdrdfe/p/13805669.html</dc:identifier>
</item>
<item>
<title>BeetleX之webapi自定义响应内容 - beetlex</title>
<link>http://www.cnblogs.com/smark/p/13806610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/13806610.html</guid>
<description>&lt;p&gt;        &lt;span&gt;输出内容多样性在webapi服务中比较普遍的，有的情况使用json,xml，图片和二进制流下载等等；为了适应用不同情况的需要，组件支持自定义内容输出。接下来的主要描述组件在webapi如何定义各种内容输出来满足实际应用的需要。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;规则&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;        &lt;span&gt;组件通过接口来规范自定义内容输出&lt;/span&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IResult
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定输出的ContentType&lt;/span&gt;
        IHeaderItem ContentType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;http body长度，此值可以是零，当为零的时候组件会自动计算&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; Length { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出前用于设置相关http头信息&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Setting(HttpResponse response);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否存在http body内容&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; HasBody { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入Http body&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Write(PipeStream stream, HttpResponse response);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;
&lt;span&gt;以上是定义内容输出的接口规则，所有自定义输出都必须实现这规则。以下是针对text/plain; charset=UTF-8的基础类输出抽象类&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ResultBase : IResult
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IHeaderItem ContentType =&amp;gt;&lt;span&gt; ContentTypes.TEXT_UTF8;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Length { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasBody =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Setting(HttpResponse response)
        {}
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Write(PipeStream stream, HttpResponse response)
        {}
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;
&lt;span&gt;&lt;span&gt;在以上抽象类的基础上，组件扩展了很多基础的输出类&lt;/span&gt;。&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;服务内部错误&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerErrorResult : ResultBase
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; InnerErrorResult(&lt;span&gt;string&lt;/span&gt; code, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; messge)
    {
        Code &lt;/span&gt;=&lt;span&gt; code;
        Message &lt;/span&gt;=&lt;span&gt; messge;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; InnerErrorResult(&lt;span&gt;string&lt;/span&gt; message, Exception e, &lt;span&gt;bool&lt;/span&gt; outputStackTrace) : &lt;span&gt;this&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, message, e, outputStackTrace)
    {
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; InnerErrorResult(&lt;span&gt;string&lt;/span&gt; code, &lt;span&gt;string&lt;/span&gt; message, Exception e, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; outputStackTrace)
    {
        Code &lt;/span&gt;=&lt;span&gt; code;
        Message &lt;/span&gt;=&lt;span&gt; message;
        Error &lt;/span&gt;=&lt;span&gt; e.Message;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (outputStackTrace)
            SourceCode &lt;/span&gt;=&lt;span&gt; e.StackTrace;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            SourceCode &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Message { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Error { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Code { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SourceCode { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasBody =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Setting(HttpResponse response)
    {
        response.Code &lt;/span&gt;=&lt;span&gt; Code;
        response.CodeMsg &lt;/span&gt;=&lt;span&gt; Message;
        response.Request.ClearStream();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Write(PipeStream stream, HttpResponse response)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(Error))
        {
            stream.WriteLine(Error);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(SourceCode))
        {
            stream.WriteLine(SourceCode);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上是组件内部错误定义的输出类，所有处理的内部异常响应都是使用这类进行输出。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mIPLimit.ValidateRPS(request))
{
    token.KeepAlive &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    InnerErrorResult innerErrorResult &lt;/span&gt;= 
    &lt;span&gt;new&lt;/span&gt; InnerErrorResult(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{request.RemoteIPAddress} request limit!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    response.Result(innerErrorResult);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上是组件内部针对IP做的一个请求限制错误输出。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;JSON输出&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JsonResult : ResultBase
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; JsonResult(&lt;span&gt;object&lt;/span&gt; data, &lt;span&gt;bool&lt;/span&gt; autoGzip = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    {
        Data &lt;/span&gt;=&lt;span&gt; data;
        mAutoGzip &lt;/span&gt;=&lt;span&gt; autoGzip;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Data { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; mAutoGzip = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ArraySegment&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt;&lt;span&gt; mJsonData;
    [ThreadStatic]
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; System.Text.StringBuilder mJsonText;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnSerialize(HttpResponse response)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mJsonText == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            mJsonText &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Text.StringBuilder();
        mJsonText.Clear();
        JsonSerializer serializer &lt;/span&gt;=&lt;span&gt; response.JsonSerializer;
        System.IO.StringWriter writer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.StringWriter(mJsonText);
        JsonTextWriter jsonTextWriter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonTextWriter(writer);
        serializer.Serialize(jsonTextWriter, Data);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; charbuffer = System.Buffers.ArrayPool&amp;lt;Char&amp;gt;&lt;span&gt;.Shared.Rent(mJsonText.Length);
        mJsonText.CopyTo(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, charbuffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, mJsonText.Length);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bytes = System.Buffers.ArrayPool&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt;.Shared.Rent(mJsonText.Length * &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; len = System.Text.Encoding.UTF8.GetBytes(charbuffer, &lt;span&gt;0&lt;/span&gt;, mJsonText.Length, bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            mJsonData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArraySegment&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt;(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, len);
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
        {
            System.Buffers.ArrayPool&lt;/span&gt;&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt;&lt;span&gt;.Shared.Return(charbuffer);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Setting(HttpResponse response)
    {
        &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.Setting(response);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mAutoGzip)
            OnSerialize(response);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mAutoGzip &amp;amp;&amp;amp; mJsonData.Count &amp;gt; &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            response.Header.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gzip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; IHeaderItem ContentType =&amp;gt;&lt;span&gt; ContentTypes.JSON;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasBody =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Write(PipeStream stream, HttpResponse response)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mAutoGzip)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mJsonData.Count &amp;gt; &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; (stream.LockFree())
                    {
                        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; gzipStream = &lt;span&gt;new&lt;/span&gt; GZipStream(stream, CompressionMode.Compress, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
                        {
                            gzipStream.Write(mJsonData.Array, mJsonData.Offset, mJsonData.Count);
                            gzipStream.Flush();
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    stream.Write(mJsonData.Array, mJsonData.Offset, mJsonData.Count);
                }
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                System.Buffers.ArrayPool&lt;/span&gt;&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt;&lt;span&gt;.Shared.Return(mJsonData.Array);
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; (stream.LockFree())
            {
                response.JsonSerializer.Serialize(response.JsonWriter, Data);
                response.JsonWriter.Flush();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上是组件内部实现的Json输出，不过这个JsonResult实现有些复杂，主要是可以根据内容大小来自动进行Gzip输出。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Websocket升级响应&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UpgradeWebsocketResult : ResultBase
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UpgradeWebsocketResult(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; websocketKey)
    {
        WebsocketKey &lt;/span&gt;=&lt;span&gt; websocketKey;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; WebsocketKey { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasBody =&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Setting(HttpResponse response)
    {
        response.Code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        response.CodeMsg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Switching Protocols&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        response.Header.Add(HeaderTypeFactory.CONNECTION, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Upgrade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        response.Header.Add(HeaderTypeFactory.UPGRADE, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;websocket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        response.Header.Add(HeaderTypeFactory.SEC_WEBSOCKET_VERSION, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        SHA1 sha1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SHA1CryptoServiceProvider();
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes_sha1_in = Encoding.UTF8.GetBytes(WebsocketKey + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes_sha1_out =&lt;span&gt; sha1.ComputeHash(bytes_sha1_in);
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str_sha1_out =&lt;span&gt; Convert.ToBase64String(bytes_sha1_out);
        response.Header.Add(HeaderTypeFactory.SEC_WEBSOCKT_ACCEPT, str_sha1_out);&lt;br/&gt;}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;以上是针对websocket握手升级响应的内容&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;文件下载&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;       &lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在web服务中很多时候需要下载指定的文件或二进制内容，以下是转门针对这些需求场制定的响应对象.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DownLoadResult : BeetleX.FastHttpApi.IResult
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DownLoadResult(&lt;span&gt;string&lt;/span&gt; text, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; fileName, IHeaderItem contentType)
    {
        mData &lt;/span&gt;=&lt;span&gt; Encoding.UTF8.GetBytes(text);
        mFileName &lt;/span&gt;=&lt;span&gt; System.Web.HttpUtility.UrlEncode(fileName);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contentType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            mContentType &lt;/span&gt;=&lt;span&gt; contentType;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DownLoadResult(&lt;span&gt;byte&lt;/span&gt;[] data, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; fileName, IHeaderItem contentType)
    {
        mData &lt;/span&gt;=&lt;span&gt; data;
        mFileName &lt;/span&gt;=&lt;span&gt; System.Web.HttpUtility.UrlEncode(fileName);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contentType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            mContentType &lt;/span&gt;=&lt;span&gt; contentType;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; mFileName;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] mData;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IHeaderItem mContentType =&lt;span&gt; ContentTypes.OCTET_STREAM;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHeaderItem ContentType =&amp;gt;&lt;span&gt; mContentType;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Length { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasBody =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Setting(HttpResponse response)
    {
        response.Header.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attachment;filename={mFileName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Write(PipeStream stream, HttpResponse response)
    {
        stream.Write(mData);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;应用示例&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [Controller]
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Webapi
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Default()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BeetleX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Admin@beetlex.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Json()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(&lt;span&gt;new&lt;/span&gt; { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BeetleX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Admin@beetlex.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Download()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; txt = JsonConvert.SerializeObject(&lt;span&gt;new&lt;/span&gt; { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BeetleX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Admin@beetlex.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DownLoadResult(txt, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ContentTypes.JSON);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Image()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; Convert.FromBase64String(str);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ImageResult(&lt;span&gt;new&lt;/span&gt; ArraySegment&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt;(data, &lt;span&gt;0&lt;/span&gt;, data.Length), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image/jpeg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/254151/202010/254151-20201013080348534-1084953351.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/254151/202010/254151-20201013080356920-103528273.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/254151/202010/254151-20201013080403224-388958396.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;strong&gt;下载示例 &lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;链接：https://pan.baidu.com/s/1GX2D-Qwo9ep1gHU-sPZkUA &lt;/p&gt;
&lt;p&gt;提取码：py6m &lt;/p&gt;
</description>
<pubDate>Tue, 13 Oct 2020 00:07:00 +0000</pubDate>
<dc:creator>beetlex</dc:creator>
<og:description>输出内容多样性在webapi服务中比较普遍的，有的情况使用json,xml，图片和二进制流下载等等；为了适应用不同情况的需要，组件支持自定义内容输出。接下来的主要描述组件在webapi如何定义各种内容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smark/p/13806610.html</dc:identifier>
</item>
<item>
<title>CDH5部署三部曲之一：准备工作 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13806601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13806601.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列介绍&quot;&gt;系列介绍&lt;/h3&gt;
&lt;p&gt;《CDH5部署三部曲》共三篇文章，对CDH5.7.2版本的准备、部署、启动、设置等环节进行实战，内容如下：&lt;/p&gt;
&lt;p&gt;第一篇：《准备工作》，即CDH集群中每一台机器都要做的操作；&lt;br/&gt;第二篇：《部署和设置》，本章完成CDH集群部署和启动；&lt;br/&gt;第三篇：《问题总结》，列出实战中遇到的问题及解决办法；&lt;/p&gt;
&lt;h3 id=&quot;系列文章链接&quot;&gt;系列文章链接&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105340968&quot;&gt;《CDH5部署三部曲之一：准备工作》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105341713&quot;&gt;《CDH5部署三部曲之二：部署和设置》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details//105342156&quot;&gt;《CDH5部署三部曲之三：问题总结》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;版本信息&quot;&gt;版本信息&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;CentOS：7.6.1810&lt;/li&gt;
&lt;li&gt;Python： 2.7.5（操作系统自带）&lt;/li&gt;
&lt;li&gt;CM包：cloudera-manager-centos7-cm5.7.2_x86_64.tar.gz&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;服务器规划&quot;&gt;服务器规划&lt;/h3&gt;
&lt;p&gt;本次搭建的CDH集群一共用到三台机器，一台master，另外两台是agent：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;内存&lt;/th&gt;
&lt;th&gt;身份&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;master&lt;/td&gt;
&lt;td&gt;192.168.133.152&lt;/td&gt;
&lt;td&gt;双核4G内存&lt;/td&gt;
&lt;td&gt;管理节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;worker1&lt;/td&gt;
&lt;td&gt;192.168.133.153&lt;/td&gt;
&lt;td&gt;双核8G内存&lt;/td&gt;
&lt;td&gt;任务节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;worker2&lt;/td&gt;
&lt;td&gt;192.168.133.154&lt;/td&gt;
&lt;td&gt;双核16G内存&lt;/td&gt;
&lt;td&gt;任务节点&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;文件下载&quot;&gt;文件下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;cm下载地址：&lt;a href=&quot;http://archive.cloudera.com/cm5/cm/5/&quot;&gt;&lt;span&gt;http://archive.cloudera.com/cm5/cm/5/&lt;/span&gt;&lt;/a&gt; ，找到自己需要的cm包下载，本次实战用的是&lt;span&gt;cloudera-manager-centos7-cm5.7.2_x86_64.tar.gz&lt;/span&gt;，如下图红框：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201013075657347-1962529598.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;parcel下载地址：&lt;a href=&quot;http://archive.cloudera.com/cdh5/parcels&quot;&gt;&lt;span&gt;http://archive.cloudera.com/cdh5/parcels&lt;/span&gt;&lt;/a&gt; ，本次实战用到的是&lt;span&gt;CDH-5.7.2-1.cdh5.7.2.p0.18-el7.parcel&lt;/span&gt;，请下载下图红框中的三个文件，注意一共要下载三个文件：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201013075658196-1251807371.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;所有机器都要做的相同操作&quot;&gt;所有机器都要做的相同操作&lt;/h3&gt;
&lt;p&gt;以下操作需要master、worker1、worker2各自做一遍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;本次实战在所有机器上的操作，都使用root账号；&lt;/li&gt;
&lt;li&gt;确保所有机器都可以用SSH工具远程登录；&lt;/li&gt;
&lt;li&gt;安装时间同步工具：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum install -y ntpdate
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;时间同步：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ntpdate cn.ntp.org.cn
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;关闭和禁用防火墙：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;systemctl stop firewalld &amp;amp;&amp;amp; systemctl disable firewalld
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;关闭SELINUX：打开文件&lt;span&gt;/etc/selinux/config&lt;/span&gt;，找到&lt;span&gt;SELINUX=xxx&lt;/span&gt;那一行，改为&lt;span&gt;SELINUX=disabled&lt;/span&gt;，如下图红框：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201013075659052-593086035.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;关闭swap：打开文件&lt;span&gt;/etc/fstab&lt;/span&gt;，找到带有&lt;span&gt;swap&lt;/span&gt;的那一行，注释掉，如下图红框：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201013075659818-1996876174.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;重启电脑；&lt;/li&gt;
&lt;li&gt;新建文件夹&lt;span&gt;/usr/lib/jvm&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;安装JDK，我这里下载的是&lt;span&gt;jdk-8u191-linux-x64.tar.gz&lt;/span&gt;，解压后是个名为&lt;span&gt;jdk1.8.0_191&lt;/span&gt;的文件夹，将此文件夹放在&lt;span&gt;/usr/lib/jvm&lt;/span&gt;目录下；&lt;/li&gt;
&lt;li&gt;打开文件&lt;span&gt;/etc/profile&lt;/span&gt;，在尾部增加以下内容：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_191
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;12&quot;&gt;&lt;li&gt;使配置生效：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;13&quot;&gt;&lt;li&gt;CDH默认的JDK目录是 &lt;span&gt;/usr/java/default&lt;/span&gt;，因此要创建软链接，执行以下命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir /usr/java &amp;amp;&amp;amp; ln -s /usr/lib/jvm/jdk1.8.0_191 /usr/java/default
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;14&quot;&gt;&lt;li&gt;检查Python是否可用，如果没有还请自行安装，本次用到的是2.6或者2.7版本：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201013075700328-1668091286.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;安装多个依赖包：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum -y install chkconfig bind-utils psmisc libxslt zlib sqlite cyrus-sasl-plain cyrus-sasl-gssapi fuse fuse-libs redhat-lsb
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;16&quot;&gt;&lt;li&gt;创建目录：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir /opt/cloudera-manager
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;17&quot;&gt;&lt;li&gt;把前面准备好的文件&lt;span&gt;cloudera-manager-centos7-cm5.7.2_x86_64.tar.gz&lt;/span&gt;上传到&lt;span&gt;master&lt;/span&gt;，执行以下命令将该文件解压到&lt;span&gt;/opt/cloudera-manager&lt;/span&gt;目录：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;tar -zxvf cloudera-manager-centos7-cm5.7.2_x86_64.tar.gz -C /opt/cloudera-manager/
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;18&quot;&gt;&lt;li&gt;创建账号&lt;span&gt;cloudera-scm&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;useradd --system --no-create-home --shell=/bin/false --comment &quot;Cloudera SCM User&quot; cloudera-scm
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;19&quot;&gt;&lt;li&gt;编辑文件&lt;span&gt;config.ini&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vi /opt/cloudera-manager/cm-5.7.2/etc/cloudera-scm-agent/config.ini
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;20&quot;&gt;&lt;li&gt;修改&lt;span&gt;server_host&lt;/span&gt;的值，改为&lt;span&gt;master&lt;/span&gt;，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201013075700746-1813786872.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;新建目录 &lt;span&gt;/usr/share/java/&lt;/span&gt;，将刚才下载的&lt;span&gt;mysql-connector-java-5.1.34.jar&lt;/span&gt;放入该目录，并改名为&lt;span&gt;mysql-connector-java.jar&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;三台电脑相互免密码登录设置&quot;&gt;三台电脑相互免密码登录设置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;三台电脑的/etc/hosts文件，都增加以下相同内容：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;192.168.133.154 master
192.168.133.155 worker1
192.168.133.156 worker2
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;三台电脑都执行命令：&lt;span&gt;ssh-keygen&lt;/span&gt; 然后四个回车完成ssh公私钥创建；&lt;/li&gt;
&lt;li&gt;在master执行&lt;span&gt;ssh-copy-id root@worker1&lt;/span&gt;、&lt;span&gt;ssh-copy-id root@worker2&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在worker1执行&lt;span&gt;ssh-copy-id root@master&lt;/span&gt;、&lt;span&gt;ssh-copy-id root@worker2&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在worker2执行&lt;span&gt;ssh-copy-id root@master&lt;/span&gt;、&lt;span&gt;ssh-copy-id root@worker1&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此，准备工作全部完成，请确保所有机器都做了上述操作，下一篇会用这些机器来完成部署。&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Oct 2020 23:57:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13806601.html</dc:identifier>
</item>
<item>
<title>我要告诉你：java接口中可以定义private私有方法 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13806592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13806592.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201013073837253-1739083026.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在传统的Java编程中，被广为人知的一个知识点是：&lt;strong&gt;java Interface接口中不能定义private私有方法&lt;/strong&gt;。只允许我们定义public访问权限的方法、抽象方法或静态方法。但是从Java 9 开始，Interface 接口中允许定义私有方法和私有静态方法。下面我们就来为大家介绍其语法规则，和为什么要有这样的设计。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;其实在Java 8之前，还有另一个被广为人之的知识点：接口中所有的方法必须是abstract 抽象方法。但是，从java 8开始接口中可以包含非abstract 方法，如下文中的default方法。这个不是我们本文要为大家介绍的内容，如不熟悉，请自行补课。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、java-9接口定义私有方法&quot;&gt;一、Java 9接口定义私有方法&lt;/h3&gt;
&lt;p&gt;从Java 9开始，我们可以在Interface接口中添加private的私有方法和私有静态方法。这些私有方法将改善接口内部的代码可重用性。例如，如果需要两个默认方法来共享代码，则私有接口方法将允许它们共享代码，但不将该私有方法暴露给它的实现类调用（后文中会给大家举一个例子）。&lt;/p&gt;
&lt;p&gt;在接口中使用私有方法有四个规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接口中private方法不能是&lt;strong&gt;abstract&lt;/strong&gt;抽象方法。因为abstract抽象方法是公开的用于给接口实现类实现的方法，所以不能是private。&lt;/li&gt;
&lt;li&gt;接口中私有方法只能在接口内部的方法里面被调用。&lt;/li&gt;
&lt;li&gt;接口中私有静态方法可以在其他静态和非静态接口方法中使用。&lt;/li&gt;
&lt;li&gt;接口中私有非静态方法不能在私有静态方法内部使用。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;interface CustomInterface {

    public abstract void abstractMethod();  //抽象方法不能是私有的

    public default void defaultMethod() {
        privateMethod(); //可以调用接口中的私有方法
        privateStaticMethod(); //可以调用接口中的私有静态方法
        System.out.println(&quot;普通方法被调用&quot;);
    }

    public static void staticMethod() {
        privateStaticMethod(); //public静态方法可以调用private静态方法
        System.out.println(&quot;静态方法被调用&quot;);
    }

    private void privateMethod() {
        System.out.println(&quot;private私有方法被调用&quot;);
    }

    private static void privateStaticMethod() {
        System.out.println(&quot;private私有静态方法被调用&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上面四个规则，上面的代码定义都是正确的&lt;/p&gt;
&lt;h2 id=&quot;二、一个例子：分别计算奇数与偶数的和&quot;&gt;二、一个例子：分别计算奇数与偶数的和&lt;/h2&gt;
&lt;p&gt;接口定义如下，下文中add方法采用了java8 的Stream流操作，分别使用lambda表达式作为过滤条件，并求和。核心是：addEvenNumbers偶数求和函数和addOddNumbers奇数求和函数，都调用了add接口私有方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface CustomCalculator 
{
    default int addEvenNumbers(int... nums) { //非抽象，java8 开始可以定义default方法
        return add(n -&amp;gt; n % 2 == 0, nums);   //过滤偶数并求和，调用private私有方法
    }
 
    default int addOddNumbers(int... nums) { //非抽象，java8 开始可以定义default方法
        return add(n -&amp;gt; n % 2 != 0, nums);  //过滤奇数并求和，调用private私有方法
    }
 
    //按照过滤条件过滤奇数或偶数并sum求和：java9开始可以定义private私有方法
    private int add(IntPredicate predicate, int... nums) { 
        return IntStream.of(nums)   //java8 Stream流
                .filter(predicate)   //java8 predicate及过滤器
                .sum();  //sum求和
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口实现类MainCalculator 实现CustomCalculator接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MainCalculator implements CustomCalculator {
 
    public static void main(String[] args) {
        CustomCalculator demo = new MainCalculator ();
         
        int sumOfEvens = demo.addEvenNumbers(1,2,3,4,5,6,7,8,9);
        System.out.println(sumOfEvens);   //过滤所有偶数并求和，结果是20
         
        int sumOfOdds = demo.addOddNumbers(1,2,3,4,5,6,7,8,9);
        System.out.println(sumOfOdds);   //过滤所有奇数并求和，结果是25
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Mon, 12 Oct 2020 23:39:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在传统的Java编程中，被广为人知的一个知识点是：java Interface接口中不能定义private私有方法。只允许我们定义public访问权限的方法、抽象方法或静态方法。但是从Java 9 开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13806592.html</dc:identifier>
</item>
<item>
<title>你不知道的闭包原理【三个栗子彻底理解】 - bigname22</title>
<link>http://www.cnblogs.com/bigname/p/13806545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigname/p/13806545.html</guid>
<description>&lt;center&gt;&lt;span&gt;你不知道的闭包原理&lt;/span&gt;&lt;/center&gt;&lt;blockquote readability=&quot;4.704&quot;&gt;
&lt;p&gt;&lt;span&gt;想要理解闭包之前，就必须理解函数的创建过程、活动变量AO、作用域链。&lt;/span&gt;&lt;a href=&quot;https://blog.csdn.net/bigname22/article/details/107465318&quot;&gt;我曾写过相关的文章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;网上相关对闭包的定义：&quot;&gt;网上相关对闭包的定义：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;MDN&lt;/strong&gt;&lt;/span&gt;：函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;你不知道的JavaScript&lt;/strong&gt;&lt;/span&gt;：是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另外一个函数。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Javascript核心技术开发解密&lt;/strong&gt;&lt;/span&gt;：闭包是一种特殊对象，由两部分组成：执行上下文A + 该执行上下文创建的函数B&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;我对这些定义的理解：&quot;&gt;我对这些定义的理解：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《MDN》的解释更加接近原理，&lt;/li&gt;
&lt;li&gt;《你不知道的Javascript》的解释更多讲的是现象，&lt;/li&gt;
&lt;li&gt;《Javascript核心技术开发解密》的解释更能说明闭包的真实存在：闭包是一种特殊对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;---------------------------------人工分割线------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;下面我们通过几个栗子来一步步讲解闭包的原理：&quot;&gt;&lt;span&gt;下面我们通过几个栗子来一步步讲解闭包的原理：&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;栗子一：&quot;&gt;&lt;span&gt;栗子一：&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;    function makeFunc() {
        var name = &quot;Mozilla&quot;;
        function displayName() {
            console.log(name);
        }
        return displayName;
    }

    var myFunc = makeFunc();
    myFunc();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：Mozilla&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;混淆点1&lt;/strong&gt;当执行到var myFunc = makeFunc();makeFunc函数在执行完之后里面的name不是应该被垃圾回收机制给处理掉了吗？&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;答案&lt;/strong&gt;：其实通过垃圾回收机制大概也知道name属性不可能被回收，因为还有myFunc函数持有name的引用。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;混淆点2&lt;/strong&gt;：与普通函数有什么不同？&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;答案&lt;/strong&gt;：如果没产生闭包，那么函数中的临时变量都被回收了。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;混淆点3&lt;/strong&gt;：name属性如果不回收，那么存放在哪里？&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;答案&lt;/strong&gt;：这个问题后面会讲到&lt;br/&gt;【myFunc在google浏览器的内部属性，生成了一个闭包对象makeFunc】&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201013015004687.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;先来思考一个问题：我们知道当执行了makeFunc函数后会产生对应的变量对象{变量对象保存了函数中的临时变量}，那么上图中的闭包对象makeFunc是否就等于makeFunc函数所产生的变量对象？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;带着这个问题看下一个栗子--&lt;/p&gt;
&lt;h3 id=&quot;栗子二：&quot;&gt;&lt;span&gt;栗子二：&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;    function makeFunc() {
        var name = &quot;Mozilla&quot;;
        var age = 12;
        function displayName() {
            console.log(name);
        }
        return displayName;
    }

    var myFunc = makeFunc();
    myFunc();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;思考：&lt;/strong&gt; 此时的闭包对象makeFunc是否带有age属性？&lt;br/&gt;&lt;strong&gt;答案&lt;/strong&gt;：没有age属性&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201013022251806.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;说明&lt;/strong&gt;：闭包对象不等于makeFunc的变量对象。闭包对象仅保存跨域的属性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;延申到另一个常见问题：如何清除闭包？&lt;/span&gt;&lt;br/&gt;我们知道闭包对象存在于myFunc函数内，所以一句：myFunc = null。使得闭包对象没有引用持有那么等待他的就是垃圾回收。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再延申到另一个常见问题：MDN：在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。那么岂不是内存很快就泄露了？&lt;/span&gt;&lt;br/&gt;实际上你的闭包大多数都是没有引用持有，很快就会被回收掉的。并且JS对闭包也有相关的优化处理。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;然而：这个时候，我们是否明白这个闭包对象与作用域链的关系是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;栗子三：&quot;&gt;&lt;span&gt;栗子三：&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; var a = 20;
    function test () {
        var b = a + 10;
        function innerTest () {
                debugger
            var c = 10;
            return b + c;
        }
        innerTest();
    }
    test();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;？？？ 当执行到debugger时，此时innerTest函数的作用链是什么呢？闭包对象是否产生？&lt;br/&gt;：：：此时innerTest函数的作用链：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201013030431231.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;闭包对象已经产生，并且闭包对象作为作用域链中的对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你是否记得很多书上都说作用域链是一条又每个函数的VO对象组成的链条。但这里看到的却不是VO对象，而是闭包对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我的看法是：如果单纯从函数的作用域来看：作用域链是一条又每个函数的VO对象组成的链条。这个说法很正确，这是真正能够以此帮助我们判断访问作用域边界的依据。但是在程序实际的运行中，经过词法编译的阶段，JS引擎已经通过代码把各个实际上闭包产生的变量已经提炼出来。而不是直接就把VO对象放在作用域链。这也有利于提高访问速度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;    function makeFunc() {
        var name = &quot;Mozilla&quot;;
        function displayName() {
            console.log(name);
        }
        return displayName;
    }

    var myFunc = makeFunc();
    myFunc();
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;执行过程有关闭包的变化：&lt;/strong&gt; 当调用makeFunc()函数进入函数创建阶段时发现displayName函数含有name的跨函数变量，所以在对displayName函数进行提升的时候就已经给displayName函数初始化了闭包对象【makeFunc闭包】。所以当执行myFunc()函数的时候，从当前myFunc()的VO对象找不到的话就会从作用域链中的上一级【makeFunc闭包】对象中找。&lt;br/&gt;来个图清晰一点：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201013033708856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpZ25hbWUyMg==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;em&gt;--- 以上便是对闭包最新的理解。不对的望多多指出。&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Oct 2020 20:02:00 +0000</pubDate>
<dc:creator>bigname22</dc:creator>
<og:description>你不知道的闭包原理 想要理解闭包之前，就必须理解函数的创建过程、活动变量AO、作用域链。我曾写过相关的文章 网上相关对闭包的定义： MDN：函数和对其周围状态（lexical environment，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigname/p/13806545.html</dc:identifier>
</item>
<item>
<title>Python库之SQLAlchemy - 冷冰若水</title>
<link>http://www.cnblogs.com/lit10050528/p/13806516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lit10050528/p/13806516.html</guid>
<description>&lt;h2 id=&quot;11、sqlalchemy是什么？&quot;&gt;1.1、SQLAlchemy是什么？&lt;/h2&gt;
&lt;p&gt;sqlalchemy是一个python语言实现的的针对关系型数据库的orm库。可用于连接大多数常见的数据库，比如Postges、MySQL、SQLite、Oracle等。&lt;/p&gt;
&lt;h2 id=&quot;12、为什么要使用sqlalchemy？&quot;&gt;1.2、为什么要使用SQLAlchemy？&lt;/h2&gt;
&lt;p&gt;它将你的代码从底层数据库及其相关的SQL特性中抽象出来。&lt;/p&gt;
&lt;h2 id=&quot;13、sqlalchemy提供了两种主要的使用模式&quot;&gt;1.3、SQLAlchemy提供了两种主要的使用模式&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;SQL表达式语言（SQLAlchemy Core）&lt;/li&gt;
&lt;li&gt;ORM&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;14、应该选择哪种模式？&quot;&gt;1.4、应该选择哪种模式？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;虽然你使用的框架中已经内置了ORM，但是希望添加更强大的报表功能，请选用Core。&lt;/li&gt;
&lt;li&gt;如果你想在一个一模式为中心的视图中查看数据（用户类似于SQL），请使用Core。&lt;/li&gt;
&lt;li&gt;如果你的数据不需要业务对象，请使用Core。&lt;/li&gt;
&lt;li&gt;如果你要把数据看作业务对象，请使用ORM。&lt;/li&gt;
&lt;li&gt;如果你想快速创建原型，请使用ORM。&lt;/li&gt;
&lt;li&gt;如果你需要同事使用业务对象和其他与问题域无关的数据，请组合使用Core和ORM。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;15、连接数据库&quot;&gt;1.5、连接数据库&lt;/h2&gt;
&lt;p&gt;要连接到数据库，需要先创建一个SQLAlchemy引擎。SQLAlchemy引擎为数据库创建一个公共接口来执行SQL语句。这是通过包装数据库连接池和方言（不同数据库客户端）来实现的。&lt;/p&gt;
&lt;p&gt;SQLAlchemy提供了一个函数来创建引擎。在这个函数中，你可以指定连接字符串，以及其他一些可选的关键字参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy import create_engine
engine = create_engine('sqlite:///cookies.db')
engine1 = create_engine('sqlite:///:memory:')
engine2 = create_engine('sqlite://///home/cookiemonster/cookies.db')
engine3 = create_engine('sqlite:///c:\\Users\\cookiemonster\\cookies.db')

engine_mysql = create_engine('mysql+pymysql://cookiemonster:chocolatechip', '@mysql01.monster.internal/cookies', pool_recycle=3600)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;16、模式和类型&quot;&gt;1.6、模式和类型&lt;/h2&gt;
&lt;p&gt;为了访问底层数据库，SQLAlchemy需要用某种东西来代表数据库中的表。为此，可以使用下面三种方法总的一种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用用户定义的Table对象&lt;/li&gt;
&lt;li&gt;使用代表数据表的声明式类&lt;/li&gt;
&lt;li&gt;从数据库中推断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SQLAlchemy core定义表结构使用的是1.5中说的第1种方式。table对象包含一系列带有类型的列和属性，它们与一个常见的元数据容器相关联。&lt;/p&gt;
&lt;p&gt;元数据可以看作是一种Table对象目录。这些表可以通过MetaData.tables来访问。&lt;/p&gt;
&lt;h2 id=&quot;21、定义表结构&quot;&gt;2.1、定义表结构&lt;/h2&gt;
&lt;p&gt;在SQLAlchemy Core中，我们通过Table构造函数来初始化Table对象。我们要在构造函数中提供MetaData对象（元数据）和表名，任何其他参数都被认为是列对象。列是通过Column()函数创建的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy import create_engine
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import String
from sqlalchemy import MedaData

metadata = MetaData()
user = table('user', metadata, 
                         Column(id, Integer(), primary_key=True), 
                         Column(name, String(255)), 
)

engine = create_engine('sqlite:///:memory:')
metadata.create_all(engine) # 表的持久化
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;22、插入数据&quot;&gt;2.2、插入数据&lt;/h2&gt;
&lt;p&gt;首先创造一条insert语句，用来把小明放入user表中。为此，先调用user表的insert()方法，然后再使用values()语句，关键字参数为各个列及相应值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;ins = user.insert().values(
        id=1, 
  name='小明'
)
print(str(ins))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此仅仅只是创建了一个inset语句，还没有真正执行呢，接下来执行插入操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;connection = engine.connect()
result = connection.execute(ins)
print(result.inserted_primary_key)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23、查询数据&quot;&gt;2.3、查询数据&lt;/h2&gt;
&lt;p&gt;构建查询时，要用到select函数，它类似于标准SQL SELECT语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy.sql import select
s = select([user])
# 可以使用str(s)查看数据库看到的语句
print(str(s))
rp = connection.execute(s)
results = rp.fetchall()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;231、resultproxy&quot;&gt;2.3.1、ResultProxy&lt;/h3&gt;
&lt;p&gt;execute()函数的返回值是一热ResultProxy对象，它允许使用索引、名称或Column对象进行访问。&lt;/p&gt;
&lt;p&gt;使用ResultProxy处理行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;first_row = results[0]
first_row[1]
first_row.name
first_row[user.c.name]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;迭代ResultProxy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;rp = connection.execute(s)
for record in rp:
        print(record.user_name)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法访问结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;rp.first() # 若有记录，则返回第一个记录并关闭连接
rp.fetchone() # 返回一行，并保持光标为打开状态，以便你做更多获取调用
rp.scalar() # 入股查询结果是包含一个列的单条记录，则返回单个值
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;232、控制查询中的列数&quot;&gt;2.3.2、控制查询中的列数&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;s = select([user.c.name])
rp = connection.execute(s)
print(rp.keys())
result = rp.first()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;233、排序&quot;&gt;2.3.3、排序&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;s = select([user.c.name])
s = s.order_by(user.c.name)
rp = connection.execute(s)
for user in rp:
        print(user.name)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;234、限制返回结果集的条数&quot;&gt;2.3.4、限制返回结果集的条数&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;s = select([user.c.name])
s = s.order_by(user.c.name)
s = s.limit(2)
rp = connection.execute(s)
for user in rp:
        print(user.name)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;235、内置sql函数和标签&quot;&gt;2.3.5、内置SQL函数和标签&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy.sql import func
s = select([func.sum(user.c.score)])
rp = connection.execute(s)
print(rp.scalar())
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;236、过滤&quot;&gt;2.3.6、过滤&lt;/h3&gt;
&lt;p&gt;对查询过滤是通过添加where()语句来完成的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;s = select([user]).where(user.c.name == '小明')
rp = connection.execute(s)
record = rp.first()
print(record.items())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只是介绍了常用的查询方法，更多复杂的查询请查阅官方文档。&lt;/p&gt;
&lt;h2 id=&quot;23、更新数据&quot;&gt;2.3、更新数据&lt;/h2&gt;
&lt;p&gt;update()方法和前面的insert()方法很相似，它们的语法几乎完全一样，但是update()可以指定一个where()子句，用来指出要更新哪些行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy import update
u = update(user).where(user.c.name == '小明')
u = u.values(name='小华')
result = connection.execute(u)
print(result.rowcount)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;24、删除数据&quot;&gt;2.4、删除数据&lt;/h2&gt;
&lt;p&gt;创建删除语句时，既可以使用delete()函数，也可以使用表的delete()方法。与insert()和update()不同，delete()不接收值参数，只接收一个可选where子句，用来指定删除范文。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy import delete
u = delete(user).where(user.c.name == '小华')
result = connection.execute(u)
print(result.rowcount)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;更多的高级操作：连接、别名、分组、链式调用、原始查询等，请查阅官方文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;25、事务&quot;&gt;2.5、事务&lt;/h2&gt;
&lt;p&gt;通过connection.begin()开启一个事务，返回一个transaction对象，接下来根据执行的情况调用transaction.commit()提交修改或者调用transaction.rollback()回滚操作。&lt;/p&gt;

&lt;p&gt;SQLAlchemy orm定义表结构使用的是1.5中说的第2种方式。通过定义一个类，它继承自一个名为declarative_base的特殊基类。declarative_base把元数据容器和映射器（用来把类映射到数据表）结合在一起。&lt;/p&gt;
&lt;p&gt;orm使用的类应该满足如下四个要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继承自declarative_base对象。&lt;/li&gt;
&lt;li&gt;包含&lt;code&gt;__tablename__&lt;/code&gt;，这是数据库中使用的表名。&lt;/li&gt;
&lt;li&gt;包含一个或多个属性，它们都是column对象。&lt;/li&gt;
&lt;li&gt;确保一个或多个属性组成主键。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;31、定义表结构：&quot;&gt;3.1、定义表结构：&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy import create_engine
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()
class User(Base):
    __tablename__ = 'user'
    
        id = Column(Integer, primary_key=True)
        name = Column(String(255))
        
engine = create_engine('sqlite:///')
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)
session = Session()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32、会话（session&quot;&gt;3.2、会话（session)&lt;/h2&gt;
&lt;p&gt;会话是SQLAlchemy ORM和数据库交互的方式。它通过引擎包装数据库连接，并为通过会话加载或与会话关联的对象提供标识映射（identity map）。标识映射是一种类似于缓存的数据结构，它包含由对象表和主键确定的一个唯一的对象列表。会话还包装了一个事务，这个事务将一直保持打开状态，直到会话提交或回滚。&lt;/p&gt;
&lt;p&gt;为创建会话，SQLAlchemy提供了一个sessionmaker类，这个类可以确保在整个应用程序中能够使用相同的参数创建会话。sessionmaker类通过创建一个Session类来实现这一点，Session类是根据传递给sessionmaker工厂的参数配置的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

engine = create_engine('sqlite:///:memory:')
Session = sessionmaker(bind=engine)
session = Session()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32、插入&quot;&gt;3.2、插入&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;user = User(1, '小明')
session.add(user)
session.commit()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;33、查询&quot;&gt;3.3、查询&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for row in session.query(User):
        print(row.id, row.name)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;4.5806451612903&quot;&gt;
&lt;p&gt;注意：session.query()的返回值是Query对象，不能使用它的返回值作为查询结果。关于Query对象的用法，请参阅：&lt;a href=&quot;https://docs.sqlalchemy.org/en/13/orm/query.html#sqlalchemy.orm.query.Query&quot;&gt;https://docs.sqlalchemy.org/en/13/orm/query.html#sqlalchemy.orm.query.Query&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常用Query对象的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;q = session.query(User)
q.count() # 获取查询结果的数量
q.all() # 返回查询结果的list，会触发执行SQL查询
q.get(id) # 根据primary_key查询单个对象
q.as_scalar() # 返回此次查询的SQL语句
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;331、控制查询中的列数&quot;&gt;3.3.1、控制查询中的列数&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(session.query(user.name).first())
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;332、排序&quot;&gt;3.3.2、排序&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for record in sesssion.query(user).order_by(user.name):
        print(user.name)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;333、限制返回结果集的条数&quot;&gt;3.3.3、限制返回结果集的条数&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;query = session.query(user).order_by(user.name).[:2]
print([result.user_name for result in query])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;334、内置sql函数和标签&quot;&gt;3.3.4、内置SQL函数和标签&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy import func
inv_count = session.query(func.sum(user.name)).scalar()
print(inv_count)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;335、过滤&quot;&gt;3.3.5、过滤&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;record = session.query(user).filter(user.name == '小华')
print(record)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;34、更新数据&quot;&gt;3.4、更新数据&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;query = session.query(user)
xm_user = query.filter(user.user_name == '小华').first()
xm_user.name = 'robin'
session.commit()
print(xm_user.quantity)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;35、删除数据&quot;&gt;3.5、删除数据&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;query = session.query(user)
xm_user = query.filter(user.user_name == '小华').first()
session.delete(xm_user)
session.commit()
print(xm_user)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;这里简单介绍了SQLAlchemy orm的常见用法，更高级的用法请查阅官方文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用反射技术可以利用先用数据库填充SQLAlchemy对象。&lt;/p&gt;
&lt;h2 id=&quot;41、反射单个表&quot;&gt;4.1、反射单个表&lt;/h2&gt;
&lt;p&gt;创建初始对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchemy import Metadata, create_engines
metadata = MetaData()
engine = reate_engine('sqlite:///')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反射Artist表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sqlalchmy impport Table
artist = Table('Artist', metadata, autoload=True, autoload_with=engine)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;42、反射整个数据库&quot;&gt;4.2、反射整个数据库&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;metadata.reflect(bind=engine)
&lt;/code&gt;
&lt;/pre&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.sqlalchemy.org/en/13/core/type_basics.html#generic-types&quot;&gt;https://docs.sqlalchemy.org/en/13/core/type_basics.html#generic-types&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 12 Oct 2020 18:04:00 +0000</pubDate>
<dc:creator>冷冰若水</dc:creator>
<og:description>一、SQLAlchemy简介 1.1、SQLAlchemy是什么？ sqlalchemy是一个python语言实现的的针对关系型数据库的orm库。可用于连接大多数常见的数据库，比如Postges、My</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lit10050528/p/13806516.html</dc:identifier>
</item>
</channel>
</rss>