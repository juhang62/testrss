<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Boot （十五）： 优雅的使用 API 文档工具 Swagger2 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11689871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11689871.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191017084256810-680025870.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;各位在开发的过程中肯定遇到过被接口文档折磨的经历，由于 RESTful 接口的轻量化以及低耦合性，我们在修改接口后文档更新不及时，导致接口的调用方（无论是前端还是后端）经常抱怨接口与文档不一致。程序员的特点是特别不喜欢写文档，但是又同时特别不喜欢别人不写文档。所以 API 文档工具这时就应运而生了，本篇文章我们将会介绍 API 文档工具 Swagger2 。&lt;/p&gt;
&lt;h2 id=&quot;快速上手&quot;&gt;2. 快速上手&lt;/h2&gt;
&lt;p&gt;既然 Swagger2 是一个 API 文档工具，我们就在代码中看一下这个文档工具在 Spring Boot 中是如何使用的吧。&lt;/p&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;2.1 引入依赖&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-swagger/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- swagger工具包 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${swagger.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里选用的版本是 &lt;code&gt;2.9.2&lt;/code&gt; ，同时也是目前最新的一个版本。&lt;/p&gt;
&lt;h3 id=&quot;配置类-swaggerconfig&quot;&gt;2.2 配置类 SwaggerConfig&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-swagger/src/main/java/com/springboot/springbootswagger/config/SwaggerConfig.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Value(&quot;${swagger.show}&quot;)
    private boolean swaggerShow;

    @Bean
    public Docket swaggerSpringMvcPlugin() {
        return new Docket(DocumentationType.SWAGGER_2)
                .enable(swaggerShow)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage(&quot;com.springboot.springbootswagger&quot;))
                .paths(PathSelectors.any())
                .build();
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title(&quot;Swagger2 演示接口RESTful APIs&quot;)
                .version(&quot;1.0&quot;)
                .build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 Swagger 是一个 API 文档工具，我们肯定不能在生产环境中开启，所以笔者这里在配置中增加了 &lt;code&gt;swagger.show&lt;/code&gt; ，在不同环境的配置文件中配置不同的值，或者如果有配置中心，这个配置可以添加到配置中心中，笔者这里示例简单起见就添加在 application 配置文件中了。这样，我们就可以优雅的开启或者关闭 Swagger 的功能。&lt;/p&gt;
&lt;h3 id=&quot;实体类&quot;&gt;2.3 实体类&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-swagger/src/main/java/com/springboot/springbootswagger/model/User.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
@ApiModel(value = &quot;用户演示类&quot;, description = &quot;请求参数类&quot;)
public class User {
    @ApiModelProperty(example = &quot;1&quot;, notes = &quot;用户ID&quot;)
    private Long id;
    @ApiModelProperty(example = &quot;geekdigging&quot;, notes = &quot;用户名&quot;)
    private String nickName;
    @ApiModelProperty(example = &quot;1570689455000&quot;, notes = &quot;创建时间&quot;)
    private Date createDate;
    @ApiModelProperty(example = &quot;18&quot;, notes = &quot;用户年龄&quot;)
    private Integer age;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Swagger 注解详细说明：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ApiModel&lt;/td&gt;
&lt;td&gt;描述返回对象的意义&lt;/td&gt;
&lt;td&gt;用在返回对象类上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ApiModelProperty&lt;/td&gt;
&lt;td&gt;对象属性&lt;/td&gt;
&lt;td&gt;用在出入参数对象的字段上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@Api&lt;/td&gt;
&lt;td&gt;协议集描述&lt;/td&gt;
&lt;td&gt;用于 controller 类上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ApiOperation&lt;/td&gt;
&lt;td&gt;协议描述&lt;/td&gt;
&lt;td&gt;用在 controller 的方法上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ApiResponses&lt;/td&gt;
&lt;td&gt;Response集&lt;/td&gt;
&lt;td&gt;用在 controller 的方法上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ApiResponse&lt;/td&gt;
&lt;td&gt;Response&lt;/td&gt;
&lt;td&gt;用在 @ApiResponses 里边&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ApiImplicitParams&lt;/td&gt;
&lt;td&gt;非对象参数集&lt;/td&gt;
&lt;td&gt;用在 controller 的方法上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ApiImplicitParam&lt;/td&gt;
&lt;td&gt;非对象参数描述&lt;/td&gt;
&lt;td&gt;用在 @ApiImplicitParams 的方法里边&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;controller&quot;&gt;2.4 Controller&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-swagger/src/main/java/com/springboot/springbootswagger/controller/UserController.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Api(value = &quot;用户管理演示&quot;)
@RestController
public class UserController {

    @Autowired
    UserService userService;

    @GetMapping(&quot;/getUserById/{id}&quot;)
    @ApiOperation(value = &quot;获取用户信息&quot;, notes = &quot;根据用户 id 获取用户信息&quot;, tags = &quot;查询用户信息类&quot;)
    public User getUserById(@PathVariable Long id) {
        return userService.getUserById(id);
    }

    @GetMapping(&quot;/getAllUsers&quot;)
    @ApiOperation(value = &quot;获取全部用户信息&quot;, notes = &quot;获取全部用户信息&quot;, tags = &quot;查询用户信息类&quot;)
    public List&amp;lt;User&amp;gt; getAllUsers() {
        return userService.getAllUsers();
    }

    @PostMapping(&quot;/saveUser&quot;)
    @ApiOperation(value = &quot;新增/修改用户信息&quot;)
    public User saveUser(@RequestBody User user) {
        return userService.saveUser(user);
    }

    @DeleteMapping(&quot;/deleteById&quot;)
    @ApiOperation(value = &quot;删除用户信息&quot;, notes = &quot;根据用户 id 删除用户信息&quot;)
    public String deleteById(@PathVariable Long id) {
        userService.deleteById(id);
        return &quot;success&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;@ApiOperation 中的 tag 标签可用于接口分组&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;展示结果如下&quot;&gt;2.5 展示结果如下&lt;/h3&gt;
&lt;p&gt;启动工程，打开浏览器访问： http://localhost:8080/swagger-ui.html ，可以看到如下页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191017084256973-1986847969.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图中可以看到我们的 tag 分组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191017084257162-470420834.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191017084257308-1225102680.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;3. 示例代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/spring-boot-examples/tree/master/spring-boot-swagger&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/spring-boot-examples/tree/master/spring-boot-swagger&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;4. 参考&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/xupeng874395012/article/details/68946676&lt;/p&gt;
</description>
<pubDate>Thu, 17 Oct 2019 00:43:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1. 引言 各位在开发的过程中肯定遇到过被接口文档折磨的经历，由于 RESTful 接口的轻量化以及低耦合性，我们在修改接口后文档更新不及时，导致接口的调用方（无论是前端还是后端）经常抱怨接口与文档不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11689871.html</dc:identifier>
</item>
<item>
<title>Java8新特性之空指针异常的克星Optional类 - 程序新视界</title>
<link>http://www.cnblogs.com/secbro/p/11689773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/secbro/p/11689773.html</guid>
<description>&lt;p&gt;Java8新特性系列我们已经介绍了Stream、Lambda表达式、DateTime日期时间处理，最后以“NullPointerException” 的克星Optional类的讲解来收尾。&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;作为开发人员每天与NullPointerException斗智斗勇。每接收到参数或调用方法获得值得判断一下是否为null。稍不留意，空指针异常就像幽灵一样出现了。&lt;/p&gt;
&lt;p&gt;这篇文章我们来学习Java8是如何通过Optional类来避免空指针异常的。&lt;/p&gt;
&lt;p&gt;先来看一下不使用Optional类时，我们为了防止NullPointerException会怎么处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public String getParentName(Person son) {
    if (son != null) {
        Person parent = son.getParent();
        if (parent != null) {
            return parent.getUsername();
        } else {
            return &quot;--&quot;;
        }
    }

    return &quot;--&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了防止出现异常，需要不停的判断对象是否为null。但如果业务逻辑比较复杂，会涌现出大量的ifelse。看似逻辑缜密，但易读性却并不高。&lt;/p&gt;
&lt;p&gt;为了解决相关问题，在Effective Java中建议若方法返回类型为集合，则通过返回空集合以避免 NullPointerException，真是煞费苦心。&lt;/p&gt;
&lt;p&gt;先看一下上面的代码使用Optional之后会变成什么样子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public String getParentNameWithOptional(Person son) {
    return Optional.ofNullable(son).map(Person::getParent).map(Person::getUsername).orElse(&quot;--&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对照一下代码，看看神不神奇？！&lt;/p&gt;
&lt;h3 id=&quot;optional类简介&quot;&gt;Optional类简介&lt;/h3&gt;
&lt;p&gt;java.util.Optional类的引入很好的解决空指针异常，类声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final class Optional&amp;lt;T&amp;gt; {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;java.util.Optional类是一个封装了Optional值的容器对象，Optional值可以为null，如果值存在，调用isPresent()方法返回true，调用get()方法可以获取值。&lt;/p&gt;
&lt;p&gt;通过源代码会发现，它并没有实现java.io.Serializable接口，因此应避免在类属性中使用，防止意想不到的问题。&lt;/p&gt;
&lt;p&gt;除了Optional类之外，还扩展了一些常用类型的Optional对象，比如：OptionalDouble、OptionalInt、OptionalLong。用法基本上相似。&lt;/p&gt;
&lt;p&gt;下面通过具体的操作和功能来了解Optional类。&lt;/p&gt;
&lt;h3 id=&quot;创建optional对象&quot;&gt;创建Optional对象&lt;/h3&gt;
&lt;p&gt;创建Optional对象有三种方法：empty()、of()、ofNullable()，均为静态方法。&lt;/p&gt;
&lt;p&gt;如果Optional对象没有值则用empty()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional empty = Optional.empty();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果确定Optional对象的值不为null，则可用of()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional stringOptional = Optional.of(&quot;Hello 公众号：程序新视界&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不确定Optional对象的值是否为null，则可用ofNullable()。比如上面，不确定Person对象是不否null，就用了ofNullable()方法。当然，也可以直接给该方法传null。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional ofNullOptional = Optional.ofNullable(null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，通过调用其isPresent方法可以查看该Optional中是否值为null。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean bool = ofNullOptional.isPresent();
System.out.println(bool);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时如果直接调用get方法获取值，则会抛出异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ofNullOptional.get();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;get获取optional中的值&quot;&gt;get获取Optional中的值&lt;/h3&gt;
&lt;p&gt;通过get方法可获取Optional中的值，但如果值为null，则会抛出异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional ofNullOptional = Optional.ofNullable(null);
ofNullOptional.get();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异常信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.util.NoSuchElementException: No value present
    at java.util.Optional.get(Optional.java:135)
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，需要另外一个方法的辅助：isPresent()。该方法可判定Optional中是否有值，如果有则返回true，如果没有则返回false。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional ofNullOptional = Optional.ofNullable(null);
boolean bool = ofNullOptional.isPresent();
if(bool){
    ofNullOptional.get();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map获取optional中的值&quot;&gt;map获取Optional中的值&lt;/h3&gt;
&lt;p&gt;对于对象操作，也可以通过map来获取值，最开始简化的例子就是如此。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional&amp;lt;Person&amp;gt; sonOptional = Optional.ofNullable(son);
System.out.println(sonOptional.map(Person::getUsername));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;map方法，如果有值，则对其执行调用映射函数得到返回值。如果返回值不为null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。&lt;/p&gt;
&lt;h3 id=&quot;flatmap获取optional中的值&quot;&gt;flatMap获取Optional中的值&lt;/h3&gt;
&lt;p&gt;如果有值，则返回Optional类型返回值，否则返回空Optional。flatMap与map方法类似。但flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional&amp;lt;Person&amp;gt; sonOptional = Optional.ofNullable(son);
sonOptional.flatMap(OptionalTest::getOptionalPerson);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用的是当前类OptionalTest的另外一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Optional&amp;lt;Person&amp;gt; getOptionalPerson(Person person){
    return Optional.ofNullable(person);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;orelse获取optional中的值&quot;&gt;orElse获取Optional中的值&lt;/h3&gt;
&lt;p&gt;orElse方法，如果有值就返回，否则返回一个给定的值作为默认值；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional.empty().orElse(&quot;--&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这种情况就会返回“--”。&lt;/p&gt;
&lt;p&gt;在此，这种操作与三目运算效果一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;str != null ? str : &quot;--&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;orelseget获取optional中的值&quot;&gt;orElseGet获取Optional中的值&lt;/h3&gt;
&lt;p&gt;orElseGet()方法与orElse()方法作用类似，但生成默认值的方式不同。该方法接受一个Supplier&amp;lt;? extends T&amp;gt;函数式接口参数，用于生成默认值；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional.empty().orElseGet(() -&amp;gt; {
            String a = &quot;关注&quot;;
            String b = &quot;公众号：程序新视界&quot;;
            return a + b;
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很显然，这里可以处理更多的业务逻辑。&lt;/p&gt;
&lt;h3 id=&quot;orelsethrow获取optional中的值&quot;&gt;orElseThrow获取Optional中的值&lt;/h3&gt;
&lt;p&gt;orElseThrow()方法与get()方法类似，当值为null时调用会抛出NullPointerException异常，但该方法可以指定抛出的异常类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional.empty().orElseThrow(()-&amp;gt; new RuntimeException(&quot;请先关注公众号！&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时打印异常信息为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional.empty().orElseThrow(()-&amp;gt; new RuntimeException(&quot;请先关注公众号！&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断并执行操作&quot;&gt;判断并执行操作&lt;/h3&gt;
&lt;p&gt;ifPresent方法，可对值进行判断然后打印，接收参数为Consumer&amp;lt;? super T&amp;gt;函数式接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional.of(&quot;公众号：程序新视界&quot;).ifPresent(System.out::println);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，也可以在函数中执行其他复杂操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional.of(&quot;公众号：程序新视界&quot;).ifPresent((val)-&amp;gt;{
            System.out.println(&quot;欢迎关注&quot; + val);
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;filter方法过滤&quot;&gt;filter()方法过滤&lt;/h3&gt;
&lt;p&gt;filter()方法可用于判断Optional对象是否满足给定条件，一般用于条件过滤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional.of(&quot;公众号：程序新视界&quot;).filter((val)-&amp;gt;{
    return val.contains(&quot;程序新视界&quot;);
});
// 简化写法
Optional.of(&quot;公众号：程序新视界&quot;).filter((val)-&amp;gt; val.contains(&quot;程序新视界&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用误区&quot;&gt;使用误区&lt;/h3&gt;
&lt;p&gt;关于使用Optional的误区有以下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正确的使用创建方法，不确定是否为null时尽量选择ofNullable方法。&lt;/li&gt;
&lt;li&gt;避免用在成员变量上（原因上面已经提到）；&lt;/li&gt;
&lt;li&gt;避免直接调用Optional对象的get和isPresent方法；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后一条可能难理解，试想一下如果先用isPresent方法获得是否存在，然后决定是否调用get方法和之前的ifelse判断并无二致。&lt;/p&gt;
&lt;p&gt;Java8提倡函数式编程，新增的许多API都可以用函数式编程表示，Optional类也是其中之一。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;至此，Java8新特性相关的内容便完结了。&lt;/p&gt;
&lt;p&gt;Java8新特性系列相关文章：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关注公众号“程序新视界”，回复“001”，获得整个《Java8新特性系列》的PDF版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文链接：《&lt;a href=&quot;https://www.choupangxia.com/2019/10/17/java8%e6%96%b0%e7%89%b9%e6%80%a7%e4%b9%8b%e7%a9%ba%e6%8c%87%e9%92%88%e5%bc%82%e5%b8%b8%e7%9a%84%e5%85%8b%e6%98%9foptional%e7%b1%bb/&quot;&gt;Java8新特性之空指针异常的克星Optional类&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;&lt;br/&gt;&lt;/h2&gt;
&lt;center&gt;&lt;strong&gt;程序新视界&lt;/strong&gt;：精彩和成长都不容错过&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742867/201910/1742867-20191013111755842-2090947098.png&quot; alt=&quot;程序新视界-微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Oct 2019 23:27:00 +0000</pubDate>
<dc:creator>程序新视界</dc:creator>
<og:description>Java8新特性系列我们已经介绍了Stream、Lambda表达式、DateTime日期时间处理，最后以“NullPointerException” 的克星Optional类的讲解来收尾。 背景 作为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/secbro/p/11689773.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 依赖注入：IoC模式 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html</guid>
<description>&lt;p&gt;正如我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;依赖注入：控制反转&lt;/a&gt;》提到过的，很多人将IoC理解为一种“面向对象的设计模式”，实际上IoC不仅与面向对象没有必然的联系，它自身甚至算不上是一种设计模式。一般来讲，设计模式提供了一种解决某种具体问题的方案，但是IoC既没有一个针对性的问题领域，其自身也没有提供一种可操作性的解决方案，所以我们更加倾向于将IoC视为一种设计原则。很多我们熟悉的设计模式背后都采用了IoC原则，接下来我们就来介绍几种典型的“设计模式”。&lt;/p&gt;

&lt;p&gt;提到IoC，很多人首先想到的是依赖注入，但是在我看来与IoC联系得最为紧密的倒是另一种被称为“&lt;strong&gt;模板方法（Template Method）&lt;/strong&gt;”的设计模式。模板方法模式与IoC的意图可以说不谋而合，该模式主张将一个可复用的工作流程或者由多个步骤组成的算法定义成模板方法，组成这个流程或者算法的单一步骤则实现在相应的虚方法之中，模板方法根据预先编排的流程去调用这些虚方法。这些方法均定义在一个类中，我们可以通过派生该类并重写相应的虚方法的方式达到对流程定制的目的。&lt;/p&gt;
&lt;p&gt;对于前面我们演示的这个MVC的例子，我们可以将整个请求处理流程实现在一个MvcEngine类中。如下面的代码片段所示，我们将请求的监听与接收、目标Controller的激活与执行以及View的呈现分别定义在5个受保护的虚方法中，模板方法StartAsync根据预定义的请求处理流程先后调用这5个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngine
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task StartAsync(Uri address)
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; ListenAsync(address);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ReceiveAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; CreateControllerAsync(request);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ExecuteControllerAsync(controller);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; RenderViewAsync(view);
        }
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task ListenAsync(Uri address);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Task&amp;lt;Request&amp;gt;&lt;span&gt; ReceiveAsync();
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Task&amp;lt;Controller&amp;gt;&lt;span&gt; CreateControllerAsync(Request request);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Task&amp;lt;View&amp;gt;&lt;span&gt; ExecuteControllerAsync(Controller controller);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task RenderViewAsync(View view);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于具体的应用程序来说，如果定义在MvcEngine中针对请求的处理方式完全符合要求，它只需要创建一个MvcEngine对象，然后指定一个监听地址调用模板方法StartAsync开启这个MVC引擎即可。如果该MVC引擎处理请求的某个环节不能满足要求，我们可以创建MvcEngine的派生类，并重写实现该环节的相应虚方法即可。比如说定义在某个应用程序中的Controller都是无状态的，它希望采用单例（Singleton）的方式重用已经激活的Controller对象以提高性能，那么它就可以按照如下的方式创建一个自定义的FoobarMvcEngine并按照自己的方式重写CreateControllerAsync方法即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMvcEngine : MvcEngine
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task&amp;lt;View&amp;gt;&lt;span&gt; CreateControllerAsync (Request request)
    {
        &lt;/span&gt;&amp;lt;&amp;lt;省略实现&amp;gt;&amp;gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于一个复杂的流程来说，我们倾向于将组成该流程的各个环节实现在相应的组件之中，那么针对流程的定制就可以通过提供相应组件的形式来实现。我们知道23种设计模式之中有一种重要的类型，那就是“创建型模式”，比如常用的“工厂方法”和“抽象工厂”，IoC所体现的针对流程的共享与定制同样可以通过这些设计模式来完成。&lt;/p&gt;
&lt;p&gt;所谓的工厂方法，说白了就是在某个类中定义用来提供所需服务对象的方法，这个方法可以是一个单纯的虚方法，也可以是具有默认实现的虚方法。至于方法声明的返回类型，可以是一个接口或者抽象类，也可以是未封闭（Sealed）的具体类型。作为它的派生类型，可以实现或者重写工厂方法以提供所需的服务对象。&lt;/p&gt;
&lt;p&gt;同样以我们的MVC框架为例，我们让独立的组件来完成整个请求处理流程的几个核心环节。具体来说，我们为这些核心组件定义了如下几个对应的接口。IWebListener接口用来监听、接收和响应请求（针对请求的响应由ReceiveAsync方法返回的HttpContext上下文来完成），IControllerActivator接口用于根据当前HttpContext上下文激活目标Controller对象，并在Controller对象执行后做一些释放回收工作。至于IControllerExecutor和IViewRender接口则分别用来完成针对Controller的执行和针对View的呈现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWebListener
{
    Task ListenAsync(Uri address);
    Task&lt;/span&gt;&amp;lt;HttpContext&amp;gt;&lt;span&gt; ReceiveAsync();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IControllerActivator
{
    Task&lt;/span&gt;&amp;lt;Controller&amp;gt;&lt;span&gt; CreateControllerAsync(HttpContext httpContext);
    Task ReleaseAsync(Controller controller);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IControllerExecutor
{
    Task&lt;/span&gt;&amp;lt;View&amp;gt;&lt;span&gt; ExecuteAsync(Controller controller, HttpContext httpContext);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IViewRender
{
    Task RendAsync(View view, HttpContext httpContext);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在作为MVC引擎的MvcEngine中定义了四个工厂方法（GetWebListener、GetControllerActivator、GetControllerExecutor和GetViewRenderer）来提供上述这四种组件。这四个工厂方法均为具有默认实现的虚方法，我们可以利用它们提供默认的组件。在用于启动引擎的StartAsync方法中，我们利用这些工厂方法提供的对象来具体完成整个请求处理流程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngine
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task StartAsync(Uri address)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listener =&lt;span&gt; GetWebListener();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; activator =&lt;span&gt; GetControllerActivator();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; executor =&lt;span&gt; GetControllerExecutor();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; render =&lt;span&gt; GetViewRender();

        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ListenAsync(address);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContext = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ReceiveAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.CreateControllerAsync(httpContext);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; executor.ExecuteAsync(controller, httpContext);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; render.RendAsync(view, httpContext);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.ReleaseAsync(controller);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IWebLister GetWebListener(); 
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IControllerActivator GetControllerActivator();
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IControllerExecutor GetControllerExecutor();
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IViewRender GetViewRender();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于具体的应用程序来说，如果需要对请求处理的某个环节进行定制，它需要将定制的操作实现在对应接口的实现类中。在MvcEngine的派生类中，我们需要重写对应的工厂方法来提供被定制的对象即可。 比如上面提及的以单例模式提供目标Controller对象的实现就定义在SingletonControllerActivator类中，我们在派生于MvcEngine的FoobarMvcEngine类中重写了工厂方法GetControllerActivator使其返回一个SingletonControllerActivator对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingletonControllerActivator : IControllerActivator
{         
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;Controller&amp;gt;&lt;span&gt; CreateControllerAsync(HttpContext httpContext)
    {
        &lt;/span&gt;&amp;lt;&amp;lt;省略实现&amp;gt;&amp;gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task ReleaseAsync(Controller controller) =&amp;gt;&lt;span&gt; Task.CompletedTask;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMvcEngine : MvcEngine
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; ControllerActivator GetControllerActivator() =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingletonControllerActivator();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然工厂方法和抽象工厂均提供了一个“生产”对象实例的工厂，但是两者在设计上却有本质的不同。工厂方法利用定义在某个类型的抽象方法或者虚方法完成了针对“&lt;strong&gt;单一对象&lt;/strong&gt;”的提供，而抽象工厂则利用一个独立的接口或者抽象类来提供“&lt;strong&gt;一组相关的对象&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;具体来说，我们需要定义一个独立的工厂接口或者抽象工厂类，并在其中定义多个工厂方法来提供“&lt;strong&gt;同一系列&lt;/strong&gt;”的多个相关对象。如果希望抽象工厂具有一组默认的“产出”，我们也可以将一个未被封闭类型作为抽象工厂，以虚方法形式定义的工厂方法将默认的对象作为返回值。在具体的应用开发中，我们可以通过实现工厂接口或者继承抽象工厂类（不一定是抽象类）的方式来定义具体工厂类，并利用它来提供一组定制的对象系列。&lt;/p&gt;
&lt;p&gt;现在我们采用抽象工厂模式来改造我们的MVC框架。如下面的代码片段所示，我们定义了一个名为IMvcEngineFactory的接口作为抽象工厂，并在其中定义了四个方法来提供请求监听和处理过程使用到的四种核心对象。如果MVC提供了针对这四种核心组件的默认实现，我们可以按照如下的方式为这个抽象工厂提供一个默认实现（MvcEngineFactory）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IMvcEngineFactory
{
    IWebLister GetWebListener();
    IControllerActivator GetControllerActivator();
    IControllerExecutor GetControllerExecutor();
    IViewRender GetViewRender();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngineFactory： IMvcEngineFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IWebLister GetWebListener();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IControllerActivator GetControllerActivator();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IControllerExecutor GetControllerExecutor();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IViewRender GetViewRender();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们采用抽象工厂模式来改造我们的MVC框架。我们在创建MvcEngine对象的时候提供一个具体的IMvcEngineFactory对象，如果没有显式指定，MvcEngine会默认使用EngineFactory对象。在用于启动引擎的StartAsync方法中，MvcEngine利用IMvcEngineFactory对象来获取相应的对象来完成对请求的处理流程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngine
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IMvcEngineFactory EngineFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MvcEngine(IMvcEngineFactory engineFactory = &lt;span&gt;null&lt;/span&gt;)  =&amp;gt; EngineFactory = engineFactory ?? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MvcEngineFactory();
        
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task StartAsync(Uri address)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listener =&lt;span&gt; EngineFactory.GetWebListener();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; activator =&lt;span&gt; EngineFactory.GetControllerActivator();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; executor =&lt;span&gt; EngineFactory.GetControllerExecutor();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; render =&lt;span&gt; EngineFactory.GetViewRender();

        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ListenAsync(address);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContext = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ReceiveAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.CreateControllerAsync(httpContext);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; executor.ExecuteAsync(controller, httpContext);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; render.RendAsync(view, httpContext);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.ReleaseAsync(controller);
            }
        }
    }        
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果具体的应用程序需要采用前面定义的SingletonControllerActivator以单例的模式来激活目标Controller对对象，可以按照如下的方式定义一个具体的工厂类FoobarEngineFactory。最终的应用程序将利用这个FoobarEngineFactory对象来创建作为引擎的MvcEngine对象即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarEngineFactory : EngineFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; ControllerActivator GetControllerActivator()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingletonControllerActivator();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; address = &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://0.0.0.0:8080/mvcapp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; engine = &lt;span&gt;new&lt;/span&gt; MvcEngine(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FoobarEngineFactory());
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; engine.StartAsync(address);
        ...
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：IoC模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入：一个迷你版DI框架&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Oct 2019 21:41:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>正如我们在《依赖注入：控制反转》提到过的，很多人将IoC理解为一种“面向对象的设计模式”，实际上IoC不仅与面向对象没有必然的联系，它自身甚至算不上是一种设计模式。一般来讲，设计模式提供了一种解决某种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html</dc:identifier>
</item>
<item>
<title>Cocos2d-x入门之旅[1]场景 - zhxmdefj</title>
<link>http://www.cnblogs.com/zhxmdefj/p/11689693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxmdefj/p/11689693.html</guid>
<description>&lt;p&gt;在游戏开发过程中，你可能需要一个主菜单，几个关卡和一个END的界面，如何组织管理这些东西呢？&lt;/p&gt;
&lt;p&gt;和其他游戏引擎类似，Cocos也使用了&lt;strong&gt;场景(Scene)&lt;/strong&gt; 这个概念&lt;/p&gt;
&lt;p&gt;试想象一部电影或是番剧，你不难发现它是被分解为不同场景或不同时间线的，这些部分就是一个又一个的场景&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/NightFrost/p/11688854.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/NightFrost/p/11688854.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;场景的存储结构&quot;&gt;场景的存储结构&lt;/h2&gt;
&lt;p&gt;为了解释场景的结构，我们先不看我们过于简单的helloworld场景，看下面这个官方文档的场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191017003059523-2072215116.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个主菜单场景，这个场景是由很多小的对象拼接而成，所有的对象组合在一起，形成了你看到的结果&lt;/p&gt;
&lt;p&gt;场景是被&lt;strong&gt;渲染器(renderer)&lt;/strong&gt;画出来的，渲染器负责渲染精灵和其它的对象进入屏幕，那渲染器怎么知道什么东西要渲染在后，什么东西要渲染在前呢？&lt;/p&gt;
&lt;p&gt;答案是通过&lt;strong&gt;场景图(Scene Graph)&lt;/strong&gt;实现&lt;/p&gt;
&lt;h3 id=&quot;场景图scene-graph&quot;&gt;场景图(Scene Graph)&lt;/h3&gt;
&lt;p&gt;Cocos2d-x使用&lt;strong&gt;场景图(Scene Graph)&lt;/strong&gt;这一数据结构来安排场景内渲染的对象，场景内所有的&lt;strong&gt;节点(Node)&lt;/strong&gt;都包含在一个&lt;strong&gt;树(tree)&lt;/strong&gt;上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191017001947779-1632083023.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Cocos2d-x使用 &lt;strong&gt;中序遍历&lt;/strong&gt;，先遍历左子树，然后根节点，最后是右子树&lt;/p&gt;
&lt;p&gt;中序遍历下图的节点，能得到 &lt;code&gt;A, B, C, D, E, F, G, H, I&lt;/code&gt; 这样的序列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191017002002191-73265266.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们再看这个游戏场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191017003059523-2072215116.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分解这场景为5个部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191017003214623-56281281.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抽象成数据结构就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191017003119384-315541501.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;z-order&quot;&gt;z-order&lt;/h3&gt;
&lt;p&gt;树上的每个元素都会存储一个&lt;strong&gt;z-order&lt;/strong&gt;，z-order为负的元素，z-order为负的节点会被放置在左子树，非负的节点会被放在右子树，实际开发的过程中，你可以按照任意顺序添加对象，他们会按照你指定的 z-order 自动排序&lt;/p&gt;
&lt;p&gt;在 Cocos2d-x 中，通过 &lt;code&gt;Scene&lt;/code&gt; 的 &lt;code&gt;addChild()&lt;/code&gt; 方法构建场景图&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Adds a child with the z-order of -2, that means
// it goes to the &quot;left&quot; side of the tree (because it is negative)
scene-&amp;gt;addChild(title_node, -2);

// When you don't specify the z-order, it will use 0
scene-&amp;gt;addChild(label_node);

// Adds a child with the z-order of 1, that means
// it goes to the &quot;right&quot; side of the tree (because it is positive)
scene-&amp;gt;addChild(sprite_node, 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;渲染时 &lt;code&gt;z-order&lt;/code&gt; &lt;strong&gt;值大的节点对象后绘制&lt;/strong&gt;，&lt;strong&gt;值小的节点对象先绘制&lt;/strong&gt;，如果两个节点对象的绘制范围有重叠，&lt;code&gt;z-order&lt;/code&gt; 值大的可能会覆盖 &lt;code&gt;z-order&lt;/code&gt; 值小的，这才实现了我们的需求&lt;/p&gt;
&lt;h2 id=&quot;helloworld场景&quot;&gt;HelloWorld场景&lt;/h2&gt;
&lt;p&gt;现在我们回看我们运行出来的HelloWorld场景，并且具体到代码操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/zhxmd/AppData/Roaming/Typora/typora-user-images/1571242412902.png&quot; alt=&quot;1571242412902&quot;/&gt;&lt;/p&gt;
&lt;p&gt;场景中有一个我们自己的图片，一个关闭按钮，一个HelloWorld的字样，这些东西都是在&lt;code&gt;HelloWorld::init()&lt;/code&gt;中生成的&lt;/p&gt;
&lt;h3 id=&quot;场景初始化&quot;&gt;场景初始化&lt;/h3&gt;
&lt;p&gt;我们向HelloWorld场景添加东西之前，需要先调用基类&lt;code&gt;Scene&lt;/code&gt;类的初始化函数，然后获得&lt;code&gt;visibleSize&lt;/code&gt;和&lt;code&gt;origin&lt;/code&gt;备用&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;bool HelloWorld::init()
{
    //////////////////////////////
    // 1. super init first
    if ( !Scene::init() )
    {
        return false;
    }
    auto visibleSize = Director::getInstance()-&amp;gt;getVisibleSize();
    Vec2 origin = Director::getInstance()-&amp;gt;getVisibleOrigin();
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关闭按钮的生成&quot;&gt;关闭按钮的生成&lt;/h3&gt;
&lt;p&gt;相关代码如下&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;bool HelloWorld::init()
{
    ...
        
    /////////////////////////////
    // 2. add a menu item with &quot;X&quot; image, which is clicked to quit the program
    //    you may modify it.

    // add a &quot;close&quot; icon to exit the progress. it's an autorelease object
    auto closeItem = MenuItemImage::create(
                                           &quot;CloseNormal.png&quot;,
                                           &quot;CloseSelected.png&quot;,
                                           CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));

    if (closeItem == nullptr ||
        closeItem-&amp;gt;getContentSize().width &amp;lt;= 0 ||
        closeItem-&amp;gt;getContentSize().height &amp;lt;= 0)
    {
        problemLoading(&quot;'CloseNormal.png' and 'CloseSelected.png'&quot;);
    }
    else
    {
        float x = origin.x + visibleSize.width - closeItem-&amp;gt;getContentSize().width/2;
        float y = origin.y + closeItem-&amp;gt;getContentSize().height/2;
        closeItem-&amp;gt;setPosition(Vec2(x,y));
    }

    // create menu, it's an autorelease object
    auto menu = Menu::create(closeItem, NULL);
    menu-&amp;gt;setPosition(Vec2::ZERO);
    this-&amp;gt;addChild(menu, 1);
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cocos里很多对象在生成的时候都会使用create这个静态工厂方法，我们创建图片精灵的时候就用到了&lt;code&gt;auto mySprite = Sprite::create(&quot;xxxxxx.png&quot;)&lt;/code&gt;，HelloWorld这个场景也不例外&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MenuItemImage&lt;/strong&gt;的create方法传入默认状态的&lt;strong&gt;close按钮的图片&lt;/strong&gt;、&lt;strong&gt;点击状态下的close按钮的图片&lt;/strong&gt;以及一个&lt;strong&gt;回调&lt;/strong&gt;，回调指的是程序对按钮被按下这个事件做出的响应，看不懂没关系，照着写就好&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;auto closeItem = MenuItemImage::create(
    &quot;CloseNormal.png&quot;,
    &quot;CloseSelected.png&quot;,
    CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是计算出x和y的值，也就是右下角的按钮的坐标，&lt;strong&gt;getContentSize()&lt;/strong&gt;获得对象的尺寸，最后使用&lt;strong&gt;setPosition&lt;/strong&gt;设置按钮的坐标&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;if (closeItem == nullptr ||
    closeItem-&amp;gt;getContentSize().width &amp;lt;= 0 ||
    closeItem-&amp;gt;getContentSize().height &amp;lt;= 0)
{
    problemLoading(&quot;'CloseNormal.png' and 'CloseSelected.png'&quot;);
}
else
{
    float x = origin.x + visibleSize.width - closeItem-&amp;gt;getContentSize().width/2;
    float y = origin.y + closeItem-&amp;gt;getContentSize().height/2;
    closeItem-&amp;gt;setPosition(Vec2(x,y));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是按钮是不可以直接添加到场景中的，按钮需要依赖菜单，也就是&lt;strong&gt;Menu&lt;/strong&gt;对象&lt;/p&gt;

&lt;p&gt;我们创建一个包含了&lt;strong&gt;closeItem&lt;/strong&gt;的菜单，并设置坐标为（0，0），最后才能使用&lt;strong&gt;addChild&lt;/strong&gt;将菜单添加到场景中&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;// create menu, it's an autorelease object
auto menu = Menu::create(closeItem, NULL);
menu-&amp;gt;setPosition(Vec2::ZERO);
this-&amp;gt;addChild(menu, 1); &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字体的生成&quot;&gt;字体的生成&lt;/h3&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;bool HelloWorld::init()
{
    ...
        
    auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/Marker Felt.ttf&quot;, 24);
    //Label::createWithTTF(显示的字符串,字体,字体大小);
    if (label == nullptr)
    {
        problemLoading(&quot;'fonts/Marker Felt.ttf'&quot;);
    }
    else
    {
        // position the label on the center of the screen
        label-&amp;gt;setPosition(Vec2(origin.x + visibleSize.width/2,
                                origin.y + visibleSize.height - label-&amp;gt;getContentSize().height));

        // add the label as a child to this layer
        this-&amp;gt;addChild(label, 1);
    }
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个也很好理解，&lt;code&gt;Label::createWithTTF&lt;/code&gt;返回一个Label对象的指针，&lt;strong&gt;显示的字符串&lt;/strong&gt;、&lt;strong&gt;字体&lt;/strong&gt;和&lt;strong&gt;字体大小&lt;/strong&gt;作为函数的参数，也是使用&lt;strong&gt;addChild&lt;/strong&gt;添加到场景中，这里的1比0高一层，我们试着把文本的坐标设置到场景中央，修改成如下：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/Marker Felt.ttf&quot;, 24);
label-&amp;gt;setPosition(Vec2(origin.x + visibleSize.width/2,
                        origin.y + visibleSize.height/2));
this-&amp;gt;addChild(label, 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191017010452212-785876577.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文本是在logo上方的，验证了 &lt;code&gt;z-order&lt;/code&gt; 值大的节点对象后绘制，值小的节点对象先绘制，先渲染的被压在后渲染的物体下面&lt;/p&gt;
&lt;h3 id=&quot;精灵的生成&quot;&gt;精灵的生成&lt;/h3&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;bool HelloWorld::init()
{
    ...
        
    auto sprite = Sprite::create(&quot;sinnosuke.png&quot;);
    if (sprite == nullptr)
    {
        problemLoading(&quot;'HelloWorld.png'&quot;);
    }
    else
    {
        // position the sprite on the center of the screen
        sprite-&amp;gt;setPosition(Vec2(visibleSize.width/2 + origin.x, visibleSize.height/2 + origin.y));
        // Vec2(visibleSize.width/4 + origin.x, visibleSize.height/2 + origin.y)
        // add the sprite as a child to this layer
        this-&amp;gt;addChild(sprite, 0);
    }
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更简单了，使用一张图片生成一个精灵，同样也是加到场景中，最后要记得return true&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191017010830606-695510203.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;深入探索helloworld场景&quot;&gt;深入探索HelloWorld场景&lt;/h2&gt;
&lt;h3 id=&quot;场景入口&quot;&gt;场景入口&lt;/h3&gt;
&lt;p&gt;首先，游戏场景的入口是导演类的runWithScene，打开&lt;code&gt;AppDelegate.cpp&lt;/code&gt;,找到&lt;code&gt;AppDelegate::applicationDidFinishLaunching()&lt;/code&gt;函数，可以看到：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;Copybool AppDelegate::applicationDidFinishLaunching() {
    // initialize director
    auto director = Director::getInstance();
    
    ...
    
    // create a scene. it's an autorelease object
    auto scene = HelloWorld::createScene();

    // run
    director-&amp;gt;runWithScene(scene);

    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Director&lt;/code&gt;类是一个单例类，使用&lt;code&gt;getInstance&lt;/code&gt;可以获得它的实例，（单例模式保证系统中应用该模式的类一个类只有一个对象实例）我们需要&lt;code&gt;Director&lt;/code&gt;实例来运行运行HelloWorld场景（通过&lt;code&gt;runWithScene&lt;/code&gt;），并让HelloWorld以及HelloWorld的子节点工作&lt;/p&gt;
&lt;h3 id=&quot;node类&quot;&gt;Node类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Node类&lt;/strong&gt;是HelloWorld场景里我们使用的大部分类的基类（其实Scene类也是一个Node）&lt;/p&gt;
&lt;p&gt;游戏世界中的对象实际上大部分都是Node，就像我们一开始提到的，Node和Node通过父子关系联系起来，形成一棵树，父节点使用addChild将子节点加到自己管理的子节点队列中，游戏运行的时候，导演&lt;code&gt;Director&lt;/code&gt;就会遍历这些Node让他们进行工作&lt;/p&gt;
&lt;p&gt;比如我们的HelloWorld场景：HelloWorld场景是根节点，精灵sprite，文本label，菜单menu是HelloWorld的子节点，按钮closeItem是菜单menu的子节点&lt;/p&gt;
&lt;h3 id=&quot;ref类&quot;&gt;Ref类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Ref类&lt;/strong&gt;是用于&lt;strong&gt;引用计数&lt;/strong&gt;的类，负责对象的引用计数，Ref类是Node类的基类，也就是说所有的Node都是使用cocos2dx的引用计数内存管理系统进行内存管理的，这也是为什么我们生成对象不是用new和delete，而是用create生成对象的原因&lt;/p&gt;
&lt;p&gt;简单来说，引用计数法的理论是，当对象被引用的时候，对象的引用计数会+1，取消引用的时候就-1，当计数为0的时候就将对象销毁，感兴趣可以了解一下&lt;strong&gt;智能指针&lt;/strong&gt;和&lt;strong&gt;RAII&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;create&quot;&gt;create&lt;/h3&gt;
&lt;p&gt;这个函数我们可以认为它是一个工厂，这个工厂把我们生成对象之前需要做的工作先做好了，在文章达到最开头有这样一段代码&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;Scene* HelloWorld::createScene()
{
    return HelloWorld::create();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后HelloWorldScene.h是这样的&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;#ifndef __HELLOWORLD_SCENE_H__
#define __HELLOWORLD_SCENE_H__

#include &quot;cocos2d.h&quot;

class HelloWorld : public cocos2d::Scene
{
public:
    static cocos2d::Scene* createScene();

    virtual bool init();
    
    void menuCloseCallback(cocos2d::Ref* pSender);
    
    CREATE_FUNC(HelloWorld);
};

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么没有看到create函数，我们看&lt;code&gt;CREATE_FUNC&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;#define CREATE_FUNC(__TYPE__) \
static __TYPE__* create() \
{ \
    __TYPE__ *pRet = new(std::nothrow) __TYPE__(); \
    if (pRet &amp;amp;&amp;amp; pRet-&amp;gt;init()) \
    { \
        pRet-&amp;gt;autorelease(); \
        return pRet; \
    } \
    else \
    { \
        delete pRet; \
        pRet = nullptr; \
        return nullptr; \
    } \
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出来，CREATE_FUNC是一个可以让你偷懒不用手动编写create函数的宏&lt;/p&gt;
&lt;p&gt;当然有的类需要客制化create，比如说Sprite的create&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;CopySprite* Sprite::create()
{
    Sprite *sprite = new (std::nothrow) Sprite();
    if (sprite &amp;amp;&amp;amp; sprite-&amp;gt;init())
    {
        sprite-&amp;gt;autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;create里进行了什么操作呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;new&lt;/code&gt;生成对象&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;init&lt;/code&gt;初始化对象&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;autorelease&lt;/code&gt;将这个Ref类交给引用计数系统管理内存&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看到这个init我们是不是想到了什么，HelloWorld场景的布局就是在&lt;code&gt;init&lt;/code&gt;中实现的，而&lt;code&gt;init&lt;/code&gt;由create调用，也就是说，在HelloWorld进行create的时候就已经将文本，按钮，精灵等物件创建并加入到场景中，而这些物件也是通过create创建的，也就是说，场景创建的时候会调用所有物件的init&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;autorelease&lt;/strong&gt;是Ref类的方法，查看一下它的定义&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;CopyRef* Ref::autorelease()
{
    PoolManager::getInstance()-&amp;gt;getCurrentPool()-&amp;gt;addObject(this);
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又看到了getInstance，说明PoolManager也是一个单例类，这段代码的意思很明显，将Ref加入到当前内存池中管理&lt;/p&gt;
&lt;p&gt;我们在后续的开发中经常需要客制化create，只要我们的create能满足上面三个功能即可&lt;/p&gt;
</description>
<pubDate>Wed, 16 Oct 2019 17:32:00 +0000</pubDate>
<dc:creator>zhxmdefj</dc:creator>
<og:description>cocos的场景是通过一颗树安排场景内渲染的对象的，Node类是场景里我们使用的大部分类的基类，游戏世界中的对象实际上大部分都是Node，Node和Node通过父子关系联系起来，形成一棵树，父节点使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxmdefj/p/11689693.html</dc:identifier>
</item>
<item>
<title>.Net下MoongoDB的简单调用 - whitebbai</title>
<link>http://www.cnblogs.com/whitebai/p/11689363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whitebai/p/11689363.html</guid>
<description>&lt;p&gt;1、&lt;span&gt;安装.Net 驱动:Install-Package MongoDB.Driver&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、数据插入&lt;/span&gt;&lt;span&gt; ，链接数据库   &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    //&lt;/span&gt;&lt;span&gt;新建Person测试类&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Height { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TestPerson t1{ &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestPerson {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ObjectPerson {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ObjectId Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Height { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 MongoClient client = &lt;span&gt;new&lt;/span&gt; MongoClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mongodb://127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 IMongoDatabase database &lt;/span&gt;= client.GetDatabase(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestDb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于数据库&lt;/span&gt;
 IMongoCollection&amp;lt;Person&amp;gt; collection = database.GetCollection&amp;lt;Person&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Persons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大致相当于表&lt;/span&gt;
 Person p1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person()
 {
    Id &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    Age &lt;/span&gt;= &lt;span&gt;29&lt;/span&gt;&lt;span&gt;,
    Height&lt;/span&gt;=&lt;span&gt;130&lt;/span&gt;&lt;span&gt;
   };          
   collection.InsertOne(p1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单条插入&lt;/span&gt;也支持异步方法，后面建议都用异步的!习惯成自然!
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 14&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;23.5&quot;&gt;
&lt;p&gt;回到客户端工具刷新一下，就能看到新插入的数据，MongoDB 会自动创建“数据库” 以及 Collection(约等于“表”)。MongoDB 默认用 id 做主键，因此不用显式指定 id 是主键。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/479217/201910/479217-20191016230936337-1019428945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MongoDB 中没有内置“自增字段”，可以把 Id 声明为 ObjectId 类型(using MongoDB.Bson) 这样插入以后就自动给字段赋值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;多条插入&lt;/span&gt;
  IMongoCollection&amp;lt;ObjectPerson&amp;gt; collection1 = database.GetCollection&amp;lt;ObjectPerson&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ObjectPersons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大致相当于表&lt;/span&gt;
  List&amp;lt;ObjectPerson&amp;gt; persons = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ObjectPerson&amp;gt;() { &lt;span&gt;new&lt;/span&gt; ObjectPerson() { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Age = &lt;span&gt;30&lt;/span&gt;, Height = &lt;span&gt;135&lt;/span&gt; }, &lt;span&gt;new&lt;/span&gt; ObjectPerson() { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Age = &lt;span&gt;31&lt;/span&gt;, Height = &lt;span&gt;140&lt;/span&gt;&lt;span&gt; } };
  collection1.InsertMany(persons);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多条插入&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/479217/201910/479217-20191016231044061-531211322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MongoDB 是用 json 保存的，因此也可以直接以 json 格式插入，用 BsonDocument 来代表:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
IMongoCollection&amp;lt;BsonDocument&amp;gt; dogs = database.GetCollection&amp;lt;BsonDocument&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dogs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; jsondata = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id:8999,Age:81,Name:'japan',gender:true}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
BsonDocument p2 &lt;/span&gt;=&lt;span&gt; BsonDocument.Parse(jsondata);
dogs.InsertOne(p2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/479217/201910/479217-20191016231439857-862913335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 15&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;还可以插入有嵌套关系的对象，比如学生和老师，注意不会有表间关系，都是存到一个集合中，注意和关系库不一样。&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
IMongoCollection&amp;lt;Person&amp;gt; collection = database.GetCollection&amp;lt;Person&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Persons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大致相当于表&lt;/span&gt;
Person p1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person()
{
  Id &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
 Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
 Age &lt;/span&gt;= &lt;span&gt;29&lt;/span&gt;&lt;span&gt;,
 Height&lt;/span&gt;=&lt;span&gt;130&lt;/span&gt;&lt;span&gt;,
 t1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; TestPerson() { Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
};          
 collection.InsertOne(p1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单条插入&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/479217/201910/479217-20191016231649393-707559740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、MongoDB查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
IMongoCollection&amp;lt;Person&amp;gt; collection = database.GetCollection&amp;lt;Person&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Persons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filter = Builders&amp;lt;Person&amp;gt;.Filter.Gt(p =&amp;gt; p.Age,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filter1 = Builders&amp;lt;Person&amp;gt;.Filter.And(Builders&amp;lt;Person&amp;gt;.Filter.Gt(p =&amp;gt; p.Age, &lt;span&gt;5&lt;/span&gt;), Builders&amp;lt;Person&amp;gt;.Filter.Eq(p =&amp;gt; p.Id, &lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; And 并且 还有or方法&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; filter2 = Builders&amp;lt;Person&amp;gt;.Filter.Where(p =&amp;gt; p.Age &amp;gt; &lt;span&gt;5&lt;/span&gt; &amp;amp;&amp;amp; p.Id == &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;和上面的写法是一样的但是，建议用Where方法
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通查询&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; result=&lt;span&gt; collection.Find(filter).ToList();
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result)
{
   Console.WriteLine(item.Age &lt;/span&gt;+&lt;span&gt; item.Name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 15&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;8&quot;&gt;
&lt;p&gt; 除了 Gt，还有 Gte、In、Lt、Lte、Ne、Nin、Near、NearSphere、Or、Where、And、Not。 当然最常用的还是 Where 操作: &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 异步查询 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步查询&lt;/span&gt;
 &lt;span&gt;using&lt;/span&gt; (IAsyncCursor&amp;lt;Person&amp;gt; personsCursor = &lt;span&gt;await&lt;/span&gt; collection.FindAsync&amp;lt;Person&amp;gt;&lt;span&gt;(filter)) {
 &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (personsCursor.MoveNextAsync().Result)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取下一组数据，相当于是否有指针，MongoDB其实是返回一个组，不像sql每次是一次次取&lt;/span&gt;
&lt;span&gt;  {
   IEnumerable&lt;/span&gt;&amp;lt;Person&amp;gt; items = personsCursor.Current;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前组的数据&lt;/span&gt;
    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; items)
    {
     Console.WriteLine(item.Age &lt;/span&gt;+&lt;span&gt; item.Name);
    }
 }
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果数据量不大,可以直接tolist&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; results =&lt;span&gt; personsCursor.ToList();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 15&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;  为什么 FindAsync 不直接返回集合，而是要 MoveNext 之后返回一个集合呢?因为返回 的数据量可能很大，因此 MongoDB 是分批下载，下载一批之后执行 GET_More 操作返回下 一批。可以通过 FindOptions 参数的 BatchSize 设置每一批的大小。&lt;/p&gt;
&lt;p&gt;  如果确认返回的数据量 不大，可以 var ps = await personsCursor.ToListAsync()(或者 ToEnumerable()等)一下子返回所有数据。还有 Any、First、FirstOrDefault 等以及异步操作。需要注意 MongoDB 中查询区分大小写。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;4、分页查询 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分页&lt;/span&gt;
FindOptions&amp;lt;Person, Person&amp;gt; findop = &lt;span&gt;new&lt;/span&gt; FindOptions&amp;lt;Person, Person&amp;gt;&lt;span&gt;();
findop.Limit &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取最多几条&lt;/span&gt;
findop.Skip = &lt;span&gt;2&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳过几条&lt;/span&gt;
findop.Sort = Builders&amp;lt;Person&amp;gt;.Sort.Ascending(p =&amp;gt; p.Age).Ascending(p =&amp;gt; p.Name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; cursor =&lt;span&gt; collection.FindAsync(filter, findop).Result)
{
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; items =&lt;span&gt; cursor.ToList();
  &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; items)
  {
   Console.WriteLine(item.Age &lt;/span&gt;+&lt;span&gt; item.Name);
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;指定排序规则 &lt;/span&gt;findop.Sort = Builders&amp;lt;Person&amp;gt;.Sort.Ascending(p =&amp;gt; p.Age).Ascending(p =&amp;gt; p.Name);&lt;/p&gt;
&lt;p&gt;5、Json格式取法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;json格式取法&lt;/span&gt;
IMongoCollection&amp;lt;BsonDocument&amp;gt; bsonDoc = database.GetCollection&amp;lt;BsonDocument&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Persons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filter4 = Builders&amp;lt;BsonDocument&amp;gt;.Filter.Gt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; persons=&lt;span&gt;await&lt;/span&gt;&lt;span&gt; bsonDoc.FindAsync(filter4)) &lt;br/&gt;{
 &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; persons.ToListAsync())
 {
    Console.WriteLine(item.GetValue(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).AsString);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、Update更新操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
IMongoCollection&amp;lt;Person&amp;gt; upPersons = database.GetCollection&amp;lt;Person&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Persons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; upFilter = Builders&amp;lt;Person&amp;gt;.Filter.Where(p =&amp;gt; p.Age&amp;gt;&lt;span&gt;20&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;筛选条件&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; update = Builders&amp;lt;Person&amp;gt;.Update.Set(c =&amp;gt; c.Name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新条件，将Name更新成test2&lt;/span&gt;
upPersons.UpdateMany(filter, update);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7、Delete删除操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
IMongoCollection&amp;lt;Person&amp;gt; teachers = database.GetCollection&amp;lt;Person&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Persons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deletefilter = Builders&amp;lt;Person&amp;gt;.Filter.Where(p =&amp;gt; p.Id == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
teachers.DeleteMany(deletefilter);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 用 Update 机会比较少，如果频繁的用 Update 可能意味着用错了;也不要想着 join、group by， 还是场景不对!&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 17&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;8、MongoDB 应用场景&lt;/p&gt;
&lt;p&gt;  日志记录系统;设备监控数据的存储;饿了么外卖骑手接单; 存储商品、商家信息;网站评论信息;存储爬虫爬过来的第三方数据;&lt;/p&gt;
&lt;p&gt;  但是像订单、金融交易、游戏装备等这些关键信息不要用 MongoDB;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 16 Oct 2019 15:25:00 +0000</pubDate>
<dc:creator>whitebbai</dc:creator>
<og:description>1、安装.Net 驱动:Install-Package MongoDB.Driver 2、数据插入&amp;#160;，链接数据库 回到客户端工具刷新一下，就能看到新插入的数据，MongoDB 会自动创建“数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whitebai/p/11689363.html</dc:identifier>
</item>
<item>
<title>关于人工智能和python - 木霖</title>
<link>http://www.cnblogs.com/mulin1999/p/11688927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mulin1999/p/11688927.html</guid>
<description>
&lt;p&gt;人工智能的话题在近几年可谓是相当火热，前几天看快本时其中有一个环节就是关于人工智能的，智能家电、智能机器人、智能工具等等，在我的印象里，提到人工智能就会出现 Python，然后我便在网上查找了相关信息，并整合了一下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1785253/201910/1785253-20191016220155073-1315272049.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;人工智能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;人工智能，英文缩写为AI，是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学；是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python 是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;之间的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而一般说起人工智能都认为是用 Python 语言实现的，就如我之前说的，但查完资料发现，的确大部分的人工智能的代码都是使用 Python 来编写，写人工智能代码时需要用到许多框架工具和库，这些大部分都是 Python 提供的，Python是这些库的API binding，但并不能因为这样就认为人工智能就是靠 Python 写的，Python 是解释语言，速度比较慢，它只是调用&lt;span lang=&quot;EN-US&quot;&gt;AI接口，而人工智能核心算法是完全依赖于 C/C++ 这类编译语言，真正的计算全是 &lt;span lang=&quot;EN-US&quot;&gt;C/C++ 写好的数据底层，因为是计算密集型，需要非常精细的优化，还需要GPU、专用硬件之类的接口，这些都只有C/C++能做到，用&lt;span lang=&quot;EN-US&quot;&gt;Python只是写相应的逻辑！所以某种意义上其实C/C++才是人工智能领域最重要的语言。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;那为什么不直接全部用 C/C++ 写人工智能呢？这是因为 Python 强大的便捷性，开发生态成熟，有很多有用的库可以用。使用 Python是因为 CPython 的胶水语言特性，要开发一个其他语言到 C/C++ 的跨语言接口，Python是最容易的，比其他语言的 ffi 门槛要低不少，C语言要写几百行的代码，可能用 Python 几行就搞定了，效率很高。尤其是使用 Cython 的时候。其他语言的 ffi 许多都只能导入 C 的函数入口点，复杂的数据结构大多只能手工用 byte 数组拼起来，如果还需要回调函数输入那就无计可施了。而 CPython 的 C API 是双向融合的，可以直接对外暴露封装过的 Python 对象，还可以允许用户通过继承这些自定义对象来引入新特性，甚至可以从 C 代码当中再调用 Python 的函数。比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C/C++重写，而后封装为Python可以调用的扩展类库。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;打个比方，就像我们统计数据或选择用 excel 制作表格时，因为在需要用到加减乘除或者、函数等时，只需要套用公式就可以，因为 SUM、AVERAGE 等这样的函数运行的背后，是 C++/C# 等语言已经编写好了代码，所以 Excel 只是工具和展现形式并不是它做计算。同理在学习人工智能时 Python 只是用来操作深度学习框架的工具，实际负责运算的主要模块并不依靠 Python，真正起作用的是也是一大堆复杂的 C/ C++  程序。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;用于通用 AI：&lt;/p&gt;
&lt;p&gt;AIMA —— Python 实现 Russell 和 Norvig 的‘Artificial Intelligence: A Modern Approach’库。&lt;/p&gt;
&lt;p&gt;pyDatalog —— Python 中的逻辑编程引擎&lt;/p&gt;
&lt;p&gt;SimpleAI —— Python 实现了“AIMA”一书中描述的许多人工智能算法。它侧重于提供易于使用，有据可查的测试库。&lt;/p&gt;
&lt;p&gt;EasyAI —— 简单的 Python 引擎，用于 AI 的双人游戏，如 Negamax, transposition tables, game solving。&lt;/p&gt;

&lt;p&gt;用于机器学习：&lt;/p&gt;
&lt;p&gt;PyBrain —— 灵活、简单，但对于机器算法任务非常高效，它是 Python 的一个机器学习模块化库。它还提供了各种预定义的环境来测试和比较你的算法。&lt;/p&gt;
&lt;p&gt;PyML —— 一款以 Python 编写的侧重于 SVM 和其他内核方法的双边框架。它支持在 Linux 和 Mac OS X 上运行。&lt;/p&gt;
&lt;p&gt;scikit-learn —— 旨在提供在各种环境下可重复使用的简单而强大的解决方案：机器学习作为科学和工程的多功能工具。它是一个 Python 模块，它将经典的经典机器学习算法集成在如紧密结合的科学世界的 Python 软件包中（如 numpy，scipy，matplotlib）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;了解了 Python 和人工智能的关系后，我认为虽然人工智能的核心算法是 C/C++，但我们编写代码时并不需要过多的了解 C/C++，我们只需要用到 Python 就好，而 Python 语言对初学编程的人来说是很友好的，被称为“最不需要备注的语言”。上手快，语言简单易懂，对比其他语言来说没那么多条条框框的规则。&lt;/p&gt;
&lt;p&gt;随着社会的不断发展和需求，人工智能已经逐渐被发展到社会行业的方方面面，从科学层面看，人工智能跨越认知科学、神经科学、数学和计算机科学等学科，具有高度交叉性；从技术层面看，人工智能包含计算机视觉、机器学习、知识工程、自然语言处理等多个领域，具有极强专业性；从产业层面看，人工智能在智能制造、智慧农业、智慧医疗、智慧城市等领域的应用不断扩大，具有内在融合性；从社会层面看，人工智能给社会治理、隐私保护、伦理道德等带来新的影响，具有全面渗透性。目前，在边界清晰、规则明确、任务规范的特定应用场景下（如下围棋、人脸识别、语音识别）设计出的智能体表现出较好的专用智能。在全新理念的引导下，机器人可以更多承担重复简单甚至是危险的工作，而帮助人类从繁杂工作中解放，获得更多从事创造性工作的机会。比起人工智能完全取代人的方式，工厂不必担心人工智能做出错误的决定延误生产，也不用考虑人在做重复劳动时效率降低的问题，双方取长补短，最大化的提升生产效率，从长远角度来看，这样的方式无疑更符合生产的需求，也更符合社会的需求。&lt;/p&gt;
&lt;p&gt;所以我有一句话想对没学过编程，但对人工智能有所期望的人说：既然有 Python 这么好上手的、适合初学者的编程语言，为什么不都尝试学一下呢，毕竟技多不压身，不迈开第一步，你永远不知道你后面的路怎么走！&lt;/p&gt;
&lt;p&gt;时代在进步，社会在发展，不说人工智能以后会不会大火，但一定不会褪色。&lt;/p&gt;

&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;参考链接：https://blog.csdn.net/leyangjun/article/details/79931144&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Oct 2019 15:04:00 +0000</pubDate>
<dc:creator>木霖</dc:creator>
<og:description>人工智能的话题在近几年可谓是相当火热，前几天看快本时其中有一个环节就是关于人工智能的，智能家电、智能机器人、智能工具等等，在我的印象里，提到人工智能就会出现 Python，然后我便在网上查找了相关信息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mulin1999/p/11688927.html</dc:identifier>
</item>
<item>
<title>分库分表(6)--- SpringBoot+ShardingSphere实现分表+ 读写分离 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11688651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11688651.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;有关分库分表前面写了五篇博客:&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11608222.html&quot;&gt;分库分表(1) --- 理论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11629883.html&quot;&gt;分库分表(2) --- ShardingSphere(理论)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11656205.html&quot;&gt;分库分表(3) ---SpringBoot + ShardingSphere实现读写分离&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11651163.html&quot;&gt;分库分表(4) ---SpringBoot + ShardingSphere 实现分表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11673493.html&quot;&gt;分库分表(5) ---SpringBoot + ShardingSphere 实现分库分表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇博客通过ShardingSphere&lt;code&gt;实现分表不分库+读写分离&lt;/code&gt;，并在文章最下方附上项目&lt;code&gt;Github地址&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一项目概述&quot;&gt;&lt;span&gt;一、项目概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;技术架构&quot;&gt;1、技术架构&lt;/h4&gt;
&lt;p&gt;项目总体技术选型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SpringBoot2.0.6 + shardingsphere4.0.0-RC1 + Maven3.5.4  + MySQL + lombok(插件)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;项目说明&quot;&gt;2、项目说明&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;场景&lt;/code&gt; 在实际开发中，如果表的数据过大，我们可能需要把一张表拆分成多张表，这里就是通过ShardingSphere实现分表+读写分离功能，但不分库。&lt;/p&gt;
&lt;h4 id=&quot;数据库设计&quot;&gt;3、数据库设计&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;分表&lt;/code&gt; tab_user单表拆分为tab_user0表 和 tab_user1表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;读写分离&lt;/code&gt; 数据写入master库 ,数据读取 slave库 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;master库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016213947793-556434384.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slave库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016213957809-1645338573.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; 初始数据的时候，这边只有 &lt;strong&gt;slave从库的tab_user0&lt;/strong&gt; 我插入了一条数据。那是因为我们这个项目中Mysql服务器并没有实现主从部署,这两个库都在同一服务器上，所以&lt;/p&gt;
&lt;p&gt;做不到主数据库数据自动同步到从数据库。所以这里在从数据库建一条数据。等下验证的时候，我们只需验证数据是否存入&lt;code&gt;master库&lt;/code&gt;，数据读取是否在&lt;code&gt;slave库&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;具体的创建表SQL也会放到GitHub项目里&lt;/p&gt;

&lt;h2 id=&quot;二核心代码&quot;&gt;&lt;span&gt;二、核心代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; 完整的代码会放到GitHub上，这里只放一些核心代码。&lt;/p&gt;
&lt;h4 id=&quot;application.properties&quot;&gt;1、application.properties&lt;/h4&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;server.port=8084

#指定mybatis信息
mybatis.config-location=classpath:mybatis-config.xml

#数据库
spring.shardingsphere.datasource.names=master0,slave0

spring.shardingsphere.datasource.master0.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.master0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.master0.url=jdbc:mysql://localhost:3306/master?characterEncoding=utf-8
spring.shardingsphere.datasource.master0.username=root
spring.shardingsphere.datasource.master0.password=123456

spring.shardingsphere.datasource.slave0.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.slave0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.slave0.url=jdbc:mysql://localhost:3306/slave?characterEncoding=utf-8
spring.shardingsphere.datasource.slave0.username=root
spring.shardingsphere.datasource.slave0.password=root

#数据分表规则
#指定所需分的表
spring.shardingsphere.sharding.tables.tab_user.actual-data-nodes=master0.tab_user$-&amp;gt;{0..1}
#指定主键
spring.shardingsphere.sharding.tables.tab_user.table-strategy.inline.sharding-column=id
#分表规则为主键除以2取模
spring.shardingsphere.sharding.tables.tab_user.table-strategy.inline.algorithm-expression=tab_user$-&amp;gt;{id % 2}

# 读写分离
spring.shardingsphere.masterslave.load-balance-algorithm-type=round_robin
spring.shardingsphere.masterslave.name=ms
#这里配置读写分离的时候一定要记得添加主库的数据源名称 这里为master0
spring.shardingsphere.sharding.master-slave-rules.master0.master-data-source-name=master0
spring.shardingsphere.sharding.master-slave-rules.master0.slave-data-source-names=slave0

#打印sql
spring.shardingsphere.props.sql.show=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sharding-JDBC可以通过&lt;code&gt;Java&lt;/code&gt;，&lt;code&gt;YAML&lt;/code&gt;，&lt;code&gt;Spring命名空间&lt;/code&gt;和&lt;code&gt;Spring Boot Starter&lt;/code&gt;四种方式配置，开发者可根据场景选择适合的配置方式。具体可以看官网。&lt;/p&gt;
&lt;h4 id=&quot;usercontroller&quot;&gt;2、UserController&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class UserController {

    @Autowired
    private UserService userService;

    /**
     * 模拟插入数据
     */
    List&amp;lt;User&amp;gt; userList = Lists.newArrayList();
    /**
     * 初始化插入数据
     */
    @PostConstruct
    private void getData() {
        userList.add(new User(1L,&quot;小小&quot;, &quot;女&quot;, 3));
        userList.add(new User(2L,&quot;爸爸&quot;, &quot;男&quot;, 30));
        userList.add(new User(3L,&quot;妈妈&quot;, &quot;女&quot;, 28));
        userList.add(new User(4L,&quot;爷爷&quot;, &quot;男&quot;, 64));
        userList.add(new User(5L,&quot;奶奶&quot;, &quot;女&quot;, 62));
    }
    /**
     * @Description: 批量保存用户
     */
    @PostMapping(&quot;save-user&quot;)
    public Object saveUser() {
        return userService.insertForeach(userList);
    }
    /**
     * @Description: 获取用户列表
     */
    @GetMapping(&quot;list-user&quot;)
    public Object listUser() {
        return userService.list();
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三测试验证&quot;&gt;&lt;span&gt;三、测试验证&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;批量插入数据&quot;&gt;1、批量插入数据&lt;/h4&gt;
&lt;p&gt;请求接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localhost:8084/save-user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以从商品接口代码中可以看出，它会批量插入5条数据。我们先看控制台输出SQL语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016214013613-520082614.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以从SQL语句可以看出 &lt;strong&gt;master0数据源&lt;/strong&gt; 中 &lt;strong&gt;tab_user0&lt;/strong&gt; 表插入了&lt;code&gt;三条数据&lt;/code&gt;，而 &lt;strong&gt;tab_user1&lt;/strong&gt; 表中插入&lt;code&gt;两条数据&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们再来看数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;master.tab_user0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016214021616-2037678416.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;master.tab_user1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016214028932-1050325570.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成分表插入数据。&lt;/p&gt;
&lt;h4 id=&quot;获取数据&quot;&gt;2、获取数据&lt;/h4&gt;
&lt;p&gt;我们来获取列表接口的SQL。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;  select *  from tab_user &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求接口结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191016214037389-922151476.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;结论&lt;/code&gt; 从接口返回的结果可以很明显的看出，数据存储在master主库,而数据库的读取在slave从库。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; ShardingSphere并不支持&lt;code&gt;CASE WHEN&lt;/code&gt;、&lt;code&gt;HAVING&lt;/code&gt;、&lt;code&gt;UNION (ALL)&lt;/code&gt;，&lt;code&gt;有限支持子查询&lt;/code&gt;。这个官网有详细说明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github地址&lt;/code&gt;：&lt;a href=&quot;https://github.com/yudiandemingzi/spring-boot-sharding-sphere&quot; class=&quot;uri&quot;&gt;https://github.com/yudiandemingzi/spring-boot-sharding-sphere&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://shardingsphere.apache.org/document/current/cn/overview/&quot;&gt;ShardingSphere中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://shardingsphere.apache.org/&quot;&gt;ShardingSphere官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://github.com/apache/incubator-shardingsphere&quot;&gt;Shardingsphere Github库&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt; 我相信，无论今后的道路多么坎坷，只要抓住今天，迟早会在奋斗中尝到人生的甘甜。抓住人生中的一分一秒，胜过虚度中的一月一年！(20）&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Wed, 16 Oct 2019 14:54:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>分库分表(6) ShardingSphere实现分表+ 读写分离 有关分库分表前面写了五篇博客: 1、 '分库分表(1) 理论' 2、 '分库分表(2) ShardingSphere(理论)' 3、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11688651.html</dc:identifier>
</item>
<item>
<title>超详细！！ sql server 同步数据库 发布 订阅 跨网段 无公网ip 常见问题 - 将来的事</title>
<link>http://www.cnblogs.com/take-it-easy/p/11688946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/take-it-easy/p/11688946.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主机1：发布端&lt;/p&gt;
&lt;p&gt;阿里云服务器--有公网ip&lt;/p&gt;

&lt;p&gt;主机2：订阅端&lt;/p&gt;
&lt;p&gt;笔记本--无公网ip&lt;/p&gt;

&lt;p&gt;数据量很小，主要是熟悉发布订阅的操作流程。&lt;/p&gt;
&lt;p&gt;主机2仅仅作为主机1的本地备份，要求修改云服务器上数据后，能通过sql server的发布订阅功能将本地数据同步。&lt;/p&gt;
&lt;p&gt;底下没有一步一步介绍，一步一步的，可以看下面这篇&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/u012861467/article/details/76411216&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;阿里云的sql server配置好后，无法使用本地sql server客户端远程登录。&lt;/p&gt;
&lt;p&gt;检查以下几点&lt;/p&gt;
&lt;p&gt;1.要在阿里云的控制台中的防火墙，&lt;span&gt;打开阿里云的1433端口&lt;/span&gt;（默认的sql server访问端口）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这点很重要，好多教程里没有提到！！！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223150940-1288205134.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;


&lt;p&gt;2.要把两台主机的sql manager中的sql server服务中的sql server代理打开（原本是禁用状态）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223207791-2037959090.png&quot; alt=&quot;&quot; width=&quot;811&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;


&lt;p&gt;3.远端服务器要开启sql server用户名密码登录方式，并且设置好代理账号和密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223324437-1205233338.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;575&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到这一步，应该可以在笔记本的sql server通过ip地址，和刚刚设置的代理账户和密码登录进云服务器了。&lt;/p&gt;

&lt;p&gt;--------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发布和订阅流程&lt;/p&gt;
&lt;p&gt;要首先在云端sql server客户端的&lt;/p&gt;
&lt;p&gt;复制---发布---新建发布&lt;/p&gt;

&lt;p&gt;1.选择哪种发布方式&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223337081-1322436641.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;464&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这点可以自己查询四种发布的区别&lt;/p&gt;
&lt;p&gt;要注意：事务发布时，被发布的表要有主键&lt;/p&gt;

&lt;p&gt;2.如何连接发布端&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223416836-431019368.png&quot; alt=&quot;&quot; width=&quot;546&quot; height=&quot;428&quot;/&gt;&lt;/p&gt;


&lt;p&gt;网上一般推荐是在云端和本地端都新建一个用户名，密码一样的windows账户，然后这里选择在windows账户下运行。&lt;/p&gt;
&lt;p&gt;我这里使用sql server登录名&lt;/p&gt;
&lt;p&gt;这里注意---登录名是sql server的登录名（就是一般是sa的那个）&lt;/p&gt;

&lt;p&gt;-------------------------&lt;/p&gt;
&lt;p&gt;以上是发布端&lt;/p&gt;
&lt;p&gt;-------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt;订阅端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.使用别名&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223441165-1367814168.png&quot; alt=&quot;&quot; width=&quot;627&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在这一步选择发布服务器时，要使用实际的服务器名称（使用windows方式登录时的名称），不能使用ip地址。&lt;/p&gt;
&lt;p&gt;这里要在订阅服务器中添加发布服务器的别名，具体操作看下面&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/u010457730/article/details/97276313&lt;/p&gt;

&lt;p&gt;2.推送订阅还是请求订阅&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223454195-461355121.png&quot; alt=&quot;&quot; width=&quot;630&quot; height=&quot;499&quot;/&gt;&lt;/p&gt;



&lt;p&gt;这里我有个不懂的问题，之后会讲到。&lt;/p&gt;

&lt;p&gt;3.连接到分发服务器&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223506578-1798223787.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;696&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这里注意，要填写分发服务器的sql server登录名。&lt;/p&gt;
&lt;p&gt;是登录名，sa那个&lt;/p&gt;
&lt;p&gt;登录名不是服务器名，这点切记。&lt;/p&gt;

&lt;p&gt;到这一步时，查看一下订阅服务器的同步状态&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223521897-1756933464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;看看是否打钩了----这代表前面的设置正确，订阅服务器能访问到发布端。&lt;/p&gt;
&lt;p&gt;本人一开始因为设置时填写错了用户名，在查看同步状态这里还是报错的。&lt;/p&gt;

&lt;p&gt;--------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;接下来，可以看看订阅服务器的数据是不是被同步了，如未同步，看看订阅端的作业历史记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223541695-845676116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223559230-1632527727.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;


&lt;p&gt;有可能还是报错&lt;/p&gt;
&lt;p&gt;但是这个报错信息是什么玩意嘛？？？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“复制代理遇到问题。有关详细信息，请参阅上一个作业步骤历史记录消息或复制监视器”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;原来要在发布端找具体错误信息。。。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223617687-777351262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;启动发布端的复制监视器&lt;/p&gt;
&lt;p&gt;在左侧选好具体的发布后，双击右侧中所有订阅中的错误的订阅，查看具体报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223627923-942571151.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;



&lt;p&gt;真相大白--&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于出现操作系统错误 3，进程无法读取文件D:\XXXX\X.pre&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;原因原来是--&lt;span&gt;这个路径是发布端存放快照文件的位置，但是由于不是网络文件夹，不能被访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里提供一种简单的解决办法&lt;/p&gt;
&lt;p&gt;参照这位的做法&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/mrray/archive/2011/03/17/1987123.html&lt;/p&gt;

&lt;p&gt;直接把发布端的快照文件夹--名称为repldata的拷贝到订阅端的某个文件位置&lt;/p&gt;
&lt;p&gt;再在订阅端修改快照位置&lt;/p&gt;
&lt;p&gt;复制--本地订阅---具体的订阅---右键---属性&lt;/p&gt;
&lt;p&gt;把快照文件夹位置修改为本地的那个位置。&lt;/p&gt;
&lt;p&gt;很神奇的是，只需要修改一次就好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1826667/201910/1826667-20191016223637722-945626510.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;395&quot;/&gt;&lt;/p&gt;


&lt;p&gt;到这一步，我的问题就解决了，以下是几点问题和思考&lt;/p&gt;
&lt;p&gt;1.坑很多，但多查询相关资料，总是能够解决的。这个信心是一次次解决问题中锻炼出来的。&lt;/p&gt;
&lt;p&gt;2.自身理论基础欠缺时，一些配置性操作就容易出问题。比如说不了解发布订阅的具体机制，就很难想到出现快照文件夹无法访问这个问题。&lt;/p&gt;
&lt;p&gt;3.我的情景比较特殊，一台有公网ip，一台没有。我在网上看到的情况，一般要么是局域网，要么两台主机都是有公网ip的（这意味着发布端，订阅端都能用唯一的ip地址访问对方）。所以我一直怀疑我这种网络结构从原理上就不能使用发布订阅这种方式（因为发布端无法“找到”订阅端）。这也是我在配置中选择了从订阅端运行代理，因为订阅端是肯定能“找到”有公网ip的发布端的。这个问题还要细研究。&lt;/p&gt;
&lt;p&gt;4.这四种发布-订阅的方式有什么区别？快照文件夹是什么原理？这是两个需要搞清楚的问题。&lt;/p&gt;
&lt;p&gt;5.sql server这个这么常见的功能为什么如此多的坑。。。可能还是我太菜了。但起码这个问题是解决了，我又成长了一点点。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Oct 2019 14:40:00 +0000</pubDate>
<dc:creator>将来的事</dc:creator>
<og:description>问题描述 主机1：发布端 阿里云服务器--有公网ip 主机2：订阅端 笔记本--无公网ip 数据量很小，主要是熟悉发布订阅的操作流程。 主机2仅仅作为主机1的本地备份，要求修改云服务器上数据后，能通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/take-it-easy/p/11688946.html</dc:identifier>
</item>
<item>
<title>Cocos Creator 通用框架设计 —— 网络 - 深圳-宝爷</title>
<link>http://www.cnblogs.com/ybgame/p/11688944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybgame/p/11688944.html</guid>
<description>&lt;p&gt;在Creator中发起一个http请求是比较简单的，但很多游戏希望能够和服务器之间保持长连接，以便服务端能够主动向客户端推送消息，而非总是由客户端发起请求，对于实时性要求较高的游戏更是如此。这里我们会设计一个通用的网络框架，可以方便地应用于我们的项目中。&lt;/p&gt;
&lt;h2 id=&quot;使用websocket&quot;&gt;使用websocket&lt;/h2&gt;
&lt;p&gt;在实现这个网络框架之前，我们先了解一下websocket，websocket是一种基于tcp的全双工网络协议，可以让网页创建持久性的连接，进行双向的通讯。在Cocos Creator中使用websocket既可以用于h5网页游戏上，同样支持原生平台Android和iOS。&lt;/p&gt;
&lt;h3 id=&quot;构造websocket对象&quot;&gt;构造websocket对象&lt;/h3&gt;
&lt;p&gt;在使用websocket时，第一步应该创建一个websocket对象，websocket对象的构造函数可以传入2个参数，第一个是url字符串，第二个是协议字符串或字符串数组，指定了可接受的子协议，服务端需要选择其中的一个返回，才会建立连接，但我们一般用不到。&lt;/p&gt;
&lt;p&gt;url参数非常重要，主要分为4部分&lt;code&gt;协议://地址:端口/资源&lt;/code&gt;，比如&lt;code&gt;ws://echo.websocket.org&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;协议：必选项，默认是ws协议，如果需要安全加密则使用wss。&lt;/li&gt;
&lt;li&gt;地址：必选项，可以是ip或域名，当然建议使用域名。&lt;/li&gt;
&lt;li&gt;端口：可选项，在不指定的情况下，ws的默认端口为80，wss的默认端口为443。&lt;/li&gt;
&lt;li&gt;资源：可选性，一般是跟在域名后某资源路径，我们基本不需要它。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;websocket的状态&quot;&gt;websocket的状态&lt;/h3&gt;
&lt;p&gt;websocket有4个状态，可以通过readyState属性查询：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0 CONNECTING 尚未建立连接。&lt;/li&gt;
&lt;li&gt;1 OPEN WebSocket连接已建立，可以进行通信。&lt;/li&gt;
&lt;li&gt;2 CLOSING 连接正在进行关闭握手，或者该close()方法已被调用。&lt;/li&gt;
&lt;li&gt;3 CLOSED 连接已关闭。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;websocket的api&quot;&gt;websocket的API&lt;/h3&gt;
&lt;p&gt;websocket只有2个API，void send( data ) 发送数据和void close( code, reason ) 关闭连接。&lt;/p&gt;
&lt;p&gt;send方法只接收一个参数——即要发送的数据，类型可以是以下4个类型的任意一种&lt;code&gt;string | ArrayBufferLike | Blob | ArrayBufferView&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果要发送的数据是二进制，我们可以通过websocket对象的binaryType属性来指定二进制的类型，binaryType只可以被设置为“blob”或“arraybuffer”，默认为“blob”。如果我们要传输的是文件这样较为固定的、用于写入到磁盘的数据，使用blob。而你希望传输的对象在内存中进行处理则使用较为灵活的arraybuffer。如果要从其他非blob对象和数据构造一个blob，需要使用Blob的构造函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在发送数据时官方有2个建议：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检测websocket对象的readyState是否为OPEN，是才进行send。&lt;/li&gt;
&lt;li&gt;检测websocket对象的bufferedAmount是否为0，是才进行send（为了避免消息堆积，该属性表示调用send后堆积在websocket缓冲区的还未真正发送出去的数据长度）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;close方法接收2个可选的参数，code表示错误码，我们应该传入1000或3000～4999之间的整数，reason可以用于表示关闭的原因，长度不可超过123字节。&lt;/p&gt;
&lt;h3 id=&quot;websocket的回调&quot;&gt;websocket的回调&lt;/h3&gt;
&lt;p&gt;websocket提供了4个回调函数供我们绑定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onopen：连接成功后调用。&lt;/li&gt;
&lt;li&gt;onmessage：有消息过来时调用：传入的对象有data属性，可能是字符串、blob或arraybuffer。&lt;/li&gt;
&lt;li&gt;onerror：出现网络错误时调用：传入的对象有data属性，通常是错误描述的字符串。&lt;/li&gt;
&lt;li&gt;onclose：连接关闭时调用：传入的对象有code、reason、wasClean等属性。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：当网络出错时，会先调用onerror再调用onclose，无论何种原因的连接关闭，onclose都会被调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;echo实例&quot;&gt;Echo实例&lt;/h3&gt;
&lt;p&gt;下面websocket官网的echo demo的代码，可以将其写入一个html文件中并用浏览器打开，打开后会自动创建websocket连接，在连接上时主动发送了一条消息“WebSocket rocks”，服务器会将该消息返回，触发onMessage，将信息打印到屏幕上，然后关闭连接。具体可以参考 http://www.websocket.org/echo.html 。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;默认的url前缀是wss，由于wss抽风，使用ws才可以连接上，如果ws也抽风，可以试试连这个地址ws://121.40.165.18:8800，这是国内的一个免费测试websocket的网址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
  &amp;lt;title&amp;gt;WebSocket Test&amp;lt;/title&amp;gt;
  &amp;lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&amp;gt;

  var wsUri = &quot;ws://echo.websocket.org/&quot;;
  var output;

  function init() {
    output = document.getElementById(&quot;output&quot;);
    testWebSocket();
  }

  function testWebSocket() {
    // 初始化websocket，绑定回调
    websocket = new WebSocket(wsUri);
    websocket.onopen = onOpen;
    websocket.onclose = onClose;
    websocket.onmessage = onMessage;
    websocket.onerror = onError;
  }

  function onOpen(evt) {
    writeToScreen(&quot;CONNECTED&quot;);
    doSend(&quot;WebSocket rocks&quot;);
  }

  function onClose(evt) {
    writeToScreen(&quot;DISCONNECTED&quot;);
  }

  function onMessage(evt) {
    writeToScreen('&amp;lt;span style=&quot;color: blue;&quot;&amp;gt;RESPONSE: ' + evt.data+'&amp;lt;/span&amp;gt;');
    websocket.close();
  }

  function onError(evt) {
    writeToScreen('&amp;lt;span style=&quot;color: red;&quot;&amp;gt;ERROR:&amp;lt;/span&amp;gt; ' + evt.data);
  }

  function doSend(message) {
    writeToScreen(&quot;SENT: &quot; + message);
    websocket.send(message);
  }

  function writeToScreen(message) {
    var pre = document.createElement(&quot;p&quot;);
    pre.style.wordWrap = &quot;break-word&quot;;
    pre.innerHTML = message;
    output.appendChild(pre);
  }

  // 加载时调用init方法，初始化websocket
  window.addEventListener(&quot;load&quot;, init, false);
  &amp;lt;/script&amp;gt;
  
  &amp;lt;h2&amp;gt;WebSocket Test&amp;lt;/h2&amp;gt;
  &amp;lt;div id=&quot;output&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;https://www.w3.org/TR/websockets/&lt;/li&gt;
&lt;li&gt;https://developer.mozilla.org/en-US/docs/Web/API/Blob&lt;/li&gt;
&lt;li&gt;http://www.websocket.org/echo.html&lt;/li&gt;
&lt;li&gt;http://www.websocket-test.com/&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;设计框架&quot;&gt;设计框架&lt;/h2&gt;
&lt;p&gt;一个通用的网络框架，在通用的前提下还需要能够支持各种项目的差异需求，根据经验，常见的需求差异如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户协议差异，游戏可能传输json、protobuf、flatbuffer或者自定义的二进制协议&lt;/li&gt;
&lt;li&gt;底层协议差异，我们可能使用websocket、或者微信小游戏的wx.websocket、甚至在原生平台我们希望使用tcp/udp/kcp等协议&lt;/li&gt;
&lt;li&gt;登陆认证流程，在使用长连接之前我们理应进行登陆认证，而不同游戏登陆认证的方式不同&lt;/li&gt;
&lt;li&gt;网络异常处理，比如超时时间是多久，超时后的表现是怎样的，请求时是否应该屏蔽UI等待服务器响应，网络断开后表现如何，自动重连还是由玩家点击重连按钮进行重连，重连之后是否重发断网期间的消息？等等这些。&lt;/li&gt;
&lt;li&gt;多连接的处理，某些游戏可能需要支持多个不同的连接，一般不会超过2个，比如一个主连接负责处理大厅等业务消息，一个战斗连接直接连战斗服务器，或者连接聊天服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据上面的这些需求，我们对功能模块进行拆分，尽量保证模块的高内聚，低耦合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://assets.processon.com/chart_image/5ca32736e4b0ec8ff3623fd2.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ProtocolHelper协议处理模块——当我们拿到一块buffer时，我们可能需要知道这个buffer对应的协议或者id是多少，比如我们在请求的时候就传入了响应的处理回调，那么常用的做法可能会用一个自增的id来区别每一个请求，或者是用协议号来区分不同的请求，这些是开发者需要实现的。我们还需要从buffer中获取包的长度是多少？包长的合理范围是多少？心跳包长什么样子等等。&lt;/li&gt;
&lt;li&gt;Socket模块——实现最基础的通讯功能，首先定义Socket的接口类ISocket，定义如连接、关闭、数据接收与发送等接口，然后子类继承并实现这些接口。&lt;/li&gt;
&lt;li&gt;NetworkTips网络显示模块——实现如连接中、重连中、加载中、网络断开等状态的显示，以及ui的屏蔽。&lt;/li&gt;
&lt;li&gt;NetNode网络节点——所谓网络节点，其实主要的职责是将上面的功能串联起来，为用户提供一个易用的接口。&lt;/li&gt;
&lt;li&gt;NetManager管理网络节点的单例——我们可能有多个网络节点（多条连接），所以这里使用单例来进行管理，使用单例来操作网络节点也会更加方便。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;protocolhelper&quot;&gt;ProtocolHelper&lt;/h2&gt;
&lt;p&gt;在这里定义了一个IProtocolHelper的简单接口，如下所示：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export type NetData = (string | ArrayBufferLike | Blob | ArrayBufferView);

// 协议辅助接口
export interface IProtocolHelper {
    getHeadlen(): number;                   // 返回包头长度
    getHearbeat(): NetData;                 // 返回一个心跳包
    getPackageLen(msg: NetData): number;    // 返回整个包的长度
    checkPackage(msg: NetData): boolean;    // 检查包数据是否合法
    getPackageId(msg: NetData): number;     // 返回包的id或协议类型
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;socket&quot;&gt;Socket&lt;/h2&gt;
&lt;p&gt;在这里定义了一个ISocket的简单接口，如下所示：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;// Socket接口
export interface ISocket {
    onConnected: (event) =&amp;gt; void;           // 连接回调
    onMessage: (msg: NetData) =&amp;gt; void;      // 消息回调
    onError: (event) =&amp;gt; void;               // 错误回调
    onClosed: (event) =&amp;gt; void;              // 关闭回调
    
    connect(ip: string, port: number);      // 连接接口
    send(buffer: NetData);                  // 数据发送接口
    close(code?: number, reason?: string);  // 关闭接口
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们实现一个WebSock，继承于ISocket，我们只需要实现connect、send和close接口即可。send和close都是对websocket对简单封装，connect则需要根据传入的ip、端口等参数构造一个url来创建websocket，并绑定websocket的回调。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export class WebSock implements ISocket {
    private _ws: WebSocket = null;              // websocket对象

    onConnected: (event) =&amp;gt; void = null;
    onMessage: (msg) =&amp;gt; void = null;
    onError: (event) =&amp;gt; void = null;
    onClosed: (event) =&amp;gt; void = null;

    connect(options: any) {
        if (this._ws) {
            if (this._ws.readyState === WebSocket.CONNECTING) {
                console.log(&quot;websocket connecting, wait for a moment...&quot;)
                return false;
            }
        }

        let url = null;
        if(options.url) {
            url = options.url;
        } else {
            let ip = options.ip;
            let port = options.port;
            let protocol = options.protocol;
            url = `${protocol}://${ip}:${port}`;    
        }

        this._ws = new WebSocket(url);
        this._ws.binaryType = options.binaryType ? options.binaryType : &quot;arraybuffer&quot;;
        this._ws.onmessage = (event) =&amp;gt; {
            this.onMessage(event.data);
        };
        this._ws.onopen = this.onConnected;
        this._ws.onerror = this.onError;
        this._ws.onclose = this.onClosed;
        return true;
    }

    send(buffer: NetData) {
        if (this._ws.readyState == WebSocket.OPEN)
        {
            this._ws.send(buffer);
            return true;
        }
        return false;
    }

    close(code?: number, reason?: string) {
        this._ws.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;networktips&quot;&gt;NetworkTips&lt;/h2&gt;
&lt;p&gt;INetworkTips提供了非常的接口，重连和请求的开关，框架会在合适的时机调用它们，我们可以继承INetworkTips并定制我们的网络相关提示信息，需要注意的是这些接口可能会被&lt;strong&gt;多次调用&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 网络提示接口
export interface INetworkTips {
    connectTips(isShow: boolean): void;
    reconnectTips(isShow: boolean): void;
    requestTips(isShow: boolean): void;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;netnode&quot;&gt;NetNode&lt;/h2&gt;
&lt;p&gt;NetNode是整个网络框架中最为关键的部分，一个NetNode实例表示一个完整的连接对象，基于NetNode我们可以方便地进行扩展，它的主要职责有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接维护
&lt;ul&gt;&lt;li&gt;连接的建立与鉴权（是否鉴权、如何鉴权由用户的回调决定）&lt;/li&gt;
&lt;li&gt;断线重连后的数据重发处理&lt;/li&gt;
&lt;li&gt;心跳机制确保连接有效（心跳包间隔由配置，心跳包的内容由ProtocolHelper定义）&lt;/li&gt;
&lt;li&gt;连接的关闭&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;数据发送
&lt;ul&gt;&lt;li&gt;支持断线重传，超时重传&lt;/li&gt;
&lt;li&gt;支持唯一发送（避免同一时间重复发送）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;数据接收
&lt;ul&gt;&lt;li&gt;支持持续监听&lt;/li&gt;
&lt;li&gt;支持request-respone模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;界面展示
&lt;ul&gt;&lt;li&gt;可自定义网络延迟、短线重连等状态的表现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下是NetNode的完整代码：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export enum NetTipsType {
    Connecting,
    ReConnecting,
    Requesting,
}

export enum NetNodeState {
    Closed,                     // 已关闭
    Connecting,                 // 连接中
    Checking,                   // 验证中
    Working,                    // 可传输数据
}

export interface NetConnectOptions {
    host?: string,              // 地址
    port?: number,              // 端口
    url?: string,               // url，与地址+端口二选一
    autoReconnect?: number,     // -1 永久重连，0不自动重连，其他正整数为自动重试次数
}

export class NetNode {
    protected _connectOptions: NetConnectOptions = null;
    protected _autoReconnect: number = 0;
    protected _isSocketInit: boolean = false;                               // Socket是否初始化过
    protected _isSocketOpen: boolean = false;                               // Socket是否连接成功过
    protected _state: NetNodeState = NetNodeState.Closed;                   // 节点当前状态
    protected _socket: ISocket = null;                                      // Socket对象（可能是原生socket、websocket、wx.socket...)

    protected _networkTips: INetworkTips = null;                            // 网络提示ui对象（请求提示、断线重连提示等）
    protected _protocolHelper: IProtocolHelper = null;                      // 包解析对象
    protected _connectedCallback: CheckFunc = null;                         // 连接完成回调
    protected _disconnectCallback: BoolFunc = null;                         // 断线回调
    protected _callbackExecuter: ExecuterFunc = null;                       // 回调执行

    protected _keepAliveTimer: any = null;                                  // 心跳定时器
    protected _receiveMsgTimer: any = null;                                 // 接收数据定时器
    protected _reconnectTimer: any = null;                                  // 重连定时器
    protected _heartTime: number = 10000;                                   // 心跳间隔
    protected _receiveTime: number = 6000000;                               // 多久没收到数据断开
    protected _reconnetTimeOut: number = 8000000;                           // 重连间隔
    protected _requests: RequestObject[] = Array&amp;lt;RequestObject&amp;gt;();          // 请求列表
    protected _listener: { [key: number]: CallbackObject[] } = {}           // 监听者列表

    /********************** 网络相关处理 *********************/
    public init(socket: ISocket, protocol: IProtocolHelper, networkTips: any = null, execFunc : ExecuterFunc = null) {
        console.log(`NetNode init socket`);
        this._socket = socket;
        this._protocolHelper = protocol;
        this._networkTips = networkTips;
        this._callbackExecuter = execFunc ? execFunc : (callback: CallbackObject, buffer: NetData) =&amp;gt; {
            callback.callback.call(callback.target, 0, buffer);
        }
    }

    public connect(options: NetConnectOptions): boolean {
        if (this._socket &amp;amp;&amp;amp; this._state == NetNodeState.Closed) {
            if (!this._isSocketInit) {
                this.initSocket();
            }
            this._state = NetNodeState.Connecting;
            if (!this._socket.connect(options)) {
                this.updateNetTips(NetTipsType.Connecting, false);
                return false;
            }

            if (this._connectOptions == null) {
                options.autoReconnect = options.autoReconnect;
            }
            this._connectOptions = options;
            this.updateNetTips(NetTipsType.Connecting, true);
            return true;
        }
        return false;
    }

    protected initSocket() {
        this._socket.onConnected = (event) =&amp;gt; { this.onConnected(event) };
        this._socket.onMessage = (msg) =&amp;gt; { this.onMessage(msg) };
        this._socket.onError = (event) =&amp;gt; { this.onError(event) };
        this._socket.onClosed = (event) =&amp;gt; { this.onClosed(event) };
        this._isSocketInit = true;
    }

    protected updateNetTips(tipsType: NetTipsType, isShow: boolean) {
        if (this._networkTips) {
            if (tipsType == NetTipsType.Requesting) {
                this._networkTips.requestTips(isShow);
            } else if (tipsType == NetTipsType.Connecting) {
                this._networkTips.connectTips(isShow);
            } else if (tipsType == NetTipsType.ReConnecting) {
                this._networkTips.reconnectTips(isShow);
            }
        }
    }

    // 网络连接成功
    protected onConnected(event) {
        console.log(&quot;NetNode onConnected!&quot;)
        this._isSocketOpen = true;
        // 如果设置了鉴权回调，在连接完成后进入鉴权阶段，等待鉴权结束
        if (this._connectedCallback !== null) {
            this._state = NetNodeState.Checking;
            this._connectedCallback(() =&amp;gt; { this.onChecked() });
        } else {
            this.onChecked();
        }
        console.log(&quot;NetNode onConnected! state =&quot; + this._state);
    }

    // 连接验证成功，进入工作状态
    protected onChecked() {
        console.log(&quot;NetNode onChecked!&quot;)
        this._state = NetNodeState.Working;
        // 关闭连接或重连中的状态显示
        this.updateNetTips(NetTipsType.Connecting, false);
        this.updateNetTips(NetTipsType.ReConnecting, false);

        // 重发待发送信息
        console.log(`NetNode flush ${this._requests.length} request`)
        if (this._requests.length &amp;gt; 0) {
            for (var i = 0; i &amp;lt; this._requests.length;) {
                let req = this._requests[i];
                this._socket.send(req.buffer);
                if (req.rspObject == null || req.rspCmd &amp;lt;= 0) {
                    this._requests.splice(i, 1);
                } else {
                    ++i;
                }
            }
            // 如果还有等待返回的请求，启动网络请求层
            this.updateNetTips(NetTipsType.Requesting, this.request.length &amp;gt; 0);
        }
    }

    // 接收到一个完整的消息包
    protected onMessage(msg): void {
        // console.log(`NetNode onMessage status = ` + this._state);
        // 进行头部的校验（实际包长与头部长度是否匹配）
        if (!this._protocolHelper.check P a c ka ge(msg)) {
            console.error(`NetNode checkHead Error`);
            return;
        }
        // 接受到数据，重新定时收数据计时器
        this.resetReceiveMsgTimer();
        // 重置心跳包发送器
        this.resetHearbeatTimer();
        // 触发消息执行
        let rspCmd = this._protocolHelper.getPackageId(msg);
        console.log(`NetNode onMessage rspCmd = ` + rspCmd);
        // 优先触发request队列
        if (this._requests.length &amp;gt; 0) {
            for (let reqIdx in this._requests) {
                let req = this._requests[reqIdx];
                if (req.rspCmd == rspCmd) {
                    console.log(`NetNode execute request rspcmd ${rspCmd}`);
                    this._callbackExecuter(req.rspObject, msg);
                    this._requests.splice(parseInt(reqIdx), 1);
                    break;
                }
            }
            console.log(`NetNode still has ${this._requests.length} request watting`);
            if (this._requests.length == 0) {
                this.updateNetTips(NetTipsType.Requesting, false);
            }
        }

        let listeners = this._listener[rspCmd];
        if (null != listeners) {
            for (const rsp of listeners) {
                console.log(`NetNode execute listener cmd ${rspCmd}`);
                this._callbackExecuter(rsp, msg);
            }
        }
    }

    protected onError(event) {
        console.error(event);
    }

    protected onClosed(event) {
        this.clearTimer();

        // 执行断线回调，返回false表示不进行重连
        if (this._disconnectCallback &amp;amp;&amp;amp; !this._disconnectCallback()) {
            console.log(`disconnect return!`)
            return;
        }

        // 自动重连
        if (this.isAutoReconnect()) {
            this.updateNetTips(NetTipsType.ReConnecting, true);
            this._reconnectTimer = setTimeout(() =&amp;gt; {
                this._socket.close();
                this._state = NetNodeState.Closed;
                this.connect(this._connectOptions);
                if (this._autoReconnect &amp;gt; 0) {
                    this._autoReconnect -= 1;
                }
            }, this._reconnetTimeOut);
        } else {
            this._state = NetNodeState.Closed;
        }
    }

    public close(code?: number, reason?: string) {
        this.clearTimer();
        this._listener = {};
        this._requests.length = 0;
        if (this._networkTips) {
            this._networkTips.connectTips(false);
            this._networkTips.reconnectTips(false);
            this._networkTips.requestTips(false);
        }
        if (this._socket) {
            this._socket.close(code, reason);
        } else {
            this._state = NetNodeState.Closed;
        }
    }

    // 只是关闭Socket套接字（仍然重用缓存与当前状态）
    public closeSocket(code?: number, reason?: string) {
        if (this._socket) {
            this._socket.close(code, reason);
        }
    }

    // 发起请求，如果当前处于重连中，进入缓存列表等待重连完成后发送
    public send(buf: NetData, force: boolean = false): boolean {
        if (this._state == NetNodeState.Working || force) {
            console.log(`socket send ...`);
            return this._socket.send(buf);
        } else if (this._state == NetNodeState.Checking ||
            this._state == NetNodeState.Connecting) {
            this._requests.push({
                buffer: buf,
                rspCmd: 0,
                rspObject: null
            });
            console.log(&quot;NetNode socket is busy, push to send buffer, current state is &quot; + this._state);
            return true;
        } else {
            console.error(&quot;NetNode request error! current state is &quot; + this._state);
            return false;
        }
    }

    // 发起请求，并进入缓存列表
    public request(buf: NetData, rspCmd: number, rspObject: CallbackObject, showTips: boolean = true, force: boolean = false) {
        if (this._state == NetNodeState.Working || force) {
            this._socket.send(buf);
        }
        console.log(`NetNode request with timeout for ${rspCmd}`);
        // 进入发送缓存列表
        this._requests.push({
            buffer: buf, rspCmd, rspObject
        });
        // 启动网络请求层
        if (showTips) {
            this.updateNetTips(NetTipsType.Requesting, true);
        }
    }

    // 唯一request，确保没有同一响应的请求（避免一个请求重复发送，netTips界面的屏蔽也是一个好的方法）
    public requestUnique(buf: NetData, rspCmd: number, rspObject: CallbackObject, showTips: boolean = true, force: boolean = false): boolean {
        for (let i = 0; i &amp;lt; this._requests.length; ++i) {
            if (this._requests[i].rspCmd == rspCmd) {
                console.log(`NetNode requestUnique faile for ${rspCmd}`);
                return false;
            }
        }
        this.request(buf, rspCmd, rspObject, showTips, force);
        return true;
    }

    /********************** 回调相关处理 *********************/
    public setResponeHandler(cmd: number, callback: NetCallFunc, target?: any): boolean {
        if (callback == null) {
            console.error(`NetNode setResponeHandler error ${cmd}`);
            return false;
        }
        this._listener[cmd] = [{ target, callback }];
        return true;
    }

    public addResponeHandler(cmd: number, callback: NetCallFunc, target?: any): boolean {
        if (callback == null) {
            console.error(`NetNode addResponeHandler error ${cmd}`);
            return false;
        }
        let rspObject = { target, callback };
        if (null == this._listener[cmd]) {
            this._listener[cmd] = [rspObject];
        } else {
            let index = this.getNetListenersIndex(cmd, rspObject);
            if (-1 == index) {
                this._listener[cmd].push(rspObject);
            }
        }
        return true;
    }

    public removeResponeHandler(cmd: number, callback: NetCallFunc, target?: any) {
        if (null != this._listener[cmd] &amp;amp;&amp;amp; callback != null) {
            let index = this.getNetListenersIndex(cmd, { target, callback });
            if (-1 != index) {
                this._listener[cmd].splice(index, 1);
            }
        }
    }

    public cleanListeners(cmd: number = -1) {
        if (cmd == -1) {
            this._listener = {}
        } else {
            this._listener[cmd] = null;
        }
    }

    protected getNetListenersIndex(cmd: number, rspObject: CallbackObject): number {
        let index = -1;
        for (let i = 0; i &amp;lt; this._listener[cmd].length; i++) {
            let iterator = this._listener[cmd][i];
            if (iterator.callback == rspObject.callback
                &amp;amp;&amp;amp; iterator.target == rspObject.target) {
                index = i;
                break;
            }
        }
        return index;
    }

    /********************** 心跳、超时相关处理 *********************/
    protected resetReceiveMsgTimer() {
        if (this._receiveMsgTimer !== null) {
            clearTimeout(this._receiveMsgTimer);
        }

        this._receiveMsgTimer = setTimeout(() =&amp;gt; {
            console.warn(&quot;NetNode recvieMsgTimer close socket!&quot;);
            this._socket.close();
        }, this._receiveTime);
    }

    protected resetHearbeatTimer() {
        if (this._keepAliveTimer !== null) {
            clearTimeout(this._keepAliveTimer);
        }

        this._keepAliveTimer = setTimeout(() =&amp;gt; {
            console.log(&quot;NetNode keepAliveTimer send Hearbeat&quot;)
            this.send(this._protocolHelper.getHearbeat());
        }, this._heartTime);
    }

    protected clearTimer() {
        if (this._receiveMsgTimer !== null) {
            clearTimeout(this._receiveMsgTimer);
        }
        if (this._keepAliveTimer !== null) {
            clearTimeout(this._keepAliveTimer);
        }
        if (this._reconnectTimer !== null) {
            clearTimeout(this._reconnectTimer);
        }
    }

    public isAutoReconnect() {
        return this._autoReconnect != 0;
    }

    public rejectReconnect() {
        this._autoReconnect = 0;
        this.clearTimer();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;netmanager&quot;&gt;NetManager&lt;/h2&gt;
&lt;p&gt;NetManager用于管理NetNode，这是由于我们可能需要支持多个不同的连接对象，所以需要一个NetManager专门来管理NetNode，同时，NetManager作为一个单例，也可以方便我们调用网络。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export class NetManager {
    private static _instance: NetManager = null;
    protected _channels: { [key: number]: NetNode } = {};

    public static getInstance(): NetManager {
        if (this._instance == null) {
            this._instance = new NetManager();
        }
        return this._instance;
    }

    // 添加Node，返回ChannelID
    public setNetNode(newNode: NetNode, channelId: number = 0) {
        this._channels[channelId] = newNode;
    }

    // 移除Node
    public removeNetNode(channelId: number) {
        delete this._channels[channelId];
    }

    // 调用Node连接
    public connect(options: NetConnectOptions, channelId: number = 0): boolean {
        if (this._channels[channelId]) {
            return this._channels[channelId].connect(options);
        }
        return false;
    }

    // 调用Node发送
    public send(buf: NetData, force: boolean = false, channelId: number = 0): boolean {
        let node = this._channels[channelId];
        if(node) {
            return node.send(buf, force);
        }
        return false;
    }

    // 发起请求，并在在结果返回时调用指定好的回调函数
    public request(buf: NetData, rspCmd: number, rspObject: CallbackObject, showTips: boolean = true, force: boolean = false, channelId: number = 0) {
        let node = this._channels[channelId];
        if(node) {
            node.request(buf, rspCmd, rspObject, showTips, force);
        }
    }

    // 同request，但在request之前会先判断队列中是否已有rspCmd，如有重复的则直接返回
    public requestUnique(buf: NetData, rspCmd: number, rspObject: CallbackObject, showTips: boolean = true, force: boolean = false, channelId: number = 0): boolean {
        let node = this._channels[channelId];
        if(node) {
            return node.requestUnique(buf, rspCmd, rspObject, showTips, force);
        }
        return false;
    }

    // 调用Node关闭
    public close(code?: number, reason?: string, channelId: number = 0) {
        if (this._channels[channelId]) {
            return this._channels[channelId].closeSocket(code, reason);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试例子&quot;&gt;测试例子&lt;/h2&gt;
&lt;p&gt;接下来我们用一个简单的例子来演示一下网络框架的基本使用，首先我们需要拼一个简单的界面用于展示，3个按钮（连接、发送、关闭），2个输入框（输入url、输入要发送的内容），一个文本框（显示从服务器接收到的数据），如下图所示。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;该例子连接的是websocket官方的echo.websocket.org地址，这个服务器会将我们发送给它的所有消息都原样返回给我们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/16/KPhKoR.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，实现一个简单的Component，这里新建了一个NetExample.ts文件，做的事情非常简单，在初始化的时候创建NetNode、绑定默认接收回调，在接收回调中将服务器返回的文本显示到msgLabel中。接着是连接、发送和关闭几个接口的实现：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;// 不关键的代码省略

@ccclass
export default class NetExample extends cc.Component {
    @property(cc.Label)
    textLabel: cc.Label = null;
    @property(cc.Label)
    urlLabel: cc.Label = null;
    @property(cc.RichText)
    msgLabel: cc.RichText = null;
    private lineCount: number = 0;

    onLoad() {
        let Node = new NetNode();
        Node.init(new WebSock(), new DefStringProtocol());
        Node.setResponeHandler(0, (cmd: number, data: NetData) =&amp;gt; {
            if (this.lineCount &amp;gt; 5) {
                let idx = this.msgLabel.string.search(&quot;\n&quot;);
                this.msgLabel.string = this.msgLabel.string.substr(idx + 1);
            }
            this.msgLabel.string += `${data}\n`;
            ++this.lineCount;
        });
        NetManager.getInstance().setNetNode(Node);
    }

    onConnectClick() {
        NetManager.getInstance().connect({ url: this.urlLabel.string });
    }

    onSendClick() {
        NetManager.getInstance().send(this.textLabel.string);
    }

    onDisconnectClick() {
        NetManager.getInstance().close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码完成后，将其挂载到场景的Canvas节点下（其他节点也可以），然后将场景中的Label和RichText拖拽到我们的NetExample的属性面板中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/16/KPholT.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/16/KPhaTA.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;可以看到，Websocket的使用很简单，我们在开发的过程中会碰到各种各样的需求和问题，要实现一个好的设计，快速地解决问题。&lt;/p&gt;
&lt;p&gt;我们一方面需要对我们使用的技术本身有深入的理解，websocket的底层协议传输是如何实现的？与tcp、http的区别在哪里？基于websocket能否使用udp进行传输呢？使用websocket发送数据是否需要自己对数据流进行分包（websocket协议保证了包的完整）？数据的发送是否出现了发送缓存的堆积（查看bufferedAmount）？&lt;/p&gt;
&lt;p&gt;另外需要对我们的使用场景及需求本身的理解，对需求的理解越透彻，越能做出好的设计。哪些需求是项目相关的，哪些需求是通用的？通用的需求是必须的还是可选的？不同的变化我们应该封装成类或接口，使用多态的方式来实现呢？还是提供配置？回调绑定？事件通知？&lt;/p&gt;
&lt;p&gt;我们需要设计出一个好的框架，来适用于下一个项目，并且在一个一个的项目中优化迭代，这样才能建立深厚的沉淀、提高效率。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;接下来的一段时间会将之前的一些经验整理为一个开源易用的cocos creator框架：https://github.com/wyb10a10/cocos_creator_framework&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 16 Oct 2019 14:40:00 +0000</pubDate>
<dc:creator>深圳-宝爷</dc:creator>
<og:description>在Creator中发起一个http请求是比较简单的，但很多游戏希望能够和服务器之间保持长连接，以便服务端能够主动向客户端推送消息，而非总是由客户端发起请求，对于实时性要求较高的游戏更是如此。这里我们会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybgame/p/11688944.html</dc:identifier>
</item>
<item>
<title>cocos2d-x 系统学习cocos(1) - 凌夜霜</title>
<link>http://www.cnblogs.com/NightFrost/p/11688854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NightFrost/p/11688854.html</guid>
<description>&lt;p&gt;以前使用cocos2d-x 3.14的时候，HelloWorld并不是一个场景类，而是一个图层类，当时的HelloWorld::createScene()是长这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Scene* HelloWorld::createScene()
{
    auto scene = Scene::create();
    auto layer = HelloWorld::create();
    scene-&amp;gt;addChild(layer);
    return scene;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而现在的3.17的HelloWorld::createScene()长这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Scene* HelloWorld::createScene()
{
    return HelloWorld::create();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;区别就是HelloWorld本身已经是一个场景了，不需要另外生成一个场景再将HelloWorld加到场景中作为子节点&lt;/p&gt;
&lt;h2 id=&quot;helloworld的布局&quot;&gt;HelloWorld的布局&lt;/h2&gt;
&lt;p&gt;HelloWorld场景中有一个cocos的logo，一个关闭按钮，一个HelloWorld的字样，这些小物体都是在HelloWorld::init()中生成的&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450046/201910/1450046-20191016223607638-438677884.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基类的初始化&quot;&gt;基类的初始化&lt;/h3&gt;
&lt;p&gt;我们向HelloWorld场景添加东西之前，需要先调用基类Scene类的初始化函数，然后获得一下visibleSize和origin备用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool HelloWorld::init()
{

    if ( !Scene::init() )
    {
        return false;
    }
    auto visibleSize = Director::getInstance()-&amp;gt;getVisibleSize();
    Vec2 origin = Director::getInstance()-&amp;gt;getVisibleOrigin();
.................
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关闭按钮的生成&quot;&gt;关闭按钮的生成&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;bool HelloWorld::init()
{
.................
    auto closeItem = MenuItemImage::create(
                                           &quot;CloseNormal.png&quot;,
                                           &quot;CloseSelected.png&quot;,
                                           CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));

    float x = origin.x + visibleSize.width - closeItem-&amp;gt;getContentSize().width/2;
    float y = origin.y + closeItem-&amp;gt;getContentSize().height/2;
    closeItem-&amp;gt;setPosition(Vec2(x,y));

    auto menu = Menu::create(closeItem, NULL);
    menu-&amp;gt;setPosition(Vec2::ZERO);
    this-&amp;gt;addChild(menu, 1);
.................
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的代码可能看起来会很复杂，其实不然，我们可以发现cocos里很多对象在生成的时候都会使用create这个静态工厂方法，HelloWorld这个场景也不例外，create将生成游戏对象所需要的参数填进去构造一个对象的指针返回&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MenuItemImage&lt;/strong&gt;的create方法传入默认状态的&lt;em&gt;close按钮的图片&lt;/em&gt;、&lt;em&gt;点击状态下的close按钮的图片&lt;/em&gt;以及一个&lt;em&gt;回调&lt;/em&gt;，回调指的是程序对按钮被按下这个事件做出的响应，使用CC_CALLBACK_1宏加上一个&lt;em&gt;void(T::*)(Ref*)类型的成员函数的函数指针&lt;/em&gt;以及&lt;em&gt;调用这个成员函数的对象的指针&lt;/em&gt;组成一个回调，看不懂没关系，我们照着写就好&lt;br/&gt;然后就是计算出x和y的值，也就是右下角的按钮的坐标，&lt;strong&gt;getContentSize()&lt;/strong&gt;获得对象的尺寸，最后使用&lt;strong&gt;setPosition&lt;/strong&gt;设置按钮的坐标&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，按钮是不可以直接添加到场景中的，按钮需要依赖菜单，也就是&lt;strong&gt;Menu&lt;/strong&gt;对象，所以我们创建一个包含了&lt;strong&gt;closeItem&lt;/strong&gt;的菜单，并设置坐标为（0，0），最后才能使用&lt;strong&gt;addChild&lt;/strong&gt;将菜单添加到场景中&lt;/p&gt;
&lt;h3 id=&quot;字体的生成&quot;&gt;字体的生成&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;bool HelloWorld::init()
{
.................
    auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/Marker Felt.ttf&quot;, 24);
    label-&amp;gt;setPosition(Vec2(origin.x + visibleSize.width/2,
                                origin.y + visibleSize.height - label-&amp;gt;getContentSize().height));
    this-&amp;gt;addChild(label, 1);
.................
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个也很好理解，&lt;strong&gt;createWithTTF&lt;/strong&gt;返回一个Label对象的指针，&lt;em&gt;显示的字符串&lt;/em&gt;、&lt;em&gt;字体&lt;/em&gt;和&lt;em&gt;字体大小&lt;/em&gt;作为函数的参数，也是使用&lt;strong&gt;addChild&lt;/strong&gt;添加到场景中，这里的1比0高一层，我们试着把文本的坐标设置到场景中央&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool HelloWorld::init()
{
.................
    auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/Marker Felt.ttf&quot;, 24);
    label-&amp;gt;setPosition(Vec2(origin.x + visibleSize.width/2,
                                origin.y + visibleSize.height/2));
    this-&amp;gt;addChild(label, 1);
.................
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450046/201910/1450046-20191016221936125-914106076.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文本是在logo上方的，证明图层越高，渲染得越晚，先渲染的被压在后渲染的物体下面&lt;/p&gt;
&lt;h3 id=&quot;精灵的生成&quot;&gt;精灵的生成&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;bool HelloWorld::init()
{
.................
    auto sprite = Sprite::create(&quot;HelloWorld.png&quot;);
    sprite-&amp;gt;setPosition(Vec2(visibleSize.width / 2 + origin.x, visibleSize.height / 2 + origin.y));
    this-&amp;gt;addChild(sprite, 0);
    return true;
.................
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个就更简单了，使用一张图片生成一个精灵，同样也是加到场景中，最后要记得return true，如果init函数不返回true的话程序会崩掉的&lt;/p&gt;
&lt;h2 id=&quot;深入探索helloworld场景&quot;&gt;深入探索HelloWorld场景&lt;/h2&gt;
&lt;p&gt;我一直都认为cocos2dx是学习c++的一个非常好的教材，cocos2dx使用了很多面向对象的特性，c++的特性，还有一些设计模式的思想，对一个新手程序员的综合性成长有很大的帮助&lt;/p&gt;
&lt;h3 id=&quot;游戏开始的地方&quot;&gt;游戏开始的地方&lt;/h3&gt;
&lt;p&gt;首先，游戏场景的入口是导演类的runWithScene，打开&lt;strong&gt;AppDelegate.cpp&lt;/strong&gt;,找到&lt;strong&gt;AppDelegate::applicationDidFinishLaunching()&lt;/strong&gt;函数，我们可以看到这样的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool AppDelegate::applicationDidFinishLaunching() {
    auto director = Director::getInstance();
..............
    auto scene = HelloWorld::createScene();

    director-&amp;gt;runWithScene(scene);

    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Director类是一个单例类，使用getInstance可以获得它的实例，单例实际上是通过把构造函数私有化，把对象的访问权限交给一个静态函数实现的，一般我们会使用懒加载来使用这种单例，扯远了，也就是说Director使用了单例模式&lt;br/&gt;Director通过runWithScene运行HelloWorld场景，并让HelloWorld以及HelloWorld的子节点工作&lt;/p&gt;
&lt;h3 id=&quot;node类&quot;&gt;Node类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Node类&lt;/strong&gt;是HelloWorld场景里我们使用的大部分类的基类，事实上Scene类也是一个Node，很好理解，游戏世界中的对象实际上大部分都是Node，Node和Node通过父子关系联系起来，游戏里的对象的模型是一棵树，父节点使用addChild将子节点加到自己管理的子节点队列中，游戏运行的时候，导演就会遍历这些Node让他们进行工作，比如说HelloWorld场景，&lt;strong&gt;HelloWorld场景是根节点，精灵sprite，文本label，菜单menu是HelloWorld的子节点，按钮closeItem是菜单menu的子节点&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;ref类&quot;&gt;Ref类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Ref类&lt;/strong&gt;是用于&lt;strong&gt;引用计数&lt;/strong&gt;的类，负责对象的引用计数，Ref类是Node类的基类，也就是说所有的Node都是使用cocos2dx的引用计数内存管理系统进行内存管理的，这也是为什么我们生成对象不是用new和delete，而是用create生成对象的原因。这里涉及到了&lt;strong&gt;GC&lt;/strong&gt;的知识。简单来说，引用计数法的理论是，当对象被引用的时候，对象的引用计数会+1，取消引用的时候就-1，当计数为0的时候就将对象销毁，感兴趣可以了解一下&lt;strong&gt;智能指针&lt;/strong&gt;和&lt;strong&gt;RAII&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;create&quot;&gt;create&lt;/h3&gt;
&lt;p&gt;这个函数我们可以认为它是一个工厂，这个工厂把我们生成对象之前需要做的工作先做好了，在文章达到最开头有这样一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Scene* HelloWorld::createScene()
{
    return HelloWorld::create();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后HelloWorldScene.h是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifndef __HELLOWORLD_SCENE_H__
#define __HELLOWORLD_SCENE_H__

#include &quot;cocos2d.h&quot;

class HelloWorld : public cocos2d::Scene
{
public:
    static cocos2d::Scene* createScene();

    virtual bool init();
    
    void menuCloseCallback(cocos2d::Ref* pSender);
    
    CREATE_FUNC(HelloWorld);
};

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;诶，奇怪了，为什么没有看到create函数，难道是在基类里？嗯呣，静态成员函数是不能继承的，所以问题出现在&lt;strong&gt;CREATE_FUNC&lt;/strong&gt;上，没错！我们看看&lt;strong&gt;CREATE_FUNC&lt;/strong&gt;的定义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define CREATE_FUNC(__TYPE__) \
static __TYPE__* create() \
{ \
    __TYPE__ *pRet = new(std::nothrow) __TYPE__(); \
    if (pRet &amp;amp;&amp;amp; pRet-&amp;gt;init()) \
    { \
        pRet-&amp;gt;autorelease(); \
        return pRet; \
    } \
    else \
    { \
        delete pRet; \
        pRet = nullptr; \
        return nullptr; \
    } \
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出来，CREATE_FUNC是一个可以让你偷懒不用手动编写create函数的宏&lt;br/&gt;当然有的类需要客制化create，比如说Sprite的create&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Sprite* Sprite::create()
{
    Sprite *sprite = new (std::nothrow) Sprite();
    if (sprite &amp;amp;&amp;amp; sprite-&amp;gt;init())
    {
        sprite-&amp;gt;autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;create里进行了什么操作呢？&lt;br/&gt;1.使用new生成对象&lt;br/&gt;2.使用init初始化对象&lt;br/&gt;3.使用autorelease将这个Ref类交给引用计数系统管理内存&lt;br/&gt;看到这个init我们是不是想到了什么，HelloWorld场景的布局就是在init中实现的，而init由create调用，也就是说，在HelloWorld进行create的时候就已经将文本，按钮，精灵等物件创建并加入到场景中，而这些物件也是通过create创建的，也就是说，场景创建的时候会调用所有物件的init，这样我们对cocos2dx的游戏流程是不是有了更深的理解&lt;br/&gt;&lt;strong&gt;autorelease&lt;/strong&gt;是Ref类的方法，查看一下它的定义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Ref* Ref::autorelease()
{
    PoolManager::getInstance()-&amp;gt;getCurrentPool()-&amp;gt;addObject(this);
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又看到了getInstance，说明PoolManager也是一个单例类，这段代码的意思很明显，将Ref加入到当前内存池中管理&lt;br/&gt;我们在后续的开发中经常需要客制化create，只要我们的create能满足上面三个功能即可&lt;/p&gt;

&lt;p&gt;这节我们通过研究cocos2dx新工程自带的HelloWorld代码了解到了很多东西，&lt;strong&gt;设计模式，GC，游戏对象结构的设计思路，还有c++的各种小知识，用宏偷懒啦，宏保护避免重复编译啦&lt;/strong&gt;&lt;br/&gt;嗯？宏保护是什么？&lt;/p&gt;
&lt;h2 id=&quot;宏保护&quot;&gt;宏保护&lt;/h2&gt;
&lt;p&gt;这里顺便讲一下宏保护这个小知识点，宏保护使用来避免.h文件被重复编译的，这里以&lt;strong&gt;HelloWorldScene.h&lt;/strong&gt;为例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifndef __HELLOWORLD_SCENE_H__
#define __HELLOWORLD_SCENE_H__
............
#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;#这个符号开头的代码是预处理命令，在程序编译之前会进行预处理工作，这几行代码的意思是，如果没有定义__HELLOWORLD_SCENE_H__这个符号就定义__HELLOWORLD_SCENE_H__并且编译到endif为止的内容，当__HELLOWORLD_SCENE_H__被定义过一次，预处理器下一次遇到这条预处理命令的时候就不会再把下面的代码作为编译目标，当然现在vs有一条#pragma once的命令，保证该文件只编译一次，也可以达到我们的目的&lt;/p&gt;
</description>
<pubDate>Wed, 16 Oct 2019 14:35:00 +0000</pubDate>
<dc:creator>凌夜霜</dc:creator>
<og:description>简析HelloWorld场景 以前使用cocos2d x 3.14的时候，HelloWorld并不是一个场景类，而是一个图层类，当时的HelloWorld::createScene()是长这样的 而现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/NightFrost/p/11688854.html</dc:identifier>
</item>
</channel>
</rss>