<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>工作一两年的程序员，有点钱，买房还是买车？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/13548169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/13548169.html</guid>
<description>&lt;blockquote readability=&quot;6.4637096774194&quot;&gt;
&lt;p&gt;先看再点赞，给自己一点思考的时间；欢迎微信搜索【&lt;strong&gt;沉默王二&lt;/strong&gt;】关注这个有颜值却假装靠才华苟且的程序员。&lt;br/&gt;本文 &lt;strong&gt;GitHub&lt;/strong&gt; &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;github.com/itwanger&lt;/a&gt; 已收录，里面还有我精心准备的一线大厂面试题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有个朋友小白，在成都，也是个程序员，最近打算买车，但有点犹豫，就问我，“二哥，很多人劝我攒钱先买房，但我就是想先买辆车，你的建议呢？”&lt;/p&gt;
&lt;p&gt;我的读者群体里，年轻人居多，尤其是像小白这样的，刚参加工作一两年的，有点钱，但买房难度有点大，买车到还好（比房子还贵的车不考虑在内哈）。我约摸着不少读者有这种困惑，所以我打算把我的观点抛出来，给大家一点点参考。（仅供参考，仅供参考，我得先撇清责任，呵呵）&lt;/p&gt;
&lt;p&gt;买房还是买车，确实是要看情况的，不能一概而论。&lt;/p&gt;
&lt;p&gt;我就问小白啊，“成都房价你现在能承受得起吗？将来打算在成都定居吗？你现在攒的钱能够首付吗？家里给的支援能到位吗？”&lt;/p&gt;
&lt;p&gt;小白有些无奈地回答，“成都的房价，以我现在的能力，真有点负担不起，我和二哥都是农村来的，支援不了那么多啊！我想着过些年，还是回咱河南工作。但问了很多人，都劝我先买房，可是在我心目中，真的非常非常想拥有一辆自己的车子！”&lt;/p&gt;
&lt;p&gt;其实对于小白这种情况，答案已经很清晰了，对不对？假如房子能买得起，我也劝他买。&lt;/p&gt;
&lt;p&gt;我 2014 年回到洛阳的时候，一心就想租个房子住。&lt;/p&gt;
&lt;p&gt;第一，我那时候就没有买房的意愿，觉得租房挺好的，当时 1200 元租了三室两厅两卫，我和女朋友一块住，奢侈得不要不要的。&lt;/p&gt;
&lt;p&gt;第二，工作了三年半，就攒了不到十万块，也不想找家里要钱，即便是要了，离一套房子的首付还有点距离，必须得再借点朋友同事的。&lt;/p&gt;
&lt;p&gt;我那时候的心态，是不是很佛系？能配得上我的头像吧！&lt;/p&gt;
&lt;p&gt;假如那时候，谁劝我买房，我就想问一句，你能不能借我点？相信我，我有能力偿还的，用人品保证。&lt;/p&gt;
&lt;p&gt;理想和现实总有点差距，对不对？可日子还是要一天天过啊。&lt;/p&gt;
&lt;p&gt;等到了 2016 年，女朋友开始催我买房，毕竟要结婚了，买房是刚需。这时候，我虽然有点不情愿，但前后合计合计，好像能买得起房了，虽然房价在两年内涨了不少。&lt;/p&gt;
&lt;p&gt;父母能给我们支援 15 万，再加上同事朋友能借 10 万，加上我们的那些积蓄，首付够了，并且装修家居的钱也够了，关键是女朋友的公积金能够负担起买房的贷款。&lt;/p&gt;
&lt;p&gt;这就满足了买房的条件对不对？假如买房的条件达成了，那肯定要买房。买房的好处是什么？&lt;/p&gt;
&lt;p&gt;第一，有了房，就满足了结婚的必要条件。&lt;/p&gt;
&lt;p&gt;第二，有了房，就有了这座城市的归属感。我虽然是个洛阳人，但在市区没有房的话，只能算是洛阳市洛宁县河底乡东河村的村民。&lt;/p&gt;
&lt;p&gt;第三，有了房，就不用搬家了。我们当初租的那套三室，后来拆迁了，如果没买房，就得搬家。&lt;/p&gt;
&lt;p&gt;但每个人的情况都不尽相同，小白就和我不同。&lt;/p&gt;
&lt;p&gt;第一，小白在成都还买不起房，能力有待发展，家里的支援也不到位。一味追求买房就是个空谈。&lt;/p&gt;
&lt;p&gt;第二，就算是首付凑得够，乱七八糟的生活费和房贷加在一起，压力特别大，这对于追求享受生活的年轻人来说，受不了。&lt;/p&gt;
&lt;p&gt;第三，小白也没打算一直在成都。&lt;/p&gt;
&lt;p&gt;第四，小白就想买辆车，他觉得有了车，就实现了自己多年的梦想，这份激励会变成他努力工作的动力，而不是压力。&lt;/p&gt;
&lt;p&gt;那有不少读者就说，买车有很多弊端啊！&lt;/p&gt;
&lt;p&gt;第一，车是消耗品，过几年就掉价了，亏得慌啊。&lt;/p&gt;
&lt;p&gt;第二，城市这么堵，买了不一定能开几次，还有油费，停车费，保险，等等乱七八糟的费用。到时候还得去挤地铁。&lt;/p&gt;
&lt;p&gt;那一个人活着是为了什么？&lt;/p&gt;
&lt;p&gt;谈恋爱是要花钱的，对吧？没有人不承认这一点吧？虽然爱情是美好的，但也得付出啊。&lt;/p&gt;
&lt;p&gt;总不能为了省下谈恋爱花的那些钱，就不去谈啊！要知道，谈恋爱不仅能够在精神上获得满足，获得幸福，还能。。。。。。你懂吧？&lt;/p&gt;
&lt;p&gt;很多程序员，都酷爱电子产品，比如说显示器、鼠标、键盘、电脑、耳机、手机、游戏机，这些东西买便宜的也能使啊，可工作效率就降低了，久而久之，就倦怠了，对吧？我那么辛苦工作图个啥？&lt;/p&gt;
&lt;p&gt;每个人都应该有一些追求，追求物质、追求精神，追求车，追求房，追求爱情。在人生的不同阶段，应该按照自己的心意，在适可的范围内，实现一些追求，这样才会获得前进的动力。&lt;/p&gt;
&lt;p&gt;以我对小白的了解，买车绝对可以激发一个更好的他，成为他努力工作的动力，用不了两年，他就有能力买房了。即便是他现在的薪资不算高，但以他的进步速度，再加上买车后的刺激，两年后绝对可以超越大多数人。&lt;/p&gt;
&lt;p&gt;我 31 岁了，你能猜得到，我下一个物质上的欲望是什么吗？我想买一辆机车（摩托车），酷酷的那种。工作压力大了，生活压力大了，我就一个人骑一辆车，自由地奔驰去。&lt;/p&gt;
&lt;p&gt;人是应该面对现实，不要空谈理想。但如果只是在现实中挣扎，那就失去了活着的意义。&lt;/p&gt;
&lt;p&gt;想象一个画面，你想去一个地方，车上载着女朋友，那种自由奔驰、兜风，把一切烦恼抛诸脑后的快感，是不是贼爽？&lt;/p&gt;
&lt;p&gt;我家的车，买了三年多，跑了不到三万公里，但每次下雨，每次出远门，我都要重复一句话，“车，真的是一个神奇的玩意，太方便了。人也太能了吧？竟然发明了车。”&lt;/p&gt;
&lt;p&gt;买了车，不意味着就不要买房，买了房也不意味着就不要买车，这两样东西，是近几十年，普通人不得不面对的两样魔幻的东西。先买哪个？得看能力，得看这个东西带给你的潜在价值。&lt;/p&gt;
&lt;p&gt;小时候，我特别羡慕别人家的摩托车，即便是到了大学的时候，我们家仍然穷得买不起摩托车，于是，每次放假回家，我都是从下了公共汽车的车站一路走回家的。&lt;/p&gt;
&lt;p&gt;我讨厌求别人搭顺风车的感觉，尤其是会遭到拒绝的时候。我就狠着心告诉自己，“劳资哪怕是走，都不要搭便车。”——特别有骨气，有没有？&lt;/p&gt;
&lt;p&gt;等我在苏州实习的时候，我特别羡慕那些苏州土著，一个月和我一样拿 1200 元的实习工资，却能开着好车上下班。我又暗下决心，“一定要拥有一辆自己的车！”&lt;/p&gt;
&lt;p&gt;买车是很多年轻人的一个梦，尤其是像我和小白这种从贫困的家庭走出来的年轻人。并不是说，买了车就实现了阶级跨越，不是的，而是它能够给我们一种心灵上的安抚，让我们变得自信，让我们敢对着操蛋的世界大喊一句，“去你大爷的，我也可以活得更好！”&lt;/p&gt;
&lt;p&gt;现如今的我，仍然是一个普普通通的程序员，每天敲着“改变世界”的代码，但我可以在洛阳这座城市扎根了，并且“车和房”都有了，靠的是自己。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我是沉默王二，一枚有颜值却假装靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，奥利给&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最近，有很多读者问我，有没有大厂的面经啊，时不时要打怪进阶一下？那问二哥就对了，微信搜索「&lt;strong&gt;沉默王二&lt;/strong&gt;」，回复「&lt;strong&gt;面试&lt;/strong&gt;」关键字就有三份我精心为你准备的刷题宝藏；本文 &lt;strong&gt;GitHub&lt;/strong&gt; &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;github.com/itwanger&lt;/a&gt; 已收录，欢迎 star。&lt;/p&gt;
</description>
<pubDate>Sun, 23 Aug 2020 00:04:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>先看再点赞，给自己一点思考的时间；欢迎微信搜索【沉默王二】关注这个有颜值却假装靠才华苟且的程序员。本文 GitHub github.com/itwanger 已收录，里面还有我精心准备的一线大厂面试题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/13548169.html</dc:identifier>
</item>
<item>
<title>精讲响应式WebClient第4篇-文件上传与下载 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13548155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13548155.html</guid>
<description>&lt;p&gt;本文是精讲响应式WebClient第4篇，前篇的blog访问地址如下：&lt;/p&gt;
&lt;p&gt;WebClient是从Spring 5开始提供的一个HTTP客户端库，为了使用WebClient进行文件上传和下载，需要我们先编写服务端的支持文件上传和下载的程序。请参考我之前写的一篇文章：&lt;a href=&quot;http://www.zimug.com/java/spring/springboot%e5%ae%9e%e7%8e%b0%e6%9c%ac%e5%9c%b0%e5%ad%98%e5%82%a8%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%e5%8f%8a%e6%8f%90%e4%be%9bhttp%e8%ae%bf%e9%97%ae%e6%9c%8d%e5%8a%a1/.html&quot;&gt;SpringBoot实现本地存储文件上传及提供HTTP访问服务&lt;/a&gt;。按照此文完成学习之后，可以获得&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个以访问服务URI为&quot;/upload”的文件上传服务端点&lt;/li&gt;
&lt;li&gt;服务端点上传文件成功后会返回一个HTTP连接,可以用来下载文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就开始学习使用WebClient是HTTP客户端库，进行文件的上传与下载。&lt;/p&gt;
&lt;h2 id=&quot;一、文件上传&quot;&gt;一、文件上传&lt;/h2&gt;
&lt;p&gt;在本地8888端口搭建了一个文件上传接收的服务端，服务端点为“/upload”。上传本地磁盘中的一个文件&quot;D:\data\local\splash.png&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootTest
class UpDownLoadTests {

   //创建webClient
   private WebClient webClient = WebClient.builder()
               .baseUrl(&quot;http://localhost:8888/&quot;)
               .build();

   @Test
   void testUpload()  {
      // 待上传的文件（存在客户端本地磁盘）
      String filePath = &quot;D:\\data\\local\\splash.png&quot;;
      // 封装请求参数
      FileSystemResource resource = new FileSystemResource(new File(filePath));
      MultiValueMap&amp;lt;String, Object&amp;gt; param = new LinkedMultiValueMap&amp;lt;&amp;gt;();
      param.add(&quot;uploadFile&quot;, resource);  //服务端MultipartFile uploadFile
      //param.add(&quot;param1&quot;, &quot;test&quot;);   //服务端如果接受额外参数，可以传递

      // 发送请求
      Mono&amp;lt;String&amp;gt; mono = webClient
                  .post() // POST 请求
                  .uri(&quot;/upload&quot;)  // 请求路径
                  .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                  .body(BodyInserters.fromMultipartData(param))
                  .retrieve() // 获取响应体
                  .bodyToMono(String.class); //响应数据类型转换

      // 输出结果
      System.out.println(mono.block());
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出打印结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200823073644675-686553157.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章上传之后返回一个HTTP URL访问地址，可以通过浏览器访问，也可以通过程序下载。&lt;/p&gt;
&lt;h2 id=&quot;二、文件下载&quot;&gt;二、文件下载&lt;/h2&gt;
&lt;p&gt;执行下列代码之后，被下载文件url，会被正确的保存到本地磁盘目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testDownLoad() throws IOException {
   Mono&amp;lt;ClientResponse&amp;gt; mono = webClient
               .get() // GET 请求
               .uri(&quot;/2020/08/22/0f0a353a-7033-4a13-832e-d043f6360514.png&quot;)  // 请求路径
               .accept(MediaType.APPLICATION_OCTET_STREAM)
               .exchange(); // 获取响应体

   ClientResponse response = mono.block();
   Resource resource = response.bodyToMono(Resource.class).block();

   assert resource != null;
   Files.copy(resource.getInputStream(),
            Paths.get(&quot;D:\\data\\local\\splash-down.png&quot; ));

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Aug 2020 23:37:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文是精讲响应式WebClient第4篇，前篇的blog访问地址如下： 精讲响应式webclient第1篇-响应式非阻塞IO与基础用法 精讲响应式WebClient第2篇-GET请求阻塞与非阻塞调用方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13548155.html</dc:identifier>
</item>
<item>
<title>学会反射后，我被录取了（干货） - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13548154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13548154.html</guid>
<description>&lt;p&gt;反射是一个非常重要的知识点，在学习&lt;code&gt;Spring 框架&lt;/code&gt;时，Bean的初始化用到了反射，在&lt;code&gt;破坏单例模式&lt;/code&gt;时也用到了反射，在&lt;code&gt;获取标注的注解&lt;/code&gt;时也会用到反射······&lt;/p&gt;
&lt;p&gt;当然了，反射在日常开发中，我们没碰到过多少，至少我没怎么用过。但面试是&lt;strong&gt;造火箭&lt;/strong&gt;现场，可爱的面试官们又怎会轻易地放过我们呢？反射是开源框架中的一个重要设计理念，在源码分析中少不了它的身影，所以，今天我会尽量用浅显易懂的语言，让你去理解下面这几点：&lt;/p&gt;
&lt;p&gt;（1）反射的思想以及它的作用​ 👉 &lt;strong&gt;概念篇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）反射的基本使用及应用场景 👉 &lt;strong&gt;应用篇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（3）使用反射能给我们编码时带来的优势以及存在的缺陷 👉 &lt;strong&gt;分析篇&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;反射的思想及作用&quot;&gt;反射的思想及作用&lt;/h2&gt;
&lt;p&gt;有反必有正，就像世间的阴和阳，计算机的0和1一样。天道有轮回，苍天...&lt;s&gt;（净会在这瞎bibi）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;在学习反射之前，先来了解&lt;strong&gt;正射&lt;/strong&gt;是什么。我们平常用的最多的 &lt;code&gt;new&lt;/code&gt; 方式实例化对象的方式就是一种正射的体现。假如我需要实例化一个&lt;code&gt;HashMap&lt;/code&gt;，代码就会是这样子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(1, 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;某一天发现，该段程序不适合用 HashMap 存储键值对，更倾向于用&lt;code&gt;LinkedHashMap&lt;/code&gt;存储。重新编写代码后变成下面这个样子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;Integer, Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;();
map.put(1, 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如又有一天，发现数据还是适合用 HashMap来存储，难道又要重新修改源码吗？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;发现问题了吗？我们每次改变一种需求，都要去重新&lt;strong&gt;修改源码&lt;/strong&gt;，然后对代码进行编译，打包，再到 JVM 上重启项目。这么些步骤下来，效率非常低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200823073714546-433564420.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这种&lt;strong&gt;需求频繁变更但变更不大&lt;/strong&gt;的场景，频繁地更改源码肯定是一种不允许的操作，我们可以使用一个&lt;code&gt;开关&lt;/code&gt;，判断什么时候使用哪一种数据结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Map&amp;lt;Integer, Integer&amp;gt; getMap(String param) {
    Map&amp;lt;Integer, Integer&amp;gt; map = null;
    if (param.equals(&quot;HashMap&quot;)) {
        map = new HashMap&amp;lt;&amp;gt;();
    } else if (param.equals(&quot;LinkedHashMap&quot;)) {
        map = new LinkedHashMap&amp;lt;&amp;gt;();
    } else if (param.equals(&quot;WeakHashMap&quot;)) {
        map = new WeakHashMap&amp;lt;&amp;gt;();
    }
    return map;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过传入参数&lt;code&gt;param&lt;/code&gt;决定使用哪一种数据结构，可以在项目运行时，通过&lt;strong&gt;动态传入参数&lt;/strong&gt;决定使用哪一个数据结构。&lt;/p&gt;
&lt;p&gt;如果某一天还想用&lt;code&gt;TreeMap&lt;/code&gt;，还是避免不了修改源码，重新编译执行的弊端。这个时候，&lt;strong&gt;反射&lt;/strong&gt;就派上用场了。&lt;/p&gt;
&lt;p&gt;在代码运行之前，我们&lt;strong&gt;不确定&lt;/strong&gt;将来会使用哪一种数据结构，只有在程序&lt;strong&gt;运行时才决定&lt;/strong&gt;使用哪一个数据类，而&lt;code&gt;反射&lt;/code&gt;可以在&lt;strong&gt;程序运行过程&lt;/strong&gt;中动态&lt;strong&gt;获取类信息&lt;/strong&gt;和&lt;strong&gt;调用类方法&lt;/strong&gt;。通过反射构造类实例，代码会演变成下面这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Map&amp;lt;Integer, Integer&amp;gt; getMap(String className) {
    Class clazz = Class.forName(className);
    Consructor con = clazz.getConstructor();
    return (Map&amp;lt;Integer, Integer&amp;gt;) con.newInstance();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论使用什么 Map，只要实现了&lt;code&gt;Map接口&lt;/code&gt;，就可以使用&lt;code&gt;全类名路径&lt;/code&gt;传入到方法中，获得对应的 Map 实例。例如java.util.HashMap / java.util.LinkedHashMap····如果要创建其它类例如&lt;code&gt;WeakHashMap&lt;/code&gt;，我也&lt;strong&gt;不需要修改上面这段源码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们来回顾一下如何从 &lt;code&gt;new&lt;/code&gt; 一个对象引出使用&lt;code&gt;反射&lt;/code&gt;的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在不使用反射时，构造对象使用 new 方式实现，这种方式在&lt;strong&gt;编译期&lt;/strong&gt;就可以把对象的类型确定下来。&lt;/li&gt;
&lt;li&gt;如果需求发生变更，需要构造另一个对象，则需要修改源码，非常不优雅，所以我们通过使用&lt;code&gt;开关&lt;/code&gt;，在程序运行时判断需要构造哪一个对象，在运行时可以&lt;strong&gt;变更开关&lt;/strong&gt;来实例化不同的数据结构。&lt;/li&gt;
&lt;li&gt;如果还有其它扩展的类有可能被使用，就会创建出&lt;strong&gt;非常多的分支&lt;/strong&gt;，且在编码时不知道有什么其他的类被使用到，假如日后&lt;code&gt;Map&lt;/code&gt;接口下多了一个集合类是&lt;code&gt;xxxHashMap&lt;/code&gt;，还得创建分支，此时引出了反射：可以在&lt;code&gt;运行时&lt;/code&gt;才确定使用哪一个数据类，在切换类时，无需重新修改源码、编译程序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一章总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;反射的&lt;strong&gt;思想&lt;/strong&gt;：&lt;strong&gt;在程序运行过程中确定和解析数据类的类型。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;反射的&lt;strong&gt;作用&lt;/strong&gt;：对于在&lt;code&gt;编译期&lt;/code&gt;无法确定使用哪个数据类的场景，通过&lt;code&gt;反射&lt;/code&gt;可以在程序运行时&lt;strong&gt;构造出不同的数据类实例&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;反射的基本使用&quot;&gt;反射的基本使用&lt;/h2&gt;
&lt;p&gt;Java 反射的主要组成部分有4个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Class&lt;/code&gt;：任何运行在内存中的所有类都是该 Class 类的实例对象，每个 Class 类对象内部都包含了本来的&lt;strong&gt;所有信息&lt;/strong&gt;。记着一句话，通过反射干任何事，先找 Class 准没错！&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Field&lt;/code&gt;：描述一个类的&lt;strong&gt;属性&lt;/strong&gt;，内部包含了该属性的所有信息，例如&lt;strong&gt;数据类型，属性名，访问修饰符&lt;/strong&gt;······&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Constructor&lt;/code&gt;：描述一个类的&lt;strong&gt;构造方法&lt;/strong&gt;，内部包含了构造方法的所有信息，例如&lt;strong&gt;参数类型，参数名字，访问修饰符&lt;/strong&gt;······&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Method&lt;/code&gt;：描述一个类的&lt;strong&gt;所有方法&lt;/strong&gt;（包括抽象方法），内部包含了该方法的所有信息，与&lt;code&gt;Constructor&lt;/code&gt;类似，不同之处是 Method 拥有&lt;strong&gt;返回值类型&lt;/strong&gt;信息，因为构造方法是没有返回值的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我总结了一张脑图，放在了下面，如果用到了反射，离不开这核心的&lt;code&gt;4&lt;/code&gt;个类，只有去了解它们内部提供了哪些信息，有什么作用，运用它们的时候才能&lt;strong&gt;易如反掌&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200823073725290-1236481635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在学习反射的基本使用时，我会用一个&lt;code&gt;SmallPineapple&lt;/code&gt;类作为模板进行说明，首先我们先来熟悉这个类的基本组成：&lt;strong&gt;属性，构造函数和方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SmallPineapple {
    public String name;
    public int age;
    private double weight; // 体重只有自己知道
        
    public SmallPineapple() {}
    
    public SmallPineapple(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public void getInfo() {
        System.out.print(&quot;[&quot;+ name + &quot; 的年龄是：&quot; + age + &quot;]&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反射中的用法有非常非常多，常见的功能有以下这几个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在运行时获取一个类的 &lt;strong&gt;Class 对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在运行时构造一个类的&lt;strong&gt;实例化对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在运行时获取一个类的所有信息：&lt;strong&gt;变量、方法、构造器、注解&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;获取类的-class-对象&quot;&gt;获取类的 Class 对象&lt;/h3&gt;
&lt;p&gt;在 Java 中，每一个类都会有专属于自己的 Class 对象，当我们编写完&lt;code&gt;.java&lt;/code&gt;文件后，使用&lt;code&gt;javac&lt;/code&gt;编译后，就会产生一个字节码文件&lt;code&gt;.class&lt;/code&gt;，在字节码文件中包含类的所有信息，如&lt;code&gt;属性&lt;/code&gt;，&lt;code&gt;构造方法&lt;/code&gt;，&lt;code&gt;方法&lt;/code&gt;······当字节码文件被装载进虚拟机执行时，会在内存中生成 Class 对象，它包含了该类内部的所有信息，在程序运行时可以获取这些信息。&lt;/p&gt;
&lt;p&gt;获取 Class 对象的方法有&lt;code&gt;3&lt;/code&gt;种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;类名.class&lt;/code&gt;：这种获取方式只有在&lt;code&gt;编译&lt;/code&gt;前已经声明了该类的类型才能获取到 Class 对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = SmallPineapple.class;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;实例.getClass()&lt;/code&gt;：通过实例化对象获取该实例的 Class 对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SmallPineapple sp = new SmallPineapple();
Class clazz = sp.getClass();
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Class.forName(className)&lt;/code&gt;：通过类的&lt;strong&gt;全限定名&lt;/strong&gt;获取该类的 Class 对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.smallpineapple&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到 &lt;code&gt;Class&lt;/code&gt;对象就可以对它为所欲为了：剥开它的皮（获取&lt;strong&gt;类信息&lt;/strong&gt;）、指挥它做事（调用它的&lt;strong&gt;方法&lt;/strong&gt;），看透它的一切（获取&lt;strong&gt;属性&lt;/strong&gt;），总之它就没有隐私了。&lt;/p&gt;
&lt;p&gt;不过在程序中，每个类的 Class 对象只有一个，也就是说你只有这一个&lt;code&gt;奴隶&lt;/code&gt;。我们用上面三种方式测试，通过三种方式打印各个 &lt;code&gt;Class&lt;/code&gt; 对象都是相同的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz1 = Class.forName(&quot;com.bean.SmallPineapple&quot;);
Class clazz2 = SmallPineapple.class;
SmallPineapple instance = new SmallPineapple();
Class clazz3 = instance.getClass();
System.out.println(&quot;Class.forName() == SmallPineapple.class:&quot; + (clazz1 == clazz2));
System.out.println(&quot;Class.forName() == instance.getClass():&quot; + (clazz1 == clazz3));
System.out.println(&quot;instance.getClass() == SmallPineapple.class:&quot; + (clazz2 == clazz3));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200823073813937-841548643.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;内存中只有一个 Class 对象的原因要牵扯到 &lt;code&gt;JVM 类加载机制&lt;/code&gt;的&lt;code&gt;双亲委派模型&lt;/code&gt;，它保证了程序运行时，&lt;code&gt;加载类&lt;/code&gt;时每个类在内存中仅会产生一个&lt;code&gt;Class对象&lt;/code&gt;。在这里我不打算详细展开说明，可以简单地理解为 JVM 帮我们保证了&lt;strong&gt;一个类在内存中至多存在一个 Class 对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;构造类的实例化对象&quot;&gt;构造类的实例化对象&lt;/h3&gt;
&lt;p&gt;通过反射构造一个类的实例方式有&lt;code&gt;2&lt;/code&gt;种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class 对象调用&lt;code&gt;newInstance()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);
SmallPineapple smallPineapple = (SmallPineapple) clazz.newInstance();
smallPineapple.getInfo();
// [null 的年龄是：0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即使 SmallPineapple 已经显式定义了构造方法，通过 newInstance() 创建的实例中，所有属性值都是对应类型的&lt;code&gt;初始值&lt;/code&gt;，因为 newInstance() 构造实例会&lt;strong&gt;调用默认无参构造器&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Constructor 构造器调用&lt;code&gt;newInstance()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);
Constructor constructor = clazz.getConstructor(String.class, int.class);
constructor.setAccessible(true);
SmallPineapple smallPineapple2 = (SmallPineapple) constructor.newInstance(&quot;小菠萝&quot;, 21);
smallPineapple2.getInfo();
// [小菠萝 的年龄是：21]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 getConstructor(Object... paramTypes) 方法指定获取&lt;strong&gt;指定参数类型&lt;/strong&gt;的 Constructor， Constructor 调用 newInstance(Object... paramValues) 时传入构造方法参数的值，同样可以构造一个实例，且内部属性已经被赋值。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;Class&lt;/code&gt;对象调用 newInstance() 会走&lt;strong&gt;默认无参构造方法&lt;/strong&gt;，如果想通过&lt;strong&gt;显式构造方法&lt;/strong&gt;构造实例，需要提前从Class中调用&lt;code&gt;getConstructor()&lt;/code&gt;方法获取对应的构造器，通过构造器去实例化对象。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这些 API 是在开发当中最常遇到的，当然还有非常多重载的方法，本文由于篇幅原因，且如果每个方法都一一讲解，我们也记不住，所以用到的时候去类里面查找就已经足够了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;获取一个类的所有信息&quot;&gt;获取一个类的所有信息&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Class 对象中包含了该类的所有信息，在编译期我们能看到的信息就是该类的变量、方法、构造器，在运行时最常被获取的也是这些信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200823073824708-1083666453.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取类中的变量（field）&quot;&gt;获取类中的变量（Field）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Field[] getFields()：获取类中所有被&lt;code&gt;public&lt;/code&gt;修饰的所有变量&lt;/li&gt;
&lt;li&gt;Field getField(String name)：根据&lt;strong&gt;变量名&lt;/strong&gt;获取类中的一个变量，该&lt;strong&gt;变量必须被public修饰&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Field[] getDeclaredFields()：获取类中所有的变量，但&lt;strong&gt;无法获取继承下来的变量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Field getDeclaredField(String name)：根据姓名获取类中的某个变量，&lt;strong&gt;无法获取继承下来的变量&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;获取类中的方法（method）&quot;&gt;获取类中的方法（Method）&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Method[] getMethods()：获取类中被&lt;code&gt;public&lt;/code&gt;修饰的所有方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Method getMethod(String name, Class...&amp;lt;?&amp;gt; paramTypes)：根据&lt;strong&gt;名字和参数类型&lt;/strong&gt;获取对应方法，该方法必须被&lt;code&gt;public&lt;/code&gt;修饰&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Method[] getDeclaredMethods()：获取&lt;code&gt;所有&lt;/code&gt;方法，但&lt;strong&gt;无法获取继承下来的方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Method getDeclaredMethod(String name, Class...&amp;lt;?&amp;gt; paramTypes)：根据&lt;strong&gt;名字和参数类型&lt;/strong&gt;获取对应方法，&lt;strong&gt;无法获取继承下来的方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;获取类的构造器（constructor）&quot;&gt;获取类的构造器（Constructor）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Constuctor[] getConstructors()：获取类中所有被&lt;code&gt;public&lt;/code&gt;修饰的构造器&lt;/li&gt;
&lt;li&gt;Constructor getConstructor(Class...&amp;lt;?&amp;gt; paramTypes)：根据&lt;code&gt;参数类型&lt;/code&gt;获取类中某个构造器，该构造器必须被&lt;code&gt;public&lt;/code&gt;修饰&lt;/li&gt;
&lt;li&gt;Constructor[] getDeclaredConstructors()：获取类中所有构造器&lt;/li&gt;
&lt;li&gt;Constructor getDeclaredConstructor(class...&amp;lt;?&amp;gt; paramTypes)：根据&lt;code&gt;参数类型&lt;/code&gt;获取对应的构造器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每种功能内部以 Declared 细分为&lt;code&gt;2&lt;/code&gt;类：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;有&lt;code&gt;Declared&lt;/code&gt;修饰的方法：可以获取该类内部包含的&lt;strong&gt;所有&lt;/strong&gt;变量、方法和构造器，但是&lt;strong&gt;无法获取继承下来的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无&lt;code&gt;Declared&lt;/code&gt;修饰的方法：可以获取该类中&lt;code&gt;public&lt;/code&gt;修饰的变量、方法和构造器，可&lt;strong&gt;获取继承下来的信息&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想获取类中&lt;strong&gt;所有的（包括继承）&lt;/strong&gt;变量、方法和构造器，则需要同时调用&lt;code&gt;getXXXs()&lt;/code&gt;和&lt;code&gt;getDeclaredXXXs()&lt;/code&gt;两个方法，用&lt;code&gt;Set&lt;/code&gt;集合存储它们获得的变量、构造器和方法，以防两个方法获取到相同的东西。&lt;/p&gt;
&lt;p&gt;例如：要获取SmallPineapple获取类中&lt;strong&gt;所有的变量&lt;/strong&gt;，代码应该是下面这样写。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);
// 获取 public 属性，包括继承
Field[] fields1 = clazz.getFields();
// 获取所有属性，不包括继承
Field[] fields2 = clazz.getDeclaredFields();
// 将所有属性汇总到 set
Set&amp;lt;Field&amp;gt; allFields = new HashSet&amp;lt;&amp;gt;();
allFields.addAll(Arrays.asList(fields1));
allFields.addAll(Arrays.asList(fields2));
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;不知道你有没有发现一件&lt;strong&gt;有趣的事情&lt;/strong&gt;，如果父类的属性用&lt;code&gt;protected&lt;/code&gt;修饰，利用反射是&lt;strong&gt;无法获取到&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;protected 修饰符的作用范围：只允许&lt;code&gt;同一个包下&lt;/code&gt;或者&lt;code&gt;子类&lt;/code&gt;访问，可以继承到子类。&lt;/p&gt;
&lt;p&gt;getFields() 只能获取到本类的&lt;code&gt;public&lt;/code&gt;属性的变量值；&lt;/p&gt;
&lt;p&gt;getDeclaredFields() 只能获取到&lt;strong&gt;本类的所有属性，不包括继承&lt;/strong&gt;的；无论如何都获取不到父类的 protected 属性修饰的变量，但是它的的确确存在于子类中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;获取注解&quot;&gt;获取注解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;获取注解单独拧了出来，因为它并不是专属于 Class 对象的一种信息，每个变量，方法和构造器都可以被注解修饰，所以在反射中，Field，Constructor 和 Method 类对象都可以调用下面这些方法获取标注在它们之上的注解。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Annotation[] getAnnotations()：获取该对象上的&lt;strong&gt;所有注解&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Annotation getAnnotation(Class annotaionClass)：传入&lt;code&gt;注解类型&lt;/code&gt;，获取该对象上的特定一个注解&lt;/li&gt;
&lt;li&gt;Annotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取&lt;code&gt;继承&lt;/code&gt;下来的注解&lt;/li&gt;
&lt;li&gt;Annotation getDeclaredAnnotation(Class annotationClass)：根据&lt;code&gt;注解类型&lt;/code&gt;，获取该对象上的特定一个注解，无法获取&lt;code&gt;继承&lt;/code&gt;下来的注解&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有注解的&lt;code&gt;@Retension&lt;/code&gt;标注为&lt;code&gt;RUNTIME&lt;/code&gt;时，才能够通过反射获取到该注解，@Retension 有&lt;code&gt;3&lt;/code&gt;种保存策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SOURCE&lt;/code&gt;：只在&lt;strong&gt;源文件(.java)&lt;/strong&gt;中保存，即该注解只会保留在源文件中，&lt;strong&gt;编译时编译器会忽略该注解&lt;/strong&gt;，例如 @Override 注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CLASS&lt;/code&gt;：保存在&lt;strong&gt;字节码文件(.class)&lt;/strong&gt;中，注解会随着编译跟随字节码文件中，但是&lt;strong&gt;运行时&lt;/strong&gt;不会对该注解进行解析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUNTIME&lt;/code&gt;：一直保存到&lt;strong&gt;运行时&lt;/strong&gt;，&lt;strong&gt;用得最多的一种保存策略&lt;/strong&gt;，在运行时可以获取到该注解的所有信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;像下面这个例子，SmallPineapple 类继承了抽象类&lt;code&gt;Pineapple&lt;/code&gt;，&lt;code&gt;getInfo()&lt;/code&gt;方法上标识有 @Override 注解，且在子类中标注了&lt;code&gt;@Transient&lt;/code&gt;注解，在运行时获取子类重写方法上的所有注解，只能获取到&lt;code&gt;@Transient&lt;/code&gt;的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Pineapple {
    public abstract void getInfo();
}
public class SmallPineapple extends Pineapple {
    @Transient
    @Override
    public void getInfo() {
        System.out.print(&quot;小菠萝的身高和年龄是:&quot; + height + &quot;cm ; &quot; + age + &quot;岁&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动类&lt;code&gt;Bootstrap&lt;/code&gt;获取 SmallPineapple 类中的 getInfo() 方法上的注解信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Bootstrap {
    /**
     * 根据运行时传入的全类名路径判断具体的类对象
     * @param path 类的全类名路径
     */
    public static void execute(String path) throws Exception {
        Class obj = Class.forName(path);
        Method method = obj.getMethod(&quot;getInfo&quot;);
        Annotation[] annotations = method.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println(annotation.toString());
        }
    }
    public static void main(String[] args) throws Exception {
        execute(&quot;com.pineapple.SmallPineapple&quot;);
    }
}
// @java.beans.Transient(value=true)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过反射调用方法&quot;&gt;通过反射调用方法&lt;/h3&gt;
&lt;p&gt;通过反射获取到某个 Method 类对象后，可以通过调用&lt;code&gt;invoke&lt;/code&gt;方法执行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;invoke(Oject obj, Object... args)&lt;/code&gt;：参数``1&lt;code&gt;指定调用该方法的**对象**，参数&lt;/code&gt;2`是方法的参数列表值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果调用的方法是&lt;strong&gt;静态方法&lt;/strong&gt;，参数1只需要传入&lt;code&gt;null&lt;/code&gt;，因为静态方法不与某个对象有关，只与某个类有关。&lt;/p&gt;
&lt;p&gt;可以像下面这种做法，通过反射实例化一个对象，然后获取&lt;code&gt;Method&lt;/code&gt;方法对象，调用&lt;code&gt;invoke()&lt;/code&gt;指定&lt;code&gt;SmallPineapple&lt;/code&gt;的&lt;code&gt;getInfo()&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);
Constructor constructor = clazz.getConstructor(String.class, int.class);
constructor.setAccessible(true);
SmallPineapple sp = (SmallPineapple) constructor.newInstance(&quot;小菠萝&quot;, 21);
Method method = clazz.getMethod(&quot;getInfo&quot;);
if (method != null) {
    method.invoke(sp, null);
}
// [小菠萝的年龄是：21]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;反射的应用场景&quot;&gt;反射的应用场景&lt;/h2&gt;
&lt;p&gt;反射常见的应用场景这里介绍&lt;code&gt;3&lt;/code&gt;个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring 实例化对象：当程序启动时，Spring 会读取配置文件&lt;code&gt;applicationContext.xml&lt;/code&gt;并解析出里面所有的 标签实例化到&lt;code&gt;IOC&lt;/code&gt;容器中。&lt;/li&gt;
&lt;li&gt;反射 + 工厂模式：通过&lt;code&gt;反射&lt;/code&gt;消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，&lt;code&gt;反射&lt;/code&gt;可以使得程序更加健壮。&lt;/li&gt;
&lt;li&gt;JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的&lt;code&gt;驱动类&lt;/code&gt;时用到反射加载驱动类&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;spring-的-ioc-容器&quot;&gt;Spring 的 IOC 容器&lt;/h3&gt;
&lt;p&gt;在 Spring 中，经常会编写一个上下文配置文件&lt;code&gt;applicationContext.xml&lt;/code&gt;，里面就是关于&lt;code&gt;bean&lt;/code&gt;的配置，程序启动时会读取该 xml 文件，解析出所有的 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;标签，并实例化对象放入&lt;code&gt;IOC&lt;/code&gt;容器中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;smallpineapple&quot; class=&quot;com.bean.SmallPineapple&quot;&amp;gt;
        &amp;lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;小菠萝&quot;/&amp;gt;
        &amp;lt;constructor-arg type=&quot;int&quot; value=&quot;21&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在定义好上面的文件后，通过&lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;加载该配置文件，程序启动时，Spring 会将该配置文件中的所有&lt;code&gt;bean&lt;/code&gt;都实例化，放入 IOC 容器中，IOC 容器本质上就是一个工厂，通过该工厂传入 &amp;lt;bean&amp;gt; 标签的&lt;code&gt;id&lt;/code&gt;属性获取到对应的实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {
    public static void main(String[] args) {
        ApplicationContext ac =
                new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        SmallPineapple smallPineapple = (SmallPineapple) ac.getBean(&quot;smallpineapple&quot;);
        smallPineapple.getInfo(); // [小菠萝的年龄是：21]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring 在实例化对象的过程经过简化之后，可以理解为反射实例化对象的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;获取Class对象的构造器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过构造器&lt;strong&gt;调用 newInstance()&lt;/strong&gt; 实例化对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然 Spring 在实例化对象时，做了非常多额外的操作，才能够让现在的开发足够的&lt;strong&gt;便捷且稳定&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在之后的文章中会专门写一篇文章讲解如何利用反射实现一个&lt;code&gt;简易版&lt;/code&gt;的&lt;code&gt;IOC&lt;/code&gt;容器，IOC容器原理很简单，只要掌握了反射的思想，了解反射的常用 API 就可以实现，我可以提供一个简单的思路：利用 HashMap 存储所有实例，key 代表 &amp;lt;bean&amp;gt; 标签的 &lt;code&gt;id&lt;/code&gt;，value 存储对应的实例，这对应了 Spring IOC容器管理的对象默认是&lt;strong&gt;单例&lt;/strong&gt;的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;反射--抽象工厂模式&quot;&gt;反射 + 抽象工厂模式&lt;/h3&gt;
&lt;p&gt;传统的工厂模式，如果需要生产新的子类，&lt;strong&gt;需要修改工厂类，在工厂类中增加新的分支&lt;/strong&gt;；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MapFactory {
    public Map&amp;lt;Object, object&amp;gt; produceMap(String name) {
        if (&quot;HashMap&quot;.equals(name)) {
            return new HashMap&amp;lt;&amp;gt;();
        } else if (&quot;TreeMap&quot;.equals(name)) {
            return new TreeMap&amp;lt;&amp;gt;();
        } // ···
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用反射和工厂模式相结合，在产生新的子类时，&lt;strong&gt;工厂类不用修改任何东西&lt;/strong&gt;，可以专注于子类的实现，&lt;strong&gt;当子类确定下来时，工厂也就可以生产该子类了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反射 + 抽象工厂的&lt;strong&gt;核心思想&lt;/strong&gt;是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在运行时通过参数传入不同子类的全限定名获取到不同的 Class 对象，调用 newInstance() 方法返回不同的子类。&lt;/strong&gt;细心的读者会发现提到了&lt;strong&gt;子类&lt;/strong&gt;这个概念，所以反射 + 抽象工厂模式，一般会用于有&lt;strong&gt;继承&lt;/strong&gt;或者&lt;strong&gt;接口实现&lt;/strong&gt;关系。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，在运行时才确定使用哪一种 &lt;code&gt;Map&lt;/code&gt; 结构，我们可以利用反射传入某个具体 Map 的全限定名，实例化一个特定的子类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MapFactory {
    /**
     * @param className 类的全限定名
     */
    public Map&amp;lt;Object, Object&amp;gt; produceMap(String className) {
        Class clazz = Class.forName(className);
        Map&amp;lt;Object, Object&amp;gt; map = clazz.newInstance();
        return map;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;className&lt;/code&gt; 可以指定为 java.util.HashMap，或者 java.util.TreeMap 等等，根据业务场景来定。&lt;/p&gt;
&lt;h3 id=&quot;jdbc-加载数据库驱动类&quot;&gt;JDBC 加载数据库驱动类&lt;/h3&gt;
&lt;p&gt;在导入第三方库时，JVM不会主动去加载外部导入的类，而是&lt;strong&gt;等到真正使用时，才去加载需要的类&lt;/strong&gt;，正是如此，我们可以在获取数据库连接时传入驱动类的全限定名，交给 JVM 加载该类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DBConnectionUtil {
    /** 指定数据库的驱动类 */
    private static final String DRIVER_CLASS_NAME = &quot;com.mysql.jdbc.Driver&quot;;
    
    public static Connection getConnection() {
        Connection conn = null;
        // 加载驱动类
        Class.forName(DRIVER_CLASS_NAME);
        // 获取数据库连接对象
        conn = DriverManager.getConnection(&quot;jdbc:mysql://···&quot;, &quot;root&quot;, &quot;root&quot;);
        return conn;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们开发 SpringBoot 项目时，会经常遇到这个类，但是可能习惯成自然了，就没多大在乎，我在这里给你们看看常见的&lt;code&gt;application.yml&lt;/code&gt;中的数据库配置，我想你应该会恍然大悟吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200823073839646-876887976.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的 &lt;strong&gt;driver-class-name&lt;/strong&gt;，和我们一开始加载的类是不是觉得很相似，这是因为&lt;strong&gt;MySQL&lt;/strong&gt;版本不同引起的&lt;strong&gt;驱动类不同&lt;/strong&gt;，这体现使用反射的好处：不需要修改源码，&lt;strong&gt;仅加载配置文件就可以完成驱动类的替换&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;在之后的文章中会专门写一篇文章详细地介绍反射的应用场景，实现简单的&lt;code&gt;IOC&lt;/code&gt;容器以及通过反射实现工厂模式的好处。&lt;/p&gt;
&lt;p&gt;在这里，你只需要掌握反射的基本用法和它的思想，了解它的主要使用场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;反射的优势及缺陷&quot;&gt;反射的优势及缺陷&lt;/h2&gt;
&lt;p&gt;反射的&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;增加程序的灵活性&lt;/strong&gt;：面对需求变更时，可以灵活地实例化不同对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，有得必有失，一项技术不可能只有优点没有缺点，反射也有&lt;strong&gt;两个比较隐晦的缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;破坏类的封装性&lt;/strong&gt;：可以强制访问 private 修饰的信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能损耗&lt;/strong&gt;：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的&lt;strong&gt;检查步骤和解析步骤&lt;/strong&gt;，JVM无法对它们优化。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;增加程序的灵活性&quot;&gt;增加程序的灵活性&lt;/h3&gt;
&lt;p&gt;这里不再用 SmallPineapple 举例了，我们来看一个更加&lt;code&gt;贴近开发&lt;/code&gt;的例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用反射连接数据库，&lt;strong&gt;涉及到数据库的数据源&lt;/strong&gt;。在 SpringBoot 中一切约定大于配置，想要&lt;strong&gt;定制配置&lt;/strong&gt;时，使用&lt;code&gt;application.properties&lt;/code&gt;配置文件指定数据源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;角色1 - Java的设计者&lt;/strong&gt;：我们设计好&lt;code&gt;DataSource&lt;/code&gt;接口，你们其它数据库厂商想要开发者用&lt;code&gt;你们的数据源&lt;/code&gt;监控数据库，就得实现&lt;code&gt;我的这个接口&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;角色2 - 数据库厂商&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MySQL 数据库厂商：我们提供了 &lt;strong&gt;com.mysql.cj.jdbc.MysqlDataSource&lt;/strong&gt; 数据源，开发者可以使用它连接 MySQL。&lt;/li&gt;
&lt;li&gt;阿里巴巴厂商：我们提供了 &lt;strong&gt;com.alibaba.druid.pool.DruidDataSource&lt;/strong&gt; 数据源，我这个数据源更牛逼，具有&lt;strong&gt;页面监控&lt;/strong&gt;，&lt;strong&gt;慢SQL日志记录&lt;/strong&gt;等功能，开发者快来用它监控 MySQL吧！&lt;/li&gt;
&lt;li&gt;SQLServer 厂商：我们提供了 &lt;strong&gt;com.microsoft.sqlserver.jdbc.SQLServerDataSource&lt;/strong&gt; 数据源，如果你想实用SQL Server 作为数据库，那就使用我们的这个数据源连接吧&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;角色3 - 开发者&lt;/strong&gt;：我们可以用&lt;code&gt;配置文件&lt;/code&gt;指定使用&lt;code&gt;DruidDataSource&lt;/code&gt;数据源&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;需求变更&lt;/strong&gt;：某一天，老板来跟我们说，Druid 数据源不太符合我们现在的项目了，我们使用 &lt;strong&gt;MysqlDataSource&lt;/strong&gt; 吧，然后程序猿就会修改配置文件，重新加载配置文件，并重启项目，完成数据源的切换。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;spring.datasource.type=com.mysql.cj.jdbc.MysqlDataSource
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在改变连接数据库的数据源时，只需要改变配置文件即可，&lt;strong&gt;无需改变任何代码&lt;/strong&gt;，原因是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Spring Boot 底层封装好了连接数据库的数据源配置，利用反射，适配各个数据源。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面来简略的进行源码分析。我们用&lt;code&gt;ctrl+左键&lt;/code&gt;点击&lt;code&gt;spring.datasource.type&lt;/code&gt;进入 DataSourceProperties 类中，发现使用setType() 将&lt;strong&gt;全类名转化为 Class 对象&lt;/strong&gt;注入到&lt;code&gt;type&lt;/code&gt;成员变量当中。在连接并监控数据库时，就会使用指定的数据源操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Class&amp;lt;? extends DataSource&amp;gt; type;

public void setType(Class&amp;lt;? extends DataSource&amp;gt; type) {
    this.type = type;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Class&lt;/code&gt;对象指定了泛型上界&lt;code&gt;DataSource&lt;/code&gt;，我们去看一下各大数据源的&lt;code&gt;类图结构&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1694029/1596689119592-98ae06fd-c59e-4794-8130-ff0bdfe0f550.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上图展示了一部分数据源，当然不止这些，但是我们可以看到，无论指定使用哪一种数据源，我们都只需要与配置文件打交道，而无需更改源码，这就是反射的灵活性！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;破坏类的封装性&quot;&gt;破坏类的封装性&lt;/h3&gt;
&lt;p&gt;很明显的一个特点，反射可以获取类中被&lt;code&gt;private&lt;/code&gt;修饰的变量、方法和构造器，这&lt;strong&gt;违反了面向对象的封装特性&lt;/strong&gt;，因为被 private 修饰意味着不想对外暴露，只允许本类访问，而&lt;code&gt;setAccessable(true)&lt;/code&gt;可以无视访问修饰符的限制，外界可以强制访问。&lt;/p&gt;
&lt;p&gt;还记得&lt;code&gt;单例模式&lt;/code&gt;一文吗？里面讲到反射破坏饿汉式和懒汉式单例模式，所以之后用了&lt;code&gt;枚举&lt;/code&gt;避免被反射KO。&lt;/p&gt;
&lt;p&gt;回到最初的起点，SmallPineapple 里有一个 weight 属性被 private 修饰符修饰，目的在于自己的体重并不想给外界知道。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SmallPineapple {
    public String name;
    public int age;
    private double weight; // 体重只有自己知道
    
    public SmallPineapple(String name, int age, double weight) {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然 weight 属性理论上只有自己知道，但是如果经过反射，这个类就像在&lt;strong&gt;裸奔&lt;/strong&gt;一样，在反射面前变得&lt;code&gt;一览无遗&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SmallPineapple sp = new SmallPineapple(&quot;小菠萝&quot;, 21, &quot;54.5&quot;);
Clazz clazz = Class.forName(sp.getClass());
Field weight = clazz.getDeclaredField(&quot;weight&quot;);
weight.setAccessable(true);
System.out.println(&quot;窥觑到小菠萝的体重是：&quot; + weight.get(sp));
// 窥觑到小菠萝的体重是：54.5 kg
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;性能损耗&quot;&gt;性能损耗&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在直接 new 对象并调用对象方法和访问属性时，编译器会在编译期提前检查可访问性，如果尝试进行不正确的访问，IDE会提前提示错误，例如参数传递类型不匹配，非法访问 private 属性和方法。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;而在利用反射操作对象时，编译器无法提前得知对象的类型，访问是否合法，参数传递类型是否匹配。只有在程序运行时调用反射的代码时才会从头开始检查、调用、返回结果，JVM也无法对反射的代码进行优化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然反射具有性能损耗的特点，但是我们不能一概而论，产生了使用反射就会性能下降的思想，反射的慢，需要同时调用上&lt;code&gt;100W&lt;/code&gt;次才可能体现出来，在几次、几十次的调用，并不能体现反射的性能低下。所以不要一味地戴有色眼镜看反射，&lt;strong&gt;在单次调用反射的过程中，性能损耗可以忽略不计。如果程序的性能要求很高，那么尽量不要使用反射。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;反射基础篇文末总结&quot;&gt;反射基础篇文末总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;反射的思想：反射就像是&lt;strong&gt;一面镜子&lt;/strong&gt;一样，在&lt;strong&gt;运行时&lt;/strong&gt;才看到自己是谁，可获取到自己的信息，甚至实例化对象。&lt;/li&gt;
&lt;li&gt;反射的作用：&lt;strong&gt;在运行时才确定实例化对象，使程序更加健壮&lt;/strong&gt;，面对需求变更时，可以最大程度地做到不修改程序源码应对不同的场景，实例化不同类型的对象。&lt;/li&gt;
&lt;li&gt;反射的应用场景常见的有&lt;code&gt;3&lt;/code&gt;个：Spring的 IOC 容器，反射+工厂模式 使工厂类更稳定，JDBC连接数据库时加载驱动类&lt;/li&gt;
&lt;li&gt;反射的&lt;code&gt;3&lt;/code&gt;个特点：增加程序的灵活性、破坏类的封装性以及性能损耗&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你好，我是 cxuan，我自己手写了四本 PDF，分别是 Java基础总结、HTTP 核心总结、计算机基础知识，操作系统核心总结，我已经整理成为 PDF，可以关注公众号 Java建设者 回复 PDF 领取优质资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200823073456818-1148579206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Aug 2020 23:36:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>反射是一个非常重要的知识点，在学习Spring 框架时，Bean的初始化用到了反射，在破坏单例模式时也用到了反射，在获取标注的注解时也会用到反射&amp;amp;#183;&amp;amp;#183;&amp;amp;#18</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13548154.html</dc:identifier>
</item>
<item>
<title>小白学PyTorch 动态图与静态图的浅显理解 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13548104.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13548104.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文章来自公众号【机器学习炼丹术】，回复“炼丹”即可获得海量学习资料哦！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本章节缕一缕PyTorch的动态图机制与Tensorflow的静态图机制（最新版的TF也支持动态图了似乎）。&lt;/p&gt;
&lt;h2 id=&quot;1-动态图的初步推导&quot;&gt;1 动态图的初步推导&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;计算图是用来描述运算的&lt;strong&gt;有向无环图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;计算图有两个主要元素：结点（Node）和边（Edge）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结点表示数据&lt;/strong&gt; ，如向量、矩阵、张量;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;边表示运算&lt;/strong&gt; ，如加减乘除卷积等；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d00f62e95260466ea34455acc7ce98d3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是用计算图表示：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(y=(x+w)∗(w+1)y=(x+w)∗(w+1)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中呢，&lt;span class=&quot;math inline&quot;&gt;\(a=x+w\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(b=w+1\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(y=a∗b\)&lt;/span&gt;. (a和b是类似于中间变量的那种感觉。)&lt;/p&gt;
&lt;p&gt;Pytorch在计算的时候，就会把计算过程用上面那样的动态图存储起来。现在我们计算一下y关于w的梯度：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial y}{\partial w} = \frac{\partial y}{\partial a} \frac{\partial a}{\partial w} + \frac{\partial y}{\partial b} \frac{\partial b}{\partial w}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(=2\times w + x + 1=5\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（上面的计算中，w=1，x=2）&lt;/p&gt;
&lt;p&gt;现在我们用Pytorch的代码来实现这个过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import torch
w = torch.tensor([1.],requires_grad = True)
x = torch.tensor([2.],requires_grad = True)

a = w+x
b = w+1
y = a*b

y.backward()
print(w.grad)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的结果：&lt;br/&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4db29e2ac17a4021a4f05ffff090283a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-动态图的叶子节点&quot;&gt;2 动态图的叶子节点&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d00f62e95260466ea34455acc7ce98d3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图中的叶子节点，是w和x，是整个计算图的根基。之所以用叶子节点的概念，是为了&lt;strong&gt;减少内存，在反向传播结束之后，非叶子节点的梯度会被释放掉&lt;/strong&gt; ， 我们依然用上面的例子解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import torch
w = torch.tensor([1.],requires_grad = True)
x = torch.tensor([2.],requires_grad = True)

a = w+x
b = w+1
y = a*b

y.backward()
print(w.is_leaf,x.is_leaf,a.is_leaf,b.is_leaf,y.is_leaf)
print(w.grad,x.grad,a.grad,b.grad,y.grad)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果是：&lt;br/&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3a35fe92aa470abea0dfaa55de7655~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到只有x和w是叶子节点，然后反向传播计算完梯度后（&lt;code&gt;.backward()&lt;/code&gt;之后），只有叶子节点的梯度保存下来了。&lt;/p&gt;
&lt;p&gt;当然也可以通过&lt;code&gt;.retain_grad()&lt;/code&gt;来保留非任意节点的梯度值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import torch
w = torch.tensor([1.],requires_grad = True)
x = torch.tensor([2.],requires_grad = True)

a = w+x
a.retain_grad()
b = w+1
y = a*b

y.backward()
print(w.is_leaf,x.is_leaf,a.is_leaf,b.is_leaf,y.is_leaf)
print(w.grad,x.grad,a.grad,b.grad,y.grad)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5db408ab4b664a8fa2e858c0a13e8b76~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-grad_fn&quot;&gt;3. grad_fn&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;torch.tensor&lt;/code&gt;有一个属性&lt;code&gt;grad_fn&lt;/code&gt;,&lt;code&gt;grad_fn&lt;/code&gt;的作用是记录创建该张量时所用的函数，这个属性反向传播的时候会用到。例如在上面的例子中，&lt;code&gt;y.grad_fn=MulBackward0&lt;/code&gt;,表示y是通过乘法得到的。所以求导的时候就是用乘法的求导法则。同样的，&lt;code&gt;a.grad=AddBackward0&lt;/code&gt;表示a是通过加法得到的，使用加法的求导法则。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import torch
w = torch.tensor([1.],requires_grad = True)
x = torch.tensor([2.],requires_grad = True)

a = w+x
a.retain_grad()
b = w+1
y = a*b

y.backward()
print(y.grad_fn)
print(a.grad_fn)
print(w.grad_fn)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果是：&lt;br/&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cb18da096ab4a2d951330b117daf205~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;叶子节点的&lt;code&gt;.grad_fn&lt;/code&gt;是None。&lt;/p&gt;
&lt;h2 id=&quot;4-静态图&quot;&gt;4 静态图&lt;/h2&gt;
&lt;p&gt;两者的区别用一句话概括就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;动态图：pytorch使用的，运算与搭建同时进行；灵活，易调节。&lt;/li&gt;
&lt;li&gt;静态图：老tensorflow使用的，先搭建图，后运算；高效，不灵活。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;静态图我们是需要先定义好运算规则流程的。比方说，我们先给出&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(a = x+w\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(b=w+1\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(y=a\times b\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后把上面的运算流程存储下来，然后把w=1，x=2放到上面运算框架的入口位置进行运算。而动态图是直接对着已经赋值的w和x进行运算，然后变运算变构建运算图。&lt;/p&gt;
&lt;p&gt;在一个课程http://cs231n.stanford.edu/slides/2018/cs231n_2018_lecture08.pdf中的第125页，有这样的一个对比例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6382a7f3cba2491090c858fc6902f346~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个代码是Tensorflow的，构建运算的时候，先构建运算框架，然后再把具体的数字放入其中。整个过程类似于训练神经网络，我们要构建好模型的结构，然后再训练的时候再吧数据放到模型里面去。又类似于在旅游的时候，我们事先定要每天的行程路线，然后每天按照路线去行动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/994c5368ed5a43c09fbd70e680792ce9~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;动态图呢，就是直接对数据进行运算，然后动态的构建出运算图。很符合我们的运算习惯。&lt;/p&gt;
&lt;p&gt;两者的区别在于，静态图先说明数据要怎么计算，然后再放入数据。假设要放入50组数据，运算图因为是事先构建的，所以每一次计算梯度都很快、高效；动态图的运算图是在数据计算的同时构建的，假设要放入50组数据，那么就要生成50次运算图。这样就没有那么高效。所以称为&lt;strong&gt;动态图&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;动态图虽然没有那么高效，但是他的优点有以下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;更容易调试。&lt;/li&gt;
&lt;li&gt;动态计算更适用于自然语言处理。（这个可能是因为自然语言处理的输入往往不定长？）&lt;/li&gt;
&lt;li&gt;动态图更面向对象编程，我们会感觉更加自然。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 22 Aug 2020 22:17:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>文章来自公众号【机器学习炼丹术】，回复“炼丹”即可获得海量学习资料哦！ 本章节缕一缕PyTorch的动态图机制与Tensorflow的静态图机制（最新版的TF也支持动态图了似乎）。 1 动态图的初步推</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13548104.html</dc:identifier>
</item>
<item>
<title>CSS动画实例：小圆球的海洋 - aTeacher</title>
<link>http://www.cnblogs.com/cs-whut/p/13548087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-whut/p/13548087.html</guid>
<description>&lt;p&gt;      CSS背景属性用于定义HTML元素的背景，在CSS提供的背景属性中，&lt;/p&gt;
&lt;p&gt;background-image：指定要使用的一个或多个背景图像；&lt;/p&gt;
&lt;p&gt;background-color：指定要使用的背景颜色；&lt;/p&gt;
&lt;p&gt;background-position：指定背景图像的位置；&lt;/p&gt;
&lt;p&gt;background-size：指定背景图片的大小；&lt;/p&gt;
&lt;p&gt;background-repeat：指定如何重复背景图像；&lt;/p&gt;
&lt;p&gt;background-origin  指定背景图像的定位区域；&lt;/p&gt;
&lt;p&gt;background-clip     指定背景图像的绘画区域；&lt;/p&gt;
&lt;p&gt;background-attachment  设置背景图像是否固定或者随着页面的其余部分滚动。&lt;/p&gt;
&lt;p&gt;下面我们以&lt;span&gt;“&lt;/span&gt;小圆球的海洋&lt;span&gt;”&lt;/span&gt;作为实例来体会背景动画的设计方法。&lt;/p&gt;
&lt;h3&gt;1．CSS3 径向渐变&lt;/h3&gt;
&lt;p&gt;      在CSS3中，可以使用radial-gradient() 函数以径向渐变的方式创建背景&lt;span&gt;“&lt;/span&gt;图像&lt;span&gt;”&lt;/span&gt;。径向渐变由它的中心定义。其调用格式为：&lt;/p&gt;
&lt;p&gt;          background-image: radial-gradient(shape size at position, start-color, ..., last-color);&lt;/p&gt;
&lt;p&gt;      各参数说明如下：&lt;/p&gt;
&lt;p&gt;      shape确定渐变的类型，属性值ellipse（默认）指定椭圆形的径向渐变，circle指定圆形的径向渐变。&lt;/p&gt;
&lt;p&gt;      size  定义渐变的大小，可取属性值有：&lt;/p&gt;
&lt;p&gt;             farthest-corner（默认）：指定径向渐变的半径长度为从圆心到离圆心最远的角；&lt;/p&gt;
&lt;p&gt;             closest-side：指定径向渐变的半径长度为从圆心到离圆心最近的边；&lt;/p&gt;
&lt;p&gt;             closest-corner：指定径向渐变的半径长度为从圆心到离圆心最近的角；&lt;/p&gt;
&lt;p&gt;             farthest-side：指定径向渐变的半径长度为从圆心到离圆心最远的边。&lt;/p&gt;
&lt;p&gt;       position   定义渐变的位置。可取属性值有：&lt;/p&gt;
&lt;p&gt;             center（默认）：设置中间为径向渐变圆心的纵坐标值；&lt;/p&gt;
&lt;p&gt;             top：设置顶部为径向渐变圆心的纵坐标值；&lt;/p&gt;
&lt;p&gt;            bottom：设置底部为径向渐变圆心的纵坐标值。&lt;/p&gt;
&lt;p&gt;       start-color，…，last-color用于指定渐变的起止颜色，可以使用长度值或百分比来指定起止色位置，但不允许负值。&lt;/p&gt;
&lt;p&gt;       设页面中有&amp;lt;div class=&quot;shape&quot;&amp;gt;&amp;lt;/div&amp;gt;，定义.shape的样式规则如下：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;    width:200px;&lt;/p&gt;
&lt;p&gt;    height:150px;&lt;/p&gt;
&lt;p&gt;    background-image: radial-gradient(red, green, blue);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;       可在页面中显示如图1所示的径向渐变图案。在这个径向渐变中颜色结点分布均匀。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051117123-1225064013.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1  径向渐变图（颜色结点分布均匀）&lt;/p&gt;
&lt;p&gt;       若改写为：background-image: radial-gradient(red 5%, green 15%, blue 60%);，则显示的图案如图2所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051133183-478373012.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2  径向渐变图（颜色结点分布不均匀）&lt;/p&gt;
&lt;p&gt;      若改写为：background-image: radial-gradient(closest-side at 60% 50%, red, green, blue);，则显示如图3所示的图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051150875-300169793.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3  径向渐变图&lt;/p&gt;
&lt;p&gt;      若改写为：background-image: radial-gradient(circle, red, green, blue);，则显示如图4所示的图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051213457-1048860695.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4  圆形径向渐变图&lt;/p&gt;
&lt;p&gt;若修改.shape的样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;    width:200px;&lt;/p&gt;
&lt;p&gt;    height:200px;&lt;/p&gt;
&lt;p&gt;    border-radius:50%;&lt;/p&gt;
&lt;p&gt;    background-image: radial-gradient(circle, red,yellow,blue);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中显示如图5所示的圆形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051234179-166463913.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5  圆形&lt;/p&gt;
&lt;h3&gt;2．小圆球一分为四&lt;/h3&gt;
&lt;p&gt;      设页面中有&amp;lt;div class=&quot;ocean&quot;&amp;gt;&amp;lt;/div&amp;gt;，为.ocean定义样式规则如下：&lt;/p&gt;
&lt;p&gt;  .ocean&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     margin: 0 auto;&lt;/p&gt;
&lt;p&gt;     width:450px;&lt;/p&gt;
&lt;p&gt;     height: 450px;&lt;/p&gt;
&lt;p&gt;     border: 4px solid rgba(255, 0, 0, 0.9);&lt;/p&gt;
&lt;p&gt;     border-radius: 10%;&lt;/p&gt;
&lt;p&gt;     background-image: radial-gradient(circle at center, #f5f6fa 10px, transparent 0),&lt;/p&gt;
&lt;p&gt;                     radial-gradient(circle at center, #f5f6fa 10px, transparent 0),&lt;/p&gt;
&lt;p&gt;                     radial-gradient(circle at center, #f5f6fa 10px, transparent 0),&lt;/p&gt;
&lt;p&gt;                     radial-gradient(circle at center, #f5f6fa 10px, transparent 0);&lt;/p&gt;
&lt;p&gt;     background-size: 90px 90px;&lt;/p&gt;
&lt;p&gt;     background-color: #0652dd;&lt;/p&gt;
&lt;p&gt;     background-repeat:no-repeat;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;      则页面中的显示如图6所示。background-image后定义了四个径向渐变图像，由于没有给它们指定位置，会叠放在一起，因而显示为一个小圆球。小圆球的圆心坐标为（45px,45px）。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051307349-161314854.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图6  一个白色小圆球&lt;/p&gt;
&lt;p&gt;       为这四个小圆球指定位置，在.ocean样式定义中加上如下属性设置：&lt;/p&gt;
&lt;p&gt;     background-position: calc(50% + 0px) calc(50% + 0px),&lt;/p&gt;
&lt;p&gt;                          calc(50% + 0px) calc(50% + 90px),&lt;/p&gt;
&lt;p&gt;                          calc(50% + 90px) calc(50% + 0px),&lt;/p&gt;
&lt;p&gt;                          calc(50% + 90px) calc(50% + 90px);&lt;/p&gt;
&lt;p&gt;       则页面中的显示如图7所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051331729-2049905458.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图7  4个小圆球&lt;/p&gt;
&lt;p&gt;      为从图6至图7的变化定义关键帧，使小球由一分成四，编写的HTML文件内容如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7550b5ad-1168-4a0e-8e62-822905281d84')&quot; readability=&quot;41&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_7550b5ad-1168-4a0e-8e62-822905281d84&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_7550b5ad-1168-4a0e-8e62-822905281d84&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7550b5ad-1168-4a0e-8e62-822905281d84&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小圆球一分为四&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .ocean 
  &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
     margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;450px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 450px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 4px solid rgba(255, 0, 0, 0.9)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-image&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; radial-gradient(circle at center, #f5f6fa 10px, transparent 0), 
                     radial-gradient(circle at center, #f5f6fa 10px, transparent 0), 
                     radial-gradient(circle at center, #f5f6fa 10px, transparent 0), 
                     radial-gradient(circle at center, #f5f6fa 10px, transparent 0)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 90px 90px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #0652dd&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     animation&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; anim 2s infinite linear&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-repeat&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;no-repeat&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  @keyframes anim 
  &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
     to
     {
         background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; calc(50% + 0px) calc(50% + 0px), 
                              calc(50% + 0px) calc(50% + 90px), 
                              calc(50% + 90px) calc(50% + 0px), 
                              calc(50% + 90px) calc(50% + 90px)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
     &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ocean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以呈现出如图8所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051510778-914813055.gif&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;413&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图8  小圆球一分为四（no-repeat）&lt;/p&gt;
&lt;p&gt;       若将上面样式定义中的&lt;span&gt;“&lt;/span&gt;background-repeat:no-repeat;&lt;span&gt;”&lt;/span&gt;去掉，此时背景图像将向垂直和水平方向重复，则呈现出如图9所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051548827-1404370471.gif&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;409&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图9  小圆球一分为四（repeat）&lt;/p&gt;
&lt;h3&gt;3．小圆球的海洋&lt;/h3&gt;
&lt;p&gt;      理解了图8和图9的动画思想，我们继续。&lt;/p&gt;
&lt;p&gt;       为4个小圆球指定好初始位置，然后将各自的终止位置略作变化。编写如下的HTML文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('54ff8d82-02fd-49b9-aa16-0103ff0a2fdb')&quot; readability=&quot;42.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_54ff8d82-02fd-49b9-aa16-0103ff0a2fdb&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_54ff8d82-02fd-49b9-aa16-0103ff0a2fdb&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_54ff8d82-02fd-49b9-aa16-0103ff0a2fdb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小圆球的海洋&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .ocean 
  &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
     margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;450px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 450px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 4px solid rgba(255, 0, 0, 0.9)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-image&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; radial-gradient(circle at center, #f5f6fa 10px, transparent 0), 
                       radial-gradient(circle at center, #f5f6fa 10px, transparent 0), 
                       radial-gradient(circle at center, #f5f6fa 10px, transparent 0), 
                       radial-gradient(circle at center, #f5f6fa 10px, transparent 0)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; calc(50% + 0px) calc(50% + 0px), 
                          calc(50% + 0px) calc(50% + 90px), 
                          calc(50% + 90px) calc(50% + 90px), 
                          calc(50% + 90px) calc(50% + 0px)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 90px 90px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #0652dd&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     animation&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; anim 2s infinite linear&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-repeat&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;no-repeat&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  @keyframes anim 
  &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
     to 
     {
         background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;calc(50% + 90px) calc(50% + 0px), 
                             calc(50% + 0px) calc(50% + 0px), 
                             calc(50% + 0px) calc(50% + 90px), 
                             calc(50% + 90px) calc(50% + 90px)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
     &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ocean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以呈现出如图10所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051709043-1915212374.gif&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;413&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图10  旋转的4个小圆球&lt;/p&gt;
&lt;p&gt;      同样将样式定义中的&lt;span&gt;“&lt;/span&gt;background-repeat:no-repeat;&lt;span&gt;”&lt;/span&gt;去掉，此时背景图像将向垂直和水平方向重复，则呈现出如图11所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051805720-1036373667.gif&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;406&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图11  小圆球的海洋（1）&lt;/p&gt;
&lt;p&gt;       若在图11的基础上，在关键帧to中加上一句&lt;span&gt;“&lt;/span&gt;background-size: 180px 180px;&lt;span&gt;”&lt;/span&gt;，使得关键结束帧的背景大小扩大1倍，则呈现出如图12所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051840995-1372754952.gif&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;410&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图12  小圆球的海洋（2）&lt;/p&gt;
&lt;p&gt;      在关键帧to中加上的一句为&lt;span&gt;“&lt;/span&gt;background-size: 45px 45px;&lt;span&gt;”&lt;/span&gt;，使得关键结束帧的背景大小缩小1倍，且将radial-gradient四个函数中的10px均修改为8px，使得小圆球也适当变小，则呈现出如图13所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823051912399-1657682698.gif&quot; alt=&quot;&quot; width=&quot;406&quot; height=&quot;411&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图13  小圆球的海洋（3）&lt;/p&gt;
&lt;p&gt;      将整个屏幕作为背景，显示欢乐的小圆球，编写的HTML文件如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('15559670-89a5-49e1-94ec-8104b3762422')&quot; readability=&quot;41&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_15559670-89a5-49e1-94ec-8104b3762422&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_15559670-89a5-49e1-94ec-8104b3762422&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_15559670-89a5-49e1-94ec-8104b3762422&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;满屏都是小圆球&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  body 
  &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
     min-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100vh&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-image&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; radial-gradient(circle at center, #f5f6fa 1vmin, transparent 0), 
                       radial-gradient(circle at center, #f5f6fa 1vmin, transparent 0), 
                       radial-gradient(circle at center, #f5f6fa 1vmin, transparent 0), 
                       radial-gradient(circle at center, #f5f6fa 1vmin, transparent 0)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; calc(50% + 0vmin) calc(50% + 0vmin), 
                          calc(50% + 0vmin) calc(50% + 15vmin),                          
                          calc(50% + 15vmin) calc(50% + 15vmin),
                          calc(50% + 15vmin) calc(50% + 0vmin)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 15vmin 15vmin&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     animation&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; anim 2s infinite linear&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
     background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #0652dd&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  @keyframes anim 
  &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
     to 
     {
        background-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 30vmin 30vmin&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; calc(50% + 15vmin) calc(50% + 0vmin), 
                             calc(50% + 0vmin) calc(50% + 0vmin), 
                             calc(50% + 0vmin) calc(50% + 15vmin), 
                             calc(50% + 15vmin) calc(50% + 15vmin)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
     &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以呈现出如图14所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200823052026549-1937641451.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图14  满屏都是欢乐的小圆球&lt;/p&gt;
</description>
<pubDate>Sat, 22 Aug 2020 21:21:00 +0000</pubDate>
<dc:creator>aTeacher</dc:creator>
<og:description>CSS背景属性用于定义HTML元素的背景，在CSS提供的背景属性中， background-image：指定要使用的一个或多个背景图像； background-color：指定要使用的背景颜色； ba</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-whut/p/13548087.html</dc:identifier>
</item>
<item>
<title>使用Spring Cloud Config统一管理配置，别再到处放配置文件了 - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/13547912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/13547912.html</guid>
<description>&lt;blockquote readability=&quot;2.9545454545455&quot;&gt;
&lt;p&gt;欢迎访问&lt;a href=&quot;https://www.pkslow.com/&quot;&gt;南瓜慢说 www.pkslow.com&lt;/a&gt;获取更多精彩文章！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可配置是一个成熟软件系统应该提供的特性，而配置管理对于大型系统就显得十分重要，特别是对于拥有多个应用的微服务系统。可喜的是，&lt;code&gt;Spring&lt;/code&gt;为我们提供了很好的配置管理，如&lt;code&gt;Springboot&lt;/code&gt;的配置就很强大。对于&lt;code&gt;Spring Cloud&lt;/code&gt;，就有强大的&lt;code&gt;Spring Cloud Config&lt;/code&gt;，在提供了一个在应用之外的配置管理，如文件或&lt;code&gt;Git&lt;/code&gt;仓库，对分布式系统配置管理十分有益。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Spring Cloud Config&lt;/code&gt;服务端就是一个&lt;code&gt;Springboot&lt;/code&gt;应用，启动、部署都十分简单。&lt;/p&gt;
&lt;p&gt;整体的架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202008/946674-20200823004436105-555030701.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;21-服务端就是一个springboot&quot;&gt;2.1 服务端就是一个Springboot&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;Springboot&lt;/code&gt;中添加依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.2.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要一个就行了，它已经包含了&lt;code&gt;web&lt;/code&gt;和&lt;code&gt;actuator&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;添加&lt;code&gt;Java&lt;/code&gt;主类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.pkslow.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer
public class ConfigServer {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServer.class,args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟普通的&lt;code&gt;Springboot&lt;/code&gt;应用相比只是多了一个注解&lt;code&gt;@EnableConfigServer&lt;/code&gt;而已。&lt;/p&gt;
&lt;h2 id=&quot;22-配置仓库&quot;&gt;2.2 配置仓库&lt;/h2&gt;
&lt;p&gt;通过我们会把配置通过版本控制管理起来，一般使用&lt;code&gt;Git&lt;/code&gt;仓库，为简单展示使用本地仓库如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 创建目录
mkdir git-repo

# 初始化一个git目录
git init

# 新建文件
touch application.properties

# 添加变更
git add .

# 提交变更
git commit -m &quot;init&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置一下项目的&lt;code&gt;application.properties&lt;/code&gt;，注意是&lt;code&gt;Config Server&lt;/code&gt;项目的，而不是在&lt;code&gt;git-repo&lt;/code&gt;目录里的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;server.port=8888
spring.application.name=config-server
spring.cloud.config.server.git.uri=/Users/pkslow/IdeaProjects/pkslow-modules/config-server/git-repo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着就可以启动&lt;code&gt;Config Server&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;git&lt;/code&gt;仓库里的配置文件没有什么内容，我们加入以下内容并提交（必须要提交，不然无法获取）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;pkslow.webSite=www.pkslow.com
pkslow.age=18
pkslow.email=admin@pkslow.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23-配置路径匹配&quot;&gt;2.3 配置路径匹配&lt;/h2&gt;
&lt;p&gt;那我们如何获取这些配置呢？可以通过以下&lt;code&gt;URL&lt;/code&gt;读取：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;label&lt;/code&gt;指的是代码分支，如&lt;code&gt;master&lt;/code&gt;，&lt;code&gt;feature-1&lt;/code&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;application&lt;/code&gt;是应用的名字，在以后客户端读取会用到。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;profile&lt;/code&gt;一般用于指定环境，如&lt;code&gt;prod&lt;/code&gt;，&lt;code&gt;dev&lt;/code&gt;，&lt;code&gt;uat&lt;/code&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，我们可以用以下&lt;code&gt;URL&lt;/code&gt;来获取我们刚添加的配置信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http://localhost:8888/application/default
http://localhost:8888/application/default/master
http://localhost:8888/master/application.properties
http://localhost:8888/application-default.properties
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ curl http://localhost:8888/application/default/master
{&quot;name&quot;:&quot;application&quot;,&quot;profiles&quot;:[&quot;default&quot;],&quot;label&quot;:&quot;master&quot;,&quot;version&quot;:&quot;8796f39b35095f6e9b7176457eb03dd6d62b1783&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;/Users/pkslow/IdeaProjects/pkslow-modules/config-server/git-repo/application.properties&quot;,&quot;source&quot;:{&quot;pkslow.webSite&quot;:&quot;www.pkslow.com&quot;,&quot;pkslow.age&quot;:&quot;18&quot;,&quot;pkslow.email&quot;:&quot;admin@pkslow.com&quot;}}]}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一个地址&lt;code&gt;/{label}/{application}-{profile}.properties&lt;/code&gt;的返回结果格式不同，直接返回配置文件内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ curl http://localhost:8888/application-default.properties
pkslow.age: 18
pkslow.email: admin@pkslow.com
pkslow.webSite: www.pkslow.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们先建一个分支&lt;code&gt;release-20200809&lt;/code&gt;，并修改&lt;code&gt;age&lt;/code&gt;为实际年龄&lt;code&gt;9&lt;/code&gt;，则如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ curl http://localhost:8888/application/default/release-20200809
{&quot;name&quot;:&quot;application&quot;,&quot;profiles&quot;:[&quot;default&quot;],&quot;label&quot;:&quot;release-20200809&quot;,&quot;version&quot;:&quot;7e27e6972ed31ee1a51e9277a2f5c0a628cec67a&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;/Users/pkslow/IdeaProjects/pkslow-modules/config-server/git-repo/application.properties&quot;,&quot;source&quot;:{&quot;pkslow.webSite&quot;:&quot;www.pkslow.com&quot;,&quot;pkslow.age&quot;:&quot;9&quot;,&quot;pkslow.email&quot;:&quot;admin@pkslow.com&quot;}}]}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到对应的&lt;code&gt;pkslow.age&lt;/code&gt;已经变为&lt;code&gt;9&lt;/code&gt;了，但访问&lt;code&gt;/application/default/master&lt;/code&gt;则还是&lt;code&gt;18&lt;/code&gt;，分支之间不会相互影响。&lt;/p&gt;
&lt;h2 id=&quot;24-远程仓库&quot;&gt;2.4 远程仓库&lt;/h2&gt;
&lt;p&gt;本地仓库只是为了简单展示，在实际项目中，一般使用远程仓库，在&lt;code&gt;GitHub&lt;/code&gt;创建一个新的仓库如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202008/946674-20200823004436495-2129000366.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;特意创建了个&lt;code&gt;private&lt;/code&gt;的仓库来检测后面的鉴权是否正确。&lt;/p&gt;
&lt;p&gt;重新配置仓库的地址如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;spring.cloud.config.server.git.uri=https://github.com/pkslow/pkslow-config
spring.cloud.config.server.git.username=admin@pkslow.com
spring.cloud.config.server.git.password=***
spring.cloud.config.server.git.default-label=master
spring.cloud.config.server.git.search-paths=demo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个&lt;code&gt;demo&lt;/code&gt;目录来放置配置，所以&lt;code&gt;search-paths&lt;/code&gt;配置为&lt;code&gt;demo&lt;/code&gt;。完成配置重启服务器，就可以正常读取远程仓库的配置了。&lt;/p&gt;
&lt;h2 id=&quot;25-多个代码配置仓库&quot;&gt;2.5 多个代码配置仓库&lt;/h2&gt;
&lt;p&gt;有些时候，我们的配置可能并不只在一个仓库里，而是在各自客户端的代码库中，比如我们有以下三个服务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）服务发现：discovery，代码库pkslow-discovery-service&lt;/li&gt;
&lt;li&gt;（2）API网关：gateway，代码库pkslow-gateway-service&lt;/li&gt;
&lt;li&gt;（3）订单服务：order，代码库pkslow-order-service&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它们各自的配置文件都放在各自的代码库里，那就需要配置多个代码库。我们还多配置一个默认的配置库pkslow-default，如果匹配不到，就会选择默认代码库的配置。具体配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;server:
  port: 8888
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: /Users/pkslow/multiple-repos/pkslow-default
          repos:
            pkslow-discovery-service:
              pattern: pkslow-discovery-*
              cloneOnStart: true
              uri: /Users/pkslow/multiple-repos/pkslow-discovery-service
              search-paths: config
            pkslow-gateway-service:
              pattern: pkslow-gateway-*/dev
              cloneOnStart: true
              uri: /Users/pkslow/multiple-repos/pkslow-gateway-service
              search-paths: config
            pkslow-order-service:
              pattern: pkslow-order-*
              cloneOnStart: true
              uri: /Users/pkslow/IdeaProjects/pkslow-order-service
              search-paths: config
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以各自定义配置文件所放的目录&lt;code&gt;search-paths&lt;/code&gt;，不配置默认为根目录。&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;pattern&lt;/code&gt;的配置规则是&lt;code&gt;{application}/{profile}&lt;/code&gt;，支持正则符号&lt;code&gt;*&lt;/code&gt;。注意只匹配一个结果，如果都满足，只取第一个匹配的仓库。&lt;/p&gt;
&lt;p&gt;启动后我们来看看配置结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 默认profile和label，正确匹配
$ curl http://localhost:8888/pkslow-order-service/default/master
{&quot;name&quot;:&quot;pkslow-order-service&quot;,&quot;profiles&quot;:[&quot;default&quot;],&quot;label&quot;:&quot;master&quot;,&quot;version&quot;:&quot;9d86e5d11974f0a0e7c20cd53d8f062755193e70&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;/Users/pkslow/IdeaProjects/pkslow-modules/config-server/multiple-repos/pkslow-order-service/config/application.properties&quot;,&quot;source&quot;:{&quot;pkslow.webSite&quot;:&quot;www.pkslow.com&quot;,&quot;pkslow.app.name&quot;:&quot;order-service&quot;}}]}

# 正确匹配，但不存在的Label，配置库没有对应代码分支，404
$ curl http://localhost:8888/pkslow-order-service/default/release
{&quot;timestamp&quot;:&quot;2020-08-13T06:58:38.722+0000&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;message&quot;:&quot;No such label: release&quot;,&quot;path&quot;:&quot;/pkslow-order-service/default/release&quot;}

# profile为dev，正确匹配
$ curl http://localhost:8888/pkslow-order-service/dev/master
{&quot;name&quot;:&quot;pkslow-order-service&quot;,&quot;profiles&quot;:[&quot;dev&quot;],&quot;label&quot;:&quot;master&quot;,&quot;version&quot;:&quot;9d86e5d11974f0a0e7c20cd53d8f062755193e70&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;/Users/pkslow/IdeaProjects/pkslow-modules/config-server/multiple-repos/pkslow-order-service/config/application.properties&quot;,&quot;source&quot;:{&quot;pkslow.webSite&quot;:&quot;www.pkslow.com&quot;,&quot;pkslow.app.name&quot;:&quot;order-service&quot;}}]}

# 对于gateway只能匹配profile=dev，无法匹配，读取默认配置
$ curl http://localhost:8888/pkslow-gateway-service/default/master
{&quot;name&quot;:&quot;pkslow-gateway-service&quot;,&quot;profiles&quot;:[&quot;default&quot;],&quot;label&quot;:&quot;master&quot;,&quot;version&quot;:&quot;8358f2b4701fac21a0c7776bc46cec6d9442c549&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;/Users/pkslow/IdeaProjects/pkslow-modules/config-server/multiple-repos/pkslow-base/application.properties&quot;,&quot;source&quot;:{&quot;pkslow.birthDate&quot;:&quot;2020-08-10&quot;}}]}

# 对于gateway只能匹配profile=dev，正确匹配
$ curl http://localhost:8888/pkslow-gateway-service/dev/master
{&quot;name&quot;:&quot;pkslow-gateway-service&quot;,&quot;profiles&quot;:[&quot;dev&quot;],&quot;label&quot;:&quot;master&quot;,&quot;version&quot;:&quot;1a4e26849b237dc2592ca0d391daaa1a879747d2&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;/Users/pkslow/IdeaProjects/pkslow-modules/config-server/multiple-repos/pkslow-gateway-service/config/application.properties&quot;,&quot;source&quot;:{&quot;pkslow.webSite&quot;:&quot;www.pkslow.com&quot;,&quot;pkslow.app.name&quot;:&quot;gateway-service&quot;}}]}

# 不存在的服务名，无法匹配，读取默认配置
$ curl http://localhost:8888/unknown-service/dev/master
{&quot;name&quot;:&quot;unknown-service&quot;,&quot;profiles&quot;:[&quot;dev&quot;],&quot;label&quot;:&quot;master&quot;,&quot;version&quot;:&quot;8358f2b4701fac21a0c7776bc46cec6d9442c549&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;/Users/pkslow/IdeaProjects/pkslow-modules/config-server/multiple-repos/pkslow-base/application.properties&quot;,&quot;source&quot;:{&quot;pkslow.birthDate&quot;:&quot;2020-08-10&quot;}}]}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;经过前面的例子我们已经了解到服务端如何从代码库里获取配置，但始终还是要使客户端能获取到对应的配置并产生效果。我们来演示一下。&lt;/p&gt;
&lt;h2 id=&quot;31-项目准备&quot;&gt;3.1 项目准备&lt;/h2&gt;
&lt;p&gt;搭建一个最简单的&lt;code&gt;Springboot Web&lt;/code&gt;项目，并加上&lt;code&gt;Spring Cloud Config&lt;/code&gt;的支持，添加依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加配置文件：&lt;code&gt;bootstrap.properties&lt;/code&gt;（虽然我们要从服务端读取配置，但有些配置还是必须在客户添加的，如服务端地址），内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;server.port=8080
spring.application.name=pkslow-gateway-service
spring.cloud.config.uri=http://localhost:8888
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里我们配置了客户端的端口、服务端的地址以及客户端应用的名字，这个名字是非常关键的，待会讲解。&lt;/p&gt;
&lt;p&gt;添加&lt;code&gt;Controller&lt;/code&gt;来暴露&lt;code&gt;API&lt;/code&gt;以显示读到的配置内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class PkslowController {
    @Value(&quot;${pkslow.age}&quot;)
    private Integer age;

    @Value(&quot;${pkslow.email}&quot;)
    private String email;

    @Value(&quot;${pkslow.webSite}&quot;)
    private String webSite;

    @GetMapping(&quot;/pkslow&quot;)
    public Map&amp;lt;String, String&amp;gt; getConfig() {
        Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;age&quot;, age.toString());
        map.put(&quot;email&quot;, email);
        map.put(&quot;webSite&quot;, webSite);
        return map;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着启动客户端即可，访问结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ curl http://localhost:8080/pkslow
{&quot;webSite&quot;:&quot;default.pkslow.com&quot;,&quot;age&quot;:&quot;9&quot;,&quot;email&quot;:&quot;admin@pkslow.com&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些配置内容并不在客户端，说明可以从服务端获取到配置信息了。&lt;/p&gt;
&lt;h2 id=&quot;32-客户端如何匹配&quot;&gt;3.2 客户端如何匹配&lt;/h2&gt;
&lt;p&gt;客户端已经获取到配置信息了，那是否正确呢？客户端又是怎样匹配的呢？其实前面的内容已经提及，主要通过三个信息来匹配：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;label&lt;/code&gt;指的是代码分支。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;application&lt;/code&gt;是应用的名字。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;profile&lt;/code&gt;一般用于指定环境。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上个例子客户端名字为&lt;code&gt;pkslow-gateway-service&lt;/code&gt;；&lt;code&gt;label&lt;/code&gt;没指定，默认为&lt;code&gt;master&lt;/code&gt;；&lt;code&gt;profile&lt;/code&gt;没有指定，默认为&lt;code&gt;default&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们在服务端匹配规则为&lt;code&gt;pattern: pkslow-gateway-*/dev&lt;/code&gt;，所以可以匹配名字，但无法匹配&lt;code&gt;profile&lt;/code&gt;，因此读取了默认仓库的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ cat pkslow-base/application.properties 
pkslow.webSite=default.pkslow.com
pkslow.age=9
pkslow.email=admin@pkslow.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改一下客户端的配置，配置&lt;code&gt;profile&lt;/code&gt;为&lt;code&gt;dev&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;server.port=8080
spring.application.name=pkslow-gateway-service
spring.profiles.active=dev
spring.cloud.config.uri=http://localhost:8888
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次获取客户端的配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ curl http://localhost:8080/pkslow
{&quot;webSite&quot;:&quot;gateway-master.pkslow.com&quot;,&quot;age&quot;:&quot;9&quot;,&quot;email&quot;:&quot;admin@pkslow.com&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见已经读取到&lt;code&gt;pkslow-gateway-service&lt;/code&gt;仓库的配置内容了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ cat pkslow-gateway-service/config/application.properties 
pkslow.webSite=gateway-master.pkslow.com
pkslow.age=9
pkslow.email=admin@pkslow.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;pkslow-gateway-service&lt;/code&gt;仓库新建代码分支&lt;code&gt;release&lt;/code&gt;并添加配置，再修改客户端配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;server.port=8080
spring.application.name=pkslow-gateway-service
spring.profiles.active=dev
spring.cloud.config.label=release
spring.cloud.config.uri=http://localhost:8888
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启后再次访问，正确读取到了新分支的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ curl http://localhost:8080/pkslow
{&quot;webSite&quot;:&quot;gateway-release.pkslow.com&quot;,&quot;age&quot;:&quot;9&quot;,&quot;email&quot;:&quot;admin@pkslow.com&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;33-客户端配置生效问题&quot;&gt;3.3 客户端配置生效问题&lt;/h2&gt;
&lt;p&gt;当我们修改配置后，再次访问结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ git commit -a -m &quot;update&quot;
[release 0e489fe] update
 1 file changed, 2 insertions(+), 2 deletions(-)

$ curl http://localhost:8888/pkslow-gateway-service/dev/release
{&quot;name&quot;:&quot;pkslow-gateway-service&quot;,&quot;profiles&quot;:[&quot;dev&quot;],&quot;label&quot;:&quot;release&quot;,&quot;version&quot;:&quot;0e489fec5de73b1a6d11befa3f65e44836979e23&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;/Users/pkslow/IdeaProjects/pkslow-modules/config-server/multiple-repos/pkslow-gateway-service/config/application.properties&quot;,&quot;source&quot;:{&quot;pkslow.webSite&quot;:&quot;gateway-release.pkslow.com&quot;,&quot;pkslow.age&quot;:&quot;10&quot;,&quot;pkslow.email&quot;:&quot;admin@pkslow.com&quot;}}]}

$ curl http://localhost:8080/pkslow
{&quot;webSite&quot;:&quot;gateway-release.pkslow.com&quot;,&quot;age&quot;:&quot;9&quot;,&quot;email&quot;:&quot;admin@pkslow.com&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果发现，服务端已经生效了，但客户端并没有。这是因为在这种模式下客户端只会在启动的时候读取配置使其生效。如果想要客户端也生效，我们要使用&lt;code&gt;Springboot actuator&lt;/code&gt;提供的&lt;code&gt;/refresh&lt;/code&gt;端点才行。&lt;/p&gt;
&lt;p&gt;先添加&lt;code&gt;actuator&lt;/code&gt;依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置要保证&lt;code&gt;/refresh&lt;/code&gt;可以访问，添加如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;management.endpoints.web.exposure.include=refresh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定刷新的范围，在&lt;code&gt;Controller&lt;/code&gt;上添加注解&lt;code&gt;@RefreshScope&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RefreshScope
@RestController
public class PkslowController {
//xxx
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启应用。操作及效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 修改配置并提交
$ git commit -a -m &quot;update age to 18&quot;
[release fc863bd] update age to 18
 1 file changed, 1 insertion(+), 1 deletion(-)

# 服务端配置生效
$ curl http://localhost:8888/pkslow-gateway-service/dev/release
{&quot;name&quot;:&quot;pkslow-gateway-service&quot;,&quot;profiles&quot;:[&quot;dev&quot;],&quot;label&quot;:&quot;release&quot;,&quot;version&quot;:&quot;fc863bd8849fa1dc5eaf2ce0a97afb485f81c2f0&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;/Users/larry/IdeaProjects/pkslow-modules/config-server/multiple-repos/pkslow-gateway-service/config/application.properties&quot;,&quot;source&quot;:{&quot;pkslow.webSite&quot;:&quot;gateway-release.pkslow.com&quot;,&quot;pkslow.age&quot;:&quot;18&quot;,&quot;pkslow.email&quot;:&quot;admin@pkslow.com&quot;}}]}

# 客户端没有生效
$ curl http://localhost:8080/pkslow
{&quot;webSite&quot;:&quot;gateway-release.pkslow.com&quot;,&quot;age&quot;:&quot;10&quot;,&quot;email&quot;:&quot;admin@pkslow.com&quot;}

# 发送POST请求到客户端/refresh
$ curl -X POST http://localhost:8080/actuator/refresh
[&quot;config.client.version&quot;,&quot;pkslow.age&quot;]

# 客户端已经生效
$ curl http://localhost:8080/pkslow
{&quot;webSite&quot;:&quot;gateway-release.pkslow.com&quot;,&quot;age&quot;:&quot;18&quot;,&quot;email&quot;:&quot;admin@pkslow.com&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;34-自动更新配置&quot;&gt;3.4 自动更新配置&lt;/h2&gt;
&lt;p&gt;每次提交代码配置后，都需要手动发一次&lt;code&gt;POST&lt;/code&gt;请求到客户端才能更新配置，显然是不够友好的。&lt;code&gt;GitHub&lt;/code&gt;提供了&lt;code&gt;webhook&lt;/code&gt;功能，可以在触发事件后，发送请求到指定&lt;code&gt;URL&lt;/code&gt;，这样便可以实现自动更新了。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;webhook&lt;/code&gt;功能实现自动更新是一对一的，如果客户端很多（通常是这种场景），就无法这样直接实现。有两个方案：&lt;/p&gt;
&lt;p&gt;（1）自己实现一个端口来接受来自&lt;code&gt;Git&lt;/code&gt;的请求，然后再分发到各个服务端。这个方法比较麻烦，不是很推荐。&lt;/p&gt;
&lt;p&gt;（2）通过引入&lt;code&gt;Spring Cloud Bus&lt;/code&gt;来刷新多个客户端。但需要引入&lt;code&gt;MQ&lt;/code&gt;，如&lt;code&gt;kafka&lt;/code&gt;或&lt;code&gt;RabbitMQ&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;35-在有服务发现时的不同&quot;&gt;3.5 在有服务发现时的不同&lt;/h2&gt;
&lt;p&gt;在微服务架构中，如果配置服务端与客户端都注册在服务发现（如&lt;code&gt;eureka&lt;/code&gt;）上时，客户端就无须再配置服务端的地址了，会从服务发现中心获取识别。这与&lt;code&gt;Springboot Admin&lt;/code&gt;在有&lt;code&gt;eureka&lt;/code&gt;的情况下有异曲同工之妙。&lt;/p&gt;
&lt;p&gt;代码没什么特别之外，就是把服务端和客户端同时注册到&lt;code&gt;eureka&lt;/code&gt;即可。&lt;/p&gt;

&lt;p&gt;本文通过例子一步步展示如何使用&lt;code&gt;Spring Cloud Config&lt;/code&gt;，主要是理解交互过程和匹配规则，其它都是代码细节，参考官方文档即可。&lt;/p&gt;
&lt;p&gt;关于配置的一些文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pkslow.com/archives/java-load-properties&quot;&gt;Java怎么从这四个位置读取配置文件Properties（普通文件系统-classpath-jar-URL）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pkslow.com/archives/springboot-annotation-configurationproperties&quot;&gt;注解@ConfigurationProperties让配置整齐而简单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pkslow.com/archives/spring-annotation-value&quot;&gt;只想用一篇文章记录@Value的使用，不想再找其它了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pkslow.com/archives/springboot-jasypt&quot;&gt;Springboot整合Jasypt，让配置信息安全最优雅方便的方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pkslow.com/archives/spring-cloud-config&quot;&gt;使用Spring Cloud Config统一管理配置，别再到处放配置文件了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pkslow.com/archives/spring-cloud-config-kubernetes&quot;&gt;Spring Cloud Config整合Spring Cloud Kubernetes，在k8s上管理配置&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注微信公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202008/946674-20200823004436723-71677329.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Aug 2020 16:45:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>1 前言 欢迎访问南瓜慢说 www.pkslow.com获取更多精彩文章！ 可配置是一个成熟软件系统应该提供的特性，而配置管理对于大型系统就显得十分重要，特别是对于拥有多个应用的微服务系统。可喜的是，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/13547912.html</dc:identifier>
</item>
<item>
<title>要点4：C的文件操作 - CN_Simo</title>
<link>http://www.cnblogs.com/lxmwb/p/13547862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxmwb/p/13547862.html</guid>
<description>&lt;p&gt;关于文件操作个人比较困惑的地方有两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关于&lt;code&gt;w&lt;/code&gt;和&lt;code&gt;wb&lt;/code&gt;的区别&lt;/li&gt;
&lt;li&gt;如何定位文件的读写位置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;c中的文件打开模式分为：文本模式和二进制模式，分别处理文本格式文件和二进制格式文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个模式的主要区别是在换行符的处理上&lt;/strong&gt;，利用文本模式在写文本内容到文件的时候，需要将换行符转换成系统对应的编码方式.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统不同，对换行符的表示方式也是不一样的&lt;/strong&gt;，例如&lt;code&gt;unix&lt;/code&gt;系统是&lt;code&gt;\n&lt;/code&gt;，而&lt;code&gt;MS-DOS&lt;/code&gt;是&lt;code&gt;\r\n&lt;/code&gt;，&lt;code&gt;Mac&lt;/code&gt;是&lt;code&gt;\r&lt;/code&gt;。&lt;code&gt;C&lt;/code&gt;里面都是用&lt;code&gt;\n&lt;/code&gt;作为换行符的，所以在文本写入时，底层需要将&lt;code&gt;C&lt;/code&gt;形式换行符&lt;code&gt;\n&lt;/code&gt;做对应的转换之后写入文件，读取文件时将对应系统的换行符转成&lt;code&gt;C&lt;/code&gt;形式的。因为&lt;code&gt;unix&lt;/code&gt;系统的换行符是&lt;code&gt;\n&lt;/code&gt;，这和&lt;code&gt;C&lt;/code&gt;形式一致，所以&lt;code&gt;unix&lt;/code&gt;系统下文本模式和二进制模式没有区别。&lt;/p&gt;
&lt;p&gt;C中使用&lt;code&gt;fopen&lt;/code&gt;函数创建文件句柄，函数原型如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;FILE *fopen(const char *filename, const char *mode)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;filename&lt;/code&gt;表示文件路径，&lt;code&gt;mode&lt;/code&gt;表示打开模式，成功返回一个文件句柄指针，失败返回null。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mode&lt;/code&gt; 有下列几种形态字符串:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 以只读方式打开文件，该文件必须存在。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r+&lt;/code&gt; 以可读写方式打开文件，该文件必须存在。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rb+&lt;/code&gt; 读写打开一个二进制文件，允许读数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rw+&lt;/code&gt; 读写打开一个文本文件，允许读和写。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w+&lt;/code&gt; 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a+&lt;/code&gt; 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wb&lt;/code&gt; 只写打开或新建一个二进制文件；只允许写数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wb+&lt;/code&gt; 读写打开或建立一个二进制文件，允许读和写。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab+&lt;/code&gt; 读写打开一个二进制文件，允许读或在文件末追加数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;at+&lt;/code&gt; 打开一个文本文件，&lt;code&gt;a&lt;/code&gt;表示&lt;code&gt;append&lt;/code&gt;,就是说写入处理的时候是接着原来文件已有内容写入，不是从头写入覆盖掉，&lt;code&gt;t&lt;/code&gt;表示打开文件的类型是文本文件，&lt;code&gt;+&lt;/code&gt;号表示对文件既可以读也可以写。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述的形态字符串都可以再加一个&lt;code&gt;b&lt;/code&gt;字符，如&lt;code&gt;rb&lt;/code&gt;、&lt;code&gt;w+b&lt;/code&gt;或&lt;code&gt;ab+&lt;/code&gt;等组合，加入&lt;code&gt;b&lt;/code&gt; 字符用来告诉函数库以二进制模式打开文件。&lt;strong&gt;如果不加&lt;code&gt;b&lt;/code&gt;，表示默认加了&lt;code&gt;t&lt;/code&gt;&lt;/strong&gt;，即&lt;code&gt;rt&lt;/code&gt;,&lt;code&gt;wt&lt;/code&gt;,其中&lt;code&gt;t&lt;/code&gt;表示以文本模式打开文件。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;windows&lt;/code&gt;上分别利用&lt;code&gt;w+&lt;/code&gt;和&lt;code&gt;wb+&lt;/code&gt;模式测试一下文本模式和二进制模式写数据的区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main(int argc, char* argv[])
{
        // 文件w+.txt
        FILE *fp1 = fopen(&quot;.\\w+.txt&quot;, &quot;w+&quot;);
        if (!fp1)
        {
                fputs(&quot;文件打开错误！&quot;, stdin);
                return EXIT_FAILURE;
        }
        fprintf(fp1, &quot;%s&quot;, &quot;The first line!\nThe second line!\n&quot;); // 写入内容中带有换行符
        fclose(fp1);

        // 文件wb+.txt
        FILE* fp2 = fopen(&quot;.\\wb+.txt&quot;, &quot;wb+&quot;);
        if (!fp2)
        {
                fputs(&quot;文件打开错误！&quot;, stdin);
                return EXIT_FAILURE;
        }
        fprintf(fp2, &quot;%s&quot;, &quot;The first line!\nThe second line!\n&quot;); // 写入内容中带有换行符
        fclose(fp2);
        return EXIT_SUCCESS;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;左侧显示的是&lt;code&gt;w+.txt&lt;/code&gt;，右侧显示的是&lt;code&gt;wb+.txt&lt;/code&gt;，明显可以看出保存的换行符是有区别的，&lt;code&gt;wb+&lt;/code&gt;模式没有将C代码中的&lt;code&gt;\n&lt;/code&gt;进行特殊处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/cnsimo/pic_bed/20200821014552.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果可以在访问文件的时候，能够直接定位到某个位置进行读取，那就可以实现像数组一样随机访问了。&lt;/p&gt;
&lt;p&gt;C语言提供了几个相关的函数，他们的原型如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int fseek( FILE *stream, long offset, int origin );
long ftell( FILE *stream );
int fgetpos( FILE *restrict stream, fpos_t *restrict pos );
int fsetpos( FILE *stream, const fpos_t *pos );
void rewind( FILE *stream );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;rewind&lt;/code&gt; 函数用于将文件内部的位置指针重新指向一个流（数据流或者文件）的起始位置。这里需要注意的是，这里的“指针”表示的不是文件指针，而是文件内部的位置指针。即随着对文件的读写，文件的位置指针（指向当前读写字节）向后移动。而文件指针指向整个文件，如果不重新赋值，文件指针不会发生改变。&lt;/p&gt;
&lt;p&gt;例如，使用&lt;code&gt;w+&lt;/code&gt;模式打开一个文件写入内容之后，再输出文件内容，代码可以这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#define MAXLEN 80

int main()
{
        // 打开文件
        char filename[MAXLEN] = &quot;.\\test.txt&quot;;
        FILE* fp = fopen(filename, &quot;w+&quot;);
        if (!fp)
        {
                fputs(&quot;文件打开失败！&quot;, stdout);
                exit(EXIT_FAILURE);
        }
        // 写入文本
        char* text = &quot;This is a test file!&quot;;
        fputs(text, fp);
        // 还原位置指针
        rewind(fp);
        // 读取文件内容
        char c;
        while ((c = fgetc(fp)) != EOF)
        {
                putchar(c);
        }
        // 关闭文件
        fclose(fp);
        return EXIT_SUCCESS;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rewind&lt;/code&gt;功能比较简单，只能用于返回到文件开头，如果想要跳转到其他位置，则&lt;code&gt;fseek&lt;/code&gt;功能更加强大，它用来设定文件的读写位置，可以实现文件的随机访问。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fseek&lt;/code&gt;的三个参数， 第一个是文件句柄，第三个参数是基准位置，第二个是相对于基准位置的偏移处，基准位置有三个：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;代表位置&lt;/th&gt;
&lt;th&gt;值形式&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;SEEK_SET&lt;/td&gt;
&lt;td&gt;文件首部&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SEEK_CUR&lt;/td&gt;
&lt;td&gt;当前位置&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SEEK_END&lt;/td&gt;
&lt;td&gt;文件尾部&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main()
{
        // 打开文件
        FILE* fp = fopen(&quot;.\\test.txt&quot;, &quot;w+&quot;);
        if (!fp)
        {
                fputs(&quot;文件打开失败！&quot;, stdout);
                exit(EXIT_FAILURE);
        }
        // 先写入123，然后改成abc
        fputc('1', fp);
        fputc('2', fp);
        fputc('3', fp);
        // 先将指针转到中间改b
        fseek(fp, -2, SEEK_END);
        fputc('b', fp);
        // 将指针转到开头改a
        fseek(fp, 0, SEEK_SET);
        fputc('a', fp);
        // 将指针转到第三个字符改c
        fseek(fp, 1, SEEK_CUR);
        fputc('c', fp);
        // 关闭文件
        fclose(fp);
        return EXIT_SUCCESS;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;SEEK_END&lt;/code&gt;指向了文件结尾，所以需要向前偏移2，才能将指针指到&lt;code&gt;1&lt;/code&gt;的后面。&lt;/p&gt;
&lt;p&gt;对于以文本模式打开的流，使用fseek函数时候需要注意，因为'\n'换行符与系统换行符之间的转换会导致&lt;code&gt;fseek&lt;/code&gt;产生意外的结果。&lt;strong&gt;&lt;code&gt;fseek&lt;/code&gt;只有在下面两种情况下才能保证当文件以文档模式打开时能正确使用&lt;code&gt;fseek&lt;/code&gt;函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与起始位置相对偏移为0的重置，即没有改动指针位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;origin&lt;/code&gt;设置为&lt;code&gt;SEEK_SET&lt;/code&gt;，&lt;code&gt;offset&lt;/code&gt;为调用&lt;code&gt;ftell&lt;/code&gt;返回的值时进行的指针位置重置情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;fsetpos&lt;/code&gt;/&lt;code&gt;fgetpos&lt;/code&gt;和&lt;code&gt;fseek&lt;/code&gt;/&lt;code&gt;ftell&lt;/code&gt;感觉很像，刚开始觉得他们可以用来互相替换，&lt;code&gt;fsetpos&lt;/code&gt;也可以用来实现随机访问，后来发现错了，&lt;code&gt;fseek&lt;/code&gt;之所以能够实现随机访问文件是因为可以传入一个整型的参数作为文件偏移，而&lt;code&gt;fsetpos&lt;/code&gt;接收的参数是&lt;code&gt;fpos_t *&lt;/code&gt;，这个&lt;code&gt;fpos_t&lt;/code&gt;只能使用通过&lt;code&gt;fgetpost&lt;/code&gt;返回的值，不能直接指定，所以两者还是有区别的。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Aug 2020 16:14:00 +0000</pubDate>
<dc:creator>CN_Simo</dc:creator>
<og:description>关于文件操作个人比较困惑的地方有两点： 关于w和wb的区别 如何定位文件的读写位置 文件格式和打开模式 c中的文件打开模式分为：文本模式和二进制模式，分别处理文本格式文件和二进制格式文件。 两个模式的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lxmwb/p/13547862.html</dc:identifier>
</item>
<item>
<title>Dubbo源码学习之-通过源码看看dubbo对netty的使用 - 淡墨痕</title>
<link>http://www.cnblogs.com/zzq6032010/p/13473038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzq6032010/p/13473038.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    前段时间，从头开始将netty源码了解了个大概，但都是原理上理解。刚好博主对dubbo框架了解过一些，这次就以dubbo框架为例，详细看看dubbo这种出色的开源框架是如何使用netty的，又是如何与框架本身逻辑进行融合的。&lt;/p&gt;
&lt;p&gt;    本文分成两大部分，一部分是dubbo服务端对netty的封装，一部分是dubbo客户端对netty的封装，而每部分都分netty初始化和调用两个阶段，下面进入正题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Dubbo服务端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    Dubbo服务端对netty的调用始于服务导出，服务导出的流程之前文章中有介绍，详见【&lt;a href=&quot;https://www.cnblogs.com/zzq6032010/p/11275478.html&quot;&gt;https://www.cnblogs.com/zzq6032010/p/11275478.html&lt;/a&gt;】，在服务导出的最后，会调用DubboProtocol#openServer方法，就是在此方法中完成的netty服务端的初始化（本文均以配置了netty通信为前提），下面就以该处作为起点探寻。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、服务端初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    openServer方法源码如下，主体逻辑是先获取了address作为key---ip:port格式的字符串，然后做了一个双重检查，server不存在则调createServer创建一个放入serverMap中。到这里我们可以知道，&lt;strong&gt;dubbo服务提供者中一个ip+端口对应一个nettyServer，所有的nettyServer统一放在一个ConcurrentHashMap中维护了起来&lt;/strong&gt;。但其实通常情况下，一个服务提供者的服务器，只会暴露一个端口给dubbo用，故虽然用Map存起来，但一般只会有一个nettyServer。此处还要注意，dubbo中是暴露一个服务提供者执行一次export方法，即一个服务提供者接口触发一次openServer方法、对应一个nettyServer，下面跟进server的创建过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; openServer(URL url) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; find server.&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         String key =&lt;span&gt; url.getAddress();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;client can export a service which's only for server to invoke&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; isServer = url.getParameter(IS_SERVER_KEY, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isServer) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             ProtocolServer server =&lt;span&gt; serverMap.get(key);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     server =&lt;span&gt; serverMap.get(key);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                        serverMap.put(key, createServer(url));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; server supports reset, use together with override&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                server.reset(url);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    openServer调用的方法栈如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1558028/202008/1558028-20200812223902528-201381214.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    进入NettyTransporter的bind方法，NettyTransporter一共有两个方法-bind和connect，&lt;strong&gt;前者初始化服务端时调用，后者初始化客户端时触发&lt;/strong&gt;，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NettyTransporter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Transporter {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String NAME = &quot;netty&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; RemotingServer bind(URL url, ChannelHandler listener) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingException {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyServer(url, listener);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Client connect(URL url, ChannelHandler listener) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingException {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyClient(url, listener);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    下面看NettyServer如何与netty关联起来的。先看下NettyServer的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1558028/202008/1558028-20200812225752713-747559641.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     有经验的园友看到类图估计就能猜到，此处是源码框架中常用的分层抽象，AbstractServer作为一个模板的抽象，继承它之后可以扩展出其他类型的通信，比如MinaServer、GrizzlyServer。下面回到本文的主角NettyServer，看看其构造器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; NettyServer(URL url, ChannelHandler handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME), ChannelHandlers.wrap(handler, url));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    设置了一下url中的线程名参数，将handler和url进行了封装，然后调用了父类AbstractServer的构造器。&lt;/p&gt;
&lt;p&gt;    到这里，需要确定好入参的handler类型和传给父类构造器的handler类型。NettyServer构造器&lt;strong&gt;入参ChannelHandler是在HeaderExchanger#bind中封装的&lt;/strong&gt;，方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ExchangeServer bind(URL url, ExchangeHandler handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HeaderExchangeServer(Transporters.bind(url, &lt;span&gt;new&lt;/span&gt; DecodeHandler(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HeaderExchangeHandler(handler))));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    再进一步，bind方法入参ExchangeHandler的实现类要追溯到DubboProtocol，是其成员变量requestHandler如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; ExchangeHandler requestHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExchangeHandlerAdapter() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略若干个重写的方法逻辑&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    至此，NettyServer构造器入参ChannelHandler的类型已经确认了，其内部最终实现是DubboProtocol中的ExchangeHandlerAdapter，外部封装了一层HeaderExchangeHandler，又封装了一层DecodeHandler。简图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1558028/202008/1558028-20200812234815556-39977214.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     搞清楚NettyServer构造器入参的ChannelHandler之后，下面跟进ChannelHandlers.wrap方法，最终封装方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ChannelHandler wrapInternal(ChannelHandler handler, URL url) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MultiMessageHandler(&lt;span&gt;new&lt;/span&gt; HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;                .getAdaptiveExtension().dispatch(handler, url)));
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    而Dispatcher默认是AllDispatcher，其dispatch方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelHandler dispatch(ChannelHandler handler, URL url) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AllChannelHandler(handler, url);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    至此，ChannelHandlers.wrap方法执行完后得到的ChannelHandler结构如下，采用的是装饰器模式，层层装饰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1558028/202008/1558028-20200812235900269-41556396.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     了解清楚了wrap方法，下面回到主线，进入AbstractServer的构造器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; AbstractServer(URL url, ChannelHandler handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、调用父类构造器将这两个变量存起来，最终是存在了AbstractPeer中&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(url, handler);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、设置两个address&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         localAddress =&lt;span&gt; getUrl().toInetSocketAddress();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         String bindIp =&lt;span&gt; getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; bindPort =&lt;span&gt; getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (url.getParameter(ANYHOST_KEY, &lt;span&gt;false&lt;/span&gt;) ||&lt;span&gt; NetUtils.isInvalidLocalHost(bindIp)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             bindIp =&lt;span&gt; ANYHOST_VALUE;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         bindAddress = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketAddress(bindIp, bindPort);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.accepts =&lt;span&gt; url.getParameter(ACCEPTS_KEY, DEFAULT_ACCEPTS);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.idleTimeout =&lt;span&gt; url.getParameter(IDLE_TIMEOUT_KEY, DEFAULT_IDLE_TIMEOUT);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、完成netty源码的调用-开启netty服务端&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            doOpen();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略异常处理&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4、获取/创建线程池&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         executor =&lt;span&gt; executorRepository.createExecutorIfAbsent(url);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    1/2的逻辑较简单，3和4才是重点，下面进入3处的doOpen方法，doOpen方法在AbstractServer中是抽象方法，所以要到其子类NettyServer中看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doOpen() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里可以看到熟悉的netty代码了&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         bootstrap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerBootstrap();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bossGroup一个线程&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         bossGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(1, &lt;span&gt;new&lt;/span&gt; DefaultThreadFactory(&quot;NettyServerBoss&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; workerGroup线程数取的CPU核数+1与32的小值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         workerGroup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; DefaultThreadFactory(&quot;NettyServerWorker&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ***1、此处将NettyServer封装进NettyServerHandler中，实现了netty和dubbo的连接&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; NettyServerHandler nettyServerHandler = &lt;span&gt;new&lt;/span&gt; NettyServerHandler(getUrl(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         channels =&lt;span&gt; nettyServerHandler.getChannels();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; netty封装&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        bootstrap.group(bossGroup, workerGroup)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 .channel(NioServerSocketChannel.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 .childHandler(&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;NioSocketChannel&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initChannel(NioSocketChannel ch) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         &lt;span&gt;int&lt;/span&gt; idleTimeout =&lt;span&gt; UrlUtils.getIdleTimeout(getUrl());
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         NettyCodecAdapter adapter = &lt;span&gt;new&lt;/span&gt; NettyCodecAdapter(getCodec(), getUrl(), NettyServer.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (getUrl().getParameter(SSL_ENABLED_KEY, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                             ch.pipeline().addLast(&quot;negotiation&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                                    SslHandlerInitializer.sslServerHandler(getUrl(), nettyServerHandler));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        ch.pipeline()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                                 .addLast(&quot;decoder&quot;&lt;span&gt;, adapter.getDecoder())
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                                 .addLast(&quot;encoder&quot;&lt;span&gt;, adapter.getEncoder())
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                                 .addLast(&quot;server-idle-handler&quot;, &lt;span&gt;new&lt;/span&gt; IdleStateHandler(0, 0&lt;span&gt;, idleTimeout, MILLISECONDS))
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                                 .addLast(&quot;handler&quot;&lt;span&gt;, nettyServerHandler);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绑定IP和端口，此处用到的就是AbstractServer中的bindAddress变量&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         ChannelFuture channelFuture =&lt;span&gt; bootstrap.bind(getBindAddress());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        channelFuture.syncUninterruptibly();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         channel =&lt;span&gt; channelFuture.channel();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     标星号***的1处就是关键点，看下面的pipeline.addLast可知，存放着dubbo逻辑的NettyServer被封装进了NettyServerHandler中，进而放入了pipeline里面，当有客户端连接的时候就会触发这个nettyServerHandler中的对应方法，进入dubbo的接口调用逻辑。&lt;strong&gt;从dubbo功能到netty框架之间的连接者就是这个NettyServerHandler类&lt;/strong&gt;。NettyServer中封装了一个线程池，即一个客户端连接过来之后，服务端用一个线程池来接收处理这个客户端的一系列请求，即在netty原有线程模型基础上又加了一层线程池。&lt;/p&gt;
&lt;p&gt;     4中的executorRepository.createExecutorIfAbsent(url)用于生成线程池，此处为服务端，点进去源码可以发现在dubbo的服务端，一个port端口对应一个线程池，而且此处未设置特殊的参数，故走ThreadPool的默认类型fixed，即FixedThreadPool的getExecutor方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Executor getExecutor(URL url) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         String name =&lt;span&gt; url.getParameter(THREAD_NAME_KEY, DEFAULT_THREAD_NAME);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; threads =&lt;span&gt; url.getParameter(THREADS_KEY, DEFAULT_THREADS);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; queues =&lt;span&gt; url.getParameter(QUEUES_KEY, DEFAULT_QUEUES);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(threads, threads, 0&lt;span&gt;, TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 queues == 0 ? &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;() :
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                         (queues &amp;lt; 0 ? &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                                 : &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(queues)),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; NamedInternalThreadFactory(name, &lt;span&gt;true&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbortPolicyWithReport(name, url));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    该方法可关注两点：线程数默认为200个，阻塞队列由于queues==0采用的是SynchronousQueue。这个线程池初始化之后干啥用？搜遍了调用关系，发现只有在NettyServer进行重置或者关闭时才会操作这个线程池。但理论上讲不通啊，总不能创建了一个线程池之后只是为了关闭它。且往下看。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、服务端调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    其实服务端的线程池这里给博主看源码一个启发，注意，此处是&lt;strong&gt;去仓库获取一个线程池的引用&lt;/strong&gt;（即executorRepository.createExecutorIfAbsent(url)），而仓库创建了线程池是将其缓存了起来，而&lt;strong&gt;缓存之后的线程池引用还可以暴露给其他地方，在其他地方执行线程池的execute方法&lt;/strong&gt;。具体在这里，最终是在AllChannelHandler中调用的线程池，比如connected方法，如下所示，getExecutorService方法就是去仓库中获取了服务端的这个线程池，封装出一个ChannelEventRunnable丢给线程池执行。而服务端接收到请求时的received方法也是同样的处理流程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public void connected(Channel channel) throws RemotingException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         ExecutorService executor = getExecutorService()&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        try {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED))&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        } catch (Throwable t) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             throw new ExecutionException(&quot;connect event&quot;, channel, getClass() + &quot; error when process connected event .&quot;, t)&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     下面结合netty的调用流程对服务调用时的处理流程做一个梳理：在之前讲解netty的run方法一文【&lt;a href=&quot;https://www.cnblogs.com/zzq6032010/p/13122483.html&quot;&gt;https://www.cnblogs.com/zzq6032010/p/13122483.html&lt;/a&gt;】中有过介绍，netty的ServerBootstrap启动后，会开启bossGroup中的那个线程（即Reactor线程），一直执行run方法。而当有客户端要连接时，select方法会从操作系统获取到一个连接事件，Reactor线程会为该连接方创建一个NioSocketChannel，并从workerGroup中挑选一个线程，运行run方法，该线程用于处理服务端与这个客户端的后续通讯。而此处添加进pipeline中的nettyServerHandler会在客户端传来读写请求时触发对应的方法。最终调用到上述AllChannelHandler中的对应方法，用线程池执行后续业务逻辑。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、Dubbo的客户端&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、客户端初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    dubbo客户端初始化时会调用RegistryProtocol的refer方法，几经周折，最后到了DubboProtocol的protocolBindingRefer方法，如下，其中第5行调用的getClients方法是与netty整合的重点，即生成连接服务端的客户端。注意此处是在客户端中每一个引入的服务接口对应一个DubboInvoker。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; protocolBindingRefer(Class&amp;lt;T&amp;gt; serviceType, URL url) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RpcException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        optimizeSerialization(url);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create rpc invoker.&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         DubboInvoker&amp;lt;T&amp;gt; invoker = &lt;span&gt;new&lt;/span&gt; DubboInvoker&amp;lt;T&amp;gt;(serviceType, url, getClients(url), invokers);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为每个invoker生成对应的nettyClient&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        invokers.add(invoker);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invoker;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    继续跟进，会进入NettyTransporter的connect方法，到这里应该会很熟悉，因为服务端初始化时调用的是该类下面的bind方法。bind方法初始化的是NettyServer对象，而connect初始化的是NettyClient对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NettyTransporter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Transporter {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String NAME = &quot;netty&quot;&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RemotingServer bind(URL url, ChannelHandler listener) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyServer(url, listener);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Client connect(URL url, ChannelHandler listener) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyClient(url, listener);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    NettyClient的类图结构与NettyServer类似：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1558028/202008/1558028-20200822121309229-91275136.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    下面看NettyClient的构造器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; NettyClient(&lt;span&gt;final&lt;/span&gt; URL url, &lt;span&gt;final&lt;/span&gt; ChannelHandler handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; you can customize name and type of client thread pool by THREAD_NAME_KEY and THREADPOOL_KEY in CommonConstants.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the handler will be warped: MultiMessageHandler-&amp;gt;HeartbeatHandler-&amp;gt;handler&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(url, wrapChannelHandler(url, handler));
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    直接调用了父类构造器，其中wrapChannelHandler方法与NettyServer中的一样，不再赘述。下面看父类构造器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; AbstractClient(URL url, ChannelHandler handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(url, handler);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         needReconnect = url.getParameter(Constants.SEND_RECONNECT_KEY, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、初始化客户端线程池&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        initExecutor(url);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             doOpen(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、创建客户端的Bootstrap&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略异常处理&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、连接Netty服务端&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            connect();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RemotingException t) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略异常处理&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            close();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抛异常&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    主要有三步，已经在上面标出，下面分别跟进这三个方法。&lt;/p&gt;
&lt;p&gt;1)、initExecutor方法直接先将线程池类型添加进url中，客户端默认是Cached类型，所以在调用executorRepository.createExecutorIfAbsent(url)时会进入CachedThreadPool中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initExecutor(URL url) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         url =&lt;span&gt; ExecutorUtil.setThreadName(url, CLIENT_THREAD_POOL_NAME);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         url =&lt;span&gt; url.addParameterIfAbsent(THREADPOOL_KEY, DEFAULT_CLIENT_THREADPOOL);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         executor =&lt;span&gt; executorRepository.createExecutorIfAbsent(url);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    CachedThreadPool代码如下，可见是创建的核心线程数为0最大线程数无上限的线程池，阻塞队列默认SynchronousQueue。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CachedThreadPool &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ThreadPool {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Executor getExecutor(URL url) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         String name =&lt;span&gt; url.getParameter(THREAD_NAME_KEY, DEFAULT_THREAD_NAME);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; cores =&lt;span&gt; url.getParameter(CORE_THREADS_KEY, DEFAULT_CORE_THREADS);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; threads =&lt;span&gt; url.getParameter(THREADS_KEY, Integer.MAX_VALUE);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; queues =&lt;span&gt; url.getParameter(QUEUES_KEY, DEFAULT_QUEUES);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; alive =&lt;span&gt; url.getParameter(ALIVE_KEY, DEFAULT_ALIVE);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(cores, threads, alive, TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 queues == 0 ? &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;() :
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         (queues &amp;lt; 0 ? &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                                 : &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(queues)),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; NamedInternalThreadFactory(name, &lt;span&gt;true&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbortPolicyWithReport(name, url));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2)、doOpen方法&lt;/p&gt;
&lt;p&gt;    实现逻辑在NettyClient中，都是正常的封装，变化的地方是将NettyClientHandler放入pipeline中。注意此处只是将Bootstrap初始化，但并未触发与服务端的连接。&lt;/p&gt;
&lt;p&gt;3)、connect方法&lt;/p&gt;
&lt;p&gt;    该方法最终在NettyClient的doConnect方法中调用了bootstrap的connect方法，完成与服务端的连接。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、客户端调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    在消费端调用服务端接口或者接收到服务端的返回结果时，均会触发NettyClientHandler中对应的方法，而此处跟NettyServerHandler类似，最终都是在AllChannelHandler中获取之前创建的客户端线程池（Cached类型的），用该线程池进行后续操作。&lt;/p&gt;
&lt;p&gt;     最后，来一张示意图做个调用的总结：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1558028/202008/1558028-20200822223254011-409590647.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 22 Aug 2020 15:03:00 +0000</pubDate>
<dc:creator>淡墨痕</dc:creator>
<og:description>前言 前段时间，从头开始将netty源码了解了个大概，但都是原理上理解。刚好博主对dubbo框架了解过一些，这次就以dubbo框架为例，详细看看dubbo这种出色的开源框架是如何使用netty的，又是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzq6032010/p/13473038.html</dc:identifier>
</item>
<item>
<title>从实际项目出发，浅淡什么是设计空间 - bluesky234</title>
<link>http://www.cnblogs.com/Pray4U/p/13547416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Pray4U/p/13547416.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;本人从事小微企业信息化工作已经有10余年了，自己的一个小工作室带着如流水一样的成员开发了一个又一个的项目。在十余年的经历中，我自行研发了一套基于ASP.NET的框架。这套框架从V1到V8体现的是我对软件工程理解的加深，回顾过去，8个版本的框架可以看出我的技术学习走向，也能看出每套框架的设计空间大小，更能看出基于框架开发应用程序的简单程度。那正好，我最近在研发V8的框架中，对这些内容也有了更深的思考和总结。写出来与大家一起分享。&lt;/p&gt;

&lt;p&gt;第一节：背景&lt;/p&gt;
&lt;p&gt;本文所述的概念是有背景和使用范围的。针对的是小工作室开发项目而不是制作产品。由于我所在的团队属于工作室性质，队员的流动性极高。同时，我所涉及的项目大部分是短平快类型的，在统计我所有项目的开发时间后发现我花费时间最多的居然是升级框架，其次才是小型项目。那么，在这个大前提下，我不方便使用自动化构建工具。因为众所周知，自动化构建最麻烦的就是项目一开始的配置工作且这种东西学习成本非常高。如果是产品，那么学习/配置一次你可以永久使用。而我的项目使用自动化构建就有鸡肋（事实上我只对前端使用自动化构建）。&lt;/p&gt;
&lt;p&gt;在此前提下，我的大部分项目都共用一个解决方案，我没有人手单独维护框架项目。只能是在不停的开发和使用过程中，更新项目框架（释放设计空间）。直到有一天，这个框架的设计空间使用完毕，直接重构然后换下一个继续。&lt;/p&gt;
&lt;p&gt;其实，这种构架并不健康。我看了一下，好像也没什么人专门研究这种团队。大部分人认为这种团队其实是失败的，活不久的，同时也是做不大的。不过呢，我见到的不少小型团队都处于这个状态下。毕竟，也不是所有人都能脑子一拍想出一个非常好的产品。哪怕有非常好的产品也不是所有人都能拿到投资。&lt;/p&gt;
&lt;p&gt;于是，本文所对应的团队背景一定要符合以下条件：&lt;/p&gt;
&lt;p&gt;1、你所在的团队开发的是一系列有共性的项目（比如都是CMS，或者都是MIS）；&lt;/p&gt;
&lt;p&gt;2、你所在的团队一定是小微团队（5-10人），并且没有足够的人手维护框架；&lt;/p&gt;
&lt;p&gt;3、你所在的团队流动性很大，团队成员的水平参差不齐，且学习成本高；&lt;/p&gt;
&lt;p&gt;4、你的经费非常宝贵，也许你团队的主要支出就是工资；&lt;/p&gt;
&lt;p&gt;5、你在团队中拥有一定的话语权。&lt;/p&gt;

&lt;p&gt;第二节：什么是设计空间&lt;/p&gt;
&lt;p&gt;这是一个我自己对软件架构稳定性的一个定义。设计空间指的在框架代码中，插入多少业务代码且不会影响框架的稳定性和复用性的空间。他有两个子概念，在何处插件代码不会影响框架的稳定性和复用性？插入什么样的代码不会影响稳定性和复用性？总的来说，插件代码的位置数目和代码形式就是设计空间的大小评判标准。&lt;/p&gt;

&lt;p&gt;我对“设计空间”的定义进行一个详细的解释：&lt;/p&gt;
&lt;p&gt;1、添加的代码必须是面向业务的&lt;/p&gt;
&lt;p&gt;软件的代码大致可以分为两大类：业务代码和框架代码。所谓框架代码，指的是可复用的代码，基本上在所有你所在的业务领域中都有的。比如，我专注于制作校企信息化系统。那么在这种系统中，无论哪个都会有：用户，角色，权限和组织机构。而无论哪个系统的用户一定有ID，姓名，学/工号，用户名和密码。那么这些类，这些字段就是属于框架代码，他们是可以复用的，而框架代码不会占用设计空间。&lt;/p&gt;
&lt;p&gt;业务代码指的是专注于某个具体业务的，比如在V3框架时代，我还是一个做学校网站的萌新。当时我开发了“某校网上展馆v1.0”系统。该系统分属于CMS系统，当时做的时候还是使用三层架构。在该系统中，拥有一个类“展板”。那么对于这个类和我所在的业务领域中，除了这个项目，再其它任何项目中我都找不到需要使用这个类的地方。那么这个类就使用了我V3框架的设计空间。&lt;/p&gt;

&lt;p&gt;2、添加后的代码必须会影响架构的稳定性或复用性&lt;/p&gt;
&lt;p&gt;由于是小型化团队，你没有可用的人手维护框架项目。所以，在这种情况下使用自研框架（不要问我为什么不用成品框架，2010年我开始工作的时候，ASP.NET的框架简直没法看），为了保证代码的复用和更新，你唯一的作法就是把所有项目都引用同一个框架部分。比如，在我的V3版本框架中，6个项目都使用了同一个Model。我现在已经没有那时候的设计工具了，直接截个图给大家看看。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/203115/202008/203115-20200822221128101-1129612375.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1 所有项目所共有的Context&lt;/p&gt;

&lt;p&gt;在这种情况下，你每增加一个类（一张表）都会使用设计空间。因为除了框架中所需要的类，其它任何类你都无法复用。而小团队有个非常麻烦的问题——人员流动性大，学习成本高。也就意味着，一个新人来到你的团队很可能需要两周甚至三周的学习。这种学习时间和过程，他们就会碰到一堆其实根本用不到的类。所以，在这种情况下，我认为这些类侵占了框架的设计空间。&lt;/p&gt;
&lt;p&gt;再举个例子，比如V3框架的工作流模块，使用的还是WWF。在这里，我写了很多自定义的活动：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/203115/202008/203115-20200822221138177-305063458.jpg&quot; alt=&quot;&quot; width=&quot;1481&quot; height=&quot;570&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2 V3工作流模块中的某个活动&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;请注意，这些活动的复用性绝对是0。因为他们是针对业务开发的，只有在“某校实验室管理系统”项目中，这些活动才有使用的可能。后来者不需要阅读此模块，但需要学习模块中的一些写法。于是他们的存在就非常尴尬，删也不是，不删也不是。他们也侵占了设计空间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;除了这种情况，还有一些代码会影响架构的稳定性。这里需要介绍一下，构架的稳定性和软件的可靠性是不一样的。架构的稳定性指的是需求的变更和代码的变更对软件系统影响大小，这是一个经验量。软件的可靠性指的是在具体的使用环境中，软件系统一段时间内的出错次数（或者说鲁棒性），这是可以量化的。本文讨论的是稳定性。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这一次来到了V4框架，构架的背景是2015年，那时我对RBAC系统的理解还非常浅，并且完全不懂Claim-based的构架。在这种情况下，我们来看一下获取用户函数的实现：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/203115/202008/203115-20200822221211173-1680443213.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3 影响稳定性的代码&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;观察上述代码，可以看到user.IsInRole直接把具体需要的角色写在了SecurityService的类里。这是一个完全无法接受的行为，因为，根据统计数字显示，我的框架获取用户的组件调用的就是本函数取数据，而这个组件每天需要被调用数万次。而哪怕换了一个系统，取用户还是这个函数，还是这套代码。那么，换了一个系统还会有“教务处管理员”吗？显然，这是不可能的。再比如，哪天教务处要添加一个新的角色，比如“创新学分管理员”，对就是上述代码里的OR后面的东西。那我需要修改所有受影响的代码，那这种构架就是不稳定的。而编写这种代码，就是在释放设计空间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第三节：设计空间的意义和度量&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;设计空间是我评判一套框架好坏的重要指标，设计空间的意义在于我对系统可以做出多少破坏，也在于我可以对系统进行多少修改。设计空间大的系统，在面临需求变更时，可以通过释放一部分设计空间来换取最高效的修改速度。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;而如何度量设计空间？我一般使用插入点的数目来定大小。我翻阅框架代码就会去理解哪些代码中是可以通过插入业务代码来实现最快速修改需求的目的。把这些数目加起来，就是我度量设计空间的方法。根据我本人的实践而言，设计空间的大小不应该小于需求功能总数的1.5倍。比如V4框架的用户模块设计空间在经过衡量以后就只有20左右。而开发一个用户模块，我就说的简单一点，用户，角色，权限和组织机构的CRUD就有16个。那么在这种情况下，新来的需求虽然也可以通过本框架实现，但修改的时候就会感觉束手束脚，哪都不方便。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;比如，还是上述例子。其实最早的函数（设计空间为2）是长这样的：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/203115/202008/203115-20200822221236764-605538738.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这个函数的设计空间就很大（大小为2，基本就是我注释的地方）。因为他完全是不基于业务的。也可以看到，当实际的需求来临的时候（即只有“教务处管理员”等角色才可以根据学号的一部分找到用户，而其它角色只能通过输入完全的学/工号才能找到用户），我可以通过释放设计空间的形式，将上述代码快速复制一份并且变成图3的样式。这一修改可以在5分钟内完成，10分钟内部署，那客户就会认为你的业务能力强，能够快速按他们的要求修改系统。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;所以，维持设计空间的最终目的是为了可以快速的按变更后的需求修改系统。设计空间的大小于与修改需求变更的时间成反比。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第四节：设计空间的释放和侵占&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;设计空间既然被定义出来，那一定就是为了被占用的。所以，何时使用设计空间就是一个非常重要的事。我认为，在项目的开发和设计阶段，使用设计空间就是一件非常不好的事。因为这时，明明可以通过对系统设计的修改而保住这些设计空间，甚至可以为将来的修改留下足够的空间。所以，在这种情况下使用设计空间，我称之为：侵占。即，你本来可以不使用，但却使用了将来的空间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;而在项目实际运行后，由于需求的变化你可能需要以最快的速度响应这些变化。这时，你就要根据实际需求释放设计空间。比如，今天来了一个重要需求，领导要求你半天必须解决。这是，观察需求一看之前留下了设计空间。那就可以通过直接释放的形式使用这些空间来快速完成项目。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;那么，非常容易理解和想到的一点就是。当一个系统的设计空间被释放的差不多时，也就是这个系统应当重构的时候。重构时，不光要把之前的设计空间还回去。还需要根据未来需求变化的可能和方向重新预留设计空间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第五节：总结&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;设计空间的本质是拥抱变化，最终目的是快速修改变化的需求。他体现着开发者对需求未来变更可能性的掌握程度。一个好的设计者可以在看到需求时就想到未来可能发生的需求变化。而使用设计空间的本质是开发者考虑不周或者因为其它原因的妥协，还是图3所示的例子，如果我当时就知道找用户有可能按角色有不同的找法，那么设计上直接给予权限“按部分学/工号查询用户”，使用时，我只要配置哪个角色有此权限即可（即，V5框架中就有）。那么，当需求变更发生时，我就不需要使用设计空间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;需要知道一点，研发系统是有时间成本的。设计者哪怕在考虑到需求未来变更可能性的时候，也不可能将所有可能性都留下接口和设计（时间成本不接受，开发成本也不定接受）。所以，这时可以留下一个设计空间，在未来需求变更时，直接通过释放设计空间的形式也能快速达成修改需求的目的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;诸位如果对这个有兴趣的话，不妨可以留言讨论。如果有兴趣的人多的话，我接下来就再写写如何在“设计空间的预留和使用”。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Aug 2020 14:14:00 +0000</pubDate>
<dc:creator>bluesky234</dc:creator>
<og:description>前言： 本人从事小微企业信息化工作已经有10余年了，自己的一个小工作室带着如流水一样的成员开发了一个又一个的项目。在十余年的经历中，我自行研发了一套基于ASP.NET的框架。这套框架从V1到V8体现的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Pray4U/p/13547416.html</dc:identifier>
</item>
<item>
<title>安全可靠国产系统背景下的应用开发应有.NET Core的一席之地 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/13547269.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/13547269.html</guid>
<description>&lt;p&gt;在中美当前背景下的安全可靠国产系统(简称安可)，安可产业要实现技术自主可控，需要在四个层面逐步实现：基础硬件设施，如芯片、服务器、存储、交换机、路由器；底层软件，包括操作系统、数据库、中间件等；应用软件，面向实际应用的不同领域；安全产品，保障边界安全、终端安全和管理安全产品。目前在安可领域，高端芯片服务器等硬件已能基本满足办公需求；基础软件正在实现国产化替代。而在国产系统下，应用生态便显得匮乏了。&lt;/p&gt;
&lt;p&gt;实现应用软件从普通环境到安可操作系统环境的平滑过渡，是丰富国产应用生态、推动安可生态从“可用”走向“好用”的重要手段。国内众多应用软件开发商也正在安可这一领域展开激烈竞争，今天想写下这篇文章是源于在微信群里看到一个群友发的一页内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202008/510-20200822214346655-329873623.png&quot;&gt;&lt;img width=&quot;900&quot; height=&quot;534&quot; title=&quot;3603f494ba9aea4edae21a29770f03f&quot; alt=&quot;3603f494ba9aea4edae21a29770f03f&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202008/510-20200822214347347-456194908.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个内容明显就是要封杀在这家公司的产品国产化改造中使用.NET Core 。首先这篇内容的非常不专业，把国产化的开发语言给限制了，而且把开发平台等同于开发语言， C#才是.NET Core的主要开发语言之一。 操作系统也没有选择安可联盟的操作系统，数据库也一样，只是特别的针对微软的产品。其次这位同学对.NET Core认识还是等同于10年的.NET,殊不知.NET Core是一个开源跨平台的开发平台，.NET Core是更加符合安可标准的开发平台。&lt;/p&gt;

&lt;p&gt;最近我们也在测试龙芯MIPS64的.NET Core移植工作，我们也建立一个微信群，群里都是对龙芯的.NET Core移植工作热心的同学，昨天我把这个内容转发到微信群，其中有一位群友的总结很到位，这里我就摘录出来和大家分享：&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;br/&gt;相比java，.netcore/.net5+、mono才是最安全可靠的选择。一是它们是最最开放的MIT/Apache2协议开源；二是它们归属于中立的第三方组织.NET基金会 掌控，不属于任何商业公司，更不是“微软家”的。退一万步说，即使是微软家的，也远比oracle、Facebook、google家的安全可信可靠！微软一直中立温和没有政治色彩，更喜欢奉献，连它的敌人苹果的满血复活，微软也是尽了最大的帮助！&lt;/p&gt;

&lt;p&gt;技术上的先进要谈，更重要的要讲清“.net+”的彻底的开源协议、完整的专利免责、中立的主管机构三大超高特性！ 这三大超强开放特性，即“彻底的开源协议、完整的专利免除、中立的主管机构”，其他平台（java、golang）基本无法同时齐备这三个要素。三大要素缺任何一样，“安全可信可靠”(安可)就会大打折扣。&lt;/p&gt;

&lt;p&gt;这里有一点就是大家对微软和.NET的关系没搞明白，要多加宣传。微软是.net的初创者，.NET基金会的发起者，但.NET 基金会建立起来后，微软也把Mono/Xamarin给收购了，贡献给.NET基金会。微软只是.net基金的主要供奉者之首,在.NET基金会里还有很多大公司，google，aws，三星都在.NET基金会里。新.net/mono的“彻底的开源协议、完整的专利免除、中立的主管机构”三大关键特色以及与微软的关系一定要吃透讲清，广而告之。&lt;/p&gt;

&lt;p&gt;“安可”才是国产化的核心要义，所以大家不能只谈技术、只谈性能。在“安可”面前，技术和性能是可以让步的，况且 .NET Core性能还是如此之好，龙芯团队在这一方面是做出非常好的表率。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;.NET 在传统应用软件中一直都占有重要地位，.NET的主要竞争者也是Java，.NET Core和Java都是开源跨平台的，我们可以来比较一下.NET Core和Java的开源协议，.NET Core是以MIT协议开源， Java是GPL协议开源。 Java 8 SDK升级Oracle要收费这件事对于很多小公司是有着重大的影响的，虽然有众多的OpenJDK发行版，腾讯云和阿里都有OpenJDK发行版，龙芯也有MIPS版本的OpenJDK。众多没有能力开发维护OpenJDK的公司完全可以转向更具有竞争力的.NET Core，.NET Core从属于.NET基金会，由微软进行官方支持。.NET Core/Mono 使用最宽松的MIT和Apache 2开源协议，文档协议遵循CC-BY。这将允许任何人任何组织和企业任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版 权和许可提示，后者协议将会除了为用户提供版权许可之外，还有专利许可，并且授权是免费，无排他性的(任何个人和企业都能获得授权)并且永久不可撤销，用户使用.NET Core完全不用担心收费问题，你可以很自由的部署在任何地方,这也正是龙芯团队可以在.NET 上发力，为龙芯生态建设发力，龙芯支持了计算机上运行应用程序的动态虚拟机Java、Javascript、.NET三大虚拟机，龙芯还正在开发一套指令翻译系统，可以将其他指令集翻译成Loongarch指令。&lt;/p&gt;

&lt;p&gt;上面说的比较多的都是龙芯，目前在国产化这块更大的一个竞争者是ARM 体系，.NET Core对ARM32/64都有完备的支持，正好我也是华为云MVP，上周我也去华为云找鲲鹏生态的相关负责人沟通鲲鹏系统对.NET Core支持的情况，华为云也是苦于找不到.NET 支持方面能力强的合作伙伴，通过这次沟通，我正在申请成为华为云的市场服务商来和华为云一起推进鲲鹏对.NET Core应用的支持。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Aug 2020 13:44:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>在中美当前背景下的安全可靠国产系统(简称安可)，安可产业要实现技术自主可控，需要在四个层面逐步实现：基础硬件设施，如芯片、服务器、存储、交换机、路由器；底层软件，包括操作系统、数据库、中间件等；应用软</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/13547269.html</dc:identifier>
</item>
</channel>
</rss>