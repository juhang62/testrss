<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据结构之红黑树-动图演示(上) - 陆十三</title>
<link>http://www.cnblogs.com/newobjectcc/p/11293689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/newobjectcc/p/11293689.html</guid>
<description>&lt;p&gt;红黑树是比较常见的数据结构之一，在Linux内核中的完全公平调度器、高精度计时器、多种语言的函数库(如,Java的TreeMap)等都有使用。&lt;/p&gt;
&lt;p&gt;在学习红黑树之前，先来熟悉一下二叉查找树。&lt;/p&gt;
&lt;h2 id=&quot;二叉查找树binary-search-tree&quot;&gt;二叉查找树(Binary Search Tree)&lt;/h2&gt;
&lt;p&gt;二叉查找树，它有一个根节点，且每个节点下最多有只能有两个子节点，左子节点的值小于其父节点，右子节点的值大于其父节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803085825577-629272728.png&quot; alt=&quot;二叉查找树&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;插入节点&quot;&gt;插入节点&lt;/h3&gt;
&lt;p&gt;从根节点向下查找，当新插入节点大于比较的节点时，新节点插入到比较节点的右侧，当小于比较的节点时，插入到比较节点的左侧，一直向下比较大小，找到要插入元素的位置并插入元素。&lt;/p&gt;
&lt;p&gt;如图: 依次插入节点[100,50,200,80,300,10]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803091400407-1322764832.gif&quot; alt=&quot;插入节点&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;伪代码(来源Java TreeMap，有省略和修改):&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void put(K key, V value) {
     if (root == null) {
        root = new Node&amp;lt;&amp;gt;(key, value, null); 
        return;
    }       
    Node&amp;lt;K,V&amp;gt; t = root; 
    int cmp; // 比较结果    
    Node&amp;lt;K,V&amp;gt; parent;  
    Comparable&amp;lt;? super K&amp;gt; k = (Comparable&amp;lt;? super K&amp;gt;) key;
    do {
        parent = t;
        cmp = k.compareTo(t.key);
        if (cmp &amp;lt; 0)
            t = t.left;
        else if (cmp &amp;gt; 0)
            t = t.right;
        else
            return; // 节点存在直接返回
    } while (t != null);
    
    Node&amp;lt;K,V&amp;gt; e = new Node&amp;lt;&amp;gt;(key, value, parent);
    if (cmp &amp;lt; 0){
         parent.left = e;
    }else{
       parent.right = e;  
    }  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查找节点&quot;&gt;查找节点&lt;/h3&gt;
&lt;p&gt;从根节点开始向下查找，当查找节点大于比较的节点时，向右查找，当小于当前比较节点时，就向左查找。一直向下查找，直到找到对应的节点或到终点查找结束。&lt;/p&gt;
&lt;p&gt;如图: 查找节点[80]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803110643308-509746032.gif&quot; alt=&quot;查找节点&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;伪代码(来源Java TreeMap，有省略和修改):&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Node&amp;lt;K,V&amp;gt; getNode(Object key) {
    Comparable&amp;lt;? super K&amp;gt; k = (Comparable&amp;lt;? super K&amp;gt;) key;
    Node&amp;lt;K,V&amp;gt; p = root;
    while (p != null) {
        int cmp = k.compareTo(p.key);
        if (cmp &amp;lt; 0)
            p = p.left;
        else if (cmp &amp;gt; 0)
            p = p.right;
        else
            return p;
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除节点&quot;&gt;删除节点&lt;/h3&gt;
&lt;p&gt;删除节点首先要查找要删除的节点，找到后执行删除操作。&lt;/p&gt;
&lt;p&gt;删除节点的节点有如下几种情况：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;删除的节点有两个子节点&lt;/li&gt;
&lt;li&gt;删除的节点有一个子节点&lt;/li&gt;
&lt;li&gt;删除的节点没有子节点&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;case-1&quot;&gt;Case 1：&lt;/h4&gt;
&lt;p&gt;该种情况下，涉及到节点的“位置变换”，用右子树中的最小节点替换当前节点。从右子树一直 left 到 NULL。最后会被转换为 Case 2 或 Case 3 的情况。&lt;/p&gt;
&lt;p&gt;所以对于删除有两个孩子的节点，删除的是其右子树的最小节点，最小节点的内容会替换要删除节点的内容。&lt;/p&gt;
&lt;p&gt;如图:删除节点[50]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803111731338-1224090242.gif&quot; alt=&quot;删除节点-Case 1&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;case-2&quot;&gt;Case 2：&lt;/h4&gt;
&lt;p&gt;有一个子节点的情况下，将其父节点指向其子节点，然后删除该节点。&lt;/p&gt;
&lt;p&gt;如图:删除节点[200]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803111834308-2070132039.gif&quot; alt=&quot;删除节点-Case 2&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;case-3&quot;&gt;Case 3：&lt;/h4&gt;
&lt;p&gt;在没有子节点的情况，其父节点指向空，然后删除该节点。&lt;/p&gt;
&lt;p&gt;如图:删除节点[70]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803111948176-1042337598.gif&quot; alt=&quot;删除节点-Case 3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;伪代码(来源Java TreeMap，有省略和修改):&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Node remove(Object key) {
    // 查找节点(参考上面查找代码)
    Node&amp;lt;K,V&amp;gt; p = getNode(key); 
  
     // 节点变换。 p 有两个子节点，将其转换为删除后继节点
    if (p.left != null &amp;amp;&amp;amp; p.right != null) {
        Entry&amp;lt;K,V&amp;gt; s = t.right;
        while (s.left != null){
            s = s.left;
        }
        p.key = s.key;
        p.value = s.value;
        p = s;
    } 

    Entry&amp;lt;K,V&amp;gt; replacement = (p.left != null ? p.left : p.right);
    // p 有一个子节点
    if (replacement != null) {
        replacement.parent = p.parent;
        if (p.parent == null){
            root = replacement;
        }  else if (p == p.parent.left){
            p.parent.left  = replacement;
        } else{
            p.parent.right = replacement;
        }
        p.left = p.right = p.parent = null;

    } else if (p.parent == null) { // 根节点
       
         root = null;
    } else { //  p 没有子节点
       
         if (p == p.parent.left){
            p.parent.left = null;
        } else if (p == p.parent.right){
            p.parent.right = null;
        }
        p.parent = null;   
    } 
    return p;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;树的优势&quot;&gt;树的优势&lt;/h3&gt;
&lt;p&gt;我们知道，有序数组删除或插入数据较慢（向数组中插入数据时，涉及到插入位置前后数据移动的操作），但根据索引查找数据很快，可以快速定位到数据，适合查询。而链表正好相反，查找数据比较慢，插入或删除数据较快，只需要引用移动下就可以，适合增删。&lt;/p&gt;
&lt;p&gt;而二叉树就是同时具有以上优势的数据结构。&lt;/p&gt;
&lt;h3 id=&quot;该树缺点&quot;&gt;该树缺点&lt;/h3&gt;
&lt;p&gt;上面的树是非平衡树，由于插入数据顺序原因，多个节点可能会倾向根的一侧。极限情况下所有元素都在一侧，此时就变成了一个相当于链表的结构。&lt;/p&gt;
&lt;p&gt;如图:依次插入节点[100,150,170,300,450,520 ...]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803112059750-1915207427.gif&quot; alt=&quot;向一端倾斜&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种不平衡将会使树的层级增多（树的高度增加），查找或插入元素效率变低。&lt;/p&gt;
&lt;p&gt;那么只要当插入元素或删除元素时还能维持树的平衡，使元素不至于向一端严重倾斜，就可以避免这个问题。&lt;/p&gt;
&lt;p&gt;到此，红黑树闪亮登场， &lt;strong&gt;红黑树&lt;/strong&gt;就是一种平衡二叉树。&lt;/p&gt;
&lt;h2 id=&quot;红黑树red-black-tree&quot;&gt;红黑树（Red Black Tree）&lt;/h2&gt;
&lt;p&gt;红黑树是一种平衡二叉树，遵守如下规则来保证红黑树的平衡，保证每个节点在它左边的后代数目和在它右边的后代数目应该是大致相等（最长路径也不会超过最短路径的2倍）。&lt;/p&gt;
&lt;h3 id=&quot;红黑树的规则&quot;&gt;红黑树的规则&lt;/h3&gt;
&lt;p&gt;红黑树是在二叉查找树基础之上再遵循如下规则的树&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;每个节点颜色不是黑色就是红色&lt;/li&gt;
&lt;li&gt;根节点一定为黑色&lt;/li&gt;
&lt;li&gt;两个红色节点不能相邻（红色节点的子节点一定是黑色）&lt;/li&gt;
&lt;li&gt;从任意节点到叶子节点的每条路径包含的黑色节点数目相同（黑色高度）&lt;/li&gt;
&lt;li&gt;每个叶子节点(NULL节点，空节点)是黑色&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;当插入或删除节点时，必须要遵守红黑树的规则，根据这些规则来决定是否需要改变树的结构或节点颜色，使其达到平衡。&lt;/p&gt;
&lt;p&gt;查找节点并不影响树的平衡，所以红黑树的节点查找和二叉查找树的操作是一样的（请参考二叉查找树）。&lt;/p&gt;
&lt;p&gt;如图: 红黑树 - 依次插入节点[100,200,300,400,500,600,700,800]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803113549962-1113334054.gif&quot; alt=&quot;红黑树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终树的结构是大致平衡的，不像二叉查找树那样偏向一侧。&lt;/p&gt;
&lt;h3 id=&quot;了解变色和旋转&quot;&gt;了解变色和旋转&lt;/h3&gt;
&lt;p&gt;如果新插入元素或删除元素后，红黑树的规则被破坏，这时需要对树进行调整来重新满足红黑树规则。调整有&lt;strong&gt;变色&lt;/strong&gt;和&lt;strong&gt;旋转&lt;/strong&gt;（左旋或右旋）两种方式，接下来分别了解这两种方式：&lt;/p&gt;
&lt;p&gt;通过改变节点颜色修正红黑树，节点由红变黑或黑变红&lt;/p&gt;
&lt;p&gt;通过改变节点的位置关系修正红黑树&lt;/p&gt;
&lt;p&gt;如图: 以右旋为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803114156024-407898753.gif&quot; alt=&quot;旋转&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左旋则与右旋对称，为逆时针旋转。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601970/201908/1601970-20190803114340845-579032473.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中空节点位置可以是多个节点构成的子树，也可以是一个具体节点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右旋(来源Java TreeMap):&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void rotateRight(Entry&amp;lt;K,V&amp;gt; p) {
    if (p != null) {
        Entry&amp;lt;K,V&amp;gt; l = p.left;
        p.left = l.right;
        if (l.right != null) 
            l.right.parent = p;
        l.parent = p.parent;
        if (p.parent == null)
            root = l;
        else if (p.parent.right == p)
            p.parent.right = l;
        else p.parent.left = l;
        l.right = p;
        p.parent = l;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;左旋(来源Java TreeMap):&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void rotateLeft(Entry&amp;lt;K,V&amp;gt; p) {
    if (p != null) {
        Entry&amp;lt;K,V&amp;gt; r = p.right;
        p.right = r.left;
        if (r.left != null)
            r.left.parent = p;
        r.parent = p.parent;
        if (p.parent == null)
            root = r;
        else if (p.parent.left == p)
            p.parent.left = r;
        else
            p.parent.right = r;
        r.left = p;
        p.parent = r;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;红黑树的插入和删除节点请看下一篇：&lt;/strong&gt; 数据结构之红黑树-动图演示(下) - 更新中 ...&lt;/p&gt;
</description>
<pubDate>Fri, 16 Aug 2019 00:28:00 +0000</pubDate>
<dc:creator>陆十三</dc:creator>
<og:description>红黑树是比较常见的数据结构之一，在Linux内核中的完全公平调度器、高精度计时器、多种语言的函数库(如,Java的TreeMap)等都有使用。该文通过动画来讲解红黑树，好看到哭 ...</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/newobjectcc/p/11293689.html</dc:identifier>
</item>
<item>
<title>破解点评网字体反爬，深入挖掘系统背后的原理 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/11361601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/11361601.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055725487-1172660525.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上次数独（&lt;a href=&quot;https://www.cnblogs.com/moonhmily/p/11312887.html&quot;&gt;旁友数独会伐啦？python秒解数独了解下伐啦？&lt;/a&gt;）后，老王好像从哪里得到了风声，跟我说少往他们家带扑克牌……意思里你的家庭矛盾都是因为一副扑克牌咯？&lt;/p&gt;
&lt;p&gt;行，那我这段时间先歇一歇，来日方长……&lt;/p&gt;
&lt;p&gt;那闲着也是闲着，不能去隔壁了，也不能让小胖这双手停下来不是……&lt;/p&gt;
&lt;p&gt;那就上点评网找找妹子乐趣，然后就发现点评的反爬做的是真厉害。各个方面的反爬都有涉及，今天我们主要来看一下字体反爬这个玩意儿。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;操作系统：windows10&lt;/li&gt;
&lt;li&gt;python版本：python 3.7&lt;/li&gt;
&lt;li&gt;代码编辑器：pycharm 2018.2&lt;/li&gt;
&lt;li&gt;使用模块：requests,json,re,fontTools&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首选我们先来看一下点评网的评论信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055736297-467417637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这里可以看到，网页上显示的文字和源码中显示的文字有些出入，并不是一一对应，那继续查看sources中的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055740407-142515379.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，评论中的某些文字点评网做了特殊处理，这就是所谓的字体反爬。&lt;/p&gt;

&lt;p&gt;前面的步骤，我们已经知道点评网对评论内容做了处理，至于是如何处理，这里我们先不管，还是先把数据拿到再说。要是数据都没有拿到，还怎么对数据进行处理呢？&lt;/p&gt;
&lt;p&gt;首先使用谷歌的network，对所有请求进行抓包。然后随便搜索一个评论中的某些东西，找到返回的评论数据请求。这里我使用评论人的名字进行搜索，找到其中的请求。有没有觉得这个请求就是返回的评论数据呢。那来验证下。因为这里返回的是一个json数据，可以借助在线json数据查看工具，方便我们对内容进行查看。&lt;/p&gt;
&lt;p&gt;将数据复制下来，然后在浏览器中输入网址&lt;code&gt;json.cn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055746751-1582824797.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055755832-14210723.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着就能看到解析出来的json数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055802448-633227269.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过分析，我们知道所有的评论数据都在&lt;code&gt;['reviewAllDOList']&lt;/code&gt;，这个集合里装了当前页面前10人的评论数据。这样就可以通过列表遍历的方式拿到相应的数据。&lt;br/&gt;点击这个url的headers，找到请求的url，准备获取数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055824788-937779923.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个获取到的url只能使用一会儿，过一会就会变化。如果一直使用这个url请求，后面就会得不到数据。所以后续当请求不到数据的时候，就需要刷新网页，获取一个新的url。因为url中有个_token参数是每次变化的。&lt;/li&gt;
&lt;li&gt;然后下面框中的内容也必须在请求头中添加上去，否则也还是得不到数据。&lt;/li&gt;
&lt;li&gt;这里的重点是在字体反爬，所以其他的一些反爬在这里就不进行赘述了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此就找到请求的评论接口数据，直接请求这个url，就能得到我们想要的数据。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
import json
import re


def get_page_info():
    # 首先分析网页，找到返回评论数据的url，这个url就会直接返回评论数据了，但是urlt中的token是会变化的，只能用一会儿，我也不知道一会儿是好久,得不到数据了就换url吧
    url = 'http://www.dianping.com/ajax/json/shopDynamic/allReview?shopId=131013635&amp;amp;cityId=1604&amp;amp;shopType=10&amp;amp;tcv=7bbq1hdmsj&amp;amp;_token=eJxVTstugkAU%2FZe7nsBcBlBIulBrGxC0MmATTReACoSCFIg4Nv33Thu66Oq8k%2FMJrXMEGymlOhK4nlqwARWqmECg72RimAZOkFkTauoE0v%2BehRqBpN09gn1glkEmhv72YwRSH9BgJpma0hmpJqmmE%2B2348gK5H3f2Ko6DINyLOK6KepMSS%2BV2uWXRkWGFJnJDHkF5KQK5URiOWI8Yv%2BnfflddrsiqyU7ubeQd3r3cQ78Loyof58HQlgrzjXhpejxiHn3Zb%2BO%2BHUjFtOZCMrkOc%2Fi6lYlWbZbrLKeJ1u6RqfxUuaHhWitZb0Oy4RHrnveV0X6%2FhQ0VbPZvu5FOZ%2B91Oi4wwN8fQMlVWIi&amp;amp;uuid=c59d33fd-e043-a0f5-f6e1-79ae90d14254.1565007755&amp;amp;platform=1&amp;amp;partner=150&amp;amp;optimusCode=10&amp;amp;originUrl=http%3A%2F%2Fwww.dianping.com%2Fshop%2F131013635'


    # 定义模拟请求头
    headers = {
        'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',
        'Cookie': 'cy=8; cye=chengdu; _lxsdk_cuid=16c61bb35536e-0e2ab00cb9c2a8-c343162-144000-16c61bb35547b; _lxsdk=16c61bb35536e-0e2ab00cb9c2a8-c343162-144000-16c61bb35547b; _hc.v=c59d33fd-e043-a0f5-f6e1-79ae90d14254.1565007755; s_ViewType=10; __utmz=1.1565010551.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _lx_utm=utm_source%3DBaidu%26utm_medium%3Dorganic; __utma=1.1978331348.1565010551.1565010551.1565161172.2; __utmc=1; _lxsdk_s=16c6b1cf413-8ae-d6-7b8%7C%7C31',
        'Referer':'http://www.dianping.com/shop/131013635',
        'Connection': 'keep-alive',
    }


    # 使用requests库请求url，得到数据json数据
    result_json_str = requests.get(url,headers=headers).text
    # 应为返回的数据是里面包含富文本数据，所以首先使用正则表达式删除标签
    result_json_str = re.sub('&amp;lt;.*?&amp;gt;','',result_json_str)

    # json数据其实就是一个字符串，所以我们需要先将json转化为python能操作的字典
    result = json.loads(result_json_str)
    # 分析得到的数据，得到我们需要的所有评论在result['reviewAllDOList']里面
    all_review = result['reviewAllDOList']


    # 遍历得到的所有评论
    for review in all_review:
        # 得到用户名
        username = review['user']['userNickName']
        # 得到评论内容
        content = review['reviewDataVO']['reviewBody']
        # 这里我们就是简单的显示出内容就是了，没有进行储存
        print('*'*30,'\n',username,content,'\n','*'*30)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行代码，查看数据，得到的数据果然就是经过处理的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055833922-204772224.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面虽然拿到了数据，但是这些都是经过处理之后的数据，拿着完全不能用，所以还是得想办法将他给破解下。&lt;/p&gt;
&lt;p&gt;首先我们分析网页得知，这些处理之后的数据class都为review，然后他的字体都是&lt;code&gt;'PingFangSC-Regular-review'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055847507-1028369377.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;猜想这就是点评网自己定义的字体。居然自定义了字体，那么网页中肯定需要加载字体文件，所以果断打开network对字体文件进行抓包。&lt;/p&gt;
&lt;p&gt;搜索关键字&lt;code&gt;'PingFangSC-Regular-review'&lt;/code&gt;，就能找到相应的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055853796-1496944042.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，点评网有许多个自定义的字体，这里只需要找自己想要的字体文件即可，即找字体文件的url。只是这些字体文件一般都是.woff或者.ttf结尾的，我们可以将下面的滚动条往右边拖动，就能找到一个.woff的url了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055914239-595304072.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现这个url前面是以&lt;code&gt;//&lt;/code&gt;开始的，那尝试直接在网址前面加https就行了，那么完整的url就是&lt;br/&gt;&lt;code&gt;https://s3plus.meituan.net/v1/mss_73a511b8f91f43d0bdae92584ea6330b/font/c667da25.woff&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后在浏览器中输入这个网址，就可以下载一个后缀是.woff的字体文件。&lt;/p&gt;
&lt;p&gt;为了方便查看字体文件的内容，我们还需要下载fontCreator这个软件。使用这个软件打开我们刚才下载的文件，就能够看到相应的值。fontCreator官网地址为&lt;br/&gt;&lt;code&gt;https://www.high-logic.com/font-editor/fontcreator&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用fontCreator打开这个woff文件，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055921287-1388107641.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们得把这里面所有的文字按顺序都写出来，并用一个列表保存，空的数据使用''表示。&lt;br/&gt;是的，你没有看错，将这些文字全部写下。&lt;/p&gt;
&lt;p&gt;这些就是字体的形状，我们已经认识了这些字，但我们还得让程序也认识这些字，当然你也可以使用机器学习来识别这些文字，注意：一定要按顺序来，不能遗漏，不然的话对应关系会出错，替换出来的结果也就会出错。&lt;/p&gt;
&lt;p&gt;我们把文字敲出来之后，然后需要得到字体形状对应的名字，对应代码字符串。这里需要使用&lt;code&gt;fontTools&lt;/code&gt;这个第三方库来处理字体文件。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from fontTools.ttLib import TTFont


def get_font_map():
    # 这个字体文件需要先析网页，找到这个url，然后下载下来到本地，然后使用TTFont()加载字体文件 
    #       字体文件的名字
    font = TTFont('76d0609c.woff')
    # 得到cmap 字体对应代码-&amp;gt;字体名字
    font_cmap = font.getBestCmap()
    # 得到所有的字体名字
    font_names = font.getGlyphOrder()
    # 这个文字是先使用fontCreator软件打开字体文件，然后查看到字体，从而得到的数据
    texts = [
        '','','1','2','3','4','5','6','7','8',
        '9','0','店','中','美','家','馆','小','车','大',
        '市','公','酒','行','国','品','发','电','金','心',
        '业','商','司','超','生','装','园','场','食','有',
        '新','限','天','面','工','服','海','华','水','房',
        '饰','城','乐','汽','香','部','利','子','老','艺',
        '花','专','东','肉','菜','学','福','饭','人','百',
        '餐','茶','务','通','味','所','山','区','门','药',
        '银','农','龙','停','尚','安','广','鑫','一','容',
        '动','南','具','源','兴','鲜','记','时','机','烤',
        '文','康','信','果','阳','理','锅','宝','达','地',
        '儿','衣','特','产','西','批','坊','州','牛','佳',
        '化','五','米','修','爱','北','养','卖','建','材',
        '三','会','鸡','室','红','站','德','王','光','名',
        '丽','油','院','堂','烧','江','社','合','星','货',
        '型','村','自','科','快','便','日','民','营','和',
        '活','童','明','器','烟','育','宾','精','屋','经',
        '居','庄','石','顺','林','尔','县','手','厅','销',
        '用','好','客','火','雅','盛','体','旅','之','鞋',
        '辣','作','粉','包','楼','校','鱼','平','彩','上',
        '吧','保','永','万','物','教','吃','设','医','正',
        '造','丰','健','点','汤','网','庆','技','斯','洗',
        '料','配','汇','木','缘','加','麻','联','卫','川',
        '泰','色','世','方','寓','风','幼','羊','烫','来',
        '高','厂','兰','阿','贝','皮','全','女','拉','成',
        '云','维','贸','道','术','运','都','口','博','河',
        '瑞','宏','京','际','路','祥','青','镇','厨','培',
        '力','惠','连','马','鸿','钢','训','影','甲','助',
        '窗','布','富','牌','头','四','多','妆','吉','苑',
        '沙','恒','隆','春','干','饼','氏','里','二','管',
        '诚','制','售','嘉','长','轩','杂','副','清','计',
        '黄','讯','太','鸭','号','街','交','与','叉','附',
        '近','层','旁','对','巷','栋','环','省','桥','湖',
        '段','乡','厦','府','铺','内','侧','元','购','前',
        '幢','滨','处','向','座','下','県','凤','港','开',
        '关','景','泉','塘','放','昌','线','湾','政','步',
        '宁','解','白','田','町','溪','十','八','古','双',
        '胜','本','单','同','九','迎','第','台','玉','锦',
        '底','后','七','斜','期','武','岭','松','角','纪',
        '朝','峰','六','振','珠','局','岗','洲','横','边',
        '济','井','办','汉','代','临','弄','团','外','塔',
        '杨','铁','浦','字','年','岛','陵','原','梅','进',
        '荣','友','虹','央','桂','沿','事','津','凯','莲',
        '丁','秀','柳','集','紫','旗','张','谷','的','是',
        '不','了','很','还','个','也','这','我','就','在',
        '以','可','到','错','没','去','过','感','次','要',
        '比','觉','看','得','说','常','真','们','但','最',
        '喜','哈','么','别','位','能','较','境','非','为',
        '欢','然','他','挺','着','价','那','意','种','想',
        '出','员','两','推','做','排','实','分','间','甜',
        '度','起','满','给','热','完','格','荐','喝','等',
        '其','再','几','只','现','朋','候','样','直','而',
        '买','于','般','豆','量','选','奶','打','每','评',
        '少','算','又','因','情','找','些','份','置','适',
        '什','蛋','师','气','你','姐','棒','试','总','定',
        '啊','足','级','整','带','虾','如','态','且','尝',
        '主','话','强','当','更','板','知','己','无','酸',
        '让','入','啦','式','笑','赞','片','酱','差','像',
        '提','队','走','嫩','才','刚','午','接','重','串',
        '回','晚','微','周','值','费','性','桌','拍','跟',
        '块','调','糕'
    ]


    font_name_map = {}


    # 将 字体名字 和 我们查看到的值 组成一个字典 
    for index,value in enumerate(texts):
        font_name_map[font_names[index]] = value


    return font_cmap,font_name_map&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我还是很贴心的给大家画了一个图来解释其中的对应关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055929678-922149261.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就得到了字体的对应关系，但是code是一个整数，而网页上显示的是&lt;code&gt;&amp;amp;#xef05;&amp;amp;#xe40e;&lt;/code&gt;类似这样的数据，这需要几步转化下：&lt;br/&gt;1、将code变成16进制&lt;br/&gt;2、将最前面的&lt;code&gt;0&lt;/code&gt;替换为&lt;code&gt;&amp;amp;#&lt;/code&gt;&lt;br/&gt;3、在最后面添加一个&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以我们也把code按照这个规则进行转换，然后使用re模块。只要找到这样的一个code，就直接替换为文字。这样就能够拿到准确的数据了。&lt;/p&gt;
&lt;p&gt;所以，我们最后的&lt;code&gt;get_page()&lt;/code&gt;函数的代码如下所示&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_page(font_names_map=None,font_cmap=None):
    # 首先分析网页，找到返回评论数据的url，这个url就会直接返回评论数据了，但是urlt中的token是会变化的，只能用一会儿，我也不知道一会儿是好久,得不到数据了就换url吧
    url = 'http://www.dianping.com/ajax/json/shopDynamic/allReview?shopId=131013635&amp;amp;cityId=1604&amp;amp;shopType=10&amp;amp;tcv=txgmn7z01d&amp;amp;_token=eJxVj81ugkAUhd9ltp3A%2FCskXag1DQq2MmBSTReAOhIEEYg6Nn33Do1ddHXO%2Fe45yb1foPG2wMUIIYYhuOwa4AJsIUsACLrWbLjgRGBHcIdzCLJ%2FTPABhSBtVi%2FA3TCC4ICzzx6EZt5gTgUcCkMelhhLGCS%2FGc9EwKHrate2r9ertc2Tqs4rZWWn0m4Pp9rGFCNMBeXmFGAqZdRXCKOQDFgPih4YTR7a%2Fc2BecKU2lxVxu1mt0i2rD3vw6CNYhTcx6HWzlxKov0M%2BzKm%2Fn3aLWJ5edOT4UiHRfp6UEl5K1OlVpO56mS6RAvs1X5GgyjXjTOtFlGRyng226%2BPR1nwp2S9uhUfda7Go3d99jz0DL5%2FANI8Y5M%3D&amp;amp;uuid=c59d33fd-e043-a0f5-f6e1-79ae90d14254.1565007755&amp;amp;platform=1&amp;amp;partner=150&amp;amp;optimusCode=10&amp;amp;originUrl=http%3A%2F%2Fwww.dianping.com%2Fshop%2F131013635'


    # 定义模拟请求头,注意，得不到数据的时候，也要将Cookie的值进行替换
    headers = {
        'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',
        'Cookie': 'cy=8; cye=chengdu; _lxsdk_cuid=16c61bb35536e-0e2ab00cb9c2a8-c343162-144000-16c61bb35547b; _lxsdk=16c61bb35536e-0e2ab00cb9c2a8-c343162-144000-16c61bb35547b; _hc.v=c59d33fd-e043-a0f5-f6e1-79ae90d14254.1565007755; s_ViewType=10; __utmz=1.1565010551.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _lx_utm=utm_source%3DBaidu%26utm_medium%3Dorganic; __utma=1.1978331348.1565010551.1565010551.1565161172.2; _lxsdk_s=16c70ded480-ab0-fe2-71%7C%7C2',
        'Referer':'http://www.dianping.com/shop/131013635',
        'Connection': 'keep-alive',
    }


    # 使用requests库请求url，得到数据json数据
    result_json_str = requests.get(url,headers=headers).text
    # 应为返回的数据是富文本数据，所以首先我们先去掉标签
    result_json_str = re.sub('&amp;lt;.*?&amp;gt;','',result_json_str)


    # 遍历 字体代码-&amp;gt;字体名字 这个字典（code 是一个数字）
    for code, name in font_cmap.items():
        try:
            # 尝试从 字体名字 -&amp;gt; 对应值 这个字典中得到值，防止程序出现KeyError的错误
            text = font_names_map[name]
        except:
            pass
        else:
            # 分析网页信息得知，将code变成16进制，并且把最前面的0换成&amp;amp;#，在加上一个';'. 就是网页加密了的字符窜了
            # 这里就是将59322这样的值变成类似`&amp;amp;#xef05;&amp;amp;#xe40e;`的值
            code_str = str(hex(code)).replace('0', '&amp;amp;#', 1) + ';'
            print(code, code_str, name, text)
            # 将得到的加密之后的字符串进行替换为相应的数据
            # result_str = re.sub('需要替换的字符窜','替换为怎样的字符串','从这个字符串里面查找')
            result_json_str = re.sub(code_str, text, result_json_str)


    # 处理之后的数据使用json模块变成字典
    result = json.loads(result_json_str)
    # 分析得到的数据，得到我们需要的所有评论在result['reviewAllDOList']里面
    # 因为这里有可能我们别识别出来是一个爬虫了，就会返回其他的数据，比如说你没有登陆啊这样的提示。所以这个时候我们就需要改变我们的额url了。然后重新运行我们的爬虫了
    try:
        all_review = result['reviewAllDOList']
    except:
        print(result_json_str)
        raise ValueError('爬取数据失败')


    # 遍历得到的所有评论
    for review in all_review:
        # 得到用户名
        username = review['user']['userNickName']
        # 得到评论内容
        content = review['reviewDataVO']['reviewBody']
        # 因为我们的重点是字体反爬，所以这里我们就是简单的显示出内容就是了
        print('*'*30,'\n',username,&quot;:&quot;,content,'\n','*'*30)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;呼。。。我们终于破解了点评网的字体加密。&lt;/p&gt;
&lt;p&gt;最后还有一点需要注意，因为这个程序我当天写好之后，能成功的替换相应的字符串，但是当我第二天运行程序的时候，缺不能替换了。&lt;/p&gt;
&lt;p&gt;经过分析发现，原来是点评网每天（或许不是每天，每几个小时）应该都会变换字体文件，然后&lt;code&gt;code-&amp;gt;name，name-&amp;gt;形状&lt;/code&gt;也就对应不上了，但是&lt;code&gt;形状-&amp;gt;值&lt;/code&gt;一定是对应上的，这个不会变化。&lt;/p&gt;
&lt;p&gt;那么我们每次运行之前，就直接找到字体文件对应的url，然后先将这个文件下载保存到本地，再运行我们的爬虫即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这个字体文件的url是会变化的，也就是点评网的服务器上每个字体应该存放了好几个不同的字体文件。所以我们每次运行都需要先去找到对应的字体文件的url。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from urllib.request import urlretrieve


def get_font_file():
    url = 'https://s3plus.meituan.net/v1/mss_73a511b8f91f43d0bdae92584ea6330b/font/c667da25.woff'
    urlretrieve(url,'font.woff')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说一下&lt;code&gt;urlretrieve&lt;/code&gt;函数的用法吧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;urlretrieve&lt;/code&gt;：将网络上的文件下载下来，保存到本地。第一个参数为url，第二个参数为保存到本地文件的文件名。&lt;/p&gt;
&lt;p&gt;使用这个函数我们可以很方便的下载网络上一些文件，图片等。&lt;br/&gt;最后我们来看一波运行结果吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190816055939297-547366169.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不得不服点评网，反爬虫做的真是厉害。。。&lt;/p&gt;
&lt;p&gt;关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」，更多有趣好玩的Python等着你哟～&lt;/p&gt;
&lt;p&gt;全部代码已上传至Github：&lt;a href=&quot;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/App/dianping_spider&quot; class=&quot;uri&quot;&gt;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/App/dianping_spider&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Aug 2019 00:02:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>上次数独后，老王好像从哪里得到了风声，跟我说少往他们家带扑克牌……意思里你的家庭矛盾都是因为一副扑克牌咯？  行，那我这段时间先歇一歇，来日方长……  那闲着也是闲着，不能去隔壁了，也不能让小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moonhmily/p/11361601.html</dc:identifier>
</item>
<item>
<title>.netcore持续集成测试篇之MVC层单元测试 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11361598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11361598.html</guid>
<description>&lt;p&gt;前面我们讲的很多单元测试的的方法和技巧不论是在.net core和.net framework里面都是通用的,但是mvc项目里有一种比较特殊的类是Controller,首先Controller类的返回结果跟普通的类并不一样,普通的类返回的都是确定的类型,而mvc项目的返回的ActionResult或者core mvc里返回的IActionResult则是一个高度封装的对象,想对它进行很细致的测试并不是一件很容易的事.因此在编写代码的时候建议尽量把业务逻辑的代码单元写到单独类中,Controller里只进行简单的前端请求参数检验以及各自http状态和数据的返回.还有一点就是Controller是在http请求到达后动态创建的,单元测试的时候很多对象诸如Httpcontext,Modelstate,request,response,routedata,uri,MetadataProvider等都是不存在的,和在http请求环境中有很大差别.但是我们仍然能通过对Controller进行单元测试做很多工作,确保结果是我们想要的.&lt;/p&gt;
&lt;h2 id=&quot;确保action返回正确view和viewmodel&quot;&gt;确保Action返回正确View和ViewModel&lt;/h2&gt;
&lt;p&gt;我们使用HomeController里面的Index方法,代码稍作修改&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public IActionResult Index()
        {
            return View(&quot;Index&quot;,&quot;hello&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的测试代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public void ViewTest()
        {
            HomeController hc = new HomeController();
            var result = (ViewResult)hc.Index();
            var viewName = result.ViewName;
            var model = (string)result.Model;
            Assert.True(viewName == &quot;Index&quot; &amp;amp;&amp;amp; model == &quot;hello&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们先创建一个Controller类,由于业务上我们需要这个方法返回一个View,这是提前预知的,所以我们把hc.Index的结果转为ViewResult,如果转换失败则说明程序中存在bug.&lt;/p&gt;
&lt;p&gt;下面是分别获取View的名称的数据模型,然后我们断言View名称是Index,model的值是hello,当然以上代码比较简单显然是能通过的,在实际业务中我们还要对Model进行更为复杂的断言.&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;需要注意的是,Action返回的view并不是都有名称的,如果是返回的本方法对应的view,默认名称是可以省略的,这样以上断言就会失败,因此如果名称不写的时候我们可以断言ViewName是空,同样返回的是本方法默认的view.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;确保action返回了正确的viewdata&quot;&gt;确保Action返回了正确的viewData&lt;/h2&gt;
&lt;p&gt;我们把HomeController里的Index方法再稍改下如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public IActionResult Index()
        {
            ViewBag.name = &quot;sto&quot;;
            return View(&quot;Index&quot;,&quot;hello&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; HomeController hc = new HomeController();
            var name= result.ViewData[&quot;name&quot;];
            Assert.True(name==&quot;sto&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到以上有些同事可能会有疑惑,为什么设置的是ViewBag而能用ViewData获取到呢,很多都从网上看到过有人说二者一个是dynamic类型,一个是字典类型,这只是它们外在的表现,其实才者运行时是同一个对象.所以可以通过ViewData[xxx]方式获取到它的值.&lt;/p&gt;
&lt;h2 id=&quot;确保程序进入的正确的分支&quot;&gt;确保程序进入的正确的分支&lt;/h2&gt;
&lt;p&gt;我们常常会看到如下代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public IActionResult Index(Student stud)
        {
            if (!ModelState.IsValid) return BadRequest();
            return View(&quot;Index&quot;,&quot;hello&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Student&lt;/code&gt;类我们加上注解,改成如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public class Student
    {
        public string Name { get; set; }
        [Range(3,10,ErrorMessage =&quot;年龄必须在三到十岁之间&quot;)]
        public int Age { get; set; }
        public byte Gender { get; set; }
        public string School { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们对年龄进行注解,标识它必须是3到10之间的一个值.&lt;/p&gt;
&lt;p&gt;我们编写以下测试来测试如果如果有模型绑定错误的时候返回 BadRequest&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public async Task ViewTest()
        {
            HomeController hc = new HomeController();
            var result = hc.Index(new Student{Age=1});
            Assert.IsType&amp;lt;BadRequestResult&amp;gt;(result);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上测试我们把stud的年龄设置为1,根据程序逻辑它不在3到10之间,因此应该返回BadRequest(实际上是一个BadRequestResult类型对象),然而运行以上测试会发现测试并没有通过,通过单步调试我们发现实际上返回的是一个ViewResult对象.为什么会是这样呢?其实原因很简单,因为Modelstate.IsValid是在模型绑定的时候如果模型验证有错误,就会写稿Modelstate对象里,然而控制器并不是动态创建的,模型数据也不是动态绑定的,没有向Modelstate里添加错误信息的动作,所以单元测试里它启动返回True,那是不是就没有办法测试了呢,其实也不是,因为ModelState不仅程序可以在模型绑定的时候动态添加,我们也可以在控制器里面根据自己的业务逻辑添加.&lt;/p&gt;
&lt;p&gt;我们把代码改为如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public async Task ViewTest()
        {
            HomeController hc = new HomeController();
            hc.ModelState.AddModelError(&quot;Age&quot;, &quot;年龄不在3到10范围内&quot;);
            var result = hc.Index(new Student{Age=1});
             Assert.IsType&amp;lt;BadRequestResult&amp;gt;(result);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们知道这里的Age值是不合法的,因此显式在controller的Modelstate对象里显式写入一个错误,这样Model.Isvalid就应该返回False,逻辑应该走入BadRequest里.以上测试通过.&lt;/p&gt;
&lt;h2 id=&quot;确保程序重定向到正确action&quot;&gt;确保程序重定向到正确Action&lt;/h2&gt;
&lt;p&gt;我们把Index方法改为如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public IActionResult Index(int? id)
        {
            if (!id.HasValue) return RedirectToAction(&quot;Contact&quot;,&quot;Home&quot;);
            return View(&quot;Index&quot;,&quot;hello&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果id为null的时候,就会返回一个RedirectToActionResult,导到Home控制器下的Contact方法下.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; [Fact]
        public async Task ViewTest()
        {
            HomeController hc = new HomeController();
            var result = hc.Index(null);
            var redirect = (RedirectToActionResult) result;
            var controllerName = redirect.ControllerName;
            var actionName = redirect.ActionName;
            Assert.True(controllerName == &quot;Home&quot; &amp;amp;&amp;amp; actionName == &quot;Contact&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然以上的代码并不是很有意义,因为RediRectToAction里面传入的参数往往是两个字符串,并不需要特别复杂的计算,而&lt;code&gt;redirect.ControllerName&lt;/code&gt;,&lt;code&gt;redirect.ActionName&lt;/code&gt;获取的也并不是真正控制器的Action的名称,而是上面方法赋值来的.因此它们的值总是相等.&lt;/p&gt;
&lt;p&gt;我们可以通过以下改造来使测试变得更有意义&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public async Task ViewTest()
        {
            HomeController hc = new HomeController();
            var result = hc.Index(null);
            var redirect = (RedirectToActionResult) result;
            var controllerName = redirect.ControllerName;
            var actionName = redirect.ActionName;
            Assert.True(
                controllerName.Equals(nameof(HomeController).GetControllerName(),
                    StringComparison.InvariantCultureIgnoreCase) &amp;amp;&amp;amp; actionName.Equals(nameof(HomeController.Contact),
                    StringComparison.InvariantCultureIgnoreCase));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码我们使用nameof获取类型或者方法的名称,然后判断手动写的和通过nameof获取到的是不是一样,这样如果我们手写有错误就会被发现,但是有一个问题是我们通过nameof获取的HomeController的名称是字符串&lt;code&gt;HomeController&lt;/code&gt;而不是Home,其它类型也是如此,但是这个很容易处理,因为它们都是以Controller结尾,我们只要对它进行一下处理就行了.我们来看GetControllerName方法,它是一个String类的扩展方法&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public static class ControllerNameExtension
    {
        public static string GetControllerName(this string str)
        {
            if (string.IsNullOrWhiteSpace(str) || !str.EndsWith(&quot;Controller&quot;,StringComparison.InvariantCultureIgnoreCase))
            {
                throw new InvalidOperationException(&quot;无法获取指定类型的ControllerName&quot;);
            }

            string controllerName =
                str.Replace(&quot;Controller&quot;, string.Empty, StringComparison.InvariantCultureIgnoreCase);
            return controllerName;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法非常简单,就是把Controller类的结果'Controller'字符串去掉&lt;/p&gt;
&lt;p&gt;由于ControllerFactory在创建Controller的时候是并不区分大小写的,因此我们的equals都加上了不区分大小写的选项,这导致方法看上去特别长,我们也进行一下简单封装.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public static class StringComparisionIgnoreCaseExtension
    {
        public static bool EqualsIgnoreCase(this string str, string other)
        {
            return str.Equals(other, StringComparison.InvariantCultureIgnoreCase);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法非常简单,就是在比较的时候加上&lt;code&gt;StringComparison.InvariantCultureIgnoreCase&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最终Assert的断言代码变成如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; Assert.True(
                controllerName.EqualsIgnoreCase(nameof(HomeController).GetControllerName()) &amp;amp;&amp;amp; actionName.EqualsIgnoreCase(nameof(HomeController.Contact)));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样如果我们因为手写错误把名称拼错或者多空格就很容易被识别出来,并且如果方法名称改掉这里会出现编译错误,方便我们定位错误.&lt;/p&gt;
&lt;h3 id=&quot;确保程序重定向到正确路由&quot;&gt;&lt;code&gt;确保程序重定向到正确路由&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;有些时候我们重定向到指定路由,下面看看如何测试&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public IActionResult Index(int? id)
        {
            if (!id.HasValue) return RedirectToRoute(new{controller=&quot;Home&quot;,action=&quot;Contact&quot;});
            return View(&quot;Index&quot;,&quot;hello&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法如果id为null就重定向到一个路由,这里简单说一下为什么创建这样一个匿名对象,为什么对象的名称为controller,和action而不是controllername和actionname?我们可以运行一下mvc程序,看看RouteData里的键值对的名称是什么,就会明白了.&lt;/p&gt;
&lt;p&gt;测试方法如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public async Task ViewTest()
        {
            HomeController hc = new HomeController();
            var result = hc.Index(null);
            var redirect = (RedirectToRouteResult) result;
            var data = redirect.RouteValues;
            var controllerName = data?[&quot;controller&quot;]?.ToString();
            var actionName = data?[&quot;action&quot;]?.ToString();
            Assert.True(!string.IsNullOrWhiteSpace(controllerName));
            Assert.True(!string.IsNullOrWhiteSpace(actionName));
            Assert.True(controllerName.EqualsIgnoreCase(nameof(HomeController).GetControllerName()));
            Assert.True(actionName.EqualsIgnoreCase(nameof(HomeController.Contact)));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法实际上和上面的RedirectToAction测试本质上差不多,都是确定导向到了正确的controller和action里,不同的是值的获取方法.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;RedirectToAction和RedirecttoRoute都可以传路由值,和上面以样通过索引键获取到值,这里不再展开讲解.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;确保正确重定向到指定短url&quot;&gt;确保正确重定向到指定短url&lt;/h3&gt;
&lt;p&gt;.net core里新增了一个&lt;code&gt;LocalRedirect&lt;/code&gt;(以及对应的永久重写向,永久重定向保持方法等,其它重定向也都有这些类似方法族).它类似于RedirecttoRoute,只不过是参数并不是RouteData,而是一个短路由(不带主机名和ip,因为默认并且只能内部重定向).&lt;/p&gt;
&lt;p&gt;我们把HomeController下的Index方法改为如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public IActionResult Index(int? id)
        {
            if (!id.HasValue) return LocalRedirect(&quot;/Home/Hello&quot;);
            return View(&quot;Index&quot;,&quot;hello&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果Id是null就重定向到&lt;code&gt;/home/Hello&lt;/code&gt;想必大家在页面向后端请求的时候写过不少这样的类似代码,这里就不再详细解释了.&lt;/p&gt;
&lt;p&gt;测试方法如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public async Task ViewTest()
        {
            HomeController hc = new HomeController();
            var result = hc.Index(null);
            var redirect = (LocalRedirectResult) result;
            var url = redirect.Url.Split(&quot;/&quot;).Where(a=&amp;gt;!string.IsNullOrEmpty(a));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要是通过Url获取到这个地址,然后把它分成若干部分.默认情况下第一部分是控制器名,第二部分是action名.后面的代码不再写了,大家自己尝试一下.&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;需要注意的是,以上所有的示例只处理了默认路由的情况,并没有处理路由参数,自定义路由以及aera中的路由等.如果不是默认路由,则以上内容的第一部分就不一定是controller名了,这里还需要根据实际业务来处理.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;view测试&quot;&gt;view测试&lt;/h2&gt;
&lt;p&gt;上一节知识算是对mvc控制器测试的补充知识.这节正式开始讲解关于mvc里view的集成测试.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有一点需要弄明白的是通过发送http请求进行集成测试是无法获取到程序里的Controller对象的,我们只能能View的页面进行集成测试.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对页面的测试主要包含了对返回状态的测试和页面内容的测试.产生确保正确响应,并且返回了正确页面,前面单元测试里主要测试的是返回的view名称是正确的,至于能否到达这个页面则不一定.集成测试里我们要根据当前页面的特征来确定当前页面的身份.也就是这个页面有与众不同的,能区分它和别的页面不同的特征.&lt;/p&gt;
&lt;p&gt;我们仍然用HomeController下的Index来作为案例讲解.对Index方法改为出厂设置,内容如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public IActionResult Index()
        {
            return View();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里返回的首先页面里面包含了一个轮播图,我们可以断言返回的页面中包含有&lt;code&gt;carousel&lt;/code&gt;关键字,测试代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public async Task ViewIntegrityTest()
        {
            var response = await _client.GetAsync(&quot;/Home/Index&quot;);
            response.EnsureSuccessStatusCode();
            var responseStr = await response.Content.ReadAsStringAsync();
            Assert.Contains(&quot;carousel&quot;, responseStr);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上测试返回的内容(就是整个view页面)中包含&lt;code&gt;carousel&lt;/code&gt;这样的字样.&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;需要注意的是以上内容在实际项目中远不能区分这个页面就是home页面,可能还需要其它的判断,需要根据实际情况酌情考虑,如果以特定id,名称等可能会变的内容作为判断则会给集成测试带来维护上的麻烦.有时候页面太多改动又太大导致单元测试大片报错,可能在时间紧任务重的情况下直接把单元测试放弃了,因此不是范围越小,判断的内容越精细越好,而是尽量找到本页面中不易变的,能区别其它页面的东西.即便是区分不了,这里至少能确定页面正确返回了而不是404页面.这样比上线后手动打开浏览器检测页面是否能正常打开要可靠的多.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;仍然有一点需要注意的是并不是集成测试通过了就万事大吉,我们仍然要在项目上线后对页面进行抽检,查看页面布局是否正常.当然这些也可以自动化来完成.但是抽检仍然是必要的,不要信息所有的方法都是天衣无缝的.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 15 Aug 2019 23:57:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>前面我们讲的很多单元测试的的方法和技巧不论是在.net core和.net framework里面都是通用的,但是mvc项目里有一种比较特殊的类是Controller,首先Controller类的返回</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11361598.html</dc:identifier>
</item>
<item>
<title>Git原理入门简析 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/11361576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/11361576.html</guid>
<description>&lt;blockquote readability=&quot;6.78125&quot;&gt;
&lt;p&gt;为了获得更好的阅读体验，建议访问原地址：&lt;a href=&quot;https://www.wmyskxz.com/2019/08/16/git-yuan-li-ru-men-jian-xi/&quot;&gt;传送门&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;前言：&lt;/strong&gt; 之前听过公司大佬分享过 Git 原理之后就想来自己总结一下，最近一忙起来就拖得久了，本来想塞更多的干货，但是不喜欢拖太久，所以先出一版足够入门的；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-5b03b7101ad98e28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Git 是当前流行的分布式版本控制管理工具，&lt;/strong&gt;最初由 Linux Torvalds (Linux 之父) 创造，于 2005 年发布。&lt;/p&gt;
&lt;p&gt;Git，这个词其实源自英国俚语，意思大约是 “混账”。Linux 为什么会以这样自嘲的名字来命名呢？这其中还有一段儿有趣的历史可以说一说：&lt;/p&gt;
&lt;blockquote readability=&quot;39&quot;&gt;
&lt;p&gt;&lt;strong&gt;Git 的诞生：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人都知道，Linus 在 1991 年创建了开源的 Linux，从此，Linux 系统不断发展，已经成为最大的服务器系统软件了。&lt;/p&gt;
&lt;p&gt;Linus 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为 Linux 编写代码，那 Linux 的代码是如何管理的呢？&lt;/p&gt;
&lt;p&gt;事实是，在 2002 年以前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！&lt;/p&gt;
&lt;p&gt;你也许会想，为什么 Linus 不把 Linux 代码放到版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为 Linus 坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS、SVN 好用，但那是付费的，和 Linux 的开源精神不符。&lt;/p&gt;
&lt;p&gt;不过，到了 2002 年，Linux 系统已经发展了十年了，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。&lt;/p&gt;
&lt;p&gt;安定团结的大好局面在 2005 年就被打破了，原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。&lt;/p&gt;
&lt;p&gt;Linus 可以向 BitMover 公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是：Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。&lt;/p&gt;
&lt;p&gt;Git 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。&lt;/p&gt;
&lt;p&gt;历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;版本控制系统&quot;&gt;版本控制系统&lt;/h2&gt;
&lt;p&gt;不管是集中式的 CVS、SVN 还是分布式的 Git 工具，实际上都是一种版本控制系统，我们可以通过他们很方便的管理我们的文件、代码等，我们可以先来畅想一下如果自己来设计这么一个系统，你会怎么设计？&lt;/p&gt;
&lt;p&gt;摁，这不禁让我想起了之前写毕业论文的日子，我先在一个开阔的空间创建了一个文件夹用于保存我的各种版本，然后开始了我的 “毕业论文版本管理”，参考下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-92d4a5d97ae0026b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这好像暴露了我写毕业论文愉快的经历..但不管怎么样，我在用一个粗粒度版本的制度，在对我的毕业论文进行着管理，摁，我通过不停在原基础上迭代出新的版本的方式，不仅保存了我各个版本的毕业论文，还有这清晰的一个路径，完美？NO！&lt;/p&gt;
&lt;p&gt;问题是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每一次的迭代都更改了什么东西，我现在完全看不出来了！&lt;/li&gt;
&lt;li&gt;当我在迭代我的超级无敌怎么样都不改的版本的时候，突然回想起好像之前版本 1.0 的第一节内容和 2.0 版本第三节的内容加起来才是最棒的，我需要打开多个文档并创建一个新的文档，仔细对比文档中的不同并为我的新文档添加新的东西，好麻烦啊...&lt;/li&gt;
&lt;li&gt;到最后文件多起来的时候，我甚至都不知道是我的 “超级无敌版” 是最终版，还是 “打死都不改版” 是最终版了；&lt;/li&gt;
&lt;li&gt;更为要命的是，我保存在我的桌面上，没有备份，意味着我本地文件手滑删除了，那我就...我就...就...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;并且可能问题还远不止于此，所以每每想起，就不自觉对 Linux 膜拜了起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-28e4fc15c065eef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;集中式与分布式的不同&quot;&gt;集中式与分布式的不同&lt;/h2&gt;
&lt;p&gt;Git 采用与 CSV/SVN 完全不同的处理方式，前者采用分布式，而后面两个都是集中式的版本管理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-2525f901ad6c6eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。&lt;/p&gt;
&lt;p&gt;集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-5e175c305c00b761.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，&lt;strong&gt;分布式版本控制系统根本没有 “中央服务器”，每个人的电脑上都是一个完整的版本库，&lt;/strong&gt;这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。&lt;/p&gt;
&lt;p&gt;和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。&lt;/p&gt;
&lt;p&gt;在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当 “中央服务器” 的电脑，但这个服务器的作用仅仅是用来方便 “交换” 大家的修改，没有它大家也一样干活，只是交换修改不方便而已。&lt;/p&gt;
&lt;p&gt;当然，Git 的强大还远不止此。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;git-初始化&quot;&gt;Git 初始化&lt;/h2&gt;
&lt;p&gt;首先，让我们来创建一个空的项目目录，并进入该目录。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ mkdir git-demo-project
$ cd git-demo-project&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们打算对该项目进行版本管理，第一件事就是使用 &lt;code&gt;git init&lt;/code&gt; 命令，进行&lt;strong&gt;初始化&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ git init&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 命令只会做一件事，就是在项目的根目录下创建一个 &lt;code&gt;.git&lt;/code&gt; 的子目录，用来保存当前项目的一些版本信息，我们可以继续使用 &lt;code&gt;tree -a&lt;/code&gt; 命令查看该目录的完整结构，如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ tree -a
.
└── .git
    ├── HEAD                                      
    ├── branches
    ├── config
    ├── description
    ├── hooks
    │   ├── applypatch-msg.sample
    │   ├── commit-msg.sample
    │   ├── fsmonitor-watchman.sample
    │   ├── post-update.sample
    │   ├── pre-applypatch.sample
    │   ├── pre-commit.sample
    │   ├── pre-push.sample
    │   ├── pre-rebase.sample
    │   ├── pre-receive.sample
    │   ├── prepare-commit-msg.sample
    │   └── update.sample
    ├── index
    ├── info
    │   └── exclude
    ├── objects
    │   ├── .DS_Store
    │   ├── info
    │   └── pack
    └── refs
        ├── heads
        └── tags&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;git-目录简单解析&quot;&gt;Git 目录简单解析&lt;/h2&gt;
&lt;h3 id=&quot;config-目录&quot;&gt;config 目录&lt;/h3&gt;
&lt;p&gt;config 是仓库的配置文件，一个典型的配置文件如下，我们创建的远端，分支都在等信息都在配置文件里有表现；&lt;code&gt;fetch&lt;/code&gt; 操作的行为也是在这里配置的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[core]
    repositoryformatversion = 0
    filemode = false
    bare = false
    logallrefupdates = true
    symlinks = false
    ignorecase = true
[remote &quot;origin&quot;]
    url = git@github.com:yanhaijing/zepto.fullpage.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch &quot;master&quot;]
    remote = origin
    merge = refs/heads/master
[branch &quot;dev&quot;]
    remote = origin
    merge = refs/heads/dev&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;objects-目录&quot;&gt;objects 目录&lt;/h3&gt;
&lt;p&gt;Git 可以通过一种算法可以得到任意文件的 &lt;strong&gt;“指纹”&lt;/strong&gt;（40 位 16 进制数字），然后通过文件指纹存取数据，存取的数据都位于 objects 目录。&lt;/p&gt;
&lt;p&gt;例如我们可以手动创建一个测试文本文件并使用 &lt;code&gt;git add .&lt;/code&gt; 命令来观察 &lt;code&gt;.git&lt;/code&gt; 文件夹出现的变化：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ touch test.txt
$ git add .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git add .&lt;/code&gt; 命令就是用于把当前新增的变化添加进 Git 本地仓库的，在我们使用后，我们惊奇的发现 &lt;code&gt;.git&lt;/code&gt; 目录下的 &lt;code&gt;objects/&lt;/code&gt; 目录下多了一个目录：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ tree -a
.
├── .git
│   ├── HEAD
│   ├── branches
│   ├── config
│   ├── description
│   ├── hooks
│   │   ├── 节省篇幅..省略..
│   ├── index
│   ├── info
│   │   └── exclude
│   ├── objects
│   │   ├── .DS_Store
│   │   ├── e6
│   │   │   └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
│   │   ├── info
│   │   └── pack
│   └── refs
│       ├── heads
│       └── tags
└── test.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;git hash-object test.txt&lt;/code&gt; 命令来看看刚才我们创建的 &lt;code&gt;test.txt&lt;/code&gt; 的 “文件指纹”：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ git hash-object test.txt
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候我们可以发现，新创建的目录 &lt;code&gt;e6&lt;/code&gt; 其实是该文件哈希值的前两位，这其实是 Git 做的一层类似于索引一样的东西，并且默认采用 16 进制的两位数来当索引，是非常合适的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;objects 目录下有 3 种类型的数据：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blob；&lt;/li&gt;
&lt;li&gt;Tree;&lt;/li&gt;
&lt;li&gt;Commit；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文件都被存储为 blob 类型的文件，文件夹被存储为 tree 类型的文件，创建的提交节点被存储为 Commit 类型的数据；&lt;/p&gt;
&lt;p&gt;一般我们系统中的目录(tree)，在 Git 会像下面这样存储：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-7e4ffc78726b906d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 Commit 类型的数据则整合了 tree 和 blob 类型，保存了当前的所有变化，例如我们可以再在刚才的目录下新建一个目录，并添加一些文件试试：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ mkdir test
$ touch test/test.file
$ tree -a
.
├── .git
│   ├── HEAD
│   ├── branches
│   ├── config
│   ├── description
│   ├── hooks
│   │   ├── 节省篇幅..省略..
│   ├── index
│   ├── info
│   │   └── exclude
│   ├── objects
│   │   ├── .DS_Store
│   │   ├── e6
│   │   │   └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
│   │   ├── info
│   │   └── pack
│   └── refs
│       ├── heads
│       └── tags
├── test
│   └── test.file
└── test.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交一个 Commit 再观察变化：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ git commit -a -m &quot;test: 新增测试文件夹和测试文件观察.git文件的变化&quot;
[master (root-commit) 30d51b1] test: 新增测试文件夹和测试文件观察.git文件的变化
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test.txt
$ tree -a
.
├── .git
│   ├── COMMIT_EDITMSG
│   ├── HEAD
│   ├── branches
│   ├── config
│   ├── description
│   ├── hooks
│   │   ├── 节省篇幅..省略..
│   ├── index
│   ├── info
│   │   └── exclude
│   ├── logs
│   │   ├── HEAD
│   │   └── refs
│   │       └── heads
│   │           └── master
│   ├── objects
│   │   ├── .DS_Store
│   │   ├── 30
│   │   │   └── d51b1edd2efd551dd6bd52d4520487b5708c0e
│   │   ├── 5e
│   │   │   └── fb9bc29c482e023e40e0a2b3b7e49cec842034
│   │   ├── e6
│   │   │   └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
│   │   ├── info
│   │   └── pack
│   └── refs
│       ├── heads
│       │   └── master
│       └── tags
├── test
│   └── test.file
└── test.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们可以观察到我们提交了一个 Commit 的时候在第一句话里面返回了一个短的像是哈希值一样的东西： &lt;code&gt;[master (root-commit) 30d51b1]&lt;/code&gt; 中 的 &lt;code&gt;30d51b1&lt;/code&gt;，对应的我们也可以在 objects 找到刚才 commit 的对象，我们可以使用 &lt;code&gt;git cat-file -p&lt;/code&gt; 命令输出一下当前文件的内容：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ git cat-file -p 30d5
tree 5efb9bc29c482e023e40e0a2b3b7e49cec842034
author 我没有三颗心脏 &amp;lt;wmyskxz@wmyskxzdeMacBook-Pro.local&amp;gt; 1565742122 +0800
committer 我没有三颗心脏 &amp;lt;wmyskxz@wmyskxzdeMacBook-Pro.local&amp;gt; 1565742122 +0800

test: 新增测试文件夹和测试文件观察.git文件的变化&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现这里面有提交的内容信息、作者信息、提交者信息以及 commit message，当然我们可以进一步看到提交的内容具体有哪些：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ git cat-file -p 5efb
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    test.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再试着提交一个 commit 来观察变化：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ touch test/test2.file
$  git commit -a -m &quot;test: 新增加一个 commit 以观察变化.&quot;
[master 9dfabac] test: 新增加一个 commit 以观察变化.
 2 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test/test.file
 create mode 100644 test/test2.file
$ git cat-file -p 9dfabac
tree c562bfb9441352f4c218b0028148289f1ea7d7cd
parent 30d51b1edd2efd551dd6bd52d4520487b5708c0e
author 龙滔 &amp;lt;longtao@longtaodeMacBook-Pro.local&amp;gt; 1565878699 +0800
committer 龙滔 &amp;lt;longtao@longtaodeMacBook-Pro.local&amp;gt; 1565878699 +0800

test: 新增加一个 commit 以观察变化.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以观察到这一次的 commit 多了一个 parent 的行，其中的 &lt;strong&gt;“指纹”&lt;/strong&gt; 和上一次的 commit 一模一样，当我们提交两个 commit 之后我们的 Git 仓库可以简化为下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-a7161524f75aad60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;说明：其中因为我们 test 文件夹新增了文件，也就是出现了变化，所以就被标识成了新的 tree 类型的对象；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;refs-目录&quot;&gt;refs 目录&lt;/h3&gt;
&lt;p&gt;refs 目录存储都是引用文件，如本地分支，远端分支，标签等&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;refs/heads/xxx 本地分支&lt;/li&gt;
&lt;li&gt;refs/remotes/origin/xxx 远端分支&lt;/li&gt;
&lt;li&gt;refs/tags/xxx 本地tag&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;引用文件的内容都是 40 位长度的 commit&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ cat .git/refs/heads/master
9dfabac68470a588a4b4a78742249df46438874a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就像是一个指针一样，它指向了你的最后一次提交（例如这里就指向了第二次提交的 commit），我们补充上分支信息，现在的 Git 仓库就会像下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-8885b281ca358403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;head-目录&quot;&gt;HEAD 目录&lt;/h3&gt;
&lt;p&gt;HEAD 目录下存储的是当前所在的位置，其内容是分支的名称：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ cat HEAD
ref: refs/heads/master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再补充上 HEAD 的信息，现在的 Git 仓库如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-869c13fe354c65f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;git-中的冲突&quot;&gt;Git 中的冲突&lt;/h2&gt;
&lt;p&gt;您也在上面了解到了，在 Git 中分支是一种十分轻便的存在，仅仅是一个指针罢了，我们在广泛的使用分支中，不可避免的会遇到新创建分支的合并，这时候不论是选择 merge 还是 rebase，都有可能发生冲突，我们先来看一下冲突是如何产生的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-5421a79a0707a46f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图上的情况，并不是移动分支指针就能够解决问题的，它需要一种合并策略。首先我们需要明确的是谁与谁的合并，是 2，3 与 4， 5， 6 两条线的合并吗？其实并不是的，&lt;strong&gt;真实合并的其实只有 3 和 6，因为每一次的提交都包含了项目完整的快照，即合并只是 tree 与 tree 的合并。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这可能说起来有点绕，我们可以先来想一个简单的算法，用来比较 3 和 6 的不同。如果我们只是单纯的比较 3 和 6 的信息，其实并没有意义，因为它们之间并不能确切的表达出当前的冲突状态。因此我们需要选取它们两个分支的分歧点（merge base）作为参考点，进行比较。&lt;/p&gt;
&lt;p&gt;首先我们把 1 作为基础，然后把 1、3、6 中所有的文件做一个列表，然后依次遍历这个列表中的文件。我们现在拿列表中的一个文件进行举例，把在提交在 1、3、6 中的该文件分别称为版本1、版本3、版本6，可能出现如下几种情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 版本 1、版本 3、版本 6 的 “指纹” 值都相同：&lt;/strong&gt;这种情况则说明没有冲突；&lt;br/&gt;&lt;strong&gt;2. 版本 3 or 版本 6 至少有一个与版本 1 状态相同（指的是指纹值相同或都不存在）：&lt;/strong&gt;这种情况可以自动合并，比如版本 1 中存在一个文件，在版本 3 中没有对该文件进行修改，而版本 6 中删除了这个文件，则以版本 6 为准就可以了；&lt;br/&gt;&lt;strong&gt;3. 版本 3 or 版本 6 都与版本 1 的状态不同：&lt;/strong&gt;这种情况复杂一些，自动合并策略很难生效了，所以需要手动解决；&lt;/p&gt;
&lt;h2 id=&quot;merge-操作&quot;&gt;merge 操作&lt;/h2&gt;
&lt;p&gt;在解决完冲突后，我们可以将修改的内容提交为一个新的提交，这就是 merge。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-c64683dbbb6b72fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 merge 是一种不修改分支历史提交记录的方式，这也是我们常用的方式。但是这种方式在某些情况下使用起来不太方便，比如我们创建了一些提交发送给管理者，管理者在合并操作中产生了冲突，还需要去解决冲突，这无疑增加了他人的负担。&lt;/p&gt;
&lt;p&gt;而我们使用 rebase 可以解决这种问题。&lt;/p&gt;
&lt;h2 id=&quot;rebase-操作&quot;&gt;rebase 操作&lt;/h2&gt;
&lt;p&gt;假设我们的分支结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-57de259409289f34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;rebase 会把从 Merge Base 以来的所有提交，以补丁的形式一个一个重新打到目标分支上。这使得目标分支合并该分支的时候会直接 &lt;strong&gt;Fast Forward&lt;/strong&gt;（可以简单理解为直接后移指针），即不会产生任何冲突。提交历史是一条线，这对强迫症患者可谓是一大福音。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-f9456a7134aef2b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实 rebase 主要是在 .git/rebase-merge 下生成了两个文件，分别为 git-rebase-todo 和 done 文件，这两个文件的作用光看名字就大概能够看得出来。git-rebase-todo 中存放了 rebase 将要操作的 commit，而 done 存放正操作或已操作完毕的 commit，比如我们这里，git-rebase-todo 存放了 4、5、6 三个提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-1b98580b5f548477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先 Git 会把 4 这个 commit 放入 done，表示正在操作 4，然后将 4 以补丁的方式打到 3 上，形成了新的 4`，这一步是可能产生冲突的，如果有冲突，需要解决冲突之后才能继续操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-aacfe4cb3a3a30a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着按同样的方式把 5、6 都放入 done，最后把指针移动到最新的提交 6` 上，就完成了 rebase 的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从刚才的图中，我们就可以看到 rebase 的一个缺点，那就是修改了分支的历史提交。&lt;/strong&gt;如果已经将分支推送到了远程仓库，会导致无法将修改后的分支推送上去，必须使用 -f 参数（force）强行推送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以使用 rebase 最好不要在公共分支上进行操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;squash-and-merge-操作&quot;&gt;Squash and Merge 操作&lt;/h2&gt;
&lt;p&gt;简单说就是压缩提交，把多次的提交融合到一个 commit 中，这样的好处不言而喻，我们着重来讨论一下实现的技术细节，还是以我们上面最开始的分支情况为例，首先，Git 会创建一个临时分支，指向当前 feature 的最新 commit。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-64c96964fff563c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后按照上面 rebase 的方式，变基到 master 的最新 commit 处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-240df5c37c980b3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着用 rebase 来 squash 之，压缩这些提交为一个提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-25d59dd6947ab90a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后以 fast forward 的方式合并到 master 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-16cb422aa9471e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见此时 master 分支多且只多了一个描述了这次改动的提交，这对于大型工程，保持主分支的简洁易懂有很大的帮助。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;想要了解更多的诸如 checkout、cherry-pick 等操作的话可以看看参考文章的第三篇，这里就不做细致描述了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;p&gt;通过上面的了解，其实我们已经大致的掌握了 Git 中的基本原理，我们的 Commit 就像是一个链表节点一样，不仅有自身的节点信息，还保存着上一个节点的指针，然后我们以 Branch 这样轻量的指针保存着一条又一条的 commit 链条，不过值得注意的是，objects 目录下的文件是不会自动删除的，除非你手动 GC，不然本地的 objects 目录下就保留着你当前项目完整的变化信息，所以我们通常都会看到 Git 上面的项目通常是没有 .git 目录的，不然仅仅通过 .git 目录理论上就可以还原出你的完整项目！&lt;/p&gt;

&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248&quot; class=&quot;uri&quot;&gt;https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248&lt;/a&gt; - 集中式vs分布式（廖雪峰的官方网站）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yanhaijing.com/git/2017/02/08/deep-git-3/&quot; class=&quot;uri&quot;&gt;https://yanhaijing.com/git/2017/02/08/deep-git-3/&lt;/a&gt; - 起底Git-Git内部原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coding.net/help/doc/practice/git-principle.html&quot; class=&quot;uri&quot;&gt;https://coding.net/help/doc/practice/git-principle.html&lt;/a&gt; - 使用原理视角看 Git&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;按照惯例黏一个尾巴：&lt;/p&gt;
&lt;blockquote readability=&quot;6.20703125&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;独立域名博客：wmyskxz.com&lt;br/&gt;简书ID：&lt;a href=&quot;https://www.jianshu.com/u/a40d61a49221&quot;&gt;@我没有三颗心脏&lt;/a&gt;&lt;br/&gt;github：&lt;a href=&quot;https://github.com/wmyskxz/&quot;&gt;wmyskxz&lt;/a&gt;&lt;br/&gt;欢迎关注公众微信号：wmyskxz&lt;br/&gt;分享自己的学习 &amp;amp; 学习资料 &amp;amp; 生活&lt;br/&gt;想要交流的朋友也可以加qq群：3382693&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 15 Aug 2019 23:19:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<og:description>为了获得更好的阅读体验，建议访问原地址： '传送门' 前言： 之前听过公司大佬分享过 Git 原理之后就想来自己总结一下，最近一忙起来就拖得久了，本来想塞更多的干货，但是不喜欢拖太久，所以先出一版足够</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wmyskxz/p/11361576.html</dc:identifier>
</item>
<item>
<title>Flutter学习笔记（16）--Scaffold脚手架、AppBar组件、BottomNavigationBar组件 - CurtisWgh</title>
<link>http://www.cnblogs.com/upwgh/p/11361402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upwgh/p/11361402.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天的内容是Scaffold脚手架、AppBar组件、BottomNavigationBar组件，通过这三个组件，能大体构建出一个app的主页面，顶导和底导。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;Scaffold（脚手架组件）&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Scaffold实现了基本的Material Design布局，只要是在Material Design中定义过的单个界面显示的布局控件元素，都可以使用Scaffold来绘制。&lt;/p&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;caption&gt;Scaffold组件属性及描述&lt;/caption&gt;
&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;属性名&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;appbar&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AppBar&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;显示在界面顶部的一个AppBar&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;body&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Widget&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;当前界面所显示的主要内容&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;floatingActionButton&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Widget&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;在Material Design中定义的一个功能按钮&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;persistentFooterButtons&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;List&amp;lt;Widget&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;固定在下方展示的按钮&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;drawer&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Widget&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;侧边栏组件&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;bottomNavigationBar&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Widget&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;显示在底部的导航栏按钮&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;backgroundColor&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Color&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;背景颜色&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;resizeToAvoidBottomPadding&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;bool&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;控制界面内容body是否重新布局来避免底部被覆盖，比如当键盘显示时，重新布局避免键盘遮盖住内容，默认值为true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;













&lt;p&gt;Demo示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;package:flutter/material.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;package:fluttertoast/fluttertoast.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; main() =&amp;gt;&lt;span&gt; runApp(DemoApp());

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoApp extends StatelessWidget{
  @override
  Widget build(BuildContext context) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MaterialApp(
      title: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Scaffold Demo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      home: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scaffold(
        appBar: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppBar(
          title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Scaffold Demo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        ),
        body: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Center(
          child: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Scaffold Dmoe 脚手架组件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        ),
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;底部导航按钮&lt;/span&gt;
        bottomNavigationBar: &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BottomAppBar(
          child: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Container(width: &lt;span&gt;100&lt;/span&gt;,height: &lt;span&gt;100&lt;/span&gt;&lt;span&gt;,),
        ),
        backgroundColor: Colors.deepOrange,
      ),
    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1024739/201908/1024739-20190815225622849-605070395.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;AppBar（导航）&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;应用中的顶部导航有两种，一种AppBar一种SilveApprBar，这两种对应Android中的toolbar，AppBar和SliveApprBar都是继承自StatefulWidget，这两者的区别是AppBar是固定在应用的最上面，就是页面的最顶部，而SliveApprBar是可以跟随内容滚动的。&lt;/p&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;caption&gt;AppBar及SliverAppBar组件属性及描述&lt;/caption&gt;
&lt;tbody readability=&quot;13&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;属性名&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;默认值&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;leading&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Widget&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;null&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;在标题前面显示的一个组件，一般情况下展示按钮，比如返回按钮&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;title&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Widget&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;null&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;通常显示为当前页面的标题名&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;actions&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;List&amp;lt;Widget&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;null&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;一个Widget列表，一般情况下展示的也是按钮，比如搜索按钮等&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;bottom&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;PreferredSizeWidget&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;null&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;通常是TabBar，用来在ToolBar标题栏下面显示一个Tab导航栏&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;elevation&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;double&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;纸墨设计中组件的z坐标顺序，对于可滚动的SliverBar，当SliverBar和内容同级的时候，该值为0，当内容滚动SliverAppBar变为toolbar的时候，修改为elevation的值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;flexibleSpace&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Widget&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;null&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;一个显示在AppBar下方的组件，高度和AppBar的高度一样，可以实现一些特殊的效果，该属性通常在SliverAppBar中使用&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;backgroundcolor&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Color&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;ThemeData.primaryColor&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;背景色&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;brightness&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Brightness&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;ThemeData.primaryColorBrightness&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AppBar的亮度，有白色和黑色两种主题&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;iconTheme&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;IconThemeData&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;ThemeData.primaryIconTheme&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AppBar上图标的颜色、透明度和尺寸信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;textTheme&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;TextTheme&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;ThemeData.primaryTextTheme&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AppBar上的文字样式&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;centerTitle&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;bool&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;标题显示是否居中，默认值根据不同的操作系统，显示的方式不一样&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;package:flutter/material.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;package:fluttertoast/fluttertoast.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; main() =&amp;gt;&lt;span&gt; runApp(DemoApp());

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoApp extends StatelessWidget{
  @override
  Widget build(BuildContext context) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MaterialApp(
      debugShowMaterialGrid: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      debugShowCheckedModeBanner: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      title: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;AppBar Demo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      home: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scaffold(
        appBar: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppBar(
          backgroundColor: Colors.cyanAccent,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题栏北京设置为浅蓝色&lt;/span&gt;
          leading: Icon(Icons.menu),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题左侧按钮&lt;/span&gt;
          iconTheme: IconThemeData(color: Colors.amberAccent,opacity: &lt;span&gt;30&lt;/span&gt;,size: &lt;span&gt;25&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;icon的主题，会作用到AppBar上的所有Icon(不包含IconButton，因为IconButton是个button)&lt;/span&gt;
          title: &lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;AppBar Demo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,style: TextStyle(color: Colors.deepPurple,fontSize: &lt;span&gt;20&lt;/span&gt;),),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题文案及字体样式设置&lt;/span&gt;
          actions: &amp;lt;Widget&amp;gt;&lt;span&gt;[
            IconButton(icon: Icon(Icons.search),tooltip: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;搜索&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, onPressed: &lt;span&gt;null&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题右侧按钮&lt;/span&gt;
            IconButton(icon: Icon(Icons.add),tooltip: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, onPressed: &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题右侧按钮&lt;/span&gt;
&lt;span&gt;          ],
        ),
      ),
    );
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这些东西在前面的Demo都用过很多次了，就不多加说明了，看下效果截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1024739/201908/1024739-20190815233141100-366460915.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;BottomNavigationBar（底部导航条组件）&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BottomNaviationBar是底部导航条，主要由按钮加文字组成，按下按钮切换不同的页面，需要一个当前的索引来控制当前具体切换的页面，可以很容易的在tab之间切换和浏览顶级试图，很多App主页底部都采用这种切换的方式。&lt;/p&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;caption&gt;BottomNavigationBar组件属性及描述&lt;/caption&gt;
&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;属性名&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;currentIndex&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;int&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;当前索引，用来切换按钮控制&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;fixedColor&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Color&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选中按钮的颜色，如果没有指定值，则用系统主题色&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;iconSize&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;double&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;按钮图标大小&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;items&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;List&amp;lt;BottomNavigationBarItem&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;底部导航条按钮集，每一项是一个BottomNavigationBarItem，由icon图标及title文本属性&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;onTap&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;ValueChanged&amp;lt;int&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;按下其中某一个按钮回调事件，需要根据返回的索引设置当前索引&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;









&lt;p&gt;写一个简单的demo，底部导航放置3个选项卡，每点击一个选项卡，屏幕中间的文案随之变化，先看下代码和结果，然后讲一下代码的内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;package:flutter/material.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;package:fluttertoast/fluttertoast.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; main() =&amp;gt;&lt;span&gt; runApp(DemoApp());

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MaterialApp(
      title: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BottomNavigationBar Demo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      home: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scaffold(
        appBar: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppBar(
          title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BottomNavigationBar Demo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
          leading: Icon(Icons.menu),
          actions: &lt;/span&gt;&amp;lt;Widget&amp;gt;&lt;span&gt;[
            IconButton(icon: Icon(Icons.search), onPressed: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          ],
        ),
        body: MyHomePage(),
      ),
    );
  }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyHomePage extends StatefulWidget {
  @override
  State&lt;/span&gt;&amp;lt;StatefulWidget&amp;gt;&lt;span&gt; createState() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; _MyHomePageState();
  }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; _MyHomePageState extends State {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _selectedIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _selectedText =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;相机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;扫码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;闹钟&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
  ];
  @override
  Widget build(BuildContext context) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scaffold(
      body: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Center(
        child: _selectedText.elementAt(_selectedIndex),
      ),
      bottomNavigationBar: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BottomNavigationBar(
        items: &lt;/span&gt;&amp;lt;BottomNavigationBarItem&amp;gt;&lt;span&gt;[
          BottomNavigationBarItem(icon: Icon(Icons.add_a_photo),title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;相机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
          BottomNavigationBarItem(icon: Icon(Icons.center_focus_weak),title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;扫码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
          BottomNavigationBarItem(icon: Icon(Icons.add_alarm),title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;闹钟&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
        ],
        currentIndex: _selectedIndex,
        onTap: _onItemTapped,
        fixedColor: Colors.amberAccent,
      ),
    );
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; _onItemTapped(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value) {
    setState(() {
      _selectedIndex &lt;/span&gt;=&lt;span&gt; value;
    });
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1024739/201908/1024739-20190816000850826-992432219.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先要清楚的一点，有状态变化，所以要用StatefulWidget有状态组件，其次要想屏幕中间的文案和底部导航按钮要随点击事件的触发而变化，必然要有初始的索引值和文案的组件数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; _selectedIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _selectedText =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;相机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;扫码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;闹钟&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
  ];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的_selectedText数组里面装的是3个Text组件，每次点击底部导航的按钮，都会根据索引值将这3个Text分别放进child里面，接下来就行处理我们的bottomNavigationBar，上面的BottomNavigationBar属性表里面说过所有的选项卡都是放在items集合里面的，currentIndex处理点击后当前选项的索引值，onTap处理点击事件，fixedColor处理点击选项卡的颜色（包含按钮及文本的颜色）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
bottomNavigationBar: &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BottomNavigationBar(
        items: &lt;/span&gt;&amp;lt;BottomNavigationBarItem&amp;gt;&lt;span&gt;[
          BottomNavigationBarItem(icon: Icon(Icons.add_a_photo),title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;相机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
          BottomNavigationBarItem(icon: Icon(Icons.center_focus_weak),title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;扫码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
          BottomNavigationBarItem(icon: Icon(Icons.add_alarm),title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;闹钟&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
        ],
        currentIndex: _selectedIndex,
        onTap: _onItemTapped,
        fixedColor: Colors.amberAccent,
      ),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后看一下事件的处理_onItemTapped，其实很简单，就是更新bottomNavigationBar的索引值，并且通过setState通知页面重新绘制，最终呈现出我们想要的效果。&lt;/p&gt;

&lt;p&gt;好啦，今天就先学这么多！该睡觉啦&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;下一章节：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/upwgh/p/11361402.html&quot;&gt;Flutter学习笔记（16）--Scaffold脚手架、AppBar组件、BottomNavigationBar组件&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Aug 2019 16:32:00 +0000</pubDate>
<dc:creator>CurtisWgh</dc:creator>
<og:description>今天的内容是Scaffold脚手架、AppBar组件、BottomNavigationBar组件，通过这三个组件，能大体构建出一个app的主页面，顶导和底导。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/upwgh/p/11361402.html</dc:identifier>
</item>
<item>
<title>重学计算机组成原理（七）- 程序无法同时在Linux和Windows下运行？ - JavaEdge</title>
<link>http://www.cnblogs.com/JavaEdge/p/11361399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaEdge/p/11361399.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002807387-1798039452.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在Linux下可以运行，而在Windows下却不行呢？&lt;/p&gt;
&lt;p&gt;反过来，Windows上的程序在Linux上也是一样不能执行的&lt;/p&gt;
&lt;p&gt;可是我们的CPU并没有换掉，它应该可以识别同样的指令呀!!!&lt;/p&gt;
&lt;p&gt;如果你和我有同样的疑问，那这一节，我们就一起来解开。&lt;/p&gt;

&lt;p&gt;写好的C语言代码，可以通过编译器编译成汇编代码，然后汇编代码再通过汇编器变成CPU可以理解的机器码，于是CPU就可以执行这些机器码了&lt;/p&gt;
&lt;p&gt;你现在对这个过程应该不陌生了，但是这个描述把过程大大简化了&lt;/p&gt;
&lt;p&gt;下面，我们一起具体来看，C语言程序是如何变成一个可执行程序的。&lt;/p&gt;
&lt;p&gt;过去几节，我们通过gcc生成的文件和objdump获取到的汇编指令都有些小小的问题&lt;/p&gt;
&lt;p&gt;我们先把前面的add函数示例，拆分成两个文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;add_lib.c&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002807709-1037723081.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;link_example.c&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002807987-470632990.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过gcc来编译这两个文件，然后通过objdump命令看看它们的汇编代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002809262-181932967.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;objdump -d -M intel -S link_example.o&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002813473-594221590.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然代码已经被我们“编译”成了指令&lt;/p&gt;
&lt;p&gt;不妨尝试运行一下 &lt;strong&gt;./link_example.o&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不幸的是，文件没有执行权限，我们遇到一个Permission denied错误&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002814543-775388582.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;即使通过&lt;strong&gt;chmod&lt;/strong&gt;命令赋予&lt;strong&gt;link_example.o&lt;/strong&gt;文件可执行的权限，运行 &lt;strong&gt;./link_example.o&lt;/strong&gt; 仍然只会得到一条&lt;strong&gt;cannot execute binary file: Exec format error&lt;/strong&gt;的错误。&lt;/p&gt;
&lt;p&gt;仔细看一下objdump出来的两个文件的代码，会发现&lt;strong&gt;两个程序的地址都是从0开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果地址一样，程序如果需要通过call指令调用函数的话，怎么知道应该跳到哪一个文件呢？&lt;/p&gt;
&lt;p&gt;无论是这里的运行报错，还是objdump出来的汇编代码里面的重复地址&lt;/p&gt;
&lt;p&gt;都是因为 &lt;strong&gt;add_lib.o&lt;/strong&gt; 以及 &lt;strong&gt;link_example.o&lt;/strong&gt; &lt;strong&gt;并不是一个可执行文件（Executable Program），而是目标文件（Object File）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只有通过&lt;strong&gt;链接器（Linker）&lt;/strong&gt; 把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个&lt;strong&gt;可执行文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;gcc的-o参数，可以生成对应的可执行文件，对应执行之后，就可以得到这个简单的加法调用函数的结果。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002815099-457150319.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;C语言代码-汇编代码-机器码&lt;/strong&gt; 过程，在我们的计算机上进行的时候是由两部分组成:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成&lt;br/&gt;三阶段后，就生成了一个可执行文件link_example:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;file format elf64-x86-64
Disassembly of section .init:
...
Disassembly of section .plt:
...
Disassembly of section .plt.got:
...
Disassembly of section .text:
...

 6b0:   55                      push   rbp
 6b1:   48 89 e5                mov    rbp,rsp
 6b4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
 6b7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
 6ba:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
 6bd:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
 6c0:   01 d0                   add    eax,edx
 6c2:   5d                      pop    rbp
 6c3:   c3                      ret    
00000000000006c4 &amp;lt;main&amp;gt;:
 6c4:   55                      push   rbp
 6c5:   48 89 e5                mov    rbp,rsp
 6c8:   48 83 ec 10             sub    rsp,0x10
 6cc:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa
 6d3:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5
 6da:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
 6dd:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
 6e0:   89 d6                   mov    esi,edx
 6e2:   89 c7                   mov    edi,eax
 6e4:   b8 00 00 00 00          mov    eax,0x0
 6e9:   e8 c2 ff ff ff          call   6b0 &amp;lt;add&amp;gt;
 6ee:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
 6f1:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]
 6f4:   89 c6                   mov    esi,eax
 6f6:   48 8d 3d 97 00 00 00    lea    rdi,[rip+0x97]        # 794 &amp;lt;\_IO\_stdin\_used+0x4&amp;gt;
 6fd:   b8 00 00 00 00          mov    eax,0x0
 702:   e8 59 fe ff ff          call   560 &amp;lt;printf@plt&amp;gt;
 707:   b8 00 00 00 00          mov    eax,0x0
 70c:   c9                      leave  
 70d:   c3                      ret    
 70e:   66 90                   xchg   ax,ax
...
Disassembly of section .fini:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;...你会发现，可执行代码dump出来内容，和之前的目标代码长得差不多，但是长了很多&lt;/p&gt;
&lt;p&gt;因为在Linux下，可执行文件和目标文件所使用的都是一种叫&lt;strong&gt;ELF（Execuatable and Linkable File Format）&lt;/strong&gt;的文件格式，中文名字叫&lt;strong&gt;可执行与可链接文件格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第二部分，我们通过装载器（Loader）把可执行文件装载（Load）到内存中&lt;br/&gt;CPU从内存中读取指令和数据，来开始真正执行程序&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002821393-1364991584.png&quot;/&gt;2 ELF格式和链接：理解链接过程程序最终是通过装载器变成指令和数据的，所以其实生成的可执行代码也并不仅仅是一条条的指令&lt;br/&gt;我们还是通过objdump指令，把可执行文件的内容拿出来看看。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如我们过去所有objdump出来的代码里，你都可以看到对应的函数名称，像add、main等等，乃至你自己定义的全局可以访问的变量名称，都存放在这个ELF格式文件里&lt;/p&gt;
&lt;p&gt;这些名字和它们对应的地址，在ELF文件里面，存储在一个叫作符号表（Symbols Table）的位置里。符号表相当于一个地址簿，把名字和地址关联了起来。&lt;/p&gt;
&lt;p&gt;我们先只关注和我们的add以及main函数相关的部分&lt;/p&gt;
&lt;p&gt;你会发现，这里面，main函数里调用add的跳转地址，不再是下一条指令的地址了，而是add函数的入口地址了，这就是EFL格式和链接器的功劳&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002830505-441742802.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ELF文件格式把各种信息，分成一个一个的Section保存起来。ELF有一个基本的文件头（File Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的CPU、操作系统等等。除了这些基本属性之外，大部分程序还有这么一些Section：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是.text Section，也叫作代码段或者指令段（Code Section），用来保存程序的代码和指令；&lt;/li&gt;
&lt;li&gt;接着是.data Section，也叫作数据段（Data Section），用来保存程序里面设置好的初始化数据信息；&lt;/li&gt;
&lt;li&gt;然后就是.rel.text Secion，叫作重定位表（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在main函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；&lt;/li&gt;
&lt;li&gt;最后是.symtab Section，叫作符号表（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190816002844950-39375565.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供CPU执行就可以了。&lt;/p&gt;

&lt;p&gt;讲到这里，相信你已经猜到，为什么同样一个程序，在Linux下可以执行而在Windows下不能执行了。其中一个非常重要的原因就是，两个操作系统下可执行文件的格式不一样。&lt;/p&gt;
&lt;p&gt;我们今天讲的是Linux下的ELF文件格式，而Windows的可执行文件格式是一种叫作PE（Portable Executable Format）的文件格式。Linux下的装载器只能解析ELF格式而不能解析PE格式。&lt;/p&gt;
&lt;p&gt;如果我们有一个可以能够解析PE格式的装载器，我们就有可能在Linux下运行Windows程序了。这样的程序真的存在吗？&lt;/p&gt;
&lt;p&gt;没错，Linux下著名的开源项目Wine，就是通过兼容PE格式的装载器，使得我们能直接在Linux下运行Windows程序的。&lt;/p&gt;
&lt;p&gt;而现在微软的Windows里面也提供了WSL，也就是Windows Subsystem for Linux，可以解析和加载ELF格式的文件。&lt;/p&gt;
&lt;p&gt;我们去写可以用的程序，也不仅仅是把所有代码放在一个文件里来编译执行，而是可以拆分成不同的函数库，最后通过一个静态链接的机制，使得不同的文件之间既有分工，又能通过静态链接来“合作”，变成一个可执行的程序。&lt;/p&gt;
&lt;p&gt;对于ELF格式的文件，为了能够实现这样一个静态链接的机制，里面不只是简单罗列了程序所需要执行的指令，还会包括链接所需要的重定位表和符号表。&lt;/p&gt;

&lt;p&gt;更深入了解程序的链接过程和ELF格式，推荐阅读《程序员的自我修养——链接、装载和库》的1～4章。这是一本难得的讲解程序的链接、装载和运行的好书。&lt;/p&gt;
</description>
<pubDate>Thu, 15 Aug 2019 16:29:00 +0000</pubDate>
<dc:creator>JavaEdge</dc:creator>
<og:description>既然程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在Linux下可以运行，而在Windows下却不行呢？ 反过来，Windows上的程序在Linux上也是一样不能执行的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaEdge/p/11361399.html</dc:identifier>
</item>
<item>
<title>重学计算机组成原理（六）- 函数调用怎么突然Stack Overflow了! - JavaEdge</title>
<link>http://www.cnblogs.com/JavaEdge/p/11361162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaEdge/p/11361162.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190815230650608-815499832.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用Google搜异常信息，肯定都访问过&lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow网站&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;全球最大的程序员问答网站，名字来自于一个常见的报错，就是栈溢出（stack overflow）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从函数调用开始，在计算机指令层面函数间的相互调用是怎么实现的，以及什么情况下会发生栈溢出&lt;/p&gt;

&lt;p&gt;先看一个简单的C程序&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;function.c&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190815230652362-676632536.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;直接在Linux中使用GCC编译运行&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[hadoop@JavaEdge Documents]$ vim function.c
[hadoop@JavaEdge Documents]$ gcc -g -c function.c 
[hadoop@JavaEdge Documents]$ objdump -d -M intel -S function.o

function.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;add&amp;gt;:
#include &amp;lt;stdio.h&amp;gt;
int static add(int a, int b)
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
   a:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
   d:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
  10:   01 d0                   add    eax,edx
  12:   5d                      pop    rbp
  13:   c3                      ret    

0000000000000014 &amp;lt;main&amp;gt;:
    return a+b;
}


int main()
{
  14:   55                      push   rbp
  15:   48 89 e5                mov    rbp,rsp
  18:   48 83 ec 10             sub    rsp,0x10
    int x = 5;
  1c:   c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5
    int y = 10;
  23:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [rbp-0x8],0xa
    int u = add(x, y);

  2a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
  2d:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  30:   89 d6                   mov    esi,edx
  32:   89 c7                   mov    edi,eax
  34:   e8 c7 ff ff ff          call   0 &amp;lt;add&amp;gt;
  39:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
    return 0;
  3c:   b8 00 00 00 00          mov    eax,0x0
}
  41:   c9                      leave  
  42:   c3                      ret    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main函数和上一节我们讲的的程序执行区别不大,主要是把jump指令换成了函数调用的call指令,call指令后面跟着的，仍然是跳转后的程序地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看看add函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;add函数编译后，代码先执行了一条push指令和一条mov指令&lt;/p&gt;
&lt;p&gt;在函数执行结束的时候，又执行了一条pop和一条ret指令&lt;/p&gt;
&lt;p&gt;这四条指令的执行，其实就是在进行我们接下来要讲&lt;strong&gt;压栈（Push）和出栈（Pop）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数调用和上一节我们讲的if…else和for/while循环有点像&lt;/p&gt;
&lt;p&gt;都是在原来顺序执行的指令过程里，执行了一个内存地址的跳转指令，让指令从原来顺序执行的过程里跳开，从新的跳转后的位置开始执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，这两个跳转有个区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;if…else和for/while的跳转，是跳转走了就不再回来了，就在跳转后的新地址开始顺序地执行指令，后会无期&lt;/li&gt;
&lt;li&gt;函数调用的跳转，在对应函数的指令执行完了之后，还要再回到函数调用的地方，继续执行call之后的指令，地球毕竟是圆的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;有没有一个可以不跳回原来开始的地方,从而实现函数的调用呢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;似乎有.可以把调用的函数指令，直接插入在调用函数的地方，替换掉对应的call指令，然后在编译器编译代码的时候，直接就把函数调用变成对应的指令替换掉。&lt;/p&gt;
&lt;p&gt;不过思考一下，你会发现&lt;strong&gt;漏洞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果函数A调用了函数B，然后函数B再调用函数A，我们就得面临在A里面插入B的指令，然后在B里面插入A的指令，这样就会产生无穷无尽地替换。&lt;/p&gt;
&lt;p&gt;就好像两面镜子面对面放在一块儿，任何一面镜子里面都会看到无穷多面镜子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190815230704780-1464192134.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Infinite Mirror Effect&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果函数A调用B，B再调用A，那么代码会无限展开&lt;/p&gt;
&lt;p&gt;那就换一个思路，能不能把后面要跳回来执行的指令地址给记录下来呢？&lt;/p&gt;
&lt;p&gt;就像PC寄存器一样，可以专门设立一个“程序调用寄存器”，存储接下来要跳转回来执行的指令地址&lt;/p&gt;
&lt;p&gt;等到函数调用结束，从这个寄存器里取出地址，再跳转到这个记录的地址，继续执行就好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但在多层函数调用里，只记录一个地址是不够的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在调用函数A之后，A还可以调用函数B，B还能调用函数C&lt;/p&gt;
&lt;p&gt;这一层又一层的调用并没有数量上的限制&lt;/p&gt;
&lt;p&gt;在所有函数调用返回之前，每一次调用的返回地址都要记录下来，但是我们CPU里的寄存器数量并不多&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;像我们一般使用的Intel i7 CPU只有16个64位寄存器，调用的层数一多就存不下了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最终，CSer们想到了一个比单独记录跳转回来的地址更完善的办法&lt;/p&gt;
&lt;p&gt;在内存里面开辟一段空间，用栈这个后进先出（LIFO，Last In First Out）的数据结构&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;栈就像一个乒乓球桶，每次程序调用函数之前，我们都把调用返回后的地址写在一个乒乓球上，然后塞进这个球桶&lt;br/&gt;这个操作其实就是我们常说的压栈。如果函数执行完了，我们就从球桶里取出最上面的那个乒乓球，很显然，这就是出栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿到出栈的乒乓球，找到上面的地址，把程序跳转过去，就返回到了函数调用后的下一条指令了&lt;/p&gt;
&lt;p&gt;如果函数A在执行完成之前又调用了函数B，那么在取出乒乓球之前，我们需要往球桶里塞一个乒乓球。而我们从球桶最上面拿乒乓球的时候，拿的也一定是最近一次的，也就是最下面一层的函数调用完成后的地址&lt;/p&gt;
&lt;p&gt;乒乓球桶的底部，就是&lt;strong&gt;栈底&lt;/strong&gt;，最上面的乒乓球所在的位置，就是&lt;strong&gt;栈顶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190815230716943-323879098.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;压栈的不只有函数调用完成后的返回地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如函数A在调用B的时候，需要传输一些参数数据，这些参数数据在寄存器不够用的时候也会被压入栈中&lt;/p&gt;
&lt;p&gt;整个函数A所占用的所有内存空间，就是函数A的栈帧（Stack Frame）&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Frame在中文里也有“相框”的意思，所以，每次到这里，都有种感觉，整个函数A所需要的内存空间就像是被这么一个“相框”给框了起来，放在了栈里面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而实际的程序栈布局，顶和底与我们的乒乓球桶相比是倒过来的&lt;/p&gt;
&lt;p&gt;底在最上面，顶在最下面，这样的布局是因为栈底的内存地址是在一开始就固定的。而一层层压栈之后，栈顶的内存地址是在逐渐变小而不是变大&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190815230721320-574671678.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应上面函数add的汇编代码，我们来仔细看看，main函数调用add函数时&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;add函数入口在0～1行&lt;/li&gt;
&lt;li&gt;add函数结束之后在12～13行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在调用第34行的call指令时，会把当前的PC寄存器里的下一条指令的地址压栈，保留函数调用结束后要执行的指令地址&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;而add函数的第0行，push rbp指令，就是在压栈&lt;br/&gt;这里的rbp又叫&lt;strong&gt;栈帧指针（Frame Pointer）&lt;/strong&gt;，存放了当前栈帧位置的寄存器。push rbp就把之前调用函数，也就是main函数的栈帧的栈底地址，压到栈顶。&lt;/li&gt;
&lt;li&gt;第1行的一条命令mov rbp, rsp，则是把rsp这个栈指针（Stack Pointer）的值复制到rbp里，而rsp始终会指向栈顶&lt;br/&gt;这个命令意味着，rbp这个栈帧指针指向的地址，变成当前最新的栈顶，也就是add函数的栈帧的栈底地址了。&lt;/li&gt;
&lt;li&gt;在函数add执行完成之后，又会分别调用第12行的pop rbp&lt;br/&gt;将当前的栈顶出栈,这部分操作维护好了我们整个栈帧&lt;/li&gt;
&lt;li&gt;然后调用第13行的ret指令，这时候同时要把call调用的时候压入的PC寄存器里的下一条指令出栈，更新到PC寄存器中，将程序的控制权返回到出栈后的栈顶。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过引入栈，我们可以看到，无论有多少层的函数调用，或者在函数A里调用函数B，再在函数B里调用A&lt;/p&gt;
&lt;p&gt;这样的递归调用，我们都只需要通过维持rbp和rsp，这两个维护栈顶所在地址的寄存器，就能管理好不同函数之间的跳转&lt;/p&gt;
&lt;p&gt;不过，栈的大小也是有限的。如果函数调用层数太多，我们往栈里压入它存不下的内容，程序在执行的过程中就会遇到栈溢出的错误，这就是&lt;strong&gt;stack overflow&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造一个栈溢出的错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;并不困难，最简单的办法，就是我们上面说的&lt;strong&gt;Infiinite Mirror Effect&lt;/strong&gt;的方式，让函数A调用自己，并且不设任何终止条件&lt;/p&gt;
&lt;p&gt;这样一个无限递归的程序，在不断地压栈过程中，将整个栈空间填满，并最终遇上stack overflow。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a()
{
  return a();
}


int main()
{
  a();
  return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了无限递归，递归层数过深，在栈空间里面创建非常占内存的变量（比如一个巨大的数组），这些情况都很可能给你带来stack overflow&lt;/p&gt;
&lt;p&gt;相信你理解了栈在程序运行的过程里面是怎么回事，未来在遇到stackoverflow这个错误的时候，不会完全没有方向了。&lt;/p&gt;

&lt;p&gt;上面我们提到一个方法，把一个实际调用的函数产生的指令，直接插入到的位置，来替换对应的函数调用指令。尽管这个通用的函数调用方案，被我们否决了，但是如果被调用的函数里，没有调用其他函数，这个方法还是可以行得通的。&lt;/p&gt;
&lt;p&gt;事实上，这就是一个常见的编译器进行自动优化的场景，我们通常叫&lt;strong&gt;函数内联(Inline)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要在GCC编译的时候，加上对应的一个让编译器自动优化的参数-O，编译器就会在可行的情况下，进行这样的指令替换。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;案例&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190815230722753-1119923277.png&quot;/&gt;&lt;br/&gt;为了避免编译器优化掉太多代码，小小修改了一下function.c，让参数x和y都变成了，通过随机数生成，并在代码的最后加上将u通过printf打印&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[hadoop@JavaEdge Documents]$ vim function.c
[hadoop@JavaEdge Documents]$ gcc -g -c -O function.c 
[hadoop@JavaEdge Documents]$ objdump -d -M intel -S function.o

function.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;main&amp;gt;:
{
    return a+b;
}

int main()
{
   0:   53                      push   rbx
   1:   bf 00 00 00 00          mov    edi,0x0
   6:   e8 00 00 00 00          call   b &amp;lt;main+0xb&amp;gt;
   b:   89 c7                   mov    edi,eax
   d:   e8 00 00 00 00          call   12 &amp;lt;main+0x12&amp;gt;
  12:   e8 00 00 00 00          call   17 &amp;lt;main+0x17&amp;gt;
  17:   89 c3                   mov    ebx,eax
  19:   e8 00 00 00 00          call   1e &amp;lt;main+0x1e&amp;gt;
  1e:   89 c1                   mov    ecx,eax
  20:   bf 67 66 66 66          mov    edi,0x66666667
  25:   89 d8                   mov    eax,ebx
  27:   f7 ef                   imul   edi
  29:   d1 fa                   sar    edx,1
  2b:   89 d8                   mov    eax,ebx
  2d:   c1 f8 1f                sar    eax,0x1f
  30:   29 c2                   sub    edx,eax
  32:   8d 04 92                lea    eax,[rdx+rdx*4]
  35:   29 c3                   sub    ebx,eax
  37:   89 c8                   mov    eax,ecx
  39:   f7 ef                   imul   edi
  3b:   c1 fa 02                sar    edx,0x2
  3e:   89 d7                   mov    edi,edx
  40:   89 c8                   mov    eax,ecx
  42:   c1 f8 1f                sar    eax,0x1f
  45:   29 c7                   sub    edi,eax
  47:   8d 04 bf                lea    eax,[rdi+rdi*4]
  4a:   01 c0                   add    eax,eax
  4c:   29 c1                   sub    ecx,eax
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int static add(int a, int b)
{
    return a+b;
  4e:   8d 34 0b                lea    esi,[rbx+rcx*1]
{
    srand(time(NULL));
    int x = rand() % 5;
    int y = rand() % 10;
    int u = add(x, y);
    printf(&quot;u = %d\n&quot;, u);
  51:   bf 00 00 00 00          mov    edi,0x0
  56:   b8 00 00 00 00          mov    eax,0x0
  5b:   e8 00 00 00 00          call   60 &amp;lt;main+0x60&amp;gt;
  60:   b8 00 00 00 00          mov    eax,0x0
  65:   5b                      pop    rbx
  66:   c3                      ret    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的function.c的编译出来的汇编代码，没有把add函数单独编译成一段指令顺序，而是在调用u = add(x, y)的时候，直接替换成了一个add指令。&lt;/p&gt;
&lt;p&gt;除了依靠编译器的自动优化，你还可以在定义函数的地方，加上inline的关键字，来提示编译器对函数进行内联。&lt;/p&gt;
&lt;p&gt;内联带来的优化是，CPU需要执行的指令数变少了，根据地址跳转的过程不需要了，压栈和出栈的过程也不用了。&lt;/p&gt;
&lt;p&gt;不过内联并不是没有代价，内联意味着，我们把可以复用的程序指令在调用它的地方完全展开了。如果一个函数在很多地方都被调用了，那么就会展开很多次，整个程序占用的空间就会变大了。&lt;/p&gt;
&lt;p&gt;这样没有调用其他函数，只会被调用的函数，我们一般称之为&lt;strong&gt;叶子函数（或叶子过程）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/201908/1097393-20190815230726540-625625674.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这一节，我们讲了一个程序的函数间调用，在CPU指令层面是怎么执行的。其中一定需要你牢记的，就是&lt;strong&gt;程序栈&lt;/strong&gt;这个新概念。&lt;/p&gt;
&lt;p&gt;我们可以方便地通过压栈和出栈操作，使得程序在不同的函数调用过程中进行转移。而函数内联和栈溢出，一个是我们常常可以选择的优化方案，另一个则是我们会常遇到的程序Bug。&lt;/p&gt;
&lt;p&gt;通过加入了程序栈，我们相当于在指令跳转的过程种，加入了一个“记忆”的功能，能在跳转去运行新的指令之后，再回到跳出去的位置，能够实现更加丰富和灵活的指令执行流程。这个也为我们在程序开发的过程中，提供了“函数”这样一个抽象，使得我们在软件开发的过程中，可以复用代码和指令，而不是只能简单粗暴地复制、粘贴代码和指令。&lt;/p&gt;

&lt;p&gt;可以仔细读一下《深入理解计算机系统（第三版）》的3.7小节《过程》，进一步了解函数调用是怎么回事。&lt;/p&gt;
&lt;p&gt;另外，我推荐你花一点时间，通过搜索引擎搞清楚function.c每一行汇编代码的含义，这个能够帮你进一步深入了解程序栈、栈帧、寄存器以及Intel CPU的指令集。&lt;/p&gt;

&lt;p&gt;深入浅出计算机组成原理&lt;/p&gt;
</description>
<pubDate>Thu, 15 Aug 2019 15:07:00 +0000</pubDate>
<dc:creator>JavaEdge</dc:creator>
<og:description>用Google搜异常信息，肯定都访问过 'Stack Overflow网站' 全球最大的程序员问答网站，名字来自于一个常见的报错，就是栈溢出（stack overflow） 从函数调用开始，在计算机指</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaEdge/p/11361162.html</dc:identifier>
</item>
<item>
<title>[Spring cloud 一步步实现广告系统] 19. 监控Hystrix Dashboard - IsaacZhang</title>
<link>http://www.cnblogs.com/zhangpan1244/p/11361078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangpan1244/p/11361078.html</guid>
<description>&lt;p&gt;在之前的18次文章中，我们实现了广告系统的&lt;code&gt;广告投放&lt;/code&gt;，&lt;code&gt;广告检索&lt;/code&gt;业务功能，中间使用到了 &lt;code&gt;服务发现Eureka&lt;/code&gt;，&lt;code&gt;服务调用Feign&lt;/code&gt;,&lt;code&gt;网关路由Zuul&lt;/code&gt;以及&lt;code&gt;错误熔断Hystrix&lt;/code&gt;等&lt;code&gt;Spring Cloud&lt;/code&gt;组件。&lt;br/&gt;简单调用关系：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/08/15/95S2IYZ4gzyCphk.png&quot; alt=&quot;UTOOLS1565828973486.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是系统往往都会报错，我们之前定义了一些容错类和方法，但是只是在控制台可以看到错误信息，我们想要统计一些数据，怎么才能更直观的看到我们的服务调用情况呢，接下来，和大家讨论一个新的熔断监控组件&lt;code&gt;Hystrix Dashboard&lt;/code&gt;,顾名思义，从名字上我们就能看出来，它是监控的图形化界面。&lt;/p&gt;
&lt;h4 id=&quot;hystrix-在服务中的使用&quot;&gt;Hystrix 在服务中的使用&lt;/h4&gt;
&lt;h5 id=&quot;结合openfeign使用&quot;&gt;结合openfeign使用&lt;/h5&gt;
&lt;p&gt;在我们实际的项目当中，使用的最多的就是结合&lt;code&gt;FeignClient#fallback&lt;/code&gt;和&lt;code&gt;Hystrix&lt;/code&gt;一起来实现熔断，我们看一下我们在&lt;code&gt;mscx-ad-feign-sdk&lt;/code&gt;中的实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FeignClient(value = &quot;mscx-ad-sponsor&quot;, fallback = SponsorClientHystrix.class)
public interface ISponsorFeignClient {
    @RequestMapping(value = &quot;/ad-sponsor/plan/get&quot;, method = RequestMethod.POST)
    CommonResponse&amp;lt;List&amp;lt;AdPlanVO&amp;gt;&amp;gt; getAdPlansUseFeign(@RequestBody AdPlanGetRequestVO requestVO);

    @RequestMapping(value = &quot;/ad-sponsor/user/get&quot;, method = RequestMethod.GET)
    /**
     * Feign 埋坑之 如果是Get请求，必须在所有参数前添加{@link RequestParam},不能使用{@link Param}
     * 会被自动转发为POST请求。
     */
    CommonResponse getUsers(@RequestParam(value = &quot;username&quot;) String username);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上述代码中，我们自定义了一个feignclient,并且给了这个client一个fallback的实现类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class SponsorClientHystrix implements ISponsorFeignClient {
    @Override
    public CommonResponse&amp;lt;List&amp;lt;AdPlanVO&amp;gt;&amp;gt; getAdPlansUseFeign(AdPlanGetRequestVO requestVO) {
        return new CommonResponse&amp;lt;&amp;gt;(-1, &quot;mscx-ad-sponsor feign &amp;amp; hystrix get plan error.&quot;);
    }

    @Override
    public CommonResponse getUsers(String username) {
        return new CommonResponse&amp;lt;&amp;gt;(-1, &quot;mscx-ad-sponsor feign &amp;amp; hystrix get user error.&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个fallback类实现了我们自定义的&lt;code&gt;ISponsorFeignClient&lt;/code&gt;，那是因为fallback的方法必须和原始执行类的方法签名保持一致，这样在执行失败的时候，可以通过反射映射到响应的降级方法/容错方法。&lt;br/&gt;在&lt;code&gt;mscx-ad-search&lt;/code&gt;服务中，我们通过注入&lt;code&gt;ISponsorFeignClient&lt;/code&gt;来调用我们的&lt;code&gt;mscz-ad-sponsor&lt;/code&gt;服务。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@Slf4j
@RequestMapping(path = &quot;/search-feign&quot;)
public class SearchFeignController {

    /**
     * 注入我们自定义的FeignClient
     */
    private final ISponsorFeignClient sponsorFeignClient;
    @Autowired
    public SearchFeignController(ISponsorFeignClient sponsorFeignClient) {
        this.sponsorFeignClient = sponsorFeignClient;
    }

    @GetMapping(path = &quot;/user/get&quot;)
    public CommonResponse getUsers(@Param(value = &quot;username&quot;) String username) {
        log.info(&quot;ad-search::getUsersFeign -&amp;gt; {}&quot;, JSON.toJSONString(username));
        CommonResponse commonResponse = sponsorFeignClient.getUsers(username);
        return commonResponse;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用hystrixcommand&quot;&gt;使用&lt;code&gt;HystrixCommand&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;其实Hystrix本身提供了一种直接在方法中应用的方式，就是使用&lt;code&gt;@ com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand&lt;/code&gt;,我们看一下这个类的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface HystrixCommand {
    ...

        /**
     * Specifies a method to process fallback logic.
     * A fallback method should be defined in the same class where is HystrixCommand.
     * Also a fallback method should have same signature to a method which was invoked as hystrix command.
     * for example:
     * &amp;lt;code&amp;gt;
     *      @HystrixCommand(fallbackMethod = &quot;getByIdFallback&quot;)
     *      public String getById(String id) {...}
     *
     *      private String getByIdFallback(String id) {...}
     * &amp;lt;/code&amp;gt;
     * Also a fallback method can be annotated with {@link HystrixCommand}
     * &amp;lt;p/&amp;gt;
     * default =&amp;gt; see {@link com.netflix.hystrix.contrib.javanica.command.GenericCommand#getFallback()}
     *
     * @return method name
     */
    String fallbackMethod() default &quot;&quot;;

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们主要关注2个点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;@Target({ElementType.METHOD})&lt;/code&gt;表明当前的注解只能应用在方法上面。&lt;/li&gt;
&lt;li&gt;可直接定义&lt;code&gt;fallbackMethod&lt;/code&gt;来保证容错。这个方法有一个缺陷，就是必须和执行方法在同一个类文件中，这就会造成我们的方法在实现的时候，显得特别的冗余和不够优雅。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以我们的&lt;code&gt;mscx-ad-search&lt;/code&gt;中的广告查询为例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Slf4j
public class SearchImpl implements ISearch {

    /**
     * 查询广告容错方法
     *
     * @param e 第二个参数可以不指定，如果需要跟踪错误，就指定上
     * @return 返回一个空map 对象
     */
    public SearchResponse fetchAdsFallback(SearchRequest request, Throwable e) {

        System.out.println(&quot;查询广告失败，进入容错降级 : %s&quot; + e.getMessage());
        return new SearchResponse().builder().adSlotRelationAds(Collections.emptyMap()).build();
    }

    @HystrixCommand(fallbackMethod = &quot;fetchAdsFallback&quot;)
    @Override
    public SearchResponse fetchAds(SearchRequest request) {
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们请求出错的时候，会转到我们的fallback方法，这个实现是通过在应用启动的时候，我们开始了&lt;code&gt;@EnableCircuitBreaker&lt;/code&gt;注解，这个注解会通过AOP拦截所有的&lt;code&gt;HystrixCommand&lt;/code&gt;方法，将&lt;code&gt;HystrixCommand&lt;/code&gt;整合到springboot的容器中，并且将注解标注的方法放入hystrix的线程中，一旦失败，通过反射调用fallback方法来实现。&lt;/p&gt;
&lt;h4 id=&quot;创建dashboard-project&quot;&gt;创建dashboard project&lt;/h4&gt;
&lt;p&gt;上述代码我们看了Hystrix实现熔断的2种方式，接下来我们来实现请求监控的图形化界面，创建&lt;code&gt;mscx-ad-dashboard&lt;/code&gt;，Let's code.&lt;br/&gt;依然遵从我们springboot项目的三部曲：&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;加依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;spring-cloud-starter-hystrix&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;1.2.7.RELEASE&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;spring-cloud-starter-hystrix-dashboard&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;1.2.7.RELEASE&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;!--eureka client--&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
     &amp;lt;/dependency&amp;gt;
 &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;加注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
   * AdDashboardApplication for Hystrix Dashboard 启动类
   *
   * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
   * @since 2019/8/15
   */
    @SpringBootApplication
    @EnableDiscoveryClient
    @EnableHystrixDashboard
    public class AdDashboardApplication {

        public static void main(String[] args) {
            SpringApplication.run(AdDashboardApplication.class, args);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;改配置&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;    server:
        port: 1234
    spring:
        application:
            name: mscx-ad-dashboard
    eureka:
        client:
            service-url:
            defaultZone: http://server1:7777/eureka/,http://server2:8888/eureka/,http://server3:9999/eureka/
    management:
        endpoints:
            web:
            exposure:
                include: &quot;*&quot;`&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;直接启动,可以看到如下页面：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/08/15/15SxazwWqX93pkZ.png&quot; alt=&quot;UTOOLS1565833851940.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加要监控的服务地址：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/08/15/cU9SBI83TNWnFmp.png&quot; alt=&quot;UTOOLS1565833920702.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Aug 2019 14:48:00 +0000</pubDate>
<dc:creator>IsaacZhang</dc:creator>
<og:description>在之前的18次文章中，我们实现了广告系统的 ，`广告检索 服务发现Eureka 服务调用Feign 网关路由Zuul 错误熔断Hystrix Spring Cloud`组件。 简单调用关系： 但是系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangpan1244/p/11361078.html</dc:identifier>
</item>
<item>
<title>从原理层面掌握@ModelAttribute的使用（核心原理篇）【一起学Spring MVC】 - _YourBatman</title>
<link>http://www.cnblogs.com/fangshixiang/p/11361070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fangshixiang/p/11361070.html</guid>
<description>&lt;h4 id=&quot;每篇一句&quot;&gt;每篇一句&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们应该做一个：胸中有蓝图，脚底有计划的人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Spring MVC&lt;/code&gt;提供的基于注释的编程模型，极大的简化了&lt;code&gt;web&lt;/code&gt;应用的开发，我们都是受益者。比如我们在&lt;code&gt;@RestController&lt;/code&gt;标注的&lt;code&gt;Controller&lt;/code&gt;控制器组件上用&lt;code&gt;@RequestMapping&lt;/code&gt;、&lt;code&gt;@ExceptionHandler&lt;/code&gt;等注解来表示请求映射、异常处理等等。&lt;br/&gt;使用这种注解的方式来开发控制器我认为最重要的优势是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;灵活的方法签名（入参随意写）&lt;/li&gt;
&lt;li&gt;不必继承基类&lt;/li&gt;
&lt;li&gt;不必实现接口&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;==总之一句话：&lt;strong&gt;灵活性非常强，耦合度非常低。&lt;/strong&gt;==&lt;/p&gt;
&lt;p&gt;在众多的注解使用中，&lt;code&gt;Spring MVC&lt;/code&gt;中有一个非常强大但几乎被忽视的一员：&lt;code&gt;@ModelAttribute&lt;/code&gt;。关于这个注解的使用情况，我在群里/线下问了一些人，感觉很少人会使用这个注解（甚至有的不知道有这个注解），这着实让我非常的意外。我认为至少这对于&quot;久经战场&quot;的一个老程序员来说这是不应该的吧。&lt;/p&gt;
&lt;p&gt;不过没关系，有幸看到此文，能够帮你弥补弥补这块的盲区。&lt;br/&gt;&lt;code&gt;@ModelAttribute&lt;/code&gt;它不是开发必须的注解（不像&lt;code&gt;@RequestMapping&lt;/code&gt;那么重要），so即使你不知道它依旧能正常书写控制器。当然，正所谓没有最好只有更好，倘若你掌握了它，便能够帮助你&lt;strong&gt;更加高效&lt;/strong&gt;的写代码，让你的代码复用性更强、代码更加简洁、可维护性更高。&lt;/p&gt;
&lt;p&gt;这种知识点就像反射、就像内省，即使你不知道它你完全也可以工作、写业务需求。但是若你能够熟练使用，那你的可想象空间就会更大了，未来可期。&lt;strong&gt;虽然它不是必须，但是它是个很好的辅助~&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;modelattribute官方解释&quot;&gt;@ModelAttribute官方解释&lt;/h3&gt;
&lt;p&gt;首先看看&lt;code&gt;Spring&lt;/code&gt;官方的&lt;code&gt;JavaDoc&lt;/code&gt;对它怎么说：它将方法参数/方法返回值绑定到&lt;code&gt;web view&lt;/code&gt;的&lt;code&gt;Model&lt;/code&gt;里面。只支持&lt;code&gt;@RequestMapping&lt;/code&gt;这种类型的控制器哦。它既可以标注在方法入参上，也可以标注在方法（返回值）上。&lt;/p&gt;
&lt;p&gt;但是请注意，&lt;strong&gt;当请求处理导致异常时&lt;/strong&gt;，引用数据和所有其他模型内容对Web视图&lt;strong&gt;不可用&lt;/strong&gt;，因为该异常随时可能引发，使&lt;code&gt;Model&lt;/code&gt;内容不可靠。&lt;strong&gt;因此，标注有&lt;code&gt;@Exceptionhandler&lt;/code&gt;的方法不提供对&lt;code&gt;Model&lt;/code&gt;参数的访问~&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// @since 2.5  只能用在入参、方法上
@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ModelAttribute {

    @AliasFor(&quot;name&quot;)
    String value() default &quot;&quot;;
    // The name of the model attribute to bind to. 注入如下默认规则
    // 比如person对应的类是：mypackage.Person（类名首字母小写）
    // personList对应的是：List&amp;lt;Person&amp;gt;  这些都是默认规则咯~~~ 数组、Map的省略
    // 具体可以参考方法：Conventions.getVariableNameForParameter(parameter)的处理规则
    @AliasFor(&quot;value&quot;)
    String name() default &quot;&quot;;

    // 若是false表示禁用数据绑定。
    // @since 4.3
    boolean binding() default true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;基本原理&lt;/h2&gt;
&lt;p&gt;我们知道&lt;code&gt;@ModelAttribute&lt;/code&gt;能标注在入参上，也可以标注在方法上。下面就从原理处深入理解，从而掌握它的使用，后面再给出多种使用场景的使用&lt;code&gt;Demo&lt;/code&gt;。&lt;br/&gt;和它相关的两个类是&lt;code&gt;ModelFactory&lt;/code&gt;和&lt;code&gt;ModelAttributeMethodProcessor&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.6772727272727&quot;&gt;
&lt;p&gt;&lt;code&gt;@ModelAttribute&lt;/code&gt;缺省处理的是&lt;code&gt;Request&lt;/code&gt;请求域，&lt;code&gt;Spring MVC&lt;/code&gt;还提供了&lt;code&gt;@SessionAttributes&lt;/code&gt;来处理和&lt;code&gt;Session&lt;/code&gt;域相关的模型数据，详见：&lt;a href=&quot;https://blog.csdn.net/f641385712/article/details/98378045&quot;&gt;从原理层面掌握@SessionAttributes的使用【一起学Spring MVC】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于&lt;code&gt;ModelFactory&lt;/code&gt;的介绍，在&lt;a href=&quot;https://blog.csdn.net/f641385712/article/details/98378045&quot;&gt;这里&lt;/a&gt;讲解&lt;code&gt;@SessionAttributes&lt;/code&gt;的时候已经介绍一大部分了，但特意留了一部分关于&lt;code&gt;@ModelAttribute&lt;/code&gt;的内容，在本文继续讲解&lt;/p&gt;
&lt;h4 id=&quot;modelfactory&quot;&gt;ModelFactory&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ModelFactory&lt;/code&gt;所在包&lt;code&gt;org.springframework.web.method.annotation&lt;/code&gt;，可见它和web是强关联的在一起的。作为上篇文章的补充说明，接下里只关心它对&lt;code&gt;@ModelAttribute&lt;/code&gt;的解析部分：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// @since 3.1
public final class ModelFactory {

    // 初始化Model 这个时候`@ModelAttribute`有很大作用
    public void initModel(NativeWebRequest request, ModelAndViewContainer container, HandlerMethod handlerMethod) throws Exception {
        // 拿到sessionAttr的属性
        Map&amp;lt;String, ?&amp;gt; sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);
        // 合并进容器内
        container.mergeAttributes(sessionAttributes);
        // 这个方法就是调用执行标注有@ModelAttribute的方法们~~~~
        invokeModelAttributeMethods(request, container);
        ... 
    }

    //调用标注有注解的方法来填充Model
    private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer container) throws Exception {
        // modelMethods是构造函数进来的  一个个的处理吧
        while (!this.modelMethods.isEmpty()) {
            // getNextModelMethod：通过next其实能看出 执行是有顺序的  拿到一个可执行的InvocableHandlerMethod
            InvocableHandlerMethod modelMethod = getNextModelMethod(container).getHandlerMethod();

            // 拿到方法级别的标注的@ModelAttribute~~
            ModelAttribute ann = modelMethod.getMethodAnnotation(ModelAttribute.class);
            Assert.state(ann != null, &quot;No ModelAttribute annotation&quot;);
            if (container.containsAttribute(ann.name())) {
                if (!ann.binding()) { // 若binding是false  就禁用掉此name的属性  让不支持绑定了  此方法也处理完成
                    container.setBindingDisabled(ann.name());
                }
                continue;
            }

            // 调用目标的handler方法，拿到返回值returnValue 
            Object returnValue = modelMethod.invokeForRequest(request, container);
            // 方法返回值不是void才需要继续处理
            if (!modelMethod.isVoid()){

                // returnValueName的生成规则 上文有解释过  本处略
                String returnValueName = getNameForReturnValue(returnValue, modelMethod.getReturnType());
                if (!ann.binding()) { // 同样的 若禁用了绑定，此处也不会放进容器里
                    container.setBindingDisabled(returnValueName);
                }
        
                //在个判断是个小细节：只有容器内不存在此属性，才会放进去   因此并不会有覆盖的效果哦~~~
                // 所以若出现同名的  请自己控制好顺序吧
                if (!container.containsAttribute(returnValueName)) {
                    container.addAttribute(returnValueName, returnValue);
                }
            }
        }
    }

    // 拿到下一个标注有此注解方法~~~
    private ModelMethod getNextModelMethod(ModelAndViewContainer container) {
        
        // 每次都会遍历所有的构造进来的modelMethods
        for (ModelMethod modelMethod : this.modelMethods) {
            // dependencies：表示该方法的所有入参中 标注有@ModelAttribute的入参们
            // checkDependencies的作用是：所有的dependencies依赖们必须都是container已经存在的属性，才会进到这里来
            if (modelMethod.checkDependencies(container)) {
                // 找到一个 就移除一个
                // 这里使用的是List的remove方法，不用担心并发修改异常？？？ 哈哈其实不用担心的  小伙伴能知道为什么吗？？
                this.modelMethods.remove(modelMethod);
                return modelMethod;
            }
        }

        // 若并不是所有的依赖属性Model里都有，那就拿第一个吧~~~~
        ModelMethod modelMethod = this.modelMethods.get(0);
        this.modelMethods.remove(modelMethod);
        return modelMethod;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ModelFactory&lt;/code&gt;这部分做的事：执行所有的标注有&lt;code&gt;@ModelAttribute&lt;/code&gt;注解的方法，并且是顺序执行哦。那么问题就来了，这些&lt;code&gt;handlerMethods&lt;/code&gt;是什么时候被“找到”的呢？？？这个时候就来到了&lt;code&gt;RequestMappingHandlerAdapter&lt;/code&gt;，来看看它是如何找到这些标注有此注解&lt;code&gt;@ModelAttribute&lt;/code&gt;的处理器的~~~&lt;/p&gt;
&lt;h4 id=&quot;requestmappinghandleradapter&quot;&gt;RequestMappingHandlerAdapter&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RequestMappingHandlerAdapter&lt;/code&gt;是个非常庞大的体系，本处我们只关心它对&lt;code&gt;@ModelAttribute&lt;/code&gt;也就是对&lt;code&gt;ModelFactory&lt;/code&gt;的创建，列出相关源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//  @since 3.1
public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean {

    // 该方法不能标注有@RequestMapping注解，只标注了@ModelAttribute才算哦~
    public static final MethodFilter MODEL_ATTRIBUTE_METHODS = method -&amp;gt;
            (!AnnotatedElementUtils.hasAnnotation(method, RequestMapping.class) &amp;amp;&amp;amp; AnnotatedElementUtils.hasAnnotation(method, ModelAttribute.class));
    ...
    // 从Advice里面分析出来的标注有@ModelAttribute的方法（它是全局的）
    private final Map&amp;lt;ControllerAdviceBean, Set&amp;lt;Method&amp;gt;&amp;gt; modelAttributeAdviceCache = new LinkedHashMap&amp;lt;&amp;gt;();

    @Nullable
    protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        // 每调用一次都会生成一个ModelFactory ~~~
        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);
        ...
        ModelAndViewContainer mavContainer = new ModelAndViewContainer();
        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
        // 初始化Model
        modelFactory.initModel(webRequest, mavContainer, invocableMethod);
        mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);
        ...
        return getModelAndView(mavContainer, modelFactory, webRequest);
    }

    // 创建出一个ModelFactory，来管理Model
    // 显然和Model相关的就会有@ModelAttribute @SessionAttributes等注解啦~
    private ModelFactory getModelFactory(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {
        // 从缓存中拿到和此Handler相关的SessionAttributesHandler处理器~~处理SessionAttr
        SessionAttributesHandler sessionAttrHandler = getSessionAttributesHandler(handlerMethod);
        Class&amp;lt;?&amp;gt; handlerType = handlerMethod.getBeanType();

        // 找到当前类（Controller）所有的标注的@ModelAttribute注解的方法
        Set&amp;lt;Method&amp;gt; methods = this.modelAttributeCache.get(handlerType);
        if (methods == null) {
            methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);
            this.modelAttributeCache.put(handlerType, methods);
        }
        
        List&amp;lt;InvocableHandlerMethod&amp;gt; attrMethods = new ArrayList&amp;lt;&amp;gt;();
        // Global methods first
        // 全局的有限，最先放进List最先执行~~~~
        this.modelAttributeAdviceCache.forEach((clazz, methodSet) -&amp;gt; {
            if (clazz.isApplicableToBeanType(handlerType)) {
                Object bean = clazz.resolveBean();
                for (Method method : methodSet) {
                    attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));
                }
            }
        });
        for (Method method : methods) {
            Object bean = handlerMethod.getBean();
            attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));
        }
        return new ModelFactory(attrMethods, binderFactory, sessionAttrHandler);
    }

    // 构造InvocableHandlerMethod 
    private InvocableHandlerMethod createModelAttributeMethod(WebDataBinderFactory factory, Object bean, Method method) {
        InvocableHandlerMethod attrMethod = new InvocableHandlerMethod(bean, method);
        if (this.argumentResolvers != null) {
            attrMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }
        attrMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
        attrMethod.setDataBinderFactory(factory);
        return attrMethod;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RequestMappingHandlerAdapter&lt;/code&gt;这部分处理逻辑：每次请求过来它都会创建一个&lt;code&gt;ModelFactory&lt;/code&gt;，从而收集到全局的（来自&lt;code&gt;@ControllerAdvice&lt;/code&gt;）+ 本&lt;code&gt;Controller&lt;/code&gt;控制器上的所有的标注有&lt;code&gt;@ModelAttribute&lt;/code&gt;注解的方法们。&lt;br/&gt;&lt;code&gt;@ModelAttribute&lt;/code&gt;标注在单独的方法上（木有&lt;code&gt;@RequestMapping&lt;/code&gt;注解），它可以在每个控制器方法&lt;strong&gt;调用之前&lt;/strong&gt;，创建出一个&lt;code&gt;ModelFactory&lt;/code&gt;从而管理&lt;code&gt;Model&lt;/code&gt;数据~&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;ModelFactory&lt;/code&gt;管理着&lt;code&gt;Model&lt;/code&gt;，提供了&lt;code&gt;@ModelAttribute&lt;/code&gt;以及&lt;code&gt;@SessionAttributes&lt;/code&gt;等对它的影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时&lt;code&gt;@ModelAttribute&lt;/code&gt;可以标注在入参、方法（返回值）上的，标注在不同地方处理的方式是不一样的，那么接下来又一主菜&lt;code&gt;ModelAttributeMethodProcessor&lt;/code&gt;就得登场了。&lt;/p&gt;
&lt;h3 id=&quot;modelattributemethodprocessor&quot;&gt;ModelAttributeMethodProcessor&lt;/h3&gt;
&lt;p&gt;从命名上看它是个&lt;code&gt;Processor&lt;/code&gt;，所以根据经验它既能处理入参，也能处理方法的返回值：&lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt; + &lt;code&gt;HandlerMethodReturnValueHandler&lt;/code&gt;。解析&lt;code&gt;@ModelAttribute&lt;/code&gt;注解标注的方法参数，并处理&lt;code&gt;@ModelAttribute&lt;/code&gt;标注的方法返回值。&lt;/p&gt;
&lt;p&gt;==先看它对方法入参的处理（稍显复杂）：==&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 这个处理器用于处理入参、方法返回值~~~~
// @since 3.1
public class ModelAttributeMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {

    private static final ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();
    private final boolean annotationNotRequired;

    public ModelAttributeMethodProcessor(boolean annotationNotRequired) {
        this.annotationNotRequired = annotationNotRequired;
    }


    // 入参里标注了@ModelAttribute 或者（注意这个或者） annotationNotRequired = true并且不是isSimpleProperty()
    // isSimpleProperty()：八大基本类型/包装类型、Enum、Number等等 Date Class等等等等
    // 所以划重点：即使你没标注@ModelAttribute  单子还要不是基本类型等类型，都会进入到这里来处理
    // 当然这个行为是是收到annotationNotRequired属性影响的，具体的具体而论  它既有false的时候  也有true的时候
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return (parameter.hasParameterAnnotation(ModelAttribute.class) ||
                (this.annotationNotRequired &amp;amp;&amp;amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));
    }

    // 说明：能进入到这里来的  证明入参里肯定是有对应注解的？？？
    // 显然不是，上面有说  这事和属性值annotationNotRequired有关的~~~
    @Override
    @Nullable
    public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
    
        // 拿到ModelKey名称~~~（注解里有写就以注解的为准）
        String name = ModelFactory.getNameForParameter(parameter);
        // 拿到参数的注解本身
        ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);
        if (ann != null) {
            mavContainer.setBinding(name, ann.binding());
        }

        Object attribute = null;
        BindingResult bindingResult = null;

        // 如果model里有这个属性，那就好说，直接拿出来完事~
        if (mavContainer.containsAttribute(name)) {
            attribute = mavContainer.getModel().get(name);
        } else { // 若不存在，也不能让是null呀
            // Create attribute instance
            // 这是一个复杂的创建逻辑：
            // 1、如果是空构造，直接new一个实例出来
            // 2、若不是空构造，支持@ConstructorProperties解析给构造赋值
            //   注意:这里就支持fieldDefaultPrefix前缀、fieldMarkerPrefix分隔符等能力了 最终完成获取一个属性
            // 调用BeanUtils.instantiateClass(ctor, args)来创建实例
            // 注意：但若是非空构造出来，是立马会执行valid校验的，此步骤若是空构造生成的实例，此步不会进行valid的，但是下一步会哦~
            try {
                attribute = createAttribute(name, parameter, binderFactory, webRequest);
            } catch (BindException ex) {
                if (isBindExceptionRequired(parameter)) {
                    // No BindingResult parameter -&amp;gt; fail with BindException
                    throw ex;
                }
                // Otherwise, expose null/empty value and associated BindingResult
                if (parameter.getParameterType() == Optional.class) {
                    attribute = Optional.empty();
                }
                bindingResult = ex.getBindingResult();
            }
        }

        // 若是空构造创建出来的实例，这里会进行数据校验  此处使用到了((WebRequestDataBinder) binder).bind(request);  bind()方法  唯一一处
        if (bindingResult == null) {
            // Bean property binding and validation;
            // skipped in case of binding failure on construction.
            WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
            if (binder.getTarget() != null) {
                // 绑定request请求数据
                if (!mavContainer.isBindingDisabled(name)) {
                    bindRequestParameters(binder, webRequest);
                }
                // 执行valid校验~~~~
                validateIfApplicable(binder, parameter);
                //注意：此处抛出的异常是BindException
                //RequestResponseBodyMethodProcessor抛出的异常是：MethodArgumentNotValidException
                if (binder.getBindingResult().hasErrors() &amp;amp;&amp;amp; isBindExceptionRequired(binder, parameter)) {
                    throw new BindException(binder.getBindingResult());
                }
            }
            // Value type adaptation, also covering java.util.Optional
            if (!parameter.getParameterType().isInstance(attribute)) {
                attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
            }
            bindingResult = binder.getBindingResult();
        }

        // Add resolved attribute and BindingResult at the end of the model
        // at the end of the model  把解决好的属性放到Model的末尾~~~
        // 可以即使是标注在入参上的@ModelAtrribute的属性值，最终也都是会放进Model里的~~~可怕吧
        Map&amp;lt;String, Object&amp;gt; bindingResultModel = bindingResult.getModel();
        mavContainer.removeAttributes(bindingResultModel);
        mavContainer.addAllAttributes(bindingResultModel);

        return attribute;
    }

    // 此方法`ServletModelAttributeMethodProcessor`子类是有复写的哦~~~~
    // 使用了更强大的：ServletRequestDataBinder.bind(ServletRequest request)方法
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ((WebRequestDataBinder) binder).bind(request);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模型属性&lt;strong&gt;首先从Model中获取&lt;/strong&gt;，若没有获取到，就使用&lt;strong&gt;默认构造函数&lt;/strong&gt;（可能是有无参，也可能是有参）创建，然后会把&lt;code&gt;ServletRequest&lt;/code&gt;请求的数据绑定上来， 然后进行&lt;code&gt;@Valid&lt;/code&gt;校验（若添加有校验注解的话），&lt;strong&gt;最后会把属性添加到&lt;code&gt;Model&lt;/code&gt;里面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后加进去的代码是：&lt;code&gt;mavContainer.addAllAttributes(bindingResultModel);&lt;/code&gt;这里我贴出参考值：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682076/201908/682076-20190815224633723-1075730620.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;如下示例，它会正常打印person的值，而不是null（因为Model内有person了~）&lt;br/&gt;请求链接是：&lt;code&gt;/testModelAttr?name=wo&amp;amp;age=10&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @GetMapping(&quot;/testModelAttr&quot;)
    public void testModelAttr(@Valid Person person, ModelMap modelMap) {
        Object personAttr = modelMap.get(&quot;person&quot;);
        System.out.println(personAttr); //Person(name=wo, age=10)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：虽然&lt;code&gt;person&lt;/code&gt;上没有标注&lt;code&gt;@ModelAtrribute&lt;/code&gt;，但是&lt;code&gt;modelMap.get(&quot;person&quot;)&lt;/code&gt;依然是能够获取到值的哦，至于为什么，原因上面已经分析了，可自行思考。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下例中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @GetMapping(&quot;/testModelAttr&quot;)
    public void testModelAttr(Integer age, Person person, ModelMap modelMap) {
        System.out.println(age); // 直接封装的值
        System.out.println(&quot;-------------------------------&quot;);
        System.out.println(modelMap.get(&quot;age&quot;));
        System.out.println(modelMap.get(&quot;person&quot;));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求：&lt;code&gt;/testModelAttr?name=wo&amp;amp;age=10&lt;/code&gt; 输入为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;10
-------------------------------
null
Person(name=wo, age=10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到&lt;strong&gt;普通类型&lt;/strong&gt;（注意理解这个普通类型）若不标注&lt;code&gt;@ModelAtrribute&lt;/code&gt;，它是不会自动识别为&lt;code&gt;Model&lt;/code&gt;而放进来的哟~~~若你这么写：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @GetMapping(&quot;/testModelAttr&quot;)
    public void testModelAttr(@ModelAttribute(&quot;age&quot;) Integer age, Person person, ModelMap modelMap) {
        System.out.println(age); // 直接封装的值
        System.out.println(&quot;-------------------------------&quot;);
        System.out.println(modelMap.get(&quot;age&quot;));
        System.out.println(modelMap.get(&quot;person&quot;));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;10
-------------------------------
10
Person(name=wo, age=10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请务必注意以上case的区别，加深记忆。使用的时候可别踩坑了~&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;==再看它对方法（返回值）的处理（很简单）：==&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ModelAttributeMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {

    // 方法返回值上标注有@ModelAttribute注解（或者非简单类型）  默认都会放进Model内哦~~
    @Override
    public boolean supportsReturnType(MethodParameter returnType) {
        return (returnType.hasMethodAnnotation(ModelAttribute.class) ||
                (this.annotationNotRequired &amp;amp;&amp;amp; !BeanUtils.isSimpleProperty(returnType.getParameterType())));
    }

    // 这个处理就非常非常的简单了，注意：null值是不放的哦~~~~
    // 注意：void的话  returnValue也是null
    @Override
    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
            ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {

        if (returnValue != null) {
            String name = ModelFactory.getNameForReturnValue(returnValue, returnType);
            mavContainer.addAttribute(name, returnValue);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它对&lt;strong&gt;方法返回值&lt;/strong&gt;的处理非常简单，只要不是null（当然不能是&lt;code&gt;void&lt;/code&gt;）就都会放进&lt;code&gt;Model&lt;/code&gt;里面，供以使用&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文介绍的是&lt;code&gt;@ModelAttribute&lt;/code&gt;的核心原理，他对我们实际使用有重要的理论支撑。下面系列文章主要在原理的基础上，展示各种各样场景下的使用&lt;code&gt;Demo&lt;/code&gt;，敬请关注~&lt;/p&gt;
&lt;h4 id=&quot;相关阅读&quot;&gt;相关阅读&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/f641385712/article/details/98378045&quot;&gt;从原理层面掌握@SessionAttributes的使用【一起学Spring MVC】&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/f641385712/article/details/98508272&quot;&gt;从原理层面掌握@RequestAttribute、@SessionAttribute的使用【一起学Spring MVC】&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/f641385712/article/details/98493425&quot;&gt;从原理层面掌握@ModelAttribute的使用（使用篇）【一起学Spring MVC】&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;知识交流&quot;&gt;知识交流&lt;/h4&gt;
&lt;p&gt;==The last：如果觉得本文对你有帮助，不妨点个赞呗。当然分享到你的朋友圈让更多小伙伴看到也是被&lt;code&gt;作者本人许可的~&lt;/code&gt;==&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若对技术内容感兴趣可以加入wx群交流：&lt;code&gt;Java高工、架构师3群&lt;/code&gt;。&lt;br/&gt;若群二维码失效，请加wx号：&lt;code&gt;fsx641385712&lt;/code&gt;（或者扫描下方wx二维码）。并且备注：&lt;code&gt;&quot;java入群&quot;&lt;/code&gt; 字样，会手动邀请入群&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.9569892473118&quot;&gt;
&lt;p&gt;&lt;strong&gt;若文章&lt;code&gt;格式混乱&lt;/code&gt;或者&lt;code&gt;图片裂开&lt;/code&gt;&lt;/strong&gt;，请点击`：&lt;a href=&quot;https://blog.csdn.net/f641385712/article/details/98260361&quot;&gt;原文链接-原文链接-原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 15 Aug 2019 14:47:00 +0000</pubDate>
<dc:creator>_YourBatman</dc:creator>
<og:description>一个可以沉迷于技术的程序猿，wx加入加入技术群：fsx641385712</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fangshixiang/p/11361070.html</dc:identifier>
</item>
<item>
<title>Eureka 缓存结构以及服务感知优化 - XuMinzhe</title>
<link>http://www.cnblogs.com/xmzJava/p/11359636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xmzJava/p/11359636.html</guid>
<description>&lt;p&gt;果然好记性不如烂笔头，再简单的东西不记录下来总是会忘的！&lt;/p&gt;
&lt;p&gt;本文首先会分析eureka中的缓存架构。并在此基础上优化服务之间的感知&lt;/p&gt;

&lt;p&gt;eureka-client获取注册信息可分为两种，分别是全量获取和增量获取。&lt;/p&gt;
&lt;p&gt;Eureka-Client 启动时，首先执行一次全量获取进行本地缓存注册信息，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Inject
    DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
                    Provider&amp;lt;BackupRegistry&amp;gt; backupRegistryProvider) {
                    if (clientConfig.shouldFetchRegistry() &amp;amp;&amp;amp; !fetchRegistry(false)) {
            fetchRegistryFromBackup();
        }
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;项目中配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;eureka.client.fetch-registry=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;便可以调用fetchRegistry方法，从eureka-server全量获取注册信息&lt;/p&gt;
&lt;p&gt;Eureka-Client 启动时，还会初始化一个缓存刷新定时任务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void initScheduledTasks() {
        if (clientConfig.shouldFetchRegistry()) {
            // registry cache refresh timer
            int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();
            int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
            scheduler.schedule(
                    new TimedSupervisorTask(
                            &quot;cacheRefresh&quot;,
                            scheduler,
                            cacheRefreshExecutor,
                            registryFetchIntervalSeconds,
                            TimeUnit.SECONDS,
                            expBackOffBound,
                            new CacheRefreshThread()
                    ),
                    registryFetchIntervalSeconds, TimeUnit.SECONDS);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每间隔 registryFetchIntervalSeconds(默认值是30) 秒执行一次CacheRefreshThread任务。CacheRefreshThread最终还是执行了fetchRegistry方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private boolean fetchRegistry(boolean forceFullRegistryFetch) {
        try {
            Applications applications = getApplications();

            if (clientConfig.shouldDisableDelta()
                    || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))
                    || forceFullRegistryFetch
                    || (applications == null)
                    || (applications.getRegisteredApplications().size() == 0)
                    || (applications.getVersion() == -1)) //Client application does not have latest library supporting delta
            {
                getAndStoreFullRegistry();
            } else {
                getAndUpdateDelta(applications);
            }
            applications.setAppsHashCode(applications.getReconcileHashCode());
        } catch (Throwable e) {
            logger.error(PREFIX + appPathIdentifier + &quot; - was unable to refresh its cache! status = &quot; + e.getMessage(), e);
            return false;
        } finally {
            if (tracer != null) {
                tracer.stop();
            }
        }
        // Notify about cache refresh before updating the instance remote status
        onCacheRefreshed();
        // Update remote status based on refreshed data held in the cache
        updateInstanceRemoteStatus();
        // registry was fetched successfully, so return true
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;fetchRegistry首先判断是全量获取还是增量获取，然后请求server端获取注册信息，成功后更新注册信息。再触发CacheRefreshed事件&lt;/p&gt;

&lt;p&gt;客户端的请求到Server端后，通过ResponseCache返回服务信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GET
    public Response getContainers(@PathParam(&quot;version&quot;) String version,
                                  @HeaderParam(HEADER_ACCEPT) String acceptHeader,
                                  @HeaderParam(HEADER_ACCEPT_ENCODING) String acceptEncoding,
                                  @HeaderParam(EurekaAccept.HTTP_X_EUREKA_ACCEPT) String eurekaAccept,
                                  @Context UriInfo uriInfo,
                                  @Nullable @QueryParam(&quot;regions&quot;) String regionsStr) {

        boolean isRemoteRegionRequested = null != regionsStr &amp;amp;&amp;amp; !regionsStr.isEmpty();
        String[] regions = null;
        if (!isRemoteRegionRequested) {
            EurekaMonitors.GET_ALL.increment();
        } else {
            regions = regionsStr.toLowerCase().split(&quot;,&quot;);
            Arrays.sort(regions); // So we don't have different caches for same regions queried in different order.
            EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS.increment();
        }

         // 判断是否可以访问
        if (!registry.shouldAllowAccess(isRemoteRegionRequested)) {
            return Response.status(Status.FORBIDDEN).build();
        }
        CurrentRequestVersion.set(Version.toEnum(version));
        // 返回数据格式
        KeyType keyType = Key.KeyType.JSON;
        String returnMediaType = MediaType.APPLICATION_JSON;
        if (acceptHeader == null || !acceptHeader.contains(HEADER_JSON_VALUE)) {
            keyType = Key.KeyType.XML;
            returnMediaType = MediaType.APPLICATION_XML;
        }
        // 响应缓存键( KEY )
        Key cacheKey = new Key(Key.EntityType.Application,
                ResponseCacheImpl.ALL_APPS,
                keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions
        );

        Response response;
        if (acceptEncoding != null &amp;amp;&amp;amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) {
        // 根据cacheKey返回注册信息
            response = Response.ok(responseCache.getGZIP(cacheKey))
                    .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)
                    .header(HEADER_CONTENT_TYPE, returnMediaType)
                    .build();
        } else {
            response = Response.ok(responseCache.get(cacheKey))
                    .build();
        }
        return response;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点就是在responseCache中的get方法了了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String get(final Key key, boolean useReadOnlyCache) {
        Value payload = getValue(key, useReadOnlyCache);
        if (payload == null || payload.getPayload().equals(EMPTY_PAYLOAD)) {
            return null;
        } else {
            return payload.getPayload();
        }
    }
private final ConcurrentMap&amp;lt;Key, Value&amp;gt; readOnlyCacheMap = new ConcurrentHashMap&amp;lt;Key, Value&amp;gt;();
private final LoadingCache&amp;lt;Key, Value&amp;gt; readWriteCacheMap;

this.readWriteCacheMap =
                CacheBuilder.newBuilder().initialCapacity(1000)
                        .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)
                        .removalListener(new RemovalListener&amp;lt;Key, Value&amp;gt;() {
                            @Override
                            public void onRemoval(RemovalNotification&amp;lt;Key, Value&amp;gt; notification) {
                                Key removedKey = notification.getKey();
                                if (removedKey.hasRegions()) {
                                    Key cloneWithNoRegions = removedKey.cloneWithoutRegions();
                                    regionSpecificKeys.remove(cloneWithNoRegions, removedKey);
                                }
                            }
                        })
                        .build(new CacheLoader&amp;lt;Key, Value&amp;gt;() {
                            @Override
                            public Value load(Key key) throws Exception {
                                if (key.hasRegions()) {
                                    Key cloneWithNoRegions = key.cloneWithoutRegions();
                                    regionSpecificKeys.put(cloneWithNoRegions, key);
                                }
                                Value value = generatePayload(key);
                                return value;
                            }
                        });
                        
Value getValue(final Key key, boolean useReadOnlyCache) {
        Value payload = null;
        try {
            if (useReadOnlyCache) {
            //从只读缓存中获取注册信息
                final Value currentPayload = readOnlyCacheMap.get(key);
                if (currentPayload != null) {
                    payload = currentPayload;
                } else {
                //只读缓存不存在便从读写缓存中获取信息
                    payload = readWriteCacheMap.get(key);
                    readOnlyCacheMap.put(key, payload);
                }
            } else {
                payload = readWriteCacheMap.get(key);
            }
        } catch (Throwable t) {
            logger.error(&quot;Cannot get value for key :&quot; + key, t);
        }
        return payload;
    }    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里采用了双层缓存的结构首先从readOnlyCacheMap读取数据，如果readOnlyCacheMap读取不到则从readWriteCacheMap读取数据。readOnlyCacheMap是个ConcurrentMap结构，而readWriteCacheMap则是一个guava cache，最大容量1000，180s后自动过期。&lt;/p&gt;
&lt;p&gt;两个map之间的数据是如何交互的呢。这里有个定时任务每隔30秒去对比一次两个缓存中的数据，如果发现两者不一致，则用readWriteCacheMap的值覆盖readOnlyCacheMap的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (shouldUseReadOnlyResponseCache) {
            timer.schedule(getCacheUpdateTask(),
                    new Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)
                            + responseCacheUpdateIntervalMs),
                    responseCacheUpdateIntervalMs);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;private TimerTask getCacheUpdateTask() {
        return new TimerTask() {
            @Override
            public void run() {
                logger.debug(&quot;Updating the client cache from response cache&quot;);
                for (Key key : readOnlyCacheMap.keySet()) {
                    try {
                        CurrentRequestVersion.set(key.getVersion());
                        Value cacheValue = readWriteCacheMap.get(key);
                        Value currentCacheValue = readOnlyCacheMap.get(key);
                        //对比两个缓存的值
                        if (cacheValue != currentCacheValue) {
                            readOnlyCacheMap.put(key, cacheValue);
                        }
                    } catch (Throwable th) {
                        logger.error(&quot;Error while updating the client cache from response cache&quot;, th);
                    }
                }
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们知道了readOnlyCacheMap中的数据是从readWriteCacheMap获得的，并且每隔30s同步一次。那么还有一个问题就是readWriteCacheMap中的数据是从哪里来的呢？&lt;/p&gt;
&lt;p&gt;在readWriteCacheMap变量上find usages无法找到明确的信息，便在build方法中添加断点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this.readWriteCacheMap =
                CacheBuilder.newBuilder().initialCapacity(1000)
                        .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)
                        .removalListener(new RemovalListener&amp;lt;Key, Value&amp;gt;() {
                            @Override
                            public void onRemoval(RemovalNotification&amp;lt;Key, Value&amp;gt; notification) {
                                Key removedKey = notification.getKey();
                                if (removedKey.hasRegions()) {
                                    Key cloneWithNoRegions = removedKey.cloneWithoutRegions();
                                    regionSpecificKeys.remove(cloneWithNoRegions, removedKey);
                                }
                            }
                        })
                        .build(new CacheLoader&amp;lt;Key, Value&amp;gt;() {
                            @Override
                            public Value load(Key key) throws Exception {
                                if (key.hasRegions()) {
                                    Key cloneWithNoRegions = key.cloneWithoutRegions();
                                    regionSpecificKeys.put(cloneWithNoRegions, key);
                                }
                                //添加断点
                                Value value = generatePayload(key);
                                return value;
                            }
                        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138295/201908/1138295-20190815171808359-302117456.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终发现readWriteCacheMap的值是在同步任务中添加的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private TimerTask getCacheUpdateTask() {
        return new TimerTask() {
            @Override
            public void run() {
                logger.debug(&quot;Updating the client cache from response cache&quot;);
                for (Key key : readOnlyCacheMap.keySet()) {
                    try {
                        CurrentRequestVersion.set(key.getVersion());
                        Value cacheValue = readWriteCacheMap.get(key);
                        //触发load方法加载Value
                        Value currentCacheValue = readOnlyCacheMap.get(key);
                        //对比两个缓存的值
                        if (cacheValue != currentCacheValue) {
                            readOnlyCacheMap.put(key, cacheValue);
                        }
                    } catch (Throwable th) {
                        logger.error(&quot;Error while updating the client cache from response cache&quot;, th);
                    }
                }
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好，触发时机我们现在也知道了，我们再看下数据时怎么产生的。大致我们可以了解到readWriteCacheMap中的value是通过AbstractInstanceRegistry中的registry变量得到的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final AbstractInstanceRegistry registry;

private Value generatePayload(Key key) {
        Stopwatch tracer = null;
        try {
            String payload;
            switch (key.getEntityType()) {
                case Application:
                    boolean isRemoteRegionRequested = key.hasRegions();

                    if (ALL_APPS.equals(key.getName())) {
                        if (isRemoteRegionRequested) {
                            tracer = serializeAllAppsWithRemoteRegionTimer.start();
                            payload = getPayLoad(key, registry.getApplicationsFromMultipleRegions(key.getRegions()));
                        } else {
                            tracer = serializeAllAppsTimer.start();
                            payload = getPayLoad(key, registry.getApplications());
                        }
                    } else if (ALL_APPS_DELTA.equals(key.getName())) {
                        if (isRemoteRegionRequested) {
                            tracer = serializeDeltaAppsWithRemoteRegionTimer.start();
                            versionDeltaWithRegions.incrementAndGet();
                            versionDeltaWithRegionsLegacy.incrementAndGet();
                            payload = getPayLoad(key,
                                    registry.getApplicationDeltasFromMultipleRegions(key.getRegions()));
                        } else {
                            tracer = serializeDeltaAppsTimer.start();
                            versionDelta.incrementAndGet();
                            versionDeltaLegacy.incrementAndGet();
                            payload = getPayLoad(key, registry.getApplicationDeltas());
                        }
                    } else {
                        tracer = serializeOneApptimer.start();
                        payload = getPayLoad(key, registry.getApplication(key.getName()));
                    }
                    break;
                case VIP:
                case SVIP:
                    tracer = serializeViptimer.start();
                    payload = getPayLoad(key, getApplicationsForVip(key, registry));
                    break;
                default:
                    logger.error(&quot;Unidentified entity type: &quot; + key.getEntityType() + &quot; found in the cache key.&quot;);
                    payload = &quot;&quot;;
                    break;
            }
            return new Value(payload);
        } finally {
            if (tracer != null) {
                tracer.stop();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AbstractInstanceRegistry中的registry是一个多层缓存结构。client注册，续约，下线的数据都是通过registry进行保存&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final ConcurrentHashMap&amp;lt;String, Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt;&amp;gt; registry
            = new ConcurrentHashMap&amp;lt;String, Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;registry有一个定时任务每隔60s去剔除过期的数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;evictionTimer.schedule(evictionTaskRef.get(),
                //60*1000
                serverConfig.getEvictionIntervalTimerInMs(),
                serverConfig.getEvictionIntervalTimerInMs());
                
@Override
        public void run() {
            try {
                long compensationTimeMs = getCompensationTimeMs();
                logger.info(&quot;Running the evict task with compensationTime {}ms&quot;, compensationTimeMs);
                evict(compensationTimeMs);
            } catch (Throwable e) {
                logger.error(&quot;Could not run the evict task&quot;, e);
            }
        }                &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结下&lt;/p&gt;
&lt;p&gt;eureka客户端注册，续约，下线都会请求到server端，server端把数据保存在registry这个双层map中。每隔60s会有定时任务去检查registry中保存的租约是否已经过期(租约有效期是90s)，然后每隔30s会有定时任务更新readWriteCacheMap的值以及同步readWriteCacheMap和readOnlyCacheMap的值&lt;/p&gt;

&lt;p&gt;基于上述流程，想象下，假如一个服务异常下线server端没有接受到下线请求，那么会有以下情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0s 时服务未通知 Eureka Client 直接下线；&lt;/li&gt;
&lt;li&gt;29s 时第一次过期检查 evict 未超过 90s；&lt;/li&gt;
&lt;li&gt;89s 时第二次过期检查 evict 未超过 90s；&lt;/li&gt;
&lt;li&gt;149s 时第三次过期检查 evict 未续约时间超过了 90s，故将该服务实例从 registry 中删除；&lt;/li&gt;
&lt;li&gt;179s 时定时任务更新readWriteCacheMap以及从 readWriteCacheMap 更新至 readOnlyCacheMap;&lt;/li&gt;
&lt;li&gt;209s 时 Eureka Client 从 Eureka Server 的 readOnlyCacheMap 更新；&lt;/li&gt;
&lt;li&gt;239s 时 Ribbon 从 Eureka Client 更新。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(ribbon同样也有缓存更新策略，默认30s)&lt;/p&gt;
&lt;p&gt;因此，极限情况下服务消费者最长感知时间将无限趋近 240s。&lt;/p&gt;
&lt;p&gt;怎么优化呢&lt;/p&gt;
&lt;p&gt;server端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;减少registry服务剔除任务时间
减少两个缓存同步定时任务时间
小型系统可以直接去掉readOnlyCacheMap&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务提供端&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;减少心跳时间
减少租约过期时间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务消费端&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;减少ribbon更新时间
减少fetchRegist时间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EurekaServer修改如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#eureka server刷新readCacheMap的时间，注意，client读取的是readCacheMap，这个时间决定了多久会把readWriteCacheMap的缓存更新到readCacheMap上
#默认30s
eureka.server.responseCacheUpdateIntervalMs=3000
#eureka server缓存readWriteCacheMap失效时间，这个只有在这个时间过去后缓存才会失效，失效前不会更新，过期后从registry重新读取注册服务信息，registry是一个ConcurrentHashMap。
#由于启用了evict其实就用不太上改这个配置了
#默认180s
eureka.server.responseCacheAutoExpirationInSeconds=180

#启用主动失效，并且每次主动失效检测间隔为3s

Eureka Server会定时（间隔值是eureka.server.eviction-interval-timer-in-ms，默认值为0，默认情况不删除实例）进行检查，
如果发现实例在在一定时间（此值由客户端设置的eureka.instance.lease-expiration-duration-in-seconds定义，默认值为90s）
内没有收到心跳，则会注销此实例。
eureka.server.eviction-interval-timer-in-ms=3000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Eureka服务提供方修改如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#服务过期时间配置,超过这个时间没有接收到心跳EurekaServer就会将这个实例剔除
#注意，EurekaServer一定要设置eureka.server.eviction-interval-timer-in-ms否则这个配置无效，这个配置一般为服务刷新时间配置的三倍
#默认90s
eureka.instance.lease-expiration-duration-in-seconds=15
#服务刷新时间配置，每隔这个时间会主动心跳一次
#默认30s
eureka.instance.lease-renewal-interval-in-seconds=5

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Eureka服务调用方修改如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#eureka client刷新本地缓存时间
#默认30s
eureka.client.registryFetchIntervalSeconds=5
#eureka客户端ribbon刷新时间
#默认30s
ribbon.ServerListRefreshInterval=5000&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 15 Aug 2019 13:49:00 +0000</pubDate>
<dc:creator>XuMinzhe</dc:creator>
<og:description>果然好记性不如烂笔头，再简单的东西不记录下来总是会忘的！ 本文首先会分析eureka中的缓存架构。并在此基础上优化服务之间的感知 [TOC] Eureka Client获取注册信息 eureka cl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xmzJava/p/11359636.html</dc:identifier>
</item>
</channel>
</rss>