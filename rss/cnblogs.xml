<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java中synchronized关键字你知道多少 - 为何不是梦</title>
<link>http://www.cnblogs.com/ibigboy/p/11415439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ibigboy/p/11415439.html</guid>
<description>&lt;h2&gt;1.什么是synchronized&lt;/h2&gt;
&lt;p&gt;我们将其理解为同步锁，可以实现共享资源的同步访问，解决线程并发的安全问题。synchronize翻译成中文：同步，使同步。synchronized：已同步。&lt;/p&gt;
&lt;h3&gt;1.1 怎么使用的&lt;/h3&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁&lt;/li&gt;
&lt;li&gt;修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。&lt;/li&gt;
&lt;li&gt;修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.早期的synchronized&lt;/h2&gt;
&lt;p&gt;JDK1.6之前属于重量级锁，依赖于操作系统的Mutex Lock，Java的线程映射到操作系统的原生线程，需要操作系统申请互斥量，操作系统对线程的切换，需要从用户态切换到内核态，比较耗时，效率底下。&lt;/p&gt;

&lt;h2&gt;3.对synchronized的优化&lt;/h2&gt;
&lt;p&gt;JDK1.6之后在JVM层面对synchronized底层做了很多的优化，包括偏向锁，轻量级锁，自旋锁，自适应自旋锁，锁消除，锁粗化等优化技术。&lt;/p&gt;
&lt;h3&gt;3.1 偏向锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目的：&lt;/strong&gt;在没有线程竞争的情况下，减少传统的重量级锁使用操作系统互斥量的开销，提升性能。&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;在没有锁竞争的情况下，会把整个锁消除&lt;/li&gt;
&lt;li&gt;偏向于第一个获取到偏向锁的线程&lt;/li&gt;
&lt;li&gt;如果在接下来的执行中偏向锁没有被其他线程获取，那么拥有该锁的线程就不需要同步&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;变化：&lt;/strong&gt;在锁竞争激烈的场合，偏向锁失效。原因是，在此情况下，极有可能每次申请锁的线程不是同一个线程，所以此时不应该使用偏向锁，否则得不偿失。But，偏向锁失效后，并不会立即膨胀为重量级锁，而是首先升级为轻量级锁。关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。&lt;/p&gt;
&lt;h3&gt;3.2 轻量级锁&lt;/h3&gt;
&lt;p&gt;当偏向锁失效，JVM不会立即升级为重量级锁，而是试图使用轻量级锁的优化手段（JDK1.6之后加入的）。轻量级锁不是为了替代重量级锁，它的本意是是在没有线程竞争的情况下，减少传统的重量级锁使用操作系统互斥量的开销，提升性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的：&lt;/strong&gt;和偏向锁一样&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;和偏向锁不同，轻量级锁使用CAS操作代替重量级锁。&lt;/li&gt;
&lt;li&gt;使用轻量级锁，不需要申请互斥量。&lt;/li&gt;
&lt;li&gt;轻量级锁的加锁和释放锁都是CAS操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;变化：&lt;/strong&gt;对于大多数锁来说，在整个同步周期都不存在竞争，这来自经验数据。如果没有竞争，轻量级锁使用CAS操作，避免了使用互斥锁的开销。如果存在竞争，除了互斥锁的开销，还会有额外的CAS操作，所以如果存在锁竞争，轻量级锁比重量级锁更慢。如果竞争激烈轻量级锁会迅速膨胀为重量级锁。关于轻量级锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。&lt;/p&gt;
&lt;h3&gt;3.3 自旋锁和自适应自旋锁&lt;/h3&gt;
&lt;p&gt;轻量级锁失效后，JVM避免线程真的在操作系统层面挂起，还会进行一项成为自旋锁的优化手段。在JDK1.6之前就有这项技术了，只是他是默认关闭的，可以通过参数--XX:+UseSpinning开启。JDK1.6之后默认开启。自旋不能完全替代阻塞，因为它还要占用处理器的时间。如果锁被占用的时间短，那么自旋锁的效果就好；否则，反之。自旋等待的时间必须固定，如果超过限定的次数，仍然没有获取到锁，就挂起线程。自旋默认10次，可以使用参数--XX:PreBlockSpin修改。&lt;/p&gt;
&lt;h4&gt;3.3.1 为什么会有自旋锁&lt;/h4&gt;
&lt;p&gt;互斥同步对性能最大的影响是阻塞的实现，因为线程的挂起和恢复都需要转入内核态去完成（用户态到内核态的转换将会耗费一定的时间）。而一般线程持有锁的时间并不会太长，如果仅仅为了这一点时间而挂起或恢复线程将会得不偿失。所以JVM团队就想：&quot;能否让后面来的请求获取锁的线程等待一会儿而不被挂起？看看持有锁的线程是否很快就会释放锁&quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的：&lt;/strong&gt;为了减少线程的挂起和恢复，减少带来的系统开销，引入自旋锁。&lt;/p&gt;
&lt;h4&gt;3.3.2 如何实现自旋&lt;/h4&gt;
&lt;p&gt;为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做&lt;strong&gt;自旋&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;3.3.3 自旋的特点&lt;/h4&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;执行忙循环&lt;/li&gt;
&lt;li&gt;自旋次数固定（默认10次）&lt;/li&gt;
&lt;li&gt;JDK1.6之前默认关闭，之后默认打开&lt;/li&gt;
&lt;li&gt;效果的好坏依赖于锁被占用的时间的长短&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;3.3.4 自适应自旋锁&lt;/h4&gt;
&lt;p&gt;另外，在JDK1.6时候引入了自适应自旋锁。改进：自旋次数不是固定的。根据上次同一个锁的自旋次数和锁的拥有者的状态来确定自旋次数。JVM变得越来越聪明了。与自旋锁的区别就是自旋次数不固定。&lt;/p&gt;
&lt;h3&gt;3.4 锁消除&lt;/h3&gt;
&lt;p&gt;即使JVM正在运行，如果检测到共享数据不可能存在竞争，将会执行锁消除操作。这将会节省毫无意义的请求锁的时间。&lt;/p&gt;
&lt;h3&gt;3.5 锁粗化&lt;/h3&gt;
&lt;p&gt;原则上我们写代码，总是建议将Synchronized代码块的作用范围限制的尽量小，只在共享数据的实际作用域才进行同步，使需要同步的操作数尽量小，如果存在竞争，等待线程也会尽快拿到锁。大部分情况下，上面的原则没有问题，但是如果一些列的连续操作都对同一个对象反复加锁解锁，会带来很多不必要的性能消耗。&lt;/p&gt;
&lt;h2&gt;4.Synchronized和ReenTrantLock对比&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;① 两者都是可重入锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ ReenTrantLock 比 synchronized 增加了一些高级功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.等待可中断；b.&lt;/strong&gt;&lt;strong&gt;可实现公平锁；c.可实现选择性通知（锁可以绑定多个条件）&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;strong&gt;ReenTrantLock提供了一种能够中断等待锁的线程的机制&lt;/strong&gt;，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ReenTrantLock可以指定是公平锁还是非公平锁。&lt;/strong&gt;&lt;strong&gt;而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。&lt;/strong&gt;ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的&lt;code&gt;ReentrantLock(boolean fair)&lt;/code&gt;构造方法来制定是否是公平的。&lt;/li&gt;
&lt;li&gt;synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），&lt;strong&gt;线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。&lt;/strong&gt;&lt;strong&gt;在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”&lt;/strong&gt; ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④ 性能已不是选择标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1205690/201908/1205690-20190826222315319-1023177722.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 27 Aug 2019 00:51:00 +0000</pubDate>
<dc:creator>为何不是梦</dc:creator>
<og:description>1.什么是synchronized 我们将其理解为同步锁，可以实现共享资源的同步访问，解决线程并发的安全问题。synchronize翻译成中文：同步，使同步。synchronized：已同步。 1.1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ibigboy/p/11415439.html</dc:identifier>
</item>
<item>
<title>跟我学SpringCloud | 第十五篇：微服务利剑之APM平台（一）Skywalking - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11416108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11416108.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084529704-1600769620.jpg&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Springboot: 2.1.7.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SpringCloud: Greenwich.SR2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;skywalking概述&quot;&gt;1. Skywalking概述&lt;/h2&gt;
&lt;p&gt;Skywalking与2016年11月2日由国人吴晟在Github上传v1.0版本，用于提供分布式链路追踪功能，从5.x开始，成为一个功能较为完善的APM（Application Performance Management）系统，2019年4月17日从Apache孵化器毕业，正式成为Apache顶级项目。提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。官方对自己介绍是专为微服务，云原生和基于容器（Docker，Kubernetes，Mesos）架构而设计。&lt;/p&gt;
&lt;h2 id=&quot;skywalking主要功能&quot;&gt;2. Skywalking主要功能&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;服务，服务实例，端点指标分析&lt;/li&gt;
&lt;li&gt;根本原因分析&lt;/li&gt;
&lt;li&gt;服务拓扑图分析&lt;/li&gt;
&lt;li&gt;服务，服务实例和端点依赖性分析&lt;/li&gt;
&lt;li&gt;慢服务检测&lt;/li&gt;
&lt;li&gt;性能优化&lt;/li&gt;
&lt;li&gt;分布式跟踪和上下文传播&lt;/li&gt;
&lt;li&gt;数据库访问指标、检测慢速数据库访问语句（包括SQL）&lt;/li&gt;
&lt;li&gt;告警&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;skywalking主要特性&quot;&gt;3. Skywalking主要特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;多种监控手段，语言探针和service mesh&lt;/li&gt;
&lt;li&gt;多语言自动探针，Java，.NET Core和Node.JS&lt;/li&gt;
&lt;li&gt;多种后端存储支持&lt;/li&gt;
&lt;li&gt;轻量高效&lt;/li&gt;
&lt;li&gt;模块化，UI、存储、集群管理多种机制可选&lt;/li&gt;
&lt;li&gt;支持告警&lt;/li&gt;
&lt;li&gt;优秀的可视化方案&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;skywalking架构简介&quot;&gt;4. Skywalking架构简介&lt;/h2&gt;
&lt;p&gt;先看一下官方提供的架构图，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084532918-1994315461.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Skywalking总体由四个部分&lt;code&gt;agent&lt;/code&gt;、&lt;code&gt;collector&lt;/code&gt;、&lt;code&gt;webapp-ui&lt;/code&gt;、&lt;code&gt;storage&lt;/code&gt;组成。图10-11从上到下是应用层接入，可以使用无入侵性的&lt;code&gt;agent&lt;/code&gt;探针接入，通过HTTP或者gRPC讲数据发送至Skywalking分析平台&lt;code&gt;collector&lt;/code&gt;，&lt;code&gt;collector&lt;/code&gt;对接受到的数据进行聚合分析，最后存储至&lt;code&gt;storage&lt;/code&gt;中，这里支持多种存储方式，比较常用的有H2和ElasticSearch，最后可以由&lt;code&gt;webapp-ui&lt;/code&gt;对所有的数据进行展示。&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud与skywalking实战&quot;&gt;5. Spring Cloud与Skywalking实战&lt;/h2&gt;
&lt;h3 id=&quot;skywalking部署构建&quot;&gt;5.1 Skywalking部署构建&lt;/h3&gt;
&lt;p&gt;在介绍实战之前，我们先简单介绍一下Skywalking部署构建方案。&lt;/p&gt;
&lt;p&gt;这里存储方式笔者选择使用ElasticSearch，具体版本是6.5.0，ElasticSearch的构建方式选择使用Docker，直接使用Linux搭建有点复杂，不适合初学者，使用Docker构建简单方便。&lt;/p&gt;
&lt;p&gt;笔者构建的一些前置条件：&lt;/p&gt;
&lt;p&gt;java：1.8&lt;br/&gt;CentOS：7.6&lt;/p&gt;
&lt;p&gt;如果当前CentOS上没有Docker环境，可以使用下面的语句快速构建：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install docker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当构建成功后，可以使用下面的语句查看当前Docker的版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker -v&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;笔者这里的输出是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Docker version 1.13.1, build 7f2769b/1.13.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装好Docker以后，最好配置一下国内的镜像站，否则在网络不好的情况下可能出现Docker下载失败等情况，可以使用下面的语句来修改镜像地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/docker/daemon.json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;笔者这里使用的是阿里云的镜像加速，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;registry-mirrors&quot;: [&quot;https://xxxxxx.mirror.aliyuncs.com&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各位读者可以自己去阿里云上开通自己的镜像加速，具体不多做介绍。&lt;/p&gt;
&lt;p&gt;使用Docker构建ElasticSearch6.5.0，首先，需要下载ElasticSearch6.5.0的镜像，输入以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull elasticsearch:6.5.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待程序下载完成，完成后就可以启动镜像了，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d --restart=always --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:6.5.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ElasticSearch的默认启动内存是1g，如果当前服务器的内存不足1g，可以使用参数&lt;code&gt;-e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;&lt;/code&gt;限制ElasticSearch的启动内存大小，完整的语句如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d --restart=always -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:6.5.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功以后可以使用如下语句看一下是否启动成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084533196-2060813404.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ElasticSearch6.5.0单节点版已经构建完成，为了方便后续操作，需要修改一个ElasticSearch的命名，输入命令&lt;code&gt;docker exec -it es /bin/bash&lt;/code&gt;进入容器文件目录，输入&lt;code&gt;vi config/elasticsearch.yml&lt;/code&gt;进入ElasticSearch配置文件，修改&lt;code&gt;cluster.name&lt;/code&gt;的值，笔者这里修改为&lt;code&gt;CollectorDBCluster&lt;/code&gt;，修改完成后，保存当前修改，输入&lt;code&gt;exit&lt;/code&gt;退出容器文件目录，输入&lt;code&gt;docker restart es&lt;/code&gt;重启当前容器，在浏览器输入http://192.168.44.128:9200/，看到如下信息可以证明ElasticSearch6.5.0单节点版已经在正常的运行了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;name&quot; : &quot;V-N2_ZQ&quot;,
  &quot;cluster_name&quot; : &quot;CollectorDBCluster&quot;,
  &quot;cluster_uuid&quot; : &quot;r9bFZ90WRyqSpMz80u61Yg&quot;,
  &quot;version&quot; : {
    &quot;number&quot; : &quot;6.5.0&quot;,
    &quot;build_flavor&quot; : &quot;default&quot;,
    &quot;build_type&quot; : &quot;tar&quot;,
    &quot;build_hash&quot; : &quot;816e6f6&quot;,
    &quot;build_date&quot; : &quot;2018-11-09T18:58:36.352602Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;7.5.0&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;
  },
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Skywalking构建，进入Skywalking官网，进入下载页面（&lt;a href=&quot;http://skywalking.apache.org/downloads/&quot; class=&quot;uri&quot;&gt;http://skywalking.apache.org/downloads/&lt;/a&gt; ），如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084533647-1481270441.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为我们是要在CentOS上运行，所以这里选择Linux二进制版，就是已经编译好的版本，无需我们自己编译，下载至我们的CentOS后，解压可以看到目录结构，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084533794-2048663480.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;agent：探针相关，后面会做更加详细的介绍。&lt;/li&gt;
&lt;li&gt;bin：这里放的是oapService和webappService的启动脚本，当然也有执行两个脚本的合并脚本&lt;code&gt;startup.sh&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;config：这里主要存放的是collector的配置信息，我们需要修改这里的application.yml中的有关ElasticSearch的配置，如下图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084534254-146346917.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;storage.elasticsearch.nameSpace&lt;/code&gt;为我们前面构建ElasticSearch设置的&lt;code&gt;cluster.name&lt;/code&gt;，笔者这里的值为&lt;code&gt;CollectorDBCluster&lt;/code&gt;，同时修改&lt;code&gt;storage.elasticsearch.clusterNodes&lt;/code&gt;为我们当前构建的ElasticSearch的地址。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;logs：存放collector和webapp-ui生成的日志。&lt;/li&gt;
&lt;li&gt;webapp：这里存放的是Skywalking展示UI的jar和配置文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Skywalking中默认使用的端口有8080、11800、12800，请保证这些端口未被占用，如需修改，可以修改&lt;code&gt;config&lt;/code&gt;目录中的&lt;code&gt;application.yml&lt;/code&gt;和&lt;code&gt;webapp&lt;/code&gt;目录中的&lt;code&gt;webapp.yml&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来启动collector和webapp-ui，进入bin目录中，执行命令&lt;code&gt;./startup.sh&lt;/code&gt;，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084534391-1243231951.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器访问http://192.168.44.128:8080/，可以看到webapp-ui的仪表盘，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084534828-797388021.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Skywalking部署到这里就结束了，下面我们开始介绍Spring Cloud如何与Skywalking整合使用。&lt;/p&gt;
&lt;h3 id=&quot;spring-cloud整合skywalking实战&quot;&gt;5.2 Spring Cloud整合Skywalking实战&lt;/h3&gt;
&lt;p&gt;先简单介绍一下案例内容，我们将创建4个工程，分别为Zuul-Service、Eureka-Service、Consumer-Service和Provider-Service，请求通过Zuul-Service访问至Consumer-Service再访问至Provider-Service完成一次链路调用。&lt;/p&gt;
&lt;p&gt;整体架构图如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084535010-650809955.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体实现代码列出，各位读者可以参考GitHub仓库（&lt;a href=&quot;https://github.com/meteor1993/SpringCloudLearning/tree/master/chapter15&quot; class=&quot;uri&quot;&gt;https://github.com/meteor1993/SpringCloudLearning/tree/master/chapter15&lt;/a&gt;），下面我们介绍Spring Cloud是如何与Skywalking整合的。&lt;/p&gt;
&lt;p&gt;这里我们需要使用到Skywalking的探针agent，我们在工程chapter15的跟目录中新建一个文件夹，命名为&lt;code&gt;skywalking&lt;/code&gt;，讲刚才解压的Skywalking中的agent整个文件夹copy到&lt;code&gt;skywalking&lt;/code&gt;，这里我们启动时只需要配置javaagen命令加载agent探针即可，在idea中使用需要修改启动配置，点击右上角的&lt;code&gt;Edit Configurations...&lt;/code&gt;，在打开的窗口中选择&lt;code&gt;Environment-&amp;gt;VM Options&lt;/code&gt;，配置如下脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-javaagent:D:\Development\SpringCloudLearning\chapter15\skywalking\agent\skywalking-agent.jar
-Dskywalking.agent.service_name=zuul-service
-Dskywalking.collector.backend_service=192.168.44.128:11800&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084535451-1019488145.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还可以使用java -jar的方式来加载agent探针，我们将整个maven项目打包，运行mvn install的命令，使用java -jar的方式来启动，启动命令中增加启动参数，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-javaagent:D:\Development\SpringCloudLearning\chapter15\skywalking\agent\skywalking-agent.jar -Dskywalking.agent.service_name=consumer-service -Dskywalking.collector.backend_service=192.168.44.128:11800 -jar zuul-0.0.1-SNAPSHOT.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;顺次启动四个工程后，使用浏览器访问：&lt;a href=&quot;http://localhost:8080/client/hello?name=spring%EF%BC%8C%E5%A4%9A%E5%88%B7%E6%96%B0%E5%87%A0%E6%AC%A1%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%86%8D%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEhttp://192.168.44.128:8080/%EF%BC%8C%E5%A6%82&quot; class=&quot;uri&quot;&gt;http://localhost:8080/client/hello?name=spring，多刷新几次后，我们再使用浏览器访问http://192.168.44.128:8080/，如&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084536132-1236355807.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;all_heatmap：所有服务响应时间的热点图&lt;/li&gt;
&lt;li&gt;all_p99：所有服务响应时间的 p99 值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;点击上边栏的拓扑图，可以看到当前我们工程的一个依赖拓扑关系，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084536631-321558622.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击上边栏的追踪，可以看到左边是当前所有的访问请求，随便点击一个，可以在右边看到一个详细的链路追踪过程，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084537315-598835796.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击链路，可以看到一些标记信息，包含端点、跨度类型、成功还是失败，以及一些Exception信息，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084538088-885491743.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击仪表盘页面的Service，可以看到一些服务相关的信息，如平均响应时间、平均吞吐量、平均时延统计，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084538843-1009291102.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;service_instance_sla：服务实例的成功率&lt;/li&gt;
&lt;li&gt;service_instance_resp_time：服务实例的平均响应时间&lt;/li&gt;
&lt;li&gt;service_instance_cpm：服务实例每分钟调用次数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;点击仪表盘页面的Endpoint，可以看到一些端点相关的信息，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084539562-395928900.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;endpoint_cpm：端点每分钟调用次数&lt;/li&gt;
&lt;li&gt;endpoint_avg：端点平均响应时间&lt;/li&gt;
&lt;li&gt;endpoint_sla：端点成功率&lt;/li&gt;
&lt;li&gt;endpoint_p99：端点响应时间的 p99 值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;点击仪表盘页面的Instance，可以看到一些JVM相关的信息，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190827084540491-921169020.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，Spring Cloud与Skywalking的介绍就结束了，感兴趣的朋友可以前往Github的官方网站进行查询。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;6. 小结&lt;/h2&gt;
&lt;p&gt;这里总结一下整个案例的启动顺序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动ElasticSearch&lt;/li&gt;
&lt;li&gt;启动collector&lt;/li&gt;
&lt;li&gt;启动web-ui（或者使用整合脚本启动）&lt;/li&gt;
&lt;li&gt;启动Agent（Eureka、provider、consumer、zuul）&lt;/li&gt;
&lt;li&gt;应用调用&lt;/li&gt;
&lt;li&gt;访问web-ui查看统计信息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上启动顺序供各位读者参考，请各位读者最好按照以上顺序启动，因为不同的组件之前其实是有相互依赖关系的，如果随意更改启动顺序可能会造成某些未知问题。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Aug 2019 00:46:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>SpringCloud系列教程 | 第十五篇：微服务利剑之APM平台（一）Skywalking Springboot: 2.1.7.RELEASE SpringCloud: Greenwich.SR2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11416108.html</dc:identifier>
</item>
<item>
<title>textRNN &amp; textCNN的网络结构与代码实现！ - mantch</title>
<link>http://www.cnblogs.com/mantch/p/11416104.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantch/p/11416104.html</guid>
<description>&lt;h2 id=&quot;什么是textrnn&quot;&gt;1. 什么是textRNN&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;textRNN指的是利用RNN循环神经网络解决文本分类问题&lt;/strong&gt;，文本分类是自然语言处理的一个基本任务，试图推断出给定文本(句子、文档等)的标签或标签集合。&lt;/p&gt;
&lt;p&gt;文本分类的应用非常广泛，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;垃圾邮件分类：2分类问题，判断邮件是否为垃圾邮件&lt;/li&gt;
&lt;li&gt;情感分析：2分类问题：判断文本情感是积极还是消极；多分类问题：判断文本情感属于{非常消极，消极，中立，积极，非常积极}中的哪一类。&lt;/li&gt;
&lt;li&gt;新闻主题分类：判断一段新闻属于哪个类别，如财经、体育、娱乐等。根据类别标签的数量，可以是2分类也可以是多分类。&lt;/li&gt;
&lt;li&gt;自动问答系统中的问句分类&lt;/li&gt;
&lt;li&gt;社区问答系统中的问题分类：多标签多分类(对一段文本进行多分类，该文本可能有多个标签)，如知乎看山杯&lt;/li&gt;
&lt;li&gt;让AI做法官：基于案件事实描述文本的罚金等级分类(多分类)和法条分类(多标签多分类)&lt;/li&gt;
&lt;li&gt;判断新闻是否为机器人所写：2分类&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;textrnn的原理&quot;&gt;1.1 textRNN的原理&lt;/h3&gt;
&lt;p&gt;在一些自然语言处理任务中，当对序列进行处理时，我们一般会采用循环神经网络RNN，尤其是它的一些变种，如LSTM(更常用)，GRU。当然我们也可以把RNN运用到文本分类任务中。&lt;/p&gt;
&lt;p&gt;这里的文本可以一个句子，文档(短文本，若干句子)或篇章(长文本)，因此每段文本的长度都不尽相同。在对文本进行分类时，我们一般会指定一个固定的输入序列/文本长度：该长度可以是最长文本/序列的长度，此时其他所有文本/序列都要进行填充以达到该长度；该长度也可以是训练集中所有文本/序列长度的均值，此时对于过长的文本/序列需要进行截断，过短的文本则进行填充。总之，要使得训练集中所有的文本/序列长度相同，该长度除之前提到的设置外，也可以是其他任意合理的数值。在测试时，也需要对测试集中的文本/序列做同样的处理。&lt;/p&gt;
&lt;p&gt;假设训练集中所有文本/序列的长度统一为n，我们需要对文本进行分词，并使用词嵌入得到每个词固定维度的向量表示。对于每一个输入文本/序列，我们可以在RNN的每一个时间步长上输入文本中一个单词的向量表示，计算当前时间步长上的隐藏状态，然后用于当前时间步骤的输出以及传递给下一个时间步长并和下一个单词的词向量一起作为RNN单元输入，然后再计算下一个时间步长上RNN的隐藏状态，以此重复...直到处理完输入文本中的每一个单词，由于输入文本的长度为n，所以要经历n个时间步长。&lt;/p&gt;
&lt;p&gt;基于RNN的文本分类模型非常灵活，有多种多样的结构。接下来，我们主要介绍两种典型的结构。&lt;/p&gt;
&lt;h2 id=&quot;textrnn网络结构&quot;&gt;2. textRNN网络结构&lt;/h2&gt;
&lt;h3 id=&quot;structure-1&quot;&gt;2.1 structure 1&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;流程&lt;/strong&gt;：embedding---&amp;gt;BiLSTM---&amp;gt;concat final output/average all output-----&amp;gt;softmax layer&lt;/p&gt;
&lt;p&gt;结构图如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kkweishe/images/raw/master/ML/2019-8-26_8-57-47.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般取前向/反向LSTM在最后一个时间步长上隐藏状态，然后进行拼接，在经过一个softmax层(输出层使用softmax激活函数)进行一个多分类；或者取前向/反向LSTM在每一个时间步长上的隐藏状态，对每一个时间步长上的两个隐藏状态进行拼接，然后对所有时间步长上拼接后的隐藏状态取均值，再经过一个softmax层(输出层使用softmax激活函数)进行一个多分类(2分类的话使用sigmoid激活函数)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上述结构也可以添加dropout/L2正则化或BatchNormalization 来防止过拟合以及加速模型训练。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;structure-2&quot;&gt;2.2 structure 2&lt;/h3&gt;
&lt;p&gt;流程：embedding--&amp;gt;BiLSTM----&amp;gt;(dropout)--&amp;gt;concat ouput---&amp;gt;UniLSTM---&amp;gt;(droput)--&amp;gt;softmax layer&lt;/p&gt;
&lt;p&gt;结构图如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kkweishe/images/raw/master/ML/2019-8-26_9-1-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与之前结构不同的是，在双向LSTM(上图不太准确，底层应该是一个双向LSTM)的基础上又堆叠了一个单向的LSTM。把双向LSTM在每一个时间步长上的两个隐藏状态进行拼接，作为上层单向LSTM每一个时间步长上的一个输入，最后取上层单向LSTM最后一个时间步长上的隐藏状态，再经过一个softmax层(输出层使用softamx激活函数，2分类的话则使用sigmoid)进行一个多分类。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;2.3 总结&lt;/h3&gt;
&lt;p&gt;TextRNN的结构非常灵活，可以任意改变。比如把LSTM单元替换为GRU单元，把双向改为单向，添加dropout或BatchNormalization以及再多堆叠一层等等。TextRNN在文本分类任务上的效果非常好，与TextCNN不相上下，但RNN的训练速度相对偏慢，一般2层就已经足够多了。&lt;/p&gt;
&lt;h2 id=&quot;什么是textcnn&quot;&gt;3. 什么是textCNN&lt;/h2&gt;
&lt;p&gt;在“卷积神经⽹络”中我们探究了如何使⽤⼆维卷积神经⽹络来处理⼆维图像数据。在之前的语⾔模型和⽂本分类任务中，我们将⽂本数据看作是只有⼀个维度的时间序列，并很⾃然地使⽤循环神经⽹络来表征这样的数据。&lt;strong&gt;其实，我们也可以将⽂本当作⼀维图像，从而可以⽤⼀维卷积神经⽹络来捕捉临近词之间的关联。本节将介绍将卷积神经⽹络应⽤到⽂本分析的开创性⼯作之⼀：textCNN&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;维卷积层&quot;&gt;3.1 ⼀维卷积层&lt;/h3&gt;
&lt;p&gt;在介绍模型前我们先来解释⼀维卷积层的⼯作原理。与⼆维卷积层⼀样，⼀维卷积层使⽤⼀维的互相关运算。在⼀维互相关运算中，卷积窗口从输⼊数组的最左⽅开始，按从左往右的顺序，依次在输⼊数组上滑动。当卷积窗口滑动到某⼀位置时，窗口中的输⼊⼦数组与核数组按元素相乘并求和，得到输出数组中相应位置的元素。如下图所⽰，输⼊是⼀个宽为7的⼀维数组，核数组的宽为2。可以看到输出的宽度为 7 - 2 + 1 = 6，且第⼀个元素是由输⼊的最左边的宽为2的⼦数组与核数组按元素相乘后再相加得到的：0 &lt;em&gt;×&lt;/em&gt; 1 + 1 × 2 = 2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kkweishe/images/raw/master/ML/2019-8-26_9-35-48.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多输⼊通道的⼀维互相关运算也与多输⼊通道的⼆维互相关运算类似：在每个通道上，将核与相应的输⼊做⼀维互相关运算，并将通道之间的结果相加得到输出结果。下图展⽰了含3个输⼊ 通道的⼀维互相关运算，其中阴影部分为第⼀个输出元素及其计算所使⽤的输⼊和核数组元素： 0 &lt;em&gt;×&lt;/em&gt; 1 + 1 &lt;em&gt;×&lt;/em&gt; 2 + 1 &lt;em&gt;×&lt;/em&gt; 3 + 2 &lt;em&gt;×&lt;/em&gt; 4 + 2 &lt;em&gt;×&lt;/em&gt; (-1) + 3 &lt;em&gt;×&lt;/em&gt; (-3) = 2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kkweishe/images/raw/master/ML/2019-8-26_9-38-34.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由⼆维互相关运算的定义可知，多输⼊通道的⼀维互相关运算可以看作单输⼊通道的⼆维互相关运算。如下图所⽰，我们也可以将上图中多输⼊通道的⼀维互相关运算以等价的单输⼊通道的⼆维互相关运算呈现。这⾥核的⾼等于输⼊的⾼。下图的阴影部分为第⼀个输出元素及其计算所使⽤的输⼊和核数组元素：2 &lt;em&gt;×&lt;/em&gt; (-1) + 3 &lt;em&gt;×&lt;/em&gt; (-3) + 1 &lt;em&gt;×&lt;/em&gt; 3 + 2 &lt;em&gt;×&lt;/em&gt; 4 + 0 &lt;em&gt;×&lt;/em&gt; 1 + 1 &lt;em&gt;×&lt;/em&gt; 2 = 2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kkweishe/images/raw/master/ML/2019-8-26_9-52-37.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上都是输出都只有⼀个通道。我们在“多输⼊通道和多输出通道”⼀节中介绍了如何在⼆维卷积层中指定多个输出通道。类似地，我们也可以在⼀维卷积层指定多个输出通道，从而拓展卷积层中的模型参数。&lt;/p&gt;
&lt;h3 id=&quot;时序最池化层&quot;&gt;3. 2 时序最⼤池化层&lt;/h3&gt;
&lt;p&gt;类似地，我们有⼀维池化层。textCNN中使⽤的时序最⼤池化（max-over-time pooling）层实际上对应⼀维全局最⼤池化层：假设输⼊包含多个通道，各通道由不同时间步上的数值组成，各通道的输出即该通道所有时间步中最⼤的数值。因此，时序最⼤池化层的输⼊在各个通道上的时间步数可以不同。为提升计算性能，我们常常将不同⻓度的时序样本组成⼀个小批量，并通过在较短序列后附加特殊字符（如0）令批量中各时序样本⻓度相同。这些⼈为添加的特殊字符当然是⽆意义的。由于时序最⼤池化的主要⽬的是抓取时序中最重要的特征，它通常能使模型不受⼈为添加字符的影响。&lt;/p&gt;
&lt;h3 id=&quot;textcnn模型&quot;&gt;3.3 textCNN模型&lt;/h3&gt;
&lt;p&gt;textCNN模型主要使⽤了⼀维卷积层和时序最⼤池化层。假设输⼊的⽂本序列由&lt;em&gt;n&lt;/em&gt;个词组成，每个词⽤&lt;em&gt;d&lt;/em&gt;维的词向量表⽰。那么输⼊样本的宽为&lt;em&gt;n&lt;/em&gt;，⾼为1，输⼊通道数为&lt;em&gt;d&lt;/em&gt;。textCNN的计算主要分为以下⼏步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义多个⼀维卷积核，并使⽤这些卷积核对输⼊分别做卷积计算。宽度不同的卷积核可能会捕捉到不同个数的相邻词的相关性。&lt;/li&gt;
&lt;li&gt;对输出的所有通道分别做时序最⼤池化，再将这些通道的池化输出值连结为向量。&lt;/li&gt;
&lt;li&gt;通过全连接层将连结后的向量变换为有关各类别的输出。这⼀步可以使⽤丢弃层应对过拟合。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下图⽤⼀个例⼦解释了textCNN的设计。这⾥的输⼊是⼀个有11个词的句⼦，每个词⽤6维词向量表⽰。因此输⼊序列的宽为11，输⼊通道数为6。给定2个⼀维卷积核，核宽分别为2和4，输出通道数分别设为4和5。因此，⼀维卷积计算后，4个输出通道的宽为 11 - 2 + 1 = 10，而其他5个通道的宽为 11 - 4 + 1 = 8。尽管每个通道的宽不同，我们依然可以对各个通道做时序最⼤池化，并将9个通道的池化输出连结成⼀个9维向量。最终，使⽤全连接将9维向量变换为2维输出，即正⾯情感和负⾯情感的预测。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kkweishe/images/raw/master/ML/2019-8-26_11-4-51.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;4. 代码实现&lt;/h2&gt;
&lt;p&gt;清华新闻分类数据集下载：&lt;a href=&quot;https://www.lanzous.com/i5t0lsd&quot; class=&quot;uri&quot;&gt;https://www.lanzous.com/i5t0lsd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://github.com/NLP-LOVE/ML-NLP&quot;&gt;机器学习通俗易懂系列文章&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190802102238788.png&quot; alt=&quot;3.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;5. 参考文献&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;4.8540145985401&quot;&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://github.com/NLP-LOVE/ML-NLP&quot;&gt;@mantchs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/NLP-LOVE/ML-NLP&quot; class=&quot;uri&quot;&gt;https://github.com/NLP-LOVE/ML-NLP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家加入讨论！共同完善此项目！群号：【541954936】&lt;a target=&quot;_blank&quot; href=&quot;https://shang.qq.com/wpa/qunwpa?idkey=863f915b9178560bd32ca07cd090a7d9e6f5f90fcff5667489697b1621cecdb3&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pub.idqqimg.com/wpa/images/group.png&quot; alt=&quot;NLP面试学习群&quot; title=&quot;NLP面试学习群&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 27 Aug 2019 00:45:00 +0000</pubDate>
<dc:creator>mantch</dc:creator>
<og:description>1. 什么是textRNN textRNN指的是利用RNN循环神经网络解决文本分类问题，文本分类是自然语言处理的一个基本任务，试图推断出给定文本(句子、文档等)的标签或标签集合。 文本分类的应用非常广</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mantch/p/11416104.html</dc:identifier>
</item>
<item>
<title>一文了解Python常见的序列化操作 - hylinux1024</title>
<link>http://www.cnblogs.com/angrycode/p/11416092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/angrycode/p/11416092.html</guid>
<description>&lt;blockquote readability=&quot;6.2553191489362&quot;&gt;
&lt;p&gt;关于我&lt;br/&gt;一个有思想的程序猿，终身学习实践者，目前在一个创业团队任team lead，技术栈涉及Android、Python、Java和Go，这个也是我们团队的主要技术栈。&lt;br/&gt;Github：&lt;a href=&quot;https://github.com/hylinux1024&quot; class=&quot;uri&quot;&gt;https://github.com/hylinux1024&lt;/a&gt;&lt;br/&gt;微信公众号：终身开发者(angrycode)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;x00-marshal&quot;&gt;0x00 marshal&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;marshal&lt;/code&gt;使用的是与&lt;code&gt;Python&lt;/code&gt;语言相关但与机器无关的二进制来读写&lt;code&gt;Python&lt;/code&gt;对象的。这种二进制的格式也跟&lt;code&gt;Python&lt;/code&gt;语言的版本相关，&lt;code&gt;marshal&lt;/code&gt;序列化的格式对不同的版本的&lt;code&gt;Python&lt;/code&gt;是不兼容的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;marshal&lt;/code&gt;一般用于&lt;code&gt;Python&lt;/code&gt;内部对象的序列化。&lt;/p&gt;
&lt;p&gt;一般地包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基本类型 &lt;code&gt;booleans, integers,floating point numbers,complex numbers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;序列集合类型 &lt;code&gt;strings, bytes, bytearray, tuple, list, set, frozenset, dictionary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;code对象 &lt;code&gt;code object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其它类型 &lt;code&gt;None, Ellipsis, StopIteration&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;marshal&lt;/code&gt;的主要作用是对&lt;code&gt;Python&lt;/code&gt;“编译”的&lt;code&gt;.pyc&lt;/code&gt;文件读写的支持。这也是&lt;code&gt;marshal&lt;/code&gt;对&lt;code&gt;Python&lt;/code&gt;版本不兼容的原因。开发者如果要使用&lt;strong&gt;序列化/反序列化&lt;/strong&gt;，那么应该使用&lt;code&gt;pickle&lt;/code&gt;模块。&lt;/p&gt;
&lt;h4 id=&quot;常见的方法&quot;&gt;常见的方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;marshal.dump(value, file[, version])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;序列化一个对象到文件中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;marshal.dumps(value[, version])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;序列化一个对象并返回一个&lt;code&gt;bytes&lt;/code&gt;对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;marshal.load(file)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从文件中反序列化一个对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;marshal.loads(bytes)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;bytes&lt;/code&gt;二进制数据中反序列化一个对象&lt;/p&gt;
&lt;h3 id=&quot;x01-pickle&quot;&gt;0x01 pickle&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;pickle&lt;/code&gt;模块也能够以二进制的方式对&lt;code&gt;Python&lt;/code&gt;对象进行读写。相比&lt;code&gt;marshal&lt;/code&gt;提供基本的序列化能力，&lt;code&gt;pickle&lt;/code&gt;的序列化应用更加广泛。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pickle&lt;/code&gt;序列化后的数据也是与&lt;code&gt;Python&lt;/code&gt;语言相关的，即其它语言例如&lt;code&gt;Java&lt;/code&gt;无法读取由&lt;code&gt;Python&lt;/code&gt;通过&lt;code&gt;pickle&lt;/code&gt;序列化的二进制数据。如果要使用与语言无法的序列化那么我们应该使用&lt;code&gt;json&lt;/code&gt;。下文将会说明。&lt;/p&gt;
&lt;p&gt;能被&lt;code&gt;pickle&lt;/code&gt;序列化的数据类型有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;None, True, and False&lt;/li&gt;
&lt;li&gt;integers, floating point numbers, complex numbers&lt;/li&gt;
&lt;li&gt;strings, bytes, bytearrays&lt;/li&gt;
&lt;li&gt;tuples, lists, sets, and dictionaries 以及包含可以被pickle序列化对象&lt;/li&gt;
&lt;li&gt;在模块顶层定义的函数对象 (使用 def定义的, 而不是 &lt;code&gt;lambda&lt;/code&gt;表达式)&lt;/li&gt;
&lt;li&gt;在模块顶层定义内置函数&lt;/li&gt;
&lt;li&gt;在模式顶层定义的类&lt;/li&gt;
&lt;li&gt;一个类的&lt;code&gt;__dict__&lt;/code&gt;包含了可序列化的对象或&lt;code&gt;__getstate__()&lt;/code&gt;方法返回了能够被序列化的对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果&lt;code&gt;pickle&lt;/code&gt;一个不支持序列化的对象时将会抛出&lt;code&gt;PicklingError&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;常见的方法-1&quot;&gt;常见的方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pickle.dump(obj, file, protocol=None, *, fix_imports=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将&lt;code&gt;obj&lt;/code&gt;对象序列化到一个&lt;code&gt;file&lt;/code&gt;文件中，该方法与&lt;code&gt;Pickler(file, protocol).dump(obj)&lt;/code&gt;等价。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pickle.dumps(obj, protocol=None, *, fix_imports=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将&lt;code&gt;obj&lt;/code&gt;对象序列化成&lt;code&gt;bytes&lt;/code&gt;二进制数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pickle.load(file, *, fix_imports=True, encoding=&quot;ASCII&quot;, errors=&quot;strict&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;file&lt;/code&gt;文件中反序列化一个对象，该方法与&lt;code&gt;Unpickler(file).load()&lt;/code&gt;等价。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pickle.loads(bytes_object, *, fix_imports=True, encoding=&quot;ASCII&quot;, errors=&quot;strict&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从二进制数据&lt;code&gt;bytes_object&lt;/code&gt;反序列化对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列化例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pickle

# 定义了一个包含了可以被序列化对象的字典
data = {
    'a': [1, 2.0, 3, 4 + 6j],
    'b': (&quot;character string&quot;, b&quot;byte string&quot;),
    'c': {None, True, False}
}

with open('data.pickle', 'wb') as f:
    # 序列化对象到一个data.pickle文件中
    # 指定了序列化格式的版本pickle.HIGHEST_PROTOCOL
    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行之后在文件夹中多一个&lt;code&gt;data.pickle&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;serialization
├── data.pickle
├── pickles.py
└── unpickles.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;反序列化例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pickle

with open('data.pickle', 'rb') as f:
    # 从data.pickle文件中反序列化对象
    # pickle能够自动检测序列化文件的版本
    # 所以这里可以不用版本号
    data = pickle.load(f)

    print(data)

# 执行后结果
# {'a': [1, 2.0, 3, (4+6j)], 'b': ('character string', b'byte string'), 'c': {False, True, None}}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;x02-json&quot;&gt;0x02 json&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;json&lt;/code&gt;是与语言无关，非常通用的数据交互格式。在&lt;code&gt;Python&lt;/code&gt;它与&lt;code&gt;marshal&lt;/code&gt;和&lt;code&gt;pickle&lt;/code&gt;一样拥有相似的&lt;code&gt;API&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;常见的方法-2&quot;&gt;常见的方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;序列化对象到&lt;code&gt;fp&lt;/code&gt;文件中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将&lt;code&gt;obj&lt;/code&gt;序列化成&lt;code&gt;json&lt;/code&gt;对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从文件中反序列化成一个对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;json&lt;/code&gt;格式文档中反序列化成一个对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;json&lt;/code&gt;与&lt;code&gt;Python&lt;/code&gt;对象的转化对照表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;dict&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;list,tuple&lt;/td&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;int, float, int- &amp;amp; float-derived Enums&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对于基本类型、序列、以及包含基本类型的集合类型&lt;code&gt;json&lt;/code&gt;都可以很好的完成&lt;strong&gt;序列化&lt;/strong&gt;工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列化例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import json
&amp;gt;&amp;gt;&amp;gt; json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
'[&quot;foo&quot;, {&quot;bar&quot;: [&quot;baz&quot;, null, 1.0, 2]}]'
&amp;gt;&amp;gt;&amp;gt; print(json.dumps(&quot;\&quot;foo\bar&quot;))
&quot;\&quot;foo\bar&quot;
&amp;gt;&amp;gt;&amp;gt; print(json.dumps('\u1234'))
&quot;\u1234&quot;
&amp;gt;&amp;gt;&amp;gt; print(json.dumps('\\'))
&quot;\\&quot;
&amp;gt;&amp;gt;&amp;gt; print(json.dumps({&quot;c&quot;: 0, &quot;b&quot;: 0, &quot;a&quot;: 0}, sort_keys=True))
{&quot;a&quot;: 0, &quot;b&quot;: 0, &quot;c&quot;: 0}
&amp;gt;&amp;gt;&amp;gt; from io import StringIO
&amp;gt;&amp;gt;&amp;gt; io = StringIO()
&amp;gt;&amp;gt;&amp;gt; json.dump(['streaming API'], io)
&amp;gt;&amp;gt;&amp;gt; io.getvalue()
'[&quot;streaming API&quot;]'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;反序列化例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import json
&amp;gt;&amp;gt;&amp;gt; json.loads('[&quot;foo&quot;, {&quot;bar&quot;:[&quot;baz&quot;, null, 1.0, 2]}]')
['foo', {'bar': ['baz', None, 1.0, 2]}]
&amp;gt;&amp;gt;&amp;gt; json.loads('&quot;\\&quot;foo\\bar&quot;')
'&quot;foo\x08ar'
&amp;gt;&amp;gt;&amp;gt; from io import StringIO
&amp;gt;&amp;gt;&amp;gt; io = StringIO('[&quot;streaming API&quot;]')
&amp;gt;&amp;gt;&amp;gt; json.load(io)
['streaming API']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;object&lt;/code&gt;的情况就复杂一些了&lt;/p&gt;
&lt;p&gt;例如定义了复数&lt;code&gt;complex&lt;/code&gt;对象的&lt;code&gt;json&lt;/code&gt;文档&lt;/p&gt;
&lt;p&gt;&lt;code&gt;complex_data.json&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;__complex__&quot;: true,
  &quot;real&quot;: 42,
  &quot;imaginary&quot;: 36
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要把这个&lt;code&gt;json&lt;/code&gt;文档反序列化成&lt;code&gt;Python&lt;/code&gt;对象，就需要定义转化的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# coding=utf-8
import json

# 定义转化函数，将json中的内容转化成complex对象
def decode_complex(dct):
    if &quot;__complex__&quot; in dct:
        return complex(dct[&quot;real&quot;], dct[&quot;imaginary&quot;])
    else:
        return dct

if __name__ == '__main__':
    with open(&quot;complex_data.json&quot;) as complex_data:
        # object_hook指定转化的函数
        z = json.load(complex_data, object_hook=decode_complex)
        print(type(z))
        print(z)

# 执行结果
# &amp;lt;class 'complex'&amp;gt;
# (42+36j)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不指定&lt;code&gt;object_hook&lt;/code&gt;，那么默认将&lt;code&gt;json&lt;/code&gt;文档中的&lt;code&gt;object&lt;/code&gt;转成&lt;code&gt;dict&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# coding=utf-8
import json

if __name__ == '__main__':

    with open(&quot;complex_data.json&quot;) as complex_data:
        # 这里不指定object_hook
        z2 = json.loads(complex_data.read())
        print(type(z2))
        print(z2)
# 执行结果
# &amp;lt;class 'dict'&amp;gt;
# {'__complex__': True, 'real': 42, 'imaginary': 36}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到&lt;code&gt;json&lt;/code&gt;文档中的&lt;code&gt;object&lt;/code&gt;转成了&lt;code&gt;dict&lt;/code&gt;对象。&lt;br/&gt;一般情况下这样使用似乎也没什么问题，但如果对类型要求很高的场景就需要明确定义转化的方法了。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;object_hook&lt;/code&gt;参数还可以使用&lt;code&gt;json.JSONEncoder&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import json

class ComplexEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, complex):
            # 如果complex对象这里转成数组的形式
            return [obj.real, obj.imag]
            # 默认处理
        return json.JSONEncoder.default(self, obj)

if __name__ == '__main__':
    c = json.dumps(2 + 1j, cls=ComplexEncoder)
    print(type(c))
    print(c)

# 执行结果
# &amp;lt;class 'str'&amp;gt;
# [2.0, 1.0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;json&lt;/code&gt;模块并不是对所有类型都能够自动完成序列化的，对于不支持的类型，会直接抛出&lt;code&gt;TypeError&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import datetime
&amp;gt;&amp;gt;&amp;gt; d = datetime.datetime.now()
&amp;gt;&amp;gt;&amp;gt; dct = {'birthday':d,'uid':124,'name':'jack'}
&amp;gt;&amp;gt;&amp;gt; dct
{'birthday': datetime.datetime(2019, 6, 14, 11, 16, 17, 434361), 'uid': 124, 'name': 'jack'}
&amp;gt;&amp;gt;&amp;gt; json.dumps(dct)
Traceback (most recent call last):
  File &quot;&amp;lt;pyshell#19&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
    json.dumps(dct)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/__init__.py&quot;, line 231, in dumps
    return _default_encoder.encode(obj)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/encoder.py&quot;, line 199, in encode
    chunks = self.iterencode(o, _one_shot=True)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/encoder.py&quot;, line 257, in iterencode
    return _iterencode(o, 0)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/encoder.py&quot;, line 179, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type datetime is not JSON serializable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于不支持序列化的类型例如&lt;code&gt;datetime&lt;/code&gt;以及自定义类型，就需要使用&lt;code&gt;JSONEncoder&lt;/code&gt;来定义转化的逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import json
import datetime

# 定义日期类型的JSONEncoder
class DatetimeEncoder(json.JSONEncoder):

    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            return obj.strftime('%Y-%m-%d %H:%M:%S')
        elif isinstance(obj, datetime.date):
            return obj.strftime('%Y-%m-%d')
        else:
            return json.JSONEncoder.default(self, obj)

if __name__ == '__main__':
    d = datetime.date.today()
    dct = {&quot;birthday&quot;: d, &quot;name&quot;: &quot;jack&quot;}
    data = json.dumps(dct, cls=DatetimeEncoder)
    print(data)

# 执行结果
# {&quot;birthday&quot;: &quot;2019-06-14&quot;, &quot;name&quot;: &quot;jack&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们希望发序列化时，能够将&lt;code&gt;json&lt;/code&gt;文档中的日期格式转化成&lt;code&gt;datetime.date&lt;/code&gt;对象，这时就需要使用到&lt;code&gt;json.JSONDecoder&lt;/code&gt;了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# coding=utf-8
import json
import datetime

# 定义Decoder解析json
class DatetimeDecoder(json.JSONDecoder):

    # 构造方法
    def __init__(self):
        super().__init__(object_hook=self.dict2obj)

    def dict2obj(self, d):
        if isinstance(d, dict):
            for k in d:
                if isinstance(d[k], str):
                    # 对日期格式进行解析，生成一个date对象
                    dat = d[k].split(&quot;-&quot;)
                    if len(dat) == 3:
                        date = datetime.date(int(dat[0]), int(dat[1]), int(dat[2]))
                        d[k] = date
        return d

if __name__ == '__main__':
    d = datetime.date.today()
    dct = {&quot;birthday&quot;: d, &quot;name&quot;: &quot;jack&quot;}
    data = json.dumps(dct, cls=DatetimeEncoder)
    # print(data)

    obj = json.loads(data, cls=DatetimeDecoder)
    print(type(obj))
    print(obj)

# 执行结果
# {&quot;birthday&quot;: &quot;2019-06-14&quot;, &quot;name&quot;: &quot;jack&quot;}
# &amp;lt;class 'dict'&amp;gt;
# {'birthday': datetime.date(2019, 6, 14), 'name': 'jack'}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;x03-总结一下&quot;&gt;0x03 总结一下&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Python&lt;/code&gt;常见的序列化工具有&lt;code&gt;marshal&lt;/code&gt;、&lt;code&gt;pickle&lt;/code&gt;和&lt;code&gt;json&lt;/code&gt;。&lt;code&gt;marshal&lt;/code&gt;主要用于&lt;code&gt;Python&lt;/code&gt;的&lt;code&gt;.pyc&lt;/code&gt;文件，并与&lt;code&gt;Python&lt;/code&gt;版本相关。它不能序列化用户定义的类。&lt;br/&gt;&lt;code&gt;pickle&lt;/code&gt;是&lt;code&gt;Python&lt;/code&gt;对象的序列化工具则比&lt;code&gt;marshal&lt;/code&gt;更通用些，它可以兼容&lt;code&gt;Python&lt;/code&gt;的不同版本。&lt;code&gt;json&lt;/code&gt;是一种语言无关的数据结构，广泛用于各种网络应用尤其在&lt;code&gt;REST API&lt;/code&gt;的服务中的数据交互。&lt;/p&gt;
&lt;h3 id=&quot;x04-学习资料&quot;&gt;0x04 学习资料&lt;/h3&gt;
</description>
<pubDate>Tue, 27 Aug 2019 00:41:00 +0000</pubDate>
<dc:creator>hylinux1024</dc:creator>
<og:description>marshal使用的是与Python语言相关但与机器无关的二进制来读写Python对象的。这种二进制的格式也跟Python语言的版本相关，marshal序列化的格式对不同的版本的Python是不兼容的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/angrycode/p/11416092.html</dc:identifier>
</item>
<item>
<title>Python 命令行之旅：深入 argparse（二） - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11415703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11415703.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201908/759200-20190820103954050-1282698709.jpg&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;br/&gt;作者：HelloGitHub-&lt;strong&gt;Prodesire&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.5660377358491&quot;&gt;
&lt;p&gt;HelloGitHub 的《讲解开源项目》系列，项目地址：&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot; class=&quot;uri&quot;&gt;https://github.com/HelloGitHub-Team/Article&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一篇“深入 argparse（一）”的文章中，我们深入了解了 &lt;code&gt;argparse&lt;/code&gt; 的包括参数动作和参数类别在内的基本功能，具备了编写一个简单命令行程序的能力。本文将继续深入了解 &lt;code&gt;argparse&lt;/code&gt; 的进阶玩法，一窥探其全貌，助力我们拥有实现复杂命令行程序的能力。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;本系列文章默认使用 Python 3 作为解释器进行讲解。
若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;帮助&quot;&gt;帮助&lt;/h2&gt;
&lt;h3 id=&quot;自动生成帮助&quot;&gt;自动生成帮助&lt;/h3&gt;
&lt;p&gt;当你在命令行程序中指定 &lt;code&gt;-h&lt;/code&gt; 或 &lt;code&gt;--help&lt;/code&gt; 参数时，都会输出帮助信息。而 &lt;code&gt;argparse&lt;/code&gt; 可通过指定 &lt;code&gt;add_help&lt;/code&gt; 入参为 &lt;code&gt;True&lt;/code&gt; 或不指定，以达到自动输出帮助信息的目的。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import argparse
&amp;gt;&amp;gt;&amp;gt; parser = argparse.ArgumentParser(add_help=True)
&amp;gt;&amp;gt;&amp;gt; parser.add_argument('--foo')
&amp;gt;&amp;gt;&amp;gt; parser.parse_args(['-h'])
usage: [-h] [--foo FOO]

optional arguments:
  -h, --help  show this help message and exit
  --foo FOO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;add_help=False&lt;/code&gt;，那么在命令行中指定 &lt;code&gt;-h&lt;/code&gt; 则会报错：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import argparse
&amp;gt;&amp;gt;&amp;gt; parser = argparse.ArgumentParser(add_help=False)
&amp;gt;&amp;gt;&amp;gt; parser.add_argument('--foo')
&amp;gt;&amp;gt;&amp;gt; parser.parse_args(['-h'])
usage: [--foo FOO]
: error: unrecognized arguments: -h&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义帮助&quot;&gt;自定义帮助&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ArgumentParser&lt;/code&gt; 使用 &lt;code&gt;formatter_class&lt;/code&gt; 入参来控制所输出的帮助格式。&lt;br/&gt;比如，通过指定 &lt;code&gt;formatter_class=argparse.RawTextHelpFormatter&lt;/code&gt;，我们可以让帮助内容遵循原始格式：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import argparse
&amp;gt;&amp;gt;&amp;gt; parser = argparse.ArgumentParser(
...     add_help=True,
...     formatter_class=argparse.RawTextHelpFormatter,
...     description=&quot;&quot;&quot;
...     description
...         raw
...            formatted&quot;&quot;&quot;
... )
&amp;gt;&amp;gt;&amp;gt; parser.add_argument(
...     '-a', action=&quot;store_true&quot;,
...     help=&quot;&quot;&quot;argument
...         raw
...             formatted
...     &quot;&quot;&quot;
... )
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; parser.parse_args(['-h'])
usage: [-h] [-a]

    description
        raw
           formatted

optional arguments:
  -h, --help  show this help message and exit
  -a          argument
                      raw
                          formatted&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对比下不指定 &lt;code&gt;formatter_class&lt;/code&gt; 的帮助输出，就可以发现 descirption 和 -a 两个帮助内容上的差异：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import argparse
&amp;gt;&amp;gt;&amp;gt; parser = argparse.ArgumentParser(
...     add_help=True,
...     description=&quot;&quot;&quot;
...     description
...         notraw
...            formatted&quot;&quot;&quot;
... )
&amp;gt;&amp;gt;&amp;gt; parser.add_argument(
...     '-a', action=&quot;store_true&quot;,
...     help=&quot;&quot;&quot;argument
...         notraw
...             formatted
...     &quot;&quot;&quot;
... )
&amp;gt;&amp;gt;&amp;gt; parser.parse_args(['-h'])
usage: [-h] [-a]

description notraw formatted

optional arguments:
  -h, --help  show this help message and exit
  -a          argument notraw formatted&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参数组&quot;&gt;参数组&lt;/h2&gt;
&lt;p&gt;有时候，我们需要给参数分组，以使得在显示帮助信息时能够显示到一起。&lt;/p&gt;
&lt;p&gt;比如某命令行支持三个参数选项 &lt;code&gt;--user&lt;/code&gt;、&lt;code&gt;--password&lt;/code&gt;和&lt;code&gt;--push&lt;/code&gt;，前两者需要放在一个名为 &lt;code&gt;authentication&lt;/code&gt; 的分组中以表示它们是身份认证信息。那么我们可以用 &lt;code&gt;ArgumentParser.add_argument_group&lt;/code&gt; 来满足：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import argparse
&amp;gt;&amp;gt;&amp;gt; parser = argparse.ArgumentParser()
&amp;gt;&amp;gt;&amp;gt; group = parser.add_argument_group('authentication')
&amp;gt;&amp;gt;&amp;gt; group.add_argument('--user', action=&quot;store&quot;)
&amp;gt;&amp;gt;&amp;gt; group.add_argument('--password', action=&quot;store&quot;)
&amp;gt;&amp;gt;&amp;gt; parser.add_argument('--push', action='store')
&amp;gt;&amp;gt;&amp;gt; parser.parse_args(['-h'])
usage: [-h] [--user USER] [--password PASSWORD] [--push PUSH]

optional arguments:
  -h, --help           show this help message and exit
  --push PUSH

authentication:
  --user USER
  --password PASSWORD&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，当我们输出帮助信息时，&lt;code&gt;--user&lt;/code&gt; 和 &lt;code&gt;--password&lt;/code&gt; 选项都出现在 &lt;code&gt;authentication&lt;/code&gt; 分组中。&lt;/p&gt;
&lt;h2 id=&quot;选项参数前缀&quot;&gt;选项参数前缀&lt;/h2&gt;
&lt;p&gt;不知你是否注意到，在不同平台上命令行程序的选项参数前缀可能是不同的。比如在 Unix 上，其前缀是 &lt;code&gt;-&lt;/code&gt;；而在 Windows 上，大多数命令行程序（比如 &lt;code&gt;findstr&lt;/code&gt;）的选项参数前缀是 &lt;code&gt;/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;argparse&lt;/code&gt; 中，选项参数前缀默认采用 Unix 命令行约定，也就是 &lt;code&gt;-&lt;/code&gt;。但它也支持自定义前缀，下面是一个例子：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import argparse
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; parser = argparse.ArgumentParser(
...     description='Option prefix',
...     prefix_chars='-+/',
... )
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; parser.add_argument('-power', action=&quot;store_false&quot;,
...                     default=None,
...                     help='Set power off',
...                     )
&amp;gt;&amp;gt;&amp;gt; parser.add_argument('+power', action=&quot;store_true&quot;,
...                     default=None,
...                     help='Set power on',
...                     )
&amp;gt;&amp;gt;&amp;gt; parser.add_argument('/win',
...                     action=&quot;store_true&quot;,
...                     default=False)
&amp;gt;&amp;gt;&amp;gt; parser.parse_args(['-power'])
Namespace(power=False, win=False)
&amp;gt;&amp;gt;&amp;gt; parser.parse_args(['+power', '/win'])
Namespace(power=True, win=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，我们指定了三个选项参数前缀 &lt;code&gt;-&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;和&lt;code&gt;/&lt;/code&gt;，从而：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过指定选项参数 &lt;code&gt;-power&lt;/code&gt;，使得 &lt;code&gt;power=False&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过指定选项参数 &lt;code&gt;+power&lt;/code&gt;，使得 &lt;code&gt;power=True&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过指定选项参数 &lt;code&gt;/win&lt;/code&gt;，使得 &lt;code&gt;win=True&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;共享解析器&quot;&gt;共享解析器&lt;/h2&gt;
&lt;p&gt;有些时候我们需要共享解析器，以共享里面的参数配置。比如，我们的命令行工具需要支持对阿里云和 AWS 进行操作，两类操作都需要指定 &lt;code&gt;AccessKeyId&lt;/code&gt; 和 &lt;code&gt;AccessKeySecret&lt;/code&gt; 来表明用户身份和权限。那么共享解析器就显得尤为必要，这样就可以少去重复代码。&lt;/p&gt;
&lt;p&gt;我们可以这样做，在 &lt;code&gt;base.py&lt;/code&gt; 中定义一个父解析器，存放 &lt;code&gt;AccessKey&lt;/code&gt; 相关参数配置，作为公用的解析器。由于后续的子解析器会自动生成帮助信息，这里的父解析器指定 &lt;code&gt;add_help=False&lt;/code&gt; 以不自动生成帮助信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# bash.py
import argparse

parser = argparse.ArgumentParser(add_help=False)

parser.add_argument('--ak-id', action=&quot;store&quot;)
parser.add_argument('--ak-secret', action=&quot;store&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以分别在 &lt;code&gt;ali.py&lt;/code&gt; 和 &lt;code&gt;aws.py&lt;/code&gt; 中分别定义子解析器，通过 &lt;code&gt;parents&lt;/code&gt; 入参指定上述父解析器，从而继承公共的参数，并实现各自的参数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# ali.py
import argparse
import base

parser = argparse.ArgumentParser(
    parents=[base.parser],
)

parser.add_argument('--ros',
                    action=&quot;store_true&quot;,
                    default=False,
                    help='Using ROS service to orchestrate cloud resources')

print(parser.parse_args())&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# aws.py
import argparse
import base

parser = argparse.ArgumentParser(
    parents=[base.parser],
)

parser.add_argument('--cloudformation',
                    action=&quot;store_true&quot;,
                    default=False,
                    help='Using CloudFormation service to orchestrate cloud resources')

print(parser.parse_args())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终通过 &lt;code&gt;-h&lt;/code&gt; 参数分别看 &lt;code&gt;ali.py&lt;/code&gt; 和 &lt;code&gt;aws.py&lt;/code&gt; 所支持的参数，其中共同参数为 &lt;code&gt;--ak-id&lt;/code&gt; 和 &lt;code&gt;--ak-secret&lt;/code&gt;，特定参数分别为 &lt;code&gt;--ros&lt;/code&gt; 和 &lt;code&gt;--cloudformation&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3 ali.py -h

usage: ali.py [-h] [--ak-id AK_ID] [--ak-secret AK_SECRET] [--ros]

optional arguments:
  -h, --help            show this help message and exit
  --ak-id AK_ID
  --ak-secret AK_SECRET
  --ros                 Using ROS service to orchestrate cloud resources&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3 aws.py -h

usage: aws.py [-h] [--ak-id AK_ID] [--ak-secret AK_SECRET] [--cloudformation]

optional arguments:
  -h, --help            show this help message and exit
  --ak-id AK_ID
  --ak-secret AK_SECRET
  --cloudformation      Using CloudFormation service to orchestrate cloud
                        resources&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;嵌套解析器&quot;&gt;嵌套解析器&lt;/h2&gt;
&lt;p&gt;我们之前介绍的命令行中，使用形式通常是 &lt;code&gt;cli --a --b xxx&lt;/code&gt;。但还有一种极为常见的命令行使用方式是 &lt;code&gt;cli subcmd --a --b xxx&lt;/code&gt;。比如当我们要通过 &lt;code&gt;git&lt;/code&gt; 推送标签时，会用到 &lt;code&gt;git push --tags&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过实现嵌套解析器，我们可以很容易地对这种子命令的形式进行解析。&lt;/p&gt;
&lt;p&gt;在嵌套解析器中，我们定义一个父解析器来作为整个命令行的入口，再分别定义N个子解析器来对应N个子命令，由此即可实现整个功能。&lt;/p&gt;
&lt;p&gt;在下面这个例子中，我们支持 &lt;code&gt;create&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 两个子命令，用来创建或删除指定路径。而 &lt;code&gt;delete&lt;/code&gt; 命令支持 &lt;code&gt;--recursive&lt;/code&gt; 参数来表明是否递归删除指定路径：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# cli.py
import argparse

parser = argparse.ArgumentParser()

subparsers = parser.add_subparsers(help='commands')

# Create
create_parser = subparsers.add_parser(
    'create', help='Create a directory')
create_parser.add_argument(
    'dirname', action='store',
    help='New directory to create')

# Delete
delete_parser = subparsers.add_parser(
    'delete', help='Remove a directory')
delete_parser.add_argument(
    'dirname', action='store', help='The directory to remove')
delete_parser.add_argument(
    '--recursive', '-r', default=False, action='store_true',
    help='Recursively remove the directory',
)

print(parser.parse_args())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接指定 &lt;code&gt;-h&lt;/code&gt; 来查看所支持的子命令和参数选项：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3 cli.py -h

usage: cli.py [-h] {create,delete} ...

positional arguments:
  {create,delete}  commands
    create         Create a directory
    delete         Remove a directory

optional arguments:
  -h, --help       show this help message and exit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接指定 &lt;code&gt;delete -h&lt;/code&gt; 来查看 &lt;code&gt;delete&lt;/code&gt; 子命令支持的参数选项：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3 cli.py delete -h

usage: cli.py delete [-h] [--recursive] dirname

positional arguments:
  dirname          The directory to remove

optional arguments:
  -h, --help       show this help message and exit
  --recursive, -r  Recursively remove the directory&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义动作&quot;&gt;自定义动作&lt;/h2&gt;
&lt;p&gt;在上一篇“深入 argparse （一）”的文章中介绍过8种参数动作，可以说是覆盖了绝大部分场景。但是也会有一些特定需求无法被满足，比如希望获取到的参数值都是大写。在这种情况下，自定义动作就派上了用场。&lt;/p&gt;
&lt;p&gt;实现一个自定义动作类，需继承自 &lt;code&gt;argparse.Action&lt;/code&gt;，这个自定义动作类要传入到 &lt;code&gt;ArgumentParser.add_argument&lt;/code&gt; 的 &lt;code&gt;action&lt;/code&gt; 入参。当解析器解析参数时，会调用该类的 &lt;code&gt;__call__&lt;/code&gt; 方法，该方法的签名为 &lt;code&gt;__call__(self, parser, namespace, values, option_string=None)&lt;/code&gt;，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;parser 为解析器实例&lt;/li&gt;
&lt;li&gt;namespace 存放解析结果&lt;/li&gt;
&lt;li&gt;values 即命令行中传入的参数值&lt;/li&gt;
&lt;li&gt;option_string 为参数选项&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在下面的例子中，我们通过 &lt;code&gt;--words&lt;/code&gt; 传入单词，并在自定义动作类中将其值转换为大写：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# cli.py
import argparse

class WordsAction(argparse.Action):

    def __call__(self, parser, namespace, values,
                 option_string=None):
        print(f'parser = {parser}')
        print(f'values = {values!r}')
        print(f'option_string = {option_string!r}')

        values = [v.upper() for v in values]
        setattr(namespace, self.dest, values)


parser = argparse.ArgumentParser()
parser.add_argument('--words', nargs='*', action=WordsAction)

results = parser.parse_args()
print(results)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3 cli.py --words foo bar

parser = ArgumentParser(prog='cli.py', usage=None, description=None, formatter_class=&amp;lt;class 'argparse.HelpFormatter'&amp;gt;, conflict_handler='error', add_help=True)
values = ['foo', 'bar']
option_string = '--words'
Namespace(words=['FOO', 'BAR'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小节&quot;&gt;小节&lt;/h2&gt;
&lt;p&gt;通过对 &lt;code&gt;argparse&lt;/code&gt;由浅入深的介绍，相信你已经全面了解了 &lt;code&gt;argparse&lt;/code&gt; 的威力，也具备了开发命令行工具的能力。但“纸上得来终觉浅，绝知此事要躬行”。&lt;/p&gt;
&lt;p&gt;在下篇文章中，将带大家一起用 &lt;code&gt;argparse&lt;/code&gt; 实现日常工作中常见的 &lt;code&gt;git&lt;/code&gt; 命令，想想是不是有些兴奋呢？&lt;/p&gt;
</description>
<pubDate>Tue, 27 Aug 2019 00:36:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub Prodesire HelloGitHub 的《讲解开源项目》系列，项目地址：https://github.com/HelloGitHub Team/Article 前言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11415703.html</dc:identifier>
</item>
<item>
<title>.net测试篇之Moq行为配置 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11416041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11416041.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们前面说过.Moq在创建模拟对象的时候,简单对象赋值默认值,引用对象赋值为null,但是有些时候接口里面还包含另一个接口对象,我们知道Moq是可以模拟一个接口对象的,我们可以通过配置让Moq模拟所有可以Mock的对象.&lt;/p&gt;
&lt;p&gt;我们新增如下代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public interface IDtoWrapper
    {
        MyDto Dto { get; set; }
        string GetString();
    }

    public interface IOutString
    {
        IDtoWrapper wrapper { get; set; }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如我们要模拟一个IOutString对象,如果不使用默认的行为则里面的wrapper对象返回为Null,如果这样我们没法再继续操作了.&lt;/p&gt;
&lt;p&gt;我们可以对Moq的&lt;code&gt;Default&lt;/code&gt;行为进行配置,让它对IDtoWrapper对象也进行Mock&lt;/p&gt;
&lt;p&gt;测试代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
        public void BehaviorConfig()
        {
            var moq = new Mock&amp;lt;IOutString&amp;gt;();
            moq.DefaultValue = DefaultValue.Mock;
            Assert.NotNull(moq.Object.wrapper);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上测试会通过.这时候wrapper不再是null,我们便可以对其进行操作了.&lt;/p&gt;
&lt;p&gt;我们通过调试可以发现这时候不但IDtoWrapper不再是null,它里面的Dto属性也被赋值为一个new MyDto.是不是Mock框架可以模拟一个对象呢,实际上确实是可以,只不过是它模拟对象有很多限制,比如不能模拟不包含无参构造函数的对象,不能模拟不带virtual或者abstract的方法等.如果我们对模拟的对象的方法没有virual或者abstract修饰,这时候如果进行setup则会抛出异常.&lt;/p&gt;
&lt;p&gt;前面我们讲的如何通过配置使mock自动mock遇到到层级可Mock对象.这一节我们来看另一个问题.&lt;/p&gt;
&lt;p&gt;假如有这样一种场:要mock的接口里有一个Name属性,在业务层我们要根据这个Name决定进入switch的不同分支里面,但是回顾前面的章节,我们没有遇到这种情况,我们都是只是在mock对象建立时使用setup为要mock的对象的字段设置值.很多人可能会想,可以通过moq对象实体的Object属性把这个对象拿出来,然后改变它的值.我们来看看这样做可行不可行.&lt;/p&gt;
&lt;p&gt;我们有以下一个简单接口&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;  public interface ISt
    {
        string Name { get; set; }
        int Age { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
        public void BehaviorConfig()
        {
            var moq = new Mock&amp;lt;ISt&amp;gt;();
            var obj = moq.Object;
            obj.Name = &quot;baidu&quot;;
            Assert.NotNull(moq.Object.Name);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把moq的Object对象赋值给obj,然后通过obj改变Name值.我们断言moq.Object.Name的值不为null,不幸的是,测试没有通过.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190827081147864-712739378.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按我们理解obj和moq.Object应该是引用类型,所以obj值的改变会引起moq.object值的改变,然而实际情况却是我们一旦把moq.Objectm赋值给了obj,它们之间便脱离了关系.看来这样是行不通的.&lt;/p&gt;
&lt;p&gt;如何解决这个问题呢,其实moq实例对象里面有一个SetupProperty方法,我们可以通过它来显示指定哪些属性会被跟踪,如果属性被跟踪,则它的变化就会被记录下来,而不像上面.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        public void BehaviorConfig()
        {
            var moq = new Mock&amp;lt;ISt&amp;gt;();
            moq.SetupProperty(a =&amp;gt; a.Name);
            var obj = moq.Object;
            obj.Name = &quot;baidu&quot;;
            Assert.NotNull(moq.Object.Name);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们多加了一行代码,测试便可以通过了.&lt;/p&gt;
&lt;p&gt;但是如果属性很多,这样一行一行几乎重复的代码挺烦的,moq实例里面还有一个&lt;code&gt;SetupAllProperties&lt;/code&gt;方法,这样可以设置所有的属性都被跟踪.这样如果多条需要这个值,我们便不需要每次都mock它,而只需要给它重新赋值即可.&lt;/p&gt;
</description>
<pubDate>Tue, 27 Aug 2019 00:14:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 我们前面说过.Moq在创建模拟对象的时候,简单对象赋值默认值,引用对象赋值为null,但是有些时候接口里面还包含另一个接口对象,我们知道Moq是可以模拟一个接口对象的,我们可以通过配置让</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11416041.html</dc:identifier>
</item>
<item>
<title>Java 迭代接口：Iterator、ListIterator 和 Spliterator - 锅外的大佬</title>
<link>http://www.cnblogs.com/liululee/p/11416038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liululee/p/11416038.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;当我们使用 &lt;code&gt;for&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 循环来遍历一个集合的元素，&lt;code&gt;Iterator&lt;/code&gt; 允许我们不用担心索引位置，甚至让我们不仅仅是遍历一个集合，同时还可以改变它。例如，你如果要删除循环中的元素，那么 &lt;code&gt;for&lt;/code&gt; 循环不见得总是可行的。&lt;/p&gt;
&lt;p&gt;结合自定义的迭代器，我们可以迭代更为复杂的对象，以及向前和向后移动，并且知晓如何利用其优势也将变得非常清楚。&lt;/p&gt;
&lt;p&gt;本文将深入讨论如何使用 &lt;code&gt;Iterator&lt;/code&gt; 和 &lt;code&gt;Iterable&lt;/code&gt; 接口。&lt;/p&gt;
&lt;h2 id=&quot;iterator&quot;&gt;2. Iterator()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt; 接口用于迭代集合中的元素（&lt;code&gt;List&lt;/code&gt;，&lt;code&gt;Set&lt;/code&gt; 或 &lt;code&gt;Map&lt;/code&gt;）。它用于逐个检索元素，并在需要时针对每个元素执行操作。&lt;/p&gt;
&lt;p&gt;下面是用于遍历集合与执行操作的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;.hasNext()&lt;/code&gt;：如果还没有到达集合的末尾，则返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.next()&lt;/code&gt;：返回集合中的下一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.remove()&lt;/code&gt;：从集合中移除迭代器返回的最后一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.forEachRemaining()&lt;/code&gt;：按顺序为集合中剩下的每个元素执行给定的操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先，由于迭代器是用于集合的，让我们做一个简单的包含几个元素的 &lt;code&gt;ArrayList&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; avengers = new ArrayList&amp;lt;&amp;gt;();

// Now lets add some Avengers to the list
avengers.add(&quot;Ant-Man&quot;);
avengers.add(&quot;Black Widow&quot;);
avengers.add(&quot;Captain America&quot;);
avengers.add(&quot;Doctor Strange&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用一个简单循环来遍历这个集合：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(&quot;Simple loop example:\n&quot;);
for (int i = 0; i &amp;lt; avengers.size(); i++) {
    System.out.println(avengers.get(i));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，我们想探索迭代器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(&quot;\nIterator Example:\n&quot;);

// First we make an Iterator by calling 
// the .iterator() method on the collection
Iterator&amp;lt;String&amp;gt; avengersIterator = avengers.iterator();

// And now we use .hasNext() and .next() to go through it
while (avengersIterator.hasNext()) {
    System.out.println(avengersIterator.next());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们想从这个 &lt;code&gt;ArrayList&lt;/code&gt; 中删除一个元素，会发生什么？让我们试着使用常规的 &lt;code&gt;for&lt;/code&gt; 循环：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(&quot;Simple loop example:\n&quot;);
for (int i = 0; i &amp;lt; avengers.size(); i++) {
    if (avengers.get(i).equals(&quot;Doctor Strange&quot;)) {
        avengers.remove(i);
    }
    System.out.println(avengers.get(i));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们会收到一个讨厌的 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Simple loop example:

Ant-Man
Black Widow
Captain America
Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: Index: 3, Size: 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这在遍历集合时更改其大小是有意义的，增强 &lt;code&gt;for&lt;/code&gt; 循环也一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(&quot;Simple loop example:\n&quot;);
for (String avenger : avengers) {
    if (avenger.equals(&quot;Doctor Strange&quot;)) {
        avengers.remove(avenger);
    }
    System.out.println(avenger);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再次收到了另一个异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Simple loop example:

Ant-Man
Black Widow
Captain America
Doctor Strange
Exception in thread &quot;main&quot; java.util.ConcurrentModificationException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时迭代器就派上用场了，由它充当中间人，从集合中删除元素，同时确保遍历按计划继续：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Iterator&amp;lt;String&amp;gt; avengersIterator = avengers.iterator();
while (avengersIterator.hasNext()) {
    String avenger = avengersIterator.next();

    // First we must find the element we wish to remove
    if (avenger.equals(&quot;Ant-Man&quot;)) {
        // This will remove &quot;Ant-Man&quot; from the original
        // collection, in this case a List
        avengersIterator.remove();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是保证在遍历集合时删除元素的安全方法。&lt;/p&gt;
&lt;p&gt;并确认该元素是否已被删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// We can also use the helper method .forEachRemaining()
System.out.println(&quot;For Each Remaining Example:\n&quot;);
Iterator&amp;lt;String&amp;gt; avengersIteratorForEach = avengers.iterator();

// This will apply System.out::println to all elements in the collection
avengersIteratorForEach.forEachRemaining(System.out::println);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;For Each Remaining Example:

Black Widow
Captain America
Doctor Strange&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如你所看到的，蚁人已经从 &lt;code&gt;复仇者联盟&lt;/code&gt; 的名单中删除了。&lt;/p&gt;
&lt;h3 id=&quot;listiterator&quot;&gt;2.1. ListIterator()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ListIterator&lt;/code&gt; 继承自 &lt;code&gt;Iterator&lt;/code&gt; 接口。它只在 &lt;code&gt;List&lt;/code&gt; 上进行使用，可以双向迭代，这意味着你可以从前到后或从后到前进行迭代。它也没有 current 元素，因为游标总是放在 &lt;code&gt;List&lt;/code&gt; 的两个元素之间，所以我们用 &lt;code&gt;.previous()&lt;/code&gt; 或 &lt;code&gt;.next()&lt;/code&gt; 来访问元素。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt; 和 &lt;code&gt;ListIterator&lt;/code&gt; 之间有什么区别呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，&lt;code&gt;Iterator&lt;/code&gt; 可以用于 &lt;em&gt;任意集合&lt;/em&gt; —— &lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Queue&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ListIterator&lt;/code&gt; 只能应用于 List，通过添加这个限制，&lt;code&gt;ListIterator&lt;/code&gt; 在方法方面可以更加具体，因此，我们引入了许多新方法，他们可以帮助我们在遍历时对其进行修改。&lt;/p&gt;
&lt;p&gt;如果你正在处理 &lt;code&gt;List&lt;/code&gt; 实现（&lt;code&gt;ArrayList&lt;/code&gt;、&lt;code&gt;LinkedList&lt;/code&gt;等），那么使用 &lt;code&gt;ListIterator&lt;/code&gt; 更为可取一些。&lt;/p&gt;
&lt;p&gt;下面是你可能会用到的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;.add(E e)&lt;/code&gt;：向 List 中添加元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.remove()&lt;/code&gt;：从 List 中删除 &lt;code&gt;.next()&lt;/code&gt; 或 &lt;code&gt;.previous()&lt;/code&gt; 返回的最后一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.set(E e)&lt;/code&gt;：使用指定元素来覆盖 List &lt;code&gt;.next（）&lt;/code&gt; 或 &lt;code&gt;.previous（）&lt;/code&gt; 返回的最后一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.hasNext()&lt;/code&gt;：如果还没有到达 List 的末尾，则返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.next()&lt;/code&gt;：返回 List 中的下一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.nextIndex()&lt;/code&gt;：返回下一元素的下标。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.hasPrevious()&lt;/code&gt;：如果还没有到达 List 的开头，则返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.previous()&lt;/code&gt;：返回 List 的上一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.previousIndex()&lt;/code&gt;：返回上一元素的下标。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再次，让我们用一些元素构成一个 &lt;code&gt;ArrayList&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ArrayList&amp;lt;String&amp;gt; defenders = new ArrayList&amp;lt;&amp;gt;();

defenders.add(&quot;Daredevil&quot;);
defenders.add(&quot;Luke Cage&quot;);
defenders.add(&quot;Jessica Jones&quot;);
defenders.add(&quot;Iron Fist&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们用 &lt;code&gt;ListIterator&lt;/code&gt; 来遍历 List 并打印其元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ListIterator listIterator = defenders.listIterator(); 
  
System.out.println(&quot;Original contents of our List:\n&quot;);
while (listIterator.hasNext()) 
    System.out.print(listIterator.next() + System.lineSeparator()); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，它的工作方式与 &lt;code&gt;Iterator&lt;/code&gt; 相同。输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Original contents of our List: 

Daredevil
Luke Cage
Jessica Jones
Iron Fist&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，让我们来尝试修改一些元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(&quot;Modified contents of our List:\n&quot;);

// Now let's make a ListIterator and modify the elements
ListIterator defendersListIterator = defenders.listIterator();

while (defendersListIterator.hasNext()) {
    Object element = defendersListIterator.next();
    defendersListIterator.set(&quot;The Mighty Defender: &quot; + element);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在打印 List 的话会得到如下结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Modified contents of our List:

The Mighty Defender: Daredevil
The Mighty Defender: Luke Cage
The Mighty Defender: Jessica Jones
The Mighty Defender: Iron Fist&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，让我们倒着遍历列表，就像我们可以用 &lt;code&gt;ListIterator&lt;/code&gt; 做的那样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(&quot;Modified List backwards:\n&quot;);
while (defendersListIterator.hasPrevious()) {
    System.out.println(defendersListIterator.previous());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Modified List backwards:

The Mighty Defender: Iron Fist
The Mighty Defender: Jessica Jones
The Mighty Defender: Luke Cage
The Mighty Defender: Daredevil&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spliterator&quot;&gt;3. Spliterator()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Spliterator&lt;/code&gt; 接口在功能上与 &lt;code&gt;Iterator&lt;/code&gt; 相同。你可能永远不需要直接使用 &lt;code&gt;Spliterator&lt;/code&gt;，但让我们继续讨论一些用例。&lt;/p&gt;
&lt;p&gt;但是，你应首先熟悉 &lt;a href=&quot;https://stackabuse.com/introduction-to-java-8-streams/&quot;&gt;Java Streams&lt;/a&gt; 和 &lt;a href=&quot;https://stackabuse.com/&quot;&gt;Lambda Expressions in Java&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;虽然我们将列出 &lt;code&gt;Spliterator&lt;/code&gt; 拥有的所有方法，但是 &lt;code&gt;Spliterator&lt;/code&gt; 接口的全部工作超出了本文的范畴。我们将通过一个例子讨论 &lt;code&gt;Spliterator&lt;/code&gt; 如何使用并行化更有效地遍历我们可以分解的 &lt;code&gt;Stream&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们在处理 &lt;code&gt;Spliterator&lt;/code&gt; 时使用的方法是：&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;.characteristics()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;： 返回该 Spliterator 具有的作为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值的特征。 这些包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DISTINCT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SORTED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SIZED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONCURRENT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IMMUTABLE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NONNULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUBSIZED&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;.estimateSize()&lt;/code&gt;：返回遍历作为 &lt;code&gt;long&lt;/code&gt; 值遇到的元素数量的估计值，如果无法返回则返回 &lt;code&gt;long.MAX_VALUE&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;.forEachRemaining(E e)&lt;/code&gt;：按顺序对集合中的每个剩余元素执行给定操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;.getComparator()&lt;/code&gt;：如果该 &lt;code&gt;Spliterator&lt;/code&gt; 的源是由 &lt;code&gt;Comparator&lt;/code&gt; 排序的，其将返回 &lt;code&gt;Comparator&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;.getExactSizeIfKnown()&lt;/code&gt;：如果大小已知则返回 &lt;code&gt;.estimateSize()&lt;/code&gt;，否则返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;.hasCharacteristics(int characteristics)&lt;/code&gt;：如果这个 &lt;code&gt;Spliterator&lt;/code&gt; 的 &lt;code&gt;.characteristics()&lt;/code&gt; 包含所有给定的特征，则返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;.tryAdvance(E e)&lt;/code&gt;：如果存在剩余元素，则对其执行给定操作，返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;.trySplit()&lt;/code&gt;：如果这个 &lt;code&gt;Spliterator&lt;/code&gt; 可以被分区，返回一个 &lt;code&gt;Spliterator&lt;/code&gt; 覆盖元素，当从这个方法返回时，它将不被这个 &lt;code&gt;Spliterator&lt;/code&gt; 覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;像往常一样，让我们从一个简单的 &lt;code&gt;ArrayList&lt;/code&gt; 开始：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; mutants = new ArrayList&amp;lt;&amp;gt;();

mutants.add(&quot;Professor X&quot;);
mutants.add(&quot;Magneto&quot;);
mutants.add(&quot;Storm&quot;);
mutants.add(&quot;Jean Grey&quot;);
mutants.add(&quot;Wolverine&quot;);
mutants.add(&quot;Mystique&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，我们需要将 &lt;code&gt;Spliterator&lt;/code&gt; 应用于 &lt;code&gt;Stream&lt;/code&gt;。值得庆幸的是，由于 Collections 框架，很容易在 &lt;code&gt;ArrayList&lt;/code&gt; 和 &lt;code&gt;Stream&lt;/code&gt; 之间进行转换：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Obtain a Stream to the mutants List.
Stream&amp;lt;String&amp;gt; mutantStream = mutants.stream();

// Getting Spliterator object on mutantStream.
Spliterator&amp;lt;String&amp;gt; mutantList = mutantStream.spliterator();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了展示其中的一些方法，让我们分别运行下它们：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// .estimateSize() method
System.out.println(&quot;Estimate size: &quot; + mutantList.estimateSize());

// .getExactSizeIfKnown() method
System.out.println(&quot;\nExact size: &quot; + mutantList.getExactSizeIfKnown());

System.out.println(&quot;\nContent of List:&quot;);
// .forEachRemaining() method
mutantList.forEachRemaining((n) -&amp;gt; System.out.println(n));

// Obtaining another Stream to the mutant List.
Spliterator&amp;lt;String&amp;gt; splitList1 = mutantStream.spliterator();

// .trySplit() method
Spliterator&amp;lt;String&amp;gt; splitList2 = splitList1.trySplit();

// If splitList1 could be split, use splitList2 first.
if (splitList2 != null) {
    System.out.println(&quot;\nOutput from splitList2:&quot;);
    splitList2.forEachRemaining((n) -&amp;gt; System.out.println(n));
}

// Now, use the splitList1
System.out.println(&quot;\nOutput from splitList1:&quot;);
splitList1.forEachRemaining((n) -&amp;gt; System.out.println(n));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将得到输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Estimate size: 6

Exact size: 6

Content of List: 
Professor X
Magneto
Storm
Jean Grey
Wolverine
Mystique

Output from splitList2: 
Professor X
Magneto
Storm

Output from splitList1: 
Jean Grey
Wolverine
Mystique&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;iterable&quot;&gt;4. Iterable()&lt;/h2&gt;
&lt;p&gt;如果出于某种原因，我们想要创建一个自定义的 &lt;code&gt;Iterator&lt;/code&gt; 接口，应该怎么办？你首先要熟悉的是这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201908/1692986-20190827081223395-274747306.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要创建自定义 &lt;code&gt;Iterator&lt;/code&gt;，我们需要为 &lt;code&gt;.hasNext()&lt;/code&gt;、&lt;code&gt;.next()&lt;/code&gt; 和 &lt;code&gt;.remove()&lt;/code&gt; 做自定义实现。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Iterator&lt;/code&gt; 接口中，有一个方法，它返回一个集合中元素的迭代器，即 &lt;code&gt;.iterator()&lt;/code&gt; 方法，还有一个方法为迭代器中的每个元素执行一个操作的方法，即 &lt;code&gt;.dorEach()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;例如，假设我们是 Tony Stark，我们需要写个自定义迭代器来列出当前武器库中的每件钢铁侠套装。&lt;/p&gt;
&lt;p&gt;首先，让我们创建一个类来获取和设置 suit 数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Suit {

    private String codename;
    private int mark;

    public Suit(String codename, int mark) {
        this.codename = codename;
        this.mark = mark;
    }

    public String getCodename() { return codename; }

    public int getMark() { return mark; }

    public void setCodename (String codename) {this.codename=codename;}

    public void setMark (int mark) {this.mark=mark;}

    public String toString() {
        return &quot;mark: &quot; + mark + &quot;, codename: &quot; + codename;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来让我们编写自定义 Iterator：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Our custom Iterator must implement the Iterable interface
public class Armoury implements Iterable&amp;lt;Suit&amp;gt; {
    
    // Notice that we are using our own class as a data type
    private List&amp;lt;Suit&amp;gt; list = null;

    public Armoury() {
        // Fill the List with data
        list = new LinkedList&amp;lt;Suit&amp;gt;();
        list.add(new Suit(&quot;HOTROD&quot;, 22));
        list.add(new Suit(&quot;SILVER CENTURION&quot;, 33));
        list.add(new Suit(&quot;SOUTHPAW&quot;, 34));
        list.add(new Suit(&quot;HULKBUSTER 2.0&quot;, 48));
    }
    
    public Iterator&amp;lt;Suit&amp;gt; iterator() {
        return new CustomIterator&amp;lt;Suit&amp;gt;(list);
    }

    // Here we are writing our custom Iterator
    // Notice the generic class E since we do not need to specify an exact class
    public class CustomIterator&amp;lt;E&amp;gt; implements Iterator&amp;lt;E&amp;gt; {
    
        // We need an index to know if we have reached the end of the collection
        int indexPosition = 0;
        
        // We will iterate through the collection as a List
        List&amp;lt;E&amp;gt; internalList;
        public CustomIterator(List&amp;lt;E&amp;gt; internalList) {
            this.internalList = internalList;
        }

        // Since java indexes elements from 0, we need to check against indexPosition +1
        // to see if we have reached the end of the collection
        public boolean hasNext() {
            if (internalList.size() &amp;gt;= indexPosition +1) {
                return true;
            }
            return false;
        }

        // This is our custom .next() method
        public E next() {
            E val = internalList.get(indexPosition);

            // If for example, we were to put here &quot;indexPosition +=2&quot; we would skip every 
            // second element in a collection. This is a simple example but we could
            // write very complex code here to filter precisely which elements are
            // returned. 
            // Something which would be much more tedious to do with a for or while loop
            indexPosition += 1;
            return val;
        }
        // In this example we do not need a .remove() method, but it can also be 
        // written if required
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是 main 方法类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class IronMan {

    public static void main(String[] args) {

        Armoury armoury = new Armoury();

        // Instead of manually writing .hasNext() and .next() methods to iterate through 
        // our collection we can simply use the advanced forloop
        for (Suit s : armoury) {
            System.out.println(s);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mark: 22, codename: HOTROD
mark: 33, codename: SILVER CENTURION
mark: 34, codename: SOUTHPAW
mark: 48, codename: HULKBUSTER 2.0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;本文中，我们详细讨论了如何使用 Java 中的迭代器，甚至写了一个定制的迭代器来探索 &lt;code&gt;Iterable&lt;/code&gt; 接口的所有新的可能性。&lt;/p&gt;
&lt;p&gt;我们还讨论了 Java 是如何利用 Stream 的并行化，使用 &lt;code&gt;Spliterator&lt;/code&gt; 接口对集合的遍历进行内部优化。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;8月福利准时来袭，关注公众号&lt;br/&gt;​&lt;br/&gt;后台回复：003即可领取7月翻译集锦哦~&lt;br/&gt;​&lt;br/&gt;往期福利回复：001，002即可领取！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201908/1692986-20190827081224232-1191953011.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Aug 2019 00:12:00 +0000</pubDate>
<dc:creator>锅外的大佬</dc:creator>
<og:description>1. 简介 当我们使用 或 循环来遍历一个集合的元素， 允许我们不用担心索引位置，甚至让我们不仅仅是遍历一个集合，同时还可以改变它。例如，你如果要删除循环中的元素，那么 循环不见得总是可行的。 结合自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liululee/p/11416038.html</dc:identifier>
</item>
<item>
<title>CSS布局：水平垂直居中 - DXSIX</title>
<link>http://www.cnblogs.com/zhupengcheng/p/11416034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhupengcheng/p/11416034.html</guid>
<description>&lt;p&gt;本文将依次介绍在不同条件下实现&lt;strong&gt;水平垂直居中&lt;/strong&gt;的多种方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;水平垂直居中&lt;/strong&gt;是在写网页时经常会用到的需求，在上两篇博客中，分别介绍了水平居中和垂直居中的方法。本文的水平垂直居中就是将之前的水平居中和垂直居中用到的方法综合起来。用到的原理都是一样的。相信掌握水平居中和垂直居中的方法后，就能自己总结如何实现水平垂直居中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip：&lt;/strong&gt;下文中说的适用场景只是举了几个简单的例子方便读者理解。实际应用场景太复杂，生搬硬套容易出错。最重要的是掌握各种方法能够实现居中的原理。只要掌握了原理，那么不管问题怎么变都可以根据自己的理解选择合适的方法。&lt;/p&gt;
&lt;h2 id=&quot;section&quot;/&gt;
&lt;h2 id=&quot;一使用text-algin和line-height&quot;&gt;一、使用text-algin和line-height&lt;/h2&gt;
&lt;h3 id=&quot;原理&quot;&gt;1.原理&lt;/h3&gt;
&lt;p&gt;使用text-algin属性的center值，实现水平居中。&lt;br/&gt;使用line-height属性，使其的值等于父元素的高度，实现垂直居中&lt;br/&gt;两者综合实现水平垂直居中&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;2.适用场景&lt;/h3&gt;
&lt;p&gt;（1）通常用于可以设置行高的元素上&lt;/p&gt;
&lt;h3 id=&quot;实现步骤&quot;&gt;3.实现步骤&lt;/h3&gt;
&lt;p&gt;（1）在父元素上设置文本水平居中&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;text-algin:center;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080602677-1973930979.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在子元素上设置行高等于父元素高度&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;line-height:100px;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080614901-1311600914.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.完整代码&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;水平垂直居中&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        .box {
            width: 300px;
            height: 100px;
            border: 1px solid #222222;
            text-align: center;/*设置水平居中*/
        }
        p{
            line-height: 100px;/*设置行高等于父元素高度实现垂直居中*/
            margin: 0;/*清除外边距的影响*/
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot;&amp;gt;
        &amp;lt;p&amp;gt;水平垂直居中&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二使用table布局&quot;&gt;二、使用table布局&lt;/h2&gt;
&lt;h3 id=&quot;原理-1&quot;&gt;1.原理&lt;/h3&gt;
&lt;p&gt;将元素转为table类型。利用vertical-align属性进行垂直居中，子元素再使用margin进行水平居中最终实现水平垂直居中（vertical-algin居中需要有参考物，否则不能实现居中。在表单元格中可以直接设置）&lt;/p&gt;
&lt;h3 id=&quot;适用场景-1&quot;&gt;2.适用场景&lt;/h3&gt;
&lt;p&gt;（1）有宽度的子元素&lt;/p&gt;
&lt;h3 id=&quot;实现步骤-1&quot;&gt;3.实现步骤&lt;/h3&gt;
&lt;p&gt;（1）父元素将类型转换为table-cell&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;display:table-cell;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080630447-576319661.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）父元素设置vertical-align实现垂直居中&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;vertical-align:middle;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080638695-1966114880.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）子元素设置margin属性&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;margin:0 auto;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080646819-241928608.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;完整代码&quot;&gt;4.完整代码&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;水平垂直居中&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        * {
            margin: 0;
            padding: 0;
        }
        .box {
            width: 300px;
            height: 100px;
            border: 1px solid #333;
            display: table-cell;
            vertical-align: middle;
        }
        .box .child {
            width: 50px;
            height: 50px;
            background: red;
            margin: 0 auto;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot;&amp;gt;
        &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三使用定位&quot;&gt;三、使用定位&lt;/h2&gt;
&lt;h3 id=&quot;方法一使用fixedmargin&quot;&gt;方法一：使用fixed+margin&lt;/h3&gt;
&lt;h3 id=&quot;原理-2&quot;&gt;1.原理&lt;/h3&gt;
&lt;p&gt;通过设置上下左右的定位属性，然后设置margin上下左右都为auto实现居中&lt;/p&gt;
&lt;h3 id=&quot;适用场景-2&quot;&gt;2.适用场景&lt;/h3&gt;
&lt;p&gt;（1）未知大小元素在浏览器中居中&lt;/p&gt;
&lt;h3 id=&quot;实现步骤-2&quot;&gt;3.实现步骤&lt;/h3&gt;
&lt;p&gt;（1）子元素设置固定定位（没有变化）&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;position: fixed;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）子元素设置上下左右的定位值为0（没有变化）&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;left: 0;
right: 0;
top: 0;
bottom: 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）子元素设置margin&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;margin:auto;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080705995-881567416.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;完整代码-1&quot;&gt;4.完整代码&lt;/h3&gt;
&lt;p&gt;示例1：未知大小的元素在浏览器可视窗口中水平居中&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;未知大小的元素在浏览器可视窗口中水平居中&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        img{
            position: fixed;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            margin: auto;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot;&amp;gt;
        &amp;lt;img src=&quot;../images/img13.jpg&quot; alt=&quot;&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例2：已知大小的元素在浏览器可视窗口中水平居中&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;已知大小的元素在浏览器可视窗口中水平居中&amp;lt;/title&amp;gt;
        &amp;lt;style&amp;gt;
            .box {
                width: 100px;
                height: 200px;
                background: #f00;
                position:fixed;
                left: 50%;
                top: 50%;
                margin: -100px 0 0 -50px;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法二使用relative-absolute&quot;&gt;方法二：使用relative + absolute&lt;/h3&gt;
&lt;h3 id=&quot;原理-3&quot;&gt;1.原理&lt;/h3&gt;
&lt;p&gt;通过父元素设置相对定位，子元素设置绝对定位。利用top值和left值进行居中移动，再使用&lt;strong&gt;margin&lt;/strong&gt;或&lt;strong&gt;transform&lt;/strong&gt;调整位置&lt;br/&gt;Tip：注意元素定位是以元素的&lt;strong&gt;某个边&lt;/strong&gt;或者&lt;strong&gt;某个角&lt;/strong&gt;作为参考，而不是以元素的中心点为参考&lt;br/&gt;例：单个使用，是以&lt;strong&gt;边框&lt;/strong&gt;为参考，两个组合使用是以&lt;strong&gt;角&lt;/strong&gt;为参考点&lt;br/&gt;（1）&lt;strong&gt;top：&lt;/strong&gt;以元素上边框为参考，top：50px；就是元素上边框距离父元素上边框50px&lt;br/&gt;（2）&lt;strong&gt;right：&lt;/strong&gt;以元素右边框为参考，right：50px；就是元素右边框距离父元素右边框50px&lt;br/&gt;（3）&lt;strong&gt;left&lt;/strong&gt;和&lt;strong&gt;top&lt;/strong&gt;组合使用：以元素的左上角的点为参考，top：50px；left：50px；表示元素左上角的点距离父元素上边框50px，距离父元素左边框50px；&lt;br/&gt;（4）&lt;strong&gt;right&lt;/strong&gt;和&lt;strong&gt;bottom&lt;/strong&gt;组合使用：以元素的右下角的点为参考，bottom：50px；right：50px；表示元素右下角的点距离父元素下边框50px，距离父元素右边框50px；&lt;br/&gt;（5）其他各种组合同理，两个对立方向的属性不能同时组合使用。例如top和bottom同时使用&lt;strong&gt;以top为准&lt;/strong&gt;，bottom会失效。left和right；同时使用的话会&lt;strong&gt;以left为准&lt;/strong&gt;，right会失效。&lt;br/&gt;（6）所以top和left定位50%，是子元素边框或某个角移动到50%的位置，还需要移动回来子元素自身一半的长度，达到真正的居中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080729121-815234224.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;适用场景-3&quot;&gt;2.适用场景&lt;/h3&gt;
&lt;p&gt;（1）已知大小元素在父元素中居中（margin属性）&lt;br/&gt;（2）未知大小元素在父元素中居中（transform属性，有兼容问题）&lt;br/&gt;（3）浮动元素居中&lt;/p&gt;
&lt;h3 id=&quot;实现步骤-3&quot;&gt;3.实现步骤&lt;/h3&gt;
&lt;p&gt;（1）先将父元素设置为相对定位relative（无变化）&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;position: relative;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）将子元素设置为绝对定位absolute（子绝父相）（无变化）&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;position:absolute;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）向右移动子元素，向下移动子元素，移动距离为父容器的一半（50%）&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;top:50%;
left: 50%;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080745042-1504613717.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tip：此时元素的左上角在父元素的中心点&lt;/p&gt;
&lt;p&gt;（4）通过向左和向上移动子元素的长度的一半使子元素整体水平居中。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*margin实现*/
margin: -25px 0 0 -25px;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080820418-408986775.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*transform实现*/
transform: translate(-50%, -50%);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080831124-756451339.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;完整代码-2&quot;&gt;4.完整代码&lt;/h3&gt;
&lt;p&gt;示例1：已知大小元素在父元素中水平垂直居中（margin属性）&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;已知大小元素在父元素中水平垂直居中&amp;lt;/title&amp;gt;
        &amp;lt;style&amp;gt;
            .box {
                width: 300px;
                height: 200px;
                border: 1px solid #333333;
                position: relative;
            }
            .box .child {
                width: 50px;
                height: 50px;
                background: #222222;
                position: absolute;
                top:50%;
                left: 50%;
                margin: -25px 0 0 -25px;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;box&quot;&amp;gt;
            &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例2：未知大小元素在父元素中水平垂直居中（transform属性）&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
        &amp;lt;title&amp;gt; 未知大小元素在父元素中水平垂直居中&amp;lt;/title&amp;gt;
        &amp;lt;style&amp;gt;
            .box {
                width: 300px;
                height: 200px;
                border: 1px solid #333333;
                position: relative;
            }
            .box .child {
                position: absolute;
                top:50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;box&quot;&amp;gt;
            &amp;lt;div class=&quot;child&quot;&amp;gt;我是transform居中&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四弹性盒子flex布局&quot;&gt;四、弹性盒子flex布局&lt;/h2&gt;
&lt;h3 id=&quot;方法一justify-contentalign-items&quot;&gt;方法一：justify-content+align-items&lt;/h3&gt;
&lt;h3 id=&quot;原理-4&quot;&gt;1.原理&lt;/h3&gt;
&lt;p&gt;css3中的弹性盒子是布局神器，并且可达到某些自适应变化的效果。利用flex布局，其中&lt;strong&gt;justify-content&lt;/strong&gt; 用于设置或检索弹性盒子元素在主轴（默认左右横轴）方向上的对齐方式；而&lt;strong&gt;align-items&lt;/strong&gt;属性定义flex子项在flex容器的当前行的侧轴（默认上下纵轴）方向上的对齐方式。不能兼容低版本的IE浏览器。&lt;/p&gt;
&lt;h3 id=&quot;适用场景-4&quot;&gt;2.适用场景&lt;/h3&gt;
&lt;p&gt;（1）已知元素大小居中&lt;br/&gt;（2）未知元素大小居中&lt;br/&gt;（3）多个元素同时居中&lt;/p&gt;
&lt;h3 id=&quot;实现步骤-4&quot;&gt;3.实现步骤&lt;/h3&gt;
&lt;p&gt;（1）父元素开启弹性盒子&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;display:flex;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080848830-2066633546.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）父元素设置主轴居中（对子元素生效）&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;justify-content: center;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080902232-834639803.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）父元素设置侧轴居中（对子元素生效）&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;align-items: center;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080911053-1590231897.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;完整代码-3&quot;&gt;4.完整代码&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;title&amp;gt; 未知大小元素在父元素中水平垂直居中&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        .box {
            height: 100px;
            width: 200px;
            border: 1px solid #222222;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot;&amp;gt;
        &amp;lt;div class=&quot;child&quot;&amp;gt;flex居中&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法二flexgrid-与-marginauto-最简单写法&quot;&gt;方法二：flex/grid 与 margin:auto (最简单写法)&lt;/h3&gt;
&lt;h3 id=&quot;原理-5&quot;&gt;1.原理&lt;/h3&gt;
&lt;p&gt;父元素开启弹性盒子布局或者网格布局，之后子元素利用margin的自动值，实现居中（不能兼容低版本的IE浏览）&lt;/p&gt;
&lt;h3 id=&quot;适用场景-5&quot;&gt;2.适用场景&lt;/h3&gt;
&lt;p&gt;（1）未知元素大小居中&lt;br/&gt;（2）已知元素大小居中&lt;/p&gt;
&lt;h3 id=&quot;实现步骤-5&quot;&gt;3.实现步骤&lt;/h3&gt;
&lt;p&gt;（1）给父元素开启弹性盒子布局或者网格布局&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*开启弹性盒子布局*/
display:flex;
/*开启网格布局*/
display:gird;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）子元素设置margin值实现居中&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;marign：auto;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1743728/201908/1743728-20190827080922201-1862387189.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;完整代码-4&quot;&gt;4.完整代码&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;title&amp;gt; 未知大小元素在父元素中水平垂直居中&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        .box {
            height: 100px;
            width: 200px;
            border: 1px solid #222222;
            /* display: flex; */
            display: grid;
        }
        .child{
            margin: auto;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot;&amp;gt;
        &amp;lt;div class=&quot;child&quot;&amp;gt;flex或gird居中&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 27 Aug 2019 00:10:00 +0000</pubDate>
<dc:creator>DXSIX</dc:creator>
<og:description>CSS布局：元素水平垂直居中 本文将依次介绍在不同条件下实现 水平垂直居中 的多种方法 水平垂直居中 是在写网页时经常会用到的需求，在上两篇博客中，分别介绍了水平居中和垂直居中的方法。本文的水平垂直居</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhupengcheng/p/11416034.html</dc:identifier>
</item>
<item>
<title>SpringIoC和SpringMVC的快速入门 - 全菜工程师小辉</title>
<link>http://www.cnblogs.com/mseddl/p/11416030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mseddl/p/11416030.html</guid>
<description>&lt;p&gt;更多内容，欢迎关注微信公众号：全菜工程师小辉~&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;降低了组件之间的耦合性 ，实现了软件各层之间的解耦&lt;/li&gt;
&lt;li&gt;可以使用容易提供的众多服务，如事务管理，消息服务等&lt;/li&gt;
&lt;li&gt;容器提供单例模式支持&lt;/li&gt;
&lt;li&gt;容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能&lt;/li&gt;
&lt;li&gt;Spring的IoC机制降低了业务对象替换的复杂性&lt;/li&gt;
&lt;li&gt;容器提供了众多的辅助类，能加快应用的开发&lt;/li&gt;
&lt;li&gt;Spring对于主流的应用框架提供了集成支持，如Hibernate，JPA，Mybatis等&lt;/li&gt;
&lt;li&gt;Spring属于低侵入式设计，代码的污染极低, 并且独立于各种应用服务器&lt;/li&gt;
&lt;li&gt;Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring的部分或全部。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IoC和AOP是Spring框架的两大特性，IoC和MVC的流程密不可分，可以看作是面向对象编程的实现；而AOP特性则是面向切面编程的体现，也是前者的补充，所以可以拆分开后续讲解。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文对SpringIoC和SpringMVC的流程进行了简单的讲解，更加详细的过程，欢迎看笔者的代码库，里面几乎每行代码都做了详细注释，一个请求debug跟下来，过程就一目了然了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/y277an/java-you-need-know/tree/master/spring-ioc-mvc&quot;&gt;快戳我，我们去学习~&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;控制反转IoC(Inversion of Control)，是一种设计思想。没有IoC的程序中我们使用面向对象编程对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，而使用控制反转后，将对象的创建转移给第三方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190827080736377-1139580595.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从IoC容器中取出需要的对象。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;基础包扫描。读取配置文件，然后根据配置路径进行全包扫描，，最后将扫描到的类名加上全限定名之后加入到数组集合中&lt;/li&gt;
&lt;li&gt;实例化所有带注解的类。遍历上一步的数组集合，判断类上的注解并实例化该类，以该类的类名为key，实例为value，放入哈希表中&lt;/li&gt;
&lt;li&gt;依赖注入。遍历上一步的哈希表，获取类上所有Fields，遍历Fields，判断Fields上是否为@Autowired类型的注解，如果是的话就把Map中的实例赋值这个field&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Url地址和方法映射。遍历第二步的哈希表，如果是Controller实例，获取Methods并遍历，判断方法上是否含有@RequestMapping注解，如果含有，则获取它的值，将@Controller的注解值拼接上@RequestMapping值组成key，当前method作为value，装入hanlerMap中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;请求反射调用。(这一步已经属于MVC范畴)一个url请求过来，获取它的地址，拆分，获取Controller实例，获取Method实例，反射执行Method&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SpringMVC框架是以请求为驱动，围绕Servlet设计，将请求发给控制器，然后通过模型对象，分派器来展示请求结果视图。其中核心类是DispatcherServlet，它是一个Servlet，顶层是实现的Servlet接口。&lt;/p&gt;

&lt;p&gt;框架的作用一直都是用来简化编程的：&lt;br/&gt;servlet只有doGet和doPost，一个servlet类只能处理一个url-pattern。&lt;br/&gt;SpringMVC类里面可以通过RequestMapping处理很多请求，并且支持Rest风格的请求，如DELETE/PUT等；SpringMVC参数的映射可以直接封装成实体类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190827080736639-767212964.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;流程图说明&quot;&gt;流程图说明:&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;用户发送请求至 前端控制器DispatcherServlet。&lt;/li&gt;
&lt;li&gt;前端控制器DispatcherServlet收到请求后调用处理器映射器HandlerMapping。&lt;/li&gt;
&lt;li&gt;处理器映射器HandlerMapping根据请求的Url找到具体的处理器，生成处理器对象Handler及处理器拦截器HandlerIntercepter（如果有则生成）一并返回给前端控制器DispatcherServlet。&lt;/li&gt;
&lt;li&gt;前端控制器DispatcherServlet通过处理器适配器HandlerAdapter调用处理器Controller。&lt;/li&gt;
&lt;li&gt;执行处理器（Controller，也叫后端控制器）&lt;/li&gt;
&lt;li&gt;处理器Controller执行完后返回ModelAndView。&lt;/li&gt;
&lt;li&gt;处理器映射器HandlerAdapter将处理器Controller执行返回的结果ModelAndView返回给前端控制器DispatcherServlet。&lt;/li&gt;
&lt;li&gt;前端控制器DispatcherServlet将ModelAnView传给视图解析器ViewResolver。&lt;/li&gt;
&lt;li&gt;视图解析器ViewResolver解析后返回具体的视图View。&lt;/li&gt;
&lt;li&gt;前端控制器DispatcherServlet对视图View进行渲染视图（即：将模型数据填充至视图中）&lt;/li&gt;
&lt;li&gt;前端控制器DispatcherServlet响应用户。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;mvc流程中的模块&quot;&gt;MVC流程中的模块：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;DispatcherServlet：前端控制器（不需要程序员开发）&lt;br/&gt;用户请求到达前端控制器，它相当于MVC模式中的C（Controller），DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。&lt;br/&gt;作用：作为接受请求，相应结果，相当于转发器，中央处理器，减少其他组件之间的耦合度。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;HandlerMapping：处理器映射器（不需要程序员开发）&lt;br/&gt;HandlerMapping负责根据用户请求找到Handler（即：处理器），SpringMVC提供了不同的映射器实现实现不同的映射方式，例如：配置文件方式、实现接口方式、注解方式等。&lt;br/&gt;作用：根据请求的Url 查找Handler&lt;/li&gt;
&lt;li&gt;Handler：处理器（需要程序员开发）&lt;br/&gt;Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下，Handler对具体的用户请求进行处理。&lt;br/&gt;由于Handler设计到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。&lt;/li&gt;
&lt;li&gt;HandlerAdapter：处理器适配器&lt;br/&gt;通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。&lt;br/&gt;作用：按照特定的规则（HandlerAdapter要求的规则）去执行Handler&lt;/li&gt;
&lt;li&gt;ViewResolver：视图解析器（不需要程序员开发）&lt;br/&gt;ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面的展示给用户。SpringMVC框架提供了很多View视图类型，包括：JSTLView、freemarkerView、pdfView等等。&lt;br/&gt;作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）。&lt;/li&gt;
&lt;li&gt;View视图 （需要程序员开发 jsp）&lt;br/&gt;View是一个接口，实现类支持不同的View类型（jsp、freemarker等）一般情况下需要通过页面标签或者页面模板技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190827080736842-1441663614.png&quot; alt=&quot;哎呀，如果我的名片丢了。微信搜索“全菜工程师小辉”，依然可以找到我&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Aug 2019 00:08:00 +0000</pubDate>
<dc:creator>全菜工程师小辉</dc:creator>
<og:description>更多内容，欢迎关注微信公众号：全菜工程师小辉~ Spring的优势？ 1. 降低了组件之间的耦合性 ，实现了软件各层之间的解耦 2. 可以使用容易提供的众多服务，如事务管理，消息服务等 3. 容器提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mseddl/p/11416030.html</dc:identifier>
</item>
<item>
<title>iNeuOS 物联网云操作系统2.0发布，集成设备容器、视图建模、机器学习三大模块 - 唯笑志在</title>
<link>http://www.cnblogs.com/lsjwq/p/11415419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/11415419.html</guid>
<description>&lt;p class=&quot;a&quot;&gt;&lt;span&gt;目       录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.      概述... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.      使命及目标... 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.      系统框架... 4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.      设备容器（iNeuKernel）... 4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.      第三方数据导入接口... 9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.      视图建模（iNeuView）... 10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.      机器学习（iNeuAI）... 11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.      征集需求... 13&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;        iNeuOS物联网云操作系统（i：代表信息和工业，Neu：代表神经元和细胞，OS：代表操作系统），这是我们起名字时候的想法。5月底发表的《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/10928843.html&quot;&gt;iNeuOS云操作系统，.NET Core全系打造&lt;/a&gt;》时有网友质疑：只是仿了Windows 10操作界面、这也能叫操作系统。只能说大家对事物的理解有偏差，也没有做过去的解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       时隔3个月的时间，我们发布iNeuOS 2.0版本信息了设备容器、视图建模和机器学习三大功能组件。&lt;strong&gt;设备容器&lt;/strong&gt;主要解决多种协议多种通讯机制设备或传感器数据接入的问题，支持二次开发；&lt;strong&gt;视图建模&lt;/strong&gt;主要解决设备或传感器数据即接入即显示的问题，可以发布成桌面应用，类似早期WindowsXP宣传的即插即用的思维；&lt;strong&gt;机器学习&lt;/strong&gt;主要解决设备或传感器数据接入后进行模型训练，提炼出来知识和规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       iNeuOS全部使用.NET Core开发，可以部署到嵌入式设备中，从而形成边缘计算网关产品，只需要开发更多的设备驱动在设备容器中运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       对于现在来讲，这就是我们体系化建设的大致思路。同道中人有什么好的相法和思路，可以随时与我们沟通。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       演示地址： &lt;/strong&gt;&lt;a href=&quot;http://192.144.173.38:8081/login.html&quot;&gt;进入iNeuOS系统&lt;/a&gt;&lt;strong&gt;。（建议使用chrome&lt;/strong&gt;&lt;strong&gt;浏览器）&lt;br/&gt;      &lt;/strong&gt; &lt;strong&gt;测试名称：admin&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       测试密码：admin&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      注：上次发布的时候，由于登陆系统的人较多，大家反馈比较慢，我们租用的是云服务器，配置确实不太高，请大家谅解！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt; 登陆界面，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826220756418-1828879435.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     系统内部界面，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826220817234-1680560867.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       现在大家都在喊工业大数据和工业互联网，但是真正能够落地的不多，反而有些企业走上了过去信息化的老路，口号高于实质；现在大家也在搞百万企业上云，从硬件集约化角度考虑，确实能够降低企业的成本，但是只限于数据和服务变更空间位置，显然体现的作用或意义不大；当然也有做的不错的，例如阿里物联网（IOT）这块，体系化、标准化解决设备接入的问题，包括规则和视图显示等，iNeuOS可以无缝与阿里IOT进行数据对接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      对于工业来讲，并不是所有企业都愿意上云，不管是以基础资源的形式还是物联网接入的形式。对于中小企业建设私有云平台，又面临成本过高和运维能力不足的情况。基于上述情况，iNeuOS的主要使命就是要解决企业信息化能力不足、成本过高的问题。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      iNeuOS现在包括三大功能组件：设备容器（iNeuKernel）、视图建模（iNeuView）、机器学习（iNeuAI）。框架示意，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826220850681-2015443631.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;5&quot;&gt;&lt;span&gt;图 iNeuOS框架示意&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       设备容器（iNeuKernel）是iNeuOS内核设备运行容器，是以物理设备或传感器为核心构建的框架，可以随意挂载设备驱动在容器下运行，总体协调设备驱动（协议）、IO通道（COM和NET）、运行机制（模式）之间的协作机制，使之无缝结合、运行，开放支持二次开发。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826220937511-1141867897.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       服务管理，在一个服务实例下可以运行多个设备驱动，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826220957907-1149909488.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;5&quot;&gt;&lt;span&gt;图 服务管理列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221032297-1055674574.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;5&quot;&gt;&lt;span&gt; 图 增加服务实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        设备管理，一个设备驱动下可以采集多个数据点的信息，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221121905-869649830.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;5&quot;&gt;&lt;span&gt;图 设备管理列表&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;5&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221149524-1758738074.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;5&quot;&gt;&lt;span&gt;图 增加设备驱动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        数据点管理，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221219478-1058669652.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;5&quot;&gt;&lt;span&gt;图 设备驱动数据点列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221244032-2065927083.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;5&quot;&gt;&lt;span&gt;图 增加数据点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）iNeuKernel的特点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持与实体设备之间多种模式交互，包括：轮询模式、自控模式、并发模式和单例模式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持协议驱动器，可以按规范开发标准协议和自定义协议。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持发送数据缓存器，支持命令缓存重发和按优先级别发送。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持协议过滤器，按规则筛选数据；并且可以承继接口，自定义过滤方式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持接收数据缓存器，可以缓存不符合过滤器的数据，和下次接收数据进行拼接。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持按设备命令优先级别进行调度设备，保证有高级别命令的驱动及时发送。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持一个设备驱动，同时支持串口和网络两种通讯方式，可以监视IO通道数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持一个设备驱动，在网络通讯时可以支持TCP Server和TCP Client两种工作模式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持服务组件接口，例如：4-20mA输出、LED大屏显示、短信服务、以及多功能网关服务。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;设备驱动与设备驱动，设备驱动与服务器（云端）可以实时双向交互，上传数据和指令下发。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持创建多服务实例，完成不同业务的拆分。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持WebSocket，进行数据采集与转发。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持多设备通讯IO通道多路复用机制。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持定时清理无效IO通道，并释放资源。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持跨平台部署，可以运行在Linux和Windows系统。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）iNeuKernel解决的现实问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      物联网平台都会有自己的接入数据标准协议，但是每个平台的数据协议又不一样，所以并没有从根本上解决协议标准的问题。所以物联网、大数据、工业互联网的数据集成过程中仍然面临四个主要困难：设备多样性、协议多样性、通讯机制多样性、数据多样性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221415026-167554996.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       系统提供HTTP Post接口服务，方便导入其他系统的数据，以便用于视图建模（iNeuView）和机器学习（iNeuAI）功能组件服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       导入配置数据接口形式，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[{
       &quot;servername&quot;: &quot;servername&quot;,
       &quot;devices&quot;: [{
              &quot;devicename&quot;: &quot;mydevice&quot;,
              &quot;tags&quot;: [{
                     &quot;tagname&quot;: &quot;tagname&quot;
              }]
       }]
}]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;      导入实时数据接口形式，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[{
       &quot;timestamp&quot;: &quot;2019-08-06T11:33:18.6983926+08:00&quot;,
       &quot;tagname&quot;: &quot;tag_2_2&quot;,
       &quot;tagvalue&quot;: 2.2
}]
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      视图建模（iNeuView）是iNeuOS视图建模功能组件，对设备容器（iNeuKernel）接入的设备或传感器数据进行视图建模组态、数据实时展示和预警等。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221622810-842439286.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     在原有图元基础上增加到3500多个SVG矢量图元，涉及到61个领域及分类。并且支持对编辑好的界面进行分享，可以对分享的链接和二维码集成到其他系统中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221637206-1623167301.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;     视图建模（iNeuView）特点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;建模和组态的图元信息丰富，满足不同行业和领域实时监测的需求。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;B/S应用框架，部署、应用和发布方便，易于操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;与设备容器（iNeuKernel）服务组件无缝对接，实现设备或传感器即插、即用、即显示。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对编辑的界面预览，查看实际应用效果。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对编辑好的界面应用进行分享，方便集成到其他系统中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对编辑好的界面可以发布到iNeuOS桌面，类似Windows应用程序。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;     机器学习（iNeuAI）是iNeuOS的核心组件，对接入的数据进行数据样本标记、数据算法模型训练、工况智能预警。现在支持决策树和KMeans两种算法，从规划角度考虑，还要增加算法和完善产品体系。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221805509-119987464.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     机器学习（iNeuAI）从体量巨大、结构繁多的数据中挖掘出潜藏在数据中的规律和知识，使数据发挥最大化的价值。与传统软件开发不同之处，如下示意图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221816646-1399135310.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     应用效果，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201908/279374-20190826221836629-871321154.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;     希望广大网友，针对领域应用提出具体的需求，在符合iNeuOS的基础上考虑集成进来。可以加入物联网&amp;amp;集成技术群：54256083，进行讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     我们不排斥任何形式的合作，技术方面和市场方面。当然，如果有实力的技术加入我们团队，那就更好了。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; 物联网&amp;amp;集成技术 QQ群：&lt;span&gt;54256083 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;span&gt;物联网&amp;amp;集成合作 QQ群：727664080&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 网站：&lt;a href=&quot;http://www.ineuos.net&quot; target=&quot;_blank&quot;&gt;http://www.ineuos.net&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Aug 2019 00:08:00 +0000</pubDate>
<dc:creator>唯笑志在</dc:creator>
<og:description>目 录 1. 概述... 2 2. 使命及目标... 3 3. 系统框架... 4 4. 设备容器（iNeuKernel）... 4 5. 第三方数据导入接口... 9 6. 视图建模（iNeuVie</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lsjwq/p/11415419.html</dc:identifier>
</item>
</channel>
</rss>