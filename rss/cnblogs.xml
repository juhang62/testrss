<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C语言入门教程-(4)常量和变量 - 程序员基础知识</title>
<link>http://www.cnblogs.com/cxyjczs/p/10193398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxyjczs/p/10193398.html</guid>
<description>&lt;p&gt;程序执行过程中其值不能发生改变的量叫做常量，其值能发生改变的量叫做变量。常量可以直接使用，而变量则必须先定义后才能使用，否则编译器会报错。&lt;/p&gt;

&lt;p&gt;在介绍常量和变量的命名规范之前，我们先了解一下什么是标识符和关键字。&lt;/p&gt;
&lt;h3 id=&quot;h1-1&quot;&gt;&lt;span&gt;1）标识符&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;标识符，用来标识符号常量名、变量名、函数名、数组名、文件名、类名、对象名等。简单的将就是大家取的名字~~有效标识符的构成规则如下：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;1）第一个字符必须是字母（大小写都行）或下划线，不能是数字;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;2）后跟字母（大小写都行）、下划线或数字组成;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;3）标识符中的大小写字母有区别。如，变量sum,Sum,SUM代表三个不同的变量；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;4）不能与编译系统已经预定义的、具有特殊用途的保留标识符（即关键字）同名。比如，不能将标识符命名int,char,float,break,case,for,while,return等等；&lt;br/&gt;下面列出几个有效的标识符：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;teemo    &lt;br/&gt;Garen&lt;br/&gt;move_name&lt;br/&gt;dj8023  &lt;br/&gt;_temp  &lt;br/&gt;i&lt;br/&gt;the_hero_is_Garen&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面列出几个无效的标识符：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;8times    &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h2-1&quot;&gt;&lt;span&gt;2）关键字&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;C语言中具有特殊含义的英文单词，通常用于构成语句，存储数据，定义数据类型等。下面列出了C语言中的一些保留字。这些保留字不能作为常量名、变量名或其他标识符名称。&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1）基本数据类型&lt;br/&gt;int：声明整数类型&lt;br/&gt;float：声明浮点型&lt;br/&gt;double：声明双精度浮点型&lt;br/&gt;char：声明字符类型&lt;br/&gt;void：空类型，声明函数无返回值或无参数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2）流程控制&lt;br/&gt;条件判断：if、else、switch、case、default等&lt;br/&gt;循环：while、do、for、break、continue&lt;br/&gt;返回：return&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在本节中，先了解一下就行，有很多不明白的关键字后面会讲到。&lt;/p&gt;
&lt;h3 id=&quot;h3&quot;&gt;&lt;span&gt;3）命名规范&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;首先，必须是有效的标识符。在这个基础上，我们使用的命名最好能做到看名字就明白它表示什么。如果要使用一个变量来表示teemo的血量，我们可以将其命名为teemo_hp或者teemoHp，而不是随便的命名为a或者b之类的。遇到两个或者更多的单词组成的名称，我们通常用下划线字符将它们连接起来，或者从第二单词开始将每一个单词的第一个字母大写。&lt;/p&gt;
&lt;p&gt;还有一些程序员可能会在变量中加入描述变量类型或者内容的前缀。例如，可以将整型变量teemoHp命名为nTeemoHp,其中n表示整数值。这样做的好处是在你遇到这个变量的时候，可以很直接的知道这个变量的类型。常用的几种前缀有：c(表示单个字符)、p(表示指针)等。另外，常量的标识符习惯用大写字母表示，变量的标识符习惯用小写字母表示。单下划线打头的标识符一般代表标准数据库的变量，双下划线打头的标识符一般代表编译器的变量。&lt;/p&gt;
&lt;p&gt;关于命名，想说的是，命名可以根据自己的需要、喜好和个人风格来使用，但起码要保证一个程序里面的风格是一致性的。在团队共同开发中，则需要按照规范进行命名。规范的命名不仅可以让自己以后看的明白，也利于给团队其他人维护代码。&lt;/p&gt;

&lt;h3 id=&quot;h1-2&quot;&gt;&lt;span&gt;1）直接常量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;直接常量又可以叫做字面常量，通过数据来直接表现。在C语言中，编译器会自动根据字面常量的表示形式确定其类型。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;y = x + &lt;span class=&quot;hljs-number&quot;&gt;3;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的程序中，3将会被编译器作为int类型的常量。再例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;y = x + &lt;span class=&quot;hljs-number&quot;&gt;3.0;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.0是小数，则会被编译器作为float类型的常量。当然，字符也有常量，不过和整型常量不同，字符常量必须使用单引号来进行表示。字符常量是使用单引号括起来的一个字符，不能是多个字符。例如，下面都是合法的字符常量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;'a'、&lt;span class=&quot;hljs-string&quot;&gt;'B'、&lt;span class=&quot;hljs-string&quot;&gt;'#'、&lt;span class=&quot;hljs-string&quot;&gt;'8'&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要强调的是只能是单引号，并且只有一个字符，字符可以是ASCII码中的任意字符。如果数字被定义成字符常量的话，就不能代表数字字面的量了。如果参与运算，它的值将会是对应的ASCII码。比如上面的字符常量'8'，在ASCII码对应的值为56。这个时候参与运算，比如加上1，将得到的整数值是57。&lt;/p&gt;
&lt;h3 id=&quot;h2-2&quot;&gt;&lt;span&gt;2）符号常量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在C语言程序中，还可以使用一个符号常量来代替常量。使用符号常量有两个好处，一个是如果需要修改常量的话，只要修改定义符号常量的语句就行；另一个好处，使得程序中常量的含义更加清楚。定义符号常量有两种方法：#define宏定义和const语句定义。在这里我就先不展开讲了，大家过一眼就好了，后面的教程会详细的讲解宏定义和const的应用。&lt;/p&gt;

&lt;p&gt;在程序中，我们会使用到各种变量。当我们创建一个变量时，就会在内存中开辟一些空间。一般变量先声明，然后初始化。&lt;/p&gt;
&lt;h3 id=&quot;h1-3&quot;&gt;&lt;span&gt;1）声明变量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;C语言中使用声明语句，来声明一个变量，指出存储类型并提供位置标签。C语言中，变量要求先声明后定义，这样做的好处在于：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;1.确保后面引用的变量名和声明的一致，减少了输入错误。如声明了变量teemo，在后面引用时，不小心输成了timo，编译器将会报错，指示timo未声明。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;2.在声明变量时，会指定变量的类型，当进行运算的时候，编译器就可以检查运算是否合法。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;3.编译器根据指定变量的类型分配内存。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;声明变量的一般语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;类型 变量名;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，类型是数据类型的关键字，比如说int表示整数类型、double表示双精度浮点类型。变量名则需要符合命名规范的标识符。下面我们将会通过简单的程序，来介绍如何声明变量。比如说：我们要声明一个变量表示提莫的血量。在C语言中，就可以表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int teemoHp;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;float teemoAttack;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;int 是一种数据类型，表示是整数。&lt;br/&gt;teemoHp 是一个标识符，这里代表整数类型的血量。&lt;br/&gt;; 表示一个语句结束。&lt;/p&gt;
&lt;p&gt;我们从计算机的角度来讲，第一条语句指出程序需要一个存储空间，用这个内存来存储一个整数。那么在C语言中，写上这个声明语句，程序就会将计算机的某一区域内存，命名为teemoHp，并在这个内存中存放整数类型。teemoHp这个标识符就是一个变量，它代表teemo的血量。这条语句创造了一个变量teemoHp，我们把这个过程叫做变量声明。&lt;/p&gt;
&lt;p&gt;同类型的变量还可以在一个语句中同时声明多个变量，各变量之间用逗号分隔开，例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int teemoHp, garenHp;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面语句声明了两个整数类型的变量，等同于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int teemoHp;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int garenHp;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h2-3&quot;&gt;&lt;span&gt;2）变量初始化&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在对变量声明时，编译器会给变量分配内存，但分配的这个内存并不会被清空。这个就和你删除电脑中的文件一样，虽然你点了删除这些文件，但实际上这些文件还会存在，只是我们看不到了。只有当你再次存储文件覆盖这些文件时，这些文件才算是删除了。这也是一些删除的文件，也可以通过某些手段来恢复的重要原因。那么就可能出现编译器给我们分配的内存，已经有存储值的情况，而且这个值对我们来说还是不确定的。为了防止程序因为不确定的值而出现不可预料的情况，我们在使用变量的时候就要对其进行赋初值，使得变量的值是确定的，这种方法就是初始化。&lt;/p&gt;
&lt;p&gt;下面再来看一个简单的实例，我们要把提莫的血量作为一个变量，提莫的血量值是586。在C语言中，就可以表示成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;int teemoHp;&lt;br/&gt;teemoHp = 586;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先声明了一个变量teemoHp，然后将常量586保存到变量teemoHp中。第二个语句中，“=”也叫赋值操作符，这个过程叫做赋值。赋值是指数据放到内存的过程，我们把这个过程叫做变量的赋值；又因为是第一次赋值，也称变量的初始化。&lt;/p&gt;
&lt;p&gt;在声明变量的同时可以直接对其进行赋值，上面的两个语句，又可以直接表示成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int teemoHp = &lt;span class=&quot;hljs-number&quot;&gt;586;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果多个变量具有相同的值，还可以进行连续的赋值。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;int teemoHp, garenHp;&lt;br/&gt;teemoHp = garenHp = 586;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但不可以在声明的时候对其进行连续赋值。像下面语句一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int teemoHp = garenHp = &lt;span class=&quot;hljs-number&quot;&gt;586;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样写会导致标识符garenHp没有声明，所以编译器报错。&lt;/p&gt;
&lt;p&gt;如果要在一个语句中这样做，我们应该写成下面语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int teemoHp = &lt;span class=&quot;hljs-number&quot;&gt;586, garenHp = &lt;span class=&quot;hljs-number&quot;&gt;586;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;int teemoHp, garenHp = 586;&lt;br/&gt;teemoHp = 586;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道，在实际中，提莫通过等级的提升以及出的装备，血量的值会不断变化，那我们应该怎么办呢？答案是，血量的值是一个变量，我们可以通过再次赋值改变血量的值，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;int teemoHp = 586;&lt;br/&gt;teemoHp = 1000;&lt;br/&gt;teemoHp = 5000;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次的赋值，会把第一次的数据覆盖掉。也就是说，teemoHp中最后的值是5000（这怕不是一个肉提莫），这也是因为586、1000已经被覆盖掉了。&lt;/p&gt;

&lt;p&gt;总结一下，本节内容主要介绍了C语言程序的常量和变量。介绍了常量和变量的概念以及命名规范，然后讲解了它们的一些基本使用方法。&lt;/p&gt;

&lt;p&gt;4-1 对下面进行判断，哪些是合法标识符，哪些又不是合法标识？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;su8&lt;br/&gt;_&lt;span class=&quot;hljs-selector-tag&quot;&gt;total&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Class&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Student_name&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;louts_1_2_3&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;BASIC&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;M&lt;span class=&quot;hljs-selector-class&quot;&gt;.D&lt;span class=&quot;hljs-selector-class&quot;&gt;.John&lt;br/&gt;\&lt;span class=&quot;hljs-selector-id&quot;&gt;#123&lt;br/&gt;3&lt;span class=&quot;hljs-selector-tag&quot;&gt;D45&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;a&amp;gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4-2 编写一个程序，对盖伦的属性值，找到合适的类型来定义并且为其赋值。&lt;br/&gt;名字：简称为G&lt;br/&gt;生命值：455&lt;br/&gt;移动速度：340&lt;br/&gt;攻击速度：0.625&lt;br/&gt;攻击范围：125&lt;br/&gt;生命回复：8.25&lt;br/&gt;攻击力：59.5&lt;/p&gt;
&lt;p&gt;可以在评论中，写下你们的练习答案。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;之后的文章会给大家带来更精彩的内容&lt;br/&gt;欢迎关注我的知乎专栏：程序员基础知识&lt;br/&gt;获取练习答案以及更多实战项目&lt;br/&gt;欢迎关注我的公众号：程序员基础知识&lt;br/&gt;交(gao)流(ji)群：493584686&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Fri, 28 Dec 2018 15:35:00 +0000</pubDate>
<dc:creator>程序员基础知识</dc:creator>
<og:description>本节内容主要介绍了C语言程序的常量和变量。介绍了常量和变量的概念以及命名规范，然后讲解了它们的一些基本使用方法。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cxyjczs/p/10193398.html</dc:identifier>
</item>
<item>
<title>python属性管理(1)：基础 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10193396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10193396.html</guid>
<description>&lt;h2 id=&quot;管理属性的几种方式&quot;&gt;管理属性的几种方式&lt;/h2&gt;
&lt;p&gt;在python中访问、设置、删除对象属性的时候，有以下几种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用内置函数getattr()、setattr()和delattr()&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;自己编写&lt;code&gt;getter()&lt;/code&gt;、&lt;code&gt;setter()&lt;/code&gt;、&lt;code&gt;deleter()&lt;/code&gt;方法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;重载&lt;code&gt;__getattr__()&lt;/code&gt;、&lt;code&gt;__setattr__()&lt;/code&gt;、&lt;code&gt;__delattr__()&lt;/code&gt;运算符，这决定了&lt;code&gt;x.y&lt;/code&gt;的访问、赋值方式以及&lt;code&gt;del x.y&lt;/code&gt;的方式&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;__getattribute__()&lt;/code&gt;方法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用描述符协议&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用property协议，它是一种特殊的描述符&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文简单介绍其中的前4种作为基础，后面使用单独的文章解释后2种。&lt;/p&gt;
&lt;h2 id=&quot;内置函数xxxattr管理属性&quot;&gt;内置函数XXXattr()管理属性&lt;/h2&gt;
&lt;p&gt;通过内置函数getattr()、setattr()、delattr()能简单访问、设置、删除对象上的属性。&lt;/p&gt;
&lt;p&gt;先看看它们的帮助文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getattr(...)
    getattr(object, name[, default]) -&amp;gt; value
    Get a named attribute from an object;
    getattr(x, 'y') is equivalent to x.y.

setattr(obj, name, value, /)
    Sets the named attribute on the given object to the specified value.
    setattr(x, 'y', v) is equivalent to ``x.y = v''

delattr(obj, name, /)
    Deletes the named attribute from the given object.
    delattr(x, 'y') is equivalent to ``del x.y''&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用法很简单，给定要操作的对象obj以及要操作的属性名称name。对于getattr()来说，如果要操作的属性不存在默认会报错，可以给定一个default参数表示属性不存在时返回该给定属性值。&lt;/p&gt;
&lt;p&gt;例如，下面是一个简单的Person类和对象p：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person():
    def __init__(self, name):
        self.name = name

p = Person(&quot;malongshuai&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用getattr()获取name属性和不存在的age属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(getattr(p, &quot;name&quot;))
print(getattr(p, &quot;age&quot;, 23))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面访问age属性时，如果把第三个参数&quot;23&quot;去掉，将抛出异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AttributeError: 'Person' object has no attribute 'age'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用setattr()和delattr()设置和删除属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setattr(p, &quot;age&quot;, 25)
print(p.__dict__)

delattr(p, &quot;age&quot;)
print(p.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{'name': 'malongshuai', 'age': 25}
{'name': 'malongshuai'}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自己编写accessor方法&quot;&gt;自己编写accessor方法&lt;/h2&gt;
&lt;p&gt;一般面向对象的语言都是自己写setter、getter、deleter方法来管理属性的，通用又安全，但是管理起来并不那么方便。&lt;/p&gt;
&lt;p&gt;这里仅介绍一下，它们更好的写法参考：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/10091181.html&quot;&gt;python设置对象属性&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;例如，在Person类中加上name、age这两个属性的accessor方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person():
    def __init__(self, name):
        self.name = name

    def set_name(self,name): self.name = name
    def get_name(self): return self.name
    def del_name(self): del self.name

    def set_age(self,age): self.age = age
    def get_age(self): return self.age
    def del_age(self): del self.age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缺点是很明显的，对于想要管理的每个属性，都得去定义这些属性。也就是说，accessor方法是针对单个属性的。&lt;/p&gt;
&lt;h2 id=&quot;运算符重载管理属性&quot;&gt;运算符重载管理属性&lt;/h2&gt;
&lt;p&gt;通常可以直接使用点号运算来访问、设置属性。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p.name          # (1)访问p对象的name属性
p.name = &quot;abc&quot;  # (2)为p对象的name属性赋值
del p.name      # (3)删除p对象的name属性&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先说对象的赋值和删除操作，也就是上面的(2)和(3)。这两种操作可以直接被&lt;code&gt;__setattr__()&lt;/code&gt;、&lt;code&gt;__delattr__()&lt;/code&gt;这两个方法拦截，或者说只要重写了这两个方法，每当对属性赋值、删除时，都会调用对应的这两个方法。&lt;/p&gt;
&lt;p&gt;再说访问属性的操作(1)，python提供了两个对应的方法&lt;code&gt;__getattr__()&lt;/code&gt;和&lt;code&gt;__getattribute__()&lt;/code&gt;。前者是在&lt;strong&gt;访问不存在的属性&lt;/strong&gt;时被自动调用的，&lt;strong&gt;后者则是访问属性时被调用的，它无视属性是否存在&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里提前说一个稍后要遇到的问题总结：对于适用于所有属性操作的&lt;code&gt;__setattr__&lt;/code&gt;、&lt;code&gt;__delattr__&lt;/code&gt;和&lt;code&gt;__getattribute__&lt;/code&gt;方法，要避免它们的无限递归。参考后面的示例即可知。&lt;/p&gt;
&lt;h3 id=&quot;getattr__&quot;&gt;__getattr__()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;__getattr__()&lt;/code&gt;是通过点号访问不存在属性时被调用的。它有两个使用标准：要么返回属性值，要么抛出异常。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person():
    def __init__(self, name):
        self.name = name

    def __getattr__(self, attrname):
        if attrname == &quot;name&quot;:
            print(&quot;in getattr1&quot;)
            return self.name
        elif attrname == &quot;age&quot;:
            print(&quot;in getattr2&quot;)
            return 25
        else:
            print(&quot;in getattr3&quot;)
            raise AttributeError(attrname)

p = Person(&quot;malongshuai&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的Person类带有属性name，所以访问name属性的时候不会调用&lt;code&gt;__getattr__()&lt;/code&gt;，而访问age或其它属性时会调用该方法，只不过age属性有自定义的返回值，其它属性则报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(p.name)
print(p.age)
print(p.job)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;malongshuai
in getattr2
25
in getattr3
Traceback (most recent call last):
  File &quot;g:/pycode/b.py&quot;, line 21, in &amp;lt;module&amp;gt;
    print(p.job)
  File &quot;g:/pycode/b.py&quot;, line 14, in __getattr__
    raise AttributeError(attrname)
AttributeError: job&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;getattribute__&quot;&gt;__getattribute__()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;和&lt;code&gt;__getattr__()&lt;/code&gt;类似，不同的是它前者适用于所有属性的访问，而不管目标属性是否存在。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;__getattribute__()&lt;/code&gt;适用于所有属性访问操作，所以要避免无限递归。例如，下面是错误的写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def __getattribute__(self, attr):
    return self.attr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为这个方法中的&lt;code&gt;self.attr&lt;/code&gt;会继续触发&lt;code&gt;__getattribute__&lt;/code&gt;的调用，从而出现无限递归问题。&lt;/p&gt;
&lt;p&gt;解决办法是通过父类来访问，比如super()或object类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;super().__getattribute__(attr)
object.__getattribute__(self, attr)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;的优先级高于&lt;code&gt;__getattr__()&lt;/code&gt;，前者存在的时候不会调用到后者，除非前者的代码中调用了后者，或者前者抛出了异常。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person():
    def __init__(self, name):
        self.name = name

    def __getattribute__(self, attr):
        print(&quot;in getattribute&quot;)
        return object.__getattribute__(self, attr)
        # return super.__getattribute__(attr)

    def __getattr__(self, attrname):
        if attrname == &quot;name&quot;:
            print(&quot;in getattr1&quot;)
            return self.name
        elif attrname == &quot;age&quot;:
            print(&quot;in getattr2&quot;)
            return 25
        else:
            print(&quot;in getattr3&quot;)
            raise AttributeError(attrname)


p = Person(&quot;malongshuai&quot;)

print(p.name)
print(p.age)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;in getattribute
malongshuai
in getattribute
in getattr2
25&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面输出了name和age两个属性，但是输出&quot;p.age&quot;的时候该属性不存在，于是&lt;code&gt;__getattribute__&lt;/code&gt;抛出异常，然后触发&lt;code&gt;__getattr__&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的是，在解决无限递归问题上，后面的&lt;code&gt;__setattr__&lt;/code&gt;和&lt;code&gt;__delattr__&lt;/code&gt;还会有一种访问&lt;code&gt;__dict__&lt;/code&gt;的方式，这不适合于这里的&lt;code&gt;__getattribute__&lt;/code&gt;，因为访问这个字典也会触发&lt;code&gt;__getattribute__&lt;/code&gt;从而继续导致无限递归。&lt;/p&gt;
&lt;h3 id=&quot;setattr__&quot;&gt;__setattr__()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;__setattr__()&lt;/code&gt;用来拦截对象属性赋值操作。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p.name = &quot;long&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会转换为调用&lt;code&gt;p.__setattr__(self,name,&quot;long&quot;)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;唯一需要注意的是避免赋值时的无限递归问题&lt;/strong&gt;。因为在&lt;code&gt;__setattr__()&lt;/code&gt;中的赋值语句&lt;code&gt;self.attr = value&lt;/code&gt;会继续调用该方法，最终导致无限递归。&lt;/p&gt;
&lt;p&gt;所以在&lt;code&gt;__setattr__()&lt;/code&gt;方法中，必须使用&lt;code&gt;__dict__&lt;/code&gt;来获取属性并进行赋值，或者访问父类同名属性。所以，有下面几种方式避免无限递归调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;self.__dict__[attr] = value
super().__setattr__(attr, value)
object.__setattr__(self, attr, value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考下面的示例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person():
    def __init__(self, name):
        self.name = name

    def __setattr__(self, attr, value):
        print(&quot;in setattr&quot;)
        #self.__dict__[attr] = value
        #super().__setattr__(attr, value)
        object.__setattr__(self, attr, value)

p = Person(&quot;malongshuai&quot;)

p.age = 33      # 自动调用__setattr__()
print(p.age)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;in setattr
in setattr
33&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能已经发现问题所在了，上面输出了两次&lt;code&gt;in setter&lt;/code&gt;，原因是&lt;code&gt;__init__()&lt;/code&gt;中的赋值操作也会触发&lt;code&gt;__setattr__()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;delattr__&quot;&gt;__delattr__()&lt;/h3&gt;
&lt;p&gt;当调用&lt;code&gt;del x.y&lt;/code&gt;的时候会自动触发&lt;code&gt;__delattr__()&lt;/code&gt;的调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同样需要注意的是避免赋值时的无限递归问题&lt;/strong&gt;。因为在&lt;code&gt;__delattr__()&lt;/code&gt;中的del语句可能会继续调用该方法，最终导致无限递归。所以在&lt;code&gt;__delattr__()&lt;/code&gt;方法中，必须使用&lt;code&gt;__dict__&lt;/code&gt;来获取属性并进行赋值，或者访问父类同名属性。所以，有下面几种方式避免无限递归调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;del self.__dict__[attr]
super().__delattr__(attr)
object.__delattr__(self, attr)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person():
    def __init__(self, name):
        self.name = name

    def __delattr__(self, attr):
        print(&quot;%s deleting&quot; % (attr))

        #del self.__dict__[attr]
        #super().__delattr__(attr)
        object.__delattr__(self, attr)

        print(&quot;%s deleted&quot; % (attr))


p = Person(&quot;malongshuai&quot;)
p.age = 33
del p.age&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 28 Dec 2018 15:33:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>管理属性的几种方式 在python中访问、设置、删除对象属性的时候，有以下几种方式： 1. 使用内置函数getattr()、setattr()和delattr() 2. 自己编写 、`setter()</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10193396.html</dc:identifier>
</item>
<item>
<title>深夜你痛苦过吗？ - 我的博客我的人生</title>
<link>http://www.cnblogs.com/JunLoveHua/p/10193367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JunLoveHua/p/10193367.html</guid>
<description>&lt;p&gt;昨天晚上在家葛优躺的时候，突然微信上连收了好几条消息，打开一看：“大纯，我好绝望！我24岁了，毕业一年了，连一件1000块的大衣都买不起。”&lt;/p&gt;
&lt;p&gt;收到这条消息的时候，我看着手上端着的五块钱一桶的泡面，瞬间也挺绝望的。&lt;/p&gt;
&lt;p&gt;给我发消息的是我的一个小学弟，叫浩子。去过初创公司，也换过不同类型的工作，一年过去了，用浩子的话说：“除了大一岁我也不知道自己增长了什么？”&lt;/p&gt;
&lt;p&gt;毕业的这一年，貌似每个人都被迷茫无助笼罩的，我问了几个身边几个毕业生，他们的一年的状态：&lt;/p&gt;
&lt;p&gt;“我每天都很困，是因为我被生活所困”；&lt;/p&gt;
&lt;p&gt;”我和女朋友的争吵，一切都是从没钱开始。“&lt;/p&gt;
&lt;p&gt;“小时候，老骗爸妈没钱，长大后老骗爸妈有钱，感觉生活，除了买不起房，买不起车，穷了点，其他也挺好的。”&lt;/p&gt;
&lt;p&gt;聊完发现尽管大家生活迥异，但在相似的年龄总是匹配着相似的烦恼和期待：被生活扼住喉咙，被工作压榨自我，被年龄渐长却一无所成的焦虑笼罩……&lt;/p&gt;
&lt;p&gt;十几岁为学业烦恼，少考了几分都感觉世界灰暗起来了，&lt;/p&gt;
&lt;p&gt;25岁，因为没有存款，因为没有爱人，顿觉手足无措，慌乱不已。&lt;/p&gt;
&lt;p&gt;30岁开始兼顾家庭，40岁上有老下有小，50岁孩子离家，生活仍不轻松，仍没有活成自己想要的样子……&lt;/p&gt;
&lt;p&gt;其实仔细想想，似乎人生的每个阶段都不会轻松。&lt;/p&gt;
&lt;p&gt;因为人生真的太苦。你总会长夜哭一次，无非有的人早一点，有的人晚一点。&lt;/p&gt;
&lt;p&gt;总有一个时刻，我们会失去很重要的东西。我们会后知后觉，明白一切已不可追回。我们发现自己如此糟糕，无比愧疚……&lt;/p&gt;
&lt;p&gt;你深夜痛哭过吗？&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 15:20:00 +0000</pubDate>
<dc:creator>我的博客我的人生</dc:creator>
<og:description>昨天晚上在家葛优躺的时候，突然微信上连收了好几条消息，打开一看：“大纯，我好绝望！我24岁了，毕业一年了，连一件1000块的大衣都买不起。” 收到这条消息的时候，我看着手上端着的五块钱一桶的泡面，瞬间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JunLoveHua/p/10193367.html</dc:identifier>
</item>
<item>
<title>Spring Boot 之日志记录 - 静默虚空</title>
<link>http://www.cnblogs.com/jingmoxukong/p/10193303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingmoxukong/p/10193303.html</guid>
<description>&lt;blockquote readability=&quot;9.8936170212766&quot;&gt;
&lt;p&gt;Spring Boot 支持集成 Java 世界主流的日志库。&lt;/p&gt;
&lt;p&gt;如果对于 Java 日志库不熟悉，可以参考：&lt;a href=&quot;https://github.com/dunwu/notes/blob/master/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/javastack/javalib/java-log.md&quot;&gt;细说 Java 主流日志工具库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关键词： &lt;code&gt;log4j&lt;/code&gt;, &lt;code&gt;log4j2&lt;/code&gt;, &lt;code&gt;logback&lt;/code&gt;, &lt;code&gt;slf4j&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring Boot 内部日志全部使用 &lt;a href=&quot;https://commons.apache.org/logging&quot;&gt;Commons Logging&lt;/a&gt; 记录，但保留底层日志实现。为 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api//java/util/logging/package-summary.html&quot;&gt;Java Util Logging&lt;/a&gt;，&lt;a href=&quot;https://logging.apache.org/log4j/2.x/&quot;&gt;Log4J2&lt;/a&gt;，和 &lt;a href=&quot;http://logback.qos.ch/&quot;&gt;Logback&lt;/a&gt; 提供了默认配置。在每种情况下，记录器都预先配置为使用控制台输出，并且还提供可选的文件输出。&lt;/p&gt;
&lt;p&gt;默认情况下，如果使用“Starters”，则使用 Logback 进行日志记录。还包括适当的 Logback 路由，以确保使用 Java Util Logging，Commons Logging，Log4J 或 SLF4J 的依赖库都能正常工作。&lt;/p&gt;
&lt;h2 id=&quot;日志格式&quot;&gt;日志格式&lt;/h2&gt;
&lt;p&gt;Spring Boot 日志默认格式类似下面的形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日期和时间：精确到微秒&lt;/li&gt;
&lt;li&gt;日志级别：&lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;WARN&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;DEBUG&lt;/code&gt;, or &lt;code&gt;TRACE&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;进程 ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;---&lt;/code&gt; 分隔符后面是实际的日志内容&lt;/li&gt;
&lt;li&gt;线程名&lt;/li&gt;
&lt;li&gt;日志名&lt;/li&gt;
&lt;li&gt;日志内容&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;控制台输出&quot;&gt;控制台输出&lt;/h2&gt;
&lt;p&gt;Spring Boot 默认打印信息到控制台，并且仅打印&lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;WARN&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt; 级别信息。&lt;/p&gt;
&lt;p&gt;如果你想打印 debug 级别信息，可以设置 jar 启动参数，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ java -jar myapp.jar --debug&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，也可以在 &lt;code&gt;application.properties&lt;/code&gt; 中设置 &lt;code&gt;debug = true&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;打印 &lt;code&gt;trace&lt;/code&gt; 级别信息同上所示。&lt;/p&gt;
&lt;h3 id=&quot;彩色打印&quot;&gt;彩色打印&lt;/h3&gt;
&lt;p&gt;如果您的终端支持 ANSI，可以使用彩色打印来提高可读性。您可以将 spring.output.ansi.enabled 设置为支持的值以覆盖自动检测。&lt;br/&gt;使用 ％clr 转换字配置颜色编码。在最简单的形式中，转换器根据日志级别对输出进行着色，如以下示例所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%clr(%5p)
%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;支持以下的颜色和样式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;blue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cyan&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;faint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;green&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;magenta&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;red&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yellow&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;文件输出&quot;&gt;文件输出&lt;/h2&gt;
&lt;p&gt;默认情况下，Spring Boot 仅记录到控制台，不会写入日志文件。如果除了控制台输出之外还要编写日志文件，则需要设置 &lt;code&gt;logging.file&lt;/code&gt; 或 &lt;code&gt;logging.path&lt;/code&gt; 属性（例如，在 application.properties 中）。&lt;/p&gt;
&lt;p&gt;详细配置参考：&lt;a href=&quot;http://www.cnblogs.com/jingmoxukong/p/10193303.html#配置&quot;&gt;配置&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;日志级别&quot;&gt;日志级别&lt;/h2&gt;
&lt;p&gt;所有支持的日志系统都可以 在 Spring 环境中通过 &lt;code&gt;logging.level.&amp;lt;logger-name&amp;gt;=&amp;lt;level&amp;gt;&lt;/code&gt; 属性设置日志级别（例如，在 &lt;code&gt;application.properties&lt;/code&gt; 中）。其中 level 是 &lt;code&gt;TRACE&lt;/code&gt;、&lt;code&gt;DEBUG&lt;/code&gt;、&lt;code&gt;INFO&lt;/code&gt;、&lt;code&gt;WARN&lt;/code&gt; 、&lt;code&gt;ERROR&lt;/code&gt;、&lt;code&gt;FATAL&lt;/code&gt; 或 &lt;code&gt;OFF&lt;/code&gt;。可以使用 logging.level.root 配置根记录器。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;logging.level.root=WARN
logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate=ERROR&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;日志组&quot;&gt;日志组&lt;/h2&gt;
&lt;p&gt;能够将相关记录器组合在一起以便可以同时配置它们通常很有用。例如，您可以更改所有 Tomcat 相关记录器的日志记录级别，但您无法轻松记住顶级软件包。&lt;/p&gt;
&lt;p&gt;Spring Boot 通过 logging.group 属性来提供这样的支持。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat
logging.level.tomcat=TRACE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是 Spring Boot 预设的日志组：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;web&lt;/td&gt;
&lt;td&gt;&lt;code&gt;org.springframework.core.codec&lt;/code&gt;, &lt;code&gt;org.springframework.http&lt;/code&gt;, &lt;code&gt;org.springframework.web&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;sql&lt;/td&gt;
&lt;td&gt;&lt;code&gt;org.springframework.jdbc.core&lt;/code&gt;, &lt;code&gt;org.hibernate.SQL&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;日志配置文件&quot;&gt;日志配置文件&lt;/h2&gt;
&lt;p&gt;可以通过在 classpath 中包含适当的库来激活各种日志记录系统，并且可以通过在 classpath 的根目录中或在以下 Spring &lt;code&gt;Environment&lt;/code&gt; 属性指定的位置提供合适的配置文件来进一步自定义：&lt;code&gt;logging.config&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;您可以使用 &lt;code&gt;org.springframework.boot.logging.LoggingSystem&lt;/code&gt; 系统属性强制 Spring Boot 使用特定的日志记录系统。该值应该是 &lt;code&gt;LoggingSystem&lt;/code&gt; 实现的完全限定类名。您还可以使用 &lt;code&gt;none&lt;/code&gt; 值完全禁用 Spring Boot 的日志记录配置。&lt;/p&gt;
&lt;p&gt;由于在创建 &lt;code&gt;ApplicationContext&lt;/code&gt; 之前初始化日志记录，因此无法在 Spring &lt;code&gt;@Configuration&lt;/code&gt; 文件中控制来自 &lt;code&gt;@PropertySources&lt;/code&gt; 的日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。&lt;/p&gt;
&lt;h2 id=&quot;logback-扩展&quot;&gt;Logback 扩展&lt;/h2&gt;
&lt;h3 id=&quot;profile-指定配置&quot;&gt;profile 指定配置&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;code&gt;&amp;lt;springProfile&amp;gt;&lt;/code&gt; 指定特定的 profile 下的配置，如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;springProfile name=&quot;staging&quot;&amp;gt;
    &amp;lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&amp;gt;
&amp;lt;/springProfile&amp;gt;

&amp;lt;springProfile name=&quot;dev | staging&quot;&amp;gt;
    &amp;lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&amp;gt;
&amp;lt;/springProfile&amp;gt;

&amp;lt;springProfile name=&quot;!production&quot;&amp;gt;
    &amp;lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&amp;gt;
&amp;lt;/springProfile&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;环境属性&quot;&gt;环境属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;springProperty&amp;gt;&lt;/code&gt; 标签允许指定从 &lt;code&gt;Environment&lt;/code&gt; 中获取的属性，并在配置文件中引用。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;springProperty scope=&quot;context&quot; name=&quot;fluentHost&quot; source=&quot;myapp.fluentd.host&quot;
        defaultValue=&quot;localhost&quot;/&amp;gt;
&amp;lt;appender name=&quot;FLUENT&quot; class=&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;&amp;gt;
    &amp;lt;remoteHost&amp;gt;${fluentHost}&amp;lt;/remoteHost&amp;gt;
    ...
&amp;lt;/appender&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-boot-中的日志配置&quot;&gt;Spring Boot 中的日志配置&lt;/h2&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;logging.config= # Location of the logging configuration file. For instance, `classpath:logback.xml` for Logback.
logging.exception-conversion-word=%wEx # Conversion word used when logging exceptions.
logging.file= # Log file name (for instance, `myapp.log`). Names can be an exact location or relative to the current directory.
logging.file.max-history=0 # Maximum of archive log files to keep. Only supported with the default logback setup.
logging.file.max-size=10MB # Maximum log file size. Only supported with the default logback setup.
logging.group.*= # Log groups to quickly change multiple loggers at the same time. For instance, `logging.level.db=org.hibernate,org.springframework.jdbc`.
logging.level.*= # Log levels severity mapping. For instance, `logging.level.org.springframework=DEBUG`.
logging.path= # Location of the log file. For instance, `/var/log`.
logging.pattern.console= # Appender pattern for output to the console. Supported only with the default Logback setup.
logging.pattern.dateformat=yyyy-MM-dd HH:mm:ss.SSS # Appender pattern for log date format. Supported only with the default Logback setup.
logging.pattern.file= # Appender pattern for output to a file. Supported only with the default Logback setup.
logging.pattern.level=%5p # Appender pattern for log level. Supported only with the default Logback setup.
logging.register-shutdown-hook=false # Register a shutdown hook for the logging system when it is initialized.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日志配置属性在应用程序生命周期的早期初始化。因此，通过 &lt;code&gt;@PropertySource&lt;/code&gt; 注释加载的属性文件中找不到日志记录属性。&lt;/li&gt;
&lt;li&gt;日志配置属性独立于实际的日志记录基础结构。因此，spring Boot 不管理特定的配置密钥（例如 Logback 的 logback.configurationFile）。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;完整示例：&lt;a href=&quot;https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/log&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分别展示如何在 Spring Boot 中使用 &lt;code&gt;log4j&lt;/code&gt;, &lt;code&gt;log4j2&lt;/code&gt;, &lt;code&gt;logback&lt;/code&gt; 记录日志。&lt;/p&gt;
&lt;h2 id=&quot;引申和引用&quot;&gt;引申和引用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;引申&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 14:57:00 +0000</pubDate>
<dc:creator>静默虚空</dc:creator>
<og:description>Spring Boot 之日志记录 Spring Boot 支持集成 Java 世界主流的日志库。 如果对于 Java 日志库不熟悉，可以参考：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingmoxukong/p/10193303.html</dc:identifier>
</item>
<item>
<title>springBoot(13)---整合Druid实现多数据源和可视化监控 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10192041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10192041.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;先献上&lt;code&gt;github&lt;/code&gt;代码地址:&lt;a href=&quot;https://github.com/yudiandemingzi/springboot-manydatasource&quot; class=&quot;uri&quot;&gt;https://github.com/yudiandemingzi/springboot-manydatasource&lt;/a&gt;&lt;br/&gt;代码拉下来换下自己的mysql数据库地址,就可以直接运行。Druid的优点很明显,它的可视化界面可以监控Sql语句和URI执行情况在开发中真的很需要。&lt;br/&gt;先说优点吧:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    1) 替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。
    2) 数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。
    3) 可以监控数据库访问性能，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。
    4) SQL执行日志，Druid提供了不同的LogFilter，监控你应用的数据库   访问情况。
    5）扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter-Chain机制，很方便编写JDBC层的扩展插件。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二配置多数据源&quot;&gt;&lt;span&gt;二、配置多数据源&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;pom.xml&quot;&gt;&lt;span&gt;1、pom.xml&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;只需要添加druid这一个jar就行了,有关springboot项目他还有个整合包,用那个整合包也一样。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;       &amp;lt;!-- Druid 数据连接池依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1.8&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1.6&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于springboot项目来讲,上面任选一个都是可以的,亲测有效。&lt;/p&gt;
&lt;h4 id=&quot;application.yml&quot;&gt;&lt;span&gt;2、application.yml&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我这里是采用application.yml进行添加配置,这里面配置了两个数据源,其实在application.yml也可以不配置这些东西,它的主要作用是给数据源配置类读取数据用的。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    initialSize: 10
    minIdle: 10
    maxActive: 200
    # 配置获取连接等待超时的时间
    maxWait: 60000
    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
    timeBetweenEvictionRunsMillis: 60000
    # 配置一个连接在池中最小生存的时间，单位是毫秒
    minEvictableIdleTimeMillis: 30000
    validationQuery: select 'x'
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    # 打开PSCache，并且指定每个连接上PSCache的大小
    poolPreparedStatements: true
    maxPoolPreparedStatementPerConnectionSize: 20
    # 配置监控统计拦截的filters
    filters: stat,wall,slf4j
    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000


#配置了两个数据源
master:
  datasource:
    url: jdbc:mysql://localhost:3306/user?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;allowMultiQueries=true
    username: root
    password: root
    driverClassName: com.mysql.jdbc.Driver

cluster:
  datasource:
    url: jdbc:mysql://localhost:3306/student?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;allowMultiQueries=true
    username: root
    password: root
    driverClassName: com.mysql.jdbc.Driver&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;主数据源配置类masterdatasourceconfig&quot;&gt;&lt;span&gt;3、主数据源配置类(MasterDataSourceConfig)&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 主数据源配置
 */
@Configuration
@MapperScan(basePackages = MasterDataSourceConfig.PACKAGE, sqlSessionFactoryRef = &quot;masterSqlSessionFactory&quot;)
public class MasterDataSourceConfig {

    /**
     * 配置多数据源 关键就在这里 这里配置了不同的数据源扫描不同mapper
     */
    static final String PACKAGE = &quot;com.binron.multidatasource.mapper.master&quot;;
    static final String MAPPER_LOCATION = &quot;classpath:mapper/master/*.xml&quot;;

    /**
     * 连接数据库信息 这个其实更好的是用配置中心完成
     */
    @Value(&quot;${master.datasource.url}&quot;)
    private String url;  
      
    @Value(&quot;${master.datasource.username}&quot;)
    private String username;  
      
    @Value(&quot;${master.datasource.password}&quot;)
    private String password;  
      
    @Value(&quot;${master.datasource.driverClassName}&quot;)
    private String driverClassName;


    /**
     * 下面的配置信息可以读取配置文件，其实可以直接写死 如果是多数据源的话 还是考虑读取配置文件
     */
    @Value(&quot;${spring.datasource.initialSize}&quot;)
    private int initialSize;  
      
    @Value(&quot;${spring.datasource.minIdle}&quot;)
    private int minIdle;  
      
    @Value(&quot;${spring.datasource.maxActive}&quot;)
    private int maxActive;  
      
    @Value(&quot;${spring.datasource.maxWait}&quot;)
    private int maxWait;  
      
    @Value(&quot;${spring.datasource.timeBetweenEvictionRunsMillis}&quot;)
    private int timeBetweenEvictionRunsMillis;  
      
    @Value(&quot;${spring.datasource.minEvictableIdleTimeMillis}&quot;)
    private int minEvictableIdleTimeMillis;  
      
    @Value(&quot;${spring.datasource.validationQuery}&quot;)
    private String validationQuery;  
      
    @Value(&quot;${spring.datasource.testWhileIdle}&quot;)
    private boolean testWhileIdle;  
      
    @Value(&quot;${spring.datasource.testOnBorrow}&quot;)
    private boolean testOnBorrow;  
      
    @Value(&quot;${spring.datasource.testOnReturn}&quot;)
    private boolean testOnReturn;  
      
    @Value(&quot;${spring.datasource.poolPreparedStatements}&quot;)
    private boolean poolPreparedStatements;  
      
    @Value(&quot;${spring.datasource.maxPoolPreparedStatementPerConnectionSize}&quot;)
    private int maxPoolPreparedStatementPerConnectionSize;  
      
    @Value(&quot;${spring.datasource.filters}&quot;)
    private String filters;
      
    @Value(&quot;{spring.datasource.connectionProperties}&quot;)
    private String connectionProperties;  
    
    
    @Bean(name = &quot;masterDataSource&quot;)
    @Primary //标志这个 Bean 如果在多个同类 Bean 候选时，该 Bean 优先被考虑。
    public DataSource masterDataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(url);  
        dataSource.setUsername(username);  
        dataSource.setPassword(password);  
        dataSource.setDriverClassName(driverClassName);  
          
        //具体配置 
        dataSource.setInitialSize(initialSize);  
        dataSource.setMinIdle(minIdle);  
        dataSource.setMaxActive(maxActive);  
        dataSource.setMaxWait(maxWait);  
        dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);  
        dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);  
        dataSource.setValidationQuery(validationQuery);  
        dataSource.setTestWhileIdle(testWhileIdle);  
        dataSource.setTestOnBorrow(testOnBorrow);  
        dataSource.setTestOnReturn(testOnReturn);  
        dataSource.setPoolPreparedStatements(poolPreparedStatements);  
        dataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);

        /**
         * 这个是用来配置 druid 监控sql语句的 非常有用 如果你有两个数据源 这个配置哪个数据源就监控哪个数据源的sql 同时配置那就都监控
         */
        try {
            dataSource.setFilters(filters);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        dataSource.setConnectionProperties(connectionProperties);  
        return dataSource;
    }

    @Bean(name = &quot;masterTransactionManager&quot;)
    @Primary
    public DataSourceTransactionManager masterTransactionManager() {
        return new DataSourceTransactionManager(masterDataSource());
    }

    @Bean(name = &quot;masterSqlSessionFactory&quot;)
    @Primary
    public SqlSessionFactory masterSqlSessionFactory(@Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource)
            throws Exception {
        final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(masterDataSource);
        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MasterDataSourceConfig.MAPPER_LOCATION));
        
        return sessionFactory.getObject();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说明几点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1) @Primary: 多数据源配置的时候注意，必须要有一个主数据源， 用 @Primary 标志该 Bean。标志这个 Bean 如果在多个同类 Bean 候选时，该 Bean优先被考虑。
  2) dataSource.setFilters(filters): 这个是用来配置 druid 监控sql语句的, 如果你有两个数据源 这个配置哪个数据源就监控哪个 数据源的sql,同时配置那就都监控。
  3) 能够做到多个数据源的关键点 就是每个数据源所扫描的mapper包不一样,谁扫描到哪个mapper那么该mapper就用哪个数据源,同时都扫到了呢,
      那当然就得用主数据源咯,也就是添加@Primary 的数据源。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;次数据源clusterdatasourceconfig&quot;&gt;&lt;span&gt;4、次数据源(ClusterDataSourceConfig)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;这里省略了部分代码,因为和主是一样的,完整代码在github代码里有。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 次数据源 另一个数据源配置
 */
@Configuration
@MapperScan(basePackages = ClusterDataSourceConfig.PACKAGE, sqlSessionFactoryRef = &quot;clusterSqlSessionFactory&quot;)
public class ClusterDataSourceConfig {

    /**
     * 配置多数据源 关键就在这里 这里配置了不同数据源扫描不同的mapper
     */
    static final String PACKAGE = &quot;com.binron.multidatasource.mapper.cluster&quot;;
    static final String MAPPER_LOCATION = &quot;classpath:mapper/cluster/*.xml&quot;;

    @Value(&quot;${cluster.datasource.url}&quot;)
    private String url;

    @Value(&quot;${cluster.datasource.username}&quot;)
    private String username;

    @Value(&quot;${cluster.datasource.password}&quot;)
    private String password;

    @Value(&quot;${cluster.datasource.driverClassName}&quot;)
    private String driverClass;

    @Bean(name = &quot;clusterDataSource&quot;)
    public DataSource clusterDataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName(driverClass);

        //具体配置
        try {
            dataSource.setFilters(&quot;stat,wall,slf4j&quot;);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return dataSource;
    }

    @Bean(name = &quot;clusterTransactionManager&quot;)
    public DataSourceTransactionManager clusterTransactionManager() {
        return new DataSourceTransactionManager(clusterDataSource());
    }

    @Bean(name = &quot;clusterSqlSessionFactory&quot;)
    public SqlSessionFactory clusterSqlSessionFactory(@Qualifier(&quot;clusterDataSource&quot;) DataSource clusterDataSource)
            throws Exception {
        final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(clusterDataSource);

        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(ClusterDataSourceConfig.MAPPER_LOCATION));
        return sessionFactory.getObject();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说明几点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   1）发现次数据源所扫描的mapper和主是完全不一样的,说明每个数据源负责自己的mapper
   2)  次数据源是没有加@Primary。
   3）这里也添加了dataSource.setFilters(filters):说明 次数据源也需要监听sql语句。&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三配置可视化界面&quot;&gt;&lt;span&gt;三、配置可视化界面&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * druid监控界面设置
 */
@Configuration
public class DruidConfiguration {

    @Bean
    public ServletRegistrationBean druidStatViewServle() {
        //注册服务
        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(
                new StatViewServlet(), &quot;/druid/*&quot;);
        // 白名单(为空表示,所有的都可以访问,多个IP的时候用逗号隔开)
        servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;127.0.0.1&quot;);
        // IP黑名单 (存在共同时，deny优先于allow) （黑白名单就是如果是黑名单，那么该ip无法登陆该可视化界面）
        servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;127.0.0.2&quot;);
        // 设置登录的用户名和密码
        servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;root&quot;);
        servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;);
        // 是否能够重置数据.
        servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;);
        return servletRegistrationBean;
    }

    @Bean
    public FilterRegistrationBean druidStatFilter() {
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(
                new WebStatFilter());
        // 添加过滤规则
        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);
        // 添加不需要忽略的格式信息
        filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;);
        System.out.println(&quot;druid初始化成功!&quot;);
        return filterRegistrationBean;

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说明几点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;（1）登陆地址:http://127.0.0.1:8080/druid/index.html(端口号看自己设置的端口号)
（2）一旦配置黑名单,那么该ip访问是没有权限的登陆的
（3）如果想看SQL执行结果,那么上面数据源配置一定要添加dataSource.setFilters(filters),我之前就没有添加,所以其它都能正常使用,就是无法监控Sql语句。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181228215904024-23947484.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181228215914568-1877439654.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实很好用。顺便讲下,我遇到其它功能都有用,唯独Sql语句无法监控的问题,之后看界面才看出端倪来。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181228215924760-1448770177.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我发现界面中,filter类名为空，可是在yml确实配置了filters,怎么还是空,原因是数据源里没有配置&lt;code&gt;setFilters(filters)&lt;/code&gt;。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181228215939943-1509290954.jpg&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;文献资料&quot;&gt;&lt;span&gt;文献资料&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、 &lt;a href=&quot;https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter&quot;&gt;阿里github有关Druid结合Boot文档&lt;/a&gt;&lt;br/&gt;2、 &lt;a href=&quot;https://github.com/xuwujing/springBoot-study&quot;&gt;demo参考github地址&lt;/a&gt;: (感谢作者分享）&lt;br/&gt;3、 &lt;a href=&quot;https://www.cnblogs.com/funnyboy0128/p/9052447.html&quot;&gt;数据连接池的属性字段说明&lt;/a&gt;&lt;br/&gt;4、 &lt;a href=&quot;https://www.jianshu.com/p/1094d3fcee8d&quot;&gt;yml配置、properties配置、ssm配置&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 14:27:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>SpringBoot整合Druid实现多数据源和可视化监控 先献上 代码地址:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10192041.html</dc:identifier>
</item>
<item>
<title>【响应式编程的思维艺术】 （4）从打飞机游戏理解并发与流的融合 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10193087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10193087.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;3.3644859813084&quot;&gt;
&lt;p&gt;本文是&lt;a href=&quot;https://segmentfault.com/a/1190000015974355&quot;&gt;Rxjs 响应式编程-第三章: 构建并发程序&lt;/a&gt;这篇文章的学习笔记。&lt;/p&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;https://github.com/dashnowords/blogs/tree/master/Demo/rxjs-starwar&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多博文：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201812/1354575-20181228215249674-682715136.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-划重点&quot;&gt;一. 划重点&lt;/h2&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;尽量避免外部状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在基本的函数式编程中，纯函数可以保障构建出的数据管道得到确切的可预测的结果，响应式编程中有着同样的要求，博文中的示例可以很清楚地看到，当依赖于外部状态时，多个订阅者在观察同一个流时就容易互相影响而引发混乱。&lt;/p&gt;
&lt;p&gt;当不同的流之间出现共享的外部依赖时，一般的实现思路有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将这个外部状态独立生成一个可观察对象，然后根据实际逻辑需求使用正确的流合并方法将其合并。&lt;/li&gt;
&lt;li&gt;将这个外部状态独立生成一个可观察对象，然后使用&lt;code&gt;Subject&lt;/code&gt;来将其和其他逻辑流联系起来。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;管道的执行效率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上一节中通过&lt;code&gt;compose&lt;/code&gt;运算符组合纯函数就可以看到，容器相关的方法几乎全都是高阶函数，这样的做法就使得管道在构建过程中并不不会被启用，而是缓存组合在了一起（从上一篇的IO容器的示例中就可以看到延缓执行的形式），当它被订阅时才会真正启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Subject类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Subject&lt;/code&gt;同时具备&lt;code&gt;Observable&lt;/code&gt;和&lt;code&gt;observer&lt;/code&gt;的功能，可订阅消息，也可产生数据，一般作为流和观察者的代理来使用，可以用来实现流的解耦。为了实现更精细的订阅控制，&lt;code&gt;Subject&lt;/code&gt;还提供了以下几种方法。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;AsyncSubject&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsyncSubject&lt;/code&gt;观察的序列完成后它才会发出最后一个值，并永远缓存这个值，之后订阅这个&lt;code&gt;AsyncSubject&lt;/code&gt;的观察者都会立刻得到这个值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;BehaviorSubject&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Observer在订阅&lt;code&gt;BehaviorSubject&lt;/code&gt;时，它接收最后发出的值，然后接收后续发出的值，一般要求提供一个初始值，观察者接收到的消息就是距离订阅时间最近的那个数据以及流后续产生的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ReplaySubject&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReplaySubject&lt;/code&gt;会缓存它监听的流发出的值，然后将其发送给任何较晚的Observer，它可以通过在构造函数中传入参数来实现缓冲时间长度的设定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二.-从理论到实践&quot;&gt;二. 从理论到实践&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201812/1354575-20181228215314933-1420103520.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原文中提供了一个非常详细的打飞机游戏的代码，但我仍然建议你在熟悉了其基本原理和思路后自己将它实现出来，然后去和原文中的代码作对比，好搞清楚哪些东西是真的理解了，哪些只是&lt;strong&gt;你以为自己理解了&lt;/strong&gt;，接着找一些很明显的优化点，继续使用响应式编程的思维模式来试着实现它们，起初不知道从何下手是非常正常的（当然也可能是笔者的自我安慰），但这对于培养响应式编程思维习惯大有裨益。笔者在自己的实现中又加入了右键切换飞船类型的功能，必须得说开发游戏的确比写业务逻辑要有意思。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;由于没有精确计算雪碧图的坐标，所以在碰撞检测时会有一些偏差&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&quot;三.-问题及反思&quot;&gt;三. 问题及反思&lt;/h2&gt;
&lt;ol readability=&quot;26.5&quot;&gt;&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;关于canvas的尺寸问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建议通过以下方式来设置:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!--推荐方式1--&amp;gt;
&amp;lt;canvas height=&quot;300&quot; width=&quot;400&quot;&amp;gt;&amp;lt;/canvas&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//推荐方式2
canvas = document.getElementById('canvas');
canvas.height = 300;
canvas.width = 300;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要避免的几种方式（都是只改变画板尺寸，不改变画布尺寸，会造成绘图被拉伸）：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;//1.CSS设置
#mycanvas{
   height:300px;
   width:300px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//2.DOM元素API设置
canvas = document.getElementById('canvas');
canvas.style.height = 300;
canvas.style.width= 300;
//3.Jquery设置
$('#mycanvas').width(300);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时需要注意canvas的宽高不支持百分比设定。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Rx.Observable.combineLatest&lt;/code&gt;以后整体的流不自动触发了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;combineLatest&lt;/code&gt;这个运算符需要等所有的流都emit一次数据以后才会开始emit数据，因为它需要为整合在一起的每一个流保持一个最新值。所以自动启动的方法也很简单，为那些不容易触发首次数据的流添加一个初始值就可以了，就像笔者在上述实现右键来更换飞船外观时所实现的那样，使用&lt;code&gt;startWith&lt;/code&gt;运算符提供一个初始值后，在鼠标移动时&lt;code&gt;combineLatest&lt;/code&gt;生成的飞船流就会开始生产数据了。另外一点需要注意的就是&lt;code&gt;combineLatest&lt;/code&gt;结合在一起后，其中任何一个流产生数据都会导致合成后的流产生数据，由于图例数据的坐标是在绘制函数中实现的，所以被动的触发可能会打乱原有流的预期频率，使得一些舞台元素的位置或形状变化更快，这种情况可以使用&lt;code&gt;sample( )&lt;/code&gt;运算符对合并后的流进行取样操作来限制数据触发频率。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;一段越来越快的流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者自己在生成敌机的时候，第一次写出这样一段代码:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let enemyShipStream = Rx.Observable.interval(1500)
.scan((prev)=&amp;gt;{//敌机信息需要一个数组来记录，所以通过scan运算符将随机出现的敌机信息聚合
     prev.push({
        shape:[238,178,120,76],
        x:parseInt(Math.random() * canvas.width,10),
        y:50
     });
     return prev
},[])
.flatMap((enemies)=&amp;gt;{
   return Rx.Observable.interval(40).map(()=&amp;gt;{
       enemies.forEach(function (enemy) {
           enemy.y = enemy.y + 2;
       });
       return enemies;
   })
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行的时候发现敌机的速度变得越来越快，很诡异，如果你看不出问题在哪，建议画一下大理石图，看看&lt;code&gt;flatMap&lt;/code&gt;汇聚的总的数据流是如何构成的，就很容易看到随着时间推移，多个流都在操作最初的源数据，所以坐标自增的频率越来越快。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;限制scan操作符聚合结果的大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自己写代码时多处使用&lt;code&gt;scan&lt;/code&gt;操作符对产生的数据进行聚合，如果聚合的形式是集合形式的，其所占空间就会随着时间推移越来越大，解决的办法就是在&lt;code&gt;scan&lt;/code&gt;操作符接收的回调函数中利用数组的&lt;code&gt;filter&lt;/code&gt;方法对聚合结果进行过滤，生成新的数组并返回，以此来控制聚合结果的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;碰撞检测的实现思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;碰撞检测是即时生效的，所以每一帧都需要进行，最终汇总的流每次发射数据时都可以拿到所有待绘制元素的坐标信息，此时即是实现碰撞检测的时机，当检测到碰撞时，只需要在坐标数据中加个标记，然后在最初的&lt;code&gt;scan&lt;/code&gt;的聚合方法中将符合标记的数据清除掉就可以了，检测碰撞的逻辑和碰撞发生后的数据清除以及绘制判断是编写在不同地方的，在笔者提供的示例中就可以看到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四.-参考代码及demo说明&quot;&gt;四. 参考代码及Demo说明&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;demo中的&lt;code&gt;index.html&lt;/code&gt;是学习原文时拷贝的代码，mygame中的代码是笔者写的，有需要的读者自行使用即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;myspace.js&lt;/code&gt;-星空背景流&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 背景
 * 扩展思考：如何融入全屏resize事件来自动调整星空
 */
//将全屏初始化为画布舞台
let canvas = document.getElementById('canvas');
    canvas.height = window.innerHeight;
    canvas.width = window.innerWidth;
    canvas.style.backgroundColor = 'black';
let ctx = canvas.getContext('2d');
    ctx.fillStyle = '#FFFFFF';
let spaceShipImg = new Image();
    spaceShipImg.src = 'plane2.png';

//生成星空
//每个数据点希望得到的数据形式是[{x:1,y:1,size:1},{}]
let starStream = Rx.Observable.range(1,250)
.map(function(data){
   return {
      x:Math.ceil(Math.random()*canvas.width),
      y:Math.ceil(Math.random()*canvas.height),
      size: Math.ceil((Math.random()*4))
   }
})
.toArray()
.flatMap(function(stars){
    /*此处是默写时的难点，静态生成的数组流需要一直保持
    *后续的结果都是在此之上不断累加的
    */
    return Rx.Observable.interval(40).map(function () {
        stars.forEach(function (star) {
            star.y = (star.y+2)  % canvas.height; 
        });
        return stars;
    })
})

//绘制星空
function paintStar(stars){
    //暴力清屏，如果不清除则上次的星星不会被擦除
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#FFFFFF';
    //绘制星星
    stars.forEach(function (star) {  
        ctx.fillRect(star.x, star.y, star.size, star.size); 　
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;myship.js&lt;/code&gt;-我方飞船流&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 自己的飞船
 * 扩展思考：如何实现右键点击时更换飞船类型?
 */

//鼠标移动流
let mouseMoveStream = Rx.Observable.fromEvent(window, 'mousemove')
.distinct() //位置发生变化时触发
.map(function (data) {
    return {
        x:data.clientX,
        y:canvas.height - 100
    }
});

//飞船类型静态流
let shipTypeStream = Rx.Observable.from([
       [0,0,130,90],
       [135,0,130,100],
       [265,0,126,100],
       [0,170,110,100]
    ]).toArray();

//鼠标右键流-实现类型切换,每次生成一个序号，然后从静态飞船流中拿出图形数据
let mouseRightStream = Rx.Observable.fromEvent(window, 'contextmenu')
.map(function (event) {
    event.preventDefault();//禁止右键弹出菜单
})
.scan(count=&amp;gt;count+1,0)//记录点击次数
.map(count=&amp;gt;count % 4).startWith(0);//将次数转换为飞船类型序号


//鼠标左键流-实现子弹发射
let mouseClickStream = Rx.Observable.fromEvent(canvas, 'click')
.sample(200)
.scan((prev,cur)=&amp;gt;{
   prev.push({
       x:cur.clientX,
       y:canvas.height - 50,
       used:false //标记是否已经击中某个飞船
   });
   return prev.filter((bullet)=&amp;gt;{return bullet.y || !bullet.used});
},[])
.startWith([{x:0,y:0}]);

//玩家飞船流
let myShipStream = Rx.Observable.combineLatest(mouseMoveStream,
                                               shipTypeStream,
                                               mouseRightStream,
                                               mouseClickStream,
                                               function(pos,typeArr,typeIndex,bullets){
                                                  return {
                                                    x:pos.x,
                                                    y:pos.y,
                                                    shape:typeArr[typeIndex],
                                                    bullets:bullets
                                                  }
                                               });

//绘制飞船
function paintMyShip(ship) {
    //绘制飞船
    ctx.drawImage(spaceShipImg,ship.shape[0],ship.shape[1],ship.shape[2],ship.shape[3], ship.x - 50, ship.y, ship.shape[2],ship.shape[3]);
    //绘制自己子弹
    ship.bullets.forEach(function (bullet) {  
         bullet.y = bullet.y - 10;
         ctx.drawImage(spaceShipImg, ship.shape[0],ship.shape[1],ship.shape[2],ship.shape[3], bullet.x , bullet.y, ship.shape[2] / 4 ,ship.shape[3] / 4);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;enemy.js&lt;/code&gt;-敌机流&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 敌方飞船
 */

//辅助函数-判断是否超出画布范围
function isVisible(obj) {
   return obj.x &amp;gt; -60 &amp;amp;&amp;amp; obj.x &amp;lt; canvas.width + 60 &amp;amp;&amp;amp; obj.y &amp;gt; -60 &amp;amp;&amp;amp; obj.y &amp;lt; canvas.height + 60;
}

//每2秒在随机横向位置产生一个敌机
let enemyShipStream = Rx.Observable.interval(2000)
.scan((prev)=&amp;gt;{//敌机信息需要一个数组来记录，所以通过scan运算符将随机出现的敌机信息聚合   
     let newEnemy = {
        shape:[238,178,120,76],
        x:parseInt(Math.random() * canvas.width,10),
        y:50,
        isDead:false,//标记敌机是否被击中
        bullets:[]
     }

     //定时生成子弹
     Rx.Observable.interval(1500).subscribe(()=&amp;gt;{
         if (!newEnemy.isDead) {//被击中的敌人不再产生子弹
            newEnemy.bullets.push({ x: newEnemy.x, y: newEnemy.y });
         }
         newEnemy.bullets = newEnemy.bullets.filter(isVisible);
     });
      
     prev.push(newEnemy);
     return prev.filter(isVisible);
},[]);

//绘制飞船
function paintEnemy(enemies) {
   enemies.forEach(function (enemy) {
       //绘制时增量改变敌机坐标
       enemy.y = enemy.y + 3;
       enemy.x = enemy.x + parseInt(Math.random()*8 - 4,10);
       //绘制时增量改变敌机子弹坐标
       enemy.bullets.forEach(function(bullet){bullet.y = bullet.y + 16;});
       //如果敌机没挂则绘制飞机
       if (!enemy.isDead) {
         ctx.save();
         ctx.translate(enemy.x, enemy.y);
         ctx.rotate(Math.PI);
         //绘制敌机
         ctx.drawImage(spaceShipImg,enemy.shape[0],enemy.shape[1],enemy.shape[2],enemy.shape[3], 0, 0, enemy.shape[2] * 0.8 ,enemy.shape[3] * 0.8);
         ctx.restore();
       }
       //绘制子弹
       enemy.bullets.forEach(function (bullet) {
          ctx.save();
          ctx.translate(bullet.x, bullet.y);
          ctx.rotate(Math.PI);
          ctx.drawImage(spaceShipImg,enemy.shape[0],enemy.shape[1],enemy.shape[2],enemy.shape[3], 0, 0, enemy.shape[2] / 4,enemy.shape[3] / 4);
          ctx.restore();
       });
       ctx.restore();
   });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;collision.js&lt;/code&gt;-碰撞检测&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 辅助函数
function isCollision(target1, target2) {
 return (target1.x &amp;gt; target2.x - 50 &amp;amp;&amp;amp; target1.x &amp;lt; target2.x + 50) &amp;amp;&amp;amp; (target1.y &amp;gt; target2.y - 20 &amp;amp;&amp;amp; target1.y &amp;lt; target2.y + 20);
}

//碰撞检测方法
function checkCollision(myship, enemies) {
    let gameOver = false;
    myship.bullets.forEach(function(bullet) {
        enemies.forEach(function (enemy) { 
            //检查是否击中了敌机
            if (isCollision(bullet, enemy)) {
                 bullet.used = true;
                 enemy.isDead = true;
            };
            //检查是否被击中，被击中则游戏结束
            enemy.bullets.forEach(function (enemyBullet) {
                if (isCollision(myship, enemyBullet)) {
                    gameOver = true;
                }
            })
        })
    });
    return gameOver;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;combineAll.js&lt;/code&gt;-融合最终的游戏流&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 集合所有流
 */

let gameStream = Rx.Observable.combineLatest(starStream,
                                            myShipStream,
                                            enemyShipStream,
                                            function (stars,myship,enemies) {
                                             return {
                                                stars,myship,enemies
                                             }
})
.sample(40);//sample函数来规避鼠标移动事件过快触发导致坐标数据更新过快

//绘制所有元素
function paintAll(data) {
     let isGameOver;
     isGameOver = checkCollision(data.myship, data.enemies);//检查子弹是否击中敌人
     if (!isGameOver) {
         paintStar(data.stars);
         paintMyShip(data.myship);
         paintEnemy(data.enemies);
     }else{
        gameSubscription.dispose();
        alert('被击中了');
     }
}

//订阅所有汇总的流来启动游戏
let gameSubscription = gameStream.subscribe(paintAll);&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 28 Dec 2018 13:54:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>. 本文是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10193087.html</dc:identifier>
</item>
<item>
<title>从零开始一起学习SLAM | 点云平滑法线估计 - 计算机视觉life</title>
<link>http://www.cnblogs.com/CV-life/p/10192777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CV-life/p/10192777.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;点击公众号“计算机视觉life”关注，置顶星标更快接收消息！&lt;br/&gt;本文编程练习框架及数据获取方法见文末获取方式&lt;br/&gt;菜单栏点击“知识星球”查看「从零开始学习SLAM」一起学习交流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;点云滤波后为什么还需要平滑&quot;&gt;点云滤波后为什么还需要平滑？&lt;/h4&gt;
&lt;p&gt;小白：师兄，师兄，上次你说的点云滤波我学会啦，下一步怎么把点云变成网格啊？&lt;br/&gt;师兄：滤波只是第一步，在网格化前我们还需要对滤波后的点云进行平滑（smoothing）&lt;br/&gt;小白：不是已经滤波了吗？怎么还要平滑啊？滤波和平滑不一样吗？&lt;br/&gt;师兄：确实不太一样。我们用RGB-D，激光扫描仪等设备扫描物体，尤其是比较小的物体时，往往会有测量误差。这些误差所造成的不规则数据如果直接拿来曲面重建的话，会使得重建的曲面不光滑或者有漏洞，而且这种不规则数据很难用前面我们提到过的统计分析等滤波方法消除，所以为了建立光滑完整的模型必须对物体表面进行平滑处理和漏洞修复。&lt;br/&gt;你看下面左边就是原始的扫描数据，右边就是用最小二乘法进行表面平滑后的结果&lt;br/&gt;&lt;a href=&quot;https://i.loli.net/2018/12/28/5c2580b5c1666.png&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/28/5c2580b5c1666.png&quot; alt=&quot;平滑前后贴图对比&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小白：从图上看，平滑确实效果很明显啊，左边杯子上黑色的是噪声吧，右边的结果来看经过平滑都消失了&lt;br/&gt;师兄：对，除了上面说到的设备测量误差外，还有一种情况也需要对点云进行平滑。就是后处理过程中，比如我们对同一个物体从不同方向进行了多次扫描，然后把扫描结果进行配准，最后得到一个完整的模型，但是你配准的结果不一定准啊，比如下图中左侧就是配准后未经过处理的结果，同一面墙壁由于配准误差变成了“两面墙”，并不能完全重叠，你觉得这个数据可以直接用来进行表面重建吗？&lt;br/&gt;&lt;a href=&quot;https://i.loli.net/2018/12/28/5c2580b8d851e.png&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/28/5c2580b8d851e.png&quot; alt=&quot;平滑前后对比&quot;/&gt;&lt;/a&gt;&lt;br/&gt;小白：好坑啊，肯定不行，这样重建出的结果也是两面墙了吧&lt;br/&gt;师兄：对，所以我们需要想办法把“两面墙”变成“一面墙”，如果这时候，我们没有条件重新扫描出更精确的结果，或者配准精度也无法提升，可以通过重采样的方法来实现点云的平滑，从而避免出现这样的问题。&lt;br/&gt;小白：原来这个平滑这么重要啊！怎么用重采样来平滑呢？感觉迫不及待想要学习啦！&lt;br/&gt;师兄：（既然胃口已经被吊起来了）那我们赶快开始切入正题吧&lt;/p&gt;
&lt;h4 id=&quot;如何通过重采样实现点云平滑&quot;&gt;如何通过重采样实现点云平滑？&lt;/h4&gt;
&lt;p&gt;师兄：点云重采样，我们实际上是通过一种叫做“移动最小二乘”（MLS， Moving Least Squares ）法来实现的，对应的类名叫做：pcl::MovingLeastSquares，你知道怎么用吗？&lt;br/&gt;小白：不知道，不过我还记得我们上次师兄给我说的方法，在PCL API documentation &lt;a href=&quot;http://docs.pointclouds.org/trunk/&quot; class=&quot;uri&quot;&gt;http://docs.pointclouds.org/trunk/&lt;/a&gt; 上查询类名称，就能看到类的定义和用法啦&lt;br/&gt;师兄：活学活用啊，哈哈，那我们现在去查一下看看吧&lt;br/&gt;小白：嗯，我查到了，这个MLS类的定义在这里：&lt;br/&gt;&lt;a href=&quot;http://docs.pointclouds.org/trunk/classpcl_1_1_moving_least_squares.html#a379330b0b1dacaa668d165f94930749c&quot; class=&quot;uri&quot;&gt;http://docs.pointclouds.org/trunk/classpcl_1_1_moving_least_squares.html#a379330b0b1dacaa668d165f94930749c&lt;/a&gt;&lt;br/&gt;成员函数好多啊&lt;br/&gt;师兄：对，看着是很多，但是很多我们不常用的，比如我们常用的一个用于重采样的示例代码如下，每行代码都给你注释好了，结合上面网址看很容易理解&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 对点云重采样  
pcl::search::KdTree&amp;lt;PointT&amp;gt;::Ptr treeSampling (new pcl::search::KdTree&amp;lt;PointT&amp;gt;); // 创建用于最近邻搜索的KD-Tree
pcl::PointCloud&amp;lt;PointT&amp;gt; mls_points;   //输出MLS
pcl::MovingLeastSquares&amp;lt;PointT, PointT&amp;gt; mls;  // 定义最小二乘实现的对象mls
mls.setComputeNormals (false);  //设置在最小二乘计算中是否需要存储计算的法线
mls.setInputCloud (cloud_filtered);     //设置待处理点云
mls.setPolynomialOrder(2);          // 拟合2阶多项式拟合
mls.setPolynomialFit (false);  // 设置为false可以 加速 smooth
mls.setSearchMethod (treeSampling); // 设置KD-Tree作为搜索方法
mls.setSearchRadius (0.05); // 单位m.设置用于拟合的K近邻半径
mls.process (mls_points);       //输出&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白：师兄，这个代码里的KD-Tree是干嘛的？&lt;br/&gt;师兄：Kd-Tree是一种数据结构，是空间二分树的一种特殊情况，可以很方便的用于进行范围搜索。在这里用KD-Tree就是为了便于管理、搜索点云，这种结构来可以很方便的找到最近邻点。&lt;br/&gt;小白：原来如此，那上面mls.setSearchRadius (0.05) 的意思是不是就是搜索当前点以5cm为半径的空间中所有的点？&lt;br/&gt;师兄：对的，然后把这些点用2阶多项式拟合~&lt;br/&gt;&lt;a href=&quot;https://i.loli.net/2018/12/28/5c2580b7c3d1f.png&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/28/5c2580b7c3d1f.png&quot; alt=&quot;平面拟合&quot;/&gt;&lt;/a&gt;&lt;br/&gt;小白：所以表面就变平滑啦！&lt;/p&gt;
&lt;h4 id=&quot;如何估计点云的表面法线&quot;&gt;如何估计点云的表面法线？&lt;/h4&gt;
&lt;p&gt;小白：师兄，现在可以网格化了吗？&lt;br/&gt;师兄：还不行。。。别急，网格化前我们还需要估计一下点云的表面法线（normal）&lt;br/&gt;小白：啊，怎么又冒出来一个法线。。。&lt;br/&gt;师兄：法线好像是中学就学过了，应该还记得平面的法线的定义吧，平面的法线是垂直于该平面的向量，如下图所示&lt;br/&gt;&lt;a href=&quot;https://i.loli.net/2018/12/28/5c2580ab0b402.png&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/28/5c2580ab0b402.png&quot; alt=&quot;法线。图片来自wiki&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你看上面右边那个图，对于曲面来说，曲面在某点P处的法线为垂直于该点切平面（tangent plane）的向量&lt;br/&gt;小白：记得呢，不过这个法线有什么用？怎么就突然冒出来了&lt;br/&gt;师兄：法线很有用的，尤其是在三维建模中应用非常广泛，比如在计算机图形学（computer graphics）领域里，法线决定着曲面与光源（light source）的强弱处理（Flat Shading），对于每个点光源位置，其亮度取决于曲面法线的方向。&lt;br/&gt;小白：原来如此。不过好像平面或曲面的法线比较容易计算，方程 ax + by + cz = d 表示的平面，向量(a, b, c)&lt;br/&gt;就是其法线。而我们这里是点云呢！怎么算呢？&lt;br/&gt;师兄：确实如此。点云的法线计算是稍微麻烦点，一般有两种方法：&lt;br/&gt;1、使用曲面重建方法，从点云数据中得到采样点对应的曲面，然后再用曲面模型计算其表面的法线&lt;br/&gt;2、直接使用近似值直接从点云数据集推断出曲面法线&lt;br/&gt;这里主要用第2种方法来近似估计点云中每个点的表面法线。&lt;br/&gt;具体来说，就是把估计某个点的表面法线问题简化为：从该点最近邻计算的协方差矩阵的特征向量和特征值的分析，这里就不多做介绍了。PCL已经帮我们封装好了函数啦&lt;br/&gt;我们计算出来点云的法线大概是这样的&lt;br/&gt;&lt;a href=&quot;https://i.loli.net/2018/12/28/5c2580abc79d0.jpg&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/28/5c2580abc79d0.jpg&quot; alt=&quot;点云表面法线&quot;/&gt;&lt;/a&gt;&lt;br/&gt;小白：那个箭头就代表法线吧？&lt;br/&gt;师兄：对的，我们前面提到了，需要从该点的周围点邻域（也称为k邻域）估计一点处的表面法线 ，所以这个K邻域的选取也很关键&lt;br/&gt;小白：这个K邻域选取会有什么影响吗？&lt;br/&gt;师兄：有的，而且影响挺大的，K近邻的取值可以通过选择k个最近点，或者确定一个以r为半径的圆内的点集来确定，你看下面这个图是对同一个点云用不同尺度因子（k和r）进行法线估计的结果。左边部分表示比例因子选择的比较合适，估计的表面法线近似垂直于这两个平面，即使在互相垂直的边缘部分，也能明显看到边沿。而右边的尺度因子就选的有点大了，这样临近点集更大范围的覆盖临近表面的点，两个平面边沿处估计的法线就不准了，不能表达真实的情况。&lt;br/&gt;&lt;a href=&quot;https://i.loli.net/2018/12/28/5c2580a9dd4e8.jpg&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/28/5c2580a9dd4e8.jpg&quot; alt=&quot;法线计算中K近邻参数的影响&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小白：确实是这样啊，看来编程的时候要格外注意了。&lt;br/&gt;师兄：法线估计的示例如下，我也给你注释好啦&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 法线估计
pcl::NormalEstimation&amp;lt;PointT, pcl::Normal&amp;gt; normalEstimation;                    //创建法线估计的对象
normalEstimation.setInputCloud(cloud_smoothed);                                 //输入点云
pcl::search::KdTree&amp;lt;PointT&amp;gt;::Ptr tree(new pcl::search::KdTree&amp;lt;PointT&amp;gt;);         // 创建用于最近邻搜索的KD-Tree
normalEstimation.setSearchMethod(tree);
pcl::PointCloud&amp;lt;pcl::Normal&amp;gt;::Ptr normals (new pcl::PointCloud&amp;lt;pcl::Normal&amp;gt;);   // 定义输出的点云法线
// K近邻确定方法，使用k个最近点，或者确定一个以r为半径的圆内的点集来确定都可以，两者选1即可
normalEstimation.setKSearch(10);                    // 使用当前点周围最近的10个点
//normalEstimation.setRadiusSearch(0.03);           //对于每一个点都用半径为3cm的近邻搜索方式
normalEstimation.compute(*normals);                 //计算法线&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文参考：PCL官网&lt;/p&gt;
&lt;h4 id=&quot;编程练习&quot;&gt;编程练习&lt;/h4&gt;
&lt;p&gt;前面我们已经介绍过点云滤波，这次练习主要是后续的平滑和法线估计，为后面网格化做铺垫。&lt;br/&gt;题目：给定一个融合后的点云，已经对其进行下采样和滤波（代码已给）。请对其进行平滑（输出结果），然后计算法线，并讲法线显示在平滑后的点云上。&lt;br/&gt;代码框架及待处理数据已经 为你准备好了，公众号「计算机视觉life」后台回复：平滑，即可获得。&lt;br/&gt;如果一切顺利，你将得到如下结果。你可以通过调整法线的稠密，放大查看法线计算的是否符合预期。&lt;br/&gt;&lt;a href=&quot;https://i.loli.net/2018/12/28/5c2580b6b343f.png&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/28/5c2580b6b343f.png&quot; alt=&quot;平滑后法线显示&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎留言讨论，更多学习视频、文档资料、参考答案等关注计算机视觉life公众号，，菜单栏点击“知识星球”查看「从零开始学习SLAM」星球介绍，快来和其他小伙伴一起学习交流~&lt;/p&gt;
&lt;h4 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247485792&amp;amp;idx=1&amp;amp;sn=358b9bea94cf31b976abc3c12b28f4d7&amp;amp;chksm=97d7ecf7a0a065e1664469c22adce35e6d919d74f5ab95693c8921241f3fefe37fb571527e10&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 为什么要学SLAM？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247485820&amp;amp;idx=1&amp;amp;sn=3fdb40aec678c2ed03e2ecb8ce9bf812&amp;amp;chksm=97d7eceba0a065fdcd70cae70e2910f72850f6ab6303c9b66ec8addaeb1fe633345990544541&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 学习SLAM到底需要学什么？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247485843&amp;amp;idx=1&amp;amp;sn=e82cbb4a5120d2b5786737f1e0eb66de&amp;amp;chksm=97d7ec04a0a065122d905987de0e369eb769cc711df56b0011094c854e14c03ea13206bca12e&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | SLAM有什么用？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247485880&amp;amp;idx=1&amp;amp;sn=e464414da06925c56c35513f4f295b97&amp;amp;chksm=97d7ec2fa0a06539149ff61edc89adb9319d4f3f3ba3634b170e7f83c2e259f2f01ffbf0ac43&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | C++新特性要不要学？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247485921&amp;amp;idx=1&amp;amp;sn=dfccfc8772d4905c744cab53c3c4c7b3&amp;amp;chksm=97d7ec76a0a065608fda155f6de835c534fa2b012b6659d317c279181e040480e6b883867d14&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 为什么要用齐次坐标？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247485988&amp;amp;idx=1&amp;amp;sn=eaec2aa09cb4baeae36d2f669cc89174&amp;amp;chksm=97d7efb3a0a066a50e8ad29f05fe595a304dd19cc55be0edbe83969c3288b97f2fecc77cd440&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 三维空间刚体的旋转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247486047&amp;amp;idx=1&amp;amp;sn=25d97bb47c26ac3babafd668ee0c013b&amp;amp;chksm=97d7efc8a0a066de0990dc79de32c666aff4698aa1f8dbfc131cc426e6beba96cd5260d0a667&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 为啥需要李群与李代数？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247486116&amp;amp;idx=1&amp;amp;sn=38252b8f03ef16122e3ac494d7ec8740&amp;amp;chksm=97d7ef33a0a06625b34d491fc83c5e6e820baa11c6f9f0c113e32fdb7c7bf1e04e40fd8019ab&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 相机成像模型&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247486151&amp;amp;idx=1&amp;amp;sn=2b322f466d916704b1070ece20e669db&amp;amp;chksm=97d7ef50a0a06646a984fcbf82870011ec10a9233899ee74fe8c09432517c5efaa285f1897c9&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 不推公式，如何真正理解对极约束?&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247486191&amp;amp;idx=1&amp;amp;sn=3b33d748dd4cd035e429665ef1e40299&amp;amp;chksm=97d7ef78a0a0666ebdd86886241b19c0a77a0ec8fa5e1a1ff5de2ae3e89740ffc5516f942bab&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 神奇的单应矩阵&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247486281&amp;amp;idx=1&amp;amp;sn=1b36bcfd9f492dabc44ae2f10562e040&amp;amp;chksm=97d7eedea0a067c89eb9b1e71f7cf5dd12410c8c81d43dc2a21f9c6f28babd7add017ad14705&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 你好，点云&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247486610&amp;amp;idx=1&amp;amp;sn=145132b3de5600d3a288c00bd50a7fa7&amp;amp;chksm=97d7e905a0a0601389157ca27a1be2618243f822583c5660ea18ff51f88f317fe8ac84360856&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始一起学习SLAM | 给点云加个滤网&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;amp;mid=2247485009&amp;amp;idx=2&amp;amp;sn=3709bcff8efb4a3d1ff78fbb60d4f245&amp;amp;chksm=97d7e3c6a0a06ad07bfcebd0e17a9d58c821ddfc2016dc4b8914bc0c921d65b59243ed5efcc9&amp;amp;scene=21#wechat_redirect&quot;&gt;零基础小白，如何入门计算机视觉？&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 12:57:00 +0000</pubDate>
<dc:creator>计算机视觉life</dc:creator>
<og:description>点击公众号“计算机视觉life”关注，置顶星标更快接收消息！ 本文编程练习框架及数据获取方法见文末获取方式 菜单栏点击“知识星球”查看「从零开始学习SLAM」一起学习交流 点云滤波后为什么还需要平滑？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CV-life/p/10192777.html</dc:identifier>
</item>
<item>
<title>002.AnyCast技术浅析 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/10192799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/10192799.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;一      常见通信方式&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;1.1  UniCastAnyCast&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;UniCast，即单播，指网络中一个节点与另一个节点之间需要建立一个单独的数据通道，从一个节点发出的信息只被一个节点收到，这种传送方式称为单播。即网络中从源向目的地转发单播流量的过程，IP地址与节点（主机）一一对应，单播流量地址唯一。每个节点必须分别对需要访问的节点发送单独的查询，而被访问节点必须向每个访问节点发送所申请的数据包拷贝。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121131250-1873053919.png&quot;&gt;&lt;img title=&quot;003&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121131541-317492268.png&quot; alt=&quot;003&quot; width=&quot;377&quot; height=&quot;349&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;1.2  MultiCast&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;MultiCast，即多播，指网络中一个节点发出的信息被多个节点（一组节点）接受。这种技术用于多媒体应用、多用户交互（如聊天室）、软件分发等，相比与传统的UniCast可以大大提高效率。在子网内实现MultiCast较为简单，跨越子网时需要Route 、Gateway等设备的支持。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121131820-1149723322.png&quot;&gt;&lt;img title=&quot;004&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121132057-1728005144.png&quot; alt=&quot;004&quot; width=&quot;375&quot; height=&quot;349&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;1.3  BroadCast&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;BroadCast，即广播，指网络中一个节点发出的信息被网络中的所有可能（通常的同子网下）的节点接受。网络设备简单地将它接收到的任何广播报文副本转发到除该报文到达的接口以外的每个接口。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121132282-624810585.png&quot;&gt;&lt;img title=&quot;005&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121132535-1732371100.png&quot; alt=&quot;005&quot; width=&quot;375&quot; height=&quot;347&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;二      什么是BGP AnyCast&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;AnyCast，也称任意播，或泛播，指IPV6协议中一个发送方同最近的一组接收方之间的通信。BGP AnyCast就是利用一个（或多个）AS号码在不同的地区广播相同的一个IP段。即不同地区若干个AS号广播同一个IP（段）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Any Cast IP拥有MultiCast和UniCast各自的部分特性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从宏观上来说，AnyCast类似于MultiCast，同一种类型的数据流同时存在多个接收者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而从微观上来说，AnyCast又有着UniCast的唯一性。每一个单独的IP会话都能够找到唯一的源主机和目标主机（最终通信双方唯一），如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即在AnyCast环境下，同时存在多个有效的数据包接收端，但具体一个特定IP数据包而言，仅有一个接收端主机收到了此数据包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AnyCast利用BGP的寻路原则，短的AS PATH会选成最优路径（BGP寻路原则之一），从而优化了访问速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即可多个不同服务器使用了相同的IP地址（该地址即这一组主机的共享单播地址）的一种技术。当发送方发送报文给这个共享单播地址时，报文会根据路由协议路由到这一组主机中离发送方最近的一台，所以这个技术也可以用来做负载均衡。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121132767-1986442896.png&quot;&gt;&lt;img title=&quot;006&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121133217-964042322.png&quot; alt=&quot;006&quot; width=&quot;375&quot; height=&quot;345&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;三      AnyCast技术特点&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;AnyCast的定义是：当一个单播地址被分配到多于一个的接口上（即目的地址不是唯一）时，发到该接口的报文被网络路由到由路由协议度量的“最近”的目标接口（某个节点）上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AnyCast允许源节点向一组目标节点中的一个节点发送数据报，而这个节点由路由系统选择，对源节点透明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时，路由系统选择“最近”的节点为源节点提供服务，从而在一定程度上为源节点提供了更好的服务也减轻了网络负载。AnyCast分布的服务节点共享相同的IP地址，同时在IP层进行透明的服务定位，这使得各种网络服务特别是应用层服务具有更强的透明性，如DNS（DomainNameSystem，域名系统），用户不需要特殊配置也不用关心访问的是哪一台DNS服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，路由系统选择了“最近”的服务，缩短了服务响应的时间，同时减轻了网络负载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，相同的服务在网络上冗余分布，路由系统可以提供机制选择负载相对轻的带宽相对高的路径来转发报文，这样就给用户带来了两个方面的好处：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;减弱了分布式拒绝服务攻击（DDoS：DistributedDenialofService）对用户带来的影响。当AnyCast组中某一个成员或者几个成员受到攻击时，负责报文转发的路由器可以根据各个组成员的响应时间来决定报文应该转发到哪个成员上，而受到攻击的成员由于没有响应，所以报文就不会被转发到此节点，同时，由于AnyCast提供的服务访问透明性，组成员也相对较难受到DDoS攻击。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;减弱了网络拥塞给用户带来的影响，当AnyCast的某些组成员处在拥塞的网段时，它的响应时间就较长，报文可以被转发到响应较好的成员那里，对于最终用户而言是无感知的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;四      AnyCast应用场景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;AnyCast主要应用于大范围的DNS部署，CDN数据缓存，数据中心等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;疑惑一：在AnyCast网络中多个主机用同一个IP，这岂不是IP地址冲突了？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解惑：首先，每一个节点主机处在不同的地理位置，相互之间不在同一个广播域内。所以把所有主机配置成相同的IP地址并不会引起我们日常所见的IP地址冲突；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，在仅仅配置相同IP之外，还需要借助BGP协议进行地址宣告，通过BGP，各个站点向Internet宣告相同的AnyCast IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;疑惑二：具有多条到达目的的路径，且具有相同Anycast IP地址的Prefix，数据包如何做到就近路由选址的呢？。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解惑：当用户的DNS（数据）请求到达运营商的宽带路由器以后，运营商的路由器会根据BGP的选路原则选择到达目的的最优路径。在用户宽带运营商和DNS服务器Internet运营商相同的情况下，最终会以IGP metric为关键因素来决定哪个DNS服务器给用户提供服务。而IGP的 Metric某种程度上就是物理距离的代表，从而实现就近原则。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.1  场景一：基于IP Anycast＋BGP的DNS部署&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;背景：假设部署三个DNS服务器站点，地点分别在北京、上海、广州，且服务于全国的DNS解析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常规方案：为了实现三个DNS服务器负载均衡，通常会考虑到使用硬件负载均衡设备，例如常见的F5负载均衡设备等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方案缺陷：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;网络流量瓶颈：所有的流量都需要先通过负载均衡设备，而硬件设备本身的吞吐量决定了整个网络环境的吞吐量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高昂的硬件成本：为了实现全国的流量负载均衡，需要极大吞吐量的硬件设备，从而大大提高了部署成本。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;AnyCast方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方案优点：通过AnyCast技术，无需要借助任何第三方负载均衡器，就可以轻松达到负载均衡的效果，同时还提供了冗余和高可靠性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方案实施：&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121133858-4077242.png&quot;&gt;&lt;img title=&quot;007&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121134408-1550641752.png&quot; alt=&quot;007&quot; width=&quot;536&quot; height=&quot;472&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过配置三个DNS站点的服务器IP为相同IP，例如1.1.1.1/32。然后通过各个站点的BGP对互联网宣告1.1.1.0/24的网段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上步骤完成以后，互联网路由表针对1.1.1.1/24会有三个不同的出口路由器，分别是北京，上海，广州。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设现有用户都使用1.1.1.1作为DNS服务器，依据就近原则，若用户地域为东北，则会优先采用北京DNS服务器进行解析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，贵阳的宽带路由器通过查看BGP路由，发现1.1.1.1出口最优路由是在广州，那么贵阳用户的DNS数据包将被发送给广州的DNS服务器。而江南一带的则是上海DNS服务器负责提供解析服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;故障容灾：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若三台DNS服务器中某一台出现故障，如广东DNS服务宕机，BGP协议会立即停止通告此1.1.1.0/24的网段，Internet路由表将会只有北京和上海的DNS可供选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时原广东DNS服务的用户将再次根据“就近原则”选择其他DNS服务器，例如上海DNS，从而达到业务的平滑迁移和服务的高可用性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结结论：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全国用户最终会根据距离DNS服务器的远近来判断使用哪个DNS服务器做域名解析；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从DNS角度来说，正因为不同的地理位置用户会根据就近路由判断，从而选择不同的DNS服务器，最终会使三台DNS服务器达到负载均衡的效果；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若其中某一个节点出现故障以后，业务会立即自动迁移到其他可用的节点上，从而避免网路服务故障。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.2  场景二：防范DDOS攻击&lt;/h3&gt;
&lt;h4 align=&quot;left&quot;&gt;4.2.1    DDoS简述&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;DoS攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DDoS（分布式拒绝服务）指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，同时对一个或多个目标发动DoS攻击。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DDOS攻击主要分为三类：流量型攻击；连接型攻击；特殊协议缺陷。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最常见的为流量型攻击，当大规模异常流量涌入时，会占用运营商核心MPLS网路带宽，同时这种洪泛攻击会给客户网络造成短时间的瘫痪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;案例参考：以NTP协议为例，NTP协议基于C/S模式，客户发起NTP时间查询申请，服务器响应NTP查询。假设有成千上万的僵尸主机纷纷伪造如下数据包并不断连续发送给全球NTP服务器：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;伪造源地址：1.2.3.4               #此地址为真正需要攻击的地址&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;目标地址：全球各个NTP服务器地址     #大批量提供响应的节点&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当全球各地的NTP服务器收到此查询以后，它会把查询结果发送回给真正的被攻击者1.2.3.4，此时IP地址为1.2.3.4的受害者收到全世界的NTP服务器发过来的数据包时，其有限的带宽链路就很容易产生拥塞并造成服务中断。受到的DDoS攻击流量=虚假数据包发送数量x全世界NTP服务器的数量。&lt;/span&gt;&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;4.2.2    AnyCast防范DDOS攻击&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;DDOS攻击最关键是需要把所有地理位置分散的小流量最终汇集为一个巨大的流量，从而发起攻击。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在AnyCast环境下，由于多个地理位置不同的主机同时使用同一个IP地址。因此，DDOS攻击流量在穿越运营商路由器时，路由器会根据地理位置远近把数据包路由到距离源地址最近的受害者主机站点，从而间接又再次分散了整个DDOS流量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上案例，假设IP地址为1.2.3.4的受害者采用了AnyCast协议部署网络，其服务器分布在全国各地。当DDOS洪流攻击时，不同的NTP服务器根据路由选择，把流量发送到距离NTP服务器最近的受害者服务器上。最终，大流量的攻击被逐步分解。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.3  场景三：大型企业CDN部署&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;AnyCast在大型企业中也常用于CDN部署，采用了Anycast技术为用户提供距离用户最近的Cache服务器，可大大提高了用户的服务体验。在全球建设了多个数据中心，凭借于AnyCast的高冗余性，任何一个数据中心出现网络、系统故障。均不会影响客户体验度，所有当地的客户流量会自动路由到其他就近的数据中心。相对传统企业网络面对网络节点故障的脆弱性，Anycast具有很强的优势。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121135043-1260496082.png&quot;&gt;&lt;img title=&quot;008&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181219121135571-434491523.png&quot; alt=&quot;008&quot; width=&quot;484&quot; height=&quot;200&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;4.4  场景四：时延敏感度高的内容服务业务&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;针对https/tcp等对时延敏感的协议（涉及多次握手的协议），由于用户位置流动，而数据中心相对固定，因此会随着用户的移动，体验可能出现严重下降。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于以上背景，可在全球有相关业务的地址位置部署小型数据中心，所有小型数据中心和总部数据中心保持长期稳定的TCP会话连接。当相对于总部的远端用户访问服务时，TCP连接实际是发送至用户当地的小型数据中心，从而降低了访问延时，提高了用户体验度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在全球大规模部署多个节点时，为了确保用户能就近访问所在地的数据中心，可把所有小型数据中心的IP采用相同地址，通过BGP发布至Internet。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当用户访问服务时，DNS解析会返回此小型数据中心的IP，然后用户运营商会根据就近原则路由用户数据到最近的小型数据中心，从而达到了上面所述的优化延迟的目的。&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;五      AnyCast总结&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;5.1  优点&lt;/h3&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;AnyCast可以零成本实现负载均衡，同时对于客户端而言是透明的，且无视流量大小；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AnyCast是非常有效的DDOS防御措施，采用了逐层分解的思想；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;部署AnyCast可以获得设备的高冗余性和可用性，即当任意目的节点异常时，可自动路由到就近目的节点；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AnyCast适用于无连接的UDP，以及有连接的TCP协议；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于AnyCast的特性——就近原则，很大程度上提升了客户端的响应速度。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;5.2  缺点&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;AnyCast严重依赖于BGP的选路原则，在整个Internet网络拓扑复杂的情况下，可能导致次优路由选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参考：https://blog.csdn.net/enweitech/article/details/79778528&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 12:55:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一 常见通信方式 1.1 UniCastAnyCast UniCast，即单播，指网络中一个节点与另一个节点之间需要建立一个单独的数据通道，从一个节点发出的信息只被一个节点收到，这种传送方式称为单播。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itzgr/p/10192799.html</dc:identifier>
</item>
<item>
<title>从应用到内核查接口超时（下） - 枕边书</title>
<link>http://www.cnblogs.com/zhenbianshu/p/10192480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenbianshu/p/10192480.html</guid>
<description>&lt;h2 id=&quot;再启&quot;&gt;再启&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;接上文 &lt;a href=&quot;https://zhenbianshu.github.io/2018/10/app_to_kernel_solve_api_timeout_2.html&quot;&gt;从应用到内核查接口超时（中）&lt;/a&gt;，查到是因为 journal 导致 write 系统调用被阻塞进而导致超时后，总感觉证据还不够充分，没有一个完美的交待。而且 leader 还想着让我把问题排查过程分享给同事们，这让我更加不安，担心搞错了方向。&lt;/p&gt;
&lt;p&gt;在以往的博客中，我的问题结论总是确定的，如果是推论的话，我会显式注明。现在的情况让我有点犯难，推论说出去担心误导了别人，而内核层的事，我只知道基本理论，有关此问题的结论还没有。&lt;/p&gt;
&lt;p&gt;于是，我只好再次踏上查这个问题的征程。&lt;/p&gt;
&lt;p&gt;转载随意，文章会持续修订，请注明来源地址：&lt;a href=&quot;https://zhenbianshu.github.io/&quot;&gt;https://zhenbianshu.github.io&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;打印进程内核栈&quot;&gt;打印进程内核栈&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;回到问题的原点，对于此问题，我能确定的资料只有稳定复现的环境和不知道什么时候会触发 write system call 延迟的 jar 包。&lt;/p&gt;
&lt;p&gt;考虑到 write system call 被阻塞可长达几百 ms，我想我能抓出当前进程的内核栈来看一下 write system call 此时被阻塞在什么位置。&lt;/p&gt;
&lt;p&gt;具体步骤为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;多个线程不便于抓内核栈，先将程序修改为单线程定量写入。&lt;/li&gt;
&lt;li&gt;使用 jar 包启动一个进程，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ps&lt;/code&gt; 拿到进程号。&lt;/li&gt;
&lt;li&gt;再通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;top -H -p pid&lt;/code&gt; 拿到占用 cpu、内存等资源最多的线程 ID，或使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;strace&lt;/code&gt; 启动，查看其输出里正在写入的线程 ID。&lt;/li&gt;
&lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;watch&lt;/code&gt; 命令搭配 &lt;code class=&quot;highlighter-rouge&quot;&gt;pstack&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;cat /proc/pid/stack&lt;/code&gt; 不停打印进程内核栈。具体命令为 &lt;code class=&quot;highlighter-rouge&quot;&gt;watch -n 0.1 &quot;date +%s &amp;gt;&amp;gt; stack.log;cat /proc/pid/stack &amp;gt;&amp;gt; stack.log&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找到 write system call 被阻塞时的时间戳，在 stack.log 里查看当时的进程内核栈。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可稳定收集到 write system call 被阻塞时，进程内核栈为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;   [&amp;lt;ffffffff812e31f4&amp;gt;] call_rwsem_down_read_failed+0x14/0x30
        [&amp;lt;ffffffffa0195854&amp;gt;] ext4_da_get_block_prep+0x1a4/0x4b0 [ext4]
        [&amp;lt;ffffffff811fbe17&amp;gt;] __block_write_begin+0x1a7/0x490
        [&amp;lt;ffffffffa019b71c&amp;gt;] ext4_da_write_begin+0x15c/0x340 [ext4]
        [&amp;lt;ffffffff8115685e&amp;gt;] generic_file_buffered_write+0x11e/0x290
        [&amp;lt;ffffffff811589c5&amp;gt;] __generic_file_aio_write+0x1d5/0x3e0
        [&amp;lt;ffffffff81158c2d&amp;gt;] generic_file_aio_write+0x5d/0xc0
        [&amp;lt;ffffffffa0190b75&amp;gt;] ext4_file_write+0xb5/0x460 [ext4]
        [&amp;lt;ffffffff811c64cd&amp;gt;] do_sync_write+0x8d/0xd0
        [&amp;lt;ffffffff811c6c6d&amp;gt;] vfs_write+0xbd/0x1e0
        [&amp;lt;ffffffff811c76b8&amp;gt;] SyS_write+0x58/0xb0
        [&amp;lt;ffffffff81614a29&amp;gt;] system_call_fastpath+0x16/0x1b
        [&amp;lt;ffffffffffffffff&amp;gt;] 0xffffffffffffffff
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;内核栈分析&quot;&gt;内核栈分析&lt;/h2&gt;
&lt;hr/&gt;&lt;h4 id=&quot;write-system-call-阻塞位置&quot;&gt;write system call 阻塞位置&lt;/h4&gt;
&lt;p&gt;通过内核栈函数关键字找到了 OenHan 大神的博客，&lt;a href=&quot;http://oenhan.com/rwsem-realtime-task-hung&quot;&gt;读写信号量与实时进程阻塞挂死问题&lt;/a&gt; 这篇文章描述的问题虽然跟我遇到的问题不同，但进程内核栈的分析对我很有启发。为了便于分析内核函数，我 clone 了一份 linux 3.10.0 的源码，在本地查看。&lt;/p&gt;
&lt;p&gt;搜索源码可以证实，栈顶的汇编函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRY call_rwsem_down_read_failed&lt;/code&gt; 会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rwsem_down_read_failed()&lt;/code&gt;, 而此函数会一直阻塞在获取 inode 的锁。&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct &lt;span class=&quot;n&quot;&gt;rw_semaphore &lt;span class=&quot;n&quot;&gt;__sched &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;nf&quot;&gt;rwsem_down_read_failed&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;k&quot;&gt;struct &lt;span class=&quot;n&quot;&gt;rw_semaphore &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;sem&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;p&quot;&gt;{
        &lt;span class=&quot;p&quot;&gt;.....
        &lt;span class=&quot;cm&quot;&gt;/* wait to be given the lock */
        &lt;span class=&quot;k&quot;&gt;while &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;nb&quot;&gt;true&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;p&quot;&gt;{
                &lt;span class=&quot;n&quot;&gt;set_task_state&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;tsk&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;TASK_UNINTERRUPTIBLE&lt;span class=&quot;p&quot;&gt;);
                &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;o&quot;&gt;!&lt;span class=&quot;n&quot;&gt;waiter&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;task&lt;span class=&quot;p&quot;&gt;)
                        &lt;span class=&quot;k&quot;&gt;break&lt;span class=&quot;p&quot;&gt;;
                &lt;span class=&quot;n&quot;&gt;schedule&lt;span class=&quot;p&quot;&gt;();
        &lt;span class=&quot;p&quot;&gt;}

        &lt;span class=&quot;n&quot;&gt;tsk&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;span class=&quot;n&quot;&gt;state &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;TASK_RUNNING&lt;span class=&quot;p&quot;&gt;;

        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;sem&lt;span class=&quot;p&quot;&gt;;
&lt;span class=&quot;p&quot;&gt;}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;延迟分配&quot;&gt;延迟分配&lt;/h4&gt;
&lt;p&gt;知道了 write system call 阻塞的位置，还要查它会什么会阻塞在这里。这时，栈顶的函数名 &lt;code class=&quot;highlighter-rouge&quot;&gt;call_rwsem_down_read_failed&lt;/code&gt; 让我觉得很奇怪，这不是 “write” system call 么，为什么会 &lt;code class=&quot;highlighter-rouge&quot;&gt;down_read_failed&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;直接搜索这个函数没有什么资料，但向栈底方向，再搜索其他函数就有了线索了，原来这是在做系统磁盘块的准备，于是就牵扯出了 ext4 的 delayed allocation 特性。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;延迟分配(delayed allocation)：ext4 文件系统在应用程序调用 write system call 时并不为缓存页面分配对应的物理磁盘块，当文件的缓存页面真正要被刷新至磁盘中时，才会为所有未分配物理磁盘块的页面缓存分配尽量连续的磁盘块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一特性，可以避免磁盘的碎片化，也可以避免存活时间极短文件的磁盘块分配，能很大提升系统文件 I/O 性能。&lt;/p&gt;
&lt;p&gt;而在 write 向内存页时，就需要查询这些内存页是否已经分配了磁盘块，然后给未分配的脏页打上延迟分配的标签（写入的详细过程可以查看 &lt;a href=&quot;https://blog.csdn.net/kai_ding/article/details/9914629&quot;&gt;ext4 的延迟分配&lt;/a&gt;）。此时需要获取此 inode 的读锁，若出现锁冲突，write system call 便会 hang 住。&lt;/p&gt;
&lt;p&gt;在挂载磁盘时使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-o nodelalloc&lt;/code&gt; 选项禁用掉延迟分配特性后再进行测试，发现 write system call 被阻塞的情况确实消失了，证明问题确定跟延迟分配有关。&lt;/p&gt;
&lt;h2 id=&quot;不算结论的结论&quot;&gt;不算结论的结论&lt;/h2&gt;
&lt;hr/&gt;&lt;h4 id=&quot;寻找写锁&quot;&gt;寻找写锁&lt;/h4&gt;
&lt;p&gt;知道了 write system call 阻塞在获取读锁，那么一定是内核里有哪些地方持有了写锁。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ipcs&lt;/code&gt; 命令可以查看系统内核此时的进程间通信设施的状态，它打印的项目包括消息列表(-q)、共享内存(-m)和信号量(-q)的信息，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ipcs -q&lt;/code&gt; 打印内核栈的函数查看 write system call 被阻塞时的信号量，却没有输出任何信息。 仔细想了一下发现其写锁 &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data_sem&lt;/code&gt; 是一把读写锁，而信号量是一种 &lt;code class=&quot;highlighter-rouge&quot;&gt;非0即1&lt;/code&gt; 的PV量，虽然名字里带有 &lt;code class=&quot;highlighter-rouge&quot;&gt;sem&lt;/code&gt;，可它并不是用信号量实现的。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;perf lock&lt;/code&gt; 可以用来分析系统内核的锁信息，但要使用它需要重新编译内核，添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;CONFIG_LOCKDEP、CONFIG_LOCK_STAT&lt;/code&gt; 选项。先不说我们测试机的重启需要建提案等两天，编译完能不能启动得来我真的没有信心，第一次试图使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; 分析 linux 性能问题就这么折戟了。&lt;/p&gt;
&lt;h4 id=&quot;转变方法&quot;&gt;转变方法&lt;/h4&gt;
&lt;p&gt;问题又卡住了，这时我也没有太多办法了，现在开始研究 linux 文件系统源码是来不及了，但我还可以问。&lt;/p&gt;
&lt;p&gt;在 stackOverflow 上问没人理我：&lt;a href=&quot;https://stackoverflow.com/questions/52778498/how-metadata-journal-stalls-write-system-call&quot;&gt;how metadata journal stalls write system call?&lt;/a&gt;， 追着 OenHan 问了几次也没有什么结论：&lt;a href=&quot;http://oenhan.com/linux-kernel-write#comment-201&quot;&gt;Linux内核写文件流程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;虽然自己没法测试 upstream linux，还是在 kernel bugzilla 上发了个帖子：&lt;a href=&quot;https://bugzilla.kernel.org/show_bug.cgi?id=201461&quot;&gt;ext4 journal stalls write system call&lt;/a&gt;。终于有内核大佬回复我：在 &lt;code class=&quot;highlighter-rouge&quot;&gt;ext4_map_blocks()&lt;/code&gt; 函数中进行磁盘块分配时内核会持有写锁。&lt;/p&gt;
&lt;p&gt;查看了源码里的函数详情，证实了这一结论：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * The ext4_map_blocks() function tries to look up the requested blocks,
 * and returns if the blocks are already mapped.
 *
 * Otherwise it takes the write lock of the i_data_sem and allocate blocks
 * and store the allocated blocks in the result buffer head and mark it
 * mapped.
*/
&lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;nf&quot;&gt;ext4_map_blocks&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;handle_t &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;handle&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;k&quot;&gt;struct &lt;span class=&quot;n&quot;&gt;inode &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;inode&lt;span class=&quot;p&quot;&gt;,
                    &lt;span class=&quot;k&quot;&gt;struct &lt;span class=&quot;n&quot;&gt;ext4_map_blocks &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;map&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;flags&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;p&quot;&gt;{
&lt;span class=&quot;p&quot;&gt;.....
        &lt;span class=&quot;cm&quot;&gt;/*
         * New blocks allocate and/or writing to uninitialized extent
         * will possibly result in updating i_data, so we take
         * the write lock of i_data_sem, and call get_blocks()
         * with create == 1 flag.
         */
        &lt;span class=&quot;n&quot;&gt;down_write&lt;span class=&quot;p&quot;&gt;((&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;span class=&quot;n&quot;&gt;EXT4_I&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;inode&lt;span class=&quot;p&quot;&gt;)&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;span class=&quot;n&quot;&gt;i_data_sem&lt;span class=&quot;p&quot;&gt;));
&lt;span class=&quot;p&quot;&gt;.....
&lt;span class=&quot;p&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;但又是哪里引用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ext4_map_blocks()&lt;/code&gt; 函数，长时间获取了写锁呢？再追问时大佬已经颇有些无奈了，linux 3.10.0 的 release 已经是 &lt;code class=&quot;highlighter-rouge&quot;&gt;5年&lt;/code&gt; 前了，当时肯定也有一堆 bug 和缺陷，到现在已经发生了很大变动，追查这个问题可能并没有很大的意义了，我只好识趣停止了。&lt;/p&gt;
&lt;h4 id=&quot;推论&quot;&gt;推论&lt;/h4&gt;
&lt;p&gt;其实再向下查这个问题对我来说也没有太大意义了，缺少对源码理解的积累，再看太多的资料也没有什么收益。就如向建筑师向小孩子讲建筑设计，知道窗子要朝南，大门要靠近电梯这些知识并无意义，不了解建筑设计的原则，只专注于一些自己可以推导出来的理论点，根本没办法吸收到其中精髓。&lt;/p&gt;
&lt;p&gt;那么只好走到最后一步，根据查到的资料和测试现象对问题原因做出推论，虽然没有直接证据，但肯定跟这些因素有关。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在 ext4 文件系统下，默认为 ordered journal 模式，所以写 metadata journal 可能会迫使脏页刷盘， 而在 ext4 启用 delayed allocation 特性时，脏页可能在落盘时发现没有分配对应的磁盘块而分配磁盘块。在脏页太多的情况下，分配磁盘块慢时会持有 inode 的写锁时间过长，阻塞了 write 系统调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;追求知识的每一步或多或少都有其中意义，查这个问题就迫使我读了很多外语文献，也了解了一部分文件系统设计思想。&lt;/p&gt;
&lt;p&gt;linux 真的是博大精深，希望有一天我也能对此有所贡献。&lt;/p&gt;
&lt;p&gt;关于本文有什么疑问可以在下面留言交流，如果您觉得本文对您有帮助，欢迎关注我的 &lt;a href=&quot;https://weibo.com/u/5715965217&quot;&gt;微博&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/zhenbianshu/&quot;&gt;GitHub&lt;/a&gt; 。您也可以在我的 &lt;a href=&quot;https://github.com/zhenbianshu/zhenbianshu.github.io&quot;&gt;博客REPO&lt;/a&gt; 右上角点击 &lt;code class=&quot;highlighter-rouge&quot;&gt;Watch&lt;/code&gt; 并选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;Releases only&lt;/code&gt; 项来 &lt;code class=&quot;highlighter-rouge&quot;&gt;订阅&lt;/code&gt; 我的博客，有新文章发布会第一时间通知您。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 11:49:00 +0000</pubDate>
<dc:creator>枕边书</dc:creator>
<og:description>再启 接上文 从应用到内核查接口超时（中），查到是因为 journal 导致 write 系统调用被阻塞进而导致超时后，总感觉证据还不够充分，没有一个完美的交待。而且 leader 还想着让</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenbianshu/p/10192480.html</dc:identifier>
</item>
<item>
<title>柯里化函数的实现 - 前端菜鸟111</title>
<link>http://www.cnblogs.com/kdcg/p/10192421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kdcg/p/10192421.html</guid>
<description>&lt;p&gt;记录柯里化函数实现的学习过程:&lt;/p&gt;
&lt;p&gt;柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。&lt;/p&gt;
&lt;p&gt;如果要实现下面这个方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
add(2)(1, 3, 4)(2, 3)(3)(4, 6)(7, 98)() // 133
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个函数当参数为空的时候执行了内部参数所有值的相加，所以我们应该考虑当参数不为空的时候将缓存起来，在为空的时候再相加，这样的思路会用闭包的方式来实现。下面是实现方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function add () {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用来缓存所有的arguments值  &lt;/span&gt;
  let args =&lt;span&gt; [].slice.call(arguments);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建currying函数实现柯里化  &lt;/span&gt;
  let currying =&lt;span&gt; function () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果参数为空，那么递归停止，返回执行结果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (arguments.length === &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; args.reduce((a, b) =&amp;gt; a +&lt;span&gt; b);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则将参数保存到args里面，返回currying方法&lt;/span&gt;
&lt;span&gt;      args.push(...arguments);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currying
    }      
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currying
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
add(2)(1, 3, 4)(2, 3)(3)(4, 6)(7, 98)() // 133
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面有需要注意的一点，因为currying函数里面使用arguments，所以currying不能使用箭头函数，箭头函数内部的arguments的用法与箭头函数内部的this差不多，它取的是上一级函数的arguments值。如果想用箭头函数，currying函数可以这样改动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  let currying = (...rest) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果参数为空，那么递归停止，返回执行结果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (rest.length === 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; args.reduce((a, b) =&amp;gt; a +&lt;span&gt; b);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则将参数保存到args里面，返回currying方法&lt;/span&gt;
&lt;span&gt;      args.push(...rest);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currying
    }      
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们返回的currying函数还可以使用callee来实现，原理相同，单数严格模式下不能使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; add () {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用来缓存所有的arguments值  &lt;/span&gt;
  let args =&lt;span&gt; [].slice.call(arguments);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建currying函数实现柯里化  &lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果参数为空，那么递归停止，返回执行结果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (arguments.length === 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; args.reduce((a, b) =&amp;gt; a +&lt;span&gt; b);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则将参数保存到args里面，返回currying方法&lt;/span&gt;
&lt;span&gt;      args.push(...arguments);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arguments.callee
    }      
  }
}
add(&lt;/span&gt;2)(1, 3, 4)(2, 3)(3)(4, 6)(7, 98)() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 133&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对普通函数进行柯里化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 柯里化函数的构造方法&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; curry (fn) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓存除第一个参数的所有参数&lt;/span&gt;
  let args = [].slice.call(arguments, 1&lt;span&gt;);  
  let _fn &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arguments.length === 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      args.push(...arguments);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _fn
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _fn
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; add () {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [].reduce.call(arguments, (a, b) =&amp;gt; a +&lt;span&gt; b)
}
console.log(curry(add, &lt;/span&gt;2)(1, 3, 4)(2, 3)(3)(4, 6)(7, 98)()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 133&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例柯里化函数思想实现的场景：&lt;/p&gt;
&lt;p&gt;如减少重复传递的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; simpleURL(protocol, domain, path) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; protocol + &quot;://&quot; + domain + &quot;/&quot; +&lt;span&gt; path;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们使用的时候将会这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; myurl = simpleURL('http', 'mysite', 'home.html'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myurl2 = simpleURL('http', 'mysite', 'aboutme.html');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以用柯里化的思想改写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; curry (fn) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓存除第一个参数的所有参数&lt;/span&gt;
  let args = [].slice.call(arguments, 1&lt;span&gt;);  
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args.concat(...arguments))
  }
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 避免每次调用重复传参&lt;/span&gt;
let myURL1 = curry(simpleURL, 'https', 'mysite'&lt;span&gt;);
let res1 &lt;/span&gt;= myURL1('home.html');    &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
console.log(res1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://mysite/home.html&lt;/span&gt;
&lt;span&gt;
let myURL2 &lt;/span&gt;= curry(simpleURL, 'http', 'mysite'&lt;span&gt;);
let res2 &lt;/span&gt;= myURL2('aboutme.html');    &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
console.log(res2);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;http://mysite/aboutme.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 28 Dec 2018 11:24:00 +0000</pubDate>
<dc:creator>前端菜鸟111</dc:creator>
<og:description>记录柯里化函数实现的学习过程: 柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kdcg/p/10192421.html</dc:identifier>
</item>
</channel>
</rss>