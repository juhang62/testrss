<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>（30天）构建直播平台~第一版 - 易烊天骐</title>
<link>http://www.cnblogs.com/menghuiyuan/p/live.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/menghuiyuan/p/live.html</guid>
<description>&lt;p&gt;&lt;span&gt;软件地址：http://www.fmpan.com/s/c7xanekb&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直播推流地址从直播站PC端获取，步骤：1、注册  2、登录  3、申请直播&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170228/201901/1170228-20190129223450890-74941583.jpg&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;579&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、电脑端（延迟3~5秒）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　地址（本来是用域名的，备案出现了小问题）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　http://47.105.121.64/live&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.1、播放页面&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170228/201901/1170228-20190129224424314-1986597346.jpg&quot; alt=&quot;&quot; width=&quot;1091&quot; height=&quot;487&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、手机端（延迟10秒+）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在pc端观看直播页面扫码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1、播放页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170228/201901/1170228-20190129225252521-1768626066.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;951&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1、厂商：某某云&lt;/p&gt;
&lt;p&gt;2、系统：CentOS  6.8 64位&lt;/p&gt;
&lt;p&gt;3、配置：&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;CPU：&lt;span class=&quot;ng-binding&quot;&gt;1核    &lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;内存： &lt;span class=&quot;ng-binding&quot;&gt;2 GB    &lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;带宽： &lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span&gt;1Mbps    磁盘： &lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;40GB&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170228/201901/1170228-20190130004904880-1613582944.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、Nginx1.12 + nginx-rtmp-module&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.1、基础软件环境&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yum install -y gcc gcc-c++ autoconf wget&lt;/span&gt;&lt;br/&gt;&lt;span&gt;yum -y install wget gcc-c++ ncurses ncurses-devel cmake make perl bison openssl openssl-devel gcc* libxml2 libxml2-devel curl-devel libjpeg* libpng* freetype*&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.2、安装openssl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　openssl官网：http://www.openssl.org/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　#tar -zxvf openssl-1.0.1i.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　#cd openssl-1.0.1i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　#./config --prefix=/usr/local/openssl-1.0.1i    #prefix指定安装目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make install&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.3、安装pcre&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　pcre官网：http://www.pcre.org/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　安装版本：pcre-8.35.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　#tar -zxf pcre-8.35.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　#cd pcre-8.35&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　./configure --prefix=/usr/local/pcre-8.35 #prefix指定安装目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make install&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.4、安装zlib&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　zlib官网：http://www.zlib.net/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　安装版本：zlib-1.2.8.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　#tar -zxf zlib-1.2.8.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　#cd zlib-1.2.8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　./configure --prefix=/usr/local/zlib-1.2.8 #prefix指定安装目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make install&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.5、下载nginx-rtmp-module&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　nginx-rtmp-module的官方github地址：https://github.com/arut/nginx-rtmp-module&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.6、安装Nginx&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　./configure --prefix=/usr/local/nginx  --with-openssl=/usr/local/src/openssl --with-pcre=/usr/local/src/pcre  --with-zlib=/usr/local/src/zlib --add-module=/usr/local/src/nginx-rtmp-module --with-http_ssl_module&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;--源码目录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make install&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.7、Nginx配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　vi /usr/local/nginx/conf/nginx.conf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　加入以下内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　rtmp {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　server {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　listen 1935; #监听的端口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　chunk_size 4096;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　application hls { #rtmp推流请求路径&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　live on;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　hls on;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　hls_path /usr/share/nginx/html/hls;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　hls_fragment 5s;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　} &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　} &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　hls_path需要可读可写的权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　修改http中的server模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　server {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　listen       80;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　server_name  localhost;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　#charset koi8-r;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　#access_log  logs/host.access.log  main;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　location / {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　root   /usr/share/nginx/html;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　index  index.html index.htm;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　#error_page  404              /404.html;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　# redirect server error pages to the static page /50x.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　error_page   500 502 503 504  /50x.html;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　location = /50x.html {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　root   html;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　#手机端播放使用苹果的直播流协议（延迟很严重）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　location /hls {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　types {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　application/vnd.apple.mpegurl m3u8;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　video/mp2t ts;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　alias /data/live/hls/;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　expires -1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　add_header Cache-Control no-cache;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　然后启动nginx:&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2、Resin4.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下载、解压 resin：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　wget http://caucho.com/download/resin-pro-4.0.48.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　tar xzf resin-pro-4.0.48.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　编译、安装：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　cd resin-pro-4.0.48&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　./configure --prefix=/usr/local/resin4 --with-java-home=/usr/local/jdk --enable-64bit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　make install&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　启动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　./bin resin.sh start&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　访问：localhost:8080&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、mysql5.7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下载：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　创建mysql用户组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　groupadd mysql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　useradd -r -g mysql mysql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　创建文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　mkdir /usr/local/mysql/data&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　更改mysql目录下所有的目录及文件夹所属组合用户&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　cd /usr/local/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　chown -R mysql:mysql mysql/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　chmod -R 755 mysql/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　编译安装并初始化mysql，记住命令行末尾的密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　/usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　启动mysql服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　/usr/local/mysql/support-files/mysql.server start&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　登录msyql，输入密码（密码刚刚初始化生成的密码）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　mysql -u root -p&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　修改密码并开放远程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　msql&amp;gt;alter user 'root'@'localhost'identified by '123456'; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　mysql&amp;gt;use mysql;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　msyql&amp;gt;update user setuser.Host='%'whereuser.User='root'; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　mysql&amp;gt;flush privileges; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　mysql&amp;gt;quit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、Redis5.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　安装：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　wget http://download.redis.io/releases/redis-5.0.3.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　tar xzf redis-5.0.3.tar.gz&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　cd redis-5.0.3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　make&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　编辑redis.conf 文件，设置后台运行：daemonize yes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　启动服务：./redis-server&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、jdk1.8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下载安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　jdk-版本号.tar.gz解压到/usr/local/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　vi /etc/profile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　最后一行添加如下内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　export JAVA_HOME=/usr/local/jdk-版本号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　export PATH=$PATH:$JAVA_HOME/bin&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　export CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/rt.jar&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　然后esc，输入:x,保存退出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　然后需要设置让更改生效：source /etc/profile&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span&gt;&lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;&lt;span&gt;1、内网项目&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span&gt;&lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;&lt;span&gt;　　直播的核心服务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;　　由于时间太少  系统尚未拆分成模块系统&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;2、外网项目&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;　　live_pc（电脑端页面）、live_h5（手机端页面）、spring-socket（即时通讯）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;3、项目使用到第三方软件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;　　spring-boot、spring-socket、spring-mvc、redisson-all-3.9、spring-thymeleaf......&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;　　mui+h5（手机端）、videojs（播放直播流）......&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i2.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i3.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;span class=&quot; text-muted&quot; data-spm-anchor-id=&quot;5176.2020520101.122.i4.63274df5pygjNh&quot;&gt;&lt;span class=&quot;ng-isolate-scope&quot;&gt;&lt;span class=&quot;nowrap ng-scope&quot;&gt;&lt;span data-spm-anchor-id=&quot;5176.2020520101.111.i0.63274df5pygjNh&quot;&gt;PS：缺少的项目（礼物系统、充值系统、消息队列系统、用户账户系统）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 29 Jan 2019 16:52:00 +0000</pubDate>
<dc:creator>易烊天骐</dc:creator>
<og:description>主播推流 软件地址：http://www.fmpan.com/s/c7xanekb 直播推流地址从直播站PC端获取，步骤：1、注册 2、登录 3、申请直播 直播站 1、电脑端（延迟3~5秒） 地址（本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/menghuiyuan/p/live.html</dc:identifier>
</item>
<item>
<title>数组初始化及赋值的方法，memset的使用 - yyzyyx</title>
<link>http://www.cnblogs.com/yyzyxy/p/10336480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyzyxy/p/10336480.html</guid>
<description>&lt;p&gt;1. 数组初始化：&lt;/p&gt;
&lt;p&gt;　　即定义时即赋值：&lt;/p&gt;
&lt;p&gt;　　int a[4]={0}; //每一个位置的int都为0&lt;/p&gt;
&lt;p&gt;　　int b[4]={1}; //只有第一个元素为1，其他都为0&lt;/p&gt;
&lt;p&gt;　　所以要想把数组初始化为其他值，则需要一个个的指定值： int b[4]={1,2,3,4};//比如指定为1，2，3，4&lt;/p&gt;
&lt;p&gt;　　或者先统一初始化为0，再利用for循环改变数组的每一个元素。&lt;/p&gt;
&lt;p&gt;2. 数组的赋值：&lt;/p&gt;
&lt;p&gt;　　在定义过后，需要给数组每一个元素赋值时，不能再像初始化那样： &lt;/p&gt;
&lt;p&gt;             a[4] = {1,3,5,7}; //这是错误的，&lt;/p&gt;
&lt;p&gt;             a={1,3,5,7};//这还是错的。&lt;/p&gt;
&lt;p&gt;　　只能利用for循环，或者利用memcpy从其他内存拷贝一份值过来。&lt;/p&gt;
&lt;p&gt;　　当使用完成后，局部数组会由函数自动释放，全局数组则需进行下清零。&lt;/p&gt;
&lt;p&gt;　　这时候就要用到memset函数。&lt;/p&gt;
&lt;p&gt;　　　　memset(a,0,sizeof(a));&lt;/p&gt;
&lt;p&gt;　　或者memset(a,0,sizeof(int)*4);   //sizeof取的是字节。  memset是按字节进行赋值的，这里为16个字节：4*4&lt;/p&gt;

&lt;p&gt;3. memset函数：memset(void *s, int ch,&lt;a href=&quot;https://baike.baidu.com/item/size_t&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;size_t&lt;/a&gt; n);    // C语言：#include &amp;lt;string.h&amp;gt; 或者 C++:  #include &amp;lt;cstring&amp;gt;&lt;/p&gt;
&lt;p&gt;一般只用来清零，或者初始化局部数组为0，以免出现局部数组的每一个元素为乱值。所以第二个参数一般为0或者-1.&lt;/p&gt;
&lt;p&gt;要注意：&lt;/p&gt;
&lt;p&gt;　　3.1 memset是按字节进行赋值，&lt;/p&gt;
&lt;p&gt;　　所以假设你想利用memset给a数组每一位置为1，memset(a,1,sizeof(a)); // 这时候你去打印a的每一位，值都是16843009，而非你期望的1&lt;/p&gt;
&lt;p&gt;        原因：int为四个字节，这时候每个字节被memset置为1，而每一个元素都是一个int，即 01 01 01 01，读取十六进制为 0x01010101，十进制为 16843009&lt;/p&gt;
&lt;p&gt;        不过 char类型的可以使用memset随意赋值为自己想要的，因为 char只占一个字节，赋多少就是多少。&lt;/p&gt;
&lt;p&gt;　　 e.g.:&lt;/p&gt;
&lt;p&gt;                char a[3]={'a' , 'b', 'c'};&lt;/p&gt;
&lt;p&gt;                memset(a, 1,sizeof(a));&lt;/p&gt;
&lt;p&gt;　　　　  for(int i=0;i&amp;lt;sizeof(a)/sizeof(a[0]);i++){&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;em id=&quot;__mceDel&quot;&gt;printf(&quot;a[%u]=[%u]\n&quot;,i,a[i]);                   //得到a[1]=1; a[2]=1; a[3]=1;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　　   }&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 29 Jan 2019 16:20:00 +0000</pubDate>
<dc:creator>yyzyyx</dc:creator>
<og:description>C++</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yyzyxy/p/10336480.html</dc:identifier>
</item>
<item>
<title>Linux必会必知 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/10336336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/10336336.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/01/29/kQXwss.jpg&quot; alt=&quot;kQXwss.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;Linux作为一个开源系统，被极客极力推崇，作为程序员不来了解一下，那就亏了&lt;/p&gt;
&lt;p&gt;Linux是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为Linux操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。只要遵循GNU通用公共许可证（GPL），任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。大多数Linux系统还包括像提供GUI的X Window之类的程序。除了一部分专家之外，大多数人都是直接使用Linux发行版，而不是自己选择每一样组件或自行设置。&lt;/p&gt;
&lt;h2 id=&quot;二分类&quot;&gt;二、分类&lt;/h2&gt;
&lt;p&gt;武林有纷争，门派有纷争。&lt;br/&gt;根据使用安装命令不同，一般来说著名的linux系统基本上分两大类：&lt;/p&gt;
&lt;h3 id=&quot;redhat系列redhatcentosfedora等&quot;&gt;1.RedHat系列：Redhat、Centos、Fedora等&lt;/h3&gt;
&lt;p&gt;常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数”&lt;/p&gt;
&lt;p&gt;包管理工具 yum&lt;/p&gt;
&lt;p&gt;支持tar包&lt;br/&gt;&lt;strong&gt;一般服务器用的centos&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;debian系列debianubuntu等&quot;&gt;2.Debian系列：Debian、Ubuntu等&lt;/h3&gt;
&lt;p&gt;常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数”&lt;/p&gt;
&lt;p&gt;包管理工具 apt-get&lt;/p&gt;
&lt;h2 id=&quot;三linux默认目录&quot;&gt;三、Linux默认目录&lt;/h2&gt;
&lt;p&gt;Linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录”/”，然后在此目录下在创建其他的目录。&lt;/p&gt;
&lt;p&gt;在Linux下目录的名称是可以自定义的，但某些特殊的目录名称包含有非常重要的功能，因此不建议更改目录的名称，以免造成错误，导致系统崩溃。在Linux安装时，系统会创建很多默认的目录，这些目录具有特殊的功能：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;Linux文件系统的上层根目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;/bin&lt;/td&gt;
&lt;td&gt;bin是binary的缩写。这个目录沿袭了UNIX系统的结构，存放着用户最经常使用的命令。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/boot&lt;/td&gt;
&lt;td&gt;操作系统启动时所需要的文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;/dev&lt;/td&gt;
&lt;td&gt;接口设备文件目录，如had表示硬盘。dev是device（设备）的缩写这个目录下是所有Linux的外部设备，其功能类似DOS下的.sys和Win下的.vxd。在Linux中设备和文件使用同种方法访问的（即设备也作为文件访问，降低编程的复杂度）。例如，/dev/hda代表第一个物理IDE硬盘。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/etc&lt;/td&gt;
&lt;td&gt;这个目录用来存放系统管理所需要的配置文件和子目录。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;一般用户的主目录或FTP站点目录。比如有个用户名为wang，那他的主目录就是/home/wang也可用~wang来表示&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/mnt&lt;/td&gt;
&lt;td&gt;装载的文件系统挂载点。例如光驱、软盘等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;/proc&lt;/td&gt;
&lt;td&gt;这个目录是一个虚拟的目录，它是系统内存的映射，所以这个目录的内容不是在硬盘上而是在内存里。用户可以通过直接访问这个目录来获取系统信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;/root&lt;/td&gt;
&lt;td&gt;管理员的主目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/sbin&lt;/td&gt;
&lt;td&gt;此目录存放系统启动时所需执行的程序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/tmp&lt;/td&gt;
&lt;td&gt;用来存放一些临时文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/usr&lt;/td&gt;
&lt;td&gt;存放用户使用的系统命令和应用程序等信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;/lib&lt;/td&gt;
&lt;td&gt;这个目录里存放着系统最基本的动态链接共享库，其作用类似于windows里的.dll文件。几乎所有的应用程序都需要用到这些共享库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/lost+found&lt;/td&gt;
&lt;td&gt;这个目录平时是空的，当系统不正常关机后，这里就存放恢复的文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/var&lt;/td&gt;
&lt;td&gt;具变动性质的相关程序目录，例如log文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;支持tar包&lt;/p&gt;
&lt;h2 id=&quot;四常用命令&quot;&gt;四、常用命令&lt;/h2&gt;
&lt;h2 id=&quot;打开文件&quot;&gt;打开文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cd&lt;/code&gt;命令&lt;/p&gt;
&lt;h3 id=&quot;返回主目录&quot;&gt;返回主目录&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cd ./&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/16899ff9f8d00265?w=333&amp;amp;h=51&amp;amp;f=png&amp;amp;s=3207&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;返回上一个目录&quot;&gt;返回上一个目录&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cd ..&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/16899ffc572c10f2?w=333&amp;amp;h=51&amp;amp;f=png&amp;amp;s=3207&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;进入目标目录&quot;&gt;进入目标目录&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cd /usr&lt;/code&gt;&lt;br/&gt;ps: 用绝对路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/16899ffe07ebc121?w=281&amp;amp;h=45&amp;amp;f=png&amp;amp;s=3320&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新建文件&quot;&gt;新建文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mkdir 文件名&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;显示文件&quot;&gt;显示文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ll 或者ls&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;结合-mkdir-ll命令&quot;&gt;结合 mkdir ll命令&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/1689a0003d0ae0a0?w=488&amp;amp;h=75&amp;amp;f=png&amp;amp;s=8318&quot;/&gt;&lt;br/&gt;发现已经创建a文件&lt;/p&gt;
&lt;h2 id=&quot;删除文件&quot;&gt;删除文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rm&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;不需要询问式删除&quot;&gt;不需要询问式删除&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rm -rf 文件名&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/1689a0025f549975?w=520&amp;amp;h=74&amp;amp;f=png&amp;amp;s=7736&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用丑的记事本&quot;&gt;使用丑的记事本&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/1689a0045919142e?w=377&amp;amp;h=169&amp;amp;f=png&amp;amp;s=8979&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用帅的记事本&quot;&gt;使用帅的记事本&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vim&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/1689a0072a9cc370?w=433&amp;amp;h=145&amp;amp;f=png&amp;amp;s=8724&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;查看文件内容&quot;&gt;查看文件内容&lt;/h2&gt;
&lt;h3 id=&quot;没有实时性&quot;&gt;没有实时性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/1689a008f9a5f866?w=491&amp;amp;h=122&amp;amp;f=png&amp;amp;s=10724&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实时性&quot;&gt;实时性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tail -f&lt;/code&gt;&lt;br/&gt;如果有输出会实时加载&lt;/p&gt;
&lt;h2 id=&quot;linux的任务管理器&quot;&gt;Linux的任务管理器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;top&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/1689a0173af3f9b1?w=554&amp;amp;h=53&amp;amp;f=png&amp;amp;s=30560&quot;/&gt;&lt;br/&gt;&lt;code&gt;pid 表示进程的id&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;结束任务&quot;&gt;结束任务&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Kill -9 对应pid&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;查看目标的pid&quot;&gt;查看目标的pid&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ps -ef|grep java&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/1689a018dbab70c0?w=554&amp;amp;h=53&amp;amp;f=png&amp;amp;s=30560&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;匹配工具&quot;&gt;匹配工具&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;grep&lt;/code&gt;&lt;br/&gt;寻找文件&lt;br/&gt;&lt;code&gt;find ./ -name 文件名&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/1689a028ea9681a0?w=465&amp;amp;h=57&amp;amp;f=png&amp;amp;s=6447&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五参考&quot;&gt;五、参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Linux&quot;&gt;维基百科Linux&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.51cto.com/494981/1383655&quot; class=&quot;uri&quot;&gt;http://blog.51cto.com/494981/1383655&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/yoeen/article/details/6765949&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/yoeen/article/details/6765949&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>一、前言 Linux作为一个开源系统，被极客极力推崇，作为程序员不来了解一下，那就亏了 Linux是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenzhuantou/p/10336336.html</dc:identifier>
</item>
<item>
<title>Spring Boot微服务如何集成fescar解决分布式事务问题？ - Scott Lewis</title>
<link>http://www.cnblogs.com/DKSL/p/fescar.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DKSL/p/fescar.html</guid>
<description>&lt;h3&gt;什么是fescar?&lt;/h3&gt;
&lt;p&gt;　　关于fescar的详细介绍，请参阅&lt;a href=&quot;https://github.com/alibaba/fescar/wiki/%E6%A6%82%E8%A7%88&quot; target=&quot;_blank&quot;&gt;fescar wiki&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/434643/201901/434643-20190129220547876-2116362323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　传统的2PC提交协议，会持有一个全局性的锁，所有局部事务预提交成功后一起提交，或有一个局部事务预提交失败后一起回滚，最后释放全局锁。锁持有的时间较长，会对并发造成较大的影响，死锁的风险也较高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/434643/201901/434643-20190129221741166-209668681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　fescar的创新之处在于，每个局部事务执行完立即提交，释放本地锁；它会去解析你代码中的sql，从数据库中获得事务提交前的事务资源即数据，存放到undo_log中，全局事务协调器在回滚的时候直接使用undo_log中的数据覆盖你提交的数据。&lt;/p&gt;
&lt;h3&gt;Spring Boot如何集成fescar?&lt;/h3&gt;
&lt;p&gt;　　我们可以从&lt;a href=&quot;https://github.com/alibaba/fescar&quot; target=&quot;_blank&quot;&gt;官方代码库&lt;/a&gt;中看到，fescar目前提供的示例是针对使用dubbo的服务，那Spring Boot的项目如何集成fescar呢？&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/434643/201901/434643-20190129222552483-1063912503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　和很多2PC提交协议（如&lt;a href=&quot;https://github.com/codingapi/tx-lcn&quot; target=&quot;_blank&quot;&gt;tx_lcn&lt;/a&gt;）的解决方案一样，fescar也是在数据源处做了代理，和事务协调器进行通信，来决定本地事务是否回滚。所以，第一步，在你的spring boot项目中，首先应使用fescar提供的代理数据源作为你的数据源，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
            DruidDataSource dataSource = initDataSource(dataSourceProps.get(&quot;url&quot;).toString(), dataSourceProps.get(&quot;username&quot;).toString(), dataSourceProps.get(&quot;password&quot;).toString());
            DataSourceProxy proxy = new DataSourceProxy(dataSource);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，你需要创建一个Feign拦截器，把RootContext中的XID（XID用于标识一个局部事务属于哪个全局事务，需要在调用链路的上下文中传递）传递到上层调用链路。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Component
public class RequestHeaderInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate template) {
        String xid = RootContext.getXID();
        if(StringUtils.isNotBlank(xid)){
            template.header(&quot;Fescar-Xid&quot;,xid);
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，你需要创建一个Http Rest请求拦截器，用于把当前上下文中获取到的XID放到RootContext。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import com.alibaba.fescar.core.context.RootContext;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class FescarXidFilter extends OncePerRequestFilter {
    protected Logger logger = LoggerFactory.getLogger(FescarXidFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String xid = RootContext.getXID();
        String restXid = request.getHeader(&quot;Fescar-Xid&quot;);
        boolean bind = false;
        if(StringUtils.isBlank(xid)&amp;amp;&amp;amp;StringUtils.isNotBlank(restXid)){
            RootContext.bind(restXid);
            bind = true;
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;bind[&quot; + restXid + &quot;] to RootContext&quot;);
            }
        }
        try{
            filterChain.doFilter(request, response);
        } finally {
            if (bind) {
                String unbindXid = RootContext.unbind();
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;unbind[&quot; + unbindXid + &quot;] from RootContext&quot;);
                }
                if (!restXid.equalsIgnoreCase(unbindXid)) {
                    logger.warn(&quot;xid in change during http rest from &quot; + restXid + &quot; to &quot; + unbindXid);
                    if (unbindXid != null) {
                        RootContext.bind(unbindXid);
                        logger.warn(&quot;bind [&quot; + unbindXid + &quot;] back to RootContext&quot;);
                    }
                }
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就完成了fescar的集成。&lt;/p&gt;
&lt;h3&gt;开始使用吧！&lt;/h3&gt;
&lt;p&gt;　　首先在项目中初始化两个Bean：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    @Bean
    public FescarXidFilter fescarXidFilter(){
        return new FescarXidFilter();
    }

    @Bean
    public GlobalTransactionScanner scanner(){
        GlobalTransactionScanner scanner = new GlobalTransactionScanner(&quot;fescar-test&quot;,&quot;my_test_tx_group&quot;);
        return scanner;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后写两个服务，服务A调用服务B，并在A服务的调用方法上打上@GlobalTransactional标签：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    @GlobalTransactional(timeoutMills = 300000, name = &quot;fescar-test-tx&quot;)
    public void testFescar() throws BusinessException {
        DictionVO dictionVO = new DictionVO();
        dictionVO.setCode(&quot;simidatest&quot;);
        dictionVO.setValue(&quot;1&quot;);
        dictionVO.setDesc(&quot;simidatest&quot;);
        dictionVO.setAppId(&quot;sso&quot;);
        commonService.createDiction(dictionVO);//远程调用服务B
        areaMapper.deleteAreaBySysNo(2);//本地事务

        throw new BusinessException(&quot;主动报错&quot;);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，两个项目中添加application.conf文件，用于告诉客户端如何与分布式协调器通信，官方示例中有这个文件，就不在此贴代码啦，&lt;a href=&quot;https://github.com/alibaba/fescar/blob/develop/examples/src/main/resources/application.conf&quot; target=&quot;_blank&quot;&gt;application.conf传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;启动事务协调器，&lt;span class=&quot;s1&quot;&gt;sh fescar-server.sh 8091 ~/dksl/git/fescar/data，启动你的项目，开始测试吧！&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;last thing&lt;/h3&gt;
&lt;p&gt;　　分布式事务作为微服务应用中的老大难问题，在现有的解决方案中，个人认为fescar是目前最轻量并且代价最小的一种解决方案。目前的版本，事务协调器还不能分布式部署，官方给出的路线图是在三月底会有第一个生产可用版本。让我们一起参与到fescar的社区中，共同推动fescar生态建设，让落地微服务不必再担心分布式事务的问题。&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 15:08:00 +0000</pubDate>
<dc:creator>Scott Lewis</dc:creator>
<og:description>什么是fescar? 关于fescar的详细介绍，请参阅fescar wiki。 传统的2PC提交协议，会持有一个全局性的锁，所有局部事务预提交成功后一起提交，或有一个局部事务预提交失败后一起回滚，最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DKSL/p/fescar.html</dc:identifier>
</item>
<item>
<title>Redis数据结构之简单动态字符串SDS - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/10335986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/10335986.html</guid>
<description>&lt;p&gt;Redis的底层数据结构非常多，其中包括SDS、ZipList、SkipList、LinkedList、HashTable、Intset等。如果你对Redis的理解还只停留在get、set的水平的话，是远远不足以应对面试提问的。本文简单介绍了Redis底层最重要的数据结构 - 简单动态字符串（SDS）&lt;/p&gt;
&lt;p&gt;Redis使用C语言开发，但并没有使用C语言传统的字符串表示（以空字符结尾的字节数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串的（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。&lt;/p&gt;
&lt;p&gt;在Redis里面，C字符串只会作为字符串字面量（static literal）用在一些无须对字符串值进行修改的地方。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串的键值对在底层都是由SDS实现的。&lt;/p&gt;
&lt;p&gt;咱们来举个例子，如果在客户端执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;redis&amp;gt; SET msg &quot;hello world&quot;
ok&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么Redis将在数据库中创建一个新的键值对，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的SDS。&lt;/li&gt;
&lt;li&gt;键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的。总之，SDS是Redis的最基础也是最重要的数据结构。&lt;/p&gt;
&lt;h2 id=&quot;sds的定义&quot;&gt;1.SDS的定义&lt;/h2&gt;
&lt;p&gt;每个 sds.h/sdshdr 结构表示一个SDS值：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct sdshdr{
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    
    // 记录buf数组中未使用字节的数量
    int free;
    //字节数组，用于保存字符串
    char buf[];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用一张图来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201901/1136672-20190125181258686-2024120115.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。&lt;/p&gt;
&lt;h2 id=&quot;sds与c字符串的区别&quot;&gt;2.SDS与C字符串的区别&lt;/h2&gt;
&lt;p&gt;现在来说，C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符“\0”。&lt;/p&gt;
&lt;p&gt;C的这种简单的字符串表达方式，并不能满足Redis对字符串在安全性、效率以及功能方面的要求。具体有以下几个方面。&lt;/p&gt;
&lt;h3 id=&quot;常数复杂度获取字符串长度&quot;&gt;2.1 常数复杂度获取字符串长度&lt;/h3&gt;
&lt;p&gt;因为C字符串并不记录字符串的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到空字符为止，这个操作的复杂度为O(n)。而在Redis的SDS中，这个时间复杂度只有O(1)。&lt;/p&gt;
&lt;h3 id=&quot;杜绝缓冲区溢出&quot;&gt;2.2 杜绝缓冲区溢出&lt;/h3&gt;
&lt;p&gt;除了获取字符串长度的复杂度高之外，C字符不记录自身长度带来的另一个问题就是缓冲区溢出。举个例子，C语言的 strcat 函数可以将字符串中的内容拼接到 dest 字符串的末尾，但是当字符串的容量不够就会产生缓存区溢出，因为字符串也是基于数组实现的，也是有大小限制的。&lt;/p&gt;
&lt;p&gt;Redis的SDS已经杜绝了这个问题，那它是如何解决的呢？&lt;/p&gt;
&lt;p&gt;当API要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的空间，如果不够的话，API会自动将SDS的空间进行扩容，然后才执行实际的修改操作。这就避免了缓冲区内存溢出。&lt;/p&gt;
&lt;h3 id=&quot;减少修改字符串时带来的内存重分配次数&quot;&gt;2.3 减少修改字符串时带来的内存重分配次数&lt;/h3&gt;
&lt;p&gt;上面说到了API会在修改SDS字符串时自动扩容，如果每次修改都伴随着对字符串内的数组的内存重分配，那效率可想而知。所以Redis实现了空间预分配和惰性空间释放两种优化策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间预分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的未使用空间。&lt;/p&gt;
&lt;p&gt;总的来说，额外分配的未使用空间数量大小有两种可能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果对SDS修改之后，SDS的长度将小于1MB，那么程序分配和len 属性同样大小的未使用空间，这时候SDS的 free 属性的值将和 len 属性的值相同。也就是说，该SDS字符串修改完后还有近一半的容量。&lt;/li&gt;
&lt;li&gt;如果对SDS修改之后，SDS的长度大于等于1MB，那么程序会分配1MB的未使用空间。这个是固定的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过空间预分配，Redis可以减少连续执行字符串操作所需的内存重分配次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;惰性空间释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用。&lt;/p&gt;
&lt;h3 id=&quot;二进制安全&quot;&gt;2.4 二进制安全&lt;/h3&gt;
&lt;p&gt;在C语言中，字符串的存储必须符合某种编码（ASCII），并且字符串不能包含空字符，否则会被认为是字符串结尾。这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。&lt;/p&gt;
&lt;p&gt;所以，为了解决C字符串的不足，Redis的 buf 数组保存的是二进制数据，这也就是把SDS的 buf 数组称为字节数组的原因。&lt;/p&gt;
&lt;h3 id=&quot;兼容部分c字符串函数&quot;&gt;2.5 兼容部分C字符串函数&lt;/h3&gt;
&lt;p&gt;虽然 Redis 的API都是二进制安全的，但它们一样遵循C字符串以空字符串结尾的惯例，这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分C的函数。&lt;/p&gt;
&lt;p&gt;举个例子， 如果我们有一个 SDS 的指针 s ， 那么我们可以直接使用 stdio.h/printf 函数， 通过执行以下语句：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;printf(&quot;%s&quot;, s-&amp;gt;buf);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来打印出 SDS 保存的字符串值 &lt;code&gt;&quot;Redis&quot;&lt;/code&gt; ， 而无须为 SDS 编写专门的打印函数。&lt;/p&gt;
&lt;p&gt;最后，临近春节，祝大家新年快乐！&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 13:49:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>Redis的底层数据结构非常多，其中包括SDS、ZipList、SkipList、LinkedList、HashTable、Intset等。如果你对Redis的理解还只停留在get、set的水平的话，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/10335986.html</dc:identifier>
</item>
<item>
<title>记录自己的一次面试  软件测试工程师的面试 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10335962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10335962.html</guid>
<description>&lt;p&gt;&lt;span&gt;10点刚到，先进行笔试，笔试的题目很基础，涉及到linux，涉及到oracle数据库，涉及编程基础，涉及测试理论，但是你读完题目和写完也要是花时间的。我花了40分钟左右的时间才写完。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Linux基础&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 查看a.txt文件中bbb字符串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;grep 'bbb' a.txt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 改变a.txt的所属者为Lisa&lt;/span&gt;&lt;br/&gt;&lt;span&gt;chown Lisa：Lisa a.txt&lt;/span&gt;&lt;br/&gt;&lt;span&gt;chown Lisa a.txt 【只让改所属者，没让改所属组】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.查看conrob进程的命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ps -ef | grep conrob&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.vi命令下，向上移动光标，向下移动光标&lt;/span&gt;&lt;br/&gt;&lt;span&gt;上下左右 kjhl【这四个键盘很好记，右手习惯的几个键，h最左右所以向左，l最右边，jk是先下后上】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.将文件a.txt排序生成b.txt&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sort a.txt &amp;gt;b.txt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. 不保存文件退出命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;末端模式下输入q！【Esc ： q！】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;7. 查找当前目录以及子目录下文件后缀是xxx的文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;find ./ -name *.xxx&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8. 显示日期的命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;date&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;Oracle基础&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【oracle数据库我好久没有遇到了，查询sql根据mysql和sqlserver写的，也不敢太用别名，怕错】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.给a表创建联合索引 name+bb+cc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;create index ind_name on tablea(name,bb,cc)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.赋予用户alex update delete a表的权限&lt;/span&gt;&lt;br/&gt;&lt;span&gt;grant update,delete on tablea to alex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.查看a表中的所有记录且姓名不在b表中的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from tablea where name not in (select distinct name from tableb) 【我想了想加了个distinct在b表中】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 查询b表中的唯一的卡号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select cardnum from tableb group by cardnum 【起初不小心加了distinct，然后想想把它给划了】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 查询b表中币种是RMB且地区是深圳的贷款总和&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select sum(amount) from tableb where city = 'shenzhen' and bizhong='RMB'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【起初没看到只要差RMB，还多此一举，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select bizhong， sum(amount) from where city = 'shenzhen' group by bizhong, 也不知道后来有没有多划掉】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. 复制b表的结构到新表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;create table tablec as select * from tableb where 1=2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【之前没印象，用的mysql格式CREATE TABLE 新表 LIKE 旧表 】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7. 查询b表中姓名和卡号，要求同一个卡号既有人民币消费，又有美金消费&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select name， cardnum from tableb group by name, cardnum having count(*) &amp;gt;=2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【我做这样的题目有各种疑问，比如消费金额为0的记录，算不算？虽然解决办法很简单，加上一个where amount&amp;gt; 0 即可，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是proc测试多了，一眼瞄过，对各个字段就不免想多了，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我10点钟才到，11点半吃饭，又怕做题太长，最终影响人家interviewer的情绪，也让我。。。】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.用一个select查询表表中姓名和卡号，要求美金中显示2条消费最大的记录，rmb中显示两条最大的记录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select name ， cardnum ,rownum from tableb where bizhong = 'dollor' and rownum&amp;lt;=2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;order by amount desc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;union all&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select name ， cardnum ,rownum from tableb where bizhong = 'rmb' and rownum&amp;lt;=2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;order by amount desc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;编程基础&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.java中==和equals的区别&lt;/span&gt;&lt;br/&gt;&lt;span&gt;==是表示值和内存地址完全一致&lt;/span&gt;&lt;br/&gt;&lt;span&gt;equals判断值是否相等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.一个java中能有多个类吗？为什么？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一个.java源文件中可以有多个类吗？（内部类除外）有什么条件？ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;可以的 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是只能有一个public类, 而且如果有public类的话，这个文件的名字要和这个类的名字一样。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果都没有public类，名字可以不和这个类一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.将x/y/z 从大到小输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int[] a ={x,y,z}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for (int i=0;i&amp;lt;a.length()-1;i++){&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for (int j=0;j&amp;lt;a.length()-1;j++){&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if (a[j]&amp;lt;a[j+1])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;temp =a[j];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a[j]=a[j+1];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a[j+1] = temp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;自己写错了，下面才是正确的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import org.testng.annotations.Test;

import java.util.Arrays;

public class TestSort {
    int a[] = {1, 2, 3, 4, 5, 6, 7};
    int temp;

    @Test(priority = 1, description = &quot;利用Arrays中的Sort函数排序&quot;)
    public void ArraysSort() {
        Arrays.sort(a);
        for (int i = 0; i &amp;lt; a.length; i++) {
            System.out.println(a[i]);
        }
    }


    @Test(priority = 2, description = &quot;冒泡排序&quot;)
    public void BuddleSort() {
        for (int i = 0; i &amp;lt; a.length - 1; i++) {
            for (int j = 0; j &amp;lt; a.length - 1 - i; j++) {
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }

    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. python2.1和python3.1的默认字符编码？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;'ascii'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;'utf-8'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;猜也能猜到，但我懒得写。python的确不熟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.python中分割aa_bb_cc,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;s1=&quot;aa_bb_cc&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;s1.split('_')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.如何用python将整型1输出为0001&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;测试的基础&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 软件测试的意义&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. bug的生命周期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 常见的测试方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4. 你常用的自动化测试工具？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;接口用Jmeter和httpClient&lt;/span&gt;&lt;br/&gt;&lt;span&gt;UI用 selenium和macaca&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5. 一个文本框，输入6的字符，要求输入的年份在199001到204912月，要求前四位是年，后两位是月，请设计测试用例并说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 写完给HR打电话，之后直接一面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面试的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 讲一个具体的接口，你是怎么测试的，怎么实现自动化的？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;针对http接口进行测试，使用Jmeter工具实现。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Jmter工具设计之初是用于做性能测试的，它在实现对各种接口的调用方面已经做的比较成熟，因此，本次直接使用Jmeter工具来完成对Http接口的测试。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一、开发接口测试案例的整体方案：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们起初会得到一个CR文档，CR文档里列出里客户此次的痛点和痒点，还有PM列出的解决方案。比如要开发什么接口，以达到什么目的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这种接口是一次性使用，做活动用的，还是日常使用等等的说明。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第一步：CR文档下来之后，我会分析出测试需求，大概知道会怎么实现，对对CR有疑问的地方，做下标记；等到下次全项目开会，提出疑问，确保测试、开发和PM对需求的理解是一致的。会议上也会阐述大概的实现方式，涉及的表，是否用触发器，等等的问题。会议之后可以拿到开发提供的接口说明文档；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第二步：从接口说明文档中整理出接口测试案例，里面要包括详细的入参和出参数据以及明确的格式和检查点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第三步：和开发一起对接口测试案例进行评审。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第四步：结合开发库，准备接口测试案例中的入参数据和出参数据，并整理成csv格式的文件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第五步：结合接口测试案例文档和csv格式的数据文档，做接口测试案例的自动化案例开发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于大一点的公司，用Jmeter编写自动化脚本，真的很low吧。我也觉得很low，但是不得不说完全够用，还极其容易上手。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对数据处理灵活，断言，数据落地，都可以查询和验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 端到端的测试你们做过吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 性能测试关注点是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们通常认为的规定的指标是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务器资源使用情况，不管是中间件服务器， 还是DB服务器，从内存，到CPU，不超过70%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从响应的结果来看，错误率不超过1%，甚至要求错误率更低；基本上实践当中，不超过0.1%;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平均响应时间不超过3秒，视查询条件而定，有的要求是不超过2秒； &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;90%的响应时间不超过3秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你们不看TPS吗？TPS知道吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也要看啊，我还没讲完呢。 每秒中的处理请求的数量啊~~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TPS是受木桶原理影响，要看每一处的配置的。【后悔没多说点，抬头对上interviewer的眼神，这个话题就完了】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 扯闲话部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你们公司的开发测试的比例是怎样的？我们是 4：1？ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你们公司系统的中间件是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性能测试中，你有进行性能调优吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;嗯，验证过很多接口，有的定量需求，比如要求某个接口的TPS达到500. 如果第一次性能测试，能达到500，也就够了，没有下文了；但是这个是注册接口，随着时间推移，DB服务器资源CPU到内存都吃的越来越紧，发现TPS下降了，之后越来越低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么原因造成的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DB服务器的原因。这个一个nosql数据库，以前这个接口是能达到500TPS的，但是随着微信绑定推出unionid后，需要增加新的字段，新的表；而这种DB对查询条件需要加索引，要不然不支持查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表中数据量越来越多，又有很多字段添加了索引，当数据量达到千万级别之后，添加索引消耗DB的资源，也明显感受到占用了时间。 导致接口查询慢，新增也慢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有别的调优吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有发现，若干个字段，因为没有加索引，导致查询接口TPS不高等问题；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;项目中有用hibernate的，有时候定位比较难，因为sql都是hibernate拼接的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 有没有自己创新什么工具，用来提高效率的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自己回答&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. oracle中分页怎么实现的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;oracle很久没用，打错了，我回答的是跟mysql差不多吧，用limit的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用limit？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后来发现用rownum&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. selenium在你们的测试过程中也用？还用吗？ 有没有什么问题？浏览器兼容性问题能做到吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;差不多就这么多了，接下来到面试者问问题时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总体感觉就是， 自己就像一个AI，面试官问什么，自己回答什么，没有做必要的延伸，没有引入自己的话题。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总体感觉就是面得不好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我想说我也可以开发自动化测试平台，只是还不太成熟。因为都是一个人做，时间和能力都有限，不知道用什么技术，架构，要增加什么。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 13:43:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>10点刚到，先进行笔试，笔试的题目很基础，涉及到linux，涉及到oracle数据库，涉及编程基础，涉及测试理论，但是你读完题目和写完也要是花时间的。我花了40分钟左右的时间才写完。。 Linux基础</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10335962.html</dc:identifier>
</item>
<item>
<title>Deep learning with Python 学习笔记（10） - 范中豪</title>
<link>http://www.cnblogs.com/zhhfan/p/10335907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhfan/p/10335907.html</guid>
<description>&lt;h2 id=&quot;生成式深度学习&quot;&gt;生成式深度学习&lt;/h2&gt;
&lt;p&gt;机器学习模型能够对图像、音乐和故事的统计&lt;strong&gt;潜在空间（latent space）&lt;/strong&gt;进行学习，然后从这个空间中&lt;strong&gt;采样（sample）&lt;/strong&gt;，创造出与模型在训练数据中所见到的艺术作品具有相似特征的新作品&lt;/p&gt;
&lt;h3 id=&quot;使用-lstm-生成文本&quot;&gt;使用 LSTM 生成文本&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;生成序列数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用深度学习生成序列数据的通用方法，就是使用前面的标记作为输入，训练一个网络（通常是循环神经网络或卷积神经网络）来预测序列中接下来的一个或多个标记。例如，给定输入the cat is on the ma，训练网络来预测目标 t，即下一个字符。与前面处理文本数据时一样，标记（token）通常是单词或字符，给定前面的标记，能够对下一个标记的概率进行建模的任何网络都叫作语言模型（language model）。语言模型能够捕捉到语言的潜在空间（latent space），即语言的统计结构&lt;/p&gt;
&lt;p&gt;一旦训练好了这样一个语言模型，就可以从中采样（sample，即生成新序列）。向模型中输入一个初始文本字符串［即条件数据（conditioning data）］，要求模型生成下一个字符或下一个单词（甚至可以同时生成多个标记），然后将生成的输出添加到输入数据中，并多次重复这一过程。这个循环可以生成任意长度的序列，这些序列反映了模型训练数据的结构，它们与人类书写的句子几乎相同&lt;/p&gt;
&lt;p&gt;使用语言模型逐个字符生成文本的过程&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129211728443-930042940.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;采样策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生成文本时，如何选择下一个字符至关重要。一种简单的方法是贪婪采样（greedy sampling），就是始终选择可能性最大的下一个字符。但这种方法会得到重复的、可预测的字符串，看起来不像是连贯的语言。一种更有趣的方法是做出稍显意外的选择：在采样过程中引入随机性，即从下一个字符的概率分布中进行采样。这叫作随机采样（stochastic sampling，stochasticity 在这个领域中就是“随机”的意思）。在这种情况下，根据模型结果，如果下一个字符是 e 的概率为0.3，那么你会有 30% 的概率选择它&lt;/p&gt;
&lt;p&gt;从模型的 softmax 输出中进行概率采样是一种很巧妙的方法，它甚至可以在某些时候采样到不常见的字符，从而生成看起来更加有趣的句子，而且有时会得到训练数据中没有的、听起来像是真实存在的新单词，从而表现出创造性。但这种方法有一个问题，就是它在采样过程中无法控制随机性的大小&lt;/p&gt;
&lt;p&gt;为了在采样过程中控制随机性的大小，我们引入一个叫作 softmax 温度（softmax temperature）的参数，用于表示采样概率分布的熵，即表示所选择的下一个字符会有多么出人意料或多么可预测。给定一个 temperature 值，将按照下列方法对原始概率分布（即模型的 softmax 输出）进行重新加权，计算得到一个新的概率分布&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np
def reweight_distribution(original_distribution, temperature=0.5): 
    #original_distribution 是概率值组成的一维 Numpy 数组，这些概率值之和必须等于 1。temperature 是一个因子，用于定量描述输出分布的熵
    distribution = np.log(original_distribution) / temperature
    distribution = np.exp(distribution)
    return distribution / np.sum(distribution)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更高的温度得到的是熵更大的采样分布，会生成更加出人意料、更加无结构的生成数据，而更低的温度对应更小的随机性，以及更加可预测的生成数据&lt;/p&gt;
&lt;p&gt;对同一个概率分布进行不同的重新加权。更低的温度 = 更确定，更高的温度 = 更随机&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129211804100-1598676964.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现字符级的 LSTM 文本生成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先下载语料，并将其转换为小写。接下来，我们要提取长度为 maxlen 的序列（这些序列之间存在部分重叠），对它们进行one-hot 编码，然后将其打包成形状为 (sequences, maxlen, unique_characters) 的三维Numpy 数组。与此同时，还需要准备一个数组 y，其中包含对应的目标，即在每一个所提取的序列之后出现的字符 ，下一步，构建网络。最后训练语言模型并从中采样&lt;/p&gt;
&lt;p&gt;给定一个训练好的模型和一个种子文本片段，我们可以通过重复以下操作来生成新的文本&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;给定目前已生成的文本，从模型中得到下一个字符的概率分布&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;根据某个温度对分布进行重新加权&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;根据重新加权后的分布对下一个字符进行随机采样&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;将新字符添加到文本末尾&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;demo&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import keras
import numpy as np
from keras import layers
import random
import sys


path = keras.utils.get_file('nietzsche.txt', origin='https://s3.amazonaws.com/text-datasets/nietzsche.txt')
# 将语料转为小写
text = open(path).read().lower()
print('Corpus length:', len(text))

maxlen = 60
step = 3
sentences = []
next_chars = []
for i in range(0, len(text) - maxlen, step):
    sentences.append(text[i: i + maxlen])
    next_chars.append(text[i + maxlen])
print('Number of sequences:', len(sentences))
# 语料中唯一字符组成的列表
chars = sorted(list(set(text)))
print('Unique characters:', len(chars))
# 将唯一字符映射为它在列表 chars 中的索引
char_indices = dict((char, chars.index(char)) for char in chars)

print('Vectorization...')
# 将字符 one-hot 编码为二进制数组
x = np.zeros((len(sentences), maxlen, len(chars)), dtype=np.bool)
y = np.zeros((len(sentences), len(chars)), dtype=np.bool)
for i, sentence in enumerate(sentences):
    for t, char in enumerate(sentence):
        x[i, t, char_indices[char]] = 1
    y[i, char_indices[next_chars[i]]] = 1

# 用于预测下一个字符的单层 LSTM 模型
model = keras.models.Sequential()
model.add(layers.LSTM(128, input_shape=(maxlen, len(chars))))
model.add(layers.Dense(len(chars), activation='softmax'))

optimizer = keras.optimizers.RMSprop(lr=0.01)
model.compile(loss='categorical_crossentropy', optimizer=optimizer)


# 模型预测，采样下一个字符的函数
def sample(preds, temperature=1.0):
    preds = np.asarray(preds).astype('float64')
    preds = np.log(preds) / temperature
    exp_preds = np.exp(preds)
    preds = exp_preds / np.sum(exp_preds)
    probas = np.random.multinomial(1, preds, 1)
    return np.argmax(probas)


for epoch in range(1, 41):
    print('epoch', epoch)
    model.fit(x, y, batch_size=128, epochs=1)
    start_index = random.randint(0, len(text) - maxlen - 1)
    generated_text = text[start_index: start_index + maxlen]
    print('--- Generating with seed: &quot;' + generated_text + '&quot;')
    for temperature in [0.2, 0.5, 1.0, 1.2]:
        print('------ temperature:', temperature)
        sys.stdout.write(generated_text)
        for i in range(400):
            sampled = np.zeros((1, maxlen, len(chars)))
            for t, char in enumerate(generated_text):
                sampled[0, t, char_indices[char]] = 1.
        preds = model.predict(sampled, verbose=0)[0]
        next_index = sample(preds, temperature)
        next_char = chars[next_index]
        generated_text += next_char
        generated_text = generated_text[1:]
        sys.stdout.write(next_char)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129211919085-482873620.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由训练结果可以看出，，较小的温度值会得到极端重复和可预测的文本，但局部结构是非常真实的，特别是所有单词都是真正的英文单词（单词就是字符的局部模式）。随着温度值越来越大，生成的文本也变得更有趣、更出人意料，甚至更有创造性，它有时会创造出全新的单词，听起来有几分可信。对于较大的温度值，局部模式开始分解，大部分单词看起来像是半随机的字符串。毫无疑问，在这个特定的设置下，0.5 的温度值生成的文本最为有趣。一定要尝试多种采样策略！在学到的结构与随机性之间，巧妙的平衡能够让生成的序列非常有趣&lt;/p&gt;
&lt;p&gt;利用更多的数据训练一个更大的模型，并且训练时间更长，生成的样本会更连贯、更真实。但是，不要期待能够生成任何有意义的文本，除非是很偶然的情况。你所做的只是从一个统计模型中对数据进行采样，这个模型是关于字符先后顺序的模型&lt;/p&gt;
&lt;h3 id=&quot;deepdream&quot;&gt;DeepDream&lt;/h3&gt;
&lt;p&gt;DeepDream 是一种艺术性的图像修改技术，它用到了卷积神经网络学到的表示。DeepDream 算法与的卷积神经网络过滤器可视化技术几乎相同，都是反向运行一个卷积神经网络：对卷积神经网络的输入做梯度上升，以便将卷积神经网络靠顶部的某一层的某个过滤器激活最大化。DeepDream 使用了相同的想法，但有以下这几个简单的区别&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 DeepDream，我们尝试将所有层的激活最大化，而不是将某一层的激活最大化，因此需要同时将大量特征的可视化混合在一起&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;不是从空白的、略微带有噪声的输入开始，而是从现有的图像开始，因此所产生的效果能够抓住已经存在的视觉模式，并以某种艺术性的方式将图像元素扭曲&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;输入图像是在不同的尺度上［叫作八度（octave）］进行处理的，这可以提高可视化的质量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;DeepDream 过程：空间处理尺度的连续放大（八度）与放大时重新注入细节&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129211953046-1262641505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于每个连续的尺度，从最小到最大，我们都需要在当前尺度运行梯度上升，以便将之前定义的损失最大化。每次运行完梯度上升之后，将得到的图像放大 40%。在每次连续的放大之后（图像会变得模糊或像素化），为避免丢失大量图像细节，我们可以使用一个简单的技巧：每次放大之后，将丢失的细节重新注入到图像中。这种方法是可行的，因为我们知道原始图像放大到这个尺寸应该是什么样子。给定一个较小的图像尺寸 S 和一个较大的图像尺寸 L，你可以计算将原始图像大小调整为 L 与将原始图像大小调整为 S 之间的区别，这个区别可以定量描述从 S 到 L 的细节损失&lt;/p&gt;
&lt;p&gt;我们可以选择任意卷积神经网络来实现 DeepDream， 不过卷积神经网络会影响可视化的效果，因为不同的卷积神经网络架构会学到不同的特征。接下来将使用 Keras 内置的 Inception V3模型来够生成漂亮的 DeepDream 图像&lt;/p&gt;
&lt;p&gt;步骤如下&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;加载预训练的 Inception V3 模型&lt;br/&gt;&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;计算损失（loss），即在梯度上升过程中需要最大化的量&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;将多个层的所有过滤器的激活同时最大化。具体来说，就是对一组靠近顶部的层激活的 L2 范数进行加权求和，然后将其最大化。选择哪些层（以及它们对最终损失的贡献）对生成的可视化结果具有很大影响，所以我们希望让这些参数变得易于配置。更靠近底部的层生成的是几何图案，而更靠近顶部的层生成的则是从中能够看出某些 ImageNet 类别（比如鸟或狗）的图案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;(2)设置 DeepDream 配置&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(2)定义需要最大化的损失&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;设置梯度上升过程&lt;br/&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在多个连续尺度上运行梯度上升&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;demo&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from keras.applications import inception_v3
from keras import backend as K
import numpy as np
import scipy
from keras.preprocessing import image


def resize_img(img, size):
    img = np.copy(img)
    factors = (1, float(size[0]) / img.shape[1], float(size[1]) / img.shape[2], 1)
    return scipy.ndimage.zoom(img, factors, order=1)


def save_img(img, fname):
    pil_img = deprocess_image(np.copy(img))
    scipy.misc.imsave(fname, pil_img)


def preprocess_image(image_path):
    img = image.load_img(image_path)
    img = image.img_to_array(img)
    img = np.expand_dims(img, axis=0)
    img = inception_v3.preprocess_input(img)
    return img


def deprocess_image(x):
    if K.image_data_format() == 'channels_first':
        x = x.reshape((3, x.shape[2], x.shape[3]))
        x = x.transpose((1, 2, 0))
    else:
        x = x.reshape((x.shape[1], x.shape[2], 3))
    x /= 2.
    x += 0.5
    x *= 255.
    x = np.clip(x, 0, 255).astype('uint8')
    return x


# 这个命令会禁用所有与训练有关的操作
K.set_learning_phase(0)
# 构建不包括全连接层的 Inception V3网络。使用预训练的 ImageNet 权重来加载模型
model = inception_v3.InceptionV3(weights='imagenet', include_top=False)

# 将层的名称映射为一个系数，这个系数定量表示该层激活对你要最大化的损失的贡献大小
layer_contributions = {
    'mixed2': 0.2,
    'mixed3': 3.,
    'mixed4': 2.,
    'mixed5': 1.5,
}

# 定义最大化的损失
layer_dict = dict([(layer.name, layer) for layer in model.layers])
loss = K.variable(0.)
for layer_name in layer_contributions:
    coeff = layer_contributions[layer_name]
    activation = layer_dict[layer_name].output
    scaling = K.prod(K.cast(K.shape(activation), 'float32'))
    # 将该层特征的L2范数添加到loss中。为了避免出现边界伪影，损失中仅包含非边界的像素
    loss += coeff * K.sum(K.square(activation[:, 2: -2, 2: -2, :])) / scaling

# 梯度上升过程
# 这个张量用于保存生成的图像，即梦境图像
dream = model.input
# 计算损失相对于梦境图像的梯度
grads = K.gradients(loss, dream)[0]
# 将梯度标准化
grads /= K.maximum(K.mean(K.abs(grads)), 1e-7)
outputs = [loss, grads]
# 给定一张输出图像，设置一个 Keras 函数来获取损失值和梯度值
fetch_loss_and_grads = K.function([dream], outputs)


def eval_loss_and_grads(x):
    outs = fetch_loss_and_grads([x])
    loss_value = outs[0]
    grad_values = outs[1]
    return loss_value, grad_values


# 运行 iterations次梯度上升
def gradient_ascent(x, iterations, step, max_loss=None):
    for i in range(iterations):
        loss_value, grad_values = eval_loss_and_grads(x)
        if max_loss is not None and loss_value &amp;gt; max_loss:
            break
        print('...Loss value at', i, ':', loss_value)
        x += step * grad_values
    return x


# 　在多个连续尺度上运行梯度上升
# 梯度上升的步长
step = 0.01
# 运行梯度上升的尺度个数
num_octave = 3
# 两个尺度之间的大小比例
octave_scale = 1.4
iterations = 20
# 如果损失增大到大于 10，我们要中断梯度上升过程，以避免得到丑陋的伪影
max_loss = 10.
base_image_path = 'img_url'
img = preprocess_image(base_image_path)
original_shape = img.shape[1:3]
successive_shapes = [original_shape]
for i in range(1, num_octave):
    # 一个由形状元组组成的列表，它定义了运行梯度上升的不同尺度
    shape = tuple([int(dim / (octave_scale ** i)) for dim in original_shape])
    successive_shapes.append(shape)
    # 将形状列表反转，变为升序
    successive_shapes = successive_shapes[::-1]
    original_img = np.copy(img)
    # 将图像 Numpy 数组的大小缩放到最小尺寸
    shrunk_original_img = resize_img(img, successive_shapes[0])
    for shape in successive_shapes:
        print('Processing image shape', shape)
        # 将梦境图像放大
        img = resize_img(img, shape)
        # 运行梯度上升，改变梦境图像
        img = gradient_ascent(img, iterations=iterations,
                              step=step, max_loss=max_loss)
        # 将原始图像的较小版本放大，它会变得像素化
        upscaled_shrunk_original_img = resize_img(shrunk_original_img, shape)
        # 在这个尺寸上计算原始图像的高质量版本
        same_size_original = resize_img(original_img, shape)
        lost_detail = same_size_original - upscaled_shrunk_original_img
        # 将丢失的细节重新注入到梦境图像中
        img += lost_detail
        shrunk_original_img = resize_img(original_img, shape)
        save_img(img, fname='dream_at_scale_' + str(shape) + '.png')
    save_img(img, fname='final_dream.png')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129212109812-105381466.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dreamImage&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129212137115-614604418.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;神经风格迁移&quot;&gt;神经风格迁移&lt;/h3&gt;
&lt;p&gt;神经风格迁移是指将参考图像的风格应用于目标图像，同时保留目标图像的内容&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129212212382-669650117.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;风格（style）&lt;/strong&gt;是指图像中不同空间尺度的纹理、颜色和视觉图案，&lt;strong&gt;内容（content）&lt;/strong&gt;是指图像的高级宏观结构&lt;/p&gt;
&lt;p&gt;实现风格迁移背后的关键概念与所有深度学习算法的核心思想是一样的：定义一个损失函数来指定想要实现的目标，然后将这个损失最小化。你知道想要实现的目标是什么，就是保存原始图像的内容，同时采用参考图像的风格。如果我们能够在数学上给出内容和风格的定义，那么就有一个适当的损失函数，我们将对其进行最小化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;loss = distance(style(reference_image) - style(generated_image)) + distance(content(original_image) - content(generated_image))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 distance 是一个范数函数，比如 L2 范数；content 是一个函数，输入一张图像，并计算出其内容的表示；style 是一个函数，输入一张图像，并计算出其风格的表示。将这个损失最小化，会使得 style(generated_image) 接近于 style(reference_image)、content(generated_image) 接近于 content(generated_image)，从而实现我们定义的风格迁移&lt;/p&gt;
&lt;p&gt;深度卷积神经网络能够从数学上定义 style 和 content 两个函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内容损失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络更靠底部的层激活包含关于图像的局部信息，而更靠近顶部的层则包含更加全局、更加抽象的信息。卷积神经网络不同层的激活用另一种方式提供了图像内容在不同空间尺度上的分解。因此，图像的内容是更加全局和抽象的，我们认为它能够被卷积神经网络更靠顶部的层的表示所捕捉到&lt;/p&gt;
&lt;p&gt;因此，内容损失的一个很好的候选者就是两个激活之间的 L2 范数，一个激活是预训练的卷积神经网络更靠顶部的某层在目标图像上计算得到的激活，另一个激活是同一层在生成图像上计算得到的激活。这可以保证，在更靠顶部的层看来，生成图像与原始目标图像看起来很相似&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;风格损失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内容损失只使用了一个更靠顶部的层，但 Gatys 等人定义的风格损失则使用了卷积神经网络的多个层。我们想要捉到卷积神经网络在风格参考图像的所有空间尺度上提取的外观，而不仅仅是在单一尺度上。对于风格损失，Gatys 等人使用了层激活的格拉姆矩阵（Gram matrix），即某一层特征图的内积。这个内积可以被理解成表示该层特征之间相互关系的映射。这些特征相互关系抓住了在特定空间尺度下模式的统计规律，从经验上来看，它对应于这个尺度上找到的纹理的外观&lt;/p&gt;
&lt;p&gt;因此，风格损失的目的是在风格参考图像与生成图像之间，在不同的层激活内保存相似的内部相互关系。反过来，这保证了在风格参考图像与生成图像之间，不同空间尺度找到的纹理看起来都很相似&lt;/p&gt;
&lt;p&gt;最终，你可以使用预训练的卷积神经网络来定义一个具有以下特点的损失&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在目标内容图像和生成图像之间保持相似的较高层激活，从而能够保留内容。卷积神经网络应该能够“看到”目标图像和生成图像包含相同的内容&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在较低层和较高层的激活中保持类似的相互关系（correlation），从而能够保留风格。特征相互关系捕捉到的是纹理（texture），生成图像和风格参考图像在不同的空间尺度上应该具有相同的纹理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;用 Keras 实现神经风格迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;神经风格迁移可以用任何预训练卷积神经网络来实现。神经风格迁移的一般过程如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个网络，它能够同时计算风格参考图像、目标图像和生成图像的 VGG19 层激活&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用这三张图像上计算的层激活来定义之前所述的损失函数，为了实现风格迁移，需要将这个损失函数最小化&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;设置梯度下降过程来将这个损失函数最小化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;demo&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from keras.preprocessing.image import load_img, img_to_array
import numpy as np
from keras.applications import vgg19
from keras import backend as K
from scipy.optimize import fmin_l_bfgs_b
from scipy.misc import imsave
import time


def preprocess_image(image_path):
    img = load_img(image_path, target_size=(img_height, img_width))
    img = img_to_array(img)
    img = np.expand_dims(img, axis=0)
    img = vgg19.preprocess_input(img)
    return img


def deprocess_image(x):
    # vgg19.preprocess_input 的作用是减去 ImageNet 的平均像素值，
    # 使其中心为 0。这里相当于 vgg19.preprocess_input 的逆操作
    x[:, :, 0] += 103.939
    x[:, :, 1] += 116.779
    x[:, :, 2] += 123.68
    # 将图像由 BGR 格式转换为 RGB 格式。这也是
    # vgg19.preprocess_input 逆操作的一部分
    x = x[:, :, ::-1]
    x = np.clip(x, 0, 255).astype('uint8')
    return x


target_image_path = 'cat.jpg'
style_reference_image_path = 'style.png'

# 设置生成图像的尺寸
width, height = load_img(target_image_path).size
img_height = 400
img_width = int(width * img_height / height)
# 加载预训练的 VGG19 网络，并将其应用于三张图像
target_image = K.constant(preprocess_image(target_image_path))
style_reference_image = K.constant(preprocess_image(style_reference_image_path))
# 占位符用于保存生成图像
combination_image = K.placeholder((1, img_height, img_width, 3))
# 将三张图像合并为一个批量
input_tensor = K.concatenate([target_image, style_reference_image, combination_image], axis=0)
model = vgg19.VGG19(input_tensor=input_tensor, weights='imagenet', include_top=False)
print('Model loaded.')


def content_loss(base, combination):
    &quot;&quot;&quot;
    内容损失
    :param base:
    :param combination:
    :return:
    &quot;&quot;&quot;
    return K.sum(K.square(combination - base))


def gram_matrix(x):
    features = K.batch_flatten(K.permute_dimensions(x, (2, 0, 1)))
    gram = K.dot(features, K.transpose(features))
    return gram


def style_loss(style, combination):
    &quot;&quot;&quot;
    风格损失
    :param style:
    :param combination:
    :return:
    &quot;&quot;&quot;
    S = gram_matrix(style)
    C = gram_matrix(combination)
    channels = 3
    size = img_height * img_width
    return K.sum(K.square(S - C)) / (4. * (channels ** 2) * (size ** 2))


def total_variation_loss(x):
    &quot;&quot;&quot;
    总变差损失
    对生成的组合图像的像素进行操作，
    促使生成图像具有空间连续性，从而避免结果过度像素化
    也可以简单理解为正则化损失
    :param x:
    :return:
    &quot;&quot;&quot;
    a = K.square(x[:, :img_height - 1, :img_width - 1, :] - x[:, 1:, :img_width - 1, :])
    b = K.square(x[:, :img_height - 1, :img_width - 1, :] - x[:, :img_height - 1, 1:, :])
    return K.sum(K.pow(a + b, 1.25))


# 定义最小化的最终损失
# 将层的名称映射为激活张量的字典
outputs_dict = dict([(layer.name, layer.output) for layer in model.layers])
content_layer = 'block5_conv2'
style_layers = ['block1_conv1', 'block2_conv1', 'block3_conv1', 'block4_conv1', 'block5_conv1']
total_variation_weight = 1e-4
style_weight = 1.
content_weight = 0.025
loss = K.variable(0.)
layer_features = outputs_dict[content_layer]
target_image_features = layer_features[0, :, :, :]
combination_features = layer_features[2, :, :, :]
loss += content_weight * content_loss(target_image_features, combination_features)
for layer_name in style_layers:
    layer_features = outputs_dict[layer_name]
    style_reference_features = layer_features[1, :, :, :]
    combination_features = layer_features[2, :, :, :]
    sl = style_loss(style_reference_features, combination_features)
    loss += (style_weight / len(style_layers)) * sl
loss += total_variation_weight * total_variation_loss(combination_image)

# 使用 L-BFGS 算法进行优化,设置梯度下降过程
# 获取损失相对于生成图像的梯度
grads = K.gradients(loss, combination_image)[0]
# 用于获取当前损失值和当前梯度值的函数
fetch_loss_and_grads = K.function([combination_image], [loss, grads])


class Evaluator(object):
    &quot;&quot;&quot;
    这个类将 fetch_loss_and_grads 包
    装起来，让你可以利用两个单独的方法
    调用来获取损失和梯度，这是我们要使
    用的 SciPy 优化器所要求的
    &quot;&quot;&quot;
    def __init__(self):
        self.loss_value = None
        self.grads_values = None

    def loss(self, x):
        assert self.loss_value is None
        x = x.reshape((1, img_height, img_width, 3))
        outs = fetch_loss_and_grads([x])
        loss_value = outs[0]
        grad_values = outs[1].flatten().astype('float64')
        self.loss_value = loss_value
        self.grad_values = grad_values
        return self.loss_value

    def grads(self, x):
        assert self.loss_value is not None
        grad_values = np.copy(self.grad_values)
        self.loss_value = None
        self.grad_values = None
        return grad_values


evaluator = Evaluator()

# 使用 SciPy 的 L-BFGS 算法来运行梯度上升过程
# 风格迁移循环
result_prefix = 'my_result'
iterations = 20
x = preprocess_image(target_image_path)
# 将图像展平，因为 scipy.optimize.fmin_l_bfgs_b 只能处理展平的向量
x = x.flatten()
for i in range(iterations):
    print('Start of iteration', i)
    start_time = time.time()
    x, min_val, info = fmin_l_bfgs_b(evaluator.loss, x, fprime=evaluator.grads, maxfun=20)
    print('Current loss value:', min_val)
    # 保存当前的生成图像
    img = x.copy().reshape((img_height, img_width, 3))
    img = deprocess_image(img)
    fname = result_prefix + '_at_iteration_%d.png' % i
    imsave(fname, img)
    print('Image saved as', fname)
    end_time = time.time()
    print('Iteration %d completed in %ds' % (i, end_time - start_time))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上技术所实现的仅仅是一种形式的改变图像纹理，或者叫纹理迁移。如果风格参考图像具有明显的纹理结构且高度自相似，并且内容目标不需要高层次细节就能够被识别，那么这种方法的效果最好。它通常无法实现比较抽象的迁移，比如将一幅肖像的风格迁移到另一幅中&lt;/p&gt;
&lt;p&gt;上面这个风格迁移算法的运行速度很慢。但这种方法实现的变换足够简单，只要有适量的训练数据，一个小型的快速前馈卷积神经网络就可以学会这种变换。因此，实现快速风格迁移的方法是，首先利用这里介绍的方法，花费大量的计算时间对一张固定的风格参考图像生成许多输入 - 输出训练样例，然后训练一个简单的卷积神经网络来学习这个特定风格的变换。一旦完成之后，对一张图像进行风格迁移是非常快的，只是这个小型卷积神经网络的一次前向传递而已&lt;/p&gt;
&lt;h3 id=&quot;用变分自编码器生成图像&quot;&gt;用变分自编码器生成图像&lt;/h3&gt;
&lt;p&gt;从图像的潜在空间中采样，并创建全新图像或编辑现有图像，这是目前最流行也是最成功的创造性人工智能应用。该领域的两种主要技术分别为&lt;strong&gt;变分自编码器（VAE，variational autoencoder）&lt;/strong&gt;和&lt;strong&gt;生成式对抗网络（GAN，generative adversarial network）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从图像的潜在空间中采样&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图像生成的关键思想就是找到一个低维的表示&lt;strong&gt;潜在空间（latent space，也是一个向量空间）&lt;/strong&gt;，其中任意点都可以被映射为一张逼真的图像。能够实现这种映射的模块，即以潜在点作为输入并输出一张图像（像素网格），叫作&lt;strong&gt;生成器&lt;/strong&gt;（generator，对于 GAN 而言）或&lt;strong&gt;解码器&lt;/strong&gt;（decoder，对于 VAE 而言）。一旦找到了这样的潜在空间，就可以从中有意地或随机地对点进行采样，并将其映射到图像空间，从而生成前所未见的图像&lt;/p&gt;
&lt;p&gt;生成图像过程示例&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129212300885-462746489.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要学习图像表示的这种潜在空间，GAN 和 VAE 是两种不同的策略。&lt;strong&gt;VAE&lt;/strong&gt; 非常适合用于学习具有良好结构的潜在空间，其中特定方向表示数据中有意义的变化轴。&lt;strong&gt;GAN&lt;/strong&gt; 生成的图像可能非常逼真，但它的潜在空间可能没有良好结构，也没有足够的连续性&lt;/p&gt;
&lt;p&gt;VAE 生成的人脸连续空间&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129212324580-1484514023.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概念向量（concept vector）&lt;/strong&gt;：给定一个表示的潜在空间或一个嵌入空间，空间中的特定方向可能表示原始数据中有趣的变化轴&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变分自编码器&lt;/strong&gt;是一种生成式模型，特别适用于利用概念向量进行图像编辑的任务。它是一种现代化的自编码器，将深度学习的想法与贝叶斯推断结合在一起。自编码器是一种网络类型，其目的是将输入编码到低维潜在空间，然后再解码回来&lt;/p&gt;
&lt;p&gt;经典的图像自编码器接收一张图像，通过一个编码器模块将其映射到潜在向量空间，然后再通过一个解码器模块将其解码为与原始图像具有相同尺寸的输出。然后，使用与输入图像&lt;strong&gt;相同的图像&lt;/strong&gt;作为目标数据来训练这个自编码器，也就是说，自编码器学习对原始输入进行重新构建。通过对代码（编码器的输出）施加各种限制，我们可以让自编码器学到比较有趣的数据潜在表示。最常见的情况是将代码限制为低维的并且是稀疏的（即大部分元素为 0），在这种情况下，编码器的作用是将输入数据压缩为更少二进制位的信息&lt;/p&gt;
&lt;p&gt;自编码器模型表示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129212337415-1785894011.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种自编码器不会得到特别有用或具有良好结构的潜在空间。它们也没有对数据做多少压缩。但是，VAE 向自编码器添加了一点统计魔法，迫使其学习连续的、高度结构化的潜在空间。这使得 VAE 已成为图像生成的强大工具&lt;/p&gt;
&lt;p&gt;VAE 不是将输入图像压缩成潜在空间中的固定编码，而是将图像转换为统计分布的参数，即平均值和方差。本质上来说，这意味着我们假设输入图像是由统计过程生成的，在编码和解码过程中应该考虑这一过程的随机性。然后，VAE 使用平均值和方差这两个参数来从分布中随机采样一个元素，并将这个元素解码到原始输入。这个过程的随机性提高了其稳健性，并迫使潜在空间的任何位置都对应有意义的表示，即潜在空间采样的每个点都能解码为有效的输出&lt;/p&gt;
&lt;p&gt;VAE模型表示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129212354970-621160551.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VAE 的工作原理&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个编码器模块将输入样本 input_img 转换为表示潜在空间中的两个参数 z_mean 和 z_log_variance&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;我们假定潜在正态分布能够生成输入图像，并从这个分布中随机采样一个点 z：z = z_mean + exp(z_log_variance) * epsilon，其中 epsilon 是取值很小的随机张量&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;一个解码器模块将潜在空间的这个点映射回原始输入图像&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因为 epsilon 是随机的，所以这个过程可以确保，与 input_img 编码的潜在位置（即z-mean）靠近的每个点都能被解码为与 input_img 类似的图像，从而迫使潜在空间能够连续地有意义。潜在空间中任意两个相邻的点都会被解码为高度相似的图像。连续性以及潜在空间的低维度，将迫使潜在空间中的每个方向都表示数据中一个有意义的变化轴，这使得潜在空间具有非常良好的结构，因此非常适合通过概念向量来进行操作&lt;/p&gt;
&lt;p&gt;VAE 的参数通过两个损失函数来进行训练：一个是&lt;strong&gt;重构损失（reconstruction loss）&lt;/strong&gt;，它迫使解码后的样本匹配初始输入；另一个是&lt;strong&gt;正则化损失（regularization loss）&lt;/strong&gt;，它有助于学习具有良好结构的潜在空间，并可以降低在训练数据上的过拟合&lt;/p&gt;
&lt;p&gt;demo&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import keras
from keras import layers
from keras import backend as K
from keras.models import Model
import numpy as np
from keras.datasets import mnist
import matplotlib.pyplot as plt
from scipy.stats import norm


class CustomVariationalLayer(keras.layers.Layer):
    &quot;&quot;&quot;
    用于计算 VAE 损失的自定义层
    &quot;&quot;&quot;
    def vae_loss(self, x, z_decoded):
        x = K.flatten(x)
        z_decoded = K.flatten(z_decoded)
        xent_loss = keras.metrics.binary_crossentropy(x, z_decoded)
        kl_loss = -5e-4 * K.mean(1 + z_log_var - K.square(z_mean) - K.exp(z_log_var), axis=-1)
        return K.mean(xent_loss + kl_loss)

    def call(self, inputs):
        x = inputs[0]
        z_decoded = inputs[1]
        loss = self.vae_loss(x, z_decoded)
        self.add_loss(loss, inputs=inputs)
        return x


def sampling(args):
    &quot;&quot;&quot;
    　潜在空间采样的函数
    :param args:
    :return:
    &quot;&quot;&quot;
    z_mean, z_log_var = args
    epsilon = K.random_normal(shape=(K.shape(z_mean)[0], latent_dim),
    mean=0., stddev=1.)
    return z_mean + K.exp(z_log_var) * epsilon


# 网络
img_shape = (28, 28, 1)
batch_size = 16
latent_dim = 2
input_img = keras.Input(shape=img_shape)
x = layers.Conv2D(32, 3, padding='same', activation='relu')(input_img)
x = layers.Conv2D(64, 3, padding='same', activation='relu', strides=(2, 2))(x)
x = layers.Conv2D(64, 3, padding='same', activation='relu')(x)
x = layers.Conv2D(64, 3, padding='same', activation='relu')(x)
shape_before_flattening = K.int_shape(x)
x = layers.Flatten()(x)
x = layers.Dense(32, activation='relu')(x)
z_mean = layers.Dense(latent_dim)(x)
z_log_var = layers.Dense(latent_dim)(x)


# z_mean 和 z_log_var 是统计分布的参数，假设这个分布能够生成 input_img
# 接下来的代码将使用 z_mean 和 z_log_var 来生成一个潜在空间点 z
z = layers.Lambda(sampling)([z_mean, z_log_var])
# VAE 解码器网络，将潜在空间点映射为图像
decoder_input = layers.Input(K.int_shape(z)[1:])
# 对输入进行上采样
x = layers.Dense(np.prod(shape_before_flattening[1:]), activation='relu')(decoder_input)
# 将 z 转换为特征图，使其形状与编码器模型最后一个 Flatten 层之前的特征图的形状相同
x = layers.Reshape(shape_before_flattening[1:])(x)
# 使用一个 Conv2DTranspose 层和一个Conv2D 层，将 z 解码为与原始输入图像具有相同尺寸的特征图
x = layers.Conv2DTranspose(32, 3, padding='same', activation='relu', strides=(2, 2))(x)
x = layers.Conv2D(1, 3, padding='same', activation='sigmoid')(x)
# 将解码器模型实例化，它将 decoder_input转换为解码后的图像
decoder = Model(decoder_input, x)
# 将实例应用于 z，以得到解码后的 z
z_decoded = decoder(z)

y = CustomVariationalLayer()([input_img, z_decoded])

# 训练 VAE
vae = Model(input_img, y)
vae.compile(optimizer='rmsprop', loss=None)
vae.summary()
(x_train, _), (x_test, y_test) = mnist.load_data()
x_train = x_train.astype('float32') / 255.
x_train = x_train.reshape(x_train.shape + (1,))
x_test = x_test.astype('float32') / 255.
x_test = x_test.reshape(x_test.shape + (1,))
vae.fit(x=x_train, y=None, shuffle=True, epochs=10, batch_size=batch_size, validation_data=(x_test, None))

# 从二维潜在空间中采样一组点的网格，并将其解码为图像
n = 15
digit_size = 28
figure = np.zeros((digit_size * n, digit_size * n))
grid_x = norm.ppf(np.linspace(0.05, 0.95, n))
grid_y = norm.ppf(np.linspace(0.05, 0.95, n))

for i, yi in enumerate(grid_x):
    for j, xi in enumerate(grid_y):
        z_sample = np.array([[xi, yi]])
        z_sample = np.tile(z_sample, batch_size).reshape(batch_size, 2)
        x_decoded = decoder.predict(z_sample, batch_size=batch_size)
        digit = x_decoded[0].reshape(digit_size, digit_size)
        figure[i * digit_size: (i + 1) * digit_size, j * digit_size: (j + 1) * digit_size] = digit
plt.figure(figsize=(10, 10))
plt.imshow(figure, cmap='Greys_r')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129212425020-54773977.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VAE&lt;/strong&gt; 得到的是高度结构化的、连续的潜在表示。因此，它在潜在空间中进行各种图像编辑的效果很好，比如换脸、将皱眉脸换成微笑脸等。它制作基于潜在空间的动画效果也很好，比如沿着潜在空间的一个横截面移动，从而以连续的方式显示从一张起始图像缓慢变化为不同图像的效果&lt;br/&gt;&lt;strong&gt;GAN&lt;/strong&gt; 可以生成逼真的单幅图像，但得到的潜在空间可能没有良好的结构，也没有很好的连续性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成式对抗网络（GAN，generative adversarial network）&lt;/strong&gt;能够迫使生成图像与真实图像在统计上几乎无法区分，从而生成相当逼真的合成图像&lt;/p&gt;
&lt;p&gt;GAN 的工作原理：一个伪造者网络和一个专家网络，二者训练的目的都是为了打败彼此。因此，GAN 由以下两部分组成&lt;br/&gt;&lt;strong&gt;生成器网络（generator network）&lt;/strong&gt;：它以一个随机向量（潜在空间中的一个随机点）作为输入，并将其解码为一张合成图像&lt;br/&gt;&lt;strong&gt;判别器网络（discriminator network）或对手（adversary）&lt;/strong&gt;：以一张图像（真实的或合成的均可）作为输入，并预测该图像是来自训练集还是由生成器网络创建&lt;/p&gt;
&lt;p&gt;训练生成器网络的目的是使其能够欺骗判别器网络，因此随着训练的进行，它能够逐渐生成越来越逼真的图像，即看起来与真实图像无法区分的人造图像，以至于判别器网络无法区分二者。与此同时，判别器也在不断适应生成器逐渐提高的能力，为生成图像的真实性设置了很高的标准。一旦训练结束，生成器就能够将其输入空间中的任何点转换为一张可信图像。与 VAE 不同，这个潜在空间无法保证具有有意义的结构，而且它还是不连续的&lt;/p&gt;
&lt;p&gt;GAN示意&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201901/1503464-20190129212445620-934126042.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GAN系统的优化最小值是不固定的。通常来说，梯度下降是沿着静态的损失地形滚下山坡。但对于 GAN 而言，每下山一步，都会对整个地形造成一点改变。它是一个动态的系统，其最优化过程寻找的不是一个最小值，而是两股力量之间的平衡。因此，GAN 的训练极其困难，想要让 GAN 正常运行，需要对模型架构和训练参数进行大量的仔细调整&lt;/p&gt;
&lt;p&gt;GAN 的简要实现流程&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;generator网络将形状为(latent_dim,)的向量映射到形状为(32, 32, 3)的图像&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;discriminator 网络将形状为 (32, 32, 3) 的图像映射到一个二进制分数，用于评估图像为真的概率&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;gan 网络将 generator 网络和 discriminator 网络连接在一起：gan(x) = discriminator(generator(x))。生成器将潜在空间向量解码为图像，判别器对这些图像的真实性进行评估，因此这个 gan 网络是将这些潜在向量映射到判别器的评估结果&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;我们使用带有“真”/“假”标签的真假图像样本来训练判别器，就和训练普通的图像分类模型一样&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;为了训练生成器，我们要使用 gan 模型的损失相对于生成器权重的梯度。这意味着，在每一步都要移动生成器的权重，其移动方向是让判别器更有可能将生成器解码的图像划分为“真”。换句话说，我们训练生成器来欺骗判别器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实现GAN的一些技巧&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 tanh 作为生成器最后一层的激活，而不用 sigmoid，后者在其他类型的模型中更加常见&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用正态分布（高斯分布）对潜在空间中的点进行采样，而不用均匀分布。随机性能够提高稳健性。训练GAN得到的是一个动态平衡，所以GAN可能以各种方式“卡住”。在训练过程中引入随机性有助于防止出现这种情况。我们通过两种方式引入随机性：一种是在判别器中使用 dropout，另一种是向判别器的标签添加随机噪声&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;稀疏的梯度会妨碍 GAN 的训练。在深度学习中，稀疏性通常是我们需要的属性，但在GAN 中并非如此。有两件事情可能导致梯度稀疏：最大池化运算和 ReLU 激活。推荐使用步进卷积代替最大池化来进行下采样，还推荐使用 LeakyReLU 层来代替 ReLU 激活。LeakyReLU 和 ReLU 类似，但它允许较小的负数激活值，从而放宽了稀疏性限制&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在生成的图像中，经常会见到棋盘状伪影，这是由生成器中像素空间的不均匀覆盖导致的。为了解决这个问题，每当在生成器和判别器中都使用步进的 Conv2DTranpose或 Conv2D 时，使用的内核大小要能够被步幅大小整除&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;GAN训练循环的大致流程&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从潜在空间中抽取随机的点（随机噪声）&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;利用这个随机噪声用 generator 生成图像&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;将生成图像与真实图像混合&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用这些混合后的图像以及相应的标签（真实图像为“真”，生成图像为“假”）来训练discriminator&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在潜在空间中随机抽取新的点&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用这些随机向量以及全部是“真实图像”的标签来训练 gan。这会更新生成器的权重（只更新生成器的权重，因为判别器在 gan 中被冻结），其更新方向是使得判别器能够将生成图像预测为“真实图像”。这个过程是训练生成器去欺骗判别器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;demo&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import keras
from keras import layers
import numpy as np
import os
from keras.preprocessing import image


# 生成器
latent_dim = 32
height = 32
width = 32
channels = 3
generator_input = keras.Input(shape=(latent_dim,))
x = layers.Dense(128 * 16 * 16)(generator_input)
x = layers.LeakyReLU()(x)
x = layers.Reshape((16, 16, 128))(x)
x = layers.Conv2D(256, 5, padding='same')(x)
x = layers.LeakyReLU()(x)
x = layers.Conv2DTranspose(256, 4, strides=2, padding='same')(x)
x = layers.LeakyReLU()(x)
x = layers.Conv2D(256, 5, padding='same')(x)
x = layers.LeakyReLU()(x)
x = layers.Conv2D(256, 5, padding='same')(x)
x = layers.LeakyReLU()(x)
x = layers.Conv2D(channels, 7, activation='tanh', padding='same')(x)
generator = keras.models.Model(generator_input, x)
generator.summary()

# 判别器
discriminator_input = layers.Input(shape=(height, width, channels))
x = layers.Conv2D(128, 3)(discriminator_input)
x = layers.LeakyReLU()(x)
x = layers.Conv2D(128, 4, strides=2)(x)
x = layers.LeakyReLU()(x)
x = layers.Conv2D(128, 4, strides=2)(x)
x = layers.LeakyReLU()(x)
x = layers.Conv2D(128, 4, strides=2)(x)
x = layers.LeakyReLU()(x)
x = layers.Flatten()(x)
x = layers.Dropout(0.4)(x)
x = layers.Dense(1, activation='sigmoid')(x)
discriminator = keras.models.Model(discriminator_input, x)
discriminator.summary()
discriminator_optimizer = keras.optimizers.RMSprop(lr=0.0008, clipvalue=1.0, decay=1e-8)
discriminator.compile(optimizer=discriminator_optimizer, loss='binary_crossentropy')

# 对抗网络，将生成器和判别器连接在一起
discriminator.trainable = False
gan_input = keras.Input(shape=(latent_dim,))
gan_output = discriminator(generator(gan_input))
gan = keras.models.Model(gan_input, gan_output)
gan_optimizer = keras.optimizers.RMSprop(lr=0.0004, clipvalue=1.0, decay=1e-8)
gan.compile(optimizer=gan_optimizer, loss='binary_crossentropy')

# 实现 GAN 的训练
(x_train, y_train), (_, _) = keras.datasets.cifar10.load_data()
x_train = x_train[y_train.flatten() == 6]
x_train = x_train.reshape((x_train.shape[0],) + (height, width, channels)).astype('float32') / 255
iterations = 10000
batch_size = 20
save_dir = 'your_dir'
start = 0
for step in range(iterations):
    random_latent_vectors = np.random.normal(size=(batch_size, latent_dim))
    generated_images = generator.predict(random_latent_vectors)
    stop = start + batch_size
    real_images = x_train[start: stop]
    combined_images = np.concatenate([generated_images, real_images])
    labels = np.concatenate([np.ones((batch_size, 1)),
    np.zeros((batch_size, 1))])
    labels += 0.05 * np.random.random(labels.shape)
    d_loss = discriminator.train_on_batch(combined_images, labels)
    random_latent_vectors = np.random.normal(size=(batch_size, latent_dim))
    misleading_targets = np.zeros((batch_size, 1))
    a_loss = gan.train_on_batch(random_latent_vectors, misleading_targets)
    start += batch_size
    if start &amp;gt; len(x_train) - batch_size:
        start = 0
    if step % 100 == 0:
        gan.save_weights('gan.h5')
        print('discriminator loss:', d_loss)
        print('adversarial loss:', a_loss)
        img = image.array_to_img(generated_images[0] * 255., scale=False)
        img.save(os.path.join(save_dir, 'generated_frog' + str(step) + '.png'))
        img = image.array_to_img(real_images[0] * 255., scale=False)
        img.save(os.path.join(save_dir, 'real_frog' + str(step) + '.png'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GAN 由一个生成器网络和一个判别器网络组成。判别器的训练目的是能够区分生成器的输出与来自训练集的真实图像，生成器的训练目的是欺骗判别器。值得注意的是，生成器从未直接见过训练集中的图像，它所知道的关于数据的信息都来自于判别器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在 Keras 中，任何对象都应该是一个层，所以如果代码不是内置层的一部分，我们应该将其包装到一个 Lambda 层（或自定义层）中&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/10336211.html&quot;&gt;Deep learning with Python 学习笔记（11）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/10304763.html&quot;&gt;Deep learning with Python 学习笔记（9）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 13:27:00 +0000</pubDate>
<dc:creator>范中豪</dc:creator>
<og:description>Python 生成式深度学习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhhfan/p/10335907.html</dc:identifier>
</item>
<item>
<title>c++ 强制类型转换 - 倔强的铃铛</title>
<link>http://www.cnblogs.com/0xfffffff0/p/10335850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0xfffffff0/p/10335850.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;在c语言中学的强制转换是用&lt;code&gt;()&lt;/code&gt;来实现的; 而在c++中更多的是用&lt;code&gt;case-name&lt;/code&gt;系列的关键字来告诉编译器我们需要转换的类型. c++引入这些关键字也是为了看代码的时候清晰明了, 每个关键字都有指定的功能. 下面我们就来分析这些关键字.&lt;/p&gt;
&lt;h3 id=&quot;case-name关键字&quot;&gt;case-name关键字&lt;/h3&gt;
&lt;h4 id=&quot;static_cast&quot;&gt;1. static_cast&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在编译期间完成类型转换&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a. 将原有的自动类型转换&lt;/strong&gt; , 如 : short转为int, int转为double, 非const转为const类型&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;short sh;
int i = static_cast&amp;lt;int&amp;gt;(sh);
const int ci = static_cast&amp;lt;const int&amp;gt;(i);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;b. void 指针和具体类型指针之间的转换&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void *vp;
int *ip = static_cast&amp;lt;int*&amp;gt;(vp);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;c. 有转换构造函数或者类型转换函数的类与其它类型之间的转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如 : A是B的基类&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;B *b;
A *a = static_cast&amp;lt;A *&amp;gt;(b); // 这种建议使用dynamic_cast来转换&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;不能用于无关类型之间的转换&lt;/span&gt; , 如 : int* 转为double* 等&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int *pi;
double *di = static_cast&amp;lt;double *&amp;gt;(pi); // error&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;const_cast&quot;&gt;2. const_cast&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;const_cast&lt;/code&gt; (常用于函数的重载) &lt;strong&gt;常量指针(引用)被转化成非常量指针(引用)，&lt;span&gt;并且仍然指向原来的对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顾名思义, &lt;code&gt;const_cast&lt;/code&gt;就是在我们需要修改&lt;code&gt;const&lt;/code&gt;修饰的常量的时候用.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int ci = 1;
int *p = const_cast&amp;lt;int*&amp;gt;(&amp;amp;ci);
*p = 10;

cout &amp;lt;&amp;lt; &amp;amp;ci &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; p &amp;lt;&amp;lt; endl;    // 0x7ffd856729cc 0x7ffd856729cc
cout &amp;lt;&amp;lt; ci &amp;lt;&amp;lt; endl; // 1
cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl; // 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意 : 上面的ci的值最终还是没有被修改, 这就是后半句 : 仍然指向原来的对象&lt;/em&gt;. 我们只能通过&lt;code&gt;const_cast&lt;/code&gt;忽略对象的属性, 却依然不能修改对象.&lt;/p&gt;
&lt;p&gt;可能有人就认为&lt;code&gt;const_cast&lt;/code&gt;并没有用, 但是我们确实用&lt;code&gt;int*&lt;/code&gt;指向了&lt;code&gt;const int*&lt;/code&gt;了, 这是一般我们都无法做到的. 同样, 下面还有&lt;code&gt;const_cast&lt;/code&gt;能够做到的.&lt;/p&gt;
&lt;p&gt;这有一部分的代码, 我们在重载const函数时, 常常会重复写很多一样的代码, 而使用&lt;code&gt;const_cast&lt;/code&gt;就可以避免写重复的代码.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class A
{
public:
    ...
    const type&amp;amp; operator[](std::size_t size) const
    {
        return *(ar + size);
    }
    type&amp;amp; operator[](std::size_t size)
    {
        return const_cast&amp;lt;type &amp;amp;&amp;gt;(static_cast&amp;lt;const A&amp;amp;&amp;gt;(*this)[size]);
    }

private:
    ...
    std::size_t size;
    type * ar;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reinterpret_cast&quot;&gt;3. reinterpret_cast&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;这种转换&lt;strong&gt;仅仅是对二进制位的重新解释(修改), 不会借助已有的转换规则对数据进行调整&lt;/strong&gt;, 非常简单粗暴, 风险很高, 一般我们不推荐使用.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;但是既然c++规定了这中转换， 那么什么时候用合适？在IBM C++指南中明确说了&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从指针类型到一个足够大的整数类型&lt;/li&gt;
&lt;li&gt;从整数类型或者枚举类型到指针类型&lt;/li&gt;
&lt;li&gt;从一个指向函数的指针到另一个不同类型的指向函数的指针&lt;/li&gt;
&lt;li&gt;从一个指向对象的指针到另一个不同类型的指向对象的指针&lt;/li&gt;
&lt;li&gt;从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针&lt;/li&gt;
&lt;li&gt;从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结来说：reinterpret_cast用在任意指针（或引用）类型之间的转换；以及指针与足够大的整数类型之间的转换；从整数类型（包括枚举类型）到指针类型，无视大小&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就像下面这样&lt;code&gt;static_cast&lt;/code&gt;无法做的但&lt;code&gt;reinterpret_cast&lt;/code&gt;就可以完成， 但是赋值等操作却会运行时报错， 这就是&lt;code&gt;reinterpret_cast&lt;/code&gt;不安全之处， 它能让代码通过编译， 操作时却会报错， 一般建议&lt;code&gt;reinterpret_cast&lt;/code&gt;只有将转换后的类型值转换回到其原始类型来使用， 做一个中间临时转存。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int *pi = NULL;
double *di = reinterpret_cast&amp;lt;double *&amp;gt;(pi);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;dynamic_cast&quot;&gt;4. dynamic_cast&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;strong&gt;用于在类的继承层次之间进行类型转换, 它既允许向上转型, 也允许向下转型.&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class A {};
class B : public A {};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向上转型 : 基类指针(引用)指向子类指针(引用), 这样的转换是安全的.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;B *b;
A *a = static_cast&amp;lt;A *&amp;gt;(b); 
A *ta = dynamic_cast&amp;lt;A *&amp;gt;(b);// 也可写成这样， 最好建议这样转换
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向下转型 : 借助 RTTI 信息进行检测, 确定安全的才能转换成功, 否则就转换失败, 有风险.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;A *a;
B *b = dynamic_cast&amp;lt;B *&amp;gt;(a);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;虽然c语言的&lt;code&gt;()&lt;/code&gt;强制能用, 但是最好推荐使用c++的转化系列, 毕竟看代码的时候很容易能够知道转化对象和原因, 也容易分析. 本片我将四种转化尽量写的简单, 多用实例证明, 只是希望能够快速的明了每个的用法.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt; : 有关联的 对象之间能够进行转化.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt; : 忽略const/volatile修饰, 但是实际不会修改对象, 常用于重载&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt; : 最多用于向下转化, 但并不安全&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt; : 二进制间, 可无关联对象间的转化, 非常不安全.&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 29 Jan 2019 13:08:00 +0000</pubDate>
<dc:creator>倔强的铃铛</dc:creator>
<og:description>前言 在c语言中学的强制转换是用 来实现的; 而在c++中更多的是用 系列的关键字来告诉编译器我们需要转换的类型. c++引入这些关键字也是为了看代码的时候清晰明了, 每个关键字都有指定的功能. 下面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0xfffffff0/p/10335850.html</dc:identifier>
</item>
<item>
<title>const关键字到底该怎么用 - 守望先生</title>
<link>http://www.cnblogs.com/bianchengzhuji/p/10335837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengzhuji/p/10335837.html</guid>
<description>&lt;h2 id=&quot;h&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们都知道使用const关键字限定一个变量为只读，但它是真正意义上的只读吗？实际中又该如何使用const关键字？在解答这些问题之前，我们需要先理解const关键字的基本使用。本文说明C中的const关键字，不包括C++。&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;const是constant的简写，是不变的意思。但并不是说它修饰常量，而是说它限定一个变量为只读。&lt;/p&gt;
&lt;h4 id=&quot;h-2&quot;&gt;修饰普通变量&lt;/h4&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-keyword&quot;&gt;int NUM = &lt;span class=&quot;hljs-number&quot;&gt;10; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于使用了const修饰NUM，使得NUM为只读，因此尝试对NUM再次赋值的操作是非法的，编译器将会报错。正因如此，如果需要使用const修饰一个变量，那么它只能&lt;strong&gt;在开始声明时就赋值，否则后面就没有机会了&lt;/strong&gt;（后面会讲到一个特殊情况）。&lt;/p&gt;
&lt;h4 id=&quot;h-3&quot;&gt;修饰数组&lt;/h4&gt;
&lt;p&gt;例如使用const关键字修饰数组，使其元素不允许被改变：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-keyword&quot;&gt;int arr[] = {&lt;span class=&quot;hljs-number&quot;&gt;0,&lt;span class=&quot;hljs-number&quot;&gt;0,&lt;span class=&quot;hljs-number&quot;&gt;2,&lt;span class=&quot;hljs-number&quot;&gt;3,&lt;span class=&quot;hljs-number&quot;&gt;4}; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试图修改arr的内容的操作是非法的，编译器将会报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs lua&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;error: assignment of &lt;span class=&quot;hljs-built_in&quot;&gt;read-only location ‘arr[&lt;span class=&quot;hljs-number&quot;&gt;2]’&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h-4&quot;&gt;修饰指针&lt;/h4&gt;
&lt;p&gt;修饰指针的情况比较多，主要有以下几种情况：&lt;br/&gt;1.const 修饰 *p，指向的对象只读，指针的指向可变：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int a = &lt;span class=&quot;hljs-number&quot;&gt;9;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int b = &lt;span class=&quot;hljs-number&quot;&gt;10;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-keyword&quot;&gt;int *p = &amp;amp;a;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里为了便于理解，可认为const修饰的是*p，通常使用*对指针进行解引用来访问对象，因而，该对象是只读的。&lt;/p&gt;
&lt;p&gt;2.const修饰p，指向的对象可变，指针的指向不可变：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int a = &lt;span class=&quot;hljs-number&quot;&gt;9;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int b = &lt;span class=&quot;hljs-number&quot;&gt;10;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int * &lt;span class=&quot;hljs-keyword&quot;&gt;const p = &amp;amp;a;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.指针不可改变指向，指向的内容也不可变&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int a = &lt;span class=&quot;hljs-number&quot;&gt;9;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int b = &lt;span class=&quot;hljs-number&quot;&gt;10;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-keyword&quot;&gt;int * &lt;span class=&quot;hljs-keyword&quot;&gt;const p = &amp;amp;a;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看完上面几种情况之后是否会觉得混乱，并且难以记忆呢？我们使用一句话总结：&lt;br/&gt;&lt;strong&gt;const放在*的左侧任意位置，限定了该指针指向的对象是只读的；const放在*的右侧，限定了指针本身是只读的，即不可变的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果还不是很好理解，我们可以这样来看，去掉类型说明符，查看const修饰的内容，上面三种情况去掉类型说明符int之后，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const *p; &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;const右边修饰谁，就说明谁是不可变的。上面的说法仅仅是帮助理解和记忆。借助上面这种理解，就会发现以下几种等价情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-keyword&quot;&gt;int NUM = &lt;span class=&quot;hljs-number&quot;&gt;10; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;hconst&quot;&gt;const关键字到底有什么用&lt;/h2&gt;
&lt;p&gt;前面介绍了这么多内容，是不是都常用呢？const关键字到底有什么用？&lt;/p&gt;
&lt;h4 id=&quot;h-5&quot;&gt;修饰函数形参&lt;/h4&gt;
&lt;p&gt;实际上，为我们可以经常发现const关键字的身影，例如很多库函数的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char *&lt;span class=&quot;hljs-title&quot;&gt;strncpy&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;char *dest,&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-keyword&quot;&gt;char *src,&lt;span class=&quot;hljs-keyword&quot;&gt;size_t n);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过看strncpy函数的原型可以知道，源字符串src是只读的，不可变的，而dest并没有该限制。我们通过一个小例子继续观察：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，我们不希望myPrint函数修改传入的字符串内容，因此入参使用了const限定符，表明传入的字符串是只读的，因此，如果myPrint函数内部如果尝试对str进行修改，将会报错:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;$ gcc -o &lt;span class=&quot;hljs-built_in&quot;&gt;test test.c&lt;br/&gt;test.c:6:12: error: assignment of &lt;span class=&quot;hljs-built_in&quot;&gt;read-only location ‘*str’&lt;br/&gt;str[0] = &lt;span class=&quot;hljs-string&quot;&gt;'H';&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，我们自己在编码过程中，&lt;strong&gt;如果确定传入的指针参数仅用于访问数据，那么应该将其声明为一个指向const限定类型的指针，避免函数内部对数据进行意外地修改&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;h-6&quot;&gt;修饰全局变量&lt;/h4&gt;
&lt;p&gt;我们知道，使用全局变量是一种不安全的做法，因为程序的任何部分都能够对全局数据进行修改。而如果对全局变量增加const限定符（假设该全局数据不希望被修改），就可以避免被程序其他部分修改。这里有两种使用方式。&lt;br/&gt;第一种，在a文件中定义，其他文件中使用外部声明，例如：&lt;br/&gt;a.h&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;b.c&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;第二种，在a文件中定义，并&lt;strong&gt;使用static修饰&lt;/strong&gt;，b文件包含a文件，例如：&lt;br/&gt;a.h&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;b.c&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;注意，这里必须使用static修饰，否则多个文件包含导致编译会出现重复定义的错误。有兴趣的可以尝试一下。&lt;/p&gt;
&lt;h2 id=&quot;hconst-1&quot;&gt;const修饰的变量是真正的只读吗？&lt;/h2&gt;
&lt;p&gt;使用const修饰之后的变量真的是完全的只读吗？看下面这个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;void)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-keyword&quot;&gt;int a = &lt;span class=&quot;hljs-number&quot;&gt;2018;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int *p = &amp;amp;a;&lt;br/&gt;*p = &lt;span class=&quot;hljs-number&quot;&gt;2019;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\n&quot;,a);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;2019&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们通过另外定义一个指针变量，将被const修饰的a的值改变了。那么我们不禁要问，const到底做了什么呢？它修饰的变量是真正意义上的只读吗?为什么它修饰的变量的值仍然可以改变？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;void)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int a = &lt;span class=&quot;hljs-number&quot;&gt;2019;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们分别获取有const修饰和无const修饰的汇编代码。&lt;br/&gt;无const修饰，汇编代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;asm language-asm&quot;&gt;.LC0:&lt;br/&gt;.string &quot;%d\n&quot;&lt;br/&gt;main:&lt;br/&gt;push    rbp&lt;br/&gt;mov     rbp, rsp&lt;br/&gt;sub     rsp, 16&lt;br/&gt;mov     DWORD PTR [rbp-4], 2019&lt;br/&gt;mov     eax, DWORD PTR [rbp-4]&lt;br/&gt;mov     esi, eax&lt;br/&gt;mov     edi, OFFSET FLAT:.LC0&lt;br/&gt;mov     eax, 0&lt;br/&gt;call    printf&lt;br/&gt;mov     eax, 0&lt;br/&gt;leave&lt;br/&gt;ret&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有const修饰，汇编代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.LC0:&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.string &quot;%&lt;span class=&quot;hljs-selector-tag&quot;&gt;d\&lt;span class=&quot;hljs-selector-tag&quot;&gt;n&quot;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;main:&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;push    &lt;span class=&quot;hljs-selector-tag&quot;&gt;rbp&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mov     &lt;span class=&quot;hljs-selector-tag&quot;&gt;rbp, &lt;span class=&quot;hljs-selector-tag&quot;&gt;rsp&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;sub     &lt;span class=&quot;hljs-selector-tag&quot;&gt;rsp, 16&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mov     &lt;span class=&quot;hljs-selector-tag&quot;&gt;DWORD &lt;span class=&quot;hljs-selector-tag&quot;&gt;PTR &lt;span class=&quot;hljs-selector-attr&quot;&gt;[rbp-4], 2019&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mov     &lt;span class=&quot;hljs-selector-tag&quot;&gt;eax, &lt;span class=&quot;hljs-selector-tag&quot;&gt;DWORD &lt;span class=&quot;hljs-selector-tag&quot;&gt;PTR &lt;span class=&quot;hljs-selector-attr&quot;&gt;[rbp-4]&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mov     &lt;span class=&quot;hljs-selector-tag&quot;&gt;esi, &lt;span class=&quot;hljs-selector-tag&quot;&gt;eax&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mov     &lt;span class=&quot;hljs-selector-tag&quot;&gt;edi, &lt;span class=&quot;hljs-selector-tag&quot;&gt;OFFSET &lt;span class=&quot;hljs-selector-tag&quot;&gt;FLAT&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:.LC0&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mov     &lt;span class=&quot;hljs-selector-tag&quot;&gt;eax, 0&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;call    &lt;span class=&quot;hljs-selector-tag&quot;&gt;printf&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mov     &lt;span class=&quot;hljs-selector-tag&quot;&gt;eax, 0&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;leave&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;ret&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现，并没有任何差异！当然这一个例子并不能说明所有的问题。但是我们要知道的是，const关键字告诉了编译器，它修饰的变量不能被改变，如果代码中发现有类似改变该变量的操作，那么编译器就会捕捉这个错误。&lt;/p&gt;
&lt;p&gt;那么它在实际中的意义之一是什么呢？&lt;strong&gt;帮助程序员提前发现问题，避免不该修改的值被意外地修改&lt;/strong&gt;，但是无法完全保证不被修改！例如我们可以通过对指针进行强转：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;myPrint&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-keyword&quot;&gt;char *str);&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;myPrint&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-keyword&quot;&gt;char *str)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char *b = (&lt;span class=&quot;hljs-keyword&quot;&gt;char *)str;&lt;br/&gt;b[&lt;span class=&quot;hljs-number&quot;&gt;0] = &lt;span class=&quot;hljs-string&quot;&gt;'H';&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot; readability=&quot;1&quot;&gt;printf(&lt;span class=&quot;hljs-string&quot; readability=&quot;2&quot;&gt;&quot;my print:%s\n&quot;,b);&lt;p&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;void)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char str[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello world&quot;;&lt;br/&gt;myPrint(str);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;my &lt;span class=&quot;hljs-keyword&quot;&gt;print:Hello world&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，const关键字是给编译器用的，帮助程序员提早发现可能存在的问题。&lt;br/&gt;&lt;strong&gt;但是实际中永远不要写这样的代码！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;h-7&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;介绍了这么多，关键点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;const关键字让编译器帮助我们发现变量不该被修改却被意外修改的错误。&lt;/li&gt;
&lt;li&gt;const关键字修饰的变量并非真正意义完完全全的只读。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于不该被修改的入参，应该用const修饰，这是const使用的常见姿势。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;const修饰的变量只能正常赋值一次。&lt;/li&gt;
&lt;li&gt;不要试图将非const数据的地址赋给普通指针。&lt;/li&gt;
&lt;li&gt;不要忽略编译器的警告，除非你很清楚在做什么。&lt;/li&gt;
&lt;li&gt;虽然可以通过某种不正规途径修改const修饰的变量，但是&lt;strong&gt;永远不要这么做&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h-8&quot;&gt;思考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;与#define相比，const有什么优点？&lt;/li&gt;
&lt;li&gt;const关键字到底该什么时候用？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;微信公众号【编程珠玑】：专注但不限于分享计算机编程基础，Linux，C语言，C++，算法，数据库等编程相关[原创]技术文章，号内包含大量经典电子书和视频学习资源。欢迎一起交流学习，一起修炼计算机“内功”，知其然，更知其所以然。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 29 Jan 2019 13:04:00 +0000</pubDate>
<dc:creator>守望先生</dc:creator>
<og:description>我们都知道使用const关键字限定一个变量为只读，但它是真正意义上的只读吗？实际中又该如何使用const关键字？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengzhuji/p/10335837.html</dc:identifier>
</item>
<item>
<title>不同语言的水仙花性能比较【Test1W】 - 轮回</title>
<link>http://www.cnblogs.com/dreign/p/10335721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dreign/p/10335721.html</guid>
<description>&lt;p&gt;看了大佬@&lt;a href=&quot;https://home.cnblogs.com/u/abountme/&quot;&gt;鱼丸粗面一碗&lt;/a&gt;的文章：&lt;a title=&quot;这段代码，c 1秒，java 9秒，c# 14秒，而python。。。&quot; href=&quot;https://www.cnblogs.com/abountme/p/10311654.html&quot; target=&quot;_blank&quot;&gt;《这段代码，c 1秒，java 9秒，c# 14秒，而python。。。》&lt;/a&gt;，基于水仙花数的各种语言1W次性能比较，觉得很有意思。于是开启cv大法，把我有环境的各种语言都跑了一遍，包括C++,C#.Net,C#.Net Core2.2,VB.Net,VB.Net Core2.2,Java,Python,Javascript,Go,NodeJs。代码copy鱼丸的，在github上放了一份：&lt;a title=&quot;https://github.com/dreign/Test1W&quot; href=&quot;https://github.com/dreign/Test1W&quot; target=&quot;_blank&quot;&gt;https://github.com/dreign/Test1W&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的电脑信息如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;基本硬件展示&lt;br/&gt;处理器 英特尔 第四代酷睿 i3-4170 @ 3.70GHz 双核&lt;br/&gt;主板 技嘉 H81M-S1&lt;br/&gt;内存 16 GB ( 金士顿 DDR3 1600MHz )&lt;br/&gt;主硬盘 OV-Blitz240GBSSD ( 240 GB / 固态硬盘 )&lt;br/&gt;主显卡 AMD Radeon R5 230 ( 1 GB )&lt;br/&gt;显示器 戴尔 DELA104 DELL E2418HN ( 24 英寸 )&lt;br/&gt;网卡 瑞昱 RTL8168/8111/8112 Gigabit Ethernet Controller / 技嘉&lt;br/&gt;声卡 英特尔 英特尔 显示器音频 @ 英特尔 Haswell 高保真音频&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;allContent ng-binding&quot;&gt;
所有程序都是在win10环境下运行，测试的结果如下：
&lt;/pre&gt;
&lt;table border=&quot;0&quot;&gt;&lt;caption&gt;Test1W&lt;/caption&gt;
&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;语言&lt;/td&gt;
&lt;td&gt;执行时间（ms）&lt;/td&gt;
&lt;td&gt;水仙花总数&lt;/td&gt;
&lt;td&gt;环境版本&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;gcc version 6.3.0 (MinGW.org GCC-6.3.0-1)，Thread model: win32&lt;/td&gt;
&lt;td&gt;gcc -O 优化后，非常快，1亿次也才30ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C#.Net&lt;/td&gt;
&lt;td&gt;5178&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;.Net FrameWork 4.5&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C#.Net Core2.2&lt;/td&gt;
&lt;td&gt;5093&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;.Net Core 2.2&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VB.Net&lt;/td&gt;
&lt;td&gt;34303&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;.Net FrameWork 4.5&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VB.Net Core2.2&lt;/td&gt;
&lt;td&gt;23848&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;Net Core 2.2&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;4263&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;java version &quot;1.8.0_181&quot;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;63727&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;Python 3.7.1&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Javascript&lt;/td&gt;
&lt;td&gt;28219&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;Google Chrome：版本 71.0.3578.98（正式版本） （64 位）&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Node.js&lt;/td&gt;
&lt;td&gt;26298&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;v8.9.3&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Go&lt;/td&gt;
&lt;td&gt;5641&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;go version go1.10.1 windows/amd64&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;allContent ng-binding&quot;&gt;
&lt;br/&gt;运行截图：&lt;br/&gt;&lt;strong&gt;c++&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129201236232-1996780428.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C#.Net4.5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129201339819-688234978.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C#.Net Core 2.2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129201424323-1221440370.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VB.Net4.5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129201511806-598222327.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VB.Net Core 2.2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129201537320-1634420331.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;allContent ng-binding&quot;&gt;
Java
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129201931815-2058529314.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;allContent ng-binding&quot;&gt;
Python
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129201959562-847976854.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;allContent ng-binding&quot;&gt;
JavaScript
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129202054538-177998054.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NodeJs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129202121125-1033315678.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Go&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/3250/201901/3250-20190129202141048-1193363742.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 12:22:00 +0000</pubDate>
<dc:creator>轮回</dc:creator>
<og:description>看了大佬@鱼丸粗面一碗的文章：《这段代码，c 1秒，java 9秒，c# 14秒，而python。。。》，基于水仙花数的各种语言1W次性能比较，觉得很有意思。于是开启cv大法，把我有环境的各种语言都跑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dreign/p/10335721.html</dc:identifier>
</item>
</channel>
</rss>