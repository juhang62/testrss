<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>requests+django+bs4实现一个web微信的功能 - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/10727084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/10727084.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;　　今天我们利用requests模块+django+bs4浏览器来实现一个web微信的基本功能，主要实现的功能如下&lt;/p&gt;
&lt;p&gt;　　a、实现返回二维码&lt;/p&gt;
&lt;p&gt;　　b、实现手机扫码后二维码变成变成头像&lt;/p&gt;
&lt;p&gt;　　c、实现手机点击登陆成功显示微信的最近联系人&lt;/p&gt;
&lt;p&gt;　　d、实现显示所有的联系人&lt;/p&gt;
&lt;p&gt;　　e、实现发送消息&lt;/p&gt;

&lt;p&gt;　　下面我们就开始实现上述的功能，在看这篇博客的之前，读者朋友需要去了解一下长轮询的知识，因为wei微信的登陆就用到了长轮询，首先我们先把web登陆的流程梳理一下，然后在实现我们的功能&lt;/p&gt;

&lt;h3&gt;一、web微信登陆分析&lt;/h3&gt;
&lt;h4&gt;1、web微信二维码分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417221413796-654160456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; a、首先拿到url，这个请求是get请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.wx2.qq.com/jslogin?appid=wx782c26e4c19acffb&amp;amp;redirect_uri=https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxnewloginpage&amp;amp;fun=new&amp;amp;lang=zh_&amp;amp;_=1555510256420
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;tabpanel-summary-value textbox-input devtools-monospace&quot;&gt;这个url很好构建，只有1555510256420这个参数需要我们认为生成，其他他就是时间戳*1000，然后取整，生成的方法如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
t = int(time.time() * 1000)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;b、分析这个url的返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417221646895-837071915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;c、查看网页的源代码，看下这个二维码到底是什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417221749912-89950448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看下img标签的src属性，有没有注意到，src的这一段字符串oaKKJgJRhA==，是我们返回二维码的url返回的字符串，所以我们就可以拼接出来二维码这个图片的src的地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.weixin.qq.com/qrcode/oaKKJgJRhA==　　
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2、等待用户扫码&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417222934676-329183336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里就用到了一个长轮询，如果客户一直没有扫码，则会hang住，等待客户的扫码&lt;/p&gt;
&lt;p&gt;a、先来分析一下url&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.wx2.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&amp;amp;uuid=oeoQNe1EiA==&amp;amp;tip=1&amp;amp;r=-732967182&amp;amp;_=1555511127069
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个url有2个地方需要我们来构建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223138370-812314534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第一个参数就上一步返回的字符串，第二个参数就是一个还是一个时间戳&lt;/p&gt;
&lt;p&gt;b、在来看下这个url返回了什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223256303-946138072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 只有一个状态码408&lt;/p&gt;
&lt;p&gt; 结论：如果url的返回的code为408，则表示等待用户扫码&lt;/p&gt;
&lt;h4&gt;3、web微信显示头像分析&lt;/h4&gt;
&lt;p&gt;手机扫码后，二维码变成头像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417222422953-49483062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;a、先来分析url&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.wx2.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&amp;amp;uuid=Qfn4ldhuNQ==&amp;amp;tip=1&amp;amp;r=-732688468&amp;amp;_=1555510848123
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个url和上面的url一样，所以我们知道，第一步返回的字符串非常重要，所以我们要把这段字符串放在session中&lt;/p&gt;
&lt;p&gt;b、在来看下url的返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223608883-1373617650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里返回了一段字符串，code为201，后面那一段字符串是头像的地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223653352-355965195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; c、我们在来看下html中的img标签的src的地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223905479-796059433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 结论：返回201，则证明用户已经扫码成功&lt;/p&gt;

&lt;h4&gt;4、web微信登陆分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417224458462-1880514468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;a、首先url还是之前的url，这里就不做分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.wx2.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&amp;amp;uuid=YacjFJrAfA==&amp;amp;tip=0&amp;amp;r=-733737113&amp;amp;_=1555511755717
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;b、看下这次请求的返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417224603215-179137209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有一个跳转的url，也就是当我们点击登陆后，会跳转到这个url&lt;/p&gt;
&lt;p&gt;这里还有一个返回码是200&lt;/p&gt;

&lt;p&gt;结论：状态码返回200，则证明登陆成功&lt;/p&gt;

&lt;h4&gt;5、分析web微信的跳转url&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417224754164-632645538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;a、分析一下这次请求的返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;lt;error&amp;gt;&amp;lt;ret&amp;gt;0&amp;lt;/ret&amp;gt;&amp;lt;message&amp;gt;&amp;lt;/message&amp;gt;&amp;lt;skey&amp;gt;@crypt_90b16895_59f7cbfc1c217310b90558af662ea9c7&amp;lt;/skey&amp;gt;&amp;lt;wxsid&amp;gt;VP1xxDiAiU5Xz8gN&amp;lt;/wxsid&amp;gt;&amp;lt;wxuin&amp;gt;1632086000&amp;lt;/wxuin&amp;gt;&amp;lt;pass_ticket&amp;gt;w%2BIW73Y3XXFLqfA%2BBworrfgKu5aRlyXW%2F57wtMPYwrP%2BWnDW3ieWQ8jBmUUTbawy&amp;lt;/pass_ticket&amp;gt;&amp;lt;isgrayscale&amp;gt;1&amp;lt;/isgrayscale&amp;gt;&amp;lt;/error&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个返回值非常重要，我们后面登陆后需要做的操作都需要这里的信息。所以这个信息我们也要组合一下放在session后，方便的后面的请求使用&lt;/p&gt;

&lt;h4&gt;6、web微信显示最近联系人流程分析&lt;/h4&gt;
&lt;p&gt;访问为跳转url后，拿到返回值信息，web微信又会发送一个post请求，获取最近联系人信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417225146204-142644495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; a、先看下url，这里url就需要用到上面跳转url的返回值的信息来拼接&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxinit?r=-733594626&amp;amp;pass_ticket=w%2BIW73Y3XXFLqfA%2BBworrfgKu5aRlyXW%2F57wtMPYwrP%2BWnDW3ieWQ8jBmUUTbawy
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; b、这个请求的返回值就是最近联系人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417225444796-260479240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; c、我们就可以把这些数据渲染到html页面就可以了&lt;/p&gt;

&lt;h4&gt;7、web微信显示全部联系人&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417230604042-992228631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 点击这里，就会显示全部联系人&lt;/p&gt;
&lt;p&gt;a、分析一下url&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxgetcontact?pass_ticket=w%2BIW73Y3XXFLqfA%2BBworrfgKu5aRlyXW%2F57wtMPYwrP%2BWnDW3ieWQ8jBmUUTbawy&amp;amp;r=1555511910553&amp;amp;seq=0&amp;amp;skey=@crypt_90b16895_59f7cbfc1c217310b90558af662ea9c7
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们完全可以根据session中的数据拼接这个字符串&lt;/p&gt;
&lt;p&gt;b、这次请求的返回信息就是所有的联系人&lt;/p&gt;

&lt;h4&gt;8、web发送消息&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417230918928-1630763442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 发送消息是一个post的请求&lt;/p&gt;
&lt;p&gt; a、先来分析url&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxsendmsg?pass_ticket=w%2BIW73Y3XXFLqfA%2BBworrfgKu5aRlyXW%2F57wtMPYwrP%2BWnDW3ieWQ8jBmUUTbawy
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以通过session中的数据拼接出这个url&lt;/p&gt;

&lt;p&gt;b、在来看下这次post携带的请求体，我们完全可以通过session中的数据拼接出这个请求体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417231112748-2030711246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; c、分析msg这个信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417231200900-113109045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一条是时间戳&lt;/p&gt;
&lt;p&gt;第二条是发送的内容&lt;/p&gt;
&lt;p&gt;第三条发送者的微信id&lt;/p&gt;
&lt;p&gt;第四条也是时间戳&lt;/p&gt;
&lt;p&gt;第五条是接受者的微信id&lt;/p&gt;

&lt;h3&gt;二、我们的代码实现&lt;/h3&gt;
&lt;p&gt;通过上面的分析，我相信大家对web微信的请求已经非常了解了，下面我们使用requests+bs4+djangon来实现一个建议的web微信&lt;/p&gt;
&lt;p&gt;1、首先看下登陆的html，重点看下我的注释&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417231616883-2003308870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2、进入views文件，看下返回二维码的视图函数，我们注意到，前面的html需要q_code这个变量来渲染img标签的src的路径，显示二维码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232034774-402315417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3、然后后看下等待用户扫码的后台逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232357718-1564585829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、看下前端处理408返回码的逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232521359-197521394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 5、在来看下用户扫码后的后台逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232709401-1323991217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 6、在看下前端收到201的返回值处理逻辑，首先修改二维码的地址为头像的地址，然后再次发送一次请求，等待用户点击确认&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232756746-2060683780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 7、在看下后端处理用户点击登陆的逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233200911-1308850874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 8、在看下前端处理200请求的逻辑，会跳转到一个最近联系人的页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233241731-289223827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;9、我们在看下这个url对应的视图函数，这个视图函数是返回最近联系人的函数，需要携带规定的请求体，这些请求体已经被存储到session中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233351864-1740173657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 10、在看下index.html这个页面，这个数据结构比较简单，大家自己自己抓包看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233551377-130983679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 11、我们再看下查所有人联系人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233653387-506052807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 12、看下对应的视图函数，拼接url，然后把返回值返回给前端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233729759-2116570307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 13、前端渲染数据即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233826575-1109128562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 14、在看发送信息的前端页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233910199-1242579459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;15、再看下后端的处理逻辑，主要是拼接url和处理中文的信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def sendmsg(request):
    if request.method == &quot;GET&quot;:
        return render(request,&quot;sendmsg.html&quot;)

    else:
        from_user = request.POST.get(&quot;from_user&quot;)
        to_user = request.POST.get(&quot;to_user&quot;)
        content = request.POST.get(&quot;content&quot;)

        data_dict = {
            &quot;BaseRequest&quot;:{
                &quot;DeviceID&quot;:&quot;e461335461567419&quot;,
                &quot;Sid&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxsid&quot;),
                &quot;Skey&quot;:request.session[&quot;temp_dict&quot;].get(&quot;skey&quot;),
                &quot;Uin&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxuin&quot;)
            },
            &quot;Msg&quot;:{
                &quot;ClientMsgId&quot;:int(time.time() * 1000),
                &quot;Content&quot;:content,
                &quot;FromUserName&quot;:from_user,
                &quot;LocalID&quot;:int(time.time() * 1000),
                &quot;ToUserName&quot;:to_user,
                &quot;Type&quot;:1
            },
        &quot;Scene&quot;:0
        }
        rep = requests.post(
            url= &quot;https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxsendmsg?lang=zh_CN&amp;amp;pass_ticket={p}&quot;.format(p = request.session[&quot;temp_dict&quot;][&quot;pass_ticket&quot;]),

            # 1、方式1，处理不了中文，由于json的问题
            # json=data_dict

            # 2、方式2，解决了json处理不了中文的问题，但是微信用的解码是不是常见的解码方式，所以还是处理不了中文
            # data = json.dumps(
            #     data_dict,
            #     ensure_ascii=False
            # )

            # 3、方式3，直接发送二进制文件，就可以解决发送中文的问题
            data = bytes(json.dumps(
                data_dict,
                ensure_ascii=False
            ),encoding=&quot;utf-8&quot;)
        )
        print(rep.text)

        return HttpResponse(&quot;success&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 三、整体的后端代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;70&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from django.shortcuts import render
from django.shortcuts import HttpResponse
from django.shortcuts import redirect
import requests
import re
# Create your views here.

import time
def login(request):
    if request.method.lower() == &quot;get&quot;:
        t = int(time.time() * 1000)
        url = &quot;https://login.wx.qq.com/jslogin?appid=wx782c26e4c19acffb&amp;amp;redirect_uri=https%3A%2F%2Fwx.qq.com%2Fcgi-bin%2Fmmwebwx-bin%2Fwebwxnewloginpage&amp;amp;fun=new&amp;amp;lang=zh_CN&amp;amp;_={t}&quot;
        res = requests.get(url=url)
        # window.QRLogin.code = 200;
        # window.QRLogin.uuid = &quot;oc86pbX-hQ==&quot;;
        re_obj = re.compile('= &quot;(.*==)&quot;;$')
        q_code = re_obj.findall(res.text)[0]
        request.session[&quot;q_code&quot;] = q_code
        return render(request,&quot;login.html&quot;,locals())

import json
import re
from bs4 import BeautifulSoup
# BeautifulSoup还可以处理xml文档
def checklogin(request):
    if request.method.lower() == &quot;get&quot;:
        res_dict = {&quot;code&quot;:408,&quot;img&quot;:None,&quot;url&quot;:None}
        code = request.session[&quot;q_code&quot;]
        t = int(time.time() * 1000)
        url = &quot;https://login.wx.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&amp;amp;uuid={code}&amp;amp;tip=0&amp;amp;r=-131537270&amp;amp;_={t}&quot;.format(code = code,t = t)
        rep = requests.get(url=url)
        if &quot;window.code=408;&quot; in rep.text:
            return HttpResponse(json.dumps(res_dict))

        elif &quot;window.code=201;&quot; in rep.text:
            # 扫码成功
            obj = re.compile(&quot;window.userAvatar = '(.*)';&quot;)
            src = obj.findall(rep.text)[0]
            res_dict[&quot;code&quot;] = 201
            res_dict[&quot;img&quot;] = src

            return HttpResponse(json.dumps(res_dict))
        elif &quot;window.code=200;&quot; in rep.text:
            # 确定登陆
            obj = re.compile('window.redirect_uri=&quot;(.*)&quot;;')
            url = obj.findall(rep.text)[0]
            res_dict[&quot;code&quot;] = 200
            res_dict[&quot;url&quot;] = url
            new = requests.get(url = url + &quot;&amp;amp;fun=new&amp;amp;version=v2&amp;amp;lang=zh_CN&quot;)
            script_obj = BeautifulSoup(new.text,&quot;html.parser&quot;)
            temp_dict = {}
            for tag in script_obj.find(name=&quot;error&quot;):
                temp_dict[tag.name] = tag.text

            request.session[&quot;temp_dict&quot;] = temp_dict
            request.session[&quot;cookies&quot;] = new.cookies.get_dict()
            return HttpResponse(json.dumps(res_dict))
        else:
            pass
            return HttpResponse(&quot;haha&quot;)


def index(request):
    url = &quot;https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxinit?r=-221192329&amp;amp;pass_ticket={t}&quot;.format(t = request.session[&quot;temp_dict&quot;].get(&quot;pass_ticket&quot;))
    init = requests.post(
        url=url,
        json={
            &quot;BaseRequest&quot;:{
                &quot;DeviceID&quot;:&quot;e701447882725714&quot;,
                &quot;Sid&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxsid&quot;),
                &quot;Skey&quot;:request.session[&quot;temp_dict&quot;].get(&quot;skey&quot;),
                &quot;Uin&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxuin&quot;)
            }
        }
    )
    init.encoding = &quot;utf-8&quot;
    init_user_dict = init.json()
    return render(request,&quot;index.html&quot;,locals())


def contact(request):
    t = int(time.time() * 1000)
    rep = requests.get(
        url = &quot;https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxgetcontact?lang=zh_CN&amp;amp;pass_ticket={p}&amp;amp;r={t}&amp;amp;seq=0&amp;amp;skey={s}&quot;.format(t = t,
                                                                                                                              p = request.session[&quot;temp_dict&quot;][&quot;pass_ticket&quot;],
                                                                                                                              s = request.session[&quot;temp_dict&quot;][&quot;skey&quot;]),
        cookies = request.session[&quot;cookies&quot;]
    )
    rep.encoding = &quot;utf-8&quot;
    user_list= rep.json()

    return render(request,&quot;contact.html&quot;,locals())


def avator(request):
    # print(request.GET.get(&quot;prev&quot;))
    # print(request.GET.get(&quot;username&quot;))
    # print(request.GET.get(&quot;skey&quot;))
    url = &quot;https://wx2.qq.com{p}&amp;amp;username={u}&amp;amp;skey={s}&quot;.format(p = request.GET.get(&quot;prev&quot;),
                                                                   u = request.GET.get(&quot;username&quot;),
                                                                   s = request.GET.get(&quot;skey&quot;)
                                                                   )
    img = requests.get(
        url = url,
        cookies = request.session[&quot;cookies&quot;]
    )
    print(url)
    return img.content


def sendmsg(request):
    if request.method == &quot;GET&quot;:
        return render(request,&quot;sendmsg.html&quot;)

    else:
        from_user = request.POST.get(&quot;from_user&quot;)
        to_user = request.POST.get(&quot;to_user&quot;)
        content = request.POST.get(&quot;content&quot;)

        data_dict = {
            &quot;BaseRequest&quot;:{
                &quot;DeviceID&quot;:&quot;e461335461567419&quot;,
                &quot;Sid&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxsid&quot;),
                &quot;Skey&quot;:request.session[&quot;temp_dict&quot;].get(&quot;skey&quot;),
                &quot;Uin&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxuin&quot;)
            },
            &quot;Msg&quot;:{
                &quot;ClientMsgId&quot;:int(time.time() * 1000),
                &quot;Content&quot;:content,
                &quot;FromUserName&quot;:from_user,
                &quot;LocalID&quot;:int(time.time() * 1000),
                &quot;ToUserName&quot;:to_user,
                &quot;Type&quot;:1
            },
        &quot;Scene&quot;:0
        }
        rep = requests.post(
            url= &quot;https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxsendmsg?lang=zh_CN&amp;amp;pass_ticket={p}&quot;.format(p = request.session[&quot;temp_dict&quot;][&quot;pass_ticket&quot;]),

            # 1、方式1，处理不了中文，由于json的问题
            # json=data_dict

            # 2、方式2，解决了json处理不了中文的问题，但是微信用的解码是不是常见的解码方式，所以还是处理不了中文
            # data = json.dumps(
            #     data_dict,
            #     ensure_ascii=False
            # )

            # 3、方式3，直接发送二进制文件，就可以解决发送中文的问题
            data = bytes(json.dumps(
                data_dict,
                ensure_ascii=False
            ),encoding=&quot;utf-8&quot;)
        )
        print(rep.text)

        return HttpResponse(&quot;success&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 相信如果大家看懂我前面分析web微信的逻辑，看懂应该不成问题。如果有不清楚的，请评论留言，感谢大家关注，谢谢！&lt;/p&gt;

</description>
<pubDate>Wed, 17 Apr 2019 15:43:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<og:description>前言： 今天我们利用requests模块+django+bs4浏览器来实现一个web微信的基本功能，主要实现的功能如下 a、实现返回二维码 b、实现手机扫码后二维码变成变成头像 c、实现手机点击登陆成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bainianminguo/p/10727084.html</dc:identifier>
</item>
<item>
<title>龟兔赛跑算法详解 - 周洋</title>
<link>http://www.cnblogs.com/zywscq/p/10727079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zywscq/p/10727079.html</guid>
<description>&lt;p&gt;龟兔赛跑算法(&lt;span id=&quot;Floyd's_Tortoise_and_Hare&quot; class=&quot;mw-headline&quot;&gt;Floyd's Tortoise and Hare/Circle Detection&lt;/span&gt;)用于判断链表是否有环.&lt;/p&gt;
&lt;p&gt;使用两个指针,一个慢的每次走一步,一个快的每次走两步.&lt;/p&gt;
&lt;p&gt;可以在O(n)的时间复杂度和O(1)的空间复杂度解决如下三个问题:&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 判断链表是否有环?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;两个指针相遇了,肯定有环.(&lt;a href=&quot;https://www.cnblogs.com/zywscq/p/10725750.html&quot; target=&quot;_blank&quot;&gt;例题&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;为什么有环就会相遇呢?&lt;/p&gt;
&lt;p&gt;证明:&lt;/p&gt;
&lt;p&gt;令:　　head=头节点;　　entry:环的入口处节点;　　meeting:相遇时所在的节点.&lt;/p&gt;
&lt;p&gt;　　　C=环的长度;　　L&lt;sub&gt;1&lt;/sub&gt;=head到entry的距离;　　L&lt;sub&gt;2&lt;/sub&gt;=entry到meeting的距离.&lt;/p&gt;
&lt;p&gt;　　　慢的每次走一步(速度为1),快的每次走两步(速度为2).同时出发,相遇时有:&lt;/p&gt;
&lt;p&gt;　　　&lt;strong&gt;L&lt;sub&gt;1&lt;/sub&gt;+L&lt;sub&gt;2&lt;/sub&gt;+n&lt;sub&gt;1&lt;/sub&gt;*C = (L&lt;sub&gt;1&lt;/sub&gt;+L&lt;sub&gt;2&lt;/sub&gt;+n&lt;sub&gt;2&lt;/sub&gt;*C)/2   &lt;/strong&gt; 化简得:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　L&lt;sub&gt;1&lt;/sub&gt; = (n&lt;sub&gt;2&lt;/sub&gt;-2*n&lt;sub&gt;1&lt;/sub&gt;)*C-L&lt;sub&gt;2&lt;/sub&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　其中L&lt;sub&gt;1&lt;/sub&gt; 和C是定值,这个等式显然有解,所以会相遇.&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 环的长度?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相遇后,一个不动,另一个一步一步走一圈,再次相遇时,走过的路程就是环的长度.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 环的入口?(&lt;a href=&quot;https://www.cnblogs.com/zywscq/p/10726882.html&quot; target=&quot;_blank&quot;&gt;例题&lt;/a&gt;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据&lt;strong&gt;L&lt;sub&gt;1&lt;/sub&gt; = (n&lt;sub&gt;2&lt;/sub&gt;-2*n&lt;sub&gt;1&lt;/sub&gt;)*C-L&lt;sub&gt;2&lt;/sub&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;L&lt;sub&gt;1&lt;/sub&gt;实际上等于先转几圈加上最后一圈减去L&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以再让一个节点从head出发,一个节点从meeting出发,同时走,每人每次一步,最后相遇肯定在entry节点,也就找到了entry节点. &lt;/p&gt;
&lt;p&gt; 图示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660979/201904/660979-20190417231607480-656496920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 17 Apr 2019 15:42:00 +0000</pubDate>
<dc:creator>周洋</dc:creator>
<og:description>龟兔赛跑算法(Floyd's Tortoise and Hare/Circle Detection)用于判断链表是否有环. 使用两个指针,一个慢的每次走一步,一个快的每次走两步. 可以在O(n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zywscq/p/10727079.html</dc:identifier>
</item>
<item>
<title>Java8新特性之二：方法引用 - 无恨之都</title>
<link>http://www.cnblogs.com/wuhenzhidu/p/10727065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhenzhidu/p/10727065.html</guid>
<description>&lt;p&gt;　　上一节介绍了Java8新特性中的Lambda表达式，本小节继续讲解Java8的新特性之二：方法引用。方法引用其实也离不开Lambda表达式。&lt;/p&gt;
&lt;h2&gt;1、方法引用的使用场景&lt;/h2&gt;
&lt;p&gt;　　我们用Lambda表达式来实现匿名方法。但有些情况下，我们用Lambda表达式仅仅是调用一些已经存在的方法，除了调用动作外，没有其他任何多余的动作，在这种情况下，我们倾向于通过方法名来调用它，而Lambda表达式可以帮助我们实现这一要求，它使得Lambda在调用那些已经拥有方法名的方法的代码更简洁、更容易理解。方法引用可以理解为Lambda表达式的另外一种表现形式。&lt;/p&gt;
&lt;h2&gt;2、方法引用的分类&lt;/h2&gt;
&lt;table class=&quot;md-table&quot; frame=&quot;border&quot; rules=&quot;all&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block md-focus-container&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;类型&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;语法&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;对应的Lambda表达式&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;静态方法引用&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;类名::staticMethod&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;(args) -&amp;gt; 类名.staticMethod(args)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;实例方法引用&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;inst::instMethod&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;(args) -&amp;gt; inst.instMethod(args)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;对象方法引用&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;类名::instMethod&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;(inst,args) -&amp;gt; 类名.instMethod(args)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;构建方法引用&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;类名::new&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;(args) -&amp;gt; new 类名(args)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;3、方法引用举例&lt;/h2&gt;
&lt;h3&gt;3.1 静态方法引用&lt;/h3&gt;
&lt;p&gt;　　有一个Person类,如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareByAge(Person a, Person b) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.age.compareTo(b.age);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现假设，一个部门有30人，把他们存放在一个数组中，并按年龄排序，通常我们可以自己写一个比较器，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Person[] rosterAsArray = &lt;span&gt;new&lt;/span&gt; Person[30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加数组元素省略&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PersonAgeComparator &lt;span&gt;implements&lt;/span&gt; Comparator&amp;lt;Person&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person a, Person b) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.getBirthday().compareTo(b.getBirthday());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt; Arrays.sort(rosterAsArray, &lt;span&gt;new&lt;/span&gt; PersonAgeComparator());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Arrays.sort的声明为：public static &amp;lt;T&amp;gt; void sort(T[] a, Comparator&amp;lt;? super T&amp;gt; c)，比较器参数Comparator为一个函数式接口，利用上一节Lambda表达式所学知识，可以改写为以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Person[] rosterAsArray = &lt;span&gt;new&lt;/span&gt; Person[30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加数组元素省略&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; Arrays.sort(rosterAsArray, (a,b) -&amp;gt; a.getAge().compareTo(b.getAge()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然而，你会发现，Perdon类中已经有了一个静态方法的比较器：compareByAge，因此，我们改用Person类已经提供的比较器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Person[] rosterAsArray = &lt;span&gt;new&lt;/span&gt; Person[30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加数组元素省略&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; Arrays.sort(rosterAsArray, (a,b) -&amp;gt; Person.compareByAge(a,b));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上代码，因为Lambda表达式调用了一个已经存在的静态方法，根据我们第2节表格中的语法，上面的代码可以最终改写成静态方法引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Person[] rosterAsArray = &lt;span&gt;new&lt;/span&gt; Person[30&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加数组元素省略&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; Arrays.sort(rosterAsArray, Person::compareByAge);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面这个例子更简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         List&amp;lt;Integer&amp;gt; list = Arrays.asList(82,22,34,50,9&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        list.sort(Integer::compare);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        System.out.println(list);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对一个Integer列表进行排序，因为Integer中已经存在静态的比较方法compare()，因此可以直接用静态方法引用的方式来调用 ，运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[9, 22, 34, 50, 82]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 实例方法引用&lt;/h3&gt;
&lt;p&gt;　　实例方法引用，顾名思义就是调用已经存在的实例的方法，与静态方法引用不同的是类要先实例化，静态方法引用类无需实例化，直接用类名去调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User(String name, Integer age) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestInstanceReference {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         TestInstanceReference test = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestInstanceReference();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt; User(&quot;欧阳峰&quot;,32&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Supplier&amp;lt;String&amp;gt; supplier = () -&amp;gt;&lt;span&gt; user.getName();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(&quot;Lambda表达式输出结果：&quot; +&lt;span&gt; supplier.get());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         Supplier&amp;lt;String&amp;gt; supplier2 =&lt;strong&gt;&lt;span&gt; user::getName;
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;23&lt;/span&gt;         System.out.println(&quot;实例方法引用输出结果：&quot; +&lt;span&gt; supplier2.get());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Lambda表达式输出结果：欧阳峰
实例方法引用输出结果：欧阳峰&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3 对象方法引用&lt;/h3&gt;
&lt;p&gt;　　若Lambda参数列表中的第一个参数是实例方法的参数调用者，而第二个参数是实例方法的参数时，可以使用对象方法引用。&lt;/p&gt;
&lt;p&gt;String的equals()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object anObject) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; anObject) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (anObject &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             String anotherString =&lt;span&gt; (String)anObject;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; value.length;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (n ==&lt;span&gt; anotherString.value.length) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;char&lt;/span&gt; v1[] =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;char&lt;/span&gt; v2[] =&lt;span&gt; anotherString.value;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (n-- != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (v1[i] !=&lt;span&gt; v2[i])
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;    BiPredicate&amp;lt;String,String&amp;gt; bp = (x, y) -&amp;gt;&lt;span&gt; x.equals(y);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;    BiPredicate&amp;lt;String,String&amp;gt; bp1 =&lt;span&gt;&lt;strong&gt;&lt;span&gt; String::equals&lt;/span&gt;&lt;/strong&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;    &lt;span&gt;boolean&lt;/span&gt; test = bp1.test(&quot;xy&quot;, &quot;xx&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;   System.out.println(test);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　BiPredicate的test()方法接受两个参数，x和y，具体实现为x.equals(y)，满足Lambda参数列表中的第一个参数是实例方法的参数调用者，而第二个参数是实例方法的参数，因此可以使用对象方法引用。&lt;/p&gt;
&lt;h3&gt;3.4 构造方法引用&lt;/h3&gt;
&lt;p&gt;　　注意：需要调用的构造器的参数列表要与函数式接口中抽象方法的参数列表保持一致。&lt;/p&gt;
&lt;p&gt;　　如：要获取一个空的User列表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Supplier&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; userSupplier = () -&amp;gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; List&amp;lt;User&amp;gt; user =&lt;span&gt; userSupplier.get();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; Supplier&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; userSupplier2 = ArrayList&amp;lt;User&amp;gt;::&lt;span&gt;new&lt;/span&gt;&lt;span&gt;;    &lt;span&gt;// 构造方法引用写法
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; List&amp;lt;User&amp;gt; user2 = userSupplier.get();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，方法引用讲完了，下一章节将讲解Stream API。&lt;/p&gt;


</description>
<pubDate>Wed, 17 Apr 2019 15:39:00 +0000</pubDate>
<dc:creator>无恨之都</dc:creator>
<og:description>上一节介绍了Java8新特性中的Lambda表达式，本小节继续讲解Java8的新特性之二：方法引用。方法引用其实也离不开Lambda表达式。 1、方法引用的使用场景 我们用Lambda表达式来实现匿名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhenzhidu/p/10727065.html</dc:identifier>
</item>
<item>
<title>如何给列表降维？sum()函数的妙用 - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/10727060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/10727060.html</guid>
<description>&lt;p&gt;上个月，学习群里的 S 同学问了个题目，大意可理解为&lt;code&gt;列表降维&lt;/code&gt; ，例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;oldlist = [[&lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;2, &lt;span class=&quot;hljs-number&quot;&gt;3], [&lt;span class=&quot;hljs-number&quot;&gt;4, &lt;span class=&quot;hljs-number&quot;&gt;5]]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原始数据是一个二维列表，目的是获取该列表中所有元素的具体值。从抽象一点的角度来理解，也可看作是列表解压或者列表降维。&lt;/p&gt;
&lt;p&gt;这个问题并不难，但是，怎么写才比较优雅呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法简单粗暴，需要拼接什么内容，就取出来直接拼接。然而，如果原列表有很多子列表，则这个方法就会变得繁琐了。&lt;/p&gt;
&lt;p&gt;我们把原问题升级一下：&lt;strong&gt;一个二维列表包含 n 个一维列表元素，如何优雅地把这些子列表拼成一个新的一维列表？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法一的做法需要写 n 个对象，以及 n - 1 次拼接操作。当然不可行。下面看看方法二：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;这个表达式中出现了两个 for 语句，在第一个 for 语句中，我们先取出原列表的长度，然后构造 range 对象，此时 j 的取值范围是 [0, n-1] 的闭区间。&lt;/p&gt;
&lt;p&gt;在第二个 for 语句中，oldlist[j] 指的正是原列表的第 j 个子列表，&lt;code&gt;for i in oldlist[j]&lt;/code&gt; 则会遍历取出 j 子列表的元素，由于 j 取值的区间正对应于原列表的全部索引值，所以，最终达到解题目的。&lt;/p&gt;
&lt;p&gt;这种方法足够优雅了，而且理解也并不难。&lt;/p&gt;
&lt;p&gt;然而，我们是否就能满足于此了呢？有没有其它奇技淫巧，哦不，是其它高级方法呢？F 同学贡献了一个思路：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;说实话，这个方法令我大感意外！sum() 函数不是用于求和的么？怎么竟然有此用法？&lt;/p&gt;
&lt;p&gt;这个写法利用了什么原理呢？由于我开始时不知道 sum() 函数可以接收两个参数，不清楚它们是怎么用于计算的，所以一度很困惑。但是，当我知道 sum() 的完整用法时，我恍然大悟。&lt;/p&gt;
&lt;p&gt;接下来也不卖关子了，直接揭晓吧。&lt;/p&gt;
&lt;p&gt;语法： &lt;code&gt;sum(iterable[, start])&lt;/code&gt; ，sum() 函数的第一个参数是可迭代对象，如列表、元组或集合等，第二个参数是起始值，默认为 0 。其用途是以 start 值为基础，再与可迭代对象的所有元素相“加”。&lt;/p&gt;
&lt;p&gt;在上例中，执行效果是 oldlist 中的子列表逐一与第二个参数相加，而列表的加法相当于 extend 操作，所以最终结果是由 [] 扩充成的列表。&lt;/p&gt;
&lt;p&gt;这里有两个关键点：&lt;strong&gt;sum() 函数允许带两个参数，且第二个参数才是起点。&lt;/strong&gt; 可能 sum() 函数用于数值求和比较多，然而用于作列表的求和，就有奇效。它比列表推导式更加优雅简洁！&lt;/p&gt;
&lt;p&gt;至此，前面的升级版问题就得到了很好的回答。简单回顾一下，s 同学最初的问题可以用三种方法实现，第一种方法中规中矩，第二种方法正道进阶，而第三种方法旁门左道（没有贬义，只是说它出人意料，却效果奇佳）。&lt;/p&gt;
&lt;p&gt;这道并不算难的问题，在众人的讨论与分享后，竟还引出了很有价值的学习内容。前不久，同样是群内的一个问题，也产生了同样的学习效果，详见《&lt;a href=&quot;https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw&quot;&gt;Python进阶：如何将字符串常量转为变量？&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;我从中得到了一个启示：&lt;strong&gt;应该多角度地思考问题，设法寻求更优解，同时，基础知识应掌握牢固，并灵活贯通起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学无止境，这里我还想再开拓一下思路，看看能发现些什么。&lt;/p&gt;
&lt;p&gt;1、如果原列表的元素除了列表，还有其它类型的元素，怎么把同类的元素归并在一起呢？&lt;/p&gt;
&lt;p&gt;2、如果是一个三维或更高维的列表，怎么更好地把它们压缩成一维列表呢？&lt;/p&gt;
&lt;p&gt;3、sum() 函数还有什么知识要点呢？&lt;/p&gt;
&lt;p&gt;前两个问题增加了复杂度，解决起来似乎没有“灵丹妙药”了，只能用笨方法分别拆解，逐一解压。&lt;/p&gt;
&lt;p&gt;第三个思考题是关于 sum() 函数本身的用法，我们看看官方文档是怎么说的：&lt;/p&gt;
&lt;blockquote readability=&quot;12.815384615385&quot;&gt;
&lt;p&gt;The &lt;em&gt;iterable&lt;/em&gt;’s items are normally numbers, and the start value is not allowed to be a string.&lt;/p&gt;
&lt;p&gt;For some use cases, there are good alternatives to &lt;a href=&quot;https://docs.python.org/3/library/functions.html#sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt;. The preferred, fast way to concatenate a sequence of strings is by calling &lt;code&gt;''.join(sequence)&lt;/code&gt;. To add floating point values with extended precision, see &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.fsum&quot;&gt;&lt;code&gt;math.fsum()&lt;/code&gt;&lt;/a&gt;. To concatenate a series of iterables, consider using &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.chain&quot;&gt;&lt;code&gt;itertools.chain()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sum() 的第二个参数不允许是字符串。如果用了，会报错：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;TypeError: sum() can't sum strings [use ''.join(seq) instead]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么不建议使用 sum() 来拼接字符串呢？哈哈，文档中建议使用 join() 方法，因为它更快。为了不给我们使用慢的方法，它竟特别限定不允许 sum() 的第二个参数是字符串。&lt;/p&gt;
&lt;p&gt;文档还建议，在某些使用场景时，不要用 sum() ，例如当以扩展精度对浮点数求和时，推荐使用 &lt;code&gt;math.fsum()&lt;/code&gt; ；当要拼接一系列的可迭代对象时，应考虑使用 &lt;code&gt;itertools.chain()&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;浮点数的计算是个难题，我曾转载过一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/4Se4j-_N0cXiWvoQSRHp1w&quot;&gt;如何在 Python 里面精确四舍五入？&lt;/a&gt;》，对此有精彩分析。而&lt;code&gt;itertools.chain()&lt;/code&gt; 可以将不同类型的可迭代对象串联成一个更大的迭代器，这在旧文《&lt;a href=&quot;https://mp.weixin.qq.com/s/7MbRCn37fIIN42rLm6ho3g&quot;&gt;Python进阶：设计模式之迭代器模式&lt;/a&gt;》中也有论及。&lt;/p&gt;
&lt;p&gt;不经意间，sum() 函数的注意事项，竟把 Python 其它的进阶内容都联系起来了。小小的函数，竟成为学习之路上的一个枢纽。&lt;/p&gt;
&lt;p&gt;前段时间，我还写过 range() 、locals() 和 eval() 等内置函数，也是通过一个问题点，而关联出多个知识点， 获益良多。这些内置函数/类的魔力可真不小啊。&lt;/p&gt;
&lt;p&gt;本文到此结束，希望对你有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;友情提示：&lt;/strong&gt; 本公众号内有限时抽奖活动，送出 Python 书籍 15 本，书目有《Python数据分析与挖掘实战》、《Python语言程序设计》《自学Python编程基础、科学计算及数据分析》《实用机器学习》、《Python程序员面试算法宝典》，活动结束时间为&lt;strong&gt;本月 20 日 18 点&lt;/strong&gt; ，赶快来抽奖啦！详情请戳：&lt;a href=&quot;https://mp.weixin.qq.com/s/8dhLmwKurlKy7y6IHzjzAg&quot;&gt;抽奖送书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】， 专注Python技术、数据科学和深度学习，力图创造一个有趣又有用的学习分享平台。本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、优质英文推荐与翻译等等，欢迎关注哦。PS：后台回复“&lt;strong&gt;爱学习&lt;/strong&gt;”，免费获得一份学习大礼包。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 15:37:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>上个月，学习群里的 S 同学问了个题目，大意可理解为列表降维 ，例子如下： 原始数据是一个二维列表，目的是获取该列表中所有元素的具体值。从抽象一点的角度来理解，也可看作是列表解压或者列表降维。 这个问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythonista/p/10727060.html</dc:identifier>
</item>
<item>
<title>python高级-动态特性(20) - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/10726350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/10726350.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、动态语⾔的定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。现在比较热门的动态语言有：Python、PHP、JavaScript、Objective-C等，而 C 、 C++ 等语言则不属于动态语言。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-运行的过程中给对象绑定添加属性&quot;&gt;&lt;span&gt;二、运行的过程中给对象绑定(添加)属性&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name=None,age=&lt;span&gt;None):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age

p &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(p.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(p.age)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里我们只定义了name和age两个属性，但是在类已经定义好了之后，我们仍然可以往里面添加属性，这就是动态语言的好处，动态的给实例绑定属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name=None,age=&lt;span&gt;None):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age

p &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(p.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(p.age)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;动态添加属性&lt;/span&gt;
p.sex = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(p.sex)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;小明
24
男&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-运行的过程中给类绑定添加属性&quot;&gt;&lt;span&gt;三、运行的过程中给类绑定(添加)属性&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name=None,age=&lt;span&gt;None):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age


P1 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,24&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(P1.sex)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\Users\Se7eN_HOU\Desktop\test.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 8, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(P1.sex)
AttributeError: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Person&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; object has no attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是程序报错说，Person没有sex这个属性，我们可以通过给Person动态绑定属性，解决问题&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name=None,age=&lt;span&gt;None):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age


P1 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,24&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;动态给类添加属性&lt;/span&gt;
Person.sex = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(P1.sex)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个时候在运行就不会出错，而且会打印出P1.sex为男&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-运行的过程中给类绑定添加方法&quot;&gt;&lt;span&gt;四、运行的过程中给类绑定(添加)方法&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name=None,age=&lt;span&gt;None):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在吃东西&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

P1 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,24&lt;span&gt;)
P1.eat()
P1.run()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;正在吃东西
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\Users\Se7eN_HOU\Desktop\test.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 11, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;span&gt;

    P1.run()
AttributeError: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Person&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; object has no attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;说明：正在吃东西打印出来了，说明eat函数被执行，但是后面报错说没有run这个属性，但是我想在类创建好了以后，在运行的时候动态的添加run方法怎么办呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;动态添加方法需要导入types模块&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; types
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name=None,age=&lt;span&gt;None):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在吃东西&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义好需要动态添加的方法&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在跑步&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    
P1 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,24&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;正常调用类里面的函数&lt;/span&gt;
&lt;span&gt;P1.eat()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;给对象动态绑定方法&lt;/span&gt;
P1.run =&lt;span&gt; types.MethodType(run,P1)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对象调用动态绑定的方法&lt;/span&gt;
P1.run()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;正在吃东西
在跑步&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;打印出来“在跑步”说明run方法被正常执行了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态绑定类方法和静态方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;动态添加方法需要导入types模块&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; types
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name=None,age=&lt;span&gt;None):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在吃东西&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义好需要动态添加的实例方法&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在跑步&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义好需要动态添加的类方法&lt;/span&gt;
&lt;span&gt;@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; dynamicClassMethod(cls):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个动态添加的类方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义好需要动态添加的静态方法&lt;/span&gt;
&lt;span&gt;@staticmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; dynamicStaticMethod():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个动态添加的静态方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    
P1 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,24&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;正常调用类里面的函数&lt;/span&gt;
&lt;span&gt;P1.eat()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;给对象动态绑定方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;MethodType(参数1,参数2)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;参数1：是动态绑定哪个方法，只写方法名即可&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;参数2：是把这个方法动态的绑定给谁&lt;/span&gt;
P1.run =&lt;span&gt; types.MethodType(run,P1)
P1.run()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;动态绑定类方法的使用&lt;/span&gt;
Person.dynamicClassMethod =&lt;span&gt; dynamicClassMethod
Person.dynamicClassMethod()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;动态绑定静态方法的使用&lt;/span&gt;
Person.dynamicStaticMethod =&lt;span&gt; dynamicStaticMethod
Person.dynamicStaticMethod()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;给对象绑定属性直接在使用前进行赋值使用即可&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;给对象动态绑定方法需要import types模块&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;给对象动态绑定实例方法，需要使用type.MethodType（）方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;给类添加类方法和静态方法，也是直接在使用前赋值即可使用&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;5-运行的过程中删除属性、方法&quot;&gt;&lt;span&gt;五、运行的过程中删除属性、方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;删除的方法:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;del 对象.属性名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;delattr(对象, &quot;属性名&quot;)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name=None,age=&lt;span&gt;None):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age

P1 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,24&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------删除前---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(P1.name)

&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; P1.name

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------删除后---------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(P1.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
---------删除前---------&lt;span&gt;
小明
&lt;/span&gt;---------删除后---------
&lt;span&gt;print&lt;/span&gt;(P1.name)AttributeError: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Person&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; object has no attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;slots&quot;&gt;&lt;span&gt;六、__slots__&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;pg-emphasize pg-emphasize-yellow&quot;&gt;动态语言：可以在运行的过程中，修改代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pg-emphasize pg-emphasize-yellow&quot;&gt;静态语言：编译时已经确定好代码，运行过程中不能修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们想要限制实例的属性怎么办？比如，只允许对Person实例添加name和age属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;__slots__&lt;/span&gt;=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

p &lt;/span&gt;=&lt;span&gt; Person()
p.name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
p.age &lt;/span&gt;= 40
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(p.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(p.age)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;slots之外的属性&lt;/span&gt;
p.sex = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(p.sex)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;老王
&lt;/span&gt;40&lt;span&gt;
    p.sex &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
AttributeError: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Person&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; object has no attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;注意&quot;&gt;&lt;span&gt;注意:&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 17 Apr 2019 15:35:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、动态语⾔的定义 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。现在比较热门的动态语言有：Python、PHP、JavaScript、Obj</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Se7eN-HOU/p/10726350.html</dc:identifier>
</item>
<item>
<title>命令行中的 vi 模式 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/cli_vi_mode.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/cli_vi_mode.html</guid>
<description>&lt;p&gt;命令行中修改已经输入的命令比较麻烦，如果你不知道一些快捷键的话，只能使用方向键一个一个字符地移动到目标位置进行修改，对于比较复杂且过长的命令来说，效率不高。&lt;/p&gt;
&lt;p&gt;以下信息来自 bash 的 man 页面：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
$ man bash
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; ...&lt;/span&gt;

   Commands &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; Moving
       beginning-of-line (C-a)
              Move to the start of the current line.
       end-of-line (C-e)
              Move to the end of the line.
       forward-char (C-f)
              Move forward a character.
       backward-char (C-b)
              Move back a character.
       forward-word (M-f)
              Move  forward  to  the end of the next word.  Words are composed of alphanu-
              meric characters (letters and digits).
       backward-word (M-b)
              Move back to the start of the current or previous word.  Words are  composed
              of alphanumeric characters (letters and digits).
       clear-screen (C-l)
              Clear the screen leaving the current line at the top of the screen.  With an
              argument, refresh the current line without clearing the screen.
       redraw-current-line
              Refresh the current line.

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可看到 bash 本身提供了一些有用的快捷键可在命令中快速导航，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;a&lt;/kbd&gt; 定位到行首（st&lt;strong&gt;a&lt;/strong&gt;rt）&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;e&lt;/kbd&gt; 定位到行末（&lt;strong&gt;e&lt;/strong&gt;nd）&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;f&lt;/kbd&gt; 向前移动一个单词（&lt;strong&gt;f&lt;/strong&gt;orward）&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;b&lt;/kbd&gt; 向后移动一个单词（&lt;strong&gt;b&lt;/strong&gt;ack）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;移动光标，大部分情况下，我觉得记住这四个可以满足日常需求。&lt;/p&gt;
&lt;p&gt;除了移动光标，还有一些编辑的快捷键，在 man 页面中 Killing and Yanking 部分，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; ...&lt;/span&gt;

   Killing and Yanking
       kill-line (C-k)
              Kill the text from point to the end of the line.
       backward-kill-line (C-x Rubout)
              Kill backward to the beginning of the line.
       unix-line-discard (C-u)
              Kill  backward  from point to the beginning of the line.  The killed text is
              saved on the kill-ring.
       kill-whole-line
              Kill all characters on the current line, no matter where point is.
       kill-word (M-d)
              Kill from point to the end of the current word, or &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; between words, to  the
              end  of  the  next word.  Word boundaries are the same as those used by for-
              ward-word.
       backward-kill-word (M-Rubout)
              Kill the word behind point.  Word boundaries are the same as those  used  by
              backward-word.
       unix-word-rubout (C-w)
              Kill  the  word  behind  point,  using  white space as a word boundary.  The
              killed text is saved on the kill-ring.
       unix-filename-rubout
              Kill the word behind point, using white space and the slash character as the
              word boundaries.  The killed text is saved on the kill-ring.
       delete-horizontal-space (M-&lt;span class=&quot;pl-cce&quot;&gt;\)&lt;/span&gt;
              Delete all spaces and tabs around point.
       kill-region
              Kill the text &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; the current region.
       copy-region-as-kill
              Copy the text &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; the region to the &lt;span class=&quot;pl-c1&quot;&gt;kill&lt;/span&gt; buffer.
       copy-backward-word
              Copy  the word before point to the &lt;span class=&quot;pl-c1&quot;&gt;kill&lt;/span&gt; buffer.  The word boundaries are the
              same as backward-word.
       copy-forward-word
              Copy the word following point to the &lt;span class=&quot;pl-c1&quot;&gt;kill&lt;/span&gt; buffer.  The word  boundaries  are
              the same as forward-word.
       yank (C-y)
              Yank the top of the &lt;span class=&quot;pl-c1&quot;&gt;kill&lt;/span&gt; ring into the buffer at point.
       yank-pop (M-y)
              Rotate  the  &lt;span class=&quot;pl-c1&quot;&gt;kill&lt;/span&gt;  ring, and yank the new top.  Only works following yank or
              yank-pop.

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中这一个我最常用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;u&lt;/kbd&gt; 删除当前光标位置到行首的内容，配合着 &lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;e&lt;/kbd&gt; 把光标定位到行末再使用该命令，可实现清空整行的效果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了这些快捷键，其实命令行还有个 vi 模式，该模式下的表现和在 vi 编辑器里一样，对于 vi 用户来说，进入这种模式后，编辑和修改命令就显得十分得心应手了。&lt;/p&gt;
&lt;h2&gt;开启 vi 模式&lt;/h2&gt;
&lt;p&gt;不同 shell 中开启的命令不一样，我比较偏好 &lt;a href=&quot;https://fishshell.com&quot; rel=&quot;nofollow&quot;&gt;fish&lt;/a&gt;，因为它的自动补全真的好用到无以复加。&lt;/p&gt;
&lt;p&gt;运行 &lt;code&gt;fish_vi_key_bindings&lt;/code&gt; 即可进入 vi 模式。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ fish_vi_key_bindings
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行 &lt;code&gt;fish_default_key_bindings&lt;/code&gt; 回到默认。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ fish_default_key_bindings
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/56299503-bf90b100-6166-11e9-8c1f-d103a7be9af2.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/56299503-bf90b100-6166-11e9-8c1f-d103a7be9af2.gif&quot; alt=&quot;命令行的 vi 模式演示&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;命令行的 vi 模式演示&lt;/p&gt;
&lt;p&gt;如果需要一直开始，可以配置文件中添加上述命令。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ vi &lt;span class=&quot;pl-k&quot;&gt;~&lt;/span&gt;/.config/fish/config.fish

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 其他代码&lt;/span&gt;
fish_vi_key_bindings
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;选择合适的主题&lt;/h2&gt;
&lt;p&gt;你可能需要一个可以在命令提示行中显示当前 vi 状态的主题。&lt;/p&gt;
&lt;p&gt;推荐 fish 搭配 omf 使用 omf 中的&lt;a href=&quot;https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md&quot;&gt;主题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;fish 有默认的 vi 状态展示，和主题很不搭配。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/56299552-dafbbc00-6166-11e9-8120-6d67820d85d8.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/56299552-dafbbc00-6166-11e9-8120-6d67820d85d8.png&quot; alt=&quot;fish 默认的 vi 状态展示&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;fish 默认的 vi 状态展示&lt;/p&gt;
&lt;p&gt;需要手动去掉，配置文件中添加如下脚本：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;fish_mode_prompt;&lt;/span&gt; end
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;修正 fish 中的自动补全&lt;/h2&gt;
&lt;p&gt;如果发现 vi 模式下， fish 的自动补全快捷键 &lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;f&lt;/kbd&gt; 不能用了，可在配置文件中添加如下脚本来修复这个快捷键：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;fish_user_key_bindings&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; insert default visual
        &lt;span class=&quot;pl-c1&quot;&gt;bind&lt;/span&gt; -M &lt;span class=&quot;pl-smi&quot;&gt;$mode&lt;/span&gt; &lt;span class=&quot;pl-cce&quot;&gt;\c&lt;/span&gt;f forward-char
    end
end
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 17 Apr 2019 15:21:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>命令行中修改已经输入的命令比较麻烦，如果你不知道一些快捷键的话，只能使用方向键一个一个字符地移动到目标位置进行修改，对于比较复杂且过长的命令来说，效率不高。 以下信息来自 bash 的 man 页面：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/cli_vi_mode.html</dc:identifier>
</item>
<item>
<title>模板模式 - 浪潮之巅、</title>
<link>http://www.cnblogs.com/JackSparrow-/p/10713978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JackSparrow-/p/10713978.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;模板模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    模板模式：一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，这种设计方式将一些步骤延迟到子类实现，但是子类却可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;    模板方法为我们提供了一种代码复用的技巧，模板方法的抽象类可以定义具体方法、抽象方法和钩子。抽象方法由子类实现，钩子是一种方法，它可以不做任何事情，或者只做默认的事情，由子类决定是否覆盖这个方法。&lt;/p&gt;
&lt;p&gt;   下面举个例子来阐述一下这个设计模式。&lt;/p&gt;
&lt;p&gt;   比如说你和你对象去口渴了店里买饮料喝，一个要金桔柠檬，一个要珍珠奶茶。我们来想一下饮料的制作过程。&lt;/p&gt;
&lt;p&gt;金桔柠檬：                                            珍珠奶茶：&lt;/p&gt;
&lt;p&gt;1、把水倒入容器中                             1、把水倒进容器&lt;/p&gt;
&lt;p&gt;2、加柠檬 、椰果等                             2、加调料（奶茶、珍珠等）&lt;/p&gt;
&lt;p&gt;3、搅拌                                                3、搅拌&lt;/p&gt;
&lt;p&gt;我们来用代码实现这些操作步骤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 金桔柠檬
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Lemon {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒水&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourWater(){};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加柠檬&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourLemon(){};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;搅拌&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stir(){}
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 奶茶
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MilkTea {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒水&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourWater(){};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加珍珠&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourPearl(){};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;搅拌&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stir(){}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    金桔柠檬和奶茶的制作有相同的地方，我们把这些共性进一步抽象,定义一个抽象类，将这些共性的东西，比如说倒水喝搅拌的动作，不希望子类修改的用final来修饰，而放调料由子类决定需要哪些调料，定义成抽象的方法，让子类必须去实现它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MakeDrink {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒水&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourWater(){ };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;搅拌&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stir(){};
　　//加调料
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; putSomething();

}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 奶茶
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MilkTea &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MakeDrink{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; putSomething() {
        System.out.println(&lt;/span&gt;&quot;放珍珠&quot;&lt;span&gt;);
    }
}


&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 金桔柠檬
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Lemon &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MakeDrink{


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; putSomething() {
        System.out.println(&lt;/span&gt;&quot;放柠檬&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是一个简单的模板模式的应用。&lt;/p&gt;
&lt;p&gt;    好的，饮料制作好了，服务人员问你是打包还是现在就喝，你的对象说打包，但是你现在就想喝，那么可以在定义一个默认的方法，做一些默认的事情，比如说给你包装好，喝不喝随你，你可以重写这个方法，也可以选着不重写，这就是钩子。&lt;/p&gt;
&lt;p&gt;我们在抽象类里面再加个打包的方法，Lemon类重写这个方法，而MilkTea采用父类默认的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MakeDrink {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒水&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourWater(){ };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;搅拌&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stir(){};

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; putSomething();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; packageDrink(){
        System.out.println(&lt;/span&gt;&quot;打包好了&quot;&lt;span&gt;);
    }

}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 金桔柠檬
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Lemon &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MakeDrink{


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; putSomething() {
        System.out.println(&lt;/span&gt;&quot;放柠檬&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; packageDrink(){
        System.out.println(&lt;/span&gt;&quot;我现在就喝&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   我们平时代码开发经常用到这种模式，一些框架用到的也非常多，像Spring的JDBCTemplate。使用模板模式能够将代码的复用最大化，算法只存在于一个地方，容易修改。&lt;/p&gt;

</description>
<pubDate>Wed, 17 Apr 2019 15:14:00 +0000</pubDate>
<dc:creator>浪潮之巅、</dc:creator>
<og:description>模板模式 模板模式：一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，这种设计方式将一些步骤延迟到子类实现，但是子类却可以不改变一个算法的结构即可重定义该算法的某些特定步骤</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JackSparrow-/p/10713978.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]高级查询（化繁为简、分页提升性能） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_search.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_search.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netstandard，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 754+）&lt;/p&gt;


&lt;p&gt;前文&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html#_label6&quot; target=&quot;_blank&quot;&gt;《[NewLife.XCode]实体类详解》&lt;/a&gt;中有讲到扩展查询，XCode生成实体类代码时，在模型类有一个region叫“扩展查询”，一般是FindByAbc/FindAllByAbc的形式。&lt;/p&gt;
&lt;p&gt;扩展查询以数据表索引为依据来生成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;唯一索引（含主键）生成FindByAbc方法（如FindByName），返回单个对象；&lt;/li&gt;
&lt;li&gt;非唯一索引生成FindAllByAbc方法（如FindAllByClassID），返回对象列表（非null）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190417211648062-2079026478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，可知Entity实体基类内部，查询方法分为单对象查询的Find和对象列表的查询FindAll。&lt;/p&gt;
&lt;p&gt;实际上，Find最终调用FindAll方法查一行。&lt;/p&gt;

&lt;p&gt;Find/FindAll有多个重载，最主要的地方都是构造where查询条件。&lt;/p&gt;
&lt;p&gt;下划线_是每个实体类都有的内嵌类，它包含了每一个字段的Field引用，借助运算符重载，可以很方便的构造查询条件，例如上面的_.Name == name最终会生成 where Name='Stone'&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190417213433311-191770165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为是内嵌类，在实体类内部使用的时候非常方便。但要是想要实体类外部使用，就麻烦很多了，需要带上实体类类名。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;原则：XCode是充血模型，不管多么简单的查询，建议都封装Find/FindAll/Search等方法供外部使用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; 仅靠一两个字段的简单查询，肯定无法满足各种业务要求，我们需要更强大的查询支持，特别是根据不同条件拼接不同语句。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190417214203260-2133769925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190417214252107-529613287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是两个非常典型的业务查询。&lt;/p&gt;
&lt;p&gt;这里请出了条件表达式WhereExpression，实际上它只有两个功能，&amp;amp;表示And，|表示Or，根据表达式级别支持括号运算。&lt;/p&gt;
&lt;p&gt;exp&amp;amp;=xxx 是最常用的写法，右边一般是各种Field表达式。&lt;/p&gt;
&lt;p&gt;上面第一个例子，生成的查询语句可能是 select * from Student where classid=?classid and name like '%?key%'&lt;/p&gt;
&lt;p&gt;为什么说“可能”？因为classid为0，或者key为空时，并不会参与拼接查询语句。&lt;/p&gt;

&lt;p&gt;第二个例子稍微复杂一些，首先对key进行精确查询，找到了就返回，若是没找到，则开启模糊查询。 &lt;/p&gt;
&lt;p&gt;这里遇到了等于、包含、区间等判断操作，后面会详解所有支持的操作。&lt;/p&gt;

&lt;p&gt;如非必要，建议保留select * 的查询方式，而不是指定列。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;码农法则：数据库压力小于100qps时不要考虑指明select列来优化，大多数系统活不到需要优化的明天！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;两个例子都出现了一个PageParameter参数page，这是分页参数，包含分页查询以及排序所需要的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190417222710264-1701063099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PageIndex和PageSize指定页序号和每页大小，这是内部建立分页查询的核心依据；&lt;/p&gt;
&lt;p&gt;Sort 指定排序字段，Desc 指定是否降序（默认升序）；&lt;/p&gt;
&lt;p&gt;RetrieveTotalCount 指定是否或者总记录数，若为true，则在查询记录集之前，先查询满足条件的总行数TotalCount，用于分页PageCount。此时等于执行两次数据库查询；&lt;/p&gt;
&lt;p&gt;RetrieveState 指定是否获取统计 State，若为true，则在查询记录集之后，执行聚合查询，对数字型字段使用Sum聚合。此时最多可能执行3次数据库查询；&lt;/p&gt;

&lt;p&gt;XCode要求数据查询必须考虑分页，没有分页的系统一般死在100万行以内。&lt;/p&gt;


&lt;p&gt;内嵌类_引用的字段是Field，它继承自FieldItem。&lt;/p&gt;
&lt;p&gt;Field/FieldItem全部功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Equal 等于，操作符==&lt;/li&gt;
&lt;li&gt;NotEqual 不等于，操作符!=&lt;/li&gt;
&lt;li&gt;大于操作符&amp;gt;，大于等于&amp;gt;=&lt;/li&gt;
&lt;li&gt;小于操作符&amp;lt;，小于等于&amp;lt;=&lt;/li&gt;
&lt;li&gt;StartsWith 字符串开始，like '{0}%'。（支持索引）&lt;/li&gt;
&lt;li&gt;EndsWith 字符串结束，like '%{0}'&lt;/li&gt;
&lt;li&gt;Contains 字符串包含，like '%{0}%'&lt;/li&gt;
&lt;li&gt;In 集合包含，支持列表集合、字符串子查询和SelectBuilder子查询，集合只有一个元素时转为相等操作&lt;/li&gt;
&lt;li&gt;NotIn 集合不包含，支持列表集合、字符串子查询和SelectBuilder子查询，集合只有一个元素时转为不相等操作&lt;/li&gt;
&lt;li&gt;IsNull 是否空&lt;/li&gt;
&lt;li&gt;NotIsNull 不是空&lt;/li&gt;
&lt;li&gt;IsNullOrEmpty 字符串空或零长度&lt;/li&gt;
&lt;li&gt;NotIsNullOrEmpty 字符串非空非零长度&lt;/li&gt;
&lt;li&gt;IsTrue 是否True或者False/Null，参数决定两组之一&lt;/li&gt;
&lt;li&gt;IsFalse 是否False或者True/Null，参数决定两组之一&lt;/li&gt;
&lt;li&gt;Between 时间区间，大于等于开始，小于结束，如果开始结束都只有日期而没有时分秒，则结束加一天，如（2019-04-17,  2019-04-17）查 time&amp;gt;='2019-04-17' and time&amp;lt;2019-04-18'&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;排序字句/分组聚合&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Asc，升序&lt;/li&gt;
&lt;li&gt;Desc，降序。order by name desc&lt;/li&gt;
&lt;li&gt;GroupBy，分组。group by name&lt;/li&gt;
&lt;li&gt;As，聚合别名&lt;/li&gt;
&lt;li&gt;Count，计数&lt;/li&gt;
&lt;li&gt;Sum，求和&lt;/li&gt;
&lt;li&gt;Min，最小&lt;/li&gt;
&lt;li&gt;Max，最大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;查询的本质是五参数版FindAll(where, order, selects, start, maxnums)，其它查询方式都由它转化而来！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Entity实体基类封装了各种常用的查询方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190417221417846-1979599099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190417221600918-915212593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190417221655588-1105882964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于单表查询的XCode来说，五参数版FindAll很容易得到 &lt;span&gt;&lt;strong&gt;&lt;span&gt;select [selects] from [table] where [where] order by [order] limit [start], [maxnums] &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;语句，根据这个理念，FindAll可以支持任意复杂查询！&lt;/p&gt;
&lt;p&gt;最终查询语句，由SelectBuilder类承载。 &lt;/p&gt;


&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd_adv.html&quot; target=&quot;_blank&quot;&gt;高级增删改&lt;/a&gt;。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dirty.html&quot; target=&quot;_blank&quot;&gt;脏数据&lt;/a&gt;。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_additional.html&quot; target=&quot;_blank&quot;&gt;增量累加&lt;/a&gt;。高并发统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_transaction.html&quot; target=&quot;_blank&quot;&gt;事务处理&lt;/a&gt;。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_extend.html&quot; target=&quot;_blank&quot;&gt;扩展属性&lt;/a&gt;。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_search.html&quot; target=&quot;_blank&quot;&gt;高级查询&lt;/a&gt;。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dbcache.html&quot; target=&quot;_blank&quot;&gt;数据层缓存&lt;/a&gt;。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entitycache.html&quot; target=&quot;_blank&quot;&gt;实体缓存&lt;/a&gt;。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_singlecache.html&quot; target=&quot;_blank&quot;&gt;对象缓存&lt;/a&gt;。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_100billion.html&quot; target=&quot;_blank&quot;&gt;百亿级性能&lt;/a&gt;。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_factory.html&quot; target=&quot;_blank&quot;&gt;实体工厂&lt;/a&gt;。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_membership.html&quot; target=&quot;_blank&quot;&gt;角色权限&lt;/a&gt;。Membership&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_import_export.html&quot; target=&quot;_blank&quot;&gt;导入导出&lt;/a&gt;。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_division.html&quot; target=&quot;_blank&quot;&gt;分表分库&lt;/a&gt;。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_stat.html&quot; target=&quot;_blank&quot;&gt;高级统计&lt;/a&gt;。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_batch.html&quot; target=&quot;_blank&quot;&gt;批量写入&lt;/a&gt;。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_queue.html&quot; target=&quot;_blank&quot;&gt;实体队列&lt;/a&gt;。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_backup.html&quot; target=&quot;_blank&quot;&gt;备份同步&lt;/a&gt;。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_service.html&quot; target=&quot;_blank&quot;&gt;数据服务&lt;/a&gt;。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_bigdata.html&quot; target=&quot;_blank&quot;&gt;大数据分析&lt;/a&gt;。ETL抽取，调度计算处理，结果持久化&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Wed, 17 Apr 2019 14:36:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>码农法则：数据库压力小于100qps时不要考虑指明select列来优化，大多数系统活不到需要优化的明天！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/xcode_search.html</dc:identifier>
</item>
<item>
<title>回归树（Regression Tree） - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10724118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10724118.html</guid>
<description>&lt;p&gt;说到决策树（Decision tree），我们很自然会想到用其做分类，每个叶子代表有限类别中的一个。但是对于决策树解决回归问题，一直是一知半解，很多时候都是一带而过。&lt;/p&gt;
&lt;p&gt;对于一个回归问题，我们第一时间想到的可能就是线性回归（linear regression），当线性回归不好的时候，可能想着用 SVR（Support Vector Regression）试试。但回归树（regression tree）也很重要，现在 shallow learning 被 SVM 和树模型统治，随机森林、GBDT、xgboost、lightGBM 大行其道，所以知道什么是回归树很有必要。&lt;/p&gt;
&lt;p&gt;常用的决策树有 ID3、C4.5、CART 等，其中 CART 就可以用来做回归问题，CART 全称就是 Classification And Regression Tree（分类和回归树）。至于 ID3 和 C4.5，能不能用来做回归问题，等了解完 CART 回归树再讨论。&lt;/p&gt;
&lt;p&gt;接下来我们介绍将 CART 用于回归问题。&lt;/p&gt;
&lt;h2 id=&quot;回归树&quot;&gt;回归树&lt;/h2&gt;
&lt;p&gt;回归树（regression tree），顾名思义，就是用树模型做回归问题，每一片叶子都输出一个预测值。预测值一般是训练集中该片叶子所含元素输出的均值，即 &lt;span class=&quot;math inline&quot;&gt;\(c_{m} = ave(y_i | \bm x_i \in leaf_m)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;CART 在分类问题和回归问题中的相同和差异：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相同：
&lt;ul&gt;&lt;li&gt;在分类问题和回归问题中，CART 都是一棵二叉树，除叶子节点外的所有节点都有且仅有两个子节点；&lt;/li&gt;
&lt;li&gt;所有落在同一片叶子中的输入都有同样的输出。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;差异：
&lt;ul&gt;&lt;li&gt;在分类问题中，CART 使用基尼指数（Gini index）作为选择特征（feature）和划分（split）的依据；在回归问题中，CART 使用 mse（mean square error）或者 mae（mean absolute error）作为选择 feature 和 split 的 criteria。&lt;/li&gt;
&lt;li&gt;在分类问题中，CART 的每一片叶子都代表的是一个 class；在回归问题中，CART 的每一片叶子表示的是一个预测值，取值是连续的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面以 criteria = 'mse' 为例，介绍 CART 回归树。&lt;/p&gt;
&lt;h3 id=&quot;理论解释&quot;&gt;理论解释&lt;/h3&gt;
&lt;p&gt;给定一个数据集 &lt;span class=&quot;math inline&quot;&gt;\(D = \{(\bm x_1, y_1), (\bm x_2, y_2), ..., (\bm x_i, y_i), ...,(\bm x_n, y_n)\}\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(\bm x_i\)&lt;/span&gt; 是一个 m 维的向量，即 &lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt; 含有 m 个 features。&lt;/p&gt;
&lt;p&gt;回归问题的目标就是构造一个函数 &lt;span class=&quot;math inline&quot;&gt;\(f(\bm x)\)&lt;/span&gt; 能够拟合数据集 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 中的元素，使得 mse 最小，即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \min \frac{1}{n} \sum_{i = 1}^{n} (f(\bm x_i) - y_i)^2 \tag{1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用 CART 进行回归，目标自然也是一样的，最小化 mse。&lt;/p&gt;
&lt;p&gt;假设一棵构建好的 CART 回归树有 &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 片叶子，这意味着 CART 将输入空间 &lt;span class=&quot;math inline&quot;&gt;\(\bm x\)&lt;/span&gt; 划分成了 &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 个单元 &lt;span class=&quot;math inline&quot;&gt;\(R_1, R_2, ..., R_M\)&lt;/span&gt;，同时意味着 CART 至多会有 &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 个不同的预测值。CART 最小化 mse 公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \min \frac{1}{n} \sum_{m = 1}^{M}\sum_{\bm x_i \in R_m} (c_m - y_i)^2 \tag{2} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(c_m\)&lt;/span&gt; 表示第 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 片叶子的预测值。&lt;br/&gt;想要最小化 CART 总体的 mse，只需要最小化每一片叶子的 mse 即可，而最小化一片叶子的 mse，只需要将预测值设定为叶子中含有的训练集元素的均值，即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ c_{m} = ave(y_i | \bm x_i \in leaf_m) \tag{3} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以，在每一次的划分中，选择切分变量（splitting variable）和切分点（splitting point）时（也就是选择 feature 和将该 feature space 一分为二的 split），使得模型在训练集上的 mse 最小，也就是每片叶子的 mse 之和最小。&lt;/p&gt;
&lt;p&gt;这里采用启发式的方法，遍历所有的切分变量和切分点，然后选出 &lt;em&gt;叶子节点 mse 之和最小&lt;/em&gt; 的那种情况作为划分。选择第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个 feature &lt;span class=&quot;math inline&quot;&gt;\(\bm x^{(j)}\)&lt;/span&gt; 和它取的值 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;，作为切分变量和切分点，则切分变量和切分点将父节点的输入空间一分为二：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} R_1\{j, s\} = \{\bm x| \bm x^{(j)} \le s\} \\ R_2\{j, s\} = \{\bm x| \bm x^{(j)} &amp;gt; s\} \end{split} \tag{4} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CART 选择切分变量 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 和 切分点 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \min_{j, s} \left[\min_{c_1} \sum_{x_i \in R_1\{j, s\}} (y_i - c_1)^2 + \min_{c_2} \sum_{x_i \in R_2\{j, s\}} (y_i - c_1)^2 \right] \tag{5} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;采取遍历的方式，我们可以将 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 找出来：先固定 feature &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 再选出在该 feature 下的最佳划分 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;；对每一个 feature 都这样做，那么有 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个feature，我们就能得到 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个 feature 对应的最佳划分，从这 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个值中取最小值即可得到令全局最优的 &lt;span class=&quot;math inline&quot;&gt;\((j, s)\)&lt;/span&gt;。式（5）中，第一项 &lt;span class=&quot;math inline&quot;&gt;\(\min_{c_1} \sum_{x_i \in R_1\{j, s\}} (y_i - c_1)^2\)&lt;/span&gt; 得到的 &lt;span class=&quot;math inline&quot;&gt;\(c_1\)&lt;/span&gt; 值按照式（3）就是 &lt;span class=&quot;math inline&quot;&gt;\(ave(y_i | \bm x_i \in R_1\{j, s\})\)&lt;/span&gt;，同理，第二项中 &lt;span class=&quot;math inline&quot;&gt;\(c_2 = ave(y_i | \bm x_i \in R_2\{j, s\})\)&lt;/span&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;算法流程&quot;&gt;算法流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201904/1351564-20190417211629985-1738278490.png&quot; alt=&quot;最小二乘法回归树生成算法&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;id3-和-c4.5-能不能用来回归&quot;&gt;ID3 和 C4.5 能不能用来回归？&lt;/h2&gt;
&lt;p&gt;CART 是一棵二叉树，那么只要回归树不是一棵二叉树，那么就不是 CART 树了。&lt;/p&gt;
&lt;p&gt;在分类问题中，ID3、C4.5 和 CART 的区别就在与划分子节点的策略不同，信息增益、增益比、基尼指数；而在回归问题中，criteria 是 mse 或者 mae，这种情况下，分类时的 ID3、C4.5、CART 之间的区别就没了，那么就是每个父节点划分成多少个子节点的问题了，如果还是二叉树，那么就认为是 CART 回归树，否则就不是了。&lt;/p&gt;
&lt;p&gt;如果你在同一个时刻对某一个 feature &lt;span class=&quot;math inline&quot;&gt;\(\bm x^{(j)}\)&lt;/span&gt; 选择两个切分点 &lt;span class=&quot;math inline&quot;&gt;\(s_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(s_2\)&lt;/span&gt; 来划分父节点，那么就将产生三个区间 &lt;span class=&quot;math inline&quot;&gt;\(R_1\{j, s_1\}, R_2\{j, s_1, s_2\}, R_3\{j, s_2\}\)&lt;/span&gt;，这种做法无疑增大了遍历的难度，如果选择更多个切分点，那么遍历的难度会指数上升。如果我们想要细分多个区域，让 CART 回归树更深即可，这样遍历的难度会小很多。&lt;/p&gt;
&lt;p&gt;所以，固然可以构建非 CART 回归树，但是不如 CART 回归树来的更简单。&lt;/p&gt;
&lt;h2 id=&quot;回归树示例&quot;&gt;回归树示例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/auto_examples/tree/plot_tree_regression.html#sphx-glr-auto-examples-tree-plot-tree-regression-py&quot; target=&quot;_blank&quot;&gt;Decision Tree Regression -- scikit-learn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wuliytTaotao/Learning-Materials/blob/master/machine%20leanring/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.pdf&quot; target=&quot;_blank&quot;&gt;《统计学习方法》-- 李航&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://scikit-learn.org/stable/auto_examples/tree/plot_tree_regression.html#sphx-glr-auto-examples-tree-plot-tree-regression-py&quot; target=&quot;_blank&quot;&gt;Decision Tree Regression -- scikit-learn&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 14:18:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>决策树怎么处理回归问题，在 xgboost、lightGBM 大行其道的时候，了解什么是回归树是很有必要的。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/10724118.html</dc:identifier>
</item>
<item>
<title>【重学计算机】计算机操作系统 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/10669879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/10669879.html</guid>
<description>&lt;h2&gt;一、操作系统概述&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 计算机软硬件系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;冯诺伊曼结构&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;以运算单元为核心，控制流由指令流产生&lt;/li&gt;
&lt;li&gt;程序和数据存储在主存中&lt;/li&gt;
&lt;li&gt;主存是按地址访问，线性编址&lt;/li&gt;
&lt;li&gt;指令由操作码和地址码组成&lt;/li&gt;
&lt;li&gt;数据以二进制编码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他&lt;/strong&gt;：参考&lt;a href=&quot;https://www.cnblogs.com/flashsun/p/10628433.html&quot; target=&quot;_blank&quot;&gt;《重学计算机-计算机组成原理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 计算机操作系统的发展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;概述&lt;/strong&gt;：任何一台机器都有其操作平台和操作系统
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;洗衣机&lt;/strong&gt;：开关表示、按钮控制、亮灯显示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;演进过程&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;手工操作&lt;/strong&gt;：手动调动地址和数据按钮录入内存，然后点运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引进装入程序&lt;/strong&gt;：用卡片和纸带，通过ROM上的装入程序载入内存
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;汇编语言&lt;/strong&gt;：对指令提供了助记符号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级语言&lt;/strong&gt;：面向问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单批处理系统&lt;/strong&gt;：编写作业控制程序，缩短手工操作的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多道批处理系统&lt;/strong&gt;：排队执行作业，不能同时，也不能和计算机交互&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分时系统、实时系统&lt;/strong&gt;：进程间切换，引入中断机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通用操作系统&lt;/strong&gt;：同时具备以上功能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 不同视角下的操作系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;资源管理的角度&lt;/strong&gt;：&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;资源&lt;/strong&gt;：硬件资源（处理器、内存、外设），软件资源（数据、程序）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例子&lt;/strong&gt;：驱动程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享&lt;/strong&gt;：资源独占、并发共享&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配&lt;/strong&gt;：静态、动态、抢占&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序控制的角度&lt;/strong&gt;：进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作方式的角度&lt;/strong&gt;：脱机、联机&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;人机交互的角度&lt;/strong&gt;：行命令、全屏幕控制、窗口界面、虚拟现实&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序接口的角度&lt;/strong&gt;：系统调用（陷入机制）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统结构的角度&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;OS构件&lt;/strong&gt;：内核、进程、线程、管程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设计概念&lt;/strong&gt;：模块化、层次化、虚拟化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2&gt;二、处理器管理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 指令与处理器模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;指令执行周期&lt;/strong&gt;：取指、译码、执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令分类&lt;/strong&gt;（根据权限）
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;特权指令&lt;/strong&gt;：只能被操作系统内核使用（启动IO，置PC值）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非特权指令&lt;/strong&gt;：所有程序都能使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理器模式&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;共有四种&lt;/strong&gt;：0内核模式，1系统调用，2共享库程序，3用户模式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般来说&lt;/strong&gt;：只有0内核模式（能执行全部指令）和3用户模式（只能执行非特权指令）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模式切换&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;用户模式 --&amp;gt; 内核模式（系统调用、异常、响应中断）&lt;/li&gt;
&lt;li&gt;内核模式 --&amp;gt; 用户模式（中断返回指令）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 中断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;概念：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;操作系统是&lt;strong&gt;中断驱动&lt;/strong&gt;的。即&lt;strong&gt;中断是激活操作系统的唯一方式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;广义中断&lt;/strong&gt;：停止CPU正在执行的进程，转而执行中断处理程序，处理完后返回原进程或调度新进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;狭义中断&lt;/strong&gt;：源于处理器之外的中断事件，IO中断、时钟中断、外部信号中断&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断源：&lt;/strong&gt;&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;处理器硬件故障中断事件&lt;/strong&gt;：内存故障&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序性中断事件&lt;/strong&gt;：除0异常、缺页异常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自愿性中断事件&lt;/strong&gt;：系统调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IO中断事件&lt;/strong&gt;：IO完成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外部中断事件&lt;/strong&gt;：鼠标点击&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断系统：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;实现&lt;/strong&gt;：硬件完成中断响应，软件完成中断处理&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190408124426906-894048566.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;184&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断装置&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;处理器外中断&lt;/strong&gt;：由中断控制器实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理器内中断（陷阱）&lt;/strong&gt;：由指令控制逻辑实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统调用（系统陷阱）&lt;/strong&gt;：执行陷入指令时直接触发，即系统陷阱&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断处理流程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190408125743923-1038593711.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;297&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多中断处理&lt;/strong&gt;：中断屏蔽、中断优先级、中断嵌套&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 进程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：操作系统进行资源分配和调度的独立单位&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程解剖&lt;/strong&gt;：OS管理进程的数据结构P + 内存代码 + 内存数据 + 通用寄存器R + PSW&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程状态&lt;/strong&gt;：&lt;img id=&quot;uploading_image_22610&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190410165902943-787863351.png&quot; alt=&quot;&quot; width=&quot;267&quot; height=&quot;258&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程数据&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程控制块PCB&lt;/strong&gt;：是OS用于记录进程状态和环境信息的数据结构
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;标识信息&lt;/strong&gt;：进程标识（进程标识号、进程组标识号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;现场信息&lt;/strong&gt;：用户可见寄存器内容、控制/状态寄存器内容、栈指针内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制信息&lt;/strong&gt;：进程调度信息、进程组成信息、队列指引元、通信相关、进程特权信息、处理器使用信息、资源清单信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程映像&lt;/strong&gt;：某一时刻进程的内容及执行状态集合
&lt;ul&gt;&lt;li&gt;进程控制块、进程程序块、进程数据块、核心栈&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190410171213833-1620349719.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;230&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程上下文&lt;/strong&gt;：进程执行的环境支持（CPU现场、Cache中的执行信息）
&lt;ul&gt;&lt;li&gt;用户级、寄存器级、系统级&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程的管理&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程实现的队列模型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190410171731621-1382013489.png&quot; alt=&quot;&quot; width=&quot;462&quot; height=&quot;278&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程控制流程&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程创建&lt;/strong&gt;：进程表增加一项，申请PCB并初始化，生成标识，建立映像，分配资源，移入就绪队列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程撤销&lt;/strong&gt;：从队列中移除，归还响应资源。。。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程阻塞&lt;/strong&gt;：保存现场，修改PCB，移入等待队列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程唤醒&lt;/strong&gt;：从等待队列移出，修改PCB，进入就绪队列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程挂起&lt;/strong&gt;：修改进程状态并出入相关队列，收回内存等资源送至对换区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程激活&lt;/strong&gt;：分配内存，修改状态并出入相关队列&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原语&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;概念&lt;/strong&gt;：由若干指令构成的完成某种特定功能，有原子性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用&lt;/strong&gt;：修改OS核心数据结构（进程表、PCB池）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程切换与模式切换&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;流程&lt;/strong&gt;： 俩进程上下文切换（保存被中断的上下文、进程调度、恢复待运行的上下文）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模式切换&lt;/strong&gt;：用户态到内核态这种。进程切换必须在内核态完成，所以必须经理模式切换&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;多线程技术：&lt;/strong&gt;一个进程内有多个线程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;思路：&lt;/strong&gt;将进程的两个功能“独立分配资源”和“调度执行”功能分开&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190410190302649-718946099.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;196&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190410190352629-1511737999.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;239&quot;/&gt; &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分类：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;KLT：&lt;/strong&gt;内核级多线程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ULT：&lt;/strong&gt;用户级别多线程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多线程实现的混合策略&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;一个ULT绑定多个KLT&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190410191107959-687687197.png&quot; alt=&quot;&quot; width=&quot;545&quot; height=&quot;332&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 处理器调度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;处理器调度的层次：&lt;/strong&gt;高级、中级、低级&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190410191432871-2005639753.png&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;232&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理器调度算法&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;原则&lt;/strong&gt;：资源利用率、响应时间、周转时间（进入系统到出系统时间）、吞吐量（单位时间处理进程数）、公平性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算法&lt;/strong&gt;：优先数算法、时间片轮转、分级调度算法、彩票算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2&gt;三、存储管理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 存储管理的基本概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;逻辑地址：&lt;/strong&gt;用户地址，从零开始编号
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一维逻辑地址&lt;/strong&gt;：(地址)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二维逻辑地址&lt;/strong&gt;：(段号: 段内地址)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主存储器的复用方式&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;按分区&lt;/strong&gt;：主存划分为多个固定/可变分区，一个程序占一个分区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按页架&lt;/strong&gt;：主存划分为多个固定页架，一个程序占多个页架&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储管理的模式&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单连续&lt;/strong&gt;：一维逻辑地址程序，占一个固定/可变分区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;段   式&lt;/strong&gt;：二维逻辑地址程序，占多个可变分区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;页   式&lt;/strong&gt;：一维逻辑地址程序，占多个页架&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;段页式&lt;/strong&gt;：二维逻辑地址程序，占多个页架&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地址转换&lt;/strong&gt;：逻辑地址 --&amp;gt; 物理地址
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;静态重定位&lt;/strong&gt;：程序装入内存时转换（早期OS）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态重定位&lt;/strong&gt;：CPU执行时转换，效率考虑需要硬件帮助&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟存储器&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;由于程序的局部性顺序性等，可以考虑只将部分程序调入主存，其他的随用随调&lt;/li&gt;
&lt;li&gt;达到了面对程序员主存扩容的目的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 单连续分区存储管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单用户连续分区管理&lt;/strong&gt;：主存区划分为系统区和用户区，采用&lt;strong&gt;静态重定位&lt;/strong&gt;进行地址转换，一般适用于单用户单任务操作系统（DOS）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;固定分区管理&lt;/strong&gt;：一个程序占一个分区，有主存分配表，容易产生&lt;strong&gt;内零头&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可变分区管理&lt;/strong&gt;：按进程内存需求动态分配内存空间，容易产生&lt;strong&gt;外零头&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 页式存储管理 **&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;概念：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;主存分&lt;strong&gt;页架&lt;/strong&gt;，程序分&lt;strong&gt;页&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;不同程序页可放在不同主存页架中，不需要连续&lt;/li&gt;
&lt;li&gt;页和页架关系由&lt;strong&gt;页表&lt;/strong&gt;维护&lt;/li&gt;
&lt;li&gt;用&lt;strong&gt;位示图&lt;/strong&gt;表示主存分配与去配，用&lt;strong&gt;进程页表&lt;/strong&gt;维护进程逻辑完整性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地址：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;逻辑地址&lt;/strong&gt;：页号 + 单元号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理地址&lt;/strong&gt;：页架号 + 单元号&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快表&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;利用&lt;strong&gt;Cache&lt;/strong&gt;存放部分页表&lt;/li&gt;
&lt;li&gt;同Cache缓存内存数据一样，也是相联存储器技术，并且有淘汰策略，具体见&lt;a href=&quot;https://www.cnblogs.com/flashsun/p/10628433.html&quot; target=&quot;_blank&quot;&gt;《重学计算机 -- 计算机组成原理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;页式虚拟存储&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;页表&lt;/strong&gt;：标识位 + 主存块号 + 辅存地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;查页表，若页在内存，则生成绝对地址&lt;/li&gt;
&lt;li&gt;若不在内存，发起&lt;strong&gt;缺页中断&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;OS响应缺页中断，若内存有空闲页架，则从辅存中调入页。更新页表快表&lt;/li&gt;
&lt;li&gt;若无空闲页架，先淘汰页，再调入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;页面调度算法&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;同Cache和内存的调度策略，具体参考&lt;a href=&quot;https://www.cnblogs.com/flashsun/p/10628433.html&quot; target=&quot;_blank&quot;&gt;《重学计算机 -- 计算机组成原理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 其他&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;段式存储管理&lt;/strong&gt;：基本不用，略&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;段页式存储管理&lt;/strong&gt;：基本不用，略&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理单元MMU：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：管理虚拟存储器的硬件控制线路，把虚拟地址映射为物理地址，并提供内存保护，必要时淘汰页面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现&lt;/strong&gt;：用一种数据结构 &lt;strong&gt;反置页表IPT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190412110558902-1176768606.png&quot; alt=&quot;&quot; width=&quot;501&quot; height=&quot;255&quot;/&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7.890124264225&quot;&gt;
&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;：许多年以前，当人们还在使用DOS或是更古老的操作系统的时候，计算机的内存还非常小，一般都是以K为单位进行计算，相应的，当时的程序规模也不大，所以内存容量虽然小，但还是可以容纳当时的程序。但随着图形界面的兴起还有用户需求的不断增大，应用程序的规模也随之膨胀起来，终于一个难题在程序员的面前，那就是应用程序太大以至于内存容纳不下该程序，通常解决的办法是把程序分割成许多称为覆盖块（overlay）的片段。覆盖块0首先运行，结束时他将调用另一个覆盖块。虽然覆盖块的交换是由OS完成的，但是必须先由程序员把程序先进行分割，这是一个费时费力的工作，而且相当枯燥。人们必须找到更好的办法从根本上解决这个问题。不久人们找到了一个办法，这就是&lt;a href=&quot;https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8&quot; target=&quot;_blank&quot;&gt;虚拟存储器&lt;/a&gt;(virtual memory).虚拟存储器的基本思想是程序，数据，&lt;a href=&quot;https://baike.baidu.com/item/%E5%A0%86%E6%A0%88&quot; target=&quot;_blank&quot;&gt;堆栈&lt;/a&gt;的总的大小可以超过物理存储器的大小，操作系统把当前使用的部分保留在内存中，而把其他未被使用的部分保存在磁盘上。比如对一个16MB的程序和一个内存只有4MB的机器，操作系统通过选择，可以决定各个时刻将哪4M的内容保留在内存中，并在需要时在内存和磁盘间交换程序片段，这样就可以把这个16M的程序运行在一个只具有4M内存机器上了。而这个16M的程序在运行前不必由程序员进行分割。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;四、设备管理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. IO的控制方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;演进过程&lt;/strong&gt;：轮询 --&amp;gt; 中断 --&amp;gt; DMA --&amp;gt; IO通道&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;经典布局&lt;/strong&gt;：南北桥
&lt;ul&gt;&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190415100940892-635620133.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;190&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PS&lt;/strong&gt;：详见&lt;a href=&quot;https://www.cnblogs.com/flashsun/p/10628433.html&quot; target=&quot;_blank&quot;&gt;《计算机组成原理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. IO的实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;软件实现层次&lt;/strong&gt;：硬件 --&amp;gt; 中断处理程序 --&amp;gt; 设备驱动程序 --&amp;gt; 独立于设备的IO软件 --&amp;gt; 用户空间的IO软件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IO缓冲：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;解决问题：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;设备与CPU速度不匹配&lt;/li&gt;
&lt;li&gt;逻辑记录大小和物理记录大小不一致&lt;/li&gt;
&lt;li&gt;减少IO操作对CPU的中断次数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现&lt;/strong&gt;：缓冲区
&lt;ul&gt;&lt;li&gt;内存中开辟一个专门&lt;strong&gt;临时&lt;/strong&gt;存放IO数据的区域&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分类&lt;/strong&gt;：单缓冲、双缓冲、多缓冲&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 磁盘&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190415102328801-1391299784.png&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;调度策略&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;移臂调度&lt;/strong&gt;：以双向调度中的电梯调度算法为经典&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;旋转调度&lt;/strong&gt;：写数据时采用&lt;strong&gt;交叉因子&lt;/strong&gt;写入方式，可以提高旋转读数据的命中率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;五、文件系统&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 文件系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件系统概述&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件的组织：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;逻辑结构&lt;/strong&gt;：流式、记录式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理结构&lt;/strong&gt;：顺序、连接、直接、索引&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件的存取&lt;/strong&gt;：顺序、直接、索引&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件的控制&lt;/strong&gt;：逻辑控制、物理控制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件的使用&lt;/strong&gt;：打开、关闭、读、写、控制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件的存储&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;块&lt;/strong&gt;：存储介质上连续存储的区域，是主存与辅存信息交换的单位&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顺序存取设备&lt;/strong&gt;：光盘、磁带&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接存取设备&lt;/strong&gt;：磁盘&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件的逻辑结构&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;流式文件&lt;/strong&gt;：只是由一段字节序列构成的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记录式文件&lt;/strong&gt;：有含义有结构的信息，比如员工工资记录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件的物理机构&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;顺序文件&lt;/strong&gt;：块块之间相连，批处理文件和系统文件一般都这么存。---&amp;gt; 数组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接文件&lt;/strong&gt;：有连接字指向下一个块地址。---&amp;gt; 链表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接文件&lt;/strong&gt;：又叫散列文件。对内容进行散列存储到相应物理位置。 ---&amp;gt; 散列表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引文件&lt;/strong&gt;：为文件建立一个索引表，可多级。 ---&amp;gt; 增加了散列表的链表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件的目录&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;概念&lt;/strong&gt;：实现文件按名存取的关键数据结构&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分类&lt;/strong&gt;：一级目录、二级目录、树型目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;六、并发程序设计&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 并发程序的基本概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;程序顺序性&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;内部顺序性&lt;/strong&gt;：CPU严格按照顺序执行指令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外部顺序性&lt;/strong&gt;：程序员设计程序时往往用顺序设计的思想&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顺序程序特性&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;程序执行的顺序性&lt;/li&gt;
&lt;li&gt;计算环境的封闭性： 程序执行时犹如独占资源&lt;/li&gt;
&lt;li&gt;计算结果的确定性&lt;/li&gt;
&lt;li&gt;计算过程的可再现性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发进程&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;无关的并发进程&lt;/strong&gt;：一组并发进程，在不同变量集上运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交往的并发进程&lt;/strong&gt;：一组并发进程，共享某些变量，相互影响&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发进程制约关系&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程互斥&lt;/strong&gt;：争夺某一个资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程同步&lt;/strong&gt;：共同完成某一个任务，协调先后顺序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发生问题：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;与时间有关的错误：结果错误、永远等待&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;临界区：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;临界资源&lt;/strong&gt;：一次只能被一个进程使用的资源（互斥共享变量）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;临界区&lt;/strong&gt;：是个&lt;strong&gt;程序段&lt;/strong&gt;，是并发进程中与&lt;strong&gt;互斥共享变量&lt;/strong&gt;相关的程序段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相关的临界区&lt;/strong&gt;：两个进程的临界区有相同的临界资源（必须互斥进入）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;问题&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;多个并发进程访问临界资源存在制约关系&lt;/li&gt;
&lt;li&gt;如果两个进程同时处在相关的临界区，会发生与时间有关的错误&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;临界区管理的要求&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;一次至多允许一个进程停留在相关临界区&lt;/li&gt;
&lt;li&gt;一个进程不能&lt;strong&gt;无限制停留&lt;/strong&gt;在临界区内&lt;/li&gt;
&lt;li&gt;一个进程不能&lt;strong&gt;无限制等待&lt;/strong&gt;进入临界区内&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;临界区嵌套使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190415172104272-2058405406.png&quot; alt=&quot;&quot; width=&quot;427&quot; height=&quot;242&quot;/&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 并发程序控制和问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;临界区管理实现：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;思路&lt;/strong&gt;：&lt;strong&gt;判断锁&lt;/strong&gt;和&lt;strong&gt;获取锁&lt;/strong&gt;要作为原子操作，不然会死锁或时间错误&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;原子指令：&lt;/strong&gt;测试并建立锁指令、对换指令（忙式等待，效率不高）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断控制&lt;/strong&gt;：进出临界区时开关中断，这样临界区执行时就不会被中断，自然实现了原子性
&lt;ul&gt;&lt;li&gt;这个时操作系统的原语，是操作系统解决这个问题的办法&lt;/li&gt;
&lt;li&gt;不建议用户程序使用，因为无法保证程序员设计出短小精悍的原语&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PV操作&lt;/strong&gt;：用&lt;strong&gt;信号量&lt;/strong&gt;，“申请-等待队列-中断恢复”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生产者消费者问题&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190417192521021-535768357.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;326&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程间通信&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;信号量&lt;/strong&gt;：低级通信方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信件&lt;/strong&gt;：进程通信机制（直接通信、间接通信）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于流&lt;/strong&gt;：多个进程共同使用一个缓冲区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RPC&lt;/strong&gt;：远程过程调用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;概念&lt;/strong&gt;：两个进程分别等待对方占有的资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁的产生&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;互斥&lt;/strong&gt;：进程互斥地使用资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;占有和等待&lt;/strong&gt;：一个进程得不到资源，就等待且不释放已有资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不剥夺&lt;/strong&gt;：进程不能从另一个进程抢走资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环等待&lt;/strong&gt;：每个进程都等待它前一个进程所持有的资源&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁的防止&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;破坏上述四个条件之一即可&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;eg. 层次分配&lt;/strong&gt;：资源分成多个层次，一个进程获得某个资源后只能获得比他层次更高的资源　　&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁的避免&lt;/strong&gt;：银行家算法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁的检测&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/flashsun/p/10628433.html&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/201904/1096103-20190417205010323-1983641529.png&quot; alt=&quot;&quot; width=&quot;422&quot; height=&quot;248&quot;/&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt;：warshall闭包&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Wed, 17 Apr 2019 13:19:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<og:description>一、操作系统概述 1. 计算机软硬件系统 冯诺伊曼结构 以运算单元为核心，控制流由指令流产生 程序和数据存储在主存中 主存是按地址访问，线性编址 指令由操作码和地址码组成 数据以二进制编码 其他：参考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flashsun/p/10669879.html</dc:identifier>
</item>
</channel>
</rss>