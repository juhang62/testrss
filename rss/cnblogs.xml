<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>TensorFlow之RNN：堆叠RNN、LSTM、GRU及双向LSTM - Luv_GEM</title>
<link>http://www.cnblogs.com/Luv-GEM/p/10788849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Luv-GEM/p/10788849.html</guid>
<description>&lt;p&gt;&lt;span&gt;RNN（Recurrent Neural Networks，循环神经网络）是一种具有短期记忆能力的神经网络模型，可以处理任意长度的序列，在自然语言处理中的应用非常广泛，比如机器翻译、文本生成、问答系统、文本分类等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但&lt;strong&gt;由于梯度爆炸或梯度消失，RNN存在长期依赖问题，难以建立长距离的依赖关系，于是引入了门控机制来控制信息的累积速度，包括有选择地加入新信息，并有选择地遗忘之前积累的信息。&lt;/strong&gt;比较经典的基于门控的RNN有LSTM（长短期记忆网络）和GRU（门控循环单元网络）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有关RNN，LSTM和GRU的相关理论知识可以看我以前的笔记&lt;strong&gt;：&lt;/strong&gt;&lt;span class=&quot;postTitle2&quot;&gt;《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Luv-GEM/p/10703906.html&quot;&gt;深度学习之循环神经网络（RNN）&lt;/a&gt;》 、《&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Luv-GEM/p/10705967.html&quot;&gt;循环神经网络之LSTM和GRU&lt;/a&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Luv-GEM/p/10703906.html&quot;&gt;》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这篇博客整理用TensorFlow构建RNN的内容，主要包括两方面，一是分别用RNN、LSTM和GRU作为记忆细胞，构建一个单向堆叠的循环神经网络，也就是有多个循环网络层（单向）；二是构建双向RNN模型，这在自然语言处理中比较常见，比如Bi-LSTM+CRF做命名实体识别。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、堆叠RNN、LSTM和GRU&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、堆叠RNN的结构和特性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RNN的一般性内容就不介绍了，如果不熟悉请看以上列出的笔记。我们先来看看堆叠RNN的结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190429094829407-235125842.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是按时间展开的堆叠循环神经网络。一般的，我们定义 h&lt;sub&gt;t&lt;/sub&gt;&lt;sup&gt;(l)&lt;/sup&gt;为在时刻 t 时第 l 层的隐状态，则它是由时刻t-1第l层的隐状态与时刻t第l-1层的隐状态共同决定：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190429095405785-1069270868.png&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;32&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中U&lt;sup&gt;(l)&lt;/sup&gt;、W&lt;sup&gt;(l)&lt;/sup&gt;是权重矩阵，b&lt;sup&gt;(l)&lt;/sup&gt;是偏置，h&lt;sub&gt;t&lt;/sub&gt;(0) = x&lt;sub&gt;t&lt;/sub&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以看到，如果一共有T步，那么会有T个输出：y&lt;sub&gt;1&lt;/sub&gt;，y&lt;sub&gt;2&lt;/sub&gt;，...，y&lt;sub&gt;T&lt;/sub&gt;。但一般只取最后一个输出y&lt;sub&gt;T&lt;/sub&gt;，相应的隐状态也取最后时刻最后一个循环层的隐状态，比如上面就是取h&lt;sub&gt;T&lt;/sub&gt;&lt;sup&gt;(3)&lt;/sup&gt;，这是代码中需要注意的地方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、RNN、LSTM和GRU的区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RNN、LSTM与GRU这三中循环神经网络结构，在构建时的区别有两个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一是在t时刻，RNN最后一个循环层只有一个隐状态，就用这个隐状态来计算输出；LSTM在最后一个循环层有两个隐状态，一个是长期状态C&lt;sub&gt;t&lt;/sub&gt;，一个是短期状态h&lt;sub&gt;t&lt;/sub&gt;，长期状态由Tanh函数激活，然后通过输出门过滤后得到短期状态，而用来输入到全连接层计算模型输出的是短期状态。于是在下图中可以看到，h&lt;sub&gt;t&lt;/sub&gt;一方面往上传递去计算当前时刻的模型输出，另一方面顺时间传递去计算下一个隐状态h&lt;sub&gt;t-1&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190429101628557-209923339.png&quot; alt=&quot;&quot; width=&quot;481&quot; height=&quot;154&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GRU在最后一个循环层也只有一个隐状态，因为没有引入额外的内部状态C，而直接在当前状态h&lt;sub&gt;t&lt;/sub&gt;和历史状态h&lt;sub&gt;t-1&lt;/sub&gt;之间引入线性依赖关系。从下图可以看到，隐状态h&lt;sub&gt;t&lt;/sub&gt;由前一时刻的隐状态h&lt;sub&gt;t-1&lt;/sub&gt;和候选状态决定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190429132858758-1706091829.png&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;168&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二是在TensorFlow中，要指定RNN中记忆细胞的激活函数，一般为ReLU函数，而LSTM和GRU中的激活函数已经确定为Sigmoid函数和Tanh函数了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、LSTM的参数初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一点要说明，一般在深度网络参数学习时，参数初始化的值一般都比较小，在训练 LSTM 网络时，过小的参数值会使得遗忘门的值比较小。这意味着前一时刻的信息大部分都丢失了，这样网络很难捕捉到长距离的依赖信息。因此遗忘门的参数初始值一般都设得比较大，其偏置向量 b&lt;sub&gt;f&lt;/sub&gt; 设为 1 或 2。而TensorFlow将b&lt;sub&gt;f&lt;/sub&gt;初始化为1的向量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190429150715585-1221076781.png&quot; alt=&quot;&quot; width=&quot;255&quot; height=&quot;30&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、TensorFlow核心代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照上一步所说的，RNN、LSTM和GRU的不同点在于隐状态和激活函数，这也体现在了TensorFlow的代码中。堆叠三个循环层，每层神经元的个数均为100，这三种记忆细胞的定义代码如下，构建的模型除了这部分不同以外，其他都是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cell_selected(cell):&lt;br/&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cell == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定激活函数为ReLU函数，然后构造三个RNN细胞状态&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构建堆叠的RNN模型&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每个时刻都有一个输出和一个隐状态（或多个隐状态），我们只取最后一个输出和隐状态&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 但是TensofFlow中不知道为啥取了最后时刻的三个隐状态，用于计算最终输出。&lt;/span&gt;
        rnn_cells = [tf.nn.rnn_cell.BasicRNNCell(num_units=n_neurons,activation=&lt;span&gt;tf.nn.relu)
                      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_layers)]
        
        multi_layer_cell &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.MultiRNNCell(rnn_cells)
        
        outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(multi_layer_cell, X, dtype=&lt;span&gt;tf.float32)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tf.concat(axis=1, values=&lt;span&gt;states)
        
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; cell == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LSTM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构造三个LSTM记忆细胞,不用管激活函数&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; states[-1]中包含了长期状态和短期状态，这里取最后一个循环层的短期状态&lt;/span&gt;
        lstm_cells = [tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_layers)]
        multi_cell &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.MultiRNNCell(lstm_cells)
        outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(multi_cell, X, dtype=&lt;span&gt;tf.float32)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; states[-1][1&lt;span&gt;]
        
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; cell == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GRU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; GRU和LSTM大致相同，但是states[-1]中只包含了短期状态。&lt;/span&gt;
        gru_cells = [tf.nn.rnn_cell.GRUCell(num_units=&lt;span&gt;n_neurons)
              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_layers)]
        multi_cell &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.MultiRNNCell(gru_cells)
        outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(multi_cell, X, dtype=&lt;span&gt;tf.float32)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; states[-1]    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;取记忆细胞的隐状态这一步需要好好理解。我们一一来看，这三个细胞状态在最后一时刻的隐状态和经过处理用来求模型输出的隐状态是什么样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）在RNN中，用tf.concat()来处理RNN记忆细胞的隐状态。未处理之前的states是三个tuple元素，是三个循环层最后一步的隐状态，维度是[batch-size, n_neurons]，100是神经元的个数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
(&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/rnn/while/Exit_3:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/rnn/while/Exit_4:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/rnn/while/Exit_5:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用tf.cncat()按第1个维度拼接后如下。可见是将最后时刻三个循环层的隐状态的值拼接在了一起。这是TensorFlow在堆叠RNN中想要的格式，我不太明白，按道理只要取三个中的最后一个就可以了啊。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;concat:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 300) dtype=float32&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（2）在LSTM中，得到的states包含三个tuple元素，而每个tuple中又有两个元素，第一个是长期状态，第二个是短期状态。显然我们要取的是最后一层中的短期状态，用此用states[-1][1]取到。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
(LSTMStateTuple(c=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/while/Exit_3:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;, h=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/while/Exit_4:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;&lt;span&gt;),
 LSTMStateTuple(c&lt;/span&gt;=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/while/Exit_5:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;, h=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/while/Exit_6:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;&lt;span&gt;),
 LSTMStateTuple(c&lt;/span&gt;=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/while/Exit_7:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;, h=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/while/Exit_8:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（3）在GRU中，得到的states包含三个元素，就是最后一步隐状态的值，因此只要用states[-1]取到最后一层的隐状态即可。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
(&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/while/Exit_3:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/while/Exit_4:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rnn/while/Exit_5:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、完整代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了方便在三种记忆细胞之间进行切换，我定义了以上选择记忆细胞的函数。基于MINIST数据集，构建了一个具有三个循环层的单向RNN网络，每个循环层的神经元个数为100，记忆细胞分别选择RNN、LSTM和GRU。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; timedelta

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录训练花费的时间&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_time_dif(start_time):
    end_time &lt;/span&gt;=&lt;span&gt; time.time()
    time_dif &lt;/span&gt;= end_time -&lt;span&gt; start_time   
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; timedelta(seconds=&lt;span&gt;int(round(time_dif)))

(X_train, y_train), (X_test, y_test) &lt;/span&gt;=&lt;span&gt; tf.keras.datasets.mnist.load_data()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里和卷积神经网络那不同，RNN中的输入维度是（batch-size，28，28），而不是（batch-size，784）&lt;/span&gt;
X_train = X_train.astype(np.float32)/ 255.0&lt;span&gt;
X_test &lt;/span&gt;= X_test.astype(np.float32)/ 255.0&lt;span&gt;
y_train &lt;/span&gt;=&lt;span&gt; y_train.astype(np.int32)
y_test &lt;/span&gt;=&lt;span&gt; y_test.astype(np.int32)
X_valid, X_train &lt;/span&gt;= X_train[:5000], X_train[5000&lt;span&gt;:]
y_valid, y_train &lt;/span&gt;= y_train[:5000], y_train[5000&lt;span&gt;:]
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; shuffle_batch(X, y, batch_size):
    
    rnd_idx &lt;/span&gt;=&lt;span&gt; np.random.permutation(len(X))
    n_batches &lt;/span&gt;= len(X) //&lt;span&gt; batch_size
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; batch_idx &lt;span&gt;in&lt;/span&gt;&lt;span&gt; np.array_split(rnd_idx, n_batches):
        X_batch, y_batch &lt;/span&gt;=&lt;span&gt; X[batch_idx], y[batch_idx]
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; X_batch, y_batch
        
n_steps &lt;/span&gt;= 28&lt;span&gt;
n_inputs &lt;/span&gt;= 28&lt;span&gt;
n_neurons &lt;/span&gt;= 100&lt;span&gt;
n_outputs &lt;/span&gt;= 10&lt;span&gt;
n_layers &lt;/span&gt;= 3&lt;span&gt;

learning_rate &lt;/span&gt;= 0.001&lt;span&gt;

X &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_inputs])
y &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32, [None])

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择记忆细胞&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cell_selected(cell):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cell == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定激活函数为ReLU函数，然后构造三个RNN细胞状态&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构建堆叠的RNN模型&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每个时刻都有一个输出和一个隐状态（或多个隐状态），我们只取最后一个输出和隐状态&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 但是TensofFlow中不知道为啥取了最后时刻的三个隐状态，用于计算最终输出。&lt;/span&gt;
        rnn_cells = [tf.nn.rnn_cell.BasicRNNCell(num_units=n_neurons,activation=&lt;span&gt;tf.nn.relu)
                      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_layers)]
        
        multi_layer_cell &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.MultiRNNCell(rnn_cells)
        
        outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(multi_layer_cell, X, dtype=&lt;span&gt;tf.float32)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tf.concat(axis=1, values=&lt;span&gt;states)
        
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; cell == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LSTM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构造三个LSTM记忆细胞,不用管激活函数&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; states[-1]中包含了长期状态和短期状态，这里取最后一个循环层的短期状态&lt;/span&gt;
        gru_cells = [tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_layers)]
        multi_cell &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.MultiRNNCell(gru_cells)
        outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(multi_cell, X, dtype=&lt;span&gt;tf.float32)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; states[-1][1&lt;span&gt;]
        
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; cell == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GRU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; GRU和LSTM大致相同，但是states[-1]中只包含了短期状态。&lt;/span&gt;
        gru_cells = [tf.nn.rnn_cell.GRUCell(num_units=&lt;span&gt;n_neurons)
              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_layers)]
        multi_cell &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.MultiRNNCell(gru_cells)
        outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(multi_cell, X, dtype=&lt;span&gt;tf.float32)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; states[-1&lt;span&gt;]   
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; build_and_train():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用上面定义的选择记忆细胞的函数，定义损失函数&lt;/span&gt;
    logits = tf.layers.dense(cell_selected(cell), n_outputs, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    xentropy &lt;/span&gt;= tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=&lt;span&gt;logits)
    loss &lt;/span&gt;= tf.reduce_mean(xentropy, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    
    optimizer &lt;/span&gt;= tf.train.AdamOptimizer(learning_rate=&lt;span&gt;learning_rate)
    training_op &lt;/span&gt;=&lt;span&gt; optimizer.minimize(loss)
    
    correct &lt;/span&gt;= tf.nn.in_top_k(logits, y, 1&lt;span&gt;)
    accuracy &lt;/span&gt;=&lt;span&gt; tf.reduce_mean(tf.cast(correct, tf.float32))

    init &lt;/span&gt;=&lt;span&gt; tf.global_variables_initializer()
    saver &lt;/span&gt;=&lt;span&gt; tf.train.Saver()
    
    n_epochs &lt;/span&gt;= 50&lt;span&gt;
    batch_size &lt;/span&gt;= 100&lt;span&gt;

    with tf.Session() as sess:
        init.run()
        start_time &lt;/span&gt;=&lt;span&gt; time.time()

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总迭代步数，一个batch算一步&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录最好的验证精度&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录上一次验证结果提升时是第几步。&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果迭代2000步后结果还没有提升就中止训练。&lt;/span&gt;
        total_batch =&lt;span&gt; 0
        best_acc_val &lt;/span&gt;= 0.0&lt;span&gt;
        last_improved &lt;/span&gt;=&lt;span&gt; 0
        require_improvement &lt;/span&gt;= 2000&lt;span&gt;

        flag &lt;/span&gt;=&lt;span&gt; False
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; epoch &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_epochs):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; X_batch, y_batch &lt;span&gt;in&lt;/span&gt;&lt;span&gt; shuffle_batch(X_train, y_train, batch_size):
                sess.run(training_op, feed_dict&lt;/span&gt;=&lt;span&gt;{X: X_batch, y: y_batch})

                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次迭代10步就验证一次&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 如果验证精度提升了，就替换为最好的结果，并保存模型&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; total_batch % 10 ==&lt;span&gt; 0:
                    acc_batch &lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: X_batch, y: y_batch})         
                    acc_val &lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: X_valid, y: y_valid})         
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; acc_val &amp;gt;&lt;span&gt; best_acc_val:
                        best_acc_val &lt;/span&gt;=&lt;span&gt; acc_val
                        last_improved &lt;/span&gt;=&lt;span&gt; total_batch
                        save_path &lt;/span&gt;= saver.save(sess, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./my_model_Cell_Selected.ckpt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        improved_str &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;improved!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                        improved_str &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                    time_dif &lt;/span&gt;=&lt;span&gt; get_time_dif(start_time)
                    msg &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Epoch:{0:&amp;gt;4}, Iter: {1:&amp;gt;6}, Acc_Train: {2:&amp;gt;7.2%}, Acc_Val: {3:&amp;gt;7.2%}, Time: {4} {5}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(msg.format(epoch, total_batch, acc_batch, acc_val, time_dif, improved_str))
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总迭代步数    &lt;/span&gt;
                total_batch += 1

                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果2000步以后还没提升，就中止训练。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; total_batch - last_improved &amp;gt;&lt;span&gt; require_improvement:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Early stopping in  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,total_batch,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; step! And the best validation accuracy is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,best_acc_val, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                    flag &lt;/span&gt;=&lt;span&gt; True
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; flag:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;        

    with tf.Session() as sess:
        saver.restore(sess, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./my_model_Cell_Selected.ckpt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) 
        acc_test&lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: X_test, y: y_test})
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nTest_accuracy:{0:&amp;gt;7.2%}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(acc_test))        
        
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    cell &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LSTM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; RNN/LSTM/GRU,在这里选择记忆细胞&lt;/span&gt;
    build_and_train()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分别选择记忆细胞为RNN、LSTM和GRU，得到的结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
RNN   耗时3分3秒   最好验证精度98.72%  测试精度98.41%&lt;span&gt;

LSTM  耗时6分35秒  最好验证精度99.&lt;/span&gt;22%  测试精度98.81%&lt;span&gt;

GRU   耗时6分9秒   最好验证精度99.&lt;/span&gt;26%  测试精度98.97%
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、双向LSTM模型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、双向LSTM的结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双向LSTM（Bidirectional Long-Short Term Memorry，Bi-LSTM）不仅能利用到过去的信息，还能捕捉到后续的信息，比如在词性标注问题中，一个词的词性由上下文的词所决定，那么用双向LSTM就可以利用好上下文的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双向LSTM由两个信息传递相反的LSTM循环层构成，其中第一层按时间顺序传递信息，第二层按时间逆序传递信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有去找双向LSTM的图了，就看这个双向RNN的结构来学习吧，理解了双向RNN，那么把循环层的记忆细胞换成LSTM就行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190429140253550-673920122.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、双向LSTM隐状态的计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键在于隐状态如何计算。为了简单，还是按照双向RNN的公式进行理解，我们看隐状态如何计算。可以看到t时刻第一层（顺时间循环层）的隐状态h&lt;sub&gt;t&lt;/sub&gt;&lt;sup&gt;(1)&lt;/sup&gt;取决于前一时刻的隐状态h&lt;sub&gt;t-1&lt;/sub&gt;&lt;sup&gt;(1)&lt;/sup&gt;和输入值x&lt;sub&gt;t&lt;/sub&gt;，这一点非常容易理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190414153153820-1361198092.png&quot; alt=&quot;&quot; width=&quot;272&quot; height=&quot;94&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而要注意的是第二层（逆时间循环层）的隐状态则依然取决于前一时刻的隐状态和输入值x，这与堆叠的LSTM不同，堆叠的LSTM其l层的隐状态不由输入值x直接输入得到，而是取决于该层前一时刻的隐状态和当前时刻下一层的隐状态。如下的公式就是堆叠的循环网络层中隐状态的计算过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190429095405785-1069270868.png&quot; alt=&quot;&quot; width=&quot;301&quot; height=&quot;33&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双向LSTM和堆叠的LSTM可以结合使用，在顺时间循环层我们可以构造堆叠多层的LSTM，同样，在逆时间循环层可以堆叠多个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而双向LSTM的一个循环层中有两个隐状态，长期状态C用于内部传递信息，不抛头露面，而短期状态h则作为该循环层的输出，用于其他循环层或全连接层的计算。因此在对得的双向LSTM的最后一步，会有超过4个隐状态存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这次构建的双向LSTM模型，在顺时间循环层和逆时间循环层都分别堆叠了两层LSTM，每层神经元个数都为100，因此循环网络层总共有4层，最后一步的隐状态有8个。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bi_lstm():
       
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顺时间循环层的记忆细胞，堆叠了两层&lt;/span&gt;
    lstm_fw1 = tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
    lstm_fw2 &lt;/span&gt;= tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
    lstm_forward &lt;/span&gt;= tf.nn.rnn_cell.MultiRNNCell(cells=&lt;span&gt;[lstm_fw1,lstm_fw2])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 逆时间循环层的记忆细胞，堆叠了两层&lt;/span&gt;
    lstm_bc1 = tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
    lstm_bc2 &lt;/span&gt;= tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
    lstm_backward &lt;/span&gt;= tf.nn.rnn_cell.MultiRNNCell(cells=&lt;span&gt;[lstm_bc1,lstm_bc2])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算输出和隐状态&lt;/span&gt;
    outputs,states=tf.nn.bidirectional_dynamic_rnn(cell_fw=lstm_forward, cell_bw=lstm_backward,inputs=X,dtype=&lt;span&gt;tf.float32)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取到顺时间循环层和拟时间循环层的最后一个隐状态&lt;/span&gt;
    state_forward = states[0][-1][-1&lt;span&gt;]
    state_backward &lt;/span&gt;= states[1][-1][-1&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把两个隐状态拼接起来。&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; state_forward+state_backward
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面是隐状态states的情况，第一个元素是顺时间循环层的隐状态，其中短期状态有两个，我们选择最后一个堆叠层的短期状态：states[0][-1][-1]。同理，第二个元素是逆时间循环层的隐状态，我们用states[1][-1][-1]来取到最后一个堆叠层的短期状态。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
((LSTMStateTuple(c=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bidirectional_rnn/fw/fw/while/Exit_3:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;, h=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bidirectional_rnn/fw/fw/while/Exit_4:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;&lt;span&gt;), 
  LSTMStateTuple(c&lt;/span&gt;=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bidirectional_rnn/fw/fw/while/Exit_5:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;, h=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bidirectional_rnn/fw/fw/while/Exit_6:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;&lt;span&gt;)), 
 
 (LSTMStateTuple(c&lt;/span&gt;=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bidirectional_rnn/bw/bw/while/Exit_3:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;, h=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bidirectional_rnn/bw/bw/while/Exit_4:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;&lt;span&gt;), 
  LSTMStateTuple(c&lt;/span&gt;=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bidirectional_rnn/bw/bw/while/Exit_5:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;, h=&amp;lt;tf.Tensor &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bidirectional_rnn/bw/bw/while/Exit_6:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; shape=(?, 100) dtype=float32&amp;gt;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;取到两个循环层的两个短期状态之后，通过简单的拼接，就可以输入到全连接层了，即states[0][-1][-1]+states[1][-1][-1]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、完整代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对MINIST数据集构建双向LSTM分类器，训练耗时12分38秒，最佳验证精度为99.16%，测试精度为98.83%&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; division, print_function, unicode_literals
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; timedelta

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录训练花费的时间&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_time_dif(start_time):
    end_time &lt;/span&gt;=&lt;span&gt; time.time()
    time_dif &lt;/span&gt;= end_time -&lt;span&gt; start_time   
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; timedelta(seconds=&lt;span&gt;int(round(time_dif)))

(X_train, y_train), (X_test, y_test) &lt;/span&gt;=&lt;span&gt; tf.keras.datasets.mnist.load_data()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里和卷积神经网络那不同，RNN中的输入维度是（batch-size，28，28），而不是（batch-size，784）&lt;/span&gt;
X_train = X_train.astype(np.float32)/ 255.0&lt;span&gt;
X_test &lt;/span&gt;= X_test.astype(np.float32)/ 255.0&lt;span&gt;
y_train &lt;/span&gt;=&lt;span&gt; y_train.astype(np.int32)
y_test &lt;/span&gt;=&lt;span&gt; y_test.astype(np.int32)
X_valid, X_train &lt;/span&gt;= X_train[:5000], X_train[5000&lt;span&gt;:]
y_valid, y_train &lt;/span&gt;= y_train[:5000], y_train[5000&lt;span&gt;:]
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; shuffle_batch(X, y, batch_size):
    
    rnd_idx &lt;/span&gt;=&lt;span&gt; np.random.permutation(len(X))
    n_batches &lt;/span&gt;= len(X) //&lt;span&gt; batch_size
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; batch_idx &lt;span&gt;in&lt;/span&gt;&lt;span&gt; np.array_split(rnd_idx, n_batches):
        X_batch, y_batch &lt;/span&gt;=&lt;span&gt; X[batch_idx], y[batch_idx]
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; X_batch, y_batch
        
n_steps &lt;/span&gt;= 28&lt;span&gt;
n_inputs &lt;/span&gt;= 28&lt;span&gt;
n_neurons &lt;/span&gt;= 100&lt;span&gt;
n_outputs &lt;/span&gt;= 10&lt;span&gt;

learning_rate &lt;/span&gt;= 0.001&lt;span&gt;

X &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_inputs])
y &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32, [None])

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bi_lstm():
       
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顺时间循环层的记忆细胞，堆叠了两层&lt;/span&gt;
    lstm_fw1 = tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
    lstm_fw2 &lt;/span&gt;= tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
    lstm_forward &lt;/span&gt;= tf.nn.rnn_cell.MultiRNNCell(cells=&lt;span&gt;[lstm_fw1,lstm_fw2])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拟时间循环层的记忆细胞，堆叠了两层&lt;/span&gt;
    lstm_bc1 = tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
    lstm_bc2 &lt;/span&gt;= tf.nn.rnn_cell.LSTMCell(num_units=&lt;span&gt;n_neurons)
    lstm_backward &lt;/span&gt;= tf.nn.rnn_cell.MultiRNNCell(cells=&lt;span&gt;[lstm_bc1,lstm_bc2])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算输出和隐状态&lt;/span&gt;
    outputs,states=tf.nn.bidirectional_dynamic_rnn(cell_fw=lstm_forward, cell_bw=lstm_backward,inputs=X,dtype=&lt;span&gt;tf.float32)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取到顺时间循环层和拟时间循环层的最后一个隐状态&lt;/span&gt;
    state_forward = states[0][-1][-1&lt;span&gt;]
    state_backward &lt;/span&gt;= states[1][-1][-1&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把两个隐状态拼接起来。&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; state_forward+&lt;span&gt;state_backward
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; build_and_train():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用上面的定义双向LSTM的函数，定义损失函数&lt;/span&gt;
    logits = tf.layers.dense(bi_lstm(), n_outputs, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    xentropy &lt;/span&gt;= tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=&lt;span&gt;logits)
    loss &lt;/span&gt;= tf.reduce_mean(xentropy, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    
    optimizer &lt;/span&gt;= tf.train.AdamOptimizer(learning_rate=&lt;span&gt;learning_rate)
    training_op &lt;/span&gt;=&lt;span&gt; optimizer.minimize(loss)
    
    correct &lt;/span&gt;= tf.nn.in_top_k(logits, y, 1&lt;span&gt;)
    accuracy &lt;/span&gt;=&lt;span&gt; tf.reduce_mean(tf.cast(correct, tf.float32))

    init &lt;/span&gt;=&lt;span&gt; tf.global_variables_initializer()
    saver &lt;/span&gt;=&lt;span&gt; tf.train.Saver()
    
    n_epochs &lt;/span&gt;= 50&lt;span&gt;
    batch_size &lt;/span&gt;= 100&lt;span&gt;

    with tf.Session() as sess:
        init.run()
        start_time &lt;/span&gt;=&lt;span&gt; time.time()

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总迭代步数，一个batch算一步&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录最好的验证精度&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录上一次验证结果提升时是第几步。&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果迭代2000步后结果还没有提升就中止训练。&lt;/span&gt;
        total_batch =&lt;span&gt; 0
        best_acc_val &lt;/span&gt;= 0.0&lt;span&gt;
        last_improved &lt;/span&gt;=&lt;span&gt; 0
        require_improvement &lt;/span&gt;= 2000&lt;span&gt;

        flag &lt;/span&gt;=&lt;span&gt; False
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; epoch &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_epochs):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; X_batch, y_batch &lt;span&gt;in&lt;/span&gt;&lt;span&gt; shuffle_batch(X_train, y_train, batch_size):
                sess.run(training_op, feed_dict&lt;/span&gt;=&lt;span&gt;{X: X_batch, y: y_batch})

                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次迭代10步就验证一次&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 如果验证精度提升了，就替换为最好的结果，并保存模型&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; total_batch % 10 ==&lt;span&gt; 0:
                    acc_batch &lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: X_batch, y: y_batch})         
                    acc_val &lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: X_valid, y: y_valid})         
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; acc_val &amp;gt;&lt;span&gt; best_acc_val:
                        best_acc_val &lt;/span&gt;=&lt;span&gt; acc_val
                        last_improved &lt;/span&gt;=&lt;span&gt; total_batch
                        save_path &lt;/span&gt;= saver.save(sess, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./my_model_Bi_LSTM.ckpt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        improved_str &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;improved!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                        improved_str &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                    time_dif &lt;/span&gt;=&lt;span&gt; get_time_dif(start_time)
                    msg &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Epoch:{0:&amp;gt;4}, Iter: {1:&amp;gt;6}, Acc_Train: {2:&amp;gt;7.2%}, Acc_Val: {3:&amp;gt;7.2%}, Time: {4} {5}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(msg.format(epoch, total_batch, acc_batch, acc_val, time_dif, improved_str))
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总迭代步数    &lt;/span&gt;
                total_batch += 1

                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果2000步以后还没提升，就中止训练。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; total_batch - last_improved &amp;gt;&lt;span&gt; require_improvement:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Early stopping in  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,total_batch,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; step! And the best validation accuracy is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,best_acc_val, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                    flag &lt;/span&gt;=&lt;span&gt; True
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; flag:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;        

    with tf.Session() as sess:
        saver.restore(sess, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./my_model_Bi_LSTM.ckpt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) 
        acc_test&lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: X_test, y: y_test})
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nTest_accuracy:{0:&amp;gt;7.2%}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(acc_test))        
        
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    build_and_train()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、《Hands on Machine Learning with Scikit-Learn and TensorFlow》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、https://blog.csdn.net/luoganttcc/article/details/83384823&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 07:31:00 +0000</pubDate>
<dc:creator>Luv_GEM</dc:creator>
<og:description>RNN（Recurrent Neural Networks，循环神经网络）是一种具有短期记忆能力的神经网络模型，可以处理任意长度的序列，在自然语言处理中的应用非常广泛，比如机器翻译、文本生成、问答系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Luv-GEM/p/10788849.html</dc:identifier>
</item>
<item>
<title>【机器学习基础】对 softmax 和 cross-entropy 求导 - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10787510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10787510.html</guid>
<description>&lt;p&gt;在论文中看到对 softmax 和 cross-entropy 的求导，一脸懵逼，故来整理整理。&lt;/p&gt;
&lt;p&gt;以 softmax regression 为例来展示求导过程，softmax regression 可以看成一个不含隐含层的多分类神经网络，如 Fig. 1 所示。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201904/1351564-20190429093302184-690937183.png&quot; width=&quot;500px&quot;/&gt;&lt;p&gt;Fig. 1 Softmax Regression.&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;softmax regression 的矩阵形式如 Fig. 2 所示：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201904/1351564-20190429092636696-1683586564.png&quot; width=&quot;500px&quot;/&gt;&lt;p&gt;Fig. 2 Matrix Form.&lt;/p&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;h2 id=&quot;符号定义&quot;&gt;符号定义&lt;/h2&gt;
&lt;p&gt;如 Fig. 1 所示，&lt;span class=&quot;math inline&quot;&gt;\(\bm x = [x_1, x_2, x_3]^{\top}\)&lt;/span&gt; 表示 softmax regression 的输入，&lt;span class=&quot;math inline&quot;&gt;\(\bm y = [y_1, y_2, y_3]^{\top}\)&lt;/span&gt; 表示 softmax regression 的输出，&lt;span class=&quot;math inline&quot;&gt;\(\bm W\)&lt;/span&gt; 为权重，&lt;span class=&quot;math inline&quot;&gt;\(\bm b = [b_1, b_2, b_3]^{\top}\)&lt;/span&gt; 为偏置。&lt;/p&gt;
&lt;p&gt;令 Fig. 2 中 softmax function 的输入为 &lt;span class=&quot;math inline&quot;&gt;\(z_i = W_{i, 1}x_1 + W_{i, 2}x_2 + W_{i, 3}x_3 + b_i = W_{i}\bm x + b_i\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(i= 1, 2, 3\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(W_{i}\)&lt;/span&gt; 表示权重矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\bm W\)&lt;/span&gt; 的第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 行；softmax function 的输出就是整个网络的输出，即 &lt;span class=&quot;math inline&quot;&gt;\(\bm y\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Note: Fig. 1 和 Fig.2 中权重 &lt;span class=&quot;math inline&quot;&gt;\(W_{i, j}\)&lt;/span&gt; 表示第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个输出和第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个输入之间的联系，和一般的记法（即 &lt;span class=&quot;math inline&quot;&gt;\(W_{i, j}\)&lt;/span&gt; 表示第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个输入和第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个输出之间权重）相差一个转置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 表示输出的类别数，本文中 &lt;span class=&quot;math inline&quot;&gt;\(m = 3\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Note: softmax regression 指的是整个网络，softmax function 仅仅指的是激活函数。本文默认 softmax 代指激活函数，当表示整个网络时会明确说明 softmax regression。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;对-softmax-求导&quot;&gt;对 softmax 求导&lt;/h2&gt;
&lt;p&gt;softmax 函数的表达式为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y_i = \frac{e^{z_i}}{\sum_{t = 1}^m e^{z_t}} \tag{1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(i= 1, 2, 3\)&lt;/span&gt;。由式（1）可知，&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt; 与 softmax function 所有的输入 &lt;span class=&quot;math inline&quot;&gt;\(z_j, j = 1,2,3.\)&lt;/span&gt; 都有关。&lt;br/&gt;softmax function 的输出对其输入求偏导：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial y_i}{\partial z_j} = \frac{\partial \frac{e^{z_i}}{\sum_{t = 1}^m e^{z_t}}}{\partial z_j} \tag{2} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;需要对式（2）中 &lt;span class=&quot;math inline&quot;&gt;\(i = j\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(i \not = j\)&lt;/span&gt; 的情况进行分别讨论。因为式（1）分子中仅含第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 项，式（2）中如果 &lt;span class=&quot;math inline&quot;&gt;\(i = j\)&lt;/span&gt;，那么导数 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial e^{z_i}}{\partial z_j} = e^{z_i}\)&lt;/span&gt;，不为 0；如果 &lt;span class=&quot;math inline&quot;&gt;\(i \not = j\)&lt;/span&gt;，那导数 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial e^{z_i}}{\partial z_j} = 0\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(i = j\)&lt;/span&gt;，则式（2）为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial y_i}{\partial z_j} &amp;amp;= \frac{\partial \frac{e^{z_i}}{\sum_{t = 1}^m e^{z_t}}}{\partial z_j} \\ &amp;amp;= \frac{e^{z_i} \cdot \sum_{t = 1}^m e^{z_t} - e^{z_i} \cdot e^{z_j} }{(\sum_{t = 1}^m e^{z_t})^2} \\ &amp;amp;= \frac{e^{z_i}}{\sum_{t = 1}^m e^{z_t}} - \frac{e^{z_i}}{\sum_{t = 1}^m e^{z_t}} \cdot \frac{e^{z_j}}{\sum_{t = 1}^m e^{z_t}} \\ &amp;amp;=y_i(1 - y_j) \end{split} \tag{3} \]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，式（3）也可以写成 &lt;span class=&quot;math inline&quot;&gt;\(y_i(1 - y_i)\)&lt;/span&gt; 或者 &lt;span class=&quot;math inline&quot;&gt;\(y_j(1 - y_j)\)&lt;/span&gt;，因为这里 &lt;span class=&quot;math inline&quot;&gt;\(i = j\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(i \not = j\)&lt;/span&gt;，则式（2）为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial y_i}{\partial z_j} &amp;amp;= \frac{\partial \frac{e^{z_i}}{\sum_{t = 1}^m e^{z_t}}}{\partial z_j} \\ &amp;amp;= \frac{0\cdot \sum_{t = 1}^m e^{z_t} - e^{z_i} \cdot e^{z_j} }{(\sum_{t = 1}^m e^{z_t})^2} \\ &amp;amp;= - \frac{e^{z_i}}{\sum_{t = 1}^m e^{z_t}} \cdot \frac{e^{z_j}}{\sum_{t = 1}^m e^{z_t}} \\ &amp;amp;= -y_iy_j \end{split} \tag{4} \]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;对-cross-entropy-求导&quot;&gt;对 cross-entropy 求导&lt;/h2&gt;
&lt;p&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(\bm {\hat y} = [\hat{y}_1, \hat{y}_2, \hat{y}_3]^{\top}\)&lt;/span&gt; 为输入 &lt;span class=&quot;math inline&quot;&gt;\(\bm x\)&lt;/span&gt; 真实类别的 one-hot encoding。&lt;/p&gt;
&lt;p&gt;cross entropy 的定义如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H(\bm {\hat y}, \bm y) = - \bm {\hat y}^{\top} \log \bm y = - \sum_{t = 1}^m \hat{y}_t\log y_t \tag{5} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对 cross entropy 求偏导：（&lt;span class=&quot;math inline&quot;&gt;\(\log\)&lt;/span&gt; 底数为 &lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial H(\bm {\hat y}, \bm y) }{\partial y_i} = \frac{\partial [- \sum_{t = 1}^m \hat{y}_t\log y_t ]}{\partial y_i} = - \frac{\hat{y}_i}{y_i} \tag{6} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\bm {\hat y}\)&lt;/span&gt; 是确定的值，可以理解为样本的真实 one-hot 标签，不受模型预测标签 &lt;span class=&quot;math inline&quot;&gt;\(\bm y\)&lt;/span&gt; 的影响。&lt;/p&gt;
&lt;h2 id=&quot;对-softmax-和-cross-entropy-一起求导&quot;&gt;对 softmax 和 cross-entropy 一起求导&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial H(\bm {\hat y}, \bm y) }{\partial z_j} &amp;amp;= \sum_{i = 1}^{m} \frac{\partial H(\bm {\hat y}, \bm y) }{\partial y_i} \frac{\partial y_i }{\partial z_j} \\ &amp;amp;= \sum_{i = 1}^{m} -\frac{\hat{y}_i}{y_i} \cdot \frac{\partial y_i }{\partial z_j} \\ &amp;amp;= \left(-\frac{\hat{y}_i}{y_i} \cdot \frac{\partial y_i }{\partial z_j}\right )_{i = j} + \sum_{i = 1 , i \not = j}^{m} -\frac{\hat{y}_i}{y_i} \cdot \frac{\partial y_i }{\partial z_j} \\ &amp;amp;= -\frac{\hat{y}_j}{y_i} \cdot y_i(1-y_j) + \sum_{i = 1 , i \not = j}^{m} -\frac{\hat{y}_i}{y_i} \cdot -y_iy_j \\ &amp;amp;= - \hat{y}_j + \hat{y}_jy_j + \sum_{i = 1 , i \not = j}^{m} \hat{y}_iy_j \\ &amp;amp; = - \hat{y}_j + y_j\sum_{i = 1}^{m} \hat{y}_i \\ &amp;amp;= y_j - \hat{y}_j \end{split} \tag{7} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;交叉熵 loss function 对 softmax function 输入 &lt;span class=&quot;math inline&quot;&gt;\(z_j\)&lt;/span&gt; 的求导结果相当简单，在 tensorflow 中，softmax 和 cross entropy 也合并成了一个函数，&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/softmax_cross_entropy_with_logits&quot;&gt;tf.nn.softmax_cross_entropy_with_logits&lt;/a&gt;，从导数求解方面看，也是有道理的。&lt;/p&gt;
&lt;p&gt;在实际使用时，推荐使用 tensorflow 中实现的 API 去实现 softmax 和 cross entropy，而不是自己写，原因如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;都已经有 API 了，干嘛还得自己写，懒就是最好的理由；&lt;/li&gt;
&lt;li&gt;softmax 因为计算了 &lt;code&gt;exp(x)&lt;/code&gt;，很容易就溢出了，比如 &lt;code&gt;np.exp(800) = inf&lt;/code&gt;，需要做一些缩放，而 tensorflow 会帮我们处理这种数值不稳定的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://data-flair.training/blogs/tensorflow-mnist-dataset/&quot;&gt;TensorFlow MNIST Dataset and Softmax Regression - Data Flair&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%93%BE%E5%BC%8F%E6%B3%95%E5%88%99&quot;&gt;链式法则 - 维基百科&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27223959&quot;&gt;Softmax函数与交叉熵 - 知乎&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 07:09:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>softmax 和 cross entropy 是机器学习中很常用的函数，softmax 常用来作为 DNN 分类网络最后一层的激活函数，而 cross entropy 也是一种常用的 loss fu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/10787510.html</dc:identifier>
</item>
<item>
<title>java泛型中使用的排序算法——归并排序及分析 - 9龙</title>
<link>http://www.cnblogs.com/9dragon/p/10790415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/9dragon/p/10790415.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;72&quot;&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;一、引言&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们知道，&lt;strong&gt;java中泛型排序使用归并排序&lt;/strong&gt;或TimSort。&lt;strong&gt;归并排序以O(NlogN)最坏时间运行&lt;/strong&gt;，下面我们分析归并排序过程及分析证明时间复杂度；也会简述为什么java选择归并排序作为泛型的排序算法。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;二、图解归并排序过程&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;算法思想：&lt;/strong&gt;采用&lt;strong&gt;分治法&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;分割：递归地把当前序列平均分割成两半。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;归并操作：指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;归并过程：&lt;/strong&gt;取两个输入数组A、B和一个输出数组C以及3个索引index1,index2,index3分别指向三个数组开始端。并在A[index1]、B[index2]中较小者拷贝到数组C中的下一个位置，相关的索引+1。当A、B中有一个数组走完时，将另一个数组中的元素全部拷贝到数组C中。&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190429145627799-1953042245.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;假设输入数组A[1、7、9、13]，B[5、8、15、17]，算法过程如下。1与5比较，1存入数组C中；接下来7与5比较，5存入C中。&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190429145710938-1245154865.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;接着7与8比较，7存入C中；9与8比较，8存入C中。&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190429145739648-240139144.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;接着这样的过程进行比较，直到13与15比较，13存入C中。&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190429145802516-1536331331.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这时候A已经用完，将B中剩余的元素全部拷贝到C中即可。&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190429145829132-1393816787.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;从图中可以看出，合并两个排序表是线性的，最多进行N-1次比较（可以改变输入序列，使得每次只有一个数进入数组C，除了最后一次，最后一次至少有两个元素进入C）。对于归并排序，N=1的时候，排序结果是显然的；否则，递归将前半部分与后半部分分别归并排序。这是使用分治的思想。&lt;/p&gt;
&lt;h3 id=&quot;hjava&quot;&gt;&lt;span&gt;三、java实现归并排序&lt;/span&gt;&lt;/h3&gt;
&lt;pre readability=&quot;19.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;33&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MergeSort&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Integer[] integers = {&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;};&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;原序列：&quot;&lt;/span&gt; + Arrays.toString(integers));&lt;br/&gt;mergeSort(integers);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;排序后：&quot;&lt;/span&gt; + Arrays.toString(integers));&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T extends Comparable&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T[] a)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;T[] tmpArray = (T[]) &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Comparable[a.length];&lt;br/&gt;mergeSort(a, tmpArray, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, a.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T extends Comparable&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T[] a, T[] tmpArray, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; left, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; right)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (left &amp;lt; right) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; center = (left + right) / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;mergeSort(a, tmpArray, left, center);&lt;br/&gt;mergeSort(a, tmpArray, center + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, right);&lt;br/&gt;merge(a, tmpArray, left, center + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, right);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T extends Comparable&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T[] a, T[] tmpArray, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; leftPos, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; rightPos, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; rightEnd)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; leftEnd = rightPos - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; tmpPos = leftPos;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; numElements = rightEnd - leftPos + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (leftPos &amp;lt;= leftEnd &amp;amp;&amp;amp; rightPos &amp;lt;= rightEnd) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (a[leftPos].compareTo(a[rightPos]) &amp;lt;= &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;tmpArray[tmpPos++] = a[leftPos++];&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;tmpArray[tmpPos++] = a[rightPos++];&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (leftPos &amp;lt;= leftEnd) {&lt;br/&gt;tmpArray[tmpPos++] = a[leftPos++];&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (rightPos &amp;lt;= rightEnd) {&lt;br/&gt;tmpArray[tmpPos++] = a[rightPos++];&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; numElements; i++, rightEnd--) {&lt;br/&gt;a[rightEnd] = tmpArray[rightEnd];&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;四、归并排序分析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们假设N是2的幂，我们递归总可以均分为两部分。对于N=1，归并排序所用时间是常数，即O(1)。对于N个数归并排序的用时等于两部分时间之和再加上合并的时间。合并是线性的，因为最多使用N-1次比较。推导如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;katex-display&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAnoAAAKXCAYAAAAVcOdQAAAgAElEQVR4Xuy9C9xVY/7+f5epiCk5ZEJDiSgax0mOkUkUM2FqfhRqhIiUUwk5pAglkkNoyDnHkdIomjAxJaJSqYyccj6MwwzG/F/v+/u/n1nPfvZhnfbea6993a/XvHy/PWvdh+u+117X+hyuT73//ve//zVqQkAICAEhIASEgBAQAqlDoJ6IXur2VAsSAkJACAgBISAEhIBFQERPB0EICAEhIASEgBAQAilFQEQvpRurZQkBISAEhIAQEAJCQERPZ0AICAEhIASEgBAQAilFQEQvpRurZQkBISAEhIAQEAJCQERPZ0AICAEhIASEgBAQAilFQEQvpRurZQkBISAEhIAQEAJCQERPZ0AICAEhIASEgBAQAilFQEQvpRurZQkBISAEhIAQEAJCQERPZ0AICAEhIASEgBAQAilFQEQvpRurZQkBISAEhIAQEAJCQERPZ0AICAEhIASEgBAQAilFQEQvpRurZQkBISAEhIAQEAJCQERPZ0AICAEhIASEgBAQAilFQEQvpRurZQkBISAEhIAQEAJCQERPZ0AICAEhIASEgBAQAilFQEQvpRurZQkBISAEhIAQEAJCQERPZ0AICAEhIASEgBAQAilFQEQvpRurZQkBvwisXr3anHvuuebTTz/1e0ut69Zbbz1z3XXXmQ4dOhS8/7///a955plnzCuvvGIGDRpk1l9//YL3BL3gX//6l5k4caLZe++9zb777mvq1asXtAtdLwSEgBBIDQIieqnZSi1ECIRD4KGHHjJTpkwxAwYMMAcffLBp0qRJTUdTp041t912m9l6663N2LFjzVZbbWX/BmH7+OOPzQ033GBWrFhhrr76arPNNtvknQD3zJw50zz99NPmwgsvNJtuumm4Cfu4C9I6atQo061bN9O1a1eRPR+Y6RIhIATSiYCIXjr3VasSAr4Q+Pbbby0hwvJ1+OGH1yJE33//vbnmmmvMrFmz7N8hZ40bN67V79y5c839999vrrrqKtO0adO8Y7766quWEI4cOdLssMMOvubnLvrmm2/M888/b/bff/86c8jV0dKlS82ll15qLrjgArPrrrsGGq9SLg6DS6WsTfMUAkIgHgRE9OLBUb0IgYpE4M033zR33HGHGT58eC1LHov5/PPPzfnnn28tdn379jUnnXRSnTVC3h577DF73QYbbJATg6+++spcdtllZscddzT9+vUzuHv9NO5bsGCBuf322+38/BBK1+9//vMfa6lcvny5ufjii+usz8/4Sb0mCi5JXZPmJQSEQHEQENErDq7qVQhUBAKPPvqogRAdc8wxdea7bNkyM3ToUPPdd9+ZK6+80nTq1KnONVj7iPEbOHBgXvfok08+ae69995a7t9cAH355ZeWOL7xxhtmk002sS5eCOlOO+0UiOjRv4s/hKj27NmzIvakFLhUNBCavBAQAoEQENELBJcuFgLpQYCkheuvv94SoO23377OwiBnxOVtvvnm1uXaqlWrOtcQw7fxxhubI444Iq81D3ftlltuac466yzToEGDvCD+9NNPBpcybuL69esbN48wRA/38/jx4826deusG9cbf1hpOxknLpW2ds1XCAiB8AiI6IXHTncKgYpGAPff/PnzzYEHHlgn+xUrH5mrjzzyiNlzzz0tSdpoo43qrHfevHmmZcuWWUmgu/ill16yrmHcp507dw6MWRSix2DEEeI2HjNmjOnYsWPg8ZN6Q1RckrouzUsICIF4ERDRixdP9SYEUoHA119/bZMmFi5caI466igrheI3rs4LAJm2kydPNrNnz/aVmZsNvKiE5u2337byMYcccojNLE6L3EpUXFJxULUIISAECiIgolcQIl0gBKoPgbfeesuSIyRUyFo99NBDQ4HgCCM357IKFuo4KqHBcolFEc2+sHMoNMdy/D0qLuWYs8YUAkKg9AiI6JUec40oBBKPAO5OLHrE3yGxki2Gz88i3nnnHXPeeeeZXXbZxZxzzjmmYcOGfm6rdU1UQuNkYl5//XUbc4irOQ0tKi5pwEBrEAJCoDACInqFMdIVQqCqEHDu1nvuuce0bdvWZro2a9YsFAavvfaaTcDo3bu3OeWUU0L1EQehueWWWwwZxuPGjTPt2rULNY9p06bZuMUoDeJMYktQHcFsY8aBS5S16F4hIAQqAwERvcrYJ81SCJQMASei/MILL5gePXr4ypTNNbmXX37ZSrScccYZWSVc/CwqDkLjKnxMmDAhtHjyDz/8YLOBozTiA0lqIZs4aosDl6hz0P1CQAgkHwERveTvkWYoBEqKgHO3vv/++5EIGpN2ZAT3bffu3UOtIw5C4/ogRi9M5m+oiRf5pjhwKfIU1b0QEAIJQEBELwGboCkIgSQh4KxwZNled911pkOHDqGnlzSiF4VwhgahSDeK6BUJWHUrBFKGgIheyjZUyxECURFwbs5tttnGxue1aNEidJdJI3qy6IXeSt0oBIRAhSIgolehG6dpC4FiIEC1DJIF0L076KCDCtawLTSHNMXoKRmj0G7r70JACCQRARG9JO6K5iQEyoQAunnDhg0zq1atMtSHPemkkyLNJE1Zt0rGiHQUdLMQEAJlQkBEr0zAa1ghkEQEXn31VZslSwk0yoZRHi1Kc1Up9tprr9DZu1Fj0ZyO3vLlyyO7oqNgEfe9UXGJez7qTwgIgWQiIKKXzH3RrIRASRBwwsiFBmvfvr0ZPXq0FVAO0qJWpcCKhssUHbzWrVubSy65xAoeB5EncXNo2rSpufDCC03jxo2DLCGR18aBSyIXpkkJASEQOwIierFDqg6FgBBwCGAZRGQYTT5i/0jwKNS8cYL5rvWriZeWWrdx41JoH/R3ISAE0oGAiF469lGrEAKJRWD+/Pk27q9cGa9YLXFDUxVj1113TSxOmpgQEAJCoBgIiOgVA1X1KQSEQA0Cn3zyibngggtsvVzKoTVo0KBk6BCfN378eLNu3TpLNJs0aVKysTWQEBACQiAJCIjoJWEXNAchkGIEqJ37yCOP2P+NHTvWbLXVViVb7erVq825555rTj/9dNOlS5eSjauBhIAQEAJJQUBELyk7oXkIgRQj8Pnnn1v3KUkd/fr1M1TdKHYjPnDKlCmGbNuLL75Y1rxiA67+hYAQSCQCInqJ3BZNSgikDwHEk4mTGzlypNlhhx2KvsClS5faTOFSjVf0BWkAISAEhEAIBET0QoCmW4SAEAiOAC7cmTNnmqefftrKnGy66abBO/F5x6effmquvPJK061bN3PwwQebevXq+bxTlwkBISAE0oWAiF669lOrEQKJRgCy98wzz5hXXnnFDBo0yKy//vqxzxcZEiRd9t57b7PvvvuK5MWOsDoUAkKgkhAQ0auk3dJchYAQEAJCQAgIASEQAAERvQBg6VIhIASEgBAQAkJACFQSAiJ6lbRbmqsQEAJCQAgIASEgBAIgIKIXACxdKgSEgBAQAkJACAiBSkJARK+SdktzFQJCQAgIASEgBIRAAARE9AKApUuFgBAQAkJACAgBIVBJCIjoVdJuaa5CQAgIASEgBISAEAiAgIheALB0qRAQAkJACAgBISAEKgkBEb1K2i3NVQgIASEgBISAEBACARAQ0QsAli4VAkJACAgBISAEhEAlISCiV0m7pbkKASGQSgTmzp1rRo4cWWttG2ywgbniiivMHnvsUWfNzz33nK0XnNmoH3z11Veb7bbbLpU4aVFCQAgER0BELzhmukMICAEhUBQEvvjiC3PBBReYpUuX2v4PP/xwM2TIENOwYcM64/3000/mpZdeMqNGjTL9+/c3PXr0MI0aNSrKvNSpEBAClYuAiF7l7p1mLgSEQMoQePPNN82kSZPMVlttZZ544gmz0UYbmbFjx5r27dtnXemyZcvM5MmTzaWXXmqaNGmSMjS0HCEgBOJAQEQvDhTVhxAQAkIgBgRw4S5YsMB07drVnH/++ea7774zvXr1MqeeeqpZb7316ozw5JNPmlWrVplBgwZl/XsMU1IXQkAIVDgCInoVvoGavhAQAulA4L///a+56aabTPPmzU337t3N6NGjzbx588zWW29trXpY+bztP//5j5k4caJp06aNvV5NCAgBIZANARE9nQshIASEQAIQ+Pbbb23yRe/evU2HDh3MnDlzzGWXXWZndtZZZ5mePXvWmuVXX31lEzgGDBhg2rVrl4AVaApCQAgkEQERvSTuiuYkBIRA1SHwzjvvmOuuu84MGzbMbL755uaTTz6xiRkrVqwwu+++e504POL5brzxRkv2mjVrVnV4acFCQAj4Q0BEzx9OukoICAEhUFQE5s+fb2bNmmVj85BWwZV79913m9tuu83G340ZM8Z07NixZg5c+9prr1lrX4MGDYo6N3UuBIRA5SIgole5e6eZCwEhkCIEpk6dalfTt2/fmlWtXr3anHvuuebTTz+tJbXi4vOI2zvmmGNShIKWIgSEQNwIiOjFjaj6EwJCQAgEROBf//qXFTo+5JBDTKdOnWru/v7778348ePNjBkzjFcMGb29ESNGmFNOOcXG86kJASEgBHIhIKKnsyEEhIAQKDMCH3/8sbnyyiutG7Zly5a1ZoMo8vDhww1WPKx9/fr1M2vWrDHXX3+9ufjii208n5oQEAJCQERPZ0AICAEhkFAEiLV74IEHrJWucePGtWbpsmsXLVpUI7Xy6quvGv5/3Lrrr79+QlelaQkBIZAEBGTRS8IuaA5CQAhUNQJUwSDrduDAgaZevXp1sHj00UdtRi7ttNNOM2vXrjWtWrVSfF5VnxotXgj4Q0BEzx9OukoICAEhUBQEfvjhB0vi9tprL9O5c+esY7z99tvWevfhhx+abbbZxhDTh/TKrrvuWpQ5qVMhIATSg4CIXnr2UisRAkKgAhEgseLyyy+3Zc623377rCvwJmVwAWTvqquuMi1atKjAFWvKQkAIlBIBEb1Soq2xhIAQEAIZCCB8fMstt9jEiiZNmuTEx5uUcdBBB9Xo7QlQISAEhEA+BET0dD6EgBAQAmVE4MknnzTLli0rKHzsTco46aSTauntlXH6GloICIGEIyCil/AN0vSEgBBIJwJUviABAxcsEilDhw7Na9EDBZeUgRSLV28vnQhpVUJACMSBgIheHCiqj7Ih4K0HGnYSBLUfeuihvm4n23HSpEk2O5I4qXzNBdlPnz691mUI3F566aVmk002qfXvP/74o9VGe/zxx+t0e8ABB9jge0pjeRsyGzNnzrSZmE2bNvW1hmq5yJupGmbNO++8sy07ls+d6vpF427atGmGWLrjjjvOlizL1bj25ptvNg8++GCdS/bcc097NjbaaKOst7/33ntWb++8886ro7cXZI1pPTdz5861tX+9jWfmiiuuMHvssUcdiJ577jlz4YUX1vl3rzh1EFx1rRBIIgIiekncFc3JNwLUB0V7rE+fPubII4+01QOcPIX70eeH/pprrjG8uF3DDXbnnXeahx56yEyYMMFX9uJbb71lRo0aZUlVtpdGvknzYsViw0ueRjxWly5dst7y73//20yZMsXwEqLuKfOuX79+1muxCkH0nn32WTNs2DC7fjVjvv32W7tXlA47+eSTbfUIVw/266+/tmRg4cKFtcqKgRv7s2TJEksMdtllF186ddzDWVq3bp0ZMmRIHTKexP1I+7khwYUPo6VLl1r4Dz/8cLs3DRs2rLMdP/30kyH+kfPSv39/06NHD9OoUaMkbpvmJARCISCiFwo23ZQEBFy9T4jcH//4xzpWFIrBUz+0TZs21gqSWUGAuCgsNvzAF7LOff755+ayyy4z++23nznqqKOyap3lwwRCuXLlSvPRRx+ZV155xUpp5Au+Z94QPmKxCjWsSDfccIO1JvEyS4uALuuZN2+eFRIGO6xcu+22m+nZs6f9by7yC14kOIwePdpcdNFFpnXr1rUgxF2KRez99983Z5xxRh0tOmeJxZJHibFCbdasWebh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BJYtW2aGDh1qiN31tvPOO8907969zlyWL19uPQI8c95GDe4xY8bUqqFd0oVosMAIiOgFhkw3CIFgCDz55JNm7Nix9iYIFta2nXfeOWsnX331lSVg1KQ9//zzTcuWLU29evWCDVglVwvXKtloLTNWBDI/BnfffXf7kdmkSZM64+AhePPNN22cL9b/448/3my00UaxzkedFR8BEb3iY6wRqhgB3KcTJ0409evXNy+++KJ59913zZFHHmnOOOMMGyOX2X744Qdz3XXXmQ4dOphDDz20ipHLv3ThqqMhBMIhwEck5Q8pg/jAAw9YT8FFF11kM/CztQ8++MBa8PBE8OGpVnkIiOhV3p5pxhWEAG6Pyy+/3Bx77LHmL3/5i5k+fbrZdNNNzdVXX2222267Oiv54osv7PW4avkhVsuOgHDVyRAC4RDAhXvnnXeaP/7xj2bUqFHm7bffNgcccIC54IILrMchs7366qtm2rRpVmy9cePG4QbVXWVFQESvrPBr8LQjQOmxCRMm2B/JNWvWmOHDh9skiZNOOsn06dOnjlsWN8nNN99sv7A33njjtMMTen3CNTR0urHKEXjiiSfsb9HAgQPN5MmTzYMPPpg3pIQM/c8++8wMGDBAYSQVenZE9Cp04zTtykBg/vz55tlnnzXnnHOOITaGBI1FixaZtm3bWvfJZpttVmshs2bNMq+99pr07Qpsr3CtjPOvWSYLARfysOOOO9rQkCVLltjfJhI0siV9ff/99zameJ999lGGfrK2MtBsRPQCwaWLhUAwBG677TZrmTvmmGPsjY8++qiNwaNdfPHFpkuXLjUduh/h1q1bmyOOOCLYQFV2tXCtsg3XcmNBgGSvyy67zJxyyik2NASCxwfnvHnzzNZbb22TxrbaaquasYjno0724MGDTatWrWKZgzopPQIieqXHXCNWCQLffvutjYE5+uijzR577GFXTTky5AxIysiMi+FHGIsfLpJ27dpVCUrBlylcg2OmO4QACBAacuONN9rfmWbNmllQ5syZY8kfjUo5PXv2rAEL78Jdd91lLrnkEmXbVvAREtGr4M3T1JONANlquD1wjbgSZFjtiMHLFhfDj/D1119vLX2bb755shdXxtkJ1zKCr6ErGoG5c+eaBQsW1AoNoe41iRgrVqwwmVIrxOfxcTpo0CBfOp4VDU6KJy+il+LN1dLKi0Cu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3+aNN96IDXzsdco47LDD5om3VwAYdAiKgCKgCCgCPgSU6OmSqDkECBHy6aefmlatWpkFF1ywUf/5/e677zYbbrihdTYociHzBQ4YqGAJkdKvX79IiR5YiFMGoVi88fYqjRM2hE899ZR1DiGrh7cwp2T2KHKBhN90001mu+22Mx06dDDzzz9/RYb7+uuvGzKs7LbbbmbppZfOtQ8//vijue2220zPnj2tyQDz+ttvvzXyEvc3yjNz5swxbdq0CXQ0yrWTWpkiUDAElOgVbELrZTioKV977TVLbPxkTvK7ElfurLPOMuutt17hYOGAHDVqlBk7dmyjsa2//vo2p+2iiy4aOO5PPvnExts77bTTGsXbqyRQjz/+uBk0aJDNyUvu3SWWWKKhOxMmTLB5e3fffffQcaXt+y+//GKGDx9uidX+++9vyBQS5LWctn7X97777jurSieTCX9vvfXWFSF7hN054YQTTLdu3azzDv158803TY8ePcySSy7pOpzA50i5x6Vk9dVXt2t08cUXN5dddpkle5C4sPL+++/bUECsCxyOKjE/mQauLysCFURAiV4Fwdem0yMA0eOGD1nxS39QY1599dW5HArekCRpervmmmva/LJRdnNSL+Rt3LhxBqeJXr16Vb0EC0IAASNUCwd2liKOItgQQkKRaHkLcwohOOWUU8wOO+xgPvvsM3PLLbeYddZZxxIS/xpI0hekongiM5Z77rnHdO/e3Rx44IGZSU2SPvAshBMS1LJly9AQOUnrTPO85D4eNmyY9cgGH7AhuPYhhxxi9txzz1RrE7LGxQsCz9/iBMS3TCFDS1hh/m+++WYzdOjQUGejNGPVdxSBekBAiV49zHIBxxh2OHz99deW4EEA+vTpE3ggoSLksIkjJz///LMZMmSIzRF7xBFH2DRhTZo0sWiigqKdadOmzZM/lt8gbEgbOZTWWmstp4DEvMNBBnk96aSTMhGXck23EIApU6aYM844w6ZXS1uQMkLacRAha4dfTSsHPSne8BamfPPNNzblG9Kmww8/3KZ+C1LlJ+kT6wcCyRqBjGQZU5J2eVZS2EH0okhP0nqTPi9heLyhdyDiV155pWEeCOOTNGUe3wsXHtYMUsIWLVo0dMuV6BEnEiIc990mHa8+rwgUHQElekWf4YKOL+hw4BBBInP99deb7bffPvBA4MCaPHmyWWWV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jGrBNXYB6AOKQJUh8MYbb5h+/fqZX375ZZ6ehe0Bb731ljn55JMN35y3kIP7ggsuMF27dq2yEWp3whBQoqdrQxEoMQJeT9hFFlnEXHrppWbNNdcMbPX77783w4YNM19++aUlaCuuuKJK3ULmR3Et8cLV6guJAA5bhGDCOYuy7rrr2kumN+amDPzvv/8277zzjjnrrLPMlltuaQ488ECz6KKLFhKXIg9KiV6RZ1fHVnEEUJmOHDnSzD///Gbq1Knm448/Nj179jTHH3+8WXDBBRv1748//jBXXHGF6dy5s9l+++0r3v9q7YDiWq0zo/2qdgS4RJ5//vlm1VVXNXfddZfVFAwcONBstdVWgV3/7LPPrAQPTQQXTy21h4ASvdqbM+1xDSGA2gN7OFKRPfroo+ahhx4ySy21lL1Rt2/fvtFIvv32W/s8qlo2Yi3BCCiuujIUgXQIoMK9+eabbVD1IUOGmA8//NB069bNnHnmmQaNg78QaH3cuHFmwIABpmnTpuka1bcqioASvYrCr40XHYH333/fDB8+3G6Ss2bNMv379zdIow477DDTu3fvRmpZ1CQ4THDDXmKJJYoOT+rxKa6podMX6xyBBx980O5FRx99tLn++uutk1aUScndd99tvv76a3P44YerGUmNrh0lejU6cdrt2kDg2WefNVOmTDGnnHKKwTYGB43p06eb1VZbzapPll566XkG8sgjj5hXXnnFnHjiiaZJkya1McgK9FJxrQDo2mTNIyAmD6uvvro1DXnttdfs3oSDRpDT1++//25tijfZZBNro6elNhFQoleb86a9rhEEbrjhBiuZ22uvvWyP7733XmuDRyE7Rffu3RtGIptwu3btzC677FIjI6xMNxXXyuCurdY2Ajh7DRo0yBx55JHWNASCx4XzqaeesmGXSJ+4/PLLNwwSe76hQ4eaE044wYZj0lKbCCjRq815017XAAI///yztYHZc889zXrrrWd7/MknnxjCGeCU4beLYRNG4oeKpFOnTjUwwsp0UXGtDO7aau0jgGnIVVddZfeZFi1a2AE9/vjjlvxR0CTsvvvuDQNFu3DLLbeYc889V71ta3j6lejV8ORp16sbAbzVUHugGmndurXtLFI7bPCC7GLYhMlFi6RvmWWWqe7BVbB3imsFwdemaxqBJ554wrzwwgvzmIbMnTvXOmK8/fbbjUKt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LhUyTvL07rbbbrnMs7T5zjvvmKWWWsoZu/vuu8+svvrqNldnFiy+/fZb07RpU7PgggtGDv/XX381d999t12Pq666aqY2XXCu1DO33XabadGihdlqq60Kl6KPvYLx9ezZ07Ru3dqmI/ztt9/s/EcVnpkzZ45p06ZNRead9IkTJkwwu+yyi+23FkXAFQEleq5I6XMWAQ66Sy65xPz+++/mxBNPtIeyt7z33nvm1FNPNYsvvrgZOHCgzeWapXz99dfm3HPPNR06dDCHHnpo5KED+TjrrLPMP//5T7Pnnnva3I15F/rz1ltvma5duwbW//LLL5szzjjDHH/88aZHjx4l6cPzzz9vzjvvPEuy+vTpE0tO8saA+hjnCSecYLp162bnm3l/88037ZjTElzW1OWXX24Y34ABA8y6665ru/7KK6+YyZMnm3333bfRAXfttdeaRx991AwaNMisscYaqYb6999/m2uuuca2c9xxx5k111wztB5Z/19++aU555xzGq3/VB3I+NIbb7xhHnnkEXPIIYfY7y6PwmXiiiuuMEceeaTZfffdS7KO8+hnmjrA6qKLLrIXBL4jMLvsssss2YPEhRUuWdOnT7fzvsEGG+RK9lh7fFOs8YUWWiiwCx9++KH91iCo++yzT0W++zR46zuVR0CJXuXnoKZ6IAcdia8hXl4yxc34xhtvNFOmTLEHb/v27XMZ2+OPP27rO+KII8z+++8fusHS/tVXX20lXsOGDTOdOnXKpX3qJfH3vffeax577DErATjllFPMDjvs0KgvbNbnn3++JcMrrbRSLu37K5Fx0p8LLrjAks5yFw4miD44d+nSxUCWkDaMGDHCEo40RPuTTz4xp512miWLvXqy38M7AAAgAElEQVT1apDgIuU7/fTTzWGHHdYIc4geBUKStiDNO/PMM80KK6xgTjrppMjLhKx/SOhOO+2UqknWCH/++uuvVO97X/rhhx8s0UVKBfkAPyTgWQvf0IMPPmgJUV7kMWuf8ngfssZlcIkllrB/i2TMZR2Byc0332yGDh1qpblxBVLIPMcVLjhcZD7//HOz33772e8niOwJ0WOt8s1pUQRcEVCi54qUPmcRiDro2IiQZh1wwAGBJAgyAGFCtbrIIos4I/rZZ5/Zg36ttday5KJJkyah77Kxjhw50gwePLiR9IeDlT5ESfr4/aeffjIff/yx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A0j6iCKgCCgCioAioAgoArWIgBK9Wpw17bMioAgoAoqAIqAIKAIOCCjRcwBJH1EEFAFFQBFQBBQBRaAWEVCiV4uzpn3OHYH//e9/ZsqUKWa++eYzW2+9tf07rLzyyivm+eefN7vttptZeumlY/vy888/m88//9y0bds2st6oin788Udz2223mZ49e5rWrVvHtqkPKAKlQmDq1Knmiy++MDvttJP5xz/+YX755Rf794ILLhjZ5KeffmqaN29uFl100VJ1LbTeX3/91dx5551m7bXXtn/mn3/+svdBG1QEKoWAEr1KIa/tVhyBv//+23z11VeGg2v8+PFm1qxZ9hAaNGiQWW+99UL79/LLL5szzjjDnHTSSWbbbbeNPTS+++47079/f9OyZUvTpk2bVOOeO3eumThxounRo4c58cQTYw/VVI3oS4pADALffPON/T5mzJhh+vbtay87XHwuuugi061bN9OkSZPAGn7//XczefJk07lzZ/vdNGvWLDes6dOtt95q9tprr9BLEETvkksuMVyYTj31VKcLWm4d1IoUgQojoESvwhOgzZcPAZGsvfnmmway9sL/1955AP1R1G98VZSiEUKXMgyEJqATIiUQNEBIIAgmgIIDASYCIXRBJEpHQhHpvQ0dQg0IwUgERaqEpoZgEJAQqqIEQVQk4n8+O2z++957Za/+7vfm2RmGJL+7vd1n926ffb5lH3/cfvjZ4bMArbHGGmb55Zc3Sy21lCV8Sbt+7j355JPtwrHKKqtkdgCiN2HCBLP99ttbFSSuXHLJJfaf991339jfeebEiRPtM1ddddXMZ6JQ/vSnPzX33HOPgdC+9tprliQecMABmcQ0s/KWXPDhhx+aSZMmmYcfftjQ35dfftnssssuZu+9925JC9Obwdw77rjjzBNPPNHjwq222sqSkUUWWaTHv3P9CSecYNXkaNl5553N+PHjrbJWVwHjq6++2pKqgw46yKrLPA/ceR+OPPLIxPfBvQPrr7++GTt2bOZGBcWQucsYZxWI5tNPP23WW289c/TRR8eSPUf02GwlvWNZz9HvQqBbERDR69aRU7uDEXjuuefM7NmzLYFbaKGFzMorr2yVhwceeMBMmTLFqhGLL754r/pY2DC5Qv580tcpopeHXLJA3nvvvXYRRkmhH0cccUQi0QwGs0UXohL94he/MC+88IKZNm2a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hIAQEAJCQAi0FIGuIHq33367OfvsswtDuN5665lTTjnFfP7zn8+s47///a+55ZZbzH/+8x+z2267mU996lOp9zz77LPmsMMOM//61796XHfEEUeYr3/9673unTVrlvne975n/vGPf/T4jefQxo033rjHv//73/82559/vhk8eLAZMmSI+cQnPpHZh267ACyOO+4488QTT/Ro+lZbbWW+//3vm0UWWaTHv3P9CSecYKZPn96rqzvvvLMZP358r3FjXC+++GJz8803F4Zn6623Nocffrj5zGc+k1nH3LlzzTnnnGNGjx5tBg4cmHl9kQt++9vfmqlTp5r999/fLL744kWqaOU9999/v50Pfll00UXNSSedZL7yla/0avODDz5ojj766F7/vtRSS5mf/OQnZsCAAb1+++c//2kuvPBC8/zzz9t3/eWXXzYTJkwwjHE3lLq/O92Agd9GzZnsEWsCo+xWdO6KJtaZzvUu/cmtJ3p8kCdOnGj+9re/mXHjxpkvf/nL5tOf/rTtlT9w2267rTn00EPnL8Is7M8884xdHL70pS/FEoYoNNxz9dVXmzfffNPWxeISWiBkLCr33nuvvWXQoEGWjMSRy//97392gWFx2nzzzc0ee+xhPve5zyU+ir6DwTbbbGNGjBjRJ8me6/zdd99tTjvtNPtX8D/99NMNRD2uvPvuu+bMM880b731ll2kV1555URsuOYHP/iBWXrppc3ee+9tVltttflk8I033rD3s9jz25gxY+bX8+GHHxqIBG3aYYcdzL777ps5Jdx4DR8+3IwcObK28WIeQfR+9atf2b5BbPpSeeedd8yRRx5pZs6cabsVfcf9vn700Ufmscces+/Jd77zHbPddtuZhRdeOBGO9957z9xzzz3mT3/6k/n5z39u+vXrZ+faGmus0VUQ1vnd6SogPm6s5kz2qNWJUfbT23FFXetMO3rXuxWtJ3oQopNPPtkcc8wxdnH2yyuvvGJQzl5//XVz0EEHmW9+85s9fmeRRgmEbIUs0Hz4b7vtNrtYLLvssrnGDCJBO1kobrrpJksiaPMWW2wRWw/kAgUPxQqCklVY7CCOLHx1KURZbaj7d4g26uUnP/lJ85vf/Ma8+uqr5hvf+IYd2zgVzY0v5D9LiXn00UfNddddZzGE7Pnl97//vfnud79reP6pp55qNtlkkx6/uw3FlltuGavS+hez8J511lmWuKO0ZSnC/r0QN5Qa2kGfQgpq1HnnnWdVKTYnUfUzpI62XsO7j+q24oormrvuustiCuFed911Y5sMdpdddlniBivuJp6BSsszeH+XWGKJtsIR2666vztdBYYxdgOtOZM+ak1g1OZ5U+c609Z+t57o3XrrrdYs6qssDswnn3zSmk1ZTCF0cYvjJZdcYlZYYQWz/fbbp47Ba6+9ZkkUpr84k2vWALLIoAbutddeliiiDn3ta1+zdcYpg5jdMBEfddRRZrHFFsuq3i7+V155pcH0e+yxxwaZoTMrbdkFEKoTTzzR7LrrrmbatGlmypQpVqVKMr+xM+V6TLVpSox7sVEGhw0b1qvXkAjUHOYJRCJKvJ1qgqIUZzr0K0Rdu/TSSy1hXGWVVYIQpn3MF1wU2Gli2s8zB7kXRQ/FO2ljEdSQll2Eqenxxx+3KjaKK9+BJNM8TQe7F154wRx44IHBBNuZs1AAIfvOWtAyKBKbU/d3p1twcO3UnMkesSYwym5F566oa53pXI+yn9xqoseH/YwzzjC77LJL7EJ+7bXXmssvv9ysvvrqdmFdZpllevQYlYMFHLUnbYF2JMqpZiG+fFFoIQuYgfbbbz+rKuALlmZ6hMC+/fbbZp999gk27b344otWAdx9992tGbGvlZdeesn6tUF+wfKHP/yhJbhRc6rrNztT/O5QTtOUmL/+9a+23oMPPrjXHHGqIKQSH0jM6VHijYkYtQdVeNVVV02EnfHEt2yjjTaK3ZhEb3TmAzYq+JGhTPMRSvLvTHqw8z/83e9+Z9sZVSyrmie8TyhIEOK6fUVRNy+66CKrrEN66dcDDzxgVlppJUvGUeD84sg834JQkuzumTx5cm7Mq8K0bD1NfHfKtrGp+zVnspFuAqPsVvS+gm801og0F6Yi9cbdU9c6U1X76qin1UQPpeL666+3O+3o4uv7pqBisOOPKmcsmj/+8Y+tz07aAo2ax+KKDxwkKm9xC8baa69tSSW+gZiDkhQIR0A33XRT66MXWrgPsyA+hEn+f6F1tfE6zKsoYmDH+EKannrqKbPWWmvFEhhM7c7smqbEoJ7iZxdnSvX9VdhQQNSjJAYz+7nnnmvnSP/+/ROhu++++6z6iN/gOuuskwkxfaTwgfv73/9u5/Af/vCHQqTDzTk2AnGqZWZjAi7gfcS1ARzrNhHjm4t/LWOCUg+2P/rRj2wr+R5ENzqQceYLG6cQ7KnHmeTZ4IWOWQBMjV3S1HensQ6VfJDmTDaATWCU3YreV2B5IxCxCbekutaZIv1u6p5WEz3MMDi2RyNRAcc513MNik8cQWNSQxyGDh2aulPAZMZEK/qxZ5FhEULxwYQIwUtTIGg7i9ghhxySSkDjJgGyO8+Ki9BtatLU9RzUWZQ552vpR1tjrvYJjFvk8NvMMssTzYtKu+aaa/ZquvPRgvBBnuOIN7vNp59+2s6jpIhbN+bMOerJuzMtS/QcaWFDlOQuUHbcmiR6+N/ijoFJGqWeMaBfzz33XGygE+N4wQUXWLKXRsZ9DLrdP6/J707ZudPE/Zoz2Sg3gVF2KzpL9OpaZ4r0u6l7Wk300kDw0wvEOdCHAuiUQVSbos7YcYtMmgKBCnXNNdeY448/PjchYLFFtSH1SB6zbygenbrORVfvtNNO883sTmklKCPq71hEwUkizpADCGaZqMuy41KW6GGSwWWAqG9UxVD/wDzj3STRY9eNYuuUevpHMA0f6bhURKHqrt9f7uGdz+OfR3Qv6inmXvwHIdiYk0eNGmU3HCGR+mxS8C++4YYbrCLNWBFIgzmaOY+CnRYx7PrQ5Hcnzzzp1LVtnTNYYpgrbFxxr+DvbDpRq/muhaRrqmrONIFRkfFvStHr1DpTBJMq7+laopflQB8KkkutQQqWos7YzrnVvz9NgcA/jw96Hqdx1x8IDr5rmM6KKEehuDR9HeMA0cJs+4UvfME+3s99F/V3ZJHDnIrSF/XNDG2781chSjpPrsU0wpikCma1qSzRo35HXIq2IauNTRI9/G8pvlLvfFRR+f1UK07dhShFI++T+lTEP48xQjVk0ebd3WyzzewizaYTwkg0cFZaJvIrolTOnj3bznXu4VvAZhXfIYhkqGWhye9O1txow+9tnDN81/ApxX+X7AHrr7++dQ156KGHrFsRG9s999wzNXioyjlTN0ZF50FTRK8T60xRTKq8ryuJXogDfShIzseLSE9MwHmLU1KWXHLJHotMkgLhFEQc9rNSgsS1xfn3zZgxIzZCNG/723J9UhRykr8jgQzsjkMTGMf108/DuOOOOxYi3q5elCYUmqTo7yycqyB6ZedyVhubInruHUG19lPdOB/Vn/3sZz2isTG7E8CD60RoWhq3YYI8hhAryCXuEvhQ4jrhB3e5bwD+xFEXAx9T5htqK+8uxM53JXAWANQ8CECW+bnp707W3Oj0722cM5B5rAXz5s2zmRh8P3HX3ocffjg1V2iVc6YJjIrOg6aIXifWmaKYVHlfVxK9EAf6UJCcCpI30tHVH3Vu9Z/rKxDulAcStbJQEAFaNDkrLwVmgJAFKgkHUruQs65MwdzJwhXn+5a3XlROxjVKtn1/x+WWW84+D1MZbc+j4MS1x5lb//znP1vCmOXrl9QnR775iBQ1m1ZB9Fx/Ntxww8LqdNq4NUX08GGFCKGQR1PdkBTZRWOj9o0dO9ZGaOdVd/P456H+kZuNOZoUAe4iqJPMwBAzNgKk3olLEYNJDX/EUDNyJ747/tyAoBDtDjZFCyZ40iMR7V62tG3OQNDYGKDcJZF/vuPMiSQf86rnTBMYFR3HpoheJ9aZophUeV9XEr0QB/pQkJwJuKifX9S51X+ur0A40yO7O3ypCMYompzVpZUhZUjRKCVUURaLMgUTBEEHJDguUxxRIno6mqyYen1/Rz6KLIakQcFHsWj/qdctroxNGdIMGUWFYS7EpfkJwaYKoufcENhAxB0dF9KONhA9lEnM6XE5Jp1vJtHYLtUKBJu/5+mzI2YhSi7+dLSFgJ4kIs8CQuLqpGP7HAnHpYO5Fp23KMK813GJ3+PGpBPfHb8dELz333/fQEaKFr4fn/3sZ4NzHqY9p21zxs0vTPNxvt++6wDWpLiE/lXPmSYwKjoXmiB6nVpnimJS5X1dSfScClfWgR4g3a6qKGliEYAsxqV3oX5fgWAnz4eNRb2If54bePcRqcsXq8oJFlIXPigQ3wMOOCA2Ctn3d8S0xYfxxhtvtGpAUf882uUW16Q8jCFt5xpH0vgzhK/IubNVED1XB3OsDv/NphQ93ieITFyqGzD2o7FJ9TJnzhw7b+rwz/PdRJJInH9N0nnIjgjGzTXnIA5ZDd1wdOK7E/o+dOK6Ns0Z3yWE89Ljgub8a1Cm49yGqp4zdWNUZtybIHqdWmfK4FLVvV1H9Kp0oK+C6MU5t/qD45uZOeUBEsCCFJrUNW6gHdEram6uavJUVY/L7o8pKC4tie8DxTMJnFh++eVzKTjRtjoVjvQ7SYtzaP/aRvSKEs42mPMdacL8nJRj0je5E7GK71GeowHdO4nJN4tY+QQ8SW3z3/G4HH9OSWCDGmeadUc5khonVBHuxHcn9H1o+rq2zRl/fiZZiny1Li5VVtVzpgmMksb9L3/5i3W3IBVamYL6jhiw0EILFaqmE+tMoYbWcFPXET1/JxTqz5KGWxlFL8m51X+eH5TBv5c1E1JHX1P0Qo6u8oMywCDJryX0HXFmTj64ZetqG9ErquhlmfNJc4MqQALypPQfZc35Icfa+S4RjDdkDyXVRWtnzYGof16/fv0M84ETP6JuCD7RgxTGnbCD6ZijGHl+3KkdfnL3OLKY1z+vU9+dLFw79Xvb5owjcURQY+qPS9bvvuGDBg2KTX5f9ZxpAqOk8WcNxMyf5s/J8aG8W2zikwrfnDKJ2juxznTqnYg+t+uIXlUO9A6IMj56ac6tPtB+UEZoVF3aBKnCR68N6g19jGb3T+q3H5TBNUmLbuiL5RZnnl+2LvnohaKefR0kjM1X1nnOvktE0sk4SU+LBk4QHTlp0iQbkBN3/B1qBBuNOPcOSCe+eXfeeac90YS0L9GTVfxFO+pu4avVoQp9p747Pp5tCsZo25xxCi3fljifTpfomjlFYB4ZGKKl6jnTBEbZb3fyFXWbbju1zpTBpMp7u47oud0vEVtFU1n4AJaJuoUskMQ1K/Gxr0BUpUKWjbrNUm9CJllZ9YZnsNNkUR8/fnzm0VUuKCOvghPXF+f/goqDChON7gzpv7tGUbd50Eq/FhKGiSUrp6UflJFXkXUqvou05l3CUhB3uo47B5vNVdQMB0mbOnWqTY8xevRo64uVlDDZbc6iZA5fO+a/23CEHN/Wqe+OP3JtCsZo25xxJI0TeaJJ2MEN9Yp1Y9y4ceZb3/pWYjBKlXOmCYzKfAXqJnqdWmfKYFLlvV1F9PzdbxWLPUDy0eQosryLBQECJE/F/4AI0CyzkVMgcB4PdRqPG2hHKmbNmpXLXFXlpKmqrg8++MBMmTLFXHHFFRZDjrpLi+B1QRlLL720vT6qvoS2y98ts5tmocV8V6aUTXlTRTCGy6NHypEiZzZn9b/OYAzebZQQTLAE2GAKJco1rbigjLwR8yQaJr8ZZlT8AEnVA0kjXU9cIYceShyLNOoe0b4QQ56PEkjCW87eTTvhgO8EfoTc66KDp0+fbs+uJr1PUnRmtD2d+u5kzY1O/N7mOUPya75RpJ5inpFnlbGD4HHuNoFGW265Zer3roo50yRGZeZAnUSvU+tMGTyqvrfVRM+PZsvqeFJ0U9Z9TmbHVyJLRaAuP+LPrzuLeKJAsFiwKIQmdY1ru0v0SlBHGbKThUudv/um7Ohz0iKJnb8jL26e5Na+X2dWv0LNZ9F6ypxK4T7GkA8CBEi1gONxXn8U14a8xCcLE/d7HUTPP/0k2o4NNtggNXrYnSjBmOVRZJk/KLrkMOM9In9d1jvJyQa8+2xM+DMbOxZqci9mbfJcv958801rlia3GqQQcoiiDLnNSvPS6e9O6Bxp4rpumTOvv/66IYk2Gwu+QZzLPWLECGveD43MLzpnOoFRmbGvg+g1vc6U6X/d97aa6NXdeep3qQ2QdoueddtEO/3Fti+eddskhnU8yzn4E00degaxU5PT2pOU0iN6T18767aOMWpbnb6FArWvyEk5beuT2lMvAn11ztRB9Oodie6qfYEnegwXu3tyqmWlWmjD0LI7xIE3LulqG9q3oLbBbRhQi+rIYZeFq1MtyS2ZJ3FwVr3+73Uoenme363XMjaY4VD98S12xfkZgitO+wMGDOjWLqrdFSOwoM0ZEb2KJ1CkOhE9Y4yTeDGl1OHbVNUQuqAO5HzIRJYPU1XPVT1hCGBe44PViQ2DSz8DyRs2bFhYg3NeJaKXEzBjDJih1pGaxndL8AM5+O7gu+uTwPxP0h19BYEFcc6I6NU7e0X0Pk7xwVmW+Ee1mUA5QkrSyLoW83qnW9+u3TlPDx061IwZM6ZXmo26eu/8cUhIWuf8JWBkxowZ9pg6kZKw0XTmeYIwcA1B1UPJw5+Sc2+dqZ/chypCAAQWxDnz+OOP20ClUH9XzZR8CIjofYyX20VxvFaZUyvywR9+tUvzQLRtVo6x8Fp1ZdUIsIBfddVVNhUHi3oThblLQAHpGsgpp9IeBDDlk2Nv2rRp1nLAe0wE5uDBg82oUaNsVGbZs6Lb01u1pAoENGeqQFF1+AiI6H2MhjOl3HHHHWbixIlm2WWXbdVMmTlzplUEiMxkcVBpJwIkTyZlBulamjDHuYS9RHE28bx2oq5WCQEhIASEQBICInoeMi6ZJT5whx56aGLy06anE3m8UIi22WYbm9Ihmnm/6fboeekIMF5sFoYPH25GjhxZ23i5zQmnFJD8t3///hoaISAEhIAQEAI9EBDRi0wIyB7Hg6GUkJuv075IJPcloSumniFDhtRGGvReVIvA3Llz7ZFZnJgwcODAaiv/uDZ8eTiZASUvNC9XLQ1RpUJACAgBIdBaBET0Wjs0apgQEAJCQAgIASEgBMohIKJXDj/dLQSEgBAQAkJACAiB1iIgotfaoVHDhIAQEAJCQAgIASFQDgERvXL46W4hIASEgBAQAkJACLQWARG91g6NGiYEhIAQEAJCQAgIgXIIiOiVw093CwEhIASEgBAQAkKgtQiI6LV2aNQwISAEhIAQEAJCQAiUQ0BErxx+ulsICAEhIASEgBAQAq1FQESvtUOjhgkBISAEhIAQEAJCoBwCInrl8NPdQkAICAEhIASEgBBoLQIieq0dGjVMCAgBISAEhIAQEALlEBDRK4ef7hYCQkAICAEhIASEQGsRENFr7dCoYUJACAgBISAEhIAQKIeAiF45/HS3EBACQkAICAEhIARai4CIXmuHRg0TAkJACAgBISAEhEA5BP4Pei1XT0IBcgIAAAAASUVORK5CYII=&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面我们假设了N=2&lt;sup&gt;k&lt;/sup&gt;，对于N不是2的幂（通常都是这种情况），其实，结果都是差不多的，也只是最多再多一次过程而已。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt;从分析可以看出，归并排序的最好最坏都&lt;strong&gt;稳定在O(NlogN)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度：&lt;/strong&gt;需要&lt;strong&gt;O(N)&lt;/strong&gt;个临时空间进行合并操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定性：稳定。&lt;/strong&gt;采用分治的思想，每次合并时，在前面的总会先存入临时数组内。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;hjava-1&quot;&gt;&lt;span&gt;五、简谈java泛型为什么选择归并排序&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;归并排序与其他O(NlogN)排序算法相比，时间很依赖比较算法与在数组中移动元素（包括临时数组中）的相对开销。这是与语言环境有关的。对于Java来说，进行比较可能比较耗时（使用Comparator）；但移动元素属于引用赋值，不是庞大对象的拷贝。归并算法在所有流行的使用比较的算法中使用最少的比较次数。&lt;/strong&gt;另一个原因是&lt;strong&gt;归并排序是稳定&lt;/strong&gt;的，这在某些特殊的场景特别重要。&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;六、总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;本篇通过画图详述了归并排序的过程，还通过数学证明归并排序时间复杂度稳定在O(NlogN)；简谈了下java选择归并排序的原因。java中对于基本类型的排序，使用的是快速排序。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 29 Apr 2019 07:00:00 +0000</pubDate>
<dc:creator>9龙</dc:creator>
<og:description>一、引言 我们知道，java中泛型排序使用归并排序或TimSort。归并排序以O(NlogN)最坏时间运行，下面我们分析归并排序过程及分析证明时间复杂度；也会简述为什么java选择归并排序作为泛型的排</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/9dragon/p/10790415.html</dc:identifier>
</item>
<item>
<title>ToB蓝海的台阶-PaaS,SaaS技术详解 - 三升水</title>
<link>http://www.cnblogs.com/sanshengshui/p/10790416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshengshui/p/10790416.html</guid>
<description>&lt;pre class=&quot;md-meta-block md-end-block&quot;&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/SaaS-banner.jpg&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/SaaS-banner.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;随着大量SaaS公司进入市场，我们看到颠覆性的软件服务以各种方式进入企业流程-从营销工具到支付系统。随着SaaS帮助优化业务流程，实现更流畅和自动化的运营，风险投资公司首先潜入池中寻找最优秀和最聪明的企业。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;从Zoom(一家提供结合了视频会议，在线会议，聊天和移动协作的通信软件)上市,阿里收购Teambition，SaaS正成为风险投资公司和创业极其有利可图的途径。为了了解SaaS,PaaS,下面将对其进行简单的概述。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果您正在考虑将您的业务迁移到云端，有三个词将萦绕在你耳边:&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;解释&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;IaaS企业提供诸如即时即付存储，网络和虚拟化等服务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;IaaS为用户提供了基于云的内部基础架构替代方案，因此企业可以避免投资昂贵的现场资源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;优势&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;维护内部部署的IT基础架构既昂贵又耗费人力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;它通常需要在物理硬件上进行大量的初始投资，然后您可能需要聘请外部IT承包商来维护硬件并保持一切正常运行和最新。&lt;span&gt;&lt;strong&gt;通过IaaS，您可以根据需要购买所需的产品，并随着业务的增长购买更多产品&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;特点&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;IaaS平台是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;示例&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;IaaS示例: 阿里云服务器ECS, AWS EC2Google Compute Engine（GCE）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 class=&quot;md-end-block md-p&quot;/&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;解释&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;PaaS供应商通过互联网提供硬件和软件工具，人们使用这些工具开发应用程序。PaaS用户往往是开发人员。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;优势&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;PaaS主要由正在构建软件或应用程序的开发人员使用。PaaS解决方案为开发人员提供了创建独特，可定制软件的平台。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这意味着开发人员在创建应用程序时无需从头开始，在编写大量代码时节省了大量时间（和金钱）。PaaS是那些想要创造独特应用程序而又不花钱或承担全部责任的企业的热门选择。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;特点&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;PaaS平台是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可供多个用户访问。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可扩展 - 您可以从各种级别的资源中进行选择，以适应您的业务规模。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;基于虚拟化技术。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;无需广泛的系统管理知识即可轻松运行。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;示例&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;PaaS示例: AWS Elastic Beanstalk，Heroku，Windows Azure（主要用作PaaS）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 class=&quot;md-end-block md-p&quot;/&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;解释&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;SaaS平台通过互联网向用户提供软件，通常每月订阅费用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;优势&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://learn.g2crowd.com/what-is-saas&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;SaaS&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;，您无需在计算机（或任何计算机）上安装和运行软件应用程序。当您在线登录帐户时，一切都可通过互联网获得。您通常可以随时从任何设备访问该软件（只要有互联网连接）。使用该软件的其他人也是如此。您的所有员工都将拥有适合其访问级别的个性化登录。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;另一个关键优势是支付结构:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;大多数SaaS提供商都使用固定的包含性月度帐户费用来运营订阅模式。您确切地知道软件的成本是多少，并且可以相应地进行预算，而不必担心隐藏的意外。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;大多数订阅包括维护，合规性和安全性服务，这在使用内部部署软件时可能既耗时又昂贵。SaaS提供商还提供易于设置的开箱即用解决方案（如果您需要基本软件包），并为大型组织提供更复杂的解决方案。您可以在几小时内启动并运行基本软件 - 并且您可以在此过程中获得客户服务和支持。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;特点&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;SaaS平台是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可通过互联网获得。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;由第三方提供商托管在远程服务器上。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可扩展，具有适用于小型，中型和企业级业务的不同层。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;包容性，提供安全性，合规性和维护作为成本的一部分&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;示例&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;SaaS示例: BigCommerce，Google Apps，Salesforce，Dropbox，MailChimp，ZenDesk，DocuSign，Slack，Hubspot。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;什么是多租户&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;聊到PaaS,SaaS，就不得不谈到多租户。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多租户指一套系统能够支撑多个租户。一个租户通常是具有相似访问模式和权限的一组用户，典型的租户是同一个组织或者公司的若干用户。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;要实现多租户，首先需要考虑的是数据层面的多租户。数据层的多租户模型对上层服务和应用的多租户实现有突出影响。本文重点介绍数据层多租户对各种多租户模型的支持。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;权衡不同的多租户实现方式时，需要考虑如下因素：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;扩展性：租户数量级别，以及未来发展趋势&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;安全性：租户之间数据隔离级别要求&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;资源共享：多租户通常有某种形式的资源共享，需要避免某个租户的糟糕SQL吃掉系统资源，影响其他租户的响应时间&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;灵活性：不同租户可能有不同的需求，对特定租户需求的扩展能力&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;跨租户分析和优化：对全部租户或者多个租户的数据和行为进行分析的能力&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;运维和管理：运维管理的复杂度和便宜性，包括监控、修改数据库模式、创建索引、收集统计数据、数据加载等&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;成本：总体拥有成本，包括方案实现成本、运维成本等&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多租户模型&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多租户模型描述了租户和该租户的数据之间的映射关系。不同的多租户模型会影响数据库和应用程序的设计、管理和维护。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一租户一数据库&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;最简单的多租户实现方式是为每一个租户创建一个数据库，如下图所示。应用程序为每个租户分配一个租户id，并为每个租户配置相应的数据库连接信息（包括数据库ip、端口等）。应用程序根据租户id连接到为其分配的数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/%E4%B8%80%E7%A7%9F%E6%88%B7%E4%B8%80%E6%95%B0%E6%8D%AE%E5%BA%93.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/%E4%B8%80%E7%A7%9F%E6%88%B7%E4%B8%80%E6%95%B0%E6%8D%AE%E5%BA%93.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这种模型中不同租户的数据物理隔离，安全级别高。如果每个租户的数据库使用不同的硬件和数据库类型，则他们之间的资源使用也是物理隔离的；如果租户的数据库共用同一套硬件，则需要对资源进行合理分配和管理，避免相互影响。由于不同租户使用独立的数据库，灵活性好，容易满足不同租户的特定需求（譬如需要额外的字段）。出现故障时影响面小。缺点是数据库数量大，维护复杂，拥有成本高。适合租户数目比较少的场景。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一租户一名字空间（Schema/Namespace）&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多个租户共享同一个数据库，每个租户拥有独立的名字空间（或模式）。应用程序为每个租户分配一个id，并把每个租户的所有操作限制在为其分配的名字空间/模式之中。如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/%E4%B8%80%E7%A7%9F%E6%88%B7%E4%B8%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/%E4%B8%80%E7%A7%9F%E6%88%B7%E4%B8%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这种多租户模型下，不同租户的数据逻辑上相互隔离，安全控制相对简单。不同租户有不同的模式，可以简便的满足不同租户的特定需求，灵活性高。对资源管理能力要求高，以避免不同租户竞争资源。可以把不同租户的数据存储在不同的磁盘上，降低了对磁盘IO的竞争。运维和管理较复杂，不易实现大量租户的跨租户分析。适合租户数目适中的场景。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;全共享方式&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;不同租户共享同一个数据库、同一个名字空间。不同租户的数据在同一组表中共存，通过租户id标记和访问不同租户的数据（应用需要调整访问数据的SQL以包含租户id）。如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/%E5%85%A8%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/%E5%85%A8%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这种多租户模型中，不同租户的数据物理存储在一起，对系统的资源隔离和安全隔离要求很高。运维相对简单。扩展能力好，可以支持较多数量租户。由于租户数据存储在一起，跨租户数据分析和优化非常简单。成本低，可以较低的代价支持更多的租户。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;全共享模型中，很多数据库采用添加大量自定义字段的方式满足不同租户的特定需求，以提高灵活性。这种方式有诸多局限性，譬如字段数目不能太多、管理复杂等。支持更多半结构化数据，包括JSON 等，通过这种半结构化数据，可以更灵活、高效、便捷的满足不同租户的特定需求。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下面我通过用一个简单的全共享数据库的多租户模式的案例，来对PaaS平台型软件进行演示。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;系统账户层级如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/Multitenancy.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/Multitenancy.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在上图这个系统用户的层级关系中，我们需要四张表:&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;4.0153846153846&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2.3162790697674&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ga_user:此表用于存储PaaS平台T1内所有的账户相关信息，如&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;mailto:laowang@test.com&quot;&gt;laowang@test.com&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;,&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;mailto:zhangshan@test.com&quot;&gt;zhangshan@test.com&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;,&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;mailto:jingwa@test.com&quot;&gt;jingwa@test.com&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;等账户和密码。此表用于登录平台时，系统认证和权限控制时所用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;tenant:用于存储所有的租户信息，如SaaS A, SaaS B,SaaS C。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;customer:用于存储所有的客户信息，如消费客户/组织S1,消费客户/组织S2。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;device:用于存储平台内所有客户，租户的设备相关信息。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;具体流程,可以概括为:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们用PaaS平台系统管理员帐号&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;mailto:laowang@test.com&quot;&gt;laowang@test.com&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;登录系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在系统中，新建SaaS A, SaaS B,SaaS C三个组织或者客户，并为这三个租户分配各种租户的租户管理员账户，分别为&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;mailto:zhangsan@test.com&quot;&gt;zhangsan@test.com&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;, &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;mailto:lisi@test.com&quot;&gt;lisi@test.com&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;,&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;mailto:wangwu@test.com&quot;&gt;wangwu@test.com&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;。当我们用这三个账户登录系统时，系统根据租户id和相应的权限显示对应的框架内容和组织信息。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这三个组织利用PaaS平台上的服务框架和应用为需要的客户和组织提供一站式解决方案，有点类似我们采用阿里云平台上的服务框架来解决自己的企业需求。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当SaaS B具体到实施项目时，为消费客户/组织S1或消费客户/组织S2分配帐号进行公有云订阅服务，进行项目迭代交付或者本地化实施。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;UML实体图如下:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/Mlti%20tenancy%20UML%20.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/ToB%E8%93%9D%E6%B5%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%A8%E6%A7%9B/Mlti%20tenancy%20UML%20.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;版权声明: 作者：穆书伟&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;github出处：&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsanshengshui&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;github.com/sanshengshu…&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;个人博客出处：&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/sanshengshui/p/blog.grozacloud.com&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;blog.grozacloud.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 07:00:00 +0000</pubDate>
<dc:creator>三升水</dc:creator>
<og:description>前言 随着大量SaaS公司进入市场，我们看到颠覆性的软件服务以各种方式进入企业流程-从营销工具到支付系统。随着SaaS帮助优化业务流程，实现更流畅和自动化的运营，风险投资公司首先潜入池中寻找最优秀和最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanshengshui/p/10790416.html</dc:identifier>
</item>
<item>
<title>ThreadLocal的应用与实现原理 - Pedlar</title>
<link>http://www.cnblogs.com/pedlar/p/10785542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pedlar/p/10785542.html</guid>
<description>&lt;p&gt;　　本文对ThreadLocal的分析基于JDK 8。&lt;/p&gt;
&lt;h2&gt;本文大纲&lt;/h2&gt;
&lt;p&gt;　　1. &lt;a href=&quot;http://www.cnblogs.com/pedlar/p/10785542.html#p1&quot;&gt;ThreadLocal快速上手&lt;/a&gt;&lt;br/&gt;　　2. &lt;a href=&quot;http://www.cnblogs.com/pedlar/p/10785542.html#p2&quot;&gt;ThreadLocal应用场景&lt;/a&gt;&lt;br/&gt;　　3. &lt;a href=&quot;http://www.cnblogs.com/pedlar/p/10785542.html#p3&quot;&gt;TheadLocal set与get方法简析&lt;/a&gt;&lt;br/&gt;　　4. &lt;a href=&quot;http://www.cnblogs.com/pedlar/p/10785542.html#p4&quot;&gt;TheadLocal与内存泄漏&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1. ThreadLocal快速上手&lt;/h2&gt;
&lt;p&gt;　　ThreadLocal是java.lang包下的一个类，它可以为每个线程维护一份独立的变量副本。当线程运行结束后，线程内部的引用的指向的实例副本都会被回收。&lt;/p&gt;
&lt;p&gt;　　对于初次接触ThreadLocal的同学来说，看了上面这段话可能还是蒙的，下面我们通过简单的例子快速上手ThreadLocal。&lt;/p&gt;
&lt;p&gt;　　我们先看看不使用ThreadLocal的情况下，让两个线程共享一个打印Task进行打印输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocalTest1 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Runnable task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Task();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(task, &quot;t1&quot;&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(task, &quot;t2&quot;&lt;span&gt;).start();
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Task &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
        Integer counter &lt;/span&gt;= 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多个线程共享的实例&lt;/span&gt;
&lt;span&gt;
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; -&amp;gt; &quot; + counter++&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;1000L&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　毫无疑问，上面这段代码对counter的操作不是线程安全的，因为counter是两个线程间共享的，所以一个线程对counter的修改操作可能会影响另一个线程对counter的输出，下面我节选了部分输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
t2 -&amp;gt; 0&lt;span&gt;
t1 &lt;/span&gt;-&amp;gt; 0 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; t1线程打印0&lt;/span&gt;
t2 -&amp;gt; 1&lt;span&gt;
t1 &lt;/span&gt;-&amp;gt; 2 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; t1线程打印couter从0直接跳到了2，因为t0线程对counter做了修改&lt;/span&gt;
t2 -&amp;gt; 3&lt;span&gt;
t1 &lt;/span&gt;-&amp;gt; 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　可以从下图看出两个线程共享counter大致模型：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439038/201904/1439038-20190428175133187-402071603.png&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　假设，现在有一个需求，要求t1和t2各自分别进行计数并打印，那么这时我们就可以使用ThreadLocal了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocalTest1 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Runnable task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Task();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(task, &quot;t1&quot;&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(task, &quot;t2&quot;&lt;span&gt;).start();
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Task &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
        ThreadLocal&lt;/span&gt;&amp;lt;Integer&amp;gt; cntTl = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Integer initialValue() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置初始值为0&lt;/span&gt;
&lt;span&gt;            }
        };

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                Integer counter &lt;/span&gt;= cntTl.get(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取值&lt;/span&gt;
                System.out.println(Thread.currentThread().getName() + &quot; -&amp;gt; &quot; + counter++&lt;span&gt;);
                cntTl.set(counter); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; counter++后，将counter值设置回去&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;1000L&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　运行上面代码的部分输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
t1 -&amp;gt; 0&lt;span&gt;
t2 &lt;/span&gt;-&amp;gt; 0&lt;span&gt;
t1 &lt;/span&gt;-&amp;gt; 1&lt;span&gt;
t2 &lt;/span&gt;-&amp;gt; 1&lt;span&gt;
t1 &lt;/span&gt;-&amp;gt; 2&lt;span&gt;
t2 &lt;/span&gt;-&amp;gt; 2&lt;span&gt;
t1 &lt;/span&gt;-&amp;gt; 3&lt;span&gt;
t2 &lt;/span&gt;-&amp;gt; 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，t1和t2两个线程分别按顺序输出了1、2、3......这就是因为上面提到过的ThreadLocal为每个线程都维护了一份数据的副本，在本例中的体现就是两个线程t1、t2中都各自有一个counter，t1和t2线程各自操作自己的counter，因此对其中一个counter的数据进行修改不会对另一个counter产生影响。&lt;/p&gt;
&lt;p&gt;　　使用ThreadLocal后的模型：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1439038/201904/1439038-20190428175202862-1911182351.png&quot; alt=&quot;&quot; width=&quot;498&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们再理解深入一点，每个线程都有一个ThreadLocalMap对象，ThreadLocalMap是ThreadLocal的一个内部类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
ThreadLocal.ThreadLocalMap threadLocals &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Thread类中的threadLocals属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　线程t1和t2&lt;span&gt;各自都有一个ThreadLocalMap对象&lt;/span&gt;，暂且就把它看成一个Map就行，这个Map以当前ThreadLocal对象为key，value为我们要保存的值。当使用cntTl调用get方法时，其实是以当前ThreadLocal对象为key去获取对应的value。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439038/201904/1439038-20190429140446252-1577599960.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;466&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2. ThreadLocal应用场景&lt;/h2&gt;
&lt;p&gt; 　　ThreadLocal主要有如下两种应用场景：&lt;/p&gt;
&lt;p&gt;　　1. 每个线程需要单独维护一个对象实例，就像在&lt;a href=&quot;http://www.cnblogs.com/pedlar/p/10785542.html#p1&quot;&gt;快速上手&lt;/a&gt;提到的那样；&lt;/p&gt;
&lt;p&gt;　　2. 在同一线程执行的不同方法中共享对象实例。&lt;/p&gt;
&lt;p&gt;　　下面将重点分析第2种应用场景。熟悉Web开发的同学都知道MVC模型，C（Controller）会调用Service，Service调用DAO，DAO会使用Connection去连接数据库。在直接使用JDBC和数据库通信的情况下，我们需要在Service中创建Connection对象，然后打开事务，并将Connection以参数的形式传递给DAO，DAO使用Connection对象与数据库进行（开启事务的Connection和执行SQL的Connection必须是同一个），交互完成后我们在Service层进行事务的提交或者回滚。在不使用ThreadLocal的情况下，我们可能会这样写代码：&lt;/p&gt;
&lt;p&gt;　　一个SqlRunner类用于执行SQL:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlRunner {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Connection connection, String sql, Object data) {
        System.out.println(&lt;/span&gt;&quot;sql: &quot; + sql + &quot; executed successfully&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Dao调用SqlRunner：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; save(Connection connection, Object data) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收Connection&lt;/span&gt;
        SqlRunner sqlRunner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlRunner();
        sqlRunner.save(connection, &lt;/span&gt;&quot;insert into ...&quot;&lt;span&gt;, data);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Service调用Dao：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Service {
    Dao dao &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dao();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Object data) {
        Connection connection &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Connection(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Connection&lt;/span&gt;
        connection.beginTransaction(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启事务&lt;/span&gt;
        dao.save(connection, data); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入connection对象&lt;/span&gt;
        connection.commit(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交事务&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Service service &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Service();
        service.save(&lt;/span&gt;&quot;test data&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　控制台输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;transaction begin
data: test data, sql: insert into ... executed successfully
transaction commit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为开启事务的Connection和执行SQL的Connection必须是同一个，所以可以看到Service中将创建的Connection以参数的方式传给了Dao，但是这种以传参的方式共享Connection会导致每个调用Dao方法的Service都必须传递Connection，显得太不优雅，下面我们将使用ThreadLocal来改变这种局面。&lt;/p&gt;
&lt;p&gt;　　SqlRunner和上面的一样，这里不再贴出代码。&lt;/p&gt;
&lt;p&gt;　　新增一个DataSource类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataSource {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;Connection&amp;gt; tl = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用ThreadLocal包装Connection&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beginTransaction() {
        getCurrentConnection().beginTransaction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启事务&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; commit() {
        getCurrentConnection().commit(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交事务&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Connection getCurrentConnection() {
        Connection connection &lt;/span&gt;= tl.get(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从ThreadLocal对象tl获取connection&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (connection == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            connection &lt;/span&gt;= getConnection(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有和当前线程绑定的connection，则新建一个&lt;/span&gt;
            tl.set(connection); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将新建的connection与当前线程绑定&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connection;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Connection getConnection() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Connection(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Dao：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Object data) {
        SqlRunner sqlRunner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlRunner();
        Connection connection &lt;/span&gt;= DataSource.getCurrentConnection(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取与当前线程绑定的connection&lt;/span&gt;
        System.out.println(&quot;connection in dao: &quot; + connection); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印Dao中的connection对象&lt;/span&gt;
        sqlRunner.save(connection, &quot;insert into ...&quot;&lt;span&gt;, data);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Service：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Service {
    Dao dao &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dao();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Object data) {
        DataSource.beginTransaction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用Connection开启事务&lt;/span&gt;
&lt;span&gt;        dao.save(data);
        System.out.println(&lt;/span&gt;&quot;connection in dao: &quot; + DataSource.getCurrentConnection()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印Service中connection对象&lt;/span&gt;
        DataSource.commit(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交事务&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试类和上面的ServiceTest相同，这里不再贴出。&lt;/p&gt;
&lt;p&gt;　　控制台输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;transaction begin
&lt;span&gt;connection in Dao: com.andywooh.texplore.demo.concurrency.threadlocal.Connection@&lt;strong&gt;15db9742
&lt;/strong&gt;&lt;/span&gt;data: test data, sql: insert into ... executed successfully
&lt;span&gt;connection in Service: com.andywooh.texplore.demo.concurrency.threadlocal.Connection@&lt;strong&gt;15db9742
&lt;/strong&gt;&lt;/span&gt;transaction commit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，在Service中的connection和Dao中的Connection是同一个对象。&lt;/p&gt;
&lt;p&gt;　　简单对ThreadLocal方式在同一个线程中、不同方法间共享connection对象做一个分析：调用Service的save方法，在开启事务前会先使用DataSource的getCurrentConnection去获得一个连接，由于是第一次获取connection，此时还没有和当前线程绑定的connection对象，所以会调用getConnection方法区创建一个connection对象，并将这个connection对象和当前线程进行绑定。当在同一个线程中在Dao里再一次调用getCurrentConnection时，由于已经有一个connection和当前线程绑定，所以就会直接返回该connection对象，这样就实现了不传参但是却在Service和Dao中使用同一个Connectiond的功能。&lt;/p&gt;
&lt;h2&gt;3. TheadLocal set与get方法简析&lt;/h2&gt;
&lt;p&gt;　　下面对ThreadLocal的set和get方法进行分析。再次说明一下，每个线程都包含一个ThreadLocalMap，我们先将其当成一个Map就行，ThreadLocalMap是ThreadLocal的一个内部类，这个Map中存储了我们想要和当前线程绑定的值，其中key是当前ThreadLocal对象，value是我们想要保存的值。&lt;/p&gt;
&lt;p&gt;　　set方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(T value) {
    Thread t &lt;/span&gt;= Thread.currentThread(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程&lt;/span&gt;
    ThreadLocalMap map = getMap(t); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程内的map&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        map.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, value); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; map不为空，则以当前ThreadLocal对象为key，value为我们想要保存的值设置到map中&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        createMap(t, value); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; map为空，创建一个map来保存value，当然key还是当前ThreadLocal&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　get方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T get() {
    Thread t &lt;/span&gt;= Thread.currentThread(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程&lt;/span&gt;
    ThreadLocalMap map = getMap(t); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程内的map&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        ThreadLocalMap.Entry e &lt;/span&gt;= map.getEntry(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以当前ThreadLocal对象为key取entry对象&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
            T result &lt;/span&gt;= (T)e.value; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取entry中包装的值，也就是我们之前设置进来的value&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; setInitialValue(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; map为空，创建一个map并给map设置一个初始值entry；或者map中没有entry，给已有的map添加一个初始值的entry&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4. TheadLocal与内存泄漏&lt;/h2&gt;
&lt;p&gt;　　 前面提到过，当线程销毁的时候，与线程绑定的相关的对象将会被GC。下面的代码展示了Thread类中的exit方法，可以看到这里将threadLocals（就是ThreadLocalMap）进行了置空，方便虚拟机对ThreadLocalMap对象进行回收。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; exit() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (group != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        group.threadTerminated(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        group &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Aggressively null out all reference fields: see bug 4006245 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    target &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Speed the release of some of these resources &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    threadLocals &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把ThreadLocalMap引用置空&lt;/span&gt;
    inheritableThreadLocals = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    inheritedAccessControlContext &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    blocker &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    uncaughtExceptionHandler &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　但是在一些线程不会死亡的场景，比如在线池，因为线程不会结束，如果处理的不好，那么和线程绑定的对象就会一直存在，从而造成内存泄漏。&lt;/p&gt;
&lt;p&gt;　　因为这里涉及到强、弱引用的知识，这里简单介绍一下：我们平常写的Object obj = new Object()中的obj就是强引用，只要还有强引用指向一个对象，这个对象不会被回收。而对于弱引用，一旦发现只被弱引用引用的对象，不管当前内存空间足够与否，这个对象都会被回收。&lt;/p&gt;
&lt;p&gt;　　ThreadLocalMap中的Entry的key就是一个弱引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry &lt;span&gt;extends&lt;/span&gt; WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The value associated with this ThreadLocal. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object value;

    Entry(ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; k, Object v) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(k); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个弱引用的key&lt;/span&gt;
        value =&lt;span&gt; v;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下图展示了Thread对象、ThreadLocal对象、ThreadLocalMap对象以及Entry对象之间的联系，其中虚线箭头表示Entry中的弱引用key指向了ThreadLocal对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439038/201904/1439038-20190429112006547-91361975.png&quot; alt=&quot;&quot; width=&quot;705&quot; height=&quot;419&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Entry对象中弱引用key指向了我们的ThreadLocal对象，当我们将ThreadLocal对象的引用置为null后，就没有强用用指向它，只剩这个弱引用指向ThreadLocal对象，那么JVM会在GC的时候回收ThreadLocal对象。然而Entry对象中value引用指向的value对象还是存活的，这样就会导致value对象一直得不到回收。但是，在我们调用ThreadLocal对象的get、set、remove方法时，会将上述提到的key为nul对应的value对象进行清除，从而避免了内存泄漏。值得注意的是，如果我们在创建一个ThreadLocal对象并set了一个value对象到ThreadLocalMap，然后不再调用前面提到的get、set、remove方法中的任意一个，此时就可能会导致这个value对象不能被回收。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 06:32:00 +0000</pubDate>
<dc:creator>Pedlar</dc:creator>
<og:description>本文对ThreadLocal的分析基于JDK 8。 本文大纲 1. ThreadLocal快速上手 2. ThreadLocal应用场景 3. TheadLocal set与get方法简析 4. Th</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pedlar/p/10785542.html</dc:identifier>
</item>
<item>
<title>OsharpNS轻量级.net core快速开发框架简明入门教程-Osharp.Redis使用 - willtoto</title>
<link>http://www.cnblogs.com/candoo/p/10790121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/candoo/p/10790121.html</guid>
<description>&lt;p&gt;教程目录&lt;/p&gt;
&lt;ol readability=&quot;5.5429497568882&quot;&gt;&lt;li readability=&quot;1.2060301507538&quot;&gt;
&lt;p&gt;从零开始启动Osharp&lt;/p&gt;
&lt;p&gt;1.1. &lt;a href=&quot;https://www.cnblogs.com/candoo/p/10773735.html#1&quot;&gt;使用OsharpNS项目模板创建项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.2. &lt;a href=&quot;https://www.cnblogs.com/candoo/p/10773735.html#2&quot;&gt;配置数据库连接串并启动项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.3. &lt;a href=&quot;https://www.cnblogs.com/candoo/p/10773735.html#3&quot;&gt;OsharpNS.Swagger使用实例(登录和授权)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.4. &lt;a href=&quot;https://www.cnblogs.com/candoo/p/10773735.html#4&quot;&gt;Angular6的前端项目启动&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.37037037037037&quot;&gt;
&lt;p&gt;Osharp代码生成器的使用&lt;/p&gt;
&lt;p&gt;2.1 &lt;a href=&quot;https://www.cnblogs.com/candoo/p/10778631.html&quot;&gt;生成器的使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.2 &lt;a href=&quot;https://www.cnblogs.com/candoo/p/10782102.html&quot;&gt;生成代码详解(如何自己实现业务功能)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.82352941176471&quot;&gt;
&lt;p&gt;Osharp部分模块使用&lt;/p&gt;
&lt;p&gt;3.1 &lt;a href=&quot;https://www.cnblogs.com/candoo/p/10790121.html&quot;&gt;Osharp.Redis使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.2 Osharp.Hangfire使用&lt;/p&gt;
&lt;p&gt;3.3 Osharp.Permissions使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;Osharp深度学习和使用&lt;/p&gt;
&lt;p&gt;4.1 切换数据库(从SqlServer改为MySql)&lt;/p&gt;
&lt;p&gt;4.2 多上下文配置(多个数据库的使用)&lt;/p&gt;
&lt;p&gt;4.3. 自定义模块的定义（Senparc.Weixin的使用）&lt;/p&gt;
&lt;p&gt;4.4. 继续学习中....&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;osharpns.redis使用&quot;&gt;OsharpNS.Redis使用&lt;/h2&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;ol readability=&quot;-0.03030303030303&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/candoo/p/10790121.html#1&quot;&gt;在Windows下配置Redis&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/candoo/p/10790121.html#2&quot;&gt;使用RedisDesktopManager连接Redis&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/candoo/p/10790121.html#3&quot;&gt;Osharp启用Redis&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/candoo/p/10790121.html#4&quot;&gt;Osharp初始化缓存查看&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/candoo/p/10790121.html#5&quot;&gt;Osharp缓存使用方法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;在windows下配置redis&quot;&gt;&lt;a name=&quot;1&quot;&gt;在Windows下配置Redis&lt;/a&gt;&lt;/h3&gt;
&lt;ol readability=&quot;6.5028409090909&quot;&gt;&lt;li readability=&quot;3.2982456140351&quot;&gt;
&lt;p&gt;前往&lt;a href=&quot;https://github.com/MicrosoftArchive/redis/releases&quot; class=&quot;uri&quot;&gt;https://github.com/MicrosoftArchive/redis/releases&lt;/a&gt;下载Windows版的Redis（.msi后缀），并完成安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508472/201904/1508472-20190426095315017-1972476661.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击版本号，进入对应版本的下载界面，下载.msi格式的就行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508472/201904/1508472-20190426095318974-348648568.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装时基本都是默认选项，下面这个界面的时候注意选下下面的选项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508472/201904/1508472-20190426095322923-4951345.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;Redis开启远程访问，注意修改的配置文件一般是redis安装目录下&lt;code&gt;redis.windows-service.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;网上很多文档都说改redis.windows.conf, 改了也没用；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190780/201812/1190780-20181206101220570-1188991561.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实我们可以查看一下服务里面的信息，看看到底使用的是那个配置文件，是哪个就改哪个，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190780/201812/1190780-20181206101519989-1516513577.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置文件基本修改两个地方即可；　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190780/201812/1190780-20181206101724710-537578379.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190780/201812/1190780-20181206101900685-2090614503.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改完以后，重启redis服务即可；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;使用redisdesktopmanager连接redis&quot;&gt;&lt;a name=&quot;2&quot;&gt;使用RedisDesktopManager连接Redis&lt;/a&gt;&lt;/h3&gt;
&lt;ol readability=&quot;-1.1820652173913&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;下载工具，工具是收费的，我是在&lt;a href=&quot;https://www.newasp.net/soft/391754.html&quot; class=&quot;uri&quot;&gt;https://www.newasp.net/soft/391754.html&lt;/a&gt;下载的，病毒自己鉴别，也可以自己找链接，反正下载安装了就行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508472/201904/1508472-20190426101948587-1165195264.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;osharp启用redis&quot;&gt;&lt;a name=&quot;3&quot;&gt;Osharp启用Redis&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;修改appsettings.Development.json中的Redis节点&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508472/201904/1508472-20190426102140525-388843250.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;配置说明&lt;/p&gt;
&lt;p&gt;2.1 Configuration配置连接串，因为Redis没有配置密码，只要填写&lt;code&gt;localhost&lt;/code&gt;,如有密码，参考格式&lt;code&gt;phone.qiadoo.com:6379,password=密码&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.2 InstanceName配置Redis中的前缀，名称中建议以&lt;code&gt;:&lt;/code&gt;结尾，具体效果自己对比&lt;/p&gt;
&lt;p&gt;2.3 Enabled配置是否启用，当然要改为&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;osharp初始化缓存查看&quot;&gt;&lt;a name=&quot;4&quot;&gt;Osharp初始化缓存查看&lt;/a&gt;&lt;/h3&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;启动项目，进入Swagger界面&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;使用工具查看Redis的数据，可以看到系统初始化后加载的数据&lt;/p&gt;
&lt;p&gt;2.1 FunctionRoles缓存，初始化代码位于项目&lt;code&gt;OSharp.Permissions&lt;/code&gt;,命名空间&lt;code&gt;OSharp.Permission.SecurityPackBase&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.2 All_KeyValue_Key缓存，初始化代码位于项目&lt;code&gt;OSharp.Permissions&lt;/code&gt;,命名空间&lt;code&gt;OSharp.Systems.SystemPack&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508472/201904/1508472-20190426103403526-1274063804.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;osharp缓存使用方法&quot;&gt;&lt;a name=&quot;5&quot;&gt;OSharp缓存使用方法&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;缓存使用&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;   // -----------------------------------------------------------------------
   //  &amp;lt;copyright file=&quot;TestController.cs&quot; company=&quot;OSharp开源团队&quot;&amp;gt;
   //      Copyright (c) 2014-2018 OSharp. All rights reserved.
   //  &amp;lt;/copyright&amp;gt;
   //  &amp;lt;site&amp;gt;http://www.osharp.org&amp;lt;/site&amp;gt;
   //  &amp;lt;last-editor&amp;gt;郭明锋&amp;lt;/last-editor&amp;gt;
   //  &amp;lt;last-date&amp;gt;2018-06-27 4:50&amp;lt;/last-date&amp;gt;
   // -----------------------------------------------------------------------
   
   using System;
   using System.Collections.Generic;
   using System.ComponentModel;
   using System.Linq;
   using System.Threading.Tasks;
   
   using CanDoo.Test.Identity;
   using CanDoo.Test.Identity.Dtos;
   using CanDoo.Test.Identity.Entities;
   
   using Microsoft.AspNetCore.Identity;
   using Microsoft.AspNetCore.Mvc;
   using Microsoft.AspNetCore.Mvc.Filters;
   using Microsoft.Extensions.Caching.Distributed;
   using Microsoft.Extensions.DependencyInjection;
   using Microsoft.Extensions.Logging;
   
   using OSharp.AspNetCore;
   using OSharp.AspNetCore.Mvc;
   using OSharp.AspNetCore.Mvc.Filters;
   using OSharp.Caching;
   using OSharp.Collections;
   using OSharp.Core.Systems;
   using OSharp.Data;
   using OSharp.Dependency;
   using OSharp.Entity;
   using OSharp.Exceptions;
   using OSharp.Identity;
   using OSharp.Json;

   namespace CanDoo.Test.Web.Controllers
   {
       [Description(&quot;网站-缓存测试&quot;)]
       [ClassFilter]
       public class TestCacheController : ApiController
       {
           private readonly IDistributedCache _cache;

           public TestCacheController(IDistributedCache cache, IKeyValueStore keyValueStore)
           {
               _cache = cache;
           }
    
           [HttpGet]
           [MethodFilter]
           [Description(&quot;写入缓存&quot;)]
           public async Task&amp;lt;string&amp;gt; Write()
           {
               await _cache.SetAsync(&quot;TestWrite&quot;, &quot;Test&quot;);
               return &quot;缓存写入完成&quot;;
           }
    
           [HttpGet]
           [MethodFilter]
           [Description(&quot;读取缓存&quot;)]
           public async Task&amp;lt;string&amp;gt; Read()
           {
               return await _cache.GetAsync&amp;lt;string&amp;gt;(&quot;TestWrite&quot;);
           }
    
           [HttpGet]
           [MethodFilter]
           [Description(&quot;移除缓存&quot;)]
           public async Task&amp;lt;string&amp;gt; Remove()
           {
               await _cache.RemoveAsync(&quot;TestWrite&quot;);
               return &quot;缓存移除完成&quot;;
           }
       }

   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;键值对使用&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
   // -----------------------------------------------------------------------
   //  &amp;lt;copyright file=&quot;SettingsController.cs&quot; company=&quot;OSharp开源团队&quot;&amp;gt;
   //      Copyright (c) 2014-2018 OSharp. All rights reserved.
   //  &amp;lt;/copyright&amp;gt;
   //  &amp;lt;site&amp;gt;http://www.osharp.org&amp;lt;/site&amp;gt;
   //  &amp;lt;last-editor&amp;gt;郭明锋&amp;lt;/last-editor&amp;gt;
   //  &amp;lt;last-date&amp;gt;2018-06-27 4:50&amp;lt;/last-date&amp;gt;
   // -----------------------------------------------------------------------

   using System;
   using System.ComponentModel;
   using System.Threading.Tasks;

   using CanDoo.Test.Systems.Dtos;

   using Microsoft.AspNetCore.Mvc;

   using Newtonsoft.Json;

   using OSharp.AspNetCore.Mvc.Filters;
   using OSharp.AspNetCore.UI;
   using OSharp.Core.Modules;
   using OSharp.Core.Systems;
   using OSharp.Data;
   using OSharp.Exceptions;

   namespace CanDoo.Test.Web.Areas.Admin.Controllers
   {
       [ModuleInfo(Order = 1, Position = &quot;Systems&quot;, PositionName = &quot;系统管理模块&quot;)]
       [Description(&quot;管理-系统设置&quot;)]
       public class SettingsController : AdminApiController
       {
           private readonly IKeyValueStore _keyValueStore;

           /// &amp;lt;summary&amp;gt;
           /// 初始化一个&amp;lt;see cref=&quot;SettingsController&quot;/&amp;gt;类型的新实例
           /// &amp;lt;/summary&amp;gt;
           public SettingsController(IKeyValueStore keyValueStore)
           {
               _keyValueStore = keyValueStore;
           }
    
           /// &amp;lt;summary&amp;gt;
           /// 读取设置
           /// &amp;lt;/summary&amp;gt;
           /// &amp;lt;param name=&quot;root&quot;&amp;gt;设置根节点，如投票设置为Votes&amp;lt;/param&amp;gt;
           /// &amp;lt;returns&amp;gt;相应节点的设置信息&amp;lt;/returns&amp;gt;
           [HttpGet]
           [ModuleInfo]
           [Description(&quot;读取设置&quot;)]
           public IActionResult Read(string root)
           {
               ISetting setting;
               switch (root)
               {
                   case &quot;System&quot;:
                       setting = _keyValueStore.GetSetting&amp;lt;SystemSetting&amp;gt;();
                       break;
                   default:
                       throw new OsharpException($&quot;未知的设置根节点: {root}&quot;);
               }
    
               return Json(new SettingOutputDto(setting));
           }
    
           /// &amp;lt;summary&amp;gt;
           /// 保存指定设置项
           /// &amp;lt;/summary&amp;gt;
           /// &amp;lt;param name=&quot;dto&quot;&amp;gt;设置信息&amp;lt;/param&amp;gt;
           /// &amp;lt;returns&amp;gt;JSON操作结果&amp;lt;/returns&amp;gt;
           [HttpPost]
           [ModuleInfo]
           [Description(&quot;保存设置&quot;)]
           [ServiceFilter(typeof(UnitOfWorkAttribute))]
           public async Task&amp;lt;AjaxResult&amp;gt; Update(SettingInputDto dto)
           {
               Check.NotNull(dto, nameof(dto));
    
               Type type = Type.GetType(dto.SettingTypeName);
               if (type == null)
               {
                   return new AjaxResult($&quot;设置类型\&quot;{dto.SettingTypeName}\&quot;无法找到&quot;);
               }
               ISetting setting = JsonConvert.DeserializeObject(dto.SettingJson, type) as ISetting;
               OperationResult result = await _keyValueStore.SaveSetting(setting);
               if (result.Succeeded)
               {
                   return new AjaxResult(&quot;设置保存成功&quot;);
               }
               return result.ToAjaxResult();
           }
       }

   }
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 29 Apr 2019 06:28:00 +0000</pubDate>
<dc:creator>willtoto</dc:creator>
<og:description>OsharpNS轻量级.net core快速开发框架简明入门教程 教程目录 1. 从零开始启动Osharp 1.1. '使用OsharpNS项目模板创建项目' 1.2. '配置数据库连接串并启动项目'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/candoo/p/10790121.html</dc:identifier>
</item>
<item>
<title>谈谈网络分层和IP - 农码关山北</title>
<link>http://www.cnblogs.com/dslx/p/10753382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dslx/p/10753382.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;在计算机网络这门课中，往往是将各层协议拆开一章一章的讲，每层协议是干嘛的，都各种怎么工作的。但如果有人问，这些协议之间怎么协调工作，有什么关系，往往处于懵逼状态。&lt;/p&gt;
&lt;h3&gt;网络分层&lt;/h3&gt;
&lt;p&gt;网络为什么分层，其实理解很简单，&lt;strong&gt;复杂的东西都要分层&lt;/strong&gt;。就像写代码，有Controller层，service层，dao层等，如果这个代码很复杂，都写在一个类里里，不利于你后期维护（可能过两天你自己都看不懂了)，和同事之间的交流沟通也不方便。所以复杂的程序都要分层，这是基本的程序设计要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201904/1333075-20190422215941320-401340912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一次用户发起的请求，浏览器用http协议打包用户的请求，然后传给下一层，调用下一层函数，这个函数会在这个网络包里加上一个TCP头，记录下源端口号，目的端口号，然后在调用下一层的函数，这个函数会加一个IP的头，记录源IP地址和目标IP的地址，然后在调用下一次函数，这个函数又加了一个本机器的MAC地址和目标MAC地址。这个数据包完整后，就可以从网口发出去。&lt;/p&gt;
&lt;p&gt;网卡检测到这个网络包的目的地址是指向自己的，把这个数据包拿进来调用一段函数来处理这个网络包，把属于这层的东西剥离出去，然后调用另一层的一个函数（process_layer3())来处理这个网络包。这一层检测一下，目标IP是不是对上自己的IP，如果IP对不上，就转发出去，若是对上IP，取下属于这层的IP头，在调用下一层的函数来处理。那是调用TCP函数还是UDP的函数处理哪，这个就得看协议字段，我这次请求是TCP的，就调用TCP的函数取下TCP头，然后查看这是一个发起，还是应答，或者是一个正常数据包，如果是发起或者应答，还需要发送一个回复包，若是一个正常数据包，根据端口号就直接交给应用去处理，然后浏览器解析html，用户现实界面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络上跑的包，都是完整的，可以有下层没上层，绝对不可能有上层没下层。&lt;/strong&gt;这有点类似于俄罗斯套娃，一层连着一层，一开始是个很小的套娃，套一层又套一层，套完后就是一个完整的套娃。网络世界中也是一样的，http层数据包，在套上TCP层，在套上IP层，又套上MAC层，所有机制都得运行一遍才能成功从网口发出去。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;      不管学没学过计算机，一定都会听到的词===&amp;gt;&lt;strong&gt;IP。&lt;/strong&gt;有没有想过，MAC地址就可以标识电脑了，还要IP干嘛，我刚开始也模糊，后面才逐渐有点头绪（但现在也不知道理解是否全对，毕竟计算机网络小白）。MAC地址与设备是一 一对应在局域网内是唯一的，如果在局域网内，MAC地址直接通信是没有问题的，每次有消息的时候，各个主机都接收一下，对照下是不是自己的MAC地址，如果不是，就直接丢弃，对上就接收并处理。但是每次有消息都得接收和处理有点费事，于是出现了交换机，交换机记录所有与之连接的MAC地址并与端口一一对应，现在A主机发消息给B主机并带上B主机的MAC地址，现在先到交换机这里，交换机查下记录的MAC对照表，哦，原来你要找B主机，就按照这个端口发给B主机。为什么会有IP哪，以太网MAC地址就可以通信了，但后来有了互联网，兼容以前的模式才有了IP + MAC的通信模式，长春这边的局域网有台A主机要与北京的局域网一台B主机通信。长春的交换机记录了A主机的MAC地址，可能还记录了北京交换机的MAC地址，北京交换机记录了要通信的B主机MAC地址。现在A给交换机发消息，我要找B主机，很遗憾，交换机找不到B主机，因为不是一个局域网内，交换机没记录这个MAC地址，没法通信。&lt;/p&gt;
&lt;p&gt;     MAC地址是硬件提供商写在网卡中的，MAC地址是唯一，但没办法表示我在互联网的位置，除非维护一个超级大的MAC地址对应表，那寻址效率必定爆炸，而且获取MAC地址是ARP协议完成的，只用MAC地址通信广播风暴就是很难克服的问题，但IP地址解决了这个问题，IP地址是网络提供商给的，你在哪里整个网络都是知道的（类似于定位功能），找到你这个网络，在这个网络环境找到你的MAC就显得容易得多。但是IP地址不总是唯一的，可能我今天在长春这个网络环境，我下线了，我这个IP就会动态分配给别的设备，明天到了北京，又动态分了一个IP地址，然而我的MAC地址总是固定且唯一的，通过这个我网络IP地址和MAC地址就很容易找到我。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; ip addr&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201904/1333075-20190423224939981-1387699495.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;165&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看ip地址，192.168.181.110就是一个IP地址，总共有四个部分，每部分有8位，总共有32位，理论上可以有42.9亿个IP地址，然而这些显然不能满足日益增长的计算机IP需求，因为不够用，所以有了IPV6，也就是我们的  fe80::20c:29ff:feb6:4146/64，这个有128位，有生之年都不可能分配完，据说可以给地球的每粒沙子分配一个IP，就可以想象有多少IP地址了。IP地址是一个网卡在网络世界的通讯地址，也相当于现实世界的门牌号码，所以不能重复，它包括两个标识码（网络ID + 主机ID）。在同一个物理网络上的所有主机都使用同一个网络ID，网络上的主机（路由器，服务器等）有一个主机ID与其对应，早期IP地址为了便于寻址和层次化构造网络，把IP分为5种类型，即A,B,C,D,E类地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201904/1333075-20190428153154606-1375217041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　A类的地址，8位网络地址，和24位的主机地址组成。地址范围 1.0.0.0 -&amp;gt; 126.255.255.255，A类网络有127个，每个网络能容纳16777214的主机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;B类的地址，16位网络地址，和16位的主机地址组成，地址范围128.0.0.0 -&amp;gt; 191.255.255.255，B类网络有16382个，每个网络可以有六万多主机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;C类的地址，24位的网络地址，和8位的主机号，地址范围 192.0.0.0 -&amp;gt; 223.255.255.0，C类网络有209万个，每个网络只能有可怜的254个主机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;D类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;D类的地址，从图中就可以看到，不分网络地址和主机地址，被称为广播地址，供特殊协议向选定节点发送消息时用，第一个字节是固定的1110，地址范围 224.0.0.0 -&amp;gt;239.255.255.255&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;E类的地址，保留将来使用。240.0.0.0 -&amp;gt; 255.255.255.254&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特殊地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;大家在使用本地测试访问经常用到的 &lt;strong&gt;127.0.0.1&lt;/strong&gt; 表示主机本身,是一个回环测试地址。&lt;/p&gt;
&lt;p&gt;　　在阿里云服务器使用监听地址 0.0.0.0 会有这样的设置，他在IPV4表示的是无效的目标地址，但在服务器端上它表示本机上所有的IPV4网段都能访问该服务&lt;/p&gt;
&lt;p&gt;　　在A,B,C类地址中，各自保留一个区域作为私有地址&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;A类：10.0.0.0 -&amp;gt; 10.255.255.255&lt;/li&gt;
&lt;li&gt;B类：172.16.0.0 -&amp;gt; 172.31.255.255&lt;/li&gt;
&lt;li&gt;C类：192.168.0.0 -&amp;gt; 192.168.255.255&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;strong&gt;CIDR&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在一个网吧用C类的IP地址，恐怕地址都不够，但是若是用B类地址，又是一种浪费。于是出现一个折中的办法，那就是无类域间路由，简称CIDR。给某个网络分配3个C类地址，然后适当的方法分配地址，使得3个地址能够聚合成一个地址。如果没有CIDR技术，ISP（地址网络提供商）的路由表就会有三条路由条目，但如果有了CIDR技术，就可以把这三个网段 198.168.1.0    198.168.2.0  198.168.3.0 汇聚成一条路由 198.168.0.0/16,这样ISP的路由表就只记录了一条198.168.0.0/16这一条路由，减少了路由表的条目，但若是ISP连接了一个172.168.1.0的网段，这些网络路由就没办法汇聚。CIRD节省了存储空间加快了查询速度。所以，现在都是用CIDR表示，为此引入子网掩码的概念，就是说网络位的个数可以任意指定，同时也兼容早期IP划分的方法。它将某个IP地址划分成网络地址和主机地址两部分，子网掩码是一个32位地址，用于屏蔽IP地址的一部分，它不能单独存在，必须结合IP地址一起使用，198.168.0.0/16 这个16就是指网络位有多少，在二进制格式中的网络位全为1，然后将二进制格式的子网掩码和二进制的IP地址进行  ‘与’ 运算，就可以得出该IP的网络位。&lt;/p&gt;
&lt;p&gt;　　IP地址：192.168.181.111                                          二进制：11000000 10101000    10110101   01101110&lt;/p&gt;
&lt;p&gt;　　子网掩码：255.255.255.0　　　　　　　　　　　　　 二进制：11111111   11111111     11111111     00000000&lt;/p&gt;
&lt;p&gt;　　运算：　　　　　　　　　　　　　　　　　　　　　　&amp;amp;          11000000  10101000    10110101   00000000&lt;/p&gt;
&lt;p&gt;　　结果：192.168.181.0&lt;/p&gt;
&lt;p&gt;这就是网络号了&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;简单的总结合和回忆了对ip的理解，虽然是基础知识，但是lz真的是计算机网络小白，也不知道是否理解准确，有大神有这方面的知识储备，是否可留言讲解下IP。&lt;/p&gt;
&lt;p&gt;参考：https://www.jianshu.com/p/e7989a7a0e96&lt;/p&gt;

</description>
<pubDate>Mon, 29 Apr 2019 05:58:00 +0000</pubDate>
<dc:creator>农码关山北</dc:creator>
<og:description>概述 在计算机网络这门课中，往往是将各层协议拆开一章一章的讲，每层协议是干嘛的，都各种怎么工作的。但如果有人问，这些协议之间怎么协调工作，有什么关系，往往处于懵逼状态。 网络分层 网络为什么分层，其实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dslx/p/10753382.html</dc:identifier>
</item>
<item>
<title>谈谈 ANR 之 Service 超时 - DeepCoder</title>
<link>http://www.cnblogs.com/pepsimaxin/p/10789927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pepsimaxin/p/10789927.html</guid>
<description>&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;ActiveServices.java&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;services/core/java/com/android/server/am/ActiveServices.java&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;ActivityManagerService.java&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;services/core/java/com/android/server/am/ActivityManagerService.java&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;AppErrors.java&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;services/core/java/com/android/server/am/AppErrors.java&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h2 id=&quot;anr-是什么&quot;&gt;2.1 ANR 是什么？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ANR(Application Not Responding)&lt;/span&gt;&lt;/strong&gt;，应用程序无响应，简单一个定义，却涵盖了很多 Android 系统的设计思想。&lt;/p&gt;
&lt;p&gt;首先，&lt;span&gt;ANR 属于应用程序的范畴&lt;/span&gt;，这不同于 SNR(System Not Respoding)，SNR 反映的问题是系统进程(system_server)失去了响应能力，而 ANR 明确将问题圈定在应用程序。&lt;strong&gt;&lt;code&gt;SNR 由 Watchdog 机制保证，ANR 由消息处理机制保证&lt;/code&gt;&lt;/strong&gt;，Android 在系统层实现了一套精密的机制来发现 ANR，核心原理是 &lt;strong&gt;&lt;code&gt;消息调度&lt;/code&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;code&gt;超时处理&lt;/code&gt;&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;其次，ANR 机制 &lt;strong&gt;&lt;code&gt;主体实现在系统层&lt;/code&gt;&lt;/strong&gt;。所有与 ANR 相关的消息，都会经过系统进程(system_server)调度，然后派发到应用进程完成对消息的实际处理，同时，系统进程设计了不同的超时限制来跟踪消息的处理。一旦应用程序处理消息不当，超时限制就起作用了，它收集一些系统状态，例如：CPU/IO使用情况、进程函数调用栈，并且报告用户有进程 &lt;strong&gt;&lt;code&gt;无响应了（ANR 对话框）&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后，ANR 问题 &lt;strong&gt;&lt;code&gt;本质是一个性能问题&lt;/code&gt;&lt;/strong&gt;。ANR 机制实际上对应用程序主线程的限制，要求主线程在限定的时间内处理完一些最常见的操作(启动服务、处理广播、处理输入)，如果处理超时，则认为主线程已经失去了响应其他操作的能力。主线程中的 &lt;strong&gt;&lt;code&gt;耗时操作&lt;/code&gt;&lt;/strong&gt;，例如：密集CPU运算、大量IO、复杂界面布局等，都会降低应用程序的响应能力。&lt;/p&gt;
&lt;p&gt;最后，部分 ANR 问题是很难分析的，有时候由于系统底层的一些影响，导致消息调度失败，出现问题的场景又难以复现。这类 ANR 问题往往需要花费大量的时间去了解系统的一些行为，超出了 ANR 机制本身的范畴。&lt;/p&gt;
&lt;h2 id=&quot;anr-机制&quot;&gt;2.2 ANR 机制&lt;/h2&gt;
&lt;p&gt;分析一些初级的 ANR 问题，只需要简单理解最终输出的日志即可，但对于一些由系统问题(例如：CPU 负载过高、进程卡死)引发的 ANR，就需要对整个 ANR 机制有所了解，才能定位出问题的原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ANR 机制可以分为两部分：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      ✎  &lt;strong&gt;ANR的监测&lt;/strong&gt;：Android 对于不同的 ANR 类型(Broadcast，Service，InputEvent)都有一套监测机制。&lt;/p&gt;
&lt;p&gt;      ✎  &lt;strong&gt;ANR的报告&lt;/strong&gt;：在监测到 ANR 以后，需要显示 ANR 对话框、输出日志(发生 ANR 时的进程函数调用栈、CPU 使用情况等)。&lt;/p&gt;
&lt;h2 id=&quot;anr-的触发原因&quot;&gt;2.3 ANR 的触发原因&lt;/h2&gt;
&lt;p&gt;前面我们说过，出现 ANR 之后一个直观现象就是系统会展示出一个 ANR 对话框。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;谷歌文档中对 ANR 产生的原因是这么描述的：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Android 系统中的应用被 &lt;code&gt;ActivityManagerService&lt;/code&gt; 及 &lt;code&gt;WindowManagerService&lt;/code&gt; 两个系统服务监控着，系统会在如下两种情况展示出 ANR 的对话框！&lt;/p&gt;
&lt;p&gt;      ✎  &lt;span&gt;KeyDispatchTimeout&lt;/span&gt; ( &lt;span&gt;5 seconds&lt;/span&gt; ) ：按键或触摸事件在特定时间内无响应。&lt;br/&gt;      ✎  &lt;span&gt;BroadcastTimeout&lt;/span&gt; ( &lt;span&gt;10 seconds&lt;/span&gt; )：BroadcastReceiver 在特定时间内无法处理完成。&lt;br/&gt;      ✎  &lt;span&gt;ServiceTimeout&lt;/span&gt; ( &lt;span&gt;20 seconds&lt;/span&gt; ) ：Service 在特定的时间内无法处理完成。&lt;/p&gt;


&lt;p&gt;Service 运行在应用程序的主线程，如果 Service 的执行时间超过 20 秒，则会引发 ANR。&lt;/p&gt;
&lt;p&gt;当发生 Service ANR 时，一般可以先排查一下在 Service 的生命周期函数中有没有做 &lt;strong&gt;&lt;code&gt;耗时的操作&lt;/code&gt;&lt;/strong&gt;，例如复杂的运算、IO 操作等。如果应用程序的代码逻辑查不出问题，就需要深入检查当前系统的状态：CPU 的使用情况、系统服务的状态等，判断当时发生 ANR 进程是否受到 &lt;strong&gt;&lt;code&gt;系统运行异常&lt;/code&gt;&lt;/strong&gt; 的影响。&lt;/p&gt;
&lt;p&gt;那么，系统是如何检测 Service 超时的呢？&lt;strong&gt;&lt;span&gt;Android 是通过设置定时消息实现的&lt;/span&gt;&lt;/strong&gt;。定时消息是由 AMS 的消息队列处理的，AMS 有 Service 运行的上下文信息，所以在 AMS 中设置一套超时检测机制也是合情合理的。&lt;/p&gt;
&lt;p&gt;Service ANR 机制相对最为简单，主体实现在&lt;code&gt;ActiveServices&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;在 Service 的启动流程中，Service 进程 attach 到 system_server 进程后会调用 &lt;code&gt;realStartServiceLocked()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h2 id=&quot;realstartservicelocked&quot;&gt;3.1 realStartServiceLocked&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java

public final class ActiveServices {

    private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app, boolean execInFg) throws RemoteException {

        // 发送 delay 消息（SERVICE_TIMEOUT_MSG）
        bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);

        boolean created = false;
        try {
            
            // 最终执行服务的 onCreate() 方法
            app.thread.scheduleCreateService(r, r.serviceInfo, mAm.
                compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                app.repProcState);

            ... ...
        }
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bumpserviceexecutinglocked&quot;&gt;3.2 bumpServiceExecutingLocked&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final void bumpServiceExecutingLocked(...) {

    scheduleServiceTimeoutLocked(r.app);
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;scheduleservicetimeoutlocked&quot;&gt;3.3 scheduleServiceTimeoutLocked&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void scheduleServiceTimeoutLocked(ProcessRecord proc) {
    if (proc.executingServices.size() == 0 || proc.thread == null) {
        return;
    }
    Message msg = mAm.mHandler.obtainMessage(
            ActivityManagerService.SERVICE_TIMEOUT_MSG);
    msg.obj = proc;
    // 当超时后仍没有 remove 该 SERVICE_TIMEOUT_MSG 消息，
    // 通过 AMS.MainHandler 抛出一个定时消息。
    mAm.mHandler.sendMessageDelayed(msg,
            proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述方法通过 &lt;code&gt;AMS.MainHandler&lt;/code&gt; 抛出一个定时消息 &lt;code&gt;SERVICE_TIMEOUT_MSG&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;servicedoneexecutinglocked&quot;&gt;3.4 serviceDoneExecutingLocked&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;前台进程中执行 Service，超时时间是 SERVICE_TIMEOUT（20 秒）&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // How long we wait for a service to finish executing.
    static final int SERVICE_TIMEOUT = 20*1000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;后台进程中执行 Service，超时时间是 SERVICE_BACKGROUND_TIMEOUT（200 秒）&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // How long we wait for a service to finish executing.
    static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 Service 的生命周期结束时（不会 ANR），会调用 &lt;code&gt;serviceDoneExecutingLocked()&lt;/code&gt; 方法，之前抛出的 &lt;code&gt;SERVICE_TIMEOUT_MSG&lt;/code&gt; 消息在这个方法中会被清除。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) {
    boolean inDestroying = mDestroyingServices.contains(r);
    if (r != null) {
        ... ...     
        serviceDoneExecutingLocked(r, inDestroying, inDestroying);
    }
}

private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying,
          boolean finishing) {  
    ... ...
    if (r.executeNesting &amp;lt;= 0) {
        if (r.app != null) {    
            ... ...
            // 当前服务所在进程中没有正在执行的service，清除 SERVICE_TIMEOUT_MSG 消息
            if (r.app.executingServices.size() == 0) {
                mAm.mHandler.removeMessages(
                             ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);            
                ... ...
            }
    ... ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;handlemessage&quot;&gt;3.5 handleMessage&lt;/h2&gt;
&lt;p&gt;如果没有 Remove 掉 SERVICE_TIMEOUT_MSG 呢？接下来我们看看对于 ANR 的处理逻辑。&lt;/p&gt;
&lt;p&gt;在 system_server 进程中有一个 Handler 线程，名叫 &lt;code&gt;ActivityManager&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果在超时时间内，&lt;code&gt;SERVICE_TIMEOUT_MSG&lt;/code&gt; 没有被清除，便会向该 &lt;code&gt;Handler&lt;/code&gt; 线程发送一条信息 &lt;code&gt;SERVICE_TIMEOUT_MSG&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final class MainHandler extends Handler {
    ... ...

    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            ... ...
            
            case SERVICE_TIMEOUT_MSG: {
                mServices.serviceTimeout((ProcessRecord)msg.obj);
            } break;
        ... ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;servicetimeout&quot;&gt;3.6 serviceTimeout&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void serviceTimeout(ProcessRecord proc) {
    String anrMessage = null;

    synchronized(mAm) {
        ... ...
        
        long nextTime = 0;

        // 寻找运行超时的 Service
        for (int i = proc.executingServices.size() - 1; i &amp;gt;= 0; i--) {
            ServiceRecord sr = proc.executingServices.valueAt(i);
            if (sr.executingStart &amp;lt; maxTime) {
                timeout = sr;
                break;
            }
            if (sr.executingStart &amp;gt; nextTime) {
                nextTime = sr.executingStart;
            }
        }

        // 判断执行 Service 超时的进程是否在最近运行进程列表，如果不在，则忽略这个 ANR
        if (timeout != null &amp;amp;&amp;amp; mAm.mLruProcesses.contains(proc)) {
            Slog.w(TAG, &quot;Timeout executing service: &quot; + timeout);
            StringWriter sw = new StringWriter();
            PrintWriter pw = new FastPrintWriter(sw, false, 1024);
            pw.println(timeout);
            timeout.dump(pw, &quot;    &quot;);
            pw.close();
            mLastAnrDump = sw.toString();
            mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);
            mAm.mHandler.postDelayed(mLastAnrDumpClearer, 
                                           LAST_ANR_LIFETIME_DURATION_MSECS);
            anrMessage = &quot;executing service &quot; + timeout.shortName;
        ... ...
    }

    if (anrMessage != null) {
        // 当存在 timeout 的 service，则执行 appNotResponding
        mAm.mAppErrors.appNotResponding(proc, null, null, false, anrMessage);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述方法会找到当前进程已经超时的 Service，经过一些判定后，决定要报告 ANR，最终调用 &lt;code&gt;AMS.appNotResponding()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;走到这一步，ANR 机制已经完成了监测报告任务，剩下的任务就是 ANR 结果的输出，我们称之为 ANR 的报告机制。ANR 的报告机制是通过 &lt;code&gt;AMS.appNotResponding()&lt;/code&gt; 完成的，Broadcast 和 InputEvent 类型的 ANR 最终也都会调用这个方法。&lt;/p&gt;


&lt;p&gt;接下来我们看看 Android ANR 的信息收集过程！&lt;/p&gt;
&lt;h2 id=&quot;appnotresponding&quot;&gt;4.1 appNotResponding&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// frameworks/base/services/core/java/com/android/server/am/AppErrors.java

class AppErrors {

    final void appNotResponding(ProcessRecord app, ActivityRecord activity,
            ActivityRecord parent, boolean aboveSystem, final String annotation) {
        ... ...

        long anrTime = SystemClock.uptimeMillis();
        if (ActivityManagerService.MONITOR_CPU_USAGE) {
            mService.updateCpuStatsNow();   // 更新 cpu 统计信息
        }

        boolean showBackground = Settings.Secure.
                getInt(mContext.getContentResolver(),
                           Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;

        boolean isSilentANR;

        synchronized (mService) {
            if (mService.mShuttingDown) {
                return;
            } else if (app.notResponding) {
                return;
            } else if (app.crashing) {
                return;
            } else if (app.killedByAm) {
                return;
            } else if (app.killed) {
                return;
            }

            // In case we come through here for the same app before completing
            // this one, mark as anring now so we will bail out.
            app.notResponding = true;

            // 记录 ANR 到 EventLog
            EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid,
                    app.processName, app.info.flags, annotation);

            // 将当前进程添加到 firstPids
            firstPids.add(app.pid);

            // Don't dump other PIDs if it's a background ANR
            isSilentANR = !showBackground 
                                  &amp;amp;&amp;amp; !isInterestingForBackgroundTraces(app);
            if (!isSilentANR) {
                int parentPid = app.pid;
                if (parent != null &amp;amp;&amp;amp; parent.app != null &amp;amp;&amp;amp; parent.app.pid &amp;gt; 0) {
                    parentPid = parent.app.pid;
                }
                if (parentPid != app.pid) firstPids.add(parentPid);

                // 将 system_server 进程添加到 firstPids
                if (MY_PID != app.pid 
                                &amp;amp;&amp;amp; MY_PID != parentPid) firstPids.add(MY_PID);

                for (int i = mService.mLruProcesses.size() - 1; i &amp;gt;= 0; i--) {
                    ProcessRecord r = mService.mLruProcesses.get(i);
                    if (r != null &amp;amp;&amp;amp; r.thread != null) {
                        int pid = r.pid;
                        if (pid &amp;gt; 0 &amp;amp;&amp;amp; pid != app.pid 
                                       &amp;amp;&amp;amp; pid != parentPid &amp;amp;&amp;amp; pid != MY_PID) {
                            if (r.persistent) {
                                // 将 persistent 进程添加到 firstPids
                                firstPids.add(pid);
                            } else if (r.treatLikeActivity) {
                                firstPids.add(pid);
                            } else {
                                // 其他进程添加到 lastPids
                                lastPids.put(pid, Boolean.TRUE);
                            }
                        }
                    }
                }
            }
        }

        // 记录 ANR 输出到 main log
        StringBuilder info = new StringBuilder();
        info.setLength(0);
        info.append(&quot;ANR in &quot;).append(app.processName);
        if (activity != null &amp;amp;&amp;amp; activity.shortComponentName != null) {
            info.append(&quot; (&quot;).append(activity.shortComponentName).append(&quot;)&quot;);
        }
        info.append(&quot;\n&quot;);
        info.append(&quot;PID: &quot;).append(app.pid).append(&quot;\n&quot;);
        if (annotation != null) {
            info.append(&quot;Reason: &quot;).append(annotation).append(&quot;\n&quot;);
        }
        if (parent != null &amp;amp;&amp;amp; parent != activity) {
            info.append(&quot;Parent: &quot;).append(parent.shortComponentName).append(&quot;\n&quot;);
        }

        // 创建 CPU tracker 对象 
        ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(true);

        ... ...

        // 输出 traces 信息
        File tracesFile = ActivityManagerService.dumpStackTraces(
                true, firstPids,
                (isSilentANR) ? null : processCpuTracker,
                (isSilentANR) ? null : lastPids,
                nativePids);

        String cpuInfo = null;
        if (ActivityManagerService.MONITOR_CPU_USAGE) {
            mService.updateCpuStatsNow();
            synchronized (mService.mProcessCpuTracker) {
                cpuInfo = mService.mProcessCpuTracker.printCurrentState(anrTime);
            }
            // 记录当前 CPU 负载情况
            info.append(processCpuTracker.printCurrentLoad());
            info.append(cpuInfo);
        }

        // 记录从 anr 时间开始的 Cpu 使用情况
        info.append(processCpuTracker.printCurrentState(anrTime));

        // 输出当前 ANR 的 reason，以及 CPU 使用率、负载信息
        Slog.e(TAG, info.toString());
        if (tracesFile == null) {
            Process.sendSignal(app.pid, Process.SIGNAL_QUIT);
        }
        ... ...
                        
        // 将 traces 文件和 CPU 使用率信息保存到 dropbox，即 data/system/dropbox 目录
        mService.addErrorToDropBox(&quot;anr&quot;, app, app.processName,
                          activity, parent, annotation, cpuInfo, tracesFile, null);
        ... ...

        synchronized (mService) {
            mService.mBatteryStatsService.noteProcessAnr(app.processName, app.uid);

            // 后台 ANR 的情况, 直接杀掉
            if (isSilentANR) {
                app.kill(&quot;bg anr&quot;, true);
                return;
            }

            // 设置 app 的 ANR 状态，病查询错误报告 receiver
            makeAppNotRespondingLocked(app,
                    activity != null ? activity.shortComponentName : null,
                    annotation != null ? &quot;ANR &quot; + annotation : &quot;ANR&quot;,
                    info.toString());

            // 弹出 ANR 对话框
            Message msg = Message.obtain();
            msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;
            msg.obj = new AppNotRespondingDialog.Data(app, activity, aboveSystem);

            // 向 ui 线程发送，内容为 SHOW_NOT_RESPONDING_MSG 的消息
            mService.mUiHandler.sendMessage(msg);
        }
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当发生 ANR 时, 会按顺序依次执行：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       ✒ 1、输出 &lt;code&gt;ANR Reason&lt;/code&gt; 信息到 &lt;code&gt;EventLog&lt;/code&gt;，也就是说 ANR 触发的时间点最接近的就是 &lt;code&gt;EventLog&lt;/code&gt; 中输出的 &lt;code&gt;am_anr&lt;/code&gt; 信息;&lt;br/&gt;       ✒ 2、收集并输出重要进程列表中的各个线程的 &lt;code&gt;traces&lt;/code&gt; 信息，该方法较耗时；&lt;br/&gt;       ✒ 3、输出当前各个进程的 &lt;code&gt;CPU 使用情况&lt;/code&gt;以及 &lt;code&gt;CPU 负载情况&lt;/code&gt;；&lt;br/&gt;       ✒ 4、将 &lt;code&gt;traces 文件&lt;/code&gt;和 &lt;code&gt;CPU 使用情况信息&lt;/code&gt;保存到 &lt;code&gt;dropbox&lt;/code&gt;，即 &lt;code&gt;data/system/dropbox&lt;/code&gt; 目录；&lt;br/&gt;       ✒ 5、根据进程类型，来决定&lt;code&gt;直接后台杀掉&lt;/code&gt;，还是&lt;code&gt;弹框告知用户&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ANR输出重要进程的traces信息，这些进程包含：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       ✒ 1、&lt;strong&gt;firstPids 队列&lt;/strong&gt;：第一个是 &lt;code&gt;ANR&lt;/code&gt; 进程，第二个是 &lt;code&gt;system_server&lt;/code&gt;，剩余是所有 &lt;code&gt;persistent&lt;/code&gt; 进程；&lt;br/&gt;       ✒ 2、&lt;strong&gt;Native 队列&lt;/strong&gt;：是指 &lt;code&gt;/system/bin/&lt;/code&gt; 目录的 &lt;code&gt;mediaserver&lt;/code&gt;、&lt;code&gt;sdcard&lt;/code&gt; 以及 &lt;code&gt;surfaceflinger&lt;/code&gt; 进程；&lt;br/&gt;       ✒ 3、&lt;strong&gt;lastPids 队列&lt;/strong&gt;: 是指 &lt;code&gt;mLruProcesses&lt;/code&gt; 中的&lt;code&gt;不属于 firstPids&lt;/code&gt; 的所有进程。&lt;/p&gt;
&lt;h2 id=&quot;dumpstacktraces&quot;&gt;4.2 dumpStackTraces&lt;/h2&gt;
&lt;p&gt;继续看看 dump 出 trace 信息的流程：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// ActivityManagerService.java

    public static File dumpStackTraces(boolean clearTraces, ... ,nativePids) {
        ... ...

        if (tracesDirProp.isEmpty()) {
            // 默认为 data/anr/traces.txt
            String globalTracesPath = 
                          SystemProperties.get(&quot;dalvik.vm.stack-trace-file&quot;, null);

            tracesFile = new File(globalTracesPath);
            try {
                if (clearTraces &amp;amp;&amp;amp; tracesFile.exists()) {
                    tracesFile.delete();      // 删除已存在的 traces 文件
                }

                // 这里会保证 data/anr/traces.txt 文件内容是全新的方式，而非追加
                tracesFile.createNewFile();   // 创建 traces 文件
                FileUtils.setPermissions(globalTracesPath, 0666, -1, -1);
            } catch (IOException e) {
                Slog.w(TAG, &quot;Unable to prepare ANR traces file: &quot; + tracesFile, e);
                return null;
            }
        } else {
        }

        // 输出 trace 内容
        dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, nativePids,
                                         extraPids, useTombstonedForJavaTraces);
        return tracesFile;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dumpstacktraces-1&quot;&gt;4.3 dumpStackTraces&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// ActivityManagerService.java

    private static void dumpStackTraces(String tracesFile, ...) {

        final DumpStackFileObserver observer;
        if (useTombstonedForJavaTraces) {
            observer = null;
        } else {
            observer = new DumpStackFileObserver(tracesFile);
        }

        // We must complete all stack dumps within 20 seconds.
        long remainingTime = 20 * 1000;
        try {
            if (observer != null) {
                observer.startWatching();
            }

            // 首先，获取 firstPids 进程的 stacks
            if (firstPids != null) {
                int num = firstPids.size();
                for (int i = 0; i &amp;lt; num; i++) {
                    final long timeTaken;
                    if (useTombstonedForJavaTraces) {
                        timeTaken = dumpJavaTracesTombstoned(firstPids.get(i),
                                                   tracesFile, remainingTime);
                    } else {
                        timeTaken = observer.dumpWithTimeout(firstPids.get(i),
                                                               remainingTime);
                    }
                    ... ... 
                }
            }

            // 下一步，获取 native 进程的 stacks
            if (nativePids != null) {
                for (int pid : nativePids) {
                    ... ...
                    
                    // 输出 native 进程的 trace
                    Debug.dumpNativeBacktraceToFileTimeout(
                            pid, tracesFile, (int) (nativeDumpTimeoutMs / 1000));
                            
                    final long timeTaken = SystemClock.elapsedRealtime() - start;
                    ... ...
                }
            }

            // Lastly, dump stacks for all extra PIDs from the CPU tracker.
            if (extraPids != null) {
                ... ...
                }
            }
        } finally {
            if (observer != null) {
                observer.stopWatching();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;4.4 小结&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;触发 ANR 时系统会输出关键信息：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       ✒ 1、将 &lt;code&gt;am_anr&lt;/code&gt; 信息，输出到 &lt;code&gt;EventLog&lt;/code&gt;；&lt;br/&gt;       ✒ 2、获取重要进程 &lt;code&gt;trace&lt;/code&gt; 信息，保存到 &lt;code&gt;/data/anr/traces.txt&lt;/code&gt;；&lt;br/&gt;       ✒ 3、&lt;code&gt;ANR reason&lt;/code&gt; 以及 &lt;code&gt;CPU&lt;/code&gt; 使用情况信息，输出到 &lt;code&gt;main log&lt;/code&gt;;&lt;br/&gt;       ✒ 4、再将 &lt;code&gt;CPU使用情况&lt;/code&gt; 和进程 &lt;code&gt;trace 文件&lt;/code&gt;信息，再保存到 &lt;code&gt;/data/system/dropbox&lt;/code&gt;。&lt;/p&gt;


&lt;p&gt;当 Service 出现 ANR 时，最终调用到 &lt;code&gt;AMS.appNotResponding()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;       ✒ 1、对于&lt;code&gt;前台服务&lt;/code&gt;，则超时为 &lt;code&gt;SERVICE_TIMEOUT = 20s&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;       ✒ 2、对于&lt;code&gt;后台服务&lt;/code&gt;，则超时为 &lt;code&gt;SERVICE_BACKGROUND_TIMEOUT = 200s&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;       ✒ 3、Service 超时检测机制：&lt;code&gt;超过一定时间没有执行完相应操作&lt;/code&gt;来触发&lt;code&gt;延时消息&lt;/code&gt;，则会触发 &lt;code&gt;ANR&lt;/code&gt;;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 05:45:00 +0000</pubDate>
<dc:creator>DeepCoder</dc:creator>
<og:description>不管是系统开发还是应用开发，ANR 一直是挥之不去的存在！本文从 ANR 的触发机制以及一个简单的范例来探讨 ANR 的原理和处理方法！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pepsimaxin/p/10789927.html</dc:identifier>
</item>
<item>
<title>基于Mycat实现读写分离 - 架构与我</title>
<link>http://www.cnblogs.com/atcloud/p/10789850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atcloud/p/10789850.html</guid>
<description>&lt;p&gt;随着应用的访问量并发量的增加，应用读写分离是很有必要的。当然应用要实现读写分离，首先数据库层要先做到主从配置，本人前一篇文章介绍了mysql数据库的主从配置方式即：&lt;a href=&quot;https://www.toutiao.com/i6680489302947791371/&quot;&gt;《mysql数据库主从配置》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;应用实现读写分离至少有两种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用本身通过代码实现，例如基于动态数据源、AOP的原理来实现写操作时用主数据库，读操作时用从数据库。&lt;/li&gt;
&lt;li&gt;通过中间件的方式实现，例如通过Mycat，即中间件会分析对应的SQL，写操作时会连接主数据库，读操作时连接从数据库。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本篇文章是介绍通过Mycat中间件的方式实现读写分离。&lt;/p&gt;
&lt;h2 id=&quot;mycat&quot;&gt;1、Mycat&lt;/h2&gt;
&lt;p&gt;Mycat是一款开源的数据库中间件，其官网为&lt;a href=&quot;http://www.mycat.io/&quot; class=&quot;uri&quot;&gt;http://www.mycat.io/&lt;/a&gt;，其中官方对它介绍为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Mycat 是一个强大的数据库中间件，不仅仅可以用作读写分离、以及分表分库、容灾备份，而且可以用于多租户应用开发、云平台基础设施、让你的架构具备很强的适应性和灵活性，借助于即将发布的Mycat 智能优化模块，系统的数据访问瓶颈和热点一目了然，根据这些统计分析数据，你可以自动或手工调整后端存储，将不同的表映射到不同存储引擎上，而整个应用的代码一行也不用改变。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Mycat的实现原理为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Mycat 的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的SQL 语句，首先对SQL 语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL 发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于Mycat更多的介绍大家可以查看官网。&lt;/p&gt;
&lt;h2 id=&quot;部署mycat&quot;&gt;2、部署Mycat&lt;/h2&gt;
&lt;p&gt;应用是直接连接Mycat，然后Mycat管理了1个主数据库和1个从数据库，架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190429132621211-438885332.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中每个组件对应服务器地址为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mycat：192.168.197.131&lt;/li&gt;
&lt;li&gt;主库：192.168.197.135&lt;/li&gt;
&lt;li&gt;从库：192.168.197.136&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;对于mysql的主从配置方式请参考&lt;a href=&quot;https://www.toutiao.com/i6680489302947791371/&quot;&gt;《mysql数据库主从配置》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;部署Mycat步骤为：&lt;/p&gt;
&lt;p&gt;（1）、安装JDK，由于Mycat是基于Java语言来编写的，所以需要安装JDK，版本为1.8即可。&lt;/p&gt;
&lt;p&gt;JDK安装包可以到官网下载，下载后解压，然后配置环境变量，即：&lt;/p&gt;
&lt;p&gt;在/etc/profile文件中加入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_HOME=/opt/jdk1.8.0_112
export PATH=$JAVA_HOME/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）、下载Mycat安装包，版本为1.6-RELEASE，下载地址为&lt;a href=&quot;http://dl.mycat.io/1.6-RELEASE/&quot; class=&quot;uri&quot;&gt;http://dl.mycat.io/1.6-RELEASE/&lt;/a&gt;，选择linux环境的版本即可。&lt;/p&gt;
&lt;p&gt;（3）、将Mycat安装包上传服务器后解压，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上3步就相当于将Mycat部署好了，现在就需要配置Mycat了。&lt;/p&gt;
&lt;p&gt;配置Mycat步骤为：&lt;/p&gt;
&lt;p&gt;（1）、在主库和从库中分别创建用于Mycat连接的账号，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GRANT CREATE,DELETE,INSERT,SELECT,UPDATE ON jgyw.* TO 'jgywuser'@'192.168.197.131' IDENTIFIED BY 'jgyw@123';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上语句的意思是创建一个jgywuser用户，该用户只有对jgyw模式下的表有增删改查的权限。&lt;/p&gt;
&lt;p&gt;（2）、配置Mycat的schema.xml文件，该文件位于Mycat中conf文件夹下，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&amp;gt;
    &amp;lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;jgywnode&quot;&amp;gt;
    &amp;lt;/schema&amp;gt;

    &amp;lt;dataNode name=&quot;jgywnode&quot; dataHost=&quot;jgywhost&quot; database=&quot;jgyw&quot; /&amp;gt;

    &amp;lt;dataHost name=&quot;jgywhost&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;3&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&amp;gt;

        &amp;lt;heartbeat&amp;gt;select user()&amp;lt;/heartbeat&amp;gt;
        
        &amp;lt;writeHost host=&quot;master&quot; url=&quot;192.168.197.135:3306&quot; user=&quot;jgywuser&quot; password=&quot;jgyw@123&quot;&amp;gt;
            &amp;lt;readHost host=&quot;slave&quot; url=&quot;192.168.197.136:3306&quot; user=&quot;jgywuser&quot; password=&quot;jgyw@123&quot;/&amp;gt;
        &amp;lt;/writeHost&amp;gt;
   &amp;lt;/dataHost&amp;gt;
&amp;lt;/mycat:schema&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;schema 标签用于定义MyCat 实例中的逻辑库，MyCat 可以有多个逻辑库，每个逻辑库都有自己的相关配置。可以使用schema 标签来划分这些不同的逻辑库。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;dataNode 标签定义了MyCat 中的数据节点，也就是我们通常说所的数据分片。一个dataNode 标签就是一个独立的数据分片。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;dataHost标签直接定义了具体的数据库实例、读写分离配置和心跳语句。其中有几个重要的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;balance属性
负载均衡类型，目前的取值有3 种：
balance=&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的writeHost 上。
balance=&quot;1&quot;，全部的readHost 与stand by writeHost 参与select 语句的负载均衡，简单的说，当双主双从模式(M1-&amp;gt;S1，M2-&amp;gt;S2，并且M1 与M2 互为主备)，正常情况下，M2,S1,S2 都参与select 语句的负载均衡。
balance=&quot;2&quot;，所有读操作都随机的在writeHost、readhost 上分发。
balance=&quot;3&quot;，所有读请求随机的分发到wiriterHost 对应的readhost 执行，writerHost 不负担读压
力，注意balance=3 只在1.4 及其以后版本有，1.3 没有。

writeType 属性
负载均衡类型，目前的取值有3 种：
writeType=&quot;0&quot;, 所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个
writeHost，重新启动后已切换后的为准，切换记录在配置文件中:dnindex.properties .
writeType=&quot;1&quot;，所有写操作都随机的发送到配置的writeHost，1.5 以后废弃不推荐。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（3）、配置server.xml，即主要配置连接Mycat的用户账号信息，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;user name=&quot;jgyw&quot;&amp;gt;
    &amp;lt;property name=&quot;password&quot;&amp;gt;jgyw&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;schemas&quot;&amp;gt;TESTDB&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;readOnly&quot;&amp;gt;false&amp;lt;/property&amp;gt;
&amp;lt;/user&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即配置一个用户名为jgyw，密码为jgyw的用户，同时具有TESTDB模式下的读写权限，注意该模式即是在schema.xml配置文件定义的模式名一样。&lt;/p&gt;
&lt;p&gt;（4）、启动Mycat，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./mycat start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Mycat启动成功后，会开放两个端口，即数据端口8066，管理端口9066&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;3、测试&lt;/h2&gt;
&lt;p&gt;首先在主库的jgyw模式下创建一个comm_config表，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE comm_config (configId varchar(200) NOT NULL ,configValue varchar(1024) DEFAULT NULL ,description varchar(2000) DEFAULT NULL ,PRIMARY KEY (configId)) ENGINE=InnoDB DEFAULT CHARSET=utf8 ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用的数据库连接配置信息为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
  datasource: 
    url: jdbc:mysql://192.168.197.131:8066/TESTDB
    username: jgyw
    password: jgyw
    driver-class-name: com.mysql.jdbc.Driver&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用的是8066端口，同时用户也是server.xml配置文件中配置的用户。&lt;/p&gt;
&lt;p&gt;测试的数据接口，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.swnote.common.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import com.swnote.common.domain.Config;
import com.swnote.common.service.IConfigService;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
public class ConfigController {

    @Autowired
    private IConfigService configService;

    @RequestMapping(value = &quot;/config/save&quot;, method = RequestMethod.POST)
    public Config save(@RequestBody Config config) throws Exception {
        try {
            configService.save(config);
            return config;
        } catch (Exception e) {
            log.error(&quot;新增配置信息错误&quot;, e);
            throw e;
        }
    }

    @RequestMapping(value = &quot;/config/list&quot;, method = RequestMethod.GET)
    public List&amp;lt;Config&amp;gt; list() throws Exception {
        try {
            return configService.list();
        } catch (Exception e) {
            log.error(&quot;查询配置信息错误&quot;, e);
            throw e;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入Mycat的管理端，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -h127.0.0.1 -ujgyw -pjgyw -P9066&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;show @@datasource;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以查到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+----------+--------+-------+-----------------+------+------+--------+------+------+---------+-----------+------------+
| DATANODE | NAME   | TYPE  | HOST            | PORT | W/R  | ACTIVE | IDLE | SIZE | EXECUTE | READ_LOAD | WRITE_LOAD |
+----------+--------+-------+-----------------+------+------+--------+------+------+---------+-----------+------------+
| jgywnode | master | mysql | 192.168.197.135 | 3306 | W    |      0 |   10 | 1000 |    8959 |         0 |         42 |
| jgywnode | slave  | mysql | 192.168.197.136 | 3306 | R    |      0 |   10 | 1000 |    8937 |        22 |          0 |
+----------+--------+-------+-----------------+------+------+--------+------+------+---------+-----------+------------+
2 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当调用读接口时READ_LOAD的值对应在slave上会加1说明是走从库；&lt;/p&gt;
&lt;p&gt;当调用写接口时WRITE_LOAD的值对就在master上会加1说明是走主库。&lt;/p&gt;
&lt;h2 id=&quot;关注我&quot;&gt;关注我&lt;/h2&gt;
&lt;p&gt;以你最方便的方式关注我：&lt;br/&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190429132559421-1751267668.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 05:27:00 +0000</pubDate>
<dc:creator>架构与我</dc:creator>
<og:description>随着应用的访问量并发量的增加，应用读写分离是很有必要的。当然应用要实现读写分离，首先数据库层要先做到主从配置，本人前一篇文章介绍了mysql数据库的主从配置方式即： '《mysql数据库主从配置》'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atcloud/p/10789850.html</dc:identifier>
</item>
<item>
<title>如何优雅地在 Spring Boot 中使用自定义注解，AOP 切面统一打印出入参日志 | 修订版 - 犬小哈</title>
<link>http://www.cnblogs.com/quanxiaoha/p/10789843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanxiaoha/p/10789843.html</guid>
<description>&lt;blockquote readability=&quot;6.5106382978723&quot;&gt;
&lt;p&gt;欢迎关注个人微信公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 文末分享阿里 P8 资深架构师总结的 《Java 核心知识整理&amp;amp;面试.pdf》资源链接！！&lt;/p&gt;
&lt;p&gt;个人网站: &lt;a href=&quot;https://www.exception.site/springboot/spring-boot-aop-web-request&quot; class=&quot;uri&quot;&gt;https://www.exception.site/springboot/spring-boot-aop-web-request&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155646129129792&quot; title=&quot;Spring Boot 自定义注解，AOP 切面统一打印出入参日志&quot; alt=&quot;Spring Boot 自定义注解，AOP 切面统一打印出入参日志&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实，小哈在之前就出过一篇关于如何使用 AOP 切面统一打印请求日志的文章，那为什么还要再出一篇呢？没东西写了？&lt;/p&gt;
&lt;p&gt;哈哈，当然不是！原因是当时的实现方案还是存在缺陷的，原因如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;不够灵活&lt;/strong&gt;，由于是以所有 Controller 方法中的方法为切面，也就是说切死了，如果说我们不想让某个接口打印出入参日志，就办不到了；&lt;/li&gt;
&lt;li&gt;Controller &lt;strong&gt;包层级过深&lt;/strong&gt;时，&lt;strong&gt;导致很多包下的接口切不到&lt;/strong&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天主要说说如何通过自定义注解的方式，在 Spring Boot 中来实现 AOP 切面统一打印出入参日志。小伙伴们可以收藏一波。&lt;/p&gt;
&lt;p&gt;废话不多说，进入正题 ！&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;一、先看看切面日志输出效果&lt;/p&gt;
&lt;p&gt;二、添加 AOP Maven 依赖&lt;/p&gt;
&lt;p&gt;三、自定义日志注解&lt;/p&gt;
&lt;p&gt;四、配置 AOP 切面&lt;/p&gt;
&lt;p&gt;五、怎么使用呢？&lt;/p&gt;
&lt;p&gt;六、对于文件上传好使不？&lt;/p&gt;
&lt;p&gt;七、只想在开发环境和测试环境中使用？&lt;/p&gt;
&lt;p&gt;八、多切面如何指定优先级？&lt;/p&gt;
&lt;h2 id=&quot;一先看看切面日志输出效果&quot;&gt;一、先看看切面日志输出效果&lt;/h2&gt;
&lt;p&gt;在看看实现方法之前，我们先看下切面日志输出效果咋样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645508854810&quot; title=&quot;Spring boot 自定义注解，aop切面统一打印请求日志效果图&quot; alt=&quot;Spring boot 自定义注解，aop切面统一打印请求日志效果图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看到，每个对于每个请求，开始与结束一目了然，并且打印了以下参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;URL&lt;/strong&gt;: 请求接口地址；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Description&lt;/strong&gt;: 接口的中文说明信息；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP Method&lt;/strong&gt;: 请求的方法，是 &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, 还是 &lt;code&gt;DELETE&lt;/code&gt; 等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Class Method&lt;/strong&gt;: 被请求的方法路径 : &lt;strong&gt;包名 + 方法名&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IP&lt;/strong&gt;: 请求方的 IP 地址；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Request Args&lt;/strong&gt;: 请求入参，以 JSON 格式输出；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Response Args&lt;/strong&gt;: 响应出参，以 JSON 格式输出；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time-Consuming&lt;/strong&gt;: 请求耗时，以此估算每个接口的性能指数；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;怎么样？看上去效果还不错呢？接下来看看，我们要如何一步一步实现它呢？&lt;/p&gt;
&lt;h2 id=&quot;二添加-aop-maven-依赖&quot;&gt;二、添加 AOP Maven 依赖&lt;/h2&gt;
&lt;p&gt;在项目 &lt;code&gt;pom.xml&lt;/code&gt; 文件中添加依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- aop 依赖 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 用于日志切面中，以 json 格式打印出入参 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.8.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三自定义日志注解&quot;&gt;三、自定义日志注解&lt;/h2&gt;
&lt;p&gt;让我们来自定义一个日志注解，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645541894834&quot; title=&quot;自定义注解&quot; alt=&quot;自定义注解&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;①&lt;/strong&gt;：什么时候使用该注解，我们定义为运行时；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;②&lt;/strong&gt;：注解用于什么地方，我们定义为作用于方法上；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;③&lt;/strong&gt;：注解是否将包含在 JavaDoc 中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;④&lt;/strong&gt;：注解名为 &lt;code&gt;WebLog&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;⑤&lt;/strong&gt;：定义一个属性，默认为空字符串；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;源代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package site.exception.springbootaopwebrequest.aspect;

import java.lang.annotation.*;

/**
 * @author 犬小哈 （微信号：小哈学Java）
 * @site www.exception.site
 * @date 2019/2/12
 * @time 下午9:19
 * @discription
 **/
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Documented
public @interface WebLog {
    /**
     * 日志描述信息
     *
     * @return
     */
    String description() default &quot;&quot;;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，一个完整的自定义注解就定义完成了。&lt;/p&gt;
&lt;h2 id=&quot;四配置-aop-切面&quot;&gt;四、配置 AOP 切面&lt;/h2&gt;
&lt;p&gt;在配置 AOP 切面之前，我们需要了解下 &lt;code&gt;aspectj&lt;/code&gt; 相关注解的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@Aspect&lt;/strong&gt;：声明该类为一个注解类；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Pointcut&lt;/strong&gt;：定义一个切点，后面跟随一个表达式，表达式可以定义为切某个注解，也可以切某个 package 下的方法；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;切点定义好后，就是围绕这个切点做文章了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@Before&lt;/strong&gt;: 在切点之前，织入相关代码；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@After&lt;/strong&gt;: 在切点之后，织入相关代码;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@AfterReturning&lt;/strong&gt;: 在切点返回内容后，织入相关代码，一般用于对返回值做些加工处理的场景；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@AfterThrowing&lt;/strong&gt;: 用来处理当织入的代码抛出异常后的逻辑处理;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Around&lt;/strong&gt;: 环绕，可以在切入点前后织入代码，并且可以自由的控制何时执行切点；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645738086039&quot; title=&quot;注解执行顺序&quot; alt=&quot;注解执行顺序&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，定义一个 &lt;code&gt;WebLogAspect.java&lt;/code&gt; 切面类，声明一个切点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645670837939&quot; title=&quot;定义一个切点&quot; alt=&quot;定义一个切点&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，定义 &lt;code&gt;@Around&lt;/code&gt; 环绕，用于何时执行切点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645708525786&quot; title=&quot;环绕&quot; alt=&quot;环绕&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;①&lt;/strong&gt;：记录一下调用接口的开始时间；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;②&lt;/strong&gt;：执行切点，执行切点后，会去依次调用 &lt;strong&gt;@Before -&amp;gt; 接口逻辑代码 -&amp;gt; @After -&amp;gt; @AfterReturning&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;③&lt;/strong&gt;：打印出参；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;④&lt;/strong&gt;：打印接口处理耗时；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;⑤&lt;/strong&gt;：返回接口返参结果；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再来看看 &lt;code&gt;@Before&lt;/code&gt; 方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645757655084&quot; title=&quot;@Before&quot; alt=&quot;@Before&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看注释功能说明，因为注释说得还是比较清楚的！&lt;/p&gt;
&lt;p&gt;最后，用 &lt;code&gt;@After&lt;/code&gt; 来做个收尾：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645788269885&quot; title=&quot;换行&quot; alt=&quot;换行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645790438918&quot; title=&quot;@After&quot; alt=&quot;@After&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在每个接口的最后，打印日志结束标志。最后再看下项目包结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645811602036&quot; title=&quot;项目包结构&quot; alt=&quot;项目包结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，切面相关的代码就完成了！&lt;/p&gt;
&lt;p&gt;上完整代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package site.exception.springbootaopwebrequest.aspect;

import com.google.gson.Gson;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.lang.reflect.Method;

/**
 * @author 犬小哈 （微信号：小哈学Java）
 * @site www.exception.site
 * @date 2019/2/12
 * @time 下午9:19
 * @discription
 **/
@Aspect
@Component
@Profile({&quot;dev&quot;, &quot;test&quot;})
public class WebLogAspect {

    private final static Logger logger         = LoggerFactory.getLogger(WebLogAspect.class);
    /** 换行符 */
    private static final String LINE_SEPARATOR = System.lineSeparator();

    /** 以自定义 @WebLog 注解为切点 */
    @Pointcut(&quot;@annotation(site.exception.springbootaopwebrequest.aspect.WebLog)&quot;)
    public void webLog() {}

    /**
     * 在切点之前织入
     * @param joinPoint
     * @throws Throwable
     */
    @Before(&quot;webLog()&quot;)
    public void doBefore(JoinPoint joinPoint) throws Throwable {
        // 开始打印请求日志
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();

        // 获取 @WebLog 注解的描述信息
        String methodDescription = getAspectLogDescription(joinPoint);

        // 打印请求相关参数
        logger.info(&quot;========================================== Start ==========================================&quot;);
        // 打印请求 url
        logger.info(&quot;URL            : {}&quot;, request.getRequestURL().toString());
        // 打印描述信息
        logger.info(&quot;Description    : {}&quot;, methodDescription);
        // 打印 Http method
        logger.info(&quot;HTTP Method    : {}&quot;, request.getMethod());
        // 打印调用 controller 的全路径以及执行方法
        logger.info(&quot;Class Method   : {}.{}&quot;, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());
        // 打印请求的 IP
        logger.info(&quot;IP             : {}&quot;, request.getRemoteAddr());
        // 打印请求入参
        logger.info(&quot;Request Args   : {}&quot;, new Gson().toJson(joinPoint.getArgs()));
    }

    /**
     * 在切点之后织入
     * @throws Throwable
     */
    @After(&quot;webLog()&quot;)
    public void doAfter() throws Throwable {
        // 接口结束后换行，方便分割查看
        logger.info(&quot;=========================================== End ===========================================&quot; + LINE_SEPARATOR);
    }

    /**
     * 环绕
     * @param proceedingJoinPoint
     * @return
     * @throws Throwable
     */
    @Around(&quot;webLog()&quot;)
    public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = proceedingJoinPoint.proceed();
        // 打印出参
        logger.info(&quot;Response Args  : {}&quot;, new Gson().toJson(result));
        // 执行耗时
        logger.info(&quot;Time-Consuming : {} ms&quot;, System.currentTimeMillis() - startTime);
        return result;
    }


    /**
     * 获取切面注解的描述
     *
     * @param joinPoint 切点
     * @return 描述信息
     * @throws Exception
     */
    public String getAspectLogDescription(JoinPoint joinPoint)
            throws Exception {
        String targetName = joinPoint.getTarget().getClass().getName();
        String methodName = joinPoint.getSignature().getName();
        Object[] arguments = joinPoint.getArgs();
        Class targetClass = Class.forName(targetName);
        Method[] methods = targetClass.getMethods();
        StringBuilder description = new StringBuilder(&quot;&quot;);
        for (Method method : methods) {
            if (method.getName().equals(methodName)) {
                Class[] clazzs = method.getParameterTypes();
                if (clazzs.length == arguments.length) {
                    description.append(method.getAnnotation(WebLog.class).description());
                    break;
                }
            }
        }
        return description.toString();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五怎么使用呢&quot;&gt;五、怎么使用呢？&lt;/h2&gt;
&lt;p&gt;因为我们的切点是自定义注解 &lt;code&gt;@WebLog&lt;/code&gt;, 所以我们仅仅需要在 Controller 控制器的每个接口方法添加 @WebLog 注解即可，如果我们不想某个接口打印出入参日志，不加注解就可以了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645834349857&quot; title=&quot;用户登录接口&quot; alt=&quot;用户登录接口&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六对于文件上传好使不&quot;&gt;六、对于文件上传好使不？&lt;/h2&gt;
&lt;p&gt;是好使的！不论是单文件上传，抑或是多文件上传，切面日志均运行良好，这里测试的东西，小哈就不贴出来了。有兴趣的小伙伴可以试试！&lt;/p&gt;
&lt;h2 id=&quot;七只想在开发环境和测试环境中使用&quot;&gt;七、只想在开发环境和测试环境中使用？&lt;/h2&gt;
&lt;p&gt;对于那些性能要求较高的应用，不想在生产环境中打印日志，只想在开发环境或者测试环境中使用，要怎么做呢？我们只需为切面添加 &lt;code&gt;@Profile&lt;/code&gt; 就可以了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155645881518775&quot; title=&quot;指定profile&quot; alt=&quot;指定profile&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就指定了只能作用于 &lt;code&gt;dev&lt;/code&gt; 开发环境和 &lt;code&gt;test&lt;/code&gt; 测试环境，生产环境 &lt;code&gt;prod&lt;/code&gt; 是不生效的！&lt;/p&gt;
&lt;h2 id=&quot;八多切面如何指定优先级&quot;&gt;八、多切面如何指定优先级？&lt;/h2&gt;
&lt;p&gt;假设说我们的服务中不止定义了一个切面，比如说我们针对 Web 层的接口，不止要打印日志，还要校验 token 等。要如何指定切面的优先级呢？也就是如何指定切面的执行顺序？&lt;/p&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;@Order(i)&lt;/code&gt;注解来指定优先级，注意：&lt;strong&gt;i 值越小，优先级则越高&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设说我们定义上面这个日志切面的优先级为 &lt;code&gt;@Order(10)&lt;/code&gt;, 然后我们还有个校验 &lt;code&gt;token&lt;/code&gt; 的切面 &lt;code&gt;CheckTokenAspect.java&lt;/code&gt;，我们定义为了 &lt;code&gt;@Order(11)&lt;/code&gt;, 那么它们之间的执行顺序如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155650612695040&quot; title=&quot;多切点优先级&quot; alt=&quot;多切点优先级&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在切点之前，&lt;code&gt;@Order&lt;/code&gt; 从小到大被执行，也就是说越小的优先级越高；&lt;/li&gt;
&lt;li&gt;在切点之后，&lt;code&gt;@Order&lt;/code&gt; 从大到小被执行，也就是说越大的优先级越高；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;九ref&quot;&gt;九、Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.didispace.com/springbootaoplog/#&quot;&gt;http://blog.didispace.com/springbootaoplog&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;十github-源码地址&quot;&gt;十、GitHub 源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/weiwosuoai/spring-boot-tutorial/tree/master/spring-boot-aop-web-request&quot; class=&quot;uri&quot;&gt;https://github.com/weiwosuoai/spring-boot-tutorial/tree/master/spring-boot-aop-web-request&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;赠送-面试学习福利资源&quot;&gt;赠送 | 面试&amp;amp;学习福利资源&lt;/h2&gt;
&lt;p&gt;最近在网上发现一个不错的 PDF 资源《Java 核心知识&amp;amp;面试.pdf》分享给大家，不光是面试，学习，你都值得拥有！！！&lt;/p&gt;
&lt;p&gt;获取方式: 关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复 &lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt;，下面是目录以及部分截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651432676587&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651441280253&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651443805696&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651470347464&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651449186666&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651451040055&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重要的事情说两遍，关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复 &lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt; ！！！&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注微信公众号-小哈学java&quot;&gt;欢迎关注微信公众号: 小哈学Java&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155634562788477&quot; title=&quot;小哈学Java，关注领取10G面试学习资料哦&quot; alt=&quot;小哈学Java，关注领取10G面试学习资料哦&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 05:25:00 +0000</pubDate>
<dc:creator>犬小哈</dc:creator>
<og:description>欢迎关注个人微信公众号: 小哈学Java , 文末分享阿里 P8 资深架构师总结的 《Java 核心知识整理&amp;面试.pdf》资源链接！！ 个人网站: 'https://www.exception.si</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quanxiaoha/p/10789843.html</dc:identifier>
</item>
</channel>
</rss>