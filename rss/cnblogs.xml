<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Asp.net Core 3.1基于AspectCore实现AOP，实现事务、缓存拦截器 - 菜工</title>
<link>http://www.cnblogs.com/caijt/p/13380455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caijt/p/13380455.html</guid>
<description>&lt;p&gt;最近想给我的框架加一种功能，就是比如给一个方法加一个事务的特性Attribute，那这个方法就会启用事务处理。给一个方法加一个缓存特性，那这个方法就会进行缓存。&lt;/p&gt;
&lt;p&gt;这个也是网上说的面向切面编程AOP。&lt;/p&gt;
&lt;p&gt;AOP的概念也很好理解，跟中间件差不多，说白了，就是我可以任意地在方法的前面或后面添加代码，这很适合用于缓存、日志等处理。&lt;/p&gt;

&lt;p&gt;在net core2.2时，我当时就尝试过用autofac实现aop，但这次我不想用autofac，我用了一个更轻量级的框架，AspectCore。&lt;/p&gt;
&lt;p&gt;用起来非常非常的简单，但一开始还是走了一点弯路，主要是网上都是net core3以下的教程，3以下的使用方法跟之前有一些不同。&lt;/p&gt;
&lt;p&gt;先安装NuGet包，包名：AspectCore.Extensions.DependencyInjection&lt;/p&gt;
&lt;p&gt;然后在Program.cs类中增加一行代码，这是net core 3的不同之处，这句添加的代码，意思就是用AspectCore的IOC容器替换内置的。因为AOP需要依靠IOC实现，所以必须得替换掉内置的IOC。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder CreateHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                webBuilder.UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dependAssemblyKey =&lt;span&gt; BuildDependAssemblyKey();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(dependAssemblyKey))
                {
                    webBuilder.UseSetting(WebHostDefaults.HostingStartupAssembliesKey, dependAssemblyKey);
                }
            })
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用AspectCore替换默认的IOC容器&lt;/span&gt;
            .UseServiceProviderFactory(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DynamicProxyServiceProviderFactory());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在Startup.cs类中的ConfigureServices中添加代码。（其实这个加不加都可以，如果需要配置就加，例如全局的拦截器、只拦截哪些匹配的服务，因为我只用特性进行拦截，所以我就什么也没配置）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
services.ConfigureDynamicProxy(o=&amp;gt;&lt;span&gt; { 
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加AOP的配置&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样AOP就配置好了，是不是很简单。&lt;/p&gt;
&lt;p&gt;当然使用方面也需要注意一下，可以在接口、接口的方法、类，类的virtual方法上进行拦截。还有如果你想拦截控制器的action的话，那需要在ConfigureService里AddControllerAsServices&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
services.AddControllers(&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把控制器当成服务&lt;/span&gt;
.AddControllersAsServices()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我列出我的事务拦截器代码，如果是特性拦截，就继承&lt;span&gt;AbstractInterceptorAttribute，如果要写一个全局拦截器，就&lt;span&gt;AbstractInterceptor，然后在ConfigureDynamicProxy中进行配置，这个我就不介绍了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransactionInterceptorAttribute : AbstractInterceptorAttribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dbContext = context.ServiceProvider.GetService&amp;lt;AppDbContext&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先判断是否已经启用了事务&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (dbContext.Database.CurrentTransaction == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; dbContext.Database.BeginTransactionAsync();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
                    dbContext.Database.CommitTransaction();
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                {
                    dbContext.Database.RollbackTransaction();
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我就可以这么优雅地使用事务了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/648126/202007/648126-20200726150117114-521743982.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我再列出我的缓存拦截器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheInterceptorAttribute : AbstractInterceptorAttribute
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 缓存秒数
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ExpireSeconds { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先判断方法是否有返回值，无就不进行缓存判断&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; returnParams =&lt;span&gt; context.GetReturnParameter();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (returnParams.Type == &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
            
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取方法参数名&lt;/span&gt;
        &lt;span&gt;string&lt;/span&gt; param =&lt;span&gt; CommonHelper.ObjectToJsonString(context.Parameters);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取方法名称，也就是缓存key值&lt;/span&gt;
        &lt;span&gt;string&lt;/span&gt; key = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Methods:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + context.ImplementationMethod.DeclaringType.FullName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; context.ImplementationMethod.Name;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cache = context.ServiceProvider.GetService&amp;lt;ICacheHelper&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果缓存有值，那就直接返回缓存值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cache.HashExists(key, param))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = &lt;span&gt;typeof&lt;/span&gt;(ICacheHelper).GetMethod(nameof(ICacheHelper.HashGet)).MakeGenericMethod(returnParams.Type).Invoke(cache, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[] { key, param });
            context.ReturnValue &lt;/span&gt;=&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
        cache.HashSet(key, param, context.ReturnValue);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ExpireSeconds &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            cache.SetExpire(key, TimeSpan.FromSeconds(ExpireSeconds));
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我还弄了一个缓存删除拦截器，作用就是带有这个特性的方法执行后，会删除相关缓存值&lt;/p&gt;
&lt;p&gt;为什么有这个设计呢，比如说我给一个方法 GetUserList 加了缓存，那我数据改变了怎么办，我想在User数据改变时，把这个缓存删除掉，那我就可以在SaveUser方法上加上我这个缓存删除拦截器，那这个方法执行后，就会把相关的缓存删除掉了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheDeleteInterceptorAttribute : AbstractInterceptorAttribute
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Type[] _types;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] _methods;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 需传入相同数量的Types跟Methods，同样位置的Type跟Method会组合成一个缓存key，进行删除
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;Types&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;传入要删除缓存的类&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;Methods&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;传入要删除缓存的方法名称，必须与Types数组对应&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CacheDeleteInterceptorAttribute(Type[] Types, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] Methods)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Types.Length !=&lt;span&gt; Methods.Length)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApiFailException(ApiFailCode.OPERATION_FAIL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Types必须跟Methods数量一致&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        _types &lt;/span&gt;=&lt;span&gt; Types;
        _methods &lt;/span&gt;=&lt;span&gt; Methods;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cache = context.ServiceProvider.GetService&amp;lt;ICacheHelper&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; _types.Length; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; type =&lt;span&gt; _types[i];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method =&lt;span&gt; _methods[i];
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; key = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Methods:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + type.FullName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; method;
            cache.Delete(key);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;AOP的实现原理我也想象了一下：&lt;/p&gt;
&lt;p&gt;要实现AOP，需要依靠IOC容器，因为它是我们类的管家，那能被拦截的类必须是IOC注入的，自己new出来的是不受拦截的。如果我想在A方法前面添加点代码，那我告诉IOC，把代码给它，那IOC在注入A方法所在类时，会继承它生成一个派生类，然后重写A方法，所以拦截方法必须得为virtual，然后A方法里写上我要添加的代码，再base.A()这样。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jul 2020 00:55:00 +0000</pubDate>
<dc:creator>菜工</dc:creator>
<og:description>最近想给我的框架加一种功能，就是比如给一个方法加一个事务的特性Attribute，那这个方法就会启用事务处理。给一个方法加一个缓存特性，那这个方法就会进行缓存。 这个也是网上说的面向切面编程AOP。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/caijt/p/13380455.html</dc:identifier>
</item>
<item>
<title>轻松应对并发问题，Newbe.Claptrap 框架中 State 和 Event 应该如何理解？ - Newbe36524</title>
<link>http://www.cnblogs.com/newbe36524/p/13381857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/newbe36524/p/13381857.html</guid>
<description>&lt;p&gt;Newbe.Claptrap 框架中 State 和 Event 应该如何理解？最近整理了一下项目的术语表。今天就谈谈什么是 Event 和 State。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Newbe.Claptrap 是一个用于轻松应对并发问题的分布式开发框架。如果您是首次阅读本系列文章。建议可以先从本文末尾的入门文章开始了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;事件 Event&lt;/h2&gt;
&lt;p&gt;Claptrap 是基于事件溯源的 Actor 模式。事件自然就起到了至关重要的作用。&lt;/p&gt;
&lt;p&gt;想要操作 Claptrap 就需要对其传递事件。事件也是改变 Claptrap State 的唯一参数。因此，在使用 Claptrap 构建系统时，所有的系统操作都会转换为事件而传入到 Claptrap 中。事件具有以下这些特点：&lt;/p&gt;
&lt;h3&gt;事件是有序的&lt;/h3&gt;
&lt;p&gt;每个事件都包含有一个唯一的序列号。在本框架中，这个序列号被称为版本号（Version）。事件的版本号是一个从 1 开始逐 1 递增的序列。事件的有序性，确保了状态的计算不存在并发问题。这是状态数据可靠性的重要保证。&lt;/p&gt;
&lt;p&gt;事件的有序性直接反应了 Claptrap 执行事件的先后顺序。而由于需要确保这种顺序，Claptrap 在执行事件时，必须逐个事件进行处理。这点恰好与 Actor 模式的单线程特性产生了天然的契合。&lt;/p&gt;
&lt;h3&gt;事件是不可变的&lt;/h3&gt;
&lt;p&gt;事件一旦产生，它就是不可变的。事件溯源，正由于事件的不可变性，才使得数据是可靠的。因为只要读取事件，就能够还原出任何一个事件执行之后的状态。但不可变性并不是物理上的限制。你仍然可以修改物理存储中的事件数据。但请注意，这是危险的，极为不建议的行为。&lt;/p&gt;
&lt;p&gt;让我们联系设计模式中的 “开闭原则”，经典的可以被概括为 “对扩展开放，对修改封闭”。其中为什么要强调 “对修改封闭” 呢？就笔者看来，对修改封闭的原因其实是因为修改所带来的未知性。因为过往执行的代码，产生的数据。他们都已经形成了一定的封闭性。他们是经过已有的测试所验证的。如果尝试修改他们，势必就需要调整相应的测试，而这就更进一步加剧了修改，这可不是一件好事。事件的不可变是一种性质，更是一种要求。&lt;/p&gt;
&lt;p&gt;那如果由于一个 BUG 导致了过往的产生事件数据不正确，现在需要修正这个 BUG，该怎么办呢？笔者的建议，不要尝试修改已有的事件。应该追加新的事件和算法来修正当前的状态。不要去调整旧的内容。笔者认为这更符合开闭原则。开发者可以自行斟酌。&lt;/p&gt;
&lt;h3&gt;事件是永久的&lt;/h3&gt;
&lt;p&gt;事件是确保 Claptrap State 正确性的重要参数。因此，需要确保事件被永久保存。但，这不是绝对的情况，如果满足以下条件，那么事件就允许被丢失：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在丢失事件之前存在一个永久的 State 快照&lt;/li&gt;
&lt;li&gt;对应的 Claptrap 已经生命终结，永远都不会再被激活&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;反之，如果不满足以上的条件，那么请必须确保在生产环境中的事件被正确的保存在持久化层，并且已经有相应的容灾手段。&lt;/p&gt;
&lt;h2&gt;状态 State&lt;/h2&gt;
&lt;p&gt;State 在 Actor 模式中代表了 Actor 对象当前的数据表现。而在 Claptrap 仅仅只是在此之上增加了一个限制：“State 只能通过事件溯源的方式进行更新”。由于事件溯源的可靠性。Claptrap 中的 State 也就拥有了更好的可靠性。&lt;/p&gt;
&lt;p&gt;State 的版本号。在 Claptrap 中的 State 中有一个名为 Version 的属性，它表示 State 当前的版本。版本号是一个从 0 开始的自增数字，会在每次处理一个事件之后进行自增。&lt;/p&gt;
&lt;p&gt;版本号为 0 的 State 是 Claptrap 的初始状态，也可以被称为创世状态。初始状态可以根据业务需要进行定制。&lt;/p&gt;
&lt;p&gt;Claptrap 和 Minion 对于版本号的处理也有一些区别。&lt;/p&gt;
&lt;p&gt;对于 Claptrap 而言，Claptrap 是事件的生产者，因此，事件的版本号本身就是由 Claptrap 进行赋予的。例如，在一次事件的处理过程中，以下这些事情将会依次发生：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;State Version = 1000&lt;/li&gt;
&lt;li&gt;开始处理 Event ，其 Version = State Version + 1 = 1001&lt;/li&gt;
&lt;li&gt;Event 处理完毕，更新 State Version = 1001&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于 Minion 而言，由于它是 Claptrap 事件的消费者。因此版本号的处理略有不同。例如，在一次事件的处理过程中，以下事件将会依次发生：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;State Version = 1000&lt;/li&gt;
&lt;li&gt;读取到了 Event Version 为 1001 的事件&lt;/li&gt;
&lt;li&gt;Event 处理完毕，更新 State Version = 1001&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;State 的版本号和 Event 的版本号相互依存，相互验证，是事件有序性的关键。如果在处理过程中，出现 State 的版本号和 Event 的版本号不匹配的情况，将会是严重的问题。通常来说，出现版本号不匹配，只有两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;持久化层中的事件出现了丢失&lt;/li&gt;
&lt;li&gt;框架恶性 BUG&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;最后但是最重要！&lt;/h2&gt;
&lt;p&gt;最近作者正在构建以&lt;code&gt;反应式&lt;/code&gt;、&lt;code&gt;Actor模式&lt;/code&gt;和&lt;code&gt;事件溯源&lt;/code&gt;为理论基础的一套服务端开发框架。希望为开发者提供能够便于开发出 “分布式”、“可水平扩展”、“可测试性高” 的应用系统 ——Newbe.Claptrap&lt;/p&gt;
&lt;p&gt;本篇文章是该框架的一篇技术选文，属于技术构成的一部分。如果读者对该内容感兴趣，欢迎转发、评论、收藏文章以及项目。您的支持是促进项目成功的关键。&lt;/p&gt;
&lt;p&gt;联系方式：&lt;/p&gt;
&lt;p&gt;您还可以查阅本系列的其他选文：&lt;/p&gt;
&lt;p&gt;理论入门篇&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Newbe.Claptrap/Overview-Of-Newbe-Claptrap/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Newbe.Claptrap/Overview-Of-Newbe-Claptrap/&quot;&gt;Newbe.Claptrap - 一套以 “事件溯源” 和 “Actor 模式” 作为基本理论的服务端开发框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Newbe.Claptrap/Newbe-Claptrap-Weekly-1/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Newbe.Claptrap/Newbe-Claptrap-Weekly-1/&quot;&gt;Newbe.Claptrap 项目周报 1 - 还没轮影，先用轮跑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Newbe.Claptrap/Why-Claptrap-And-Minion/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Newbe.Claptrap/Why-Claptrap-And-Minion/&quot;&gt;Newbe.Claptrap 框架中为什么用 Claptrap 和 Minion 两个词？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实现入门篇&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Newbe.Claptrap/Get-Started-1/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Newbe.Claptrap/Get-Started-1/&quot;&gt;Newbe.Claptrap 框架入门，第一步 —— 创建项目，实现简易购物车&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Newbe.Claptrap/Get-Started-2/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Newbe.Claptrap/Get-Started-2/&quot;&gt;Newbe.Claptrap 框架入门，第二步 —— 简单业务，清空购物车&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;样例实践篇&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Newbe.Claptrap/Create-A-Train-Ticketing-System-In-Newbe-Claptrap-1/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Newbe.Claptrap/Create-A-Train-Ticketing-System-In-Newbe-Claptrap-1/&quot;&gt;构建一个简易的火车票售票系统，Newbe.Claptrap 框架用例，第一步 —— 业务分析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其他番外篇&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Newbe.Claptrap/Reactive-In-Server-1/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Newbe.Claptrap/Reactive-In-Server-1/&quot;&gt;谈反应式编程在服务端中的应用，数据库操作优化，从 20 秒到 0.5 秒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Newbe.Claptrap/Reactive-In-Server-2/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Newbe.Claptrap/Reactive-In-Server-2/&quot;&gt;谈反应式编程在服务端中的应用，数据库操作优化，提速 Upsert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Newbe.Claptrap/How-Many-RAMs-In-Used-While-There-Are-One-Hundred-Thousand-Users-Online/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Newbe.Claptrap/How-Many-RAMs-In-Used-While-There-Are-One-Hundred-Thousand-Users-Online/&quot;&gt;十万同时在线用户，需要多少内存？——Newbe.Claptrap 框架水平扩展实验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.newbe.pro/Others/Full-Speed-To-Download-Netcore-Docker-Images/&quot; data-cke-saved-href=&quot;https://www.newbe.pro/Others/Full-Speed-To-Download-Netcore-Docker-Images/&quot;&gt;docker-mcr 助您全速下载 dotnet 镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;术语介绍篇&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/1-Actor-Pattern&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/1-Actor-Pattern&quot;&gt;Actor 模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/2-Event-Sourcing&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/2-Event-Sourcing&quot;&gt;事件溯源（Event Sourcing）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/3-Claptrap&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/3-Claptrap&quot;&gt;Claptrap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/4-Minion&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/4-Minion&quot;&gt;Minion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/5-Event&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/5-Event&quot;&gt;事件 （Event）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/6-State&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;https://claptrap.newbe.pro/zh_Hans/2-Glossary/6-State&quot;&gt;状态 （State）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;GitHub 项目地址：&lt;a href=&quot;https://github.com/newbe36524/Newbe.Claptrap&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;https://github.com/newbe36524/Newbe.Claptrap&quot;&gt;https://github.com/newbe36524/Newbe.Claptrap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitee 项目地址：&lt;a href=&quot;https://gitee.com/yks/Newbe.Claptrap&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;https://gitee.com/yks/Newbe.Claptrap&quot;&gt;https://gitee.com/yks/Newbe.Claptrap&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.9891304347826&quot;&gt;
&lt;p&gt;您当前查看的是先行发布于 &lt;a href=&quot;http://www.newbe.pro/&quot; data-cke-saved-href=&quot;http://www.newbe.pro/&quot;&gt;www.newbe.pro&lt;/a&gt; 上的博客文章，实际开发文档随版本而迭代。若要查看最新的开发文档，需要移步 &lt;a href=&quot;http://claptrap.newbe.pro/&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;http://claptrap.newbe.pro/&quot;&gt;claptrap.newbe.pro&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://www.newbe.pro/images/main_banner.png&quot; alt=&quot;Newbe.Claptrap&quot; data-cke-saved-src=&quot;https://www.newbe.pro/images/main_banner.png&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 27 Jul 2020 00:54:00 +0000</pubDate>
<dc:creator>Newbe36524</dc:creator>
<og:description>Newbe.Claptrap 框架中 State 和 Event 应该如何理解？最近整理了一下项目的术语表。今天就谈谈什么是 Event 和 State。 Newbe.Claptrap 是一个用于轻松</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/newbe36524/p/13381857.html</dc:identifier>
</item>
<item>
<title>JavaFX布局神器-SceneBuilder - HiIT青年</title>
<link>http://www.cnblogs.com/itqn/p/13380499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itqn/p/13380499.html</guid>
<description>&lt;p&gt;JavaFX允许开发使用FXML来设计和布局界面，跟Qt和Android的布局有点类似，JavaFX用SceneBuilder来设计和布局界面。&lt;br/&gt;SceneBuilder最新的下载地址：&lt;a href=&quot;https://gluonhq.com/products/scene-builder&quot;&gt;https://gluonhq.com/products/scene-builder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里用到的开发工具有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;IntelliJ IDEA（社区版）&lt;/li&gt;
&lt;li&gt;JavaFX IDEA 插件&lt;/li&gt;
&lt;li&gt;SceneBuilder&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;1-安装scenebuilder&quot;&gt;1. 安装SceneBuilder&lt;/h3&gt;
&lt;p&gt;从上面的下载地址，下载对应操作系统环境的SceneBuilder安装即可。&lt;br/&gt;SceneBuilder的界面主要分为四个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;顶部菜单栏&lt;/li&gt;
&lt;li&gt;左边容器和控件区域&lt;/li&gt;
&lt;li&gt;右边属性和布局区域&lt;/li&gt;
&lt;li&gt;中间界面设计区域&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202007/2083963-20200726153003342-1822217171.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SceneBuilder对JavaFX开发来说很有帮助，可以通过它来了解JavaFX提供了哪些控件，这些控件都有什么属性。&lt;br/&gt;另外，在通过SceneBuilder布局后按&lt;code&gt;Ctrl + P&lt;/code&gt;来预览界面，这样就不用写代码也能查看自己设计的界面。&lt;/p&gt;
&lt;h3 id=&quot;2-intellij-idea-关联-scenebuilder&quot;&gt;2. IntelliJ IDEA 关联 SceneBuilder&lt;/h3&gt;
&lt;p&gt;SceneBuilder可以单独使用，但更方便的是让它跟IDEA集成，这样子的话，在开发过成功就不需要打开两个软件了。&lt;br/&gt;在IDEA关联SceneBuilder之前，可以先IDEA装一个JavaFX插件，这个插件对FXML和Contoller代码关联很有用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202007/2083963-20200726153251981-1341246211.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完JavaFX IDEA 插件之后，通过指定SceneBuilder可执行程序的路径就可以将 SceneBuilder集成到IDEA中了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202007/2083963-20200726153533828-1043274369.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，开发工具的环境就搭建好了。&lt;/p&gt;
&lt;h3 id=&quot;3-在idea中使用scenebuilder&quot;&gt;3. 在IDEA中使用SceneBuilder&lt;/h3&gt;
&lt;p&gt;SceneBuilder跟IntelliJ IDEA集成之后，在IDEA打开FXML文件就可以用SceneBuilder来布局界面了。&lt;br/&gt;可以通过切换底部的“Text”和“Scene Builder”来实现代码布局和控件布局。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202007/2083963-20200726154421017-1087399638.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般来说，可以先通过SceneBuilder将JavaFX应用做一个大体的界面排版布局，然后通过Text调整FXML的布局的代码，比如删除一些SceneBuilder生成不必要的代码等。&lt;/p&gt;
&lt;h3 id=&quot;4-通过实践示例使用fxml&quot;&gt;4. 通过实践示例使用FXML&lt;/h3&gt;
&lt;p&gt;通过以上的步骤已经可以很快的开发JavaFX的界面了，最后这里通过一个示例，来说明一下FXML控件是如何跟Java代码进行交互的。&lt;br/&gt;这个示例通过点击按钮（Button）实现标签（Label）的文字替换。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标签（Label）通过fx:id跟Controller的Label变量text绑定。&lt;/li&gt;
&lt;li&gt;按钮（Button）通过onAction绑定Controller中的事件处理方法click()。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;视图层代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;center&amp;gt;
  &amp;lt;VBox alignment=&quot;CENTER&quot; spacing=&quot;10.0&quot;&amp;gt;
   &amp;lt;Label fx:id=&quot;text&quot;/&amp;gt;
   &amp;lt;Button text=&quot;Go.&quot; onAction=&quot;#click&quot;/&amp;gt;
  &amp;lt;/VBox&amp;gt;
&amp;lt;/center&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制层代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AppUI implements Initializable {
    public Label text;
    private AppModel model = new AppModel();
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        text.textProperty().bindBidirectional(model.textProperty());
        model.setText(&quot;Hello JavaFX.&quot;);
    }
    public void click(ActionEvent event) {
        String[] lArr = new String[] {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;};
        model.setText(lArr[new Random().nextInt(lArr.length)]);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202007/2083963-20200726160429557-2052289682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样子，就通过点击按钮随机生成（A,B,C,D）这四个字母显示在标签上，完成FXML和Controller的java代码的通讯了。&lt;br/&gt;这里采用MVC模式，通过修改model的值，就能控制view的显示。&lt;br/&gt;关于MVC模式的完成代码，可以查看我的另一篇博文（JavaFX桌面应用开发-HelloWorld），或者通过我的公众号下载完整的源码。&lt;/p&gt;
&lt;p&gt;=========================================================&lt;br/&gt;源码可&lt;strong&gt;关注&lt;/strong&gt;公众号 “HiIT青年” 发送 “javafx-fxml” 获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/itqn/1797476/o_200702010008qrcode.jpg&quot; alt=&quot;HiIT青年&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;关注公众号&lt;/strong&gt;，阅读更多文章。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jul 2020 00:51:00 +0000</pubDate>
<dc:creator>HiIT青年</dc:creator>
<og:description>JavaFX允许开发使用FXML来设计和布局界面，跟Qt和Android的布局有点类似，JavaFX用SceneBuilder来设计和布局界面。 SceneBuilder最新的下载地址：https:/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itqn/p/13380499.html</dc:identifier>
</item>
<item>
<title>搞事情？Spring Boot今天一口气发布三个版本 - YourBatman</title>
<link>http://www.cnblogs.com/yourbatman/p/13383542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yourbatman/p/13383542.html</guid>
<description>&lt;blockquote readability=&quot;6.3&quot;&gt;
&lt;p&gt;学无止境？本文已被 &lt;a href=&quot;https://www.yourbatman.cn&quot;&gt;&lt;strong&gt;https://www.yourbatman.cn&lt;/strong&gt;&lt;/a&gt; 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的&lt;strong&gt;专栏&lt;/strong&gt;供以免费学习。关注公众号【&lt;strong&gt;BAT的乌托邦&lt;/strong&gt;】逐个击破，深入掌握，拒绝浅尝辄止。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725232718273.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;各位好，我是A哥(YourBatman)。今天是2020-07-25，上午我正从&lt;strong&gt;&lt;a href=&quot;https://start.spring.io&quot;&gt;https://start.spring.io&lt;/a&gt;&lt;/strong&gt;准备down一个工程下来的时候，打开页面发现默认选中的Spring Boot版本号是&lt;code&gt;2.3.2&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725213616518.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;并非我刻意的去找到这个变化，而是由于我&lt;strong&gt;昨天&lt;/strong&gt; down下来的工程使用的Spring Boot版本是&lt;strong&gt;2.3.1&lt;/strong&gt;，印象还在，所以今天一下子就发现了差异。&lt;/p&gt;
&lt;p&gt;既然升级了（虽然是小版本号），那就去官方楼一眼呗。不看不知道，一看还真让发现些内容：&lt;strong&gt;Spring Boot在同一天（2020-07-25）一口气发布了三个版本，这是要搞事情啊？&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725233253231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小贴士：本文所有时间若未做特殊说明，指的均是&lt;strong&gt;北京时间&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Spring Boot目前还处于&lt;strong&gt;Active&lt;/strong&gt;活跃的分支共有三个：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725215806663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;因此就在今天，&lt;strong&gt;同一天&lt;/strong&gt;里Spring Boot对它的这三条线做了更新：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring Boot 2.3.1 -&amp;gt; &lt;strong&gt;Spring Boot 2.3.2&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Spring Boot 2.2.8 -&amp;gt; &lt;strong&gt;Spring Boot 2.2.9&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Spring Boot 2.1.15 -&amp;gt; &lt;strong&gt;Spring Boot 2.1.16&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725221151805.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;此次发版，距离上次&lt;strong&gt;正式&lt;/strong&gt;发版（不区分分支）已足足有&lt;strong&gt;44天&lt;/strong&gt;之久。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725220629806.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;有哪些升级？&quot;&gt;有哪些升级？&lt;/h2&gt;
&lt;p&gt;参考github上的Release详情，三个分支&lt;strong&gt;都&lt;/strong&gt;有如下三方面的改进：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;🐞 修复bug&lt;/li&gt;
&lt;li&gt;📔 文档同步&lt;/li&gt;
&lt;li&gt;🔨 升级依赖&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;-修复bug&quot;&gt;🐞 修复bug&lt;/h3&gt;
&lt;p&gt;小版本号的升级，最重要的使命就是&lt;strong&gt;修复bug&lt;/strong&gt;，这是它存在的意义。针对这三个版本，各自的bug修复总数如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;2.3.2&lt;/strong&gt;：34个。遥遥领先&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2.2.9&lt;/strong&gt;：10个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2.1.16&lt;/strong&gt;：1个。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;能发现规律吧，&lt;strong&gt;版本越新，bug越多&lt;/strong&gt;，这是符合常理的。另外，从小版本号里能知道：2.1.x版本都修复16次bug了，而2.3.x才第2次修复，正处于bug井喷阶段呢。所以一味的追新的话，还需谨慎哈。&lt;/p&gt;
&lt;p&gt;也许你会吐槽，Spring Boot这啥编码水平，咋这么多bug？其实非也，个数虽多（其实也还好），但每一个都是&lt;strong&gt;非严重bug&lt;/strong&gt;，影响甚微，无需大惊小怪。&lt;/p&gt;
&lt;p&gt;另外，从bug的原因上来看，不少bug是各个版本都有的共性问题。比如2.1.x版本那个唯一的bug，其它两个版本均有：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725224007874.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-文档同步&quot;&gt;📔 文档同步&lt;/h3&gt;
&lt;p&gt;此part用于对文档上的改变做出一些说明，比如文字描述错误、排版不正确等等。举例本次的一个修复：&lt;/p&gt;
&lt;p&gt;修复前：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725224446430.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;修复后：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725224517894.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;不得不说，这老外还挺较真（挺仔细）的。&lt;/p&gt;
&lt;h3 id=&quot;-升级依赖&quot;&gt;🔨 升级依赖&lt;/h3&gt;
&lt;p&gt;由于是小版本的升级，因此对应的依赖也是小版本升级。举例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Tomcat升级到9.0.37&lt;/li&gt;
&lt;li&gt;Spring Framework升级到5.2.8（此版本4天前发布）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意的是，拿&lt;code&gt;Spring Framework&lt;/code&gt;的升级举例：Spring Boot的2.2.x和2.3.x都是升级到了5.2.8版本，而Spring Boot的2.1.x分支依赖的是&lt;code&gt;Spring Framework 5.1.17&lt;/code&gt;版本哦。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;除此之外&lt;/strong&gt;，Spring Boot它的最新版本，也就是2.3.2里还新增了3个新特性，了解一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;改进 Kubernates Liveness/Readiness 健康指标和探针配置&lt;/li&gt;
&lt;li&gt;添加运行镜像选项用于Docker镜像构建&lt;/li&gt;
&lt;li&gt;增加对reactive Elasticsearch的健康检查&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小贴士：小版本号的升级是可以新增这种很小的功能点的，但不允许新增大功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三个版本核心依赖的区别&quot;&gt;三个版本核心依赖的区别&lt;/h2&gt;
&lt;p&gt;Spring Boot目前活跃的分支有3个，也就是这三个&lt;strong&gt;主线版本&lt;/strong&gt;。那么他们三在核心依赖上有啥区别呢？A哥特意翻资料帮你整理了一下，绘制如下表：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;说明：因为表格兼容性不太好，所以我以图片方式展示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725230447674.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于15x和20x版本&quot;&gt;关于1.5.x和2.0.x版本&lt;/h2&gt;
&lt;p&gt;这两个分支已经是古董分支了：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725230905400.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;stale中文意思：不新鲜的，老掉牙的，没有新意的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它们&lt;strong&gt;早已&lt;/strong&gt;寿终正寝，最后一个版本和发布时间为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.5.22.RELEASE，2019.08&lt;/li&gt;
&lt;li&gt;2.0.9.RELEASE，2019.04&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有意思的是，&lt;strong&gt;2.0.x&lt;/strong&gt;版本的生命周期非常的短暂，几乎刚好一年（2018.3 - 2019.4）。但是不可否认2.0.x版本是具有划时代意义的，在1.5.x的基础上垮了一大步，上了一个大台阶。&lt;/p&gt;
&lt;p&gt;所以如果你的项目还在使用这两个版本，特别是1.5.x，那么尽快升级吧。官方推荐的是使用最新的2.3.x分支，这也是当前最为活跃的分支。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小贴士：1.5.x升级到2.x.x属于阻断式升级，需要十分谨慎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Spring Boot作为微服务、云原生开发的基础设施，每个Java开发者都应该理解它、跟上它、学习它，才得以保证自己不掉队，不被&lt;strong&gt;后浪&lt;/strong&gt;拍死。&lt;/p&gt;
&lt;p&gt;但是，如此之快的更新速度，Spring官方是认真的，但你能认真起来吗？歪果仁，这是周末唉，你们不用休息的吗？疫情期间在家办公就这么任性？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200725231628798.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;相关推荐：&quot;&gt;相关推荐：&lt;/h5&gt;
</description>
<pubDate>Mon, 27 Jul 2020 00:45:00 +0000</pubDate>
<dc:creator>YourBatman</dc:creator>
<og:description>你，还学得动吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yourbatman/p/13383542.html</dc:identifier>
</item>
<item>
<title>艺术鬼才！Unicode 字符还能这么玩？ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13383519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13383519.html</guid>
<description>&lt;p&gt;上周的时候，朋友圈的直升飞机不知道为什么就火了，很多朋友开着各种花式飞机带着起飞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082906328-1473022599.jpg&quot; alt=&quot;图片来自网络&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还没来得及了解咋回事来着，这个直升飞机就🔥到的微博热搜。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082906613-1989793929.jpg&quot; alt=&quot;图片来自网络&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后面越来越多人开来他们的直升飞机，盘旋在朋友圈上方。于是很多朋友开来他们的坦克，专打直升飞机，一轰一个准。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082906804-1635280390.jpg&quot; alt=&quot;图片来自网络&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，说回正题！&lt;/p&gt;
&lt;p&gt;程序员朋友应该都很熟悉 &lt;strong&gt;Unicode&lt;/strong&gt; （万国码），它几乎包含世界上所有符号，比如组成直升飞机这几个特殊符号对应的 Unicode 码分别为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082907033-2132445196.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082907235-854318952.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.0194174757282&quot;&gt;
&lt;p&gt;ps:推荐一个网站，可以根据符号搜对应的 Unicode 码：&lt;a href=&quot;https://unicode.yunser.com/unicode&quot;&gt;https://unicode.yunser.com/unicode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了这些正常字符以外，&lt;strong&gt;Unicode&lt;/strong&gt; 还包含着各种各样的奇葩字符。&lt;/p&gt;
&lt;h2 id=&quot;奇葩字符&quot;&gt;奇葩字符&lt;/h2&gt;
&lt;p&gt;除了正常的我们熟知的文字以外，&lt;strong&gt;Unicode&lt;/strong&gt; 中还有一些奇怪的文字，比如下面这些文字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082907389-1176810763.jpg&quot; alt=&quot;这咋读？某少？&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082907541-207627548.jpg&quot; alt=&quot;世代？&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082907685-2061154969.jpg&quot; alt=&quot;恩？超出认知范围&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了这些奇怪文字以外，&lt;strong&gt;Unicode&lt;/strong&gt; 还有一些奇葩的的符号。&lt;/p&gt;
&lt;p&gt;例如下面一整套麻将牌：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082907882-1925634053.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一整套的扑克牌：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082908139-1545103553.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一整套国际象棋：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082908355-1598893557.jpg&quot; alt=&quot;image-20200725215319183&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了这些，通过组合符合，我们还可以造出各种各样的颜文字(๑•̀ㅂ•́)و✧、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082908521-1644428143.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外 Unicode 还收录着我们常用的 &lt;strong&gt;Emoji&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082908695-944617393.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了这些之外，&lt;strong&gt;Unicode&lt;/strong&gt; 中还有一些特殊字符的，利用这些字符，我们还可以玩出很多有趣的骚操作。&lt;/p&gt;
&lt;h2 id=&quot;组合字符&quot;&gt;组合字符&lt;/h2&gt;
&lt;p&gt;Unicode 有一类字符称为组合字符，它可以附加在前一个非组合字符上，从而使整体看起来像是一个字符。&lt;/p&gt;
&lt;p&gt;组合字符原来目的是为了解决一些地区语言、文字特殊的需要，比如说泰文声调符号与母音符号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082908915-1113480002.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082909101-349440802.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正常使用的情况下，这些组合字符数量都会有一些限制。但是在 &lt;strong&gt;Unicode&lt;/strong&gt; 组合字符设计上，并没有加这种限制，这样使我们可以无限加这类组合字符。&lt;/p&gt;
&lt;p&gt;利用这个特性，可以达到一些恶搞效果，比如「击穿天花板」与「凿穿地板」的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082909285-2134240820.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面实现原理其是利用以下两个组合字符：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082909424-1069898345.jpg&quot; alt=&quot;上翻字符&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082909557-1610210817.jpg&quot; alt=&quot;下翻字符&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要复制这两个字符相应的 HTML 代码，跟在正常的字符后面，就可以使这两个字符附加在普通字符上，比如下面实现效果为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-HTML&quot;&gt;黑&amp;amp;#785;&amp;amp;#814;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082909663-1866336195.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Unicode 码值通常使用 &lt;code&gt;U+N&lt;/code&gt;(16 进制N 代表码值)，比如 A 的码值为 U+0041。&lt;/p&gt;
&lt;p&gt;在 HTML 中 Unicode 可以使用 &lt;code&gt;&amp;amp;#N;&lt;/code&gt;(十进制，N 代表码值)表示&lt;/p&gt;
&lt;p&gt;在 JS 中 Unicode 中需要使用] &lt;code&gt;\uN&lt;/code&gt;(16 进制N 代表码值)表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要我们在普通字符多复制几个这类附加字符，就可以形成上述「击穿」效果。&lt;/p&gt;
&lt;p&gt;还记得上面说的泰文吗，曾经有一段时间贴吧，很流行一种喷射文，比如下面的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082909808-1288938512.jpg&quot; alt=&quot;向左喷&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082909922-1320331795.jpg&quot; alt=&quot;向右喷&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082910043-406165732.jpg&quot; alt=&quot;左右互喷&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种喷射文实际原理就是利用泰文中声调符号附加在其他正常符号上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082910222-305418710.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过现在这个效果貌似已经没办法再复现了，现在我们只能看到这样的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082910394-1041625101.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在一些老版本的系统/浏览器可能还能看到这种效果，知道的小伙伴留言区可以告知一下。&lt;/p&gt;
&lt;h2 id=&quot;零宽字符&quot;&gt;零宽字符&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Unicode&lt;/strong&gt; 中还有一类格式字符，不可见，不可打印，主要作用于调整字符的显示格式，所以我们将其称为零宽字符。&lt;/p&gt;
&lt;p&gt;零宽字符主要有以下几类：&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;零宽度空格符 (zero-width space) U+200B : 用于较长单词的换行分隔&lt;/p&gt;
&lt;p&gt;零宽度非断空格符 (zero width no-break space) U+FEFF : 用于阻止特定位置的换行分隔&lt;/p&gt;
&lt;p&gt;零宽度连字符 (zero-width joiner) U+200D : 用于阿拉伯文与印度语系等文字中，使不会发生连字的字符间产生连字效果&lt;/p&gt;
&lt;p&gt;零宽度断字符 (zero-width non-joiner) U+200C : 用于阿拉伯文，德文，印度语系等文字中，阻止会发生连字的字符间的连字效果&lt;/p&gt;
&lt;p&gt;左至右符 (left-to-right mark) U+200E : 用于在混合文字方向的多种语言文本中（例：混合左至右书写的英语与右至左书写的希伯来语），规定排版文字书写方向为左至右&lt;/p&gt;
&lt;p&gt;右至左符 (right-to-left mark) U+200F : 用于在混合文字方向的多种语言文本中，规定排版文字书写方向为右至左&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用零宽字符不不可见的特性，我们也可以玩出一些骚效果。&lt;/p&gt;
&lt;h3 id=&quot;空白微博&quot;&gt;空白微博&lt;/h3&gt;
&lt;p&gt;发布微博的时候，如果内容都是空格，将没办法发布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082910589-1632820025.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果我们将零宽字符，比如说「&lt;strong&gt;零宽度空格符 U+200B&lt;/strong&gt;」复制到微博，这样我们就可以发布空白微博。&lt;/p&gt;
&lt;p&gt;我们可以利用 Chrome 浏览器的控制台复制零宽字符，操作方式如下：&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082910779-866785096.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发布效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082910931-642921256.jpg&quot; alt=&quot;真的没有改 HTML 导致的.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;隐形水印&quot;&gt;隐形水印&lt;/h3&gt;
&lt;p&gt;对于一些内部论坛或者说小说网站来说，可以通过零宽字符在帖子或小说内容嵌入隐形水印。&lt;/p&gt;
&lt;p&gt;当这些内容被一些爬虫复制到其他网站时，我们就可以通过隐形水印，轻松查找时那位用户泄漏内容。&lt;/p&gt;
&lt;p&gt;隐形水印&lt;strong&gt;主要原理&lt;/strong&gt;就是将用户信息比如用户名，通过一定算法转成零宽字符，这样普通用户浏览时完全看不到这个水印。&lt;/p&gt;
&lt;p&gt;如果内容被复制到其他网站，隐形谁赢也被复制，只要找到这个水印，将这些零宽字符反转成用户名即可。&lt;/p&gt;
&lt;p&gt;下面展示一种转换方法，JS 代码主要参考以下 Github 项目：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/umpox/zero-width-detection&quot;&gt;https://github.com/umpox/zero-width-detection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐形水印生成方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步我们需要将明文字符串每个字符都转成二进制串。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;    // 每个字符转为二进制,用空格分隔
    const textToBinary = username =&amp;gt; (
      username
      .split('')
      // charCodeAt 将字符转成相应的 Unicode 码值
      .map(char =&amp;gt; char.charCodeAt(0).toString(2))
      .join(' ')
    );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082911176-137654640.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步，将二进制串转为零度字符串，转换规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 转换为 &lt;strong&gt;\u200b 零宽度字符（zero-width space）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;0 转换为 &lt;strong&gt;\u200c 零宽度断字符（zero-width non-joiner）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其他（剩余就是空格） 转换为 &lt;strong&gt;\u200d 零宽度连字符 (zero-width joiner)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最后使用 &lt;strong&gt;\ufeff 零宽度非断空格符 (zero width no-break space)&lt;/strong&gt; 作为分隔符&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;const binaryToZeroWidth = binary =&amp;gt; (
  binary.split('').map((binaryNum) =&amp;gt; {
    const num = parseInt(binaryNum, 10);
    if (num === 1) {
      return '\u200b'; // \u200b 零宽度字符（zero-width space）
    } else if(num===0) {
      return '\u200c'; // \u200c 零宽度断字符（zero-width non-joiner）
    }
    return '\u200d'; // \u200d 零宽度连字符 (zero-width joiner)

  }).join('\ufeff') // \ufeff 零宽度非断空格符 (zero width no-break space)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终加密方法如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;const encode = username =&amp;gt; {
  const binaryUsername = textToBinary(username);
  const zeroWidthUsername = binaryToZeroWidth(binaryUsername);
  return zeroWidthUsername;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用加密方法将明文字符串加密之后，加密字符串肉眼是看不到了，但是实际还是存在的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082911376-1131971161.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上，如果我们将加密之后字符串复制到 &lt;a href=&quot;https://www.bejson.com/convert/unicode_chinese/&quot;&gt;BEJSON&lt;/a&gt; 网站,就可以看到字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082911510-101441139.jpg&quot; alt=&quot;image-20200722083507869&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外你还可以把加密字符串复制到 IDEA 中，可以看到相应的 Unicode 编码值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082911750-1319095924.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解密隐形水印&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;知道了加密的方式，解密其实就很简单，我们只要按照相反步骤的来就可以了。&lt;/p&gt;
&lt;p&gt;第一步，将隐形水印按照以下规则转换为二进制串。转换规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;strong&gt;\ufeff&lt;/strong&gt; 分隔字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\u200b&lt;/strong&gt; 转为 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\u200c&lt;/strong&gt; 转为 0&lt;/li&gt;
&lt;li&gt;其他字符使用空格&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;const zeroWidthToBinary = string =&amp;gt; (
  string.split('\ufeff').map((char) =&amp;gt; { // \ufeff 零宽度非断空格符 (zero width no-break space)
    if (char === '\u200b') { // \u200b 零宽度字符（zero-width space）
      return '1';
    } else if(char === '\u200c') { // \u200c 零宽度断字符（zero-width non-joiner）
      return '0';
    }
    return ' ';
  }).join('')
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用该方法，隐形水印转成二进制串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082911974-1510751504.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步，将二进制再转为相应的字符。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;const binaryToText = string =&amp;gt; (
  // fromCharCode 二进制转化
  string.split(' ').map(num =&amp;gt; String.fromCharCode(parseInt(num, 2))).join('')
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终解密方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;const decode = zeroWidthUsername =&amp;gt; {
  const binaryUsername = zeroWidthToBinary(zeroWidthUsername);
  const textUsername = binaryToText(binaryUsername);
  return textUsername;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解密示例如下：&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082912194-1772545035.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;短网址&quot;&gt;短网址&lt;/h3&gt;
&lt;p&gt;我们常用的短网址，域名后面会跟上一串随机串，从而实现短网址到长网址的映射。比如以下网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sourl.cn/iLyn9S&quot;&gt;https://sourl.cn/iLyn9S&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然而我们可以利用零宽字符也可以实现短网址的效果，,比如下面这个网站，就可以生成这类短网址。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zws.im/&quot;&gt;https://zws.im/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082912367-1760573334.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这个短网址后面看不到任何字符，实际上这后面跟着一串零宽字符。当浏览器访问该短网址时，后端程序只要反解密的后面零宽字符，拿到相应的网址，然后在做跳转就可以到指定的网站。&lt;/p&gt;
&lt;p&gt;反解密的原理可以参考上面隐形水印的代码&lt;/p&gt;
&lt;h3 id=&quot;小心零宽字符&quot;&gt;小心零宽字符&lt;/h3&gt;
&lt;p&gt;日常开发过程中，我们有时需要从一些文件中读取文本内容，然后做相应的处理。&lt;/p&gt;
&lt;p&gt;有时候我们可能会碰到一些诡异的现象，比如我们之前碰到的例子。&lt;/p&gt;
&lt;p&gt;后台程序从 Excel 读取文本内容，然后程序中判断是读取的文本内容是否与指定的字符串相等。&lt;/p&gt;
&lt;p&gt;然后当我们读取一份 Excel 内容后，返现这段比较逻辑怎么也通过不了。本来以为是 Excel 内容存在空格什么的，但是打开 Excel 仔细一看，跟指定字符串一模一样，并没有什么其他字符。&lt;/p&gt;
&lt;p&gt;第一次碰到这种例子，没有什么经验，真的排查了很久，到最后都有点怀疑人生了。最后无意间将文本内容复制到了 IDEA 中，才发现整理混杂着零宽字符!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082912593-1244110869.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果各位小伙伴也碰到这类问题，不妨将复制文本内容，然后到 IDEA 中查看是否存在某些看不见字符~&lt;/p&gt;
&lt;h2 id=&quot;最后（点个赞呗！）&quot;&gt;最后（点个赞呗！）&lt;/h2&gt;
&lt;p&gt;这两个星期一直很忙，一直都在 9106 的节奏，真的是累，所以断更了一周！&lt;/p&gt;
&lt;p&gt;所幸最近项目提测，稍微轻松了一点，能有点划水时间来写写文章。不过再提起笔来写文章，就有点断节奏了！&lt;/p&gt;
&lt;p&gt;这篇文章墨迹了很久才水出来，下周开始再次恢复周更的节奏，再忙再累，每周都来一篇。&lt;/p&gt;
&lt;p&gt;欢迎各位小伙伴，每周来这里蹲我，Gank 我！！！&lt;/p&gt;
&lt;p&gt;好了，我是楼下小黑哥，下周见！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200727082912731-759789954.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5d3f01e7f265da03c23ead69&quot;&gt;https://juejin.im/post/5d3f01e7f265da03c23ead69&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zero.rovelast.com/&quot;&gt;http://zero.rovelast.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zws.im/&quot;&gt;https://zws.im/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imweb.io/topic/5a08a5c7ef79bc941c30d8dd&quot;&gt;https://imweb.io/topic/5a08a5c7ef79bc941c30d8dd&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 27 Jul 2020 00:29:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>上周的时候，朋友圈的直升飞机不知道为什么就火了，很多朋友开着各种花式飞机带着起飞。 还没来得及了解咋回事来着，这个直升飞机就&amp;amp;#128293;到的微博热搜。 后面越来越多人开来他们的直升飞机，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13383519.html</dc:identifier>
</item>
<item>
<title>.Net Core in Docker极简入门（下篇） - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13357781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13357781.html</guid>
<description>&lt;p&gt;Tips：本篇已加入&lt;a href=&quot;https://www.cnblogs.com/xhznl/p/13259036.html&quot; target=&quot;_blank&quot;&gt;系列文章阅读目录&lt;/a&gt;，可点击查看更多相关文章。&lt;/p&gt;


&lt;p&gt;上一篇【&lt;a href=&quot;https://www.cnblogs.com/xhznl/p/13353095.html&quot;&gt;.Net Core in Docker极简入门（上篇）&lt;/a&gt;】讲解了docker的一些基本命令和操作，并成功构建了自己的asp.net core web应用的镜像，启动容器。本篇继续。&lt;/p&gt;

&lt;p&gt;上一篇的项目例子非常简单，通常我们的实际项目要复杂的多。项目中会依赖各种组件服务，比如数据库，MQ，缓存等等。这就会涉及到多个容器，如果手动用docker命令去一个一个的启动就很麻烦了，那么这时候就可以使用Docker-Compose来完成多个容器的管理。&lt;/p&gt;
&lt;h2 id=&quot;docker-compose&quot;&gt;Docker-Compose&lt;/h2&gt;
&lt;p&gt;什么是Docker Compose？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来理解，Compose类似一个批量工具，可以执行一组命令，支持批量构建镜像，批量启动容器，批量删除容器等等功能。&lt;/p&gt;
&lt;p&gt;Windows的Docker Desktop中已经包括了Compose，Linux下Compose则需要单独安装一下。&lt;/p&gt;
&lt;p&gt;下面在项目中添加一些数据库操作的相关代码便于测试，使用EF Core+SQL Server。&lt;/p&gt;
&lt;h3 id=&quot;代码修改&quot;&gt;代码修改&lt;/h3&gt;
&lt;p&gt;安装EF Code相关的包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721113041488-941061223.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class WeatherForecast
{
    [Key]
    public int Id { get; set; }

    public DateTime Date { get; set; }

    public int TemperatureC { get; set; }

    public int TemperatureF { get; set; }

    public string Summary { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class DemoContext : DbContext
{
    public DemoContext(DbContextOptions&amp;lt;DemoContext&amp;gt; options)
        : base(options)
    {

    }

    public DbSet&amp;lt;WeatherForecast&amp;gt; WeatherForecasts { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        //初始化种子数据
        modelBuilder.Entity&amp;lt;WeatherForecast&amp;gt;().HasData(new WeatherForecast
        {
            Id = 1,
            Date = DateTime.Now,
            Summary = &quot;none&quot;,
            TemperatureC = 20,
            TemperatureF = 32 + (int)(20 / 0.5556)
        }, new WeatherForecast
        {
            Id = 2,
            Date = DateTime.Now.AddDays(1),
            Summary = &quot;none&quot;,
            TemperatureC = 25,
            TemperatureF = 32 + (int)(25 / 0.5556)
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Startup
{
    ......
        
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();

        services.AddDbContext&amp;lt;DemoContext&amp;gt;(opt =&amp;gt; opt.UseSqlServer(Configuration.GetConnectionString(&quot;DemoContext&quot;)));
    }
    
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env, DemoContext context)
    {
        //自动迁移
        context.Database.Migrate();

        ......
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class WeatherForecastController : ControllerBase
{
    private readonly ILogger&amp;lt;WeatherForecastController&amp;gt; _logger;
    private readonly DemoContext _context;

    public WeatherForecastController(ILogger&amp;lt;WeatherForecastController&amp;gt; logger, DemoContext context)
    {
        _logger = logger;
        _context = context;
    }

    [HttpGet]
    public IEnumerable&amp;lt;WeatherForecast&amp;gt; Get()
    {
        return _context.WeatherForecasts.ToArray();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;appsettings.json添加数据库连接字符串配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  ......
  
  &quot;ConnectionStrings&quot;: {
    &quot;DemoContext&quot;: &quot;Server=sql-server;Database=DemoDB;User Id=sa;Password=Password@2020;&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：Server=sql-server，这个sql-server是需要在docker-compose.yml中定义的，下面再说。&lt;/p&gt;
&lt;p&gt;添加迁移：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721144943560-1897298717.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;yml-file&quot;&gt;yml file&lt;/h3&gt;
&lt;p&gt;右键项目-添加-容器业务流程协调程序支持&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721095027287-1541923640.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加后会生成docker-compose相关文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721145135508-2012645134.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的docker-compose.yml文件需要修改一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;version: '3.4'

services:
  webapplication1:
    image: ${DOCKER_REGISTRY-}webapplication1
    build:
      context: .
      dockerfile: WebApplication1/Dockerfile
    ports: 
      - '5000:80'
    networks:
      - my-net
    depends_on:
      - sql-server

  sql-server:
    image: mcr.microsoft.com/mssql/server:2019-CU5-ubuntu-18.04
    ports: 
      - '1434:1433'
    environment: 
      ACCEPT_EULA: Y
      SA_PASSWORD: Password@2020
    networks: 
      - my-net

networks: 
  my-net: 
    driver: bridge 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;services下定义了2个服务webapplication1、sql-server，相当于2个容器。webapplication1是基于WebApplication1/Dockerfile构建的镜像${DOCKER_REGISTRY-}webapplication1来启动，depends_on用于指定依赖的服务，这里的webapplication1服务依赖于sql-server服务。networks用于指定网络，因为docker中容器之间默认是无法直接通信的，这里创建了一个bridge模式的网络my-net，webapplication1和sql-server都在my-net网络中，那么他们之间就可以通过服务名来通信。所以在上面webapplication1的数据库连接字符串中就可以写：Server=sql-server。通常数据库的数据目录会挂载到主机上，防止容器发生意外导致数据丢失。&lt;/p&gt;
&lt;p&gt;上一篇有小伙伴问容器内能不能访问容器外的数据库，这个是可以访问的。访问宿主机的话直接用IP访问就可以，或者用&lt;code&gt;host.docker.internal&lt;/code&gt;，这个host.docker.internal是docker安装时会写入到你的hosts文件里的一个主机名，实际还是指向你的主机IP。&lt;/p&gt;
&lt;p&gt;以上的yml内容还是比较简单，yml文件是使用Compose必不可少的，语法可以自行学习一下。掌握其语法关键字后，你就可以在docker-compose.yml文件中定义更复杂的环境。&lt;/p&gt;
&lt;h3 id=&quot;up--down&quot;&gt;up &amp;amp; down&lt;/h3&gt;
&lt;p&gt;来到项目根目录，启动PowerShell或cmd执行docker命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721153646176-1760174103.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;docker-compose up&lt;/code&gt;，也可以加-d参数，让他在后台运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721153830988-2058859466.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动完成后，浏览器访问：&lt;a href=&quot;http://localhost:5000/weatherforecast&quot;&gt;http://localhost:5000/weatherforecast&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721154058075-1491616276.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功。这里省略了&lt;code&gt;docker-compose build&lt;/code&gt;命令，你也可以在up前先执行build。&lt;/p&gt;
&lt;p&gt;docker-compose是不是很方便呢，即使你的系统环境部署再复杂，也只需要一个up指令。&lt;/p&gt;
&lt;p&gt;如果你想摧毁这个环境只需要执行&lt;code&gt;docker-compose down&lt;/code&gt;即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721155008767-597745884.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的，以上操作也可以直接在vs2019中完成，无需手动执行指令，只需要将docker-compose项目设为启动项，然后直接运行即可，还支持代码调试哦。不过由于网络等问题，可能会遇到一些坑。。。&lt;/p&gt;
&lt;h2 id=&quot;镜像仓库&quot;&gt;镜像仓库&lt;/h2&gt;
&lt;p&gt;我们也可以把自己的镜像推送到远程仓库，然后在其他机器上直接就能通过命令拉取了。国内阿里云之类的都有docker镜像仓库服务，也可以搭建私有仓库，本文就推送到docker的官方仓库docker hub。首先需要在docker官网https://www.docker.com/注册账号。&lt;/p&gt;
&lt;p&gt;重新构建镜像：&lt;code&gt;docker build -t xhznl/webapp1 -f ./WebApplication1/Dockerfile .&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中xhznl是我的docker用户名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721200613757-1841259185.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录docker： &lt;code&gt;docker login&lt;/code&gt;，输入自己的用户名密码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721200744941-1546213685.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录成功后即可推送镜像，执行：&lt;code&gt;docker push xhznl/webapp1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721200943979-977254262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推送成功，在docker官网可以查看镜像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200721201025080-134863490.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样在其他机器的docker中也可以通过&lt;code&gt;docker pull xhznl/webapp1&lt;/code&gt;来拉取这个镜像。&lt;/p&gt;
&lt;p&gt;修改docker-compose.yml文件，将webapplication1服务的image改为xhznl/webapp1，然后把这个docker-compose.yml文件放到任何装有docker的机器上，只需执行&lt;code&gt;docker-compose up&lt;/code&gt;，即可启动程序的所有环境，是不是很神奇。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;services:
  webapplication1:
    image: xhznl/webapp1
    ports: 
      - '5000:80'
    networks:
      - my-net
    depends_on:
      - sql-server
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后推荐一波vs code，安装docker相关插件，无论是编写yml文件还是管理docker都很方便， 很多操作都不用手敲命令啦。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200722100153719-1559793559.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Docker作为当今最流行的容器技术，是很多技术架构的基础。它有很多的优点，使用中也会面临各种问题，希望本篇入门文章能够帮助到一些初学的小伙伴。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jul 2020 00:22:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>Tips：本篇已加入系列文章阅读目录，可点击查看更多相关文章。 前言 上一篇【.Net Core in Docker极简入门（上篇）】讲解了docker的一些基本命令和操作，并成功构建了自己的asp.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13357781.html</dc:identifier>
</item>
<item>
<title>Web优化躬行记（2）——JavaScript - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13214314.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13214314.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）慎用全局变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当变量暴露在全局作用域中时，由于全局作用域比较复杂，因此查找会比较慢。&lt;/p&gt;
&lt;p&gt;　　并且还有可能污染window对象，覆盖之前所赋的值，发生意想不到的错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
0 == ''     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
0 == '0'    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）简写&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　简写的方式很多，此处只会列举其中的几种，例如用三目运算替代if-else语句，或用&amp;amp;&amp;amp;或||符号替代条件语句。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (count &amp;gt; 1&lt;span&gt;) {
  &lt;/span&gt;++&lt;span&gt;a;
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;--&lt;span&gt;a;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 简写&lt;/span&gt;
count &amp;gt; 1 ? (++a) : (--&lt;span&gt;a);

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (count) {
  &lt;/span&gt;++&lt;span&gt;a;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 简写&lt;/span&gt;
count &amp;amp;&amp;amp; (++a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　利用ES6语法，可以用解构赋值，简洁明了。还有些小技巧包括用箭头函数表示回调，块级作用域变量等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
const { count } = obj;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　关于去除数组中的重复数，可以采用ES6最新的Set数据结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Array.from(&lt;span&gt;new&lt;/span&gt; Set(arr));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）减少魔法数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　魔法数是指意义不明的常量，例如直接在代码中使用一个数字1，其判断条件令人费解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(type == 1) { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而如果将该数字赋给一个语义化的常量后，就能明确其意图。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const ERROR_TYPE = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type == ERROR_TYPE) { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）位运算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用位运算取代纯数学操作，例如对2取模（digit%2）判断偶数与奇数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (digit &amp;amp; 1&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 奇数（odd）&lt;/span&gt;
} &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 偶数（even）&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　位掩码技术，使用单个数字的每一位来判断选项是否成立。掩码中每个选项的值都是2的幂。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; OPTION_A = 1, OPTION_B = 2, OPTION_C = 4, OPTION_D = 8, OPTION_E = 16&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用按位或运算创建一个数字来包含多个设置选项&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; options = OPTION_A | OPTION_C |&lt;span&gt; OPTION_D;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接下来可以用按位与操作来判断给定的选项是否可用&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;选项A是否在列表中&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(options &amp;amp;&lt;span&gt; OPTION_A) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用按位左移（&amp;lt;&amp;lt;）做乘法，用按位右移做除法（&amp;gt;&amp;gt;），例如digit*2可以替换成digit&amp;lt;&amp;lt;2。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）字符串拼接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　除了使用加号（+）或加等（+=）实现字符串拼接之外，还可以使用数组的join()和字符串的concat()方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[&quot;strick&quot;, &quot;jane&quot;].join(&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&quot;strick&quot;.concat(&quot;jane&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ES6提供的模板字面量是一种能够嵌入表达式的格式化字符串，也可以用来做字符串拼接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
str = &quot;My name is \&quot;&quot; + name + &quot;\&quot;. M y age is &quot; + age + &quot;.&quot;;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传统拼接方式&lt;/span&gt;
str = `My name is &quot;${name}&quot;. My age is ${age}.`;        　　　　     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;模板字面量方式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7）正则优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　正则优化包括：&lt;/p&gt;
&lt;p&gt;　　1. 减少分支数量，缩小分支范围；&lt;/p&gt;
&lt;p&gt;　　2. 使用非捕获数组；&lt;/p&gt;
&lt;p&gt;　　3. 只捕获感兴趣的文本以减少后期处理；&lt;/p&gt;
&lt;p&gt;　　4. 使用合适的量词；&lt;/p&gt;
&lt;p&gt;　　5. 化繁为简，分解复杂的正则。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8）惰性模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　惰性模式用于减少每次代码执行时的重复性分支判断，通过对对象重定义来屏蔽原对象中的分支判断。&lt;/p&gt;
&lt;p&gt;　　惰性模式分为两种：第一种文件加载后立即执行对象方法来重定义，第二种是当第一次使用方法对象时来重定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; A =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载时 损失性能 第一次加载时 不损失性能&lt;/span&gt;
A.on = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dom, type, fn) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dom.addEventListener) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dom, type, fn) {
      dom.addEventListener(type, fn, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    };
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dom.attachEvent) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dom, type, fn) {
      dom.attachEvent(&lt;/span&gt;&quot;on&quot; +&lt;span&gt; type, fn);
    };
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dom, type, fn) {
      dom[&lt;/span&gt;&quot;on&quot; + type] =&lt;span&gt; fn;
    };
  }
})();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载时 不损失性能 第一次加载时 损失性能&lt;/span&gt;
A.on = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dom, type, fn) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dom.addEventListener) {
    A.on &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dom, type, fn) {
      dom.addEventListener(type, fn, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    };
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dom.attachEvent) {
    A.on &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dom, type, fn) {
      dom.attachEvent(&lt;/span&gt;&quot;on&quot; +&lt;span&gt; type, fn);
    };
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    A.on &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dom, type, fn) {
      dom[&lt;/span&gt;&quot;on&quot; + type] =&lt;span&gt; fn;
    };
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行重定义on方法&lt;/span&gt;
&lt;span&gt;  A.on(dom, type, fn);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9）使用缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当执行for循环时，需要读取数组的长度，可以事先做缓存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (let i = 0, len = arr.length; i &amp;lt; len; i++) {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　或者在事件处理程序或对象方法中缓存this指向。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
  name: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    let self &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  }
};
btn.addEventListener(&lt;/span&gt;&quot;click&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  let self &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10）记忆函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　记忆函数是指能够缓存先前计算结果的函数，避免重复执行不必要的复杂计算，是一种用空间换时间的编程技巧。&lt;/p&gt;
&lt;p&gt;　　具体的实施可以有多种写法，例如创建一个缓存对象，每次将计算条件作为对象的属性名，计算结果作为对象的属性值。&lt;/p&gt;
&lt;p&gt;　　下面的代码用于判断某个数是否是质数（质数又叫素数，是指一个大于1的自然数，除了1和它本身外，不能被其它自然数整除的数），在每次计算完成后，就将计算结果缓存到函数的自有属性digits内。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; prime(number) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;prime.digits) {
    prime.digits &lt;/span&gt;= {};     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存对象&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prime.digits[number] !==&lt;span&gt; undefined) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; prime.digits[number];
  }
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isPrime = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 2; i &amp;lt; number; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (number % i == 0&lt;span&gt;) {
      isPrime &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; number) {
    isPrime &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (prime.digits[number] =&lt;span&gt; isPrime);
}
prime(&lt;/span&gt;87&lt;span&gt;);
prime(&lt;/span&gt;17&lt;span&gt;);
console.log(prime.digits[&lt;/span&gt;87]);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
console.log(prime.digits[17]);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11）闭包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通常来说，函数的活动对象会随着执行环境一同销毁。但引入闭包时，由于引用仍然存在于闭包的作用域中，因此对象无法被销毁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; outter(count) {
  count&lt;/span&gt;++&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 闭包&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; inner() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; count + 1&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这意味着闭包需要更多的内存开销。在脚本编程中，要小心地使用闭包。&lt;/p&gt;
&lt;p&gt;　　推荐将跨作用域的变量存储到一个局部变量中，然后直接访问该局部变量，如下所示，将count作为参数传递给inner()函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; outter(count) {
  count&lt;/span&gt;++&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 闭包&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; inner(count) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; count + 1&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner(count);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;12）节流和去抖动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　节流（throttle）是指预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。适用于mousemove事件、window对象的resize和scroll事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; throttle(fn, wait) {
  let start &lt;/span&gt;= 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; () =&amp;gt;&lt;span&gt; {
    const now &lt;/span&gt;= +&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (now - start &amp;gt;&lt;span&gt; wait) {
      fn();
      start &lt;/span&gt;=&lt;span&gt; now;
    }
  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　去抖动（debounce）是指当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。适用于文本输入的keydown事件，keyup事件，做autocomplete等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; debounce(fn, wait) {
  let start &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; () =&amp;gt;&lt;span&gt; {
    clearTimeout(start);
    start &lt;/span&gt;=&lt;span&gt; setTimeout(fn, wait);
  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　节流与去抖动最大的不同的地方就是在计算最后执行时间的方式上。著名的开源工具库underscore中有内置了两个方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）合理放置脚本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　脚本会阻塞页面渲染，直至全部下载并执行完成后，页面渲染才会继续。浏览器在解析到body元素之前，不会渲染页面的任何部分。&lt;/p&gt;
&lt;p&gt;　　把脚本放在页面顶部会导致明显的延迟，通常表现为空白页面。因此推荐将所有script元素尽可能放到body元素底部。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）无阻塞脚本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　为了解决阻塞的问题，script元素新增了两个布尔属性，分别是延迟（defer）和异步（async）。&lt;/p&gt;
&lt;p&gt;　　1. defer：延迟脚本执行，直到文档解析完成。&lt;/p&gt;
&lt;p&gt;　　2. async：尽快执行脚本，不会阻塞文档解析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;scripts/jquery.js&quot;&lt;/span&gt;&lt;span&gt; defer&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;scripts/jquery.js&quot;&lt;/span&gt;&lt;span&gt; async&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）动态脚本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用JavaScript动态创建script元素，文件的下载和执行过程不会阻塞页面其它进程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; hm = document.createElement(&quot;script&quot;&lt;span&gt;);
hm.src &lt;/span&gt;= &quot;//www.pwstrick.com/hm.js&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = document.getElementsByTagName(&quot;script&quot;)[0&lt;span&gt;];
s.parentNode.insertBefore(hm, s);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）图像上传&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在上传图像时，可将其转换成Base64，相当于将图像做成字符串传送到后台。在下面的示例中用到了&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;FileReader&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader();
reader.readAsDataURL(file);
reader.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; img = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Image();
  img.src &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.result;
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.result);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，Base64图像会比原图要大。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）原生方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　JavaScript引擎提供的原生方法总是最快的。因为原生方法存在于浏览器中，并且都是用低级语言编写的。&lt;/p&gt;
&lt;p&gt;　　这意味着它们会被编译成机器码，成为浏览器的一部分，不会像自己写的JavaScript代码那样受到各种限制。&lt;/p&gt;
&lt;p&gt;　　CSS查询被JavaScript原生支持并被jQuery发扬光大。jQuery的选择器引擎虽然很快，但是仍然比原生方法慢。&lt;/p&gt;
&lt;p&gt;　　推荐使用原生的querySelector和querySelectorAll()作为选择器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）本地缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在HTML5的本地缓存出现之前，都喜欢用cookie缓存数据。但cookie数据量只有4KB左右，并且每次都会携带在HTTP首部中，如果使用cookie保存过多数据会带来性能问题。&lt;/p&gt;
&lt;p&gt;　　而&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;localStorage&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;和&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;sessionStorage&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;数据量一般在2.5M到10M之间（大部分是5M），并且不参与和服务器之间的通信，因此比较容易实现网页或应用的离线化。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7）重排和重绘&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当DOM的变化影响了元素的几何属性（宽和高）将会发生重排（reflow），发生重排的情况如下所列。&lt;/p&gt;
&lt;p&gt;　　1. 添加或删除可见的DOM元素&lt;/p&gt;
&lt;p&gt;　　2. 元素位置改变&lt;/p&gt;
&lt;p&gt;　　3. 元素尺寸改变（包括外边距、内边距、边框宽度、宽、高等属性）&lt;/p&gt;
&lt;p&gt;　　4. 内容改变，例如文本改变或图片被不同尺寸的替换掉。&lt;/p&gt;
&lt;p&gt;　　5. 页面渲染器初始化。&lt;/p&gt;
&lt;p&gt;　　6. 浏览器窗口尺寸改变。&lt;/p&gt;
&lt;p&gt;　　完成重排后，浏览器会重新绘制受影响的部分到屏幕中，此过程为重绘（repaint）。&lt;/p&gt;
&lt;p&gt;　　下面代码看上去会重排3次，但其实只会重排1次，大多数浏览器通过队列化修改和批量显示优化重排版过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渲染树变化的排队和刷新&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ele = document.getElementById('myDiv'&lt;span&gt;);
ele.style.borderLeft &lt;/span&gt;= '1px'&lt;span&gt;;
ele.style.borderRight &lt;/span&gt;= '2px'&lt;span&gt;;
ele.style.padding &lt;/span&gt;= '5px';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但下列操作将会强迫队列刷新并要求所有计划改变的部分立刻应用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;offsetTop, offsetLeft, offsetWidth, offsetHeight 
scrollTop, scrollLeft, scrollWidth, scrollHeight 
clientTop, clientLeft, clientWidth, clientHeight 
getComputedStyle() (currentStyle &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; IE)（在 IE 中此函数称为 currentStyle） 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　像offsetHeight属性需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理变化”并触发重排以返回正确的值。&lt;/p&gt;
&lt;p&gt;　　最小化重绘和重排的方式有两种：&lt;/p&gt;
&lt;p&gt;　　1. cssText和class，cssText可以一次设置多个CSS属性。class也可以一次性设置，并且更清晰，更易于维护，但有前提条件，就是不依赖于运行逻辑和计算的情况。&lt;/p&gt;
&lt;p&gt;　　2. 批量修改DOM，包括隐藏元素display:none，修改后重新显示display:block；使用文档片段fragment，在片段上操作节点，再拷贝回文档；将原始元素拷贝到一个脱离文档的节点中（例如position:absolute），修改副本，完成后再替换原始元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8）定时器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　为了不让一些复杂的JavaScript任务阻塞线程，就需要将其让出线程的控制权，即停止执行，可以通过定时器实现。&lt;/p&gt;
&lt;p&gt;　　当函数运行时间太长时，可以把它拆分成一系列更小的步骤，把每个独立的方法放到定时器中回调，如下所示，其中arguments.callee是指当前正在执行的函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let tasks =&lt;span&gt; [openDocumnet, writeText, closeDocument, updateUI];
setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行下一个任务&lt;/span&gt;
  let task =&lt;span&gt; tasks.shift();
  task();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否还有其他任务&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (tasks.length &amp;gt; 0&lt;span&gt;) {
    setTimeout(arguments.callee, &lt;/span&gt;25&lt;span&gt;);
  }
}, &lt;/span&gt;25);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9）动画&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　JavaScript早期的动画是用定时器实现的，但随着浏览器功能的不断完善，出现了一种更新、性能更高的方法：&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;requestAnimationFrame()&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　requestAnimationFrame()会在重绘之前更新下一帧的动画，注意，回调函数自身必须再次调用requestAnimationFrame()，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; step(timestamp) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; progress = timestamp -&lt;span&gt; start;
  element.style.left &lt;/span&gt;= Math.min(progress / 10, 200) + 'px'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (progress &amp;lt; 2000&lt;span&gt;) {
    window.requestAnimationFrame(step);
  }
}
window.requestAnimationFrame(step);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10）Ajax&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最快的Ajax请求是没有请求，即避免发送不必要的请求，例如：&lt;/p&gt;
&lt;p&gt;　　1. 在服务端，设置HTTP首部信息以确保响应会被浏览器缓存。&lt;/p&gt;
&lt;p&gt;　　2. 在客户端，把获取到的信息缓存到本地。&lt;/p&gt;
&lt;p&gt;　　其它加速Ajax的技术包括：&lt;/p&gt;
&lt;p&gt;　　1. 数据格式采用轻量级的JSON，解析速度快，通用性与XML相当。&lt;/p&gt;
&lt;p&gt;　　2. 缩短页面加载时间，主要内容加载后，再用Ajax获取次要文件。&lt;/p&gt;
&lt;p&gt;　　3. 确保代码的健壮性，错误不会输出给用户。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11）DOMContentLoaded&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当初始的HTML文档被完全加载和解析完成之后，&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;DOMContentLoaded&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;事件被触发，而无需等待样式表、图像等资源的完全加载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
document.addEventListener(&quot;DOMContentLoaded&quot;, &lt;span&gt;function&lt;/span&gt;() { }, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另一个load事件应该仅用于检测一个完全加载的页面。&lt;/p&gt;
&lt;p&gt;　　注意，DOMContentLoaded事件必须等待其所属script之前的样式表加载解析完成后才会触发。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;12）事件委托&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　事件委托（event delegation）是一种提高程序性能、降低内存空间的技术手段，它利用了事件冒泡的特性，只需在某个祖先元素上注册一个事件，就能管理其所有后代元素上同一类型的事件。&lt;/p&gt;
&lt;p&gt;　　通过事件对象的target属性，就能分辨出当前运行在哪个事件目标上，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
container.addEventListener(&quot;click&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  event.target;
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用委托后就能避免对容器中的每个子元素注册事件，并且如果在容器中动态添加子元素，新加入的子元素也能使用容器元素上注册的事件，而不用再单独绑定一次事件处理程序。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;13）SSR&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　服务器端渲染（&lt;span&gt;&lt;a href=&quot;https://juejin.im/post/5def0816f265da33aa6aa7fe&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;SSR&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）是指将单页应用（SPA）在服务器端渲染成HTML片段，发送到浏览器，然后交由浏览器为其绑定状态与事件，成为完全可交互页面的过程。&lt;/p&gt;
&lt;p&gt;　　其优点是：&lt;/p&gt;
&lt;p&gt;　　1. 更快的首屏加载速度，无需等待JavaScript完成下载且执行之后才显示内容。&lt;/p&gt;
&lt;p&gt;　　2. 更友好的SEO，爬虫可以直接抓取渲染之后的页面。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;14）MVVM&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　MVVM模式是指视图和数据之间的双向互通，视图的修改会反映给数据，反之亦然。&lt;/p&gt;
&lt;p&gt;　　目前市面上许多库和框架都会采用MVVM模式的思想，其提升的并不在于性能，而是开发效率，鼓励开发者操作数据更新视图，由库或框架最低限度的操作DOM，减少回流。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;15）虚拟DOM&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　虚拟DOM（Virtual DOM）是构建在真实DOM之上的一层抽象，它将DOM元素映射成内存中的JavaScript对象（即通过React.createElement()得到的React元素），形成一棵JavaScript对象树。&lt;/p&gt;
&lt;p&gt;　　虚拟DOM与模板引擎有些相似，将多次的DOM操作先在映射的JavaScript对象中处理，再将该对象一次性挂载到真实的DOM树上，避免因浏览器重排导致的大量无用计算。&lt;/p&gt;
&lt;p&gt;　　同构应用也是基于虚拟DOM实现的，虚拟DOM的思想还可应用于其它方面，例如&lt;span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/103253120&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;JavaScript录像回放&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）history&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　浏览器中的历史浏览记录就像一堆层叠的卡片，在HTML4中，可以使用window.history对象来控制历史记录的跳转。&lt;/p&gt;
&lt;p&gt;　　HTML5引进了history.pushState()方法和history.replaceState()方法，允许逐条地添加和修改历史记录条目。这些方法可以协同window.onpopstate事件一起工作。&lt;/p&gt;
&lt;p&gt;　　利用全新的history对象，就能让&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/4523995.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Ajax&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;就像重定向到新页面一样，拥有能够返回上一页或进入下一页的功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）Web Worker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Web Worker可以在主线程（通常是UI线程）之外运行代码，当在独立线程中执行费时的任务时，就能避免主线程被阻塞。&lt;/p&gt;
&lt;p&gt;　　注意，由于Web Worker没有绑定UI线程，因此它们不能访问浏览器的许多资源，例如从外部线程修改DOM会导致界面出现错误。&lt;/p&gt;
&lt;p&gt;　　由于Web Worker有着不同的全局运行环境，因此需要创建一个完全独立的JavaScript文件，其中包含了需要在Worker中运行的代码。&lt;/p&gt;
&lt;p&gt;　　例如下面的code.js，其中message事件用于接收信息，postMessage()方法用于发送信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; worker = &lt;span&gt;new&lt;/span&gt; Worker(&quot;code.js&quot;&lt;span&gt;);
worker.onmessage &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
  console.log(event.data);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;hello strick&quot;&lt;/span&gt;
&lt;span&gt;};
worker.postMessage(&lt;/span&gt;&quot;strick&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; code.js的内部代码&lt;/span&gt;
self.onmessage = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; text =&lt;span&gt; `hello ${event.data}`;
  self.postMessage(text);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Worker通过importScripts()方法加载外部JavaScript文件，它的调用过程是阻塞式的，直到所有文件加载并执行完成之后，脚本才会继续运行。注意，不会影响UI响应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
importScripts(&quot;foo1.js&quot;, foo2.js);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Web Worker的实际应用包括解析大JSON字符串，计算复杂数学运算（例如图像或视频处理），大数组排序，任何超过100ms的处理过程，都应该考虑Worker方案。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）Service Worker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Service Worker是谷歌发起的实现PWA（Progressive Web App，渐进式Web应用）的一个关键角色，它相当于Web应用与浏览器之间的一台代理服务器。&lt;/p&gt;
&lt;p&gt;　　Service Worker会在后台启动一条Worker线程（不能访问DOM），其工作是把一些资源缓存起来（跨域资源无法缓存），然后拦截页面的HTTPS请求，如果缓存中有，就从缓存里取，响应200，没有就走正常的请求流程。&lt;/p&gt;
&lt;p&gt;　　Service Worker结合Web App Manifest能完成离线使用、断网时返回200、将一个图标添加到桌面上等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）WebAssembly&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将繁重的计算（如Web游戏）任务抽离到WebAssembly（WASM）中，它是一种二进制指令格式，被设计为一种用高级语言（如C/C++/Rust）编译的可移植对象。&lt;/p&gt;
&lt;p&gt;　　WebAssembly的目的并不是替代JavaScript，而是与JavaScript共存，允许两者一起工作。&lt;/p&gt;
&lt;p&gt;　　通过使用WebAssembly的JavaScript接口，你可以把WebAssembly模块加载到一个JavaScript应用中，这样在同一个应用中就能同时享用WebAssembly的性能和JavaScript的灵活。&lt;/p&gt;
&lt;p&gt;　　下载一个&lt;span&gt;&lt;a href=&quot;https://raw.githubusercontent.com/mdn/webassembly-examples/master/js-api-examples/simple.wasm&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;simple.wasm&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;示例，其内容如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(module
  (func $i (import &lt;/span&gt;&quot;imports&quot; &quot;imported_func&quot;&lt;span&gt;) (param i32))
  (func (export &lt;/span&gt;&quot;exported_func&quot;&lt;span&gt;)
    i32.const &lt;/span&gt;42&lt;span&gt;
    call $i
  )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于内部函数$i是从imports.imported_func导入的，因此需要创建一个对象来反映simple.wasm中的两级命名空间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let importObject =&lt;span&gt; {
  imports: {
    imported_func: (arg) &lt;/span&gt;=&amp;gt;&lt;span&gt; console.log(arg)
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在加载wasm文件后，使其在Array Buffer中可用，然后就可以使用导出函数了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
fetch(&quot;simple.wasm&quot;&lt;span&gt;)
  .then((res) &lt;/span&gt;=&amp;gt;&lt;span&gt; res.arrayBuffer())
  .then((bytes) &lt;/span&gt;=&amp;gt;&lt;span&gt; WebAssembly.instantiate(bytes, importObject))
  .then((results) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    results.instance.exports.exported_func();
  });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 27 Jul 2020 00:19:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、语言 1）慎用全局变量 当变量暴露在全局作用域中时，由于全局作用域比较复杂，因此查找会比较慢。 并且还有可能污染window对象，覆盖之前所赋的值，发生意想不到的错误。 0 == &amp;#39;&amp;#3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13214314.html</dc:identifier>
</item>
<item>
<title>小书MybatisPlus第9篇-常用字段默认值自动填充 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13383476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13383476.html</guid>
<description>&lt;p&gt;本文为Mybatis Plus系列文章的第9篇，前8篇访问地址如下：&lt;/p&gt;
&lt;h2 id=&quot;一、填充字段处理&quot;&gt;一、填充字段处理&lt;/h2&gt;
&lt;p&gt;需求案例：在插入数据的时候自动填充createTime和updateTime为当前插入数据的时间，在数据更新的时候修改updateTime为修改数据的时间。不需要人为的手动赋值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在数据库表层面需要先添加2个日期类型的字段create_tme和update_time&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200727075458693-367585467.png&quot; alt=&quot;填充字段处理-数据库新建字段&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用@TableField注解标记实体类中的哪些字段需要填充：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Data
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;

    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FieldFill是一个枚举，用于指定在何种情况下会自动填充，有如下几种可选值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DEFAULT：默认不处理&lt;/li&gt;
&lt;li&gt;INSERT：插入时自动填充字段&lt;/li&gt;
&lt;li&gt;UPDATE：更新时自动填充字段&lt;/li&gt;
&lt;li&gt;INSERT_UPDATE：插入和更新时自动填充字段&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、自定义填充默认数值&quot;&gt;二、自定义填充默认数值&lt;/h2&gt;
&lt;p&gt;编写公共字段填充处理器类，该类继承了MetaObjectHandler类，重写 insertFill和updateFill方法，我们在这两个方法中获取需要填充的字段以及默认填充的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;填充处理器MyMetaObjectHandler在Spring Boot中需要声明@Component或@Bean注入&lt;/li&gt;
&lt;li&gt;strictInsertFill和strictUpdateFill方法第二个参数写的是实体类里的属性名，不是对应数据库字段名。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
 
    @Override
    public void insertFill(MetaObject metaObject) {
        this.strictInsertFill(metaObject, &quot;createTime&quot;, Date.class, new Date());
        this.strictInsertFill(metaObject, &quot;updateTime&quot;, Date.class, new Date());
    }
 
    @Override
    public void updateFill(MetaObject metaObject) {
        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, Date.class, new Date());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是3.3.0后面的版本，比如3.3.1.8，也可以改用下面更简单的写法（3.3.0不要用该方法，有bug）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
 
    @Override
    public void insertFill(MetaObject metaObject) {
        this.fillStrategy(metaObject, &quot;createTime&quot;, new Date());
        this.fillStrategy(metaObject, &quot;updateTime&quot;, new Date());
    }
 
    @Override
    public void updateFill(MetaObject metaObject) {
        this.fillStrategy(metaObject, &quot;updateTime&quot;, new Date());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一些比较旧的版本，为填充字段设置值的API如下，3.3.0之后已经不建议使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject);
 this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、开始测试&quot;&gt;三、开始测试&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;插入一条数据，注意我们没有为createTime和updateTime赋值&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Test
public void testInsert() {
  User user = new User();
  user.setName(&quot;字母哥&quot;);
  user.setAge(18);

  userMapper.insert(user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是运行的结果是：createTime和updateTime被自动赋值&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200727075458882-1797427303.png&quot; alt=&quot;createTime和updateTime被自动赋值&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据Id更新一条数据，注意我们没有为updateTime赋值&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Test
public void testUpdate() {
  User user = new User();
  user.setId(1287387821681790977L);
  user.setName(&quot;字母哥&amp;amp;curry&quot;);
  user.setAge(18);

  userMapper.updateById(user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是运行的结果是：updateTime在执行数据记录修改操作时被自动赋值&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200727075459048-1764315218.png&quot; alt=&quot;updateTime在执行数据记录修改操作时被自动赋值&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Jul 2020 23:55:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文为Mybatis Plus系列文章的第9篇，前8篇访问地址如下： 小书MybatisPlus第1篇-整合SpringBoot快速开始增删改查 小书MybatisPlus第2篇-条件构造器的应用及总</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13383476.html</dc:identifier>
</item>
<item>
<title>【Go语言学习】匿名函数与闭包 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/13383467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/13383467.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;入坑 &lt;code&gt;Go&lt;/code&gt; 语言已经大半年了，却没有写过一篇像样的技术文章，每次写一半就搁笔，然后就烂尾了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/07/13/9uNa8GTcxLZfj57.gif&quot; alt=&quot;1.gif&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;几经思考，痛定思痛，决定金盆洗手，重新做人，哦不，重新开始写技术博文。&lt;/p&gt;
&lt;p&gt;这段时间在研究Go语言&lt;code&gt;闭包&lt;/code&gt;的过程中，发现了很多有意思的东西，也学到了不少内容，于是便以次为契机，重新开始技术文章的输出。&lt;/p&gt;
&lt;h2 id=&quot;什么是闭包&quot;&gt;什么是闭包&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;闭包&lt;/code&gt; 是 &lt;code&gt;Go&lt;/code&gt; 语言中一个重要特性，也是 &lt;code&gt;函数式编程&lt;/code&gt; 中必不可少的角色。那么什么是 &lt;code&gt;闭包&lt;/code&gt; 呢？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;A closure is a function value that references variables from outside its body.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是 &lt;code&gt;A Tour of Go&lt;/code&gt; 上的定义，&lt;code&gt;闭包&lt;/code&gt; 是一种引用了外部变量的函数。但我觉得这个定义还不够准确，&lt;code&gt;闭包&lt;/code&gt; 应该是引用了外部变量的 &lt;code&gt;匿名函数&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;看了很多文章，大多把 &lt;code&gt;闭包&lt;/code&gt; 跟&lt;code&gt;匿名函数&lt;/code&gt;混淆在了一起，也有很多人说，&lt;code&gt;闭包&lt;/code&gt; 其实就是&lt;code&gt;匿名函数&lt;/code&gt;，但其实两者是不能直接划等号的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;闭包&lt;/code&gt; 是一种特殊的&lt;code&gt;匿名函数&lt;/code&gt;，是&lt;code&gt;匿名函数&lt;/code&gt;的子集。所以在说 &lt;code&gt;闭包&lt;/code&gt; 之前，我们先来看看 &lt;code&gt;匿名函数&lt;/code&gt; 吧。&lt;/p&gt;
&lt;h2 id=&quot;匿名函数&quot;&gt;匿名函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;匿名函数&lt;/code&gt; 顾名思义，就是没有名字的函数。在Go语言中，函数是一等公民，也就是说，函数可以被赋值或者当作返回值和参数进行传递，在很多时候我们并不需要一个有名字的函数（而且命名确实是一项相当费劲的事），所以我们在某些场景下可以选择使用 &lt;code&gt;匿名函数&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func main(){
    hello := func(){
        fmt.Println(&quot;Hello World&quot;)
    }
    hello()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个简单的例子，我们声明了一个 &lt;code&gt;匿名函数&lt;/code&gt; ，然后把它赋值给一个叫 &lt;code&gt;hello&lt;/code&gt; 的变量，然后我们就能像调用函数那样使用它了。&lt;/p&gt;
&lt;p&gt;这跟下面的代码效果是一样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func main(){
    hello()
}

func hello(){
    fmt.Println(&quot;Hello World&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以把 &lt;code&gt;匿名函数&lt;/code&gt; 当作函数参数进行传递：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func main(){
    doPrint(&quot;Hello World&quot;, func(s string){
                fmt.Println(s)
        })
}

type Printer func(string)

func doPrint(s string, printer Printer){
    printer(s)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者当作函数返回值进行返回：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func main(){
    getPrinter()(&quot;Hello World&quot;)
}

type Printer func(string)

func getPrinter()Printer{
    return func(s string){
                fmt.Println(s)
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;匿名函数&lt;/code&gt; 跟普通函数在绝大多数场景下没什么区别，普通函数的函数名可以当作是与该函数绑定的函数常量。&lt;/p&gt;
&lt;p&gt;一个函数主要包含两个信息:函数签名和函数体，函数的签名包括参数类型，返回值的类型，函数签名可以看做是函数的类型，函数的函数体即函数的值。所以一个接收匿名函数的变量的类型便是由函数的签名决定的，一个匿名函数被赋值给一个变量后，这个变量便只能接收同样签名的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func main(){
    hello := func(){
        fmt.Println(&quot;Hello World&quot;)
    } // 给 hello 变量赋值一个匿名函数
    hello()
    
    hello = func(){
        fmt.Println(&quot;Hello World2&quot;)
    } // 重新赋值新的匿名函数
    hello()
    
    hello = hi // 将一个普通函数赋值给 hello
    hello()
    
    hello = func(int){
        fmt.Println(&quot;Hello World3&quot;)
    } // 这里编译器会报错
    hello()
}

func hi(){
    fmt.Println(&quot;Hi&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;匿名函数&lt;/code&gt; 跟普通函数的微小区别在于 &lt;code&gt;匿名函数&lt;/code&gt; 赋值的变量可以重新设置新的 &lt;code&gt;匿名函数&lt;/code&gt;，但普通函数的函数名是与特定函数绑定的，无法再将其它函数赋值给它。这就类似于变量与常量之间的区别。&lt;/p&gt;
&lt;h2 id=&quot;闭包的特性&quot;&gt;闭包的特性&lt;/h2&gt;
&lt;p&gt;说完了 &lt;code&gt;匿名函数&lt;/code&gt;，我们再回过头来看看 &lt;code&gt;闭包&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;闭包&lt;/code&gt; 是指由一个拥有许多变量和绑定了这些变量的环境的 &lt;code&gt;匿名函数&lt;/code&gt;&lt;br/&gt;&lt;code&gt;闭包&lt;/code&gt; = &lt;code&gt;函数&lt;/code&gt; + &lt;code&gt;引用环境&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;听起来有点绕，什么是 &lt;code&gt;引用环境&lt;/code&gt;呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;引用环境&lt;/code&gt; 是指在程序执行中的某个点所有处于活跃状态的变量所组成的集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于&lt;code&gt;闭包&lt;/code&gt;把函数和运行时的引用环境打包成为一个新的整体，所以就解决了函数编程中的嵌套所引发的问题。&lt;/p&gt;
&lt;p&gt;当每次调用包含&lt;code&gt;闭包&lt;/code&gt;的函数时都将返回一个新的闭包实例，这些实例之间是隔离的，分别包含调用时不同的引用环境现场。不同于函数，&lt;code&gt;闭包&lt;/code&gt;在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。&lt;/p&gt;
&lt;p&gt;简单来说，&lt;code&gt;闭包&lt;/code&gt; 就是引用了外部变量的匿名函数。不太明白？没关系，让我们先来看一个栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func adder() func() int {
        var i = 0
        return func() int {
                i++
                return i
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是用&lt;code&gt;闭包&lt;/code&gt;实现的简单累加器，这一部分便是闭包，它引用在其作用域范围之外的变量i。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func() int {
    i++
    return i
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以这样使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func main() {
        a := adder()
        fmt.Println(a())
        fmt.Println(a())
        fmt.Println(a())
        fmt.Println(a())
    b := adder()
        fmt.Println(b())
        fmt.Println(b())
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;1
2
3
4
1
2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述例子中，&lt;code&gt;adder&lt;/code&gt; 是一个函数，没有入参，返回值是一个返回 &lt;code&gt;int&lt;/code&gt; 类型的无参函数，也就是说调用 &lt;code&gt;adder&lt;/code&gt; 函数会返回一个函数，这个函数的返回值是 &lt;code&gt;int&lt;/code&gt; 类型，且不接收参数。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;main&lt;/code&gt; 方法中:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;a := adder()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是将调用后得到的函数赋值给了变量 &lt;code&gt;a&lt;/code&gt; ，随后进行了四次函数调用和输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;fmt.Println(a())
fmt.Println(a())
fmt.Println(a())
fmt.Println(a())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也许你还是会感到困惑，&lt;code&gt;i&lt;/code&gt; 是 &lt;code&gt;adder&lt;/code&gt; 函数里的变量，调用完成之后变量的生命周期不久结束了吗？为什么还能不断累加？&lt;/p&gt;
&lt;p&gt;这就涉及到&lt;code&gt;闭包&lt;/code&gt;的另一个重要话题了：&lt;code&gt;闭包&lt;/code&gt; 会让被引用的局部变量从栈逃逸到堆上，从而使其能在其作用域范围之外存活。&lt;code&gt;闭包&lt;/code&gt; “捕获”了和它在同一作用域的其它常量和变量。这就意味着当&lt;code&gt;闭包&lt;/code&gt;被调用的时候，不管在程序什么地方调用，&lt;code&gt;闭包&lt;/code&gt;能够使用这些常量或者变量。它不关心这些捕获了的变量和常量是否已经超出了作用域，只要&lt;code&gt;闭包&lt;/code&gt;还在使用它们，这些变量就还会存在。&lt;/p&gt;
&lt;h2 id=&quot;匿名函数和闭包的使用&quot;&gt;匿名函数和闭包的使用&lt;/h2&gt;
&lt;p&gt;可以利用&lt;code&gt;匿名函数&lt;/code&gt;和&lt;code&gt;闭包&lt;/code&gt;可以实现很多有意思的功能，比如上面的累加器，便是利用了 &lt;code&gt;闭包&lt;/code&gt; 的作用域隔离特性，每调用一次 &lt;code&gt;adder&lt;/code&gt; 函数，就会生成一个新的累加器，使用新的变量 &lt;code&gt;i&lt;/code&gt;，所以在调用 &lt;code&gt;b()&lt;/code&gt; 时，仍旧会从1开始输出。&lt;/p&gt;
&lt;p&gt;再来看几个&lt;code&gt;匿名函数&lt;/code&gt;和&lt;code&gt;闭包&lt;/code&gt;应用的例子。&lt;/p&gt;
&lt;h3 id=&quot;工厂函数&quot;&gt;工厂函数&lt;/h3&gt;
&lt;p&gt;工厂函数即生产函数的函数，调用工厂函数可以得到其内嵌函数的引用，每次调用都可以得到一个新的函数引用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func getFibGen() func() int {
        f1 := 0
        f2 := 1
        return func() int {
                f2, f1 = f1 + f2, f2
                return f1
        }
}

func main() {
        gen := getFibGen()
        for i := 0; i &amp;lt; 10; i++ {
                fmt.Println(gen())
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是利用闭包实现的函数工厂来求解斐波那契数列问题，调用 &lt;code&gt;getFibGen&lt;/code&gt; 函数之后，&lt;code&gt;gen&lt;/code&gt; 便获得了内嵌函数的引用，且该函数引用里一直持有 &lt;code&gt;f1&lt;/code&gt; 和 &lt;code&gt;f2&lt;/code&gt; 的引用，每执行一次 &lt;code&gt;gen()&lt;/code&gt;，便会运算一次斐波那契的递推关系式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func() int {
    f2, f1 = f1 + f2, f2
    return f1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1
1
2
3
5
8
13
21
34
55
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;闭包&lt;/code&gt;能构造出单独的变量环境，可以很好的实现环境隔离，所以很适合应用于函数工厂，在实现功能时保存某些状态变量。&lt;/p&gt;
&lt;h3 id=&quot;装饰器中间件&quot;&gt;装饰器/中间件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;修饰器&lt;/code&gt;是指在不改变对象的内部结构情况下，动态地扩展对象的功能。通过创建一个装饰器，来包装真实的对象。使用&lt;code&gt;闭包&lt;/code&gt;很容易实现&lt;code&gt;装饰器模式&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 gin 中的 Middleware 便是使用&lt;code&gt;装饰器模式&lt;/code&gt;来实现的。比如我们可以这样实现一个自定义的 Logger：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func Logger() gin.HandlerFunc {
        return func(context *gin.Context) {
                host := context.Request.Host
                url := context.Request.URL
                method := context.Request.Method
                fmt.Printf(&quot;%s::%s \t %s \t %s \n&quot;, time.Now().Format(&quot;2006-01-02 15:04:05&quot;), host, url, method)
                context.Next()
        fmt.Println(&quot;response status: &quot;, context.Writer.Status())
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是在 &lt;code&gt;gin&lt;/code&gt; 中利用 &lt;code&gt;匿名函数&lt;/code&gt; 实现的自定义日志中间件，在 &lt;code&gt;gin&lt;/code&gt; 中，类似的用法十分常见。&lt;/p&gt;
&lt;h3 id=&quot;defer&quot;&gt;defer&lt;/h3&gt;
&lt;p&gt;这是&lt;code&gt;匿名函数&lt;/code&gt;和&lt;code&gt;闭包&lt;/code&gt;最常用的地方，我们会经常在 &lt;code&gt;defer&lt;/code&gt; 函数中使用&lt;code&gt;匿名函数&lt;/code&gt;和&lt;code&gt;闭包&lt;/code&gt;来做释放锁，关闭连接，处理 &lt;code&gt;panic&lt;/code&gt; 等函数善后工作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func main() {
    defer func() {
        if ok := recover(); ok != nil {
            fmt.Println(&quot;recover from panic&quot;)
        }
    }()

    panic(&quot;error&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gorutine&quot;&gt;gorutine&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;匿名函数&lt;/code&gt;和&lt;code&gt;闭包&lt;/code&gt;还有一个十分常用的场景，那便是在启动 &lt;code&gt;gorutine&lt;/code&gt; 时使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func main(){
    go func(){
        fmt.Println(&quot;Hello World&quot;)
    }()
    time.Sleep(1 * time.Second)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新声明一下，在函数内部引用了外部变量便是&lt;code&gt;闭包&lt;/code&gt;，否则就是&lt;code&gt;匿名函数&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;func main(){
    hello := &quot;Hello World&quot;
    go func(){
        fmt.Println(hello)
    }()
    time.Sleep(1 * time.Second)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;context&quot;&gt;context&lt;/h3&gt;
&lt;p&gt;在cancelContext中也使用到了闭包：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;// A CancelFunc tells an operation to abandon its work.
// A CancelFunc does not wait for the work to stop.
// A CancelFunc may be called by multiple goroutines simultaneously.
// After the first call, subsequent calls to a CancelFunc do nothing.
type CancelFunc func()

// WithCancel returns a copy of parent with a new Done channel. The returned
// context's Done channel is closed when the returned cancel function is called
// or when the parent context's Done channel is closed, whichever happens first.
//
// Canceling this context releases resources associated with it, so code should
// call cancel as soon as the operations running in this Context complete.
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
        c := newCancelCtx(parent)
        propagateCancel(parent, &amp;amp;c)
        return &amp;amp;c, func() { c.cancel(true, Canceled) }
}

// newCancelCtx returns an initialized cancelCtx.
func newCancelCtx(parent Context) cancelCtx {
        return cancelCtx{Context: parent}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;闭包的陷阱&quot;&gt;闭包的陷阱&lt;/h2&gt;
&lt;p&gt;闭包很好用，但在某些场景下，也十分具有欺骗性，稍有不慎，就会掉入其陷阱里。&lt;/p&gt;
&lt;p&gt;不如先来看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;for j := 0; j &amp;lt; 2; j++ {
        defer func() {
                fmt.Println(j)
        }()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你猜会输出什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;2
2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为在 &lt;code&gt;defer&lt;/code&gt; 中使用的闭包引用了外部变量 &lt;code&gt;j&lt;/code&gt; 。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;闭包&lt;/code&gt; 中持有的是外部变量的引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是很容易犯的错误，在循环体中使用 &lt;code&gt;defer&lt;/code&gt;，来关闭连接，释放资源，但由于闭包内持有的是外部变量的引用，在这里持有的是变量 &lt;code&gt;j&lt;/code&gt; 的引用，&lt;code&gt;defer&lt;/code&gt; 会在函数执行完成前调用闭包，在开始执行闭包时，&lt;code&gt;j&lt;/code&gt; 的值已经是2了。&lt;/p&gt;
&lt;p&gt;那么这个问题应该如何修复呢？有两种方式，一种是重新定义变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;for j := 0; j &amp;lt; 2; j++ {
    k := j
        defer func() {
                fmt.Println(k)
        }()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在循环体里，每次循环都定义了一个新的变量 &lt;code&gt;k&lt;/code&gt; 来获取原变量 &lt;code&gt;j&lt;/code&gt; 的值，因此每次调用&lt;code&gt;闭包&lt;/code&gt;时，引用的是不同的变量 &lt;code&gt;k&lt;/code&gt;，从而达到变量隔离的效果。&lt;/p&gt;
&lt;p&gt;另一种方式是把变量当成参数传入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;for j := 0; j &amp;lt; 2; j++ {
        defer func(k int) {
                fmt.Println(k)
        }(j)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里每次调用&lt;code&gt;闭包&lt;/code&gt;时，传入的都是变量 &lt;code&gt;j&lt;/code&gt; 的值，虽然 &lt;code&gt;defer&lt;/code&gt; 仍会在函数执行完成前调用，但传入&lt;code&gt;闭包&lt;/code&gt;的参数值却是先计算好的，因而能够正确输出。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;闭包&lt;/code&gt;返回的包装对象是一个复合结构，里面包含&lt;code&gt;匿名函数&lt;/code&gt;的地址，以及&lt;code&gt;环境变量&lt;/code&gt;的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了更好的理解这一点，我们再来看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;package main

import &quot;fmt&quot;

func main() {
    x, y := 1, 2

    defer func(a int) { 
        fmt.Printf(&quot;x:%d,y:%d\n&quot;, a, y)  
    }(x)     

    x += 1
    y += 1
    fmt.Println(x, y)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;2 3
x:1,y:3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，由于&lt;code&gt;闭包&lt;/code&gt;会使得其持有的外部变量逃逸出原有的作用域，所以使用不当可能会造成内存泄漏，这一点由于相当具有隐蔽性，所以也需要谨慎对待。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;闭包&lt;/code&gt;是一种特殊的&lt;code&gt;匿名函数&lt;/code&gt;，是由函数体和引用的外部变量一起组成，可以看成类似如下结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Go&quot;&gt;type FF struct {
        F unitptr
        A *int
        B *int
        X *int // 如果X是string/[]int，那么这里应该为*string，*[]int
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Go语言中，闭包的应用十分广泛，掌握了闭包的使用可以让你在写代码时能更加游刃有余，也可以避免很多不必要的麻烦。所以是必须要掌握的一个知识点。&lt;/p&gt;
&lt;p&gt;至此，关于闭包的内容就完结了，希望能对你有帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202007/1043143-20200727074006066-1700986643.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Jul 2020 23:42:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>前言 入坑 Go 语言已经大半年了，却没有写过一篇像样的技术文章，每次写一半就搁笔，然后就烂尾了。 几经思考，痛定思痛，决定金盆洗手，重新做人，哦不，重新开始写技术博文。 这段时间在研究Go语言闭包的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mfrank/p/13383467.html</dc:identifier>
</item>
<item>
<title>5万字长文:Stream和Lambda表达式最佳实践-附PDF下载 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/java-stream-lambda-all-in-one.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/java-stream-lambda-all-in-one.html</guid>
<description>&lt;p&gt;5万字长文详解介绍Stream和Lambda表达式最佳实践,干货实在太多，最后附上PDF下载，方便大家查阅！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;1477.8555720628&quot;&gt;


&lt;p&gt;今天要讲的Stream指的是java.util.stream包中的诸多类。Stream可以方便的将之前的结合类以转换为Stream并以流式方式进行处理，大大的简化了我们的编程，Stream包中，最核心的就是interface Stream&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409222144859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_25,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的图中我们可以看到Stream继承自BaseStream。Stream中定义了很多非常实用的方法，比如filter，map，flatmap,forEach,reduce,collect等等。接下来我们将会逐一讲解。&lt;/p&gt;
&lt;h2 id=&quot;11-创建stream&quot;&gt;1.1 创建Stream&lt;/h2&gt;
&lt;p&gt;Stream的创建有很多方式，java引入Stream之后所有的集合类都添加了一个stream()方法，通过这个方法可以直接得到其对应的Stream。也可以通过Stream.of方法来创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Stream Creation
        String[] arr = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
        Stream&amp;lt;String&amp;gt; stream = Arrays.stream(arr);
        stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;12-streams多线程&quot;&gt;1.2 Streams多线程&lt;/h2&gt;
&lt;p&gt;如果我们想使用多线程来处理集合类的数据，Stream提供了非常方便的多线程方法parallelStream()：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Multi-threading
        List&amp;lt;String&amp;gt; list =new ArrayList();
        list.add(&quot;aaa&quot;);
        list.add(&quot;bbb&quot;);
        list.add(&quot;abc&quot;);
        list.add(&quot;ccc&quot;);
        list.add(&quot;ddd&quot;);
        list.parallelStream().forEach(element -&amp;gt; doPrint(element));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;13-stream的基本操作&quot;&gt;1.3 Stream的基本操作&lt;/h2&gt;
&lt;p&gt;Stream的操作可以分为两类，一类是中间操作，中间操作返回Stream，因此可以级联调用。 另一类是终止操作，这类操作会返回Stream定义的类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Operations
        long count = list.stream().distinct().count();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，distinct()返回一个Stream，所以可以级联操作，最后的count()是一个终止操作，返回最后的值。&lt;/p&gt;
&lt;h3 id=&quot;matching&quot;&gt;Matching&lt;/h3&gt;
&lt;p&gt;Stream提供了anyMatch(), allMatch(), noneMatch()这三种match方式，我们看下怎么使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Matching
        boolean isValid = list.stream().anyMatch(element -&amp;gt; element.contains(&quot;h&quot;));
        boolean isValidOne = list.stream().allMatch(element -&amp;gt; element.contains(&quot;h&quot;));
        boolean isValidTwo = list.stream().noneMatch(element -&amp;gt; element.contains(&quot;h&quot;));  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;filtering&quot;&gt;Filtering&lt;/h3&gt;
&lt;p&gt;filter() 方法允许我们对Stream中的数据进行过滤，从而得到我们需要的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Stream&amp;lt;String&amp;gt; filterStream = list.stream().filter(element -&amp;gt; element.contains(&quot;d&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中我们从list中选出了包含“d”字母的String。&lt;/p&gt;
&lt;h3 id=&quot;mapping&quot;&gt;Mapping&lt;/h3&gt;
&lt;p&gt;map就是对Stream中的值进行再加工，然后将加工过后的值作为新的Stream返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Mapping
        Stream&amp;lt;String&amp;gt; mappingStream = list.stream().map(element -&amp;gt; convertElement(element));

    private static String convertElement(String element) {
        return &quot;element&quot;+&quot;abc&quot;;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上的例子中我们把list中的每个值都加上了“abc”然后返回一个新的Stream。&lt;/p&gt;
&lt;h3 id=&quot;flatmap&quot;&gt;FlatMap&lt;/h3&gt;
&lt;p&gt;flatMap和Map很类似，但是他们两个又有不同，看名字我们可以看到flatMap意思是打平之后再做Map。&lt;/p&gt;
&lt;p&gt;怎么理解呢？&lt;/p&gt;
&lt;p&gt;假如我们有一个CustBook类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class CustBook {

    List&amp;lt;String&amp;gt; bookName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CustBook定义了一个bookName字段。&lt;/p&gt;
&lt;p&gt;先看一下Map返回的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;CustBook&amp;gt; users = new ArrayList&amp;lt;&amp;gt;();
        users.add(new CustBook());
Stream&amp;lt;Stream&amp;lt;String&amp;gt;&amp;gt; userStreamMap
                = users.stream().map(user -&amp;gt; user.getBookName().stream());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，map将每一个user都转换成了stream，所以最后的结果是返回Stream的Stream。&lt;/p&gt;
&lt;p&gt;如果我们只想返回String，则可以使用FlatMap：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;CustBook&amp;gt; users = new ArrayList&amp;lt;&amp;gt;();
        users.add(new CustBook());
        Stream&amp;lt;String&amp;gt; userStream
                = users.stream().map(user -&amp;gt; user.getBookName().stream());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单点讲FlatMap就是将层级关系铺平重来。&lt;/p&gt;
&lt;h3 id=&quot;reduction&quot;&gt;Reduction&lt;/h3&gt;
&lt;p&gt;使用reduce() 方法可以方便的对集合的数据进行运算，reduce()接收两个参数，第一个是开始值，后面是一个函数表示累计。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Reduction
        List&amp;lt;Integer&amp;gt; integers = Arrays.asList(1, 1, 1);
        Integer reduced = integers.stream().reduce(100, (a, b) -&amp;gt; a + b);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子我们定义了3个1的list，然后调用reduce(100, (a, b) -&amp;gt; a + b)方法，最后的结果是103.&lt;/p&gt;
&lt;h3 id=&quot;collecting&quot;&gt;Collecting&lt;/h3&gt;
&lt;p&gt;collect()方法可以方便的将Stream再次转换为集合类，方便处理和展示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; resultList
                = list.stream().map(element -&amp;gt; element.toUpperCase()).collect(Collectors.toList());
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;java 8引入了lambda表达式，lambda表达式实际上表示的就是一个匿名的function。&lt;/p&gt;
&lt;p&gt;在java 8之前，如果需要使用到匿名function需要new一个类的实现，但是有了lambda表达式之后，一切都变的非常简介。&lt;/p&gt;
&lt;p&gt;我们看一个之前讲线程池的时候的一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ExecutorService using class
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        executorService.submit(new Runnable() {
            @Override
            public void run() {
            log.info(&quot;new runnable&quot;);
            }
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;executorService.submit需要接收一个Runnable类，上面的例子中我们new了一个Runnable类，并实现了它的run（）方法。&lt;/p&gt;
&lt;p&gt;上面的例子如果用lambda表达式来重写，则如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ExecutorService using lambda
        executorService.submit(()-&amp;gt;log.info(&quot;new runnable&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起是不是很简单，使用lambda表达式就可以省略匿名类的构造，并且可读性更强。&lt;/p&gt;
&lt;p&gt;那么是不是所有的匿名类都可以用lambda表达式来重构呢？也不是。&lt;/p&gt;
&lt;p&gt;我们看下Runnable类有什么特点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Runnable 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Runnable类上面有一个@FunctionalInterface注解。这个注解就是我们今天要讲到的Functional Interface。&lt;/p&gt;
&lt;h2 id=&quot;21-functional-interface&quot;&gt;2.1 Functional Interface&lt;/h2&gt;
&lt;p&gt;Functional Interface是指带有 @FunctionalInterface 注解的interface。它的特点是其中只有一个子类必须要实现的abstract方法。如果abstract方法前面带有default关键字，则不做计算。&lt;/p&gt;
&lt;p&gt;其实这个也很好理解，因为Functional Interface改写成为lambda表达式之后，并没有指定实现的哪个方法，如果有多个方法需要实现的话，就会有问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Functional Interface一般都在java.util.function包中。&lt;/p&gt;
&lt;p&gt;根据要实现的方法参数和返回值的不同，Functional Interface可以分为很多种，下面我们分别来介绍。&lt;/p&gt;
&lt;h2 id=&quot;22-function：一个参数一个返回值&quot;&gt;2.2 Function：一个参数一个返回值&lt;/h2&gt;
&lt;p&gt;Function接口定义了一个方法，接收一个参数，返回一个参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {

    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t)；
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般我们在对集合类进行处理的时候，会用到Function。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;String, Integer&amp;gt; nameMap = new HashMap&amp;lt;&amp;gt;();
        Integer value = nameMap.computeIfAbsent(&quot;name&quot;, s -&amp;gt; s.length());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中我们调用了map的computeIfAbsent方法，传入一个Function。&lt;/p&gt;
&lt;p&gt;上面的例子还可以改写成更短的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Integer value1 = nameMap.computeIfAbsent(&quot;name&quot;, String::length);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Function没有指明参数和返回值的类型，如果需要传入特定的参数，则可以使用IntFunction, LongFunction, DoubleFunction：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface IntFunction&amp;lt;R&amp;gt; {

    /**
     * Applies this function to the given argument.
     *
     * @param value the function argument
     * @return the function result
     */
    R apply(int value);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要返回特定的参数，则可以使用ToIntFunction, ToLongFunction, ToDoubleFunction：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface ToDoubleFunction&amp;lt;T&amp;gt; {

    /**
     * Applies this function to the given argument.
     *
     * @param value the function argument
     * @return the function result
     */
    double applyAsDouble(T value);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要同时指定参数和返回值，则可以使用DoubleToIntFunction, DoubleToLongFunction, IntToDoubleFunction, IntToLongFunction, LongToIntFunction, LongToDoubleFunction：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface LongToIntFunction {

    /**
     * Applies this function to the given argument.
     *
     * @param value the function argument
     * @return the function result
     */
    int applyAsInt(long value);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23-bifunction：接收两个参数，一个返回值&quot;&gt;2.3 BiFunction：接收两个参数，一个返回值&lt;/h2&gt;
&lt;p&gt;如果需要接受两个参数，一个返回值的话，可以使用BiFunction：BiFunction, ToDoubleBiFunction, ToIntBiFunction, ToLongBiFunction等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface BiFunction&amp;lt;T, U, R&amp;gt; {

    /**
     * Applies this function to the given arguments.
     *
     * @param t the first function argument
     * @param u the second function argument
     * @return the function result
     */
    R apply(T t, U u);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看一个BiFunction的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//BiFunction
        Map&amp;lt;String, Integer&amp;gt; salaries = new HashMap&amp;lt;&amp;gt;();
        salaries.put(&quot;alice&quot;, 100);
        salaries.put(&quot;jack&quot;, 200);
        salaries.put(&quot;mark&quot;, 300);

        salaries.replaceAll((name, oldValue) -&amp;gt;
                name.equals(&quot;alice&quot;) ? oldValue : oldValue + 200);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;24-supplier：无参的function&quot;&gt;2.4 Supplier：无参的Function&lt;/h2&gt;
&lt;p&gt;如果什么参数都不需要，则可以使用Supplier：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Supplier&amp;lt;T&amp;gt; {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;25-consumer：接收一个参数，不返回值&quot;&gt;2.5 Consumer：接收一个参数，不返回值&lt;/h2&gt;
&lt;p&gt;Consumer接收一个参数，但是不返回任何值，我们看下Consumer的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Consumer&amp;lt;T&amp;gt; {

    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一个Consumer的具体应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Consumer
        nameMap.forEach((name, age) -&amp;gt; System.out.println(name + &quot; is &quot; + age + &quot; years old&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;26-predicate：接收一个参数，返回boolean&quot;&gt;2.6 Predicate：接收一个参数，返回boolean&lt;/h2&gt;
&lt;p&gt;Predicate接收一个参数，返回boolean值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Predicate&amp;lt;T&amp;gt; {

    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果用在集合类的过滤上面那是极好的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Predicate
        List&amp;lt;String&amp;gt; names = Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;);
        List&amp;lt;String&amp;gt; namesWithA = names.stream()
                .filter(name -&amp;gt; name.startsWith(&quot;A&quot;))
                .collect(Collectors.toList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;27-operator：接收和返回同样的类型&quot;&gt;2.7 Operator：接收和返回同样的类型&lt;/h2&gt;
&lt;p&gt;Operator接收和返回同样的类型，有很多种Operator：UnaryOperator BinaryOperator ，DoubleUnaryOperator, IntUnaryOperator, LongUnaryOperator, DoubleBinaryOperator, IntBinaryOperator, LongBinaryOperator等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface IntUnaryOperator {

    /**
     * Applies this operator to the given operand.
     *
     * @param operand the operand
     * @return the operator result
     */
    int applyAsInt(int operand);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看一个BinaryOperator的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; //Operator
        List&amp;lt;Integer&amp;gt; values = Arrays.asList(1, 2, 3, 4, 5);
        int sum = values.stream()
                .reduce(0, (i1, i2) -&amp;gt; i1 + i2);
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Lambda表达式java 8引入的函数式编程框架。之前的文章中我们也讲过Lambda表达式的基本用法。&lt;/p&gt;
&lt;p&gt;本文将会在之前的文章基础上更加详细的讲解Lambda表达式在实际应用中的最佳实践经验。&lt;/p&gt;
&lt;h2 id=&quot;31-优先使用标准functional接口&quot;&gt;3.1 优先使用标准Functional接口&lt;/h2&gt;
&lt;p&gt;之前的文章我们讲到了，java在java.util.function包中定义了很多Function接口。基本上涵盖了我们能够想到的各种类型。&lt;/p&gt;
&lt;p&gt;假如我们自定义了下面的Functional interface：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Usage {
    String method(String string);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们需要在一个test方法中传入该interface：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String test(String string, Usage usage) {
    return usage.method(string);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们定义的函数接口需要实现method方法，接收一个String，返回一个String。这样我们完全可以使用Function来代替：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String test(String string, Function&amp;lt;String, String&amp;gt; fn) {
    return fn.apply(string);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用标准接口的好处就是，不要重复造轮子。&lt;/p&gt;
&lt;h2 id=&quot;32-使用functionalinterface注解&quot;&gt;3.2 使用@FunctionalInterface注解&lt;/h2&gt;
&lt;p&gt;虽然@FunctionalInterface不是必须的，不使用@FunctionalInterface也可以定义一个Functional Interface。&lt;/p&gt;
&lt;p&gt;但是使用@FunctionalInterface可以在违背Functional Interface定义的时候报警。&lt;/p&gt;
&lt;p&gt;如果是在维护一个大型项目中，加上@FunctionalInterface注解可以清楚的让其他人了解这个类的作用。&lt;/p&gt;
&lt;p&gt;从而使代码更加规范和更加可用。&lt;/p&gt;
&lt;p&gt;所以我们需要这样定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Usage {
    String method(String string);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而不是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Usage {
    String method(String string);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;33-在functional-interfaces中不要滥用default-methods&quot;&gt;3.3 在Functional Interfaces中不要滥用Default Methods&lt;/h2&gt;
&lt;p&gt;Functional Interface是指只有一个未实现的抽象方法的接口。&lt;/p&gt;
&lt;p&gt;如果该Interface中有多个方法，则可以使用default关键字为其提供一个默认的实现。&lt;/p&gt;
&lt;p&gt;但是我们知道Interface是可以多继承的，一个class可以实现多个Interface。 如果多个Interface中定义了相同的default方法，则会报错。&lt;/p&gt;
&lt;p&gt;通常来说default关键字一般用在升级项目中，避免代码报错。&lt;/p&gt;
&lt;h2 id=&quot;34-使用lambda-表达式来实例化functional-interface&quot;&gt;3.4 使用Lambda 表达式来实例化Functional Interface&lt;/h2&gt;
&lt;p&gt;还是上面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Usage {
    String method(String string);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要实例化Usage，我们可以使用new关键词：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Usage usage = new Usage() {
    @Override
    public String method(String string) {
        return string;
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是最好的办法就是用lambda表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Usage usage = parameter -&amp;gt; parameter;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;35-不要重写functional-interface作为参数的方法&quot;&gt;3.5 不要重写Functional Interface作为参数的方法&lt;/h2&gt;
&lt;p&gt;怎么理解呢？ 我们看下面两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ProcessorImpl implements Processor {
    @Override
    public String process(Callable&amp;lt;String&amp;gt; c) throws Exception {
        // implementation details
    }
 
    @Override
    public String process(Supplier&amp;lt;String&amp;gt; s) {
        // implementation details
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个方法的方法名是一样的，只有传入的参数不同。但是两个参数都是Functional Interface，都可以用同样的lambda表达式来表示。&lt;/p&gt;
&lt;p&gt;在调用的时候：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String result = processor.process(() -&amp;gt; &quot;test&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为区别不了到底调用的哪个方法，则会报错。&lt;/p&gt;
&lt;p&gt;最好的办法就是将两个方法的名字修改为不同的。&lt;/p&gt;
&lt;h2 id=&quot;36-lambda表达式和内部类是不同的&quot;&gt;3.6 Lambda表达式和内部类是不同的&lt;/h2&gt;
&lt;p&gt;虽然我们之前讲到使用lambda表达式可以替换内部类。但是两者的作用域范围是不同的。&lt;/p&gt;
&lt;p&gt;在内部类中，会创建一个新的作用域范围，在这个作用域范围之内，你可以定义新的变量，并且可以用this引用它。&lt;/p&gt;
&lt;p&gt;但是在Lambda表达式中，并没有定义新的作用域范围，如果在Lambda表达式中使用this，则指向的是外部类。&lt;/p&gt;
&lt;p&gt;我们举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private String value = &quot;Outer scope value&quot;;

public String scopeExperiment() {
    Usage usage = new Usage() {
        String value = &quot;Inner class value&quot;;
 
        @Override
        public String method(String string) {
            return this.value;
        }
    };
    String result = usage.method(&quot;&quot;);
 
    Usage usageLambda = parameter -&amp;gt; {
        String value = &quot;Lambda value&quot;;
        return this.value;
    };
    String resultLambda = usageLambda.method(&quot;&quot;);
 
    return &quot;Results: result = &quot; + result + 
      &quot;, resultLambda = &quot; + resultLambda;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子将会输出“Results: result = Inner class value, resultLambda = Outer scope value”&lt;/p&gt;
&lt;h2 id=&quot;37-lambda-expression尽可能简洁&quot;&gt;3.7 Lambda Expression尽可能简洁&lt;/h2&gt;
&lt;p&gt;通常来说一行代码即可。如果你有非常多的逻辑，可以将这些逻辑封装成一个方法，在lambda表达式中调用该方法即可。&lt;/p&gt;
&lt;p&gt;因为lambda表达式说到底还是一个表达式，表达式当然越短越好。&lt;/p&gt;
&lt;p&gt;java通过类型推断来判断传入的参数类型，所以我们在lambda表达式的参数中尽量不传参数类型，像下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;(a, b) -&amp;gt; a.toLowerCase() + b.toLowerCase();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而不是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;(String a, String b) -&amp;gt; a.toLowerCase() + b.toLowerCase();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只有一个参数的时候，不需要带括号：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;a -&amp;gt; a.toLowerCase();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而不是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;(a) -&amp;gt; a.toLowerCase();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回值不需要带return:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;a -&amp;gt; a.toLowerCase();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而不是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;a -&amp;gt; {return a.toLowerCase()};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;38-使用方法引用&quot;&gt;3.8 使用方法引用&lt;/h2&gt;
&lt;p&gt;为了让lambda表达式更加简洁，在可以使用方法引用的时候，我们可以使用方法引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;a -&amp;gt; a.toLowerCase();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以被替换为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String::toLowerCase;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;39-effectively-final-变量&quot;&gt;3.9 Effectively Final 变量&lt;/h2&gt;
&lt;p&gt;如果在lambda表达式中引用了non-final变量，则会报错。&lt;/p&gt;
&lt;p&gt;effectively final是什么意思呢？这个是一个近似final的意思。只要一个变量只被赋值一次，那么编译器将会把这个变量看作是effectively final的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    String localVariable = &quot;Local&quot;;
    Usage usage = parameter -&amp;gt; {
         localVariable = parameter;
        return localVariable;
    };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中localVariable被赋值了两次，从而不是一个Effectively Final 变量，会编译报错。&lt;/p&gt;
&lt;p&gt;为什么要这样设置呢？因为lambda表达式通常会用在并行计算中，当有多个线程同时访问变量的时候Effectively Final 变量可以防止不可以预料的修改。&lt;/p&gt;

&lt;p&gt;在Stream处理中，我们通常会遇到if/else的判断情况，对于这样的问题我们怎么处理呢？&lt;/p&gt;
&lt;p&gt;还记得我们在上一篇文章lambda最佳实践中提到，lambda表达式应该越简洁越好，不要在其中写臃肿的业务逻辑。&lt;/p&gt;
&lt;p&gt;接下来我们看一个具体的例子。&lt;/p&gt;
&lt;h2 id=&quot;41-传统写法&quot;&gt;4.1 传统写法&lt;/h2&gt;
&lt;p&gt;假如我们有一个1 to 10的list，我们想要分别挑选出奇数和偶数出来，传统的写法，我们会这样使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public void inForEach(){
        List&amp;lt;Integer&amp;gt; ints = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        ints.stream()
                .forEach(i -&amp;gt; {
                    if (i.intValue() % 2 == 0) {
                        System.out.println(&quot;i is even&quot;);
                    } else {
                        System.out.println(&quot;i is old&quot;);
                    }
                });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们把if/else的逻辑放到了forEach中，虽然没有任何问题，但是代码显得非常臃肿。&lt;/p&gt;
&lt;p&gt;接下来看看怎么对其进行改写。&lt;/p&gt;
&lt;h2 id=&quot;42-使用filter&quot;&gt;4.2 使用filter&lt;/h2&gt;
&lt;p&gt;我们可以把if/else的逻辑改写为两个filter：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; ints = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        Stream&amp;lt;Integer&amp;gt; evenIntegers = ints.stream()
                .filter(i -&amp;gt; i.intValue() % 2 == 0);
        Stream&amp;lt;Integer&amp;gt; oddIntegers = ints.stream()
                .filter(i -&amp;gt; i.intValue() % 2 != 0);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这两个filter，再在filter过后的stream中使用for each：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        evenIntegers.forEach(i -&amp;gt; System.out.println(&quot;i is even&quot;));
        oddIntegers.forEach(i -&amp;gt; System.out.println(&quot;i is old&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么样，代码是不是非常简洁明了。&lt;/p&gt;

&lt;p&gt;Map是java中非常常用的一个集合类型，我们通常也需要去遍历Map去获取某些值，java 8引入了Stream的概念，那么我们怎么在Map中使用Stream呢？&lt;/p&gt;
&lt;h2 id=&quot;51--基本概念&quot;&gt;5.1 基本概念&lt;/h2&gt;
&lt;p&gt;Map有key，value还有表示key，value整体的Entry。&lt;/p&gt;
&lt;p&gt;创建一个Map：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;String, String&amp;gt; someMap = new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取Map的entrySet：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Set&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; entries = someMap.entrySet();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取map的key：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Set&amp;lt;String&amp;gt; keySet = someMap.keySet();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取map的value：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Collection&amp;lt;String&amp;gt; values = someMap.values();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们可以看到有这样几个集合：Map，Set，Collection。&lt;/p&gt;
&lt;p&gt;除了Map没有stream，其他两个都有stream方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Stream&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; entriesStream = entries.stream();
        Stream&amp;lt;String&amp;gt; valuesStream = values.stream();
        Stream&amp;lt;String&amp;gt; keysStream = keySet.stream();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过其他几个stream来遍历map。&lt;/p&gt;
&lt;h2 id=&quot;52-使用stream获取map的key&quot;&gt;5.2 使用Stream获取map的key&lt;/h2&gt;
&lt;p&gt;我们先给map添加几个值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;someMap.put(&quot;jack&quot;,&quot;20&quot;);
someMap.put(&quot;bill&quot;,&quot;35&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们添加了name和age字段。&lt;/p&gt;
&lt;p&gt;如果我们想查找age=20的key，则可以这样做：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;String&amp;gt; optionalName = someMap.entrySet().stream()
                .filter(e -&amp;gt; &quot;20&quot;.equals(e.getValue()))
                .map(Map.Entry::getKey)
                .findFirst();

        log.info(optionalName.get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为返回的是Optional,如果值不存在的情况下，我们也可以处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;optionalName = someMap.entrySet().stream()
                .filter(e -&amp;gt; &quot;Non ages&quot;.equals(e.getValue()))
                .map(Map.Entry::getKey).findFirst();

        log.info(&quot;{}&quot;,optionalName.isPresent());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子我们通过调用isPresent来判断age是否存在。&lt;/p&gt;
&lt;p&gt;如果有多个值，我们可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;someMap.put(&quot;alice&quot;,&quot;20&quot;);
        List&amp;lt;String&amp;gt; listnames = someMap.entrySet().stream()
                .filter(e -&amp;gt; e.getValue().equals(&quot;20&quot;))
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        log.info(&quot;{}&quot;,listnames);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们调用了collect(Collectors.toList())将值转成了List。&lt;/p&gt;
&lt;h2 id=&quot;53-使用stream获取map的value&quot;&gt;5.3 使用stream获取map的value&lt;/h2&gt;
&lt;p&gt;上面我们获取的map的key，同样的我们也可以获取map的value：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; listAges = someMap.entrySet().stream()
                .filter(e -&amp;gt; e.getKey().equals(&quot;alice&quot;))
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());

        log.info(&quot;{}&quot;,listAges);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们匹配了key值是alice的value。&lt;/p&gt;

&lt;p&gt;java 8 stream作为流式操作有两种操作类型，中间操作和终止操作。这两种有什么区别呢？&lt;/p&gt;
&lt;p&gt;我们看一个peek的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;);
        stream.peek(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们的本意是打印出Stream的值，但实际上没有任何输出。&lt;/p&gt;
&lt;p&gt;为什么呢？&lt;/p&gt;
&lt;h2 id=&quot;61-中间操作和终止操作&quot;&gt;6.1 中间操作和终止操作&lt;/h2&gt;
&lt;p&gt;一个java 8的stream是由三部分组成的。数据源，零个或一个或多个中间操作，一个或零个终止操作。&lt;/p&gt;
&lt;p&gt;中间操作是对数据的加工，注意，中间操作是lazy操作，并不会立马启动，需要等待终止操作才会执行。&lt;/p&gt;
&lt;p&gt;终止操作是stream的启动操作，只有加上终止操作，stream才会真正的开始执行。&lt;/p&gt;
&lt;p&gt;所以，问题解决了，peek是一个中间操作，所以上面的例子没有任何输出。&lt;/p&gt;
&lt;h2 id=&quot;62-peek&quot;&gt;6.2 peek&lt;/h2&gt;
&lt;p&gt;我们看下peek的文档说明：peek主要被用在debug用途。&lt;/p&gt;
&lt;p&gt;我们看下debug用途的使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;).filter(e -&amp;gt; e.length() &amp;gt; 3)
                .peek(e -&amp;gt; System.out.println(&quot;Filtered value: &quot; + e))
                .map(String::toUpperCase)
                .peek(e -&amp;gt; System.out.println(&quot;Mapped value: &quot; + e))
                .collect(Collectors.toList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;Filtered value: three
Mapped value: THREE
Filtered value: four
Mapped value: FOUR
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子我们输出了stream的中间值，方便我们的调试。&lt;/p&gt;
&lt;p&gt;为什么只作为debug使用呢？我们再看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;).peek(u -&amp;gt; u.toUpperCase())
                .forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子我们使用peek将element转换成为upper case。然后输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;one
two
three
four
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到stream中的元素并没有被转换成大写格式。&lt;/p&gt;
&lt;p&gt;再看一个map的对比：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;).map(u -&amp;gt; u.toUpperCase())
                .forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;ONE
TWO
THREE
FOUR
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到map是真正的对元素进行了转换。&lt;/p&gt;
&lt;p&gt;当然peek也有例外，假如我们Stream里面是一个对象会怎么样？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Data
    @AllArgsConstructor
    static class User{
        private String name;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        List&amp;lt;User&amp;gt; userList=Stream.of(new User(&quot;a&quot;),new User(&quot;b&quot;),new User(&quot;c&quot;)).peek(u-&amp;gt;u.setName(&quot;kkk&quot;)).collect(Collectors.toList());
        log.info(&quot;{}&quot;,userList);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;10:25:59.784 [main] INFO com.flydean.PeekUsage - [PeekUsage.User(name=kkk), PeekUsage.User(name=kkk), PeekUsage.User(name=kkk)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到如果是对象的话，实际的结果会被改变。&lt;/p&gt;
&lt;p&gt;为什么peek和map有这样的区别呢？&lt;/p&gt;
&lt;p&gt;我们看下peek和map的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Stream&amp;lt;T&amp;gt; peek(Consumer&amp;lt;? super T&amp;gt; action)
&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;peek接收一个Consumer，而map接收一个Function。&lt;/p&gt;
&lt;p&gt;Consumer是没有返回值的，它只是对Stream中的元素进行某些操作，但是操作之后的数据并不返回到Stream中，所以Stream中的元素还是原来的元素。&lt;/p&gt;
&lt;p&gt;而Function是有返回值的，这意味着对于Stream的元素的所有操作都会作为新的结果返回到Stream中。&lt;/p&gt;
&lt;p&gt;这就是为什么peek String不会发生变化而peek Object会发送变化的原因。&lt;/p&gt;

&lt;p&gt;java 8中引入了lambda表达式，lambda表达式可以让我们的代码更加简介，业务逻辑更加清晰，但是在lambda表达式中使用的Functional Interface并没有很好的处理异常，因为JDK提供的这些Functional Interface通常都是没有抛出异常的，这意味着需要我们自己手动来处理异常。&lt;/p&gt;
&lt;p&gt;因为异常分为Unchecked Exception和checked Exception,我们分别来讨论。&lt;/p&gt;
&lt;h2 id=&quot;71-处理unchecked-exception&quot;&gt;7.1 处理Unchecked Exception&lt;/h2&gt;
&lt;p&gt;Unchecked exception也叫做RuntimeException，出现RuntimeException通常是因为我们的代码有问题。RuntimeException是不需要被捕获的。也就是说如果有RuntimeException，没有捕获也可以通过编译。&lt;/p&gt;
&lt;p&gt;我们看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; integers = Arrays.asList(1,2,3,4,5);
        integers.forEach(i -&amp;gt; System.out.println(1 / i));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子是可以编译成功的，但是上面有一个问题，如果list中有一个0的话，就会抛出ArithmeticException。&lt;/p&gt;
&lt;p&gt;虽然这个是一个Unchecked Exception，但是我们还是想处理一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        integers.forEach(i -&amp;gt; {
            try {
                System.out.println(1 / i);
            } catch (ArithmeticException e) {
                System.err.println(
                        &quot;Arithmetic Exception occured : &quot; + e.getMessage());
            }
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子我们使用了try，catch来处理异常，简单但是破坏了lambda表达式的最佳实践。代码变得臃肿。&lt;/p&gt;
&lt;p&gt;我们将try，catch移到一个wrapper方法中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static Consumer&amp;lt;Integer&amp;gt; lambdaWrapper(Consumer&amp;lt;Integer&amp;gt; consumer) {
        return i -&amp;gt; {
            try {
                consumer.accept(i);
            } catch (ArithmeticException e) {
                System.err.println(
                        &quot;Arithmetic Exception occured : &quot; + e.getMessage());
            }
        };
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则原来的调用变成这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;integers.forEach(lambdaWrapper(i -&amp;gt; System.out.println(1 / i)));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是上面的wrapper固定了捕获ArithmeticException，我们再将其改编成一个更通用的类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static &amp;lt;T, E extends Exception&amp;gt; Consumer&amp;lt;T&amp;gt;
    consumerWrapperWithExceptionClass(Consumer&amp;lt;T&amp;gt; consumer, Class&amp;lt;E&amp;gt; clazz) {

        return i -&amp;gt; {
            try {
                consumer.accept(i);
            } catch (Exception ex) {
                try {
                    E exCast = clazz.cast(ex);
                    System.err.println(
                            &quot;Exception occured : &quot; + exCast.getMessage());
                } catch (ClassCastException ccEx) {
                    throw ex;
                }
            }
        };
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的类传入一个class，并将其cast到异常，如果能cast，则处理，否则抛出异常。&lt;/p&gt;
&lt;p&gt;这样处理之后，我们这样调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;integers.forEach(
                consumerWrapperWithExceptionClass(
                        i -&amp;gt; System.out.println(1 / i),
                        ArithmeticException.class));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;72-处理checked-exception&quot;&gt;7.2 处理checked Exception&lt;/h2&gt;
&lt;p&gt;checked Exception是必须要处理的异常，我们还是看个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static void throwIOException(Integer integer) throws IOException {
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; integers = Arrays.asList(1, 2, 3, 4, 5);
        integers.forEach(i -&amp;gt; throwIOException(i));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们定义了一个方法抛出IOException，这是一个checked Exception，需要被处理，所以在下面的forEach中，程序会编译失败，因为没有处理相应的异常。&lt;/p&gt;
&lt;p&gt;最简单的办法就是try，catch住，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        integers.forEach(i -&amp;gt; {
            try {
                throwIOException(i);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，这样的做法的坏处我们在上面已经讲过了，同样的，我们可以定义一个新的wrapper方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static &amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; consumerWrapper(
            ThrowingConsumer&amp;lt;T, Exception&amp;gt; throwingConsumer) {

        return i -&amp;gt; {
            try {
                throwingConsumer.accept(i);
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        };
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这样调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;integers.forEach(consumerWrapper(i -&amp;gt; throwIOException(i)));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也可以封装一下异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static &amp;lt;T, E extends Exception&amp;gt; Consumer&amp;lt;T&amp;gt; consumerWrapperWithExceptionClass(
            ThrowingConsumer&amp;lt;T, E&amp;gt; throwingConsumer, Class&amp;lt;E&amp;gt; exceptionClass) {

        return i -&amp;gt; {
            try {
                throwingConsumer.accept(i);
            } catch (Exception ex) {
                try {
                    E exCast = exceptionClass.cast(ex);
                    System.err.println(
                            &quot;Exception occured : &quot; + exCast.getMessage());
                } catch (ClassCastException ccEx) {
                    throw new RuntimeException(ex);
                }
            }
        };
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后这样调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;integers.forEach(consumerWrapperWithExceptionClass(
                i -&amp;gt; throwIOException(i), IOException.class));
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;之前的文章我们讲到，在stream中处理异常，需要将checked exception转换为unchecked exception来处理。&lt;/p&gt;
&lt;p&gt;我们是这样做的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static &amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; consumerWrapper(
            ThrowingConsumer&amp;lt;T, Exception&amp;gt; throwingConsumer) {

        return i -&amp;gt; {
            try {
                throwingConsumer.accept(i);
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        };
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将异常捕获，然后封装成为RuntimeException。&lt;/p&gt;
&lt;p&gt;封装成RuntimeException感觉总是有那么一点点问题，那么有没有什么更好的办法？&lt;/p&gt;
&lt;h2 id=&quot;81-throw小诀窍&quot;&gt;8.1 throw小诀窍&lt;/h2&gt;
&lt;p&gt;java的类型推断大家应该都知道，如果是 这样的形式，那么T将会被认为是RuntimeException！&lt;/p&gt;
&lt;p&gt;我们看下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RethrowException {

    public static &amp;lt;T extends Exception, R&amp;gt; R throwException(Exception t) throws T {
        throw (T) t; // just throw it, convert checked exception to unchecked exception
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的类中，我们定义了一个throwException方法，接收一个Exception参数，将其转换为T，这里的T就是unchecked exception。&lt;/p&gt;
&lt;p&gt;接下来看下具体的使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class RethrowUsage {

    public static void main(String[] args) {
        try {
            throwIOException();
        } catch (IOException e) {
           log.error(e.getMessage(),e);
            RethrowException.throwException(e);
        }
    }

    static void throwIOException() throws IOException{
        throw new IOException(&quot;io exception&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们将一个IOException转换成了一个unchecked exception。&lt;/p&gt;

&lt;p&gt;在java stream中，我们通常需要将处理后的stream转换成集合类，这个时候就需要用到stream.collect方法。collect方法需要传入一个Collector类型，要实现Collector还是很麻烦的，需要实现好几个接口。&lt;/p&gt;
&lt;p&gt;于是java提供了更简单的Collectors工具类来方便我们构建Collector。&lt;/p&gt;
&lt;p&gt;下面我们将会具体讲解Collectors的用法。&lt;/p&gt;
&lt;p&gt;假如我们有这样两个list：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;jack&quot;, &quot;bob&quot;, &quot;alice&quot;, &quot;mark&quot;);
List&amp;lt;String&amp;gt; duplicateList = Arrays.asList(&quot;jack&quot;, &quot;jack&quot;, &quot;alice&quot;, &quot;mark&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面一个是无重复的list，一个是带重复数据的list。接下来的例子我们会用上面的两个list来讲解Collectors的用法。&lt;/p&gt;
&lt;h2 id=&quot;91--collectorstolist&quot;&gt;9.1 Collectors.toList()&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; listResult = list.stream().collect(Collectors.toList());
        log.info(&quot;{}&quot;,listResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将stream转换为list。这里转换的list是ArrayList，如果想要转换成特定的list，需要使用toCollection方法。&lt;/p&gt;
&lt;h2 id=&quot;92-collectorstoset&quot;&gt;9.2 Collectors.toSet()&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Set&amp;lt;String&amp;gt; setResult = list.stream().collect(Collectors.toSet());
        log.info(&quot;{}&quot;,setResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;toSet将Stream转换成为set。这里转换的是HashSet。如果需要特别指定set，那么需要使用toCollection方法。&lt;/p&gt;
&lt;p&gt;因为set中是没有重复的元素，如果我们使用duplicateList来转换的话，会发现最终结果中只有一个jack。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Set&amp;lt;String&amp;gt; duplicateSetResult = duplicateList.stream().collect(Collectors.toSet());
        log.info(&quot;{}&quot;,duplicateSetResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;93-collectorstocollection&quot;&gt;9.3 Collectors.toCollection()&lt;/h2&gt;
&lt;p&gt;上面的toMap,toSet转换出来的都是特定的类型，如果我们需要自定义，则可以使用toCollection()&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; custListResult = list.stream().collect(Collectors.toCollection(LinkedList::new));
        log.info(&quot;{}&quot;,custListResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子，我们转换成了LinkedList。&lt;/p&gt;
&lt;h2 id=&quot;94-collectorstomap&quot;&gt;9.4 Collectors.toMap()&lt;/h2&gt;
&lt;p&gt;toMap接收两个参数，第一个参数是keyMapper，第二个参数是valueMapper:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;String, Integer&amp;gt; mapResult = list.stream()
                .collect(Collectors.toMap(Function.identity(), String::length));
        log.info(&quot;{}&quot;,mapResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果stream中有重复的值，则转换会报IllegalStateException异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;String, Integer&amp;gt; duplicateMapResult = duplicateList.stream()
                .collect(Collectors.toMap(Function.identity(), String::length));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么解决这个问题呢？我们可以这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;String, Integer&amp;gt; duplicateMapResult2 = duplicateList.stream()
                .collect(Collectors.toMap(Function.identity(), String::length, (item, identicalItem) -&amp;gt; item));
        log.info(&quot;{}&quot;,duplicateMapResult2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在toMap中添加第三个参数mergeFunction，来解决冲突的问题。&lt;/p&gt;
&lt;h2 id=&quot;95-collectorscollectingandthen&quot;&gt;9.5 Collectors.collectingAndThen()&lt;/h2&gt;
&lt;p&gt;collectingAndThen允许我们对生成的集合再做一次操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; collectAndThenResult = list.stream()
                .collect(Collectors.collectingAndThen(Collectors.toList(), l -&amp;gt; {return new ArrayList&amp;lt;&amp;gt;(l);}));
        log.info(&quot;{}&quot;,collectAndThenResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;96-collectorsjoining&quot;&gt;9.6 Collectors.joining()&lt;/h2&gt;
&lt;p&gt;Joining用来连接stream中的元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String joinResult = list.stream().collect(Collectors.joining());
        log.info(&quot;{}&quot;,joinResult);
        String joinResult1 = list.stream().collect(Collectors.joining(&quot; &quot;));
        log.info(&quot;{}&quot;,joinResult1);
        String joinResult2 = list.stream().collect(Collectors.joining(&quot; &quot;, &quot;prefix&quot;,&quot;suffix&quot;));
        log.info(&quot;{}&quot;,joinResult2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以不带参数，也可以带一个参数，也可以带三个参数，根据我们的需要进行选择。&lt;/p&gt;
&lt;h2 id=&quot;97-collectorscounting&quot;&gt;9.7 Collectors.counting()&lt;/h2&gt;
&lt;p&gt;counting主要用来统计stream中元素的个数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Long countResult = list.stream().collect(Collectors.counting());
        log.info(&quot;{}&quot;,countResult);
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;SummarizingDouble/Long/Int为stream中的元素生成了统计信息，返回的结果是一个统计类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;IntSummaryStatistics intResult = list.stream()
                .collect(Collectors.summarizingInt(String::length));
        log.info(&quot;{}&quot;,intResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;22:22:35.238 [main] INFO com.flydean.CollectorUsage - IntSummaryStatistics{count=4, sum=16, min=3, average=4.000000, max=5}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;99-collectorsaveragingdoublelongint&quot;&gt;9.9 Collectors.averagingDouble/Long/Int()&lt;/h2&gt;
&lt;p&gt;averagingDouble/Long/Int()对stream中的元素做平均：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Double averageResult = list.stream().collect(Collectors.averagingInt(String::length));
        log.info(&quot;{}&quot;,averageResult);
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;summingDouble/Long/Int()对stream中的元素做sum操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Double summingResult = list.stream().collect(Collectors.summingDouble(String::length));
        log.info(&quot;{}&quot;,summingResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;911-collectorsmaxbyminby&quot;&gt;9.11 Collectors.maxBy()/minBy()&lt;/h2&gt;
&lt;p&gt;maxBy()/minBy()根据提供的Comparator，返回stream中的最大或者最小值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;String&amp;gt; maxByResult = list.stream().collect(Collectors.maxBy(Comparator.naturalOrder()));
        log.info(&quot;{}&quot;,maxByResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;912-collectorsgroupingby&quot;&gt;9.12 Collectors.groupingBy()&lt;/h2&gt;
&lt;p&gt;GroupingBy根据某些属性进行分组，并返回一个Map：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;Integer, Set&amp;lt;String&amp;gt;&amp;gt; groupByResult = list.stream()
                .collect(Collectors.groupingBy(String::length, Collectors.toSet()));
        log.info(&quot;{}&quot;,groupByResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;913-collectorspartitioningby&quot;&gt;9.13 Collectors.partitioningBy()&lt;/h2&gt;
&lt;p&gt;PartitioningBy是一个特别的groupingBy，PartitioningBy返回一个Map，这个Map是以boolean值为key，从而将stream分成两部分，一部分是匹配PartitioningBy条件的，一部分是不满足条件的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; Map&amp;lt;Boolean, List&amp;lt;String&amp;gt;&amp;gt; partitionResult = list.stream()
                .collect(Collectors.partitioningBy(s -&amp;gt; s.length() &amp;gt; 3));
        log.info(&quot;{}&quot;,partitionResult);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看下运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;22:39:37.082 [main] INFO com.flydean.CollectorUsage - {false=[bob], true=[jack, alice, mark]}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果被分成了两部分。&lt;/p&gt;

&lt;p&gt;在之前的java collectors文章里面，我们讲到了stream的collect方法可以调用Collectors里面的toList()或者toMap()方法，将结果转换为特定的集合类。&lt;/p&gt;
&lt;p&gt;今天我们介绍一下怎么自定义一个Collector。&lt;/p&gt;
&lt;h2 id=&quot;101-collector介绍&quot;&gt;10.1 Collector介绍&lt;/h2&gt;
&lt;p&gt;我们先看一下Collector的定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414193724654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_25,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Collector接口需要实现supplier(),accumulator(),combiner(),finisher(),characteristics()这5个接口。&lt;/p&gt;
&lt;p&gt;同时Collector也提供了两个静态of方法来方便我们创建一个Collector实例。&lt;/p&gt;
&lt;p&gt;我们可以看到两个方法的参数跟Collector接口需要实现的接口是一一对应的。&lt;/p&gt;
&lt;p&gt;下面分别解释一下这几个参数：&lt;/p&gt;
&lt;p&gt;Supplier是一个函数，用来创建一个新的可变的集合。换句话说Supplier用来创建一个初始的集合。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;accumulator&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;accumulator定义了累加器，用来将原始元素添加到集合中。&lt;/p&gt;
&lt;p&gt;combiner用来将两个集合合并成一个。&lt;/p&gt;
&lt;p&gt;finisher将集合转换为最终的集合类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;characteristics&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;characteristics表示该集合的特征。这个不是必须的参数。&lt;/p&gt;
&lt;p&gt;Collector定义了三个参数类型，T是输入元素的类型，A是reduction operation的累加类型也就是Supplier的初始类型，R是最终的返回类型。 我们画个图来看一下这些类型之间的转换关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200430173026607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_25,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这几个参数，我们接下来看看怎么使用这些参数来构造一个自定义Collector。&lt;/p&gt;
&lt;h2 id=&quot;102-自定义collector&quot;&gt;10.2 自定义Collector&lt;/h2&gt;
&lt;p&gt;我们利用Collector的of方法来创建一个不变的Set：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static &amp;lt;T&amp;gt; Collector&amp;lt;T, Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;&amp;gt; toImmutableSet() {
        return Collector.of(HashSet::new, Set::add,
                (left, right) -&amp;gt; {
                    left.addAll(right);
                    return left;
                }, Collections::unmodifiableSet);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们HashSet::new作为supplier，Set::add作为accumulator，自定义了一个方法作为combiner，最后使用Collections::unmodifiableSet将集合转换成不可变集合。&lt;/p&gt;
&lt;p&gt;上面我们固定使用HashSet::new作为初始集合的生成方法，实际上，上面的方法可以更加通用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static &amp;lt;T, A extends Set&amp;lt;T&amp;gt;&amp;gt; Collector&amp;lt;T, A, Set&amp;lt;T&amp;gt;&amp;gt; toImmutableSet(
            Supplier&amp;lt;A&amp;gt; supplier) {

        return Collector.of(
                supplier,
                Set::add, (left, right) -&amp;gt; {
                    left.addAll(right);
                    return left;
                }, Collections::unmodifiableSet);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的方法，我们将supplier提出来作为一个参数，由外部来定义。&lt;/p&gt;
&lt;p&gt;看下上面两个方法的测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Test
    public void toImmutableSetUsage(){
        Set&amp;lt;String&amp;gt; stringSet1=Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)
                .collect(ImmutableSetCollector.toImmutableSet());
        log.info(&quot;{}&quot;,stringSet1);

        Set&amp;lt;String&amp;gt; stringSet2=Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)
                .collect(ImmutableSetCollector.toImmutableSet(LinkedHashSet::new));
        log.info(&quot;{}&quot;,stringSet2);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;INFO com.flydean.ImmutableSetCollector - [a, b, c, d]
INFO com.flydean.ImmutableSetCollector - [a, b, c, d]
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Stream API提供了一些预定义的reduce操作，比如count(), max(), min(), sum()等。如果我们需要自己写reduce的逻辑，则可以使用reduce方法。&lt;/p&gt;
&lt;p&gt;本文将会详细分析一下reduce方法的使用，并给出具体的例子。&lt;/p&gt;
&lt;h2 id=&quot;111-reduce详解&quot;&gt;11.1 reduce详解&lt;/h2&gt;
&lt;p&gt;Stream类中有三种reduce，分别接受1个参数，2个参数，和3个参数，首先来看一个参数的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;T&amp;gt; reduce(BinaryOperator&amp;lt;T&amp;gt; accumulator);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法接受一个BinaryOperator参数，BinaryOperator是一个@FunctionalInterface,需要实现方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;R apply(T t, U u);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;accumulator告诉reduce方法怎么去累计stream中的数据。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; intList = Arrays.asList(1,2,3);
        Optional&amp;lt;Integer&amp;gt; result1=intList.stream().reduce(Integer::sum);
        log.info(&quot;{}&quot;,result1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;com.flydean.ReduceUsage - Optional[6]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个参数的例子很简单。这里不再多说。&lt;/p&gt;
&lt;p&gt;接下来我们再看一下两个参数的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法接收两个参数：identity和accumulator。多出了一个参数identity。&lt;/p&gt;
&lt;p&gt;也许在有些文章里面有人告诉你identity是reduce的初始化值，可以随便指定，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Integer result2=intList.stream().reduce(100, Integer::sum);
        log.info(&quot;{}&quot;,result2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子，我们计算的值是106。&lt;/p&gt;
&lt;p&gt;如果我们将stream改成parallelStream：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Integer result3=intList.parallelStream().reduce(100, Integer::sum);
        log.info(&quot;{}&quot;,result3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得出的结果就是306。&lt;/p&gt;
&lt;p&gt;为什么是306呢？因为在并行计算的时候，每个线程的初始累加值都是100，最后3个线程加出来的结果就是306。&lt;/p&gt;
&lt;p&gt;并行计算和非并行计算的结果居然不一样，这肯定不是JDK的问题，我们再看一下JDK中对identity的说明：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;identity必须是accumulator函数的一个identity，也就是说必须满足：对于所有的t,都必须满足 accumulator.apply(identity, t) == t&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以这里我们传入100是不对的，因为sum（100+1）！= 1。&lt;/p&gt;
&lt;p&gt;这里sum方法的identity只能是0。&lt;/p&gt;
&lt;p&gt;如果我们用0作为identity,则stream和parallelStream计算出的结果是一样的。这就是identity的真正意图。&lt;/p&gt;
&lt;p&gt;下面再看一下三个参数的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;U&amp;gt; U reduce(U identity,
                 BiFunction&amp;lt;U, ? super T, U&amp;gt; accumulator,
                 BinaryOperator&amp;lt;U&amp;gt; combiner);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和前面的方法不同的是，多了一个combiner，这个combiner用来合并多线程计算的结果。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;同样的，identity需要满足combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家可能注意到了为什么accumulator的类型是BiFunction而combiner的类型是BinaryOperator？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface BinaryOperator&amp;lt;T&amp;gt; extends BiFunction&amp;lt;T,T,T&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BinaryOperator是BiFunction的子接口。BiFunction中定义了要实现的apply方法。&lt;/p&gt;
&lt;p&gt;其实reduce底层方法的实现只用到了apply方法，并没有用到接口中其他的方法，所以我猜测这里的不同只是为了简单的区分。&lt;/p&gt;
&lt;p&gt;虽然reduce是一个很常用的方法，但是大家一定要遵循identity的规范，并不是所有的identity都是合适的。&lt;/p&gt;

&lt;p&gt;Spliterator是在java 8引入的一个接口，它通常和stream一起使用，用来遍历和分割序列。&lt;/p&gt;
&lt;p&gt;只要用到stream的地方都需要Spliterator，比如List，Collection，IO channel等等。&lt;/p&gt;
&lt;p&gt;我们先看一下Collection中stream方法的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;default Stream&amp;lt;E&amp;gt; stream() {
        return StreamSupport.stream(spliterator(), false);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;default Stream&amp;lt;E&amp;gt; parallelStream() {
        return StreamSupport.stream(spliterator(), true);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，不管是并行stream还是非并行stream，都是通过StreamSupport来构造的，并且都需要传入一个spliterator的参数。&lt;/p&gt;
&lt;p&gt;好了，我们知道了spliterator是做什么的之后，看一下它的具体结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414221557893.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spliterator有四个必须实现的方法，我们接下来进行详细的讲解。&lt;/p&gt;
&lt;h2 id=&quot;121-tryadvance&quot;&gt;12.1 tryAdvance&lt;/h2&gt;
&lt;p&gt;tryAdvance就是对stream中的元素进行处理的方法，如果元素存在，则对他进行处理，并返回true，否则返回false。&lt;/p&gt;
&lt;p&gt;如果我们不想处理stream后续的元素，则在tryAdvance中返回false即可，利用这个特征，我们可以中断stream的处理。这个例子我将会在后面的文章中讲到。&lt;/p&gt;
&lt;h2 id=&quot;122-trysplit&quot;&gt;12.2 trySplit&lt;/h2&gt;
&lt;p&gt;trySplit尝试对现有的stream进行分拆，一般用在parallelStream的情况，因为在并发stream下，我们需要用多线程去处理stream的不同元素，trySplit就是对stream中元素进行分拆处理的方法。&lt;/p&gt;
&lt;p&gt;理想情况下trySplit应该将stream拆分成数目相同的两部分才能最大提升性能。&lt;/p&gt;
&lt;h2 id=&quot;123-estimatesize&quot;&gt;12.3 estimateSize&lt;/h2&gt;
&lt;p&gt;estimateSize表示Spliterator中待处理的元素，在trySplit之前和之后一般是不同的，后面我们会在具体的例子中说明。&lt;/p&gt;
&lt;h2 id=&quot;124-characteristics&quot;&gt;12.4 characteristics&lt;/h2&gt;
&lt;p&gt;characteristics表示这个Spliterator的特征，Spliterator有8大特征：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static final int ORDERED    = 0x00000010;//表示元素是有序的（每一次遍历结果相同）
public static final int DISTINCT   = 0x00000001;//表示元素不重复
public static final int SORTED     = 0x00000004;//表示元素是按一定规律进行排列（有指定比较器）
public static final int SIZED      = 0x00000040;//
表示大小是固定的
public static final int NONNULL    = 0x00000100;//表示没有null元素
public static final int IMMUTABLE  = 0x00000400;//表示元素不可变
public static final int CONCURRENT = 0x00001000;//表示迭代器可以多线程操作
public static final int SUBSIZED   = 0x00004000;//表示子Spliterators都具有SIZED特性
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个Spliterator可以有多个特征，多个特征进行or运算，最后得到最终的characteristics。&lt;/p&gt;
&lt;h2 id=&quot;125-举个例子&quot;&gt;12.5 举个例子&lt;/h2&gt;
&lt;p&gt;上面我们讨论了Spliterator一些关键方法，现在我们举一个具体的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@AllArgsConstructor
@Data
public class CustBook {
    private String name;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先定义一个CustBook类，里面放一个name变量。&lt;/p&gt;
&lt;p&gt;定义一个方法，来生成一个CustBook的list：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static List&amp;lt;CustBook&amp;gt; generateElements() {
        return Stream.generate(() -&amp;gt; new CustBook(&quot;cust book&quot;))
                .limit(1000)
                .collect(Collectors.toList());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义一个call方法，在call方法中调用了tryAdvance方法，传入了我们自定义的处理方法。这里我们修改book的name,并附加额外的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public String call(Spliterator&amp;lt;CustBook&amp;gt; spliterator) {
        int current = 0;
        while (spliterator.tryAdvance(a -&amp;gt; a.setName(&quot;test name&quot;
                .concat(&quot;- add new name&quot;)))) {
            current++;
        }

        return Thread.currentThread().getName() + &quot;:&quot; + current;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，写一下测试方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Test
    public void useTrySplit(){
        Spliterator&amp;lt;CustBook&amp;gt; split1 = SpliteratorUsage.generateElements().spliterator();
        Spliterator&amp;lt;CustBook&amp;gt; split2 = split1.trySplit();

        log.info(&quot;before tryAdvance: {}&quot;,split1.estimateSize());
        log.info(&quot;Characteristics {}&quot;,split1.characteristics());
        log.info(call(split1));
        log.info(call(split2));
        log.info(&quot;after tryAdvance {}&quot;,split1.estimateSize());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;23:10:08.852 [main] INFO com.flydean.SpliteratorUsage - before tryAdvance: 500
23:10:08.857 [main] INFO com.flydean.SpliteratorUsage - Characteristics 16464
23:10:08.858 [main] INFO com.flydean.SpliteratorUsage - main:500
23:10:08.858 [main] INFO com.flydean.SpliteratorUsage - main:500
23:10:08.858 [main] INFO com.flydean.SpliteratorUsage - after tryAdvance 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;List总共有1000条数据，调用一次trySplit之后，将List分成了两部分，每部分500条数据。&lt;/p&gt;
&lt;p&gt;注意，在tryAdvance调用之后，estimateSize变为0，表示所有的元素都已经被处理完毕。&lt;/p&gt;
&lt;p&gt;再看一下这个Characteristics=16464，转换为16进制：Ox4050 = ORDERED or SIZED or SUBSIZED 这三个的或运算。&lt;/p&gt;
&lt;p&gt;这也是ArrayList的基本特征。&lt;/p&gt;

&lt;p&gt;我们通常需要在java stream中遍历处理里面的数据，其中foreach是最最常用的方法。&lt;/p&gt;
&lt;p&gt;但是有时候我们并不想处理完所有的数据，或者有时候Stream可能非常的长，或者根本就是无限的。&lt;/p&gt;
&lt;p&gt;一种方法是先filter出我们需要处理的数据，然后再foreach遍历。&lt;/p&gt;
&lt;p&gt;那么我们如何直接break这个stream呢？今天本文重点讲解一下这个问题。&lt;/p&gt;
&lt;h2 id=&quot;131-使用spliterator&quot;&gt;13.1 使用Spliterator&lt;/h2&gt;
&lt;p&gt;上篇文章我们在讲Spliterator的时候提到了，在tryAdvance方法中，如果返回false，则Spliterator将会停止处理后续的元素。&lt;/p&gt;
&lt;p&gt;通过这个思路，我们可以创建自定义Spliterator。&lt;/p&gt;
&lt;p&gt;假如我们有这样一个stream：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Stream&amp;lt;Integer&amp;gt; ints = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们想定义一个操作，当x &amp;gt; 5的时候就停止。&lt;/p&gt;
&lt;p&gt;我们定义一个通用的Spliterator：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomSpliterator&amp;lt;T&amp;gt; extends Spliterators.AbstractSpliterator&amp;lt;T&amp;gt;  {

    private Spliterator&amp;lt;T&amp;gt; splitr;
    private Predicate&amp;lt;T&amp;gt; predicate;
    private volatile boolean isMatched = true;

    public CustomSpliterator(Spliterator&amp;lt;T&amp;gt; splitr, Predicate&amp;lt;T&amp;gt; predicate) {
        super(splitr.estimateSize(), 0);
        this.splitr = splitr;
        this.predicate = predicate;
    }

    @Override
    public synchronized boolean tryAdvance(Consumer&amp;lt;? super T&amp;gt; consumer) {
        boolean hadNext = splitr.tryAdvance(elem -&amp;gt; {
            if (predicate.test(elem) &amp;amp;&amp;amp; isMatched) {
                consumer.accept(elem);
            } else {
                isMatched = false;
            }
        });
        return hadNext &amp;amp;&amp;amp; isMatched;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的类中，predicate是我们将要传入的判断条件，我们重写了tryAdvance，通过将predicate.test(elem)加入判断条件，从而当条件不满足的时候返回false.&lt;/p&gt;
&lt;p&gt;看下怎么使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class CustomSpliteratorUsage {

    public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; takeWhile(Stream&amp;lt;T&amp;gt; stream, Predicate&amp;lt;T&amp;gt; predicate) {
        CustomSpliterator&amp;lt;T&amp;gt; customSpliterator = new CustomSpliterator&amp;lt;&amp;gt;(stream.spliterator(), predicate);
        return StreamSupport.stream(customSpliterator, false);
    }

    public static void main(String[] args) {
        Stream&amp;lt;Integer&amp;gt; ints = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List&amp;lt;Integer&amp;gt; result =
          takeWhile(ints, x -&amp;gt; x &amp;lt; 5 )
                        .collect(Collectors.toList());
        log.info(result.toString());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义了一个takeWhile方法，接收Stream和predicate条件。&lt;/p&gt;
&lt;p&gt;只有当predicate条件满足的时候才会继续，我们看下输出的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[main] INFO com.flydean.CustomSpliteratorUsage - [1, 2, 3, 4]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;132-自定义foreach方法&quot;&gt;13.2 自定义forEach方法&lt;/h2&gt;
&lt;p&gt;除了使用Spliterator，我们还可以自定义forEach方法来使用自己的遍历逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomForEach {

    public static class Breaker {
        private volatile boolean shouldBreak = false;

        public void stop() {
            shouldBreak = true;
        }

        boolean get() {
            return shouldBreak;
        }
    }

    public static &amp;lt;T&amp;gt; void forEach(Stream&amp;lt;T&amp;gt; stream, BiConsumer&amp;lt;T, Breaker&amp;gt; consumer) {
        Spliterator&amp;lt;T&amp;gt; spliterator = stream.spliterator();
        boolean hadNext = true;
        Breaker breaker = new Breaker();

        while (hadNext &amp;amp;&amp;amp; !breaker.get()) {
            hadNext = spliterator.tryAdvance(elem -&amp;gt; {
                consumer.accept(elem, breaker);
            });
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们在forEach中引入了一个外部变量，通过判断这个外部变量来决定是否进入spliterator.tryAdvance方法。&lt;/p&gt;
&lt;p&gt;看下怎么使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class CustomForEachUsage {

    public static void main(String[] args) {
        Stream&amp;lt;Integer&amp;gt; ints = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        CustomForEach.forEach(ints, (elem, breaker) -&amp;gt; {
            if (elem &amp;gt;= 5 ) {
                breaker.stop();
            } else {
                result.add(elem);
            }
        });
        log.info(result.toString());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们用新的forEach方法，并通过判断条件来重置判断flag，从而达到break stream的目的。&lt;/p&gt;

&lt;p&gt;Predicate是一个FunctionalInterface，代表的方法需要输入一个参数，返回boolean类型。通常用在stream的filter中，表示是否满足过滤条件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    boolean test(T t);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;141-基本使用&quot;&gt;14.1 基本使用&lt;/h2&gt;
&lt;p&gt;我们先看下在stream的filter中怎么使用Predicate：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Test
    public void basicUsage(){
        List&amp;lt;String&amp;gt; stringList=Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;).filter(s -&amp;gt; s.startsWith(&quot;a&quot;)).collect(Collectors.toList());
        log.info(&quot;{}&quot;,stringList);
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子很基础了，这里就不多讲了。&lt;/p&gt;
&lt;h2 id=&quot;142-使用多个filter&quot;&gt;14.2 使用多个Filter&lt;/h2&gt;
&lt;p&gt;如果我们有多个Predicate条件，则可以使用多个filter来进行过滤：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public void multipleFilters(){
        List&amp;lt;String&amp;gt; stringList=Stream.of(&quot;a&quot;,&quot;ab&quot;,&quot;aac&quot;,&quot;ad&quot;).filter(s -&amp;gt; s.startsWith(&quot;a&quot;))
                .filter(s -&amp;gt; s.length()&amp;gt;1)
                .collect(Collectors.toList());
        log.info(&quot;{}&quot;,stringList);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们又添加了一个filter，在filter又添加了一个Predicate。&lt;/p&gt;
&lt;h2 id=&quot;143-使用复合predicate&quot;&gt;14.3 使用复合Predicate&lt;/h2&gt;
&lt;p&gt;Predicate的定义是输入一个参数，返回boolean值，那么如果有多个测试条件，我们可以将其合并成一个test方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Test
    public void complexPredicate(){
        List&amp;lt;String&amp;gt; stringList=Stream.of(&quot;a&quot;,&quot;ab&quot;,&quot;aac&quot;,&quot;ad&quot;)
                .filter(s -&amp;gt; s.startsWith(&quot;a&quot;) &amp;amp;&amp;amp;  s.length()&amp;gt;1)
                .collect(Collectors.toList());
        log.info(&quot;{}&quot;,stringList);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们把s.startsWith(&quot;a&quot;) &amp;amp;&amp;amp; s.length()&amp;gt;1 作为test的实现。&lt;/p&gt;
&lt;h2 id=&quot;144-组合predicate&quot;&gt;14.4 组合Predicate&lt;/h2&gt;
&lt;p&gt;Predicate虽然是一个interface，但是它有几个默认的方法可以用来实现Predicate之间的组合操作。&lt;/p&gt;
&lt;p&gt;比如：Predicate.and(), Predicate.or(), 和 Predicate.negate()。&lt;/p&gt;
&lt;p&gt;下面看下他们的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
    public void combiningPredicate(){
        Predicate&amp;lt;String&amp;gt; predicate1 = s -&amp;gt; s.startsWith(&quot;a&quot;);
        Predicate&amp;lt;String&amp;gt; predicate2 =  s -&amp;gt; s.length() &amp;gt; 1;
        List&amp;lt;String&amp;gt; stringList1 = Stream.of(&quot;a&quot;,&quot;ab&quot;,&quot;aac&quot;,&quot;ad&quot;)
                .filter(predicate1.and(predicate2))
                .collect(Collectors.toList());
        log.info(&quot;{}&quot;,stringList1);

        List&amp;lt;String&amp;gt; stringList2 = Stream.of(&quot;a&quot;,&quot;ab&quot;,&quot;aac&quot;,&quot;ad&quot;)
                .filter(predicate1.or(predicate2))
                .collect(Collectors.toList());
        log.info(&quot;{}&quot;,stringList2);

        List&amp;lt;String&amp;gt; stringList3 = Stream.of(&quot;a&quot;,&quot;ab&quot;,&quot;aac&quot;,&quot;ad&quot;)
                .filter(predicate1.or(predicate2.negate()))
                .collect(Collectors.toList());
        log.info(&quot;{}&quot;,stringList3);

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，我们并不需要显示的assign一个predicate，只要是满足&lt;br/&gt;predicate接口的lambda表达式都可以看做是一个predicate。同样可以调用and，or和negate操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; stringList4 = Stream.of(&quot;a&quot;,&quot;ab&quot;,&quot;aac&quot;,&quot;ad&quot;)
                .filter(((Predicate&amp;lt;String&amp;gt;)a -&amp;gt; a.startsWith(&quot;a&quot;))
                        .and(a -&amp;gt; a.length() &amp;gt; 1))
                .collect(Collectors.toList());
        log.info(&quot;{}&quot;,stringList4);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;145-predicate的集合操作&quot;&gt;14.5 Predicate的集合操作&lt;/h2&gt;
&lt;p&gt;如果我们有一个Predicate集合，我们可以使用reduce方法来对其进行合并运算：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
    public void combiningPredicateCollection(){
        List&amp;lt;Predicate&amp;lt;String&amp;gt;&amp;gt; allPredicates = new ArrayList&amp;lt;&amp;gt;();
        allPredicates.add(a -&amp;gt; a.startsWith(&quot;a&quot;));
        allPredicates.add(a -&amp;gt; a.length() &amp;gt; 1);

        List&amp;lt;String&amp;gt; stringList = Stream.of(&quot;a&quot;,&quot;ab&quot;,&quot;aac&quot;,&quot;ad&quot;)
                .filter(allPredicates.stream().reduce(x-&amp;gt;true, Predicate::and))
                .collect(Collectors.toList());
        log.info(&quot;{}&quot;,stringList);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们调用reduce方法，对集合中的Predicate进行了and操作。&lt;/p&gt;

&lt;p&gt;在java中，我们可以将特定的集合转换成为stream，那么在有些情况下，比如测试环境中，我们需要构造一定数量元素的stream，需要怎么处理呢？&lt;/p&gt;
&lt;p&gt;这里我们可以构建一个无限的stream，然后调用limit方法来限定返回的数目。&lt;/p&gt;
&lt;h2 id=&quot;151-基本使用&quot;&gt;15.1 基本使用&lt;/h2&gt;
&lt;p&gt;先看一个使用Stream.iterate来创建无限Stream的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Test
    public void infiniteStream(){
        Stream&amp;lt;Integer&amp;gt; infiniteStream = Stream.iterate(0, i -&amp;gt; i + 1);
        List&amp;lt;Integer&amp;gt; collect = infiniteStream
                .limit(10)
                .collect(Collectors.toList());
        log.info(&quot;{}&quot;,collect);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们通过调用Stream.iterate方法，创建了一个0，1，2，3，4....的无限stream。&lt;/p&gt;
&lt;p&gt;然后调用limit(10)来获取其中的前10个。最后调用collect方法将其转换成为一个集合。&lt;/p&gt;
&lt;p&gt;看下输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;INFO com.flydean.InfiniteStreamUsage - [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;152-自定义类型&quot;&gt;15.2 自定义类型&lt;/h2&gt;
&lt;p&gt;如果我们想输出自定义类型的集合，该怎么处理呢？&lt;/p&gt;
&lt;p&gt;首先，我们定义一个自定义类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@AllArgsConstructor
public class IntegerWrapper {
    private Integer integer;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后利用Stream.generate的生成器来创建这个自定义类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static IntegerWrapper generateCustType(){
        return new IntegerWrapper(new Random().nextInt(100));
    }

    @Test
    public void infiniteCustType(){
        Supplier&amp;lt;IntegerWrapper&amp;gt; randomCustTypeSupplier = InfiniteStreamUsage::generateCustType;
        Stream&amp;lt;IntegerWrapper&amp;gt; infiniteStreamOfCustType = Stream.generate(randomCustTypeSupplier);

        List&amp;lt;IntegerWrapper&amp;gt; collect = infiniteStreamOfCustType
                .skip(10)
                .limit(10)
                .collect(Collectors.toList());
        log.info(&quot;{}&quot;,collect);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看下输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;INFO com.flydean.InfiniteStreamUsage - [IntegerWrapper(integer=46), IntegerWrapper(integer=42), IntegerWrapper(integer=67), IntegerWrapper(integer=11), IntegerWrapper(integer=14), IntegerWrapper(integer=80), IntegerWrapper(integer=15), IntegerWrapper(integer=19), IntegerWrapper(integer=72), IntegerWrapper(integer=41)]
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;之前我们讲到parallelStream的底层使用到了ForkJoinPool来提交任务的，默认情况下ForkJoinPool为每一个处理器创建一个线程，parallelStream如果没有特别指明的情况下，都会使用这个共享线程池来提交任务。&lt;/p&gt;
&lt;p&gt;那么在特定的情况下，我们想使用自定义的ForkJoinPool该怎么处理呢？&lt;/p&gt;
&lt;h2 id=&quot;161-通常操作&quot;&gt;16.1 通常操作&lt;/h2&gt;
&lt;p&gt;假如我们想做一个从1到1000的加法，我们可以用并行stream这样做：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; integerList= IntStream.range(1,1000).boxed().collect(Collectors.toList());
        ForkJoinPool customThreadPool = new ForkJoinPool(4);

        Integer total= integerList.parallelStream().reduce(0, Integer::sum);
        log.info(&quot;{}&quot;,total);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;INFO com.flydean.CustThreadPool - 499500
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;162-使用自定义forkjoinpool&quot;&gt;16.2 使用自定义ForkJoinPool&lt;/h2&gt;
&lt;p&gt;上面的例子使用的共享的thread pool。 我们看下怎么使用自定义的thread pool来提交并行stream：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; integerList= IntStream.range(1,1000).boxed().collect(Collectors.toList());

ForkJoinPool customThreadPool = new ForkJoinPool(4);
        Integer actualTotal = customThreadPool.submit(
                () -&amp;gt; integerList.parallelStream().reduce(0, Integer::sum)).get();
        log.info(&quot;{}&quot;,actualTotal);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们定义了一个4个线程的ForkJoinPool，并使用它来提交了这个parallelStream。&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;INFO com.flydean.CustThreadPool - 499500
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不想使用公共的线程池，则可以使用自定义的ForkJoinPool来提交。&lt;/p&gt;

&lt;p&gt;本文统一介绍了Stream和lambda表达式的使用，涵盖了Stream和lambda表达式的各个小的细节，希望大家能够喜欢。&lt;/p&gt;
&lt;p&gt;本文的代码&lt;a href=&quot;https://github.com/ddean2009/learn-java-streams/&quot;&gt;https://github.com/ddean2009/learn-java-streams/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的PDF&lt;a href=&quot;https://github.com/ddean2009/www.flydean.com/blob/master/java/stream/java-stream-lambda-all-in-one.pdf&quot;&gt;java-stream-lambda-all-in-one.pdf&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;最通俗的解读，最深刻的干货，最简洁的教程，众多你不知道的小技巧等你来发现！&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:「程序那些事」,懂技术，更懂你！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200709152618916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 26 Jul 2020 23:35:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>5万字长文详解介绍Stream和Lambda表达式最佳实践,干货实在太多，最后附上PDF下载，方便大家查阅！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/java-stream-lambda-all-in-one.html</dc:identifier>
</item>
</channel>
</rss>