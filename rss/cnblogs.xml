<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>对HTML5标签的认识(四) - Eden-Xie</title>
<link>http://www.cnblogs.com/xym15079750872/p/10701371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xym15079750872/p/10701371.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;span&gt;这篇随笔讲讲HTML5中的表单和表单的一些元素&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、表单的作用是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;概念：表单在网页中主要是负责对数据信息的采取，表单一共分成三个部分：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、表单的标签：这里面包含了处理表单的数据所用CGI程序以及数据提交到服务器的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、表单域元素：包含着文本框，和密码框，多行文本框，复选框，单选框，下拉选择框和文件上传框等等元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、表单按钮：包括提交的按钮，复位按钮和一般的按钮，用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;CGI是什么呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CGI是Web服务器运行时外部程序的规范，按CGI编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互，还可通过数据库API 与数据库服务器等外部数据源进行通信，从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413111539552-1186403413.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、表单标签的认识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&amp;lt;form&amp;gt;标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &amp;lt;form&amp;gt;标签用于为用户输入创建HTML表单，如下图是最常见的表单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413115425692-496203328.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;440&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表单能包含input元素比如文本字段，复选框，单选框，提交按钮等等&lt;/p&gt;
&lt;p&gt;表单的主要作用就是传输数据给服务器。&lt;/p&gt;

&lt;p&gt;定义一个简单的表单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Form&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;get/Post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;txtName&quot; /&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;txtName&quot; /&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413121442299-1511924171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到form元素里面的Method属性 它有连两个值 set和Post&lt;/p&gt;
&lt;p&gt;它们的区别：&lt;/p&gt;
&lt;p&gt;1、get是从服务器上获取数据，post是向服务器传送数据。&lt;/p&gt;
&lt;p&gt;2、对于get方式，服务器端用Request，QueryString获取变量值，对于post方式，服务器端用Request，Form获取提交的数据。&lt;/p&gt;
&lt;p&gt;3、get安全性较低，post安全性较高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413123540896-1301421517.png&quot; alt=&quot;&quot;/&gt;action属性是规定当提交表单时向何处发送表单数据。（&lt;span&gt;大概了解&lt;/span&gt;）&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、&amp;lt;input&amp;gt;标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：&amp;lt;input&amp;gt; 标签规定用户可输入数据的输入字段。&lt;/p&gt;
&lt;p&gt;根据不同的 type 属性，输入字段有多种形态。输入字段可以是文本字段、复选框、密码字段、单选按钮、按钮等等。&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413140041167-1854504526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义input可以在文本框里面输入内容了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type属性：规定input元素的名称&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;type属性值默认text值，表示定义一个单行的文本字段（默认宽度为 20 个字符）。&lt;/p&gt;
&lt;p&gt;type属性值有很多，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413141430102-462991504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413141513463-1969092932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;做一个两个文本输入框和两个单选按钮还有一个提交按钮的小案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Form&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;get&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;name属性是定有一个input元素的名称&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;文本输入框&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;txtName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;txtAge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;单选按钮的属性值为radio，当你要定义单选按钮时就用radio属性值&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;单选按钮&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;性别：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;男
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;女&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;提交按钮&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;input有很多属性，比如id，name，type，checked，size,max,min,height,form,width,value,list这些经常用的到的属性。&lt;/p&gt;
&lt;p&gt;就拿checked属性来说，我们在注册一个账号的时候经常能看到性别选项，按照人口惯例，是男性的概率偏多，所以在选择中时为了方便，我们可以给它一个默认选中男性(当然也可以现在女性)，这样让用户的体验更好。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Form&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;get&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;name属性是定有一个input元素的名称&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;文本输入框&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;txtName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;txtAge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;单选按钮的属性值为radio，当你要定义单选按钮时就用radio属性值&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;单选按钮&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;性别：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; checked&lt;/span&gt;&lt;span&gt;=&quot;checked&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;男
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;女&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;提交按钮&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413143217662-1106245125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413143248727-1337674071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多选框：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;textarea&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;爱好：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;游泳&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;游泳
                  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;唱歌&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;唱歌
                  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;篮球&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;篮球
                  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;跳舞&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;跳舞              
                  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413151647033-906235473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、&amp;lt;textarea&amp;gt;标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 定义：&amp;lt;textarea&amp;gt;标签定义多行的文本输入控件。文本中可容纳无限数量的文本，可通过clos和rows属性来规定textarea的尺寸，不过更好的办法就是使用css的height和width属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;textarea&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; cols&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;textarea标签是多行的文本输入控件。可通过rows和cols来改变尺寸&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413145111974-1602297921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、&amp;lt;button&amp;gt;标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：&amp;lt;button&amp;gt;标签是定义一个按钮。在button元素的内部，你可以放置内容，比如文本，图像，这是该元素于使用input元素创建的按钮之间的不同之处。相比&amp;lt;input type=&quot;   &quot;&amp;gt;有更强大的功能和更丰富的内容。&lt;/p&gt;
&lt;p&gt;请始终为按钮规定type属性，属性 Internet Explorer 的默认类型是button 而其他的浏览器中的默认值是“submit”。&lt;/p&gt;
&lt;p&gt;定义一个按钮：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;textarea&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;点击&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;：如果在HTML表单中使用button元素，不同的浏览器会提交不同的按钮值，请使用input元素在HTML，表单中创建按钮。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、&amp;lt;select&amp;gt;标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：select元素可创建单选多选菜单，&amp;lt;select&amp;gt;元素中的&amp;lt;option&amp;gt;标签用于定义列表中的可用选项。&lt;/p&gt;
&lt;p&gt;下拉菜单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413150808205-1474771561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;textarea&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;HTML5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HTML5网页编程语言&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;CSS&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;css样式&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;java编程&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Java编程&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;JavaScript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;JavaScript&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201904/1635146-20190413151216528-1462190008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;option&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注&lt;/span&gt;：1、&amp;lt;option&amp;gt;标签可以在不带有任何属性的情况下使用，但是你通常需要使用value属性，此属性会指示被送往服务器的内容。&lt;/p&gt;
&lt;p&gt;2、请与select元素配合使用此标签，否则这个标签毫无意义。&lt;/p&gt;

</description>
<pubDate>Sat, 13 Apr 2019 07:34:00 +0000</pubDate>
<dc:creator>Eden-Xie</dc:creator>
<og:description>这篇随笔讲讲HTML5中的表单和表单的一些元素 一、表单的作用是什么？ 概念：表单在网页中主要是负责对数据信息的采取，表单一共分成三个部分： 1、表单的标签：这里面包含了处理表单的数据所用CGI程序以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xym15079750872/p/10701371.html</dc:identifier>
</item>
<item>
<title>机场航站楼时钟系统设计方案 - mazhankang</title>
<link>http://www.cnblogs.com/syn029/p/10701364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/syn029/p/10701364.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;机场航站楼时钟系统设计方案&lt;/p&gt;
&lt;p&gt;为适应民用机场建设发展需要，保证民用机场航站楼弱电系统工程设计质量，特根据《MHT5019-2014民用机场航站楼时钟系统工程设计规范》设计出本时钟系统方案。&lt;/p&gt;
&lt;p&gt;专用术语解析&lt;/p&gt;
&lt;p&gt;1、母钟：接受标准卫星时间信息，与自身所设的时间信号源进行高科技的校正、处理后，发送时间信号给所属子系统的装置，&lt;/p&gt;
&lt;p&gt;2、子钟：接收母钟所发送的信号，进行显示的装置&lt;/p&gt;
&lt;p&gt;3、GPS时钟信号：全球定位系统发送的格林威治标准时间信号&lt;/p&gt;
&lt;p&gt;一般规定&lt;/p&gt;
&lt;p&gt;&lt;span&gt;母钟：&lt;/span&gt;SYN4505型标准同步时钟&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子钟：&lt;/span&gt;SYN6109型NTP子钟&lt;/p&gt;
&lt;p&gt;a、常见的民用机场航站楼的时钟系统的作用，应能为机场工作人员、旅客及各计算机管理系统提供准确统一的时间服务。&lt;/p&gt;
&lt;p&gt;b、一般机场只设常规子母钟系统，显示北京时间信息，有国际航班的机场，应增设世界钟显示有关城市的当地时间。&lt;/p&gt;
&lt;p&gt;子钟的类型分为单面子钟和双面子钟，单面子钟可采用指针式或者数显式。双面子钟宜采用数显式。各类子钟的显示内容可根据实际情况而定，但至少宜显示时分秒，数显钟应进行无反光处理，以保证显示效果。&lt;/p&gt;
&lt;p&gt;子钟安装位置&lt;/p&gt;
&lt;p&gt;1、指挥调度中心、广播室、会议室、航行气象情报室、机组签派室及其他对时间有特殊要求的地点宜装设子钟。&lt;/p&gt;
&lt;p&gt;2、对时间有特殊要求地航班动态显示机房及其他设备机房等宜装设子钟。&lt;/p&gt;
&lt;p&gt;3、在航站楼迎客、送客、候机、办理乘机手续、通道等场所醒目的地方宜装设子钟；在旅客餐厅、休息场所，也宜设置子钟。&lt;/p&gt;
&lt;p&gt;4、行李分拣、提取大厅宜装设子钟。&lt;/p&gt;
&lt;p&gt;5、由母钟统一校时的航显系统，在设置有能显示时间的航显终端的场所，应尽量减少或取消子钟的安装。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子钟的规格应根据安装的高度和视距的远近而定。安装高度一般距地面&lt;/span&gt;2.5m~5m，特殊场合可适当调整，但应满足美观。名目的使用要求。&lt;/p&gt;
&lt;p&gt;供电要求&lt;/p&gt;
&lt;p&gt;a、母钟和子钟的供电电源，一般由系统所在的电子设备机房的电源供给，当供电距离较远时，也可由就近的可靠电源提供&lt;/p&gt;
&lt;p&gt;b、母钟系统和子母钟设备的电源电压，一般按设备要求设备，当需要提高母钟的输出信号电压时，必须保证母钟工作电压和每一回路信号电流在允许的范围内。&lt;/p&gt;
&lt;p&gt;机场航站楼时钟系统可应用于城市重要公共建筑，如车站、高校、交通路口、标志建筑等场所和电信行业的移动及固定电话报时等方面。它是供了准确的公众时间，为人们的日常生活提供便利，避免了因时钟不准确而带来的不便。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 07:33:00 +0000</pubDate>
<dc:creator>mazhankang</dc:creator>
<og:description>机场航站楼时钟系统设计方案 为适应民用机场建设发展需要，保证民用机场航站楼弱电系统工程设计质量，特根据《MHT5019-2014民用机场航站楼时钟系统工程设计规范》设计出本时钟系统方案。 专用术语解析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/syn029/p/10701364.html</dc:identifier>
</item>
<item>
<title>数据结构--第四章串、数组和广义表总结 - 陈述v</title>
<link>http://www.cnblogs.com/yi2105/p/10700148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yi2105/p/10700148.html</guid>
<description>&lt;p&gt;知识点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1.串：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于串的学习，我最大的收获是理解了KMP算法（解决串的模式匹配问题)和了解了Manacher算法（解决求字符串最长回文问题）。&lt;/p&gt;
&lt;p&gt;在这一过程中，我常惊叹算法的巧妙，感慨前人的智慧结晶，以下是我对这两种算法的理解：&lt;/p&gt;

&lt;p&gt;（1）KMP算法：&lt;/p&gt;
&lt;p&gt;  这里就不贴代码了，就说说它的实现原理。具体可以看这里&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yi2105/p/10665769.html&quot;&gt;利用KMP算法解决串的模式匹配问题（c++) -- 数据结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主串和模式串匹配到某一个位置发现 主串中1的部分和模式串中2部分不匹配时，&lt;/p&gt;
&lt;p&gt;模式串就会移动一定的位置，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497599/201904/1497599-20190413151209938-1606055007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么我们该移动多少呢？&lt;/p&gt;
&lt;p&gt;我们继续往下看，上下这两个字符串分别是原来模式串的位置，和移动后模式串的位置。&lt;/p&gt;
&lt;p&gt;能够这样移动的前提是保证 A == B，原来的匹配点截至到了1和2（即d）部分，&lt;/p&gt;
&lt;p&gt;模式串移动之后匹配点就变成了1和c部分的比较。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497599/201904/1497599-20190413150910418-1127120170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;为了能够实现KMP算法中模式串的移动，需要引入一个next[ ]数组。&lt;/p&gt;
&lt;p&gt;next[ ] 存放已匹配子串中最长前后缀长度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497599/201904/1497599-20190413152014202-1505271209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 以红色部分c为例子：&lt;/p&gt;
&lt;p&gt;已匹配的子串：abaab   →  最长前后缀ab  长度为2&lt;/p&gt;


&lt;p&gt;KMP算法应用：PowerString问题（求字符串的最小周期）&lt;/p&gt;

&lt;p&gt;（2）Manacher算法（马拉车算法）：&lt;/p&gt;

&lt;p&gt; &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yi2105/p/10701117.html&quot;&gt;谈谈我对Manacher算法的理解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.数组：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至于数组的学习，最大的收获和成就就是理解了十字链表的原理和操作过程，并成功将以实现。&lt;/p&gt;
&lt;p&gt;以下博客已经写得挺详细的了，就不再重复声明：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yi2105/p/10685957.html&quot;&gt;利用十字链表压缩稀疏矩阵（c++）-- 数据结构&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;编程时遇到的困难：&lt;/p&gt;

&lt;p&gt;1.&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yi2105/p/10665769.html&quot;&gt;利用KMP算法解决串的模式匹配问题（c++) -- 数据结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yi2105/p/10685957.html&quot;&gt;利用十字链表压缩稀疏矩阵（c++）-- 数据结构&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;总结及学习心得:&lt;/p&gt;
&lt;p&gt; 在作业和实践的题目中，我都选择了相对来说困难的完成方式，这对我来说是一种得到锻炼和学习的最好方式。&lt;/p&gt;
&lt;p&gt;纵使过程很痛苦，熬了大半个星期的夜，幸运的是结果还算是差强人意。&lt;/p&gt;

&lt;p&gt;——林子里有两条路，我选择了行人稀少的那一条，它改变了我的一生。（《未选择的路》）&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;目标:&lt;/p&gt;
&lt;p&gt; 保持当前的学习热情，高要求严格自己，学习更多更巧妙的算法。&lt;/p&gt;

&lt;hr/&gt;
</description>
<pubDate>Sat, 13 Apr 2019 07:25:00 +0000</pubDate>
<dc:creator>陈述v</dc:creator>
<og:description>知识点： 1.串： 关于串的学习，我最大的收获是理解了KMP算法（解决串的模式匹配问题)和了解了Manacher算法（解决求字符串最长回文问题）。 在这一过程中，我常惊叹算法的巧妙，感慨前人的智慧结晶</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yi2105/p/10700148.html</dc:identifier>
</item>
<item>
<title>ES 16 - 对Elasticsearch中的索引数据进行增删改查(CRUD) - 马瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/10701141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/10701141.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;说在前面: 本文的所有演示, 都是基于Elasticsearch 6.6.10进行的, 不同的版本可能存在API发生修改、不支持的情况, 还请注意.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;创建时手动指定id&quot;&gt;1.1 创建时手动指定id&lt;/h2&gt;
&lt;p&gt;(1) 适用情景:&lt;/p&gt;
&lt;p&gt;从其他系统中导入数据到ES时, 会采取这种方式: 使用原有系统中数据已有的唯一标识, 作为ES中document的id.&lt;/p&gt;
&lt;p&gt;而如果数据一生产出来就存储到了ES中, 一般是不适合手动指定id的.&lt;/p&gt;
&lt;p&gt;(2) 使用语法:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;put index/type/id&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) 使用示例:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT employee/developer/1
{
    &quot;name&quot;: &quot;shoufeng&quot;, 
    &quot;e_id&quot;: 5220
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4) 添加成功后的响应信息:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;_index&quot; : &quot;employee&quot;,
  &quot;_type&quot; : &quot;developer&quot;,
  &quot;_id&quot; : &quot;1&quot;,          // 指定了id, 控制底层的_id元字段
  &quot;_version&quot; : 1,       // 当前版本号, 基于此字段进行并发控制
  &quot;result&quot; : &quot;created&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,        // 参与创建的分片数, 包括Primary和Replica
    &quot;successful&quot; : 1,   // 成功创建索引的分片数量
    &quot;failed&quot; : 0        // 创建索引失败的分片数量
  },
  &quot;_seq_no&quot; : 0,
  &quot;_primary_term&quot; : 1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建时自动生成id&quot;&gt;1.2 创建时自动生成id&lt;/h2&gt;
&lt;p&gt;(1) 使用情景:&lt;/p&gt;
&lt;p&gt;ES作为数据存储服务器, 应用程序中的数据直接对接到ES中, 这种场景适合自动生成id.&lt;/p&gt;
&lt;p&gt;在多节点并发生成大量数据的场景下, 自动生成id更具安全性.&lt;/p&gt;
&lt;p&gt;(2) 使用语法:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST index/type&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) 使用示例:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST employee/developer
{
    &quot;name&quot;: &quot;shoufeng&quot;,
    &quot;sex&quot;: &quot;male&quot;,
    &quot;age&quot;: 20
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4) 添加成功后的响应结果:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;_index&quot; : &quot;employee&quot;,
  &quot;_type&quot; : &quot;developer&quot;,
  &quot;_id&quot; : &quot;vMxcFWoBfKUnm9s_Uxen&quot;,  // 没有指定id, 就会自动生成id, 长度为20个字符
  &quot;_version&quot; : 1,
  &quot;result&quot; : &quot;created&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,
    &quot;successful&quot; : 1,
    &quot;failed&quot; : 0
  },
  &quot;_seq_no&quot; : 0,
  &quot;_primary_term&quot; : 1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;官方文档中指出:&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;Elasticsearch自动生成的id, 长度为20个字符, 是URL安全的, 它是Base64编码的GUID字符串, 多节点(分布式系统)并行生成id时不会发生冲突.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;根据id查询文档&quot;&gt;2.1 根据id查询文档&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;查询时可以不指定type, 即下述的developer, 而用_all代替.&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;// 查询语法:
GET employee/developer/1

// 结果如下: 
{
  &quot;_index&quot; : &quot;employee&quot;,
  &quot;_type&quot; : &quot;developer&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 1,
  &quot;_seq_no&quot; : 0,
  &quot;_primary_term&quot; : 1,
  &quot;found&quot; : true,
  &quot;_source&quot; : {          // 文档的元数据
    &quot;name&quot; : &quot;shoufeng&quot;,
    &quot;e_id&quot; : 5220
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通过_source字段控制查询结果&quot;&gt;2.2 通过_source字段控制查询结果&lt;/h2&gt;
&lt;p&gt;(1) 只获取指定id的文档的&lt;code&gt;_source&lt;/code&gt;内容:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET employee/developer/1/_source
// 结果是:
{
  &quot;name&quot; : &quot;shoufeng&quot;,
  &quot;e_id&quot; : 5220
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 禁用指定id的文档的&lt;code&gt;_source&lt;/code&gt;字段:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET employee/developer/1?_source=false
// 结果是:
{
  &quot;_index&quot; : &quot;employee&quot;,
  &quot;_type&quot; : &quot;developer&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 1,
  &quot;_seq_no&quot; : 0,
  &quot;_primary_term&quot; : 1,
  &quot;found&quot; : true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) 过滤&lt;code&gt;_source&lt;/code&gt;中的某些field:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;// _source_includes和_source_excludes可以匹配通配符*
GET employee/developer/1?_source_includes=name,age&amp;amp;_source_excludes=sex
GET employee/developer/_search?_source_includes=name,age&amp;amp;_source_excludes=sex&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4) 通过&lt;code&gt;stored_fields&lt;/code&gt; API过滤文档中已存储的字段:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在Elasticsearch 6.0之后, 不再支持&lt;code&gt;fields&lt;/code&gt;, 需要使用&lt;code&gt;stored_fields&lt;/code&gt;API替换.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET employee/developer/1?stored_fields=name,age              // 指定id
GET employee/developer/_search?stored_fields=name,age // 不指定id, 将查询所有文档&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;其他查询操作, 将在后续的文章中专门记录.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;全量替换document&quot;&gt;3.1 全量替换document&lt;/h2&gt;
&lt;p&gt;全量替换是基于指定文档id的修改:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;// 语法与创建语法相同: 
PUT employee/developer/1
{
    &quot;name&quot;: &quot;shoufeng001&quot;,  // 修改姓名
    &quot;age&quot;: 20,              // 添加年龄
    &quot;sex&quot;: &quot;male&quot;,          // 添加性别
    &quot;e_id&quot;: 5220
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;操作过程说明:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;① 如果指定的document id不存在, 就是创建操作;&lt;br/&gt;② 如果指定的document id已经存在, 就是全量替换操作 —— 替换旧文档的JSON串内容;&lt;br/&gt;③ &lt;strong&gt;Lucene中倒排索引一旦被创建就是不可变的&lt;/strong&gt;, 要修改文档内容, 可以采取全量替换的方式 —— 对文档重新建立索引, 替换旧文档的所有内容;&lt;br/&gt;④ ES会将旧文档标记为deleted, 然后根据我们提交的请求创建一个新文档, 当标记为deleted的文档数达到一定量时, ES会在自动删除这些旧文档.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;强制创建document&quot;&gt;3.2 强制创建document&lt;/h2&gt;
&lt;p&gt;(1) 存在这样的场景:&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;我们不知道索引中是否已经存在某个文档 —— 可能有其他用户在并发添加文档;&lt;br/&gt;为了防止创建操作被执行为全量替换操作, 从而导致数据的丢失, 我们可以使用强制创建的方式, 来避免这种失误.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(2) 强制创建示例:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT employee/developer/1?op_type=create
{
    &quot;name&quot;: &quot;shoufeng&quot;,
    &quot;age&quot;: 20
}
// 或者使用:
PUT employee/developer/1/_create
{
    &quot;name&quot;: &quot;shoufeng&quot;,
    &quot;age&quot;: 20
}

// 响应结果中出现冲突:
{
  &quot;error&quot;: {
    &quot;root_cause&quot;: [
      {         // 由于文档已经存在, 发生版本冲突, 导致创建失败
        &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,
        &quot;reason&quot;: &quot;[developer][1]: version conflict, document already exists (current version [2])&quot;,
        &quot;index_uuid&quot;: &quot;OYu6J2x_S2S5v-R74aq6NQ&quot;,
        &quot;shard&quot;: &quot;3&quot;,
        &quot;index&quot;: &quot;employee&quot;
      }
    ],
    &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,
    &quot;reason&quot;: &quot;[developer][1]: version conflict, document already exists (current version [2])&quot;,
    &quot;index_uuid&quot;: &quot;OYu6J2x_S2S5v-R74aq6NQ&quot;,
    &quot;shard&quot;: &quot;3&quot;,
    &quot;index&quot;: &quot;employee&quot;
  },
  &quot;status&quot;: 409
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出现冲突的原因:&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;① &lt;strong&gt;Elasticsearch通过乐观锁控制每个文档的&lt;code&gt;_version&lt;/code&gt;信息, 强制创建语法会对当前操作的文档的&lt;code&gt;_version&lt;/code&gt;信息进行初始化&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;② 添加索引时, 发现已经存在对应id的文档, 而且其版本号与正在强制创建的文档的版本信息不匹配, 所以报错.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出现冲突后, 我们就能知道索引中已存在该文档了, 就可以根据自己的应用需求, 采取更改id后重新添加, 或者更改已有的文档等操作.&lt;/p&gt;

&lt;p&gt;(1) 删除语法:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;DELETE index/type/id&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 删除示例:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;DELETE employee/developer/1
// 再次查看id为1的文档, 发现&quot;found&quot;: false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) &lt;strong&gt;Elasticsearch删除文档采取的是懒删除机制&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;不会立即物理删除, 而是将其标记为deleted, 当被删除的文档数量达到一定级别后, ES会在后台自动删除这些文档.&lt;/p&gt;
&lt;blockquote readability=&quot;16.040752351097&quot;&gt;

&lt;p&gt;作者: ma_shoufeng(马瘦风)&lt;/p&gt;
&lt;p&gt;出处: 博客园 &lt;a href=&quot;https://www.cnblogs.com/shoufeng&quot;&gt;马瘦风的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;您的支持是对博主的极大鼓励, 感谢您的阅读.&lt;/p&gt;
&lt;p&gt;本文版权归博主所有, 欢迎转载, 但请保留此段声明, 并在文章页面明显位置给出原文链接, 否则博主保留追究相关人员法律责任的权利.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 13 Apr 2019 06:49:00 +0000</pubDate>
<dc:creator>马瘦风</dc:creator>
<og:description>如何对Elasticsearch的索引数据进行增删改查操作? 新增数据时是否指定id? 如何通过`_id`和`_source`元字段查询文档, 全量修改和强制替换文档的使用, 删除文档的原理.....</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufeng/p/10701141.html</dc:identifier>
</item>
<item>
<title>Java单元测试神器之Mockito - 深夜里的程序猿</title>
<link>http://www.cnblogs.com/coding-night/p/10701033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coding-night/p/10701033.html</guid>
<description>&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;什么是 Mock 测试&lt;/h4&gt;
&lt;p&gt;Mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。什么是不容易构造的对象呢？例如HttpServletRequest，需要在有servlet容器环境中创建获取。那不容易获取的对象呢？如一个JedisCluster，需要准备redis相关环境，然后设置进去等等。&lt;/p&gt;
&lt;p&gt;Mock 可以分解在单元测试中耦合的其他类或者接口，它能够帮你模拟这些依赖，并帮你验证所调用的依赖的行为。&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;场景事例&lt;/h4&gt;

&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/3/169e0c30405cee2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/3/169e0c30405cee2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;432&quot; data-height=&quot;380&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当我们需要测试OrderService时，按照我们常规的做法呢，都是要先准备好redis，跟db的环境，然后构造UserService跟CouponService注入进来，此时需要构建完整的依赖树，其过程是比较繁琐的，万一数据库连不上，依赖找不到，服务挂了... 时间一长可能会打击我们对项目进行单测的积极性，所以这时候很有必要寻求一种优雅的方式来解决。&lt;/p&gt;
&lt;p&gt;铛铛铛~这时候Mockito出现了(java中Mock框架比较多，但是本篇只介绍这个)，它会把那些繁琐的依赖统统转化为Mock Object，如下图，这样我们就可以专注的进行我们的单测，减少在解决依赖上浪费的时间了。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/3/169e0c3396cb3a67?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/3/169e0c3396cb3a67?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;435&quot; data-height=&quot;328&quot;/&gt;&lt;/p&gt;

&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;直接开干&lt;/h4&gt;
&lt;p&gt;关于Mockito的简介这里就不在赘述了，大家有兴趣可以自行去官方文档查阅，这里主要带大家了解一些常用的Mock方法。&lt;/p&gt;
&lt;p&gt;maven依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mockito&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mockito-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.23.4&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了代码测试的方便，直接在测试类中静态导入 import static org.mockito.Mockito.*;&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;基础方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMockBase(){
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建ArrayList的Mock对象&lt;/span&gt;
       List mockList = mock(ArrayList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
       Assert.assertTrue(mockList &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ArrayList);

       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当我们mockList调用方法去add(&quot;张三&quot;)的时候会返回true&lt;/span&gt;
       when(mockList.add(&quot;张三&quot;)).thenReturn(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当我们mockList调用方法size()的时候返回10&lt;/span&gt;
       when(mockList.size()).thenReturn(10&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
       Assert.assertTrue(mockList.add(&quot;张三&quot;&lt;span&gt;));
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
       Assert.assertFalse(mockList.add(&quot;李四&quot;&lt;span&gt;));
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
       Assert.assertEquals(mockList.size(),10&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;
       System.out.println(mockList.get(0&lt;span&gt;));
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mock静态方法会创建一个Mock对象，由于 Mock对象 并不会真的执行方法中的代码，所以如果未指定返回值的话会返回默认值（如19行）。第九、十行我们指定了mockList在执行特定方法后需要返回的值，所以在assertTrue校验是没问题的，但是add(&quot;李四&quot;)，我们并没设置，所以是false。&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;校验方法调用次数&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用mock&lt;/span&gt;
 List mockedList = mock(ArrayList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
 mockedList.add(&lt;/span&gt;&quot;once&quot;&lt;span&gt;);

 mockedList.add(&lt;/span&gt;&quot;twice&quot;&lt;span&gt;);
 mockedList.add(&lt;/span&gt;&quot;twice&quot;&lt;span&gt;);

 mockedList.add(&lt;/span&gt;&quot;three times&quot;&lt;span&gt;);
 mockedList.add(&lt;/span&gt;&quot;three times&quot;&lt;span&gt;);
 mockedList.add(&lt;/span&gt;&quot;three times&quot;&lt;span&gt;);
 
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里默认是判断该方法调用times(1),同下&lt;/span&gt;
 verify(mockedList).add(&quot;once&quot;&lt;span&gt;);
 verify(mockedList, times(&lt;/span&gt;1)).add(&quot;once&quot;&lt;span&gt;);

 verify(mockedList, times(&lt;/span&gt;2)).add(&quot;twice&quot;&lt;span&gt;);
 verify(mockedList, times(&lt;/span&gt;3)).add(&quot;three times&quot;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从没调用，times(0)&lt;/span&gt;
 verify(mockedList, never()).add(&quot;never happened&quot;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最少一次，最少几次，最多几次&lt;/span&gt;
 verify(mockedList, atLeastOnce()).add(&quot;three times&quot;&lt;span&gt;);
 verify(mockedList, atLeast(&lt;/span&gt;2)).add(&quot;three times&quot;&lt;span&gt;);
 verify(mockedList, atMost(&lt;/span&gt;5)).add(&quot;three times&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实在上述的代码中，命名是比较直观的，所以我这边就直接注释在代码中了。&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;校验方法调用时长&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法执行在100ms以内的时候可以通过&lt;/span&gt;
   verify(mock, timeout(100&lt;span&gt;)).someMethod();
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同上&lt;/span&gt;
   verify(mock, timeout(100).times(1&lt;span&gt;)).someMethod();

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法2次调用均没超过100ms&lt;/span&gt;
   verify(mock, timeout(100).times(2&lt;span&gt;)).someMethod();

   verify(mock, timeout(&lt;/span&gt;100).atLeast(2)).someMethod();
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过超时检测可以校验我们的方法逻辑会不会有出现问题而导致超时的地方。&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;参数匹配&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
linkedList.add(&quot;element&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; anyInt() 任何整数我们都返回 element &lt;/span&gt;
when(linkedList.get(anyInt())).thenReturn(&quot;element&quot;&lt;span&gt;);

System.out.print(linkedList.get(&lt;/span&gt;10));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回element&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;方法抛出异常&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 @Test(expected = RuntimeException.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doThrow(){
        List list &lt;/span&gt;= mock(List.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        doThrow(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RuntimeException()).when(list).add(1&lt;span&gt;);
        list.add(&lt;/span&gt;1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-8&quot;&gt;使用注解注入&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArticleManagerTest {

       @Mock &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ArticleCalculator calculator;
       @Mock &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ArticleDatabase database;
       @Mock &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserProvider userProvider;

       &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ArticleManager manager;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意的是，通过注解的方式用使用的话，我们必须在添加初始化mock的代码，不然即使标注了注解也会是null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
MockitoAnnotations.initMocks(testClass);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于Mockito更多详细的用法，大家可以直接参考官方文档，因为各种“奇技淫巧”确实比较多，后面也更新对java8 lambda的支持，很多功能还是期待大家去挖掘~&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/3/169e0c7fc5239a2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/3/169e0c7fc5239a2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1080&quot; data-height=&quot;691&quot;/&gt;&lt;/p&gt;

&lt;p&gt;更多详细用法可直接参考官方文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fstatic.javadoc.io%2Forg.mockito%2Fmockito-core%2F2.25.1%2Forg%2Fmockito%2FMockito.html%230&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;static.javadoc.io/org.mockito…&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相信当你熟练使用Mockito以后，你会爱上写单测的，也会让你代码健壮性有所加强。有些bug能提前发现的话，总比运行的时候被别人半夜叫起来修复舒服是吧?&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/3/169e0c8389f14bdd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; width=&quot;170&quot; height=&quot;170&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/3/169e0c8389f14bdd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;200&quot; data-height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;center&gt;微信公众号《深夜里的程序猿》 -  每天分享最干的干货&lt;/center&gt;
</description>
<pubDate>Sat, 13 Apr 2019 06:26:00 +0000</pubDate>
<dc:creator>深夜里的程序猿</dc:creator>
<og:description>什么是 Mock 测试 Mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。什么是不容易构造的对象呢？例如HttpServletReques</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coding-night/p/10701033.html</dc:identifier>
</item>
<item>
<title>文本相似度分析（基于jieba和gensim） - molearner</title>
<link>http://www.cnblogs.com/wkslearner/p/10505562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wkslearner/p/10505562.html</guid>
<description>&lt;h2 id=&quot;基础概念&quot;&gt;基础概念&lt;/h2&gt;
&lt;p&gt;本文在进行文本相似度分析过程分为以下几个部分进行，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文本分词&lt;/li&gt;
&lt;li&gt;语料库制作&lt;/li&gt;
&lt;li&gt;算法训练&lt;/li&gt;
&lt;li&gt;结果预测&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分析过程主要用两个包来实现jieba，gensim&lt;br/&gt;jieba:主要实现分词过程&lt;br/&gt;gensim：进行语料库制作和算法训练&lt;/p&gt;

&lt;h2 id=&quot;结巴jieba分词&quot;&gt;结巴（jieba）分词&lt;/h2&gt;
&lt;p&gt;在自然语言处理领域中，分词和提取关键词都是对文本处理时通常要进行的步骤。用Python语言对英文文本进行预处理时可选择NLTK库，中文文本预处理可选择jieba库。结巴分词是基于统计的分词方法，它对给出大量已经分词的文本，利用统计机器学习模型学习词语切分的规律（称为训练），从而实现对未知文本的切分。例如最大概率分词方法和最大熵分词方法等。随着大规模语料库的建立，统计机器学习方法的研究和发展，基于统计的中文分词方法渐渐成为了主流方法。&lt;/p&gt;

&lt;h3 id=&quot;jieba分词的三种模式&quot;&gt;jieba分词的三种模式:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;精确模式：将句子最精确的分开，适合文本分析&lt;/li&gt;
&lt;li&gt;全模式：句子中所有可以成词的词语都扫描出来，速度快，不能解决歧义&lt;/li&gt;
&lt;li&gt;搜索引擎模式：在精确的基础上，对长词再次切分，提高召回&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;结巴分词的其他特点诸如：支持繁体分词，支持自定义词典，基于Trie树结构实现高效的词图扫描，采用了动态规划查找最大概率路径等特点。&lt;/p&gt;

&lt;h3 id=&quot;jieba库中分词函数&quot;&gt;jieba库中分词函数&lt;/h3&gt;
&lt;p&gt;1、jieba.cut()方法&lt;br/&gt;参数string:需要接受分词的字符串。&lt;br/&gt;参数cut_all：控制是否采用全模式分词发，参数为True时表示采用全模式。&lt;br/&gt;参数HMM：控制是否使用HMM模型，参数为True时表示使用HMM模型。&lt;/p&gt;
&lt;p&gt;2、jieba.cut_for_search()&lt;br/&gt;参数string:需要接受分词的字符串。&lt;br/&gt;参数HMM：控制是否使用HMM模型，参数为True时表示使用HMM模型。&lt;/p&gt;
&lt;p&gt;jieba.cut 以及 jieba.cut_for_search 返回的结构都是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语。jieba.lcut和jieba.lcut_for_search参数和上面两个方法一致但返回的是一个list。&lt;/p&gt;

&lt;h3 id=&quot;python上的分词输出对比&quot;&gt;python上的分词输出对比&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import jieba

string='上海市浦东新区世纪大道100号楼501'

#精准模式
text_cut=jieba.cut(string)
print(&quot; &quot;.join(text_cut))

#全模式
text_cut=jieba.cut(string,cut_all=True)
print(&quot; &quot;.join(text_cut))

#搜索模式
text_cut=jieba.cut_for_search(string)
print(&quot; &quot;.join(text_cut))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三种模式的输出结果：&lt;br/&gt;精准模式：上海市浦东新区 世纪 大道 100 号楼 501&lt;br/&gt;全模式：上海 上海市 上海市浦东新区 海市 浦东 浦东新区 新区 世纪 纪大 大道 100 号 楼 501&lt;br/&gt;搜索引擎模式：上海 海市 浦东 新区 上海市 上海市浦东新区 世纪 大道 100 号楼 501&lt;/p&gt;

&lt;h3 id=&quot;jieba分词自定义字典&quot;&gt;jieba分词自定义字典&lt;/h3&gt;
&lt;p&gt;在使用jieba时，用户除了直接对文本进行分词外，还可以自行添加新词，已达到优化分词效果的目的。&lt;/p&gt;
&lt;p&gt;1、加载自定义字典jieba.load_userdict()&lt;br/&gt;参数filename：为文件类对象或自定义词典的路径&lt;br/&gt;词典格式分为3个部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。&lt;br/&gt;file_name 若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。&lt;/p&gt;
&lt;p&gt;2、从字典中添加或删除词汇add_word、del_word&lt;br/&gt;add_word(word,freq=None,tag=None)，add_word有3个参数，添加词名称，词频，词性&lt;br/&gt;del_word(word)，del_word只有一个参数词语名称&lt;/p&gt;
&lt;p&gt;3、词频调整suggest_freq&lt;br/&gt;suggest_freq（segment,tune=True）&lt;br/&gt;调节单个词语的词频，可以使其能（或不能）被分出来，词频越高在分词时，能够被分出来的概率越大。&lt;/p&gt;

&lt;h3 id=&quot;python示例&quot;&gt;python示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import jieba

#载入自定义词典
jieba.load_userdict('word_dict.txt')

#查看用户自定义词典中的内容
print(jieba.user_word_tag_tab)

#往自定义词典中添加新词
jieba.add_word('人民广场',freq=5,tag='n')

#添加新词后的结果
print(jieba.user_word_tag_tab)

string='上海市浦东新区世纪大道100号楼501'
text_cut=jieba.cut(string)
print(&quot; &quot;.join(text_cut))

#调整词频，重新分词
jieba.suggest_freq(('上海市','浦东新区'),tune=True)
text_cut=jieba.cut(string)
print(&quot; &quot;.join(text_cut))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;br/&gt;载入词典内容：{'世纪大道': 'n', '浦东新区 2 ': 'n', '世纪公园 3 ': 'n'}&lt;br/&gt;添加新词后：{'世纪大道': 'n', '浦东新区 2 ': 'n', '世纪公园 3 ': 'n', '人民广场': 'n'}&lt;br/&gt;结巴原始字典库，分词结果：上海市浦东新区 世纪 大道 100 号楼 501&lt;br/&gt;使用自定义词典后，分词结果：上海市浦东新区 世纪大道 100 号楼 501&lt;br/&gt;调整词频后，分词结果：上海市 浦东新区 世纪大道 100 号楼 501&lt;/p&gt;
&lt;p&gt;结巴分词官方文档：&lt;br/&gt;&lt;a href=&quot;https://pypi.org/project/jieba/&quot; class=&quot;uri&quot;&gt;https://pypi.org/project/jieba/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结巴分词github地址：&lt;br/&gt;&lt;a href=&quot;https://github.com/fxsjy/jieba&quot; class=&quot;uri&quot;&gt;https://github.com/fxsjy/jieba&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;gensim&quot;&gt;Gensim&lt;/h2&gt;
&lt;p&gt;Gensim是一款开源的第三方Python工具包，用于从原始的非结构化的文本中，无监督地学习到文本隐层的主题向量表达。&lt;br/&gt;它支持包括TF-IDF，LSA，LDA，和word2vec在内的多种主题模型算法。&lt;/p&gt;

&lt;h3 id=&quot;相关概念&quot;&gt;相关概念&lt;/h3&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;语料（Corpus）：一组原始文本的集合，用于无监督地训练文本主题的隐层结构。在Gensim中，Corpus通常是一个可迭代的对象（比如列表）。每一次迭代返回一个可用于表达文本对象的稀疏向量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;向量（Vector）：由一组文本特征构成的列表。是一段文本在Gensim中的内部表达。在向量空间模型中，每个文档被表示成了一组特征，比如，一个单一的特征可能被视为一个问答对。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;稀疏向量（SparseVector）：通常，大部分问题的答案都是0，为了节约空间，我们会从文档表示中省略他们，向量中的每一个元素是一个(key, value)的元组，比如（1,3），（2,4），（5,0），其中（5,0）是一个稀疏向量，在表示是会被忽略。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;模型（Model）：是一个抽象的术语。定义了两个向量空间的变换（即从文本的一种向量表达变换为另一种向量表达）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;把几个概念组织起来表述：gensim可以通过读取一段语料，输出一个向量，表示文档中的一个词。为了节约空间，通常稀疏的词向量会被忽略，剩下的词向量则可以用来训练各种模型，即从原有的文本表达转向另一种文本表达。&lt;/p&gt;

&lt;h3 id=&quot;语料库制作&quot;&gt;语料库制作&lt;/h3&gt;
&lt;p&gt;语料库制作主要包含两个过程：&lt;br/&gt;获取词袋：本文主要来自于结巴分词结果&lt;br/&gt;向量转换：对获取的词袋进行向量转换&lt;/p&gt;
&lt;p&gt;1、获取词袋函数 gensim.corpora.Dictionary()&lt;br/&gt;gensim.corpora.dictionary.Dictionary可以为每个出现在语料库中的单词分配了一个独一无二的整数编号id。这个操作收集了单词计数及其他相关的统计信息。&lt;/p&gt;

&lt;h3 id=&quot;python示例-1&quot;&gt;python示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import jieba
import gensim

print(jieba.user_word_tag_tab)
string=['上海市浦东新区世纪大道100号楼501','上海市世纪大道100号楼501']

texts_list=[]
for sentence in string:
    sentence_list=[ word for word in jieba.cut(sentence)]
    texts_list.append(sentence_list)

dictionary=gensim.corpora.Dictionary(texts_list)
print(dictionary)
print(dictionary.token2id)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;br/&gt;Dictionary(7 unique tokens: ['100', '501', '上海市浦东新区', '世纪', '号楼']...)&lt;br/&gt;{'100': 0, '501': 1, '上海市浦东新区': 2, '世纪': 3, '号楼': 4, '大道': 5, '上海市': 6}&lt;/p&gt;
&lt;p&gt;第一行结果告诉我们语料库中有7个不同的单词，这表明每个文档将会用7个数字表示（即7维向量）。&lt;br/&gt;第二行结果是查看单词与编号之间的映射关系。&lt;/p&gt;
&lt;p&gt;2、向量转换 dictionary.doc2bow（）&lt;br/&gt;函数doc2bow() 简单地对每个不同单词的出现次数进行了计数，并将单词转换为其编号，然后以稀疏向量的形式返回结果。&lt;/p&gt;

&lt;h3 id=&quot;python示例-2&quot;&gt;python示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;corpus = [dictionary.doc2bow(doc) for doc in texts_list]
print(corpus)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;br/&gt;[[(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)], [(0, 1), (1, 1), (3, 1), (4, 1), (5, 1), (6, 1)]]&lt;/p&gt;
&lt;p&gt;以上结果中，表示两个字符串中，每个词的id以及它对应的出现频次，比如第一个元组（0,1）代表的是编号为0的词在第一个字符串中出现一次。&lt;/p&gt;

&lt;h3 id=&quot;算法训练&quot;&gt;算法训练&lt;/h3&gt;
&lt;p&gt;下面我们使用tf-idf算法对上面的语料库进行建模，识别不同文本的相似度。&lt;/p&gt;

&lt;h3 id=&quot;python示例-3&quot;&gt;python示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#测试字符串
test_string='浦东新区世纪大道100号楼501'
test_doc_list=[word for word in jieba.cut(test_string)]
test_doc_vec=dictionary.doc2bow(test_doc_list)

# 使用TF-IDF模型对语料库建模
tfidf = gensim.models.TfidfModel(corpus)

#分析测试文档与已存在的每个训练文本的相似度
index = gensim.similarities.SparseMatrixSimilarity(tfidf[corpus], num_features=len(dictionary.keys()))
sim = index[tfidf[test_doc_vec]]

print(sim)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;br/&gt;[ 0.63650501 0.63650501 0. ]&lt;br/&gt;表示测试文本与训练的3个文本相似度分布0.63 0.63 0&lt;br/&gt;以上就是使用jieba和gensim文本相似度的简单实现.&lt;/p&gt;
&lt;p&gt;gensim官方文档：&lt;br/&gt;&lt;a href=&quot;https://pypi.org/project/gensim/&quot; class=&quot;uri&quot;&gt;https://pypi.org/project/gensim/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 06:23:00 +0000</pubDate>
<dc:creator>molearner</dc:creator>
<og:description>基础概念 本文在进行文本相似度分析过程分为以下几个部分进行， 文本分词 语料库制作 算法训练 结果预测 分析过程主要用两个包来实现jieba，gensim jieba:主要实现分词过程 gensim：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wkslearner/p/10505562.html</dc:identifier>
</item>
<item>
<title>关于写作那些事之利用 js 统计各大博客阅读量 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10700986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10700986.html</guid>
<description>&lt;p&gt;在日常文章数据统计的过程中,纯手动方式已经难以应付,于是乎,逐步开始了程序介入方式进行统计.&lt;/p&gt;
&lt;p&gt;在上一节中,探索利用 &lt;code&gt;csv&lt;/code&gt; 文件格式进行文章数据统计,本来以为能够应付一阵子,没想到仅仅一天我就放弃了.&lt;/p&gt;
&lt;p&gt;原因还不是因为我懒,需要复制文章内容,然后整理成&lt;strong&gt;特定的&lt;/strong&gt; &lt;code&gt;csv&lt;/code&gt; 格式,最后利用已编写的 &lt;code&gt;java&lt;/code&gt; 工具类进行统计.&lt;/p&gt;
&lt;p&gt;在这三步操作中,第一步复制文章内容最简单,第二步整理文章格式最麻烦,第三步编写 &lt;code&gt;csv&lt;/code&gt; 工具类最技术.&lt;/p&gt;
&lt;p&gt;因此,能不能再简单点?懒癌晚期,必须继续寻求新的解决方案.&lt;/p&gt;
&lt;blockquote readability=&quot;3.3888888888889&quot;&gt;
&lt;p&gt;关于如何利用 &lt;code&gt;csv&lt;/code&gt; 文件处理统计数据,可以参考 &lt;a href=&quot;https://snowdreams1006.github.io/static-semi-manual-with-csv.html&quot; class=&quot;uri&quot;&gt;https://snowdreams1006.github.io/static-semi-manual-with-csv.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实现效果&quot;&gt;实现效果&lt;/h2&gt;
&lt;h3 id=&quot;慕课手记&quot;&gt;慕课手记&lt;/h3&gt;
&lt;blockquote readability=&quot;0.27272727272727&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.imooc.com/u/5224488/articles&quot;&gt;慕课手记&lt;/a&gt; : &lt;a href=&quot;https://www.imooc.com/u/5224488/articles&quot; class=&quot;uri&quot;&gt;https://www.imooc.com/u/5224488/articles&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-cc8399aed715a114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;慕课手记&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;简书&quot;&gt;简书&lt;/h3&gt;
&lt;blockquote readability=&quot;0.31914893617021&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/u/577b0d76ab87&quot;&gt;简书&lt;/a&gt; : &lt;a href=&quot;https://www.jianshu.com/u/577b0d76ab87&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/u/577b0d76ab87&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-3283c88e4b235a5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;简书&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;博客园&quot;&gt;博客园&lt;/h3&gt;
&lt;blockquote readability=&quot;0.29411764705882&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/snowdreams1006/&quot;&gt;博客园&lt;/a&gt; : &lt;a href=&quot;https://www.cnblogs.com/snowdreams1006/&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/snowdreams1006/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-61ba3f918fe0e5f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;简书&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;腾讯云社区&quot;&gt;腾讯云社区&lt;/h3&gt;
&lt;blockquote readability=&quot;0.19480519480519&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/user/2952369/activities&quot;&gt;腾讯云社区&lt;/a&gt; : &lt;a href=&quot;https://cloud.tencent.com/developer/user/2952369/activities&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/user/2952369/activities&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-b2766aad3c4ed260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;腾讯云社区&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;js-抓取分析数据&quot;&gt;js 抓取分析数据&lt;/h2&gt;
&lt;p&gt;下面以 &lt;code&gt;chrome&lt;/code&gt; 浏览器为例,说明如何利用默认控制台抓取关键数据,本文需要一定的 &lt;code&gt;jQuery&lt;/code&gt; 基础.&lt;/p&gt;
&lt;h3 id=&quot;慕课手记-1&quot;&gt;慕课手记&lt;/h3&gt;
&lt;p&gt;在目标页面右键选择&lt;strong&gt;检查&lt;/strong&gt;选项,打开默认开发者控制台,点击最左侧的&lt;strong&gt;小鼠标箭头&lt;/strong&gt;,然后选中关键数据,比如浏览量.&lt;/p&gt;
&lt;p&gt;此时,开发者控制台自动滚动到&lt;strong&gt;元素&lt;/strong&gt;(Elements)选项卡,在目标数据上右键点击&lt;strong&gt;复制&lt;/strong&gt;(Copy),接着点击复制选择器(Copy selector),现在已经定位到阅读量的节点.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-e696b1f087eb909f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;imooc-copy-selector.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;strong&gt;控制台&lt;/strong&gt;(Console)选项卡,并且将选择器更改成 &lt;code&gt;jQuery&lt;/code&gt; 选择器,即&lt;code&gt;$(&quot;复制的选择器&quot;).text()&lt;/code&gt;,现在在控制台直接输出内容,看一下能否抓取到浏览量吧!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-1389baa5c311bd82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;imooc-paste-jQuery-selector.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在已经成功定位到指定元素,而我们要统计的是全部文章的阅读量,因此需要定位到全部元素.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(&quot;#articlesList &amp;gt; div:nth-child(1) &amp;gt; div.item-btm.clearfix &amp;gt; div &amp;gt; div:nth-child(1) &amp;gt; em&quot;).text();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单分析下文章结构结合选择器分析,可以得知, 浏览,推荐和评论三者文档基本一致,唯一不同之处就是&lt;strong&gt;排列顺序&lt;/strong&gt;而已,因此想要准确定位到浏览数,需要定位到第一个元素,推荐量则是第二个元素,因此类推.&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;r right-info&quot;&amp;gt;
    &amp;lt;div class=&quot;favorite l&quot;&amp;gt;
        &amp;lt;i class=&quot;icon sns-thumb-up-outline&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;em&amp;gt; 83浏览&amp;lt;/em&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;favorite l&quot;&amp;gt;
        &amp;lt;i class=&quot;icon sns-thumb-up-outline&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;em&amp;gt; 1推荐&amp;lt;/em&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot; l&quot;&amp;gt;
        &amp;lt;i class=&quot;icon sns-comment&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;em&amp;gt; 0评论&amp;lt;/em&amp;gt;
    &amp;lt;/div&amp;gt;    
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;弄清楚基本文档结构后,开始着手改造选择器使其定位到全部文章的浏览量,我们做如下改造.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(&quot;#articlesList div:nth-child(1) &amp;gt; em&quot;).text();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅仅保留头部和尾部,再去掉中间部分 &lt;code&gt;&amp;gt; div:nth-child(1) &amp;gt; div.item-btm.clearfix &amp;gt; div &amp;gt;&lt;/code&gt; ,这样就轻松定位到全部元素的浏览量了,是不是很简单?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-b3d1190a7f3af094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;imooc-modify-jQuery-selector.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到控制台输出结果,心里瞬间踏实了,这不刚好是&lt;strong&gt;第一页&lt;/strong&gt;全部文章的浏览量吗?观察输出内容格式可知,我们需要将整个字符串按照&lt;strong&gt;空格&lt;/strong&gt;分割成字符串数组.&lt;/p&gt;
&lt;p&gt;需要注意的是,行首还有一个空格哟,因此在分割成字符串数组前,我们先将行首的空格去除掉.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 去除空格前:&quot; 83浏览 91浏览 114浏览 150浏览 129浏览 175浏览 222浏览 173浏览 225浏览 200浏览 201浏览 217浏览 291浏览 202浏览 229浏览 184浏览 226浏览 155浏览 153浏览 211浏览&quot;

$(&quot;#articlesList div:nth-child(1) &amp;gt; em&quot;).text().trim();

// 去除空格后: &quot;83浏览 91浏览 114浏览 150浏览 129浏览 175浏览 222浏览 173浏览 225浏览 200浏览 201浏览 217浏览 291浏览 202浏览 229浏览 184浏览 226浏览 155浏览 153浏览 211浏览&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们再将这整个字符串按照空格分割成字符串数组.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 分割字符串前: &quot;83浏览 91浏览 114浏览 150浏览 129浏览 175浏览 222浏览 173浏览 225浏览 200浏览 201浏览 217浏览 291浏览 202浏览 229浏览 184浏览 226浏览 155浏览 153浏览 211浏览&quot;

$(&quot;#articlesList div:nth-child(1) &amp;gt; em&quot;).text().trim().split(&quot; &quot;);

// 分割字符串后: [&quot;83浏览&quot;, &quot;91浏览&quot;, &quot;114浏览&quot;, &quot;150浏览&quot;, &quot;129浏览&quot;, &quot;175浏览&quot;, &quot;222浏览&quot;, &quot;173浏览&quot;, &quot;225浏览&quot;, &quot;200浏览&quot;, &quot;201浏览&quot;, &quot;217浏览&quot;, &quot;291浏览&quot;, &quot;202浏览&quot;, &quot;229浏览&quot;, &quot;184浏览&quot;, &quot;226浏览&quot;, &quot;155浏览&quot;, &quot;153浏览&quot;, &quot;211浏览&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们已经够将整个字符串分割成一个个小的字符串,下面需要再将&lt;code&gt;83浏览&lt;/code&gt;中的&lt;code&gt;浏览&lt;/code&gt;去掉,仅仅保留数字&lt;code&gt;83&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$.each($(&quot;#articlesList div:nth-child(1) &amp;gt; em&quot;).text().trim().split(&quot; &quot;),function(idx,ele){
     console.log(ele.substr(0,ele.lastIndexOf(&quot;浏览&quot;)));
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-22d3e0d14baece99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;imooc-split-ele-read.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经抓取到真正的浏览量,接下来就比较简单了,直接将这些浏览量进行累加即可,需要注意的是,这里的浏览数还是字符串类型,需要转换成数字类型才能进行累加运算哟!&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//阅读量
var readCount = 0;
$.each($(&quot;#articlesList div:nth-child(1) &amp;gt; em&quot;).text().trim().split(&quot; &quot;),function(idx,ele){
     readCount += parseInt(ele.substr(0,ele.lastIndexOf(&quot;浏览&quot;)));
});
console.log(&quot;阅读量: &quot; + readCount);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-27394a260f3d5ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;imooc-read-count.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;我们以 &lt;code&gt;chrome&lt;/code&gt; 浏览器为例,讲解了如何利用自带的控制台工具抓取关键数据,从页面结构分析入口,一步一个脚印提取有效数据,最终从一条数据变成多条数据,进而实现数据的累加统计.&lt;/p&gt;
&lt;p&gt;总体来说,还是比较简单的,并不需要太多的基础知识,但还是稍微总结其中涉及到的 &lt;code&gt;jQuery&lt;/code&gt; 知识点吧!&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定位到具体元素: &lt;code&gt;$(&quot;这里是复制的选择器&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定位到具体元素内容: &lt;code&gt;$(&quot;这里是复制的选择器&quot;).text()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;去除字符串首尾空格: &lt;code&gt;$(&quot;这里是复制的选择器&quot;).text().trim()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将字符串按照&lt;strong&gt;空格&lt;/strong&gt;分割成字符串数组: &lt;code&gt;$(&quot;这里是复制的选择器&quot;).text().trim().split(&quot; &quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;截取字符串指定部分: &lt;code&gt;ele.substr(0,ele.lastIndexOf(&quot;浏览&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将字符串转化成数字类型: &lt;code&gt;parseInt(ele.substr(0,ele.lastIndexOf(&quot;浏览&quot;)));&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;变量累加求和: &lt;code&gt;readCount += parseInt(ele.substr(0,ele.lastIndexOf(&quot;浏览&quot;)));&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完整示例:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//阅读量
var readCount = 0;
$.each($(&quot;#articlesList div:nth-child(1) &amp;gt; em&quot;).text().trim().split(&quot; &quot;),function(idx,ele){
     readCount += parseInt(ele.substr(0,ele.lastIndexOf(&quot;浏览&quot;)));
});
console.log(&quot;阅读量: &quot; + readCount);

//推荐量
var recommendCount = 0;
$.each($(&quot;#articlesList div:nth-child(2) &amp;gt; em&quot;).text().trim().split(&quot; &quot;),function(idx,ele){
     recommendCount += parseInt(ele.substr(0,ele.lastIndexOf(&quot;推荐&quot;)));
});
console.log(&quot;推荐量: &quot; + recommendCount);

//评论量
var commendCount = 0;
$.each($(&quot;#articlesList div:nth-child(3) &amp;gt; em&quot;).text().trim().split(&quot; &quot;),function(idx,ele){
     commendCount += parseInt(ele.substr(0,ele.lastIndexOf(&quot;评论&quot;)));
});
console.log(&quot;评论量: &quot; + commendCount);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;简书-1&quot;&gt;简书&lt;/h3&gt;
&lt;p&gt;简书的文章数据不一定很规整,比如有的发布文章还没有简书钻,所以阅读量的排列顺序就是不确定的,这一点不像前面介绍的慕课手记,但是简书的关键数据前面是有小图标的,因此我们可以利用图标定位到旁边的数据.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-e0808e17c74ddbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;jianshu-selector-analysis.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照前面介绍的步骤,我们仍然定位到阅读量,然而 &lt;code&gt;#note-44847909 &amp;gt; div &amp;gt; div &amp;gt; a:nth-child(2) &amp;gt; i&lt;/code&gt; 却不能直接使用,因为我们刚刚分析了,简书不能利用顺序定位只能用图标辅助定位.&lt;/p&gt;
&lt;p&gt;所以,还是先看看文档结构,尝试着直接定位到全部的&lt;strong&gt;阅读量小图标&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-a4a8cdbf4580df50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;jianshu-locate-icon.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过分析文章结构,我们可以很轻松定位到全部阅读小图标,当然这是一个元素数组,并不是字符串数组哟!&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(&quot;#list-container .ic-list-read&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们看一下能否正确定位到每一个小图标,进而定位到小图标左侧的阅读量.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-ebf62b1521097668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;jianshu-each-icon.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经能够定位到全部的阅读量小图标,现在思考如何定位到旁边的真正阅读量呢?&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;meta&quot;&amp;gt;
    &amp;lt;span class=&quot;jsd-meta&quot;&amp;gt;
      &amp;lt;i class=&quot;iconfont ic-paid1&quot;&amp;gt;&amp;lt;/i&amp;gt; 0.2
    &amp;lt;/span&amp;gt;
    &amp;lt;a target=&quot;_blank&quot; href=&quot;/p/3441940065b5&quot;&amp;gt;
        &amp;lt;i class=&quot;iconfont ic-list-read&quot;&amp;gt;&amp;lt;/i&amp;gt; 2
    &amp;lt;/a&amp;gt;        
    &amp;lt;a target=&quot;_blank&quot; href=&quot;/p/3441940065b5#comments&quot;&amp;gt;
      &amp;lt;i class=&quot;iconfont ic-list-comments&quot;&amp;gt;&amp;lt;/i&amp;gt; 0
    &amp;lt;/a&amp;gt;      
    &amp;lt;span&amp;gt;&amp;lt;i class=&quot;iconfont ic-list-like&quot;&amp;gt;&amp;lt;/i&amp;gt; 1&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;time&quot; data-shared-at=&quot;2019-04-12T10:39:57+08:00&quot;&amp;gt;昨天 10:39&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析文章结构,我们发现阅读量是小图标的父节点的内容,这一下就简单了,我们顺藤摸瓜定位到父节点自然就能定位到阅读量了!&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(&quot;#list-container .ic-list-read&quot;).each(function(idx,ele){
    console.log($(ele).parent().text().trim());
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-4402b5e8fcadfdbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;jianshu-locate-read.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在既然已经能够定位到阅读量,那么首先累加求和就很简单了.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//阅读量
var readCount = 0;
$(&quot;#list-container .ic-list-read&quot;).each(function(idx,ele){
    readCount += parseInt($(ele).parent().text().trim());
});
console.log(&quot;阅读量: &quot; + readCount);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-e4b27bb4e590cfe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;jianshu-read-count-preview.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;小结-1&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;首先分析文章基本结构发现,简书的阅读量需要定位到阅读量小图标,进而定位到父节点,然后父节点的内容才是真正的阅读量.&lt;/p&gt;
&lt;p&gt;定位到真正的阅读量后,一切问题迎刃而解,总结一下新增 &lt;code&gt;jQuery&lt;/code&gt; 知识点.&lt;/p&gt;
&lt;p&gt;定位到当前节点的父节点: &lt;code&gt;$(ele).parent()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;完整示例:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//阅读量
var readCount = 0;
$(&quot;#list-container .ic-list-read&quot;).each(function(idx,ele){
    readCount += parseInt($(ele).parent().text().trim());
});
console.log(&quot;阅读量: &quot; + readCount);

//评论量
var commendCount = 0;
$(&quot;#list-container .ic-list-comments&quot;).each(function(idx,ele){
    commendCount += parseInt($(ele).parent().text().trim());
});
console.log(&quot;评论量: &quot; + commendCount);

//喜欢量
var recommendCount = 0;
$(&quot;#list-container .ic-list-like&quot;).each(function(idx,ele){
    recommendCount += parseInt($(ele).parent().text().trim());
});
console.log(&quot;喜欢量: &quot; + recommendCount);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;博客园-1&quot;&gt;博客园&lt;/h3&gt;
&lt;p&gt;博客园的文章列表比较复古,传统的 &lt;code&gt;table&lt;/code&gt; 布局,是这几个平台中最简单的,基本上不同怎么介绍.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-171875965f9d06fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;cnblogs-selector-analysis.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制到阅读量选择器: &lt;code&gt;#post-row-10694598 &amp;gt; td:nth-child(4)&lt;/code&gt; 此时再结合文章结构,因此我们可以得到全部文章的阅读量选择器.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(&quot;#post_list td:nth-child(4)&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来需要遍历数组,看看能否抓取到当前页面全部文章的阅读量.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(&quot;#post_list td:nth-child(4)&quot;).each(function(idx,ele){
    console.log($(ele).text().trim());
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-b71e7913a56fdb33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;cloud-tencent-each-read.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功抓取到阅读量,现在开始累加当前页面全部文章的阅读量.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//阅读数
var readCount = 0;
$(&quot;#post_list td:nth-child(4)&quot;).each(function(idx,ele){
    readCount += parseInt($(ele).text().trim());
});
console.log(&quot;阅读数: &quot; + readCount);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-68b2e75901b99149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;cnblogs-read-count-preview.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;小结-2&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;中规中矩的传统 &lt;code&gt;table&lt;/code&gt; 布局,只需要顺序定位到具体的元素即可,需要注意的是,博客园文章页面采用了分页,如果需要统计全部文章的阅读量,需要将每页的阅读量手动累加计算.&lt;/p&gt;
&lt;p&gt;完整示例:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//评论数
var commendCount = 0;
$(&quot;#post_list td:nth-child(3)&quot;).each(function(idx,ele){
    commendCount += parseInt($(ele).text().trim());
});
console.log(&quot;评论数: &quot; + commendCount);

//阅读数
var readCount = 0;
$(&quot;#post_list td:nth-child(4)&quot;).each(function(idx,ele){
    readCount += parseInt($(ele).text().trim());
});
console.log(&quot;阅读数: &quot; + readCount);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;腾讯云社区-1&quot;&gt;腾讯云社区&lt;/h3&gt;
&lt;p&gt;大致分析腾讯云社区的文章结构,基本上和简书结构差不多,既可以像简书那种采用图标定位方式,也可以像慕课网和博客园那种直接顺序定位.&lt;/p&gt;
&lt;p&gt;为了较为精准的定位,现在采用图标定位方式来获取阅读量.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-08d62be478fe52ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;cloud-tencent-selector-analysis.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#react-root &amp;gt; div:nth-child(1) &amp;gt; div.J-body.com-body.with-bg &amp;gt; section &amp;gt; div &amp;gt; section &amp;gt; div &amp;gt; div.com-log-list &amp;gt; section:nth-child(1) &amp;gt; section &amp;gt; div &amp;gt; div &amp;gt; span &amp;gt; span&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然要根据图标定位,我们需要分析图标和阅读量的关系.&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;com-operations com-article-panel-operations&quot;&amp;gt;
    &amp;lt;span class=&quot;com-opt-link&quot;&amp;gt;
        &amp;lt;i class=&quot;com-i-view&quot;&amp;gt;&amp;lt;/i&amp;gt;
        &amp;lt;span class=&quot;text&quot;&amp;gt;76&amp;lt;/span&amp;gt;
    &amp;lt;/span&amp;gt;
    &amp;lt;a href=&quot;javascript:;&quot; class=&quot;com-opt-link&quot;&amp;gt;
        &amp;lt;i class=&quot;com-i-like&quot;&amp;gt;&amp;lt;/i&amp;gt;
        &amp;lt;span class=&quot;text&quot;&amp;gt;3&amp;lt;/span&amp;gt;
    &amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此,我们需要做如下改造才能定位到与阅读量.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(&quot;#react-root .com-i-view&quot;).each(function(idx,ele){
    console.log($(ele).next().text().trim());
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-9b33b06e862b6c5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;cloud-tencent-each-read.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定位到阅读量,接下来就是简单的数据累加求和了.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//阅读量
var readCount = 0;
$(&quot;#react-root .com-i-view&quot;).each(function(idx,ele){
    readCount += parseInt($(ele).next().text().trim());
});
console.log(&quot;阅读量: &quot; + readCount);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-5670429bad52e05d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;cloud-tencent-read-count-preview.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;小结-3&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;腾讯云社区和简书一样,采用的分页叠加模式,因此需要统计全部文章的话,只需要一直滚动直到加载出全部文章即可.&lt;/p&gt;
&lt;p&gt;总结一下涉及到的新增 &lt;code&gt;jQuery&lt;/code&gt; 知识点:&lt;/p&gt;
&lt;p&gt;获取当前节点的下一个节点: &lt;code&gt;$(ele).next()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;完整示例:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//阅读量
var readCount = 0;
$(&quot;#react-root .com-i-view&quot;).each(function(idx,ele){
    readCount += parseInt($(ele).next().text().trim());
});
console.log(&quot;阅读量: &quot; + readCount);

//点赞量
var recommendCount = 0;
$(&quot;#react-root .com-i-like&quot;).each(function(idx,ele){
    recommendCount += parseInt($(ele).next().text().trim());
});
console.log(&quot;点赞量: &quot; + recommendCount);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结-4&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文通过 &lt;code&gt;jQuery&lt;/code&gt; 方式直接抓取文章数据,简单方便,学习成本低,能够快速上手.&lt;/p&gt;
&lt;p&gt;慕课网和博客园的文章列表存在分页,如果需要统计全部文章浏览量,需要将每一页的文章累加,直到最后一页.&lt;br/&gt;简书和腾讯云社区的文章列表虽然也有分支,但会自动累加,所以统计全部文章时只需要先等全部文章加载完毕,再利用 &lt;code&gt;js&lt;/code&gt; 脚本一次性统计即可.&lt;/p&gt;
&lt;p&gt;好了,本次分享到此结束,如果你觉得本文对你有所帮助,欢迎分享让更多人看到哦,对了,上一篇文章也是解决统计问题的,不过使用的是 &lt;code&gt;java&lt;/code&gt; 读取 &lt;code&gt;csv&lt;/code&gt; 文件方式,如果有兴趣,也可以&lt;a href=&quot;https://snowdreams1006.github.io/static-semi-manual-with-csv.html&quot;&gt;看一看&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 06:14:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>在日常文章数据统计的过程中,纯手动方式已经难以应付,于是乎,逐步开始了程序介入方式进行统计. 在上一节中,探索利用 文件格式进行文章数据统计,本来以为能够应付一阵子,没想到仅仅一天我就放弃了. 原因还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowdreams1006/p/10700986.html</dc:identifier>
</item>
<item>
<title>Python的简单介绍 - Lucas27171</title>
<link>http://www.cnblogs.com/lucas27171/p/10700962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lucas27171/p/10700962.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;0. 前言&lt;/h2&gt;
&lt;p&gt;最近在从头梳理Python的相关知识，有助于以后更好地学习新知识。这篇博客，我简单介绍一下Python语言的有关内容。&lt;/p&gt;
&lt;h2 id=&quot;python介绍&quot;&gt;1. Python介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;7.7559912854031&quot;&gt;
&lt;p&gt;Python的创始人为荷兰人吉多·范罗苏姆（Guido van Rossum）。1989年圣诞节期间，在阿姆斯特丹，Guido为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，作为ABC 语言的一种继承。之所以选中Python（大蟒蛇的意思）作为该编程语言的名字，是取自英国20世纪70年代首播的电视喜剧《蒙提.派森干的飞行马戏团》（Monty Python's Flying Circus）。&lt;a href=&quot;https://baike.baidu.com/item/Python/407313?fr=aladdin&quot;&gt;[百度百科]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;python是一种面向对象的解释型动态数据类型程序设计语言但它也是一种强类型语言&quot;&gt;Python是一种面向对象的、解释型、动态数据类型程序设计语言，但它也是一种强类型语言。&lt;/h3&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;面向对象：一种软件开发方法，早期的编程是基于面向过程的方法的，也就是像C语言一样，啥都写成一个函数。但是随着工业项目的开发越来越大型，思路越来越复杂，面向对象的方法就诞生了，它的核心思想是将所有事物转化为一个个对象，将现实世界中的关系抽象成类和继承，再通过这种思路去对现实世界进行抽象与数字建模。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;解释型： 传统的编译型语言是通过编译器将源码编译成机器语言，而解释型语言是先将代码翻译成中间代码，再通过解释器进行解释运行的。（移步下方有介绍Python解释器种类。）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;动态数据类型： 不用在初始化时事先声明一个变量的数据类型是什么，你放什么数据进去，这个变量就是什么类型。很多同学容易将动态数据类型与弱类型搞混，弱类型是与数据类型转换相关的，而动态数据类型是与变量初始状态相关的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;强类型： 也就是解释器不会自动转换变量数据类型，不像JavaScript，输入一个数字就自动将它转为整型，在Python里，输入一个数字它就是个字符，需要手动进行数据类型转换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;python解释器&quot;&gt;2. Python解释器&lt;/h2&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;官方CPython&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;C语言开发，最广泛的Python解析器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;IPython&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个交互式、功能增强的CPython。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;PyPy&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Python语言写的Python解释器，JIT技术，动态编译Python代码，因为JIT技术所以更灵活，更易于使用和试验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;Jython&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Python的源代码转化成Java的字节码，跑在JVM上，既有CPython中继承的模块库，又可以调用Java类，所以它已经成为一个完整的语言了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;IronPython&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;与Jython类似，运行在.Net平台上的解释器，Python代码被转化成.Net的字节码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;设计理念&quot;&gt;3. 设计理念&lt;/h2&gt;
&lt;p&gt;很多同学都有听说，“人生苦短，我用Python。”这样的话。这是因为Python语言的设计理念之一就是：能用一种方法就只用这种方法。一个容易解释的方法就是好方法。在Python中内置有Python之禅。英语较好的同学可以看看。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 输入这个语句可以看到The Zen of Python
import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.       优美胜于丑陋
Explicit is better than implicit.    明了胜于晦涩
Simple is better than complex.       简单胜过复杂
Complex is better than complicated.  复杂胜过凌乱
Flat is better than nested.　　　　　　扁平胜于嵌套
Sparse is better than dense. 　　　　 间隔胜于紧凑
Readability counts.　　　　　　　　　　 可读性很重要
Special cases aren't special enough to break the rules.   即使假借特例的实用性之名，也不违背这些规则
Although practicality beats purity.　　　虽然实用性次于纯度
Errors should never pass silently.　　　 错误不应该被无声的忽略
Unless explicitly silenced.　　　　　　　 除非明确的沉默　　　　　　　
In the face of ambiguity, refuse the temptation to guess. 当存在多种可能时，不要尝试去猜测
There should be one-- and preferably only one --obvious way to do it. 应该有一个，最好只有一个，明显能做到这一点
Although that way may not be obvious at first unless you're Dutch.虽然这种 方式可能不容易，除非你是python之父
Now is better than never.    现在做总比不做好
Although never is often better than *right* now.  虽然过去从未比现在好
If the implementation is hard to explain, it's a bad idea.  如果这个实现不容易解释，那么它肯定是坏主意
If the implementation is easy to explain, it may be a good idea.   如果这个实现容易解释，那么它很可能是个好主意
Namespaces are one honking great idea -- let's do more of those!  命名空间是一种绝妙的理念，应当多加利用
&amp;gt;&amp;gt;&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python的发展&quot;&gt;4. Python的发展&lt;/h2&gt;
&lt;p&gt;Python因为近年来机器学习和人工智能的兴起，也被越来越多人使用。但是它本身也是一门非常优秀的语言，也可以用于web开发、游戏开发、自动化等方面。截止至2018.12，Python在TIOBE排行榜排第三名。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;TIOBE排行榜是根据互联网上有经验的程序员、课程和第三方厂商的数量，并使用搜索引擎（如Google、Bing、Yahoo!）以及Wikipedia、Amazon、YouTube统计出排名数据，反映某个编程语言的热门程度。&lt;img src=&quot;https://i.loli.net/2019/04/12/5cb000aaf2fde.png&quot; alt=&quot;20190412110617-image.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;5. 写在最后&lt;/h2&gt;
&lt;p&gt;无论是什么语言，只要学好了，都能排上用场。既然选择了Python，那便风雨兼程。&lt;/p&gt;
&lt;p&gt;与各位共勉。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 06:08:00 +0000</pubDate>
<dc:creator>Lucas27171</dc:creator>
<og:description>0. 前言 最近在从头梳理Python的相关知识，有助于以后更好地学习新知识。这篇博客，我简单介绍一下Python语言的有关内容。 1. Python介绍 Python的创始人为荷兰人吉多·范罗苏姆（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lucas27171/p/10700962.html</dc:identifier>
</item>
<item>
<title>从零开始搭建一个规范的vue-cli 3.0项目 - 陌上兮月</title>
<link>http://www.cnblogs.com/zhangnan35/p/10697812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangnan35/p/10697812.html</guid>
<description>&lt;p&gt;&lt;span&gt;在这一集我们将讲到如何从安装vue-cli开始，到新建一个本地项目，再到vscode中关于eslint的配置，以及本地项目关联公司远程项目的基本操作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一，初始化本地项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，首先，全局安装vue-cli 3.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190412155552345-436238082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.检查vue-cli的版本,确定是3.0以上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190412160121849-58088677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3，新建一个叫question-editor的本地项目，注意这里的配置，预设置选择手动，勾选必要的Babel,Router,CSS预处理器,Linter格式化工具。不选择历史模式，CSS预处理器的选择看个人喜好，SCSS和Less其实语法区别不大，而ESLint的配置选择airbnb（在eslint的官方地址中star数高居第一，远超prettier和standard的存在），选择在保存时自动lint，独立放置配置文件，即可等待其初始化完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;(顺便吐槽一下，在windows系统中的git bash方向键有问题，所以这里才用回自带的powershell来建项目)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190413094745161-1987948490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;说一下历史模式这个问题，关于历史模式和哈希模式的区别不仅仅是有没有#号这么简单，历史模式还带来了关于二级菜单刷新出现404，重定向等问题，而哈希模式在url中仅仅是多了一个#号，就可以避免历史模式的所有缺陷，以及提供低版本浏览器甚至是ie的支持！所以在此墙裂不推荐使用历史模式。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二，在vscode中配置eslint&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，首先，我的vscode一开始在插件方面以及设置方面如下，可以看到是非常简单的，插件只有一个汉化工具、代码提交者追查工具、代码特效工具、.vue文件语法高亮工具。而在setting.json中，仅仅是配了颜色主题、shell终端、代码烟花特效而已。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190412161959593-743750995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.抛弃vetur格式化功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在这个时候，如果我们在一个vue文件中，书写一些代码如下，会发现是可以格式化的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190412164345636-1641574580.png&quot; alt=&quot;&quot;/&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190412164359607-1828576293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;如果你对eslint的airbnb有所了解，那么你一定知道它有两条大名鼎鼎的规矩：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;第一，字符串必须为单引号；第二，函数语句不必加分号。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;而在我们执行完格式化后（快捷键Alt+Ctrl+F），这两个规矩都被破坏了，产生这种现象的原因是vscode默认是不支持vue文件的格式化，而Vetur插件自带了格式化工具。所以在vue文件中执行格式化操作的时候 ，先在vscode自身找格式化工具，找不到就到插件中找，然后在Vetur里面找到了，然后执行Vetur自带的格式化标准。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;而Vetur的格式化标准叫做prettier,这玩意跟airbnb标准是不太一样的。可以在设置中验证这一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190412165201867-1403610562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;所以我的建议是，&lt;span&gt;&lt;strong&gt;&lt;span&gt;Vetur就仅仅是作为一个语法高亮工具，能给vue文件上点颜色，就行了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;至于代码格式化这件事情，就不要来参与。在设置中把Vetur的“特权”给禁掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190412165146027-2105318188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.让所有的格式化工作都交给eslint插件去完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;然后就可以安装eslint插件，安装这承载着全项目格式化希望的关键插件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190412174959243-33121348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;安装完成后，我们需要配置一下eslint的&lt;span&gt;validate&lt;/span&gt;(也就是eslint在哪儿生效)，setting.json更改如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190413104138520-1704673511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;现在来试试效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190413105555377-1351446429.png&quot; alt=&quot;&quot;/&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190413105600856-110446113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　哦对了，在windows还会遇到Expected linebreaks to be 'LF' but found 'CRLF'这个问题，这是因为不同的操作系统对于换行符的定义不同，windows是回车换行（CR+LF）,而在Linux和Unix中是简单换行(LF),默认为LF。至于换行这件事情，不止和操作系统有关，有时候不同的编辑器也可能导致换行符的问题，而这些所谓的“换行问题”并不会反映到代码中，你根本看不着这东西，所以在eslintrc.js中，把换行检测关闭就可以了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190413133300651-721861136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三，线上对接项目（GitLab）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1，在GitLab中新建一个项目，这时候会发现，项目名称会带有个人用户名前缀：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190413113228922-981463247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这当然是不科学的，因为我在新建的是一个公司的项目，而不是个人项目，出现这种尴尬的现象是因为在GitLab群组中，分为三个角色：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Owner&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;(群主，拥有所有权限) --&amp;gt;&lt;strong&gt;&lt;span&gt;Maintainer&lt;/span&gt;&lt;/strong&gt;（管理员，可以新建组内项目）--&amp;gt; &lt;strong&gt;&lt;span&gt;Developer&lt;/span&gt;&lt;/strong&gt;(开发者，只负责开发)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;好吧，我是Developer,所以我去找了个Maintainer同事来帮我建项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190413114242798-308981596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;现在项目已经被同事建好了，我现在要做的就是把本地仓库和远程仓库进行关联。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　复制一下项目的ssh key，回到本地项目看看本地的状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190413135022248-1648618474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　把远程仓库与本地仓库相关联的命令是git remote add origin &amp;lt;一个项目的ssh地址&amp;gt;,而第一次推的时候加上-u参数是为了把本地master分支与远程master分支相关联，有关git的更多内容请移步至廖大大的官网，这里不详细讲各种git操作了，附上地址：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;廖雪峰git教程&lt;/a&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190413135911908-1437643475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;打开GitLab，发现已经推上去了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，要让这个项目真正在线上运行，根据我们的每次代码提交可以看到最新的线上内容，我们还要搞一下CI，这个下一集在讲如何手撸CI。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 06:06:00 +0000</pubDate>
<dc:creator>陌上兮月</dc:creator>
<og:description>在这一集我们将讲到如何从安装vue-cli开始，到新建一个本地项目，再到vscode中关于eslint的配置，以及本地项目关联公司远程项目的基本操作。 一，初始化本地项目 1，首先，全局安装vue-c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangnan35/p/10697812.html</dc:identifier>
</item>
<item>
<title>深度学习在推荐系统的应用(三) - 混沌战神阿瑞斯</title>
<link>http://www.cnblogs.com/arachis/p/DL4REC3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/arachis/p/DL4REC3.html</guid>
<description>&lt;h3 id=&quot;dssm深度语义匹配模型&quot;&gt;DSSM(深度语义匹配模型)&lt;/h3&gt;
&lt;h3 id=&quot;bpr贝叶斯个性化排序&quot;&gt;BPR(贝叶斯个性化排序)&lt;/h3&gt;
&lt;ul readability=&quot;0.48420177383592&quot;&gt;&lt;li&gt;模型原始论文&lt;br/&gt;&lt;a href=&quot;https://arxiv.org/pdf/1205.2618.pdf&quot;&gt;BPR: Bayesian Personalized Ranking from Implicit Feedback&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;模型简介&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;1.这篇文章提出了一种个性化排名的方法BPR-OPT，这种方法是基于贝叶斯理论的极大化后验概率。用户的显式反馈一般从用户与系统的交互行为中得出，比如用户的购买历史，观看历史等，这些很容易从后台日志中得到。&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;2.排序推荐算法大体上可以分为三类，第一类排序算法类别是点对方法(Pointwise Approach)，这类算法将排序问题被转化为分类、回归之类的问题，并使用现有分类、回归等方法进行实现。第二类排序算法是成对方法(Pairwise Approach)，在序列方法中，排序被转化为对序列分类或对序列回归。所谓的pair就是成对的排序，比如(a,b)一组表明a比b排的靠前。第三类排序算法是列表方法(Listwise Approach)，它采用更加直接的方法对排序问题进行了处理。它在学习和预测过程中都将排序列表作为一个样本。排序的组结构被保持。之前我们介绍的算法大都是Pointwise的方法，今天我们来介绍一种Pairwise的方法：贝叶斯个性化排序(Bayesian Personalized Ranking, 以下简称BPR)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;模型原理
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;1.数据pair化预处理：&lt;br/&gt;BPR算法将用户对物品的评分（显示反馈“1”，隐式反馈“0”）处理为一个pair对的集合&amp;lt;i,j&amp;gt;，其中i为评分为1的物品，j为评分为0的物品。假设某用户有M个“1”的评分，N个“0”的评分，则该用户共有M*N个pair对。&lt;br/&gt;这样数据集就由三元组&amp;lt;u,i,j&amp;gt;表示，该三元组的物理含义为：相对于物品“j”，用户“u”更喜欢物品“i”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;2.数据假设：
&lt;ul&gt;&lt;li&gt;每个用户之间的偏好行为相互独立&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;同一用户对不同物品的偏序相互独立&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;则优化问题为极大化如下目标：&lt;br/&gt;&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0097/7770/06b26cb1-b3b5-310e-9a52-f45889e00498.png&quot; alt=&quot;优化目标&quot;/&gt;&lt;br/&gt;其中theta为所求模型，具体包括：表示用户的隐含因子矩阵P，及表达物品的隐含因子矩阵Q。&lt;/p&gt;
&lt;p&gt;其中关于似然部分：&lt;br/&gt;&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0097/7784/76258e8d-49c0-3c4e-bbac-5fb6c4a5a49e.png&quot; alt=&quot;似然部分公式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们假设先验服从如下分布:&lt;br/&gt;&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0097/7786/3e25fc39-b260-3654-94d5-f0a74084fbfc.png&quot; alt=&quot;正态分布&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则先验的概率密度函数为：&lt;br/&gt;&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0097/7790/72b1d015-607b-315a-a1e5-8946c8d1aab1.png&quot; alt=&quot;正态分布密度函数&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于上述假设，优化目标进一步展开得到：&lt;br/&gt;&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0097/7792/affbb554-c96c-3efc-a1b9-5f45239273ce.png&quot; alt=&quot;计算推导1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应的最小化问题为：&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0097/7794/5f2f14c0-0bed-32c7-a2da-0b68d1bc5457.png&quot; alt=&quot;最小化目标定义&quot;/&gt;&lt;br/&gt;——其中 λθ 为正则系数&quot;model specic regularization parameters&quot;。&lt;/p&gt;
&lt;p&gt;采用SGD求解上述最小化问题，分别针对pu qi qj求偏导如下：&lt;br/&gt;&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0097/7796/f6990206-6fc9-37cd-8eeb-c9ebade1dd0e.png&quot; alt=&quot;偏导定义&quot;/&gt;&lt;/p&gt;
&lt;p&gt;偏导即为梯度下降方向，模型迭代求解的公式如下：&lt;br/&gt;&lt;img src=&quot;http://dl2.iteye.com/upload/attachment/0097/7800/225108a6-6998-3f30-8a90-2183de782baf.png&quot; alt=&quot;偏导求解公式&quot;/&gt;&lt;br/&gt;其中α为学习速率。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Apr 2019 06:03:00 +0000</pubDate>
<dc:creator>混沌战神阿瑞斯</dc:creator>
<og:description>### DSSM(深度语义匹配模型) ### BPR(贝叶斯个性化排序)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/arachis/p/DL4REC3.html</dc:identifier>
</item>
</channel>
</rss>