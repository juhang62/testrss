<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【图解】我使用过的 Dubbo 和 Spring Cloud - 史亚健</title>
<link>http://www.cnblogs.com/shiyajian/p/10381335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shiyajian/p/10381335.html</guid>
<description>&lt;p&gt;自从2015年毕业开始从事 Java 开发工作，已经过去3年多了， 在各种不知名的小公司待过，经历过生产力从低到高，技术从落后到先进的过程， Dubbo 和 Spring Cloud 就是我曾经所经历过的两次技术变革。微服务这个概念已经出现好多年了，但是最近几年微服务异常火爆，很多以前使用 Dubbo 的公司也在纷纷尝试转型。Dubbo 好还是 Spring Cloud 好，有啥差异，有啥优缺点是人们常常讨论的话题，很多知名大V也纷纷写一些科普文章，我也拜读过很多，读完感受良多，也激起了我写这篇文章的动力。这篇文章更多的不是解释概念，而是讲述我曾经使用到的两种技术的方式，希望大家可以从文章中获得启发。&lt;/p&gt;
&lt;h2 id=&quot;原生状态&quot;&gt;原生状态&lt;/h2&gt;
&lt;p&gt;如果以前关注过 Dubbo ，对 Dubbo 印象最深的一个定位就是 ”服务治理“的概念。为什么要服务治理？服务治理到底治理了什么方面？这是我们遇到的最直观的问题。&lt;/p&gt;
&lt;p&gt;下面就展示下我们曾经没有使用 Dubbo 的业务模型：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1221720/201902/1221720-20190214233642899-299437322.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大体的业务如下：&lt;/p&gt;
&lt;p&gt;1、我们有项目A，和项目B，项目A由项目管理部负责使用，项目B由物流部负责使用；&lt;/p&gt;
&lt;p&gt;2、每当项目管理部在项目A中完成一个项目，那么就必须发请求给项目B，通知项目B进行物流发货；&lt;/p&gt;
&lt;p&gt;3、项目B物流完成之后给项目A发送一个请求，完成物流操作，告知项目A进入结算。&lt;/p&gt;
&lt;p&gt;根据图看的话，无非就是两个项目互相调用，在没用采用 Dubbo 之前，我们的项目结构就像图中那样混乱，很多问题都是不可避免的。下面我就把所有遇到的问题一一进行列举，以项目A为例，：&lt;/p&gt;
&lt;p&gt;1、开发者由于自身综合素质不高，没有良好编码习惯和架构能力，对 webservice 的调用和服务暴露散落在各个层面如图所示；&lt;/p&gt;
&lt;p&gt;2、项目A中所有的请求的ip，写在配置文件，如果项目B修改了部署ip或者端口，项目A需要手动修改配置文件然后重启；&lt;/p&gt;
&lt;p&gt;3、项目B如果修改了方法的参数和返回值，项目A无法得知；&lt;/p&gt;
&lt;p&gt;4、项目A调用项目B使用的方式由于开发者的能力和经验不同，采用的实现方式千奇百怪，有的使用 okhttp ，有的使用 Apache 的 HttpClient，有的使用原生的使用 Java 提供的原生操作。同样，项目B中提供服务的方式也千奇百怪，有的是 Spring MVC 提供的 http 接口，有的使用的是 webservice，整个项目混乱不堪；&lt;/p&gt;
&lt;p&gt;5、每个人写的请求参数五花八门，比如超时时间设置，比如MediaType的设置等，没有统一的规范；&lt;/p&gt;
&lt;p&gt;6、当时接口是暴露在内网的，所以接口没有做安全性校验，但是这也是一大遗留问题。&lt;/p&gt;
&lt;h2 id=&quot;dubbo&quot;&gt;Dubbo&lt;/h2&gt;
&lt;p&gt;当原生的架构出现了这些问题之后，我们需要对架构进行更新升级，综合以前遇到的问题，我们提出了一些关于框架的需求：&lt;/p&gt;
&lt;p&gt;1、调用其他服务的时候，不用手动的维护ip和端口；&lt;/p&gt;
&lt;p&gt;2、暴露给其他服务的接口，接口形式要一致；调用其他服务的接口，方式要统一，参数统一设置，支持个别方法单独设置参数；&lt;/p&gt;
&lt;p&gt;3、采用RPC的形式，本地项目依赖远程项目提供的sdk，调用sdk中的方法就可以实现远程方法的调用。&lt;/p&gt;
&lt;p&gt;在这样的趋势下，就很正常的选择了 Dubbo 作为项目的框架，当时的想法也特别单纯，和 Dubbo 当时的定位一样，主要就是&lt;strong&gt;”服务治理“&lt;/strong&gt;，让混乱不堪的项目结构清晰起来。当时还没有想到什么分布式事务、服务熔断、服务鉴权这些概念。我们使用 Dubbo 的时候， Dubbo 依然是停止更新状态，还没有捐献给 Apache 。才采用 Dubbo 架构之后，我们对项目进行了整体的重构，同时引入了 SSO 的单点登录，最后的架构大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1221720/201902/1221720-20190214233700275-1947221638.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改之后的架构大概如下：&lt;/p&gt;
&lt;p&gt;1、新增了 CAS 服务器作为统一认证，实现多项目的 SSO，保证登录了一个系统之后，其他的系统也处于登录状态；&lt;/p&gt;
&lt;p&gt;2、项目A和项目B，每个项目给对方提供一个 rpc-client 的包，里面包含所提供的接口，公用的实体类等；&lt;/p&gt;
&lt;p&gt;3、项目A和项目B，配置上增加 Dubbo 配置，比如注册地址，序列化协议扥等 。一般都是采用 Dubbo 协议，认证到zookeeper中；&lt;/p&gt;
&lt;p&gt;4、调用对方项目的接口时候，只需要注入 rpc-client 包中的类，调用其中的方法即可，dubbo会自动在zookeeper中查找服务注册信息，发送请求，返回结构。&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud&quot;&gt;Spring Cloud&lt;/h2&gt;
&lt;p&gt;现在的公司架构采用的 Spring Cloud 微服务架构，平时自己也有学习和研究 Spring Cloud 相关的知识，自己对 Spring Cloud 的架构认识大概如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1221720/201902/1221720-20190214233712696-875606209.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概的架构如下：&lt;/p&gt;
&lt;p&gt;1、用户访问Nginx，跳转到前台页面；&lt;/p&gt;
&lt;p&gt;2、当页面有ajax请求时候，通过访问nginx，nginx转发到 Spring Cloud Gateway，然后根据路由规则转发到具体的某个微服务中；&lt;/p&gt;
&lt;p&gt;3、nacos作为服务注册发现 + 动态配置 + 服务监控使用，这里替代了 eureka + config + admin，其中config 项目，没有可视化页面，同时必须配合 Spring Cloud Bus + RabbitMQ通过订阅消息才可以实现配置的动态刷新。是nacos一个项目融合了多个功能，如果以集群方式部署，大大节省了项目的数量，比如 eureka + config + admin 都要实现高可用，那么需要至少 3*3个实例，而 nacos 只需要3个实例即可，同时降低项目复杂度。同时动态配置这块nacos提供了可视化界面，并且有配置信息回滚等操作，简单且功能强大 ；&lt;/p&gt;
&lt;p&gt;4、每个微服务之间难免有服务的调用，比如支付服务在付款的时候，必须调用订单服务，把订单中商品的数量和价格等信息查询过来，这里使用的是 Feign ，每个微服务本身属于 server 服务，给调用方提供一个 client 的sdk，当调用方使用 client 中的方法时候，就是实现了微服务之间的 Fegin 调用，同时配有 Hystrix 熔断功能，防止接口长时间不返回，阻塞后续请求造成服务的连锁奔溃反应。同时还包括有 Rbbion 的负载均衡和自动重试功能，某个服务无法访问时候，自动进行切换并重试；&lt;/p&gt;
&lt;p&gt;5、一次请求，可能涉及多个微服务，如果请求超时，那么必须要能定位到哪一步的请求耗时过多，方便后续的优化修改，这时候就必须使用微服务的全链路追踪，这里使用了 Skywalking ，是因为 Skywalking 是通过字节码增强技术实现，无须手动埋点，切性能较高。 Zipkin + Seluth 的组合，需要多个项目，同时 Zipkin 是通过 http 请求收集信息，性能较差；&lt;/p&gt;
&lt;p&gt;6、其他的分布式事务、分布式主键发号器、分库分表、缓存等方案就暂时不写，主要就是为了表达下 Spring Cloud 架构下的 Java 项目结构。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;大部分情况下，说区别其实是个伪概念，因为 Dubbo 能实现的方式 Spring Cloud 也能实现， 反之亦然。下面所说的区别是针对我个人曾经经历过的项目，个人所得出的感觉，欢迎不同观点朋友的探讨：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Dubbo
&lt;ul&gt;&lt;li&gt;项目结构：一般为前后一体化的项目为主，多以 JSP 为页面技术；&lt;/li&gt;
&lt;li&gt;项目定位：每个项目一般称之为一个系统，如 OA管理系统，BOSS系统等；&lt;/li&gt;
&lt;li&gt;团队构成：Java Web 员工为主，前后台都写；&lt;/li&gt;
&lt;li&gt;使用群体：一般为公司内部员工及管理人员使用，受众在百人与千人左右；&lt;/li&gt;
&lt;li&gt;性能要求：性能要求不高，高可用要求也不高，偶尔停机更新影响个5分钟，半小时都不会有太大影响（额。。好像容易挨打）；&lt;/li&gt;
&lt;li&gt;技术聚焦：采用 Dubbo 更多是出于服务治理的原因，就是为了解决原生架构中，服务调用的混乱和难以管理等问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring Cloud
&lt;ol&gt;&lt;li&gt;项目结构： 微服务化，每个服务关于某个具体领域，每个项目拥有自己的数据库。采用前后分离技术，前台页面关注于效果展示，页面统一访问网关，由网关根据路由规则转发到具体的某个微服务中；&lt;/li&gt;
&lt;li&gt;项目定位：每个项目称之为微服务，只提供 http ( restful ) 接口，不负责页面；&lt;/li&gt;
&lt;li&gt;研发团队：以微服务领域划分，每个微服务应该有自己的团队，独立开发和维护，每个团队尽可能将自己所负责的项目做到做好；&lt;/li&gt;
&lt;li&gt;使用群体：以广大用户为主，人数成千上万乃至亿；&lt;/li&gt;
&lt;li&gt;性能要求：一般微服务项目要求全年3个9（99.999%）或者4个9（99.9999%）高可用，微服务需要具备自动降级、故障切换、熔断、在线扩容、重启等功能；&lt;/li&gt;
&lt;li&gt;技术聚焦：采用 Spring Cloud 架构，整个系统复杂度大幅度提升了，更多的是为在高并发和大流量下系统可以正常运行。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;由于本人经验有限，经验不足，文笔笨拙，文章写的有点过于粗糙，以上分析和解释可能还有错误和有失偏驳，还望大家批评指正。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 15:43:00 +0000</pubDate>
<dc:creator>史亚健</dc:creator>
<og:description>自从2015年毕业开始从事 Java 开发工作，已经过去3年多了， 在各种不知名的小公司待过，经历过生产力从低到高，技术从落后到先进的过程， Dubbo 和 Spring Cloud 就是我曾经所经历</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shiyajian/p/10381335.html</dc:identifier>
</item>
<item>
<title>.Net Core跨平台应用研究-HelloDDNS(动态域名篇) - 赫山老妖</title>
<link>http://www.cnblogs.com/flyfire-cn/p/10381298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flyfire-cn/p/10381298.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;.Net Core跨平台应用研究-HelloDDNS&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;-玩转DDNS&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       为解决自己搭建的内网服务器需要域名而因没有超级用户密码不能开启光猫内置DDNS功能的问题，自己动手，基于.net core,实现动态域名的自助解析更新功能。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;      最近学习ABP开源项目框架，因测试和展示需求，需要部署基于asp.net core的web应用。手上有一个闲置了两年的35互联基于windows IIS的虚拟主机空间，联系服务商升级支持.net core运行时，增加无托管应用程序池，等了两天，技术支持回复不能予以支持，建议购买云主机。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      登录35的管理控制台，看了看35云主机的价格，2核4G内存10M出口带宽的云主机，1年不下5K大洋的价格，让人无语。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      听说马云baba的阿里云性价比不错，登录阿里云，2核4G的ECS，1年价格也不低于1.5K。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      错过了双11，也错过了双12，肿么办？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      想到家里100M的电信宽带，20M的上行速率，是不是可以利用下呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      正好最近在折腾基于arm64的Linux嵌入式平台（ubuntu core内核），已经成功实现了.net core应用跨平台部署（详见之前&lt;a href=&quot;https://www.cnblogs.com/flyfire-cn/p/10356991.html&quot;&gt;《.Net Core跨平台应用研究-HelloArm(串口篇)》&lt;/a&gt;文章），只要解决了外部网络访问及域名解析问题，手上就是现成的云主机啊。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      习大大说，撸起袖子加油干。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      说干就干。&lt;/p&gt;

&lt;h2&gt;    .Net Core Web应用部署&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      首先，需要解决web app的部署。发布.net core Web项目的Linux（arm64）平台运行版本，部署到Linux。具体步骤参见笔者另一篇文章&lt;a href=&quot;https://www.cnblogs.com/flyfire-cn/p/10356991.html&quot;&gt;《.Net Core跨平台应用研究-HelloArm(串口篇)》&lt;/a&gt;，在此不再赘述。&lt;/p&gt;
&lt;h2&gt;配置外网访问&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      登录电信提供的光猫，开启端口映射功能。（不懂的同学请自行百度或必应）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      通过&lt;a href=&quot;http://www.ip138.com&quot;&gt;www.ip138.com&lt;/a&gt;,查看自己的外网地址（本人直接使用的光猫路由功能，未使用二级路由），或登录光猫查看WLAN信息，获取自己的外网IP地址。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      关掉手机WIFI，用4G上网，通过手机浏览器访问http://外网IP:Port，访问发布的Web站点，bingo,访问成功。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      有同学会问，为什么要关掉手机wifi用流量访问？通常这些小型的家用路由器之类，是不会具有NAT回环配置功能的，无法从内网通过外网IP再NAT到内网IP。我的光猫，也不例外。&lt;/p&gt;
&lt;h2&gt;    DDNS简介&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      稍懂网络知识的同学应该知道，家庭宽带用户，每次拨号上网得到IP地址是非固定的（固定IP地址的带宽线路用户，每年至少需要几万大洋哦，非土豪用户，一般不会申请 固定IP），光猫断个电或由于某些原因重新启动一下，IP就发生了变化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      如何解决这个问题呢？此时，本文的主角终于快要出现了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      我们知道，TCP/IP网络中的计算机，是通过IP地址进行寻址访问的，由于IP地址不好记忆，人们发明了一种便于标识IP的方式：域名。通过域名与IP进行绑定，解决IP地址难以记忆的问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      域名到IP地址的解析，是由DNS服务所完成。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      DNS通常只实现静态注册IP地址的解析，我们这种经常会变化的IP地址怎么办呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      这年头，只要有需求，就会有对应的产品或服务。针对这种IP地坦经常发生变化又需要有域名的情况，一种叫DDNS的服务应运而生。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      顾名思义，DDNS就是动态DNS，当IP地址发生变化时，只要能及对所辖域名的DNS服务器进行更新，则可保证对应域名的解析服务可用。当然，DDNS在IP发生变化时，会有一个失效时间，但只要更新及时，失效时间很短，用于测试和展示的话，基本不影响使用。&lt;/p&gt;
&lt;h2&gt;    DDNS使用&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      中国的互联网络，从电话拨号上网，到ADSL，到现在的光纤入户，经历了好几代的演进。目前，大部分的接入设备-光猫，都是具备DDNS功能的，只不过该功能属于高阶功能，通常需要具有管理员权限才能使用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      使用DDNS服务，需要先到DDNS服务商注册，注册成功后，可下载DDNS客户端软件（pc端）或配置开启光猫DDNS功能，即可实现DDNS服务的自助更新。&lt;/p&gt;
&lt;h2&gt;    DDNS服务商&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      笔者接触互联网较早（没有从事互联网行业，感觉错失几个亿，在此汗一个），知道国内较早提供DDNS服务的是花生壳，国外提供DDNS的有dynu.com、noip.com等。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      另外在折腾路由器的过程中，用过的内置支持DDNS的光猫，在此记录一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;      华为HG8245光猫，支持3322、dynu；&lt;/li&gt;
&lt;li&gt;      烽火HG2201T光猫，支持oray(花生壳)；&lt;/li&gt;
&lt;li&gt;      ……&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2&gt;    蛋疼的中兴F450(V2)&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      因升级到100M带宽，电信给提供了一个支持1000M的光猫，型号为中兴F450。根据网络上目前能查询到的资料，一翻折腾，确定目前中兴F450（V2版本）的光猫无法在免拆机的情况获取到超级管理员帐号。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      在没有超管密码的情况下，无法进入高级网络应用功能设置，不能开启光猫内置的动态域名支持（其实我也不知道它支持哪家的动态域名哈）。&lt;/p&gt;
&lt;h2&gt;    生命不休，折腾不止&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      虽然本人的动手能力，足以通过拆机连接TTL串行接口的方式，以串行终端登录的方式获取中兴光猫的超级管理用户密码，一方面，考虑到光猫还在保修期（最近升级更换的新光猫呵），另一方，之前对DNS，DDNS的工作机制有一定的了解，知道DDNS厂家通常除了DDNS Client工具外，也有API接口可供用户自行开发集成。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;本着自已动手，丰衣足食的原则，决定自己实现DDNS定期更新功能。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;      获取相关DDNS协议&lt;/p&gt;
&lt;h2&gt;    ORAY&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      通过一翻搜索，查询到花生壳的协议文档，链接在&lt;a href=&quot;http://service.oray.com/question/3820.html&quot;&gt;这里&lt;/a&gt;，支持浏览器手动更新和原始Http Get请求：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      1.使用URL验证&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      适用于浏览器或应用程序（fetch, curl, lwp-request），可以在URL中包含验证信息。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      http://username:password@ddns.oray.com/ph/update?hostname=yourhostname&amp;amp;myip=ipaddress&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      2.原始HTTP GET请求&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      实际的HTTP请求，类似下面的代码。 其中 base-64-authorization 请使用 Base64 加密 username:password 后的字符替换。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      GET /ph/update?hostname=yourhostname&amp;amp;myip=ipaddress HTTP/1.0&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      Host: ddns.oray.com&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      Authorization: Basic base-64-authorization&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      User-Agent: Oray&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      请注意必须使用GET请求，POST是不被允许的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      更新参数&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      目前仅允许提交以下参数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      参数      说明&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      hostname    需要更新的域名，此域名必须是开通花生壳服务。多个域名使用,分隔，默认为空，则更新护照下所有激活的域名。例：hostname=test.oray.com,customtest.oray.com&lt;/p&gt;
&lt;p&gt;      myip     需要更新的IP地址，可以不填。如果不指定，则由服务器获取到的IP地址为准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     看了花生壳的动态域名更新协议，心中有底了，very easy。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;    DYNU&lt;/h2&gt;
&lt;p&gt;      因本人以前有申请过DYNU的免费域名，顺便也查了下&lt;a href=&quot;https://www.dynu.com/DynamicDNS/IP-Update-Protocol&quot;&gt;接口文档&lt;/a&gt;，文档地址如下（某些地区需要梯子呵）：&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;https://www.dynu.com/DynamicDNS/IP-Update-Protocol&quot; target=&quot;_blank&quot;&gt;https://www.dynu.com/DynamicDNS/IP-Update-Protocol&lt;/a&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;主要内容如下：&lt;/p&gt;
&lt;p&gt;      GET /nic/update?myip=198.144.117.32 HTTP/1.1&lt;/p&gt;
&lt;p&gt;      Host: api.dynu.com&lt;/p&gt;
&lt;p&gt;      Authorization: Basic [BASE64-ENCODED-USERNAME:PASSWORD-PAIR]&lt;/p&gt;
&lt;p&gt;      User-Agent: [DEVICE-MODEL-MAKE-VERSION]&lt;/p&gt;

&lt;p&gt;      Oray和Dynu的接口协议简直是一个模子出来的，不知道是谁模仿了谁，本人不想深究，好用就行。&lt;/p&gt;

&lt;h2&gt;    NO-IP&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      群中有网友提到No-IP，本人没有注册过，相关资料在此，无需FQ，有需要的同学拿走不谢。&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;https://www.noip.com/&quot;&gt;https://www.noip.com/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;https://www.noip.com/integrate/request&quot;&gt;https://www.noip.com/integrate/request&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;http://username:password@dynupdate.no-ip.com/nic/update?hostname=mytest.testdomain.com&amp;amp;myip=1.2.3.4&quot;&gt;http://username:password@dynupdate.no-ip.com/nic/update?hostname=mytest.testdomain.com&amp;amp;myip=1.2.3.4&lt;/a&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;      万事具备 ，只欠编码……&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;h2&gt;    创建类库项目&lt;/h2&gt;
&lt;p&gt;      打开宇宙最强IDE，名字我就不说了，你懂的，新建一个类库项目，选择.NET Standard类库。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190214233454200-1241325160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      为什么选择.NET Standard类库，.net跨平台的之首选佳品。相关知识自行百度/必应补充。&lt;/p&gt;
&lt;p&gt;      类库实现以下功能：&lt;/p&gt;
&lt;p&gt;      夜深了，还是上图吧&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190214233522433-1105403757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;    创建dotnet core控制台程序&lt;/h2&gt;
&lt;p&gt;      为啥选择dotnet core,原因很简单，跨平台。本人需要部署到Linux系统平台。&lt;/p&gt;
&lt;p&gt;      照旧，上图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190214233537613-1906852990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;    HttpClient和HttpClientFactor&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      原来准备直接使用HttpClient，参考一些文章后，我发现HttpClient的使用会导致一些问题：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      &lt;a href=&quot;https://www.zhibaoku.com/2018/10/31/net-core-zhong-httpclientfactory-ruhejiejue-httpclient-choumingzhaozhudewenti/&quot;&gt;.NET Core 中 HttpClientFactory 如何解决 HttpClient 臭名昭著的问题&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;a href=&quot;https://www.zhibaoku.com/2018/10/31/net-core-zhong-httpclientfactory-ruhejiejue-httpclient-choumingzhaozhudewenti/&quot;&gt;https://www.zhibaoku.com/2018/10/31/net-core-zhong-httpclientfactory-ruhejiejue-httpclient-choumingzhaozhudewenti/&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      What is HttpClientFactory?&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;a href=&quot;https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore&quot;&gt;https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      .NET Core 2.1中的HttpClientFactory最佳实践&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;a href=&quot;https://www.cnblogs.com/xiaoliangge/p/9476568.html&quot;&gt;https://www.cnblogs.com/xiaoliangge/p/9476568.html&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2&gt;    Microsoft.Extensions.Http&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      网上博客文章中，介绍IHttpClientFactory的可真不少，但是都没有提到需要安装其所需要Package,最后经过东搜西搜，花费了一翻不小的力气，还是在官方文档中找到了解决方法（好怀念有Google的日子啊）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      需要安装Microsoft.Extensions.Http包&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      官方文档出处：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.2&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.2&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      完成程序，运行：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190214233559294-1648974423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      本项目已开源至：&lt;a href=&quot;https://github.com/flyfire-cn/flyfire.DDNS&quot;&gt;https://github.com/flyfire-cn/flyfire.DDNS&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      类库flyfire.DDNS已发布至：&lt;a href=&quot;https://www.nuget.org&quot;&gt;https://www.nuget.org&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      有需要的同学，请自行获取。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;      在今天这个特别的日子，谨以此文献给所有坚守在一线的程序员/媛，祝天下有情人终成眷属。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;      也感谢我的家人，长久以来为我默默的付出。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      注：本次折腾过程中，还出现了一个意外。在配置光猫NAT端口映射时，发现死活无法生效，开始还以为是光猫功能有问题，差点准备换光猫了（手上还有HW -HG8245光猫,因是华为早期产品，功耗有点大，无线信号稍弱，退休闲置中），无意中发现WLAN中得到的IP地址，居然是一个10开头的地址，原来电信把我给分配到了一个大局域网中了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      同学们如果遇到这种情况，不要慌，给10000号打报修电话，要求使用公网IP，通常电信客服会帮你搞定。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 15:32:00 +0000</pubDate>
<dc:creator>赫山老妖</dc:creator>
<og:description>.Net Core跨平台应用研究-HelloDDNS -玩转DDNS 摘要 为解决自己搭建的内网服务器需要域名而因没有超级用户密码不能开启光猫内置DDNS功能的问题，自己动手，基于.net core,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flyfire-cn/p/10381298.html</dc:identifier>
</item>
<item>
<title>2019 Valentine's Day 圣地巡礼和WPR003N开箱刷U-boot记录 - A.Z</title>
<link>http://www.cnblogs.com/A-Z/p/super2019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/A-Z/p/super2019.html</guid>
<description>[unable to retrieve full-text content]即兴打出这个标题，似乎性息量有点大，后面的内容真的和你想象的是一样的吗？ 自上一篇blog告别这里有多少年了，掐指一算，今天是一个回归的日子，看着这里搭上云之路，渐渐的变成了云主机中的一员，感慨时事境迁，时代的标签默默地打在每一件事物的身上。 延续标题的思路，预防被称作标题党，看了一下时间，接下来就</description>
<pubDate>Thu, 14 Feb 2019 15:28:00 +0000</pubDate>
<dc:creator>A.Z</dc:creator>
<og:description>.Net Core跨平台应用研究-HelloDDNS -玩转DDNS 摘要 为解决自己搭建的内网服务器需要域名而因没有超级用户密码不能开启光猫内置DDNS功能的问题，自己动手，基于.net core,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flyfire-cn/p/10381298.html</dc:identifier>
</item>
<item>
<title>如何实现微信扫码直接下载APP - 全萨王萨</title>
<link>http://www.cnblogs.com/moone2009/p/10381287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moone2009/p/10381287.html</guid>
<description>&lt;p&gt;目前的APP基本都支持二维码扫描下载，二维码下载也成为了大家用起来很顺手的一种方式。由于微信的用户基本占据了国内市场的90%，说到扫一扫用户第一个想到的就是打开微信扫一下，通过微信分享APP，再从分享的链接下载apk/ios包。故用户通常都是使用微信打开链接或扫描二维码前往下载页，这是刚需。&lt;/p&gt;
&lt;p&gt;在我们做营销活动或推广宣传的时候，容易遇到域名被封，无法跳转app下载等情况。这时需要微信跳转外部浏览器打开页面的功能，对于ios用户默认可以通过微信内置浏览器点击右上角的更多按钮从而选择“在浏览器中打开”，对于安卓用户则可以实现微信内直接跳出到手机默认浏览器。但是很多用户其实并不知道该任何实现，其实只要在代码中进行相关的处理即可。下面为大家介绍这两种方式的实现方式，不仅可以防封，还可以达到跳转手机浏览器的效果.&lt;/p&gt;
&lt;p&gt;操作方式：&lt;/p&gt;
&lt;p&gt;旋风微跳是一款基于微信后端开发了一款微信营销下载推广助手，使用了本插件生成的链接，用户在微信任意环境下点击链接或者扫描二维码，可以实现直接跳转手机默认浏览器并打开指定网页。&lt;/p&gt;
&lt;p&gt;1、打开 &lt;a href=&quot;http://www.zjychina.cn/&quot; target=&quot;_blank&quot;&gt;旋风微跳&lt;/a&gt; 网址：&lt;a href=&quot;http://www.zjychina.cn/&quot; target=&quot;_blank&quot;&gt;http://www.zjychina.cn&lt;/a&gt;   &lt;/p&gt;


&lt;p&gt;2、准备好我们的推广链接：实例如：www.baidu.com&lt;a href=&quot;http://t.cn/EzSfapi%C2%A0&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt; 在输入框填写你的下载链接，填写完毕后。点击生成按钮&lt;/p&gt;

&lt;p&gt; 3、点击生成之后，就会看到底部生成了自己的推广二维码以及短网址链接地址。   &lt;/p&gt;

&lt;p&gt;至此，我们已经生成了APP推广链接的宣传二维码和链接。 我们就可以直接用微信扫描二维码在微信中分享和宣传引流了。这样我们能够极大的提高自己的APP在微信中的推广转化率。解决掉了微信中下载链接被屏蔽等问题。充分利用微信的用户群体来宣传引流。&lt;/p&gt;

</description>
<pubDate>Thu, 14 Feb 2019 15:27:00 +0000</pubDate>
<dc:creator>全萨王萨</dc:creator>
<og:description>目前的APP基本都支持二维码扫描下载，二维码下载也成为了大家用起来很顺手的一种方式。由于微信的用户基本占据了国内市场的90%，说到扫一扫用户第一个想到的就是打开微信扫一下，通过微信分享APP，再从分享</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moone2009/p/10381287.html</dc:identifier>
</item>
<item>
<title>[Go] 开始试探一门新语言的五点思考 - Golang - 黑眼诗人</title>
<link>http://www.cnblogs.com/farwish/p/10381275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/farwish/p/10381275.html</guid>
<description>
&lt;p&gt;1.如果在其他语言环境中写的代码很烂，那么换一门语言很可能情况更糟，因为是涉及到&lt;span&gt;基本功、工程能力和心思逻辑&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;2.一定要了解语言&lt;span&gt;&lt;a href=&quot;https://golang.org/doc/&quot; target=&quot;_blank&quot;&gt;解决的问题&lt;/a&gt;&lt;/span&gt;（比如：多核并发机制性能高、省机器、简洁易学、资料少），优势是否真的解决了问题，劣势是否可以承受，投入产出的性价比怎样，否则不如观望。&lt;/p&gt;

&lt;p&gt;3.选择合适的入门资料非常重要，有利形成正确的使用方式和提高上手速度，建议参考官网从&lt;span&gt;&lt;a href=&quot;https://golang.org/doc/code.html&quot; target=&quot;_blank&quot;&gt;工程结构&lt;/a&gt;&lt;/span&gt;开始，其次是&lt;span&gt;&lt;a href=&quot;http://www.runoob.com/go/go-tutorial.html&quot; target=&quot;_blank&quot;&gt;语言教程&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;4.越简洁的语言越考验代码的组织、抽象（比如 C、GO），此时&lt;span&gt;&lt;a href=&quot;http://www.runoob.com/design-pattern/design-pattern-tutorial.html&quot; target=&quot;_blank&quot;&gt;设计模式&lt;/a&gt;&lt;/span&gt;应能派上较大的用场。&lt;/p&gt;

&lt;p&gt;5.语言的语法、特性都是一个在实践中熟悉的过程，会依赖一些过往经验，其实也不会有明显差异，但是能实现怎样的功能几乎取决于&lt;span&gt;想象力&lt;/span&gt;（比如 Web框架、Web服务器、数据库）。&lt;/p&gt;

&lt;p&gt;Lab：&lt;a href=&quot;https://github.com/farwish/go-lab&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/go-lab&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Link：&lt;a href=&quot;https://www.cnblogs.com/farwish/p/10381275.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/farwish/p/10381275.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 15:27:00 +0000</pubDate>
<dc:creator>黑眼诗人</dc:creator>
<og:description>1.如果在其他语言环境中写的代码很烂，那么换一门语言很可能情况更糟，因为是涉及到基本功、工程能力和心思逻辑。 2.一定要了解语言解决的问题（比如：多核并发机制性能高、省机器、简洁易学、资料少），优势是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/farwish/p/10381275.html</dc:identifier>
</item>
<item>
<title>iOS 使用UI控件的外观协议UIAppearance进行设置默认UI控件样式 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/10381268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/10381268.html</guid>
<description>&lt;p&gt;在iOS开发中，经常会对UINavigationBar的样式进行全局样式。采用的设置方式有两种：&lt;/p&gt;
&lt;p&gt;第一种，采用方式如下：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[UINavigationBar appearance]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这种是对一类对象的默认全局外观样式设置，它对设置时机有要求。&lt;/p&gt;
&lt;p&gt;通常需要在UIWindow的viewlayout之前。错过了时机后，设置是没有效果的。&lt;/p&gt;
&lt;p&gt;可以选择在下面方法内设置：&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *&lt;span&gt;)launchOptions {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Override point for customization after application launch.&lt;/span&gt;
    
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; YES;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种，采用方式如下：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[self.navigationController.navigationBar setBarTintColor:[UIColor redColor]];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种是即时性的，设置后就会有效果。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;

&lt;p&gt;第一种方式通过appearance使得UINavigationBar产生了全局默认样式，那么appearance是什么东西呢？&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Appearance(外观协议)讲解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;11.5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201902/826860-20190214231421688-1023011964.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;UIAppearance文件包含于UIKit框架中，该文件很短，包括注释加起来总共56行&lt;/p&gt;
&lt;p&gt;点击去看看。&lt;/p&gt;
&lt;p&gt;里面有一个宏定义和两个协议声明，分别如下：&lt;/p&gt;
&lt;p&gt;1.宏定义：&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; UI_APPEARANCE_SELECTOR __attribute__((annotate(&quot;ui_appearance_selector&quot;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由注释可知：凡是被这个宏标记的属性方法，都可以当用作全局样式的调用方法。&lt;/p&gt;
&lt;p&gt;如：UIView的backgroundColor属性&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@property(nullable, nonatomic,copy)            UIColor          *backgroundColor UI_APPEARANCE_SELECTOR; &lt;span&gt;//&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.外观容器协议：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@protocol&lt;/span&gt; UIAppearanceContainer &amp;lt;NSObject&amp;gt; &lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是个空协议，里面啥都没有&lt;/p&gt;
&lt;p&gt;3.外观协议：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@protocol&lt;/span&gt; UIAppearance &amp;lt;NSObject&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回实现了此外观协议的UI控件实例，用这个返回的对象设置的属性是全局性。&lt;/span&gt;
+&lt;span&gt; (instancetype)appearance;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回实现了此外观协议的UI控件实例，用这个返回的对象设置的属性只对ContainerClass内部包裹的对象有效。&lt;/span&gt;
+ (instancetype)appearanceWhenContainedIn:(nullable Class &amp;lt;UIAppearanceContainer&amp;gt;)ContainerClass, ... NS_REQUIRES_NIL_TERMINATION NS_DEPRECATED_IOS(5_0, 9_0, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Use +appearanceWhenContainedInInstancesOfClasses: instead&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) __TVOS_PROHIBITED;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是iOS9之后的替代方法，作用和上面的一样。&lt;/span&gt;
+ (instancetype)appearanceWhenContainedInInstancesOfClasses:(NSArray&amp;lt;Class &amp;lt;UIAppearanceContainer&amp;gt;&amp;gt; *&lt;span&gt;)containerTypes NS_AVAILABLE_IOS(9_0);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是iOS8新增的方法，是对不同的布局方案（紧凑型，普通型）采用不同的外观样式&lt;/span&gt;
+ (instancetype)appearanceForTraitCollection:(UITraitCollection *&lt;span&gt;)trait NS_AVAILABLE_IOS(8_0);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与上面的方法相似，多了一个参数条件，只对ContainerClass内部包裹的对象有效。&lt;/span&gt;
+ (instancetype)appearanceForTraitCollection:(UITraitCollection *)trait whenContainedIn:(nullable Class &amp;lt;UIAppearanceContainer&amp;gt;)ContainerClass, ... NS_REQUIRES_NIL_TERMINATION NS_DEPRECATED_IOS(8_0, 9_0, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Use +appearanceForTraitCollection:whenContainedInInstancesOfClasses: instead&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) __TVOS_PROHIBITED;
//iOS9后的新方法，是对上面方法的替换。
&lt;/span&gt;+ (instancetype)appearanceForTraitCollection:(UITraitCollection *)trait whenContainedInInstancesOfClasses:(NSArray&amp;lt;Class &amp;lt;UIAppearanceContainer&amp;gt;&amp;gt; *&lt;span&gt;)containerTypes  NS_AVAILABLE_IOS(9_0);
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面代码中对里面定义的5个方法进行了说明。&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;遵守了这两个协议的类，可以进行同一默认外观设置，那么哪些类遵守了这两个协议了呢？&lt;/p&gt;
&lt;p&gt;看一下UI控件的父类UIView&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
NS_CLASS_AVAILABLE_IOS(2_0) &lt;span&gt;@interface&lt;/span&gt; UIView : UIResponder &amp;lt;NSCoding, UIAppearance, UIAppearanceContainer, UIDynamicItem, UITraitEnvironment, UICoordinateSpace, UIFocusItem, UIFocusItemContainer, CALayerDelegate&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面UIView的定义可以发现，UIView遵守了外观协议和外观容器协议。&lt;/p&gt;
&lt;p&gt;也就是说所有的UI控件，只有其属性方法被UI_APPEARANCE_SELECTOR宏标示了，那么就可以进行全局外观&lt;/p&gt;
&lt;p&gt;默认设置。&lt;/p&gt;

&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里列一下UINavigationBar通常用的的全局设置。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//⚠️: 1与2互斥，且1的优先级高&lt;/p&gt;
&lt;p&gt;//1.设置导航背景&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
UIImage *bg =&lt;span&gt; [UIImage pureImageWithColor:[UIColor brownColor]];
[[UINavigationBar appearance] setBackgroundImage:bg forBarMetrics:UIBarMetricsDefault];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;//2.设置导航颜色&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[[UINavigationBar appearance] setBarTintColor:[UIColor redColor]];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;//3.设置导航文字颜色&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[[UINavigationBar appearance] setTintColor:[UIColor blueColor]];
&lt;/pre&gt;&lt;/div&gt;
//4.设置导航字体&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
NSShadow *shadow =&lt;span&gt; [[NSShadow alloc] init];
shadow.shadowColor &lt;/span&gt;= [UIColor colorWithRed:&lt;span&gt;0.0&lt;/span&gt; green:&lt;span&gt;0.0&lt;/span&gt; blue:&lt;span&gt;0.0&lt;/span&gt; alpha:&lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;];
shadow.shadowOffset &lt;/span&gt;= CGSizeMake(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
[[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys: [UIColor colorWithRed:&lt;/span&gt;&lt;span&gt;245.0&lt;/span&gt;/&lt;span&gt;255.0&lt;/span&gt; green:&lt;span&gt;245.0&lt;/span&gt;/&lt;span&gt;255.0&lt;/span&gt; blue:&lt;span&gt;245.0&lt;/span&gt;/&lt;span&gt;255.0&lt;/span&gt; alpha:&lt;span&gt;1.0&lt;/span&gt;], NSForegroundColorAttributeName, shadow, NSShadowAttributeName, [UIFont fontWithName:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;HelveticaNeue-CondensedBlack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; size:&lt;span&gt;21.0&lt;/span&gt;], NSFontAttributeName, nil]];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;//5.特定环境或某种场合下外观样式设置（水平紧凑型，UINavigationBar默认外观为粉色。）&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[[UINavigationBar appearanceForTraitCollection:[UITraitCollection traitCollectionWithHorizontalSizeClass:UIUserInterfaceSizeClassCompact]] setBarTintColor:[UIColor purpleColor]];
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;另外对UIButton的全局默认设置如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//让一类控件同时表现出某种属性&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[[UIButton appearance] setBackgroundColor:[UIColor yellowColor]];
[[UIButton appearance] setTitle:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;同一设置&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; forState:UIControlStateNormal];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;//让一类控件在某种环境下表现出某种外观样式&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[[UIButton appearanceWhenContainedInInstancesOfClasses:@[[UINavigationBar &lt;span&gt;class&lt;/span&gt;]]] setTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;比较特别&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; forState:UIControlStateNormal];
[[UIButton appearanceWhenContainedInInstancesOfClasses:@[[UINavigationBar &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;]]] setBackgroundColor:[UIColor redColor]];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;UI控件的默认全局设置方式符合预期。&lt;/p&gt;
&lt;p&gt;那么iOS开发中，所有的UI控件都可以通过上面两种方法进行全局样式默认设置和自定义设置了。&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 14 Feb 2019 15:23:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>在iOS开发中，经常会对UINavigationBar的样式进行全局样式。采用的设置方式有两种： 第一种，采用方式如下： [UINavigationBar appearance] 这种是对一类对象的默</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/10381268.html</dc:identifier>
</item>
<item>
<title>Mysql实现树形递归查询 - javahih</title>
<link>http://www.cnblogs.com/mzq123/p/10381216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10381216.html</guid>
<description>&lt;p&gt;最近在做项目迁移，Oracle版本的迁到Mysql版本，遇到有些oracle的函数，mysql并没有，所以就只好想自定义函数或者找到替换函数的方法进行改造。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Oracle递归查询&lt;/strong&gt;&lt;br/&gt;oracle实现递归查询的话，就可以使用start with ... connect by&lt;/p&gt;
&lt;p&gt;connect by递归查询基本语法是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select 1 from 表格 start with ... connect by prior id = pId &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;start with：表示以什么为根节点，不加限制可以写1=1，要以id为123的节点为根节点，就写为start with id =123&lt;/p&gt;
&lt;p&gt;connect by：connect by是必须的，start with有些情况是可以省略的，或者直接start with 1=1不加限制&lt;/p&gt;
&lt;p&gt;prior：prior关键字可以放在等号的前面，也可以放在等号的后面，表示的意义是不一样的，比如 prior id = pid，就表示pid就是这条记录的根节点了&lt;/p&gt;
&lt;p&gt;具体可以参考我以前写的一篇oracle方面的博客：https://blog.csdn.net/u014427391/article/details/84996259&lt;/p&gt;
&lt;p&gt;Oracle方面的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;select id=&quot;listUnitInfo&quot; resultType=&quot;com.admin.system.unit.model.UnitModel&quot; databaseId=&quot;oracle&quot;&amp;gt;
        select distinct u.unit_code,
              u.unit_name,
              u.unit_tel,
              u.para_unit_code
         from lzcity_approve_unit_info u
         start with 1 = 1
         &amp;lt;if test=&quot;unitCode != null and unitCode !=''&quot;&amp;gt;
            and u.unit_code = #{unitCode}
         &amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;unitName!=null and unitName!=''&quot;&amp;gt;
            and u.unit_name like '%'|| #{unitName} ||'%'
         &amp;lt;/if&amp;gt;
         connect by prior u.unit_code = u.para_unit_code
            and u.unit_code &amp;amp;lt;&amp;gt;u.para_unit_code
    &amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Mysql递归查询&lt;/strong&gt;&lt;br/&gt;下面主要介绍Mysql方面的实现，Mysql并没有提供类似函数，所以只能通过自定义函数实现，网上很多这种资料，不过已经不知道那篇是原创了，这篇博客写的不错，https://www.2cto.com/database/201209/152513.html， 下面我也是用作者提供的方法实现自己的，先感谢作者的分享&lt;/p&gt;
&lt;p&gt;这里借用作者提供的自定义函数，再加上Find_in_set函数 &lt;code&gt;find_in_set(u.unit_code,getunitChildList(#{unitCode}))&lt;/code&gt;，getunitChildList是自定义函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;select id=&quot;listUnitInfo&quot; resultType=&quot;com.admin.system.unit.model.UnitModel&quot; databaseId=&quot;mysql&quot;&amp;gt;
        select distinct u.unit_code,
              u.unit_name,
              u.unit_tel,
              u.para_unit_code
         from t_unit_info u
         &amp;lt;where&amp;gt;
             &amp;lt;if test=&quot;unitCode != null and unitCode !=''&quot;&amp;gt;
                and find_in_set(u.unit_code,getunitChildList(#{unitCode}))
             &amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;unitName!=null and unitName!=''&quot;&amp;gt;
                and u.unit_name like concat('%', #{unitName} ,'%')
             &amp;lt;/if&amp;gt;
         &amp;lt;/where&amp;gt;
    &amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getUnitChildList自定义函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DELIMITER $$

USE `gd_base`$$

DROP FUNCTION IF EXISTS `getUnitChildList`$$

CREATE DEFINER=`root`@`%` FUNCTION `getUnitChildList`(rootId INT) RETURNS VARCHAR(1000) CHARSET utf8
BEGIN
      DECLARE sChildList VARCHAR(1000);
      DECLARE sChildTemp VARCHAR(1000);
      SET sChildTemp =CAST(rootId AS CHAR);
      WHILE sChildTemp IS NOT NULL DO
        IF (sChildList IS NOT NULL) THEN
          SET sChildList = CONCAT(sChildList,',',sChildTemp);
    ELSE
      SET sChildList = CONCAT(sChildTemp);
    END IF;
        SELECT GROUP_CONCAT(unit_code) INTO sChildTemp FROM LZCITY_APPROVE_UNIT_INFO WHERE FIND_IN_SET(para_unit_code,sChildTemp)&amp;gt;0;
        END WHILE;
      RETURN sChildList;
END$$

DELIMITER ;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 14 Feb 2019 15:02:00 +0000</pubDate>
<dc:creator>javahih</dc:creator>
<og:description>最近在做项目迁移，Oracle版本的迁到Mysql版本，遇到有些oracle的函数，mysql并没有，所以就只好想自定义函数或者找到替换函数的方法进行改造。 Oracle递归查询 oracle实现递归</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10381216.html</dc:identifier>
</item>
<item>
<title>Oracle session相关数据字典(一) - gegeman</title>
<link>http://www.cnblogs.com/lijiaman/p/10381167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiaman/p/10381167.html</guid>
<description>&lt;p&gt;&lt;strong&gt;（一）session相关视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)视图&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;v$session&lt;/li&gt;
&lt;li&gt;v$active_session_history&lt;/li&gt;
&lt;li&gt;dba_hist_active_session_history&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果是多节点数据库，v$session和v$active_hist_session_history仅获得单节点的信息，可以使用gv$sessiongv$active_session_history来获取所有节点的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)三个视图介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2.1）v$session&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;v$session视图记录了当前连接到数据库的session信息，记录的是实时的数据，当有新的会话连接到数据库时，v$session就会产生一条新的session记录，一旦会话断开，记录消除，所以v$session的信息是实时动态变化的。&lt;/p&gt;
&lt;p&gt;视图结构如下：&lt;/p&gt;
&lt;p&gt;链接：  &lt;a href=&quot;https://www.cnblogs.com/lijiaman/p/6881695.html&quot;&gt;v$session视图介绍&lt;/a&gt; ，其它2个视图与其类似，不再介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2.2)v$active_session_history&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　v$active_session_history是记录了数据库活跃会话的采样，如果是多节点，则用gv$active_session_history来查看所有节点的信息。每隔1秒钟，数据库会进行一次采样，将活跃会话记录到该视图，每个活跃会话记录一行。该视图是ASH的核心，用以记录活动SESSION的历史等待信息，这部分内容记录在内存中，期望值是记录一个小时的内容。&lt;/p&gt;
&lt;p&gt;　　关于活跃会话的定义，大致如下：会话在CPU进行运算或者是非空闲等待的会话都属于活跃会话。官方解释：A database session is considered active if it was on the CPU or was waiting for an event that didn't belong to the &lt;code&gt;Idle&lt;/code&gt; wait class. Refer to the &lt;code&gt;V$EVENT_NAME&lt;/code&gt; view for more information on wait classes.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195449432-1901100376.png&quot;&gt;&lt;img title=&quot;ash&quot; src=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195450216-27851391.png&quot; alt=&quot;ash&quot; width=&quot;511&quot; height=&quot;226&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;               图1. v$active_session_history是ash报告的数据来源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2.3）dba_hist_active_sess_history&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　视图gv$active_session_history会每秒钟将数据库所有节点的活跃会话采样一次，但是数据是存放在内存中的，无法长久保存。而dba_hist_active_sess_history则会将gv$active_session_history里的数据每10秒采样一次并持久化保存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）视图数据流向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195450581-1499666706.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195450988-1788019042.png&quot; alt=&quot;image&quot; width=&quot;654&quot; height=&quot;469&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                               图2.视图数据流向&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：这里需要非常注意，假如一个sql语句运行了100秒，那么会在v$active_session_history里面采集到100~101次，而v$dba_hist_active_session_history每隔10秒从v$active_session_history里面采集一次样本，那么会采集到10~11次样本，计算时间时需要x10.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（二）session相关视图的用途&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）使用v$session来查看实时阻塞会话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以前处理异常锁的方式如下：&lt;/p&gt;
&lt;p&gt;1.查询blocking session&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt;    se.machine,se.sid,se.serial#,se.seconds_in_wait,se.paddr,lo.block
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;    v$lock lo, v$session se
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;    lo.sid &lt;span&gt;=&lt;/span&gt;&lt;span&gt; se.sid
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt;    lo.block &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;bloc&amp;gt;0代表这个会话阻塞了其他会话&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.根据1的sid，serial#杀死会话&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; system &lt;span&gt;kill&lt;/span&gt; session &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sid,serial#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后来在EM里面的Blocking session里面看到下图，以折叠图的形式展现，最上面的代表正在阻塞其它session的会话，研究了一下，可以使用v$session来得到类似的效果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195451443-2042085633.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195452695-1769505512.png&quot; alt=&quot;image&quot; width=&quot;1180&quot; height=&quot;292&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                                                                  图1.blocking session树形图&lt;/p&gt;
&lt;p&gt;我们来做一次测试，对表test01和test02进行DML操作，观察运行情况，操作如下&lt;/p&gt;
&lt;p&gt;（1）创建测试表test01,test02。并在2个表的id列添加主键约束&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195453700-1524435692.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195454394-97828170.png&quot; alt=&quot;image&quot; width=&quot;245&quot; height=&quot;159&quot; border=&quot;0&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195454734-1821234637.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195455060-1678844983.png&quot; alt=&quot;image&quot; width=&quot;244&quot; height=&quot;156&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;         test01表                                                               test02表&lt;/p&gt;
&lt;p&gt;（2）对2个表进行操作，执行顺序如下&lt;/p&gt;
&lt;p&gt;----------------------------------------test01操作-------------------------------------------------------&lt;/p&gt;
&lt;p&gt;[sessid:27  ]  delete from test01;                                      --删除test01整个表的数据，未提交，阻塞源头&lt;/p&gt;
&lt;p&gt;[sessid:28  ]  update test01 set name = 'aaa' where id = 1;   --更新test01表id=1的行，会话产生等待&lt;/p&gt;
&lt;p&gt;[sessid:142]   insert into test01 values(1,'abc');                   --插入test01表id=1的行，会话产生等待&lt;/p&gt;
&lt;p&gt;[sessid:25 ]   delete from test01 where id = 2;                     --删除test01表id=2的行，会话产生等待&lt;/p&gt;
&lt;p&gt;[sessid:29 ]   update test01 set  name = 'bbb' where id  = 2; --更新test01表id=2的行，会话产生等待&lt;/p&gt;
&lt;p&gt;-----------------------------------------test02操作--------------------------------------------------------&lt;/p&gt;
&lt;p&gt;[sessid:30 ]  insert into test02 values(3,'augly',3000);          --插入test02表id=3的行，未提交，阻塞源头&lt;/p&gt;
&lt;p&gt;[sessid:23 ]  insert into test02 values(3,'augly',3300);          --插入test02表id=3的行，会话产生等待&lt;/p&gt;
&lt;p&gt;此时我们到EM里面观察，就会发现图1的blocking session树形图。&lt;/p&gt;
&lt;p&gt;在实际环境中，大部分系统是没有安装EM的，在没有EM的情况下，我们依然可以通过v$session得到类似的图形&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;使用v$session来查看阻塞session信息&lt;/span&gt;

&lt;span&gt;SELECT&lt;/span&gt;   LPAD(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;LEVEL&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;||&lt;/span&gt;S.&quot;USERNAME&quot; &lt;span&gt;AS &lt;span&gt;user&lt;/span&gt;&lt;/span&gt;&lt;span&gt; , 
         LPAD(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;LEVEL&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;||&lt;/span&gt;&lt;span&gt;S.&quot;SID&quot; &lt;span&gt;AS &lt;span&gt;sid&lt;/span&gt;&lt;/span&gt;,
         S.&quot;SERIAL#&quot;,
         S.&quot;SQL_ID&quot;,
         S.&quot;WAIT_CLASS&quot;,
         S.&quot;EVENT&quot;,
         S.&quot;P1&quot;,
         S.&quot;P2&quot;,
         S.&quot;P3&quot;,
         S.&quot;SECONDS_IN_WAIT&quot;
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;     V$SESSION S 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;    S.&quot;BLOCKING_SESSION&quot; &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;
&lt;span&gt;OR&lt;/span&gt;       S.SID &lt;span&gt;IN&lt;/span&gt;(&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;DISTINCT&lt;/span&gt; BLOCKING_SESSION &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; V$SESSION)
START &lt;/span&gt;&lt;span&gt;WITH&lt;/span&gt; S.&quot;BLOCKING_SESSION&quot; &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
CONNECT &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt; PRIOR S.&quot;SID&quot; &lt;span&gt;=&lt;/span&gt; S.&quot;BLOCKING_SESSION&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下，红色的为阻塞源头：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195455661-1974406429.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/823295/201812/823295-20181209195456417-366504555.png&quot; alt=&quot;image&quot; width=&quot;1009&quot; height=&quot;156&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）使用v$active_session_history、dba_hist_active_sess_history来查看历史阻塞会话信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时数据库出现问题，而我们不在现场，事后需要分析当时的业务异常情况，可以使用v$active_session_history和dba_hist_active_sess_history来分析当时的情况。&lt;/p&gt;
&lt;p&gt;使用dba_hist_active_sess_history的例子：&lt;a title=&quot;https://www.cnblogs.com/lijiaman/p/10381133.html&quot; href=&quot;https://www.cnblogs.com/lijiaman/p/10381133.html&quot;&gt;https://www.cnblogs.com/lijiaman/p/10381133.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【完】&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 14:42:00 +0000</pubDate>
<dc:creator>gegeman</dc:creator>
<og:description>（一）session相关视图 (1)视图 v$session v$active_session_history dba_hist_active_session_history 如果是多节点数据库，v$</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiaman/p/10381167.html</dc:identifier>
</item>
<item>
<title>爬虫之Scrapy框架介绍 - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10381121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10381121.html</guid>
<description>&lt;p&gt;Scrapy是用纯Python实现一个为了爬取网站数据、提取结构性数据而编写的应用框架，用途非常广泛。&lt;/p&gt;
&lt;p&gt;框架的力量，用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便。&lt;/p&gt;
&lt;p&gt;Scrapy 使用了 Twisted异步网络框架来处理网络通讯，可以加快我们的下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。&lt;/p&gt;
&lt;h2&gt;Scrapy架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201902/1392643-20190214212754020-2044044744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scrapy Engine(引擎)&lt;/strong&gt;: 用来处理整个系统的数据流处理, 触发事务(框架核心)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scheduler(调度器)&lt;/strong&gt;: 用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Downloader（下载器）&lt;/strong&gt;：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spider（爬虫）&lt;/strong&gt;：爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Item Pipeline(管道)&lt;/strong&gt;：负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Downloader Middlewares（下载中间件）&lt;/strong&gt;：位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spider Middlewares（调度中间件）&lt;/strong&gt;：介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。&lt;/p&gt;
&lt;h2&gt;Scrapy运行流程&lt;/h2&gt;
&lt;div readability=&quot;17.559953434226&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;ol&gt;&lt;li&gt;首先，引擎从调度器中取出一个链接(URL)用于接下来的抓取&lt;/li&gt;
&lt;li&gt;引擎把URL封装成一个请求(Request)传给下载器，下载器把资源下载下来，并封装成应答包(Response)&lt;/li&gt;
&lt;li&gt;然后，爬虫解析Response&lt;/li&gt;
&lt;li&gt;若是解析出实体（Item）,则交给实体管道进行进一步的处理。&lt;/li&gt;
&lt;li&gt;若是解析出的是链接（URL）,则把URL交给Scheduler等待抓取&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;安装&lt;/h2&gt;
&lt;h3&gt;Linux安装:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip3 install scrapy
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Windows安装:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. pip3 install wheel&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 下载twisted http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3. 进入下载目录，执行 pip3 install Twisted‑17.1.0‑cp35‑cp35m‑win_amd64.whl&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4. pip3 install pywin32&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5. pip3 install scrapy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;命令行工具&lt;/h2&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1 查看帮助&lt;/span&gt;
    scrapy -&lt;span&gt;h
    scrapy &lt;/span&gt;&amp;lt;command&amp;gt; -&lt;span&gt;h

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2 有两种命令：其中Project-only必须切到项目文件夹下才能执行，而Global的命令则不需要&lt;/span&gt;
&lt;span&gt;    Global commands:
        startproject &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建项目&lt;/span&gt;
        genspider    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建爬虫程序&lt;/span&gt;
        settings     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果是在项目目录下，则得到的是该项目的配置&lt;/span&gt;
        runspider    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行一个独立的python文件，不必创建项目&lt;/span&gt;
        shell        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;scrapy shell url地址  在交互式调试，如选择器规则正确与否&lt;/span&gt;
        fetch        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;独立于程单纯地爬取一个页面，可以拿到请求头&lt;/span&gt;
        view         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;下载完毕后直接弹出浏览器，以此可以分辨出哪些数据是ajax请求&lt;/span&gt;
        version      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;scrapy version 查看scrapy的版本，scrapy version -v查看scrapy依赖库的版本&lt;/span&gt;
    Project-&lt;span&gt;only commands:
        crawl        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行爬虫，必须创建项目才行，确保配置文件中ROBOTSTXT_OBEY = False&lt;/span&gt;
        check        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;检测项目中有无语法错误&lt;/span&gt;
        list         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;列出项目中所包含的爬虫名&lt;/span&gt;
        edit         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;编辑器，一般不用&lt;/span&gt;
        parse        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;scrapy parse url地址 --callback 回调函数  #以此可以验证我们的回调函数是否正确&lt;/span&gt;
        bench        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;scrapy bentch压力测试&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scrapy框架官方网址：&lt;a href=&quot;http://doc.scrapy.org/en/latest&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;http://doc.scrapy.org/en/latest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Scrapy中文维护站点：&lt;a href=&quot;http://scrapy-chs.readthedocs.io/zh_CN/latest/index.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;http://scrapy-chs.readthedocs...&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;目录结构&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
project_name/&lt;span&gt;
   scrapy.cfg  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 项目的主配置信息，用来部署scrapy时使用，爬虫相关的配置信息在settings.py文件中。&lt;/span&gt;
   project_name/
       &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
       items.py  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置数据存储模板，用于结构化数据，如：Django的Model&lt;/span&gt;
       pipelines.py  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 项目管道文件，如：一般结构化的数据持久化&lt;/span&gt;
       settings.py  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置文件，如：递归的层数、并发数，延迟下载等。&lt;/span&gt;
       spiders/  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 爬虫目录，如：创建文件，编写爬虫规则&lt;/span&gt;
           &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
           爬虫1.py
           爬虫2.py
           爬虫3.py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1. 一般创建爬虫文件时，以网站域名命名&lt;/p&gt;
&lt;p&gt;　　2. 默认只能在终端执行命令，为了更便捷操作：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;如果想在pycharm中执行需要做：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在项目目录下新建：entrypoint.py&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; scrapy.cmdline &lt;span&gt;import&lt;/span&gt;&lt;span&gt; execute
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; execute(['scrapy', 'crawl', 'amazon','--nolog'])  #不要日志打印&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; execute(['scrapy', 'crawl', 'amazon'])&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;我们可能需要在命令行为爬虫程序传递参数，就用下面这样的命令&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;acrapy crawl amzaon -a keyword=iphone8&lt;/span&gt;
execute([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scrapy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;crawl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amazon1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;keyword=iphone8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--nolog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;不要日志打印&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; execute(['scrapy', 'crawl', 'amazon1'])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;


&lt;p&gt;&lt;strong&gt;1.创建爬虫应用程序&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
scrapy startproject Qiubai  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建项目&lt;/span&gt;
&lt;span&gt;
cd Qiubai &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进入项目目录&lt;/span&gt;
&lt;span&gt;
scrapy genspider qiubai www.qiushibaike.com  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 应用名称 爬取网页的起始url&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;28.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;2 编写爬虫文件:在步骤2执行完毕后，会在项目的spiders中生成一个应用名的py爬虫文件，文件源码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; QiubaiSpider(scrapy.Spider):
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;qiubai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 应用名称&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许爬取的域名（如果遇到非该域名的url则爬取不到数据）&lt;/span&gt;
    allowed_domains = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.qiushibaike.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    start_urls &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.qiushibaike.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 起始爬取的url&lt;/span&gt;
 
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; xpath为response中的方法，可以将xpath表达式直接作用于该函数中&lt;/span&gt;
        odiv = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@id=&quot;content-left&quot;]/div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        content_list &lt;/span&gt;= [] &lt;span&gt;# &lt;/span&gt;&lt;span&gt;用于存储解析到的数据&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; div &lt;span&gt;in&lt;/span&gt;&lt;span&gt; odiv:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; xpath函数返回的为列表，列表中存放的数据为Selector类型的数据。我们解析到的内容被封装在了Selector对象中，需要调用extract()函数将解析的内容从Selecor中取出。&lt;/span&gt;
            author = div.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//div[@class=&quot;author clearfix&quot;]/a/h2/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0].extract()
            content&lt;/span&gt;=div.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//div[@class=&quot;content&quot;]/span/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0].extract()
 
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将解析到的内容封装到字典中&lt;/span&gt;
            dic=&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;作者&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:author,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:content
            }
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将数据存储到content_list这个列表中&lt;/span&gt;
&lt;span&gt;            content_list.append(dic)
 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; content_list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3 设置修改settings.py配置文件相关配置，修改内容及其结果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
USER_AGENT = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;伪装请求载体身份&lt;/span&gt;
&lt;span&gt; 
ROBOTSTXT_OBEY &lt;/span&gt;= False  &lt;span&gt;# &lt;/span&gt;&lt;span&gt;可以忽略或者不遵守robots协议&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4 执行爬虫程序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
scrapy crawl 爬虫名称  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该种执行形式会显示执行的日志信息&lt;/span&gt;
scrapy crawl 爬虫名称 --nolog  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该种执行形式不会显示执行的日志信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;今天是情人节，祝大家情人节快乐&lt;/p&gt;
&lt;p&gt;有对象的已经去跟对象去约会了，爱学习的才会跟代码相伴（比如我）&lt;/p&gt;
&lt;p&gt;送大家一段 python 的情人节代码吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.join([&lt;span&gt;''&lt;/span&gt;.join([(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Love&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;[(x-y) % len(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Love&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)] &lt;span&gt;if&lt;/span&gt; ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3 &amp;lt;= 0 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(-30, 30)]) &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt; range(30, -30, -1)]))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好奇的去copy运行一下吧~&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 14 Feb 2019 14:30:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>Scrapy介绍 Scrapy是用纯Python实现一个为了爬取网站数据、提取结构性数据而编写的应用框架，用途非常广泛。 框架的力量，用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10381121.html</dc:identifier>
</item>
<item>
<title>HTTP性能测试工具wrk安装及使用 - guoew</title>
<link>http://www.cnblogs.com/guoew/p/10381115.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoew/p/10381115.html</guid>
<description>&lt;p&gt;wrk 是一个很简单的 http 性能测试工具，没有Load Runner那么复杂，他和 apache benchmark（ab）同属于HTTP性能测试工具，但是比 ab 功能更加强大，并且可以支持lua脚本来创建复杂的测试场景。&lt;/p&gt;
&lt;p&gt;wrk 的一个很好的特性就是能用很少的线程压出很大的并发量，原因是它使用了一些操作系统特定的高性能 io 机制, 比如 select, epoll, kqueue 等.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;其实它是复用了 redis 的 ae 异步事件驱动框架. 确切的说 ae 事件驱动框架并不是 redis 发明的, 它来至于 Tcl的解释器 jim, 这个小巧高效的框架, 因为被 redis 采用而更多的被大家所熟知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;wrk 是开源的, 代码在 github 上. https://github.com/wg/wrk&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;p&gt;wrk 支持大多数类 UNIX 系统，不支持 windows。需要操作系统支持LuaJIT 和 OpenSSL，不过不用担心，大多数类 Unix 系统都支持。安装 wrk 非常简单，只要从 github 上下载 wrk 源码，在项目路径下执行 make 命令即可。&lt;/p&gt;
&lt;h5 id=&quot;unbuntudebian下的安装&quot;&gt;Unbuntu/Debian下的安装&lt;/h5&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo apt-get install build-essential libssl-dev git -y
git clone https://github.com/wg/wrk.git wrk
cd wrk
make
# 把生成的wrk移到一个PATH目录下面, 比如
sudo cp wrk /usr/local/bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;centosredhatfedora-下的安装&quot;&gt;CentOs/RedHat/Fedora 下的安装&lt;/h5&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo yum groupinstall 'Development Tools'
sudo yum install openssl-devel
sudo yum install git
git clone https://github.com/wg/wrk.git wrk
cd wrk
make
# 把生成的 wrk 移到一个 PATH 目录下面, 比如
sudo cp wrk /usr/local/bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;mac-下快捷安装&quot;&gt;mac 下快捷安装&lt;/h5&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;brew install wrk
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;基本使用&quot;&gt;基本使用&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;wrk -t12 -c400 -d30s http://127.0.0.1:8080/index.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 12 个线程运行 30 秒, 400 个 http 并发&lt;/p&gt;
&lt;h4 id=&quot;命令行选项&quot;&gt;命令行选项&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;使用方法: wrk &amp;lt;选项&amp;gt; &amp;lt;被测HTTP服务的URL&amp;gt;
  Options:
    -c, --connections &amp;lt;N&amp;gt;  跟服务器建立并保持的 TCP 连接数量
    -d, --duration    &amp;lt;T&amp;gt;  压测时间
    -t, --threads     &amp;lt;N&amp;gt;  使用多少个线程进行压测
    -s, --script      &amp;lt;S&amp;gt;  指定 Lua 脚本路径
    -H, --header      &amp;lt;H&amp;gt;  为每一个 HTTP 请求添加 HTTP 头
        --latency          在压测结束后，打印延迟统计信息
        --timeout     &amp;lt;T&amp;gt;  超时时间
    -v, --version          打印正在使用的 wrk 的详细版本信息

  &amp;lt;N&amp;gt;代表数字参数，支持国际单位 (1k, 1M, 1G)
  &amp;lt;T&amp;gt;代表时间参数，支持时间单位 (2s, 2m, 2h)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;做一次简单压测，分析下结果&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;wrk -t8 -c200 -d30s --latency  &quot;http://www.bing.com&quot;

输出：
Running 30s test @ http://www.bing.com
  8 threads and 200 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    46.67ms  215.38ms   1.67s    95.59%
    Req/Sec     7.91k     1.15k   10.26k    70.77%
  Latency Distribution
     50%    2.93ms
     75%    3.78ms
     90%    4.73ms
     99%    1.35s
  1790465 requests in 30.01s, 684.08MB read
Requests/sec:  59658.29
Transfer/sec:     22.79MB
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上使用 8 个线程 200 个连接，对 bing 首页进行了 30 秒的压测，并要求在压测结果中输出响应延迟信息。以下对压测结果进行简单注释：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Running 30s test @ http://www.bing.com （压测时间30s）
  8 threads and 200 connections （共8个测试线程，200个连接）
  Thread Stats   Avg      Stdev     Max   +/- Stdev
              （平均值） （标准差）（最大值）（正负一个标准差所占比例）
    Latency    46.67ms  215.38ms   1.67s    95.59%
    （延迟）
    Req/Sec     7.91k     1.15k   10.26k    70.77%
    （处理中的请求数）
  Latency Distribution （延迟分布）
     50%    2.93ms
     75%    3.78ms
     90%    4.73ms
     99%    1.35s （99分位的延迟）
  1790465 requests in 30.01s, 684.08MB read （30.01秒内共处理完成了1790465个请求，读取了684.08MB数据）
Requests/sec:  59658.29 （平均每秒处理完成59658.29个请求）
Transfer/sec:     22.79MB （平均每秒读取数据22.79MB）
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，wrk 使用方便，结果清晰。并且因为非阻塞 IO 的使用，可以在普通的测试机上创建出大量的连接，从而达到较好的压测效果。&lt;/p&gt;
&lt;h4 id=&quot;lua脚本压测&quot;&gt;lua脚本压测&lt;/h4&gt;
&lt;p&gt;在基本压测中, 每次发送的请求都是一样的,很多时候我们压测的请求体是每个请求都不一样, 这时候就要写lua基本来压测&lt;/p&gt;
&lt;h5 id=&quot;使用-post-方法压测&quot;&gt;使用 POST 方法压测&lt;/h5&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;wrk.method = &quot;POST&quot;
wrk.body   = &quot;foo=bar&amp;amp;baz=quux&quot;
wrk.headers[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;wrk -t2 -d30s -c1k -s xxx.lua http://192.168.17.1/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;每个-request-的参数都不一样&quot;&gt;每个 request 的参数都不一样&lt;/h5&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;request = function()
   uid = math.random(1, 10000000)
   path = &quot;/test?uid=&quot; .. uid
   return wrk.format(nil, path)
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释一下 wrk.format 这个函数&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;wrk.format 这个函数的作用,根据参数和全局变量 wrk 生成一个 http 请求
函数签名: function wrk.format(method, path, headers, body)
method:http方法,比如GET/POST等
path: url上的路径(含函数)
headers: http header
body: http body&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;每个线程先登录然后压测&quot;&gt;每个线程先登录然后压测&lt;/h5&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;token = nil
path  = &quot;/authenticate&quot;

request = function()
   return wrk.format(&quot;GET&quot;, path)
end

response = function(status, headers, body)
   if not token and status == 200 then
      token = headers[&quot;X-Token&quot;]
      path  = &quot;/resource&quot;
      wrk.headers[&quot;X-Token&quot;] = token
   end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;发送-json&quot;&gt;发送 json&lt;/h4&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;request = function()
    local headers = { }
    headers['Content-Type'] = &quot;application/json&quot;
    body = {
        mobile={&quot;1533899828&quot;},
        params={code=math.random(1000,9999)}
    }

    local cjson = require(&quot;cjson&quot;)
    body_str = cjson.encode(body)
    return wrk.format('POST', nil, headers, body_str)
end&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;若运行的时候报错找不到cjson, 可以安装 luarocks install lua-cjson&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;wrk-lua脚本说明&quot;&gt;wrk lua脚本说明&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;wrk 压测脚本有3个生命周期, 分别是 启动阶段,运行阶段和结束阶段,每个线程都有自己的lua运行环境&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/1/13/160ef2fd402ad52b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;启动阶段&quot;&gt;启动阶段&lt;/h5&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;function setup(thread)
在脚本文件中实现setup方法，wrk就会在测试线程已经初始化但还没有启动的时候调用该方法。wrk会为每一个测试线程调用一次setup方法，并传入代表测试线程的对象thread作为参数。setup方法中可操作该thread对象，获取信息、存储信息、甚至关闭该线程。
-- thread提供了1个属性，3个方法
-- thread.addr 设置请求需要打到的ip
-- thread:get(name) 获取线程全局变量
-- thread:set(name, value) 设置线程全局变量
-- thread:stop() 终止线程&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;运行阶段&quot;&gt;运行阶段&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;function init(args)
-- 每个线程仅调用1次，args 用于获取命令行中传入的参数, 例如 --env=pre

function delay()
-- 每次请求调用1次，发送下一个请求之前的延迟, 单位为ms

function request()
-- 每次请求调用1次，返回http请求

function response(status, headers, body)
-- 每次请求调用1次，返回 http 响应&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;init由测试线程调用，只会在进入运行阶段时，调用一次。支持从启动wrk的命令中，获取命令行参数； delay在每次发送request之前调用，如果需要delay，那么delay相应时间； request用来生成请求；每一次请求都会调用该方法，所以注意不要在该方法中做耗时的操作； reponse在每次收到一个响应时调用；为提升性能，如果没有定义该方法，那么wrk不会解析headers和body； 结束阶段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;结束阶段&quot;&gt;结束阶段&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;function done(summary, latency, requests)

latency.min              -- minimum value seen
latency.max              -- maximum value seen
latency.mean             -- average value seen
latency.stdev            -- standard deviation
latency:percentile(99.0) -- 99th percentile value
latency(i)               -- raw value and count

summary = {
  duration = N,  -- run duration in microseconds
  requests = N,  -- total completed requests
  bytes    = N,  -- total bytes received
  errors   = {
    connect = N, -- total socket connection errors
    read    = N, -- total socket read errors
    write   = N, -- total socket write errors
    status  = N, -- total HTTP status codes &amp;gt; 399
    timeout = N  -- total request timeouts
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;该方法在整个测试过程中只会调用一次，可从参数给定的对象中，获取压测结果，生成定制化的测试报告。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;线程变量&quot;&gt;线程变量&lt;/h4&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;wrk = {
    scheme  = &quot;http&quot;,
    host    = &quot;localhost&quot;,
    port    = nil,
    method  = &quot;GET&quot;,
    path    = &quot;/&quot;,
    headers = {},
    body    = nil,
    thread  = &amp;lt;userdata&amp;gt;,
}

-- 生成整个request的string，例如：返回
-- GET / HTTP/1.1
-- Host: tool.lu
function wrk.format(method, path, headers, body)
-- method: http方法, 如GET/POST/DELETE 等
-- path:   url的路径, 如 /index, /index?a=b&amp;amp;c=d
-- headers: 一个header的table
-- body:    一个http body, 字符串类型

-- 获取域名的IP和端口，返回table，例如：返回 `{127.0.0.1:80}`
function wrk.lookup(host, service)
-- host:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)
-- service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等

-- 判断addr是否能连接，例如：`127.0.0.1:80`，返回 true 或 false
function wrk.connect(addr)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原文转载自： https://www.ruoxiaozh.com/blog/article/84&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 14 Feb 2019 14:29:00 +0000</pubDate>
<dc:creator>guoew</dc:creator>
<og:description>wrk 是一个很简单的 http 性能测试工具，没有Load Runner那么复杂，他和 apache benchmark（ab）同属于HTTP性能测试工具，但是比 ab 功能更加强大，并且可以支持l</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoew/p/10381115.html</dc:identifier>
</item>
</channel>
</rss>