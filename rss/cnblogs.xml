<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>@程序员，你需要点金融常识 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10934950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10934950.html</guid>
<description>&lt;h3 id=&quot;h01&quot;&gt;01、对金融的偏见&lt;/h3&gt;
&lt;p&gt;常常听见一句俗话：“越靠近钱的地方越能挣钱。”&lt;/p&gt;
&lt;p&gt;很遗憾，以前的我总是对这句充满铜臭味的话视若罔闻——我是一名程序员，所以我的核心工作就是钻进代码的世界里，把代码写得尽可能的完善，少出 bug。&lt;/p&gt;
&lt;p&gt;这种思维的局限性，一直把我封闭在一个很狭隘的世界里。我不肯去了解代码之外的世界，比如说金融。以至于我在开发“大宗期货交易平台”的时候，竟然被一种问题困扰了一个多星期，代码迟迟写不出来。&lt;/p&gt;
&lt;p&gt;当一种商品的行情处于上升势头时，你 100 元买入订单，涨到 110 元的时候卖出平仓，能够挣到 10 元。这种买涨的道理大家都能理解，我也能理解。&lt;/p&gt;
&lt;p&gt;当一种商品的行情处于下跌趋势时，你 100 元卖出订单，跌到 90 元的时候买入平仓，也能挣到 10 元。这种买跌的道理就不太容易理解，我就花了很长的时间才理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上了很多年的学，学校从加减乘除教到微积分，但从来没有讲过金融&lt;/strong&gt;（这也和我上的学校有关）。而我的家人，更没有金融的常识，也就无法熏陶我。&lt;/p&gt;
&lt;p&gt;当然了，更深层次的原因在我，以前的我对金融不感兴趣，不愿意主动去学习，这就导致我成了一个金融盲。&lt;/p&gt;
&lt;p&gt;是时候去改变了！&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;02、货币是什么？&lt;/h3&gt;
&lt;p&gt;学过历史的人都知道，秦始皇采用商鞅制定的度量衡标准器，第一次统一了全国的度量衡，其中就包括货币的统一，这对后世的影响极大。&lt;/p&gt;
&lt;p&gt;那么货币到底是什么呢？&lt;strong&gt;货币是一种关于交换权的契约&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很早很早以前，人们之间交换的方式简单粗暴，一只羊换二十只鸡，一头牛换十只鸡——只想交换一只鸡腿，办不到；只想交换一只羊腿，也办不到；只想交换一只牛腿，仍然办不到。&lt;/p&gt;
&lt;p&gt;但货币的出现，彻底地改变了这种窘境。生活在互联网时代的我们更是幸运的，出门连纸币（法定货币）也不需要带了，带上智能手机（有电的）就能行走天下——未来，虚拟货币很有可能会替代纸币。&lt;/p&gt;
&lt;p&gt;那这个世界上有不存在货币的地方吗？有人会说监狱里面没有。但看过《肖申克的救赎》的都知道，在监狱里面，货币变成了一根香烟，监狱里面的人通过香烟来进行交换——人的智慧真的是无穷啊。&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;03、通货膨胀和通货紧缩&lt;/h3&gt;
&lt;p&gt;两个月前左右，我去超市的时候，突然发现苹果的价格飙升到了十元（以上）一斤，吓得我赶紧检查了一下，发现苹果并没有变大。&lt;/p&gt;
&lt;p&gt;再想想自己的工资好几年没涨了，真的是感觉到了“通货膨胀”的巨大压力——&lt;strong&gt;工资没涨而物价上涨了，其实表明你的购买力下降了，你被降薪了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不仅如此，通货膨胀带来的另外一个显而易见的事实是，存在银行的钱越来越不值钱了。这个很好理解，五年前，你用十块钱至少能买到四斤苹果，现在呢，你用十块钱连一斤苹果也买不到了——关键是苹果并没有变得更大。&lt;/p&gt;
&lt;p&gt;那通货膨胀是怎么发生的呢？原因也很简单，流入市场上的货币变多了。至于货币为什么会增多的深层次原因，我就不得而知了。&lt;/p&gt;
&lt;p&gt;有许多经济学家认为，温和良性的通货膨胀有利于经济的发展。不过，我曾对“历史”书中关于通货膨胀的描述印象深刻，有一段黑暗的国民时期，老百姓提了一袋子的钱去买一块面包。&lt;/p&gt;
&lt;p&gt;聊了一点通货膨胀，再来聊聊通货紧缩。先问一下大家啊，什么情况下会发生通货紧缩呢？&lt;/p&gt;
&lt;p&gt;《薛兆丰的经济学课》里的第一节“战俘营里的经济组织”，曾谈到通过紧缩的概念：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;每当营房的周围发生空袭，炮弹就在营房边上爆炸的时候，人们就变得非常沮丧，觉得差一点就没命了，存那么多香烟干嘛？还是今朝有酒今朝醉吧，他们就抽起了香烟。第二天早上，他们发现原来面包能卖到 3 根香烟的价格，到现在只能卖到 1 根香烟的价格了，发生通货紧缩了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么呢？因为他们抽掉的可不只是香烟，更是货币。换句话说，&lt;strong&gt;通货紧缩的情况下，1 根香烟能买到 1 块面包，而原来 1 根香烟只能买 1/3 块面包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在通货膨胀的情况下，人们应该从银行把钱借出来，用于购置房产，因为房价的上涨带来的收益大于偿还贷款的利息。而在通货紧缩的情况下，人们应该尽快偿还债务，因为债务的压力变大了。&lt;/p&gt;
&lt;p&gt;再给大家提供一个思路。&lt;/p&gt;
&lt;p&gt;近些年来，很多商家喜欢上了众筹，买家把钱提前付给商家，商家收到一定额度的筹款后再去生产或者进货，然后再发给买家。假如商家不滥用这笔钱的话，在通货膨胀的情况下，买家的钱其实是保值的。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;04、银行运作的原理&lt;/h3&gt;
&lt;p&gt;三年前，我曾看过一遍陈道明演的《红顶商人胡雪岩》。当时看不懂，搞不明白钱庄是如何运作的。&lt;/p&gt;
&lt;p&gt;我现在明白了，钱庄的运作原理很简单，简单到只有一句话：“&lt;strong&gt;所有的人不会一次性地取出所有存款&lt;/strong&gt;。”&lt;/p&gt;
&lt;p&gt;人们把钱存进钱庄，钱庄许给这些人一部分利息。然后钱庄再把这些钱借贷出去，收取借贷人更高的利息。&lt;/p&gt;
&lt;p&gt;这是钱庄的运作原理，同样适用于银行。当然了，银行的借贷行为要有一个底线，必须保证一部分额度的钱不被借出去，以备存钱的人能够在需要的时候取到钱。&lt;/p&gt;
&lt;h3 id=&quot;h05&quot;&gt;05、股票与股市&lt;/h3&gt;
&lt;p&gt;股票是股份制公司发行的所有权凭证。公司发行股票的目的是为了筹集资金（这笔钱无须偿还），而股东持有股票或者交易股票是一种投资行为。&lt;/p&gt;
&lt;p&gt;股票最大的特点就是时时刻刻是变化的（涨停和跌停了就没法变了）。而股市是已经发行的股票进行买卖的流通场所。&lt;/p&gt;
&lt;p&gt;与期货交易相似的一点是，当你以较低的价格买入股票而以较高的价格卖出时，你就赚钱了（据说做空也可以赚钱）。当然了，你不能在买入股票后立即出售，那样注定要亏钱，因为要缴纳手续费。&lt;/p&gt;
&lt;p&gt;身边有很多朋友都有过买卖股票的经验，但大多数都是亏钱的，真所谓“&lt;strong&gt;一入股市深似海&lt;/strong&gt;”啊！&lt;/p&gt;
&lt;p&gt;据说程序员在投资股票的时候有着天然的优势，因为我们具有天然的分析复杂数据的能力——画画 K 线图。但这种能力并不能保证我们在股市上稳定收益。&lt;/p&gt;
&lt;p&gt;不过话又说回来，风险大的地方赚钱的收益也会更大。如果你不愿意去了解的话，机会也就溜之大吉了。&lt;/p&gt;
&lt;h3 id=&quot;h06&quot;&gt;06、最后&lt;/h3&gt;
&lt;p&gt;和小区一位大妈聊天，她常夸赞她家女婿。说她女婿会定期买股票，近十年来，只要买就会赚，赚多赚少而已，据说他们家生第一胎的时候直接中了六万。&lt;/p&gt;
&lt;p&gt;买彩票也好，买股票也好，投资不动产也好，不管做什么，挣钱的人有，亏钱的人也有——亏钱的人甚至比挣钱的人多得多。&lt;/p&gt;
&lt;p&gt;但我要陈述的一个观点是：既然大家都说越靠近钱的地方越能挣钱，那我们总不能远离它吧？&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 22:58:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>01、对金融的偏见 常常听见一句俗话：“越靠近钱的地方越能挣钱。” 很遗憾，以前的我总是对这句充满铜臭味的话视若罔闻——我是一名程序员，所以我的核心工作就是钻进代码的世界里，把代码写得尽可能的完善，少</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/10934950.html</dc:identifier>
</item>
<item>
<title>深入V8引擎-Time核心方法之win篇(1) - 书生小龙</title>
<link>http://www.cnblogs.com/QH-Jimmy/p/10919451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QH-Jimmy/p/10919451.html</guid>
<description>&lt;p&gt;　　上一篇的源码看得十分无趣，官方文档跟黑心棉一样渣。&lt;/p&gt;
&lt;p&gt;　　这一篇讲讲windows操作系统上的时间戳实现，由于类的声明，方法解释上一篇都贴过了，所以这次直接上对应版本的代码。&lt;/p&gt;

&lt;p&gt;　　windows与mac很不一样，实现了一个新的Clock类来管理时间，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We implement time using the high-resolution timers so that we can get
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; timeouts which are smaller than 10-15ms. To avoid any drift, we
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; periodically resync the internal clock to the system clock.&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Clock final {
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
  Clock() : initial_ticks_(GetSystemTicks()), initial_time_(GetSystemTime()) {}

  Time Now() { &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }

  Time NowFromSystemTime() { &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }

 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TimeTicks GetSystemTicks() { &lt;span&gt;/*&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }

  &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Time GetSystemTime() { &lt;span&gt;/*&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }

  TimeTicks initial_ticks_;
  Time initial_time_;
  Mutex mutex_;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从注释和方法名可以看出，windows完全用这个新类代替了老的Time、TimeTicks，因为这个方法拥有更好的性能，这个类同时会周期性的与系统时间同步数据。&lt;/p&gt;
&lt;p&gt;　　下面正式开始。&lt;/p&gt;

&lt;p&gt;　　先从Now方法看起，看windows系统是如何获取本地的时间戳。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DEFINE_LAZY_LEAKY_OBJECT_GETTER(Clock, GetClock)

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; DEFINE_LAZY_LEAKY_OBJECT_GETTER(T, FunctionName, ...) \&lt;span&gt;
  T&lt;/span&gt;*&lt;span&gt; FunctionName() {                                         \
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; ::v8::&lt;span&gt;base&lt;/span&gt;::LeakyObject&amp;lt;T&amp;gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;{__VA_ARGS__};    \
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();                                      \
  }

Time Time::Now() { &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; GetClock()-&amp;gt;Now(); }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个方法的定义也不一般，直接用了一个特殊宏，宏就不展开了，简单说就是懒加载，调用的时候会分配空间生成一个Clock类，初始化完后第二次调用就直接返回了，当成一个单例来理解。&lt;/p&gt;
&lt;p&gt;　　直接看宏的返回类型，刚好是上面的Clock，该类只有一个无参构造函数，初始化两个时间戳属性。&lt;/p&gt;
&lt;p&gt;　　先看后那个，也就是系统时间的时间戳。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; Time GetSystemTime() {
    FILETIME ft;
    ::GetSystemTimeAsFileTime(&lt;/span&gt;&amp;amp;&lt;span&gt;ft);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Time::FromFiletime(ft);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的FILETIME和GetSystemTimeAsFileTime都是windowsAPI，可以获取当前系统的日期和时间，但是返回值很奇怪。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _FILETIME {
  DWORD dwLowDateTime;
  DWORD dwHighDateTime;
} FILETIME, &lt;/span&gt;*PFILETIME, *LPFILETIME;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　这是结构体的声明与解释，High、Low分别代表时间的高位与地位，而那个方法就是配合这个使用的。&lt;/p&gt;
&lt;p&gt;　　可以从上面看到，这个API返回的时间竟然是从1601年1月1日开始算的，不知道那一年发生了什么。&lt;/p&gt;
&lt;p&gt;　　下面写一个测试代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{&lt;/span&gt;&lt;span&gt;
    FILETIME ft;
    LARGE_INTEGER t;
    ::GetSystemTimeAsFileTime(&lt;/span&gt;&amp;amp;&lt;span&gt;ft);
    t.LowPart &lt;/span&gt;=&lt;span&gt; ft.dwLowDateTime;
    t.HighPart &lt;/span&gt;=&lt;span&gt; ft.dwHighDateTime;
    cout &lt;/span&gt;&amp;lt;&amp;lt; t.QuadPart &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　得到的输出为132034487665022709，由于单位是100纳秒，所以这个数字乘以100的，然后换算一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858904/201905/858904-20190528004435836-1400891244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由于基准是1601年，而Date是从1970年开始算，所以年份上差了369年，刚好是2019，很合理。&lt;/p&gt;
&lt;p&gt;　　来看看V8的处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Time between windows epoch and standard epoch.&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; int64_t kTimeToEpochInMicroseconds = int64_t{&lt;span&gt;11644473600000000&lt;/span&gt;&lt;span&gt;};

Time Time::FromFiletime(FILETIME ft) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 特殊情况处理&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (ft.dwLowDateTime == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ft.dwHighDateTime == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Time();
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ft.dwLowDateTime == std::numeric_limits&amp;lt;DWORD&amp;gt;::max() &amp;amp;&amp;amp;&lt;span&gt;
      ft.dwHighDateTime &lt;/span&gt;== std::numeric_limits&amp;lt;DWORD&amp;gt;&lt;span&gt;::max()) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Max();
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 换算&lt;/span&gt;
  int64_t us = (static_cast&amp;lt;uint64_t&amp;gt;(ft.dwLowDateTime) +&lt;span&gt;
                (static_cast&lt;/span&gt;&amp;lt;uint64_t&amp;gt;(ft.dwHighDateTime) &amp;lt;&amp;lt; &lt;span&gt;32&lt;/span&gt;)) / &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Time(us -&lt;span&gt; kTimeToEpochInMicroseconds);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　前面的特殊情况看看就行了，主要是换算这一步，就是简单的将高低位的数值拼到了一起，除以10之后，单位从100纳秒变成了微秒。&lt;/p&gt;
&lt;p&gt;　　最后的计算，也是为了平衡标准的时间戳和windows时间戳两者的差异，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858904/201905/858904-20190528005846095-1474978519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为什么不是1970 - 1601 = 369年整呢？因为中间有闰年，很合理。&lt;/p&gt;
&lt;p&gt;　　最后得到微秒单位的标准时间戳，将该数值赋到类的属性上。&lt;/p&gt;

&lt;p&gt;　　回到最初的Now方法，初始化完后，会调用Clock自身的Now方法获取最终的时间戳，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Time Now() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个误差临界值&lt;/span&gt;
  &lt;span&gt;const&lt;/span&gt; TimeDelta kMaxElapsedTime = TimeDelta::FromMinutes(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我目前不想解析所有关于锁的东西&lt;/span&gt;
  MutexGuard lock_guard(&amp;amp;&lt;span&gt;mutex_);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再次获取当前的硬件时间戳与本地时间戳&lt;/span&gt;
  TimeTicks ticks =&lt;span&gt; GetSystemTicks();
  Time time &lt;/span&gt;=&lt;span&gt; GetSystemTime();

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里进行误差修正&lt;/span&gt;
  TimeDelta elapsed = ticks -&lt;span&gt; initial_ticks_;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.当前时间小于初始化时间 可参考上一篇中类方法的注释(the system might adjust its clock...)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.硬件时间戳的时间差超过临界值 这种情况基本可以认定初始化的时间完全不可信了&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (time &amp;lt; initial_time_ || elapsed &amp;gt;&lt;span&gt; kMaxElapsedTime) {
    initial_ticks_ &lt;/span&gt;=&lt;span&gt; ticks;
    initial_time_ &lt;/span&gt;=&lt;span&gt; time;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; time;
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; initial_time_ +&lt;span&gt; elapsed;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然在构造函数中获取了时间戳，但是V8考虑到由于函数调用、系统修正等原因导致的误差(比如第一次初始化)，再次进行了修正，具体操作和原因可以直接看注释，最后返回的时间戳是计算获得的理论本地时间戳加上硬件时间戳差值。&lt;/p&gt;
&lt;p&gt;　　至于NewFromSystemTime就比较简单了，在mac中这两个方法是一个，在windows里如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Time NowFromSystemTime() {
  MutexGuard lock_guard(&lt;/span&gt;&amp;amp;&lt;span&gt;mutex_);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新两个时间戳&lt;/span&gt;
  initial_ticks_ =&lt;span&gt; GetSystemTicks();
  initial_time_ &lt;/span&gt;=&lt;span&gt; GetSystemTime();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接返回最新获得的时间戳&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; initial_time_;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不计算任何东西，直接返回系统API的时间戳，可以配合注释来理解这两个方法。　　&lt;/p&gt;

&lt;p&gt;　　尴尬了，没想到V8在Time阶段把两个时间戳全用上了。稍微看了一下TimeTicks的实现，发现还有点意思，所以这一篇先这样了，太长了写的累。&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 17:28:00 +0000</pubDate>
<dc:creator>书生小龙</dc:creator>
<og:description>上一篇的源码看得十分无趣，官方文档跟黑心棉一样渣。 这一篇讲讲windows操作系统上的时间戳实现，由于类的声明，方法解释上一篇都贴过了，所以这次直接上对应版本的代码。 windows与mac很不一样</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/QH-Jimmy/p/10919451.html</dc:identifier>
</item>
<item>
<title>不一样视角的Glide剖析 - toney.wu</title>
<link>http://www.cnblogs.com/sihaixuan/p/10925585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sihaixuan/p/10925585.html</guid>
<description>&lt;p&gt;&lt;span&gt;Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道，以及自动的资源池技术。&lt;/span&gt;&lt;span&gt;为了让用户拥有良好的App使用体验，图片不仅要快速加载，而且还不能因为过多的主线程I/O或频繁的垃圾回收导致页面的闪烁和抖动现象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本文将依次分析Glide如下问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.Glide图片加载的大致加载流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.Glide图片加载的生命周期的集成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Glide的图片缓存机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.对象池优化，减少内存抖动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.Bitmap的解码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.网络栈的切换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.Glide图片加载的大致加载流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Glide使用简明的流式语法Api，大部分情况下一行代码搞定图片显示，比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Glide.with(activity).load(url).into(imageView)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;就以上述调用简易分析图片加载流程，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190526115136060-446959352.png&quot; alt=&quot;&quot; width=&quot;908&quot; height=&quot;472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                            Glide图片加载流程图&lt;/p&gt;

&lt;p&gt;&lt;span&gt;ResourceDiskCache包含了降低采样、转换的图片资源，DataDiskCache为原始图片资源。RemoteSurce即从远端服务器拉取资源。从ResourceCache、RemoteSource 加载图片都涉及到ModelLoader、 解码与转码,以及多层回调才到显示图片，流程比较复杂，这里就不详述了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.Glide图片加载的生命周期的集成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从Glide.with(host)调用出发，跟踪创建RequestManager的过程，可以推断了解到RequestManager的实例化，最终由RequestManagerRetriever一系列重载函数get()完成，最终根据host不同类型(Application和非ui线程除外)，由supportFragmentGet或fragmentGet方法构建,其实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@NonNull
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RequestManager supportFragmentGet(@NonNull Context context, @NonNull androidx.fragment.app.FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {
     SupportRequestManagerFragment current &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getSupportRequestManagerFragment(fm, parentHint, isParentVisible);
    RequestManager requestManager &lt;/span&gt;=&lt;span&gt; current.getRequestManager();
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (requestManager == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          Glide glide &lt;/span&gt;= Glide.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(context);
          requestManager &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
          current.setRequestManager(requestManager);
     }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; requestManager;
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RequestManager fragmentGet(@NonNull Context context, @NonNull FragmentManager fm, @Nullable android.app.Fragment parentHint, boolean isParentVisible) {
    RequestManagerFragment current &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRequestManagerFragment(fm, parentHint, isParentVisible);
    RequestManager requestManager &lt;/span&gt;=&lt;span&gt; current.getRequestManager();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (requestManager == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Glide glide &lt;/span&gt;= Glide.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(context);
        requestManager &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
        current.setRequestManager(requestManager);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; requestManager;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;都会创建并添加一个可不见的&lt;/span&gt;SupportRequestManagerFragment&lt;span&gt;或者&lt;/span&gt;RequestManagerFragment&lt;span&gt;,而这两个Fragment都有添加LifecycleListener的功能，在其生命周期函数中都会调用listener对应的生命周期函数，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SupportRequestManagerFragment\RequestManagerFragment{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对LifecycleListener 进行了封装&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; final ActivityFragmentLifecycle lifecycle;
  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStart() {
    super.onStart();
    lifecycle.onStart();
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStop() {
    super.onStop();
    lifecycle.onStop();
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy() {
    super.onDestroy();
    lifecycle.onDestroy();
    unregisterFragmentWithRoot();
  }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ActivityFragmentLifecycle implements Lifecycle {
   &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStart() {
    isStarted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStart();
    }
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStop() {
    isStarted &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStop();
    }
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy() {
    isDestroyed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onDestroy();
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;再查看RequestManager的相关代码实现，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RequestManager implements LifecycleListener, ...{
  RequestManager(...,Lifecycle lifecycle,...) {
    ...
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lifecycle =&lt;span&gt; lifecycle;
    ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we're the application level request manager, we may be created on a background thread.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; In that case we cannot risk synchronously pausing or resuming requests, so we hack around the
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This should be entirely safe.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Util.isOnBackgroundThread()) {
      mainHandler.post(addSelfToLifecycle);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      lifecycle.addListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
    lifecycle.addListener(connectivityMonitor);


    ...
  }

@Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStart() {
    resumeRequests();
    targetTracker.onStart();
  }

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Lifecycle callback that unregisters for connectivity events (if the
   * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStop() {
    pauseRequests();
    targetTracker.onStop();
  }

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Lifecycle callback that cancels all in progress requests and clears and recycles resources for
   * all completed requests.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy() {
    ...
    requestTracker.clearRequests();
    lifecycle.removeListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    lifecycle.removeListener(connectivityMonitor);
    ..
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;RequestManager实现了LifecycleListener接口，并在构造器中给lifecycle添加listener,而这里lifecycle正好对应了RequestManagerFragment中的lifecycle，就这样RequestManager可以只能感知RequestManagerFragment的生命周期，也就感知其中host Activity或者Fragment的生命周期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RequestManager管理所有的其对应host中所有的请求,requestTracker对跟踪Request的封装，具有暂停、重启、清空请求的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此就可以知道Glide图片加载可以智能感知Activity、Fragment的生命周期函数进行重启，暂停，清除。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.Glide的图片缓存机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Glide图片加载流程图中，可以知道真正开始加载图片的地方从Engine.load()，大致代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; synchronized &amp;lt;R&amp;gt;&lt;span&gt; LoadStatus load(...) {

    EngineKey key &lt;/span&gt;=&lt;span&gt; keyFactory.buildKey(model, signature, width, height, transformations,
        resourceClass, transcodeClass, options);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;活动资源&lt;/span&gt;
    EngineResource&amp;lt;?&amp;gt; active =&lt;span&gt; loadFromActiveResources(key, isMemoryCacheable);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (active != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;内存缓存&lt;/span&gt;
    EngineResource&amp;lt;?&amp;gt; cached =&lt;span&gt; loadFromCache(key, isMemoryCacheable);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cached != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    EngineJob&lt;/span&gt;&amp;lt;?&amp;gt; current = jobs.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(key, onlyRetrieveFromCache);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      current.addCallback(cb, callbackExecutor);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadStatus(cb, current);
    }

    EngineJob&lt;/span&gt;&amp;lt;R&amp;gt; engineJob =&lt;span&gt; engineJobFactory.build(...);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解码工作任务 由线程池调度启动，ResourceDiskcache DataDiskCached都这里加载编码&lt;/span&gt;
    DecodeJob&amp;lt;R&amp;gt; decodeJob =&lt;span&gt; decodeJobFactory.build(...);

    jobs.put(key, engineJob);

    engineJob.addCallback(cb, callbackExecutor);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始DecodeJob，由线程池调度启动&lt;/span&gt;
&lt;span&gt;    engineJob.start(decodeJob);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadStatus(cb, engineJob);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;DecodeJob decode state有如下几种：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Where we're trying to decode data from.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DecodeJob内部枚举类&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Stage {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* The initial stage. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    INITIALIZE,
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* Decode from a cached resource. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    RESOURCE_CACHE,
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* Decode from cached source data. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    DATA_CACHE,
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* Decode from retrieved source. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    SOURCE,
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* Encoding transformed resources after a successful load. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ENCODE,
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* No more viable stages. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    FINISHED,
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;State.ENCODE代表成功从Source中加载数据后，把transformed的资源保存到DiskCache。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由此可以看出Glide分为四级缓存：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;活动资源 (ActiveResources)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;内存缓存 (MemoryCache)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;资源类型（Resource DiskCache）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;原始数据 (Data DiskCache)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;活动资源：&lt;/span&gt;&lt;span&gt;如果当前对应的图片资源正在使用，则这个图片会被Glide放入活动缓存。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存缓存：&lt;/span&gt;&lt;span&gt;如果图片最近被加载过，并且当前没有使用这个图片，则会被放入内存中 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;资源类型: &lt;/span&gt;&lt;span&gt;被解码后的图片写入磁盘文件中，解码的过程可能修改了图片的参数(如: inSampleSize、inPreferredConfig)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原始数据: &lt;/span&gt;&lt;span&gt;图片原始数据在磁盘中的缓存(从网络、文件中直接获得的原始数据)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Glide加载图片依次从四级缓存中获取图片资源的时序图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190526154111168-1323728419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;活动资源ActiveResources&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ActiveResources维护着弱引用EngineResource map集合,当有垃圾回收时，弱引用关联的EngineResource 会被存放到ReferenceQueue中，ActiveResources在实例化时开启线程监控清理被回收的EngineResource 该EngineResource 又会转移到MemoryCache中去，具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
final &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ActiveResources {
 ... 

  final Map&lt;/span&gt;&amp;lt;Key, ResourceWeakReference&amp;gt; activeEngineResources = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final ReferenceQueue&amp;lt;EngineResource&amp;lt;?&amp;gt;&amp;gt; resourceReferenceQueue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue&amp;lt;&amp;gt;&lt;span&gt;();

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ResourceListener listener;

  ...

  ActiveResources(
      boolean isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.isActiveResourceRetentionAllowed =&lt;span&gt; isActiveResourceRetentionAllowed;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.monitorClearedResourcesExecutor =&lt;span&gt; monitorClearedResourcesExecutor;

    monitorClearedResourcesExecutor.execute(
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
          @Override
          &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            cleanReferenceQueue();
          }
    });
  }
} 

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; cleanupActiveReference(@NonNull ResourceWeakReference &lt;span&gt;ref&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fixes a deadlock where we normally acquire the Engine lock and then the ActiveResources lock
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; but reverse that order in this one particular test. This is definitely a bit of a hack...&lt;/span&gt;
&lt;span&gt;    synchronized (listener) {
      synchronized (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
        activeEngineResources.remove(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;.key);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ref&lt;/span&gt;.isCacheable || &lt;span&gt;ref&lt;/span&gt;.resource == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        EngineResource&lt;/span&gt;&amp;lt;?&amp;gt; newResource =
            &lt;span&gt;new&lt;/span&gt; EngineResource&amp;lt;&amp;gt;(&lt;span&gt;ref&lt;/span&gt;.resource, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;isCacheable=&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;isRecyclable=&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        newResource.setResourceListener(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;.key, listener);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Engine实现了ResourceListener接口，最终会调用Resource.recycle()方法&lt;/span&gt;
        listener.onResourceReleased(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;.key, newResource);
      }
    }
 }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Engine类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt; onResourceReleased(Key cacheKey, EngineResource&amp;lt;?&amp;gt;&lt;span&gt; resource) {
    activeResources.deactivate(cacheKey);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resource.isCacheable()) {
      cache.put(cacheKey, resource);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      resourceRecycler.recycle(resource);
    }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;EngineResource是对Resource一种包装，新增了引用计数功能，每当一个地方获取该资源时，引用计数acquired就会加1，当EngineResource被release时引用计数acquired减1，当acquired==0也会回调EngineResource从ActiveResources回收到MemeryCache中去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;那引用计数在哪些情况下加1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;情况一、 资源在ActiveResources中命中，acquired++，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; EngineResource&amp;lt;?&amp;gt;&lt;span&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isMemoryCacheable) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    EngineResource&lt;/span&gt;&amp;lt;?&amp;gt; active = activeResources.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (active != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      active.acquire();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;acquire++&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; active;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;情况二、资源在MemoryCache中命中，资源从MemoryCach转移到ActiveResources，acquired++，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; EngineResource&amp;lt;?&amp;gt;&lt;span&gt; loadFromCache(Key key, boolean isMemoryCacheable) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isMemoryCacheable) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
     EngineResource&lt;/span&gt;&amp;lt;?&amp;gt; cached =&lt;span&gt; getEngineResourceFromCache(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cached != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      cached.acquire();
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cached 转移到activeResources&lt;/span&gt;
&lt;span&gt;      activeResources.activate(key, cached);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cached;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;情况三、 资源从DiskCache、RemoteSource加载也会acquired++，拉取的资源也会加入到ActiveResources。通过DecodeJob加载的资源，最终都会回调DecodeJob的decodeFromRetrievedData()方法,最终辗转到EngineJob的notifyCallbacksOfResult()方法，其代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; notifyCallbacksOfResult() {
 
     ...
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;listener 为Engine,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;EngineonEngineJobComplete方法中调用了activeResources.activate()&lt;/span&gt;
    listener.onEngineJobComplete(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, localKey, localResource);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CallResourceReady.run方法调用&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (final ResourceCallbackAndExecutor entry : copy) {
      entry.executor.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CallResourceReady(entry.cb));
    }
    decrementPendingCallbacks();
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Engine&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onEngineJobComplete(
      EngineJob&lt;/span&gt;&amp;lt;?&amp;gt; engineJob, Key key, EngineResource&amp;lt;?&amp;gt;&lt;span&gt; resource) {

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (resource != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      resource.setResourceListener(key, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resource.isCacheable()) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把加载的资源加入到activeResources中去&lt;/span&gt;
&lt;span&gt;        activeResources.activate(key, resource);
      }
    }

    jobs.removeIfCurrent(key, engineJob);
  }


&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CallResourceReady implements Runnable {
    ... 

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
      synchronized (EngineJob.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cbs.contains(cb)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Acquire for this particular callback.&lt;/span&gt;
          engineResource.acquire(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;acquire++&lt;/span&gt;
&lt;span&gt;          callCallbackOnResourceReady(cb);
          removeCallback(cb);
        }
        decrementPendingCallbacks();
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;引用计数减一情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在Glide图片加载的生命周期的集成部分，已分析RequestManeger能感知Activity,Fragment生命周期函数，由RequetTracker跟踪Request,具有暂停、重启，清除Request的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RequestManeger生命回调函数onStop、onDestory代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStop() {
    pauseRequests();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;暂停所有请求&lt;/span&gt;
&lt;span&gt;    targetTracker.onStop();
  }

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Lifecycle callback that cancels all in progress requests and clears and recycles resources for
   * all completed requests.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy() {
    targetTracker.onDestroy();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Target&amp;lt;?&amp;gt;&lt;span&gt; target : targetTracker.getAll()) {
      clear(target);
    }
    targetTracker.clear();
    requestTracker.clearRequests();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除所有请求&lt;/span&gt;
    lifecycle.removeListener(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    lifecycle.removeListener(connectivityMonitor);
    mainHandler.removeCallbacks(addSelfToLifecycle);
    glide.unregisterRequestManager(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;requestTracker的clearRequests()和pauseRequests()方法都调用了request.clear()方法,而真正的请求实例为SingleRequest,其clear方法代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
    ...
    cancel();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Resource must be released before canNotifyStatusChanged is called.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (resource != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      releaseResource(resource);
    }
    ...
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; releaseResource(Resource&amp;lt;?&amp;gt;&lt;span&gt; resource) {
    engine.release(resource);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;EngineResoure.release&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.resource = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;调用了EngineResoure.release()方法,代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; release() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; To avoid deadlock, always acquire the listener lock before our lock so that the locking
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; scheme is consistent (Engine -&amp;gt; EngineResource). Violating this order leads to deadlock
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (b/123646037).&lt;/span&gt;
&lt;span&gt;    synchronized (listener) {
      synchronized (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (acquired &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot release a recycled or not yet acquired resource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (--acquired == &lt;span&gt;0&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减一操作
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Engine.onResourceReleased&lt;/span&gt;
          listener.onResourceReleased(key, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;当acquired == 0时会回调Engine. onResourceReleased方法，把资源从activeResources中移除，加入带MemoryCache中去，其代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt; onResourceReleased(Key cacheKey, EngineResource&amp;lt;?&amp;gt;&lt;span&gt; resource) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从activeResources 移除该资源&lt;/span&gt;
&lt;span&gt;    activeResources.deactivate(cacheKey);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resource.isCacheable()) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放入MemoryCache中&lt;/span&gt;
&lt;span&gt;      cache.put(cacheKey, resource);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      resourceRecycler.recycle(resource);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;内存缓存MemoryCache&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Glide中MemoryCache默认情况下，为LruResourceCache，继承了LruCache，使用了最近最少算法管理内存资源，同时对外提供了trimMemory ，clearMemory接口，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * An LRU in memory cache for {@link com.bumptech.glide.load.engine.Resource}s.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LruResourceCache extends LruCache&amp;lt;Key, Resource&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; implements MemoryCache {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ResourceRemovedListener listener;

  ...

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listener =&lt;span&gt; listener;
  }

  @Override
  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onItemEvicted(@NonNull Key key, @Nullable Resource&amp;lt;?&amp;gt;&lt;span&gt; item) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (listener != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; item != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      listener.onResourceRemoved(item);
    }
  }

  @Override
  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getSize(@Nullable Resource&amp;lt;?&amp;gt;&lt;span&gt; item) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super.getSize(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item.getSize();
    }
  }

  @SuppressLint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InlinedApi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; trimMemory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; level) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (level &amp;gt;=&lt;span&gt; android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Entering list of cached background apps
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Evict our entire bitmap cache&lt;/span&gt;
&lt;span&gt;      clearMemory();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (level &amp;gt;=&lt;span&gt; android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
        &lt;/span&gt;|| level ==&lt;span&gt; android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The app's UI is no longer visible, or app is in the foreground but system is running
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; critically low on memory
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Evict oldest half of our bitmap cache&lt;/span&gt;
      trimToSize(getMaxSize() / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;MemoryCache对外提供了资源删除监听接口，通过搜索可以知道Engine实现了ResourceRemovedListener接口，并设置给MemoryCache，Engine资源删除回调函数Engine.onResourceRemoved相关代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onResourceRemoved(@NonNull final Resource&amp;lt;?&amp;gt;&lt;span&gt; resource) {
    resourceRecycler.recycle(resource);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ResourceRecycler&lt;/span&gt;
synchronized &lt;span&gt;void&lt;/span&gt; recycle(Resource&amp;lt;?&amp;gt;&lt;span&gt; resource) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRecycling) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If a resource has sub-resources, releasing a sub resource can cause it's parent to be
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; synchronously evicted which leads to a recycle loop when the parent releases it's children.
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Posting breaks this loop.&lt;/span&gt;
&lt;span&gt;      handler.obtainMessage(ResourceRecyclerCallback.RECYCLE_RESOURCE, resource).sendToTarget();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      isRecycling &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      resource.recycle();
      isRecycling &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;onResourceRemoved回调函数对资源进行Recycle,MemoryCache的Resource实际上为EngineResource，最终对被包裹的资源进行Recycle,而Resource的实现类有如下图这些：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190526230122740-1847841560.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对跟Bitmap有关的BitmapResource，BitmapDrawableResource进行分析，其recycle方法实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;BitmapResource&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; recycle() {
    bitmapPool.put(bitmap);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;BitmapDrawableResource&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; recycle() {
    bitmapPool.put(drawable.getBitmap());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;把从MemoryCache删除资源关联的bitmap回收到BitmapPool中，注意这里删除是指资源被MemoryCache被逐出，触发onItemEvicted回调了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么有些地方会触发了onItemEvicted动作了？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;情况一、MemoryCache进行put操作时，old的资源被新的资源覆盖时，oldResource被逐出，和size超过了maxSize，会逐出最近最少使用的资源，都会触发onItemEvicted，最终资源关联的Bitmap回收到BitmapPool中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;情况二、Glide对面提供了trimMemory，clearMemory接口(通常会在Activity.trimMemory方法中调用)，对最终MemoryCache资源进行清理，触发onItemEvicted回调，资源关联的Bitmap回收到BitmapPool中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里讲到MemoryCache资源被Evicted的情况，其他情况还没讲到，其实前文已经提到了，资源在MemoryCache中命中了，被remove,且转移到ActiveResources中；在资源请求被暂停、取消、删除以及ActiveResources自身资源清除监控线程进行清除时，也会是相关的资源从ActiveResources转移到MemoryCache。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.对象池优化，减少内存抖动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Glide大量使用对象池Pools来对频繁需要创建和销毁的代码进行优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下就是使用对象池的情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.每次图片加载都会涉及到Request对象,可能涉及到EncodeJob,DecodeJob对象，在加载大量图片的加载情况下，这会频繁创建和销毁对象，造成内存抖动，至此使用FactoryPools（android support包 Pool）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.对MemoryCache的资源回收，使用BitmapPool池对资源关联的Bitmap回收；解码图片生成Bitmap（大对象）时，复用了BitmapPool池中的Bitmap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;解码图片生成Bitmap时，配置了inTempStorage，使用了ArrayPool技术复用了byte[]（64kb）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;FactoryPools&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FactoryPools是基于android support包中的对象池存取的辅助类Pools，先看Pools源码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Pools {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Interface for managing a pool of objects.
     *
     * @param &amp;lt;T&amp;gt; The pooled type.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Pool&amp;lt;T&amp;gt;&lt;span&gt; {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * @return An instance from the pool if such, null otherwise.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T acquire();

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * Release an instance to the pool.
         *
         * @param instance The instance to release.
         * @return Whether the instance was put in the pool.
         *
         * @throws IllegalStateException If the instance is already in the pool.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean release(T instance);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Pools() {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; do nothing - hiding constructor &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Simple (non-synchronized) pool of objects.
     *
     * @param &amp;lt;T&amp;gt; The pooled type.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SimplePool&amp;lt;T&amp;gt; implements Pool&amp;lt;T&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; final Object[] mPool;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mPoolSize;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * Creates a new instance.
         *
         * @param maxPoolSize The max pool size.
         *
         * @throws IllegalArgumentException If the max pool size is less than zero.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; SimplePool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxPoolSize) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (maxPoolSize &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The max pool size must be &amp;gt; 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            mPool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[maxPoolSize];
        }

        @Override
        @SuppressWarnings(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unchecked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T acquire() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mPoolSize &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                final &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lastPooledIndex = mPoolSize - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                T instance &lt;/span&gt;=&lt;span&gt; (T) mPool[lastPooledIndex];
                mPool[lastPooledIndex] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                mPoolSize&lt;/span&gt;--&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean release(T instance) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isInPool(instance)) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Already in the pool!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mPoolSize &amp;lt;&lt;span&gt; mPool.length) {
                mPool[mPoolSize] &lt;/span&gt;=&lt;span&gt; instance;
                mPoolSize&lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; boolean isInPool(T instance) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; mPoolSize; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mPool[i] ==&lt;span&gt; instance) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Synchronized) pool of objects.
     *
     * @param &amp;lt;T&amp;gt; The pooled type.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SynchronizedPool&amp;lt;T&amp;gt; extends SimplePool&amp;lt;T&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final Object mLock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * Creates a new instance.
         *
         * @param maxPoolSize The max pool size.
         *
         * @throws IllegalArgumentException If the max pool size is less than zero.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; SynchronizedPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxPoolSize) {
            super(maxPoolSize);
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T acquire() {
            synchronized (mLock) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; super.acquire();
            }
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean release(T element) {
            synchronized (mLock) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; super.release(element);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190526232015136-32334820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义了Pool池接口类，包含两个方法acquire（从池中取出对象），release（回收对象，存入对象池），提供了两个实现简单实现类SimplePool，SynchronizedPool，SimplePool用数组维护这个对象池，有个缺点就是不能动态扩容，SynchronizedPool对SimplePool进行了同步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FactoryPools类中定义了FactoryPool类，FactoryPool使用装饰者模式，对Pool扩展了对象工厂创建、回收对象重置功能；提供了一些创建Pool的静态方法。&lt;/span&gt;&lt;span&gt;源码搜索FactoryPools，就看到哪些地方用FactoryPools了，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190526232252183-1509647235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里就不详细陈述EncodeJob、DecodeJob、SingRequest，是在什么时机，被回收到FactoryPool中了，基本上都在其release方法中进行回收操作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BitmapPool&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;Bitmap的创建是申请内存昂贵的，大则占用十几M,使用进行BitmapPool回收复用，可以显著减少内存消耗和抖动。BitmapPool定义了如下接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BitmapPool {

  &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; getMaxSize();

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; setSizeMultiplier(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; sizeMultiplier);

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; put(Bitmap bitmap);

  Bitmap &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height, Bitmap.Config config);

  Bitmap getDirty(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height, Bitmap.Config config);

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; clearMemory();

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; trimMemory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; level);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Glide的默认BitmapPool实现为LruBitmapPool，从GlideBuild.build方法可以看出，LruBitmapPool把Bitmap缓存的维护委托给LruPoolStrategy，大致代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LruBitmapPool implements BitmapPool {
  ...
  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; put(Bitmap bitmap) {

    ... 

    final &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; strategy.getSize(bitmap);
    strategy.put(bitmap);
    tracker.add(bitmap);

    puts&lt;/span&gt;++&lt;span&gt;;
    currentSize &lt;/span&gt;+=&lt;span&gt; size;
    ...
    evict();
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; evict() {
    trimToSize(maxSize);
  }


  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Bitmap &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height, Bitmap.Config config) {
    Bitmap result &lt;/span&gt;=&lt;span&gt; getDirtyOrNull(width, height, config);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      result.eraseColor(Color.TRANSPARENT);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      result &lt;/span&gt;=&lt;span&gt; createBitmap(width, height, config);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Bitmap getDirty(&lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height, Bitmap.Config config) {
    Bitmap result &lt;/span&gt;=&lt;span&gt; getDirtyOrNull(width, height, config);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      result &lt;/span&gt;=&lt;span&gt; createBitmap(width, height, config);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; synchronized Bitmap getDirtyOrNull(
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height, @Nullable Bitmap.Config config) {
    assertNotHardwareConfig(config);

    final Bitmap result &lt;/span&gt;= strategy.&lt;span&gt;get&lt;/span&gt;(width, height, config != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;  config : DEFAULT_CONFIG);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      misses&lt;/span&gt;++&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      hits&lt;/span&gt;++&lt;span&gt;;
      currentSize &lt;/span&gt;-=&lt;span&gt; strategy.getSize(result);
      tracker.remove(result);
      normalize(result);
    }

    dump();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
 }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clearMemory() {
    ...
    trimToSize(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
  }


  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; trimMemory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; level) {

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (level &amp;gt;=&lt;span&gt; android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
      clearMemory();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (level &amp;gt;=&lt;span&gt; android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
        &lt;/span&gt;|| level ==&lt;span&gt; android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
      trimToSize(getMaxSize() &lt;/span&gt;/ &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    }
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt; trimToSize(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; size) {
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (currentSize &amp;gt;&lt;span&gt; size) {
      final Bitmap removed &lt;/span&gt;=&lt;span&gt; strategy.removeLast();
      ...
      currentSize &lt;/span&gt;-=&lt;span&gt; strategy.getSize(removed);
      evictions&lt;/span&gt;++&lt;span&gt;;
      ...     
      removed.recycle();
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Bitmap缓存策略接口默认实现有AttributeStrategy和SizeConfigStrategy，前者在Api&amp;lt;19情况下使用，两者实现功能相同，只不过前者是严格要个图片的width、height、Bitmap.Config完全匹配,才算命中缓存，后者不严格要求图片的大小size和Config完全匹配，获取到的缓存Bitmap的size，可能会大于要求图片的size，再通过Bitmap.reconfigure()重新配置成符合要求的图片，其具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; Bitmap &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height, Bitmap.Config config) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; Util.getBitmapByteSize(width, height, config);
    Key bestKey &lt;/span&gt;=&lt;span&gt; findBestKey(size, config);

    Bitmap result &lt;/span&gt;= groupedMap.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(bestKey);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decrement must be called before reconfigure.&lt;/span&gt;
&lt;span&gt;      decrementBitmapOfSize(bestKey.size, result);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新配置成符合要求的图片&lt;/span&gt;
&lt;span&gt;      result.reconfigure(width, height, config);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Key findBestKey(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size, Bitmap.Config config) {
    Key result &lt;/span&gt;= keyPool.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(size, config);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Bitmap.Config possibleConfig : getInConfigs(config)) {
      NavigableMap&lt;/span&gt;&amp;lt;Integer, Integer&amp;gt; sizesForPossibleConfig =&lt;span&gt; getSizesForConfig(possibleConfig);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取&amp;gt;= size的最小值&lt;/span&gt;
      Integer possibleSize =&lt;span&gt; sizesForPossibleConfig.ceilingKey(size);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (possibleSize != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; possibleSize &amp;lt;= size *&lt;span&gt; MAX_SIZE_MULTIPLE) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (possibleSize !=&lt;span&gt; size
            &lt;/span&gt;|| (possibleConfig == &lt;span&gt;null&lt;/span&gt; ? config != &lt;span&gt;null&lt;/span&gt; : !&lt;span&gt;possibleConfig.equals(config))) {
          keyPool.offer(result);
          result &lt;/span&gt;= keyPool.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(possibleSize, possibleConfig);
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这两个缓存策略类都是使用GroupedLinkedMap来维护Bitmap缓存，&lt;/span&gt;&lt;span&gt;GroupedLinkedMap内部使用了一个名为head的双向链表，链表的key是由bitmap size和config构成的Key，value是一个由bitmap构成的list。这样GroupedLinkedMap中的每个元素就相当于是一个组，这个组中的bitmap具有相同的size和config,同时，为了加快查找速度，添加了keyToEntry的Hashmap，将key和链表中的LinkedEntry对应起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GroupedLinkedMap进行get操作时，会把该组移动链头，返回并移除该组的最后一个元素；put操作会把该组移动链尾，添加到该组尾部;进行trimToSize操作,优先删除链尾的对应组的最后一个元素，当该组没有元素时，删除该组。这里与访问排序的LinkedHashMap有区别了，get和put操作都是把节点移至到链尾，LruCache trimToSize操作时优先删除链头。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ArrayPool&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ArrayPool用于存储不同类型数组的数组池的接口，默认实现LruArrayPool只支持int[],byte[]池化，内部也是使用GroupedLinkedMap维护着，由size和class构成key,获取数组资源时，跟SizeConfigStrategy类似，获取到Array的size，可能会大于要求的size。在图片Bimtap解码的时候有使用到ArrayPool。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、Bitmap的解码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先介绍下加载本地资源和远程资源的流程(从DecodeJob中算起)大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190528002625784-390025795.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常情况下，远程图片通过ModelLoaders拉取图片，返回inoutStream/ByteBuffer等，供后续对应的ResourceDecoder解码器、transformations、ResourceTranscoders转码器、ResourceEncoder编码器处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.Bitmap的解码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图片加载不管源自网络、本地文件都会通过ResourceDecoder编码器对inputStream、ByteBuffer等进行下采样、解码工作，由Downsampler辅助ResourceDecoder完成，Downsampler相关的decode方法如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Resource&amp;lt;Bitmap&amp;gt;&lt;span&gt; decode(..) throws IOException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从ArrayPool获取byte[]资源，设置给inTempStorage&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt;[] bytesForOptions = byteArrayPool.&lt;span&gt;get&lt;/span&gt;(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, &lt;span&gt;byte&lt;/span&gt;[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    BitmapFactory.Options bitmapFactoryOptions &lt;/span&gt;=&lt;span&gt; getDefaultOptions();
    bitmapFactoryOptions.inTempStorage &lt;/span&gt;=&lt;span&gt; bytesForOptions;

    ...

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      Bitmap result &lt;/span&gt;= decodeFromWrappedStreams(&lt;span&gt;is&lt;/span&gt;&lt;span&gt;, bitmapFactoryOptions,
          downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,
          requestedHeight, fixBitmapToRequestedDimensions, callbacks);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BitmapResource.obtain(result, bitmapPool);
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
      releaseOptions(bitmapFactoryOptions);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte[]资源回收到ArrayPool&lt;/span&gt;
&lt;span&gt;      byteArrayPool.put(bytesForOptions);
    }
  }

 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Bitmap decodeFromWrappedStreams(...) throws IOException {
     ...
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取原图片的宽高&lt;/span&gt;
     &lt;span&gt;int&lt;/span&gt;[] sourceDimensions = getDimensions(&lt;span&gt;is&lt;/span&gt;&lt;span&gt;, options, callbacks, bitmapPool);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算BitmapFactory.Options 缩放相关参数 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比如 inSampleSize、inScaled、inDensity、inTargetDensity&lt;/span&gt;
&lt;span&gt;    calculateScaling(...);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置inPreferredConfig、inDither&lt;/span&gt;
&lt;span&gt;    calculateConfig(...);

    boolean isKitKatOrGreater &lt;/span&gt;= Build.VERSION.SDK_INT &amp;gt;=&lt;span&gt; Build.VERSION_CODES.KITKAT;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((options.inSampleSize == &lt;span&gt;1&lt;/span&gt; || isKitKatOrGreater) &amp;amp;&amp;amp;&lt;span&gt; shouldUsePool(imageType)) {

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (expectedWidth &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; expectedHeight &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从bitmapPool获取bitmap资源，设置options.inBitmap
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.inBitmap = bitmapPool.getDirty(width, height, expectedConfig)&lt;/span&gt;
&lt;span&gt;        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);
      }
    }
    Bitmap downsampled &lt;/span&gt;= decodeStream(&lt;span&gt;is&lt;/span&gt;&lt;span&gt;, options, callbacks, bitmapPool);
    callbacks.onDecodeComplete(bitmapPool, downsampled);

   ...

    Bitmap rotated &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (downsampled != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we scaled, the Bitmap density will be our inTargetDensity. Here we correct it back to
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the expected density dpi. 对bitmap 设置Density&lt;/span&gt;
&lt;span&gt;      downsampled.setDensity(displayMetrics.densityDpi);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对图片进行旋转&lt;/span&gt;
      rotated =&lt;span&gt; TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;downsampled.equals(rotated)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rotated后的Bitmap不是原Bitmap，回收原Bitmap&lt;/span&gt;
&lt;span&gt;        bitmapPool.put(downsampled);
      }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotated;
  }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Bitmap decodeStream(...) throws IOException {
    ...
    final Bitmap result;
    TransformationUtils.getBitmapDrawableLock().&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      result &lt;/span&gt;= BitmapFactory.decodeStream(&lt;span&gt;is&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, options);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
      IOException bitmapAssertionException &lt;/span&gt;=&lt;span&gt;
          newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重用已经存在的Bitmap，失败，在尝试不重用已经存在的bitmap，
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;且把该bitmap回收到bitmapPool&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (options.inBitmap != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.reset();
          bitmapPool.put(options.inBitmap);
          options.inBitmap &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decodeStream(&lt;span&gt;is&lt;/span&gt;&lt;span&gt;, options, callbacks, bitmapPool);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException resetException) {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; bitmapAssertionException;
        }
      }
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; bitmapAssertionException;
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
      TransformationUtils.getBitmapDrawableLock().unlock();
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (options.inJustDecodeBounds) {
      &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.reset();

    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;对inputStream(ByteBuffer等也雷同)的decode过程分析如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.给BitmapFactory.Options选项设置了inTempStorage&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;inTempStorage为Bitmap解码过程中需要缓存空间，就算我们没有配置这个，系统也会给我们配置，相关代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Bitmap decodeStreamInternal(@NonNull InputStream &lt;span&gt;is&lt;/span&gt;&lt;span&gt;,
            @Nullable Rect outPadding, @Nullable Options opts) {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ASSERT(is != null);&lt;/span&gt;
        &lt;span&gt;byte&lt;/span&gt; [] tempStorage = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (opts != &lt;span&gt;null&lt;/span&gt;) tempStorage =&lt;span&gt; opts.inTempStorage;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tempStorage == &lt;span&gt;null&lt;/span&gt;) tempStorage = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[DECODE_BUFFER_SIZE];
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nativeDecodeStream(&lt;span&gt;is&lt;/span&gt;&lt;span&gt;, tempStorage, outPadding, opts);&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;不过，这里每次decode过程,就会申请和释放DECODE_BUFFER_SIZE的内存空间，多次docode可能会造成频繁gc和内存抖动；而Glide却从ArrayPool获取，设置给inTempStorage，decode完成后，又会回收到ArrayPool中，可以减少内存抖动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.获取图片原始宽高&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取图片资源的原始宽高，设置参数inJustDecodeBounds为True即可，没什么特别的，然后对inputStream进行reset，以便后续的真正的decode动作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.计算缩放因子，配置Options的inSampleSize、inScaled、inDensity、inTargetDensity&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.配置Options的inPreferredConfig、inDither，首先判断是否允许设置硬件位图，允许则inPreferredConfig设置为HARDWARE，inMutable为false,否则再解析流中的ImageHeader数据，假如有透明通道，inPreferredConfig设置为ARGB_8888，没有则为RGB_565,同时inDither置为True。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意HARDWARE的bitmap不能被回收到BitmapPool，具体查看LruBitmapPool的put方法；其相应的像素数据只存在于显存中，并对图片仅在屏幕上绘制的场景做了优化，具体详述查看Glide官方文档-硬件位图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.设置inBitmap,如果为硬件位图配置，则不设置inBitmap。其他情况，从BitmapPool获取Bitmap，设置给inBitmap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.配置完Options后，就真正调用BitmapFactory的decode方法，解码失败再尝试一次取消inBitmap进行解码，并对inBitmap回收BitmapPool。然后setDensity（绘制时缩放，decodedBtimap本身占用内存没有变化）,decodedBtimap最后根据exifOrientation，旋转位图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、网络栈的切换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Glide最终使用的网络加载ModelLoader为HttpGlideUrlLoader,其对应的DataFetcher为HttpUrlFetcher，使用HttpURLConnection进行网络请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Glide可以自由定制加载器ModelLoader，资源解码器ResourceDecoder，资源编码器ResourceEncoder，这里想进行底层网络库切换，定制ModelLoader即可，教材可以参考Glide文档，官方提供了OkHttp和Volley 集成库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定制的加载器，解码器，编码器自动注入到Glide的原理如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.定制LibraryGlideModule类，通过其 registerComponents()方法的形参Registry登记所有定制的加载器ModelLoader，资源解码器Decoder，资源编码器Encoder，给定制的LibraryGlideModule类添加@GlideModule注解，编译期间自动在AndroidManifest.xml文件中添加该LibraryGlideModule相关的元数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.在Glide初始化时，会从功能配置文件AndroidManifest.xml中获取相关GlideModule元数据，并通过反射实例化所有的GlideModule，再迭代所有定制的GlideModule调用registerComponents方法，这样那些定制的加载器ModelLoader，解码器Decoder，编码器Encoder就自动注入到Glide了。关键源码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
    Context applicationContext &lt;/span&gt;=&lt;span&gt; context.getApplicationContext();
    GeneratedAppGlideModule annotationGeneratedModule &lt;/span&gt;=&lt;span&gt; getAnnotationGeneratedGlideModules();
    List&lt;/span&gt;&amp;lt;com.bumptech.glide.module.GlideModule&amp;gt; manifestModules =&lt;span&gt; Collections.emptyList();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (annotationGeneratedModule == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; annotationGeneratedModule.isManifestParsingEnabled()) {
      manifestModules &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ManifestParser(applicationContext).parse();
    }

   ...

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (com.bumptech.glide.module.GlideModule module : manifestModules) {
      module.applyOptions(applicationContext, builder);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (annotationGeneratedModule != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      annotationGeneratedModule.applyOptions(applicationContext, builder);
    }
    Glide glide &lt;/span&gt;=&lt;span&gt; builder.build(applicationContext);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (com.bumptech.glide.module.GlideModule module : manifestModules) {
      module.registerComponents(applicationContext, glide, glide.registry);
    }

    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;至此，6个问题都解析完毕，相信能对Glide有更深刻的整体认识。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://muyangmin.github.io/glide-docs-cn/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt; Glide v4 快速高效的Android图片加载库(官方)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sihaixuan/p/Glide高级详解—缓存与解码复用&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Glide高级详解—缓存与解码复用&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/e4b17cef6370&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;[Glide4源码解析系列] — 3.Glide数据解码与转码&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010911576/article/details/42774603&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;android.support.v4.util.Pools源码解析&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c3b00f16fb9a049ab0dd8c6&quot; target=&quot;_blank&quot;&gt; Glide4.8源码拆解（四）Bitmap解析之&quot;下采样&quot;浅析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; 如果您对博主的更新内容持续感兴趣，请关注公众号！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657146/201905/657146-20190528074933322-1104756605.jpg&quot; alt=&quot;&quot; width=&quot;233&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 27 May 2019 16:45:00 +0000</pubDate>
<dc:creator>toney.wu</dc:creator>
<og:description>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道，以及自动的资源池技术。为了让用户拥有良好的App使用体验，图片不仅要快</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sihaixuan/p/10925585.html</dc:identifier>
</item>
<item>
<title>Web测试框架SeleniumBase - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/10934588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/10934588.html</guid>
<description>&lt;p&gt;前几天逛GitHub发现一个基于Selenium和unittest单元测试框架的一个测试框架SeleniumBase。&lt;/p&gt;
&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/seleniumbase/SeleniumBase&quot; class=&quot;uri&quot;&gt;https://github.com/seleniumbase/SeleniumBase&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大概看了一个它的API，它的设计思想与我的pyse很像。&lt;/p&gt;
&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/defnngj/pyse&quot; class=&quot;uri&quot;&gt;https://github.com/defnngj/pyse&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，提供了更加丰富的API，和一些强大的功能。&lt;/p&gt;
&lt;p&gt;首先，SeleniumBase支持 pip安装：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt; pip install seleniumbase&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它依赖的库比较多，包括pytest、nose这些第三方单元测试框架，是为更方便的运行测试用例，因为这两个测试框架是支持unittest测试用例的执行的。&lt;/p&gt;
&lt;p&gt;SeleniumBase还生成了“seleniumbase”命令，主要是为了方便我们安装浏览器驱动。&lt;/p&gt;
&lt;p&gt;你可以通过下面的命令安装不同的浏览器驱动。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;seleniumbase install chromedriver

seleniumbase install geckodriver

seleniumbase install edgedriver

seleniumbase install iedriver

seleniumbase install operadriver
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在项目的examples/目录下面提供了丰富的例子。其中my_first_test.py如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from seleniumbase import BaseCase


class MyTestClass(BaseCase):

    def test_basic(self):
        self.open(&quot;https://xkcd.com/353/&quot;)  
        self.assert_element('img[alt=&quot;Python&quot;]')  
        self.click('a[rel=&quot;license&quot;]')  
        self.assert_text(&quot;free to copy&quot;, &quot;div center&quot;)  
        self.open(&quot;https://xkcd.com/1481/&quot;)
        title = self.get_attribute(&quot;#comic img&quot;, &quot;title&quot;)  
        self.assert_true(&quot;86,400 seconds per day&quot; in title)
        self.click(&quot;link=Blag&quot;)  
        self.assert_text(&quot;The blag of the webcomic&quot;, &quot;h2&quot;)
        self.update_text(&quot;input#s&quot;, &quot;Robots!\n&quot;)  
        self.assert_text(&quot;Hooray robots!&quot;, &quot;#content&quot;)
        self.open(&quot;https://xkcd.com/1319/&quot;)
        self.assert_exact_text(&quot;Automation&quot;, &quot;#ctitle&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你很熟悉Selenium的话，我想这些API对你来说并没什么难度。脚本中的元素定位默认使用的CSS。&lt;/p&gt;
&lt;p&gt;接下来是脚本的执行，你可以使用pytest或nose，因为SeleniumBase已经帮你装好了：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt; pytest my_first_test.py --browser=chrome

&amp;gt; nosetests my_first_test.py --browser=firefox &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它还提供的有 &lt;code&gt;—demo_mode&lt;/code&gt; 模式，使脚本执行的过程变得很慢，而且还会让操作的元素高亮显示，方便你查看和定位问题。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pytest my_first_test.py --demo_mode
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201905/311516-20190528002132903-602050772.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在调试Selenium脚本的时候，我们希望错误时可以暂停脚本，那么可以加 &lt;code&gt;--pdb -s&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pytest my_first_test.py --pdb -s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当脚本报错时是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201905/311516-20190528002029606-293971398.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的代码将使浏览器窗口保持打开状态，以防出现故障。你可以继续输入命令：&lt;br/&gt;“c”：继续&lt;br/&gt;“s”：步骤&lt;br/&gt;“n”: 下一步&lt;/p&gt;
&lt;p&gt;你还可以利用pytest 的 pytest-thml插件生成测试报告。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pytest test_suite.py --html=report.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当用例运行失败时自动截图！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201905/311516-20190528002102537-55906082.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他就没什么亮点了，不过提供的API 非常丰富，而且作者非常积极的在维护项目。你可以在项目说明中查看，或者通过提供的examples/的例子来学习。&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 16:25:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>基于Selenium 和 unittest 的Web自动化测试框架</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fnng/p/10934588.html</dc:identifier>
</item>
<item>
<title>c++语言虚函数实现多态的原理 - coding小菜鸟</title>
<link>http://www.cnblogs.com/xgmzhna/p/10934562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xgmzhna/p/10934562.html</guid>
<description>&lt;p&gt; 自上一个帖子之间跳过了一篇总结性的帖子，之后再发，今天主要研究了c++语言当中虚函数对多态的实现，感叹于c++设计者的精妙绝伦&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;c++中虚函数表的作用主要是实现了多态的机制。首先先解释一下多态的概念，多态是c++的特点之一，关于多态，简而言之就是 &lt;span&gt;用父类的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数&lt;/span&gt;，这种方法呢，可以让父类的指针具有多种形态，也就是说不需要改动很多的代码就可以让父类这一种指针，干一些很多子类指针的事情，这里是从虚函数的实现机制层面进行研究&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在写这篇帖子之前对于相关的文章进行了查阅，基本上是大段的文字，所以我的这一篇可能会用大量的图形进行赘述（如果理解有误的地方，烦请大佬能够指出），接下来就言归正传：&lt;/p&gt;
&lt;p&gt;首先介绍一下为什么会引进多态呢，基于c++的复用性和拓展性而言，同类的程序模块进行大量重复，是一件无法容忍的事情，比如我设置了苹果，香蕉，西瓜类，现在想把这些东西都装到碗这个函数里，那么在主函数当中，声明对象是必须的，但是每一次装进碗里对于水果来说，都要用自己的指针调用一次装的功能，那为什么不把这些类抽象成一个水果类呢，直接定义一个水果类的指针一次性调用所有水果装的功能呢，这个就是利用&lt;strong&gt;&lt;span&gt;父类指针去调用子类成员&lt;/span&gt;&lt;/strong&gt;，但是这个思想受到了指针指向类型的限制，也就是说表面指针指向了子类成员，但实际上还是只能调用子类成员里的父类成员，这样的思想就变的毫无意义了，如果想要解决这个问题，只要在父类前加上virtual就可以解决了，这里就是利用虚函数实现多态的实例。&lt;/p&gt;
&lt;p&gt;首先还是作为举例来两个类，在之前基础知识的帖子中提到过，空类的大小是一个字节（占位符），函数，静态变量都在编译期就形成了，不用类去分配空间，但是做一个小实验，看一看在定义了虚函数之后，类的大小是多少呢&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CFather 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AA()　　//虚函数标识符
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CFather :: AA()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BB()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CFather  :: BB()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CSon : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CFather
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AA()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CSon :: AA()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BB()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CSon :: BB()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(CFather) &amp;lt;&amp;lt;&lt;span&gt; endl;     　　　　　　//测试加了虚函数的类
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1664912/201905/1664912-20190527232822863-1481857866.png&quot; alt=&quot;&quot; width=&quot;151&quot; height=&quot;43&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显类里装了一个 4个字节的东西，除了整形int，就是指针了，没错这里装的就是&lt;span&gt;&lt;strong&gt;函数指针&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先把这个代码，给抽象成图形进行理解，在这CFather为A，CSon为B&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1664912/201905/1664912-20190527233411680-1289524449.png&quot; alt=&quot;&quot; width=&quot;325&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 此时就是一个单纯的继承的情况，不存在虚函数，然后我new一个对象，A *p = new A；那么 p -&amp;gt; AA(),必然是指向A类中的AA()函数，那么函数的调用有两种方式 一种函数名加（）直接调用，一种是利用函数指针进行调用，在这里我想要调用子类的，就可以利用函数指针进行调用，假设出来两个函数指针，来指向B类中的两个成员函数，如果我父类想要调用子类成员，就可以通过 p指针去调用函数指针，再通过函数指针去调用成员函数&lt;/p&gt;
&lt;p&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1664912/201905/1664912-20190527234659582-1821272691.png&quot; alt=&quot;&quot; width=&quot;338&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 每一个函数都可以用一个函数指针去指着，那么每一类中的函数指针都可以形成自己的一个表，这个就叫做虚函数表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1664912/201905/1664912-20190527235419215-984693224.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 那么在创建对象后，为什么类中会有四个字节的内存空间呢？&lt;/p&gt;
&lt;p&gt;在&lt;span&gt;C++&lt;/span&gt;的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象中最前面的位置（这是为了保证正确取到虚函数的偏移量）。这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。也就是说这四个字节的指针，代替了上图中（p-&amp;gt;*pfn）（）的作用，指向了函数指针，也就是说，在使用了虚函数的父类成员函数，&lt;span&gt;&lt;strong&gt;&lt;span&gt;虽然写的还是p-&amp;gt;AA(),实际上却是，(p-&amp;gt;*(vfptr[0]))&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;,而指向哪个虚函数表就由，创建的对象来决定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1664912/201905/1664912-20190528000306476-1956682188.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，就能理解如何用虚函数这个机制来实现多态的了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无虚数覆盖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1664912/201905/1664912-20190528001050352-1344165398.png&quot; alt=&quot;&quot; width=&quot;73&quot; height=&quot;177&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，&lt;/span&gt;&lt;span&gt;&lt;span&gt;Derive d;&lt;/span&gt; 的虚函表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1664912/201905/1664912-20190528001206885-1243740769.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;103&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以看到下面几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;虚函数按照其声明顺序放于表中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;父类的虚函数在子类的虚函数前面。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有虚数覆盖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1664912/201905/1664912-20190528001342955-1656808915.png&quot; alt=&quot;&quot; width=&quot;75&quot; height=&quot;176&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：&lt;span&gt;f()&lt;/span&gt;。那么，对于派生类的实例，其虚函数表会是下面的一个样子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1664912/201905/1664912-20190528001411209-1219771750.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;130&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们从表中可以看到下面几点，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;覆盖的&lt;span&gt;f()&lt;/span&gt;函数被放到了虚表中原来父类虚函数的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;没有被覆盖的函数依旧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样，我们就可以看到对于下面这样的程序，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            Base *b = new Derive();&lt;/p&gt;
&lt;p&gt;            b-&amp;gt;f();&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由&lt;span&gt;b&lt;/span&gt;所指的内存中的虚函数表的&lt;span&gt;f()&lt;/span&gt;的位置已经被&lt;span&gt;Derive::f()&lt;/span&gt;函数地址所取代，于是在实际调用发生时，是&lt;span&gt;Derive::f()&lt;/span&gt;被调用了。这就实现了多态。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;2019-05-28 00:15:30 编程小菜鸟自我反思，今天图画的太丑了，大家多多担待，如果技术上有什么偏差，大家可以踊跃批评我，谢谢！！！&lt;/p&gt;

</description>
<pubDate>Mon, 27 May 2019 16:17:00 +0000</pubDate>
<dc:creator>coding小菜鸟</dc:creator>
<og:description>自上一个帖子之间跳过了一篇总结性的帖子，之后再发，今天主要研究了c++语言当中虚函数对多态的实现，感叹于c++设计者的精妙绝伦 c++中虚函数表的作用主要是实现了多态的机制。首先先解释一下多态的概念，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xgmzhna/p/10934562.html</dc:identifier>
</item>
<item>
<title>【Spring源码解析】—— 简单工厂模式的BeanFactory的超简版实现 - 可可_小虾米</title>
<link>http://www.cnblogs.com/keke-xiaoxiami/p/10934406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keke-xiaoxiami/p/10934406.html</guid>
<description>&lt;h3 align=&quot;center&quot;&gt; 一、什么是简单工厂模式&lt;/h3&gt;
&lt;p&gt;设计模式的核心是“分工”，通过分工将对象与职责划分的更细化，进而提升系统设计的可扩展性，使其更容易维护。&lt;/p&gt;

&lt;p&gt;开闭原则：对扩展开放，对修改关闭；要增加一个新的处理逻辑，可以开一个新的类，不要在老的上面修改&lt;/p&gt;
&lt;p&gt;依赖倒转原则：依赖关系从具体转向抽象，也就是说：A调用B，不是直接调用B的实现，而是依赖B的接口&lt;/p&gt;
&lt;p&gt;迪米特法则：类尽量少的与其他类发生关系，或者产生依赖，以此来使扩展可以更容易&lt;/p&gt;

&lt;p&gt;工厂模式中的三种：简单工厂模式、工厂方法模式、抽象工厂模式；实现了创建者和调用者的分离，调用者不需要知道具体的创建者是什么类，只需要知道工厂的接口以及自己想要的产品名称，就可以进行调用得到想要的产品&lt;/p&gt;
&lt;p&gt;简单工厂模式：简单工厂模式也称为静态工厂模式，工厂类一般采用静态方法，根据接收的参数不同来确定返回对象实例，但简单工厂模式违反了开闭原则，要增加一个新的类别必须要修改代码&lt;/p&gt;
&lt;p&gt;注意，简单工厂模式就是：针对一个项目或者一个独立模块只有一个工厂类，而工厂方法模式是有一组实现了相同接口的工厂类（虽然符合开闭原则，但是会增加新的类来扩展，看情况而定，实际上在项目开发中通常还是用简单工厂比较多）&lt;/p&gt;
&lt;h3&gt;二、依据Spring中的BeanFactory自己实现简版&lt;/h3&gt;
&lt;p&gt;首先是，先写一个接口类，BeanFactory的接口类如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;public interface&lt;/strong&gt; BeanFactory {&lt;br/&gt;    Object getBean(String beanName);&lt;br/&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面是xml配置文件 springtest.xml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;beans&amp;gt;

    &amp;lt;bean id=&quot;usertest&quot; &lt;span&gt;class&lt;/span&gt;=&quot;beanfactory.demo.User&quot;&amp;gt;

        &amp;lt;property name=&quot;username&quot; value=&quot;lxlx&quot; /&amp;gt;

        &amp;lt;property name=&quot;passWord&quot; value=&quot;111&quot; /&amp;gt;

        &amp;lt;property name=&quot;age&quot; value=&quot;11&quot;/&amp;gt;

    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;下面是bean定义的class文件 User类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String passWord;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassWord(String passWord) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.passWord =&lt;span&gt; passWord;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassWord() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; passWord;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是实现类 ConcreteBeanFactory：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; beanfactory.demo;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.io.SAXReader;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.dom4j.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Type;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;

 * Created by xiami on 2019/5/26.

 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteBeanFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanFactory{


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单工厂模式的特征是：一个工厂中可以生产多种不同的产品，这里的Bean其实是没有区分不同的bean，是可以通过get返回不同的bean&lt;/span&gt;
&lt;span&gt;
    @Override

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getBean(String beanName) {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanDefinitionMap.get(beanName);

    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加一个init的操作方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从xml配置文件中进行解析读取&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(String xmlPath){

        SAXReader saxReader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SAXReader();

        File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(xmlPath);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

            Document document &lt;/span&gt;=&lt;span&gt; saxReader.read(file);

            Element root &lt;/span&gt;=&lt;span&gt; document.getRootElement();

            Element foo;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历bean&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (Iterator i = root.elementIterator(&quot;bean&quot;&lt;span&gt;); i.hasNext();) {

                foo &lt;/span&gt;=&lt;span&gt; (Element) i.next();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取bean的属性id和class&lt;/span&gt;
&lt;span&gt;
                Attribute id &lt;/span&gt;= foo.attribute(&quot;id&quot;&lt;span&gt;);

                Attribute cls &lt;/span&gt;= foo.attribute(&quot;class&quot;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用Java反射机制，通过class的名称获取Class对象&lt;/span&gt;
&lt;span&gt;
                Class&lt;/span&gt;&amp;lt;?&amp;gt; bean =&lt;span&gt; Class.forName(cls.getText());

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取对应class的信息&lt;/span&gt;
&lt;span&gt;
                java.beans.BeanInfo info &lt;/span&gt;=&lt;span&gt; java.beans.Introspector.getBeanInfo(bean);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取其属性描述&lt;/span&gt;
&lt;span&gt;
                java.beans.PropertyDescriptor pd[] &lt;/span&gt;=&lt;span&gt; info.getPropertyDescriptors();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置值的方法&lt;/span&gt;
&lt;span&gt;
                Method mSet &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个对象&lt;/span&gt;
&lt;span&gt;
                Object obj &lt;/span&gt;=&lt;span&gt; bean.newInstance();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历该bean的property属性&lt;/span&gt;

                &lt;span&gt;for&lt;/span&gt; (Iterator ite = foo.elementIterator(&quot;property&quot;&lt;span&gt;); ite.hasNext();) {

                    Element foo2 &lt;/span&gt;=&lt;span&gt; (Element) ite.next();

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取该property的name属性&lt;/span&gt;
&lt;span&gt;
                    Attribute name &lt;/span&gt;= foo2.attribute(&quot;name&quot;&lt;span&gt;);

                    String value &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                    Object typeValue &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取value值&lt;/span&gt;
&lt;span&gt;
                    value &lt;/span&gt;= foo2.attributeValue(&quot;value&quot;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; pd.length; k++&lt;span&gt;) {

                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pd[k].getName().equalsIgnoreCase(name.getText())) {

                            mSet &lt;/span&gt;=&lt;span&gt; pd[k].getWriteMethod();

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置值这里，需要根据类型给value做类型转换

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;properties中包含了properType的项，因为当前程序中就只有String和Int，先处理这样的类型&lt;/span&gt;
&lt;span&gt;
                            Type mType &lt;/span&gt;=&lt;span&gt; pd[k].getPropertyType();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mType.getTypeName().equals(&quot;java.lang.String&quot;&lt;span&gt;)){

                                typeValue &lt;/span&gt;=&lt;span&gt; String.valueOf(value);

                            }

                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(mType.getTypeName().equals(&quot;int&quot;&lt;span&gt;)){

                                typeValue &lt;/span&gt;=&lt;span&gt; Integer.parseInt(value);

                            }

                            mSet.invoke(obj, typeValue);

                        }

                    }

                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将对象放入beanMap中，其中key为id值，value为对象&lt;/span&gt;
&lt;span&gt;
                beanDefinitionMap.put(id.getText(), obj);

            }

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){

            System.out.println(e.toString());

        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面是测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){

        AbstractBeanFactory absbf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbstractBeanFactory();

        absbf.init(&lt;/span&gt;&quot;E:\\java-demo\\src\\beanfactory\\demo\\springtest.xml&quot;&lt;span&gt;);

        User user &lt;/span&gt;= (User)absbf.getBean(&quot;usertest&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;User类的bean有没有创建成功：&quot; +&lt;span&gt; user);

        System.out.println(&lt;/span&gt;&quot;属性值：&quot; + user.getUsername() + &quot;,&quot; + user.getPassWord() + &quot;,&quot; +&lt;span&gt; user.getAge());

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果是：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634202/201905/634202-20190527234319779-1881480996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要理解的是：简单工厂模式是一种思想，就是：不针对特定的产品进行工厂的划分，也就是说没有多个批次或者类别的工厂，而是所有的内容都在一个工厂里面生产，你需要什么我给你什么即可&lt;/p&gt;

&lt;p&gt;参考文章：https://blog.csdn.net/mlc1218559742/article/details/52776160/&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 15:50:00 +0000</pubDate>
<dc:creator>可可_小虾米</dc:creator>
<og:description>一、什么是简单工厂模式 设计模式的核心是“分工”，通过分工将对象与职责划分的更细化，进而提升系统设计的可扩展性，使其更容易维护。 开闭原则：对扩展开放，对修改关闭；要增加一个新的处理逻辑，可以开一个新</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/keke-xiaoxiami/p/10934406.html</dc:identifier>
</item>
<item>
<title>NanoPC-T3 64位裸机编程 —— 启动和运行状态切换 - 摩斯电码</title>
<link>http://www.cnblogs.com/pengdonglin137/p/10934375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengdonglin137/p/10934375.html</guid>
<description>&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;参考：&lt;/span&gt;&lt;/p&gt;





&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;作者：彭东林&lt;/span&gt;&lt;/span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;邮箱：pengdonglin137@163.com&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234413278-514956498.png&quot; alt=&quot;&quot; width=&quot;857&quot; height=&quot;556&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　可以看到S5P6818一共有两个cluster，每个cluster各有4个Cortex-A53架构的core。从官方手册中说，每个core都工作在不小于1.4GHz的频率上，每个core有一个属于自己的L1 Cache，其中I-Cache和D-Cache各32KB，每个cluster内部的4个core共享一个大小为512KB的L2 Cache，外部的CCI-400用于Cache一致性。此外，SoC内部还有一个64KB的Internal SRAM和一个20KB的Internal ROM，其中Internal ROM用于存放bootrom代码，Internal SRAM一部分给bootrom存放.data/.bss/stack，另一部分给留给二级bootloader运行，二级bootloader用于初始化DDR以及从Flash读取其他镜像到DDR中，比如uboot以及ATF镜像等。&lt;/span&gt;&lt;/span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234414011-1161839511.jpg&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;734&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;目前主要知道如下几个地址范围：&lt;/span&gt;&lt;/span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Internal ROM: 0x3400_0000 ~ 0x3400_4FFF， 一共20KB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Internal SRAM: 0xFFFF_0000 ~ 0xFFFF_FFFF，一共64KB&lt;/span&gt;&lt;/p&gt;


&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234414477-2110338840.png&quot; alt=&quot;&quot; width=&quot;701&quot; height=&quot;185&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　&lt;span id=&quot;wizkm_highlight_tmp_span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;上图是S5P6818的启动源，目前NanoPC T3上支持e&lt;span id=&quot;wizkm_highlight_tmp_span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;MMC&lt;/span&gt;&lt;/span&gt;、sdcard的启动方式，如果所有的device都启动失败的话，最后会从USB启动，对应的就是上面的 &quot;5=SDMMC&quot;，然后通过SD3和VID1[3]来控制使用哪个port，一个port对应的就是一个SDMMC控制器，这款SoC一共有3个SDMMC控制器，eMMC接在SDMMC2上，sdcard接在SDMMC0上，wifi和bt接在SDMMC1上，使用的是SDIO接口。在原理图上：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234415515-129976605.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;284&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　图中，CAM1_D3就是VID1[3]引脚，当按下图中的BOOT按键是，就是从sdcard启动，抬起就是从eMMC启动。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;从sdcard启动&lt;/span&gt;&lt;/span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234416464-2002402937.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;313&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　如果从sdcard启动的话，&lt;/span&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;上电后首先执行的是Internal ROM中的程序&lt;/span&gt;&lt;/strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;（称之为iROMBOOT），硬件会自动把Internal ROM重新映射到物理地址0x0000_0000上，然后bootrom中的程序通过bootconfig得知是从SDMMC0启动，然后将用户自己的Bootcode从sdcard当中读取出来放入Internal SRAM中相应的位置执行，称之为SDHCBOOT。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234417362-468939921.jpg&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;714&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234418110-1768583168.png&quot; alt=&quot;&quot; width=&quot;711&quot; height=&quot;339&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　既然用户自己的Bootcode是被固化在芯片内部的bootrom程序加载的，所以用户自己的Bootcode在sdcard当中的存放就必须有一定的格式，否则bootrom不认，这个格式称之为Boot Header。从上面的图中，首先我们应该知道的是User Bootcode应该从sdcard的第1号扇区开始存放，对于sdcard来说，每个扇区的大小是512byte，其中第0号扇区保留出来给分区表使用，当然对于SDHCBOOT这种启动方式，不care在sdcard的第0号扇区里是否有分区表，因为bootrom是直接定位到第1号扇区开始读取的，读取56KB的大小，也就是112个扇区。存放位置清楚了，下面就是具体的Boot Header的数据结构，具体请参考S5P6818的芯片手册的3.4.9 Additional Information。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234418531-1278600861.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　下面是我的理解：上面是关于Boot Header的说明：如果不是从uart启动的话，那么bootrom会检查第二级bootloader（也就是user boot code）的前512字节的Boot Header，bootrom会将第二级bootloader的前512字节的Boot Header存放到0xFFFF_0000地址上，这个是Internal SRAM的起始地址，然后检查signature是否为&quot;NSIH&quot;，如果不是的话，就尝试下一个启动源。在Boot Header中LOADSIZE、LOADADDR以及LAUNCHADDR必须有效（16字节对齐），LOADSIZE表示第二级bootloader的大小（给bootrom看的），后两个分别表示第二级bootloader的加载地址和运行地址（加载地址表示bootrom把第二级bootloader从sdcard读取出来后，存放到Internal SRAM的哪个地址上，而运行地址的意思是，读到Internal SRAM之后，最后执行跳转操作时需要将PC指针设置为哪个地址&lt;/span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;），也就是0xFFFF_0000。如果是从SPI启动的话，bootrom还会检查CRC32&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;（文档上说这部分校验码不包含Boot Header，意思是将前512B填充成0，然后计算CRC32，计算结果填充到对应的位置）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;。最后PC指针就会跳转到LAUNCHADDR表示的地址处开始执行， 也就是0xFFFF_0000，下面是从sdcard启动时的Boot Header的格式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234418862-479525032.png&quot; alt=&quot;&quot; width=&quot;382&quot; height=&quot;636&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　上面是Boot Header的基本格式，其中vector可以用于存放异常向量表（当然也可以不这么干），文档中给的例子看，异常向量表是按Aarch32组织的，说明S5P6818这款SoC的上电后bootrom运行在Aarch32状态。Device Addr表示第二级bootloader从sdcard的哪个地址（以字节为单位）上去读取第三级bootloder。从0x44~0x4C分别表示第二级bootloader的大小，加载地址和运行地址(这两个地址固定为0xFFFF_0000)，这三个是给bootrom看的。Port Num表示第二级bootloader通过哪个sdhc port将第三级bootloader读取进来，CRC32是user bootcode的校验码&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;（文档上说这部分校验码不包含Boot Header，意思是将前512B填充成0，然后计算CRC32，计算结果填充到对应的位置）&lt;/span&gt;。Stub区域也是留给第二级bootloader自己使用的，下面的excel表格只是一种用法，其中存放了一些时钟配置和ddr时序配置参数，在第二级bootloader里会解析这部分，这样的好处是，不需要修改代码，如果换了硬件，只需要修改一下Boot Header就行了。最后的signature非常重要。可以参考&lt;a href=&quot;https://github.com/SamsungARTIK/bl1-artik710/blob/artik/nsih-generator/PERIDOT_SYSINFO_Gen_ver03.xls&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;https://github.com/SamsungARTIK/bl1-artik710&lt;/span&gt;&lt;/a&gt;，这份代码实现了一个第二级bootloader，对理解上面的启动过程很具有参考意义。&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　首先需要认识一下nsih.bin文件，也就是上面说的Boot Header，它占一个扇区（512B）大小。可以&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;参考&lt;/span&gt;&lt;/span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;a href=&quot;https://github.com/SamsungARTIK/bl1-artik710/blob/artik/nsih-generator/PERIDOT_SYSINFO_Gen_ver03.xls&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;https://github.com/SamsungARTIK/bl1-artik710/blob/artik/nsih-generator/PERIDOT_SYSINFO_Gen_ver03.xls&lt;/span&gt;&lt;/a&gt;，这个文件用excel表格的方式表示了Boot Header，由于我们这里要折腾的是64位裸机程序，所以在nsih.bin里需要实现对处理器运行状态的切换操作，好在前面的excel表格里已经有这部分操作了，下图是这个excel表格的DDR3 NSIH64标签的内容：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234420268-1449290707.png&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;2040&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;我们重点关注上图中红框里的内容：&lt;/span&gt;&lt;/span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234420705-189046176.png&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;257&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;图中第一列是机器码，第二列表示的是偏移地址，最后是对应的反汇编代码，这段反汇编实现了从Aarch32切到Aarch64。根据上面的内容我手动填写了一个可用的nsih64.bin文件，内容如下：&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234421090-885163420.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;510&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;然后使用下面的命令对其进行反汇编：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;arm-none-linux-gnueabi-objdump -D -b binary -m arm nsih64.bin &amp;gt; nsih64.S&lt;/span&gt;&lt;/p&gt;

&lt;div data-mode=&quot;C&quot; data-theme=&quot;default&quot; readability=&quot;24&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
nsih64.&lt;span&gt;bin:&lt;/span&gt;&lt;span&gt;     file format binary


Disassembly of section .&lt;/span&gt;&lt;span&gt;data:&lt;/span&gt;

&lt;span&gt;00000000&lt;/span&gt;&lt;span&gt; &amp;lt;.data&amp;gt;:
   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;:    e3a00103     &lt;span&gt;mov&lt;/span&gt;    r0, #-&lt;span&gt;1073741824&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0xc0000000&lt;/span&gt;
   &lt;span&gt;4&lt;/span&gt;:    e3800a11     orr    r0, r0, #&lt;span&gt;69632&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x11000&lt;/span&gt;
   &lt;span&gt;8&lt;/span&gt;:    e590113c     ldr    r1, [r0, #&lt;span&gt;316&lt;/span&gt;]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x13c&lt;/span&gt;
   &lt;span&gt;c:&lt;/span&gt;    e3811a0f     orr    r1, r1, #&lt;span&gt;61440&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0xf000&lt;/span&gt;
  &lt;span&gt;10&lt;/span&gt;:    e580013c     &lt;span&gt;str&lt;/span&gt;    r0, [r0, #&lt;span&gt;316&lt;/span&gt;]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x13c&lt;/span&gt;
  &lt;span&gt;14&lt;/span&gt;:    e3a025ff     &lt;span&gt;mov&lt;/span&gt;    r2, #&lt;span&gt;1069547520&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x3fc00000&lt;/span&gt;
  &lt;span&gt;18&lt;/span&gt;:    e38229ff     orr    r2, r2, #&lt;span&gt;4177920&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x3fc000&lt;/span&gt;
  1&lt;span&gt;c:&lt;/span&gt;    e3822080     orr    r2, r2, #&lt;span&gt;128&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x80&lt;/span&gt;
  &lt;span&gt;20&lt;/span&gt;:    e5802140     &lt;span&gt;str&lt;/span&gt;    r2, [r0, #&lt;span&gt;320&lt;/span&gt;]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x140&lt;/span&gt;
  &lt;span&gt;24&lt;/span&gt;:    e3a08103     &lt;span&gt;mov&lt;/span&gt;    r8, #-&lt;span&gt;1073741824&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0xc0000000&lt;/span&gt;
  &lt;span&gt;28&lt;/span&gt;:    e3888801     orr    r8, r8, #&lt;span&gt;65536&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x10000&lt;/span&gt;
  2&lt;span&gt;c:&lt;/span&gt;    e59892ac     ldr    r9, [r8, #&lt;span&gt;684&lt;/span&gt;]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x2ac&lt;/span&gt;
  &lt;span&gt;30&lt;/span&gt;:    e3899001     orr    r9, r9, #&lt;span&gt;1&lt;/span&gt;
  &lt;span&gt;34&lt;/span&gt;:    e58892ac     &lt;span&gt;str&lt;/span&gt;    r9, [r8, #&lt;span&gt;684&lt;/span&gt;]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0x2ac&lt;/span&gt;
  &lt;span&gt;38&lt;/span&gt;&lt;span&gt;:    e320f003     wfi
  3&lt;/span&gt;&lt;span&gt;c:&lt;/span&gt;&lt;span&gt;    eafffffe     b    0x3c
    ...
  &lt;/span&gt;&lt;span&gt;48&lt;/span&gt;:    ffff0000             &lt;span&gt;;&lt;/span&gt;&lt;span&gt; &amp;lt;UNDEFINED&amp;gt; instruction: 0xffff0000&lt;/span&gt;
  4&lt;span&gt;c:&lt;/span&gt;    ffff0000             &lt;span&gt;;&lt;/span&gt;&lt;span&gt; &amp;lt;UNDEFINED&amp;gt; instruction: 0xffff0000&lt;/span&gt;
&lt;span&gt;    ...
 1&lt;/span&gt;&lt;span&gt;fc:&lt;/span&gt;    4849534e     stmdami    r9, {r1, r2, r3, r6, r8, r9, ip, lr}^
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;将上面的代码转成C语言就容易理解了：&lt;/span&gt;&lt;/p&gt;
&lt;div data-mode=&quot;C&quot; data-theme=&quot;default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; REG32(addr)        (*((volatile uint32 *)addr))
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     REG32(&lt;span&gt;0xC001113c&lt;/span&gt;) |= &lt;span&gt;0xF000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     REG32(&lt;span&gt;0xC0011140&lt;/span&gt;) = &lt;span&gt;0x3FFC080&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     REG32(&lt;span&gt;0xC00102AC&lt;/span&gt;) |= &lt;span&gt;0x1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    wfi();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;结合6818的寄存器手册分析一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;第4行，将0xC001113C的[15:12]写成0xF， 表示将cluster0的四个core都设置为Aarch64，此时并没有生效。这个寄存器的默认值是0，对应的是Aarch32，所以对于S5P6818来说，上电后，cpu默认处于Aarch32模式&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234422063-1960544106.png&quot; alt=&quot;&quot; width=&quot;633&quot; height=&quot;303&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;第5行，设置复位向量基地址，也就是执行warm reset后，cluster0的core0会从这里设置的地址上开始运行&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234422568-1169559260.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;132&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;这里需要注意：上面写入的是0x3FFFC080，结合寄存器，这里设置的其实是地址的[33:2]，所以最终的地址其实是(0x3FFC080&amp;lt;&amp;lt;2) = 0xFFFF0200。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;第6行，0xC00102AC寄存器在手册里描述的是Reserved，这个寄存器的作用应该是设置warm reset标志，此时并没有执行reset操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;第7行，执行wfi操作，当执行完这条指令后，发现前面设置了warm reset标志，此时才会执行真正的warm reset操作。执行warm reset后，cluster的core0就会从0xFFFF0200地址上开始运行，并且此时的运行状态是Aarch64，这样就完成了对处理器运行状态的切换。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;这里为什么不采用eret的方式进行处理器运行状态切换呢？ 因为目前运行在Aarch32，而eret是Aarch64指令，所以只能通过warm reset的方式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;关于处理器执行状态的切换这部分，可以参考ARMv8参考手册D1.20：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234423307-994787289.png&quot; alt=&quot;&quot; width=&quot;843&quot; height=&quot;361&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;关于warm reset可以参考ARMv8参考手册D1.9:&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234424286-1802931314.jpg&quot; alt=&quot;&quot; width=&quot;848&quot; height=&quot;557&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234425477-754904995.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，我们已经知道了，在nsih64.bin的开始阶段完成了对处理器运行状态的切换，而且切换后会从0xFFFF0200开始运行。所以我们需要将裸机程序的入口放到这个地址上。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里用到的裸机程序已经上传到了github上：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;下面重点关注如下几个文件：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;链接脚本spl.lds&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234425899-1105600015.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;322&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;链接地址设置的是0xFFFF0000。&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234426591-1086127508.jpg&quot; alt=&quot;&quot; width=&quot;664&quot; height=&quot;621&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;上面第23行，表示跳过前512字节，也就是将最终可执行程序的前512字节填充为0，将来这部分会用nsih64.bin填充，并更新LOADSIZE和CRC32字段（前面填充0不会影响CRC32的校验值）。这样的话，第27行的b reset指令正好就位于0xFFFF0200.&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div data-mode=&quot;C&quot; data-theme=&quot;default&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; boot_master(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i, d = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    clrsetbits32(&lt;/span&gt;&lt;span&gt;0xc001b020&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;&lt;span&gt;);
    setbits32(&lt;/span&gt;&lt;span&gt;0xc001b004&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);

    clrsetbits32(&lt;/span&gt;&lt;span&gt;0xc001b020&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;22&lt;/span&gt;&lt;span&gt;);
    setbits32(&lt;/span&gt;&lt;span&gt;0xc001b004&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;);
    tglbits32(&lt;/span&gt;&lt;span&gt;0xc001b000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;200000&lt;/span&gt;; ++&lt;span&gt;i)
            d &lt;/span&gt;^=&lt;span&gt; i;
        tglbits32(&lt;/span&gt;&lt;span&gt;0xc001b000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
        tglbits32(&lt;/span&gt;&lt;span&gt;0xc001b000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;这个裸机程序运行的效果是，板子上的两个LED灯交替闪烁，下面是原理图：&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/480488/201905/480488-20190527234427073-649491489.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;208&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;完。&lt;/span&gt;&lt;/p&gt;





</description>
<pubDate>Mon, 27 May 2019 15:43:00 +0000</pubDate>
<dc:creator>摩斯电码</dc:creator>
<og:description>参考： https://github.com/metro94/s5p6818_spl https://github.com/trebisky/Fire3/tree/master/Boot_NSIH h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pengdonglin137/p/10934375.html</dc:identifier>
</item>
<item>
<title>一篇文章搞懂装饰器所有用法（建议收藏） - 站在两个世界的边缘</title>
<link>http://www.cnblogs.com/wongbingming/p/10934356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wongbingming/p/10934356.html</guid>
<description>&lt;h2 id=&quot;装饰器语法糖&quot;&gt;01. 装饰器语法糖&lt;/h2&gt;
&lt;p&gt;如果你接触 Python 有一段时间了的话，想必你对 &lt;code&gt;@&lt;/code&gt; 符号一定不陌生了，没错 &lt;code&gt;@&lt;/code&gt; 符号就是装饰器的语法糖。&lt;/p&gt;
&lt;p&gt;它放在一个函数开始定义的地方，它就像一顶帽子一样戴在这个函数的头上。和这个函数绑定在一起。在我们调用这个函数的时候，第一件事并不是执行这个函数，而是将这个函数做为参数传入它头顶上这顶帽子，这顶帽子我们称之为&lt;code&gt;装饰函数&lt;/code&gt; 或 &lt;code&gt;装饰器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你要问我装饰器可以实现什么功能？我只能说你的脑洞有多大，装饰器就有多强大。&lt;/p&gt;
&lt;p&gt;装饰器的使用方法很固定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先定义一个装饰函数（帽子）（也可以用类、偏函数实现）&lt;/li&gt;
&lt;li&gt;再定义你的业务函数、或者类（人）&lt;/li&gt;
&lt;li&gt;最后把这顶帽子带在这个人头上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;装饰器的简单的用法有很多，这里举两个常见的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日志打印器&lt;/li&gt;
&lt;li&gt;时间计时器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;入门用法日志打印器&quot;&gt;02. 入门用法：日志打印器&lt;/h2&gt;
&lt;p&gt;首先是&lt;strong&gt;日志打印器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实现的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在函数执行前，先打印一行日志告知一下主人，我要执行函数了。&lt;/li&gt;
&lt;li&gt;在函数执行完，也不能拍拍屁股就走人了，咱可是有礼貌的代码，再打印一行日志告知下主人，我执行完啦。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 这是装饰函数
def logger(func):
    def wrapper(*args, **kw):
        print('我准备开始计算：{} 函数了:'.format(func.__name__))

        # 真正执行的是这行。
        func(*args, **kw)

        print('啊哈，我计算完啦。给自己加个鸡腿！！')
    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如，我的业务函数是，计算两个数之和。写好后，直接给它带上帽子。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@logger
def add(x, y):
    print('{} + {} = {}'.format(x, y, x+y))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们来计算一下。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;add(200, 50)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;快来看看输出了什么，神奇不？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;我准备开始计算：add 函数了:
200 + 50 = 250
啊哈，我计算完啦。给自己加个鸡腿！&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;入门用法时间计时器&quot;&gt;03. 入门用法：时间计时器&lt;/h2&gt;
&lt;p&gt;再来看看 &lt;strong&gt;时间计时器&lt;/strong&gt;&lt;br/&gt;实现功能：顾名思义，就是计算一个函数的执行时长。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 这是装饰函数
def timer(func):
    def wrapper(*args, **kw):
        t1=time.time()
        # 这是函数真正执行的地方
        func(*args, **kw)
        t2=time.time()

        # 计算下时长
        cost_time = t2-t1 
        print(&quot;花费时间：{}秒&quot;.format(cost_time))
    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如，我们的函数是要睡眠10秒。这样也能更好的看出这个计算时长到底靠不靠谱。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time

@timer
def want_sleep(sleep_time):
    time.sleep(sleep_time)

want_sleep(10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看看，输出。真的是10秒耶。真历害！！！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;花费时间：10.0073800086975098秒&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进阶用法带参数的函数装饰器&quot;&gt;04. 进阶用法：带参数的函数装饰器&lt;/h2&gt;
&lt;p&gt;通过上面简单的入门，你大概已经感受到了装饰的神奇魅力了。&lt;/p&gt;
&lt;p&gt;不过，装饰器的用法远不止如此。我们今天就要把这个知识点讲透。&lt;/p&gt;
&lt;p&gt;上面的例子，装饰器是不能接收参数的。其用法，只能适用于一些简单的场景。不传参的装饰器，只能对被装饰函数，执行固定逻辑。&lt;/p&gt;
&lt;p&gt;如果你有经验，你一定经常在项目中，看到有的装饰器是带有参数的。&lt;/p&gt;
&lt;p&gt;装饰器本身是一个函数，既然做为一个函数都不能携带函数，那这个函数的功能就很受限。只能执行固定的逻辑。这无疑是非常不合理的。而如果我们要用到两个内容大体一致，只是某些地方不同的逻辑。不传参的话，我们就要写两个装饰器。小明觉得这不能忍。&lt;/p&gt;
&lt;p&gt;那么装饰器如何实现&lt;code&gt;传参&lt;/code&gt;呢，会比较复杂，需要两层嵌套。&lt;/p&gt;
&lt;p&gt;同样，我们也来举个例子。&lt;/p&gt;
&lt;p&gt;我们要在这两个函数的执行的时候，分别根据其国籍，来说出一段打招呼的话。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def american():
    print(&quot;我来自中国。&quot;)

def chinese():
    print(&quot;I am from America.&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在给他们俩戴上装饰器的时候，就要跟装饰器说，这个人是哪国人，然后装饰器就会做出判断，打出对应的招呼。&lt;/p&gt;
&lt;p&gt;戴上帽子后，是这样的。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@say_hello(&quot;china&quot;)
def american():
    print(&quot;我来自中国。&quot;)

@say_hello(&quot;america&quot;)
def chinese():
    print(&quot;I am from America.&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;万事俱备，只差帽子了。来定义一下，这里需要两层嵌套。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def say_hello(contry):
    def wrapper(func):
        def deco(*args, **kwargs):
            if contry == &quot;china&quot;:
                print(&quot;你好!&quot;)
            elif contry == &quot;america&quot;:
                print('hello.')
            else:
                return

            # 真正执行函数的地方
            func(*args, **kwargs)
        return deco
    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行一下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;american()
print(&quot;------------&quot;)
chinese()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看输出结果。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;你好!
我来自中国。
------------
hello.
I am from America&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;emmmm，这很NB。。。&lt;/p&gt;
&lt;h2 id=&quot;高阶用法不带参数的类装饰器&quot;&gt;05. 高阶用法：不带参数的类装饰器&lt;/h2&gt;
&lt;p&gt;以上都是基于函数实现的装饰器，在阅读别人代码时，还可以时常发现还有基于类实现的装饰器。&lt;/p&gt;
&lt;p&gt;基于类装饰器的实现，必须实现 &lt;code&gt;__call__&lt;/code&gt; 和 &lt;code&gt;__init__&lt;/code&gt;两个内置函数。&lt;br/&gt;&lt;code&gt;__init__&lt;/code&gt; ：接收被装饰函数&lt;br/&gt;&lt;code&gt;__call__&lt;/code&gt; ：实现装饰逻辑。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class logger(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(&quot;[INFO]: the function {func}() is running...&quot;\
            .format(func=self.func.__name__))
        return self.func(*args, **kwargs)

@logger
def say(something):
    print(&quot;say {}!&quot;.format(something))

say(&quot;hello&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行一下，看看输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[INFO]: the function say() is running...
say hello!&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;高阶用法带参数的类装饰器&quot;&gt;06. 高阶用法：带参数的类装饰器&lt;/h2&gt;
&lt;p&gt;上面不带参数的例子，你发现没有，只能打印&lt;code&gt;INFO&lt;/code&gt;级别的日志，正常情况下，我们还需要打印&lt;code&gt;DEBUG&lt;/code&gt; &lt;code&gt;WARNING&lt;/code&gt;等级别的日志。 这就需要给类装饰器传入参数，给这个函数指定级别了。&lt;/p&gt;
&lt;p&gt;带参数和不带参数的类装饰器有很大的不同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__init__&lt;/code&gt; ：不再接收被装饰函数，而是接收传入参数。&lt;br/&gt;&lt;code&gt;__call__&lt;/code&gt; ：接收被装饰函数，实现装饰逻辑。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class logger(object):
    def __init__(self, level='INFO'):
        self.level = level

    def __call__(self, func): # 接受函数
        def wrapper(*args, **kwargs):
            print(&quot;[{level}]: the function {func}() is running...&quot;\
                .format(level=self.level, func=func.__name__))
            func(*args, **kwargs)
        return wrapper  #返回函数

@logger(level='WARNING')
def say(something):
    print(&quot;say {}!&quot;.format(something))

say(&quot;hello&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们指定&lt;code&gt;WARNING&lt;/code&gt;级别，运行一下，来看看输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[WARNING]: the function say() is running...
say hello!&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用偏函数与类实现装饰器&quot;&gt;07. 使用偏函数与类实现装饰器&lt;/h2&gt;
&lt;p&gt;绝大多数装饰器都是基于函数和闭包实现的，但这并非制造装饰器的唯一方式。&lt;/p&gt;
&lt;p&gt;事实上，Python 对某个对象是否能通过装饰器（ &lt;code&gt;@decorator&lt;/code&gt;）形式使用只有一个要求：&lt;strong&gt;decorator 必须是一个“可被调用（callable）的对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于这个 callable 对象，我们最熟悉的就是函数了。&lt;/p&gt;
&lt;p&gt;除函数之外，类也可以是 callable 对象，只要实现了&lt;code&gt;__call__&lt;/code&gt; 函数（上面几个盒子已经接触过了），还有比较少人使用的偏函数也是 callable 对象。&lt;/p&gt;
&lt;p&gt;接下来就来说说，如何使用 类和偏函数结合实现一个与众不同的装饰器。&lt;/p&gt;
&lt;p&gt;如下所示，DelayFunc 是一个实现了 &lt;code&gt;__call__&lt;/code&gt; 的类，delay 返回一个偏函数，在这里 delay 就可以做为一个装饰器。（以下代码摘自 Python工匠：使用装饰器的小技巧）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import functools

class DelayFunc:
    def __init__(self,  duration, func):
        self.duration = duration
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f'Wait for {self.duration} seconds...')
        time.sleep(self.duration)
        return self.func(*args, **kwargs)

    def eager_call(self, *args, **kwargs):
        print('Call without delay')
        return self.func(*args, **kwargs)

def delay(duration):
    &quot;&quot;&quot;
    装饰器：推迟某个函数的执行。
    同时提供 .eager_call 方法立即执行
    &quot;&quot;&quot;
    # 此处为了避免定义额外函数，
    # 直接使用 functools.partial 帮助构造 DelayFunc 实例
    return functools.partial(DelayFunc, duration)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的业务函数很简单，就是相加&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@delay(duration=2)
def add(a, b):
    return a+b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看一下执行过程&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; add    # 可见 add 变成了 Delay 的实例
&amp;lt;__main__.DelayFunc object at 0x107bd0be0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; add(3,5)  # 直接调用实例，进入 __call__
Wait for 2 seconds...
8
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; add.func # 实现实例方法
&amp;lt;function add at 0x107bef1e0&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何写能装饰类的装饰器&quot;&gt;08. 如何写能装饰类的装饰器？&lt;/h2&gt;
&lt;p&gt;用 Python 写单例模式的时候，常用的有三种写法。其中一种，是用装饰器来实现的。&lt;/p&gt;
&lt;p&gt;以下便是我自己写的装饰器版的单例写法。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;instances = {}

def singleton(cls):
    def get_instance(*args, **kw):
        cls_name = cls.__name__
        print('===== 1 ====')
        if not cls_name in instances:
            print('===== 2 ====')
            instance = cls(*args, **kw)
            instances[cls_name] = instance
        return instances[cls_name]
    return get_instance

@singleton
class User:
    _instance = None

    def __init__(self, name):
        print('===== 3 ====')
        self.name = name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们用singleton 这个装饰函数来装饰 User 这个类。装饰器用在类上，并不是很常见，但只要熟悉装饰器的实现过程，就不难以实现对类的装饰。在上面这个例子中，装饰器就只是实现对类实例的生成的控制而已。&lt;/p&gt;
&lt;p&gt;其实例化的过程，你可以参考我这里的调试过程，加以理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190512113917.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;wrapper-装饰器有啥用&quot;&gt;09. wrapper 装饰器有啥用？&lt;/h2&gt;
&lt;p&gt;在 functools 标准库中有提供一个 wrapper 装饰器，你应该也经常见过，那他有啥用呢？&lt;/p&gt;
&lt;p&gt;先来看一个例子&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def wrapper(func):
    def inner_function():
        pass
    return inner_function

@wrapper
def wrapped():
    pass

print(wrapped.__name__)
#inner_function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么会这样子？不是应该返回 &lt;code&gt;func&lt;/code&gt; 吗？&lt;/p&gt;
&lt;p&gt;这也不难理解，因为上边执行&lt;code&gt;func&lt;/code&gt; 和下边 &lt;code&gt;decorator(func)&lt;/code&gt; 是等价的，所以上面 &lt;code&gt;func.__name__&lt;/code&gt; 是等价于下面&lt;code&gt;decorator(func).__name__&lt;/code&gt; 的，那当然名字是 &lt;code&gt;inner_function&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def wrapper(func):
    def inner_function():
        pass
    return inner_function

def wrapped():
    pass

print(wrapper(wrapped).__name__)
#inner_function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那如何避免这种情况的产生？方法是使用 functools .wrapper 装饰器，它的作用就是将 &lt;strong&gt;被修饰的函数(wrapped)&lt;/strong&gt; 的一些属性值赋值给 &lt;strong&gt;修饰器函数(wrapper)&lt;/strong&gt; ，最终让属性的显示更符合我们的直觉。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import wraps

def wrapper(func):
    @wraps(func) 
    def inner_function():
        pass
    return inner_function

@wrapper
def wrapped():
    pass

print(wrapped.__name__)
# wrapped&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;准确点说，wrapper 其实是一个偏函数对象（partial），源码如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def wraps(wrapped,
          assigned = WRAPPER_ASSIGNMENTS,
          updated = WRAPPER_UPDATES):
    return partial(update_wrapper, wrapped=wrapped,
                   assigned=assigned, updated=updated)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到wraps其实就是调用了一个函数&lt;code&gt;update_wrapper&lt;/code&gt;，知道原理后，我们改写上面的代码，在不使用 wraps的情况下，也可以让 &lt;code&gt;wrapped.__name__&lt;/code&gt; 打印出 wrapped，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import update_wrapper

def wrapper(func):
    def inner_function():
        pass
    update_wrapper(func, inner_function)
    return inner_function

def wrapped():
    pass

print(wrapped.__name__)
# wrapped&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内置装饰器property&quot;&gt;10. 内置装饰器：property&lt;/h2&gt;
&lt;p&gt;以上，我们介绍的都是自定义的装饰器。&lt;/p&gt;
&lt;p&gt;其实Python语言本身也有一些装饰器。比如&lt;code&gt;property&lt;/code&gt;这个内建装饰器，我们再熟悉不过了。&lt;/p&gt;
&lt;p&gt;它通常存在于类中，可以将一个函数定义成一个属性，属性的值就是该函数return的内容。&lt;/p&gt;
&lt;p&gt;通常我们给实例绑定属性是这样的&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student(object):
    def __init__(self, name, age=None):
        self.name = name
        self.age = age

# 实例化
XiaoMing = Student(&quot;小明&quot;)

# 添加属性
XiaoMing.age=25

# 查询属性
XiaoMing.age

# 删除属性
del XiaoMing.age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是稍有经验的开发人员，一下就可以看出，这样直接把属性暴露出去，虽然写起来很简单，但是并不能对属性的值做合法性限制。为了实现这个功能，我们可以这样写。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student(object):
    def __init__(self, name):
        self.name = name
        self.name = None

    def set_age(self, age):
        if not isinstance(age, int):
            raise ValueError('输入不合法：年龄必须为数值!')
        if not 0 &amp;lt; age &amp;lt; 100:
            raise ValueError('输入不合法：年龄范围必须0-100')
        self._age=age

    def get_age(self):
        return self._age

    def del_age(self):
        self._age = None


XiaoMing = Student(&quot;小明&quot;)

# 添加属性
XiaoMing.set_age(25)

# 查询属性
XiaoMing.get_age()

# 删除属性
XiaoMing.del_age()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码设计虽然可以变量的定义，但是可以发现不管是获取还是赋值（通过函数）都和我们平时见到的不一样。&lt;br/&gt;按照我们思维习惯应该是这样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 赋值
XiaoMing.age = 25

# 获取
XiaoMing.age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这样的方式我们如何实现呢。请看下面的代码。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student(object):
    def __init__(self, name):
        self.name = name
        self.name = None

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if not isinstance(value, int):
            raise ValueError('输入不合法：年龄必须为数值!')
        if not 0 &amp;lt; value &amp;lt; 100:
            raise ValueError('输入不合法：年龄范围必须0-100')
        self._age=value

    @age.deleter
    def age(self):
        del self._age

XiaoMing = Student(&quot;小明&quot;)

# 设置属性
XiaoMing.age = 25

# 查询属性
XiaoMing.age

# 删除属性
del XiaoMing.age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用&lt;code&gt;@property&lt;/code&gt;装饰过的函数，会将一个函数定义成一个属性，属性的值就是该函数return的内容。&lt;strong&gt;同时&lt;/strong&gt;，会将这个函数变成另外一个装饰器。就像后面我们使用的&lt;code&gt;@age.setter&lt;/code&gt;和&lt;code&gt;@age.deleter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@age.setter&lt;/code&gt; 使得我们可以使用&lt;code&gt;XiaoMing.age = 25&lt;/code&gt;这样的方式直接赋值。&lt;br/&gt;&lt;code&gt;@age.deleter&lt;/code&gt; 使得我们可以使用&lt;code&gt;del XiaoMing.age&lt;/code&gt;这样的方式来删除属性。&lt;/p&gt;
&lt;p&gt;property 的底层实现机制是「描述符」，为此我还写过一篇文章。&lt;/p&gt;
&lt;p&gt;这里也介绍一下吧，正好将这些看似零散的文章全部串起来。&lt;/p&gt;
&lt;p&gt;如下，我写了一个类，里面使用了 property 将 math 变成了类实例的属性&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student:
    def __init__(self, name):
        self.name = name

    @property
    def math(self):
        return self._math

    @math.setter
    def math(self, value):
        if 0 &amp;lt;= value &amp;lt;= 100:
            self._math = value
        else:
            raise ValueError(&quot;Valid value must be in [0, 100]&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么说 property 底层是基于描述符协议的呢？通过 PyCharm 点击进入 property 的源码，很可惜，只是一份类似文档一样的伪源码，并没有其具体的实现逻辑。&lt;/p&gt;
&lt;p&gt;不过，从这份伪源码的魔法函数结构组成，可以大体知道其实现逻辑。&lt;/p&gt;
&lt;p&gt;这里我自己通过模仿其函数结构，结合「描述符协议」来自己实现类 &lt;code&gt;property&lt;/code&gt; 特性。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class TestProperty(object):

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        print(&quot;in __get__&quot;)
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError
        return self.fget(obj)

    def __set__(self, obj, value):
        print(&quot;in __set__&quot;)
        if self.fset is None:
            raise AttributeError
        self.fset(obj, value)

    def __delete__(self, obj):
        print(&quot;in __delete__&quot;)
        if self.fdel is None:
            raise AttributeError
        self.fdel(obj)


    def getter(self, fget):
        print(&quot;in getter&quot;)
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        print(&quot;in setter&quot;)
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        print(&quot;in deleter&quot;)
        return type(self)(self.fget, self.fset, fdel, self.__doc__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后 Student 类，我们也相应改成如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student:
    def __init__(self, name):
        self.name = name

    # 其实只有这里改变
    @TestProperty
    def math(self):
        return self._math

    @math.setter
    def math(self, value):
        if 0 &amp;lt;= value &amp;lt;= 100:
            self._math = value
        else:
            raise ValueError(&quot;Valid value must be in [0, 100]&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了尽量让你少产生一点疑惑，我这里做两点说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;TestProperty&lt;/code&gt;装饰后，&lt;code&gt;math&lt;/code&gt; 不再是一个函数，而是&lt;code&gt;TestProperty&lt;/code&gt; 类的一个实例。所以第二个math函数可以使用 &lt;code&gt;math.setter&lt;/code&gt; 来装饰，本质是调用&lt;code&gt;TestProperty.setter&lt;/code&gt; 来产生一个新的 &lt;code&gt;TestProperty&lt;/code&gt; 实例赋值给第二个&lt;code&gt;math&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第一个 &lt;code&gt;math&lt;/code&gt; 和第二个 &lt;code&gt;math&lt;/code&gt; 是两个不同 &lt;code&gt;TestProperty&lt;/code&gt; 实例。但他们都属于同一个描述符类（TestProperty），当对 math 对于赋值时，就会进入 &lt;code&gt;TestProperty.__set__&lt;/code&gt;，当对math 进行取值里，就会进入 &lt;code&gt;TestProperty.__get__&lt;/code&gt;。仔细一看，其实最终访问的还是Student实例的 &lt;code&gt;_math&lt;/code&gt; 属性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;说了这么多，还是运行一下，更加直观一点。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 运行后，会直接打印这一行，这是在实例化 TestProperty 并赋值给第二个math
in setter
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; s1.math = 90
in __set__
&amp;gt;&amp;gt;&amp;gt; s1.math
in __get__
90&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如对上面代码的运行原理，有疑问的同学，请务必结合上面两点说明加以理解，那两点相当关键。&lt;/p&gt;
&lt;h2 id=&quot;其他装饰器装饰器实战&quot;&gt;11. 其他装饰器：装饰器实战&lt;/h2&gt;
&lt;p&gt;读完并理解了上面的内容，你可以说是Python高手了。别怀疑，自信点，因为很多人都不知道装饰器有这么多用法呢。&lt;/p&gt;
&lt;p&gt;在我看来，使用装饰器，可以达到如下目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使代码可读性更高，逼格更高；&lt;/li&gt;
&lt;li&gt;代码结构更加清晰，代码冗余度更低；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;刚好我在最近也有一个场景，可以用装饰器很好的实现，暂且放上来看看。&lt;/p&gt;
&lt;p&gt;这是一个实现控制函数运行超时的装饰器。如果超时，则会抛出超时异常。&lt;/p&gt;
&lt;p&gt;有兴趣的可以看看。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import signal

class TimeoutException(Exception):
    def __init__(self, error='Timeout waiting for response from Cloud'):
        Exception.__init__(self, error)


def timeout_limit(timeout_time):
    def wraps(func):
        def handler(signum, frame):
            raise TimeoutException()

        def deco(*args, **kwargs):
            signal.signal(signal.SIGALRM, handler)
            signal.alarm(timeout_time)
            func(*args, **kwargs)
            signal.alarm(0)
        return deco
    return wraps&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190511161447.png&quot; alt=&quot;关注公众号，获取最新干货！&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 15:38:00 +0000</pubDate>
<dc:creator>站在两个世界的边缘</dc:creator>
<og:description>一文搞懂 Python 中装饰器的所有用法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wongbingming/p/10934356.html</dc:identifier>
</item>
<item>
<title>搞懂ZooKeeper的Watcher之源码分析及特性总结 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10922480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10922480.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　本章讲ZooKeeper重要的机制，Watcher特性。&lt;span&gt;ZooKeeper允许客户端向服务端注册Watcher监听，当服务端一些指定事件触发了这个Watcher，那么就会向指定客户端发送一个事件通知客户端执行回调逻辑&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;一.Watcher机制&lt;/h2&gt;
&lt;p&gt;　　ZooKeeper允许客户端向服务端注册感兴趣的Watcher监听，当服务端触发了这个Watcher，那么就会向客户端发送一个时间来实现分布式的通知功能。真正的Watcher回调与业务逻辑执行都在客户端&lt;/p&gt;
&lt;p&gt;　　那么需要注意一下，&lt;span&gt;给客户端的通知里只会告诉你通知状态（KeeperState），事件类型（EventType）和路径（Path）。&lt;span&gt;&lt;strong&gt;不会告诉你原始数据和更新过后的数据！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Watcher机制包括三部分：&lt;span&gt;注册、存储、通知&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册：注册Watcher&lt;/li&gt;
&lt;li&gt;存储：讲Watcher对象存在客户端的WatcherManager中&lt;/li&gt;
&lt;li&gt;通知：服务端触发Watcher事件，通知客户端，客户端从WatcherManager中取出对应的Watcher对象执行回调 &lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201905/1465200-20190525152451939-1359939836.png&quot; alt=&quot;&quot; width=&quot;746&quot; height=&quot;527&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么接下来，我们就分这3步来分析：&lt;/p&gt;
&lt;h3&gt;注册&lt;/h3&gt;
&lt;p&gt;　　我们可以通过以下方式向服务端注册Watcher，主要是构造参数、getData、getChildren和exists方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ZooKeeper(String connectString, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sessionTimeout, Watcher watcher)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] getData(String path, Watcher watcher, Stat stat)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getChildren(String path, Watcher watcher)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Stat exists(String path, Watcher watcher)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们就看getData方法，从源码角度看看如何注册的，可以看到首先封装了一个WatchRegistration对象，保存了节点的路径和Watcher对象的关系，然后在请求的request设置了是否有watcher这么一个boolean的成员变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getData(String path, Watcher &lt;span&gt;watcher&lt;/span&gt;, Stat stat) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; KeeperException, InterruptedException {
    PathUtils.validatePath(path);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装一个WatcherRegistration的对象，保存节点路径和Watcher的对应关系&lt;/span&gt;
    ZooKeeper.WatchRegistration &lt;span&gt;wcb&lt;/span&gt; = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;watcher&lt;/span&gt; != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;span&gt;wcb &lt;/span&gt;&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZooKeeper.DataWatchRegistration(watcher, path);
    }
    String serverPath &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.prependChroot(path);
    RequestHeader h &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestHeader();
    h.setType(&lt;/span&gt;4&lt;span&gt;);
    GetDataRequest request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GetDataRequest();
    request.setPath(serverPath);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记是否有watcher&lt;/span&gt;
    request.setWatch(&lt;span&gt;watcher&lt;/span&gt; != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    GetDataResponse response &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GetDataResponse();
    ReplyHeader r &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cnxn.submitRequest(h, request, response, &lt;span&gt;wcb&lt;/span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r.getErr() != 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; KeeperException.create(Code.get(r.getErr()), path);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stat != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            DataTree.copyStat(response.getStat(), stat);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.getData();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; DataWatchRegistration &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ZooKeeper.WatchRegistration {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存节点路径和Watcher的关系&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataWatchRegistration(Watcher watcher, String clientPath) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(watcher, clientPath);
    }

    ...
}

&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WatchRegistration {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Watcher watcher;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String clientPath;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WatchRegistration(Watcher watcher, String clientPath) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.watcher =&lt;span&gt; watcher;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clientPath =&lt;span&gt; clientPath;
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们继续接着看这个wcb变量做了什么（已经用&lt;span&gt;紫色&lt;/span&gt;标注该变量），简单来说就是这个变量被封装在了packet对象里，packet可以看成一个最小的通信协议单元，传输信息。最后将packet对象放到了发送队列里&lt;span&gt;SendThread&lt;span&gt;里&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ReplyHeader submitRequest(RequestHeader h, Record request, Record response, WatchRegistration &lt;span&gt;watchRegistration&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
    ReplyHeader r &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReplyHeader();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端与服务端的网络传输&lt;/span&gt;
    ClientCnxn.Packet packet = &lt;span&gt;this&lt;/span&gt;.queuePacket(h, r, request, response, (AsyncCallback)&lt;span&gt;null&lt;/span&gt;, (String)&lt;span&gt;null&lt;/span&gt;, (String)&lt;span&gt;null&lt;/span&gt;, (Object)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, &lt;span&gt;watchRegistration&lt;/span&gt;);
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(packet) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;packet.finished) {
            packet.wait();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
    }
}

ClientCnxn.Packet queuePacket(RequestHeader h, ReplyHeader r, Record request, Record response, AsyncCallback cb, String clientPath, String serverPath, Object ctx, WatchRegistration &lt;span&gt;watchRegistration&lt;/span&gt;) {
    ClientCnxn.Packet packet &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    LinkedList var11 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outgoingQueue;
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outgoingQueue) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任何传输的对象都包装成Packet对象&lt;/span&gt;
        packet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClientCnxn.Packet(h, r, request, response, &lt;span&gt;watchRegistration&lt;/span&gt;);
        packet.cb &lt;/span&gt;=&lt;span&gt; cb;
        packet.ctx &lt;/span&gt;=&lt;span&gt; ctx;
        packet.clientPath &lt;/span&gt;=&lt;span&gt; clientPath;
        packet.serverPath &lt;/span&gt;=&lt;span&gt; serverPath;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.state.isAlive() &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.closing) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h.getType() == -11&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.closing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放入发送队列中，等待发送&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outgoingQueue.add(packet);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.conLossPacket(packet);
        }
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendThread.getClientCnxnSocket().wakeupCnxn();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; packet;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们看org.apache.zookeeper.ClientCnxnSocketNIO#doIO这个方法，关键代码已经用红色标注出来了，从要发送的队列outgoingQueue中取出packet然后序列化到底层数组，&lt;span&gt;注意了，这里没有序列化前面说的WatchRegistration对象，只序列化了requestHeader和request两个属性，也就是说，&lt;span&gt;&lt;strong&gt;服务端并不会接收到阶段路径和watcher对象的关系，回调的业务逻辑代码也不会给服务端！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; doIO(List&amp;lt;Packet&amp;gt; pendingQueue, LinkedList&amp;lt;Packet&amp;gt; outgoingQueue, ClientCnxn cnxn) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, IOException {
    SocketChannel sock &lt;/span&gt;= (SocketChannel)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sockKey.channel();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sock == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IOException(&quot;Socket is null!&quot;&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否可读&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sockKey.isReadable()) {
            ...
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sockKey.isWritable()) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(outgoingQueue) {
                &lt;span&gt;Packet p &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= this.findSendablePacket(outgoingQueue, cnxn.sendThread.clientTunneledAuthenticationInProgress());
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateLastSend();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.bb == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.requestHeader != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; p.requestHeader.getType() != 11 &amp;amp;&amp;amp; p.requestHeader.getType() != 100&lt;span&gt;) {
                            p.requestHeader.setXid(cnxn.getXid());
                        }

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 序列化&lt;/span&gt;
&lt;span&gt;&lt;span&gt;                        p.createBB();&lt;/span&gt;
                    }
                    
                    &lt;span&gt;sock.write(p.bb);&lt;/span&gt;
                    ...
                }

                ...
            }
        }
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createBB() {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        ByteArrayOutputStream baos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
        BinaryOutputArchive boa &lt;/span&gt;=&lt;span&gt; BinaryOutputArchive.getArchive(baos);
        boa.writeInt(&lt;/span&gt;-1, &quot;len&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 序列化header&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.requestHeader != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this.requestHeader.serialize(boa, &quot;header&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.request &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ConnectRequest) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.request.serialize(boa, &quot;connect&quot;&lt;span&gt;);
            boa.writeBool(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.readOnly, &quot;readOnly&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 序列化request&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.request != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this.request.serialize(boa, &quot;request&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        }
        baos.close();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bb =&lt;span&gt; ByteBuffer.wrap(baos.toByteArray());
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bb.putInt(&lt;span&gt;this&lt;/span&gt;.bb.capacity() - 4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bb.rewind();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException var3) {
        ClientCnxn.LOG.warn(&lt;/span&gt;&quot;Ignoring unexpected exception&quot;&lt;span&gt;, var3);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;存储&lt;/h3&gt;
&lt;p&gt;　　上面都是客户端发起请求的过程，那么接下来我们看服务端接收到请求会做些什么，&lt;span&gt;ZooKeeper的服务端对于客户端的请求，采用了典型的责任链模式&lt;/span&gt;，也就是说客户端的每个请求都由几个不同的处理器来依次进行处理，我们这里就看这个方法:org.apache.zookeeper.server.FinalRequestProcessor#processRequest&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processRequest(Request request) {
    ...
    PrepRequestProcessor.checkACL(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.zks, &lt;span&gt;this&lt;/span&gt;.zks.getZKDatabase().convertLong(aclG), 1&lt;span&gt;, request.authInfo);
    Stat stat &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stat();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里根据客户端设置的是否有watch变量来传入watcher对象
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果true则将当前的ServerCnxn传入（ServerCnxn代表客户端和服务端的连接）&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt;[] b = &lt;span&gt;this&lt;/span&gt;.zks.getZKDatabase().getData(getDataRequest.getPath(), stat, getDataRequest.getWatch() ? cnxn : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    rsp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GetDataResponse(b, stat);
    ...
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getData(String path, Stat stat, Watcher watcher) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoNodeException {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dataTree.getData(path, stat, watcher);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　紧接着，将数据节点路径和ServerCnxn对象存储在&lt;span&gt;WatcherManager的watchTable和watch2Paths中。前者是路径维度，后者是Watcher维度&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getData(String path, Stat stat, Watcher watcher) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoNodeException {
    DataNode n &lt;/span&gt;= (DataNode)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nodes.get(path);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoNodeException();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(n) {
            n.copyStat(stat);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (watcher != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加watcher&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.dataWatches.addWatch(path, watcher);&lt;/span&gt;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n.data;
        }
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addWatch(String path, Watcher watcher) {
    HashSet&lt;/span&gt;&amp;lt;Watcher&amp;gt; list = (HashSet)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.watchTable.get(path);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet(4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.watchTable.put(path, list);&lt;/span&gt;
    }

    list.add(watcher);
    HashSet&lt;/span&gt;&amp;lt;String&amp;gt; paths = (HashSet)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.watch2Paths.get(watcher);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (paths == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        paths &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashSet();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.watch2Paths.put(watcher, paths);&lt;/span&gt;
    }

   &lt;span&gt; paths.add(path);&lt;/span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 路径维度&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;String, HashSet&amp;lt;Watcher&amp;gt;&amp;gt; watchTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Watcher维度&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;Watcher, HashSet&amp;lt;String&amp;gt;&amp;gt; watch2Paths = &lt;span&gt;new&lt;/span&gt; HashMap();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当服务端处理完毕之后，&lt;span&gt;客户端的SendThread线程负责接收服务端的响应，finishPacket方法会从packet中取出WatchRegistration并注册到ZKWatchManager中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishPacket(ClientCnxn.Packet p) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端注册wathcer&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (p.watchRegistration != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;span&gt;        p.watchRegistration.register(p.replyHeader.getErr());&lt;/span&gt;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.cb == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(p) {
            p.finished &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            p.notifyAll();
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        p.finished &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventThread.queuePacket(p);
    }

}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; register(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rc) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.shouldAddWatch(rc)) {
        Map&lt;/span&gt;&amp;lt;String, Set&amp;lt;Watcher&amp;gt;&amp;gt; watches = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getWatches(rc);
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(watches) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据路径拿到&lt;/span&gt;
            Set&amp;lt;Watcher&amp;gt; watchers = (Set)watches.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientPath);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (watchers == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                watchers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashSet();
               &lt;span&gt; watches.put(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.clientPath, watchers);&lt;/span&gt;
            }

            &lt;span&gt;((Set)watchers).add(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.watcher);&lt;/span&gt;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;通知&lt;/h3&gt;
&lt;p&gt; 　　当服务端对应的数据节点内容发生改变，那么会触发watcher，对应的代码在org.apache.zookeeper.server.DataTree#setData&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Stat setData(String path, &lt;span&gt;byte&lt;/span&gt;[] data, &lt;span&gt;int&lt;/span&gt; version, &lt;span&gt;long&lt;/span&gt; zxid, &lt;span&gt;long&lt;/span&gt; time) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoNodeException {
    Stat s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stat();
    DataNode n &lt;/span&gt;= (DataNode)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nodes.get(path);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoNodeException();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] lastdata = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] lastdata;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 赋值node&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(n) {
            lastdata &lt;/span&gt;=&lt;span&gt; n.data;
            n.data &lt;/span&gt;=&lt;span&gt; data;
            n.stat.setMtime(time);
            n.stat.setMzxid(zxid);
            n.stat.setVersion(version);
            n.copyStat(s);
        }

        String lastPrefix;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((lastPrefix = &lt;span&gt;this&lt;/span&gt;.getMaxPrefixWithQuota(path)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.updateBytes(lastPrefix, (&lt;span&gt;long&lt;/span&gt;)((data == &lt;span&gt;null&lt;/span&gt; ? 0 : data.length) - (lastdata == &lt;span&gt;null&lt;/span&gt; ? 0&lt;span&gt; : lastdata.length)));
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发watcher&lt;/span&gt;
        &lt;span&gt;this.dataWatches.triggerWatch(path, EventType.NodeDataChanged);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　触发watcher，&lt;span&gt;从watchTable和watch2Paths中移除该路径的watcher。这里可以看出，Watcher在服务端是&lt;span&gt;&lt;strong&gt;一次性&lt;/strong&gt;&lt;/span&gt;的，触发一次就失效了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Watcher&amp;gt;&lt;span&gt; triggerWatch(String path, EventType type) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.triggerWatch(path, type, (Set)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Watcher&amp;gt; triggerWatch(String path, EventType type, Set&amp;lt;Watcher&amp;gt;&lt;span&gt; supress) {
    WatchedEvent e &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WatchedEvent(type, KeeperState.SyncConnected, path);
    HashSet watchers;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个同步代码块主要做的就是从watchTable和watch2Paths中移除该路径的watcher&lt;/span&gt;
    &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
        &lt;span&gt;watchers &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= (HashSet)this.watchTable.remove(path);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (watchers == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; watchers.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (LOG.isTraceEnabled()) {
                ZooTrace.logTraceMessage(LOG, &lt;/span&gt;64L, &quot;No watchers for &quot; +&lt;span&gt; path);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        Iterator i$ &lt;/span&gt;=&lt;span&gt; watchers.iterator();

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(i$.hasNext()) {
            Watcher w &lt;/span&gt;=&lt;span&gt; (Watcher)i$.next();
            HashSet&lt;/span&gt;&amp;lt;String&amp;gt; paths = (HashSet)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.watch2Paths.get(w);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (paths != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;span&gt;paths.remove(path);&lt;/span&gt;
            }
        }
    }

    Iterator i$ &lt;/span&gt;=&lt;span&gt; watchers.iterator();

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
        Watcher w;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;i$.hasNext()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; watchers;
            }

            w &lt;/span&gt;=&lt;span&gt; (Watcher)i$.next();
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(supress != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; supress.contains(w));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; watcher调用，这里的e对象里只有通知状态（KeeperState）、事件类型（EventType）以及节点路径（Path）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有修改过后的新值也没有老的值&lt;/span&gt;
&lt;span&gt;&lt;span&gt;        w.process(e);&lt;/span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后看一下process方法里，其实做的事情就是把事件发送给客户端，所以我们可以看出，真正的回调和业务逻辑执行都在客户端org.apache.zookeeper.server.NIOServerCnxn#process：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(WatchedEvent event) {&lt;br/&gt;&lt;span&gt; 　　// 请求头标记-1，表明是通知&lt;/span&gt;
    ReplyHeader h &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReplyHeader(-1, -1L, 0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (LOG.isTraceEnabled()) {
        ZooTrace.logTraceMessage(LOG, &lt;/span&gt;64L, &quot;Deliver event &quot; + event + &quot; to 0x&quot; + Long.toHexString(&lt;span&gt;this&lt;/span&gt;.sessionId) + &quot; through &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    WatcherEvent e &lt;/span&gt;=&lt;span&gt; event.getWrapper();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送通知&lt;/span&gt;
    &lt;span&gt;this.sendResponse(h, e, &quot;notification&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　客户端收到该通知，由org.apache.zookeeper.ClientCnxn.SendThread#readResponse处理，主要做的就是反序列化然后交给EventThread线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; readResponse(ByteBuffer incomingBuffer) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
    ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是通知&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (replyHdr.getXid() == -1&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ClientCnxn.LOG.isDebugEnabled()) {
            ClientCnxn.LOG.debug(&lt;/span&gt;&quot;Got notification sessionid:0x&quot; + Long.toHexString(ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sessionId));
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反序列化&lt;/span&gt;
        WatcherEvent event = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WatcherEvent();
        event.deserialize(bbia, &lt;/span&gt;&quot;response&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ClientCnxn.&lt;span&gt;this&lt;/span&gt;.chrootPath != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            String serverPath &lt;/span&gt;=&lt;span&gt; event.getPath();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (serverPath.compareTo(ClientCnxn.&lt;span&gt;this&lt;/span&gt;.chrootPath) == 0&lt;span&gt;) {
                event.setPath(&lt;/span&gt;&quot;/&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (serverPath.length() &amp;gt; ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.chrootPath.length()) {
                event.setPath(serverPath.substring(ClientCnxn.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.chrootPath.length()));
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                ClientCnxn.LOG.warn(&lt;/span&gt;&quot;Got server path &quot; + event.getPath() + &quot; which is too short for chroot path &quot; + ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.chrootPath);
            }
        }

        WatchedEvent we &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WatchedEvent(event);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ClientCnxn.LOG.isDebugEnabled()) {
            ClientCnxn.LOG.debug(&lt;/span&gt;&quot;Got &quot; + we + &quot; for sessionid 0x&quot; + Long.toHexString(ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sessionId));
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交给EventThread线程处理&lt;/span&gt;
        &lt;span&gt;ClientCnxn.this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.eventThread.queueEvent(we);&lt;/span&gt;
    } 
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后从之前注册的ZKWatcherManager中获取到所有该路径的watcher，注意了，客户端的Watcher机制也是一次性的！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; queueEvent(WatchedEvent event) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (event.getType() != EventType.None || &lt;span&gt;this&lt;/span&gt;.sessionState !=&lt;span&gt; event.getState()) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sessionState =&lt;span&gt; event.getState();
        ClientCnxn.WatcherSetEventPair pair &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClientCnxn.WatcherSetEventPair(ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.watcher.&lt;span&gt;materialize&lt;/span&gt;(event.getState(), event.getType(), event.getPath()), event);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.waitingEvents.add(pair);
    }
}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Watcher&amp;gt;&lt;span&gt; materialize(KeeperState state, EventType type, String clientPath) {
    ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把该路径下的所有Watcher都拿出来
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove方法，所以客户端也是一次性的，一旦触发，watcher就失效了&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; NodeDataChanged:
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; NodeCreated:
        var6 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dataWatches;
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dataWatches) {
            &lt;/span&gt;&lt;span&gt;this.addTo((Set)this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.dataWatches.remove(clientPath), result);&lt;/span&gt;
        }

        var6 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.existWatches;
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.existWatches) {
            &lt;/span&gt;&lt;span&gt;this.addTo((Set)this.existWatches.remove(clientPath), result);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后EventThread会从waitingEvents队列中取出Watcher并执行串行化同步处理。看一下这个方法：org.apache.zookeeper.ClientCnxn.EventThread#processEvent&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processEvent(Object event) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (event &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ClientCnxn.WatcherSetEventPair) {
             ClientCnxn.WatcherSetEventPair pair &lt;/span&gt;=&lt;span&gt; (ClientCnxn.WatcherSetEventPair)event;
             Iterator i$ &lt;/span&gt;=&lt;span&gt; pair.watchers.iterator();
  
             &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(i$.hasNext()) {
             
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的watcher就是客户端传入的watcher，里面有真正的回调逻辑代码&lt;/span&gt;
                &lt;span&gt;Watcher watcher = (Watcher)i$.next();
 
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;span&gt;watcher.process(pair.event);&lt;/span&gt;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var7) {
                    ClientCnxn.LOG.error(&lt;/span&gt;&quot;Error while calling watcher &quot;&lt;span&gt;, var7);
                }
             }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        ...
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　嗯，就是这样，走完了，从网上找到一张图，我觉得画的很不错。以上三步骤，注册，存储，通知可以结合这张图来看，最好请打开原图来看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201905/1465200-20190527233624890-1044105279.png&quot; alt=&quot;&quot; width=&quot;2974&quot; height=&quot;2362&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;三.总结&lt;/h2&gt;
&lt;h3&gt;Watcher特性总结&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一次性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　无论客户端还是服务端，一旦watcher被触发，都会被移除&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端串行执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从源码也看到了，watcher回调是串行同步化执行过程，注意不要一个watcher中放很多处理逻辑造成影响别的watcher回调&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性能轻量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　注册watcher把watcher对象传给服务端，回调的时候并不会告诉节点的具体变化前后的内容。非常轻量　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　发生CONNECTIONLOSS之后，只要在session_timeout之内再次连接上（即不发生SESSIONEXPIRED），那么这个连接注册的watches依然在。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节点通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;guava to java is Curator to ZooKeeper，开源客户端Curator引入Cache实现对服务端事件的监听，从而大大简化了原生API开发的繁琐过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;虽然我们可以通过Curator或者ZKClient避免每次要watcher注册的痛苦，&lt;span&gt;&lt;strong&gt;但是我们无法保证在节点更新频率很高的情况下客户端能收到每一次节点变化的通知&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　原因在于：当一次数据修改，通知客户端，客户端再次注册watch，在这个过程中，可能数据已经发生了许多次数据修改&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;偷来的图：&lt;a href=&quot;https://blog.csdn.net/huyangyamin/article/details/77743624&quot;&gt;https://blog.csdn.net/huyangyamin/article/details/77743624&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 15:34:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>前言 本章讲ZooKeeper重要的机制，Watcher特性。ZooKeeper允许客户端向服务端注册Watcher监听，当服务端一些指定事件触发了这个Watcher，那么就会向指定客户端发送一个事件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GrimMjx/p/10922480.html</dc:identifier>
</item>
<item>
<title>数据库扩展表设计过程记录 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10919740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10919740.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;这两天需要实现一个动态表单设计，面对着属性的不确定，要能够容纳不同的属性进来，之前也接触过这方面的设计，但是没有设计好，导致问题太多，这一次参考一些前辈们的经验后，再次尝试一番，通过动态设计表结构，以达到任务要求。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、常用动态表结构设计方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　1、动态修改表，适应变化。&lt;/p&gt;
&lt;p&gt;　　2、预留字段实现动态表结构(伪动态)。&lt;/p&gt;
&lt;p&gt;　　3、将动态属性全部保存在一个字段中，xml或是json格式保存(版本号+通用列)。&lt;/p&gt;
&lt;p&gt;　　4、表结构和表数据分离，xml形式分别保存表结构和表数据。&lt;/p&gt;
&lt;p&gt;　　5、横向表转纵向表(属性字段行存储)。&lt;/p&gt;
&lt;p&gt;　　对于这几种方式，或许不同的选用适用不同的形式，我选择了最后一种来实现我现有的设计，这种方式个人感觉更加灵活，可以更方便的扩展属性(适合的才是最好的)。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、横向表转纵向表初步设计&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　首先看下横向表的设计，如果采用横向表，因为业务的需要，要容纳好几种行业的信息进来，这样一来整张表的字段数将会非常多，从设计或是维护角度来讲，这都是一个棘手的芋头，因此传统的横向表设计不能满足现有的需求了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527215318636-1434148158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　按照横向表转纵向表的思路对表结构进行更改，通过设置成键值对形式，得到如下表结构。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527220659802-1847602494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　在这里可能有一个情况得想清楚了，我们每一次增加一条记录的时候，记录内的信息是作为同一批添加进来的，反过来，当我从数据库中取出数据时，也应该需要把同一批的记录信息取出来，因此在上面的设计中再加入一个GroupId用来区分同一批次的数据，而至于属性的重复量很大，之后将进行优化处理。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527220718218-1926552670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在看到这个结构时，对于动态扩充属性来讲，已经是达到了我的预期了，对于数据库设计时，将检测指标及限值均设置成字符串的，分组号我采用时间戳的形式进行存储，当然也可以采用其它更为稳妥的方式，如Guid或是自定义ID等。&lt;/p&gt;
&lt;p&gt;　　对于好多检测指标名称出现重复情况，我将这部分单独抽出来一张表用于存储检测指标属性，需要注意的是此处的名称需要在某个检测项目编号下唯一，该部分属性先在界面上呈现，其次呈现对应的数据，如果某列增加或删除了，对应展示行也就空着了一个数据或是消失了一个数据单元，而对于改了指标名称或是对外的展示名称，都不会影响数据的存储，通过默认值可以使得有些常用值不要再二次输入，减少工作量。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527221138968-1619935917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在具体检测限值中完成对检测指标的关联，加入一列完成外键关联，同时对原有表内存在的列可以进行优化，因为这些信息都在检测指标中存在了，不必要的数据冗余还是不存在为好。单从现在的表结构来看，当我们按照在增加一些额外的属性时，可以做到不要去修改表结构，而只需要对表内数据进行管理即可。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527221700790-1157804374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;三、代码实现过程&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　此处我采用Asp.Net Core MVC并利用Razor语法，更为方便的完成表单展示工作，当然对于这部分工作，采用js或模板等等都是可以快速完成的。&lt;/p&gt;
&lt;p&gt;　　1、首先对于界面添加检测指标的设计，遵循普通的表单设计方式即可，此处增加了两个隐藏元素，为适用于编辑场景而存在，此处快速略过提交到后台并保存到数据库的过程，可能需要在后台验证提交的名称的唯一性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-fluid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form&quot;&lt;/span&gt;&lt;span&gt; lay-filter&lt;/span&gt;&lt;span&gt;=&quot;layuiadmin-form-evaluationIndex&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;padding: 15px 0 0 0;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;@Model.Id&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;evaluationStandardId&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;@Model.EvaluationStandardId&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;名称&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; lay-verify&lt;/span&gt;&lt;span&gt;=&quot;required&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入名称&quot;&lt;/span&gt;&lt;span&gt; autocomplete&lt;/span&gt;&lt;span&gt;=&quot;off&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;layui-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;显示名称&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;displayName&quot;&lt;/span&gt;&lt;span&gt; lay-verify&lt;/span&gt;&lt;span&gt;=&quot;required&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入显示名称&quot;&lt;/span&gt;&lt;span&gt; autocomplete&lt;/span&gt;&lt;span&gt;=&quot;off&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;layui-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;默认值&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;defaultValue&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入默认值&quot;&lt;/span&gt;&lt;span&gt; autocomplete&lt;/span&gt;&lt;span&gt;=&quot;off&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;layui-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-btn layui-hide&quot;&lt;/span&gt;&lt;span&gt; lay-submit lay-filter&lt;/span&gt;&lt;span&gt;=&quot;LAY-evaluationIndex-front-submit&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;LAY-evaluationIndex-front-submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;立即提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　2、对于增加具体的检测记录，需要先读取到整个检测项目下的所有检测指标，然后实现生成表单的过程，按照如下的思路一步一步实现：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527222416282-794537383.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于第一步，从数据库获取指定检测项目的检测指标，该步可以直接利用提供的id做一次查询即可得到相应的指标集合。然后在前端循环输出时，利用Razor语法完成动态渲染Html，生成label和input元素，依照之前设计检测指标时的name唯一，可以在此处设计表单时指定name属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-fluid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form&quot;&lt;/span&gt;&lt;span&gt; lay-filter&lt;/span&gt;&lt;span&gt;=&quot;layuiadmin-form-evaluationLimitValue&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;padding: 15px 0 0 0;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        @foreach (var item in Model)
        {
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@item.DisplayName&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;@item.Name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;@item.DefaultValue&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;@(&quot;&lt;/span&gt;&lt;span&gt;请输入&quot;+item.DisplayName)&quot; autocomplete&lt;/span&gt;&lt;span&gt;=&quot;off&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;layui-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-btn layui-hide&quot;&lt;/span&gt;&lt;span&gt; lay-submit lay-filter&lt;/span&gt;&lt;span&gt;=&quot;LAY-evaluationLimitValue-front-submit&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;LAY-evaluationLimitValue-front-submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;立即提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　接下来可以完成表单的输入工作了，并提交到后台完成保存到数据库中，如我此处，新增记录时，保存到数据库前，先生成分组号，以此来区分这些指标下的数据是一个批次的，然后完成保存到数据库的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task ConvertTableToEvaluationLimitValues(TestItemCode_EvaluationStandardSubItem assignTestItemCode, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; evaluationLimitValues)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; groupId =&lt;span&gt; DateTimeHelper.GetTimeStamp();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationIndexes =&lt;span&gt; assignTestItemCode.EvaluationStandardSubItem.EvaluationStandard.EvaluationIndexes.ToList();

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; evaluationLimitValues)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationIndex = evaluationIndexes.Where(e =&amp;gt; e.Name ==&lt;span&gt; item.Key).FirstOrDefault();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (evaluationIndex == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationLimitValue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EvaluationLimitValue(evaluationIndex.Id, assignTestItemCode.Id, item.Value, groupId);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.InsertAsync(evaluationLimitValue);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　对于这部分的设计，做一点更改也适用于更新操作，但是得注意到，更新表单时，表单上展示的检测指标可能存在增加或是删除的情形，因此对于存在的记录我们可以展示出来，不存在的则留空，当提交到数据库时，需要做一次比对过程，对那部分增加的检测指标需要保存到数据库中，当然对于已有的检测指标也存在变更的可能，因此需要做一次判断，当有变更时更新，没有时不处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task UpdateEvaluationLimitValues(TestItemCode_EvaluationStandardSubItem assignTestItemCode, &lt;span&gt;string&lt;/span&gt; groupId, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; evaluationLimitValues)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前的检测指标&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; evaluationIndexes =&lt;span&gt; assignTestItemCode.EvaluationStandardSubItem.EvaluationStandard.EvaluationIndexes.ToList();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标分组已存在的检测限值&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; results = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.GetAll()
        .Where(e &lt;/span&gt;=&amp;gt; e.TestItemCode_EvaluationStandardSubItemId == assignTestItemCode.Id &amp;amp;&amp;amp; e.GroupId ==&lt;span&gt; groupId)
        .Include(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.EvaluationIndex).ToListAsync();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已存在的检测限值对应于检测指标名称列表&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; existedEvaluationLimitValueNameList = results.Select(r =&amp;gt;&lt;span&gt; r.EvaluationIndex.Name).ToList();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需新增的检测限值记录&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; addEvaluationLimitValueList =&lt;span&gt; evaluationLimitValues.Keys.Except(existedEvaluationLimitValueNameList).ToList();
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; addEvaluationLimitValueList)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationIndexId = evaluationIndexes.Where(e =&amp;gt; e.Name ==&lt;span&gt; key).FirstOrDefault().Id;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationLimitValue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EvaluationLimitValue(evaluationIndexId, assignTestItemCode.Id, evaluationLimitValues[key], groupId);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.InsertAsync(evaluationLimitValue);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除记录&lt;/span&gt;
&lt;span&gt;        evaluationLimitValues.Remove(key);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新已有检测限值记录值&lt;/span&gt;
    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; evaluationLimitValues.Keys)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; editEvaluationLimitValues = results.Where(r =&amp;gt; r.EvaluationIndex.Name == key &amp;amp;&amp;amp; r.LimitValue !=&lt;span&gt; evaluationLimitValues[key]).FirstOrDefault();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (editEvaluationLimitValues != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            editEvaluationLimitValues.LimitValue &lt;/span&gt;=&lt;span&gt; evaluationLimitValues[key];
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.UpdateAsync(editEvaluationLimitValues);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　3、完成检测记录的表格展示，此处需要遵循一个原则，就是先展示检测指标，也就是先展示属性列，其次展示数据值，只有相应的属性列存在，展示的数据值才有意义，通过指定的编号Id获取相应的属性集合并展示在前端，利用Razor语法循环输出th元素，来产生表格行头。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-col-xs12&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-table&quot;&lt;/span&gt;&lt;span&gt;
            lay-data&lt;/span&gt;&lt;span&gt;=&quot;{height: 'full-100', id:'mainList'}&quot;&lt;/span&gt;&lt;span&gt;
            lay-filter&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt; lay-size&lt;/span&gt;&lt;span&gt;=&quot;xs&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;lay-data&lt;/span&gt;&lt;span&gt;=&quot;{checkbox:true, fixed: true}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                @foreach (var item in Model)
                {
                    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;lay-data&lt;/span&gt;&lt;span&gt;=&quot;{field:'@item.Name'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@Html.Raw(item.DisplayName)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                }
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;lay-data&lt;/span&gt;&lt;span&gt;=&quot;{fixed:'right', width:240, align:'center', toolbar: '#barList'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　表格展示完毕时便是数据开始呈现的时机，通过获取检测限值中的记录，注意这里的记录会有多条存在的，我们需要将纵向表结构转换成横向的json格式，用于前端读取，注意这里得把分组号加入进来，这是属于同一批次的标识。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527225947244-1910562538.png&quot; alt=&quot;&quot; width=&quot;1316&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过纵向转横向，可以得到字典类型的list集合，然后再返回前序列化成json格式，便是前端需要的格式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; ConvertEvaluationLimitValuesToTable(Guid assignedTestItemCodeId)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分组后的评价限值&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; results = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.GetAll()
        .Where(e &lt;/span&gt;=&amp;gt; e.TestItemCode_EvaluationStandardSubItemId ==&lt;span&gt; assignedTestItemCodeId)
        .Include(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.EvaluationIndex)
        .GroupBy(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.GroupId).ToListAsync();

    List&lt;/span&gt;&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; convertResultList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt;&lt;span&gt; results)
    {
        Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; tempResultList = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            { EvaluationLimitValue.GetGroupIdName(), result.ElementAt(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GroupId }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加分组号GroupId&lt;/span&gt;
&lt;span&gt;        };

        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result)
        {
            tempResultList.Add(item.EvaluationIndex.Name, item.LimitValue);
        }

        convertResultList.Add(tempResultList);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; convertResultList;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;四、设计实现效果&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　1、实现动态增加属性列，尽管没有太丰富的功能，但是已经满足我现有的需求了，或许还能依据此得到更复杂的表单属性列设计。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527230617422-762272980.gif&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、增加表单具体值，依据增加的属性列完成相应值填写。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527230750766-1440723637.gif&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;384&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、再次增加属性列后增加表单具体值，实现属性列的增加删除和修改后，仍然可以适用而无需手动修改表结构。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527230935327-543914222.gif&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　至此，动态表单的简单设计工作已经完成，过程较为简单，没有融入更多的比如多选，单选、数值型的设计，纯字符类型设计工作。&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;2019-&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;05-&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;27,望技术有成后能回来看见自己的脚步&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 27 May 2019 15:16:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>这两天需要实现一个动态表单设计，面对着属性的不确定，要能够容纳不同的属性进来，之前也接触过这方面的设计，但是没有设计好，导致问题太多，这一次参考一些前辈们的经验后，再次尝试一番，通过动态设计表结构，以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CKExp/p/10919740.html</dc:identifier>
</item>
</channel>
</rss>