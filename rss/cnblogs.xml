<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python 命令行之旅：使用 click 实现 git 命令 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12050450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12050450.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201911/759200-20191104220305180-1564290170.jpg&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;br/&gt;作者：HelloGitHub-&lt;strong&gt;Prodesire&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.5660377358491&quot;&gt;
&lt;p&gt;HelloGitHub 的《讲解开源项目》系列，项目地址：&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot; class=&quot;uri&quot;&gt;https://github.com/HelloGitHub-Team/Article&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;在前面五篇介绍 &lt;code&gt;click&lt;/code&gt; 的文章中，我们全面了解了 &lt;code&gt;click&lt;/code&gt; 的强大能力。按照惯例，我们要像使用 &lt;code&gt;argparse&lt;/code&gt; 和 &lt;code&gt;docopt&lt;/code&gt; 一样使用 &lt;code&gt;click&lt;/code&gt; 来实现 git 命令。&lt;/p&gt;
&lt;p&gt;本文的关注点并不在 &lt;code&gt;git&lt;/code&gt; 的各种命令是如何实现的，而是怎么使用 &lt;code&gt;click&lt;/code&gt; 去打造一个实用命令行程序，代码结构是怎样的。因此，和 &lt;code&gt;git&lt;/code&gt; 相关的操作，将会使用 &lt;code&gt;gitpython&lt;/code&gt; 库来简单实现。&lt;/p&gt;
&lt;p&gt;为了让没读过 &lt;code&gt;使用 xxx 实现 git 命令&lt;/code&gt;（&lt;code&gt;xxx&lt;/code&gt; 指 &lt;code&gt;argparse&lt;/code&gt; 和 &lt;code&gt;docopt&lt;/code&gt;） 的小伙伴也能读明白本文，我们仍会对 &lt;code&gt;git&lt;/code&gt; 常用命令和 &lt;code&gt;gitpython&lt;/code&gt; 做一个简单介绍。&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;本系列文章默认使用 Python 3 作为解释器进行讲解。
若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二git-常用命令&quot;&gt;二、git 常用命令&lt;/h2&gt;
&lt;p&gt;当你写好一段代码或增删一些文件后，会用如下命令查看文件状态：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git status&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确认文件状态后，会用如下命令将的一个或多个文件（夹）添加到暂存区：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git add [pathspec [pathspec ...]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用如下命令提交信息：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git commit -m &quot;your commit message&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后使用如下命令将提交推送到远程仓库：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git push&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将使用 &lt;code&gt;click&lt;/code&gt; 和 &lt;code&gt;gitpython&lt;/code&gt; 库来实现这 4 个子命令。&lt;/p&gt;
&lt;h2 id=&quot;三关于-gitpython&quot;&gt;三、关于 gitpython&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gitpython.readthedocs.io/en/stable/intro.html&quot;&gt;gitpython&lt;/a&gt; 是一个和 &lt;code&gt;git&lt;/code&gt; 仓库交互的 Python 第三方库。&lt;br/&gt;我们将借用它的能力来实现真正的 &lt;code&gt;git&lt;/code&gt; 逻辑。&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;pip install gitpython&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四思考&quot;&gt;四、思考&lt;/h2&gt;
&lt;p&gt;在实现前，我们不妨先思考下会用到 &lt;code&gt;click&lt;/code&gt; 的哪些功能？整个程序的结构是怎样的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;click&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git&lt;/code&gt; 的 4 个子命令的实现其实对应于四个函数，每个函数使用 &lt;code&gt;click&lt;/code&gt; 的 &lt;code&gt;command&lt;/code&gt; 来装饰。&lt;br/&gt;而对于 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt;，则分别需要表示参数的 &lt;code&gt;click.argument&lt;/code&gt; 和表示选项的 &lt;code&gt;click.option&lt;/code&gt; 来装饰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序结构上：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实例化 &lt;code&gt;Git&lt;/code&gt; 对象，供全局使用&lt;/li&gt;
&lt;li&gt;定义 &lt;code&gt;cli&lt;/code&gt; 函数作为命令组，也就是整个命令程序的入口&lt;/li&gt;
&lt;li&gt;定义四个命令对应的实现函数 &lt;code&gt;status&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;commit&lt;/code&gt;、&lt;code&gt;push&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;则基本结构如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import os
import click
from git.cmd import Git

git = Git(os.getcwd())


@click.group()
def cli():
    &quot;&quot;&quot;
    git 命令行
    &quot;&quot;&quot;
    pass


@cli.command()
def status():
    &quot;&quot;&quot;
    处理 status 命令
    &quot;&quot;&quot;
    pass


@cli.command()
@click.argument('pathspec', nargs=-1)
def add(pathspec):
    &quot;&quot;&quot;
    处理 add 命令
    &quot;&quot;&quot;
    pass


@cli.command()
@click.option('-m', 'msg')
def commit(msg):
    &quot;&quot;&quot;
    处理 -m &amp;lt;msg&amp;gt; 命令
    &quot;&quot;&quot;
    pass


@cli.command()
def push():
    &quot;&quot;&quot;
    处理 push 命令
    &quot;&quot;&quot;
    pass


if __name__ == '__main__':
    cli()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们将一步步地实现我们的 &lt;code&gt;git&lt;/code&gt; 程序。&lt;/p&gt;
&lt;h2 id=&quot;五实现&quot;&gt;五、实现&lt;/h2&gt;
&lt;p&gt;假定我们在 &lt;a href=&quot;https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/click-git.py&quot;&gt;click-git.py&lt;/a&gt; 文件中实现我们的 &lt;code&gt;git&lt;/code&gt; 程序。&lt;/p&gt;
&lt;h3 id=&quot;status-子命令&quot;&gt;5.1 status 子命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;status&lt;/code&gt; 子命令不接受任何参数和选项，因此其实现函数只需 &lt;code&gt;cli.command()&lt;/code&gt; 装饰。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@cli.command()
def status():
    &quot;&quot;&quot;
    处理 status 命令
    &quot;&quot;&quot;
    cmd = ['git', 'status']
    output = git.execute(cmd)
    click.echo(output)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难看出，我们最后调用了真正的 &lt;code&gt;git status&lt;/code&gt; 来实现，并打印了输出。&lt;/p&gt;
&lt;h3 id=&quot;add-子命令&quot;&gt;5.2 add 子命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;add&lt;/code&gt; 子命令相对于 &lt;code&gt;status&lt;/code&gt; 子命令，需要接受任意个 pathspec 参数，因此增加一个 &lt;code&gt;click.argument&lt;/code&gt; 装饰器，并且在 &lt;code&gt;add&lt;/code&gt; 函数中需要增加同名的 &lt;code&gt;pathspec&lt;/code&gt; 入参。&lt;br/&gt;经 &lt;code&gt;click&lt;/code&gt; 处理后的 &lt;code&gt;pathspec&lt;/code&gt; 其实是个元组，和列表相加前，需要先转换为列表。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@cli.command()
@click.argument('pathspec', nargs=-1)
def add(pathspec):
    &quot;&quot;&quot;
    处理 add 命令
    &quot;&quot;&quot;
    cmd = ['git', 'add'] + list(pathspec)
    output = git.execute(cmd)
    click.echo(output)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们执行 &lt;code&gt;python3 click-git.py add --help&lt;/code&gt; 时，结果如下：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;Usage: click-git.py add [OPTIONS] [PATHSPEC]...

  处理 add 命令

Options:
  --help  Show this message and exit.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然 &lt;code&gt;git add&lt;/code&gt; 能接受任意多个 &lt;code&gt;pathspec&lt;/code&gt;，那么 &lt;code&gt;add(pathspec)&lt;/code&gt; 的参数其实改为复数形式更为合适，但我们又希望帮助信息中是单数形式，这就需要额外指定 &lt;code&gt;metavar&lt;/code&gt;，则有：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@cli.command()
@click.argument('pathspecs', nargs=-1, metavar='[PATHSPEC]...')
def add(pathspecs):
    &quot;&quot;&quot;
    处理 add 命令
    &quot;&quot;&quot;
    cmd = ['git', 'add'] + list(pathspecs)
    output = git.execute(cmd)
    click.echo(output)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;commit-子命令&quot;&gt;5.3 commit 子命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;add&lt;/code&gt; 子命令相对于 &lt;code&gt;status&lt;/code&gt; 子命令，需要接受 &lt;code&gt;-m&lt;/code&gt; 选项，因此增加一个 &lt;code&gt;click.option&lt;/code&gt; 装饰器，指定选项名称 &lt;code&gt;msg&lt;/code&gt;，并且在 &lt;code&gt;commit&lt;/code&gt; 函数中增加同名入参。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@cli.command()
@click.option('-m', 'msg')
def commit(msg):
    &quot;&quot;&quot;
    处理 -m &amp;lt;msg&amp;gt; 命令
    &quot;&quot;&quot;
    cmd = ['git', 'commit', '-m', msg]
    output = git.execute(cmd)
    click.echo(output)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;push-子命令&quot;&gt;5.4 push 子命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;push&lt;/code&gt; 子命令同 &lt;code&gt;status&lt;/code&gt; 子命令一样，不接受任何参数和选项，因此其实现函数只需 &lt;code&gt;cli.command()&lt;/code&gt; 装饰。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@cli.command()
def push():
    &quot;&quot;&quot;
    处理 push 命令
    &quot;&quot;&quot;
    cmd = ['git', 'push']
    output = git.execute(cmd)
    click.echo(output)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们就实现了一个简单的 &lt;code&gt;git&lt;/code&gt; 命令行，使用 &lt;code&gt;python click-git.py status&lt;/code&gt; 便可查询项目状态。&lt;/p&gt;
&lt;p&gt;非常方便的是，每个命令函数的 &lt;code&gt;docstring&lt;/code&gt; 都将作为这个命令的帮助信息，因此，当我们执行 &lt;code&gt;python3 click-git.py --help&lt;/code&gt; 会自动生成如下帮助内容：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;Usage: click-git.py [OPTIONS] COMMAND [ARGS]...

  git 命令行

Options:
  --help  Show this message and exit.

Commands:
  add     处理 add 命令
  commit  处理 -m &amp;lt;msg&amp;gt; 命令
  push    处理 push 命令
  status  处理 status 命令&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想看整个源码，请戳 &lt;a href=&quot;https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/click-git.py&quot;&gt;click-git.py&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;六小结&quot;&gt;六、小结&lt;/h2&gt;
&lt;p&gt;本文简单介绍了日常工作中常用的 &lt;code&gt;git&lt;/code&gt; 命令，然后提出实现它的思路，最终一步步地使用 &lt;code&gt;click&lt;/code&gt; 和 &lt;code&gt;gitpython&lt;/code&gt; 实现了 &lt;code&gt;git&lt;/code&gt; 程序。&lt;/p&gt;
&lt;p&gt;对比 &lt;code&gt;argparse&lt;/code&gt; 和 &lt;code&gt;click&lt;/code&gt; 的实现版本，你会发现使用 &lt;code&gt;click&lt;/code&gt; 来实现变得特定简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相较于 &lt;code&gt;argparse&lt;/code&gt;，子解析器、参数类型什么的统统不需要关心&lt;/li&gt;
&lt;li&gt;相较于 &lt;code&gt;docopt&lt;/code&gt;，参数解析和命令调用处理也不需要关心&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这无疑是 &lt;code&gt;click&lt;/code&gt; 最大的优势了。&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;click&lt;/code&gt; 的讲解将告一段落，回顾下 &lt;code&gt;click&lt;/code&gt; 的至简之道，你会爱上它。&lt;/p&gt;
&lt;p&gt;现在，你已学会了三个命令行解析库的使用了。但你以为这就够了吗？&lt;code&gt;click&lt;/code&gt; 已经够简单了吧，够直接了吧？但它仍然不是最简单的。&lt;/p&gt;
&lt;p&gt;在下篇文章中，将为大家介绍一个由谷歌出品的在 Python 界很火的命令行库 —— &lt;code&gt;fire&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;『讲解开源项目系列』&lt;/strong&gt;——让对开源项目感兴趣的人不再畏惧、让开源项目的发起者不再孤单。跟着我们的文章，你会发现编程的乐趣、使用和发现参与开源项目如此简单。欢迎留言联系我们、加入我们，让更多人爱上开源、贡献开源～&lt;/p&gt;
</description>
<pubDate>Tue, 17 Dec 2019 00:35:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub Prodesire HelloGitHub 的《讲解开源项目》系列，项目地址： 'https://github.com/HelloGitHub Team/Article'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12050450.html</dc:identifier>
</item>
<item>
<title>scikit-learn与数据预处理 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/12052417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/12052417.html</guid>
<description>[unable to retrieve full-text content]预处理操作是机器学习整个周期中必不可少的一个过程，也是最能快速改善模型性能的一个过程，往往稍微转换一下特征属性的形态，就能得到性能的极大提升。当然，数据预处理绝对也是耗时最长的一个过程，这一过程不仅要求洞悉整个数据集结构分布，还要探查每一个特征属性细节情况，并作出应对处理，使数据以最适合的状态传输给...</description>
<pubDate>Mon, 16 Dec 2019 23:51:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>预处理操作是机器学习整个周期中必不可少的一个过程，也是最能快速改善模型性能的一个过程，往往稍微转换一下特征属性的形态，就能得到性能的极大提升。当然，数据预处理绝对也是耗时最长的一个过程，这一过程不仅要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/12052417.html</dc:identifier>
</item>
<item>
<title>Docker私有仓库搭建与界面化管理 - LeoZhanggg</title>
<link>http://www.cnblogs.com/leozhanggg/p/12050322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leozhanggg/p/12050322.html</guid>
<description>
&lt;hr/&gt;&lt;h2&gt;一、关于Registry&lt;/h2&gt;
&lt;p class=&quot;p0&quot;&gt;官方的Docker hub是一个用于管理公共镜像的好地方，我们可以在上面找到我们想要的镜像，也可以把我们自己的镜像推送上去。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;但是有时候我们的使用场景需要我们拥有一个私有的镜像仓库用于管理我们自己的镜像。这个可以通过开源软件Registry来达成目的。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt; Registry在github上有两份代码：老代码库和新代码库。老代码是采用python编写的，存在pull和push的性能问题，出到0.9.1版本之后就标志为deprecated，不再继续开发。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt; 从2.0版本开始就到在新代码库进行开发，新代码库是采用go语言编写，修改了镜像id的生成算法、registry上镜像的保存结构，大大优化了pull和push镜像的效率。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt; 官方在Docker hub上提供了registry的镜像，我们可以直接使用该registry镜像来构建一个容器，搭建我们自己的私有仓库服务。&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;二、搭建Registry&lt;/h2&gt;
&lt;h4&gt;首先搜索并拉取镜像&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker search registry　　　　&lt;span&gt;# 建议先搜索一下，可以看一下相关的镜像，说不定哪天就有更好的镜像了&lt;/span&gt;
docker pull registry&lt;/span&gt;　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 标签可以不加，因为当前最新就是v2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;　　运行一个registry容器&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker run -d \            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 后台运行&lt;/span&gt;
--name registry-srv \    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定容器名&lt;/span&gt;
--restart=always \        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置自动启动&lt;/span&gt;
-p 5000:5000 \            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 端口映射宿主机，通过宿主机地址访问&lt;/span&gt;
-v /opt/zwx-registry:/var/lib/registry \     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把镜像存储目录挂载到本地，方便管理和持久化&lt;/span&gt;
-v /opt/zwx-registry/srv-config.yml:/etc/docker/registry/config.yml \    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把配置文件挂载到本地，方便修改和保存&lt;/span&gt;
registry
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　srv-config.yml内容如下&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　标红delete参数设置为true，是为了让仓库支持删除功能。默认没有这个参数，也就是不能删除仓库镜像。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
version: 0.1&lt;span&gt;
log:
  fields:
    service: registry
storage:
&lt;strong&gt;&lt;span&gt;  delete:
    enabled: &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;true&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
  cache:
    blobdescriptor: inmemory
  filesystem:
    rootdirectory: &lt;/span&gt;/var/lib/&lt;span&gt;registry
http:
  addr: :&lt;/span&gt;5000&lt;span&gt;
  headers:
    X&lt;/span&gt;-Content-Type-&lt;span&gt;Options: [nosniff]
health:
  storagedriver:
    enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    interval: 10s
    threshold: &lt;/span&gt;3
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　注册https协议（否则push安全认证过不去）&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　需要通过本地仓库下载镜像，均需要配置&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
vim /etc/docker/daemon.json　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认无此文件，需自行添加，有则追加以下内容。&lt;/span&gt;&lt;span&gt;
{ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insecure-registries&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xx.xx.xx.xx:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] }　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定IP地址或域名&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
systemctl daemon&lt;/span&gt;-reload    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 守护进程重启&lt;/span&gt;
systemctl restart docker    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重启docker服务&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;镜像上传与下载&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker push xx.xx.xx.xx:5000/nginx            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一定要注明仓库地址，否则会报错&lt;/span&gt;
docker pull xx.xx.xx.xx:5000/nginx
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　查看仓库镜像信息&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -XGET http://xx.xx.xx.xx:5000/v2/&lt;span&gt;_catalog&lt;span&gt;　　　　# 查看仓库镜像列表（也可以通过windows浏览器打开查看）&lt;/span&gt;
curl &lt;/span&gt;-XGET http://xx.xx.xx.xx:5000/v2/&lt;span&gt;image_name&lt;/span&gt;/tags/list　　&lt;span&gt;# 查看指定应用镜像tag&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;hr/&gt;&lt;h2&gt;三、搭建Registry web&lt;/h2&gt;
&lt;h4&gt;首先搜索并拉取镜像&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker search docker-registry-&lt;span&gt;web
docker pull hyper&lt;/span&gt;/docker-registry-web　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个镜像用的人较多&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;　　运行一个registry web容器&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker run -d \            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 后台运行&lt;/span&gt;
--name registry-web \    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定容器名&lt;/span&gt;
--restart=always \        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置自动启动&lt;/span&gt;
-p 8000:8080 \            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 端口映射宿主机，通过宿主机地址访问&lt;/span&gt;
-v /opt/zwx-registry/web-config.yml:/etc/config.yml \    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把配置文件挂载到本地，方便修改和保存&lt;/span&gt;
hyper/docker-registry-web
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;　　web-config.yml文件内容如下&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;标红&lt;/span&gt;&lt;span&gt;readonly参数设置为false，是为了web页面可以显示删除按钮。默认是true，只读状态，没有删除按钮，只能查看。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;registry:
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Docker registry url&lt;/span&gt;
  url: http://10.88.77.32:5000/&lt;span&gt;v2
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Docker registry fqdn&lt;/span&gt;
  name: localhost:5000
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; To allow image delete, should be false&lt;/span&gt;
  &lt;span&gt;readonly: false&lt;/span&gt;&lt;span&gt;
  auth:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Disable authentication&lt;/span&gt;
    enabled: &lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1059616/201912/1059616-20191216172801430-1490140624.png&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择任意应用镜像库，即可查看到该镜像的所有tag信息，每个tag后面都有个删除按钮（默认没有，配置参考config.yml）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1059616/201912/1059616-20191216172830271-680915343.png&quot; alt=&quot;&quot; width=&quot;808&quot; height=&quot;186&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;h2&gt;四、快捷部署&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　集群模式可以通过docker stack快速部署registry和registry web。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　新建配置文件srv-config.yml、web-config.yml放到指定路径，再新建docker-compose.yml文件，执行命令即可。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker stack deploy -c docker-compose.yml RGT
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
version: '3.7&lt;span&gt;'　　　　　　&lt;span&gt;# docker stack 需要是3.0以上版本&lt;/span&gt;
services:
  registry&lt;/span&gt;-&lt;span&gt;srv:　　　　　　&lt;span&gt;# 服务名&lt;/span&gt;
    image: registry
    
    ports:　　　　　　　　　&lt;span&gt;# 映射端口
      &lt;/span&gt;&lt;/span&gt;- 5000:5000&lt;span&gt;
      
    volumes:　　　　　　　　&lt;span&gt;# 挂载镜像路径和配置文件，注意修改路径与实际一致
      &lt;/span&gt;&lt;/span&gt;- /opt/zwx-registry:/var/lib/&lt;span&gt;registry
      &lt;/span&gt;- /opt/zwx-registry/srv-config.yml:/etc/docker/registry/&lt;span&gt;config.yml
      
    deploy:　　　　　　　　&lt;span&gt;# 设置单任务，并约束主节点运行&lt;/span&gt;
      mode: replicated
      replicas: &lt;/span&gt;1&lt;span&gt;
      placement:
        constraints:
          &lt;/span&gt;- node.role ==&lt;span&gt; manager
      
  registry&lt;/span&gt;-&lt;span&gt;web:　　　　　　&lt;span&gt;# 服务名　　&lt;/span&gt;
    image: hyper&lt;/span&gt;/docker-registry-&lt;span&gt;web
    
    ports:　　　　　　　　&lt;span&gt;# 映射端口
      &lt;/span&gt;&lt;/span&gt;- 8000:8080&lt;span&gt;
    
    volumes:　　　　　　&lt;span&gt;# 挂载配置文件，注意修改路径与实际一致
      &lt;/span&gt;&lt;/span&gt;- /opt/zwx-registry/web-config.yml:/conf/&lt;span&gt;config.yml
      
    environment:
      &lt;/span&gt;- REGISTRY_URL=http://registry-srv:5000/&lt;span&gt;v2
      &lt;/span&gt;- REGISTRY_NAME=localhost:5000&lt;span&gt;
    
    deploy:　　　　　　　　&lt;span&gt;# 设置单任务，并约束主节点运行&lt;/span&gt;
      mode: replicated
      replicas: &lt;/span&gt;1&lt;span&gt;
      placement:
        constraints:
          &lt;/span&gt;- node.role ==&lt;span&gt; manager&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;
&lt;blockquote readability=&quot;6.0666666666667&quot;&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;span&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/leozhanggg/&quot; target=&quot;_blank&quot;&gt;Leozhang&lt;/a&gt;gg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处： &lt;a class=&quot;ng-star-inserted&quot; href=&quot;https://www.cnblogs.com/leozhanggg/p/12050322.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/leozhanggg/p/12050322.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 16 Dec 2019 17:51:00 +0000</pubDate>
<dc:creator>LeoZhanggg</dc:creator>
<og:description>一、关于Registry 官方的Docker&amp;#160;hub是一个用于管理公共镜像的好地方，我们可以在上面找到我们想要的镜像，也可以把我们自己的镜像推送上去。 但是有时候我们的使用场景需要我们拥有一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leozhanggg/p/12050322.html</dc:identifier>
</item>
<item>
<title>秉心说，不一样的 2019 - 秉心说</title>
<link>http://www.cnblogs.com/bingxinshuo/p/12052126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingxinshuo/p/12052126.html</guid>
<description>&lt;p&gt;即将迎来人生的第二十七个年头。&lt;/p&gt;
&lt;p&gt;我想，不管过去多久，&lt;strong&gt;2019&lt;/strong&gt; ，都将是我人生中极其特殊的一年。&lt;/p&gt;
&lt;h2 id=&quot;我开始认真写博客了&quot;&gt;2019，我开始认真写博客了。&lt;/h2&gt;
&lt;p&gt;第一次写博客可以追溯到三四年前刚毕业那会，在 csdn 上瞎写，大概写了有五六篇就荒废了。今年认认真真写了 50+ 篇，除了几篇译文之外，全部都是原创技术文，所有文章我都同步到 &lt;a href=&quot;https://github.com/lulululbj/Pyramid&quot;&gt;这个仓库&lt;/a&gt; 了。博客内容涉及到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK 源码解析系列&lt;/li&gt;
&lt;li&gt;AOSP 源码解析系列&lt;/li&gt;
&lt;li&gt;Android 反编译系列&lt;/li&gt;
&lt;li&gt;Kotlin 系列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要说我能坚持写博客的原因是什么？其实很简单，写作是一个 &lt;strong&gt;正向反馈&lt;/strong&gt; 的过程。自我学习，总结输出，得到读者反馈，反过来又会倒逼你去学习。还真有好几次读者本着打破砂锅问到底的精神，把我问懵了，我只得深入研究再去给出答复。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/user/586eff908d6d81005879507d&quot;&gt;掘金&lt;/a&gt; 是我最活跃的博客平台，简单纯粹，正如它的 Slogan 一样，“一个帮助开发者成长的社区”。的确，掘金也陪伴了我这一年的成长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/16/16f0f20d82a47270?w=340&amp;amp;h=357&amp;amp;f=png&amp;amp;s=21411&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今年目标是十万阅读，还有半个月，努努力，应该就算完成目标了。&lt;/p&gt;
&lt;p&gt;每一位开发者都应该养成写博客的好习惯。之前在群里看到有同学抱怨某某知识点看了没多久就忘记了，这我深有体会。以前阅读 AOSP 的一些文章，看过就忘，两礼拜一过没有任何印象。在我认认真真花了几个小时阅读相关源码并输出一篇文章之后，真的，想记不住都难。即使真的忘记了，掏出自己的文章来复习，我想肯定是事半功倍的。&lt;/p&gt;
&lt;h2 id=&quot;我开始做开源项目了&quot;&gt;2019，我开始做开源项目了。&lt;/h2&gt;
&lt;p&gt;今年，确切的说是下半年，认认真真的维护了三个仓库。分别是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/12/16efab5cac680043?w=952&amp;amp;h=266&amp;amp;f=png&amp;amp;s=22597&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululerbj/wanandroid&quot;&gt;wanandroid&lt;/a&gt; 是我的 Jetpack MVVM 试验品，会在上面做很多新鲜的尝试。目前的技术栈是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ViewModel + LiveData + Databinding 完成 Jetpack MVVM 基础框架&lt;/li&gt;
&lt;li&gt;Kotlin Coroutines 负责异步任务&lt;/li&gt;
&lt;li&gt;Koin 负责依赖注&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个项目还是比较受欢迎的，莫名的好几次在不同的群里被人认出来了（手动脸红），也因此认识了一些小伙伴，有学生，有老鸟，大家一起讨论技术的氛围我大概很久没有经历过了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/12/16efabedb53e8865?w=733&amp;amp;h=136&amp;amp;f=png&amp;amp;s=31847&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然有愧大佬这个称号，但每次看到这种评论心里还是很开心的。Android 本身作为一个开源操作系统，作为开发者也应该在适当的时候反哺社区。Wanandroid 也会基于 Jetpack 持续更新，欢迎大家关注。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/AndroidUtilCodeKTX&quot;&gt;AndroidUtilCodeKTX&lt;/a&gt; 是我在用 Blankj 的 AndroidUtilCode 时诞生的想法，Blankj 的库的确很好用，但是在 Kotlin 中照搬 Java 的用法实在有点不合适，所以着手写了这么一个库。&lt;/p&gt;
&lt;p&gt;它并不是 AndroidUtilCode 的 Kotlin 翻译版本，我也从来没有把它定位于此，更多的还是要从 Kotlin 的角度去写，当然肯定少不了剽窃 Blankj 的代码，哈哈，在此向 Blankj 表示极大的感谢。目前已经积累了一些工具类，但个人进度还是很缓慢的，有兴趣的话，可以抛来 PR ，一起维护吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/Box&quot;&gt;Box&lt;/a&gt; 的诞生源于 Trinea 的开发助手，不知道小伙伴们有没有使用过，对于里面的反编译功能我就特好奇是如何实现的，当然开发助手并不开源。最后发现直接把 jadx 搬过来就好了。&lt;/p&gt;
&lt;p&gt;Box 的定位就是一些稀奇古怪的功能了，可能哪天看到了什么功能，就会想办法搬过来。最近看到了 MT 的修改 Apk 功能，就准备实现它，当然 MT 也是不开源的。关于修改 Apk 功能，其实已经有了大概的思路，距离完成还需要一段时间，到时候也会开源出来。&lt;/p&gt;
&lt;p&gt;另外还想做一个抓包的功能，全局的，不是自己应用内的抓包。暂时只想到通过 Vpn 拦截所有 IP 包，具体的实现逻辑还有待思考，协议方面的知识也有所欠缺，希望 2020 年有机会把这个捣鼓出来。&lt;/p&gt;
&lt;p&gt;还要特别感谢 issue 区的同学，给我挑毛病，提建议，给方案&lt;/p&gt;
&lt;p&gt;要说写博客和做开源项目耗时间吗？答案是肯定的。我的业余时间基本都贡献给了技术输出和开源，而且我的两个孩子都在身边，时间并不富裕。最开始做这些事情，我的想法是树立个人品牌，说直白点，就是想红。然而大半年过来了，显然我并没有红。但是我坚持下来了，我体会到了开源带给我的乐趣。我想，余下的一生，我仍然会以此为乐趣。&lt;/p&gt;
&lt;p&gt;无他，为热爱尔。&lt;/p&gt;
&lt;h2 id=&quot;我迎来了我的女儿&quot;&gt;2019，我迎来了我的女儿。&lt;/h2&gt;
&lt;p&gt;虽然要求主题与技术相关，但是作为一个奶爸程序员，我不得不分（炫）享（耀）一下我的生活。&lt;/p&gt;
&lt;p&gt;2019，我的小天使诞生了。&lt;/p&gt;
&lt;p&gt;在这里首先要对老婆说一声，辛苦了！她的孕吐反应极其严重，九个月的孕期简直就是一种煎熬。不过幸运的是，最后是我们想要的结果。&lt;/p&gt;
&lt;p&gt;都说女儿是爸爸上辈子的情人，和我那个恨不得每天揍他一顿的儿子相比，的确有很多不一样的情愫在里面。一个是哇哇的哭，另一个是嘤嘤的哭。一个动若脱兔，另一个静若处子。一个想培养成程序员，另一个肯定不想培养成程序媛。&lt;/p&gt;
&lt;p&gt;每天看着自己的两个孩子，幸福感油然而生。作为自己生命的另一种存在，这种感觉，我想只有切身体会才能感同身受。&lt;/p&gt;
&lt;p&gt;很期待他们上小学，上高中，甚至成人的样子，话说妈妈给你们的升学宴的酒都备好了。又想时间可以再慢一些，因为现在所经历的每一刻都是以后再也不会经历的了。&lt;/p&gt;
&lt;p&gt;正如关注我的公众号自动回复里的那句话，“秉心识本源,于事少凝滞。” 希望两个孩子永远可以秉持内心做自己，爸爸妈妈永远是你们坚强的后盾。&lt;/p&gt;
&lt;h2 id=&quot;立个-flag&quot;&gt;立个 Flag ？&lt;/h2&gt;
&lt;p&gt;立 Flag 好像成了年终总结必备，其实我是很不情愿做这种事的。相比一整年的目标，我更喜欢分解出一个一个切实可行的阶段性目标。&lt;/p&gt;
&lt;p&gt;最后还是来罗列一下我的 2020 小目标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公众号关注数加个 0&lt;/li&gt;
&lt;li&gt;每月至少输出一篇技术文章&lt;/li&gt;
&lt;li&gt;持续维护开源项目以及添加新功能（编辑Apk 和全局抓包）&lt;/li&gt;
&lt;li&gt;技术上还是以深度为主，广度为辅，持续学习&lt;/li&gt;
&lt;li&gt;刷算法，刷算法，刷算法，重要的事情说三遍&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大致先列这么多，2020 还有半个月，我可能还会回来更新(删除) flag 。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;感谢孩子，让我认识到做爸爸的责任。&lt;/p&gt;
&lt;p&gt;感谢老婆，在背后默默的付出，无微不至的照顾一家人的生活。&lt;/p&gt;
&lt;p&gt;感谢父母，一辈子都在为孩子操劳。&lt;/p&gt;
&lt;p&gt;感谢所有和我发生交集的同学，朋友，家人，程序员们，我的每一点进步，也少不了你们。&lt;/p&gt;
&lt;p&gt;最后分享一句话，努力的人运气一定不会差 ！&lt;/p&gt;
&lt;p&gt;2020，一起努力 ！&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;文章同步微信公众号： &lt;strong&gt;&lt;code&gt;秉心说&lt;/code&gt;&lt;/strong&gt; ， 专注 Java 、Kotlin、Android 原创知识分享。&lt;/p&gt;
&lt;p&gt;更多最新原创文章，扫码关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/27/16a5f352eab602c4?w=2800&amp;amp;h=800&amp;amp;f=jpeg&amp;amp;s=178470&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Dec 2019 15:40:00 +0000</pubDate>
<dc:creator>秉心说</dc:creator>
<og:description>即将迎来人生的第二十七个年头。 我想，不管过去多久， 2019 ，都将是我人生中极其特殊的一年。 2019，我开始认真写博客了。 第一次写博客可以追溯到三四年前刚毕业那会，在 csdn 上瞎写，大概写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingxinshuo/p/12052126.html</dc:identifier>
</item>
<item>
<title>【前端知乎系列】ArrayBuffer 和 Blob 对象 - 王平安</title>
<link>http://www.cnblogs.com/pingan8787/p/12051861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingan8787/p/12051861.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/16/16f0f050b78f8e44?w=900&amp;amp;h=383&amp;amp;f=png&amp;amp;s=73814&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.4861660079051&quot;&gt;
&lt;p&gt;本文首发在 &lt;a href=&quot;http://www.pingan8787.com/&quot;&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;个人博客&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;5.6199095022624&quot;&gt;
&lt;div readability=&quot;6.5050505050505&quot;&gt;更多丰富的前端学习资料，可以查看我的 Github:&lt;span class=&quot;juejin-editor-bold&quot;&gt; 《&lt;a href=&quot;https://github.com/pingan8787/Leo-JavaScript&quot;&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;Leo-JavaScript&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;》，内容涵盖&lt;span class=&quot;juejin-editor-bold&quot;&gt;数据结构与算法、HTTP、&lt;span class=&quot;juejin-editor-bold&quot;&gt;Hybrid、&lt;span class=&quot;juejin-editor-bold&quot;&gt;面试题、&lt;span class=&quot;juejin-editor-bold&quot;&gt;React、&lt;span class=&quot;juejin-editor-bold&quot;&gt;Angular、&lt;span class=&quot;juejin-editor-bold&quot;&gt;TypeScript和&lt;span class=&quot;juejin-editor-bold&quot;&gt;Webpack等等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;点个 Star 不迷路~&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer&lt;/code&gt; 对象与 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 对象大家或许不太陌生，常见于文件上传操作处理（如处理图片上传预览等问题）。&lt;/p&gt;
&lt;p&gt;那么本文将与大家深入介绍两者。&lt;/p&gt;
&lt;h2&gt;一、ArrayBuffer 对象&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer&lt;/code&gt; 对象是 ES6 才纳入正式 ECMAScript 规范，是 JavaScript 操作二进制数据的一个接口。&lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer&lt;/code&gt; 对象是以数组的语法处理二进制数据，也称二进制数组。&lt;/p&gt;
&lt;p&gt;介绍 &lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer&lt;/code&gt; 对象还需介绍 &lt;code class=&quot;juejin-editor-code&quot;&gt;TypedArray&lt;/code&gt; 视图和 &lt;code class=&quot;juejin-editor-code&quot;&gt;DataView&lt;/code&gt; 视图，本文不具体介绍，详细可以查看阮一峰老师《ECMAScript 6 入门 ArrayBuffer》 章节。&lt;/p&gt;
&lt;h3&gt;1. 概念介绍&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer&lt;/code&gt; 对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（&lt;code class=&quot;juejin-editor-code&quot;&gt;TypedArray&lt;/code&gt;视图和&lt;code class=&quot;juejin-editor-code&quot;&gt;DataView&lt;/code&gt;视图）来读写，视图的作用是以指定格式解读二进制数据。&lt;/p&gt;
&lt;p&gt;关于 &lt;code class=&quot;juejin-editor-code&quot;&gt;TypedArray&lt;/code&gt; 视图和 &lt;code class=&quot;juejin-editor-code&quot;&gt;DataView&lt;/code&gt; 视图 ，可以查看阮一峰老师《ECMAScript 6 入门 ArrayBuffer》 章节的介绍。&lt;/p&gt;
&lt;h3&gt;2. 对象使用&lt;/h3&gt;
&lt;p&gt;浏览器原生提供 &lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer()&lt;/code&gt; 构造函数，用来生成实例。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const buffer = new ArrayBuffer(32);
&lt;/pre&gt;
&lt;p&gt;上面代码表示实例对象 &lt;code class=&quot;juejin-editor-code&quot;&gt;buffer&lt;/code&gt; 占用 32 个字节。&lt;/p&gt;
&lt;h3&gt;3. 实例属性和方法&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer&lt;/code&gt; 对象有实例属性 &lt;code class=&quot;juejin-editor-code&quot;&gt;byteLength&lt;/code&gt; ，表示当前实例占用的内存字节长度（单位字节），一单创建就不可变更（只读）：&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const buffer = new ArrayBuffer(32);buffer.byteLength; // 32
&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer&lt;/code&gt; 对象有实例方法 &lt;code class=&quot;juejin-editor-code&quot;&gt;slice()&lt;/code&gt;，用来复制一部分内存。&lt;/p&gt;
&lt;p&gt;参数如下：&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;start，整数类型，表示开始复制的位置。默认从 0 开始。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;end，整数类型，表示结束复制的位置（不包括结束的位置）。如果省略，则表示复制到结束。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const buffer = new ArrayBuffer(32);const buffer2 = buffer.slice(0);
&lt;/pre&gt;
&lt;h3&gt;4. 兼容性&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/16/16f0efffe098b614?w=975&amp;amp;h=835&amp;amp;f=png&amp;amp;s=60159&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片来自 MDN&lt;/p&gt;
&lt;h2&gt;二、Blob 对象&lt;/h2&gt;
&lt;h3&gt;1. 概念介绍&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 全称：&lt;code class=&quot;juejin-editor-code&quot;&gt;Binary Large Object&lt;/code&gt; （二进制大型对象）。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 对象表示一个二进制文件的数据内容，通常用来读写文件，比如一个图片文件的内容就可以通过 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 对象读写。&lt;/p&gt;
&lt;p&gt;与 &lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer&lt;/code&gt; 区别：&lt;/p&gt;
&lt;h3&gt;2. 对象使用&lt;/h3&gt;
&lt;p&gt;浏览器原生提供 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob()&lt;/code&gt; 构造函数，用来生成实例。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 的内容由参数数组中给出的值的串联组成。&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const leoBlob = new Blob(array [, options]);
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;成员可以是一个由 &lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBuffer&lt;/code&gt; ,  &lt;code class=&quot;juejin-editor-code&quot;&gt;ArrayBufferView&lt;/code&gt; , &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; ,  &lt;code class=&quot;juejin-editor-code&quot;&gt;DOMString&lt;/code&gt; 等对象构成的 &lt;code class=&quot;juejin-editor-code&quot;&gt;Array&lt;/code&gt; ，或者其他类似对象的混合体，它将会被放进 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt;。&lt;code class=&quot;juejin-editor-code&quot;&gt;DOMStrings&lt;/code&gt;会被编码为&lt;code class=&quot;juejin-editor-code&quot;&gt;UTF-8&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;options&lt;/code&gt; 目前可能有两个属性：&lt;code class=&quot;juejin-editor-code&quot;&gt;type&lt;/code&gt; 和 &lt;code class=&quot;juejin-editor-code&quot;&gt;endings&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;endings&lt;/code&gt; 用于指定包含行结束符 &lt;code class=&quot;juejin-editor-code&quot;&gt;\n&lt;/code&gt; 的字符串如何被写入，默认值 &lt;code class=&quot;juejin-editor-code&quot;&gt;transparent&lt;/code&gt;。它只有这两个值：&lt;code class=&quot;juejin-editor-code&quot;&gt;native&lt;/code&gt; （代表行结束符会被更改为适合宿主操作系统文件系统的换行符）和 &lt;code class=&quot;juejin-editor-code&quot;&gt;transparent&lt;/code&gt; （代表会保持blob中保存的结束符不变）。&lt;/p&gt;
&lt;p&gt;使用案例：&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const leoHtmlFragment = ['&amp;lt;a id=&quot;a&quot;&amp;gt;&amp;lt;b id=&quot;b&quot;&amp;gt;hey leo！&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;']; // 一个包含 DOMString 的数组const leoBlob = new Blob(leoHtmlFragment, {type : 'text/html'});   // 得到 blob
&lt;/pre&gt;
&lt;p&gt;该代码中，实例对象 &lt;code class=&quot;juejin-editor-code&quot;&gt;leoBlob&lt;/code&gt; 包含的是字符串。生成实例时，指定数据类型为 &lt;code class=&quot;juejin-editor-code&quot;&gt;text/html&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还可以使用 Blob 保存 JSON 数据：&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const obj = { hello: 'leo' };const blob = new Blob([ JSON.stringify(obj) ], {type : 'application/json'});
&lt;/pre&gt;
&lt;h3&gt;3. 实例属性和方法&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 具有两个实例属性：&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;size&lt;/code&gt;：文件的大小，单位为字节。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;type&lt;/code&gt;：文件的 MIME 类型。如果类型无法确定，则返回空字符串。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const leoHtmlFragment = ['&amp;lt;a id=&quot;a&quot;&amp;gt;&amp;lt;b id=&quot;b&quot;&amp;gt;hey leo！&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;']; // 一个包含 DOMString 的数组const leoBlob = new Blob(leoHtmlFragment, {type : 'text/html'});   // 得到 blobleoBlob.size; // 38leoBlob.type; // &quot;text/html&quot;
&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 实例方法：&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const newBlob = oldBlob.slice([start [, end [, contentType]]])
&lt;/pre&gt;
&lt;p&gt;包含三个参数：&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;start&lt;/code&gt;，可选，起始的字节位置，默认 0；&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;end&lt;/code&gt;，可选，结束的字节位置，默认 &lt;code class=&quot;juejin-editor-code&quot;&gt;size&lt;/code&gt; 属性的值，不包含该位置；&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;contentType&lt;/code&gt;，可选，新实例的数据类型（默认为空字符串）；&lt;/p&gt;
&lt;h3&gt;4. 兼容性&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/16/16f0f0022794f43a?w=1002&amp;amp;h=272&amp;amp;f=png&amp;amp;s=18621&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片来自 MDN&lt;/p&gt;
&lt;h3&gt;5. 实际案例&lt;/h3&gt;
&lt;h4&gt;5.1 获取文件信息&lt;/h4&gt;
&lt;p&gt;文件选择器 &lt;code class=&quot;juejin-editor-code&quot;&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; 用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的 &lt;code class=&quot;juejin-editor-code&quot;&gt;value&lt;/code&gt; 属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。&lt;/p&gt;
&lt;p&gt;文件选择器返回一个 &lt;code class=&quot;juejin-editor-code&quot;&gt;FileList&lt;/code&gt; 对象，该对象是个类数组对象，每个成员都是一个 &lt;code class=&quot;juejin-editor-code&quot;&gt;File&lt;/code&gt; 实例对象。&lt;code class=&quot;juejin-editor-code&quot;&gt;File&lt;/code&gt; 实例对象是一个特殊的 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 实例，增加了 &lt;code class=&quot;juejin-editor-code&quot;&gt;name&lt;/code&gt; 和 &lt;code class=&quot;juejin-editor-code&quot;&gt;lastModifiedDate&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;也包括拖放 API 的 &lt;code class=&quot;juejin-editor-code&quot;&gt;dataTransfer.files&lt;/code&gt; 返回的也是一个 &lt;code class=&quot;juejin-editor-code&quot;&gt;FileList&lt;/code&gt; 对象，成员也是 &lt;code class=&quot;juejin-editor-code&quot;&gt;File&lt;/code&gt; 实例对象。&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// HTML 代码如下// &amp;lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple onchange=&quot;fileinfo(this.files)&quot;/&amp;gt;function fileinfo(files) {  for (let i = 0; i &amp;lt; files.length; i++) {    let f = files[i];    console.log(      f.name, // 文件名，不含路径      f.size, // 文件大小，Blob 实例属性      f.type, // 文件类型，Blob 实例属性      f.lastModifiedDate // 文件的最后修改时间    );  }}
&lt;/pre&gt;
&lt;h4&gt;5.2 下载文件&lt;/h4&gt;
&lt;p&gt;在 AJAX 请求中，指定 &lt;code class=&quot;juejin-editor-code&quot;&gt;responseType&lt;/code&gt; 属性为 &lt;code class=&quot;juejin-editor-code&quot;&gt;blob&lt;/code&gt; ，皆可以下下载一个 Blob 对象。&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
function getBlob(url, callback) {  const xhr = new XMLHttpRequest();  xhr.open('GET', url);  xhr.responseType = 'blob';  xhr.onload = function () {    callback(xhr.response);  }  xhr.send(null);}
&lt;/pre&gt;
&lt;p&gt;然后，&lt;code class=&quot;juejin-editor-code&quot;&gt;xhr.response&lt;/code&gt; 拿到的就是一个 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 对象。&lt;/p&gt;
&lt;h4&gt;5.3 生成 URL&lt;/h4&gt;
&lt;p&gt;浏览器允许使用 &lt;code class=&quot;juejin-editor-code&quot;&gt;URL.createObjectURL()&lt;/code&gt; 方法，针对 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 对象生成一个临时&lt;code class=&quot;juejin-editor-code&quot;&gt;URL&lt;/code&gt;，以便于某些 &lt;code class=&quot;juejin-editor-code&quot;&gt;API&lt;/code&gt; 使用。&lt;/p&gt;
&lt;p&gt;如作为图片预览的 URL。&lt;/p&gt;
&lt;p&gt;这个 URL 以 &lt;code class=&quot;juejin-editor-code&quot;&gt;blob://&lt;/code&gt; 开头，表明对应一个 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与 &lt;code class=&quot;juejin-editor-code&quot;&gt;data://URL&lt;/code&gt;（URL 包含实际数据）和 &lt;code class=&quot;juejin-editor-code&quot;&gt;file://URL&lt;/code&gt;（本地文件系统里面的文件）都不一样。&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const droptarget = document.getElementById('droptarget');droptarget.ondrop = function (e) {  const files = e.dataTransfer.files;  for (let i = 0; i &amp;lt; files.length; i++) {    let type = files[i].type;    if (type.substring(0,6) !== 'image/')      continue;    let img = document.createElement('img');    img.src = URL.createObjectURL(files[i]);    img.onload = function () {      this.width = 100;      document.body.appendChild(this);      URL.revokeObjectURL(this.src);    }  }}
&lt;/pre&gt;
&lt;p&gt;代码中，通过为拖放的图片文件生成一个 URL，作为预览的缩略图。&lt;/p&gt;
&lt;p&gt;浏览器处理 Blob URL 就跟普通的 URL 一样，如果 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 &lt;code class=&quot;juejin-editor-code&quot;&gt;GET&lt;/code&gt; 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。&lt;/p&gt;
&lt;h4&gt;5.4 读取文件&lt;/h4&gt;
&lt;p&gt;取得 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 对象以后，可以通过 &lt;code class=&quot;juejin-editor-code&quot;&gt;FileReader&lt;/code&gt; 对象，读取 &lt;code class=&quot;juejin-editor-code&quot;&gt;Blob&lt;/code&gt; 对象的内容，即文件内容。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;FileReader&lt;/code&gt; 对象提供四个方法。将 Blob 对象作为参数传入，然后以指定的格式返回。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;FileReader.readAsText()&lt;/code&gt;：返回文本，需要指定文本编码，默认为 UTF-8。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;FileReader.readAsArrayBuffer()&lt;/code&gt;：返回 ArrayBuffer 对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;FileReader.readAsDataURL()&lt;/code&gt;：返回 Data URL。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code class=&quot;juejin-editor-code&quot;&gt;FileReader.readAsBinaryString()&lt;/code&gt;：返回原始的二进制字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是 &lt;code class=&quot;juejin-editor-code&quot;&gt;FileReader.readAsText()&lt;/code&gt; 方法的例子，用来读取文本文件：&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// HTML 代码如下// &amp;lt;input type='file' onchange='readfile(this.files[0])'&amp;gt;&amp;lt;/input&amp;gt;// &amp;lt;pre id='output'&amp;gt;&amp;lt;/pre&amp;gt;function readfile(f) {  let reader = new FileReader();  reader.readAsText(f);  reader.onload = function () {    let text = reader.result;    let out = document.getElementById('output');    out.innerHTML = '';    out.appendChild(document.createTextNode(text));  }  reader.onerror = function(e) {    console.log('Error', e);  };}
&lt;/pre&gt;
&lt;p&gt;下面是 &lt;code class=&quot;juejin-editor-code&quot;&gt;FileReader.readAsArrayBuffer()&lt;/code&gt; 方法的例子，用于读取二进制文件：&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// HTML 代码如下// &amp;lt;input type=&quot;file&quot; onchange=&quot;typefile(this.files[0])&quot;&amp;gt;&amp;lt;/input&amp;gt;function typefile(file) {  // 文件开头的四个字节，生成一个 Blob 对象  let slice = file.slice(0, 4);  let reader = new FileReader();  // 读取这四个字节  reader.readAsArrayBuffer(slice);  reader.onload = function (e) {    let buffer = reader.result;    // 将这四个字节的内容，视作一个32位整数    let view = new DataView(buffer);    let magic = view.getUint32(0, false);    // 根据文件的前四个字节，判断它的类型    switch(magic) {      case 0x89504E47: file.verified_type = 'image/png'; break;      case 0x47494638: file.verified_type = 'image/gif'; break;      case 0x25504446: file.verified_type = 'application/pdf'; break;      case 0x504b0304: file.verified_type = 'application/zip'; break;    }    console.log(file.name, file.verified_type);  };}
&lt;/pre&gt;
&lt;h2&gt;三、参考资料&lt;/h2&gt;

</description>
<pubDate>Mon, 16 Dec 2019 14:41:00 +0000</pubDate>
<dc:creator>王平安</dc:creator>
<og:description>本文首发在&amp;#160;个人博客 更多丰富的前端学习资料，可以查看我的 Github:&amp;#160;《Leo-JavaScript》，内容涵盖数据结构与算法、HTTP、Hybrid、面试题、React、A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pingan8787/p/12051861.html</dc:identifier>
</item>
<item>
<title>从零开始openGL——五、光线追踪 - ITryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/12051657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/12051657.html</guid>
<description>&lt;p&gt;前面介绍了基本图形、模型、曲线的绘制，但是，在好像还没有感受到那种3D游戏里一些能惊艳到自己的效果，即真实感还不是很足。这篇文章中介绍的光线追踪，是实现真实感必不可少的。拿下面的两张图片来对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201912/1413964-20191216195444550-423738907.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201912/1413964-20191216195552903-177988951.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比一下是不是被下面这张图片的效果惊艳到了？可以很明显感觉到，下面的这个图片效果要好的多。这篇博客将介绍如何实现这样的效果。&lt;/p&gt;

&lt;p&gt;这里暂时只介绍光线与球面和三角面片的求交&lt;/p&gt;
&lt;h2 id=&quot;光线与球面相交&quot;&gt;光线与球面相交&lt;/h2&gt;
&lt;p&gt;射线的方程：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ R(t) = A+tD \]&lt;/span&gt;&lt;br/&gt;球面的隐式方程：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ (X-C)^2=r^2 \]&lt;/span&gt;&lt;br/&gt;联立两式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ (A+tD-C)^2=r^2 \]&lt;/span&gt;&lt;br/&gt;然后通过判别式：&lt;span class=&quot;math display&quot;&gt;\[\Delta=4[(A-C) \cdot D]^2 - 4(A-C)^2+r^2\]&lt;/span&gt;来判断是否相交。&lt;/p&gt;
&lt;p&gt;交点法向量：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ N=\frac{P-C}{||P-C||} \]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool Sphere::intersectLocal( const ray&amp;amp; r, isect&amp;amp; i ) const
{
    // YOUR CODE HERE:
    // 光线与球面相交
    // Add sphere intersection code here.
    Vec3d A = r.getPosition();
    Vec3d D = r.getDirection();
    Vec3d C= Vec3&amp;lt;double&amp;gt;();
    double _r = 1.0;
    double a = D.length2();
    double b = 2 * (A - C) * D;
    double c = (A - C).length2() - _r;
    double delta = b * b - 4 * a * c;
    // it currently ignores all spheres and just return false.
    if (delta &amp;gt;= 0) {
        double t1 = (-b + sqrt(delta)) / (2 * a);
        double t2 = (-b - sqrt(delta)) / (2 * a);
        if (t1 &amp;lt;= RAY_EPSILON)
            return false;
        else {
            double t;
            if (t2 &amp;lt;= RAY_EPSILON) {
                t = t1;
                i.outsideTheObject = false;
            }
            else {
                t = t2;
                i.outsideTheObject = true;
            }
            // 焦点设置
            i.obj = this;
            i.setT(t);
            Vec3d P = r.at(t);
            Vec3d Normal = P;
            if (D*Normal &amp;gt; 0)
                Normal = -Normal;
            Normal.normalize();
            i.setN(Normal);
            return true;
        }
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;光线与三角面片相交&quot;&gt;光线与三角面片相交&lt;/h2&gt;
&lt;p&gt;射线的方程：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ R(t) = A+tD \]&lt;/span&gt;&lt;br/&gt;三角面片点法式方程：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ N(p-p_1)=0 \]&lt;/span&gt;&lt;br/&gt;联立两式得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ t=\frac{N\cdot p_1 - N \cdot A}{n\cdot D} \]&lt;/span&gt;&lt;br/&gt;求出t后，便得到交点坐标，然后可通过同向法来判别交点是否在平面内。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201912/1413964-20191216201244006-897746440.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;// Calculates and returns the normal of the triangle too.
bool TrimeshFace::intersectLocal(const ray&amp;amp; r, isect&amp;amp; i) const
{
    // YOUR CODE HERE:
    // Add triangle intersection code here.
    // it currently ignores all triangles and just return false.
    //
    // Note that you are only intersecting a single triangle, and the vertices
    // of the triangle are supplied to you by the trimesh class.
    //
    // You should retrieve the vertices using code like this:
    //
    // const Vec3d&amp;amp; a = parent-&amp;gt;vertices[ids[0]];
    // const Vec3d&amp;amp; b = parent-&amp;gt;vertices[ids[1]];
    // const Vec3d&amp;amp; c = parent-&amp;gt;vertices[ids[2]];
    const Vec3d&amp;amp; a = parent-&amp;gt;vertices[ids[0]];
    const Vec3d&amp;amp; b = parent-&amp;gt;vertices[ids[1]];
    const Vec3d&amp;amp; c = parent-&amp;gt;vertices[ids[2]];

    Vec3d edge1 = b - a;
    Vec3d edge2 = c - a;
    // 计算平面法向量
    Vec3d nor = edge1 ^ edge2;
    nor.normalize();

    // 判断是否与平面平行
    float x = nor * r.getDirection();
    if (x == 0)
        return false;
    // Ax + By + Cz = d
    float d = nor * a;
    float t = (d - nor * r.getPosition()) / x;
    if (t &amp;lt;= RAY_EPSILON)
        return false;
    Vec3d intersection_point = r.at(t);
    Vec3d edge3 = intersection_point - a;
    // 同向法判断是否在平面内
    if (((b - a) ^ (intersection_point - a)) * nor &amp;lt;= 0)
        return false;
    else if (((c - b) ^ (intersection_point - b)) * nor &amp;lt;= 0)
        return false;
    else if (((a - c) ^ (intersection_point - c)) * nor &amp;lt;= 0)
        return false;
    else {
        //交点设置
        i.obj = this;
        i.setT(t);
        i.setN(nor);
        return true;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;当然，这里还可以使用重心坐标法来实现&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在现实场景中，光线也是会衰减的，比如看同一场景，距离远近不同看到的清晰度也就不同，这是距离衰减。还有阴影衰减，当有物体遮挡住部分光的时候，会形成一定的阴影，这就是阴影衰减产生的效果。&lt;/p&gt;
&lt;h2 id=&quot;距离衰减&quot;&gt;距离衰减&lt;/h2&gt;
&lt;p&gt;点光源：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ A_{j}^{d i s t}=\min \left\{1, \frac{1}{a_{j}+b_{j} r_{j}+c_{j} r_{j}^{2}}\right\} \]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;double PointLight::distanceAttenuation( const Vec3d&amp;amp; P ) const
{
    // You'll need to modify this method to attenuate the intensity 
    // of the light based on the distance between the source and the 
    // point P.  For now, we assume no attenuation and just return 1.0
    Vec3d d = P - position;
    double r = d.length(); //距离
    return min(1.0, 1.0 / (constantTerm + linearTerm * r + quadraticTerm * r*r));
//  return 1.0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;平行光源：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;double DirectionalLight::distanceAttenuation( const Vec3d&amp;amp; P ) const
{
    // distance to light is infinite, so f(di) goes to 0.  Return 1.
    return 1.0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;阴影衰减&quot;&gt;阴影衰减&lt;/h2&gt;
&lt;p&gt;点光源：&lt;/p&gt;
&lt;p&gt;首先判断光线是否被遮挡，然后再判断是否超出光强所能打到的距离&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Vec3d PointLight::shadowAttenuation(const Vec3d&amp;amp; P) const
{
    // YOUR CODE HERE:
    // You should implement shadow-handling code here.
    Vec3d d = getDirection(P);
    isect i;
    ray shadowRay(P, d);
    if (this-&amp;gt;getScene()-&amp;gt;intersect(shadowRay, i)) {
        double tLight = (P - position).length();
        if (i.t &amp;lt; tLight)
            return Vec3d(0, 0, 0);
        else
            return Vec3d(1, 1, 1);
    }
    return Vec3d(1,1,1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;平行光：&lt;/p&gt;
&lt;p&gt;只需判断是否被遮挡即可&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Vec3d DirectionalLight::shadowAttenuation( const Vec3d&amp;amp; P ) const
{
    // YOUR CODE HERE:
    Vec3d d = getDirection(P);
    isect i;
    ray shadowRay(P, d);
    if (this-&amp;gt;getScene()-&amp;gt;intersect(shadowRay, i)) {
        return Vec3d(0, 0, 0);
    }
    // You should implement shadow-handling code here.
    return Vec3d(1,1,1);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;先来份伪代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201912/1413964-20191216211341038-1741803530.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;光线跟踪中的四种射线：&lt;/p&gt;
&lt;p&gt;光线追踪的过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201912/1413964-20191216213926085-1554638990.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;phong光照模型&quot;&gt;phong光照模型&lt;/h2&gt;
&lt;p&gt;由物体表面上一点&lt;em&gt;P&lt;/em&gt;反射到视点的光强I为环境光的反射光强&lt;span class=&quot;math inline&quot;&gt;\(I_e\)&lt;/span&gt;、理想漫反射光强&lt;span class=&quot;math inline&quot;&gt;\(I_d\)&lt;/span&gt;、和镜面反射光&lt;span class=&quot;math inline&quot;&gt;\(I_s\)&lt;/span&gt;的总和，即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I=I_ak_a + I_lk_d(L \cdot N)+k_s\sum_{i=1}^{m}[I_{pi}(R \cdot V)^n] \]&lt;/span&gt;&lt;br/&gt;在washington CSE 457的课件中给出的公式为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ l_{\text {direct }}=k_{e}+k_{e} I_{L s}+\sum_{f} A_{j}^{\text {shadow}} A_{j}^{\text {dist}} I_{L j} B_{j}\left[k_{d}\left(\mathbf{N} \cdot \mathbf{L}_{j}\right)+k_{s}\left(\mathbf{N} \cdot \mathbf{H}_{j}\right)^{n_{s}}\right] \]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(k_d\)&lt;/span&gt;项表示漫反射，采用Lamber模型，&lt;span class=&quot;math inline&quot;&gt;\(k_s\)&lt;/span&gt;项表示镜面反射&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I_{d}=I_{p} K_{d} *(L \cdot N) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ I_{s}=k_{s} I_{p}(R \cdot V)^{n} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即可写出下列代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Apply the Phong model to this point on the surface of the object, returning
// the color of that point.
Vec3d Material::shade( Scene *scene, const ray&amp;amp; r, const isect&amp;amp; i ) const
{
    // YOUR CODE HERE

    // For now, this method just returns the diffuse color of the object.
    // This gives a single matte color for every distinct surface in the
    // scene, and that's it.  Simple, but enough to get you started.
    // (It's also inconsistent with the Phong model...)

    // Your mission is to fill in this method with the rest of the phong
    // shading model, including the contributions of all the light sources.
    // You will need to call both distanceAttenuation() and shadowAttenuation()
    // somewhere in your code in order to compute shadows and light falloff.
    if( debugMode )
        std::cout &amp;lt;&amp;lt; &quot;Debugging the Phong code (or lack thereof...)&quot; &amp;lt;&amp;lt; std::endl;

    Vec3d pos = r.at(i.t);
    Vec3d N = i.N;  
    N.normalize();
    Vec3d Ip, L, H, Atten;
    Vec3d shadow = ke(i) + prod(scene-&amp;gt;ambient(), ka(i));
    for (vector&amp;lt;Light*&amp;gt;::const_iterator litr = scene-&amp;gt;beginLights();
        litr != scene-&amp;gt;endLights(); ++litr) {
        Light* pLight = *litr;
        Ip = pLight-&amp;gt;getColor(pos);
        L = pLight-&amp;gt;getDirection(pos);
        H = -r.getDirection() + L;  H.normalize();
        Atten = pLight-&amp;gt;distanceAttenuation(pos)*pLight-&amp;gt;shadowAttenuation(pos);
        shadow += prod(Atten, prod(Ip, kd(i)*(L*N) + ks(i)*pow(H*N, 256)));
    }
    return shadow;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;反射方向&quot;&gt;反射方向&lt;/h2&gt;
&lt;p&gt;这里的反射指的是镜面反射&lt;/p&gt;
&lt;p&gt;计算公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ R=2(V\cdot N)N-V \]&lt;/span&gt;&lt;br/&gt;为什么是这样呢？首先来看&lt;span class=&quot;math inline&quot;&gt;\(V\cdot N\)&lt;/span&gt;，这里N是交点处的法向量，并且是单位向量，那个即视线在法向量上的投影，再乘法向量的两倍，得到的是平行四边形的对角线，减去V便是反射后的光线的方向。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201912/1413964-20191216214842115-901198474.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;折射方向&quot;&gt;折射方向&lt;/h2&gt;
&lt;p&gt;跟反射方向一样都是公式推导&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{array}{l}{\eta=\frac{\eta_{i}}{\eta_{t}}} \\ \eta_{i} \sin \theta_{i}=\eta_{t} \sin \theta_{t} \\ {\cos \theta_{i}=\mathbf{N} \cdot \mathbf{V}} \\ {\cos \theta_{t}=\sqrt{1-\eta^{2}\left(1-\cos ^{2} \theta_{i}\right)}} \\ {\mathbf{T}=\left(\eta \cos \theta_{i}-\cos \theta_{t}\right) \mathbf{N}-\eta \mathbf{V}}\end{array} \]&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201912/1413964-20191216215234596-11118047.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;终止条件&quot;&gt;终止条件&lt;/h2&gt;
&lt;p&gt;经过上述的介绍，很容易可以想到，什么时候终止光线追踪&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;该光线未碰到任何物体&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该光线碰到了背景&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;光线在经过许多次反射和折射以后，就会产生衰减，光线对于视点的光强贡献很小（小于某个设定值）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;光线反射或折射次数即跟踪深度大于一定值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，光线追踪的代码实现如下&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Do recursive ray tracing!  You'll want to insert a lot of code here
// (or places called from here) to handle reflection, refraction, etc etc.
Vec3d RayTracer::traceRay( const ray&amp;amp; r, 
    const Vec3d&amp;amp; thresh, int depth )
{
    isect i;

    if( scene-&amp;gt;intersect( r, i ) &amp;amp;&amp;amp; depth &amp;gt;= 0) {
        const Material&amp;amp; m = i.getMaterial();

        //计算光源直射
        Vec3d I = m.shade(scene, r, i);

        //计算反射递归
        Vec3d Q = r.at(i.t);
        Vec3d R = r.getDirection() - 2 * (r.getDirection()*i.N)*i.N;
        R.normalize();
        I += prod(m.kr(i), traceRay(ray(Q, R), thresh, depth - 1));

        //计算折射递归
        double cosThetaI = -i.N*r.getDirection();
        double eta = (i.outsideTheObject) ? 1.0003 / m.index(i) : m.index(i) / 1.0003;
        if (eta*eta*(1 - cosThetaI * cosThetaI) &amp;lt; 1) {
            double cosThetaT = sqrt(1 - eta * eta*(1 - cosThetaI * cosThetaI));
            Vec3d T = (eta*cosThetaI - cosThetaT)*i.N - eta * r.getDirection();
            T.normalize();
            I += prod(m.kt(i), traceRay(ray(Q, -T), thresh, depth - 1));
        }
        return I;
        // An intersection occured!  We've got work to do.  For now,
        // this code gets the material for the surface that was intersected,
        // and asks that material to provide a color for the ray.  

        // This is a great place to insert code for recursive ray tracing.
        // Instead of just returning the result of shade(), add some
        // more steps: add in the contributions from reflected and refracted
        // rays.

        //const Material&amp;amp; m = i.getMaterial();
        //return m.shade(scene, r, i);
    
    } else {
        // No intersection.  This ray travels to infinity, so we color
        // it according to the background color, which in this (simple) case
        // is just black.

        return Vec3d( 0.0, 0.0, 0.0 );
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;到这里，光线追踪也就差不多介绍完了，这一系列博客也算是收尾了。那天在课上听其他同学展示的的时候，说是我的世界有部分的开源源码，里面有一个可以实现光追的接口，有兴趣的小伙伴可以去康康，似乎那个仅仅实现光追还无法达到很好的效果，还要加上路线追踪，emmmmm。。。。期末考完有空了我再去康康，明早图形学考试祝我好运 orz&lt;/p&gt;
</description>
<pubDate>Mon, 16 Dec 2019 14:16:00 +0000</pubDate>
<dc:creator>ITryagain</dc:creator>
<og:description>前言 前面介绍了基本图形、模型、曲线的绘制，但是，在好像还没有感受到那种3D游戏里一些能惊艳到自己的效果，即真实感还不是很足。这篇文章中介绍的光线追踪，是实现真实感必不可少的。拿下面的两张图片来对比</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csu-lmw/p/12051657.html</dc:identifier>
</item>
<item>
<title>超燃| 2019 中国.NET 开发者峰会视频发布 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/12051570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/12051570.html</guid>
<description>&lt;p&gt;2019 年，注定会是 &lt;strong&gt;.NET Core&lt;/strong&gt; 社区发展的关键一年，诸多重大事件在这一年发生！正如大家所期待的那样，刷新中国 .NET 社区的年度盛会——&lt;strong&gt;2019 中国 .NET 开发者峰会（.NET Conf China 2019）&lt;/strong&gt;于 2019 年 11 月 9 日在上海中谷小南国花园酒店拉开帷幕，&lt;strong&gt;微软云（Microsoft Azure）&lt;/strong&gt;作为本次峰会战略合作伙伴，&lt;strong&gt;校宝在线&lt;/strong&gt;作为星牌赞助给予了峰会大力支持！随着大会第二天的工作坊在&lt;strong&gt;微软·上海 Reactor&lt;/strong&gt;顺利收官，本次大会完美谢幕。本次大会由于经费原因没有提供直播，一共28场Session 我们都做了录播，经过后期的视频整理，今天向大家发布课程视频。&lt;/p&gt;
&lt;p&gt;腾讯视频地址：&lt;a href=&quot;http://v.qq.com/vplus/d0d8c96b4435af67a25e9827b38c171e&quot;&gt;http://v.qq.com/vplus/d0d8c96b4435af67a25e9827b38c171e&lt;/a&gt; &lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody readability=&quot;57.231041814316&quot;&gt;&lt;tr readability=&quot;19.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;22&quot;&gt;
&lt;p&gt;My Developer Journey with .NET&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Justin Yoo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As a former HR person, I changed my career to a software developer&lt;/p&gt;
&lt;p&gt;15 years ago, and my developer journey started with .NET 1.0. Now,&lt;/p&gt;
&lt;p&gt;.NET Core 3.0 has been successfully launched,&lt;/p&gt;
&lt;p&gt;and I'd like to look back on how I and my work have dealt with&lt;/p&gt;
&lt;p&gt;.NET for their successful business,&lt;/p&gt;
&lt;p&gt;and what will be expected with the new .NET Core 3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;用ASP.NET Core构建可检测的高可用服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;肖伟宇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着现代化微服务架构的发展，&lt;/p&gt;
&lt;p&gt;系统故障的定位与快速恢复面临着诸多挑战，&lt;/p&gt;
&lt;p&gt;构建可检测的服务，&lt;/p&gt;
&lt;p&gt;帮助线上保障团队时刻掌控应用的运行状况越来越重要。&lt;/p&gt;
&lt;p&gt;本次分享会讲解如何让ASP.NET Core应用与现代化云基础设施完美融合&lt;/p&gt;
&lt;p&gt;，提升服务的可检测性，保障线上系统的可用率。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;在.NET Core下的机器学习&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;卢建晖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.NET Core 在机器学习的应用场景，&lt;/p&gt;
&lt;p&gt;除了ML.NET还会介绍一个非常棒的開源技術&lt;/p&gt;
&lt;p&gt;TensorFlow.NET ， Keras.NET.&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;ASP.NET Core基于K8S的微服务电商案例实践&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刘腾飞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个完整的电商项目微服务的实践过程，&lt;/p&gt;
&lt;p&gt;从选型、业务设计、架构设计到开发过程管理、&lt;/p&gt;
&lt;p&gt;以及上线运维的完整过程总结与剖析。&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;DNC 在 K8S 上的开发实践&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;桂素伟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本主题受众是架构师，开发人员，互联网企业IT运维人员.&lt;/p&gt;
&lt;p&gt;大纲：&lt;/p&gt;
&lt;p&gt;1 K8S对应用的要求&lt;/p&gt;
&lt;p&gt;2 DNC上K8S的优势&lt;/p&gt;
&lt;p&gt;3 K8S 下的 DNC 配置&lt;/p&gt;
&lt;p&gt;4 DNC 上分布式组件概览&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;微服务快速开发框架的设计&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;朱宗海&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从零开始搭建一个基于.net core平台的微服务快速开发框架，&lt;/p&gt;
&lt;p&gt;抛开深奥的理论与繁多的设计模式，&lt;/p&gt;
&lt;p&gt;以一线业务开发人员的需求视角，&lt;/p&gt;
&lt;p&gt;分享作为一个功能齐全的微服务开发框架到底要有哪些东西&lt;/p&gt;
&lt;p&gt;，又该如何去实现。&lt;/p&gt;
&lt;p&gt;目标受众：一线开发工程师，想体验架构师工作的高级开发工程师，&lt;/p&gt;
&lt;p&gt;入门级系统架构师&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;深入浅出Application Insights&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;罗彬&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;介绍如何将Application Insights用于生产上实践，&lt;/p&gt;
&lt;p&gt;并透过它发现/诊断问题。&lt;/p&gt;
&lt;p&gt;同时也会介绍如何将Application Insighs与其他体系相集成实现Devops&lt;/p&gt;
&lt;p&gt;（与发布系统整合，自动报表，历史数据持久化等）&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;.Net Core + 微信赋能企业级智能客服系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;苏震巍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;围绕目前需求猛增的微信及移动端企业智能客服业务，&lt;/p&gt;
&lt;p&gt;利用 .NET Core 的一系列优秀特性及 SignalR 模块打造全双工、&lt;/p&gt;
&lt;p&gt;跨微信/QQ/钉钉等应用平台、跨系统平台、跨终端、&lt;/p&gt;
&lt;p&gt;支持企业级并发的移动端客服系统。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;传统.NET应用向微服务架构迁移的实践经验&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;李望&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本次分享中，演讲嘉宾将基于真实项目案例，&lt;/p&gt;
&lt;p&gt;剖析.NET应用向微服务、.NET Core等技术栈迁移的具体收益，&lt;/p&gt;
&lt;p&gt;并且分享在迁移中技术和非技术的众多考量、以及保证业务连续性的一些方法论。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;使用.NET Core技术构建全新物联网电子标签系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;黄海鹏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于.net core构建物联网电子标签系统的案例分享&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;助力传统Net应用上云-kubernetes windows混合集群&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;张潇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分享让传统.NET应用程序容器化&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;编译又快又小的.NET Core最佳实践&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Anduin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;探索如何进行.NET Core的编译的最佳实践&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;当我们谈跨平台时，我们在谈些什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;蒋金楠&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. .NET Framework在过去十多年在跨平台上的尝试。&lt;/p&gt;
&lt;p&gt;2. .NET Core跨平台的实现有何不同？&lt;/p&gt;
&lt;p&gt;3. 基于.NET Standard的平台兼容性是如何实现的？&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;.NET 大数据实时计算&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;黄国石&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;纯.Net自研大数据实时计算平台，在中通快递服务数百亿包裹，&lt;/p&gt;
&lt;p&gt;处理数据万亿计！将分享大数据如何落地以及设计思路，技术重难点。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;.NET 技术架构下的混沌工程实践&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周国庆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.Net混沌工程-实践和成果，分享基于.Net技术的混沌事件注入框架和工具，&lt;/p&gt;
&lt;p&gt;通过混沌工程踩过的坑、发现的问题，以及问题的解决方案：容错降级、&lt;/p&gt;
&lt;p&gt;故障转移、超时治理、重试补偿、限流隔离等，最终做到问题闭环、&lt;/p&gt;
&lt;p&gt;质量归零  混沌工程-展望和规划，&lt;/p&gt;
&lt;p&gt;混沌工程Team建设和文化建设，持续执行改进&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;.NET Core下建立测试驱动的高效开发模型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梁规晓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么要编写测试用例&lt;/p&gt;
&lt;p&gt;-.NETCore下的测试框架&lt;/p&gt;
&lt;p&gt;-单元测试&lt;/p&gt;
&lt;p&gt;-文件监视测试&lt;/p&gt;
&lt;p&gt;-托管逐渐集成测试&lt;/p&gt;
&lt;p&gt;-CI/CD下的自动化测试&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;.NET Core 微服务测试最佳实践&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陈计节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从单元测试的分层和边界介绍微服务系统中的单元测试、&lt;/p&gt;
&lt;p&gt;集成测试、组件测试和契约测试等各类测试及其适应场景，&lt;/p&gt;
&lt;p&gt;总结 .NET Core 在微服务系统中进行自动化测试可用的&lt;/p&gt;
&lt;p&gt;各种工具和最佳实践&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;RPA AI .NET Core 与未来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;潘淳&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当下RPA平台主要采用.NET Framework框架，&lt;/p&gt;
&lt;p&gt;也限制了 RPA 只用于 Windows 平台。&lt;/p&gt;
&lt;p&gt;.NET Core 的开放与跨平台特性赋予RPA更大发展空间&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;Xamarin跨平台应用案例剖析&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周岳&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分享Xamarin的实际案例&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.8284023668639&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7.2426035502959&quot;&gt;
&lt;p&gt;Visual Studio Code —— .NET 开发利器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;韩骏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谈谈 Visual Studio Online，可以说是东半球首秀了！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjgwNTExNQ==&amp;amp;mid=2247484480&amp;amp;idx=2&amp;amp;sn=1ed6031d3d8ad50a025423d58f86a228&amp;amp;chksm=fc3e3ad4cb49b3c232cd1c3f701ded88aa8e30247a1baecbcb522d9db8e0e0cd4f7ede3aef8f&amp;amp;scene=21#wechat_redirect&quot;&gt;四种开发模式，未来已来&lt;/a&gt;！助力 .NET 开发&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;.NET 下的深度学习应用实践&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刘凡平&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 介绍.NET 下的深度学习技术；&lt;/p&gt;
&lt;p&gt;2. 通过案例实践介绍应用效果；&lt;/p&gt;
&lt;p&gt;3. 深度学习开发中的一些技巧；&lt;/p&gt;
&lt;p&gt;4. 介绍未来 .NET下深度学习相关技术可能的发展趋势；&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;.NET Core IOT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;杨守斌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本主题介绍了如何在物联网设备上安装和使用.NET Core 技术&lt;/p&gt;
&lt;p&gt;进行物联网边缘系统的开发.整个主题涉及到如下的部分:&lt;/p&gt;
&lt;p&gt;1. 在Raspberry Pi设备上安装.NET Core SDK,以 Raspberry Pi 3&lt;/p&gt;
&lt;p&gt;(也可以安装Windows 10 IOT Core版本)和Ubuntu系统为例.&lt;/p&gt;
&lt;p&gt;2. 利用.NET Core 操作树莓派的GPIO口&lt;/p&gt;
&lt;p&gt;3. 向Azure IOT Hub传输模拟数据.&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;Abp vNext 下一代ASP.NET Core开源应用程序框架&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梁士伟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ABP vNext是ASP.NET  Boilerplate下一代框架，&lt;/p&gt;
&lt;p&gt;它吸收了ASP.NET Boilerplate的经验并且重新设计。&lt;/p&gt;
&lt;p&gt;它基于领域驱动思想设计，拥有模块化、多租户、&lt;/p&gt;
&lt;p&gt;虚拟文件系统、审计、动态API等众多特性。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;21&quot;&gt;
&lt;p&gt;Unity DOTS： 高性能C# 开发技术&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;鲍健运&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;借助Unity全新高性能多线程的面向数据技术堆栈(DOTS)，&lt;/p&gt;
&lt;p&gt;开发者完全可以充分利用当今的多核处理器。&lt;/p&gt;
&lt;p&gt;Unity DOTS包含以下功能：C# Job System，&lt;/p&gt;
&lt;p&gt;用于高效运行多线程代码；实体组件系统 (ECS)，&lt;/p&gt;
&lt;p&gt;用于默认编写高性能代码；Burst编译器，&lt;/p&gt;
&lt;p&gt;用于生成高度优化的本地代码。&lt;/p&gt;
&lt;p&gt;通过本次演讲，听众将能了解这三大功能为Unity DOTS&lt;/p&gt;
&lt;p&gt;如何提供优异的性能表现。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;Neo- 通过.NET探索区块链技术&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;王龙飞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Neo是一个由社区驱动的开源平台，国内首个使用C#实现的区块链底层协议。&lt;/p&gt;
&lt;p&gt;Neo主网已稳定运行超过三年，其致力于通过分布式网络建设下一代互联网基础设施，&lt;/p&gt;
&lt;p&gt;为区块链技术大规模落地奠定基础，以实现智能经济的宏大愿景。&lt;/p&gt;
&lt;p&gt;本次分享主要聚焦于Neo区块链底层技术，&lt;/p&gt;
&lt;p&gt;以及如何通过NEO VS开发套提升C#智能合约开发友好度。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;无头浏览器Puppeteer在.NET中的应用和避坑&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;衣明志&lt;/strong&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Winform场景化窗体设计&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;郭腾飞&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;简单介绍Abp.io,分享对.NET Core和ABP框架的看法&lt;/td&gt;
&lt;td valign=&quot;top&quot;/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;相关文章：&lt;/p&gt;
</description>
<pubDate>Mon, 16 Dec 2019 13:45:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>2019 年，注定会是 .NET Core 社区发展的关键一年，诸多重大事件在这一年发生！正如大家所期待的那样，刷新中国 .NET 社区的年度盛会——2019 中国 .NET 开发者峰会（.NET C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/12051570.html</dc:identifier>
</item>
<item>
<title>【算法随记六】一段Matlab版本的Total Variation(TV)去噪算法的C语言翻译。 - Imageshop</title>
<link>http://www.cnblogs.com/Imageshop/p/12051536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Imageshop/p/12051536.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　最近看到一篇文章讲IMAGE DECOMPOSITION，里面提到了将图像分为Texture layer和Structure layer，测试了很多方法，对于那些具有非常强烈纹理的图像，总觉得用TV去燥的方法分离的结果都比其他的方法都要好（比如导向、双边），比如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201912/349293-20191216205722994-2138525273.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201912/349293-20191216205810682-125987177.png&quot; alt=&quot;&quot; width=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　再比如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201912/349293-20191216210027193-890378808.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201912/349293-20191216210031661-2067313895.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　可见TV可以把纹理很好的提取出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在应该能找到很多的TV代码，比如IPOL上就有，详见&lt;a href=&quot;%20http://www.ipol.im/pub/art/2013/61/&quot; target=&quot;_blank&quot;&gt; http://www.ipol.im/pub/art/2013/61/&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我在其他地方也见过一些，比如这里： &lt;a href=&quot;http://yu-li.github.io/paper/li_eccv14_jpeg.zip&quot; target=&quot;_blank&quot;&gt;http://yu-li.github.io/paper/li_eccv14_jpeg.zip&lt;/a&gt;，他是借助于FFT实现的，当然少不了多次迭代，速度也是比较慢的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我还收藏了很久前一位朋友写的M代码，但是现在我不知道把他QQ或者微信弄到哪里去了，也不知道他会不会介意我把他的代码分享出来。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function dualROF()
clc

f0&lt;/span&gt;=imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rr.bmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
f0&lt;/span&gt;=f0(:,:,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
[m,n]&lt;/span&gt;=&lt;span&gt;size(f0);
f0&lt;/span&gt;=&lt;span&gt;double&lt;/span&gt;&lt;span&gt;(f0);

lamda&lt;/span&gt;=&lt;span&gt;30&lt;/span&gt;; %&lt;span&gt; smoothness paramter, the larger the smoother
tao&lt;/span&gt;=.&lt;span&gt;125&lt;/span&gt;; % &lt;span&gt;fixed&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; not change it.

p1&lt;/span&gt;=&lt;span&gt;zeros(m,n);
p2&lt;/span&gt;=&lt;span&gt;zeros(m,n);

tic
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; step=&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;100&lt;/span&gt;
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&lt;span&gt;
    div_p&lt;/span&gt;=&lt;span&gt;div(p1,p2);
    cx&lt;/span&gt;=Fx(div_p-f0/&lt;span&gt;lamda);
    cy&lt;/span&gt;=Fy(div_p-f0/&lt;span&gt;lamda);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;　　　　abs_c=sqrt(cx.^2+cy.^2);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　p1=(p1+tao*cx)./(1+tao*abs_c);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　p2=(p2+tao*cy)./(1+tao*abs_c);&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;end

u&lt;/span&gt;=f0-lamda*&lt;span&gt;div_p;
toc
figure; imagesc(f0); colormap(gray); axis off; axis equal;
figure; imagesc(u); colormap(gray); axis off; axis equal;

&lt;/span&gt;% Compute divergence &lt;span&gt;using&lt;/span&gt;&lt;span&gt; backward derivative
function f &lt;/span&gt;=&lt;span&gt; div(a,b)
f &lt;/span&gt;= Bx(a)+&lt;span&gt;By(b);

&lt;/span&gt;% Forward derivative &lt;span&gt;operator&lt;/span&gt; on x with boundary condition u(:,:,&lt;span&gt;1&lt;/span&gt;)=u(:,:,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
function Fxu &lt;/span&gt;=&lt;span&gt; Fx(u)
[m,n] &lt;/span&gt;=&lt;span&gt; size(u);
Fxu &lt;/span&gt;= circshift(u,[&lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;])-&lt;span&gt;u;
Fxu(:,n) &lt;/span&gt;= zeros(m,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;% Forward derivative &lt;span&gt;operator&lt;/span&gt; on y with boundary condition u(&lt;span&gt;1&lt;/span&gt;,:,:)=&lt;span&gt;u(m,:,:)
function Fyu &lt;/span&gt;=&lt;span&gt; Fy(u)
[m,n] &lt;/span&gt;=&lt;span&gt; size(u);
Fyu &lt;/span&gt;= circshift(u,[-&lt;span&gt;1&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;])-&lt;span&gt;u;
Fyu(m,:) &lt;/span&gt;= zeros(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,n);

&lt;/span&gt;% Backward derivative &lt;span&gt;operator&lt;/span&gt; on x with boundary condition Bxu(:,&lt;span&gt;1&lt;/span&gt;)=u(:,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
function Bxu &lt;/span&gt;=&lt;span&gt; Bx(u)
[&lt;/span&gt;~,n] =&lt;span&gt; size(u);
Bxu &lt;/span&gt;= u - circshift(u,[&lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
Bxu(:,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;) = u(:,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
Bxu(:,n) &lt;/span&gt;= -u(:,n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;% Backward derivative &lt;span&gt;operator&lt;/span&gt; on y with boundary condition Bxu(&lt;span&gt;1&lt;/span&gt;,:)=u(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,:)
function Byu &lt;/span&gt;=&lt;span&gt; By(u)
[m,&lt;/span&gt;~] =&lt;span&gt; size(u);
Byu &lt;/span&gt;= u - circshift(u,[&lt;span&gt;1&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
Byu(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,:) = u(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,:);
Byu(m,:) &lt;/span&gt;= -u(m-&lt;span&gt;1&lt;/span&gt;,:);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　M的代码，代码量不大，那是因为Matlab的向量化确实很厉害，但是这个代码还是很慢的，256*256的灰度图迭代100次都要700ms了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里抛开一些优化不说，用这个circshift会造成很大的性能损失，我们稍微分析下就能看到用这个地方其实就是简单的水平或者垂直方向的差分，完全没有必要这样写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　直接按照代码的意思用C语言把他们展开并不做其他的优化可得到大概下面这种不怎么好的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; IM_DualTVDenoising(unsigned &lt;span&gt;char&lt;/span&gt; *Src, unsigned &lt;span&gt;char&lt;/span&gt; *Dest, &lt;span&gt;int&lt;/span&gt; Width, &lt;span&gt;int&lt;/span&gt; Height, &lt;span&gt;int&lt;/span&gt; Stride,  &lt;span&gt;float&lt;/span&gt; Lamda = &lt;span&gt;20&lt;/span&gt; , &lt;span&gt;int&lt;/span&gt; Iter = &lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Channel = Stride /&lt;span&gt; Width;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Src == NULL) || (Dest == NULL))                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_NULLREFRENCE;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Width &amp;lt;= &lt;span&gt;0&lt;/span&gt;) || (Height &amp;lt;= &lt;span&gt;0&lt;/span&gt;))                            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_INVALIDPARAMETER;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Channel != &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;3&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;4&lt;/span&gt;))        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_INVALIDPARAMETER;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; tao = &lt;span&gt;0.125&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; fixed do not change it.&lt;/span&gt;
        &lt;span&gt;float&lt;/span&gt; InvLamda = &lt;span&gt;1.0&lt;/span&gt; /&lt;span&gt; Lamda;
    
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *p1 = (&lt;span&gt;float&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(Width * Height * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *p2 = (&lt;span&gt;float&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(Width * Height * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *div_p = (&lt;span&gt;float&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(Width * Height * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *cx = (&lt;span&gt;float&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(Width * Height * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *cy = (&lt;span&gt;float&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(Width * Height * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *Temp = (&lt;span&gt;float&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(Width * Height * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; X, Y;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; q1, q2, q, abs_c;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *LineP1, *LineP2, *LineP3, *&lt;span&gt;LineP4;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *LinePS, *&lt;span&gt;LinePD;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Z = &lt;span&gt;0&lt;/span&gt;; Z &amp;lt; Iter; Z++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Div(p1, p2, div_p);&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++&lt;span&gt;)
            {
                LineP1 &lt;/span&gt;= p1 + Y * Width;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Fx(Temp, cx);&lt;/span&gt;
                LineP2 = cx + Y *&lt;span&gt; Width;
                LineP2[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = LineP1[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (X = &lt;span&gt;1&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
                {
                    LineP2[X] &lt;/span&gt;= LineP1[X] - LineP1[X - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                }
                LineP2[Width &lt;/span&gt;- &lt;span&gt;1&lt;/span&gt;] = -LineP1[Width - &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
            }

            memcpy(cy, p2, Width &lt;/span&gt;* &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Y = &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; Height; Y++&lt;span&gt;)
            {
                LineP1 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(p2 + (Y - &lt;span&gt;1&lt;/span&gt;)*&lt;span&gt; Width);
                LineP2 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(p2 + Y * Width);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Fy(Temp, cy);&lt;/span&gt;
                LineP3 = (&lt;span&gt;float&lt;/span&gt; *)(cy + Y *&lt;span&gt; Width);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
                {
                    LineP3[X] &lt;/span&gt;= LineP2[X] -&lt;span&gt; LineP1[X];
                }
            }
            LineP1 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(p2 + (Height - &lt;span&gt;2&lt;/span&gt;) *&lt;span&gt; Width);
            LineP2 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(cy + (Height - &lt;span&gt;1&lt;/span&gt;) *&lt;span&gt; Width);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
            {
                LineP2[X] &lt;/span&gt;= -&lt;span&gt;LineP1[X];
            }

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++&lt;span&gt;)
            {
                LineP1 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(cx + Y *&lt;span&gt; Width);
                LineP2 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(cy + Y * Width);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Fy(Temp, cy);&lt;/span&gt;
                LineP3 = (&lt;span&gt;float&lt;/span&gt; *)(div_p + Y *&lt;span&gt; Width);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
                {
                    LineP3[X] &lt;/span&gt;= LineP1[X] +&lt;span&gt; LineP2[X];
                }
            }

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++&lt;span&gt;)
            {
                LineP1 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(div_p + Y *&lt;span&gt; Width);
                LineP2 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(Temp + Y *&lt;span&gt; Width);
                LinePS &lt;/span&gt;= Src + Y *&lt;span&gt; Stride;

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
                {
                    LineP2[X] &lt;/span&gt;= LineP1[X] - LinePS[X] *&lt;span&gt; InvLamda;
                }
            }


            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++&lt;span&gt;)
            {
                LineP1 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(Temp + Y * Width);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Fx(Temp, cx);&lt;/span&gt;
                LineP2 = (&lt;span&gt;float&lt;/span&gt; *)(cx + Y *&lt;span&gt; Width);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width - &lt;span&gt;1&lt;/span&gt;; X++&lt;span&gt;)
                {
                    LineP2[X] &lt;/span&gt;= LineP1[X + &lt;span&gt;1&lt;/span&gt;] -&lt;span&gt; LineP1[X];
                }
                LineP2[Width &lt;/span&gt;- &lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height - &lt;span&gt;1&lt;/span&gt;; Y++&lt;span&gt;)
            {
                LineP1 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(Temp + Y *&lt;span&gt; Width);
                LineP2 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(Temp + (Y + &lt;span&gt;1&lt;/span&gt;) * Width);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Fy(Temp, cy);&lt;/span&gt;
                LineP3 = (&lt;span&gt;float&lt;/span&gt; *)(cy + Y *&lt;span&gt; Width);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
                {
                    LineP3[X] &lt;/span&gt;= LineP2[X] -&lt;span&gt; LineP1[X];
                }
            }
            memset(Temp &lt;/span&gt;+ (Height - &lt;span&gt;1&lt;/span&gt;) * Width, &lt;span&gt;0&lt;/span&gt;, Width * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++&lt;span&gt;)
            {
                LineP1 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(p1 + Y *&lt;span&gt; Width);
                LineP2 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(p2 + Y *&lt;span&gt; Width);
                LineP3 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(cx + Y *&lt;span&gt; Width);
                LineP4 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(cy + Y *&lt;span&gt; Width);

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
                {
                    abs_c &lt;/span&gt;= sqrt(LineP3[X] * LineP3[X] + LineP4[X] *&lt;span&gt; LineP4[X]);
                    abs_c &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt; / (&lt;span&gt;1&lt;/span&gt; + tao *&lt;span&gt; abs_c);
                    LineP1[X] &lt;/span&gt;= (LineP1[X] + tao * LineP3[X]) *&lt;span&gt; abs_c;
                    LineP2[X] &lt;/span&gt;= (LineP2[X] + tao * LineP4[X]) *&lt;span&gt; abs_c;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++&lt;span&gt;)
        {
            LineP1 &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt; *)(div_p + Y *&lt;span&gt; Width);
            LinePS &lt;/span&gt;= Src + Y *&lt;span&gt; Stride;
            LinePD &lt;/span&gt;= Dest + Y *&lt;span&gt; Stride;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
            {
                LinePD[X] &lt;/span&gt;= IM_ClampToByte((&lt;span&gt;int&lt;/span&gt;)(LinePS[X] - Lamda *&lt;span&gt; LineP1[X]));
            }
        }

        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p1);
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p2);
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(div_p);
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(cx);
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(cy);
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(Temp);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        

    }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　算法明显占用很大的内存，而且看起来别扭，不过速度还是杠杠的，256*256的灰度图迭代100次都要30ms了。反编译看了下代码，编译器对代码做了很好的SIMD指令优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面的C语言还是可以继续优化的，这就需要大家自己的认真的去研读代码深层次的逻辑关系了，实际上可以只要上面的一半的临时内存的，而且很多计算可以集中在一个循环里完成，可以手动内嵌SIMD指令，或者直接使用编译器的优化能力，基本上这样的简单的算法逻辑编译器编译后的速度不会比我们手写的SIMD指令慢，有的时候还是会快一些，不得不佩服那些写编译器的大牛。优化后的速度大概在14ms左右。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　研究TV算法需要很好的数学功底，以前朋友曾经给我寄过一本书，里面都是微分方面的数学公式，看的我吓死了，不过TV算法似乎有很多很好的应用，也曾经流行过一段时间，可惜现在深度学习一出来，很多人都喜欢这种直接从海量数据中建造黑盒模型，而对那些有着很明显的数学逻辑的算法嗤之以鼻了，真有点可惜。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以前在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Imageshop/p/3365517.html&quot;&gt;基于总变差模型的纹理图像中图像主结构的提取方法&lt;/a&gt; 一文中曾提到那个论文附带的Matlab代码没有什么意义，因为他很难转换成C的代码，即时转换成功了，也处理不了大图，但是本文这里的TV算法总的来说在内存占用或者速度方面都还令人满意。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在去噪效果上，这个算法还算可以：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201912/349293-20191216213603540-1824952750.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201912/349293-20191216213609530-1551889928.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201912/349293-20191216213746634-826805245.png&quot; alt=&quot;&quot;/&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201912/349293-20191216213753237-1925616750.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　本文Demo下载地址：  &lt;a href=&quot;http://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&quot; target=&quot;_blank&quot;&gt;http://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&lt;/a&gt;， 算法位于Denoise --&amp;gt; TV Denoising下。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Dec 2019 13:39:00 +0000</pubDate>
<dc:creator>Imageshop</dc:creator>
<og:description>最近看到一篇文章讲IMAGE DECOMPOSITION，里面提到了将图像分为Texture layer和Structure layer，测试了很多方法，对于那些具有非常强烈纹理的图像，总觉得用TV去</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Imageshop/p/12051536.html</dc:identifier>
</item>
<item>
<title>直击面试，聊聊 GC 机制 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12051482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12051482.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;1.9117647058824&quot;&gt;
&lt;p&gt;文章来源:&lt;a href=&quot;https://urlify.cn/imUF32&quot;&gt;https://studyidea.cn/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;GC&lt;/code&gt; 中文直译垃圾回收，是一种回收内存空间避免内存泄漏的机制。当 &lt;code&gt;JVM&lt;/code&gt; 内存紧张，通过执行 &lt;code&gt;GC&lt;/code&gt; 有效回收内存，转而分配给新对象从而实现内存的再利用。 &lt;code&gt;JVM&lt;/code&gt; &lt;code&gt;GC&lt;/code&gt; 机制虽然无需开发主动参与，减轻不少工作量，但是某些情况下，自动 &lt;code&gt;GC&lt;/code&gt; 将会导致系统性能下降，响应变慢，所以这就需要我们提前了解掌握 &lt;code&gt;GC&lt;/code&gt; 机制。当面对这种情况时，才能从容不迫的解决问题。另外 &lt;code&gt;GC&lt;/code&gt; 机制也是 &lt;code&gt;Java&lt;/code&gt; 面试高频考题，了解掌握 GC 是一项必备技能。&lt;/p&gt;
&lt;p&gt;学习 &lt;code&gt;GC&lt;/code&gt; ，首先我们解决三个问题:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是垃圾&lt;/li&gt;
&lt;li&gt;在哪里回收垃圾&lt;/li&gt;
&lt;li&gt;怎么回收垃圾&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么是垃圾&quot;&gt;什么是垃圾&lt;/h2&gt;
&lt;p&gt;我们先来看一段简单的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212849941-1247122573.jpg&quot; alt=&quot;code&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码通过将字符串对象转化成字节数组，然后写入本地文件。方法一旦开始执行，就将会在分配一定内存给新建的对象，然后将引用告诉了&lt;code&gt;str&lt;/code&gt;， &lt;code&gt;bytes&lt;/code&gt; 变量。等到方法执行完毕，方法内部局部变量紧接将就会被销毁。但是这样仅仅销毁了局部变量，却没有带走内存上这些实际的对象。这类不再起作用，没有被引用的对象，将其归类为垃圾。&lt;/p&gt;
&lt;p&gt;在偌大的内存上存活着无数对象，&lt;code&gt;GC&lt;/code&gt; 之前需要准确将这些对象标记出来，分为存活对象与垃圾对象。这个过程一旦少标记，那就只能等待下次 &lt;code&gt;GC&lt;/code&gt;标记，再回收，这样将会影响 GC 效率。另外决不能错标记，将正常存活对象标记为垃圾。一旦回收正常存活的对象，可能就会引起程序各种崩溃。&lt;/p&gt;
&lt;p&gt;目前有两种算法可以用来标记：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引用计数法&lt;/li&gt;
&lt;li&gt;可达性分析法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;引用计数法&quot;&gt;引用计数法&lt;/h3&gt;
&lt;p&gt;引用计数法通过在对象头分配一个字段，用来存储该对象引用计数。一旦该对象被其他对象引用，计数加 1。如果这个引用失效，计数减 1。当引用计数值为 0 时，代表这个对象已不再被引用，可以被回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212850169-547574374.jpg&quot; alt=&quot;引用计数法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，当 &lt;code&gt;str&lt;/code&gt; 引用堆中对象时，计数值增加为 1。当 &lt;code&gt;str&lt;/code&gt; 变为 &lt;code&gt;null&lt;/code&gt; 时，既不再引用该对象，计数值减 1。此时该对象就可以被 &lt;code&gt;GC&lt;/code&gt; 回收。&lt;/p&gt;
&lt;p&gt;引用计数法只需要判断计数值，所以实现比较简单，这个过程也比较高效。但是存在一个很严重的问题，无法解决对象循环引用问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212850338-1333335655.jpg&quot; alt=&quot;引用计数法-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到， &lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt; 不再引用堆中对象，导致计数减一。此时两个对象内部还存在互相引用，计数值不为 0，此时 &lt;code&gt;GC&lt;/code&gt; 没办法回收该对象。&lt;/p&gt;
&lt;h3 id=&quot;可达性分析法&quot;&gt;可达性分析法&lt;/h3&gt;
&lt;p&gt;这个算法首先需要按照规则查找当前活跃的引用，将其称为 &lt;code&gt;GC Roots&lt;/code&gt;。接着将 &lt;code&gt;GC Roots&lt;/code&gt; 作为根节点出发，遍历对象引用关系图，将可以遍历（可达）的对象标记为存活，其余对象当做无用对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212850510-309610436.jpg&quot; alt=&quot;可达性分析&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里是是&lt;strong&gt;引用&lt;/strong&gt;，而不是对象。&lt;/p&gt;
&lt;p&gt;从上图可以看到，绿色对象虽然存在循环引用，但是由于这些对象不能被 &lt;code&gt;GC Roots&lt;/code&gt; 遍历到，所以将会被回收。&lt;/p&gt;
&lt;p&gt;可以被当做&lt;code&gt;GC Roots&lt;/code&gt; 活跃引用包括但不限于以下引用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法中局部变量&lt;/li&gt;
&lt;li&gt;静态变量，常量&lt;/li&gt;
&lt;li&gt;JNI handles&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;在哪里回收垃圾&quot;&gt;在哪里回收垃圾&lt;/h2&gt;
&lt;p&gt;还记得刚开始接触 &lt;code&gt;Java&lt;/code&gt; 时，只知道堆栈，对象实例分配在堆中，方法中局部变量位于栈中。实际上 &lt;code&gt;JVM&lt;/code&gt; 内存区域划分更加细致，分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;虚拟机栈&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212850676-1311214399.jpg&quot; alt=&quot;JVM 运行时内存区域划分&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，我们将内存划分为线程私有与线程共享的区域。方法区与堆都是线程共享的区域，这两部分占用 &lt;code&gt;JVM&lt;/code&gt; 大部分内存，剩下三个小弟将会跟线程绑定，随着线程消亡，自动将会被 &lt;code&gt;JVM&lt;/code&gt; 回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆应该是大家最熟悉的一块区域，几乎所有对象实例都将会在此出生，通常也是虚拟机上占用内存最大一块区域，简直就是 &lt;code&gt;JVM&lt;/code&gt; 内存中的大哥大。堆内存内部也不是简简单单一块而已，目前将会根据分代算法，将堆分代，不同对象位于不同区域。这一点我们下文再详细了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法区将会保存已被虚拟上加载的类信息、常量，静态变量，字节码等信息，堆上的对象正式通过方法区这些信息，才能正确创建出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机栈栈由一系列栈帧组成，每个栈帧其实代表一个方法，栈帧中将会保存一个方法的局部变量表，方法出入口信息，操作栈等。每当调用一个方法，就将会把这个栈帧压入栈中，执行结束，出栈。&lt;/p&gt;
&lt;p&gt;本地方法栈与虚拟机栈比较类似，最大区别在于，虚拟机栈执行的 &lt;code&gt;Java&lt;/code&gt; 方法，而本地方法栈将会用来执行 &lt;code&gt;Native&lt;/code&gt; 方法服务。下面方法就会在本地方法栈中执行。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static native void arraycopy(Object src,  int  srcPos,
                                    Object dest, int destPos,
                                    int length);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序计算器可以说是这几块区域占用最小的一部分，但是功能却十分重要。Java 源代码通过编译变成字节码，然后被 JVM 载入运行之后，将会变成一条条指令，而程序计数器的工作就是告诉当前线程下一条需要执行指令。这样即使发生了线程切换，等待恢复的时候，当前线程依然知道接下去要执行的指令。&lt;/p&gt;
&lt;h2 id=&quot;怎么回收&quot;&gt;怎么回收&lt;/h2&gt;
&lt;p&gt;目前主流 GC 算法主要分为三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标记-清除算法&lt;/li&gt;
&lt;li&gt;复制算法&lt;/li&gt;
&lt;li&gt;标记-整理算法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;标记-清除算法&quot;&gt;标记-清除算法&lt;/h3&gt;
&lt;p&gt;这是一个最为基础也是最容易实现的算法，主要实现步骤分为两步：标记，清除。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标记：通过上述 &lt;code&gt;GC Roots&lt;/code&gt; 标记出可达对象。&lt;/li&gt;
&lt;li&gt;清除：清理&lt;strong&gt;未标记对象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212851671-1317326992.jpg&quot; alt=&quot;image-20191214114722060&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps：这个图着实难画啊。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到经过这个算法回收之后，虽然堆空间被清理出来，但是也产生很多&lt;strong&gt;空间碎片&lt;/strong&gt;。这就会导致一个新对象根据堆剩余容量计算，看起来是可以分配，但是实际分配过程，由于没有连续内存，导致虚拟机感知到内存不足，又不得不提前再次触发 &lt;code&gt;GC&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可能这里你就会有疑惑，为什么对象需要分配一块连续的内存？&lt;/p&gt;
&lt;p&gt;这里引用一下 R 神 &lt;a href=&quot;https://www.zhihu.com/people/rednaxelafx&quot;&gt;@RednaxelaFX&lt;/a&gt; 答案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212853276-1369084343.jpg&quot; alt=&quot;image-20191214141247453&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外这个算法还有一个不足：标记与清除效率比较低。这就竟会导致 &lt;code&gt;GC&lt;/code&gt; 占用时间过长，影响正常程序使用。&lt;/p&gt;
&lt;h3 id=&quot;复制算法&quot;&gt;复制算法&lt;/h3&gt;
&lt;p&gt;为了解决上述效率问题，诞生复制算法。这个算法将可用内存分为两块，每次只使用其中一块，当这一块内存使用完毕，触发 &lt;code&gt;GC&lt;/code&gt; ，将会把存活的对象依次复制到另外一块上，然后再把已使用过的内存一次性清理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212854659-1182529795.jpg&quot; alt=&quot;image-20191214144413235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个算法每次只需要操作一半内存，&lt;code&gt;GC&lt;/code&gt; 回收之后也不存在任何空间碎片，新对象内存分配时只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。但是这个算法闲置一半内存空间，空间利用效率不高。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：复制算法以空间换时间，两者不可兼得&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外对象存活率也会影响复制算法效率。如果对象大部分都是朝生夕死，只需要移动少量存活对象，就能腾出大部分空间。反而如果对象存活率高，这就需要进行较多的复制操作，回收之后也并没有多余内存，这就可能导致频繁触发 &lt;code&gt;GC&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;针对这种存活时间长的对象，就需要使用标记-整理算法。&lt;/p&gt;
&lt;h3 id=&quot;标记-整理算法&quot;&gt;标记-整理算法&lt;/h3&gt;
&lt;p&gt;标记-整理算法可以说是标记-清除算法的改进版，改进了清除导致的空间碎片问题。这个算法分为两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标记：也是通过 &lt;code&gt;GC Roots&lt;/code&gt; 标记存活对象。&lt;/li&gt;
&lt;li&gt;整理：将存活对象往一端移动，按照内存地址一次排序，然后将末端边界之外内存直接清理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212856888-801582552.jpg&quot; alt=&quot;image-20191214152625150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然标记-整理算法解决了标记-清除算法空间碎片问题，也完整利用整个内存空间，但是这个算法问题效率并不高。相较于标记-清除算法，标记-整理算法多增加整理这一步，所以该算法效率还低于标记-清除算法。&lt;/p&gt;
&lt;h3 id=&quot;分代收集算法&quot;&gt;分代收集算法&lt;/h3&gt;
&lt;p&gt;从上面三种 &lt;code&gt;GC&lt;/code&gt; 算法可以看到，并没有一种空间与时间效率都是比较完美的算法，所以只能做的是综合利用各种算法特点将其作用到不用的内存区域。&lt;/p&gt;
&lt;p&gt;目前商业虚拟机根据对象存活周期不同划分内存区域，一般分为新生代，老年代。新对象一般情况都会优先分配在新生代，新生代对象若存活时间大于一定阈值之后，将会移到至老年代。新生代的对象都是短命鬼，老年代的对象都是长寿先生。&lt;/p&gt;
&lt;p&gt;新生代每次 &lt;code&gt;GC&lt;/code&gt; 之后都可以回收大批量对象，所以比较适合复制算法，只需要付出少量复制存活对象的成本。这里内存划分并没有按照 1:1 划分，默认将会按照 8:1:1 划分成 &lt;code&gt;Eden&lt;/code&gt; 与两块 &lt;code&gt;Survivor&lt;/code&gt;空间。每次使用 &lt;code&gt;Eden&lt;/code&gt; 与一块&lt;code&gt;Survivor&lt;/code&gt;空间，这样我们只是闲置 10% 内存空间。不过我们每次回收并不能保证存活对象小于 10%,在这种情况下就需要依靠老年代的内存分配担保。当&lt;code&gt;Survivor&lt;/code&gt;空间并不能保存剩余存活对象，就将这些对象通过分配担保进制移动至老年代。&lt;/p&gt;
&lt;p&gt;老年代中对象存活率将会特别高，且没有额外空间进行分配担保，所以并不适合复制算法，所以需要使用标记-清除或标记-整理算法。&lt;/p&gt;
&lt;h2 id=&quot;随便聊聊&quot;&gt;随便聊聊&lt;/h2&gt;
&lt;p&gt;最近又到一年一次大考的时候，不得不又拿起周志明『深入 Java 虚拟机』重新学习。还记得第一次翻看这本书的时候，大半内容看不懂，看完也很快就忘了。然后过了一段时间，又重新拿起此书，这次比上次好，也已经能看小大半了。最近跟一些小伙伴聊天，发现他们都是看这本书学习 &lt;code&gt;JVM&lt;/code&gt; ，不得不说这本书真是一本神书。最近『深入 Java 虚拟机』第三版即将上架开售，有需要的小伙伴可以考虑入手了。&lt;/p&gt;
&lt;p&gt;好了 ，&lt;code&gt;GC&lt;/code&gt; 机制就就总结到这里，下一篇我们来聊聊 JVM 常用 &lt;code&gt;GC&lt;/code&gt; 回收器。&lt;/p&gt;
&lt;h2 id=&quot;帮助链接&quot;&gt;帮助链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/53613423/answer/135743258&quot;&gt;GC Roots&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/qianguyihao/p/4744233.html&quot;&gt;Java虚拟机详解04----GC算法和种类&lt;/a&gt;&lt;br/&gt;深入 Java 虚拟机&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201912/1419561-20191216212858940-188657924.png&quot; alt=&quot;其他平台.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Dec 2019 13:29:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>前言 文章来源: 'https://studyidea.cn/' 中文直译垃圾回收，是一种回收内存空间避免内存泄漏的机制。当 内存紧张，通过执行 有效回收内存，转而分配给新对象从而实现内存的再利用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12051482.html</dc:identifier>
</item>
<item>
<title>面试题-关于Java线程池一篇文章就够了 - 程序新视界</title>
<link>http://www.cnblogs.com/secbro/p/12051473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/secbro/p/12051473.html</guid>
<description>&lt;p&gt;在Java面试中，线程池相关知识，虽不能说是必问提，但出现的频次也是非常高的。同时又鉴于公众号“程序新视界”的读者后台留言让写一篇关于Java线程池的文章，于是就有本篇内容，本篇将基于Java线程池的原理、实现以及相关源码进行讲解等。&lt;/p&gt;
&lt;h2 id=&quot;什么是线程池&quot;&gt;什么是线程池&lt;/h2&gt;
&lt;p&gt;线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。&lt;/p&gt;
&lt;p&gt;为了充分利用CPU多核资源，应用都会采用多线程并行/并发计算，最大限度的利用多核提升应用程序性能。&lt;/p&gt;
&lt;p&gt;试想一下，如果每个请求都执行一遍创建线程、执行任务、销毁线程，那么对服务器资源将是一种浪费。在高并发的情况下，甚至会耗尽服务器资源。&lt;/p&gt;
&lt;p&gt;线程池的主要作用有两个：不同请求之间重复利用线程，无需频繁的创建和销毁线程，降低系统开销和控制线程数量上限，避免创建过多的线程耗尽进程内存空间，同时减少线程上下文切换次数。&lt;/p&gt;
&lt;h2 id=&quot;常见面试题&quot;&gt;常见面试题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;说说Java线程池的好处及实现的原理？&lt;/li&gt;
&lt;li&gt;Java提供线程池各个参数的作用，如何进行的?&lt;/li&gt;
&lt;li&gt;根据线程池内部机制，当提交新任务时，有哪些异常要考虑？&lt;/li&gt;
&lt;li&gt;线程池都有哪几种工作队列？&lt;/li&gt;
&lt;li&gt;使用无界队列的线程池会导致内存飙升吗？&lt;/li&gt;
&lt;li&gt;说说几种常见的线程池及使用场景?&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;线程池的创建与使用&quot;&gt;线程池的创建与使用&lt;/h2&gt;
&lt;p&gt;在JDK5版本中增加了内置线程池实现ThreadPoolExecutor，同时提供了Executors来创建不同类型的线程池。Executors中提供了以下常见的线程池创建方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;newSingleThreadExecutor：一个单线程的线程池。如果因异常结束，会再创建一个新的，保证按照提交顺序执行。&lt;/li&gt;
&lt;li&gt;newFixedThreadPool：创建固定大小的线程池。根据提交的任务逐个增加线程，直到最大值保持不变。如果因异常结束，会新创建一个线程补充。&lt;/li&gt;
&lt;li&gt;newCachedThreadPool：创建一个可缓存的线程池。会根据任务自动新增或回收线程。&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool：支持定时以及周期性执行任务的需求。&lt;/li&gt;
&lt;li&gt;newWorkStealingPool：JDK8新增，根据所需的并行层次来动态创建和关闭线程，通过使用多个队列减少竞争，底层使用ForkJoinPool来实现。优势在于可以充分利用多CPU，把一个任务拆分成多个“小任务”，放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然在JDK中提供Executors类来支持以上类型的线程池创建，但通常情况下不建议开发人员直接使用（见《阿里巴巴java开发规范》）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Executors部分方法的弊端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;newFixedThreadPool和newSingleThreadExecutor主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。&lt;/li&gt;
&lt;li&gt;newCachedThreadPool和newScheduledThreadPool:主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时，阿里巴巴java开发规范中推荐了3种线程池创建方式。&lt;/p&gt;
&lt;p&gt;方式一，引入commons-lang3包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//org.apache.commons.lang3.concurrent.BasicThreadFactory
ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,
    new BasicThreadFactory.Builder().namingPattern(&quot;example-schedule-pool-%d&quot;).daemon(true).build());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方式二，引入com.google.guava包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
    .setNameFormat(&quot;demo-pool-%d&quot;).build();

//Common Thread Pool
ExecutorService pool = new ThreadPoolExecutor(5, 200,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());

pool.execute(()-&amp;gt; System.out.println(Thread.currentThread().getName()));
pool.shutdown();//gracefully shutdown&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方式三，spring配置线程池方式：自定义线程工厂bean需要实现ThreadFactory，可参考该接口的其它默认实现类，使用方式直接注入bean，调用execute(Runnable task)方法即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;userThreadPool&quot;
    class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&amp;gt;
    &amp;lt;property name=&quot;corePoolSize&quot; value=&quot;10&quot; /&amp;gt;
    &amp;lt;property name=&quot;maxPoolSize&quot; value=&quot;100&quot; /&amp;gt;
    &amp;lt;property name=&quot;queueCapacity&quot; value=&quot;2000&quot; /&amp;gt;

&amp;lt;property name=&quot;threadFactory&quot; value= threadFactory /&amp;gt;
    &amp;lt;property name=&quot;rejectedExecutionHandler&quot;&amp;gt;
        &amp;lt;ref local=&quot;rejectedExecutionHandler&quot; /&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
// in code
userThreadPool.execute(thread);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;threadpoolexecutor的构造方法&quot;&gt;ThreadPoolExecutor的构造方法&lt;/h2&gt;
&lt;p&gt;除了以上推荐的创建线程池的方法，还可以通过ThreadPoolExecutor的构造方法，直接创建线程池。本质上来讲，以上方法最终也是创建了ThreadPoolExecutor对象，然后堆积进行包装处理。&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor提供了多个构造方法，我们最终都调用的构造方法来进行说明。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public ThreadPoolExecutor(int corePoolSize,
      int maximumPoolSize,
      long keepAliveTime,
      TimeUnit unit,
      BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
      ThreadFactory threadFactory,
      RejectedExecutionHandler handler) {
   // 省略代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心参数作用解析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;corePoolSize：线程池核心线程数最大值。&lt;/li&gt;
&lt;li&gt;maximumPoolSize：线程池最大线程数大小。&lt;/li&gt;
&lt;li&gt;keepAliveTime：线程池中非核心线程空闲的存活时间大小。&lt;/li&gt;
&lt;li&gt;unit：线程空闲存活时间单位。&lt;/li&gt;
&lt;li&gt;workQueue：存放任务的阻塞队列。&lt;/li&gt;
&lt;li&gt;threadFactory：创建新线程的工厂，所有线程都是通过该工厂创建的，有默认实现。&lt;/li&gt;
&lt;li&gt;handler：线程池的拒绝策略。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;程池的拒绝策略&quot;&gt;程池的拒绝策略&lt;/h2&gt;
&lt;p&gt;构造方法的中最后的参数RejectedExecutionHandler用于指定线程池的拒绝策略。当请求任务不断的过来，而系统此时又处理不过来的时候，我们就需要采取对应的策略是拒绝服务。&lt;/p&gt;
&lt;p&gt;默认有四种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。&lt;/li&gt;
&lt;li&gt;DiscardOleddestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。&lt;/li&gt;
&lt;li&gt;DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，除了默认的4种策略之外，还可以根据业务需求自定义拒绝策略。通过实现RejectedExecutionHandler接口，在创建ThreadPoolExecutor对象时作为参数传入即可。&lt;/p&gt;
&lt;p&gt;在spring-integration-core中便自定义了CallerBlocksPolicy，相关代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CallerBlocksPolicy implements RejectedExecutionHandler {
    private static final Log logger = LogFactory.getLog(CallerBlocksPolicy.class);
    private final long maxWait;

    public CallerBlocksPolicy(long maxWait) {
        this.maxWait = maxWait;
    }

    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        if (!executor.isShutdown()) {
            try {
                BlockingQueue&amp;lt;Runnable&amp;gt; queue = executor.getQueue();
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Attempting to queue task execution for &quot; + this.maxWait + &quot; milliseconds&quot;);
                }

                if (!queue.offer(r, this.maxWait, TimeUnit.MILLISECONDS)) {
                    throw new RejectedExecutionException(&quot;Max wait time expired to queue task&quot;);
                } else {
                    if (logger.isDebugEnabled()) {
                        logger.debug(&quot;Task execution queued&quot;);
                    }

                }
            } catch (InterruptedException var4) {
                Thread.currentThread().interrupt();
                throw new RejectedExecutionException(&quot;Interrupted&quot;, var4);
            }
        } else {
            throw new RejectedExecutionException(&quot;Executor has been shut down&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;线程池的执行&quot;&gt;线程池的执行&lt;/h2&gt;
&lt;p&gt;创建完成ThreadPoolExecutor之后，当向线程池提交任务时，通常使用execute方法。execute方法的执行流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742867/201912/1742867-20191216212754053-751859506.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果线程池中存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。&lt;/li&gt;
&lt;li&gt;如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。&lt;/li&gt;
&lt;li&gt;当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。&lt;/li&gt;
&lt;li&gt;如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;源代码分析&quot;&gt;源代码分析&lt;/h2&gt;
&lt;p&gt;下面看一下JDK8中ThreadPoolExecutor中execute方法的源代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    // 线程池本身的状态跟worker数量使用同一个变量ctl来维护
    int c = ctl.get();
    // 通过位运算得出当然线程池中的worker数量与构造参数corePoolSize进行比较
    if (workerCountOf(c) &amp;lt; corePoolSize) {
        // 如果小于corePoolSize，则直接新增一个worker，并把当然用户提交的任务command作为参数，如果成功则返回。
        if (addWorker(command, true))
            return;
        // 如果失败，则获取最新的线程池数据
        c = ctl.get();
    }
    // 如果线程池仍在运行，则把任务放到阻塞队列中等待执行。
    if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
        // 这里的recheck思路是为了处理并发问题
        int recheck = ctl.get();
        // 当任务成功放入队列时，如果recheck发现线程池已经不再运行了则从队列中把任务删除
        if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
            //删除成功以后，会调用构造参数传入的拒绝策略。
            reject(command);
         // 如果worker的数量为0（此时队列中可能有任务没有执行），则新建一个worker（由于此时新建woker的目的是执行队列中堆积的任务，
         // 因此入参没有执行任务，详细逻辑后面会详细分析addWorker方法）。
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 如果前面的新增woker，放入队列都失败，则会继续新增worker，此时线程池的状态是woker数量达到corePoolSize，阻塞队列任务已满
    // 只能基于maximumPoolSize参数新建woker
    else if (!addWorker(command, false))
        // 如果基于maximumPoolSize新建woker失败，此时是线程池中线程数已达到上限，队列已满，则调用构造参数中传入的拒绝策略
        reject(command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面再看在上述代码中调用的addWorker方法的源代码实现及解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private boolean addWorker(Runnable firstTask, boolean core) {
    // 这里有一段基于CAS+死循环实现的关于线程池状态，线程数量的校验与更新逻辑就先忽略了，重点看主流程。
    //...

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
         // 把指定任务作为参数新建一个worker线程
        w = new Worker(firstTask);
        // 这里是重点w.thread是通过线程池构造函数参数threadFactory生成的woker对象
        // 也就是说这个变量t就是代表woker线程。绝对不是用户提交的线程任务firstTask。
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // 加锁之后仍旧是判断线程池状态等一些校验逻辑。
                int rs = runStateOf(ctl.get());
                if (rs &amp;lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                    if (t.isAlive()) 
                        throw new IllegalThreadStateException();
                    // 把新建的woker线程放入集合保存，这里使用的是HashSet
                    workers.add(w);
                    int s = workers.size();
                    if (s &amp;gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 然后启动woker线程
                 // 该变量t代表woker线程，会调用woker的run方法
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            // 如果woker启动失败，则进行一些善后工作，比如说修改当前woker数量等
            addWorkerFailed(w);
    }
    return workerStarted;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;addWorker方法主要做的工作就是新建一个Woker线程，加入到woker集合中。在上述方法中会调用到Worker类的run方法，并最终执行了runWorker方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Woker类实现了Runnable接口
public void run() {
    runWorker(this);
}

final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    // task就是Woker构造函数入参指定的任务，即用户提交的任务
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); 
    boolean completedAbruptly = true;
    try {
        //一般情况下，task都不会为空（特殊情况上面注释中也说明了），因此会直接进入循环体中
        //这里getTask方法是要重点说明的，它的实现跟我们构造参数设置存活时间有关
        //我们都知道构造参数设置的时间代表了线程池中的线程，即woker线程的存活时间，如果到期则回收woker线程，这个逻辑的实现就在getTask中。
        //来不及执行的任务，线程池会放入一个阻塞队列，getTask方法就是去阻塞队列中取任务，用户设置的存活时间，就是
        //从这个阻塞队列中取任务等待的最大时间，如果getTask返回null，意思就是woker等待了指定时间仍然没有
        //取到任务，此时就会跳过循环体，进入woker线程的销毁逻辑。
        while (task != null || (task = getTask()) != null) {
            w.lock();
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;amp;&amp;amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                //该方法是个空的实现，如果有需要用户可以自己继承该类进行实现
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //真正的任务执行逻辑
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    //该方法是个空的实现，如果有需要用户可以自己继承该类进行实现
                    afterExecute(task, thrown);
                }
            } finally {
                //这里设为null，也就是循环体再执行的时候会调用getTask方法
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        //当指定任务执行完成，阻塞队列中也取不到可执行任务时，会进入这里，做一些善后工作，比如在corePoolSize跟maximumPoolSize之间的woker会进行回收
        processWorkerExit(w, completedAbruptly);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;woker线程的执行流程就是首先执行初始化时分配给的任务，执行完成以后会尝试从阻塞队列中获取可执行的任务，如果指定时间内仍然没有任务可以执行，则进入销毁逻辑。这里只会回收corePoolSize与maximumPoolSize直接的那部分woker。&lt;/p&gt;
&lt;h2 id=&quot;execute与submit的区别&quot;&gt;execute与submit的区别&lt;/h2&gt;
&lt;p&gt;执行任务除了可以使用execute方法还可以使用submit方法。它们的主要区别是：execute适用于不需要关注返回值的场景，submit方法适用于需要关注返回值的场景。&lt;/p&gt;
&lt;h2 id=&quot;异常处理&quot;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;当执行任务时发生异常，那么该怎么处理呢？首先看当Thread线程异常如何处理。&lt;/p&gt;
&lt;p&gt;在任务中通过try...catch是可以捕获异常并进行处理的，如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread t = new Thread(() -&amp;gt; {
    try {
        System.out.println(1 / 0);
    } catch (Exception e) {
        LOGGER.error(e.getMessage(), e);
    }
});
t.start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果很多线程任务默认的异常处理机制都是相同的，可以通过Thread类的UncaughtExceptionHandler来设置线程默认的异常处理机制。&lt;/p&gt;
&lt;p&gt;实现UncaughtExceptionHandler接口，并调用Thread#setUncaughtExceptionHandler(UncaughtExceptionHandler)方法。如果想设置为全局默认异常处理机制，则可调用Thread#setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler)方法。&lt;/p&gt;
&lt;p&gt;ThreadGroup默认提供了异常处理机制如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void uncaughtException(Thread t, Throwable e) {
    if (parent != null) {
        parent.uncaughtException(t, e);
    } else {
        Thread.UncaughtExceptionHandler ueh =
            Thread.getDefaultUncaughtExceptionHandler();
        if (ueh != null) {
            ueh.uncaughtException(t, e);
        } else if (!(e instanceof ThreadDeath)) {
            System.err.print(&quot;Exception in thread \&quot;&quot;
                             + t.getName() + &quot;\&quot; &quot;);
            e.printStackTrace(System.err);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ThreadPoolExecutor的异常处理机制与Thread是一样的。同时，ThreadPoolExecutor提供了uncaughtExceptionHandler方法来设置异常处理。如下示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadPool {

    public static void main(String[] args) {
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat(&quot;demo-pool-%d&quot;)
                .setUncaughtExceptionHandler(new LogUncaughtExceptionHandler())
                .build();

        ExecutorService pool = new ThreadPoolExecutor(5, 200,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());

        pool.execute(() -&amp;gt; {
            throw new RuntimeException(&quot;测试异常&quot;);
        });

        pool.shutdown();
    }

    static class  LogUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            System.out.println(&quot;打印LogUncaughtExceptionHandler中获得的异常信息:&quot; + e.getMessage());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但需要注意的是使用UncaughtExceptionHandler的方法只适用于execute方法执行的任务，而对submit方法是无效。submit执行的任务，可以通过返回的Future对象的get方法接收抛出的异常，再进行处理。这也算是execute方法与submit方法的差别之一。&lt;/p&gt;
&lt;h2 id=&quot;线程池中常见的队列&quot;&gt;线程池中常见的队列&lt;/h2&gt;
&lt;p&gt;线程池有以下工作队列：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ArrayBlockingQueue：有界队列，是一个用数组实现的有界阻塞队列，按FIFO排序量。&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue：可设置容量队列，基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列。&lt;/li&gt;
&lt;li&gt;DelayQueue：延迟队列，是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue：优先级队列，是具有优先级的无界阻塞队列。&lt;/li&gt;
&lt;li&gt;SynchronousQueue：同步队列，一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;关闭线程池&quot;&gt;关闭线程池&lt;/h2&gt;
&lt;p&gt;关闭线程池可以调用shutdownNow和shutdown两个方法来实现。&lt;/p&gt;
&lt;p&gt;shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。&lt;/p&gt;
&lt;p&gt;shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/5df6e38e4362&lt;/p&gt;
&lt;p&gt;https://juejin.im/post/5d1882b1f265da1ba84aa676&lt;/p&gt;
&lt;p&gt;原文链接：《&lt;a href=&quot;https://www.choupangxia.com/2019/12/16/java-thread-pool/&quot;&gt;面试题-关于Java线程池一篇文章就够了&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;&lt;br/&gt;&lt;/h2&gt;
&lt;center&gt;&lt;strong&gt;程序新视界&lt;/strong&gt;：精彩和成长都不容错过&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742867/201910/1742867-20191013111755842-2090947098.png&quot; alt=&quot;程序新视界-微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Dec 2019 13:28:00 +0000</pubDate>
<dc:creator>程序新视界</dc:creator>
<og:description>在Java面试中，线程池相关知识，虽不能说是必问提，但出现的频次也是非常高的。同时又鉴于公众号“程序新视界”的读者后台留言让写一篇关于Java线程池的文章，于是就有本篇内容，本篇将基于Java线程池的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/secbro/p/12051473.html</dc:identifier>
</item>
</channel>
</rss>