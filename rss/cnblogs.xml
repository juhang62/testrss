<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>thingsboard改造使用mysql数据库 - 落烨无痕</title>
<link>http://www.cnblogs.com/danny-djy/p/10762685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danny-djy/p/10762685.html</guid>
<description>&lt;p&gt;thingsboard从2.2版本开始，兼容关系型数据库与非关系型数据库共用（关系型数据库保存实体类信息、非关系型数据库cassandra保存遥测数据信息）。由于国内偏向使用mysql数据库，而非postgresql。所以，通过修改thingsboard.yml的JDBC链接，可以实现使用mysql数据库的目的。&lt;/p&gt;
&lt;p&gt;同理，如果需要改成使用oracle或者其他数据库，也是修改配置文件即可。因为thingsboard使用了JPA作为持久化手段，所以基本兼容目前流行的数据库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;thingsboard.yml配置修改如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DATABASE_ENTITIES_TYPE    sql&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;SPRING_JPA_DATABASE_PLATFORM  org.hibernate.dialect.MySQL5InnoDBDialect&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;SPRING_DRIVER_CLASS_NAME  com.mysql.jdbc.Driver&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;SPRING_DATASOURCE_URL  jdbc:mysql://${mysql_ip}:3306/thingsboard?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=UTC&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;SPRING_DATASOURCE_USERNAME      ${mysql_username}&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;SPRING_DATASOURCE_PASSWORD      ${mysql_password}&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 07:34:00 +0000</pubDate>
<dc:creator>落烨无痕</dc:creator>
<og:description>thingsboard从2.2版本开始，兼容关系型数据库与非关系型数据库共用（关系型数据库保存实体类信息、非关系型数据库cassandra保存遥测数据信息）。由于国内偏向使用mysql数据库，而非po</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danny-djy/p/10762685.html</dc:identifier>
</item>
<item>
<title>Spring Boot入门(四)：开发Web Api接口常用注解总结 - 周伟伟的博客</title>
<link>http://www.cnblogs.com/zwwhnly/p/10762585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwwhnly/p/10762585.html</guid>
<description>&lt;p&gt;在程序员的日常工作中，Web开发应该是占比很重的一部分，至少我工作以来，开发的系统基本都是Web端访问的系统，Web开发在这几年也是经历了很快的发展，前端也显得越来越重要，现在很多大一点的公司都实行前后端分离，让后端和前端只专注于自己的事，所谓术业有专攻，我个人也非常建议前后端分离。&lt;/p&gt;
&lt;p&gt;既然前后端分离了，那么后端肯定需要提供Web Api接口给到前端，并返回前端需要的数据。&lt;/p&gt;
&lt;p&gt;在Spring Boot中，开发Web Api接口主要使用以下几个注解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Controller&lt;/li&gt;
&lt;li&gt;@ResponseBody&lt;/li&gt;
&lt;li&gt;@RestController&lt;/li&gt;
&lt;li&gt;@RequestMapping&lt;/li&gt;
&lt;li&gt;@PathVariable&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，这些注解在Spring MVC里都有了，所以Spring Boot里的用法也和Spring MVC里基本一样。&lt;/p&gt;
&lt;p&gt;在Spring Boot之所以能使用，是因为在spring-boot-starter-web 这个starter pom中，已经引用了spring-web和spring-webmvc。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190424104323784-1267276978.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们通过具体例子来讲解下各个注解的使用方法。&lt;/p&gt;
&lt;h2 id=&quot;controller&quot;&gt;1.@Controller&lt;/h2&gt;
&lt;p&gt;新建控制器HelloController，添加@Controller注解，添加1个方法sayHello，添加@RequestMapping注解，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zwwhnly.springbootdemo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class HelloController {

    @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
    public String sayHello() {
        return &quot;hello&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行项目，在浏览器输入http://localhost:8080/hello访问，发现报如下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190424110537306-2069439901.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报错的原因是未找到对应的模板，那么如何解决呢？&lt;/p&gt;
&lt;p&gt;我们先讲解下第一种解决方法，添加下thymeleaf模板，首先修改pom文件，添加如下配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有设置自动导入maven包的话，IDEA右下角会提示你导入，点击“Import Changes”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190424111207524-341568277.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在resources/templates目录下，新建hello.html文件（内容先随便写），再次运行项目，访问http://localhost:8080/hello，发现访问正常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201904/424537-20190424111534883-1852935502.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;responsebody&quot;&gt;2.@ResponseBody&lt;/h2&gt;
&lt;p&gt;还有一种更简单的方法是在控制器上添加@ResponseBody注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zwwhnly.springbootdemo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

    @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
    public String sayHello() {
        return &quot;hello&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时的运行结果(直接返回字符串)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;restcontroller&quot;&gt;3.@RestController&lt;/h2&gt;
&lt;p&gt;@RestController是Spring4.0推出的组合注解，相当于@Controller+@ResponseBody，我们看下它的源码,也能看出：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
    @AliasFor(
        annotation = Controller.class
    )
    String value() default &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们就可以将代码简化为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class HelloController {
    @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
    public String sayHello() {
        return &quot;hello&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;requestmapping&quot;&gt;4.@RequestMapping&lt;/h2&gt;
&lt;p&gt;@RequestMapping注解主要用来配置url映射，既可以添加到控制器上，也可以添加到控制器下的方法上，添加到方法上是对添加到控制器上的补充，举例说明：&lt;/p&gt;
&lt;p&gt;新建图书类Book：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zwwhnly.springbootdemo.model;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Book {
    private Integer bookId;
    private String bookName;
    private String bookAuthor;
    private Date purchaseDate;

    public Book(Integer bookId, String bookName, String bookAuthor, String purchaseDate) throws ParseException {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);

        this.bookId = bookId;
        this.bookName = bookName;
        this.bookAuthor = bookAuthor;
        this.purchaseDate = simpleDateFormat.parse(purchaseDate);
    }

    public Integer getBookId() {
        return bookId;
    }

    public void setBookId(Integer bookId) {
        this.bookId = bookId;
    }

    public String getBookName() {
        return bookName;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    public String getBookAuthor() {
        return bookAuthor;
    }

    public void setBookAuthor(String bookAuthor) {
        this.bookAuthor = bookAuthor;
    }

    public Date getPurchaseDate() {
        return purchaseDate;
    }

    public void setPurchaseDate(Date purchaseDate) {
        this.purchaseDate = purchaseDate;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在HelloController中添加方法getBookList：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(value = &quot;/getBookList&quot;, method = RequestMethod.GET)
public List&amp;lt;Book&amp;gt; getBookList() {
    List&amp;lt;Book&amp;gt; books = new ArrayList&amp;lt;&amp;gt;();
    try {
         Book book1 = new Book(1, &quot;平凡的世界&quot;, &quot;路遥&quot;, &quot;2010-01-01&quot;);
         Book book2 = new Book(2, &quot;人生&quot;, &quot;路遥&quot;, &quot;2011-01-01&quot;);

         books.add(book1);
         books.add(book2);
    } catch (ParseException e) {
         e.printStackTrace();
    }

    return books;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行项目在浏览器输入http://localhost:8080/getBookList，结果为：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;// 20190424140621
// http://localhost:8080/getBookList

[
  {
    &quot;bookId&quot;: 1,
    &quot;bookName&quot;: &quot;平凡的世界&quot;,
    &quot;bookAuthor&quot;: &quot;路遥&quot;,
    &quot;purchaseDate&quot;: &quot;2009-12-31 16:00:00&quot;
  },
  {
    &quot;bookId&quot;: 2,
    &quot;bookName&quot;: &quot;人生&quot;,
    &quot;bookAuthor&quot;: &quot;路遥&quot;,
    &quot;purchaseDate&quot;: &quot;2010-12-31 16:00:00&quot;
  }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们在HelloController上也加上@RequestMapping注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zwwhnly.springbootdemo.controller;

import com.zwwhnly.springbootdemo.model.Book;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping(value = &quot;hello&quot;)
public class HelloController {

    @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
    public String sayHello() {
        return &quot;hello&quot;;
    }

    @RequestMapping(value = &quot;/getBookList&quot;, method = RequestMethod.GET)
    public List&amp;lt;Book&amp;gt; getBookList() {
        List&amp;lt;Book&amp;gt; books = new ArrayList&amp;lt;&amp;gt;();
        try {
            Book book1 = new Book(1, &quot;平凡的世界&quot;, &quot;路遥&quot;, &quot;2010-01-01&quot;);
            Book book2 = new Book(2, &quot;人生&quot;, &quot;路遥&quot;, &quot;2011-01-01&quot;);

            books.add(book1);
            books.add(book2);
        } catch (ParseException e) {
            e.printStackTrace();
        }

        return books;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时两个方法的访问地址就分别变为了：http://localhost:8080/hello/hello，http://localhost:8080/hello/getBookList。&lt;/p&gt;
&lt;h2 id=&quot;pathvariable&quot;&gt;5.@PathVariable&lt;/h2&gt;
&lt;p&gt;@PathVariable注解用来获取url中的数据，以下为具体的使用方法，&lt;/p&gt;
&lt;p&gt;在HelloController控制器中添加方法getBook，通过占位符传递bookId：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(value = &quot;/getBook/{bookId}&quot;, method = RequestMethod.GET)
public Book getBook(@PathVariable Integer bookId) {
     Book book = null;
     List&amp;lt;Book&amp;gt; books = new ArrayList&amp;lt;&amp;gt;();
     try {
            Book book1 = new Book(1, &quot;平凡的世界&quot;, &quot;路遥&quot;, &quot;2010-01-01&quot;);
            Book book2 = new Book(2, &quot;人生&quot;, &quot;路遥&quot;, &quot;2011-01-01&quot;);

            books.add(book1);
            books.add(book2);

            book = books.get(bookId - 1);
        } catch (ParseException e) {
            e.printStackTrace();
    }

    return book;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行项目，在浏览器中访问http://localhost:8080/hello/getBook/1，结果如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;// 20190424145348
// http://localhost:8080/hello/getBook/1

{
  &quot;bookId&quot;: 1,
  &quot;bookName&quot;: &quot;平凡的世界&quot;,
  &quot;bookAuthor&quot;: &quot;路遥&quot;,
  &quot;purchaseDate&quot;: &quot;2009-12-31 16:00:00&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：占位符里的名称必须和参数名完全一致，区分大小写，否则访问会报500错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想不一致，可以写成如下方式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(value = &quot;/getBook/{bookId}&quot;, method = RequestMethod.GET)
public Book getBook(@PathVariable(&quot;bookId&quot;) Integer bookIndex) {
      ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式也要求，PathVariable的value属性值必须与占位符里的名称完全一致。&lt;/p&gt;
&lt;p&gt;好了，本篇文章就先讲解这么多，其它注解后续再单独发布文章讲解。&lt;/p&gt;
&lt;h2 id=&quot;源码地址&quot;&gt;6.源码地址&lt;/h2&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://www.zwwhnly.com/springboot/2019/04/24/spring-boot-webapi.html&quot;&gt;Spring Boot入门(四)：开发Web Api接口常用注解总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;http://www.zwwhnly.com&quot; class=&quot;uri&quot;&gt;http://www.zwwhnly.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/zwwhnly/springbootdemo.git&quot; class=&quot;uri&quot;&gt;https://github.com/zwwhnly/springbootdemo.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家下载，有问题可以多多交流。&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;7.参考链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28202661/article/details/79946176&quot;&gt;用Spring Boot开发一个web API 接口返回数据&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010412719/article/details/69710480&quot;&gt;SpringBoot 中常用注解@Controller/@RestController/@RequestMapping介绍&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 07:21:00 +0000</pubDate>
<dc:creator>周伟伟的博客</dc:creator>
<og:description>在程序员的日常工作中，Web开发应该是占比很重的一部分，至少我工作以来，开发的系统基本都是Web端访问的系统，Web开发在这几年也是经历了很快的发展，前端也显得越来越重要，现在很多大一点的公司都实行前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zwwhnly/p/10762585.html</dc:identifier>
</item>
<item>
<title>python接口自动化（二十二）--unittest执行顺序隐藏的坑（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10755530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10755530.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　大多数的初学者在使用 unittest 框架时候，不清楚用例的执行顺序到底是怎样的。对测试类里面的类和方法分不清楚，不知道什么时候执行，什么时候不执行。虽然或许通过代码实现了，也是稀里糊涂的一知半解，这样还好，好歹自己鼓&lt;/p&gt;
&lt;p&gt;捣出了，但是时间和效率并不是很高，下次遇到还是老样子。那么本篇通过最简单案例来给给为小伙伴详细讲解、演示一下 unittest 执行顺序。&lt;/p&gt;
&lt;h2&gt;实例代码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190424083353030-1129366547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;参考代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;23&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用unittest框架编写测试用例执行顺序
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; #&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入unittest模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import unittest
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; #&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.执行顺序和运行测试
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import unittest
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLogin(unittest.TestCase):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    def test_login_blog(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;登录博客园&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    def test_add_essay(self):
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 添加随笔&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    def test_release_essay(self):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 发布随笔&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    def test_quit_blog(self):
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;退出博客园&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     unittest.main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个标准的使用unittest进行测试的例子，写完后心里美滋滋，嗯，就按照一贯思路代码会按照这个顺序测就可以了。结果一运行。就傻眼了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190424083919359-1934783132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190424144647874-1636973817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　这时候自己心里犯嘀咕，这是什么鬼，怎么回事呢。&lt;strong&gt;执行的顺序乱了&lt;/strong&gt;。第一个执行的测试用例并不是登录博客园，而是添加随笔，此时用户还没登录博客园，进行添加随笔的话会直接报错，导致用例失败。&lt;/p&gt;
&lt;p&gt;到这里有些小伙伴可能会说，为什么要让测试用例之间有所依赖呢？&lt;/p&gt;
&lt;p&gt;　　的确，如果完全没依赖，测试用例的执行顺序是不需要关注的。但是这样对于用例的设计和实现，要求就高了许多。而对博客园来说，一个系统内的操作，是有很大的关联性的。以添加随笔为例，随笔内的每个操作都有一个前提，你需要&lt;/p&gt;
&lt;p&gt;登录博客园才能添加随笔。所以要实现用例之间的完全解耦，需要每个用例开始之前，检测用户的登录状态。&lt;/p&gt;
&lt;p&gt;　　如果可以控制测试用例的执行顺序，按照功能流程一遍走下来，节省的代码量是非常可观的，阅读测试用例也会清晰明了许多。&lt;/p&gt;
&lt;h2&gt;如何控制unittest用例执行的顺序呢？&lt;/h2&gt;
&lt;p&gt;1、带大家先看看源码，unittest是怎么样对用例进行排序的。在&lt;code&gt;loader.py&lt;/code&gt;的&lt;code&gt;loadTestsFromTestCase&lt;/code&gt;方法里边，调用了&lt;code&gt;getTestCaseNames&lt;/code&gt;方法来获取测试用例的名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190424111758350-210516870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、从源码可以清楚地看到，&lt;code&gt;getTestCaseNames&lt;/code&gt;方法对测试用例的名称进行了排序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190424111938233-1864966866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、一步一步跟进去，查看其排序方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190424112402962-614080194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、根据排序规则，unittest执行测试用例，默认是根据ASCII码的顺序加载测试用例，数字与字母的顺序为：0-9，A-Z，a-z。&lt;/p&gt;
&lt;p&gt;5、做个小demo，看看是不是我们所说的那种排序规则&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190424112753576-29735455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、从上边的运行结果，我们可以看出是：unittest执行测试用例，默认是根据ASCII码的顺序加载测试用例，数字与字母的顺序为：0-9，A-Z，a-z。&lt;/p&gt;
&lt;p&gt;7、基于unittest的机制，如何控制用例执行顺序呢？查了一些网上的资料，主要介绍了两种方式：&lt;/p&gt;
&lt;h3 id=&quot;方式1，通过TestSuite类的addTest方法，按顺序加载测试用例&quot;&gt;方式1，通过TestSuite类的addTest方法，按顺序加载测试用例&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190424144432296-1513536059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;参考代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;23&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用unittest框架编写测试用例执行顺序
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; #&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入unittest模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import unittest
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; #&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.执行顺序和运行测试
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import unittest
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLogin(unittest.TestCase):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    def setUp(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        pass
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    def test_login_blog(self):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;登录博客园&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录博客园&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    def test_add_essay(self):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 添加随笔&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;添加随笔&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    def test_release_essay(self):
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 发布随笔&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发布随笔&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    def test_quit_blog(self):
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;退出博客园&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出博客园&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    def tearDown(self):
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        pass
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    # 启动单元测试
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    # unittest.main()
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    # 获取TestSuite的实例对象
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     suite =&lt;span&gt; unittest.TestSuite()
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    # 将测试用例添加到测试容器中
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     suite.addTest(TestLogin(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_login_blog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     suite.addTest(TestLogin(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_add_essay&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     suite.addTest(TestLogin(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_release_essay&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     suite.addTest(TestLogin(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_quit_blog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    # 创建TextTestRunner类的实例对象
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     runner =&lt;span&gt; unittest.TextTestRunner()
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    runner.run(suite)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     #unittest.TextTestRunner(verbosity=&lt;span&gt;3&lt;/span&gt;).run(suite)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;方式2，通过修改函数名的方式&quot;&gt;方式2，通过修改函数名的方式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190424145005526-1651743407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;参考代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;23&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用unittest框架编写测试用例执行顺序
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; #&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入unittest模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import unittest
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; #&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.执行顺序和运行测试
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import unittest
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLogin(unittest.TestCase):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    def setUp(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        pass
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    def test_1_login_blog(self):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;登录博客园&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录博客园&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    def test_2_add_essay(self):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 添加随笔&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;添加随笔&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    def test_3_release_essay(self):
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 发布随笔&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发布随笔&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    def test_4_quit_blog(self):
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;退出博客园&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         :&lt;span&gt;return&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出博客园&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    def tearDown(self):
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        pass
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    # 启动单元测试
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     unittest.main()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;拓展练习&lt;/h2&gt;
&lt;h3&gt;1、实例&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190423130704591-2042375124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、运行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190423131122823-559985546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、运行结果分析&lt;/h3&gt;
&lt;p&gt;1、从运行结果可以看出执行顺序：&lt;/p&gt;
&lt;p&gt;　　start!-执行测试用例 01-end!&lt;/p&gt;
&lt;p&gt;　　start!-执行测试用例 02-end!&lt;/p&gt;
&lt;p&gt;　　start!-执行测试用例 03-end!&lt;/p&gt;
&lt;p&gt;2、从执行结果可以看出几点&lt;/p&gt;
&lt;p&gt;　　--先执行的前置 setUp，然后执行的用例(test*)，最后执行的后置 tearDown&lt;/p&gt;
&lt;p&gt;　　--测试用例（test*）的执行顺序是根据 01-02-03 执行的，也就是说根据用例名称来顺序执行的&lt;/p&gt;
&lt;p&gt;　　--addtest（self）这个方法没执行,说明只执行 test 开头的用例&lt;/p&gt;
&lt;h3&gt;参考代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;23&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用unittest框架编写测试用例思路
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; #&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入unittest模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import unittest
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; #&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.执行顺序和运行测试
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import time
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test(unittest.TestCase):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    def setUp(self):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    def tearDown(self):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         time.sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;end!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    def test01(self):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行测试用例 01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    def test03(self):
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行测试用例 03&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    def test02(self):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行测试用例 02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    def addtest(self):
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add 方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     unittest.main()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;1、这个执行顺序，看似简单，实则不简单，只有掌握最简单的才可以应付最复杂的。&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;setUp()&lt;/code&gt;和&lt;code&gt;tearDown()&lt;/code&gt;方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在&lt;code&gt;setUp()&lt;/code&gt;方法中连接数据库，在&lt;code&gt;tearDown()&lt;/code&gt;方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 06:59:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 大多数的初学者在使用 unittest 框架时候，不清楚用例的执行顺序到底是怎样的。对测试类里面的类和方法分不清楚，不知道什么时候执行，什么时候不执行。虽然或许通过代码实现了，也是稀里糊涂的一知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10755530.html</dc:identifier>
</item>
<item>
<title>Windows中使用Mysql-Proxy实现Mysql读写分离 - 进击的辣条</title>
<link>http://www.cnblogs.com/wyt007/p/10762300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyt007/p/10762300.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;1、简介&lt;/h2&gt;
&lt;p id=&quot;读写分离&quot;&gt;读写分离：当业务量上来时，往往一台单机的mysql数据库不能满足性能需求，这时候就需要配置主从库读写分离来解决性能瓶颈。简单的来说，就是原先一台数据库既读又写，现在改成一台写和1台以上读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991704/201904/991704-20190424092343552-1561849286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;环境准备&quot;&gt;1.1、环境准备&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;3台windows server 2012(理论上windows server 2003+ 都行）&lt;/li&gt;
&lt;li&gt;mysql 5.6&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;mysql-proxy-0.8.5-windows-x86-32bit&quot; href=&quot;https://downloads.mysql.com/archives/proxy/&quot;&gt;mysql-proxy-0.8.5-windows-x86-32bit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;navicat for mysql (如果你对命令行比较熟，忽略这个)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;分配ip&quot;&gt;1.2、分配IP&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;主数据库：192.168.103.207&lt;/li&gt;
&lt;li&gt;从数据库：192.168.103.208&lt;/li&gt;
&lt;li&gt;中间件服务器：192.168.103.203&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;安装mysql&quot;&gt;1.3、安装mysql&lt;/h3&gt;
&lt;p&gt;在[主]192.168.103.207和[从]192.168.103.208两台机子上根据向导模式一步步安装mysql 5.6，这里我选择&lt;strong&gt;Server&lt;/strong&gt;环境，安装后先停止mysql服务&lt;/p&gt;
&lt;h2 id=&quot;配置my.ini&quot;&gt;2、配置my.ini&lt;/h2&gt;
&lt;p&gt;在主从的服务器上分别找到以下路径的&lt;strong&gt;my.ini&lt;/strong&gt;文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
C:\ProgramData\MySQL\MySQL Server &lt;span&gt;5.6&lt;/span&gt;\my.ini
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主数据库配置的&lt;strong&gt;mysqld&lt;/strong&gt;节点下加入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[mysqld]
log&lt;/span&gt;-bin=mysql-bin #从库会基于此log-&lt;span&gt;bin来做复制
binlog&lt;/span&gt;-&lt;span&gt;do&lt;/span&gt;-db=&lt;span&gt;mytest #用于读写分离的具体数据库，这里我创建了mytest作测试
binlog_ignore_db&lt;/span&gt;=&lt;span&gt;mysql #不用于读写分离的具体数据库
binlog_ignore_db&lt;/span&gt;=information_schema #和binlog-&lt;span&gt;do&lt;/span&gt;-db一样，可以设置多个
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从数据库配置配置的&lt;strong&gt;mysqld&lt;/strong&gt;节点下加入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[mysqld]
log&lt;/span&gt;-bin=mysql-bin #从库会基于此log-&lt;span&gt;bin来做复制
replicate&lt;/span&gt;-&lt;span&gt;do&lt;/span&gt;-db=mytest #用于读写分离的具体数据库，这里我创建了mytest作测试
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：在对从数据库配置的时候，需要在文件内找到找到&lt;strong&gt;server-id&lt;/strong&gt;，将它改成和主库不一样的编号，例如&lt;/p&gt;
&lt;h4 id=&quot;主库&quot;&gt;主库&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
server-id=&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;从库&quot;&gt;从库&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
server-id=&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多个从库时，可以递增填写&lt;/p&gt;
&lt;h2 id=&quot;配置主数据库&quot;&gt;3、配置主数据库&lt;/h2&gt;
&lt;p&gt;开启主数据库服务，创建用来测试读写分离的数据库&lt;br/&gt;对用户授权使其用于复制主库数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;grant
replication slave on
&lt;/span&gt;*.*&lt;span&gt; to
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.103.%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
identified by
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用户名：slave123&lt;br/&gt;密码：123456&lt;/p&gt;
&lt;p&gt;然后查询主数据库状态，并记录下File和Position字段的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;&lt;span&gt; show master status;
&lt;/span&gt;+------------------+----------+--------------+--------------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB         | Executed_Gtid_Set |
+------------------+----------+--------------+--------------------------+-------------------+
| mysql-bin.&lt;span&gt;000001&lt;/span&gt; |     &lt;span&gt;2073&lt;/span&gt; | mytest       | mysql,information_schema |                   |
+------------------+----------+--------------+--------------------------+-------------------+
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.05&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的&lt;br/&gt;File：mysql-bin.000001&lt;br/&gt;Position：2073&lt;/p&gt;
&lt;h2 id=&quot;配置从数据库&quot;&gt;4、配置从数据库&lt;/h2&gt;
&lt;p&gt;开启从数据库服务，&lt;strong&gt;手动&lt;/strong&gt;创建测试读写分离的库，这边不会帮你自动创建，同时也创建和主库一样的用户，我这里还是先停止从库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
stop slave;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;设置它的master&quot;&gt;设置它的master&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;change master to
master_host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.103.207&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
master_port&lt;/span&gt;=&lt;span&gt;3307&lt;/span&gt;&lt;span&gt;,
master_user&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
master_password&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
master_log_file&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql-bin.000001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
master_log_pos&lt;/span&gt;=&lt;span&gt;2073&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：这里的 &lt;strong&gt;master_log_file&lt;/strong&gt;和&lt;strong&gt;master_log_pos&lt;/strong&gt;就是配置主数据库查询到的&lt;strong&gt;File&lt;/strong&gt;和&lt;strong&gt;Position&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;启动从库&quot;&gt;启动从库&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
start slave;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;检查是否启动成功&quot;&gt;检查是否启动成功&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
show slave status;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果Slave_IO_State字段显示 &lt;strong&gt;Waiting for master to send event&lt;/strong&gt;说明成功，当然你也可以在主库表中插入一条数据，看看从库是否有同步，到这里，已经配置好主从同步了。&lt;/p&gt;
&lt;h2 id=&quot;配置mysql-proxy&quot;&gt;5、配置Mysql-Proxy&lt;/h2&gt;
&lt;p&gt;下载 &lt;strong&gt;mysql-proxy-0.8.5-windows-x86-32bit &lt;/strong&gt;解压到任意位置，它是绿色免安装版的，创建配置文件 &lt;strong&gt;mysql-proxy.conf&lt;/strong&gt;，内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[mysql-&lt;span&gt;proxy]
admin&lt;/span&gt;-username=&lt;span&gt;root
admin&lt;/span&gt;-password=&lt;span&gt;root
admin&lt;/span&gt;-lua-script=C:/mysql-proxy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;-windows-x86-32bit/lib/mysql-proxy/lua/&lt;span&gt;admin.lua
proxy&lt;/span&gt;-backend-addresses=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;103.207&lt;/span&gt;:&lt;span&gt;3307&lt;/span&gt;&lt;span&gt;
proxy&lt;/span&gt;-read-only-backend-addresses=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;103.208&lt;/span&gt;:&lt;span&gt;3307&lt;/span&gt;&lt;span&gt;
proxy&lt;/span&gt;-lua-script=C:/mysql-proxy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;-windows-x86-32bit/share/doc/mysql-proxy/rw-&lt;span&gt;splitting.lua
log&lt;/span&gt;-file=C:/mysql-proxy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;-windows-x86-32bit/log/mysql-&lt;span&gt;proxy.log
log&lt;/span&gt;-level=&lt;span&gt;debug
daemon&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
keepalive&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;admin-username：用于中间件连接的用户，这里我还是用root偷懒&lt;br/&gt;admin-password：同上用户密码&lt;br/&gt;admin-lua-script：根据存放的文件位置自行调整&lt;br/&gt;proxy-backend-addresses：主库服务器+端口&lt;br/&gt;proxy-read-only-backend-addresses：从库服务器+端口，多个从库用，隔开&lt;br/&gt;proxy-lua-script：根据存放的文件位置自行调整&lt;br/&gt;log-file：日志文件存放位置，如果你指定了一个路径，请确保手动创建了对应的文件夹，否则会报错&lt;br/&gt;log-level：日志级别&lt;br/&gt;daemon：以守护进程方式运行&lt;br/&gt;keepalive：长连接&lt;/p&gt;
&lt;p&gt;将上面创建的文件复制到&lt;strong&gt;mysql-proxy-0.8.5-windows-x86-32bit&lt;/strong&gt;的bin目录中&lt;br/&gt;创建&lt;strong&gt;install.bat&lt;/strong&gt;文件,内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\mysql-proxy-0.8.5-windows-x86-32bit\bin\mysql-proxy.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -P &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;103.203&lt;/span&gt;:&lt;span&gt;6217&lt;/span&gt; --defaults-file=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\mysql-proxy-0.8.5-windows-x86-32bit\bin\mysql-proxy.conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也放在&lt;strong&gt;mysql-proxy-0.8.5-windows-x86-32bit&lt;/strong&gt;的&lt;strong&gt;bin&lt;/strong&gt;目录中，双击运行&lt;br/&gt;接下来，用你的客户端工具连接 &lt;strong&gt;192.168.103.203:6217&lt;/strong&gt;（6217这个端口随便设置，跟上面的bat里面一致就行），测试是否可以能正常连接，如果能连接，但是不能显示读写分离的数据库，那一般是权限设置问题&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 06:41:00 +0000</pubDate>
<dc:creator>进击的辣条</dc:creator>
<og:description>1、简介 读写分离：当业务量上来时，往往一台单机的mysql数据库不能满足性能需求，这时候就需要配置主从库读写分离来解决性能瓶颈。简单的来说，就是原先一台数据库既读又写，现在改成一台写和1台以上读。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyt007/p/10762300.html</dc:identifier>
</item>
<item>
<title>【STM32H7教程】第8章   STM32H7的终极调试组件Event Recorder - 安富莱电子</title>
<link>http://www.cnblogs.com/armfly/p/10757582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/armfly/p/10757582.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;完整教程下载地址：&lt;a href=&quot;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=86980&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=86980&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;本章节为大家介绍终极调试方案Event Recoder，之所以叫终极解决方案，是因为所有Link通吃，支持时间测量，功耗测量，printf打印，RTX5及其所有中间件调试信息展示。&lt;/p&gt;
&lt;p&gt;8.1 重要提示（必读）&lt;/p&gt;
&lt;p&gt;8.2 Event Recorder简介&lt;/p&gt;
&lt;p&gt;8.3 创建工程模板和注意事项&lt;/p&gt;
&lt;p&gt;8.4 Event Recorder事件记录的实现&lt;/p&gt;
&lt;p&gt;8.5 Event Recoder 实现printf重定向&lt;/p&gt;
&lt;p&gt;8.6 Event Statistics 时间测量功能的实现&lt;/p&gt;
&lt;p&gt;8.7 Event Statistics 功耗测量功能的实现&lt;/p&gt;
&lt;p&gt;8.8 Event Recoder对RTX5及其所有中间件的支持&lt;/p&gt;
&lt;p&gt;8.9 JLINK配置说明&lt;/p&gt;
&lt;p&gt;8.10 STLINK配置说明&lt;/p&gt;
&lt;p&gt;8.11 CMSIS-DAP配置说明&lt;/p&gt;
&lt;p&gt;8.12 ULINK配置说明&lt;/p&gt;
&lt;p&gt;8.13 配套例子&lt;/p&gt;
&lt;p&gt;8.14 总结&lt;/p&gt;


&lt;h2&gt;8.1   重要提示（&lt;span&gt;必读&lt;/span&gt;）&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;  只要是MDK支持的调试下载器，基本都支持Event Recorder，本教程测试了JLINK，STLINK和CMSIS-DAP。&lt;/li&gt;
&lt;li&gt;  务必使用MDK5.25及其以上版本。&lt;/li&gt;
&lt;li&gt;  使用ARM_Compiler 软件包V1.4.0及其以上版本。详情看此贴：&lt;a href=&quot;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=87175&quot;&gt;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=87175&lt;/a&gt; 。&lt;/li&gt;
&lt;li&gt;  CMSIS软件包 要是使用V5.3.0及其以上版本，详情本教程8.3小节末尾的说明。&lt;/li&gt;
&lt;li&gt;  如果大家的MDK5.X应用不是很熟练的话，可以看论坛网友翻译的MDK5.X入门手册：&lt;a href=&quot;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=31288&quot;&gt;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=31288&lt;/a&gt;。如果觉得看手册上手慢的话，可以直接看KEIL官方做的MDK入门系列视频，带中文字幕：&lt;a href=&quot;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=82667&quot;&gt;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=82667&lt;/a&gt; 。&lt;/li&gt;
&lt;li&gt;  为了实现Event Recorder组件的最高性能，最好将下载器的时钟速度设置到所支持的最大值，另外，根据需要加大EventRecorderConf.h文件中的缓冲大小，默认可以缓冲64个消息（动态更新的FIFO空间）。&lt;/li&gt;
&lt;li&gt;  此调试组件不需要用到SWO引脚，使用标准的下载接口即可。以我们的开发板为例，用到VCC，GND，SWDIO，SWCLK和NRST。大家使用三线JLINK-OB也是没问题的，仅需用到GND，SWDIO和SWCLK。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;8.2   Event Recorder简介&lt;/h2&gt;
&lt;p&gt;前面的专题教程中为大家讲解了使用SEGGER的RTT功能来替代串口打印，比较方便。只是这种方法限制用户必须使用JLINK才可以。而使用Event Recorder的话，无此限制，各种LINK通吃。只要是MDK支持的即可。&lt;/p&gt;
&lt;p&gt;Event Recorder是MDK在5.22版本的时增加的功能，到了5.25版本后，这个功能就更加完善了，增加了时间测量和功耗测量的功能。&lt;/p&gt;
&lt;p&gt;此调试组件不需要用到SWO引脚，使用标准的下载接口即可。以我们的开发板为例，用到VCC，GND，SWDIO，SWCLK和NRST。大家使用三线JLINK-OB也是没问题的，仅需用到GND，SWDIO和SWCLK。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;  JTAG接口和SWD接口区别&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;下图分别是20pin的标准JTAG引脚和SWD（ Serial Wire Debug）引脚，一般SWD接口仅需要Vref，SWDIO，SWCLK，RESET和GND五个引脚即可，SWO（Serial Wire Output）引脚是可选的。有了SWO引脚才可以实现数据从芯片到电脑端的数据发送。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170322288-1656436275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;  词条 SWV（Serial Wire Viewer）&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;SWV是由仪器化跟踪宏单元ITM(Instrumentation Trace Macrocell)和SWO构成的。SWV实现了一种从MCU内部获取信息的低成本方案，SWO接口支持输出两种格式的跟踪数据，但是任意时刻只能使用一种。两种格式的数据编码分别是UART（串行）和Manchester（曼彻斯特）。当前JLINK仅支持UART编码，SWO引脚可以根据不同的信息发送不同的数据包。当前M3/M4可以通过SWO引脚输出以下三种信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ITM支持printf函数的debug调用（工程需要做一下接口重定向即可）。ITM有32个通道，如果使用MDK的话，通道0用于输出调试字符或者实现printf函数，通道31用于Event Viewer，这就是为什么实现Event Viewer需要配置SWV的原因。&lt;/li&gt;
&lt;li&gt;数据观察点和跟踪DWT(Data Watchpoint and Trace)可用于变量的实时监测和PC程序计数器采样。&lt;/li&gt;
&lt;li&gt;ITM 还附带了一个时间戳的功能：当一个新的跟踪数据包进入了ITM的FIFO 时，ITM 就会把一个差分的时间戳数据包插入到跟踪数据流中。跟踪捕获设备在得到了这些时间戳后，就可以找出各跟踪数据之间的时间相关信息。另外，在时间戳计数器溢出时也会发送时间戳数据包。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;8.2.1        Event Recorder的特色&lt;/h3&gt;
&lt;p&gt;Event Recorder的特色主要有以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提升应用程序动态执行期间的检测能力。&lt;/li&gt;
&lt;li&gt;支持的事件类型滤除机制，比如运行错误、API调用、内部操作和操作信息的区分。&lt;/li&gt;
&lt;li&gt;可以在任务中、RTOS内核中和中断服务程序中任意调用。&lt;/li&gt;
&lt;li&gt;对于带ITM功能的Cortex-M3/M4/M7/M33内核芯片，执行记录期间，全程无需开关中断操作。对于不带ITM功能的Cortex-M0/M0+/M23，是需要开关中断的。&lt;/li&gt;
&lt;li&gt;支持printf重定向。&lt;/li&gt;
&lt;li&gt;各种link通吃，支持SWD接口或者JTAG接口方式的JLINK、STLINK、ULINK和CMSIS-DAP。&lt;/li&gt;
&lt;li&gt;对于带DWT时钟周期计数器功能的Cortex-M3/M4/M7/M33内核芯片，创建时间戳时，可以有效降低系统负担，无需专用定时器来实现。&lt;/li&gt;
&lt;li&gt;Event Recorder执行时间具有时间确定性，即执行的时间是确定的，而且执行速度超快，因此，实际产品中的代码依然可以带有这部分，无需创建debug和release两种版本。&lt;/li&gt;
&lt;li&gt;RTX5及其所有中间件都支持Event Recorder调试。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;8.2.2        Event Recorder是如何工作的&lt;/h3&gt;
&lt;p&gt;首先来看下面这张图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170448259-1105070795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在截图的左下角有个Memory内存区，在这个内存区里面有一个缓冲Event Buffer，其实就是一个大数组。MDK通过访问这个数组实现消息的图形化展示。为了正确的图形化展示，数组缓冲里面的数据就得有一定的数据格式。而这个数据格式就是通过左侧截图里面的Event Recorder和Event Filter来实现的。Event Recorder的API实现数据记录和整理，Event Filter的API实现数据的筛选，从而可以选择哪些数据可以在MDK的Event Recorder调试组件里面展示出来。&lt;/p&gt;
&lt;p&gt;这就是Event Recorder的基本工作流程。&lt;/p&gt;
&lt;h3&gt;8.2.3  Event Statistics时间测量功能&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;Event Statistics提供的时间测量功能简单易用，在测试代码前后加上测量函数即可：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170459791-1391034648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在本章教程程的8.6小节为大家详细进行了讲解。通过这个时间测量功能，用户可以方便测试代码的执行时间，从而根据需要，进行合理的优化，提高代码执行效率。&lt;/p&gt;
&lt;h3&gt;8.2.4  Event Statistics功耗测量功能&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;Event Statistics提供的功耗测量功能，当前只有KEIL的ULINKplus支持此功能，由于ULINKplus价格不便宜，一套5000多，大家作为了解即可，实际效果如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170508633-604997918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;8.2.5  Event Recorder的实现原理&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;每条Event Recorder消息是由16字节的数据组成，32位的ID，32位的时间戳，两个32位的数据，共计16个字节。其中32位ID最重要，格式如下： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170522526-1676043027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Level指定消息分类，主要用于消息筛选： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170540564-1169466750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Component number指定事件消息所属的软件组件，也可用于过滤： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170601375-452410691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;看了下Event Recorder的源码，每条消息大体是一样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {

  uint32_t ts;                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Timestamp (32-bit, Toggle bit instead of MSB)&lt;/span&gt;
&lt;span&gt;
  uint32_t val1;                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Value 1   (32-bit, Toggle bit instead of MSB)&lt;/span&gt;
&lt;span&gt;
  uint32_t val2;                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Value 2   (32-bit, Toggle bit instead of MSB)&lt;/span&gt;
&lt;span&gt;
  uint32_t info;                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Record Information

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [ 7.. 0]: Message ID (8-bit)

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [15.. 8]: Component ID (8-bit)

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [18..16]: Data Length (1..8) / Event Context

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      [19]: IRQ Flag

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [23..20]: Sequence Number

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      [24]: First Record

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      [25]: Last Record

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      [26]: Locked Record

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      [27]: Valid Record

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      [28]: Timestamp MSB

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      [29]: Value 1 MSB

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      [30]: Value 2 MSB

                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      [31]: Toggle bit&lt;/span&gt;
&lt;span&gt;
} EventRecord_t;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;其中参数成员info最重要，也就是前面说的32位ID，这里的说明与前面的说明稍有不同。这里是经过处理后，实际存储到Event Recorder缓冲里面的数据。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;对于Event Recorder，大家了解了这些知识点基本就够用了。&lt;/p&gt;
&lt;h2&gt;8.3   创建工程模板和注意事项&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;Event Recorder工程的创建比较简单，这里分步为大家做个介绍。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;  第1步：准备好一个使用MDK5.25或以上版本创建的工程模板。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170632657-1993041872.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  第2步：安装ARM_Compiler V1.4.0或以上版本（如果有最新版，直接安装最新的&lt;/strong&gt;&lt;/span&gt;），详情见帖子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=87175&quot;&gt;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=87175&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  第3步：打开MDK5.25或以上版本创建的RTE环境。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170650185-669673997.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  第4步：通过RTE环境，为工程添加Event Recorder功能。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170657242-1256716513.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  第5步：为了实现printf重定向，我们需要将STDOUT的输出方式改为Event Recorder，即选项里面的EVR。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170706002-1897168797.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  第6步：打开通过RTE环境为工程添加的文件EventRecorderConf.h，配置如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170712458-796173079.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;这里主要设置方框里面的两个参数。&lt;/p&gt;
&lt;p&gt;Number of Records：表示Event Recorder缓冲可以记录的消息条数。&lt;/p&gt;
&lt;p&gt;Time Stamp Source：表示时间戳来源，有如下四种可以选择，我们这里使用DWT时钟周期计数器。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170722770-339885817.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;由于选择的是DWT，因此EventRecorderCong.h文件中的Systick Configuration配置就不用管了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;==========================&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过上面的6步就完成了Event Recorder功能的添加，效果如下：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170730837-1887275229.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;添加完成后，还有非常重要的两点要特别注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  第1点：一定要使用当前最新的CMSIS软件包，当前是V5.4.0（随着时间的推移，如果升级了新版本，直接使用新版即可）。大家可以从这里下载：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;http://www.keil.com/dd2/pack/&quot;&gt;http://www.keil.com/dd2/pack/&lt;/a&gt; 。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170743570-795985284.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;下载并导入到MDK后，需要大家更新自己现有工程CMSIS文件里面的头文件，可以直接将CMSIS文件夹中Include文件里面的所有文件全部删掉，替换为MDK安装目录如下路径里面的所有头文件：&lt;/p&gt;
&lt;p&gt;ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Include。保证头文件都是最新的5.4.0版本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 第2点：由于使能了printf重定向，大家的工程里面一定不要再做重定向了，比如fpuc，fgetc。另外当前选择了微库MicroLib：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170753296-1595622046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这两点后，就可以使用Event Recorder的功能了。&lt;/p&gt;
&lt;h2&gt;8.4   Event Recorder事件记录的实现&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;Event Recorder的使用也比较省事，这里也分步为大家进行说明：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;  第1步：初始化，仅需添加如下两行代码即可。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化EventRecorder并开启 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

EventRecorderInitialize(EventRecordAll, &lt;/span&gt;&lt;span&gt;1U&lt;/span&gt;&lt;span&gt;);

EventRecorderStart();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;  第2步：调用Event Recorder的API就可以使用了，主要有以下三个API：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;EventRecord2：可以发送两个32位数据。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;EventRecord4：可以发送四个32位数据。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;EventRecordData：可以发送字符串。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;显然这三个函数没有printf使用方便，所以对于这三个函数，大家做个简单的了解即可。教程配套例子里面有调用到这三个函数，可以操作熟悉下。这三个API的说明是在对应的help文档中，即MDK安装目录路径：/ARM/PACK/Keil/ARM_Compiler/1.6.0/Doc/General/html/index.html。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170823924-1313151585.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;  第3步：进入调试状态，选上周期更新：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170835111-4014127.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;点击全速运行：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170841075-1431321286.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;然后将Event Recorder调试组件展示出来：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170846954-2105203746.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170853463-663215090.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;另外，这里有个知识点需要大家了解下，如果程序里面也调用了Event Statistics时间测量函数，那么也会在这个界面里面展示消息的，如何才能仅展示大家想看的功能呢？这就需要用到Event Recorder支持的筛选功能。使用这个功能需要大家先暂停全速运行，然后点击下面这个选项：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170910775-685826858.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;弹出的界面里面可以设置哪些选项显示，哪些选项不显示（勾上表示显示），我们这里取消Event Statistics的显示，设置完毕后记得点击OK按钮。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170917532-1982127040.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;这就不展示Event Statistics的内容了。再次启动全速运行前，下面这个选项的对勾别忘了勾上。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170924472-19062076.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;8.5   Event Recorder实现printf重定向&lt;/h2&gt;
&lt;p&gt;实现printf输出需要用到MDK调试组件中的Debug(printf) Viewer，输出效果就跟大家使用串口调试软件一样，可以输出中文和英文。&lt;/p&gt;
&lt;p&gt;MDK的printf调试组件使用方法跟本章8.4小节中的说明一样，点击调试，选中周期运行，然后显示Debug(printf) Viewer调试组件：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170935735-1059077410.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423170941726-480965403.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;另外，还有一个知识点需要给大家做个补充，使用SWD接口的SWO引脚也是可以做串口打印的，并且也是通过这个调试组件Debug(printf) Viewer进行输出。只是这种方式的性能没有Event Viewer强，而且要多占用一个SWO引脚。&lt;/p&gt;

&lt;p&gt;关于SWO输出方式可以看此贴：&lt;a href=&quot;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=526&quot;&gt;http://forum.armfly.com/forum.php?mod=viewthread&amp;amp;tid=526&lt;/a&gt; 。&lt;/p&gt;
&lt;h2&gt;8.6   Event Statistics 时间测量功能的实现&lt;/h2&gt;
&lt;p&gt;时间测量功能简单易用，仅需一个起始函数，一个停止函数即可。当前支持4组，每组支持16路测量，也就是可以同时测量64路。&lt;/p&gt;
&lt;p&gt;时间测量的API函数支持多任务和中断里面随意调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、  测量起始函数：EventStartG (slot) 或者EventStartGv (slot, val1, val2)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 函数中的字母G是表示分组A，B，C，D，即实际调用函数为EventStartA，EventStartB，EventStartC和EventStartD。&lt;/li&gt;
&lt;li&gt;  函数的第一个形参slot的范围是0-15，也就是每个分组可以测试16路。&lt;/li&gt;
&lt;li&gt;  函数后面的两个形象val1和val2是32位变量，用户可以用这两个形参来传递变量数值给Event Statistics调试组件里面，方便图形化展示。简单的说，这两个变量仅仅起到一个传递变量数值的作用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、  测量停止函数：EventStopG (slot) 或者  EventStopGv (slot, val1, val2)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  函数中的字母G是表示分组A，B，C，D，即实际调用函数为EventStopA，EventStopB，EventStopC和EventStopD。&lt;/li&gt;
&lt;li&gt;  函数的第一个形参slot的范围是0-15，也就是每个分组可以测试16路。&lt;/li&gt;
&lt;li&gt; 函数后面的两个形象val1和val2是32位变量，用户可以用这两个形参来传递变量数值给Event Statistics调试组件里面，方便图形化展示。简单的说，这两个变量仅仅起到一个传递变量数值的作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里也分步为大家说明Event Statistics时间测量功能的使用方法。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  第1步：初始化，仅需添加如下两行代码即可。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化EventRecorder并开启 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

EventRecorderInitialize(EventRecordAll, &lt;/span&gt;&lt;span&gt;1U&lt;/span&gt;&lt;span&gt;);

EventRecorderStart();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  第2步：在要测量的代码前后加上起始和结束时间。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
EventStartA(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

测量的代码部分

EventStopA(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是用分组A的测量通道0。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  第3步：跟本章8.4小节讲解的一样，点击调试，选择周期更新选项，然后全速运行。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  第4步：全速运行后，显示Event Statistics调试组件。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171003998-1481745199.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;比如我这里简单的测试了一个5ms的延迟函数，效果如下（测量时间是动态更新的）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171020473-1286557281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外要注意一点，微秒的时间单位us可能无法正常显示，这个是没有关系的：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171028567-1545713545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;8.7   Event Statistics 功耗测量功能的实现&lt;/h2&gt;
&lt;p&gt;当前仅KEIL自家的ULINKplus支持功耗测量功能，这款下载器不便宜，一套5000多，大家有个了解即可，我们这里就不做讲解了。&lt;/p&gt;
&lt;h2&gt;8.8   Event Recorder对RTX5及其所有中间件的支持&lt;/h2&gt;
&lt;p&gt;后面做RTX5及其所有中间件的教程时会为大家做讲解，这里让大家看下效果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;  RTX5组件和使用Event Recoder的效果：&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171050048-1291656169.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171056678-1879169006.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;  网络调试组件效果展示：&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171103643-1933727879.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171111974-321393761.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;  文件系统和USB协议栈的效果展示:&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171124344-339297810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;8.9   JLINK配置说明&lt;/h2&gt;
&lt;p&gt;为了帮助大家更好的使用JLINK，这里将JLINK配置中关键的几个地方做个说明。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  &lt;span&gt;下面这个地方最重要&lt;/span&gt;，&lt;span&gt;一定要正确设置当前系统工作的主频，如果不正确，会导致Event Statistics的时间统计不正确&lt;/span&gt;（&lt;span&gt;对于H7，Core部分要填400MHz&lt;/span&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171141355-2037635743.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;注：如果大家调试状态弹出SWD配置时钟超出范围的问题，可以考虑将上面截图中的Enable选项的对勾取消掉即可，但内核时钟一定要修改为芯片的主频。&lt;/p&gt;
&lt;p&gt;另外，进入调试状态后，右下角的时间是否正常更新都没有关系：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171155032-1062163499.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;  其它选项配置如下（只要大家的工程能够正常调试，配置就是没问题的）：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171207932-174177049.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171214278-1242779705.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171222606-939395241.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171229169-342626374.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;8.10 STLINK配置说明&lt;/h2&gt;
&lt;p&gt;为了帮助大家更好的使用STLINK，这里将STLINK配置中关键的几个地方做个说明。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  &lt;span&gt;下面这个地方最重要&lt;/span&gt;，&lt;span&gt;一定要正确设置当前系统工作的主频，如果不正确，会导致Event Statistics的时间统计是不正确的&lt;/span&gt;（&lt;span&gt;对于H7，Core部分要填400MHz&lt;/span&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171240569-758975852.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;另外注意，进入调试状态后，右下角的时间是否正常更新都没有关系：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171248157-154182714.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;其它选项配置如下（只要大家的工程能够正常调试，配置就是没问题的）&lt;/span&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171305488-344479310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171315047-1137310004.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171321495-448746961.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;8.11 CMSIS-DAP配置说明&lt;/h2&gt;
&lt;p&gt;为了帮助大家更好的使用CMSIS-DAP，这里将CMSIS-DAP配置中关键的几个地方做个说明。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  &lt;span&gt;下面这个地方最重要&lt;/span&gt;，&lt;span&gt;一定要正确设置当前系统工作的主频，如果不正确，会导致Event Statistics的时间统计不正确&lt;/span&gt;（&lt;span&gt;对于H7，Core部分要填400MHz&lt;/span&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171333543-1274990382.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;另外注意，进入调试状态后，右下角的时间是否正常更新都没有关系：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171340046-1836940012.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  &lt;span&gt;其它选项配置如下（只要大家的工程能够正常调试，配置就是没问题的）&lt;/span&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171353528-2008866492.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171402755-1032571939.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171409571-410591039.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171416541-712936949.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171424361-1410212227.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;8.12 ULINK配置说明&lt;/h2&gt;
&lt;p&gt;由于手头没有ULINK，这里就不做讲解了。如果大家需要相关配置，按照前面小节三款LINK的配置照葫芦画瓢搞一下即可，或者在MDK安装目录的路径ARM\Hlp下有对应的文档说明：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171434731-1135271103.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;8.13 配套例子&lt;/h2&gt;
&lt;p&gt;本章节教程配套了如下例程，仅MDK版本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;  V7-008_终极调试组件EventRecoder的使用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体代码实现也比较简单，以V6开发板为例，定义一个TIM6的中断，中断频率是500Hz，通过Event Statistics测量中断的执行频率。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bsp.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EventRecorder.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

 

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 定时器频率，500Hz &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt;  timerINTERRUPT_FREQUENCY    500

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 中断优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt;  timerHIGHEST_PRIORITY       10

 

    

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vEventRecorderTest

*    功能说明: 创建定时器

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; vEventRecorderTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     bsp_SetTIMforInt(TIM6, timerINTERRUPT_FREQUENCY, timerHIGHEST_PRIORITY, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

     EventStartB(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);   

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TIM6_DAC_IRQHandler

*    功能说明: TIM6中断服务程序。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; TIM6_DAC_IRQHandler( &lt;span&gt;void&lt;/span&gt;&lt;span&gt; )

{

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((TIM6-&amp;gt;SR &amp;amp; TIM_FLAG_UPDATE) !=&lt;span&gt; RESET)

     {

         EventStopB(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);    

         EventStartB(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);   

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 清除更新标志 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         TIM6&lt;/span&gt;-&amp;gt;SR = ~&lt;span&gt; TIM_FLAG_UPDATE;

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下，测量的平均频率是1.98ms，与我们设计的500Hz基本符合：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171452996-1784634573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用程序的设计如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bsp.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 底层硬件驱动 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EventRecorder.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                              函数和变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vEventRecorderTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

uint8_t s_ucBuf[&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;armfly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: main

*    功能说明: c程序入口

*    形    参：无

*    返 回 值: 错误代码(无需处理)

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t ucKeyCode;     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键代码 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     uint32_t t0 &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;, t1 = &lt;span&gt;0&lt;/span&gt;, t2 = &lt;span&gt;0&lt;/span&gt;, t3 = &lt;span&gt;0&lt;/span&gt;, t4 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

 

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化EventRecorder并开启 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     EventRecorderInitialize(EventRecordAll, &lt;/span&gt;&lt;span&gt;1U&lt;/span&gt;&lt;span&gt;);

     EventRecorderStart();

    

     bsp_Init();        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 硬件初始化 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

 

     bsp_StartAutoTimer(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 启动1个200ms的自动重装的定时器 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测量中断周期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     vEventRecorderTest();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 进入主程序循环体 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         bsp_Idle();        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这个函数在bsp.c文件。用户可以修改这个函数实现CPU休眠和喂狗 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 判断定时器超时时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;if&lt;/span&gt; (bsp_CheckTimer(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))

         {

              EventStartA(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);  

              EventStopA(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

             

              EventStartA(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

              bsp_DelayMS(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);

              EventStopA(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

             

              EventStartA(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

              bsp_DelayMS(&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);

              EventStopA(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

             

              t0&lt;/span&gt;++&lt;span&gt;;

              EventStartAv(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;, t0, t0);

              bsp_DelayMS(&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);

              EventStopAv(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;, t0, t0);

         }

 

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键滤波和检测由后台systick中断服务程序实现，我们只需要调用bsp_GetKey读取键值即可。 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         ucKeyCode &lt;/span&gt;= bsp_GetKey();   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 读取键值, 无键按下时返回 KEY_NONE = 0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;if&lt;/span&gt; (ucKeyCode !=&lt;span&gt; KEY_NONE)

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ucKeyCode)

              {

                   &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; KEY_DOWN_K1:           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K1键按下 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                       t1 &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

                       t2 &lt;/span&gt;+= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

                        EventRecord2(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;EventLevelAPI, t1, t2);

                       t3 &lt;/span&gt;+= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;

                       t4 &lt;/span&gt;+= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

                       EventRecord4(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;EventLevelOp, t1, t2, t3, t4);

                       EventRecordData(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;+EventLevelOp, s_ucBuf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(s_ucBuf));

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; KEY_DOWN_K2:           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K2键按下 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K2按键按下\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; KEY_DOWN_K3:           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K3键按下 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K3按键按下\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:

                        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其它的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                       &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应用程序里面主要实现了三个功能：&lt;/p&gt;
&lt;p&gt;  1、利用测量分组A实现4路时间的测量（第1路什么也没有测量，可以用来表示这两个函数本身执行占用的时间）。每100ms测量一次时间，效果如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171511611-71218838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、利用函数EventRecord2，EventRecord4和EventRecordData发送消息事件。按下按键K1进行更新，效果如下：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171518526-156238750.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;  3、基于Event Recorder的printf重定向。按下按键K2或者K3会打印消息，效果如下：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1379107/201904/1379107-20190423171525167-1892379583.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;8.14 总结&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;Event Recoder还是非常实用的，建议大家多使用几次，熟练掌握。基本用上几次就上瘾，离不开了，的确是工程调试的利器。&lt;/p&gt;

</description>
<pubDate>Wed, 24 Apr 2019 06:39:00 +0000</pubDate>
<dc:creator>安富莱电子</dc:creator>
<og:description>完整教程下载地址：http://forum.armfly.com/forum.php?mod=viewthread&amp;tid=86980 第8章 STM32H7的终极调试组件Event Reco</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/armfly/p/10757582.html</dc:identifier>
</item>
<item>
<title>MOCK API 的定义及实践（使用eolinker实现） - 隔壁王书</title>
<link>http://www.cnblogs.com/dc20181010/p/10762240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dc20181010/p/10762240.html</guid>
<description>&lt;h3 id=&quot;mock-api-的定义&quot;&gt;MOCK API 的定义&lt;/h3&gt;
&lt;p&gt;根据百度百科的定义，mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。这个虚拟的对象就是mock对象，mock对象就是真实对象在调试期间的代替品。&lt;/p&gt;
&lt;p&gt;在瀑布流开发模式中，如果前端开发人员需要进行页面对接，需要后端先完成API的开发工作，如果没有mock，那么前后端开发的进度会互相影响。&lt;/p&gt;
&lt;p&gt;通过 Mock API事先编写好 API 的数据生成规则，由工具动态生成 API 的返回数据。开发人员通过访问 Mock API 来获得页面所需要的数据，就可以轻松地完成对接工作。&lt;/p&gt;
&lt;h3 id=&quot;mock-api-能用来解决什么&quot;&gt;MOCK API 能用来解决什么？&lt;/h3&gt;
&lt;h4 id=&quot;依赖的接口尚未开发完成&quot;&gt;1.依赖的接口尚未开发完成&lt;/h4&gt;
&lt;p&gt;在系统交互双方定义好接口之后，我们可以提前进行开发和测试，并不依赖上游系统的开发实现。&lt;/p&gt;
&lt;h4 id=&quot;自定义返回测试结果比如-httpservletrequetjdbc-对象等&quot;&gt;2.自定义返回测试结果（比如 HttpservletRequet、JDBC 对象等）&lt;/h4&gt;
&lt;p&gt;在测试时使用Mock，可以自由方便的构建配置接口对象的信息参数；&lt;/p&gt;
&lt;p&gt;在测试过程中，需要第三方接口返回特定的数据以符合特定的测试场景，这种情况往往需要跨条线的沟通协调测试数据，成本高，效率低；利用Mock可以自定义返回测试结果，支持手动构造依赖接口的返回值。（这个功能将在后面重点提及）&lt;/p&gt;
&lt;h4 id=&quot;自动化测试&quot;&gt;3.自动化测试&lt;/h4&gt;
&lt;p&gt;在自动化测试概念和发展要求下，自动化测试的规模也逐渐增大到一定程度；&lt;/p&gt;
&lt;p&gt;大型业务系统下测试接口多，测试用例也日益增多，依赖环境的稳定就成为了自动化测试执行的关键所在；&lt;/p&gt;
&lt;p&gt;自动化测试过程中，经常会因为依赖的第三方环境不稳定，导致测试执行失败，长期以往的出现问题，导致测试人员对自动化的稳定运行失去维护的信心；&lt;/p&gt;
&lt;p&gt;利用Mock技术，在测试过程中，只关注被测业务逻辑，mock掉依赖不相关的系统，这种情况下自动化测试运行失败，就一定是被测系统本身的业务逻辑问题，而不是第三方系统、数据的问题；&lt;/p&gt;
&lt;h4 id=&quot;更多场景欢迎看客老爷补充&quot;&gt;4.更多场景，欢迎看客老爷补充。&lt;/h4&gt;
&lt;h3 id=&quot;应用场景示例自定义返回结果&quot;&gt;应用场景示例（自定义返回结果）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;接下来我们从测试的层面举个场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我所在的项目是企业管理咨询，项目最经常需要的是根据企业详情判断返回不同的状态。涉及到的数据其实很多，但是为了方便举例，我计划写三个接口进行演示，第一个是登录，第二个是获取企业详情，简化了复杂的判断，直接用判断corpld(企业ID)来作为识别的凭证，第三个是设置企业状态，有注销和恢复两种状态。会根据企业的corpstatus进行判断。接下来带你一一设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FsvsQT0Ji46FoWAxIPoP3SP1rc8p&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登陆接口不必多讲，我们直接到第二个接口，新建一个期望，请求触发条件不写，在返回数据这里添加corpstatus可能值为1或者2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FiqckbnQv7J373XAvJKrJyYC9TeN&quot; alt=&quot;2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三个接口是设置企业状态（注销/恢复），这里需要两个请求参数，第一个是corpld企业ID，对应上个接口的corpld;第二个是corpstatus企业状态，这里引用了全局变量，用两对花括号表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/Fl4SwKbp6bW14B1lDj3BpwLU_4RJ&quot; alt=&quot;3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是进入mockapi新建期望，因为这里有两个状态（注销/恢复），所以需要写两个期望。当请求参数corpstatus=4条件触发时，返回参数content=注销成功；当请求参数corpstatus=2条件触发时，返回参数content=企业已恢复。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FibfQynEwD02xPyyJ7vZ_HU2GBsY&quot; alt=&quot;4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/Fj8xfvVMU2ymnhm9yU6Y102R_T2H&quot; alt=&quot;5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于这三个接口都是应用在一个场景里面的，我们不妨用一个流程进行测试的，总共三个测试用例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;登陆&lt;/li&gt;
&lt;li&gt;获取企业详情&lt;/li&gt;
&lt;li&gt;设置企业状态（注销/恢复）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在测试前需要在第二个用例中要写好一个响应预处理，通过Javascript代码动态改变返回的结果，实现corpstatus=2或者4，从而对应上之前的全局变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/Fjgc942kOqRWBUgFO3PcdcgZ2gMG&quot; alt=&quot;6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就可以点击进行测试。从测试记录可以看到会根据corpstatus的不同返回了不同的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FsLbDR8G-GTbsSW2eBv3wcxLLKTC&quot; alt=&quot;7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FmQHlqPKINJm5PHaykoi70znlGfG&quot; alt=&quot;8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是一个简略完整的一个场景用例设计。那如果没有mockapi的话，等着后端开发，corpstatus可能就拿不到，进度势必会被影响，为了模拟数据测试，这时候mockapi的优势就凸显了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面再讲一个使用mock自定义功能的项目场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前所在公司子系统较多，我们为了减低集成和维护成本，采用了ESB的架构。ESB架构可以解决多个应用系统互联所面临的的复杂性。也是因为子系统较多导致整个业务系统的运转比较复杂，其中便涉及到和多个外部系统的对接及数据交互，比如仓储和物流，势必会跟EMS、顺丰等有数据交互。&lt;/p&gt;
&lt;p&gt;当然，跟外部系统对接时系统间的联调测试必不可少，有些外部系统提供测试环境，有些甚至不提供。即便是提供测试环境的外部系统，一般也仅在开发联调阶段配合提供联调测试对接服务，一旦联调测试结束，也不再继续提供测试服务。&lt;/p&gt;
&lt;p&gt;那么，当这些外部系统的联调测试环境不可用时，我们就需模拟这些外部系统来和自己的系统进行数据交互，以便支持完整业务测试流程的正常进行。&lt;/p&gt;
&lt;p&gt;再具体到API开发层面的话，就是开发的API经常遇到在URL一样的情况下，需要根据请求头或者请求体的不同，返回不同测试结果。以前没用mockapi自定义的功能的话，解决的方式只有新建多个接口分别进行，十分麻烦。&lt;/p&gt;
&lt;p&gt;举个例子，在API文档建立后，在进行测试时，我的要求是在URL一样的情况下，根据不同的请求头部返回不同结果。&lt;/p&gt;
&lt;p&gt;1.当标签头部&lt;br/&gt;Contest-type=application/json&lt;br/&gt;Clientld=purchase.consemer&lt;br/&gt;OperationCode= medicine.purchase.consemer.List&lt;/p&gt;
&lt;p&gt;那么返回参数&lt;br/&gt;Floor=2&lt;br/&gt;Room=2&lt;br/&gt;Cabinet=2&lt;/p&gt;
&lt;p&gt;2.当标签头部&lt;br/&gt;Contest-type=application/json1&lt;br/&gt;Clientld=purchase.consemer1&lt;br/&gt;OperationCode= medicine.purchase.consemer.List1&lt;/p&gt;
&lt;p&gt;那么返回参数&lt;br/&gt;Floor=3&lt;br/&gt;Room=3&lt;br/&gt;Cabinet=3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 eolinker 进行自定义 MOCK API？&lt;/strong&gt;&lt;br/&gt;eolinker 是一款接口管理工具，提供API管理、测试功能，本次我们使用它来进行 Mock API，官网地址：&lt;a href=&quot;http://www.eolinker.com/#/?ref=cnblogs&quot;&gt;https://www.eolinker.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.先建立好文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FhHSRXrXOXn14nvGSMF9UuUtImpV&quot; alt=&quot;9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.建立期望进行测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FstN4sd9yAo4-m61muPwShW0_jHb&quot; alt=&quot;10.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.写完后测试后返回的数据与我们的想要的一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FrisE87rKiClZ1N7vo7RnwmGKD5T&quot; alt=&quot;11.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.第二种情况类似，就不赘述了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FlQYHEXQSJcSwv9RKipZaqU9pvPM&quot; alt=&quot;12.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本篇文章主要从测试层面和角度去介绍 MOCK API，下篇我会从开发的层面去介绍 MOCK API 的实际应用。希望对大家有所帮助。eolinker官网：&lt;a href=&quot;https://s.growingio.com/ddx3bP&quot;&gt;https://www.eolinker.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 06:33:00 +0000</pubDate>
<dc:creator>隔壁王书</dc:creator>
<og:description>MOCK API 的定义 根据百度百科的定义，mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。这个虚拟的对象就是mock对象，mock对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dc20181010/p/10762240.html</dc:identifier>
</item>
<item>
<title>深入vue - 源码目录及构建过程分析 - wolfSoul</title>
<link>http://www.cnblogs.com/yuqing6/p/10762171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuqing6/p/10762171.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;em&gt; 公众号原文链接：&lt;/em&gt;&lt;em&gt;&lt;a title=&quot;深入vue - 源码目录及构建过程分析&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NTA4NTIwNA==&amp;amp;mid=2247483812&amp;amp;idx=1&amp;amp;sn=7143c589ebf0868375cc7485d92678e3&amp;amp;chksm=ce5e33dff929bac9b8eb6af851880033e8cc7141a53b0d5ab402d56d94497a30013752345b32&amp;amp;token=2069117221&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;深入vue - 源码目录及构建过程分析 &lt;/a&gt;&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;   喜欢本文可以扫描下方二维码关注我的公众号 「前端小苑」&lt;/span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;​“&lt;/strong&gt; 本文主要梳理一下vue代码的目录，以及vue代码构建流程，旨在对vue源码整体有一个认知，有助于后续对源码的阅读。&lt;strong&gt;”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;一、目录结构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055753/201904/1055753-20190424141031495-2115649168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上图是对vue的代码的所有目录进行的梳理，其中源码位于src目录下，下面对src下的目录进行介绍。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;compiler&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;该目录是编译相关的代码，即将 template 模板转化成 render 函数的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vue 提供了 render 函数，render 函数作用是用来创建 VNode，但在平时开发中，绝大多数情况下使用 template 来创建 HTML，所以需要将 template模板编译成 render 函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编译工作既可以在代码构建时做，也可以在客户端运行时做，但编译十分消耗性能，所以在项目中建议使用 runtime 版本。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;core&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这部分代码是 vue 的核心代码，可以说是 vue 的灵魂所在，也是我们要重点学习的源码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;core目录又包含如下子目录。&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;components -- 内置组件的代码，即 keep-alive 代码&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;global-api -- 全局API代码，mixin，extend 等 api 在这里实现&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;instance -- vue实例化相关代码，包括初始化，事件，生命周期，渲染等部分的代码&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;observer -- 响应式数据相关代码&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;util -- 工具方法&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;vdom -- 虚拟 dom 的代码。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;platforms&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;platforms下包含两个子目录，web 和 weex。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分别代表可以打包生成在web端使用的 vue 代码和在native端使用的 weex 代码。美团开源的开发微信小程序的 mpvue 框架也是在这个目录下进行拓展的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过不同平台的入口就可以打包出运行在不同平台的版本的 vue 文件，后面代码构建部分会介绍具体的构建过程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;server&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;该目录下是 SSR 相关的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Vue.js 是构建客户端应用程序的框架。除了可以在浏览器中输出 Vue 组件，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;sfc&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们平时开发时，都是写 .vue 文件。sfc 的代码就是提供一个解析器，把.vue文件代码解析成一个 javascript 对象。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;shared&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;该目录下定义了一些公用的工具方法，提供给上面的几个目录内代码使用。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、源码编译&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;vue的源码按照功能拆分的十分清晰，每个功能都有单独的目录，那么项目中引用的vue文件是怎么编译出来的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，我们看一下编译输出的dist目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055753/201904/1055753-20190424113832169-286927368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，dist下有10几种不同版本的vue文件，他们是根据不同规范（包括 CommonJS规范，ES Module，UMD）和 是否包含编译器 构建出的不同版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vue源码选择了rollup进行构建，rollup相比于webpack，更加轻量，编译后的代码更加干净，更适合javascript库的构建，除了vue以外，像React，Ember，D3，Three.js 以及其他很多开源库也选择了Rollup 进行构建。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面看一下vue具体构建过程，首先到pakage.json中看下vue编译执行的命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055753/201904/1055753-20190424113858525-1554294713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从命令可以看出，构建命令就是执行 scripts 目录下 build.js 文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是 scripts/build.js 核心代码&lt;span&gt;&lt;em&gt;（&lt;/em&gt;&lt;em&gt;下文中&lt;/em&gt;汉字&lt;/span&gt;注释部分是为方便理解自己补充的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055753/201904/1055753-20190424113937564-1398888554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从代码可以看出，首先通过 script/config.js 文件的getAllBuilds方法获取配置，然后根据构建命令传入的参数对配置进行过滤，最后根据过滤后的配置执行build函数，编译出对应版本的vue文件。&lt;span&gt;&lt;em&gt;(这里介绍代码构建的过程，主要说明vue是怎么构建出不同版本代码的，build方法在此不做分析)&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们在看一下配置文件 script/config.js 中的 getAllBuilds 是怎么获取具体配置的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055753/201904/1055753-20190424140741680-1159657125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看出，getAllBuilds 方法首先通过 Object.keys 拿到 builds 对象所有key的组成的数组，并通过map遍历执行genConfig方法。下面我们先看一下builds对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055753/201904/1055753-20190424140820871-684296958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看出，builds对象是不同版本vue的编译配置。具体配置项的作用，已经用注释在代码中标出。接下来我们看下genConfig函数做了什么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055753/201904/1055753-20190424140849517-1831629903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;genConfig 通过 key 拿到 builds 中每个key对应的配置对象，然后根据这个对象重新定义一个 config 对象，这个 config 对象的结构才是 rollup 配置真正需要的结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看了 builds 对象和 genConfig 方法，我们就知道了 getAllBuilds 的目的，是通过映射把 builds 配置对象转化成 rollup 所需要的配置数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，我们就清楚是如何构建出不同版本的vue代码了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三、心得&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;学习源码时，不建议按照源码的顺序一行一行的阅读。首先要抓住主干，先梳理清楚主要的代码逻辑，再去仔细阅读具体的每行代码。另外按照源码顺序阅读可能很枯燥，很难坚持下来，可以先选择自己感兴趣的部分进行学习，最后再串联起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;如果喜欢本文请扫描关注公众号前端小苑，下一篇vue源码文章，将为大家介绍 render 函数和 Virtual DOM 。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055753/201904/1055753-20190424142254020-1039176415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 24 Apr 2019 06:27:00 +0000</pubDate>
<dc:creator>wolfSoul</dc:creator>
<og:description>​“ 本文主要梳理一下vue代码的目录，以及vue代码构建流程，旨在对vue源码整体有一个认知，有助于后续对源码的阅读。”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuqing6/p/10762171.html</dc:identifier>
</item>
<item>
<title>沉默的中年人-写在工作5年之际 - 才子锅锅</title>
<link>http://www.cnblogs.com/ihardcoder/p/10761953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ihardcoder/p/10761953.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当时我是年轻人，觉得能洁身自好不去害别人就可以了。现在我是中年人——一个社会里，中年人要负很重的责任；要对社会负责，要对年轻人负责，不能只顾自己。&lt;br/&gt;——王小波《沉默的大多数》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;南京4年，上海3年，我已经习惯了长三角湿润的气候和甜不拉几的饭菜，在5年前的今天买了一张卧铺票，穿着秋裤离开了正值阴冷雨季的上海来到北京，迎接我的是春天的大风和糊了一脸的杨柳絮以及在秋裤的助攻下快把我捂中暑的北方五月天。当天，在中钢大厦优酷的茶水间签完劳动合同之后，买了一份庆丰包子铺的主席套餐，住进了四季青附近的一家快捷酒店，用三条朋友圈正式宣告了北漂的开始。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595796/201904/595796-20190424135203931-151091897.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后是还算“顺利”的找房租房，用最后一点残余的实习工资在马连洼城中村租下了一间拆迁价值连城的违建民房，1000块钱月租的“单身公寓”类似大学宿舍的上床下桌，只不过改成了上床下厕，东西南北皆不通透的屋子里充满了吲哚被稀释1万倍之后的清香气息。登时一位在北京的朋友参观完我的”公寓“之后非常感性的说了句：真鸡儿奢华。不过我倒是没有很在意，满脑子都是初入社会的新鲜感和要去后海酒吧撒欢的浪劲儿。&lt;/p&gt;
&lt;p&gt;2014年的北京有4毛钱随便坐的公交车和2块钱跑全程的地铁，让已经习惯了上海地铁动辄五六块票价的我倍儿感动，恨不得立即翻出角落里鲜红的红领巾跑到天安门前敬一个少先队员礼高喊我是社会主义接班人。除了极其便宜的交通费以外，初到北京让我不习惯的还有满大街的”您“和儿化音，然而很快就在北京话强大的感染力之下重新找回了骨子里北方人的精气神儿，连吵架的开场词都改成了倍儿客气的“您特么的”，朋友圈的画风也从满嘴骚话的矫情模式切换到了相声模式。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595796/201904/595796-20190424135223458-803610133.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595796/201904/595796-20190424135931802-907426853.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回想当时非常巧合地拿到优酷offer之后几乎没有一丝犹豫就来到北京的原因可能就是单纯的离家近。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595796/201904/595796-20190424135235907-900874522.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样说可能对优酷有些不公平，但跟当时稳步前行的携程比起来，优酷的工作岗位并没有很大的竞争力，并且当时我本就没有很强的事业心。自从高考一志愿落榜之后我基本上已经接受了自己是无名小卒的设定，那种在电视剧里活不过一集、台词仅有“大侠饶命”、被阿紫下毒割了舌头的店小二。随后在优酷参加的第一个项目得了个“最佳贡献奖”之后，我的自信心似乎稍稍找回了些，待人接物也友善了许多，看雾霾都觉得芬芳四溢，连脸大似馕的产品经理都可爱了起来。至今我仍然很感激优酷同事给予的肯定和鼓励，这些无形的力量促进了我一步步的成长。&lt;/p&gt;
&lt;p&gt;跳槽在这个行业内是非常普遍的现象，促使一个人跳槽的原因多种多样。参加工作至今5年里我换了三家公司，严格来说应该是四家，2016年为了与曾经在优酷并肩战斗的伙伴们一起体验创业的成就感，离开了入职不到一个月的今日头条毅然决然地加入了58到家，反观如今已经成为巨头的今日头条，可能无形中错过了财务自由的机会，并且在58的结局也并不愉快。离开58之后，选择搜狗最主要的原因是对地图类应用涉及的技术感兴趣，所以放弃了钱更多团队规模更大的站酷和职级更高业务更核心的搜狐。薪酬、团队、环境等客观条件诚然是衡量一份工作的必要因素，但我觉得在参加工作的最初几年内，决定一份工作是否适合自己最核心的因素是它是否给了你最想要的东西。最想要钱，那就选钱多的；最想要成长，那就选技术最好的。对于我来说，在最想体验创业成就感的时候加入58是最正确的选择；在最想得到技术成长的时候加入搜狗地图也是最正确的选择。至于以后怎样，谁知道呢。&lt;/p&gt;
&lt;p&gt;加入社会之后，你必须接受再怎么努力也可能达不到理想的目标，以及个人的努力并非是达成目标的唯一甚至主要途径。近两年通过参加前端行业的一些线下会议和论坛，认识了一些技术大牛比如winter，在佩服之余感叹自己达到与之相同水平的可能性几乎为零；也观赏了一些喜欢互捧臭脚的技术网红和会虫，把非常浅显的技术表述的天花乱坠，在鄙视之余警示自己万不可与之为伍。工作期间也见识过连cookie可跨子域名都不知道楞要用iframe的前端架构师。诚然每个人都有技术盲点，但如果连一些常识性的东西都不知道就说不过去了。然而即使对这些人心存鄙夷，也仍然要在大多数时候保持表面上的尊重和友善，学会沉默可能是身在职场的必备技能之一。&lt;/p&gt;
&lt;p&gt;每个技术从业者可能都或多或少地写过博客发表过文章，必须承认的一点是：阅读量最高点赞数最多的往往是一些入门级的“how to”文章。这类文章普遍带有强烈的个人色彩，不应该作为新入行者的“启蒙教材”。其实这种现象并非技术领域独有，在所有行业中最不缺的就是宁愿拾人牙慧也不愿阅读说明手册的伸手党，这些才是“how to”文章的主要目标读者。所以工作越久就越来越远离一些技术社区，写博客成为了单纯的记录而非是要教会别人一些东西。当然，这只是我的个人愚见，如果冒犯了一些人我表示抱歉，更抱歉的是我觉得说的没错。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595796/201904/595796-20190424135247605-1900210564.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟小说不同的是，生活很平淡，没有妻离子散国仇家恨，不必餐风露宿；然而生活也很艰难，没有主角光环高人相助，必须独立前行。愿下个5年继续平淡中前行。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 06:06:00 +0000</pubDate>
<dc:creator>才子锅锅</dc:creator>
<og:description>当时我是年轻人，觉得能洁身自好不去害别人就可以了。现在我是中年人——一个社会里，中年人要负很重的责任；要对社会负责，要对年轻人负责，不能只顾自己。 ——王小波《沉默的大多数》 南京4年，上海3年，我已</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ihardcoder/p/10761953.html</dc:identifier>
</item>
<item>
<title>你必须知道的 SmartSql ！ - Ahoo-Wang</title>
<link>http://www.cnblogs.com/Ahoo-Wang/p/SmartSql-README.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ahoo-Wang/p/SmartSql-README.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.smartsql.net/&quot; target=&quot;_blank&quot;&gt;&lt;img width=&quot;100&quot; src=&quot;https://raw.githubusercontent.com/dotnetcore/SmartSql/master/SmartSql.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SmartSql = MyBatis + Cache(Memory | Redis) + R/W Splitting +Dynamic Repository + Diagnostics ......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;简洁、高效、高性能、扩展性、监控、渐进式开发！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;她是如何工作的&quot;&gt;她是如何工作的？&lt;/h2&gt;
&lt;p&gt;SmartSql 借鉴了 MyBatis 的思想，使用 XML 来管理 SQL ，并且提供了若干个筛选器标签来消除代码层面的各种 if/else 的判断分支。&lt;/p&gt;
&lt;p&gt;SmartSql将管理你的 SQL ，并且通过筛选标签来维护本来你在代码层面的各种条件判断，使你的代码更加优美。&lt;/p&gt;
&lt;h2 id=&quot;为什么选择-smartsql&quot;&gt;为什么选择 SmartSql ？&lt;/h2&gt;
&lt;p&gt;DotNet 体系下大都是 Linq 系的 ORM，Linq 很好，消除了开发人员对 SQL 的依赖。&lt;br/&gt;但却忽视了一点，SQL 本身并不复杂，而且在复杂查询场景当中开发人员很难通过编写Linq来生成良好性能的SQL，相信使用过EF的同学一定有这样的体验：“我想好了Sql怎么写，然后再来写Linq,完了可能还要再查看一下Linq输出的Sql是什么样的“。这是非常糟糕的体验。要想对Sql做绝对的优化，那么开发者必须对Sql有绝对的控制权。另外Sql本身很简单，为何要增加一层翻译器呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6.4571428571429&quot;&gt;
&lt;p&gt;SmartSql 从正式开源已历经俩年多的时间，在生产环境经过若干个微服务验证。&lt;br/&gt;同时也有一部分企业正在使用 SmartSql （如果您也在使用 SmartSql 欢迎提交issue）&lt;a href=&quot;https://github.com/dotnetcore/SmartSql/issues/13&quot;&gt;Who is using SmartSql&lt;/a&gt;。&lt;br/&gt;目前已加入 &lt;a href=&quot;https://github.com/dotnetcore&quot;&gt;NCC&lt;/a&gt;。&lt;br/&gt;未来(&lt;a href=&quot;https://github.com/dotnetcore/SmartSql/issues/47&quot;&gt;Roadmap-2019&lt;/a&gt;) SmartSql 也会持续加入一些新的特性来帮助开发者提升效率。欢迎提交 Issue &lt;a href=&quot;https://github.com/dotnetcore/SmartSql/issues&quot; class=&quot;uri&quot;&gt;https://github.com/dotnetcore/SmartSql/issues&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;那么为什么不是-dapper或者-dbhelper&quot;&gt;那么为什么不是 Dapper，或者 DbHelper ？&lt;/h2&gt;
&lt;p&gt;Dapper 确实很好，并且又很好的性能，但是会让给你的代码里边充斥着 SQL 和各种判断分支，这些将会使代码维护难以阅读和维护。另外 Dapper 只提供了DataReader 到 Entity 的反序列化功能。而 SmartSql 提供了大量的特性来提升开发者的效率。&lt;/p&gt;
&lt;h2 id=&quot;特性概览&quot;&gt;特性概览&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/SmartSql-features.png&quot; alt=&quot;SmartSql&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;动态仓储&quot;&gt;动态仓储&lt;/h2&gt;
&lt;p&gt;动态代理仓储(SmartSql.DyRepository)组件是 SmartSql 非常独特的功能，它能简化 SmartSql 的使用。对业务代码几乎没有侵入。可以说使用 ISqlMapper 是原始方法，而 DyRepository 自动帮你实现这些方法。&lt;/p&gt;
&lt;p&gt;DyRepository 的表现是只需要定义仓储接口，通过简单配置就能自动实现这些接口并注册到 IoC 容器中，使用时注入即刻获取实现。原理是通过接口和接口方法的命名规则来获取 SmartSql 的 xml 文件中的 Scope 和 SqlId ，用接口方法的参数作为 Request ，通过 xml 中的 sql 自动判断是查询还是执行操作，最后实现对 ISqlMapper 的调用。&lt;/p&gt;
&lt;h3 id=&quot;定义仓储接口&quot;&gt;0. 定义仓储接口&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public interface IUserRepository : IRepository&amp;lt;User, long&amp;gt;
    {
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注入依赖&quot;&gt;1. 注入依赖&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;            services.AddSmartSql()
                .AddRepositoryFromAssembly(options =&amp;gt; { options.AssemblyString = &quot;SmartSql.Starter.Repository&quot;; });&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用&quot;&gt;2. 使用&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public class UserService
    {
        IUserRepository userRepository;

        public UserService(IActivityRepository userRepository)
        {
            this.userRepository = userRepository;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;smartsql-最佳实践---smartcode&quot;&gt;SmartSql 最佳实践 -&amp;gt; &lt;a href=&quot;https://github.com/dotnetcore/SmartCode&quot;&gt;SmartCode&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/SmartCode.gif&quot; alt=&quot;SmartCode&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;a href=&quot;https://github.com/dotnetcore/SmartCode&quot;&gt;SmartCode&lt;/a&gt; 开发人员仅需配置好数据库连接即可生成解决方案所需的一切，包括但不限于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决方案工程&lt;/li&gt;
&lt;li&gt;帮你 restore 一下&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;  ReStore:
    Type: Process
    Parameters: 
      FileName: powershell
      WorkingDirectory: '{{Project.Output.Path}}'
      Args: dotnet restore&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Docker
&lt;ul&gt;&lt;li&gt;构建 Docker 镜像 &amp;amp; 运行实例&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt; BuildDocker:
    Type: Process
    Parameters:
      FileName: powershell
      WorkingDirectory: '{{Project.Output.Path}}'
      Args: docker build -t {{Project.Parameters.DockerImage}}:v1.0.0 .

  RunDocker:
    Type: Process
    Parameters:
      FileName: powershell
      WorkingDirectory: '{{Project.Output.Path}}'
      Args: docker run --name {{Project.Parameters.DockerImage}} --rm -d -p 8008:80 {{Project.Parameters.DockerImage}}:v1.0.0 .&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;顺便开启个浏览器&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;  RunChrome:
    Type: Process
    Parameters:
      FileName: C:\Program Files (x86)\Google\Chrome\Application\chrome.exe
      CreateNoWindow: false
      Args: http://localhost:8008/swagger&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;docker&quot;&gt;Docker&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/docker-0.png&quot; alt=&quot;SmartCode&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/docker-1.png&quot; alt=&quot;SmartCode&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/docker-2.png&quot; alt=&quot;SmartCode&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/docker-3.png&quot; alt=&quot;SmartCode&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;smartcode-生成的目录结构&quot;&gt;SmartCode 生成的目录结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/SmartCode-directory-structure.png&quot; alt=&quot;SmartCode-directory-structure&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;读写分离&quot;&gt;读写分离&lt;/h2&gt;
&lt;p&gt;SmartSql 读写分离特别简便，仅需提供好配置即可：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;Database&amp;gt;
    &amp;lt;DbProvider Name=&quot;PostgreSql&quot;/&amp;gt;
    &amp;lt;Write Name=&quot;WriteDB&quot; ConnectionString=&quot;${Master}&quot;/&amp;gt;
    &amp;lt;Read Name=&quot;ReadDb-1&quot; ConnectionString=&quot;${Slave-0}&quot; Weight=&quot;100&quot;/&amp;gt;
    &amp;lt;Read Name=&quot;ReadDb-2&quot; ConnectionString=&quot;${Slave-1}&quot; Weight=&quot;100&quot;/&amp;gt;
  &amp;lt;/Database&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;缓存&quot;&gt;缓存&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Lru 最近最少使用算法&lt;/li&gt;
&lt;li&gt;Fifo 先进先出算法&lt;/li&gt;
&lt;li&gt;RedisCacheProvider&lt;/li&gt;
&lt;li&gt;其他继承自ICacheProvider缓存类型均可&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Caches&amp;gt;
    &amp;lt;Cache Id=&quot;LruCache&quot; Type=&quot;Lru&quot;&amp;gt;
      &amp;lt;Property Name=&quot;CacheSize&quot; Value=&quot;10&quot;/&amp;gt;
      &amp;lt;FlushOnExecute Statement=&quot;AllPrimitive.Insert&quot;/&amp;gt;
      &amp;lt;FlushInterval Hours=&quot;1&quot; Minutes=&quot;0&quot; Seconds=&quot;0&quot;/&amp;gt;
    &amp;lt;/Cache&amp;gt;
    &amp;lt;Cache Id=&quot;FifoCache&quot; Type=&quot;Fifo&quot;&amp;gt;
      &amp;lt;Property Name=&quot;CacheSize&quot; Value=&quot;10&quot;/&amp;gt;
    &amp;lt;/Cache&amp;gt;
    &amp;lt;Cache Id=&quot;RedisCache&quot; Type=&quot;${RedisCacheProvider}&quot;&amp;gt;
      &amp;lt;Property Name=&quot;ConnectionString&quot; Value=&quot;${Redis}&quot; /&amp;gt;
      &amp;lt;FlushInterval Seconds=&quot;60&quot;/&amp;gt;
    &amp;lt;/Cache&amp;gt;
  &amp;lt;/Caches&amp;gt;
   &amp;lt;Statement Id=&quot;QueryByLruCache&quot;  Cache=&quot;LruCache&quot;&amp;gt;
      SELECT Top 6 T.* From T_User T;
    &amp;lt;/Statement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;类型处理器&quot;&gt;类型处理器&lt;/h2&gt;
&lt;p&gt;SmartSql 内部实现了 DotNet 主要类型的类型处理器，并且提供了部分类型兼容的类型转换处理器，同时还提供了比较常用的 JsonTypeHanlder 。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;TypeHandler PropertyType=&quot;SmartSql.Test.Entities.UserInfo,SmartSql.Test&quot; Type=&quot;${JsonTypeHandler`}&quot;&amp;gt;
      &amp;lt;Properties&amp;gt;
        &amp;lt;Property Name=&quot;DateFormat&quot; Value=&quot;yyyy-MM-dd mm:ss&quot;/&amp;gt;
        &amp;lt;Property Name=&quot;NamingStrategy&quot; Value=&quot;Camel&quot;/&amp;gt;
      &amp;lt;/Properties&amp;gt;
    &amp;lt;/TypeHandler&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cud-代码生成&quot;&gt;CUD 代码生成&lt;/h2&gt;
&lt;p&gt;SmartSql 同时提供了 CUD 扩展函数帮助开发者生成好 CUD-SQL ，方便开发者直接使用，无需编写任何配置。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static TEntity GetById&amp;lt;TEntity, TPrimaryKey&amp;gt;(this ISqlMapper);
public static TPrimaryKey Insert&amp;lt;TEntity, TPrimaryKey&amp;gt;(this ISqlMapper sqlMapper, TEntity entity);
public static int DyUpdate&amp;lt;TEntity&amp;gt;(this ISqlMapper sqlMapper, object entity);
public static int Update&amp;lt;TEntity&amp;gt;(this ISqlMapper sqlMapper, TEntity entity);
public static int DeleteById&amp;lt;TEntity, TPrimaryKey&amp;gt;(this ISqlMapper sqlMapper, TPrimaryKey id);
public static int DeleteMany&amp;lt;TEntity, TPrimaryKey&amp;gt;(this ISqlMapper sqlMapper, IEnumerable&amp;lt;TPrimaryKey&amp;gt; ids);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;id-生成器&quot;&gt;Id 生成器&lt;/h2&gt;
&lt;h3 id=&quot;snowflakeid&quot;&gt;SnowflakeId&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;IdGenerators&amp;gt;
    &amp;lt;IdGenerator Name=&quot;SnowflakeId&quot; Type=&quot;SnowflakeId&quot;&amp;gt;
      &amp;lt;Properties&amp;gt;
        &amp;lt;Property Name=&quot;WorkerIdBits&quot; Value=&quot;10&quot;/&amp;gt;
        &amp;lt;Property Name=&quot;WorkerId&quot; Value=&quot;888&quot;/&amp;gt;
        &amp;lt;Property Name=&quot;Sequence&quot; Value=&quot;1&quot;/&amp;gt;
      &amp;lt;/Properties&amp;gt;
    &amp;lt;/IdGenerator&amp;gt;
&amp;lt;/IdGenerators&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;Statement Id=&quot;Insert&quot;&amp;gt;
      &amp;lt;IdGenerator Name=&quot;SnowflakeId&quot; Id=&quot;Id&quot;/&amp;gt;
      INSERT INTO T_UseIdGenEntity
      (
      Id,
      Name
      )
      VALUES
      (
      @Id,
      @Name
      );
      Select @Id;
    &amp;lt;/Statement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var id = SqlMapper.ExecuteScalar&amp;lt;long&amp;gt;(new RequestContext
            {
                Scope = nameof(UseIdGenEntity),
                SqlId = &quot;Insert&quot;,
                Request = new UseIdGenEntity()
                {
                    Name = &quot;SmartSql&quot;
                }
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dbsequence&quot;&gt;DbSequence&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;IdGenerators&amp;gt;
    &amp;lt;IdGenerator Name=&quot;DbSequence&quot; Type=&quot;DbSequence&quot;&amp;gt;
      &amp;lt;Properties&amp;gt;
        &amp;lt;Property Name=&quot;Step&quot; Value=&quot;10&quot;/&amp;gt;
        &amp;lt;Property Name=&quot;SequenceSql&quot; Value=&quot;Select Next Value For IdSequence;&quot;/&amp;gt;
      &amp;lt;/Properties&amp;gt;
    &amp;lt;/IdGenerator&amp;gt;
&amp;lt;/IdGenerators&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;Statement Id=&quot;InsertByDbSequence&quot;&amp;gt;
      &amp;lt;IdGenerator Name=&quot;DbSequence&quot; Id=&quot;Id&quot;/&amp;gt;
      INSERT INTO T_UseIdGenEntity
      (
      Id,
      Name
      )
      VALUES
      (
      @Id,
      @Name
      );
      Select @Id;
    &amp;lt;/Statement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;            var id = SqlMapper.ExecuteScalar&amp;lt;long&amp;gt;(new RequestContext
            {
                Scope = nameof(UseIdGenEntity),
                SqlId = &quot;InsertByDbSequence&quot;,
                Request = new UseIdGenEntity()
                {
                    Name = &quot;SmartSql&quot;
                }
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;aop-事务&quot;&gt;AOP 事务&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        [Transaction]
        public virtual long AddWithTran(User user)
        {
            return _userRepository.Insert(user);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;事务嵌套&quot;&gt;事务嵌套&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当出现事务嵌套时，子函数的事务特性注解将不再开启，转而使用上级调用函数的事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        [Transaction]
        public virtual long AddWithTranWrap(User user)
        {
            return AddWithTran(user);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bulkinsert&quot;&gt;BulkInsert&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using (var dbSession= SqlMapper.SessionStore.Open())
            {
                var data = SqlMapper.GetDataTable(new RequestContext
                {
                    Scope = nameof(AllPrimitive),
                    SqlId = &quot;Query&quot;,
                    Request = new { Taken = 100 }
                });
                data.TableName = &quot;T_AllPrimitive&quot;;
                IBulkInsert bulkInsert = new BulkInsert(dbSession);
                bulkInsert.Table = data;
                bulkInsert.Insert();
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;skywalking-监控&quot;&gt;Skywalking 监控&lt;/h2&gt;
&lt;p&gt;SmartSql 目前支持 Skywalking 监控，通过安装 &lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet&quot;&gt;SkyAPM-dotnet&lt;/a&gt; 代理来启用。以下是部分截图。&lt;/p&gt;
&lt;h3 id=&quot;监控执行命令&quot;&gt;监控执行命令&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/skyapm-0.png&quot; alt=&quot;Query&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看是否缓存以及返回的记录数&quot;&gt;查看是否缓存，以及返回的记录数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/skyapm-1.png&quot; alt=&quot;Query-Detail&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看执行的sql语句&quot;&gt;查看执行的SQL语句&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/skyapm-2.png&quot; alt=&quot;Query-Statement&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;事务&quot;&gt;事务&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/skyapm-3.png&quot; alt=&quot;Transaction&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;异常&quot;&gt;异常&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/skyapm-error-0.png&quot; alt=&quot;Error&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;异常堆栈跟踪&quot;&gt;异常堆栈跟踪&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Smart-Kit/SmartSql-Docs/master/docs/imgs/skyapm-error-1.png&quot; alt=&quot;Error-Detail&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例项目&quot;&gt;示例项目&lt;/h2&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnetcore/SmartSql/tree/master/sample/SmartSql.Sample.AspNetCore&quot;&gt;SmartSql.Sample.AspNetCore&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;技术交流&quot;&gt;技术交流&lt;/h2&gt;
&lt;p&gt;点击链接加入QQ群【SmartSql 官方交流群】：&lt;a href=&quot;https://jq.qq.com/?_wv=1027&amp;amp;k=5Sy8Ahw&quot;&gt;604762592&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 06:05:00 +0000</pubDate>
<dc:creator>Ahoo-Wang</dc:creator>
<og:description>介绍 SmartSql = MyBatis + Cache(Memory | Redis) + R/W Splitting +Dynamic Repository + Diagnostics ....</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ahoo-Wang/p/SmartSql-README.html</dc:identifier>
</item>
<item>
<title>[翻译 EF Core in Action 2.1] 设置一个图书销售网站的场景 - liangshiwei</title>
<link>http://www.cnblogs.com/LiangSW/p/10761977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiangSW/p/10761977.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Entityframework Core in action是 &lt;code&gt;Jon P smith&lt;/code&gt; 所著的关于Entityframework Core 书籍。&lt;a href=&quot;https://www.manning.com/books/entity-framework-core-in-action&quot;&gt;原版地址&lt;/a&gt;. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;在本章中你会构建一个图书销售网站示例,称之为图书应用程序. 这个示例应用程序帮助我们查看查询中的关系. 本节中介绍了图书应用程序所需的数据库与EF Core的实体类部分&lt;/p&gt;
&lt;h2 id=&quot;图书应用程序的关系型数据库&quot;&gt;图书应用程序的关系型数据库&lt;/h2&gt;
&lt;p&gt;虽然我们可以将作者,书,评论等所有数据都放到一张表中,但在关系型数据库中这样设计是很糟糕的,关系型数据库的规范是分离重复的数据,例如作者&lt;/p&gt;
&lt;p&gt;我们有多种方式在数据库设计图书数据的各种部分,在本例中的数据库具有EF Core的主要关系类型,分别是以下三种:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一对一的关系: 书与优惠价格&lt;/li&gt;
&lt;li&gt;一对多的关系: 书与评价&lt;/li&gt;
&lt;li&gt;多对多的关系: 书与作者&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;一对一的关系-书与价格&quot;&gt;一对一的关系: 书与价格&lt;/h3&gt;
&lt;p&gt;一个书可以有促销价格,这通过PriceOffers表的一个可选行实现的,这是一个一对一的例子(从技术来讲,这是一个1-0或1的关系,不过EF Core的处理方式是一样的);参见图2.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135316758-1525903325.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The PriceOffers table has a foreign key that links to the books table's primary key&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PriceOffers表有一个连接到books表主键的外键&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;EF Core uses its conventions to detect that this is a one-to-one relationship. It therefore adds a unique index to the foreign key to ensure that there can only be one per book&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EF Core使用它的约定来检测这是一个一对一的关系,因此它为外键添加了唯一索引,确保每本书只能有一个优惠价格&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;计算图书的最终价格,需要通过外键找到与图书链接的优惠价格记录. 如果找到了记录,NewPrice会取代原书的价格,并将PromotionalText显示到屏幕上; 例如:&lt;/p&gt;
&lt;p&gt;原价￥40现价￥9.9 温州印书场倒闭了,老板带着小姨子跑路了. 原价都是四十五十的,现价只要九块九&lt;/p&gt;
&lt;h3 id=&quot;一对多的关系-书的评论&quot;&gt;一对多的关系: 书的评论&lt;/h3&gt;
&lt;p&gt;顾客可以评价一本书;他们可以评星级,也可以留文字评论. 因为一本书可能没有一个评论或者有很多(无限)的评论,所以需要创建一张表保存这些数据. 在本例中它是Review表. Books表与Review表是一对多的关系, 如图2.2所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135333019-4804873.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The Review table is linked to the Books table via the foreign key called BookId&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Review表通过BookId外键链接到Books表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在显示图书介绍时,需要计算评论数量与平均星级评价. 这些通过一对多的关系去检索. 呈现在页面上是以下效果:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;平均分 4.5 共有1000用户评论&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;多对多的关系-图书与作者&quot;&gt;多对多的关系: 图书与作者&lt;/h3&gt;
&lt;p&gt;一书本可能由一个人编写也可能由多人编写, 一个人(作者)可以著作一本书或多本书. 这是一个典型的多对多关系,在数据库中Books表保存图书数据,Authors表保存作者. Books和Authors表之间的链接就是多对多关系. 它们之间需要一张中间表. 参见图2.3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135346171-619571042.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The BookAuthor table is the key to creating the many-to-many relationship and is known as a linking table&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BookAuthor表是多对多关系的核心,称为中间表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This table uses the foreign keys as the primary keys. Because primary keys must be unique, this ensures that only one link can exist between a book and an author&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BookAuthor表使用外键做为主键,因为主键必须是唯一的, 所以确保了书和作者之间只能有一个链接&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;多对多关系的页面展示如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;删库到跑路 - 我的程序一生 赵日天,萧炎,林动 著&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;EF6: 在EF6中定义多对多关系不需要链接类,EF6会自动创建隐藏的中间表.但是在EF Core中必须自己创建中间表&lt;/p&gt;
&lt;h2 id=&quot;本章中未涉及的其他关系类型&quot;&gt;本章中未涉及的其他关系类型&lt;/h2&gt;
&lt;p&gt;使用EF Core你可以使用继承达到与之前一对一关系的类似结果,例如你可以将PriceOffer类继承自Book类. EF Core会使用第七章中介绍的table-per-hierarchy(TPH)实现. (子类和基类都需要包含在应用程序的DbContext中)&lt;/p&gt;
&lt;p&gt;另一种是分层关系类型: 一组通过层次关系彼此关系的数据项目. 一个典型的例子是员工与经理,经理也是员工的一种. EF Core使用与一对五和一对多相同的方法来提供层次关系,在第七章详细讨论这类关系与如何配置&lt;/p&gt;
&lt;h2 id=&quot;最终数据库的样子&quot;&gt;最终数据库的样子&lt;/h2&gt;
&lt;p&gt;图2.4展示了图书应用程序的数据库,在本章和第三章的示例中我们会使用到它. 图中包含了我们之前提到每张表与列的定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135405058-882279717.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注: PK表示主键,FK表示外键&lt;/p&gt;
&lt;p&gt;为了帮助理解,图2.5展示了图片列表的输出(只有一书本). 图书应用程序需要访问数据库中的每一张表来构建图书列表,后面我会使用代码进行查询显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135430514-1319179356.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注: 你可以在http://efcoreinaction.com/查看在线的示例,会有助于你理解本章的剩余部分,你也可以在Github仓库中找到这个示例在本地调试运行&lt;/p&gt;
&lt;h2 id=&quot;ef-core映射数据库的类&quot;&gt;EF Core映射数据库的类&lt;/h2&gt;
&lt;p&gt;我创建5个类对应着灵气库中的5张表,分别是Book,PriceOffer,Review,Author和BookAuthor(多对多中间表)&lt;/p&gt;
&lt;p&gt;这些类称之为实休类,以突出它们是由EF Core映射到数据库的. 从软件工程的角度来看实体类是普通的.Net类(有时也被称为POCO)并没有什么特别之处. 因为它们是EF Core映射到数据库中的类,所以对其与其他类区分,称为实体类&lt;/p&gt;
&lt;p&gt;图书应用程序中主要的实体类是Book类,如下图所示. 它引用了PriceOffer类,Review类型的集合以及BookAuthor的集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135525003-628834759.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用了EF Core的约定配置实体类的主键,也就是类中int类型的Id属性. 数据库在添加新行时使用 Sql Identity 命令创建唯一键&lt;/p&gt;
&lt;p&gt;为了保持示例的简单,示例中使用了EF Core的约定配置方法对数据库建模. .Net类的导航属性(比如ICollection)定义了我需要关系类型,例如Reviews属性的类型是ICollection,所以是一对多关系. 第六章和第七章介绍了建模的其他方法&lt;/p&gt;
&lt;p&gt;本文的示例介绍了如何通过EF Core定义和创建数据库,如果你已经有了一个现有数据库,可以使用EF Core的逆行工程数据库的功能根据数据库表构建DbContext类和实体类,在11.3节中会介绍到,如果你不希望EF Core更改数据库结果而是通过SQL脚本或数据库部署工具自己来管理,可以在11.4节中找到方法&lt;/p&gt;
</description>
<pubDate>Wed, 24 Apr 2019 05:57:00 +0000</pubDate>
<dc:creator>liangshiwei</dc:creator>
<og:description>Entity Framework Core in Action Entityframework Core in action是 所著的关于Entityframework Core 书籍。 '原版地址'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LiangSW/p/10761977.html</dc:identifier>
</item>
</channel>
</rss>