<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Rancker2.2.2-HA 高可用k8s容器集群搭建 - kelsen</title>
<link>http://www.cnblogs.com/kelsen/p/10836332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kelsen/p/10836332.html</guid>
<description>&lt;p&gt;对于生产环境，需以高可用的配置安装 Rancher，确保用户始终可以访问 Rancher Server。当安装在Kubernetes集群中时，Rancher将与集群的 etcd 集成，并利用Kubernetes 调度实现高可用。&lt;/p&gt;
&lt;p&gt;为确保高可用，本文所部署的 Kubernetes 集群将专用于运行 Rancher ，Rancher 运行起来后，可再创建或导入集群以运行具体的工作负载。&lt;/p&gt;
&lt;h2 id=&quot;一推荐架构&quot;&gt;一、推荐架构&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Rancher的DNS 应解析到 4层(TCP) 负载均衡上。&lt;/li&gt;
&lt;li&gt;负载均衡应将端口 TCP/80 和 TCP/443 转发到 Kubernetes 集群中的所有3个节点。&lt;/li&gt;
&lt;li&gt;Ingress-controller 将 HTTP 重定向到HTTPS并终止端口 TCP/443 上的 SSL/TLS（SSL数字证书在这里部署）。&lt;/li&gt;
&lt;li&gt;Ingress-controller 将流量转发到 pod 的 TCP/80 端口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是一张从官网拉过来的图片,更直观一些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://rancher.com/docs/img/rancher/ha/rancher2ha.svg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二准备工作&quot;&gt;二、准备工作&lt;/h2&gt;
&lt;h3 id=&quot;服务器准备&quot;&gt;1. 服务器准备&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;1台 Linux服务器，配置不用很高，用于四层负载均衡&lt;/li&gt;
&lt;li&gt;3台 Linux服务器，Rancker-server-node 节点&lt;/li&gt;
&lt;li&gt;n台 Linux服务器，Rancker-agent-node 节点(n&amp;lt;=50)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;节点服务器的硬件配置，可根据实际情况依据该表自行选择。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;最多5个&lt;/td&gt;
&lt;td&gt;高达50&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8 GB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;中&lt;/td&gt;
&lt;td&gt;最多15个&lt;/td&gt;
&lt;td&gt;最多200&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;大&lt;/td&gt;
&lt;td&gt;高达50&lt;/td&gt;
&lt;td&gt;最多500个&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;32 GB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;超大&lt;/td&gt;
&lt;td&gt;最多100个&lt;/td&gt;
&lt;td&gt;高达1000&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;128 GB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;更大规模&lt;/td&gt;
&lt;td&gt;100+&lt;/td&gt;
&lt;td&gt;1000+&lt;/td&gt;
&lt;td&gt;联系 Rancher&lt;/td&gt;
&lt;td&gt;联系 Rancher&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;工具安装&quot;&gt;2.工具安装&lt;/h3&gt;
&lt;p&gt;这些工具软件将在部署过程中用到，需提前安装好，并确保通过 $PATH 变量可以找到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装 kubectl&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个 kubernetes 命令行工具，&lt;a href=&quot;https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl&quot;&gt;安装参考&lt;/a&gt; K8S 官网&lt;/p&gt;
&lt;p&gt;这里要注意的是，官网的安装过程是到谷歌云平台下载，这里我门修改下载链接为 RANCHER 提供的镜像地址。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 下载目前最新版
wget https://www.cnrancher.com/download/kubernetes/linux-amd64-v1.14.1-kubectl
# 设置执行权限
chmod +x ./linux-amd64-v1.14.1-kubectl 
# 将其移动到 /usr/locak/bin/kubectl 
sudo mv ./linux-amd64-v1.14.1-kubectl /usr/local/bin/kubectl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;安装 RKE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RKE 全称 Rancher Kubernetes Engine，是一个用于构建 kubernets 集群的命令行工具。网络原因，我们切换到 Rancher 提供的镜像地址下载安装&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 下载目前最新版
wget https://www.cnrancher.com/download/rke/v0.1.18-rke_linux-amd64
# 设置执行权限
chmod +x v0.1.18-rke_linux-amd64
# 将其移动到 /usr/locak/bin/kubectl 
sudo cp v0.1.18-rke_linux-amd64 /usr/local/bin/rke
# 验证安装
rke --version # rke version v0.1.18&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;安装 helm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;helm 是Kubernetes的包管理器。Helm版本需高于 &lt;code&gt;v2.12.1&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 网络原因，切换到 Rancher 提供的镜像连接
wget https://www.cnrancher.com/download/helm/helm-v2.13.1-linux-amd64.tar.gz
# 解压
tar -zxvf helm-v2.0.0-linux-amd64.tgz
# 移动到 /usr/local/bin/helm
mv linux-amd64/helm /usr/local/bin/helm&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三创建节点和负载均衡&quot;&gt;三、创建节点和负载均衡&lt;/h2&gt;
&lt;p&gt;这些节点须在同一个网络区域或数据中心。&lt;/p&gt;
&lt;h3 id=&quot;节点准备&quot;&gt;1. 节点准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;操作系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有节点安装 ubuntu 18.04(64-bit x86)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络要求&lt;/strong&gt;&lt;br/&gt;注意参考 &lt;a href=&quot;https://rancher.com/docs/rancher/v2.x/en/installation/requirements/#&quot;&gt;官网&lt;/a&gt;放行相关端口。本文 ip 清单（仅用于演示）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NODE-LB&lt;/td&gt;
&lt;td&gt;公网 168.168.168.1 / 内网 10.0.0.1&lt;/td&gt;
&lt;td&gt;四层负载均衡&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NODE-SERVER&lt;/td&gt;
&lt;td&gt;公网 168.168.168.6 / 内网 10.0.0.6&lt;/td&gt;
&lt;td&gt;local 集群&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NODE-SERVER&lt;/td&gt;
&lt;td&gt;公网 168.168.168.7 / 内网 10.0.0.7&lt;/td&gt;
&lt;td&gt;local 集群&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NODE-SERVER&lt;/td&gt;
&lt;td&gt;公网 168.168.168.8 / 内网 10.0.0.8&lt;/td&gt;
&lt;td&gt;local 集群&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NODE-WORKER&lt;/td&gt;
&lt;td&gt;公网 168.168.168.16 / 内网 10.0.0.16&lt;/td&gt;
&lt;td&gt;local 集群&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NODE-WORKER&lt;/td&gt;
&lt;td&gt;公网 168.168.168.17 / 内网 10.0.0.17&lt;/td&gt;
&lt;td&gt;工作负载&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NODE-WORKER&lt;/td&gt;
&lt;td&gt;公网 168.168.168.18 / 内网 10.0.0.18&lt;/td&gt;
&lt;td&gt;工作负载&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;docker-ce&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;并安装最新stable版 docker-ce:18.09.6&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 删除旧版本docker
sudo apt-get remove docker docker-engine docker.io containerd runc

# 更新 apt 
$ sudo apt-get update

# 安装工具包
$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common

# 添加Docker官方 GPG key
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

# 添加 stable apt 源
$ sudo add-apt-repository \
   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable&quot;

# 安装 Docker CE
$ sudo apt-get update
$ sudo apt-get install docker-ce docker-ce-cli containerd.io

# 将当前用户加入&quot;docker&quot;用户组，加入到该用户组的账号在随后安装过程会用到。
$ sudo usermod -aG docker $USER&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置四层负载均衡&quot;&gt;2. 配置四层负载均衡&lt;/h3&gt;
&lt;p&gt;RKE 将会在每个节点上配置一个 Ingress-controller pod，这个 pod 将绑定到该节点的 TCP/80 和 TCP/443 端口，作为 Rancher-server 的HTTPS流量入口点。&lt;/p&gt;
&lt;p&gt;将负载均衡器配置为基本的第4层TCP转发器，这里采用 NGINX 作四层负载均衡。&lt;/p&gt;
&lt;p&gt;*&lt;strong&gt;安装 Nginx&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt-get install nginx
# /usr/sbin/nginx：主程序
# /etc/nginx：存放配置文件
# /usr/share/nginx：存放静态文件
# /var/log/nginx：存放日志&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新配置文件 &lt;code&gt;/etc/nginx/nginx.conf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;worker_processes 4;
worker_rlimit_nofile 40000;

events {
    worker_connections 8192;
}

stream {
    upstream rancher_servers_http {
        least_conn;
        server 10.0.0.6:80 max_fails=3 fail_timeout=5s;
        server 10.0.0.7:80 max_fails=3 fail_timeout=5s;
        server 10.0.0.8:80 max_fails=3 fail_timeout=5s;
    }
    server {
        listen     80;
        proxy_pass rancher_servers_http;
    }

    upstream rancher_servers_https {
        least_conn;
        server 10.0.0.6:443 max_fails=3 fail_timeout=5s;
        server 10.0.0.7:443 max_fails=3 fail_timeout=5s;
        server 10.0.0.8:443 max_fails=3 fail_timeout=5s;
    }
    
    server {
        listen     443;
        proxy_pass rancher_servers_https;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;code&gt;注意：将local群集专用于Rancher。
勿将此负载均衡（即local群集Ingress）对 Rancher 以外的应用程序进行负载转发。&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;四使用-rke-安装-kubernetes&quot;&gt;四、使用 RKE 安装 kubernetes&lt;/h2&gt;
&lt;p&gt;下面使用 RKE(Kubernetes Engine) 安装高可用的 Kubernetes。&lt;/p&gt;
&lt;h3 id=&quot;node-server-之间建立-ssh-信任&quot;&gt;1. NODE-SERVER 之间建立 ssh 信任&lt;/h3&gt;
&lt;p&gt;我们目前有三台服务器用作 local 集群，首先要确保我们主机能够通过 ssh 访问到另外两台主机并执行相关操作。比如执行 docker 命令，还记得前面我们加入 docker 用户组的用户吧。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 根据需求配置相关信息生成 rsa 公钥密钥
ssh-keygen

# 复制当前主机上的公钥到另外两台上面，实现免密码登录
ssh-copy-id -i ~/.ssh/id_rsa.pub user@x.x.x.x

# 要注意这里也要跟自己注册注册一下 ：ssh-copy-id -i ~/.ssh/id_rsa.pub user@本机ip&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写-rancher-cluster.yml-文件&quot;&gt;2. 编写 rancher-cluster.yml 文件&lt;/h3&gt;
&lt;p&gt;这里需要注意，这个文件没有明确配置rsa文件名，默认会使用 &lt;code&gt;$HOME/.ssh/id_rsa&lt;/code&gt; 建立连接。内容如下&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;nodes:
  - address: 168.168.168.6
    internal_address: 10.0.0.6
    user: ubuntu
    role: [controlplane,worker,etcd]
  - address: 168.168.168.7
    internal_address: 10.0.0.7
    user: ubuntu
    role: [controlplane,worker,etcd]
  - address: 168.168.168.8
    internal_address: 10.0.0.8
    user: ubuntu
    role: [controlplane,worker,etcd]

services:
  etcd:
    snapshot: true
    creation: 6h
    retention: 24h&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行-rke-构建-kubernetes-集群&quot;&gt;3. 运行 RKE 构建 kubernetes 集群&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;rke up --config ./rancher-cluster.yml
# 验证：返回类似下面的消息则说明执行成功，有问题欢迎留言交流。
# Finished building Kubernetes cluster successfully.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行成功会在当前目录生成一个文件 &lt;code&gt;kube_config_rancher-cluster.yml&lt;/code&gt;，将该文件复制到 &lt;code&gt;.kube/kube_config_rancher-cluster.yml&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;export KUBECONFIG=$(pwd)/kube_config_rancher-cluster.yml&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试集群&quot;&gt;4. 测试集群&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get nodes
# 返回下面信息说明集群创建成功
NAME           STATUS   ROLES                      AGE   VERSION
168.168.168.6   Ready    controlplane,etcd,worker   13m   v1.13.5
168.168.168.7   Ready    controlplane,etcd,worker   13m   v1.13.5
168.168.168.8   Ready    controlplane,etcd,worker   13m   v1.13.5&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;保存好相关配置文件&quot;&gt;5. 保存好相关配置文件&lt;/h3&gt;
&lt;p&gt;当排除故障、升级群集时需要用到以下文件，请将其副本保存在一个安全的位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rancher-cluster.yml&lt;/code&gt;：RKE集群配置文件。&lt;br/&gt;&lt;code&gt;kube_config_rancher-cluster.yml&lt;/code&gt;：群集的Kubeconfig文件，此文件包含完全访问群集的凭据。&lt;br/&gt;&lt;code&gt;rancher-cluster.rkestate&lt;/code&gt;：Kubernetes群集状态文件，此文件包含完全访问群集的凭据。&lt;/p&gt;
&lt;h3 id=&quot;初始化-helm&quot;&gt;6. 初始化 Helm&lt;/h3&gt;
&lt;p&gt;一开始，我们安装了 Helm ，Helm 是 Kubernetes 首选的包管理工具。为了能够使用 Helm，需要在群集上安装服务器端组件 tiller。&lt;/p&gt;
&lt;p&gt;Kubernetes APIServer 开启了 RBAC 访问控制，所以需要创建 tiller 使用的service account: tiller 并分配合适的角色给它。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 在 kube-system 命名空间下创建一个 serviceaccount ,并将角色绑定给 tiller
kubectl -n kube-system create serviceaccount tiller

# 然后， heml 就可以在集群上安装 tiller 了
# 同样，网络原因，我们需要配置一个镜像仓库地址
helm init --upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts

# 输出：$HELM_HOME has been configured at /home/ubuntu/.helm.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试-tiller-安装是否成功&quot;&gt;7. 测试 tiller 安装是否成功&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl -n kube-system  rollout status deploy/tiller-deploy
# 输出 deployment &quot;tiller-deploy&quot; successfully rolled out

helm version
# Client: &amp;amp;version.Version{SemVer:&quot;v2.13.1&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;}
# Server: &amp;amp;version.Version{SemVer:&quot;v2.13.1&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五安装-rancher&quot;&gt;五、安装 Rancher&lt;/h2&gt;
&lt;p&gt;这里注意选择 stable 版本，首先添加 heml 源仓库。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;helm repo add rancher-stable https://releases.rancher.com/server-charts/stable&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;部署-rancher-并配置-ssl-数字证书&quot;&gt;1. 部署 Rancher 并配置 SSL 数字证书&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;helm install rancher-stable/rancher \
  --name rancher \
  --namespace cattle-system \
  --set hostname=cloud.jfjbapp.cn \
  --set ingress.tls.source=secret
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将通过-ca-机构签发的数字证书准备好&quot;&gt;2. 将通过 CA 机构签发的数字证书准备好，&lt;/h3&gt;
&lt;h3 id=&quot;检查-rancher-是否成功可用&quot;&gt;3. 检查 rancher 是否成功可用&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl -n cattle-system rollout status deploy/rancher
Waiting for deployment &quot;rancher&quot; rollout to finish: 0 of 3 updated replicas are available...
deployment &quot;rancher&quot; successfully rolled out&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;访问-rancher-ui&quot;&gt;4. 访问 Rancher UI&lt;/h3&gt;
&lt;p&gt;浏览器打开 &lt;code&gt;https://your.doamin&lt;/code&gt;，为 &lt;code&gt;admin&lt;/code&gt;账户设置初始密码，并登入系统。提示设置&lt;code&gt;server-url&lt;/code&gt;，确保你的地址无误，确认即可。随后稍等皮片刻，待系统完成初始化。&lt;/p&gt;
&lt;p&gt;如果出现local集群一直停留在等待状态，并提示 &lt;code&gt;Waiting for server-url setting to be set&lt;/code&gt;，可以尝试点击 全局-&amp;gt;local-&amp;gt;升级-&amp;gt;添加一个成员角色（admin/ClusterOwner）-&amp;gt;保存即可。&lt;/p&gt;
&lt;h2 id=&quot;六结语&quot;&gt;六、结语&lt;/h2&gt;
&lt;p&gt;至此，已完成 Rancher 2.2.3 的 HA 安装，后续再做一些安全加固，检查各项配置确保无安全风险，即可开始提供服务。随后会抽空再写一篇文章简单介绍微服务架构应用的部署。&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 23:33:00 +0000</pubDate>
<dc:creator>kelsen</dc:creator>
<og:description>对于生产环境，需以高可用的配置安装 Rancher，确保用户始终可以访问 Rancher Server。当安装在Kubernetes集群中时，Rancher将与集群的 etcd 集成，并利用Kuber</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kelsen/p/10836332.html</dc:identifier>
</item>
<item>
<title>强迫症福利--收起.NET程序的dll来 - 波多尔斯基</title>
<link>http://www.cnblogs.com/podolski/p/10836241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/podolski/p/10836241.html</guid>
<description>&lt;p&gt;作为上床后需要下床检查好几次门关了没有的资深强迫症患者，有一个及其搞我的问题，就是dll问题。&lt;/p&gt;
&lt;p&gt;曾几何时，在没有nuget的年代，当有依赖项需要引用的时候，只能通过文件引用来管理引用问题，版本问题，更新问题层出不穷，很是难受。&lt;/p&gt;
&lt;p&gt;后来出来nuget，喜大普奔，总算解决了引用的问题。开心之余，依然还有一个很膈应人的问题：生成文件夹满地的dll，找个exe眼睛很难受。&lt;/p&gt;
&lt;p&gt;讲道理这个也不是什么大问题，但是就是心痒痒，就特别想把这些dll收到一个单独文件夹里面，外面就留exe和配置等文件。然后就找这个东西：PrettyBin。&lt;/p&gt;
&lt;h2 id=&quot;prettybin&quot;&gt;PrettyBin&lt;/h2&gt;
&lt;p&gt;PrettyBin是一个开源的nuget包：&lt;a href=&quot;https://github.com/slmjy/PrettyBin&quot; class=&quot;uri&quot;&gt;https://github.com/slmjy/PrettyBin&lt;/a&gt;，使用它可以将.NET Framework程序引用的文件收到lib文件夹里面，使用起来也非常方便，老样子，直接nuget安装。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;Install-Package PrettyBin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提示重新加载项目，点击确定，就完事了。&lt;br/&gt;安装之前，输出是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616093/201905/616093-20190509011826843-867839415.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装之后，输出是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616093/201905/616093-20190509011838953-1738509163.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dll之类的文件都进lib文件夹了，感觉世界都干净了很多。&lt;/p&gt;
&lt;h2 id=&quot;补充&quot;&gt;补充&lt;/h2&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;细心的童鞋应该能够发现，我写的是&lt;strong&gt;.NET Framework&lt;/strong&gt;的程序引用，.NET Core，.NET Standard呢？&lt;br/&gt;答案是：.NET Core啥的东西生成的就是dll，都一样就没必要了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;安装prettybin之后，再安装新的包会怎么样？受不受影响？&lt;br/&gt;依然有用，不受影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于新的nuget管理形式PackageReference效果如何怎么样？&lt;br/&gt;这个有说法的，需要先了解这个包工作的原理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;原理解析&quot;&gt;原理解析&lt;/h2&gt;
&lt;p&gt;首先看看安装的时候，nuget包管理器弹出的提示：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;正在执行脚本文件“ConsoleApp4\packages\PrettyBin.1.1.0\tools\init.ps1”
Init BinPrettify
正在执行脚本文件“ConsoleApp4\packages\PrettyBin.1.1.0\tools\install.ps1”
Install PrettifyBin; 
http://schemas.microsoft.com/developer/msbuild/2003
No Target AfterBuild Node. Creating
No ItemGroup whith MoveToLibFolder tag. Creating
No Move tag in AfterBuild Target. Creating
Edititing App.config
runtimeNode items
No probing Node. Creating
已将“PrettyBin 1.1.0”成功安装到 ConsoleApp4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里首先执行的是给项目文件添加`&lt;code&gt;msbuild&lt;/code&gt;内容，增加了&lt;code&gt;AfterBuild&lt;/code&gt;节点，&lt;code&gt;MoveToLibFolder&lt;/code&gt;节点和&lt;code&gt;Move&lt;/code&gt;节点。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Import Project=&quot;$(MSBuildToolsPath)\Microsoft.CSharp.targets&quot; /&amp;gt;
&amp;lt;Target Name=&quot;AfterBuild&quot;&amp;gt;
&amp;lt;ItemGroup&amp;gt;
    &amp;lt;MoveToLibFolder Include=&quot;$(OutputPath)*.dll ; $(OutputPath)*.pdb ; $(OutputPath)*.xml&quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&amp;lt;Move SourceFiles=&quot;@(MoveToLibFolder)&quot; DestinationFolder=&quot;$(OutputPath)lib&quot; OverwriteReadOnlyFiles=&quot;true&quot; /&amp;gt;
&amp;lt;/Target&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;msbuild可以设置生成后的操作，成功生成之后，将目录下面的dll文件，pdb文件和xml都转到了lib文件夹。&lt;br/&gt;然后修改了app.config文件，在runtime底下增加了一个&lt;code&gt;probing&lt;/code&gt;节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;runtime&amp;gt;
&amp;lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&amp;gt;
    &amp;lt;probing privatePath=&quot;lib;libs&quot; xmlns=&quot;&quot; /&amp;gt;
&amp;lt;/assemblyBinding&amp;gt;
&amp;lt;/runtime&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.3694029850746&quot;&gt;
&lt;p&gt;probing节点提供.NET程序集查找的选项，privatepath指定路径，详细资料可以查看MSDN：&lt;a href=&quot;https://support.microsoft.com/en-us/help/837908/how-to-load-an-assembly-at-runtime-that-is-located-in-a-folder-that-is&quot; class=&quot;uri&quot;&gt;https://support.microsoft.com/en-us/help/837908/how-to-load-an-assembly-at-runtime-that-is-located-in-a-folder-that-is&lt;/a&gt;&lt;br/&gt;补充资料：关于&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/specify-assembly-location&quot;&gt;指定程序集位置&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，prettybin是通过运行&lt;code&gt;powershell&lt;/code&gt;脚本设置生成成功后转移文件，并将程序集查找路径调整为lib文件夹。&lt;/p&gt;
&lt;p&gt;根据&lt;a href=&quot;https://docs.microsoft.com/zh-cn/nuget/reference/migrate-packages-config-to-package-reference&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/zh-cn/nuget/reference/migrate-packages-config-to-package-reference&lt;/a&gt;，PackageReference方式nuget是不支持install.ps1脚本的。所以并不能支持prettybin。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;新建.NET Framework程序是默认是通过传统的package.config文件进行包管理的，新建.NET Core和.NET Standard都是默认使用PackageReference包管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;em&gt;如果需要使用PrettyBin，那么直接默认配置.NET FRAMEWORK项目的nuget管理方式，完美支持。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;如果需要升级新的包管理方式，可以在安装了PrettyBin之后升级项目，依然支持。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;升级了PackageReference之后，安装PrettyBin无效。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;p.s.-补充不使用prettybin也不调用afterbuild的一种实现httpswww.broculos.net201403visual-studio-build-dlls-to-separate.html.wwitjjfjly8&quot;&gt;P.S. 补充不使用prettybin，也不调用AFTERBUILD的一种实现：&lt;a href=&quot;https://www.broculos.net/2014/03/visual-studio-build-dlls-to-separate.html#.WWiTjJFJLy8&quot; class=&quot;uri&quot;&gt;https://www.broculos.net/2014/03/visual-studio-build-dlls-to-separate.html#.WWiTjJFJLy8&lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Wed, 08 May 2019 17:22:00 +0000</pubDate>
<dc:creator>波多尔斯基</dc:creator>
<og:description>作为上床后需要下床检查好几次门关了没有的资深强迫症患者，有一个及其搞我的问题，就是dll问题。 曾几何时，在没有nuget的年代，当有依赖项需要引用的时候，只能通过文件引用来管理引用问题，版本问题，更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/podolski/p/10836241.html</dc:identifier>
</item>
<item>
<title>Spring Boot 2 快速教程：WebFlux 快速入门（二） - www.bysocket.com</title>
<link>http://www.cnblogs.com/Alandre/p/10836242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/10836242.html</guid>
<description>&lt;p&gt;摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！&lt;/p&gt;

&lt;p&gt;文章工程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK 1.8&lt;/li&gt;
&lt;li&gt;Maven 3.5.2&lt;/li&gt;
&lt;li&gt;Spring Boot 2.1.3.RELEASE&lt;/li&gt;
&lt;li&gt;工程名：springboot-webflux-1-quickstart&lt;/li&gt;
&lt;li&gt;工程地址：见文末&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;一、Spring Boot 2.0&lt;/h2&gt;
&lt;p&gt;spring.io 官网有句醒目的话是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;BUILD ANYTHING WITH SPRING BOOT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring Boot （Boot 顾名思义，是引导的意思）框架是用于简化 Spring 应用从搭建到开发的过程。应用开箱即用，只要通过一个指令，包括命令行 &lt;code&gt;java -jar&lt;/code&gt; 、&lt;code&gt;SpringApplication&lt;/code&gt; 应用启动类 、 Spring Boot Maven 插件等，就可以启动应用了。另外，Spring Boot 强调只需要很少的配置文件，所以在开发生产级 Spring 应用中，让开发变得更加高效和简易。目前，Spring Boot 版本是 2.x 版本。Spring Boot 包括 WebFlux。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.gitbook.cn/87db53c0-b936-11e7-b969-cb3cfaf54002&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、Spring Boot 2.0 WebFlux&lt;/h2&gt;
&lt;p&gt;了解 WebFlux ,首先了解下什么是 Reactive Streams。Reactive Streams 是 JVM 中面向流的库标准和规范：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理可能无限数量的元素&lt;/li&gt;
&lt;li&gt;按顺序处理&lt;/li&gt;
&lt;li&gt;组件之间异步传递&lt;/li&gt;
&lt;li&gt;强制性非阻塞背压（Backpressure）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.1 Backpressure(背压)&lt;/p&gt;
&lt;p&gt;背压是一种常用策略，使得发布者拥有无限制的缓冲区存储元素，用于确保发布者发布元素太快时，不会去压制订阅者。&lt;/p&gt;
&lt;p&gt;2.2 Reactive Streams（响应式流）&lt;/p&gt;
&lt;p&gt;一般由以下组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发布者：发布元素到订阅者&lt;/li&gt;
&lt;li&gt;订阅者：消费元素&lt;/li&gt;
&lt;li&gt;订阅：在发布者中，订阅被创建时，将与订阅者共享&lt;/li&gt;
&lt;li&gt;处理器：发布者与订阅者之间处理数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.3 响应式编程&lt;br/&gt;有了 Reactive Streams 这种标准和规范，利用规范可以进行响应式编程。那再了解下什么是 Reactive programming 响应式编程。响应式编程是基于异步和事件驱动的非阻塞程序，只是垂直通过在 JVM 内启动少量线程扩展，而不是水平通过集群扩展。这就是一个编程范例，具体项目中如何体现呢？&lt;/p&gt;
&lt;p&gt;响应式项目编程实战中，通过基于 Reactive Streams 规范实现的框架 Reactor 去实战。Reactor 一般提供两种响应式 API ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mono：实现发布者，并返回 0 或 1 个元素&lt;/li&gt;
&lt;li&gt;Flux：实现发布者，并返回 N 个元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.4 Spring Webflux&lt;/p&gt;
&lt;p&gt;Spring Boot Webflux 就是基于 Reactor 实现的。Spring Boot 2.0 包括一个新的 spring-webflux 模块。该模块包含对响应式 HTTP 和 WebSocket 客户端的支持，以及对 REST，HTML 和 WebSocket 交互等程序的支持。一般来说，Spring MVC 用于同步处理，Spring Webflux 用于异步处理。&lt;/p&gt;
&lt;p&gt;Spring Boot Webflux 有两种编程模型实现，一种类似 Spring MVC 注解方式，另一种是使用其功能性端点方式。注解的会在第二篇文章讲到，下面快速入门用 Spring Webflux 功能性方式实现。&lt;/p&gt;
&lt;h2&gt;三、Spring Boot 2.0 WebFlux 特性&lt;/h2&gt;
&lt;p&gt;常用的 Spring Boot 2.0 WebFlux 生产的特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应式 API&lt;/li&gt;
&lt;li&gt;编程模型&lt;/li&gt;
&lt;li&gt;适用性&lt;/li&gt;
&lt;li&gt;内嵌容器&lt;/li&gt;
&lt;li&gt;Starter 组件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有对日志、Web、消息、测试及扩展等支持。&lt;/p&gt;
&lt;h4&gt;3.1 响应式 API&lt;/h4&gt;
&lt;p&gt;Reactor 框架是 Spring Boot Webflux 响应库依赖，通过 Reactive Streams 并与其他响应库交互。提供了 两种响应式 API : Mono 和 Flux。一般是将 Publisher 作为输入，在框架内部转换成 Reactor 类型并处理逻辑，然后返回 Flux 或 Mono 作为输出。&lt;/p&gt;
&lt;h4&gt;3.2 适用性&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/e39654d047bd43a8f708d67f947c00c01523267&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一图就很明确了，WebFlux 和 MVC 有交集，方便大家迁移。但是注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MVC 能满足场景的，就不需要更改为 WebFlux。&lt;/li&gt;
&lt;li&gt;要注意容器的支持，可以看看下面内嵌容器的支持。&lt;/li&gt;
&lt;li&gt;微服务体系结构，WebFlux 和 MVC 可以混合使用。尤其开发 IO 密集型服务的时候，选择 WebFlux 去实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;3.3 编程模型&lt;/h4&gt;
&lt;p&gt;Spring 5 web 模块包含了 Spring WebFlux 的 HTTP 抽象。类似 Servlet API , WebFlux 提供了 WebHandler API 去定义非阻塞 API 抽象接口。可以选择以下两种编程模型实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注解控制层。和 MVC 保持一致，WebFlux 也支持响应性 @RequestBody 注解。&lt;/li&gt;
&lt;li&gt;功能性端点。基于 lambda 轻量级编程模型，用来路由和处理请求的小工具。和上面最大的区别就是，这种模型，全程控制了请求 – 响应的生命流程&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;3.4 内嵌容器&lt;/h4&gt;
&lt;p&gt;跟 Spring Boot 大框架一样启动应用，但 WebFlux 默认是通过 Netty 启动，并且自动设置了默认端口为 8080。另外还提供了对 Jetty、Undertow 等容器的支持。开发者自行在添加对应的容器 Starter 组件依赖，即可配置并使用对应内嵌容器实例。&lt;/p&gt;
&lt;p&gt;但是要注意，必须是 Servlet 3.1+ 容器，如 Tomcat、Jetty；或者非 Servlet 容器，如 Netty 和 Undertow。&lt;/p&gt;
&lt;h4&gt;3.5 Starter 组件&lt;/h4&gt;
&lt;p&gt;跟 Spring Boot 大框架一样，Spring Boot Webflux 提供了很多 “开箱即用” 的 Starter 组件。Starter 组件是可被加载在应用中的 Maven 依赖项。只需要在 Maven 配置中添加对应的依赖配置，即可使用对应的 Starter 组件。例如，添加 &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; 依赖，就可用于构建响应式 API 服务，其包含了 Web Flux 和 Tomcat 内嵌容器等。&lt;/p&gt;
&lt;p&gt;开发中，很多功能是通过添加 Starter 组件的方式来进行实现。那么，Spring Boot 2.x 常用的 Starter 组件有哪些呢？&lt;/p&gt;
&lt;h2&gt;四、Spring Boot 2.0 WebFlux 组件&lt;/h2&gt;
&lt;p&gt;Spring Boot WebFlux 官方提供了很多 Starter 组件，每个模块会有多种技术实现选型支持，来实现各种复杂的业务需求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Web：Spring WebFlux&lt;/li&gt;
&lt;li&gt;模板引擎：Thymeleaf&lt;/li&gt;
&lt;li&gt;存储：Redis、MongoDB、Cassandra。不支持 MySQL&lt;/li&gt;
&lt;li&gt;内嵌容器：Tomcat、Jetty、Undertow&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;五、快速入门&lt;/h2&gt;
&lt;h3&gt;5.1 Spring Initializr 快速构建项目骨架&lt;/h3&gt;
&lt;p&gt;Spring Boot Maven 工程，就是普通的 Maven 工程，加入了对应的 Spring Boot 依赖即可。Spring Initializr 则是像代码生成器一样，自动就给你出来了一个 Spring Boot Maven 工程。Spring Initializr 有两种方式可以得到 Spring Boot Maven 骨架工程：&lt;/p&gt;
&lt;h4&gt;5.1.1 start.spring.io 在线生成&lt;/h4&gt;
&lt;p&gt;Spring 官方提供了名为 Spring Initializr 的网站，去引导你快速生成 Spring Boot 应用。网站地址为：https://start.spring.io，操作步骤如下：&lt;/p&gt;
&lt;p&gt;第一步，选择 Maven 或者 Gradle 构建工具，开发语言 Java 、Kotlin 或者 Groovy，最后确定 Spring Boot 版本号。这里默认选择 Maven 构建工具、Java 开发语言和 Spring Boot 2.0.1。&lt;/p&gt;
&lt;p&gt;第二步，输入 Maven 工程信息，即项目组 &lt;code&gt;groupId&lt;/code&gt; 和名字 &lt;code&gt;artifactId&lt;/code&gt;。这里对应 Maven 信息为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;groupId：springboot&lt;/li&gt;
&lt;li&gt;artifactId：sspringboot-webflux-1-quickstart&lt;br/&gt;这里默认版本号 version 为 0.0.1-SNAPSHOT 。三个属性在 Maven 依赖仓库是唯一标识的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第三步，选择工程需要的 Starter 组件和其他依赖。最后点击生成按钮，即可获得骨架工程压缩包。这里快速入门，只要选择 Reactive Web 即可。如图 1-8 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/e8756dce7ada604d9f29f2fd61d0f1721523318&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.2 配置 POM 依赖&lt;/h3&gt;
&lt;p&gt;检查工程 POM 文件中，是否配置了 spring-boot-starter-webflux 依赖。如果是上面自动生成的，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;reactor-test&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring-boot-starter-webflux 依赖，是我们核心需要学习 webflux 的包，里面默认包含了 spring-boot-starter-reactor-netty 、spring 5 webflux 包。也就是说默认是通过 netty 启动的。&lt;/p&gt;
&lt;p&gt;reactor-test、spring-boot-starter-test 两个依赖搭配是用于单元测试。&lt;/p&gt;
&lt;p&gt;spring-boot-maven-plugin 是 Spring Boot Maven 插件，可以运行、编译等调用。&lt;/p&gt;
&lt;h3&gt;5.3 编写处理器类 Handler&lt;/h3&gt;
&lt;p&gt;新建包 org.spring.springboot.handler ，作为编写功能处理类。新建城市（City）例子的处理类 CityHandler，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.http.MediaType;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.stereotype.Component;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.reactive.function.BodyInserters;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.reactive.function.server.ServerRequest;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.reactive.function.server.ServerResponse;
&lt;span class=&quot;hljs-keyword&quot;&gt;import reactor.core.publisher.Mono;

&lt;span class=&quot;hljs-meta&quot;&gt;@Component
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;CityHandler {

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Mono&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;helloCity&lt;span class=&quot;hljs-params&quot;&gt;(ServerRequest request) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return ServerResponse.ok().contentType(MediaType.TEXT_PLAIN)
                .body(BodyInserters.fromObject(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello, City!&quot;));
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ServerResponse 是对响应的封装，可以设置响应状态，响应头，响应正文。比如 ok 代表的是 200 响应码、MediaType 枚举是代表这文本内容类型、返回的是 String 的对象。&lt;/p&gt;
&lt;p&gt;这里用 Mono 作为返回对象，是因为返回包含了一个 ServerResponse 对象，而不是多个元素。&lt;/p&gt;
&lt;h3&gt;5.4 编写路由器类 Router&lt;/h3&gt;
&lt;p&gt;新建 org.spring.springboot.router 包，作为编写路由器类。新建城市（City）例子的路由类 CityRouter，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.spring.springboot.handler.CityHandler;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.context.annotation.Bean;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.context.annotation.Configuration;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.http.MediaType;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.reactive.function.server.RequestPredicates;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.reactive.function.server.RouterFunction;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.reactive.function.server.RouterFunctions;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.reactive.function.server.ServerResponse;

&lt;span class=&quot;hljs-meta&quot;&gt;@Configuration
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;CityRouter {


    &lt;span class=&quot;hljs-meta&quot;&gt;@Bean
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public RouterFunction&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;routeCity&lt;span class=&quot;hljs-params&quot;&gt;(CityHandler cityHandler) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return RouterFunctions
                .route(RequestPredicates.GET(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/hello&quot;)
                                .and(RequestPredicates.accept(MediaType.TEXT_PLAIN)),
                        cityHandler::helloCity);
    }

}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RouterFunctions 对请求路由处理类，即将请求路由到处理器。这里将一个 GET 请求 /hello 路由到处理器 cityHandler 的 helloCity 方法上。跟 Spring MVC 模式下的 HandleMapping 的作用类似。&lt;/p&gt;
&lt;p&gt;RouterFunctions.route(RequestPredicate, HandlerFunction) 方法，对应的入参是请求参数和处理函数，如果请求匹配，就调用对应的处理器函数。&lt;/p&gt;
&lt;p&gt;到这里一个简单的服务就写好了，下面怎么运行该服务。&lt;/p&gt;
&lt;h3&gt;5.5 启动运行项目&lt;/h3&gt;
&lt;p&gt;一个简单的 Spring Boot Webflux 工程就开发完毕了，下面运行工程验证下。使用 IDEA 右侧工具栏，点击 Maven Project Tab ，点击使用下 Maven 插件的 &lt;code&gt;install&lt;/code&gt; 命令。或者使用命令行的形式，在工程根目录下，执行 Maven 清理和安装工程的指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;cd springboot-webflux-&lt;span class=&quot;hljs-number&quot;&gt;1-quickstart
mvn clean install
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在控制台中看到成功的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;... 省略
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: &lt;span class=&quot;hljs-number&quot;&gt;01:&lt;span class=&quot;hljs-number&quot;&gt;30 min
[INFO] Finished at: &lt;span class=&quot;hljs-number&quot;&gt;2017-&lt;span class=&quot;hljs-number&quot;&gt;10-&lt;span class=&quot;hljs-number&quot;&gt;15T10:&lt;span class=&quot;hljs-number&quot;&gt;00:&lt;span class=&quot;hljs-number&quot;&gt;54+&lt;span class=&quot;hljs-number&quot;&gt;08:&lt;span class=&quot;hljs-number&quot;&gt;00
[INFO] Final Memory: &lt;span class=&quot;hljs-number&quot;&gt;31M/&lt;span class=&quot;hljs-number&quot;&gt;174M
[INFO] ------------------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;5.5.1 运行工程&lt;/h4&gt;
&lt;p&gt;在 IDEA 中执行 &lt;code&gt;Application&lt;/code&gt; 类启动，任意正常模式或者 Debug 模式。可以在控制台看到成功运行的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;... 省略
&lt;span class=&quot;hljs-number&quot;&gt;2018-&lt;span class=&quot;hljs-number&quot;&gt;04-&lt;span class=&quot;hljs-number&quot;&gt;10 &lt;span class=&quot;hljs-number&quot;&gt;08:&lt;span class=&quot;hljs-number&quot;&gt;43:&lt;span class=&quot;hljs-number&quot;&gt;39.932  INFO &lt;span class=&quot;hljs-number&quot;&gt;2052 --- [ctor-http-nio-&lt;span class=&quot;hljs-number&quot;&gt;1] r.ipc.netty.tcp.BlockingNettyContext     : Started HttpServer on /&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;8080
&lt;span class=&quot;hljs-number&quot;&gt;2018-&lt;span class=&quot;hljs-number&quot;&gt;04-&lt;span class=&quot;hljs-number&quot;&gt;10 &lt;span class=&quot;hljs-number&quot;&gt;08:&lt;span class=&quot;hljs-number&quot;&gt;43:&lt;span class=&quot;hljs-number&quot;&gt;39.935  INFO &lt;span class=&quot;hljs-number&quot;&gt;2052 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : &lt;span class=&quot;hljs-function&quot;&gt;Netty started on &lt;span class=&quot;hljs-title&quot;&gt;port&lt;span class=&quot;hljs-params&quot;&gt;(s): 8080
2018-04-10 08:43:39.960  INFO 2052 --- [           main] org.spring.springboot.Application        : Started Application in 6.547 &lt;span class=&quot;hljs-title&quot;&gt;seconds &lt;span class=&quot;hljs-params&quot;&gt;(JVM running &lt;span class=&quot;hljs-keyword&quot;&gt;for &lt;span class=&quot;hljs-number&quot;&gt;9.851)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一看，确实是 Netty 启动的。&lt;/p&gt;
&lt;p&gt;打开浏览器，访问 /hello 地址，会看到如图所示的返回结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/42a9f1eaa1ee54923556727eac2216481523320&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、总结&lt;/h2&gt;
&lt;p&gt;本文主要讲了 Spring Boot 2.0 WebFlux 背景和快速入门使用。用的是基于功能性端点去创建一个服务，但这个有点代码偏多。下一章一个 CRUD 我们使用注解控制层，让开发更方便。&lt;/p&gt;
&lt;h3&gt;系列教程目录&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《01：WebFlux 系列教程大纲》&lt;/li&gt;
&lt;li&gt;《02：WebFlux 快速入门实践》&lt;/li&gt;
&lt;li&gt;《03：WebFlux Web CRUD 实践》&lt;/li&gt;
&lt;li&gt;《04：WebFlux 整合 Mongodb》&lt;/li&gt;
&lt;li&gt;《05：WebFlux 整合 Thymeleaf》&lt;/li&gt;
&lt;li&gt;《06：WebFlux 中 Thymeleaf 和 Mongodb 实践》&lt;/li&gt;
&lt;li&gt;《07：WebFlux 整合 Redis》&lt;/li&gt;
&lt;li&gt;《08：WebFlux 中 Redis 实现缓存》&lt;/li&gt;
&lt;li&gt;《09：WebFlux 中 WebSocket 实现通信》&lt;/li&gt;
&lt;li&gt;《10：WebFlux 集成测试及部署》&lt;/li&gt;
&lt;li&gt;《11：WebFlux 实战图书管理系统》&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;本文示例读者可以通过查看下面仓库的中的模块工程名: 2-x-spring-boot-webflux-handling-errors：&lt;/p&gt;
&lt;p&gt;如果您对这些感兴趣，欢迎 star、follow、收藏、转发给予支持！&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Spring Boot 2.x WebFlux 系列：https://www.bysocket.com/archives/2290&lt;/li&gt;
&lt;li&gt;spring.io 官方文档&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;以下专题教程也许您会有兴趣&lt;/h3&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2017/01/qrcode_for_gh_cd421e7eb7d6_430.jpg&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;224&quot;/&gt; &lt;br/&gt;（关注微信公众号，领取 Java 精选干货学习资料） &lt;br/&gt;（添加我微信：bysocket01。加入纯技术交流群，成长技术）&lt;/div&gt;
</description>
<pubDate>Wed, 08 May 2019 17:22:00 +0000</pubDate>
<dc:creator>www.bysocket.com</dc:creator>
<og:description>摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！ 02：WebFlux 快速入门实践 文章工程： JDK 1.8</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alandre/p/10836242.html</dc:identifier>
</item>
<item>
<title>分布式系统原理之cap理论 - killianxu</title>
<link>http://www.cnblogs.com/killianxu/p/10714665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/killianxu/p/10714665.html</guid>
<description>&lt;p&gt;&lt;span&gt;  Cap理论表示在分布式系统中一致性(C)、可用性(A)和分区容错性(P)最多只能同时满足两个。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  一致性:客户端更新数据成功后,在任意时刻,在系统任意对外提供服务的节点,读取到的数据都是最新写入的数据。(强一致性)。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  可用性:当系统出现异常时，仍能对外提供服务。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  分区容错:当出现网络分区时，系统的容错能力(机器之间出现网络故障,不能正常通信)。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  证明cap理论:有两台机器M1和M2,为保持一致性,两台机器的数据相同,现在客户端对M1的数据进行更新,但M1和M2之间出现网络故障(分区),M的最新数据无法同步到M2,导致M1的数据变为v1,M2仍为v0。现有一客户端向M2发送数据读取请求,对此请求的处理有两种选择：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;返回旧数据v0,满足可用性,但是却违反了一致性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;阻塞此次读操作,直至网络故障恢复,M1的数据v1同步到M2中,满足一致性，但违反了可用性。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;  由于分布式系统天生具有分区的特性，所以一定要满足P，只能在CA中选其一。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Cap理论说明了想设计完全满足强一致性、可用性和分区容错性的分布式系统是不切实际的,只能在三者之间权衡,为分布式系统的设计提供理论指导。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.2 一致性的分类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  一致性可从客户端和服务端两个角度来看，客户端一致性定义客户端怎样和何时看到数据更新，服务端一致性定义更新时数据如何流经系统及系统对更新有何保证。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  客户端一致性分为以下几种：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  1. 强一致性:数据更新之后，任何客户端在后续的访问中都能访问到最新版本的数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  2. 弱一致性：数据更新之后，不能保证客户端的访问能访问到最新更新之后的数据，数据更新到所有客户端可见这段时间称为不一致窗口。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  3. 最终一致性:最终一致性是种特殊的弱一致性，假如更新数据之后没有后续的对此数据对象的更新操作，系统保证一段时间之后任何客户端对此数据对象的访问都能返回最后一次更新的数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  最终一致性有如下变种:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  1. 因果一致性: 如果进程A向进程B传达它已更新数据项，则进程B的后续访问将返回更新的值，并且保证写入将取代先前的写入。进程C的访问与进程A没有因果关系，遵循正常的最终一致性规则。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  2. 读已之所写一致性: 进程A在更新数据项之后始终访问更新的值，并且永远不会看到较旧的值。这是因果一致性模型的特例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  3. 会话一致性:是读已之所写的实际应用版本,进程对系统的访问存在与一个会话上下文中,在此会话中的访问遵循读已之所写一致性。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  4. 单调读一致性:进程访问某一数据对象的值之后，此进程后续的访问都不会返回更旧版本的值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  5. 单调写一致性:系统保证相同进程的一系列写操作是序列化有序的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;同一个系统中，可以同时满足多种一致性,例如读已之所写和单调读一致性是常用的组合方案,这两种一致性使系统更易使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  服务端一致性:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  N=存储数据副本的结点数量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  W=在更新完成之前，需要确认更新成功的副本数量。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  R=当读操作访问数据对象，需要访问的副本数量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  如果W+R&amp;gt;N,写副本和读副本会出现重叠,能保证一定能读到更新后的数据对象,从而保证强一致性。例如:在实现了primary-backup关系数据库管理系统中,同步副本技术N=2,W=2,R=1,能保证强一致性;异步副本方式N=2,W=1,R=1, R+W=N,一致性不能得到保证。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  如果W+R&amp;lt;=N, 那么不能保证强一致性，只能是弱一致性或最终一致性。如在主备RDBMS中，使用异步同步副本，并开启从副本读功能的方式，那么N=2, W=1和R=1。在这种情况下，R+W=N, 一致性不能得到保证。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3 CAP理论的变种(BASE理论)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  BASE理论由CAP理论演化而来，是工业界对分布式系统实践的总结，其核心思想是即使无法达到强一致性，也要保证满足最终一致性。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;BASE是Basically Available(基本可用）、Soft state(软状态）和Eventually consistent(最终一致性）三个短语的简写。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  基本可用:当系统发生不可预知故障时，允许损失部分可用性，例如:部分机房故障，允许查询时间变长(时间上的损失),系统高峰期为保证系统的稳定性,将部分用户请求引导到降级页面(功能上的损失)。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  软状态:允许系统中的数据存在中间状态，该中间状态不会影响系统的整体可用性,即允许多个副本间的同步存在延时。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  最终一致性:系统中数据的副本经过一段时间的同步之后，最终能达到一致性状态，不要求强一致性。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;[1] 分布式系统的CAP理论.https://www.hollischuang.com/archives/666&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[2] Vogels W. Eventually consistent[J]. Communications of the ACM, 2009, 52(1): 40-44.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[3] 分布式系统原理九：CAP理论和BASE理论.http://feixiao.github.io/2017/03/14/fbsxt9/&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 16:18:00 +0000</pubDate>
<dc:creator>killianxu</dc:creator>
<og:description>cap理论是分布式系统的基础理论,任何一个分布式系统不可能同时满足强一致性、可用性和分区容错性，而只能在三者之间权衡。为了提高系统的写入性能，一般系统只需满足最终一致性,最终一致性有几下几种常见变种:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/killianxu/p/10714665.html</dc:identifier>
</item>
<item>
<title>深入理解java虚拟机之垃圾收集器 - rainple</title>
<link>http://www.cnblogs.com/rainple/p/10829144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainple/p/10829144.html</guid>
<description>&lt;p&gt;　　如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的虚拟机所提供的垃圾收集器都有可能会有很大的区别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。&lt;/p&gt;
&lt;p&gt;　　相关系列博客：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190508152011542-1236068799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中展示了不同年龄代的收集器，其中Serial、ParNew和Parallel Scavenge收集器作用于新生代，CMS、Parallel Old 和 Serial Old作用于老年代，G1在新生代和老年代都可以使用。不同的收集器之间如果有连线，则说明他们可以相互搭配使用。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;并行&lt;/strong&gt;：指的是多条垃圾收集线程一起公共，但是此时用户工作线程仍处于等待状态。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;并发&lt;/strong&gt;：指的是用户线程和垃圾收集线程同时工作，也有可能是交替执行，用户程序在继续执行，而垃圾收集程序运行与另一个CPU上。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;吞吐量&lt;/strong&gt;：吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。&lt;/p&gt;


&lt;p&gt;&lt;em&gt;　　Serial收集器是一款串行执行的收集器，它是历史最悠久，也是最基本的收集器，采用复制算法实现的新生代收集器。在jdk1.3以前，Serial收集器是新生代唯一的选择。它是一个单线程执行的收集器，工作时只会知用一个cpu或线程区执行，更重要的是Serial在工作期间必须停掉所有的用户线程，直至垃圾收集完成，这一过程我们称之为“stop the world”。这项工作是由虚拟机自动执行和自动完成的，用户在不知情的情况下停掉了所有的线程，这对于一个最求响应速度来说简直是无法接受的。下图展示了Serial收集器在工作时的运行流程：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190508154614376-164710287.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　由于Serial收集器的工作模式是单线程的，自然就没有了多线程环境下线程切换带来的性能开销，所以该收集器在单线程环境下更加简单高效。&lt;/p&gt;


&lt;p&gt;　　Parnew是Serial收集器的多线程版本，也是新生代收集器。ParNew收集器和Serial收集器除了多线程工作外几乎是相同的，包括所有控制参数、收集算法、stop the world，对象分配规则，回收策略等都是一样的。运行流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190508161127865-1394556920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虽然与Serial收集器相比仅仅多了多线程特性外，没有其它的创新之处，但是它却是许多Server模式下的虚拟机新生代收集器的首选，原因在于目前为止只有Serial和ParNew两个新生代收集器能够与性能优异的CMS配合使用。关于CMS介绍将在下文展开描述。&lt;/p&gt;


&lt;p&gt;&lt;em&gt;　　Parallel Scavenge也是一款使用复制算法的新生代收集器。该收集器与其它收集器不同的是，它关注的目标是达到一个可控制的吞吐量，而CMS等收集器的关注点则是尽可能地减少用户线程地停顿时间，提高用户体验。Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。也因此，Parallel Scavenge 被成为“吞吐量优先”收集器。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;　　停顿时间越短就越适合与用户交互较多地程序，这样用户体验才更好。而高吞吐量则可以让出更多的cpu资源给用户线程，让程序更快的完成运算任务，更适合后台运算较多而不需要与用户交互的程序。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;　　自适应调节策略是&lt;em id=&quot;__mceDel&quot;&gt;Parallel Scavenge收集器的特点，也是与ParNew收集器的区别。&lt;em id=&quot;__mceDel&quot;&gt;Parallel Scavenge通过打开-XX:+UseAdaptiveSizePolicy的设置，就不需要手动地调节新生代（-Xmn）大小，Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，而是根据当前系统运行情况来确定这些参数，从而提高程序地吞吐量和缩短停顿时间，这一过程称之为GC自适应的调节策略（GC Ergonomics）。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;　　另外值得注意的一点是，&lt;em id=&quot;__mceDel&quot;&gt;Parallel Scavenge无法已CMS配合使用，如果新生代选择了&lt;em id=&quot;__mceDel&quot;&gt;Parallel Scavenge收集器，那么老年代的收集器只能选用Serial Old或者Parallel Old来配置使用。&lt;/em&gt;&lt;/em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;&lt;em&gt;　　Serial Old是Serial收集器的老年代版本，也是单线程工作的，使用的是“标记-整理”算法。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　该收集器主要用于Client模式下的虚拟机使用，如果在Server模式下可以与&lt;/em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;Parallel Scavenge收集器配合使用；&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。运行流程如下：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190508172212784-1193262127.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;&lt;em&gt;　　&lt;em id=&quot;__mceDel&quot;&gt;Parallel Old是Parallel Scavenge的老年代版本，也是一个并行收集器，使用“标记-整理”算法。该收集器在jdk1.6后对外提供使用，Parallel Scavenge 和  &lt;em id=&quot;__mceDel&quot;&gt;Parallel Old配合使用的话，更加适合应用于高吞吐量和cpu敏感资源的场合。下面是这两个收集器配合使用的运行流程：&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190508173257753-1511029872.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;　　CMS（Concurrent Mark Sweep）是一个并发收集器，使用了“标记-清除”算法来实现的。该收集器最求的更短的停顿时间，从而提升用户体验，因此也非常符合使用在网站、B/S系统的服务端的应用。&lt;/p&gt;
&lt;p&gt;　　CMS收集器的工作流程大概可以分为以下4个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始标记：这个阶段仅仅标记能够和gc roots直接关联的对象，速度很快，但是需要“stop the world”。&lt;/li&gt;
&lt;li&gt;并发标记：这个阶段开始进行gc roots tracing标记，与用户线程一起执行的，消耗时间很多。&lt;/li&gt;
&lt;li&gt;重新标记：这个阶段是要是修正在并发标记期间由于用户线程也在运行而产生标记变动的那部分对象的标记，比较耗费的时间比初始标记阶段要长，但是远比并发标记阶段要短，这个过程也是需要“stop the world”的。&lt;/li&gt;
&lt;li&gt;并发清除：对无用对象进行回收操作。这个过程与用户线程并行执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　由于标记和清除阶段可以和用户线程一起工作，因此几乎可以把CMS收集器的工作是并发的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190508180119437-2064927211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　CMS是一款优秀的收集器，它的主要优点是低停顿，并发收集，因此也被成为并发低停顿收集器（Concurrent Low Pause Collector）。&lt;/p&gt;
&lt;p&gt;　　当然，CMS收集器也有一定的缺点，主要包括一下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CMS收集器使用“标记-清除”算法实现，因此不可避免地有内存碎片地问题。当内存碎片过多时，在分配大对象地过程中即使有足够的空间，但是找不到足够地连续的空间来放该对象，那么就有可能触发一次full gc。&lt;/li&gt;
&lt;li&gt;无法处理浮动垃圾（Floating Garbage） 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。这是因为在标记的过程中用户线程也在运行着，那么在这一过程中出现的垃圾无法立即回收，而是等下一次gc才能清理，我这部分的垃圾就叫做“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。&lt;/li&gt;
&lt;li&gt;对cpu资源非常敏感。其实，只要是面对并发的情况下都会有这个问题，在并发阶段虽然不会中断用户线程，但是因为占用了部分用户的资源而导致程序变慢，总吞吐量降低。CMS搜集器默认的线程数 = （cpu核数 + 3） / 4，当cpu数量大于4时，垃圾回收线程数不少于25%，随着线程数的增加而下降，当cpu数量小于4时对线程的执行效率有显著的影响。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　运行示意图如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190508220304509-363296343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　G1（Garbage-First）是一款&lt;strong&gt;面向服务端应用&lt;/strong&gt;的垃圾收集器，JDK 7 Update4 后开始进入商用。HotSpot开发团队赋予它的使命是未来可以替换掉JDK 1.5中发布的CMS收集器。之前提供的收集器都是仅作用于新生代或者是老年代，但是G1收集器可以作用于新生代和老年代，因为使用G1收集器是java heap的内存结构有很大的不同，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但是他们已经没有了物理上的隔阂了，它们都是region的一部分的集合。&lt;/p&gt;
&lt;p&gt;　　G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，与其他收集器相比，G1收集器具有以下特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;并行与并发&lt;/strong&gt;： G1能充分利用多CPU，多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间，部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分代收集&lt;/strong&gt;： 与其他收集器一样，分代概念在G1中仍然得以保留。虽然G1可以不需要其他收集器配合能够独立管理整个堆，但它能够采用不用的方式去处理新创的对象和已经存活了一段世纪那、熬过多次GC的旧对象以获得更好的收集效果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间整合&lt;/strong&gt;： 与CMS的“标记-清除”算法不同，G1整体来看采用了“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。无论使用哪一种方法，都意味着G1运作期间不会产生内存空间碎片的问题，收集后能提供规整的可用空间。这种特性有利于程序长时间运行，分配大对象是不会因为无法得到连续内存空间而提前处罚一次GC。&lt;/li&gt;
&lt;li&gt;可预测的停顿： 这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了最求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎是java（RTSJ）的垃圾收集器的特征了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　G1收集器之所以能够建立可预测的停顿时间模型，因为他能够有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要的经验值），在后台维护一个优先表，每次根据允许的收集时间，优先回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。&lt;/p&gt;
&lt;p&gt;　　在G1收集器中，Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region中的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描，也不会有遗漏。&lt;/p&gt;
&lt;p&gt;　　如果不计算维护Remembered Set的操作，G1收集器的运作大致分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;初始标记（Initial Marking）&lt;/strong&gt;： 这阶段仅仅只是标记GC Roots能直接关联到的对象并修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段需要停顿线程，但是耗时很短。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发标记（Concurrent Marking）&lt;/strong&gt;： 从GC Roots 开始对堆的对象进行可达性分析，找出存活的对象，这阶段耗时长，但是可以与用户程序并发执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终标记（Final Marking）&lt;/strong&gt;： 为了修正在并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录记录在线程Remembered Set Logs里面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;筛选回收（Live Data Counting and Evacuation）&lt;/strong&gt;： 首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这一阶段是可以与用户程序一起并发执行的，但是因为只回收部分Region，时间是用户可控的，而且停顿用户线程将大幅度提高收集效率。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　执行流程如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190508230524633-68667895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;table class=&quot;table&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;收集器&lt;/th&gt;
&lt;th&gt;串行、并行or并发&lt;/th&gt;
&lt;th&gt;新生代/老年代&lt;/th&gt;
&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;目标&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Serial&lt;/td&gt;
&lt;td&gt;串行&lt;/td&gt;
&lt;td&gt;新生代&lt;/td&gt;
&lt;td&gt;复制算法&lt;/td&gt;
&lt;td&gt;响应速度优先&lt;/td&gt;
&lt;td&gt;单CPU环境下的Client模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Serial Old&lt;/td&gt;
&lt;td&gt;串行&lt;/td&gt;
&lt;td&gt;老年代&lt;/td&gt;
&lt;td&gt;标记-整理&lt;/td&gt;
&lt;td&gt;响应速度优先&lt;/td&gt;
&lt;td&gt;单CPU环境下的Client模式、CMS的后备预案&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ParNew&lt;/td&gt;
&lt;td&gt;并行&lt;/td&gt;
&lt;td&gt;新生代&lt;/td&gt;
&lt;td&gt;复制算法&lt;/td&gt;
&lt;td&gt;响应速度优先&lt;/td&gt;
&lt;td&gt;多CPU环境时在Server模式下与CMS配合&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Parallel Scavenge&lt;/td&gt;
&lt;td&gt;并行&lt;/td&gt;
&lt;td&gt;新生代&lt;/td&gt;
&lt;td&gt;复制算法&lt;/td&gt;
&lt;td&gt;吞吐量优先&lt;/td&gt;
&lt;td&gt;在后台运算而不需要太多交互的任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Parallel Old&lt;/td&gt;
&lt;td&gt;并行&lt;/td&gt;
&lt;td&gt;老年代&lt;/td&gt;
&lt;td&gt;标记-整理&lt;/td&gt;
&lt;td&gt;吞吐量优先&lt;/td&gt;
&lt;td&gt;在后台运算而不需要太多交互的任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CMS&lt;/td&gt;
&lt;td&gt;并发&lt;/td&gt;
&lt;td&gt;老年代&lt;/td&gt;
&lt;td&gt;标记-清除&lt;/td&gt;
&lt;td&gt;响应速度优先&lt;/td&gt;
&lt;td&gt;集中在互联网站或B/S系统服务端上的Java应用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;G1&lt;/td&gt;
&lt;td&gt;并发&lt;/td&gt;
&lt;td&gt;both&lt;/td&gt;
&lt;td&gt;标记-整理+复制算法&lt;/td&gt;
&lt;td&gt;响应速度优先&lt;/td&gt;
&lt;td&gt;面向服务端应用，将来替换CMS&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　参考资料： 《深入理解Java虚拟机-JVM高级特性与最佳实践》 -周志明&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 15:20:00 +0000</pubDate>
<dc:creator>rainple</dc:creator>
<og:description>前言 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的虚拟机所提供的垃圾收集器都有可能会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rainple/p/10829144.html</dc:identifier>
</item>
<item>
<title>QT学习小demo之LightMD（MarkDown编辑器） - Asche</title>
<link>http://www.cnblogs.com/asche/p/10834587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/asche/p/10834587.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;很早之前就有了写一个类似Windows记事本的想法，加上最近也刚好在学编译原理，所以就想把两者结合起来，于是就打算结合MarkDown，开发一款MarkDown编辑器。&lt;br/&gt;不过由于我之前一直使用的是Java语言居多，对c++并不熟悉，所以一些糟糕的代码风格和规范还望各位大佬谅解！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/asche910/LightMD&quot;&gt;&lt;strong&gt;LightMD&lt;/strong&gt;&lt;/a&gt; 即一款基于QT实现的markdown编辑器，当然也可以作为代码编辑器，由于时间与个人能力等原因，目前实现的功能非常有限！&lt;/p&gt;
&lt;p&gt;主要包括：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持语法高亮（目前支持C/C++）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持MarkDown预览&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;代码行数、文本信息统计等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其它一些基本的文件处理相关功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了直接上图吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470456/201905/1470456-20190508205235739-283039740.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470456/201905/1470456-20190508205249824-1786194754.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本项目主要目的在于学习qt相关的windows开发，其中主要有以下几个模块：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整体布局&lt;/li&gt;
&lt;li&gt;代码编辑器&lt;/li&gt;
&lt;li&gt;markdown编辑器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;整体布局&quot;&gt;整体布局&lt;/h2&gt;
&lt;p&gt;最外面当然是_QMainWindow_， 然后从上到下依次是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;menuBar&lt;/li&gt;
&lt;li&gt;QSplitter&lt;/li&gt;
&lt;li&gt;statusBar&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;menubar的简单示例如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    QMenu *menuFile = menuBar()-&amp;gt;addMenu(tr(&quot;&amp;amp;File&quot;));
    QAction *itemNew = new QAction(tr(&quot;&amp;amp;New&quot;), this);
    itemNew-&amp;gt;setStatusTip(tr(&quot;Create a new file&quot;));
    connect(itemNew, &amp;amp;QAction::triggered, this, &amp;amp;Home::newFile);
    menuFile-&amp;gt;addAction(itemNew);
   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中QMenu就是最外面显示的menu，即鼠标不点击就可以看见的那个menu；QAction则是QMenu上众多选项之一；然后是调用connect函数为QAction设置点击事件。&lt;/p&gt;
&lt;p&gt;中间主体则是QSplitter，&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;
    QSplitter *centralSplitter = new QSplitter(this);

    setCentralWidget(centralSplitter);

    centralSplitter-&amp;gt;addWidget(codeEditor);
    centralSplitter-&amp;gt;addWidget(preview);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先new一个QSplitter，然后将其设置为中间组件，然后在QSplitter上再添加两个组件，分别为代码编辑区域和markdown预览区域的组件。&lt;br/&gt;这两个区域在文章下面将有具体讲解。&lt;/p&gt;
&lt;p&gt;底部则是statusBar：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    label = new QLabel(&quot;LightMD is ready!&quot;);
    textType = new QLabel(&quot;Plain Text&quot;);
    codeLength = new QLabel(&quot;Length:652&quot;);
    codeLines = new QLabel(&quot;Lines:54&quot;);

    statusBar()-&amp;gt;addWidget(label, 1);
    statusBar()-&amp;gt;addPermanentWidget(textType);
    statusBar()-&amp;gt;addPermanentWidget(codeLength);
    statusBar()-&amp;gt;addPermanentWidget(codeLines);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;label用来显示正常的提示消息；textType用来显示当前的文本类型，如markdown或c++等；codeLength和codeLines就不用过多解释了吧。&lt;/p&gt;
&lt;h2 id=&quot;代码编辑器&quot;&gt;代码编辑器&lt;/h2&gt;
&lt;p&gt;其中代码编辑框我纠结了半天，用QPlainTextEdit好呢，还是QTextEdit好？？？其中StackOverflow上一高赞回答如下：&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;QPlainTextEdit is an advanced viewer/editor supporting plain text. It is optimized to handle large documents and to respond quickly to user input.&lt;/p&gt;
&lt;p&gt;QPlainText uses very much the same technology and concepts as QTextEdit, but is optimized for plain text handling.&lt;/p&gt;
&lt;p&gt;QPlainTextEdit works on paragraphs and characters. A paragraph is a formatted string which is word-wrapped to fit into the width of the widget. By default when reading plain text, &amp;gt; one newline signifies a paragraph. A document consists of zero or more paragraphs. Paragraphs are separated by hard line breaks. Each character within a paragraph has its&lt;br/&gt;own attributes, for example, font and color.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单点说，就是QPlainTextEdit对普通文本的支持度特别高，也就是很方便，不过一些复杂功能却不能实现；而QTextEdit是一个更加重量级的组件，支持各种复杂功能，不过一些简单的功能可能没有QPlainTextEdit使用的那么方便。&lt;/p&gt;
&lt;p&gt;两者我都简单试用后，发现还是QPlainTextEdit用着比较方便，于是就决定采用QPlainTextEdit了。&lt;/p&gt;
&lt;p&gt;然后关于代码框和代码行数的实现，QT的官方demo里面好像有现成的（不得不说，qt的demo是真的多！）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470456/201905/1470456-20190508223249653-563185469.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，这里的实现我就不解释啥了。&lt;/p&gt;
&lt;h2 id=&quot;markdown编辑器&quot;&gt;markdown编辑器&lt;/h2&gt;
&lt;p&gt;这里官方也有个markdown的demo，下载就行了。不过要注意的是，这里由于用到了web引擎，所以这里必须使用vs来编译运行，安装vs环境这里不懂的还是自行百度吧。&lt;/p&gt;
&lt;p&gt;官方demo中好像实现的都挺全的，我只是做了个小修改，然后就转移到LightMD来了。&lt;br/&gt;其中markdown预览流程是先将markdown内容转换为对应的html内容，然后web引擎来显示HTML页面。&lt;br/&gt;其中转换官方也全部为我们做好了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470456/201905/1470456-20190508224007661-1374021705.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;由于时间关系，当然是直接套用了。不过以后有空的话，自己再去实现一下吧。&lt;/p&gt;
&lt;p&gt;最后，LightMd项目地址：&lt;a href=&quot;https://github.com/asche910/LightMD&quot;&gt;LightMD&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 14:48:00 +0000</pubDate>
<dc:creator>Asche</dc:creator>
<og:description>很早之前就有了写一个类似Windows记事本的想法，加上最近也刚好在学编译原理，所以就想把两者结合起来，于是就打算结合MarkDown，开发一款MarkDown编辑器。 不过由于我之前一直使用的是Ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/asche/p/10834587.html</dc:identifier>
</item>
<item>
<title>微服务熔断限流Hystrix之流聚合 - 程序员果果</title>
<link>http://www.cnblogs.com/huanchupkblog/p/10835570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huanchupkblog/p/10835570.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;上一篇介绍了 Hystrix Dashboard 监控单体应用的例子，在生产环境中，监控的应用往往是一个集群，我们需要将每个实例的监控信息聚合起来分析，这就用到了 Turbine 工具。Turbine有一个重要的功能就是汇聚监控信息，并将汇聚到的监控信息提供给Hystrix Dashboard来集中展示和监控。&lt;/p&gt;
&lt;h2 id=&quot;流程&quot;&gt;流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224203653-1490838029.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验&quot;&gt;实验&lt;/h2&gt;
&lt;h3 id=&quot;工程说明&quot;&gt;工程说明&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;eureka-server&lt;/td&gt;
&lt;td&gt;8761&lt;/td&gt;
&lt;td&gt;注册中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;service-hi&lt;/td&gt;
&lt;td&gt;8762&lt;/td&gt;
&lt;td&gt;服务提供者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;service-consumer&lt;/td&gt;
&lt;td&gt;8763&lt;/td&gt;
&lt;td&gt;服务消费者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;service-turbine&lt;/td&gt;
&lt;td&gt;8765&lt;/td&gt;
&lt;td&gt;Turbine服务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;核心代码&quot;&gt;核心代码&lt;/h3&gt;
&lt;p&gt;eureka-server 、service-hi、service-consumer 工程代码与上一节 &lt;a href=&quot;https://mp.weixin.qq.com/s/Nmqu2ul4aRT6iXecxrmt9A&quot;&gt;微服务熔断限流Hystrix之Dashboard&lt;/a&gt; 相同，下面是 service-turbine 工程的核心代码。&lt;/p&gt;
&lt;h4 id=&quot;pom.xml&quot;&gt;pom.xml&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-turbine&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix-dashboard&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;application.yml&quot;&gt;application.yml&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8765

spring:
  application:
    name: service-turbine
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/

turbine:
  app-config: service-consumer
  cluster-name-expression: new String(&quot;default&quot;)
  combine-host-port: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;turbine.app-config：指定要监控的应用名&lt;/li&gt;
&lt;li&gt;turbine.cluster-name-expression：指定集群的名字&lt;/li&gt;
&lt;li&gt;turbine.combine-host-port：表示同一主机上的服务通过host和port的组合来进行区分，默认情况下是使用host来区分，这样会使本地调试有问题&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;启动类&quot;&gt;启动类&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableEurekaClient
@EnableHystrixDashboard
@EnableTurbine
public class ServiceTurbineApplication {

    public static void main(String[] args) {
        SpringApplication.run( ServiceTurbineApplication.class, args );
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模拟多实例&quot;&gt;模拟多实例&lt;/h3&gt;
&lt;p&gt;启动多个 service-consumer 工程，来模拟多实例，可以通过命令java -jar service-consumer.jar --server.port=XXXX 来实现。&lt;/p&gt;
&lt;p&gt;为了方便，在编辑器中实现启动工程。但 idea 不支持单个应用的多次启动， 需要开启并行启动：&lt;/p&gt;
&lt;p&gt;选择 “Edit Configurations...”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224247934-54106350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;勾选 “Allow running in parallel”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224258847-65412686.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;启动工程，访问 http//localhost:8763/hi , http//localhost:8764/hi , http//localhost:8763/oh , http//localhost:8764/oh，来产生测试数据。&lt;/p&gt;
&lt;p&gt;访问 http://localhost:8765/hystrix ，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224310961-1018349054.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入监控流地址 http://localhost:8765/turbine.stream ，点击 Monitor Stream 进入监控页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224337299-967613962.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到聚合了两个实例的 Hystrix dashbord 数据。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;https://github.com/gf-huanchupk/SpringCloudLearning/tree/master/chapter18&lt;/p&gt;
&lt;p&gt;欢迎扫码或微信搜索公众号《程序员果果》关注我，关注有惊喜~&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201903/528977-20190311112108481-2022563516.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 14:45:00 +0000</pubDate>
<dc:creator>程序员果果</dc:creator>
<og:description>简介 上一篇介绍了 Hystrix Dashboard 监控单体应用的例子，在生产环境中，监控的应用往往是一个集群，我们需要将每个实例的监控信息聚合起来分析，这就用到了 Turbine 工具。Turb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huanchupkblog/p/10835570.html</dc:identifier>
</item>
<item>
<title>SpringBoot整合Redis使用Restful风格实现CRUD功能 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/10835571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/10835571.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇文章主要介绍的是SpringBoot整合Redis，使用Restful风格实现的CRUD功能。&lt;/p&gt;
&lt;h2 id=&quot;redis-介绍&quot;&gt;Redis 介绍&lt;/h2&gt;
&lt;p&gt;Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value缓存产品有以下三个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多的使用说明可以查看官方的文档。&lt;br/&gt;官方文档: https://redis.io&lt;/p&gt;
&lt;h2 id=&quot;springboot整合redis&quot;&gt;SpringBoot整合Redis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明：如果想直接获取工程那么可以直接跳到底部，通过链接下载工程代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发准备&quot;&gt;开发准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;环境要求&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;JDK&lt;/strong&gt;：1.8&lt;br/&gt;&lt;strong&gt;SpringBoot&lt;/strong&gt;：1.5.15.RELEASE&lt;br/&gt;&lt;strong&gt;Redis&lt;/strong&gt;：3.2或以上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;：Redis的偶数为稳定版本，奇数为非稳定版本，所以在使用的时候最好使用偶数的版本！&lt;/p&gt;
&lt;p&gt;Reids的可以看我之前的写的这篇文章: &lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/7536708.html&quot;&gt;Redis安装教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先还是Maven的相关依赖:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;fastjson&amp;gt;1.2.41&amp;lt;/fastjson&amp;gt;
    &amp;lt;springboot&amp;gt;1.5.15.RELEASE&amp;lt;/springboot&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${springboot}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
            &amp;lt;version&amp;gt;${springboot}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${springboot}&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${springboot}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
  
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${fastjson}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
  
  &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加了相应的maven依赖之后，我们再来查看配置。&lt;br/&gt;&lt;strong&gt;Redis&lt;/strong&gt;配置的说明在下面中已经说的很详细了，这里就不在过多说明了，不过需要注意的是如果&lt;strong&gt;Redis&lt;/strong&gt;是集群版的话，需要使用这个&lt;code&gt;spring.redis.cluster.nodes&lt;/code&gt;这个配置，该配置为Redis的Host加上Port，多个之间用，逗号隔开。&lt;br/&gt;&lt;strong&gt;application.properties&lt;/strong&gt;的配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Redis服务器地址
# 单机版配置
spring.redis.host = 127.0.0.1
spring.redis.port = 6379
# redis最大重连数
redis.cluster.max-redirects=3
# Redis服务器连接密码（默认为空）
redis.password=
# 最大空闲数  
redis.maxIdle=5  
# 连接池的最大数据库连接数。
redis.maxTotal=5 
# 最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。  
redis.maxWaitMillis=1000  
# 连接的最小空闲时间 默认1800000毫秒(30分钟)  
redis.minEvictableIdleTimeMillis=300000  
# 每次释放连接的最大数目,默认3  
redis.numTestsPerEvictionRun=3 
# 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1  
redis.timeBetweenEvictionRunsMillis=30000  
# 是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个  
redis.testOnBorrow=true  
# 在空闲时检查有效性, 默认false  
redis.testWhileIdle=true  &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码编写&quot;&gt;代码编写&lt;/h3&gt;
&lt;p&gt;首先是编写Redis的配置类，对Redis这块进行配置。&lt;br/&gt;在使用SpringBoot整合Redis的时候，SpringBoot是可以根据配置自动完成Redis的相关配置，不过为了更灵活一点，我们这边还是手动加载一下配置，配置成自己想要的那种效果吧。&lt;br/&gt;首先，配置一个Redis的连接池，使用&lt;code&gt;redis.clients.jedis.JedisPoolConfig&lt;/code&gt;这个类来进行实现，相关的配置在代码的注释中说明得很详细了，这里就不在过多讲述了；&lt;br/&gt;然后，再来配置一个Redis的工厂，加载Redis的连接池配置，这里我们也可以进行一下设置，如果Redis设置了密码，我们就加载改密码，否则就不进行加载。&lt;br/&gt;继而，我们再来设置数据存入Redis的序列化的方式并开启事务。这里也顺便说下为什么要设置序列化器，如果不设置，那么在用实体类(未序列化)进行存储的时候，会提示错误: &lt;code&gt;Failed to serialize object using DefaultSerializer&lt;/code&gt;; 当然，也可以不设置，不过存储的实体类必须进行序列化。&lt;br/&gt;最后，我们再来实例化RedisTemplate的对象，加载上述的配置。在使用的时候，只需要使用如下的方式注入就可以使用了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Autowired
RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Redis的配置类的代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 
 * @Title: RedisConfig
 * @Description: redis初始化配置
 * @Version:1.0.0
 * @author pancm
 * @date 2018年6月7日
 */
@Component
public class RedisConfig {

    @Value(&quot;${redis.maxIdle}&quot;)
    private Integer maxIdle;

    @Value(&quot;${redis.maxTotal}&quot;)
    private Integer maxTotal;

    @Value(&quot;${redis.maxWaitMillis}&quot;)
    private Integer maxWaitMillis;

    @Value(&quot;${redis.minEvictableIdleTimeMillis}&quot;)
    private Integer minEvictableIdleTimeMillis;

    @Value(&quot;${redis.numTestsPerEvictionRun}&quot;)
    private Integer numTestsPerEvictionRun;

    @Value(&quot;${redis.timeBetweenEvictionRunsMillis}&quot;)
    private long timeBetweenEvictionRunsMillis;

    @Value(&quot;${redis.testOnBorrow}&quot;)
    private boolean testOnBorrow;

    @Value(&quot;${redis.testWhileIdle}&quot;)
    private boolean testWhileIdle;

    @Value(&quot;${redis.cluster.max-redirects}&quot;)
    private Integer mmaxRedirectsac;

    @Value(&quot;${redis.password}&quot;)
    private String redispwd;

    /**
     * JedisPoolConfig 连接池
     * 
     * @return
     */
    @Bean
    public JedisPoolConfig jedisPoolConfig() {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        // 最大空闲数
        jedisPoolConfig.setMaxIdle(maxIdle);
        // 连接池的最大数据库连接数
        jedisPoolConfig.setMaxTotal(maxTotal);
        // 最大建立连接等待时间
        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);
        // 逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
        jedisPoolConfig.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        // 每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3
        jedisPoolConfig.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
        // 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
        jedisPoolConfig.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        // 是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个
        jedisPoolConfig.setTestOnBorrow(testOnBorrow);
        // 在空闲时检查有效性, 默认false
        jedisPoolConfig.setTestWhileIdle(testWhileIdle);
        return jedisPoolConfig;
    }



    
    /**
     * 配置工厂
     */
    @Bean
    public JedisConnectionFactory JedisConnectionFactory(JedisPoolConfig jedisPoolConfig) {
        JedisConnectionFactory JedisConnectionFactory = new JedisConnectionFactory(jedisPoolConfig);
        if (redispwd == null || redispwd.length() == 0) {
            JedisConnectionFactory.setPassword(redispwd);
        }
        return JedisConnectionFactory;
    }

    

    /**
     * 设置数据存入 redis 的序列化方式,并开启事务
     * 
     * @param redisTemplate
     * @param factory
     */
    private void initDomainRedisTemplate(RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate, RedisConnectionFactory factory) {
        /*
         * 设置 序列化器 .
         * 如果不设置，那么在用实体类(未序列化)进行存储的时候，会提示错误: Failed to serialize object using DefaultSerializer;
         */
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        // 开启事务
        redisTemplate.setEnableTransactionSupport(true);
        // 将连接工厂设置到模板类中
        redisTemplate.setConnectionFactory(factory);
    }
    
    /**
     * 实例化 RedisTemplate 对象
     * @return
     */
    @Bean
    public RedisTemplate&amp;lt;String, Object&amp;gt; functionDomainRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate = new RedisTemplate&amp;lt;&amp;gt;();
        initDomainRedisTemplate(redisTemplate, redisConnectionFactory);
        return redisTemplate;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，如果自己想使用自定义的Redis工具类进行实现，那么只需在该配置类中注册一个Bean注入封装一下就可以了，然后在工具类中加载一下就可以了。&lt;br/&gt;配置类中添加:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Bean(name = &quot;redisUtil&quot;)
    public RedisUtil redisUtil(RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate) {
        RedisUtil redisUtil = new RedisUtil();
        redisUtil.setRedisTemplate(redisTemplate);
        return redisUtil;
    }'
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redis的工具类添加如下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate;

    public void setRedisTemplate(RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Redis工具类示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Resource
    private RedisUtil redisUtil;
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;讲完Redis的配置类之后，我们再来进行编写相应的实体类、dao层、service层和Controller层的代码了。&lt;br/&gt;由于这块的代码比较简单，而且格式和之前的&lt;a href=&quot;https://github.com/xuwujing/springBoot-study&quot;&gt;项目&lt;/a&gt;基本类似，因此这里我就简单的贴下代码了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又是万能的用户表 (&lt;em&gt;^▽^&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class User implements Serializable{
    private static final long serialVersionUID = 1L;
    /** 编号 */
     private int id;
     /** 姓名 */
     private String name;
     /** 年龄 */
     private int age;
     
     public User(){
     }

    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String toString() {
        return JSONObject.toJSONString(this);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Dao 数据层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我是使用的自定义的Redis工具类，其实也就是对&lt;code&gt;RedisTemplate&lt;/code&gt;做了二次封装。&lt;br/&gt;因为使用的是set（集合）方式存储的，所以我这边把用户数据的ID作为key，用户数据作为value了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现类的代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@Repository
public class UserDaoImpl implements UserDao {

    @Resource
    private RedisUtil redisUtil;
    

    @Override
    public void addUser(User user) {
        redisUtil.set(String.valueOf(user.getId()), user.toString());
    }


    @Override
    public void updateUser(User user) {
        redisUtil.set(String.valueOf(user.getId()), user.toString());
    }


    @Override
    public void deleteUser(int id) {
        redisUtil.del(String.valueOf(id));
    }

    
    @Override
    public User findByUserId(int id) {
        String data = redisUtil.get(String.valueOf(id)).toString();
        User user = JSON.parseObject(data, User.class);
        return  user;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Service 业务层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;业务层这边处理比较简单，成功就返回true，失败就返回false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现类的代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@Service
public class UserServiceImpl implements UserService {   

    private  final Logger logger = LoggerFactory.getLogger(this.getClass());
    @Autowired
    private UserDao userDao;    
    
    @Override
    public boolean addUser(User user) {
        boolean flag=false;
        try{
            userDao.addUser(user);
            flag=true;
        }catch(Exception e){
            logger.error(&quot;新增失败!&quot;,e);
        }
        return flag;
    }

    @Override
    public boolean updateUser(User user) {
        boolean flag=false;
        try{
            userDao.updateUser(user);
            flag=true;
        }catch(Exception e){
            logger.error(&quot;修改失败!&quot;,e);
        }
        return flag;
    }

    @Override
    public boolean deleteUser(int id) {
        boolean flag=false;
        try{
            userDao.deleteUser(id);
            flag=true;
        }catch(Exception e){
            logger.error(&quot;删除失败!&quot;,e);
        }
        return flag;
    }


    @Override
    public User findByUserId(int id) {
        return userDao.findByUserId(id);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Controller 控制层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制层这边也比较简单，使用Restful风格实现的CRUD功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@RestController
@RequestMapping(value = &quot;/api&quot;)
public class UserRestController {
    
    private  final Logger logger = LoggerFactory.getLogger(this.getClass());

    
    @Autowired
    private UserService userService;
 
    @PostMapping(&quot;/user&quot;)
    public boolean addUser(@RequestBody User user) {
        logger.info(&quot;开始新增...&quot;);
        return userService.addUser(user);
    }
    
    @PutMapping(&quot;/user&quot;)
    public boolean updateUser(@RequestBody User user) {
        logger.info(&quot;开始更新...&quot;);
        return userService.updateUser(user);
    }
    
    @DeleteMapping(&quot;/user&quot;)
    public boolean delete(@RequestParam(value = &quot;id&quot;, required = true) int userId) {
        logger.info(&quot;开始删除...&quot;);
        return userService.deleteUser(userId);
    }
    

    @GetMapping(&quot;/user&quot;)
    public User findByUserId(@RequestParam(value = &quot;id&quot;, required = true) int userId) {
        logger.info(&quot;开始查询所有数据...&quot;);
        return userService.findByUserId(userId);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;App 入口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和普通的SpringBoot项目基本一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@SpringBootApplication
public class App 
{
    public static void main( String[] args )
    {
        SpringApplication.run(App.class, args);
        System.out.println(&quot;程序正在运行...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;功能测试&quot;&gt;功能测试&lt;/h3&gt;
&lt;p&gt;我们成功启动该程序之后，使用Postman工具来进行接口测试。&lt;/p&gt;
&lt;p&gt;首先添加一条数据，使用POST方式进行请求&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;POST http://localhost:8180/api/user&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508212843449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;界面返回true，表示新增成功了！&lt;/p&gt;
&lt;p&gt;然后在进行查询，使用GET请求。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GET http://localhost:8180/api/user?id=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508213152690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再来使用&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/10393111.html&quot;&gt;RedisDesktopManager&lt;/a&gt;工具进行查询看下，是否真的写入到Redis中去了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508213342227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;可以看到已经成功写入到Redis中了。&lt;/p&gt;
&lt;p&gt;然后我们再来更新下更新该数据，使用PUT方式请求。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PUT http://localhost:8180/api/user&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里只是更改了下age年龄，Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:19}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508213514420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;可以看到已经成功更新了。&lt;/p&gt;
&lt;p&gt;最后我们再来查询一遍看下是否成功更新。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GET http://localhost:8180/api/user?id=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:19}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019050821361881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;可以看到已经成功更新了。&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;其实SpringBoot整合Redis整个项目很早之前就已经写好并且上传到Github了，但是一直没有抽出时间写篇博客讲述(还有很多SpringBoot的项目也是如此)，最近不是那么的忙了，于是准备了下时间编写本篇博文。后续个人Github上的SpringBoot项目中以后有时间的话，也会对其中的一些发表博文进行讲解，不过那是以后的事了ヽ(ー_ー)ノ&lt;/p&gt;
&lt;p&gt;关于SpringBoot整合Redis的文章就讲解到这里了，如有不妥，欢迎指正！&lt;/p&gt;
&lt;h3 id=&quot;项目地址&quot;&gt;项目地址&lt;/h3&gt;
&lt;p&gt;SpringBoot整合Redis的项目工程地址:&lt;br/&gt;https://github.com/xuwujing/springBoot-study/tree/master/springboot-Redis&lt;/p&gt;
&lt;p&gt;SpringBoot整个集合的地址:&lt;br/&gt;https://github.com/xuwujing/springBoot-study&lt;/p&gt;
&lt;h3 id=&quot;springboot整合系列的文章&quot;&gt;SpringBoot整合系列的文章&lt;/h3&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　　　　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 14:41:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 本篇文章主要介绍的是SpringBoot整合Redis，使用Restful风格实现的CRUD功能。 Redis 介绍 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key valu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/10835571.html</dc:identifier>
</item>
<item>
<title>【面试被虐】说说游戏中的敏感词过滤是如何实现的？ - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/10834993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/10834993.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;版权声明：本文为&lt;strong&gt;苦逼的码农&lt;/strong&gt;原创。未经同意禁止任何形式转载，特别是那些复制粘贴到别的平台的，否则，必定追究。欢迎大家多多转发，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小秋今天去面试了，面试官问了一个与敏感词过滤算法相关的问题，然而小秋对敏感词过滤算法一点也没听说过。于是，有了下下事情的发生.....&lt;/p&gt;
&lt;h3 id=&quot;面试官开怼&quot;&gt;面试官开怼&lt;/h3&gt;
&lt;p&gt;面试官：玩过王者荣耀吧？了解过&lt;strong&gt;敏感词过滤吗？&lt;/strong&gt;，例如在游戏里，如果我们发送“你在干嘛？麻痹演员啊你？”，由于“麻痹”是一个敏感词，所以当你把聊天发出来之后，我们会用“**”来代表“麻痹”这次词，所以发送出来的聊天会变成这样：“你在干嘛？**演员啊你？”。&lt;/p&gt;
&lt;p&gt;小秋：听说过啊，在各大社区也经常看到，例如评论一个问题等，一些粗话经常被过滤掉了。&lt;/p&gt;
&lt;p&gt;面试官：嗯，如果我给你一段文字，以及给你一些需要过滤的敏感词，你会怎么来实现这个敏感词过滤的算法呢？例如我给你一段字符串“abcdefghi&quot;,以及三个敏感词&quot;de&quot;, &quot;bca&quot;, &quot;bcf&quot;。&lt;/p&gt;
&lt;p&gt;小秋：（敏感词过来算法？？不就是字符串匹配吗？）我可以通过字符串匹配算法，例如在字符串”abcdefghi&quot;在查找是否存在字串“de&quot;，如果找到了就把”de“用&quot;&lt;strong&gt;&quot;代替。通过三次匹配之后，接变成这样了：“abc&lt;/strong&gt; fghi&quot;。&lt;/p&gt;
&lt;p&gt;面试官：可以说说你采用哪种字符串匹配算法吗？&lt;/p&gt;
&lt;p&gt;小秋：最简单的方法就是采用两个for循环保留求解了，不过每次匹配的都时间复杂度为O(n*m)，我可以采用 KMP 字符串匹配算法，这样时间复杂度是 O(m+n)。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;n 表示字符串的长度，m 表示每个敏感词的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面试官：这是一个方法，对于敏感词过滤，你还有其他方法吗？&lt;/p&gt;
&lt;p&gt;小秋：（其他方法？说实话，我也觉得不是采用这种 KMP 算法来匹配的了，可是，之前也没去了解过敏感词，这下要凉）对敏感词过来之前也没了解过，暂时没想到其他方法。&lt;/p&gt;
&lt;h3 id=&quot;trie-树&quot;&gt;trie 树&lt;/h3&gt;
&lt;p&gt;面试官：了解过 trie 树吗？&lt;/p&gt;
&lt;p&gt;小秋：（嘿嘿，数据结构这方法，我得争气点）了解过，我还用代码实现过。&lt;/p&gt;
&lt;p&gt;面试官：可以说说它的特点吗？&lt;/p&gt;
&lt;p&gt;小秋：trie 树也称为字典树、单词查找树，最大的特点就是共享&lt;strong&gt;字符串的公共前缀&lt;/strong&gt;来达到节省空间的目的了。例如，字符串 &quot;abc&quot;和&quot;abd&quot;构成的 trie 树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a9220f8cb8b0f8?w=471&amp;amp;h=336&amp;amp;f=png&amp;amp;s=17359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;trie 树的&lt;strong&gt;根节点&lt;/strong&gt;不存任何数据，每&lt;strong&gt;整个&lt;/strong&gt;个分支代表一个完整的字符串。像 abc 和 abd 有公共前缀 ab，所以我们可以共享节点 ab。如果再插入 abf，则变成这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a92247a12117dc?w=475&amp;amp;h=348&amp;amp;f=png&amp;amp;s=19729&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我再插入 bc，则是这样（bc 和其他三个字符串没有公共前缀）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a922651588ed2e?w=489&amp;amp;h=342&amp;amp;f=png&amp;amp;s=23915&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;面试官：那如果再插入 &quot;ab&quot; 这个字符串呢？&lt;/p&gt;
&lt;p&gt;小秋：差点说了，每个分支的内部可能也含有完整的字符串，所以我们可以对于那些是某个字符串结尾的节点做一个&lt;strong&gt;标记&lt;/strong&gt;，例如 abc, abd,abf 都包含了字符串 ab,所以我们可以在节点 b 这里做一个标记。如下（我用红色作为标记）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a922b03ec436fa?w=432&amp;amp;h=370&amp;amp;f=png&amp;amp;s=23677&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面试官：可以说说 trie 树有哪些应用吗？&lt;/p&gt;
&lt;p&gt;小秋：trie 最大的特点就是利用了字符串的公共前缀，像我们有时候在百度、谷歌输入某个关键字的时候，它会给我们列举出很多相关的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a92311b4dfcdf2?w=984&amp;amp;h=236&amp;amp;f=png&amp;amp;s=25030&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种就是通过 trie 树来实现的。&lt;/p&gt;
&lt;p&gt;小秋：（嗯？ trie 又称为单词查找树，好像可以用 trie 来实现刚才的敏感词匹配？面试官无缘无故提 trie 树难道别有用意？）&lt;/p&gt;
&lt;p&gt;面试官：刚才的敏感词过滤，其实也可以采用 trie 来实现，你知道怎么实现吗？&lt;/p&gt;
&lt;h3 id=&quot;trie-树来实现敏感词过滤&quot;&gt;trie 树来实现敏感词过滤&lt;/h3&gt;
&lt;p&gt;小秋：（果然，面试官真是个好人啊，直接提示了，要是还不知道怎么实现，那不真凉？）我想想........我知道了，我可以这样来实现：&lt;/p&gt;
&lt;p&gt;先把你给我的三个敏感词：&quot;de&quot;, &quot;bca&quot;, &quot;bcf&quot; 建立一颗 trie 树，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a923f595a6fae5?w=411&amp;amp;h=349&amp;amp;f=png&amp;amp;s=21076&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着我们可以采用三个指针来遍历，我直接用上面你给你例子来演示吧。&lt;/p&gt;
&lt;p&gt;1、首先指针 p1 指向 root，指针 p2 和 p3 指向字符串第一个字符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a9241249414d30?w=950&amp;amp;h=509&amp;amp;f=png&amp;amp;s=34588&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、然后从字符串的 a 开始，检测有没有以 a 作为前缀的敏感词，直接判断 p1 的孩子节点中是否有 a 这个节点就可以了，显然这里没有。接着把指针 p2 和 p3 向右移动一格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a9243c3fe2e11c?w=914&amp;amp;h=405&amp;amp;f=png&amp;amp;s=32150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、然后从字符串 b 开始查找，看看是否有以 b 作为前缀的字符串，p1 的孩子节点中有 b，这时，&lt;strong&gt;我们把 p1 指向节点 b，p2 向右移动一格，不过，p3不动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a92475d7f0be9d?w=926&amp;amp;h=413&amp;amp;f=png&amp;amp;s=32744&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、判断 p1 的孩子节点中是否存在 p2 指向的字符c，显然有。我们把 p1 指向节点 c，p2 向右移动一格，p3不动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a92496237eb3cf?w=919&amp;amp;h=412&amp;amp;f=png&amp;amp;s=32450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、判断 p1 的孩子节点中是否存在 p2 指向的字符d，这里没有。这意味着，&lt;strong&gt;不存在以字符b作为前缀的敏感词&lt;/strong&gt;。这时我们把p2和p3都移向字符c，p1 还是还原到最开始指向 root。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a924bda72bba94?w=1019&amp;amp;h=400&amp;amp;f=png&amp;amp;s=33486&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、和前面的步骤一样，判断有没以 c 作为前缀的字符串，显然这里没有，所以把 p2 和 p3 移到字符 d。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a924cf1a5d0009?w=980&amp;amp;h=483&amp;amp;f=png&amp;amp;s=35107&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、然后从字符串 d 开始查找，看看是否有以 d 作为前缀的字符串，p1 的孩子节点中有 d，这时，&lt;strong&gt;我们把 p1 指向节点 b，p2 向右移动一格，不过，p3和刚才一样不动。&lt;/strong&gt;（看到这里，我猜你已经懂了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a924e6fa468db5?w=1046&amp;amp;h=375&amp;amp;f=png&amp;amp;s=33005&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8、判断 p1 的孩子节点中是否存在 p2 指向的字符e，显然有。我们把 p1 指向节点 e，&lt;strong&gt;并且，这里e是最后一个节点了，查找结束，所以存在敏感词de&lt;/strong&gt;，即 p3 和 p2 这个区间指向的就是敏感词了，把 p2 和 p3 指向的区间那些字符替换成 *。并且把 p2 和 p3 移向字符 f。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a9251b45b50014?w=954&amp;amp;h=422&amp;amp;f=png&amp;amp;s=33004&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、接着还是重复同样的步骤，知道 p3 指向最后一个字符。&lt;/p&gt;
&lt;h3 id=&quot;复杂度分析&quot;&gt;复杂度分析&lt;/h3&gt;
&lt;p&gt;面试官：可以说说时间复杂度吗？&lt;/p&gt;
&lt;p&gt;小秋：如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;这里我说明一下，在实际的应用中，构建 trie 树的时间复杂度我觉得可以忽略，因为 trie 树我们可以在一开始就构建了，以后可以无数次重复利用的了。而刚才的 kmp 算法时间复杂度是 t *(m+n)，不过kmp需要维护 next 数组比较费空间，而且在实际情况中,敏感词的数量 t 是比较大，而 n 反而比较小的吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;10、如果让你来 构建 trie 树，你会用什么数据结构来实现？&lt;/p&gt;
&lt;p&gt;小秋：我一般使用 Java，我会采用 HashMap 来实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。&lt;/p&gt;
&lt;p&gt;面试官：嗯，回去等通知吧。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;今天主要将了 trie 树以及 trie 树的一些应用，还要就是如何通过 trie 树来实现敏感词的过滤，至于代码的实现，我这里就不给出了，在实现的时候，为了防止这种”麻 痹&quot;或者“麻￥痹”等，我们也要对特殊字符进行过滤等，有兴趣的可以去实现一波。&lt;/p&gt;
&lt;p&gt;今天也是第一次尝试采用这种对话的方式来写文章，可能写的没有平常的好，不过我会慢慢改进，希望大家多多支持。&lt;/p&gt;
&lt;blockquote readability=&quot;6.4939759036145&quot;&gt;
&lt;p&gt;最后推荐下我的公众号：苦逼的码农，主要分享一下技术文章、面试题、算法题，各种工具、视频资源等，里面已有100多篇原创文章，期待各路英雄来交流，点击即可扫码关注&lt;a href=&quot;https://qr.tschangcun.net/q/zsDeBp&quot;&gt;戳我即可关注&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 08 May 2019 14:01:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>版权声明：本文为 苦逼的码农 原创。未经同意禁止任何形式转载，特别是那些复制粘贴到别的平台的，否则，必定追究。欢迎大家多多转发，谢谢。 小秋今天去面试了，面试官问了一个与敏感词过滤算法相关的问题，然而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/10834993.html</dc:identifier>
</item>
<item>
<title>gitbook 入门教程之解决windows热加载失败问题 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10834754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10834754.html</guid>
<description>&lt;h2 id=&quot;破镜如何贴花黄&quot;&gt;破镜如何贴花黄&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 在 &lt;code&gt;Windows&lt;/code&gt; 系统无法热加载,总是报错!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 是一款文档编写利器,可以方便地 &lt;code&gt;markdown&lt;/code&gt; 输出成美观优雅的 &lt;code&gt;html&lt;/code&gt; ,&lt;code&gt;gitbook serve&lt;/code&gt; 启动服务器后,原来相貌平平的 &lt;code&gt;markdown&lt;/code&gt; 丑小鸭摇身一变就成了倾国倾城的 &lt;code&gt;html&lt;/code&gt; 绝色佳人.&lt;/p&gt;
&lt;p&gt;如果源文件发生更改,&lt;code&gt;Windows&lt;/code&gt; 却无法按照预期那样重启服务器,直接抛出一个异常,立即终止了 &lt;code&gt;markdown&lt;/code&gt; 的化妆.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Restart after change in file README.md

Stopping server
events.js:183
      throw er; // Unhandled 'error' event
      ^

Error: EPERM: operation not permitted, lstat 'F:\workspace\private-cloud-backup\gitbook-test\_book'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对镜贴花黄&quot;&gt;对镜贴花黄&lt;/h3&gt;
&lt;p&gt;现在看一下 &lt;code&gt;markdown&lt;/code&gt; 灰姑娘变身 &lt;code&gt;html&lt;/code&gt; 小姐姐的神奇过程吧!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook serve --log=debug
Live reload server started on port: 35729
Press CTRL+C to quit ...

debug: readme found at README.md
debug: summary file found at SUMMARY.md
debug: cleanup folder &quot;G:\sublime\gitbook-test\_book&quot;
info: 7 plugins are installed
info: loading plugin &quot;livereload&quot;... OK
...
info: loading plugin &quot;theme-default&quot;... OK
info: found 1 pages
info: found 0 asset files
debug: calling hook &quot;config&quot;
debug: calling hook &quot;init&quot;
debug: copy assets from theme C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-theme-default\_assets\website
...
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-livereload\book
debug: generate page &quot;README.md&quot;
debug: calling hook &quot;page:before&quot;
debug: calling hook &quot;page&quot;
debug: index page README.md
debug: calling hook &quot;finish:before&quot;
debug: calling hook &quot;finish&quot;
debug: write search index
info: &amp;gt;&amp;gt; generation finished with success in 1.5s !

Starting server ...
Serving book on http://localhost:4000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上述输出日志,我们可以分析出 &lt;code&gt;gitbook&lt;/code&gt; 的基本运行流程.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加载 &lt;code&gt;readme&lt;/code&gt; 和 &lt;code&gt;summary&lt;/code&gt; 文件,若存在 &lt;code&gt;glossary&lt;/code&gt; 文件也会加载,并删除 &lt;code&gt;_book&lt;/code&gt; 目录&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: readme found at README.md
debug: summary file found at SUMMARY.md
debug: cleanup folder &quot;G:\sublime\gitbook-test\_book&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;加载依赖插件,若没有找到相应插件会报错,提示运行 &lt;code&gt;gitbook install&lt;/code&gt; 安装插件.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;info: 7 plugins are installed
info: loading plugin &quot;livereload&quot;... OK
info: loading plugin &quot;highlight&quot;... OK
info: loading plugin &quot;search&quot;... OK
info: loading plugin &quot;lunr&quot;... OK
info: loading plugin &quot;sharing&quot;... OK
info: loading plugin &quot;fontsettings&quot;... OK
info: loading plugin &quot;theme-default&quot;... OK&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;扫描页面和静态资源文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;info: found 1 pages
info: found 0 asset files&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;读取配置文件并初始化&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: calling hook &quot;config&quot;
debug: calling hook &quot;init&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;拷贝样式资源和插件资源&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: copy assets from theme C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-theme-default\_assets\website
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-fontsettings\assets
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-sharing\assets
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-lunr\assets
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-search\assets
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-highlight\css
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-livereload\book&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;开始生成单独页面,依次执行 &lt;code&gt;page:before&lt;/code&gt; ,&lt;code&gt;page&lt;/code&gt; 回调函数,全部页面执行完毕后执行 &lt;code&gt;finish:before&lt;/code&gt; 和 &lt;code&gt;finish&lt;/code&gt; 回调函数.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: generate page &quot;README.md&quot;
debug: calling hook &quot;page:before&quot;
debug: calling hook &quot;page&quot;
debug: index page README.md
debug: calling hook &quot;finish:before&quot;
debug: calling hook &quot;finish&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;生成搜索文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: write search index&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动完毕,输出成功信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Starting server ...
Serving book on http://localhost:4000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下服务器启动后会占用两个端口,一个是对外暴露的 &lt;code&gt;4000&lt;/code&gt; 端口,用于浏览器访问项目.&lt;/p&gt;
&lt;p&gt;另外一个是 &lt;code&gt;35729&lt;/code&gt; 端口,用于监听本地文件变化,重启服务器进而实现热加载功能.&lt;/p&gt;
&lt;p&gt;本地服务器启动后我们就可以访问 &lt;code&gt;http://localhost:4000&lt;/code&gt; 预览静态网站效果,&lt;code&gt;markdown&lt;/code&gt; 源文件华丽演变成 &lt;code&gt;html&lt;/code&gt; 富文本文件.&lt;/p&gt;
&lt;h3 id=&quot;破镜怎化妆&quot;&gt;破镜怎化妆&lt;/h3&gt;
&lt;p&gt;不幸的是,&lt;code&gt;Windows&lt;/code&gt; 热加载可能会有问题,也就是说如果启动服务器后,本地文件发生改变,此时会触发热加载功能而报错 &lt;code&gt;Error: EPERM: operation not permitted&lt;/code&gt; ,这样一来浏览器又无法访问了.&lt;/p&gt;
&lt;p&gt;刚刚变身的 &lt;code&gt;markdown&lt;/code&gt; 瞬间又被打回原形,无法欣赏化妆后的容颜了,这样的体验相当不好!&lt;/p&gt;
&lt;p&gt;边化妆边照镜子才是做到心中有谱,随时调整,如果不照镜子而直接化妆,那不是一般人能做到的.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 启动本地服务器给我们提供了镜子,但热加载失败又把镜子摔碎了,还怎么愉快的化妆?&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Restart after change in file README.md

Stopping server
debug: readme found at README.md
debug: summary file found at SUMMARY.md
debug: cleanup folder &quot;G:\sublime\gitbook-test\_book&quot;
events.js:174
      throw er; // Unhandled 'error' event
      ^

Error: EPERM: operation not permitted, lstat 'G:\sublime\gitbook-test\_book'
Emitted 'error' event at:
    at FSWatcher._handleError (C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\chokidar\index.js:236:10)
    at ReaddirpReadable.emit (events.js:189:13)
    at Immediate.&amp;lt;anonymous&amp;gt; (C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\chokidar\node_modules\readdirp\stream-api.js:82:32)
    at runCallback (timers.js:705:18)
    at tryOnImmediate (timers.js:676:5)
    at processImmediate (timers.js:658:5)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;寻医问诊修破镜&quot;&gt;寻医问诊修破镜&lt;/h2&gt;
&lt;p&gt;现在问题已经复现,接下来就要开始寻医问诊,试图让破镜重圆,好让 &lt;code&gt;markdown&lt;/code&gt; 灰姑娘变成人见人爱的 &lt;code&gt;html&lt;/code&gt; 小姐姐.&lt;/p&gt;
&lt;p&gt;根据报错信息描述,定位到删除 &lt;code&gt;_book&lt;/code&gt; 目录再次创建该目录时,提示 &lt;code&gt;EPERM: operation not permitted&lt;/code&gt; ,即无权操作.&lt;/p&gt;
&lt;h3 id=&quot;柯南附体&quot;&gt;柯南附体&lt;/h3&gt;
&lt;p&gt;既然说是操作权限的问题,那我们看一下 &lt;code&gt;_book&lt;/code&gt; 目录现在是怎样状态吧!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ ls
gitbook-errorforwindows-preview.png  README.md  SUMMARY.md&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前项目已经没有 &lt;code&gt;_book&lt;/code&gt; 目录,证明发生报错时确实已经删除了 &lt;code&gt;_book&lt;/code&gt; 目录,但是某种原因无权再次创建该文件夹而重启失败.&lt;/p&gt;
&lt;p&gt;然而,这只是表现现象,老师告诉我们,要透过现象看本质,即使现在没有 &lt;code&gt;_book&lt;/code&gt; 文件再次启动服务器还是会启动成功并创建 &lt;code&gt;_book&lt;/code&gt; 文件的,所以真想只有一个!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-c2b30c8fb721e6e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-errorforwindows-onlyonetruth.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那就是,&lt;code&gt;gitbook&lt;/code&gt; 控制台在说谎!&lt;/p&gt;
&lt;p&gt;虽然排除了 &lt;code&gt;gitbook&lt;/code&gt; 无权创建 &lt;code&gt;_book&lt;/code&gt; 目录的嫌疑,那又怎么解释重启服务器却没能创建 &lt;code&gt;_book&lt;/code&gt;目录这件事呢?&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: cleanup folder &quot;G:\sublime\gitbook-test\_book&quot;
events.js:174
      throw er; // Unhandled 'error' event
      ^

Error: EPERM: operation not permitted, lstat 'G:\sublime\gitbook-test\_book'
Emitted 'error' event at:
    at FSWatcher._handleError (C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\chokidar\index.js:236:10)
    at ReaddirpReadable.emit (events.js:189:13)
    at Immediate.&amp;lt;anonymous&amp;gt; (C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\chokidar\node_modules\readdirp\stream-api.js:82:32)
    at runCallback (timers.js:705:18)
    at tryOnImmediate (timers.js:676:5)
    at processImmediate (timers.js:658:5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看一下 &lt;code&gt;FSWatcher._handleError&lt;/code&gt; 异常信息: &lt;code&gt;sed -n &quot;223,239p&quot; ~/.gitbook/versions/3.2.3/node_modules/chokidar/index.js&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;分析发现: &lt;code&gt;FSWatcher._handleError&lt;/code&gt; 是私有方法,作用是处理异常信息,和这起事故关联不大.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master)
$ sed -n &quot;223,239p&quot; ~/.gitbook/versions/3.2.3/node_modules/chokidar/index.js
// Private method: Common handler for errors
//
// * error  - object, Error instance
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._handleError = function(error) {
  var code = error &amp;amp;&amp;amp; error.code;
  var ipe = this.options.ignorePermissionErrors;
  if (error &amp;amp;&amp;amp;
    code !== 'ENOENT' &amp;amp;&amp;amp;
    code !== 'ENOTDIR' &amp;amp;&amp;amp;
    (!ipe || (code !== 'EPERM' &amp;amp;&amp;amp; code !== 'EACCES'))
  ) this.emit('error', error);
  return error || this.closed;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们接着往下找,再看一下 &lt;code&gt;ReaddirpReadable.emit (events.js:189:13)&lt;/code&gt; ,这里没有给出文件的具体路径,所以暂时无法定位.&lt;/p&gt;
&lt;p&gt;那我们再看下一个 &lt;code&gt;Immediate.&amp;lt;anonymous&amp;gt;&lt;/code&gt; : &lt;code&gt;sed -n &quot;78,96p&quot; ~/.gitbook/versions/3.2.3/node_modules/chokidar/node_modules/readdirp/stream-api.js&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master)
$ sed -n &quot;78,96p&quot; ~/.gitbook/versions/3.2.3/node_modules/chokidar/node_modules/readdirp/stream-api.js
proto._handleFatalError = function (err) {
  var self = this;
  setImmediate(function () {
    if (self._paused) return self._errors.push(err);
    if (!self._destroyed) self.emit('error', err);
  });
}

function createStreamAPI () {
  var stream = new ReaddirpReadable();

  return {
      stream           :  stream
    , processEntry     :  stream._processEntry.bind(stream)
    , done             :  stream._done.bind(stream)
    , handleError      :  stream._handleError.bind(stream)
    , handleFatalError :  stream._handleFatalError.bind(stream)
  };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遗憾的是,仍然没有找到具体问题,那就继续看一下一条线索.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;timers.js:705:18&lt;/code&gt; 和 &lt;code&gt;events.js:189:13&lt;/code&gt; 都没有显示具体的文件位置,如果也在 &lt;code&gt;chokidar&lt;/code&gt; 模块的话就好了.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master)
$ tree -P &quot;events.js&quot; --prune ~/.gitbook/versions/3.2.3/
/c/Users/Administrator/.gitbook/versions/3.2.3/
└── node_modules
    ├── cheerio
    │   └── node_modules
    │       └── jsdom
    │           └── lib
    │               └── jsdom
    │                   └── level2
    │                       └── events.js
    └── gitbook-plugin-theme-default
        └── src
            └── js
                └── core
                    └── events.js

11 directories, 2 files

Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master)
$ tree -P &quot;timers.js&quot; --prune ~/.gitbook/versions/3.2.3/
/c/Users/Administrator/.gitbook/versions/3.2.3/
0 directories, 0 files&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;git-bash&lt;/code&gt; 命令行正常没有 &lt;code&gt;tree&lt;/code&gt; 命令,如需扩展参考我另外一篇文章.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过肉眼验证,发现 &lt;code&gt;events.js&lt;/code&gt; 根本就没有 &lt;code&gt;174&lt;/code&gt; 行文件,所以这两个文件大都不是目标文件.&lt;/p&gt;
&lt;p&gt;既然命令行中无法找到目标文件,那就请专业的搜索工具全系统查找这两个文件吧,这里使用的是 &lt;code&gt;Everything&lt;/code&gt; 搜索工具.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-2a095ad83b8a6486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-errorforwindows-everything-search.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然并卵,依然没有找到目标文件.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;毕竟不是柯南,没有发现真相&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-08ed138a63853ff1.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;gitbook-errorforwindows-emoj-sad.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;求助官方&quot;&gt;求助官方&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 可是开源产品,出现问题的应该不止我一个,所以去 &lt;code&gt;github&lt;/code&gt; 看看有没有遇到和我一样的问题.&lt;/p&gt;
&lt;p&gt;虽然找到了志同道合的小伙伴,但是并没有提供解决方案,连官方都放弃了,那我还有什么可留恋的?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-790761d5835e8ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-errorforwindows-issue.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.5116279069767&quot;&gt;
&lt;p&gt;点击查看 &lt;a href=&quot;https://github.com/GitbookIO/gitbook-cli/issues/67&quot;&gt;gitbook serve livereload error&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;自己动手&quot;&gt;自己动手&lt;/h3&gt;
&lt;p&gt;最害怕的不是 &lt;code&gt;bug&lt;/code&gt;,而是发现了 &lt;code&gt;bug&lt;/code&gt; 却无法定位,虽然控制台有报错信息但是没有找到真正的文件!&lt;/p&gt;
&lt;p&gt;首先确认下当前系统版本,然后采取版本切换方式测试其他版本是否存在该问题.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook --version
CLI version: 2.3.2
GitBook version: 3.2.3&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;升级到最新版&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;gitbook ls&lt;/code&gt; 是列出当前已安装的版本,而 &lt;code&gt;gitbook ls-remote&lt;/code&gt; 则是列出远程服务器版本.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 列出本地已安装版本
$ gitbook ls
GitBook Versions Installed:

    * 3.2.3

Run &quot;gitbook update&quot; to update to the latest version.

# 列出远程可用版本
$ gitbook ls-remote
Available GitBook Versions:

     4.0.0-alpha.6, 4.0.0-alpha.5, 4.0.0-alpha.4, 4.0.0-alpha.3, 4.0.0-alpha.2, 4.0.0-alpha.1, 3.2.3, 3.2.2, 3.2.1, 3.2.0, 3.2.0-pre.1, 3.2.0-pre.0, 3.1.1, 3.1.0, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-pre.15, 3.0.0-pre.14, 3.0.0-pre.13, 3.0.0-pre.12, 3.0.0-pre.11, 3.0.0-pre.10, 3.0.0-pre.9, 3.0.0-pre.8, 3.0.0-pre.7, 3.0.0-pre.6, 3.0.0-pre.5, 3.0.0-pre.4, 3.0.0-pre.3, 3.0.0-pre.2, 3.0.0-pre.1, 2.6.9, 2.6.8, 2.6.7, 2.6.6, 2.6.5, 2.6.4, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.2, 2.5.1, 2.5.0, 2.5.0-beta.7, 2.5.0-beta.6, 2.5.0-beta.5, 2.5.0-beta.4, 2.5.0-beta.3, 2.5.0-beta.2, 2.5.0-beta.1, 2.4.3, 2.4.2, 2.4.1, 2.4.0, 2.3.3, 2.3.2, 2.3.1, 2.3.0, 2.2.0, 2.1.0, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-beta.5, 2.0.0-beta.4, 2.0.0-beta.3, 2.0.0-beta.2, 2.0.0-beta.1, 2.0.0-alpha.9, 2.0.0-alpha.8, 2.0.0-alpha.7, 2.0.0-alpha.6, 2.0.0-alpha.5, 2.0.0-alpha.4, 2.0.0-alpha.3, 2.0.0-alpha.2, 2.0.0-alpha.1

Tags:

     latest : 2.6.9
     pre : 4.0.0-alpha.6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前最新发布版本是 &lt;code&gt;3.2.3&lt;/code&gt; ,而我们本地已安装的版本正是该版本,所以现在应该测试 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 版.&lt;/p&gt;
&lt;p&gt;看到 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 心里有些忐忑,根据版本管理约定,版本号一般有三部分组成,第一部分代表不兼容的重大升级,第二部分代表主干兼容的功能升级,第三部分是小版本修复.&lt;/p&gt;
&lt;p&gt;由 &lt;code&gt;3.2.3&lt;/code&gt; 直接跨度到 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 意味着 &lt;code&gt;gitbook&lt;/code&gt; 发生了重大重构!&lt;/p&gt;
&lt;p&gt;算了,先下载试试看!&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;gitbook fetch&lt;/code&gt; 下载 和 &lt;code&gt;gitbook update&lt;/code&gt;升级,两种方式都可以体验最新版本,这里选择下载方式方便进行不同版本的切换.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 下载 `4.0.0-alpha.6` 版本
$ gitbook fetch 4.0.0-alpha.6
Installing GitBook 4.0.0-alpha.6
gitbook@4.0.0-alpha.6 C:\Users\SNOWDR~1\AppData\Local\Temp\tmp-8912hSrxNvTCrFEH\node_modules\gitbook
├── escape-html@1.0.3
├── escape-string-regexp@1.0.5
├── destroy@1.0.4
├── ignore@3.1.2
└── ied@2.3.6 (lodash.memoize@4.1.2, lodash.frompairs@4.0.1, force-symlink@0.0.2, semver@5.7.0, minimist@1.2.0, node-uuid@1.4.8, npm-package-arg@4.2.1, source-map-support@0.4.18, ora@0.2.3, easy-table@1.1.1, rimraf@2.6.3, tar-fs@1.16.3, gunzip-maybe@1.4.1, init-package-json@1.10.3, rxjs@5.0.0-rc.1, needle@1.0.0, node-pre-gyp@0.6.39, node-gyp@3.8.0)

GitBook 4.0.0-alpha.6 has been installed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看一下本地安装 &lt;code&gt;gitbook&lt;/code&gt; 版本,确保待会运行时使用最新的 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 版本.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 列出本地已安装版本
$ gitbook ls
GitBook Versions Installed:

    * 4.0.0-alpha.6
      3.2.3

Run &quot;gitbook update&quot; to update to the latest version.

# 列出当前正在使用版本
$ gitbook current
GitBook version is 3.2.3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;gitbook serve --gitbook=4.0.0-alpha.6 --log=debug&lt;/code&gt; 运行 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 版本并打印 &lt;code&gt;debug&lt;/code&gt; 级别日志.&lt;/p&gt;
&lt;p&gt;意外的是,竟然没有连启动都没启动成功,提示无法打开 &lt;code&gt;~\.gitbook\versions\4.0.0-alpha.6\node_modules\gitbook-plugin-livereload\_assets\plugin.js&lt;/code&gt; 文件.&lt;/p&gt;
&lt;p&gt;回想到版本号规范,可能 &lt;code&gt;v3&lt;/code&gt; 到 &lt;code&gt;v4&lt;/code&gt; 更改比较大,版本不兼容吧,重新初始化项目试试看!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 初始化项目并指定 `gitbook` 运行版本
$ gitbook init --gitbook=4.0.0-alpha.6
Warning: Accessing PropTypes via the main React package is deprecated, and will be removed in  React v16.0. Use the latest available v15.* prop-types package from npm instead. For info on usage, compatibility, migration and more, see https://fb.me/prop-types-docs
info: create SUMMARY.md
info: initialization is finished&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而,仍然还是同样的报错,依旧无法启动.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook serve --gitbook=4.0.0-alpha.6 --log=debug                             Warning: Accessing PropTypes via the main React package is deprecated, and will be removed in  React v16.0. Use the latest available v15.* prop-types package from npm instead. For info on usage, compatibility, migration and more, see https://fb.me/prop-types-docs
Live reload server started on port: 35729
Press CTRL+C to quit ...

...

Error: ENOENT: no such file or directory, open 'C:\Users\snowdreams1006\.gitbook\versions\4.0.0-alpha.6\node_modules\gitbook-plugin-livereload\_assets\plugin.js'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此路不通,再换一条,既然向上无法处理,那向下回退会不会有结果呢?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回退版本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当前系统版本是 &lt;code&gt;3.2.3&lt;/code&gt;,最新测试版本是 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; ,然而最近一次提交的版本却是 &lt;code&gt;2.6.9&lt;/code&gt; ?&lt;/p&gt;
&lt;p&gt;为什么 &lt;code&gt;gitbook-ci&lt;/code&gt; 管理的 &lt;code&gt;gitbook&lt;/code&gt; 版本号会突然跳水,会不会有什么猫腻,难不成修复了什么 &lt;code&gt;bug&lt;/code&gt; ?&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook ls-remote
Available GitBook Versions:

     4.0.0-alpha.6, 4.0.0-alpha.5, 4.0.0-alpha.4, 4.0.0-alpha.3, 4.0.0-alpha.2, 4.0.0-alpha.1, 3.2.3, 3.2.2, 3.2.1, 3.2.0, 3.2.0-pre.1, 3.2.0-pre.0, 3.1.1, 3.1.0, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-pre.15, 3.0.0-pre.14, 3.0.0-pre.13, 3.0.0-pre.12, 3.0.0-pre.11, 3.0.0-pre.10, 3.0.0-pre.9, 3.0.0-pre.8, 3.0.0-pre.7, 3.0.0-pre.6, 3.0.0-pre.5, 3.0.0-pre.4, 3.0.0-pre.3, 3.0.0-pre.2, 3.0.0-pre.1, 2.6.9, 2.6.8, 2.6.7, 2.6.6, 2.6.5, 2.6.4, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.2, 2.5.1, 2.5.0, 2.5.0-beta.7, 2.5.0-beta.6, 2.5.0-beta.5, 2.5.0-beta.4, 2.5.0-beta.3, 2.5.0-beta.2, 2.5.0-beta.1, 2.4.3, 2.4.2, 2.4.1, 2.4.0, 2.3.3, 2.3.2, 2.3.1, 2.3.0, 2.2.0, 2.1.0, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-beta.5, 2.0.0-beta.4, 2.0.0-beta.3, 2.0.0-beta.2, 2.0.0-beta.1, 2.0.0-alpha.9, 2.0.0-alpha.8, 2.0.0-alpha.7, 2.0.0-alpha.6, 2.0.0-alpha.5, 2.0.0-alpha.4, 2.0.0-alpha.3, 2.0.0-alpha.2, 2.0.0-alpha.1

Tags:

     latest : 2.6.9
     pre : 4.0.0-alpha.6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;带着这些疑问,不妨下载 &lt;code&gt;2.6.9&lt;/code&gt; 版本试试,看一下能否热加载?&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;gitbook serve --log=debug --gitbook=2.6.9&lt;/code&gt; 指定 &lt;code&gt;gitbook&lt;/code&gt; 版本,依旧失败!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook serve --log=debug --gitbook=2.6.9
Error loading version latest: Error: Cannot find module 'q'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:582:15)
    at Function.Module._load (internal/modules/cjs/loader.js:508:25)
    at Module.require (internal/modules/cjs/loader.js:637:17)
    at require (internal/modules/cjs/helpers.js:22:18)
    at Object.&amp;lt;anonymous&amp;gt; (C:\Users\myHome\.gitbook\versions\2.6.9\lib\index.js:3:9)
    at Module._compile (internal/modules/cjs/loader.js:701:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10)
    at Module.load (internal/modules/cjs/loader.js:600:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:539:12)
    at Function.Module._load (internal/modules/cjs/loader.js:531:3)

TypeError: Cannot read property 'commands' of null&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重回现场&quot;&gt;重回现场&lt;/h3&gt;
&lt;p&gt;现在把目光再次聚焦到最初的案发现场,这一次只能背水一战了,自己动手要么丰衣足食要么饿死冻死!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Stopping server
debug: readme found at README.md
debug: summary file found at SUMMARY.md
debug: cleanup folder &quot;G:\sublime\private-cloud-backup\gitbook-test\_book&quot;
events.js:174
      throw er; // Unhandled 'error' event
      ^

Error: EPERM: operation not permitted, lstat 'G:\sublime\private-cloud-backup\gitbook-test\_book'
Emitted 'error' event at:
    at FSWatcher._handleError (C:\Users\myHome\.gitbook\versions\3.2.3\node_modules\chokidar\index.js:236:10)
    at ReaddirpReadable.emit (events.js:189:13)
    at Immediate.&amp;lt;anonymous&amp;gt; (C:\Users\myHome\.gitbook\versions\3.2.3\node_modules\chokidar\node_modules\readdirp\stream-api.js:82:32)
    at runCallback (timers.js:705:18)
    at tryOnImmediate (timers.js:676:5)
    at processImmediate (timers.js:658:5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于上述错误描述中,在&lt;strong&gt;真相只有一个&lt;/strong&gt;章节中已经探讨过,当时得出的结论是 &lt;code&gt;gitbook&lt;/code&gt; 是删除 &lt;code&gt;_book&lt;/code&gt; 文件夹再新建 &lt;code&gt;_book&lt;/code&gt; 文件夹时发生了意外.&lt;/p&gt;
&lt;p&gt;如果这个行为不是由 &lt;code&gt;gitbook&lt;/code&gt; 发生而是由我们手动干预的话,也就是说,当成功启动本地服务器后并在即将发生热加载之前,此时人为删除 &lt;code&gt;_book&lt;/code&gt; 文件夹,会发生什么?&lt;/p&gt;
&lt;p&gt;我的猜想是:&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;gitbook&lt;/code&gt; 的热加载机制是监听本地文件目录系统发生改变,进而停止服务器再重新启动服务器.&lt;/p&gt;
&lt;p&gt;当我们手动删除了 &lt;code&gt;_book&lt;/code&gt; 文件夹,对于 &lt;code&gt;gitbook&lt;/code&gt; 来说,再触发重启服务器的那一刻来说,突然发现没有 &lt;code&gt;_book&lt;/code&gt; 文件夹,此时就不会删除也不会新建时发生异常,相当于直接新建 &lt;code&gt;_book&lt;/code&gt; 文件夹,变相把&lt;strong&gt;热加载&lt;/strong&gt;弄成了&lt;strong&gt;初始启动&lt;/strong&gt;模式!&lt;/p&gt;
&lt;p&gt;希望苍天不负我,如若不行,只能看源码逻辑找 &lt;code&gt;bug&lt;/code&gt; 了!&lt;/p&gt;
&lt;p&gt;你猜猜会怎么样? &lt;code&gt;it works&lt;/code&gt; !&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-7e5df990d64afa29.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;gitbook-errorforwindows-rm_book.gif&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在实验中,&lt;code&gt;gitbook serve --log=debug&lt;/code&gt; 启动本地服务器后,如果本地文件发生修改会重启失败!&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;但是,如果在启动本地服务器后立即删除 &lt;code&gt;_book&lt;/code&gt; 目录,当本地文件发生修改时重启服务就能成功了.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到此为止,总算找到一个解决方案,那就是启动服务后立即删除 &lt;code&gt;_book&lt;/code&gt; 目录.&lt;/p&gt;
&lt;h2 id=&quot;不算完美的总结&quot;&gt;不算完美的总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;windows&lt;/code&gt; 系统上启动 &lt;code&gt;gitbook&lt;/code&gt; 服务后,如果本地文件发生更改,热加会失败.&lt;/p&gt;
&lt;p&gt;如果启动服务器后立即删除 &lt;code&gt;_book&lt;/code&gt; 目录,那么之后再怎么修改本地文件都能顺利重启.&lt;/p&gt;
&lt;p&gt;目前还没有找到问题的根源,下一次将深入源码继续探讨到底是哪里出问题导致 &lt;code&gt;Windows&lt;/code&gt; 系统无法重启.&lt;/p&gt;
&lt;p&gt;虽然及时删除 &lt;code&gt;_book&lt;/code&gt; 目录并不算是很好的解决方案,但至少 &lt;code&gt;markdown&lt;/code&gt; 灰姑娘又能化妆成 &lt;code&gt;html&lt;/code&gt; 小姐姐了呢!&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 13:23:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>破镜如何贴花黄 在 系统无法热加载,总是报错! 是一款文档编写利器,可以方便地 输出成美观优雅的 , 启动服务器后,原来相貌平平的 丑小鸭摇身一变就成了倾国倾城的 绝色佳人. 如果源文件发生更改, 却</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowdreams1006/p/10834754.html</dc:identifier>
</item>
</channel>
</rss>