<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Security 前后端分离登录，非法请求直接返回 JSON - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/11645640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/11645640.html</guid>
<description>&lt;p&gt;hello 各位小伙伴，国庆节终于过完啦，松哥也回来啦，今天开始咱们继续发干货！&lt;/p&gt;
&lt;p&gt;关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HKJOlatXDS8awBNyCe9JMg&quot;&gt;手把手带你入门 Spring Security！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/oDow2miLIst-R4NNzc_i4g&quot;&gt;Spring Security 登录添加验证码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/X1t-VCxzxIcQKOAu-pJrdw&quot;&gt;SpringSecurity 登录使用 JSON 格式数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7D0qJiEIzNuz8VAVvZsXCA&quot;&gt;Spring Security 中的角色继承问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/riyFQSrkQBQBCyomE__fLA&quot;&gt;Spring Security 中使用 JWT!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/1rVPzJGCtDZKvMoA4BYzIA&quot;&gt;Spring Security 结合 OAuth2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不过，今天要和小伙伴们聊一聊 Spring Security 中的另外一个问题，那就是在 Spring Security 中未获认证的请求默认会重定向到登录页，但是在前后端分离的登录中，这个默认行为则显得非常不合适，今天我们主要来看看如何实现未获认证的请求直接返回 JSON ，而不是重定向到登录页面。&lt;/p&gt;
&lt;h2 id=&quot;前置知识&quot;&gt;前置知识&lt;/h2&gt;
&lt;p&gt;这里关于 Spring Security 的基本用法我就不再赘述了，如果小伙伴们不了解，可以参考上面的 6 篇文章。&lt;/p&gt;
&lt;p&gt;大家知道，在自定义 Spring Security 配置的时候，有这样几个属性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
            .anyRequest().authenticated()
            .formLogin()
            .loginProcessingUrl(&quot;/doLogin&quot;)
            .loginPage(&quot;/login&quot;)
            //其他配置
            .permitAll()
            .and()
            .csrf().disable();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有两个比较重要的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;loginProcessingUrl：这个表示配置处理登录请求的接口地址，例如你是表单登录，那么 form 表单中 action 的值就是这里填的值。&lt;/li&gt;
&lt;li&gt;loginPage：这个表示登录页的地址，例如当你访问一个需要登录后才能访问的资源时，系统就会自动给你通过重定向跳转到这个页面上来。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种配置在前后端不分的登录中是没有问题的，在前后端分离的登录中，这种配置就有问题了。我举个简单的例子，例如我想访问 &lt;code&gt;/hello&lt;/code&gt; 接口，但是这个接口需要登录之后才能访问，我现在没有登录就直接去访问这个接口了，那么系统会给我返回 302，让我去登录页面，在前后端分离中，我的后端一般是没有登录页面的，就是一个提示 JSON，例如下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(&quot;/login&quot;)
public RespBean login() {
    return RespBean.error(&quot;尚未登录，请登录!&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;完整代码大家可以参考我的微人事项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，当我没有登录直接去访问 &lt;code&gt;/hello&lt;/code&gt; 这个接口的时候，我会看到上面这段 JSON 字符串。在前后端分离开发中，这个看起来没问题（后端不再做页面跳转，无论发生什么都是返回 JSON）。但是问题就出在这里，系统默认的跳转是一个重定向，就是说当你访问 &lt;code&gt;/hello&lt;/code&gt; 的时候，服务端会给浏览器返回 302，同时响应头中有一个 Location 字段，它的值为 &lt;code&gt;http://localhost:8081/login&lt;/code&gt; ，也就是告诉浏览器你去访问 &lt;code&gt;http://localhost:8081/login&lt;/code&gt; 地址吧。浏览器收到指令之后，就会直接去访问 &lt;code&gt;http://localhost:8081/login&lt;/code&gt; 地址，如果此时是开发环境并且请求还是 Ajax 请求，就会发生跨域。因为前后端分离开发中，前端我们一般在 NodeJS 上启动，然后前端的所有请求通过 NodeJS 做请求转发，现在服务端直接把请求地址告诉浏览器了，浏览器就会直接去访问 &lt;code&gt;http://localhost:8081/login&lt;/code&gt; 了，而不会做请求转发了，因此就发生了跨域问题。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;很明显，上面的问题我们不能用跨域的思路来解决，虽然这种方式看起来也能解决问题，但不是最佳方案。&lt;/p&gt;
&lt;p&gt;如果我们的 Spring Security 在用户未获认证的时候去请求一个需要认证后才能请求的数据，此时不给用户重定向，而是直接就返回一个 JSON，告诉用户这个请求需要认证之后才能发起，就不会有上面的事情了。&lt;/p&gt;
&lt;p&gt;这里就涉及到 Spring Security 中的一个接口 &lt;code&gt;AuthenticationEntryPoint&lt;/code&gt; ，该接口有一个实现类：&lt;code&gt;LoginUrlAuthenticationEntryPoint&lt;/code&gt; ，该类中有一个方法 &lt;code&gt;commence&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Performs the redirect (or forward) to the login form URL.
 */
public void commence(HttpServletRequest request, HttpServletResponse response,
        AuthenticationException authException) {
    String redirectUrl = null;
    if (useForward) {
        if (forceHttps &amp;amp;&amp;amp; &quot;http&quot;.equals(request.getScheme())) {
            redirectUrl = buildHttpsRedirectUrlForRequest(request);
        }
        if (redirectUrl == null) {
            String loginForm = determineUrlToUseForThisRequest(request, response,
                    authException);
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Server side forward to: &quot; + loginForm);
            }
            RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);
            dispatcher.forward(request, response);
            return;
        }
    }
    else {
        redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);
    }
    redirectStrategy.sendRedirect(request, response, redirectUrl);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。&lt;/p&gt;
&lt;p&gt;那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
            .anyRequest().authenticated()
            .formLogin()
            .loginProcessingUrl(&quot;/doLogin&quot;)
            .loginPage(&quot;/login&quot;)
            //其他配置
            .permitAll()
            .and()
            .csrf().disable().exceptionHandling()
                .authenticationEntryPoint(new AuthenticationEntryPoint() {
            @Override
            public void commence(HttpServletRequest req, HttpServletResponse resp, AuthenticationException authException) throws IOException, ServletException {
                resp.setContentType(&quot;application/json;charset=utf-8&quot;);
                PrintWriter out = resp.getWriter();
                RespBean respBean = RespBean.error(&quot;访问失败!&quot;);
                if (authException instanceof InsufficientAuthenticationException) {
                    respBean.setMsg(&quot;请求失败，请联系管理员!&quot;);
                }
                out.write(new ObjectMapper().writeValueAsString(respBean));
                out.flush();
                out.close();
            }
        });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Spring Security 的配置中加上自定义的 &lt;code&gt;AuthenticationEntryPoint&lt;/code&gt; 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;好了，一个小小的重定向问题和小伙伴们分享下，不知道大家有没有看懂呢？这也是我最近在重构微人事的时候遇到的问题。预计 11 月份，微人事的 Spring Boot 版本会升级到目前最新版，请小伙伴们留意哦。&lt;/p&gt;
&lt;p&gt;关注公众号【江南一点雨】，专注于 Spring Boot+微服务以及前后端分离等全栈技术，定期视频教程分享，关注后回复 Java ，领取松哥为你精心准备的 Java 干货！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201910/747810-20191010082725344-216994086.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Oct 2019 00:28:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<og:description>hello 各位小伙伴，国庆节终于过完啦，松哥也回来啦，今天开始咱们继续发干货！ 关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用： 1. '手把手带你入门 Sp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lenve/p/11645640.html</dc:identifier>
</item>
<item>
<title>ElasticSearch实战系列三: ElasticSearch的JAVA API使用教程 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/11645630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/11645630.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一篇中介绍了&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/11567053.html&quot;&gt;ElasticSearch实战系列二: ElasticSearch的DSL语句使用教程---图文详解&lt;/a&gt;，本篇文章就来讲解下 ElasticSearch 6.x官方Java API的使用。&lt;/p&gt;
&lt;h2 id=&quot;elasticsearch-java-api&quot;&gt;ElasticSearch JAVA API&lt;/h2&gt;
&lt;p&gt;目前市面上有几种常见的ElasticSearch Java API架包，JestClient、SpringBoot整合的SpringData、Spring整合的ElasticsearchTemplate、Elasticsearch Bboss等一些开源架包，上述这些第三方整合的架包中，基本已经支持日常的使用，除了支持的ES版本会低一些而已。&lt;/p&gt;
&lt;p&gt;本文介绍的是ElasticSearch官方的&lt;code&gt;Java High Level REST Client&lt;/code&gt;的使用，&lt;code&gt;Java High Level REST Client&lt;/code&gt;是ElasticSearch官方目前推荐使用的，适用于6.x以上的版本，要求JDK在1.8以上，可以很好的在大版本中进行兼容，并且该架包自身也包含&lt;code&gt;Java Low Level REST Client&lt;/code&gt;中的方法，可以应对一些特需的情况进行特殊的处理， 它对于一些常用的方法封装Restful风格，可以直接对应操作名调用使用即可，支持同步和异步(Async)调用。&lt;/p&gt;
&lt;p&gt;这里我们的使用也可以直接对应上一篇文章中的DSL语句使用，这样的话可以非常方便的对照和学习使用。&lt;/p&gt;
&lt;p&gt;在对下述进行操作时，我们先来看下Elasticsearch &lt;code&gt;Java High Level REST Client&lt;/code&gt;的初始化连接写法吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(new HttpHost(elasticIp, elasticPort)));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很简单呢，关闭也很简单，client不为空直接close即可！&lt;/p&gt;
&lt;h3 id=&quot;一新增数据&quot;&gt;一、新增数据&lt;/h3&gt;
&lt;p&gt;ElasticSearch可以直接新增数据，只要你指定了index(索引库名称)和type(类型)即可。在新增的时候你可以自己指定主键ID，也可以不指定，由 ElasticSearch自身生成。Elasticsearch &lt;code&gt;Java High Level REST Client&lt;/code&gt;新增数据提供了三种方法，这里我们就来看一下这三种写法吧。&lt;/p&gt;
&lt;p&gt;新增数据代码示例一，通过jsonString进行创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    String index = &quot;test1&quot;;
    String type = &quot;_doc&quot;;
    // 唯一编号
    String id = &quot;1&quot;;
    IndexRequest request = new IndexRequest(index, type, id);

    String jsonString = &quot;{&quot; + &quot;\&quot;uid\&quot;:\&quot;1234\&quot;,&quot;+ &quot;\&quot;phone\&quot;:\&quot;12345678909\&quot;,&quot;+ &quot;\&quot;msgcode\&quot;:\&quot;1\&quot;,&quot; + &quot;\&quot;sendtime\&quot;:\&quot;2019-03-14 01:57:04\&quot;,&quot;
            + &quot;\&quot;message\&quot;:\&quot;xuwujing study Elasticsearch\&quot;&quot; + &quot;}&quot;;
    request.source(jsonString, XContentType.JSON);
    IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增数据代码示例二，通过map创建,会自动转换成json的数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    String index = &quot;test1&quot;;
    String type = &quot;_doc&quot;;
    // 唯一编号
    String id = &quot;1&quot;;
    IndexRequest request = new IndexRequest(index, type, id);
    Map&amp;lt;String, Object&amp;gt; jsonMap = new HashMap&amp;lt;&amp;gt;();
    jsonMap.put(&quot;uid&quot;, 1234);
    jsonMap.put(&quot;phone&quot;, 12345678909L);
    jsonMap.put(&quot;msgcode&quot;, 1);
    jsonMap.put(&quot;sendtime&quot;, &quot;2019-03-14 01:57:04&quot;);
    jsonMap.put(&quot;message&quot;, &quot;xuwujing study Elasticsearch&quot;);
    request.source(jsonMap);
    IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增数据代码示例三，通过XContentBuilder对象进行创建:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   String index = &quot;test1&quot;;
    String type = &quot;_doc&quot;;
    // 唯一编号
    String id = &quot;1&quot;;
    IndexRequest request = new IndexRequest(index, type, id);
    XContentBuilder builder = XContentFactory.jsonBuilder();
    builder.startObject();
    {
        builder.field(&quot;uid&quot;, 1234);
        builder.field(&quot;phone&quot;, 12345678909L);
        builder.field(&quot;msgcode&quot;, 1);
        builder.timeField(&quot;sendtime&quot;, &quot;2019-03-14 01:57:04&quot;);
        builder.field(&quot;message&quot;, &quot;xuwujing study Elasticsearch&quot;);
    }
    builder.endObject();
    request.source(builder);
    IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述三种方法中，个人推荐第二种，比较容易理解和使用。&lt;/p&gt;
&lt;h3 id=&quot;二创建索引库&quot;&gt;二、创建索引库&lt;/h3&gt;
&lt;p&gt;在上述示例中，我们通过直接通过创建数据从而创建了索引库，但是没有创建索引库而通过ES自身生成的这种并不友好，因为它会使用默认的配置，字段结构都是text(text的数据会分词，在存储的时候也会额外的占用空间)，分片和索引副本采用默认值，默认是5和1，ES的分片数在创建之后就不能修改，除非reindex，所以这里我们还是指定数据模板进行创建。&lt;br/&gt;使用JAVA API 创建索引库的方法和上述中新增数据的一样，有三种方式，不过这里就只介绍一种。&lt;/p&gt;
&lt;p&gt;新增索引库的代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void createIndex() throws IOException {
    String type = &quot;_doc&quot;;
    String index = &quot;test1&quot;;
    // setting 的值
    Map&amp;lt;String, Object&amp;gt; setmapping = new HashMap&amp;lt;&amp;gt;();
    // 分区数、副本数、缓存刷新时间
    setmapping.put(&quot;number_of_shards&quot;, 10);
    setmapping.put(&quot;number_of_replicas&quot;, 1);
    setmapping.put(&quot;refresh_interval&quot;, &quot;5s&quot;);
    Map&amp;lt;String, Object&amp;gt; keyword = new HashMap&amp;lt;&amp;gt;();
    //设置类型
    keyword.put(&quot;type&quot;, &quot;keyword&quot;);
    Map&amp;lt;String, Object&amp;gt; lon = new HashMap&amp;lt;&amp;gt;();
    //设置类型
    lon.put(&quot;type&quot;, &quot;long&quot;);
    Map&amp;lt;String, Object&amp;gt; date = new HashMap&amp;lt;&amp;gt;();
    //设置类型
    date.put(&quot;type&quot;, &quot;date&quot;);
    date.put(&quot;format&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;);

    Map&amp;lt;String, Object&amp;gt; jsonMap2 = new HashMap&amp;lt;&amp;gt;();
    Map&amp;lt;String, Object&amp;gt; properties = new HashMap&amp;lt;&amp;gt;();
    //设置字段message信息
    properties.put(&quot;uid&quot;, lon);
    properties.put(&quot;phone&quot;, lon);
    properties.put(&quot;msgcode&quot;, lon);
    properties.put(&quot;message&quot;, keyword);
    properties.put(&quot;sendtime&quot;, date);
    Map&amp;lt;String, Object&amp;gt; mapping = new HashMap&amp;lt;&amp;gt;();
    mapping.put(&quot;properties&quot;, properties);
    jsonMap2.put(type, mapping);

    GetIndexRequest getRequest = new GetIndexRequest();
    getRequest.indices(index);
    getRequest.local(false);
    getRequest.humanReadable(true);
    boolean exists2 = client.indices().exists(getRequest, RequestOptions.DEFAULT);
    //如果存在就不创建了
    if(exists2) {
        System.out.println(index+&quot;索引库已经存在!&quot;);
        return;
    }
    // 开始创建库
    CreateIndexRequest request = new CreateIndexRequest(index);
    try {
        // 加载数据类型
        request.settings(setmapping);
        //设置mapping参数
        request.mapping(type, jsonMap2);
        //设置别名
        request.alias(new Alias(&quot;pancm_alias&quot;));
        CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT);
        boolean falg = createIndexResponse.isAcknowledged();
        if(falg){
            System.out.println(&quot;创建索引库:&quot;+index+&quot;成功！&quot; );
        }
    } catch (IOException e) {
        e.printStackTrace();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：创建索引库的时候，一定要先判断索引库是否存在！！！&lt;/strong&gt;&lt;br/&gt;这里创建索引库的时候顺便也指定了别名（alias），这个别名是一个好东西，使用恰当可以提升查询性能，这里我们留着下次在讲。&lt;/p&gt;
&lt;h3 id=&quot;三修改数据&quot;&gt;三、修改数据&lt;/h3&gt;
&lt;p&gt;ES提供修改API的时候，有两种方式，一种是直接修改，但是若数据不存在会抛出异常，另一种则是存在更新，不存着就插入。相比第一种，第二种会更加好用一些，不过在写入速度上是不如第一种的。&lt;/p&gt;
&lt;p&gt;ES修改的代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void update() throws IOException {
    String type = &quot;_doc&quot;;
    String index = &quot;test1&quot;;
    // 唯一编号
    String id = &quot;1&quot;;
    UpdateRequest upateRequest = new UpdateRequest();
    upateRequest.id(id);
    upateRequest.index(index);
    upateRequest.type(type);

    // 依旧可以使用Map这种集合作为更新条件
    Map&amp;lt;String, Object&amp;gt; jsonMap = new HashMap&amp;lt;&amp;gt;();
    jsonMap.put(&quot;uid&quot;, 12345);
    jsonMap.put(&quot;phone&quot;, 123456789019L);
    jsonMap.put(&quot;msgcode&quot;, 2);
    jsonMap.put(&quot;sendtime&quot;, &quot;2019-03-14 01:57:04&quot;);
    jsonMap.put(&quot;message&quot;, &quot;xuwujing study Elasticsearch&quot;);
    upateRequest.doc(jsonMap);
    // upsert 方法表示如果数据不存在，那么就新增一条
    upateRequest.docAsUpsert(true);
    client.update(upateRequest, RequestOptions.DEFAULT);
    System.out.println(&quot;更新成功！&quot;);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注:upsert 方法表示如果数据不存在，那么就新增一条，默认是false。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;四删除数据&quot;&gt;四、删除数据&lt;/h3&gt;
&lt;p&gt;根据上述的几个操作，想必不用多说，已经知道了是DELETE方法了，那我们就直接开始吧。&lt;/p&gt;
&lt;p&gt;ES根据ID删除代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void delete() throws IOException {

    String type = &quot;_doc&quot;;
    String index = &quot;test1&quot;;
    // 唯一编号
    String id = &quot;1&quot;;
    DeleteRequest deleteRequest = new DeleteRequest();
    deleteRequest.id(id);
    deleteRequest.index(index);
    deleteRequest.type(type);
    // 设置超时时间
    deleteRequest.timeout(TimeValue.timeValueMinutes(2));
    // 设置刷新策略&quot;wait_for&quot;
    // 保持此请求打开，直到刷新使此请求的内容可以搜索为止。此刷新策略与高索引和搜索吞吐量兼容，但它会导致请求等待响应，直到发生刷新
    deleteRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL);
    // 同步删除
    DeleteResponse deleteResponse = client.delete(deleteRequest, RequestOptions.DEFAULT);
}       &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES根据条件进行删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   private static void deleteByQuery() throws IOException {
    String type = &quot;_doc&quot;;
    String index = &quot;test1&quot;;
    DeleteByQueryRequest request = new DeleteByQueryRequest(index,type);
    // 设置查询条件
    request.setQuery(QueryBuilders.termsQuery(&quot;uid&quot;,1234));
    // 同步执行
    BulkByScrollResponse bulkResponse = client.deleteByQuery(request, RequestOptions.DEFAULT);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试结果&quot;&gt;测试结果&lt;/h4&gt;
&lt;p&gt;示例图:&lt;/p&gt;
&lt;h3 id=&quot;查询语句&quot;&gt;查询语句&lt;/h3&gt;
&lt;p&gt;几个常用的查询API这里就简单的介绍下用法，然后再直接给出所有的查询语句代码。&lt;/p&gt;
&lt;h4 id=&quot;查询api&quot;&gt;查询API&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;等值（term查询：QueryBuilders.termQuery(name,value);&lt;/li&gt;
&lt;li&gt;多值(terms)查询:QueryBuilders.termsQuery(name,value,value2,value3...);&lt;/li&gt;
&lt;li&gt;范围（range)查询：QueryBuilders.rangeQuery(name).gte(value).lte(value);&lt;/li&gt;
&lt;li&gt;存在(exists)查询:QueryBuilders.existsQuery(name);&lt;/li&gt;
&lt;li&gt;模糊(wildcard)查询:QueryBuilders.wildcardQuery(name,&lt;em&gt;+value+&lt;/em&gt;);&lt;/li&gt;
&lt;li&gt;组合（bool）查询: BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder();&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查询所有代码示例&quot;&gt;查询所有代码示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt; private static void allSearch() throws IOException {
    SearchRequest searchRequestAll = new SearchRequest();
    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
    searchSourceBuilder.query(QueryBuilders.matchAllQuery());
    searchRequestAll.source(searchSourceBuilder);
    // 同步查询
    SearchResponse searchResponseAll = client.search(searchRequestAll, RequestOptions.DEFAULT);
    System.out.println(&quot;所有查询总数:&quot; + searchResponseAll.getHits().getTotalHits());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一般查询代码示例&quot;&gt;一般查询代码示例&lt;/h4&gt;
&lt;p&gt;其实就是等值查询，只不过在里面加入了分页、排序、超时、路由等等设置，并且在查询结果里面增加了一些处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   private static void genSearch() throws IOException {
    String type = &quot;_doc&quot;;
    String index = &quot;test1&quot;;
    // 查询指定的索引库
    SearchRequest searchRequest = new SearchRequest(index);
    searchRequest.types(type);
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    // 设置查询条件
    sourceBuilder.query(QueryBuilders.termQuery(&quot;uid&quot;, &quot;1234&quot;));
    // 设置起止和结束
    sourceBuilder.from(0);
    sourceBuilder.size(5);
    sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS));
    // 设置路由
//      searchRequest.routing(&quot;routing&quot;);
    // 设置索引库表达式
    searchRequest.indicesOptions(IndicesOptions.lenientExpandOpen());
    // 查询选择本地分片，默认是集群分片
    searchRequest.preference(&quot;_local&quot;);

    // 排序
    // 根据默认值进行降序排序
//  sourceBuilder.sort(new ScoreSortBuilder().order(SortOrder.DESC));
    // 根据字段进行升序排序
//  sourceBuilder.sort(new FieldSortBuilder(&quot;id&quot;).order(SortOrder.ASC));

    // 关闭suorce查询
//  sourceBuilder.fetchSource(false);

    String[] includeFields = new String[]{&quot;title&quot;, &quot;user&quot;, &quot;innerObject.*&quot;};
    String[] excludeFields = new String[]{&quot;_type&quot;};
    // 包含或排除字段
//  sourceBuilder.fetchSource(includeFields, excludeFields);

    searchRequest.source(sourceBuilder);
    System.out.println(&quot;普通查询的DSL语句:&quot;+sourceBuilder.toString());
    // 同步查询
    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);

    // HTTP状态代码、执行时间或请求是否提前终止或超时
    RestStatus status = searchResponse.status();
    TimeValue took = searchResponse.getTook();
    Boolean terminatedEarly = searchResponse.isTerminatedEarly();
    boolean timedOut = searchResponse.isTimedOut();

    // 供关于受搜索影响的切分总数的统计信息，以及成功和失败的切分
    int totalShards = searchResponse.getTotalShards();
    int successfulShards = searchResponse.getSuccessfulShards();
    int failedShards = searchResponse.getFailedShards();
    // 失败的原因
    for (ShardSearchFailure failure : searchResponse.getShardFailures()) {
        // failures should be handled here
    }
    // 结果
    searchResponse.getHits().forEach(hit -&amp;gt; {
        Map&amp;lt;String, Object&amp;gt; map = hit.getSourceAsMap();
        System.out.println(&quot;普通查询的结果:&quot; + map);
    });
    System.out.println(&quot;\n=================\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;或查询&quot;&gt;或查询&lt;/h4&gt;
&lt;p&gt;其实这个或查询也是bool查询中的一种，这里的查询语句相当于SQL语句中的&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT * FROM test1 where (uid = 1 or uid =2) and phone = 12345678919&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void orSearch() throws IOException {
    SearchRequest searchRequest = new SearchRequest();
    searchRequest.indices(&quot;test1&quot;);
    searchRequest.types(&quot;_doc&quot;);
    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
    BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder();
    BoolQueryBuilder boolQueryBuilder2 = new BoolQueryBuilder();
 
      /**
     *  SELECT * FROM test1 where (uid = 1234 or uid =12345)  and phone = 12345678909
     * */
    boolQueryBuilder2.should(QueryBuilders.termQuery(&quot;uid&quot;, 1234));
    boolQueryBuilder2.should(QueryBuilders.termQuery(&quot;uid&quot;, 12345));
    boolQueryBuilder.must(boolQueryBuilder2);
    boolQueryBuilder.must(QueryBuilders.termQuery(&quot;phone&quot;, &quot;12345678909&quot;));
    searchSourceBuilder.query(boolQueryBuilder);
    System.out.println(&quot;或查询语句:&quot; + searchSourceBuilder.toString());
    searchRequest.source(searchSourceBuilder);
    // 同步查询
    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);

    searchResponse.getHits().forEach(documentFields -&amp;gt; {

        System.out.println(&quot;查询结果:&quot; + documentFields.getSourceAsMap());
    });

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;模糊查询&quot;&gt;模糊查询&lt;/h4&gt;
&lt;p&gt;相当于SQL语句中的like查询。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void likeSearch() throws IOException {
    String type = &quot;_doc&quot;;
    String index = &quot;test1&quot;;
    SearchRequest searchRequest = new SearchRequest();
    searchRequest.indices(index);
    searchRequest.types(type);
    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
    BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder();

   /**
     *  SELECT * FROM p_test where  message like '%xu%';
     * */
    boolQueryBuilder.must(QueryBuilders.wildcardQuery(&quot;message&quot;, &quot;*xu*&quot;));
    searchSourceBuilder.query(boolQueryBuilder);
    System.out.println(&quot;模糊查询语句:&quot; + searchSourceBuilder.toString());
    searchRequest.source(searchSourceBuilder);
    // 同步查询
    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
    searchResponse.getHits().forEach(documentFields -&amp;gt; {
        System.out.println(&quot;模糊查询结果:&quot; + documentFields.getSourceAsMap());
    });
    System.out.println(&quot;\n=================\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多值查询&quot;&gt;多值查询&lt;/h4&gt;
&lt;p&gt;也就是相当于SQL语句中的in查询。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     private static void inSearch() throws IOException {
        String type = &quot;_doc&quot;;
        String index = &quot;test1&quot;;
        // 查询指定的索引库
        SearchRequest searchRequest = new SearchRequest(index,type);
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        /**
         *  SELECT * FROM p_test where uid in (1,2)
         * */
        // 设置查询条件
        sourceBuilder.query(QueryBuilders.termsQuery(&quot;uid&quot;, 1, 2));
        searchRequest.source(sourceBuilder);
        System.out.println(&quot;in查询的DSL语句:&quot;+sourceBuilder.toString());
        // 同步查询
        SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
        // 结果
        searchResponse.getHits().forEach(hit -&amp;gt; {
            Map&amp;lt;String, Object&amp;gt; map = hit.getSourceAsMap();
            String string = hit.getSourceAsString();
            System.out.println(&quot;in查询的Map结果:&quot; + map);
            System.out.println(&quot;in查询的String结果:&quot; + string);
        });

        System.out.println(&quot;\n=================\n&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;存在查询&quot;&gt;存在查询&lt;/h4&gt;
&lt;p&gt;判断是否存在该字段，用法和SQL语句中的exist类似。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private static void existSearch() throws IOException {
    String type = &quot;_doc&quot;;
    String index = &quot;test1&quot;;
    // 查询指定的索引库
    SearchRequest searchRequest = new SearchRequest(index);
    searchRequest.types(type);
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();

    // 设置查询条件
     sourceBuilder.query(QueryBuilders.existsQuery(&quot;msgcode&quot;));
    searchRequest.source(sourceBuilder);
    System.out.println(&quot;存在查询的DSL语句:&quot;+sourceBuilder.toString());
    // 同步查询
    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
    // 结果
    searchResponse.getHits().forEach(hit -&amp;gt; {
        Map&amp;lt;String, Object&amp;gt; map = hit.getSourceAsMap();
        String string = hit.getSourceAsString();
        System.out.println(&quot;存在查询的Map结果:&quot; + map);
        System.out.println(&quot;存在查询的String结果:&quot; + string);
    });
    System.out.println(&quot;\n=================\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;范围查询&quot;&gt;范围查询&lt;/h4&gt;
&lt;p&gt;和SQL语句中&amp;lt;&amp;gt;使用方法一样,其中gt是大于，lt是小于，gte是大于等于，lte是小于等于。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void rangeSearch() throws IOException{
    String type = &quot;_doc&quot;;
    String index = &quot;test1&quot;;
    SearchRequest searchRequest = new SearchRequest(index);
    searchRequest.types(type);
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();

    // 设置查询条件
    sourceBuilder.query(QueryBuilders.rangeQuery(&quot;sendtime&quot;).gte(&quot;2019-01-01 00:00:00&quot;).lte(&quot;2019-12-31 23:59:59&quot;));
    searchRequest.source(sourceBuilder);
     System.out.println(&quot;范围查询的DSL语句:&quot;+sourceBuilder.toString());
    // 同步查询
    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
    // 结果
    searchResponse.getHits().forEach(hit -&amp;gt; {
        String string = hit.getSourceAsString();
        System.out.println(&quot;范围查询的String结果:&quot; + string);
    });
    System.out.println(&quot;\n=================\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;正则查询&quot;&gt;正则查询&lt;/h4&gt;
&lt;p&gt;ES可以使用正则进行查询，查询方式也非常的简单，代码示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private static void regexpSearch() throws IOException{
    String type = &quot;_doc&quot;;
    String index = &quot;test1&quot;;
    // 查询指定的索引库
    SearchRequest searchRequest = new SearchRequest(index);
    searchRequest.types(type);
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    // 设置查询条件
    sourceBuilder.query(QueryBuilders.regexpQuery(&quot;message&quot;,&quot;xu[0-9]&quot;));
    searchRequest.source(sourceBuilder);
     System.out.println(&quot;正则查询的DSL语句:&quot;+sourceBuilder.toString());
    // 同步查询
    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
    // 结果
    searchResponse.getHits().forEach(hit -&amp;gt; {
        Map&amp;lt;String, Object&amp;gt; map = hit.getSourceAsMap();
        String string = hit.getSourceAsString();
        System.out.println(&quot;正则查询的Map结果:&quot; + map);
        System.out.println(&quot;正则查询的String结果:&quot; + string);
    });

    System.out.println(&quot;\n=================\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查询测试结果&quot;&gt;查询测试结果&lt;/h4&gt;
&lt;blockquote readability=&quot;113&quot;&gt;
&lt;p&gt;所有查询总数:6&lt;br/&gt;普通查询的DSL语句:{&quot;from&quot;:0,&quot;size&quot;:5,&quot;timeout&quot;:&quot;60s&quot;,&quot;query&quot;:{&quot;term&quot;:{&quot;uid&quot;:{&quot;value&quot;:&quot;1234&quot;,&quot;boost&quot;:1.0}}}}&lt;/p&gt;
&lt;p&gt;=================&lt;/p&gt;
&lt;p&gt;或查询语句:{&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;bool&quot;:{&quot;should&quot;:[{&quot;term&quot;:{&quot;uid&quot;:{&quot;value&quot;:1234,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;uid&quot;:{&quot;value&quot;:12345,&quot;boost&quot;:1.0}}}],&quot;adjust_pure_negative&quot;:true,&quot;boost&quot;:1.0}},{&quot;term&quot;:{&quot;phone&quot;:{&quot;value&quot;:&quot;12345678909&quot;,&quot;boost&quot;:1.0}}}],&quot;adjust_pure_negative&quot;:true,&quot;boost&quot;:1.0}}}&lt;br/&gt;或查询结果:{msgcode=1, uid=12345, phone=12345678909, message=qq, sendtime=2019-03-14 01:57:04}&lt;/p&gt;
&lt;p&gt;=================&lt;/p&gt;
&lt;p&gt;模糊查询语句:{&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;wildcard&quot;:{&quot;message&quot;:{&quot;wildcard&quot;:&quot;&lt;em&gt;xu&lt;/em&gt;&quot;,&quot;boost&quot;:1.0}}}],&quot;adjust_pure_negative&quot;:true,&quot;boost&quot;:1.0}}}&lt;br/&gt;模糊查询结果:{msgcode=2, uid=12345, phone=123456789019, sendtime=2019-03-14 01:57:04, message=xuwujing study Elasticsearch}&lt;br/&gt;模糊查询结果:{uid=123456, phone=12345678909, message=xu1, sendtime=2019-03-14 01:57:04}&lt;/p&gt;
&lt;p&gt;=================&lt;/p&gt;
&lt;p&gt;存在查询的DSL语句:{&quot;query&quot;:{&quot;exists&quot;:{&quot;field&quot;:&quot;msgcode&quot;,&quot;boost&quot;:1.0}}}&lt;br/&gt;存在查询的Map结果:{msgcode=2, uid=12345, phone=123456789019, sendtime=2019-03-14 01:57:04, message=xuwujing study Elasticsearch}&lt;br/&gt;存在查询的String结果:{&quot;uid&quot;:12345,&quot;phone&quot;:123456789019,&quot;msgcode&quot;:2,&quot;sendtime&quot;:&quot;2019-03-14 01:57:04&quot;,&quot;message&quot;:&quot;xuwujing study Elasticsearch&quot;}&lt;br/&gt;存在查询的Map结果:{msgcode=1, uid=12345, phone=12345678909, message=qq, sendtime=2019-03-14 01:57:04}&lt;br/&gt;存在查询的String结果:{&quot;uid&quot;:&quot;12345&quot;,&quot;phone&quot;:&quot;12345678909&quot;,&quot;message&quot;:&quot;qq&quot;,&quot;msgcode&quot;:&quot;1&quot;,&quot;sendtime&quot;:&quot;2019-03-14 01:57:04&quot;}&lt;/p&gt;
&lt;p&gt;=================&lt;/p&gt;
&lt;p&gt;范围查询的DSL语句:{&quot;query&quot;:{&quot;range&quot;:{&quot;sendtime&quot;:{&quot;from&quot;:&quot;2019-01-01 00:00:00&quot;,&quot;to&quot;:&quot;2019-12-31 23:59:59&quot;,&quot;include_lower&quot;:true,&quot;include_upper&quot;:true,&quot;boost&quot;:1.0}}}}&lt;br/&gt;范围查询的String结果:{&quot;uid&quot;:12345,&quot;phone&quot;:123456789019,&quot;msgcode&quot;:2,&quot;sendtime&quot;:&quot;2019-03-14 01:57:04&quot;,&quot;message&quot;:&quot;xuwujing study Elasticsearch&quot;}&lt;br/&gt;范围查询的String结果:{&quot;uid&quot;:&quot;123456&quot;,&quot;phone&quot;:&quot;12345678909&quot;,&quot;message&quot;:&quot;xu1&quot;,&quot;sendtime&quot;:&quot;2019-03-14 01:57:04&quot;}&lt;br/&gt;范围查询的String结果:{&quot;uid&quot;:&quot;12345&quot;,&quot;phone&quot;:&quot;12345678909&quot;,&quot;message&quot;:&quot;qq&quot;,&quot;msgcode&quot;:&quot;1&quot;,&quot;sendtime&quot;:&quot;2019-03-14 01:57:04&quot;}&lt;/p&gt;
&lt;p&gt;=================&lt;/p&gt;
&lt;p&gt;正则查询的DSL语句:{&quot;query&quot;:{&quot;regexp&quot;:{&quot;message&quot;:{&quot;value&quot;:&quot;xu[0-9]&quot;,&quot;flags_value&quot;:65535,&quot;max_determinized_states&quot;:10000,&quot;boost&quot;:1.0}}}}&lt;br/&gt;正则查询的Map结果:{uid=123456, phone=12345678909, message=xu1, sendtime=2019-03-14 01:57:04}&lt;br/&gt;正则查询的String结果:{&quot;uid&quot;:&quot;123456&quot;,&quot;phone&quot;:&quot;12345678909&quot;,&quot;message&quot;:&quot;xu1&quot;,&quot;sendtime&quot;:&quot;2019-03-14 01:57:04&quot;}&lt;/p&gt;
&lt;p&gt;=================&lt;/p&gt;
&lt;p&gt;组合查询的DSL语句:{&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;term&quot;:{&quot;uid&quot;:{&quot;value&quot;:12345,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;msgcode&quot;:{&quot;value&quot;:1,&quot;boost&quot;:1.0}}}],&quot;adjust_pure_negative&quot;:true,&quot;boost&quot;:1.0}}}&lt;br/&gt;组合查询的String结果:{&quot;uid&quot;:&quot;12345&quot;,&quot;phone&quot;:&quot;12345678909&quot;,&quot;message&quot;:&quot;qq&quot;,&quot;msgcode&quot;:&quot;1&quot;,&quot;sendtime&quot;:&quot;2019-03-14 01:57:04&quot;}&lt;/p&gt;
&lt;p&gt;=================&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;参考ES官方文档：&lt;br/&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html&quot; class=&quot;uri&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于SpringBoot集成ElasticSearch和JestClient的使用可以查看这篇文章：&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/8998168.html&quot;&gt;SpringBoot整合ElasticSearch实现多版本的兼容&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于ElasticSearch Java API的选择，如果ElasticSearch版本在6.x以前的话，推荐使用JestClient。如果是6.x之后并且有意升级到7.x的话，那么直接使用ES官方的&lt;code&gt;Java High Level REST Client&lt;/code&gt;，因为在7.x之后将直接会舍弃&lt;code&gt;Transport client&lt;/code&gt;的连接方式，目前Spring和SpringBoot集成的ES就是使用该方式(不知后续是否会做调整)。&lt;/p&gt;
&lt;p&gt;本篇文章的代码已收录在本人的&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;java-study&lt;/a&gt;项目中，若有兴趣，欢迎star、fork和issues。&lt;br/&gt;项目地址:&lt;a href=&quot;https://github.com/xuwujing/java-study&quot; class=&quot;uri&quot;&gt;https://github.com/xuwujing/java-study&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xuwujing/tag/elasticsearch/&quot;&gt;ElasticSearch实战系列&lt;/a&gt;:&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/11385255.html&quot;&gt;ElasticSearch实战系列一: ElasticSearch集群+Kinaba安装教程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/11567053.html&quot;&gt;ElasticSearch实战系列二: ElasticSearch的DSL语句使用教程---图文详解&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　　　　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot; class=&quot;uri&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Oct 2019 00:21:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在上一篇中介绍了 'ElasticSearch实战系列二: ElasticSearch的DSL语句使用教程 图文详解' ，本篇文章就来讲解下 ElasticSearch 6.x官方Java AP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuwujing/p/11645630.html</dc:identifier>
</item>
<item>
<title>品Spring：真没想到，三十步才能完成一个bean实例的创建 - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/taste-spring-016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/taste-spring-016.html</guid>
<description>&lt;p&gt;&lt;span&gt;在容器启动快完成时，会把所有的单例bean进行实例化，也可以叫做预先实例化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样做的好处之一是，可以及早地发现问题，及早的抛出异常，及早地解决掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文就来看下整个的实例化过程。其实还是比较繁琐的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;、从容器中找出所有的bean定义名称&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为不知道谁是单例bean，所以只能先全部找出来。如下图01：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214712266-123915212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;二&lt;/span&gt;&lt;span&gt;、循环遍历所有的bean名称，检查是否符合条件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先要合并bean定义，因为bean定义可以有父子关系，类似继承。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后这个合并后的bean定义必须是，非抽象的，单例的，非延迟初始化的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么它就满足条件，如下图02：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214735344-1288678625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;三&lt;/span&gt;&lt;span&gt;、判断是否为FactoryBean&amp;lt;?&amp;gt;类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果不是的话，说明该beanName对应一个普通的bean，可以直接实例化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是的话，说明该beanName对应的是一个工厂，这个工厂本身是单例的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是它里面生产的bean不一定是单例的。即使是的话，还要判断是否要积极的去初始化工厂里的bean。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体的判断如下图03：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214745281-1417137866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;编程新说&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;注：提到FactoryBean&amp;lt;?&amp;gt;类型，是否想起&amp;amp;符号的作用呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;四&lt;/span&gt;&lt;span&gt;、开始进入众所熟知的getBean(String name)方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在上一图中可以看到Spring对bean的实例化时竟然是调用的getBean(..)方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样共用一套代码，简单省事。不仅如此，当获取一个bean的依赖时，也可以用该方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样getBean(..)就是一个综合方法，没有bean实例就生成，有的话就直接返回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图04：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214756177-1680884642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;五&lt;/span&gt;&lt;span&gt;、对手工直接注册的单例对象进行检测&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;bean实例除了可以用bean定义生成外，还可以由开发人员直接注册一个bean实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样在使用bean定义生成实例前，先使用beanName去手动注册的bean实例集合中找一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图05：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214804092-1262703399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;如果找到了，就不用生成了，否则就会根据bean定义生成bean实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;六&lt;/span&gt;&lt;span&gt;、对FactoryBean&amp;lt;?&amp;gt;类型的检测&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这和上面提到的是一个类型，它是一个工厂，可以认为是包裹在了实际bean实例的外面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样可以有一些特殊的作用，不好之处就是每次都要检测下，然后从它内部拿出实际的bean实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体检测过程不再展开，如下图06：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214816353-434122598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;七&lt;/span&gt;&lt;span&gt;、对类型进行转换，如果有必要的话&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面我们仅仅是用beanName去手动注册的实例集合中寻找，万一这个手动注册的实例类型和bean定义要求的不兼容呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此要进行类型检测与转换，实在不行就抛异常，如下图07：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214831166-2063246695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;如果成功的话，就表明手动注册的bean定义实例满足要求，将它返回即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;注：如果在第五步没有找到beanName对应的手动注册的bean实例，那开始根据bean定义来生成bean实例。继续往下看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;八&lt;/span&gt;&lt;span&gt;、准备好显式指定的依赖，如@DependsOn指定的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先获取合并后的bean定义，然后从中读出显式指定的依赖，并逐个处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用registerDependentBean(..)将依赖关系写入容器，由容器维护。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并同样使用getBean(..)方法实例化这些依赖，一模一样的套路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实就是递归，如下图08：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214842271-1039868875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;编程新说&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;注：接下来使用createBean(..)方法正式开始创建bean&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;九&lt;/span&gt;&lt;span&gt;、解析出bean的Class&amp;lt;?&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为在注册bean定义时并不一定加载类，可能只是一个字符串的类名称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以要根据类名称去加载类，并得到类的Class&amp;lt;?&amp;gt;。如下图09：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214853659-325022520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;十&lt;/span&gt;&lt;span&gt;、调用bean后处理器的postProcessBeforeInstantiation方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时还处在实例化之前，让用户有机会来提供一个bean实例或代理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样Spring就不再进行后续的实例化步骤，直接返回这个用户提供的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果用户没有提供的话，Spring继续后续的处理。如下图1011：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214908832-869863644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214914696-42670448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;十一&lt;/span&gt;&lt;span&gt;、调用InstanceSupplier生成bean实例，如果有的话&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在注册bean定义时，可以设置一个Supplier&amp;lt;?&amp;gt;类型的函数式接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实就是用户可以提供一段创建bean实例的代码，这样Spring就使用它来创建bean实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后将这个实例返回即可，如下图12：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214937191-744265558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;十二&lt;/span&gt;&lt;span&gt;、通过FactoryMethod来生成bean实例，如果FactoryMethodName不为null的话&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图13：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925214956853-2022143678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;FactoryMethod就是工厂方法，说明bean的实例是通过调用这个工厂方法返回的，而不是通过反射调用构造函数返回的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工厂方法有两种，静态的和实例的。&lt;/span&gt;&lt;span&gt;如果是实例的，那还要有一个FactoryBeanName来指定一个bean名称，根据它可以从容器中获取一个对象，用作工厂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是静态的，那就不需要实例了，直接把bean定义中的类型作为工厂类即可。&lt;/span&gt;&lt;span&gt;如下图14：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215003259-770350731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;然后根据工厂方法的名称，从bean定义中解析出对应的Method对象。&lt;/span&gt;&lt;span&gt;然后再解析出构造方法参数用作工厂方法的参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终通过反射调用这个工厂方法，获取返回值，就是bean实例了，如下图15：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215010652-1980837142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;这个bean实例会用一个BeanWrapper接口进行包装，这个接口提供一些基础的JavaBean功能，如数据的类型转换然后再进行属性绑定等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十三&lt;/span&gt;&lt;span&gt;、调用bean后处理器的determineCandidateConstructors方法来确定候选构造方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图16：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215020911-79530446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;这里涉及到从多个候选构造方法中选出一个最合适的，是一个比较复杂的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后也是通过反射调用构造方法，获取到bean的实例。&lt;/span&gt;&lt;span&gt;如下图17：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215036964-399122788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;然后也用BeanWrapper接口进行包装。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十四&lt;/span&gt;&lt;span&gt;、使用更适合的构造方法来实例化，如果有的话&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果上一步没有执行的话，则使用bean定义中更适合的构造方法，如下图18：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215049649-1271553808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;十五&lt;/span&gt;&lt;span&gt;、使用默认无参的构造方法来实例化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果上一步没有执行的话，则使用默认无参构造方法，如下图19：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215055901-2120897833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;编程新说&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;注：至此bean实例已经创建好了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十六&lt;/span&gt;&lt;span&gt;、应用bean后处理器的postProcessMergedBeanDefinition方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上两篇文章详细介绍了bean后处理器，主要是用来实现注解的功能的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图2021：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215109989-1061830258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215122475-520085082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;十七&lt;/span&gt;&lt;span&gt;、此时就可以暴露早期的bean引用了，如果需要的话&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如允许循环引用的话，就需要这个操作，如下图22：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215130757-632685749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;十八&lt;/span&gt;&lt;span&gt;、应用bean后处理器的postProcessAfterInstantiation方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图23：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215138111-1612167220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;且该方法如果返回false，该bean实例后续的bean后处理器操作将不再执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十九&lt;/span&gt;&lt;span&gt;、根据设置的自动装配类型处理自动装配问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图24：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215201026-1061480420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;如果配置的是按名称自动装配，则会把所有setter方法中参数类型是非基本类型的都找出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后按照属性名称从容器中找出同名的bean，作为属性值保存起来以备后用。&lt;/span&gt;&lt;span&gt;如下图25：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215216532-1183088191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;如果配置的是按类型自动装配，则会把所有setter方法中参数类型是非基本类型的都找出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后按照属性类型从容器中解析出对应的bean，作为属性值保存起来以备后用。&lt;/span&gt;&lt;span&gt;如下图26：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215235783-1214966229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;如果看了上两篇文章，会发现这里按类型从容器中解析bean的套路和上两篇一模一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上的setter方法上不需要标任何注解，因为显式设置了自动装配类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而默认情况其实是没有设置的，即AUTOWIRE_NO，所以我们要标上@Autowired注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二十&lt;/span&gt;&lt;span&gt;、应用bean后处理器的postProcessProperties方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这一步其实是完成了依赖的注入，如下图27：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215244161-1509757723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;二十一&lt;/span&gt;&lt;span&gt;、其余属性值到bean属性的绑定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一步是由BeanWrapper这个接口完成的，如下图28：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215251092-1897717621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;编程新说&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;注：至此bean的所有依赖装配和属性设置都已完毕。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二十二&lt;/span&gt;&lt;span&gt;、应用bean后处理器的postProcessBeforeInitialization方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一步就开始执行初始化方法了。如下图2930:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215315663-624217446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215328088-349165502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;二十三&lt;/span&gt;&lt;span&gt;、执行bean的初始化方法afterPropertiesSet()&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果bean实现了InitializingBean接口，此刻会调用它唯一的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图31：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215340062-1063759638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;二十四&lt;/span&gt;&lt;span&gt;、执行bean定义中指定的初始化方法initMethod&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果bean定义是使用@Bean注册的，可以通过设置注解属性指定初始化方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图32：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215348187-1677881420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;编程新说&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前文章中写过，有三种方式可以指定初始化方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）@PostConstruct注解，2）InitializingBean接口，3）@Bean注解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里有两个问题需要记住：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）如果两种或三种方式都指向了同一个方法，这个方法也只会被执行一次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）三种方式指定的初始化方法的执行顺序就按刚刚列出的1、2、3这个顺序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二十五&lt;/span&gt;&lt;span&gt;、应用bean后处理器的postProcessAfterInitialization方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图3334：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215356593-158879869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215402712-320501333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;编程新说&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;注：至此bean的初始化工作已经完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二十六&lt;/span&gt;&lt;span&gt;、注册bean销毁时要执行的代码，如果需要的话&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了使用了之前说过的三种方式指定过销毁发方法之外，如果bean实现了AutoCloseable接口也算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果使用@Bean注册且没有指定销毁方法，那么默认把close和shutdown方法作为销毁方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些情况都是需要注册的，如下图35：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215418179-2079273281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;编程新说&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;注：至此bean实例本身已经准好了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二十七&lt;/span&gt;&lt;span&gt;、缓存单例的bean&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果这个bean是单例的，而且是新创建的，会把它缓存到容器里，以备后用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图36：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215426786-1586964252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;二十八&lt;/span&gt;&lt;span&gt;、进行Scope处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果一个bean指定了Scope，即它的生命周期既非单例也非原型而是属于某一个范围。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring暂时支持的范围如下图37：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925215435240-1536387459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;实现原理其实很简单，比如Session范围，那就先从Session中获取，没有的话生成一个放入Session中即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二十九&lt;/span&gt;&lt;span&gt;、对FactoryBean&amp;lt;?&amp;gt;类型的检测与处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚刚创建的这个bean可能是FactoryBean&amp;lt;?&amp;gt;类型，即一个工厂。而我们想要的可能是工厂里生成的bean。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单来说，那就从工厂中把bean拿出来即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三十&lt;/span&gt;&lt;span&gt;、类型的检测与转换&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终得到的bean实例可能与期望的类型不兼容，此时就要进行类型转换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转换成功的话就返回，失败的话就抛出类型不匹配异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此一个bean的创建工作已经全部结束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体流程步骤就是这样，只是忽略了一些和流程无关的细节实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结与感谢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;耗时近三个月，看了很多Spring的源码，写了16篇《品Spring》系列文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从bean定义是什么入手，到现在bean实例已经创建好且可用了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也算是一个阶段性的闭环和里程碑了。感谢每次都点开公众号的读者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;希望都能学到一些知识，也欢迎持续关注本号后续文章。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 品Spring系列文章 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484229&amp;amp;idx=1&amp;amp;sn=b552914c42963d06306d35f1d8332284&amp;amp;chksm=fc3338b5cb44b1a39d0762b2fd94d8870fcbc520b0713964d9a453d8466d781897707de8cd8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean定义上梁山&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=d500b3ed748331687028b78d567222a8&amp;amp;chksm=fc3338a4cb44b1b23f5dd9bef1cc66950a1ded23151a05b38716f4ec46ff960cdda5d8022e8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：实现bean定义时采用的“先进生产力”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484249&amp;amp;idx=1&amp;amp;sn=dfbdca65a2b64b0ac951f90b301e73a0&amp;amp;chksm=fc3338a9cb44b1bfafee072597430dae91d4dd8b4787e4af0896f9ce45b258fd5d3634169a5d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解终于“成功上位”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484259&amp;amp;idx=1&amp;amp;sn=791a5726b9b7bf41e4e64053cfbc7ffa&amp;amp;chksm=fc333893cb44b1851d2052423392551ca9188c4fc0a33f412ddda13af9e0dc6655966a668964&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：能工巧匠们对注解的“加持”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484301&amp;amp;idx=1&amp;amp;sn=a5557c4c285cb07a052238d3de2a2585&amp;amp;chksm=fc33387dcb44b16b487edee0ab4c755de394d19dd4a0acd2532af0e49e95eb7988628e93157b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot和Spring到底有没有本质的不同？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484319&amp;amp;idx=1&amp;amp;sn=89d925e6128109444c2ec40111a9f217&amp;amp;chksm=fc33386fcb44b179dcee6ef522e2252420658c0342759a9d6d9795bf90b144f6284c72fe808d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：负责bean定义注册的两个“排头兵”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484337&amp;amp;idx=1&amp;amp;sn=398a1f718cc8b5a711ba9f45a6d9074b&amp;amp;chksm=fc333841cb44b157da33d685daedda001cb59abb64aa6152c3d4096d43c8d92bff8ae5d084ed&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot轻松取胜bean定义注册的“第一阶段”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484358&amp;amp;idx=1&amp;amp;sn=21fc717c7815ae41103e3e2e4f5520df&amp;amp;chksm=fc333836cb44b120fd9073b6075580109d5665afbd0f50abe43e8a5aea42e066c759dcdb8157&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot发起bean定义注册的“二次攻坚战”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484369&amp;amp;idx=1&amp;amp;sn=ac9d591014074f49a96bc9f3ed7cca4a&amp;amp;chksm=fc333821cb44b137f3c0c7c24b88fc5b3edfa0dc530366b884a3813759ae6fb32c1974e506de&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解之王@Configuration和它的一众“小弟们”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484403&amp;amp;idx=1&amp;amp;sn=f10760d51119f91b5c18d3267ebbd1eb&amp;amp;chksm=fc333803cb44b115a6fcab3e264233514f90fd8874f038361aaa174e8c73bb7f2a31d96f9099&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean工厂后处理器的调用规则&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484414&amp;amp;idx=1&amp;amp;sn=16391934efdc318c65251d311a6cc61c&amp;amp;chksm=fc33380ecb44b1183af1d82647996fb5ec24a3cc977b028671cb62f91edcc421542e92ecbe92&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：详细解说bean后处理器&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484431&amp;amp;idx=1&amp;amp;sn=29a6cc3aa9959c04512864ee59365f6b&amp;amp;chksm=fc333fffcb44b6e9cce30ca85ee1c8a32fd5e5597cd27d45a1c1a6bc3bd59b004df3cc66ea22&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@PostConstruct和@PreDestroy注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484448&amp;amp;idx=1&amp;amp;sn=dc0e6d9b0ddd8168d749b90069999c03&amp;amp;chksm=fc333fd0cb44b6c68127c6a1e8b9c91891ef4ee37df40e7c85d2b67bd058d3c59e5e51d06101&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@Resource注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484462&amp;amp;idx=1&amp;amp;sn=d492ff48764329f37abd452b0b4e1287&amp;amp;chksm=fc333fdecb44b6c8b6634ac340a63c9271d22a08e53d3adaeef5e487658a425122b45f84fd20&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@Autowired和@Value注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 热门文章集锦 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484219&amp;amp;idx=1&amp;amp;sn=e6c39138e44ce8f0c91aba4873fb42cd&amp;amp;chksm=fc3338cbcb44b1dde7ae372ed66b40bdf4f755d711008810eb837a8f78d884f00956ae7ce7a7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;毕业10年，我有话说&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483949&amp;amp;idx=1&amp;amp;sn=200c9ac4f8e4e877b0b253d45205712a&amp;amp;chksm=fc3339ddcb44b0cb5ac2957dbed41b2f9e11fbba14967d00f97012806a9d6af364b0f8135eee&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何面试别人List相关知识的，深度有点长文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483989&amp;amp;idx=1&amp;amp;sn=cf9ce5c3f7981c16b71047b868b1c1ab&amp;amp;chksm=fc3339a5cb44b0b3df524ce684e8cd76ab6d15a2ccf26ec2425ecbcdd26bc777b95a06994189&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;我是如何在毕业不久只用1年就升为开发组长的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483994&amp;amp;idx=1&amp;amp;sn=fb09e943331e89abcb99d8304ea6b677&amp;amp;chksm=fc3339aacb44b0bc2a120c79efebb46a43ce5b4d3148992d86b2841a89bb46bf5d8863e065ea&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;爸爸又给Spring MVC生了个弟弟叫Spring WebFlux&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484017&amp;amp;idx=1&amp;amp;sn=a2055640b142fc4cfa5a9901d22ec57f&amp;amp;chksm=fc333981cb44b09782c196da25dc613b38a9ede52de073bfaaaef6214a9deb294b6527091892&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Spring事务时“套路”对方的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484029&amp;amp;idx=1&amp;amp;sn=44b05473af37fe008bb9659a35d1a9de&amp;amp;chksm=fc33398dcb44b09bbd25a7e14e7100419988479fbeb4bda7787f1b93dd932ec699dfd793df04&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】Spring事务面试考点吐血整理（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484158&amp;amp;idx=1&amp;amp;sn=1ca952ba9166c5ccf0e3f40622335fc5&amp;amp;chksm=fc33390ecb44b01898bb2500ba61a15e38487a23f5c0405d738cc4c272cd705d2dbbf1a3f8e7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Redis相关知识时“软怼”他的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484164&amp;amp;idx=1&amp;amp;sn=390d911b19812d22aebd3f0f6522004c&amp;amp;chksm=fc3338f4cb44b1e20bc2344474586934a2b148f92eefdaecf134d57af10f64310579e196904a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】吃透了这些Redis知识点，面试官一定觉得你很NB（干货 | 建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484184&amp;amp;idx=1&amp;amp;sn=37007efde0cc93e48c55a133dc9cc8d4&amp;amp;chksm=fc3338e8cb44b1fea0ed4af7f01de658e8a1bc7f573cb5bde2701d9b09ba14747139d2bcea39&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484195&amp;amp;idx=1&amp;amp;sn=95c3acdaeb0f6a1d61f152550c3d2669&amp;amp;chksm=fc3338d3cb44b1c55f6046f6280da863d3514cca3ce50ef29e2d53b0eafe2b7efef062c51c27&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484201&amp;amp;idx=1&amp;amp;sn=7cf45aff64eecdff58d2acea8fb7c9fa&amp;amp;chksm=fc3338d9cb44b1cfc6b5c797a005c91ed19b0dd06587fdfb2e7b553e2b03104a145380a7a990&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】一篇文章帮你彻底搞清楚“I/O多路复用”和“异步I/O”的前世今生（深度好文，建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484206&amp;amp;idx=1&amp;amp;sn=9547fdad111ac1a8ac9311cb9e76b9dc&amp;amp;chksm=fc3338decb44b1c89aee789e80e32989ea43232321397cc265c99b1d0ce4057e6563bc00a3d3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484214&amp;amp;idx=1&amp;amp;sn=0f677e8b0d61b5a5317a274cc8b33cbc&amp;amp;chksm=fc3338c6cb44b1d06aa20533aafb0b7b709b3bd88dbf6af6b8f3cb91288e4afc585ecb77489a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java多线程通关———基础知识挑战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号和知识星球的二维码，欢迎关注！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419093441100-1622885471.jpg&quot; alt=&quot;&quot;/&gt;      &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419132131137-250931220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 10 Oct 2019 00:21:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>在容器启动快完成时，会把所有的单例bean进行实例化，也可以叫做预先实例化。这样做的好处之一是，可以及早地发现问题，及早的抛出异常，及早地解决掉。本文就来看下整个的实例化过程。其实还是比较繁琐的。一、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/taste-spring-016.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [中篇] - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-01-02.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-01-02.html</guid>
<description>&lt;p&gt;我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;上篇&lt;/a&gt;》利用dotnet new命令创建了一个简单的控制台程序，接下来我们将它改造成一个ASP.NET Core应用。一个ASP.NET Core应用构建在ASP.NET Core框架之上，ASP.NET Core框架利用一个消息处理管道完成对HTTP请求的监听、接收、处理和最终的响应。ASP.NET Core管道由一个服务器（Server）和若干中间件（Middleware）构成，当宿主（Host）程序启动之后，管道被构建出来，作为管道“龙头”的服务器开始监听来自客户端的HTTP请求。&lt;/p&gt;

&lt;p&gt;接下来我们直接利用Visual Studio 打开前面这个helloworld.csproj项目文件。为了能够使用ASP.NET Core 框架提供的程序集，我们可以通过修改项目文件（.csproj）添加针对“&lt;strong&gt;Microsoft.AspNetCore.App&lt;/strong&gt;”的框架引用（FrameworkReference）。在Visual Studio中修改项目文件非常方便，我们只需要右键选择目标项目，并从弹出的菜单中选择“&lt;strong&gt;Edit Project File&lt;/strong&gt;”就可以了。如下所示的是修改后的项目文件，针对“Microsoft.AspNetCore.App”的框架引用被添加到&amp;lt;ItemGroup/&amp;gt;节点下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Project &lt;/span&gt;&lt;span&gt;Sdk&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.NET.Sdk&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;OutputType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Exe&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;OutputType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;netcoreapp3.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;strong&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FrameworkReference &lt;/span&gt;&lt;span&gt;Include&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.App&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/strong&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从应用承载或者寄宿（Hosting）方面来看，.NET Core具有一个以&lt;strong&gt;IHost/IHostBuilder&lt;/strong&gt;为核心的服务承载系统，任何需要长时间运行的操作都可以定义成IHostedService服务并通过该系统来承载。&lt;strong&gt;IHost&lt;/strong&gt;对象可以视为所有承载服务的宿主（Host），而&lt;strong&gt;IHostBuilder&lt;/strong&gt;对象则是它的构建者（Builder）。一个ASP.NET Core应用本质上就是一个用来监听、接收和处理HTTP请求的后台服务，所以它被定义成一个&lt;strong&gt;GenericWebHostService&lt;/strong&gt;（实现了IHostedService接口），我们将它注册到承载系统中进而实现了针对ASP.NET Core应用的承载。&lt;/p&gt;
&lt;p&gt;一个运行的ASP.NET Core应用本质上体现为&lt;strong&gt;由一个服务器和若干中间件构成的消息处理管道&lt;/strong&gt;，服务器解决针对HTTP请求的监听、接收和最终的响应，具体针对请求的处理则由它递交给后续的中间件来完成。这个管道是由前面提到的GenericWebHostService服务构建出来的。&lt;/p&gt;
&lt;p&gt;ASP.NET Core提供了几种原生的服务类型，比较常用的是&lt;strong&gt;KestrelServer&lt;/strong&gt;和&lt;strong&gt;HTTP.sys&lt;/strong&gt;。KestrelServer是采用libuv创建的跨平台的Web服务器，可以在Windows、Mac OS和Linux上使用。它不仅可以作为独立的Web服务器直接对外提供服务，也可以结合传统的Web服务器（比如&lt;strong&gt;IIS&lt;/strong&gt;、&lt;strong&gt;Apache&lt;/strong&gt;和&lt;strong&gt;NGinx&lt;/strong&gt;）并将它们作为反向代理来使用。HTTP.sys则是一种只能在Windows平台使用的Web服务器，由于它本质上是一个在操作系统内核模式运行的驱动，所以能够提供非常好的性能。&lt;/p&gt;
&lt;p&gt;在对项目文件helloworld.csproj作了上述修改之后，我们对定义在Program.cs中的Main方法做了如下的改造。我们调用了静态类型&lt;strong&gt;Host&lt;/strong&gt;的&lt;strong&gt;CreateDefaultBuilder&lt;/strong&gt;方法创建了一个&lt;strong&gt;IHostBuilder&lt;/strong&gt;对象，并最终调用该对象的&lt;strong&gt;Build&lt;/strong&gt;方法构建出作为服务宿主的&lt;strong&gt;IHost&lt;/strong&gt;对象。当我们调用IHost对象的&lt;strong&gt;Run&lt;/strong&gt;扩展方法的时候，ASP.NET Core应用程序将会被启动。&lt;/p&gt;
&lt;p&gt;在调用Build方法构建IHost对象之前，我们调用IHostBuilder接口的&lt;strong&gt;ConfigureWebHost&lt;/strong&gt;扩展方法，并利用指定的&lt;strong&gt;Action&amp;lt;IWebHostBuilder&amp;gt;&lt;/strong&gt;委托对象构建出ASP.NET Core应用的请求处理管道。具体来说，我们调用IWebHostBuilder接口的&lt;strong&gt;UseKestrel&lt;/strong&gt;扩展方法将&lt;strong&gt;KestrelServer&lt;/strong&gt;注册为服务器，调用&lt;strong&gt;Configure&lt;/strong&gt;扩展方法注册了用来处理请求的中间件。Configure方法的输入参数是一个Action&amp;lt;IApplicationBuilder&amp;gt;对象，所需的中间件就注册在&lt;strong&gt;IApplicationBuilder&lt;/strong&gt;对象上。演示程序注册的唯一中间件是通过调用IApplicationBuilder接口的&lt;strong&gt;Run&lt;/strong&gt;扩展方法注册的，该中间件利用指定的Func&amp;lt;HttpContext,Task&amp;gt;对象将响应的主体内容设置为“Hello World”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Hosting;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; helloworld
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            Host.CreateDefaultBuilder()
                .ConfigureWebHost(webHostBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt; webHostBuilder
                    .UseKestrel()
                    .Configure(app &lt;/span&gt;=&amp;gt;&lt;span&gt; app.Run(
                         context &lt;/span&gt;=&amp;gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))))
                .Build()
                .Run();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以按照上面演示的那样通过执行&lt;strong&gt;dotnet&lt;/strong&gt;命令行来启动该程序，也可以直接在Visual Studio中按F5或者Ctrl+F5启动该程序。下图所示的是执行dotnet run命令后控制台的输出结果，这些输出其实是通过&lt;strong&gt;日志&lt;/strong&gt;的形式输出的。我们从这些输出可以看出ASP.NET Core应用采用的默认监听地址（http//localhost:5000和https//localhost:5001）和承载环境（Production）。如果需要关闭应用程序，只需要按Ctrl+C组合键就可以了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071510388-855440085.png&quot;&gt;&lt;img width=&quot;513&quot; height=&quot;263&quot; title=&quot;1-6&quot; alt=&quot;1-6&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071510799-774600240.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注册的KestrelServer服务器会绑定到http//localhost:5000和https//localhost:5001这两个地址监听请求，如果我们利用浏览器分别对这两个地址发起请求会得到怎样的响应呢？如下图所示，两个请求都会得到主体内容为“Hello World.”的响应（由于证书的问题，Chrome浏览器为HTTPS的请求会显示“Not secure”的警告），毫无疑问该内容就是我们注册的中间件写入的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071511102-839507498.png&quot;&gt;&lt;img width=&quot;495&quot; height=&quot;293&quot; title=&quot;1-7&quot; alt=&quot;1-7&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071511356-1993505389.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;每个.NET Core应用都针对一种具体的SDK类型。我们在前面展示了项目文件helloworld.csproj的完整定义，这是一个XML文件，根节点的&amp;lt;Project&amp;gt;上通过SDK属性设置了当前项目采用的SDK类型。对于前面这个通过dotnet new命令工具创建出来的控制台应用，它默认采用的SDK类型为“&lt;strong&gt;Microsoft.NET.Sdk&lt;/strong&gt;”。对于一个ASP.NET Core应用，我们一般会采用另一种名为“&lt;strong&gt;Microsoft.NET.Sdk.Web&lt;/strong&gt;”的SDK类型。&lt;/p&gt;
&lt;p&gt;如果将SDK设置为“Microsoft.NET.Sdk.Web”，我们甚至可以将针对“&lt;strong&gt;Microsoft.AspNetCore.App&lt;/strong&gt;”的框架引用从项目文件中删除。由于我们并不需要利用生成的.exe文件来启动ASP.NET Core应用，所以我们也应该将XML元素&amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;从&amp;lt;PropertyGroup&amp;gt;节点中删除，所以最终的项目文件只需要保留如下的内容就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Project &lt;/span&gt;&lt;span&gt;Sdk&lt;/span&gt;&lt;span&gt;=&quot;&lt;strong&gt;&lt;span&gt;Microsoft.NET.Sdk.Web&lt;/span&gt;&lt;/strong&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;netcoreapp3.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当我们通过修改项目文件helloworld.csproj将SDK改为“Microsoft.NET.Sdk.Web”之后，如果我们使用Visual Studio打开这个文件，一个名为“&lt;strong&gt;launchSettings.json&lt;/strong&gt;”的配置文件将自动生成并被保存在“&lt;strong&gt;\Properties&lt;/strong&gt;”目录下。顾名思义，launchSettings.json是一个在应用启动的时候自动加载的配置文件，该配置文件使我们可以在不同的设置下执行我们的应用程序。如下所示的就是Visual Studio自动创建的launchSettings.json文件的内容。我们可以看出该配置文件默认添加了两个节点，其中“&lt;strong&gt;iisSettings&lt;/strong&gt;”用于设置IIS相关的选项，而“&lt;strong&gt;profiles&lt;/strong&gt;”节点定义了一系列用于表示应用启动场景的Profile。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;iisSettings&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;windowsAuthentication&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;anonymousAuthentication&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;iisExpress&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;applicationUrl&quot;: &quot;http://localhost:51127/&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;sslPort&quot;: 0&lt;span&gt;
    }
  },
  &lt;/span&gt;&quot;profiles&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;IIS Express&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;commandName&quot;: &quot;IISExpress&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;launchBrowser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;environmentVariables&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&lt;span&gt;
      }
    },
    &lt;/span&gt;&quot;helloworld&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;commandName&quot;: &quot;Project&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;launchBrowser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;environmentVariables&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&lt;span&gt;
      },
      &lt;/span&gt;&quot;applicationUrl&quot;: &quot;http://localhost:51128/&quot;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始的launchSettings.json文件会默认创建两个Profile，一个被命名为“IIS Express”，另一个则使用当前项目名称来命名（“helloworld”）。每一个Profile相当于定义了应用的启动场景，相关的设置包括应用启动的方式、环境变量和URL等，具体的设置包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;commandName：启动当前应用程序的命令类型，有效的选项包括IIS、IISExpress、Executable和Project，前三个选项分别表示采用IIS、IISExpress和指定的可执行文件（.exe）来启动应用程序。如果我们使用dotnet run命令来启动程序，对应Profile的启动命名名称应该设置为Project。&lt;/li&gt;
&lt;li&gt;executablePath：如果commandName属性被设置为Executable，我们需要利用该属性来设置启动可执行文件的路径（绝对路径或者相对路径）。&lt;/li&gt;
&lt;li&gt;environmentVariables：该属性用来设置环境变量。由于launchSettings.json仅仅使用在开发环境，所以默认会添加一个名为“ASPNETCORE_ENVIRONMENT”的环境变量，并将它的值设置为“Development”，ASP.NET Core应用中正是利用这样一个环境变量来表示当前的部署环境。&lt;/li&gt;
&lt;li&gt;commandLineArgs：命令行参数，即传入Main方法的参数列表。&lt;/li&gt;
&lt;li&gt;workingDirectory：启动当前应用运行的工作目录。&lt;/li&gt;
&lt;li&gt;applicationUrl：应用程序采用的URL列表，多个URL之间采用分号（“；”）进行分隔。&lt;/li&gt;
&lt;li&gt;launchBrowser：一个布尔类型的开关，表示应用程序的时候是否自动启动浏览器。&lt;/li&gt;
&lt;li&gt;launchUrl：如果launchBrowser被设置为true，浏览器采用的初始化路径通过该属性进行设置。&lt;/li&gt;
&lt;li&gt;nativeDebugging：是否启动本地代码调试（Native Code Debugging），默认值为false。&lt;/li&gt;
&lt;li&gt;externalUrlConfiguration：如果该属性被设置为true，意味着禁用本地的配置，默认值为false。&lt;/li&gt;
&lt;li&gt;use64Bit：如果commandName属性设置为IIS Express，该属性决定是采用X64版本还是X86版本，默认值为false，意味着ASP.NET Core应用默认会采用X86版本的IIS Express。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;launchSettings.json文件中的所有设置仅仅针对开发环境，产品环境下是不需要这个文件的，应用发布后生成的文件列表中也不包含该文件。该文件不需要手工进行编辑，当前项目属性对话框（通过在解决方案对话框中右击选择“属性（Properties）”选项）中“调试（Debug）”选项卡下的所有设置最终都会体现在该文件上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071511675-2055226632.png&quot;&gt;&lt;img width=&quot;588&quot; height=&quot;500&quot; title=&quot;1-8&quot; alt=&quot;1-8&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071511992-21155574.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果在launchSettings.json文件设置了多个Profile，它们会以如下图所示的形式出现在Visual Studio的工具栏中，我们可以选择任意一个Profile中定义的配置选项来启动当前应用程序。如果Profile中通过设置launchBrowser属性选择启动浏览器，我们还可以选择浏览器的类型。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071512220-1504148872.png&quot;&gt;&lt;img width=&quot;581&quot; height=&quot;208&quot; title=&quot;1-9&quot; alt=&quot;1-9&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071512477-75565777.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果我们在当前项目所在目录下通过执行dotnet run命令来启动应用程序，launchSettings.json文件会默认被加载。我们可以通过命令行参数&lt;strong&gt;--launch-profile&lt;/strong&gt;指定采用的Profile。如果没有对Profile作显式指定，定义在该配置文件中第一个commandName为“&lt;strong&gt;Project&lt;/strong&gt;”的Profile会默认被使用。如下图所示，我们在创建的应用根目录下通过执行dotnet run命令启动我们的应用程序，其中第一次执行dotnet run命令的时候显式设置了Profile名称（&lt;strong&gt;--launch-profile helloworld&lt;/strong&gt;）。从输出的结果可以看出，两次采用的是同一个Profile。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071512718-473635530.png&quot;&gt;&lt;img width=&quot;577&quot; height=&quot;442&quot; title=&quot;1-10&quot; alt=&quot;1-10&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071513077-392479672.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果在执行dotnet run命令的时候不希望加载launchSettings.json文件，我们可以通过显式指定命令行参数&lt;strong&gt;--no-launch-profile&lt;/strong&gt;来实现。如下图所示，我们在执行dotnet run命令时指定了--no-launch-profile参数，所以应用会采用KestrelServer默认的监听地址（http://localhost:5000和https://localhost:5001）。由于launchSettings.json根本就没有被加载，所以当前执行环境从Development变成了默认的Production。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071513370-1392618746.png&quot;&gt;&lt;img width=&quot;572&quot; height=&quot;265&quot; title=&quot;1-11&quot; alt=&quot;1-11&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191010071513699-1076203479.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果既不想使用launchSettings.json文件中定义的URL，也不想使用KestrelServer默认采用的监听地址，我们可以在应用程序中显式指定应用的URL。如下面的代码片段所示，我们只需要调用IWebHostBuilder的扩展方法&lt;strong&gt;UseUrls&lt;/strong&gt;指定一组以分号分隔的URL即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder()
            .ConfigureWebHost(webHostBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt; webHostBuilder
                .UseKestrel()
         &lt;strong&gt;       &lt;span&gt;.UseUrls(&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;http://0.0.0.0:3721;https://0.0.0.0:9527&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;
                .Configure(app &lt;/span&gt;=&amp;gt; app.Run(context =&amp;gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))))
            .Build()
            .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在上面演示的实例中，我们都是调用IHostBuilder接口的&lt;strong&gt;ConfigureWebHost&lt;/strong&gt;扩展方法借助指定的Action&amp;lt;IWebHostBuilder&amp;gt;委托对象来构建处理请求处理管道，该接口还有另一个&lt;strong&gt;ConfigureWebHostDefaults&lt;/strong&gt;的扩展方法，它会为我们作一些默认设置。如下面的代码片段所示，如果调用这个方法，KestrelServer服务器都不需要进行显式注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder()
            .ConfigureWebHostDefaults(webHostBuilder &lt;/span&gt;=&amp;gt; webHostBuilder.Configure(app =&amp;gt; app.Run(context =&amp;gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))))
            .Build()
            .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Mac OS&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Linux&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Docker&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Oct 2019 23:15:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>我们在《上篇》利用dotnet new命令创建了一个简单的控制台程序，接下来我们将它改造成一个ASP.NET Core应用。一个ASP.NET Core应用构建在ASP.NET Core框架之上，AS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-01-02.html</dc:identifier>
</item>
<item>
<title>Java 爬虫遇到需要登录的网站，该怎么办？ - 平头哥的技术博文</title>
<link>http://www.cnblogs.com/jamaler/p/11645569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jamaler/p/11645569.html</guid>
<description>&lt;p&gt;这是 Java 网络爬虫系列博文的第二篇，在上一篇 &lt;a href=&quot;https://www.cnblogs.com/jamaler/p/11640131.html&quot;&gt;Java 网络爬虫，就是这么的简单&lt;/a&gt; 中，我们简单的学习了一下如何利用 Java 进行网络爬虫。在这一篇中我们将简单的聊一聊在网络爬虫时，遇到需要登录的网站，我们该怎么办？&lt;/p&gt;
&lt;p&gt;在做爬虫时，遇到需要登陆的问题也比较常见，比如写脚本抢票之类的，但凡需要个人信息的都需要登陆，对于这类问题主要有两种解决方式：&lt;strong&gt;一种方式是手动设置 cookie ，就是先在网站上面登录，复制登陆后的 cookies ，在爬虫程序中手动设置 HTTP 请求中的 Cookie 属性，这种方式适用于采集频次不高、采集周期短，因为 cookie 会失效，如果长期采集的话就需要频繁设置 cookie，这不是一种可行的办法，第二种方式就是使用程序模拟登陆，通过模拟登陆获取到 cookies，这种方式适用于长期采集该网站，因为每次采集都会先登陆，这样就不需要担心 cookie 过期的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了能让大家更好的理解这两种方式的运用，我以获取豆瓣个人主页昵称为例，分别用这两种方式来获取需要登陆后才能看到的信息。获取信息如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/8/16daab724e763d8f?w=1461&amp;amp;h=814&amp;amp;f=png&amp;amp;s=131325&quot;/&gt;&lt;br/&gt;获取图片中的&lt;code&gt;缺心眼那叫单纯&lt;/code&gt;，这个信息显然是需要登陆后才能看到的，这就符合我们的主题啦。接下来分别用上面两种办法来解决这个问题。&lt;/p&gt;
&lt;h3 id=&quot;手动设置-cookie&quot;&gt;手动设置 cookie&lt;/h3&gt;
&lt;p&gt;手动设置 cookie 的方式，这种方式比较简单，我们只需要在豆瓣网上登陆，登陆成功后就可以获取到带有用户信息的cookie，豆瓣网登录链接：&lt;code&gt;https://accounts.douban.com/passport/login&lt;/code&gt;。如下图所示：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/8/16daac2a9061089b?w=1735&amp;amp;h=870&amp;amp;f=png&amp;amp;s=145081&quot;/&gt;&lt;br/&gt;图中的这个 cookie 就携带了用户信息，我们只需要在请求时携带这个 cookie 就可以查看到需要登陆后才能查看到的信息。我们用 Jsoup 来模拟一下手动设置 cookie 方式，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 手动设置 cookies
 * 先从网站上登录，然后查看 request headers 里面的 cookies
 * @param url
 * @throws IOException
 */
public void setCookies(String url) throws IOException {

    Document document = Jsoup.connect(url)
            // 手动设置cookies
            .header(&quot;Cookie&quot;, &quot;your cookies&quot;)
            .get();
    //
    if (document != null) {
        // 获取豆瓣昵称节点
        Element element = document.select(&quot;.info h1&quot;).first();
        if (element == null) {
            System.out.println(&quot;没有找到 .info h1 标签&quot;);
            return;
        }
        // 取出豆瓣节点昵称
        String userName = element.ownText();
        System.out.println(&quot;豆瓣我的网名为：&quot; + userName);
    } else {
        System.out.println(&quot;出错啦！！！！！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中可以看出跟不需要登陆的网站没什么区别，只是多了一个&lt;code&gt;.header(&quot;Cookie&quot;, &quot;your cookies&quot;)&lt;/code&gt;，我们把浏览器中的 cookie 复制到这里即可，编写 main 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception {
    // 个人中心url
    String user_info_url = &quot;https://www.douban.com/people/150968577/&quot;;
    new CrawleLogin().setCookies(user_info_url);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行 main 得到结果如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/8/16daac2d50de0182?w=504&amp;amp;h=154&amp;amp;f=png&amp;amp;s=9883&quot;/&gt;&lt;br/&gt;可以看出我们成功获取到了&lt;code&gt;缺心眼那叫单纯&lt;/code&gt;，这说明我们设置的 cookie 是有效的，成功的拿到了需要登陆的数据。这种方式是真的比较简单，唯一的不足就是需要频繁的更换 cookie，因为 cookie 会失效，这让你使用起来就不是很爽啦。&lt;/p&gt;
&lt;h3 id=&quot;模拟登陆方式&quot;&gt;模拟登陆方式&lt;/h3&gt;
&lt;p&gt;模拟登陆的方式可以解决手动设置 cookie 方式的不足之处，但同时也引入了比较复杂的问题，现在的验证码形形色色、五花八门，很多都富有挑战性，比如在一堆图片中操作某类图片，这个还是非常有难度，不是随便就能够编写出来。所以对于使用哪种方式这个就需要开发者自己去衡量利弊啦。今天我们用到的豆瓣网，在登陆的时候就没有验证码，对于这种没有验证码的还是比较简单的，&lt;strong&gt;关于模拟登陆方式最重要的就是找到真正的登陆请求、登陆需要的参数。&lt;/strong&gt; 这个我们就只能取巧了，我们先在登陆界面输入错误的账号密码，这样页面将不会跳转，所以我们就能够轻而易举的找到登陆请求。我来演示一下豆瓣网登陆查找登陆链接，我们在登陆界面输入错误的用户名和密码，点击登陆后，在 network 查看发起的请求链接，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/8/16daab7bf51180ce?w=1395&amp;amp;h=914&amp;amp;f=png&amp;amp;s=276392&quot;/&gt;&lt;br/&gt;从 network 中我们可以查看到豆瓣网的登陆链接为&lt;code&gt;https://accounts.douban.com/j/mobile/login/basic&lt;/code&gt;，需要的参数有五个，具体参数查看图中的 Form Data，有了这些之后，我们就能够构造请求模拟登陆啦。登陆后进行后续操作，接下来我们就用 Jsoup 来模拟登陆到获取豆瓣主页昵称，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Jsoup 模拟登录豆瓣 访问个人中心
 * 在豆瓣登录时先输入一个错误的账号密码，查看到登录所需要的参数
 * 先构造登录请求参数，成功后获取到cookies
 * 设置request cookies，再次请求
 * @param loginUrl 登录url
 * @param userInfoUrl 个人中心url
 * @throws IOException
 */
public void jsoupLogin(String loginUrl,String userInfoUrl)  throws IOException {

    // 构造登陆参数
    Map&amp;lt;String,String&amp;gt; data = new HashMap&amp;lt;&amp;gt;();
    data.put(&quot;name&quot;,&quot;your_account&quot;);
    data.put(&quot;password&quot;,&quot;your_password&quot;);
    data.put(&quot;remember&quot;,&quot;false&quot;);
    data.put(&quot;ticket&quot;,&quot;&quot;);
    data.put(&quot;ck&quot;,&quot;&quot;);
    Connection.Response login = Jsoup.connect(loginUrl)
            .ignoreContentType(true) // 忽略类型验证
            .followRedirects(false) // 禁止重定向
            .postDataCharset(&quot;utf-8&quot;)
            .header(&quot;Upgrade-Insecure-Requests&quot;,&quot;1&quot;)
            .header(&quot;Accept&quot;,&quot;application/json&quot;)
            .header(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)
            .header(&quot;X-Requested-With&quot;,&quot;XMLHttpRequest&quot;)
            .header(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&quot;)
            .data(data)
            .method(Connection.Method.POST)
            .execute();
    login.charset(&quot;UTF-8&quot;);
    // login 中已经获取到登录成功之后的cookies
    // 构造访问个人中心的请求
    Document document = Jsoup.connect(userInfoUrl)
            // 取出login对象里面的cookies
            .cookies(login.cookies())
            .get();
    if (document != null) {
        Element element = document.select(&quot;.info h1&quot;).first();
        if (element == null) {
            System.out.println(&quot;没有找到 .info h1 标签&quot;);
            return;
        }
        String userName = element.ownText();
        System.out.println(&quot;豆瓣我的网名为：&quot; + userName);
    } else {
        System.out.println(&quot;出错啦！！！！！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码分两段，前一段是模拟登陆，后一段是解析豆瓣主页，在这段代码中发起了两次请求，第一次请求是模拟登陆获取到 cookie，第二次请求时携带第一次模拟登陆后获取的cookie，这样也可以访问需要登陆的页面，修改 main 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception {
    // 个人中心url
    String user_info_url = &quot;https://www.douban.com/people/150968577/&quot;;

    // 登陆接口
    String login_url = &quot;https://accounts.douban.com/j/mobile/login/basic&quot;;

    // new CrawleLogin().setCookies(user_info_url);
    new CrawleLogin().jsoupLogin(login_url,user_info_url);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行 main 方法，得到如下结果：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/8/16daac2d50de0182?w=504&amp;amp;h=154&amp;amp;f=png&amp;amp;s=9883&quot;/&gt;&lt;br/&gt;模拟登陆的方式也成功的获取到了网名&lt;code&gt;缺心眼那叫单纯&lt;/code&gt;，虽然这已经是最简单的模拟登陆啦，从代码量上就可以看出它比设置 cookie 要复杂很多，对于其他有验证码的登陆，我就不在这里介绍了，第一是我在这方面也没什么经验，第二是这个实现起来比较复杂，会涉及到一些算法和一些辅助工具的使用，有兴趣的朋友可以参考崔庆才老师的博客研究研究。模拟登陆写起来虽然比较复杂，但是只要你编写好之后，你就能够一劳永逸，如果你需要长期采集需要登陆的信息，这个还是值得你的做的。&lt;/p&gt;
&lt;p&gt;除了使用 jsoup 模拟登陆外，我们还可以使用 httpclient 模拟登陆，httpclient 模拟登陆没有 Jsoup 那么复杂，因为 httpclient 能够像浏览器一样保存 session 会话，这样登陆之后就保存下了 cookie ，在同一个 httpclient 内请求就会带上 cookie 啦。httpclient 模拟登陆代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * httpclient 的方式模拟登录豆瓣
 * httpclient 跟jsoup差不多，不同的地方在于 httpclient 有session的概念
 * 在同一个httpclient 内不需要设置cookies ，会默认缓存下来
 * @param loginUrl
 * @param userInfoUrl
 */
public void httpClientLogin(String loginUrl,String userInfoUrl) throws Exception{

    CloseableHttpClient httpclient = HttpClients.createDefault();
    HttpUriRequest login = RequestBuilder.post()
            .setUri(new URI(loginUrl))// 登陆url
            .setHeader(&quot;Upgrade-Insecure-Requests&quot;,&quot;1&quot;)
            .setHeader(&quot;Accept&quot;,&quot;application/json&quot;)
            .setHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)
            .setHeader(&quot;X-Requested-With&quot;,&quot;XMLHttpRequest&quot;)
            .setHeader(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&quot;)
            // 设置账号信息
            .addParameter(&quot;name&quot;,&quot;your_account&quot;)
            .addParameter(&quot;password&quot;,&quot;your_password&quot;)
            .addParameter(&quot;remember&quot;,&quot;false&quot;)
            .addParameter(&quot;ticket&quot;,&quot;&quot;)
            .addParameter(&quot;ck&quot;,&quot;&quot;)
            .build();
    // 模拟登陆
    CloseableHttpResponse response = httpclient.execute(login);
    if (response.getStatusLine().getStatusCode() == 200){
        // 构造访问个人中心请求
        HttpGet httpGet = new HttpGet(userInfoUrl);
        CloseableHttpResponse user_response = httpclient.execute(httpGet);
        HttpEntity entity = user_response.getEntity();
        //
        String body = EntityUtils.toString(entity, &quot;utf-8&quot;);

        // 偷个懒，直接判断 缺心眼那叫单纯 是否存在字符串中
        System.out.println(&quot;缺心眼那叫单纯是否查找到？&quot;+(body.contains(&quot;缺心眼那叫单纯&quot;)));
    }else {
        System.out.println(&quot;httpclient 模拟登录豆瓣失败了!!!!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这段代码，返回的结果也是 true。&lt;/p&gt;
&lt;p&gt;有关 Java 爬虫遇到登陆问题就聊得差不多啦，来总结一下：&lt;strong&gt;对于爬虫遇到登陆问题有两种解决办法，一种是手动设置cookie，这种方式适用于短暂性采集或者一次性采集，成本较低。另一种方式是模拟登陆的方式，这种方式适用于长期采集的网站，因为模拟登陆的代价还是蛮高的，特别是一些变态的验证码，好处就是能够让你一劳永逸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上就是 Java 爬虫时遇到登陆问题相关知识分享，希望对你有所帮助，下一篇是关于爬虫是遇到数据异步加载的问题。如果你对爬虫感兴趣，不妨关注一波，相互学习，相互进步&lt;/p&gt;
&lt;p&gt;源代码：&lt;a href=&quot;https://github.com/BinaryBall/java-base/blob/master/crawler/src/main/java/com/jamal/crawler/CrawleLogin.java&quot;&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文章不足之处，望大家多多指点，共同学习，共同进步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;打个小广告，欢迎扫码关注微信公众号：「平头哥的技术博文」，一起进步吧。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/4/16cf9e5f7dece6b6?w=900&amp;amp;h=500&amp;amp;f=png&amp;amp;s=75961&quot; alt=&quot;平头哥的技术博文&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Oct 2019 23:00:00 +0000</pubDate>
<dc:creator>平头哥的技术博文</dc:creator>
<og:description>这是 Java 网络爬虫系列博文的第二篇，在上一篇 'Java 网络爬虫，就是这么的简单' 中，我们简单的学习了一下如何利用 Java 进行网络爬虫。在这一篇中我们将简单的聊一聊在网络爬虫时，遇到需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jamaler/p/11645569.html</dc:identifier>
</item>
<item>
<title>让视频丝滑流畅——N/A通用补帧傻瓜解决方案 - zhxmdefj</title>
<link>http://www.cnblogs.com/zhxmdefj/p/11645341.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxmdefj/p/11645341.html</guid>
<description>&lt;p&gt;补帧就是字面意思，把24帧的视频通过算法即时补偿到更高的帧数，获得更优秀的观感体验&lt;/p&gt;
&lt;p&gt;索尼大法brivia电视的中高端产品线中的motionflow技术，都可以实现硬件补帧，只需要把动态打开，相应的画面就可以实现补帧&lt;/p&gt;
&lt;p&gt;从硬件层面支持补帧的还有AMD的显卡，只要是HD7000以上系列GCN架构显卡，以及采用GCN架构显卡的APU，便可以通过AMD官方提供的插帧程序或以此为蓝本民间加工的版本BFRC（Bluesky Frame Rate Converter）轻易实现对低帧率视频的补帧&lt;/p&gt;
&lt;p&gt;当然现在介绍的是PC上A/N平台通用方便的补帧方法，不再对硬件补帧做过多介绍&lt;/p&gt;
&lt;h2 id=&quot;potplayer倍帧&quot;&gt;potplayer倍帧&lt;/h2&gt;
&lt;p&gt;首先推荐一个地表最强视频播放器&lt;strong&gt;potplayer&lt;/strong&gt;，&lt;strong&gt;自带一键倍帧功能&lt;/strong&gt;，官网http://potplayer.daum.net/（可能需要科学，百度potplayer下的应该也能用，别下错了就好）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010001520844-885402879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先在pot主界面右键-&amp;gt;选项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010001751819-1933793227.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择视频-&amp;gt;图像处理-&amp;gt;勾选&lt;strong&gt;倍帧(创建中间帧)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010001824876-153486064.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如此简单，插帧就完成了，但是这种方法只能给帧数翻倍，24帧变为48帧，而且画面质量不是很高，接下来介绍一个稍微麻烦一点点，但是画面质量能上升好几个层次的方案&lt;/p&gt;
&lt;h2 id=&quot;dmitrirender满帧&quot;&gt;dmitrirender满帧&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DmitriRender&lt;/strong&gt;是一个补帧软件，和pot的倍帧不一样，运用gpu运算把帧数插满60甚至144，画面效果非常惊艳&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DmitriRender&lt;/strong&gt;已经开始支持RTX Turing显卡，一份license要8刀，价格只有SVP Pro的1/3，作者是个毛子，又条件的可以和我一起支持一下作者，买一份license，毕竟也不贵（虽然SVP可选项非常多，但是上手也不容易，所以这里选择DmitriRender介绍）&lt;/p&gt;
&lt;p&gt;你需要先到dmitrirender的&lt;a href=&quot;http://www.dmitrirender.ru/&quot;&gt;官网&lt;/a&gt;下载一份&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191009235808591-391918669.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不用看前面花里胡哨的，直接下载本体就行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010000127819-129697089.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可能奇怪无论在桌面还是开始菜单都无法找到此软件，不用担心，它默认安装到了&lt;code&gt;C:\Users\你的用户名\AppData\Roaming\DmitriRender&lt;/code&gt;，打开这个目录下的&lt;code&gt;x64&lt;/code&gt;或者&lt;code&gt;x86&lt;/code&gt;（根据你的系统决定，新机器一般都是64位系统），然后打开pcnsl.exe进行注册，我们先尝试免费试用30天&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010003347223-662091942.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在你需要再下载一份&lt;a href=&quot;https://files.cnblogs.com/files/zhxmdefj/dmitriRender.7z&quot;&gt;dat文件&lt;/a&gt;（点这个链接），下载出来解压缩，覆盖到你DmitriRender的安装目录下，默认安装目录为&lt;code&gt;C:\Users\你的用户名\AppData\Roaming\DmitriRender&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010000748675-632191572.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后以管理员身份运行registerFilter&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010002327753-518336725.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后你就注册好dmitriRender.dll了，现在我们可以在各播放器软件里激活dmitriRender，这里示范的是potplayer&lt;/p&gt;
&lt;p&gt;同上打开pot的选项：&lt;/p&gt;
&lt;p&gt;选择滤镜-&amp;gt;全局滤镜优先权-&amp;gt;添加系统滤镜&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010002803136-2075032796.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候你应该能看到DmitriRender&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010002848942-1959226021.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确定&lt;/p&gt;
&lt;p&gt;然后勾选为&lt;strong&gt;强制使用&lt;/strong&gt;（很关键）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010002928393-1085718553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来重启你的potplayer，打开一个视频，如无意外左下角会显示DmitriRender Trial的水印，就成功了&lt;/p&gt;
&lt;p&gt;不出意外你的任务栏会出现DmitriRender的图标来表示实时负载，如果图标变红就意味着你的显卡不太行了。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536438/201910/1536438-20191010004138750-1678500794.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人实测RTX2060观看BD1080p的动画负载均不超过20%，GTX1050负载不超过30%，希望能作为参考&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;感兴趣爱折腾的朋友可以试试对比N卡+dmitriRender，A卡+BFRC，CPU+SVP Pro三种补帧方案的效果，我这里就懒得折腾了&lt;/p&gt;
</description>
<pubDate>Wed, 09 Oct 2019 17:03:00 +0000</pubDate>
<dc:creator>zhxmdefj</dc:creator>
<og:description>补帧就是字面意思，把24帧的视频通过算法即时补偿到更高的帧数，获得更优秀的观感体验 索尼大法brivia电视的中高端产品线中的motionflow技术，都可以实现硬件补帧，只需要把动态打开，相应的画面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxmdefj/p/11645341.html</dc:identifier>
</item>
<item>
<title>从 axios 源码中了解到的 Promise 链与请求的取消 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/axios_promise_chain_and_request_cancelation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/axios_promise_chain_and_request_cancelation.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt; 中一个请求取消的示例：&lt;/p&gt;
&lt;details readability=&quot;6&quot;&gt;axios 取消请求的示例代码
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;, { &lt;span class=&quot;pl-smi&quot;&gt;useState&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;useEffect&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;react&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;axios&lt;/span&gt;, { &lt;span class=&quot;pl-smi&quot;&gt;AxiosResponse&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;axios&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; App() {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; [index, setIndex] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;useState&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; [imgUrl, setImgUrl] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;useState&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-en&quot;&gt;useEffect&lt;/span&gt;(() &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;loading ${&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;}&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; source &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;axios&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;CancelToken&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;source&lt;/span&gt;();
    &lt;span class=&quot;pl-smi&quot;&gt;axios&lt;/span&gt;
      .&lt;span class=&quot;pl-c1&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;https://dog.ceo/api/breeds/image/random&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, {
        cancelToken: &lt;span class=&quot;pl-smi&quot;&gt;source&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;token&lt;/span&gt;
      })
      .&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;((&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;AxiosResponse&lt;/span&gt;&amp;lt;{ message&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;; status&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt; }&amp;gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;${&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;} done&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
        &lt;span class=&quot;pl-en&quot;&gt;setImgUrl&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;);
      })
      .&lt;span class=&quot;pl-c1&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;axios&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;isCancel&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;source&lt;/span&gt;)) {
          &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;);
        }
      });

    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;canceling ${&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;}&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
      &lt;span class=&quot;pl-smi&quot;&gt;source&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;cancel&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;canceling ${&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;}&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    };
  }, [&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;]);

  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
    &amp;lt;&lt;span class=&quot;pl-en&quot;&gt;div&lt;/span&gt;&amp;gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;button&lt;/span&gt;
        &lt;span class=&quot;pl-smi&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{() =&amp;gt; {
          setIndex(&lt;span class=&quot;pl-v&quot;&gt;index&lt;/span&gt; + 1);
        }}
      &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;pl-smi&quot;&gt;click&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &amp;lt;&lt;span class=&quot;pl-en&quot;&gt;div&lt;/span&gt;&amp;gt;
        &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;pl-smi&quot;&gt;imgUrl&lt;/span&gt;} &lt;span class=&quot;pl-smi&quot;&gt;alt&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/66497032-6f2f5600-eaee-11e9-882a-d33b8c6e2c7d.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/66497032-6f2f5600-eaee-11e9-882a-d33b8c6e2c7d.gif&quot; alt=&quot;axios 中一个请求取消的示例&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;axios 中一个请求取消的示例&lt;/p&gt;
&lt;p&gt;通过解读其源码不难实现出一个自己的版本。Here we go...&lt;/p&gt;
&lt;h2&gt;Promise 链与拦截器&lt;/h2&gt;
&lt;p&gt;这个和请求的取消其实关系不大，但不妨先来了解一下，axios 中如何组织起来一个 Promise 链（Promise chain），从而实现在请求前后可执行一个拦截器（Interceptor）的。&lt;/p&gt;
&lt;p&gt;简单来说，通过 axios 发起的请求，可在请求前后执行一些函数，来实现特定功能，比如请求前添加一些自定义的 header，请求后进行一些数据上的统一转换等。&lt;/p&gt;
&lt;h3&gt;用法&lt;/h3&gt;
&lt;p&gt;首先，通过 axios 实例配置需要执行的拦截器：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;axios&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;interceptors&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;before request&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;;
  }, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-v&quot;&gt;error&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;);
  });

&lt;span class=&quot;pl-smi&quot;&gt;axios&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;interceptors&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-v&quot;&gt;response&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;after response&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;;
  }, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-v&quot;&gt;error&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;);
  });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后每次请求前后都会打印出相应信息，拦截器生效了。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;axios&lt;/span&gt;({
    url: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;https://dog.ceo/api/breeds/image/random&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    method: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
}).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;load success&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面编写一个页面，放置一个按钮，点击后发起请求，后续示例中将一直使用该页面来测试。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-tsx&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;react&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;axios&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;axios&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; App() {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; sendRequest &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-smi&quot;&gt;axios&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;interceptors&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(
      &lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;before request&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;;
      },
      &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;error&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;);
      }
    );

    &lt;span class=&quot;pl-smi&quot;&gt;axios&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;interceptors&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(
      &lt;span class=&quot;pl-v&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;after response&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;;
      },
      &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;error&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;);
      }
    );

    &lt;span class=&quot;pl-en&quot;&gt;axios&lt;/span&gt;({
      url: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;https://dog.ceo/api/breeds/image/random&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
      method: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
    }).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;load success&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    });
  };
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;sendRequest&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&amp;gt;click me&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;button&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击按钮后运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;before request
after response
load success
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;拦截器机制的实现&lt;/h3&gt;
&lt;p&gt;实现分两步走，先看请求前的拦截器。&lt;/p&gt;
&lt;h4&gt;请求前拦截器的实现&lt;/h4&gt;
&lt;p&gt;Promise 的常规用法如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;resolve&lt;/span&gt;,&lt;span class=&quot;pl-smi&quot;&gt;reject&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如我们封装一个类似 axios 的请求库，可以这么写：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt; {
  url&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  method&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;POST&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; request(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;((&lt;span class=&quot;pl-v&quot;&gt;resolve&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;reject&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; xhr &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;XMLHttpRequest&lt;/span&gt;();
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;method&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;url&lt;/span&gt;);
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;responseText&lt;/span&gt;);
    };
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
    };
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;send&lt;/span&gt;();
  });
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了像上面那个直接 &lt;code&gt;new&lt;/code&gt; 一个 Promise 外，其实任意对象值都可以形成一个 Promise，方法是调用 &lt;code&gt;Promise.resolve&lt;/code&gt;，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;value&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(()&lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt;{ &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt;... &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式创建 Promise 的好处是，我们可以从 &lt;code&gt;config&lt;/code&gt; 开始，创建一个 Promise 链，在真实的请求发出前，先执行一些函数，像这样：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; request(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;)
    .&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 1&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;;
    })
    .&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 2&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;;
    })
    .&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;((&lt;span class=&quot;pl-v&quot;&gt;resolve&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;reject&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; xhr &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;XMLHttpRequest&lt;/span&gt;();
        &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;method&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;url&lt;/span&gt;);
        &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
          &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;responseText&lt;/span&gt;);
        };
        &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
          &lt;span class=&quot;pl-en&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
        };
        &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;send&lt;/span&gt;();
      });
    });
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将前面示例中 axios 替换为我们自己写的 &lt;code&gt;request&lt;/code&gt; 函数，示例可以正常跑起来，输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interceptor 1
interceptor 2
load success
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，已经实现了 axios 中请求前拦截器的功能。仔细观察，上面三个 &lt;code&gt;then&lt;/code&gt; 当中的函数，形成了一个 Promise 链，在这个链中顺次执行，每一个都可以看成一个拦截器，即使是执行发送请求的那个 &lt;code&gt;then&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;于是我们可以将他们抽取成三个函数，每个函数就是一个&lt;strong&gt;拦截器&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; interceptor1(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 1&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;;
}
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; interceptor2(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 2&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; xmlHttpRequest&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;((&lt;span class=&quot;pl-v&quot;&gt;resolve&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;reject&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; xhr &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;XMLHttpRequest&lt;/span&gt;();
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;method&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;url&lt;/span&gt;);
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;responseText&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;);
    };
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
    };
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;send&lt;/span&gt;();
  });
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来要做的，就是从 Promise 链的头部 &lt;code&gt;Promise.resolve(config)&lt;/code&gt; 开始，将上面三个函数串起来。借助 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monkey_patch&quot; rel=&quot;nofollow&quot;&gt;Monkey patch&lt;/a&gt; 这不难实现：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; request&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; chain&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;);
  &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor1&lt;/span&gt;);
  &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor2&lt;/span&gt;);
  &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;xmlHttpRequest&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，将上面硬编码的写法程式化一下，就实现了任意个请求前拦截器的功能。&lt;/p&gt;
&lt;p&gt;扩展配置，以接收拦截器：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt; {
  url&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  method&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;POST&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  interceptors&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Interceptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;&amp;gt;[];
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个数组，将执行请求的函数做为默认的元素放进去，然后将用户配置的拦截器压入数组前面，这样形成了一个拦截器的数组。最后再遍历这个数组形成 Promise 链。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; request&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;({ &lt;span class=&quot;pl-v&quot;&gt;interceptors&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [], &lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt; }&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 发送请求的拦截器为默认，用户配置的拦截器压入数组前面&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; tmpInterceptors&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Interceptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;[] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;pl-smi&quot;&gt;xmlHttpRequest&lt;/span&gt;];
  &lt;span class=&quot;pl-smi&quot;&gt;interceptors&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-smi&quot;&gt;tmpInterceptors&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;unshift&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt;);
  });
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; chain&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;);
  &lt;span class=&quot;pl-smi&quot;&gt;tmpInterceptors&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt;)));
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;request&lt;/span&gt;({
    url: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;https://dog.ceo/api/breeds/image/random&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    method: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    interceptors: [&lt;span class=&quot;pl-smi&quot;&gt;interceptor1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;interceptor2&lt;/span&gt;]
}).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;load success&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interceptor 2
interceptor 1
load success
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意这里顺序为传入的拦截器的反序，不过这不重要，可通过传递的顺序来控制。&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;响应后拦截器&lt;/h4&gt;
&lt;p&gt;上面实现了在请求前执行一序列拦截函数，同理，如果将拦截器压入到数组后面，即执行请求那个函数的后面，便实现了响应后的拦截器。&lt;/p&gt;
&lt;p&gt;继续扩展配置，将请求与响应的拦截器分开：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt; {
  url&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  method&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;POST&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  interceptors&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
    request&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Interceptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;&amp;gt;[];
    response&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Interceptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;[];
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新 &lt;code&gt;request&lt;/code&gt; 方法，请求前拦截器的逻辑不变，将新增的响应拦截器通过 &lt;code&gt;push&lt;/code&gt; 压入数组后面：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; request&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;({
  &lt;span class=&quot;pl-v&quot;&gt;interceptors&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; { request: [], response: [] },
  &lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;
}&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; tmpInterceptors&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Interceptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;[] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;pl-smi&quot;&gt;xmlHttpRequest&lt;/span&gt;];
  &lt;span class=&quot;pl-smi&quot;&gt;interceptors&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-smi&quot;&gt;tmpInterceptors&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;unshift&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt;);
  });

  &lt;span class=&quot;pl-smi&quot;&gt;interceptors&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-smi&quot;&gt;tmpInterceptors&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt;);
  });

  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; chain&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;);
  &lt;span class=&quot;pl-smi&quot;&gt;tmpInterceptors&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt;)));
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似 &lt;code&gt;interceptor1&lt;/code&gt; &lt;code&gt;interceptor2&lt;/code&gt;，新增两个拦截器用于响应后执行，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; interceptor3&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 3&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; interceptor4&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 4&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;request&lt;/span&gt;({
    url: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;https://dog.ceo/api/breeds/image/random&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    method: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    interceptors: {
    request: [&lt;span class=&quot;pl-smi&quot;&gt;interceptor1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;interceptor2&lt;/span&gt;],
    response: [&lt;span class=&quot;pl-smi&quot;&gt;interceptor3&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;interceptor4&lt;/span&gt;]
    }
}).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;load success&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interceptor 2
interceptor 1
interceptor 3
interceptor 4
load success
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难看出，当我们发起一次 axios 请求时，其实是发起了一次 Promise 链，链上的函数顺次执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;request interceptor 1
request interceptor 2
...
request
response interceptor 1
response interceptor 2
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为拉弓没有回头箭，请求发出后，能够取消的是后续操作，而不是请求本身，所以上面的 Promise 链中，需要实现 &lt;code&gt;request&lt;/code&gt; 之后的拦截器和后续回调的取消执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;request interceptor 1
request interceptor 2
...
request
# 🚫 后续操作不再执行
response interceptor 1
response interceptor 2
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;请求的取消&lt;/h2&gt;
&lt;h3&gt;Promise 链的中断&lt;/h3&gt;
&lt;p&gt;中断 Promise 链的执行，可通过 throw 异常来实现。&lt;/p&gt;
&lt;p&gt;添加一个中间函数，将执行请求的函数进行封装，无论其成功与否，都抛出异常将后续执行中断。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; adapter(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;xmlHttpRequest&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(
    &lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;baddie!&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
    },
    &lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;baddie!&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
    }
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新 &lt;code&gt;request&lt;/code&gt; 函数使用 &lt;code&gt;adapter&lt;/code&gt; 而不是直接使用 &lt;code&gt;xmlHttpRequest&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
function request&amp;lt;T = any&amp;gt;({
  interceptors = { request: [], response: [] },
  ...config
}: Config) {
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;  const tmpInterceptors: Interceptor&amp;lt;any&amp;gt;[] = [xmlHttpRequest];&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  const tmpInterceptors: Interceptor&amp;lt;any&amp;gt;[] = [adapter];&lt;/span&gt;
  interceptors.request.forEach(interceptor =&amp;gt; {
    tmpInterceptors.unshift(interceptor);
  });

  interceptors.response.forEach(interceptor =&amp;gt; {
    tmpInterceptors.push(interceptor);
  });

  let chain: Promise&amp;lt;any&amp;gt; = Promise.resolve(config);
  tmpInterceptors.forEach(interceptor =&amp;gt; (chain = chain.then(interceptor)));
  return chain as Promise&amp;lt;T&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行其输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interceptor 2
interceptor 1
Uncaught (in promise) baddie!
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;请求取消的实现&lt;/h3&gt;
&lt;p&gt;按照 axios 的实现思路，要实现请求的取消，需要先创建一个 token，通过该 token 可调用一个 &lt;code&gt;cancel&lt;/code&gt; 方法；通过将 token 传递到配置中，在发起请求时对 token 进行检查以判定该 token 是否执行过取消，如果是则利用上面的思路，将 Promise 链中断掉。&lt;/p&gt;
&lt;h4&gt;构造 token&lt;/h4&gt;
&lt;p&gt;所以不难看出，这里的 token 对象至少：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有一个 &lt;code&gt;cancel&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;有一个字段记录 &lt;code&gt;cancel&lt;/code&gt; 方法是否被调用过&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;额外地，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果有一个字段记录取消的原因，那也不错。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由此我们得到这么一个类：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;CancelTokenSource&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; _canceled &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;get&lt;/span&gt; canceled() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_canceled&lt;/span&gt;;
  }
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; _message &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;unknown reason&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;get&lt;/span&gt; message() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_message&lt;/span&gt;;
  }

  cancel(&lt;span class=&quot;pl-v&quot;&gt;reason&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;canceled&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;reason&lt;/span&gt;) {
      &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_message&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;reason&lt;/span&gt;;
    }
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_canceled&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;添加 token 到配置&lt;/h4&gt;
&lt;p&gt;扩展配置，以接收一个用来取消的 token 对象：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
interface Config {
  url: string;
  method: &quot;GET&quot; | &quot;POST&quot;;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  cancelToken?: CancelTokenSource;&lt;/span&gt;
  interceptors?: {
    request: Interceptor&amp;lt;Config&amp;gt;[];
    response: Interceptor&amp;lt;any&amp;gt;[];
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;请求逻辑中处理取消&lt;/h4&gt;
&lt;p&gt;同时更新 &lt;code&gt;xmlHttpRequest&lt;/code&gt; 函数，判断 token 的状态是否调用过取消，如果是则调用 &lt;code&gt;xhr.abort()&lt;/code&gt;，同时添加 &lt;code&gt;onabort&lt;/code&gt; 回调以 reject 掉 Promise:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
function xmlHttpRequest&amp;lt;T&amp;gt;(config: Config) {
  return new Promise&amp;lt;T&amp;gt;((resolve, reject) =&amp;gt; {
    const xhr = new XMLHttpRequest();
    xhr.open(config.method, config.url);
    xhr.onload = () =&amp;gt; {
      resolve(xhr.responseText as any);
    };
    xhr.onerror = err =&amp;gt; {
      reject(err);
    };
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    xhr.onabort = () =&amp;gt; {&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      reject();&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    };&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    if (config.cancelToken) {&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      xhr.abort();&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    }&lt;/span&gt;
    xhr.send();
  });
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;取消的调用&lt;/h4&gt;
&lt;p&gt;将抛异常的代码抽取成方法以在多处调用，更新 &lt;code&gt;adapter&lt;/code&gt; 的逻辑，在没有取消的情况下正常返回和 reject。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; throwIfCancelRequested(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;canceled&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;;
  }
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; adapter(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;throwIfCancelRequested&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;xmlHttpRequest&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(
    &lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;throwIfCancelRequested&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;;
    },
    &lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;throwIfCancelRequested&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
    }
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;测试请求的取消&lt;/h4&gt;
&lt;p&gt;似乎一切 okay，接下来测试一波。以下代码期望每次点击按钮发起请求，请求前先取消掉之前的请求。为了区分每次不同的请求，添加 &lt;code&gt;index&lt;/code&gt; 变量，按钮点击时自增。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;21&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;, { &lt;span class=&quot;pl-smi&quot;&gt;useEffect&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;useState&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;react&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; App() {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; [index, setIndex] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;useState&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;);

  &lt;span class=&quot;pl-en&quot;&gt;useEffect&lt;/span&gt;(() &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; token &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;CancelTokenSource&lt;/span&gt;();
    &lt;span class=&quot;pl-en&quot;&gt;request&lt;/span&gt;({
      url: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;https://dog.ceo/api/breeds/image/random&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
      method: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
      cancelToken: &lt;span class=&quot;pl-smi&quot;&gt;token&lt;/span&gt;,
      interceptors: {
        request: [&lt;span class=&quot;pl-smi&quot;&gt;interceptor1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;interceptor2&lt;/span&gt;],
        response: [&lt;span class=&quot;pl-smi&quot;&gt;interceptor3&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;interceptor4&lt;/span&gt;]
      }
    })
      .&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;load ${&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;} success&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
      })
      .&lt;span class=&quot;pl-c1&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;outer catch &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
      });

    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-smi&quot;&gt;token&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;cancel&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;just cancel ${&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;}&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    };
  }, [&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;]);

  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
    &amp;lt;&lt;span class=&quot;pl-en&quot;&gt;div&lt;/span&gt;&amp;gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;button&lt;/span&gt;
        &lt;span class=&quot;pl-smi&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{() =&amp;gt; {
          setIndex(&lt;span class=&quot;pl-v&quot;&gt;index&lt;/span&gt; + 1);
        }}
      &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;pl-smi&quot;&gt;click&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;me&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加载页面进行测试，&lt;code&gt;useEffect&lt;/code&gt; 会在页面加载后首次运行，会触发一次完整的请求流程。然后连续点击两次按钮，以取消掉两次中的前一次。运行结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;success&lt;/span&gt;

&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;outer&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt;  &lt;span class=&quot;pl-smi&quot;&gt;just&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;success&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;现有实现中的问题&lt;/h4&gt;
&lt;p&gt;从输出来看，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一部分为首次请求，是一次正常的请求。&lt;/li&gt;
&lt;li&gt;第二部分为第一次点击的请求拦截器的执行。&lt;/li&gt;
&lt;li&gt;第三部分为第二次点击，将第一次请求进行了取消，然后完成一次完整的请求。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从输出和网络请求来看，有两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;xhr.abort()&lt;/code&gt; 没有生效，连续的两次点击中，浏览器调试工具中会有两条状态为 200 的请求。&lt;/li&gt;
&lt;li&gt;第一条请求后续的回调确实被取消掉了，但它是在等待请求成功后，在成功回调中取消的，这点可通过在取消函数中添加标志位来查看。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; throwIfCancelRequested(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;canceled&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;flag&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;;
  }
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; adapter(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;throwIfCancelRequested&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;xmlHttpRequest&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(
    &lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;ℹ 后续输出证明，实际生效的是此处&lt;/span&gt;
      &lt;span class=&quot;pl-en&quot;&gt;throwIfCancelRequested&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;;
    },
    &lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;ℹ 而非此处，即使取消的动作是在请求进行过程中&lt;/span&gt;
      &lt;span class=&quot;pl-en&quot;&gt;throwIfCancelRequested&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
    }
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;outer&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt;  &lt;span class=&quot;pl-smi&quot;&gt;just&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;success&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;优化&lt;/h4&gt;
&lt;p&gt;下面的优化需要解决上面的问题。所用到的方法便是 &lt;a href=&quot;https://github.com/axios/axios/blob/master/lib/cancel/CancelToken.js#L17&quot;&gt;axios 中的逻辑&lt;/a&gt;，也是一开始看源码会不太理解的地方。&lt;/p&gt;
&lt;p&gt;其实外部调用 &lt;code&gt;cancel()&lt;/code&gt; 的时机并不确定，所以 token 对象上记录其是否被取消的字段，何时被置为 &lt;code&gt;true&lt;/code&gt; 是不确定的，因此，我们取消请求的逻辑（&lt;code&gt;xhr.abort()&lt;/code&gt;）应该是在一个 Promise 中来完成。&lt;/p&gt;
&lt;p&gt;因此，在 &lt;code&gt;CancelTokenSource&lt;/code&gt; 类中，创建一个 Promise 类型的字段，它会在 &lt;code&gt;cancel()&lt;/code&gt; 方法被调用的时候 resolve 掉。&lt;/p&gt;
&lt;p&gt;更新后的 &lt;code&gt;CancelTokenSource&lt;/code&gt; 类：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;CancelTokenSource&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; promise&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;unknown&lt;/span&gt;&amp;gt;;
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; resolvePromise&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;pl-v&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;void&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;constructor&lt;/span&gt;() {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;promise&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;resolve&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;resolvePromise&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;resolve&lt;/span&gt;;
    });
  }
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; _canceled &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;get&lt;/span&gt; canceled() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_canceled&lt;/span&gt;;
  }
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; _message &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;unknown reason&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;get&lt;/span&gt; message() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_message&lt;/span&gt;;
  }

  cancel(&lt;span class=&quot;pl-v&quot;&gt;reason&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;reason&lt;/span&gt;) {
      &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_message&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;reason&lt;/span&gt;;
    }
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_canceled&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;resolvePromise&lt;/span&gt;();
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后访问 &lt;code&gt;canceled&lt;/code&gt; 字段的逻辑：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; xmlHttpRequest&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;((&lt;span class=&quot;pl-v&quot;&gt;resolve&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;reject&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; xhr &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;XMLHttpRequest&lt;/span&gt;();
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;method&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;url&lt;/span&gt;);
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;responseText&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;);
    };
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
    };
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onabort&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;reject&lt;/span&gt;();
    };
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;) {
      &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(() &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;abort&lt;/span&gt;();
      });
    }
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;send&lt;/span&gt;();
  });
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;测试优化后的版本&lt;/h4&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interceptor 2
interceptor 1
interceptor 3
interceptor 4
load 0 success

interceptor 2
interceptor 1

interceptor 2
3
interceptor 1
outer catch  just cancel 1
interceptor 3
interceptor 4
load 2 success
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器调试工具的网络会有一次飘红被 &lt;code&gt;abort&lt;/code&gt; 掉的请求，同时上面的输出（生效的地方是 3 而非 2）显示被取消的请求正确地 reject 掉了。&lt;/p&gt;
&lt;h2&gt;完整代码&lt;/h2&gt;
&lt;details readability=&quot;12.5&quot;&gt;自己实现的请求取消机制完整代码
&lt;div class=&quot;highlight highlight-source-tsx&quot; readability=&quot;30&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;, { &lt;span class=&quot;pl-smi&quot;&gt;useState&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;useEffect&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;react&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;CancelTokenSource&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; promise&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;unknown&lt;/span&gt;&amp;gt;;
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; resolvePromise&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;pl-v&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;void&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;constructor&lt;/span&gt;() {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;promise&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;resolve&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;resolvePromise&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;resolve&lt;/span&gt;;
    });
  }
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; _canceled &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;get&lt;/span&gt; canceled() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_canceled&lt;/span&gt;;
  }
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; _message &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;unknown reason&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;get&lt;/span&gt; message() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_message&lt;/span&gt;;
  }

  cancel(&lt;span class=&quot;pl-v&quot;&gt;reason&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;reason&lt;/span&gt;) {
      &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_message&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;reason&lt;/span&gt;;
    }
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_canceled&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;resolvePromise&lt;/span&gt;();
  }
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Interceptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;pl-v&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;;

&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt; {
  url&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  method&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;POST&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  cancelToken&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;CancelTokenSource&lt;/span&gt;;
  interceptors&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
    request&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Interceptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;&amp;gt;[];
    response&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Interceptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;[];
  };
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; interceptor1(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 1&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;;
}
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; interceptor2(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 2&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; interceptor3&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 3&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; interceptor4&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;interceptor 4&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; xmlHttpRequest&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;((&lt;span class=&quot;pl-v&quot;&gt;resolve&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;reject&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; xhr &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;XMLHttpRequest&lt;/span&gt;();
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;method&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;url&lt;/span&gt;);
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;responseText&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;);
    };
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
    };
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;onabort&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;reject&lt;/span&gt;();
    };
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;) {
      &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(() &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;abort&lt;/span&gt;();
      });
    }
    &lt;span class=&quot;pl-smi&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;send&lt;/span&gt;();
  });
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; throwIfCancelRequested(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;canceled&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;flag&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;cancelToken&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;;
  }
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; adapter(&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;throwIfCancelRequested&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;xmlHttpRequest&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(
    &lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;throwIfCancelRequested&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;;
    },
    &lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;throwIfCancelRequested&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
    }
  );
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; request&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;({
  &lt;span class=&quot;pl-v&quot;&gt;interceptors&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; { request: [], response: [] },
  &lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;config&lt;/span&gt;
}&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Config&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; tmpInterceptors&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Interceptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt;[] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;pl-smi&quot;&gt;adapter&lt;/span&gt;];
  &lt;span class=&quot;pl-smi&quot;&gt;interceptors&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-smi&quot;&gt;tmpInterceptors&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;unshift&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt;);
  });

  &lt;span class=&quot;pl-smi&quot;&gt;interceptors&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-smi&quot;&gt;tmpInterceptors&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt;);
  });

  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; chain&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;&amp;gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;config&lt;/span&gt;);
  &lt;span class=&quot;pl-smi&quot;&gt;tmpInterceptors&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;interceptor&lt;/span&gt;)));
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; App() {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; [index, setIndex] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;useState&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;);

  &lt;span class=&quot;pl-en&quot;&gt;useEffect&lt;/span&gt;(() &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; token &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;CancelTokenSource&lt;/span&gt;();
    &lt;span class=&quot;pl-en&quot;&gt;request&lt;/span&gt;({
      url: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;https://dog.ceo/api/breeds/image/random&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
      method: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;GET&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
      cancelToken: &lt;span class=&quot;pl-smi&quot;&gt;token&lt;/span&gt;,
      interceptors: {
        request: [&lt;span class=&quot;pl-smi&quot;&gt;interceptor1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;interceptor2&lt;/span&gt;],
        response: [&lt;span class=&quot;pl-smi&quot;&gt;interceptor3&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;interceptor4&lt;/span&gt;]
      }
    })
      .&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;load ${&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;} success&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
      })
      .&lt;span class=&quot;pl-c1&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;outer catch &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;);
      });

    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-smi&quot;&gt;token&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;cancel&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;just cancel ${&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;}&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    };
  }, [&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;]);

  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;button&lt;/span&gt;
        &lt;span class=&quot;pl-e&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;{&lt;/span&gt;() &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
          &lt;span class=&quot;pl-en&quot;&gt;setIndex&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
        }&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;
      &amp;gt;
        click me
      &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;button&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/66497136-99811380-eaee-11e9-963d-5d8fd664562f.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/66497136-99811380-eaee-11e9-963d-5d8fd664562f.gif&quot; alt=&quot;运行效果&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;运行效果&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Wed, 09 Oct 2019 17:02:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>axios 中一个请求取消的示例： axios 取消请求的示例代码 import React, { useState, useEffect } from 'react'; import axios,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/axios_promise_chain_and_request_cancelation.html</dc:identifier>
</item>
<item>
<title>夯实Java基础系列23：一文读懂继承、封装、多态的底层实现原理 - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/11645103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/11645103.html</guid>
<description>&lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; class=&quot;uri&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;www.how2playlife.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;从jvm结构开始谈多态&quot;&gt;从JVM结构开始谈多态&lt;/h2&gt;
&lt;p&gt;Java 对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用和接口引用调用的实现则有所不同。总体而言，当某个方法被调用时，JVM 首先要查找相应的常量池，得到方法的符号引用，并查找调用类的方法表以确定该方法的直接引用，最后才真正调用该方法。以下分别对该过程中涉及到的相关部分做详细介绍。&lt;/p&gt;
&lt;h3 id=&quot;jvm-的结构&quot;&gt;JVM 的结构&lt;/h3&gt;
&lt;p&gt;典型的 Java 虚拟机的运行时结构如下图所示&lt;/p&gt;
&lt;p&gt;图 1.JVM 运行时结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201910/1092007-20191009233109851-817953490.jpg&quot; alt=&quot;图 1.JVM 运行时结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此结构中，我们只探讨和本文密切相关的方法区 (method area)。当程序运行需要某个类的定义时，载入子系统 (class loader subsystem) 装入所需的 class 文件，并在内部建立该类的类型信息，这个类型信息就存贮在方法区。类型信息一般包括该类的方法代码、类变量、成员变量的定义等等。可以说，类型信息就是类的 Java 文件在运行时的内部结构，包含了改类的所有在 Java 文件中定义的信息。&lt;/p&gt;
&lt;p&gt;注意到，该类型信息和 class 对象是不同的。class 对象是 JVM 在载入某个类后于堆 (heap) 中创建的代表该类的对象，可以通过该 class 对象访问到该类型信息。比如最典型的应用，在 Java 反射中应用 class 对象访问到该类支持的所有方法，定义的成员变量等等。可以想象，JVM 在类型信息和 class 对象中维护着它们彼此的引用以便互相访问。两者的关系可以类比于进程对象与真正的进程之间的关系。&lt;/p&gt;
&lt;h3 id=&quot;java-的方法调用方式&quot;&gt;Java 的方法调用方式&lt;/h3&gt;
&lt;p&gt;Java 的方法调用有两类，动态方法调用与静态方法调用。静态方法调用是指对于类的静态方法的调用方式，是静态绑定的；而动态方法调用需要有方法调用所作用的对象，是动态绑定的。类调用 (invokestatic) 是在编译时刻就已经确定好具体调用方法的情况，而实例调用 (invokevirtual) 则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。&lt;/p&gt;
&lt;p&gt;JVM 的方法调用指令有四个，分别是 invokestatic，invokespecial，invokesvirtual 和 invokeinterface。前两个是静态绑定，后两个是动态绑定的。本文也可以说是对于 JVM 后两种调用实现的考察。&lt;/p&gt;
&lt;h3 id=&quot;常量池constant-pool&quot;&gt;常量池（constant pool）&lt;/h3&gt;
&lt;p&gt;常量池中保存的是一个 Java 类引用的一些常量信息，包含一些字符串常量及对于类的符号引用信息等。Java 代码编译生成的类文件中的常量池是静态常量池，当类被载入到虚拟机内部的时候，在内存中产生类的常量池叫运行时常量池。&lt;/p&gt;
&lt;p&gt;常量池在逻辑上可以分成多个表，每个表包含一类的常量信息，本文只探讨对于 Java 调用相关的常量池表。&lt;/p&gt;
&lt;p&gt;CONSTANT_Utf8_info&lt;/p&gt;
&lt;p&gt;字符串常量表，该表包含该类所使用的所有字符串常量，比如代码中的字符串引用、引用的类名、方法的名字、其他引用的类与方法的字符串描述等等。其余常量池表中所涉及到的任何常量字符串都被索引至该表。&lt;/p&gt;
&lt;p&gt;CONSTANT_Class_info&lt;/p&gt;
&lt;p&gt;类信息表，包含任何被引用的类或接口的符号引用，每一个条目主要包含一个索引，指向 CONSTANT_Utf8_info 表，表示该类或接口的全限定名。&lt;/p&gt;
&lt;p&gt;CONSTANT_NameAndType_info&lt;/p&gt;
&lt;p&gt;名字类型表，包含引用的任意方法或字段的名称和描述符信息在字符串常量表中的索引。&lt;/p&gt;
&lt;p&gt;CONSTANT_InterfaceMethodref_info&lt;/p&gt;
&lt;p&gt;接口方法引用表，包含引用的任何接口方法的描述信息，主要包括类信息索引和名字类型索引。&lt;/p&gt;
&lt;p&gt;CONSTANT_Methodref_info&lt;/p&gt;
&lt;p&gt;类方法引用表，包含引用的任何类型方法的描述信息，主要包括类信息索引和名字类型索引。&lt;/p&gt;
&lt;h5 id=&quot;图-2.-常量池各表的关系&quot;&gt;图 2. 常量池各表的关系&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201910/1092007-20191009233110711-1683933133.jpg&quot; alt=&quot;图 2. 常量池各表的关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，给定任意一个方法的索引，在常量池中找到对应的条目后，可以得到该方法的类索引（class_index）和名字类型索引 (name_and_type_index), 进而得到该方法所属的类型信息和名称及描述符信息（参数，返回值等）。注意到所有的常量字符串都是存储在 CONSTANT_Utf8_info 中供其他表索引的。&lt;/p&gt;
&lt;h3 id=&quot;方法表与方法调用&quot;&gt;方法表与方法调用&lt;/h3&gt;
&lt;p&gt;方法表是动态调用的核心，也是 Java 实现动态调用的主要方式。它被存储于方法区中的类型信息，包含有该类型所定义的所有方法及指向这些方法代码的指针，注意这些具体的方法代码可能是被覆写的方法，也可能是继承自基类的方法。&lt;/p&gt;
&lt;p&gt;如有类定义 Person, Girl, Boy,&lt;/p&gt;
&lt;h5 id=&quot;清单-1&quot;&gt;清单 1&lt;/h5&gt;
&lt;pre name=&quot;code&quot;&gt;
 class Person { 
 public String toString(){ 
    return &quot;I'm a person.&quot;; 
     } 
 public void eat(){} 
 public void speak(){} 

 } 

 class Boy extends Person{ 
 public String toString(){ 
    return &quot;I'm a boy&quot;; 
     } 
 public void speak(){} 
 public void fight(){} 
 } 

 class Girl extends Person{ 
 public String toString(){ 
    return &quot;I'm a girl&quot;; 
     } 
 public void speak(){} 
 public void sing(){} 
 }
&lt;/pre&gt;
&lt;p&gt;当这三个类被载入到 Java 虚拟机之后，方法区中就包含了各自的类的信息。Girl 和 Boy 在方法区中的方法表可表示如下：&lt;/p&gt;
&lt;p&gt;图 3.Boy 和 Girl 的方法表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201910/1092007-20191009233111850-1219600743.jpg&quot; alt=&quot;图 3.Boy 和 Girl 的方法表&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，Girl 和 Boy 的方法表包含继承自 Object 的方法，继承自直接父类 Person 的方法及各自新定义的方法。注意方法表条目指向的具体的方法地址，如 Girl 的继承自 Object 的方法中，只有 toString() 指向自己的实现（Girl 的方法代码），其余皆指向 Object 的方法代码；其继承自于 Person 的方法 eat() 和 speak() 分别指向 Person 的方法实现和本身的实现。&lt;/p&gt;
&lt;p&gt;Person 或 Object 的任意一个方法，在它们的方法表和其子类 Girl 和 Boy 的方法表中的位置 (index) 是一样的。这样 JVM 在调用实例方法其实只需要指定调用方法表中的第几个方法即可。&lt;/p&gt;
&lt;p&gt;如调用如下：&lt;/p&gt;
&lt;p&gt;清单 2&lt;/p&gt;
&lt;pre name=&quot;code&quot;&gt;
 class Party{ 
…
 void happyHour(){ 
 Person girl = new Girl(); 
 girl.speak(); 
…
     } 
 }
&lt;/pre&gt;
&lt;p&gt;当编译 Party 类的时候，生成 &lt;code&gt;girl.speak()&lt;/code&gt;的方法调用假设为：&lt;/p&gt;
&lt;p&gt;Invokevirtual #12&lt;/p&gt;
&lt;p&gt;设该调用代码对应着 girl.speak(); #12 是 Party 类的常量池的索引。JVM 执行该调用指令的过程如下所示：&lt;/p&gt;
&lt;p&gt;图 4. 解析调用过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201910/1092007-20191009233112830-1336931041.jpg&quot; alt=&quot;图 4. 解析调用过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JVM 首先查看 Party 的常量池索引为 12 的条目（应为 CONSTANT_Methodref_info 类型，可视为方法调用的符号引用），进一步查看常量池（CONSTANT_Class_info，CONSTANT_NameAndType_info ，CONSTANT_Utf8_info）可得出要调用的方法是 Person 的 speak 方法（注意引用 girl 是其基类 Person 类型），查看 Person 的方法表，得出 speak 方法在该方法表中的偏移量 15（offset），这就是该方法调用的直接引用。&lt;/p&gt;
&lt;p&gt;当解析出方法调用的直接引用后（方法表偏移量 15），JVM 执行真正的方法调用：根据实例方法调用的参数 this 得到具体的对象（即 girl 所指向的位于堆中的对象），据此得到该对象对应的方法表 (Girl 的方法表 )，进而调用方法表中的某个偏移量所指向的方法（Girl 的 speak() 方法的实现）。&lt;/p&gt;
&lt;h3 id=&quot;接口调用&quot;&gt;接口调用&lt;/h3&gt;
&lt;p&gt;因为 Java 类是可以同时实现多个接口的，而当用接口引用调用某个方法的时候，情况就有所不同了。Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同样的方法在基类和派生类的方法表的位置就可能不一样了。&lt;/p&gt;
&lt;p&gt;清单 3&lt;/p&gt;
&lt;pre name=&quot;code&quot;&gt;
interface IDance{ 
   void dance(); 
 } 

 class Person { 
 public String toString(){ 
   return &quot;I'm a person.&quot;; 
     } 
 public void eat(){} 
 public void speak(){} 

 } 

 class Dancer extends Person 
 implements IDance { 
 public String toString(){ 
   return &quot;I'm a dancer.&quot;; 
     } 
 public void dance(){} 
 } 

 class Snake implements IDance{ 
 public String toString(){ 
   return &quot;A snake.&quot;; 
     } 
 public void dance(){ 
 //snake dance 
     } 
 }
&lt;/pre&gt;
&lt;h5 id=&quot;图-5.dancer-的方法表查看大图&quot;&gt;图 5.Dancer 的方法表（&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-polymorph/image011.jpg&quot;&gt;查看大图&lt;/a&gt;）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201910/1092007-20191009233113525-1441806973.jpg&quot; alt=&quot;图 5.Dancer 的方法表&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，由于接口的介入，继承自于接口 IDance 的方法 dance（）在类 Dancer 和 Snake 的方法表中的位置已经不一样了，显然我们无法通过给出方法表的偏移量来正确调用 Dancer 和 Snake 的这个方法。这也是 Java 中调用接口方法有其专有的调用指令（invokeinterface）的原因。&lt;/p&gt;
&lt;p&gt;Java 对于接口方法的调用是采用搜索方法表的方式，对如下的方法调用&lt;/p&gt;
&lt;p&gt;invokeinterface #13&lt;/p&gt;
&lt;p&gt;JVM 首先查看常量池，确定方法调用的符号引用（名称、返回值等等），然后利用 this 指向的实例得到该实例的方法表，进而搜索方法表来找到合适的方法地址。&lt;/p&gt;
&lt;p&gt;因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的。&lt;/p&gt;
&lt;p&gt;执行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201910/1092007-20191009233114424-1516436963.png&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;可以看到&lt;code&gt;System.out.println(dancer);&lt;/code&gt; 调用的是Person的toString方法。&lt;/p&gt;
&lt;h2 id=&quot;继承的实现原理&quot;&gt;继承的实现原理&lt;/h2&gt;
&lt;p&gt;Java 的继承机制是一种复用类的技术，从原理上来说，是更好的使用了组合技术，因此要理解继承，首先需要了解类的组合技术是如何实现类的复用的。&lt;/p&gt;
&lt;p&gt;使用组合技术复用类&lt;br/&gt;假设现在的需求是要创建一个具有基本类型，String 类型以及一个其他非基本类型的对象。该如何处理呢？&lt;/p&gt;
&lt;p&gt;对于基本类型的变量，在新类中成员变量处直接定义即可，但对于非基本类型变量，不仅需要在类中声明其引用，并且还需要手动初始化这个对象。&lt;/p&gt;
&lt;p&gt;这里需要注意的是，编译器并不会默认将所有的引用都创建对象，因为这样的话在很多情况下会增加不必要的负担，因此，在合适的时机初始化合适的对象，可以通过以下几个位置做初始化操作：&lt;/p&gt;
&lt;p&gt;在定义对象的地方，先于构造方法执行。&lt;br/&gt;在构造方法中。&lt;br/&gt;在正要使用之前，这个被称为惰性初始化。&lt;br/&gt;使用实例初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Soap {
    private String s;
    Soap() {
        System.out.println(&quot;Soap()&quot;);
        s = &quot;Constructed&quot;;
    }
    public String tiString(){
        return s;
    }
}

public class Bath {
    // s1 初始化先于构造函数
    private String s1 = &quot;Happy&quot;, s2 = &quot;Happy&quot;, s3, s4;
    private Soap soap;
    private int i;
    private float f;
    
    public Both() {
        System.out.println(&quot;inSide Both&quot;);
        s3 = &quot;Joy&quot;;
        f = 3.14f;
        soap = new Soap();
    }
    
    {
        i = 88;
    }
    
    public String toString() {
        if(s4 == null){
            s4 = &quot;Joy&quot;
        }
        return &quot;s1 = &quot; + s1 +&quot;\n&quot; +
               &quot;s2 = &quot; + s2 +&quot;\n&quot; +
               &quot;s3 = &quot; + s3 +&quot;\n&quot; +
               &quot;s4 = &quot; + s4 +&quot;\n&quot; +
               &quot;i = &quot; + i +&quot;\n&quot; +
               &quot;f = &quot; + f +&quot;\n&quot; +
               &quot;soap = &quot; + soap;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承&lt;br/&gt;Java 中的继承由 extend 关键字实现，组合的语法比较平实，而继承是一种特殊的语法。当一个类继承自另一个类时，那么这个类就可以拥有另一个类的域和方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Cleanser{
    private String s = &quot;Cleanser&quot;;
    
    public void append(String a){
        s += a;
    }
    public void apply(){
        append(&quot;apply&quot;);
    }
    public void scrub(){
        append(&quot;scrub&quot;);
    }
    public String toString(){
        return s;
    }
    public static void main(String args){
        Cleanser c = new Cleanser();
        
        c.apply();
        System.out.println(c);
    }
}

public class Deter extends Cleanser{
    public void apply(){
        append(&quot;Deter.apply&quot;);
        super.scrub();
    }
    public void foam(){
        append(&quot;foam&quot;);
    }
    public static void main(String args){
        Deter d = new Deter();
        
        d.apply();
        d.scrub();
        d.foam();
        System.out.println(d);
        Cleanser.main(args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，展示了继承语法中的一些特性：&lt;/p&gt;
&lt;p&gt;子类可以直接使用父类中公共的方法和成员变量（通常为了保护数据域，成员变量均为私有）&lt;br/&gt;子类中可以覆盖父类中的方法，也就是子类重写了父类的方法，此时若还需要调用被覆盖的父类的方法，则需要用到 super 来指定是调用父类中的方法。&lt;br/&gt;子类中可以自定义父类中没有的方法。&lt;br/&gt;可以发现上面两个类中均有 main 方法，命令行中调用的哪个类就执行哪个类的 main 方法，例如：java Deter。&lt;br/&gt;继承语法的原理&lt;br/&gt;接下来我们将通过创建子类对象来分析继承语法在我们看不到的地方做了什么样的操作。&lt;/p&gt;
&lt;p&gt;可以先思考一下，如何理解使用子类创建的对象呢，首先这个对象中包含子类的所有信息，但是也包含父类的所有公共的信息。&lt;/p&gt;
&lt;p&gt;下面来看一段代码，观察一下子类在创建对象初始化的时候，会不会用到父类相关的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Art{
    Art() {
        System.out.println(&quot;Art Construct&quot;);
    }
}

class Drawing extends Art {
    Drawing() {
        System.out.println(&quot;Drawing Construct&quot;);
    }
}

public class Cartoon extends Drawing {
    public Cartoon() {
        System.out.println(&quot;Cartoon construct&quot;);
    }
    public void static main(String args) {
        Cartoon c = new Cartoon();
    }
}
/*output:
Art Construct
Drawing Construct
Cartoon construct
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过观察代码可以发现，在实例化Cartoon时，事实上是从最顶层的父类开始向下逐个实例化，也就是最终实例化了三个对象。编译器会默认在子类的构造方法中增加调用父类默认构造方法的代码。&lt;/p&gt;
&lt;p&gt;因此，继承可以理解为编译器帮我们完成了类的特殊组合技术，即在子类中存在一个父类的对象，使得我们可以用子类对象调用父类的方法。而在开发者看来只不过是使用了一个关键字。&lt;/p&gt;
&lt;p&gt;注意：虽然继承很接近组合技术，但是继承拥有其他更多的区别于组合的特性，例如父类的对象我们是不可见的，对于父类中的方法也做了相应的权限校验等。&lt;/p&gt;
&lt;p&gt;那么，如果类中的构造方法是带参的，该如何操作呢？（使用super关键字显示调用）&lt;/p&gt;
&lt;p&gt;见代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Game {
    Game(int i){
        System.out.println(&quot;Game Construct&quot;);
    }
}

class BoardGame extends Game {
    BoardGame(int j){
        super(j);
        System.out.println(&quot;BoardGame Construct&quot;);
    }
}
public class Chess extends BoardGame{
    Chess(){
        super(99);
        System.out.println(&quot;Chess construct&quot;);
    }
    public static void main(String args) {
        Chess c = new Chess();
    }
}
/*output:
Game Construct
BoardGame Construct
Chess construc
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重载和重写的实现原理&quot;&gt;重载和重写的实现原理&lt;/h2&gt;
&lt;p&gt;    刚开始学习Java的时候，就了解了Java这个比较有意思的特性：重写 和 重载。开始的有时候从名字上还总是容易弄混。我相信熟悉Java这门语言的同学都应该了解这两个特性，可能只是从语言层面上了解这种写法，但是jvm是如何实现他们的呢 ?&lt;/p&gt;
&lt;p&gt;重载官方给出的介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;一.  overload:&lt;br/&gt;The Java programming language supports overloading methods, and Java can distinguish between methods with different method signatures. This means that methods within a class can have the same name if they have different parameter lists .&lt;/p&gt;
&lt;p&gt;Overloaded methods are differentiated by the number and the type of the arguments passed into the method.&lt;/p&gt;
&lt;p&gt;You cannot declare more than one method with the same name and the same number and type of arguments, because the compiler cannot tell them apart.&lt;/p&gt;
&lt;p&gt;The compiler does not consider return type when differentiating methods, so you cannot declare two methods with the same signature even if they have a different return type.&lt;/p&gt;
&lt;p&gt;首先看一段代码，来看看代码的执行结果：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;public class OverrideTest {
 
    class Father{}
 
    class Sun extends Father {}
 
    public void doSomething(Father father){
        System.out.println(&quot;Father do something&quot;);
    }
 
    public void doSomething(Sun father){
        System.out.println(&quot;Sun do something&quot;);
    }
 
    public static void main(String [] args){
        OverrideTest overrideTest = new OverrideTest();
        Father sun = overrideTest.new Sun();
        Father father = overrideTest.new Father();
        overrideTest.doSomething(father);
        overrideTest.doSomething(sun);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看下这段代码的执行结果，最后会打印：&lt;/p&gt;
&lt;p&gt;Father do something&lt;br/&gt;Father do something&lt;/p&gt;
&lt;p&gt;为什么会打印出这样的结果呢？ 首先要介绍两个概念：静态分派和动态分派&lt;/p&gt;
&lt;p&gt;静态分派：依赖静态类型来定位方法执行版本的分派动作称为静态分派&lt;/p&gt;
&lt;p&gt;动态分派：运行期根据实际类型确定方法执行版本的分派过程。&lt;/p&gt;
&lt;p&gt;他们的区别是：&lt;/p&gt;
&lt;p&gt;1.  静态分派发生在编译期，动态分派发生在运行期；&lt;/p&gt;
&lt;p&gt;2.  private,static,final 方法发生在编译期，并且不能被重写，一旦发生了重写，将会在运行期处理。&lt;/p&gt;
&lt;p&gt;3.  重载是静态分派，重写是动态分派&lt;/p&gt;
&lt;p&gt;回到上面的问题，因为重载是发生在编译期，所以在编译期已经确定两次 doSomething 方法的参数都是Father类型，在class文件中已经指向了Father类的符号引用，所以最后会打印两次Father do something。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;二. override:&lt;br/&gt;An instance method in a subclass with the same signature (name, plus the number and the type of its parameters) and return type as an instance method in the superclass overrides the superclass's method.&lt;/p&gt;
&lt;p&gt;The ability of a subclass to override a method allows a class to inherit from a superclass whose behavior is &quot;close enough&quot; and then to modify behavior as needed. The overriding method has the same name, number and type of parameters, and return type as the method that it overrides. An overriding method can also return a subtype of the type returned by the overridden method. This subtype is called a covariant return type.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还是上面那个代码，稍微改动下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class OverrideTest {
 
    class Father{}
 
    class Sun extends Father {}
 
    public void doSomething(){
        System.out.println(&quot;Father do something&quot;);
    }
 
    public void doSomething(){
        System.out.println(&quot;Sun do something&quot;);
    }
 
    public static void main(String [] args){
        OverrideTest overrideTest = new OverrideTest();
        Father sun = overrideTest.new Sun();
        Father father = overrideTest.new Father();
        overrideTest.doSomething();
        overrideTest.doSomething();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​&lt;br/&gt;最后会打印：&lt;/p&gt;
&lt;p&gt;Father do something&lt;/p&gt;
&lt;p&gt;Sun do something&lt;/p&gt;

&lt;p&gt;相信大家都会知道这个结果，那么这个结果jvm是怎么实现的呢？&lt;/p&gt;
&lt;p&gt;在编译期，只会识别到是调用Father类的doSomething方法，到运行期才会真正找到对象的实际类型。&lt;/p&gt;
&lt;p&gt;首先该方法的执行，jvm会调用invokevirtual指令，该指令会找栈顶第一个元素所指向的对象的实际类型，如果该类型存在调用的方法，则会走验证流程，否则继续找其父类。这也是为什么子类可以直接调用父类具有访问权限的方法的原因。简而言之，就是在运行期才会去确定对象的实际类型，根据这个实际类型确定方法执行版本，这个过程称为动态分派。override 的实现依赖jvm的动态分派。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/dj_dengjian/article/details/80811348&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/dj_dengjian/article/details/80811348&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chenssy/article/details/12757911&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/chenssy/article/details/12757911&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fan2012huan/article/details/51007517&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/fan2012huan/article/details/51007517&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fan2012huan/article/details/50999777&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/fan2012huan/article/details/50999777&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/serendipity-fly/p/9469289.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/serendipity-fly/p/9469289.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_37264516/article/details/86709537&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/m0_37264516/article/details/86709537&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;微信公众号&quot;&gt;微信公众号&lt;/h2&gt;
&lt;h3 id=&quot;java技术江湖&quot;&gt;Java技术江湖&lt;/h3&gt;
&lt;p&gt;如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java工程师必备学习资源:&lt;/strong&gt; 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 &lt;strong&gt;“Java”&lt;/strong&gt; 即可免费无套路获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201910/1092007-20191009233114588-1857143244.jpg&quot; alt=&quot;我的公众号&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;个人公众号黄小斜&quot;&gt;个人公众号：黄小斜&lt;/h3&gt;
&lt;p&gt;作者是跨考软件工程的 985 硕士，自学 Java 两年，拿到了 BAT 等近十家大厂 offer，从技术小白成长为阿里工程师。&lt;/p&gt;
&lt;p&gt;作者专注于 JAVA 后端技术栈，热衷于分享程序员干货、学习经验、求职心得和程序人生，目前黄小斜的CSDN博客有百万+访问量，知乎粉丝2W+，全网已有10W+读者。&lt;/p&gt;
&lt;p&gt;黄小斜是一个斜杠青年，坚持学习和写作，相信终身学习的力量，希望和更多的程序员交朋友，一起进步和成长！&lt;/p&gt;
&lt;p&gt;关注公众号【黄小斜】后回复【原创电子书】即可领取我原创的电子书《菜鸟程序员修炼手册：从技术小白到阿里巴巴Java工程师》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序员3T技术学习资源：&lt;/strong&gt; 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 &lt;strong&gt;“资料”&lt;/strong&gt; 即可免费无套路获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1092007/201910/1092007-20191009233114739-433124464.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Oct 2019 15:31:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看 https://github.com/h2pl/Java Tutorial 喜欢的话麻烦点下Star哈</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xll1025/p/11645103.html</dc:identifier>
</item>
<item>
<title>浅谈Java的内存模型以及交互 - 张小云的博客</title>
<link>http://www.cnblogs.com/zhangweicheng/p/11638841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangweicheng/p/11638841.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文的内存模型只写虚拟机内存模型，物理机的不予描述。&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;　　在Java中，虚拟机将运行时区域分成6中，如下图：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191008230559030-1822616937.jpg&quot; alt=&quot;&quot; width=&quot;648&quot; height=&quot;380&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; &lt;strong&gt;程序计数器：&lt;/strong&gt;用来记录当前线程执行到哪一步操作。在多线程轮换的模式中，当当前线程时间片用完的时候记录当前操作到哪一步，重新获得时间片时根据此记录来恢复之前的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟机栈：&lt;/strong&gt;这就是我们平时所说的栈了，一般用来储存局部变量表、操作数表、动态链接等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地方法栈：&lt;/strong&gt;这是另一个栈，用来提供虚拟机中用到的本地服务，像线程中的start方法，JUC包里经常使用的CAS等方法都是从这来的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆：&lt;/strong&gt;主要的储存区域，平时所创建的对象都是放在这个区域。其内部还分为新生代、老年代和永久代（也就是方法区，在Java8之后删除了），新生代又分为两块Survivor和一块Eden，平时创建的对象其实都是在Eden区创建的，不过这些之后再跟垃圾回收器写在一篇文章。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法区：&lt;/strong&gt;储存符号引用、被JVM加载的类信息、静态变量的地方。在Java8之后方法区被移除，使用元空间来存放类信息，常量池和其他东西被移到堆中（其实在7的时候常量池和静态变量就已经被移到堆中），不再有永久代一说。删除的原因大致如下：
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;&lt;em&gt;容易造成内存溢出或内存泄漏，例如 web开发中JSP页面较多的情况。&lt;/em&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;em&gt;由于类和方法的信息难以确定，不好设定大小，太大则影响年老代，太小容易内存溢出。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;GC不好处理，回收效率低下，调优困难。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常量池：&lt;/strong&gt;存放final修饰的成员变量、直接定义的字符串（如 Sring s = &quot;test&quot;;这种）还有6种数据类型包装类型从-128~127对应的对象（这也解释了我们new两个在这区间的包装类型对象时，为什么他们是一样的，布尔类型存放的是true和false两种，浮点类型Double和Float因为精度问题不存入其中）等&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 在上面的6种类型中，前三种是&lt;strong&gt;线程私有&lt;/strong&gt;的，也就是说里面存放的值其他线程是看不到的，而后面三种（真正意义上讲只有堆一种）是&lt;strong&gt;线程之间共享&lt;/strong&gt;的，这里面的变量对于各个线程都是可见的。如下图所示，前三种存放在线程内存中，大家都是相互独立的，而主内存可以理解为堆内存（实际上只是堆内存中的对象实例数据部分，其他例如对象头和对象的填充数据并不算入在内），为线程之间共享：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191008235940953-1593375947.jpg&quot; alt=&quot;&quot; width=&quot;657&quot; height=&quot;367&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里的&lt;strong&gt;变量&lt;/strong&gt;指的是&lt;strong&gt;可以放在堆中的变量&lt;/strong&gt;，其他例如局部变量、方法参数这些并不算入在内。&lt;strong&gt;线程内存跟主内存&lt;/strong&gt;变量之间的交互是非常重要的，Java虚拟机把这些交互规范为以下&lt;strong&gt;8种操作&lt;/strong&gt;，每一种都是原子性的（非volatile修饰的Double和Long除外）操作。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Lock（锁）操作：&lt;/strong&gt;操作对象为线程，作用对象为主内存的变量，当一个变量被锁住的时候，其他线程只有等当前线程解锁之后才能使用，其他线程不能对该变量进行解锁操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unlock（解锁）操作：&lt;/strong&gt;同上，线程操作，作用于主内存变量，令一个被锁住的变量解锁，使得其他线程可以对此变量进行操作，不能对未锁住的变量进行解锁操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read（读）：&lt;/strong&gt;线程从主内存读取变量值，load操作根据此读取的变量值为线程内存中的变量副本赋值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Load（加载）：&lt;/strong&gt;将Read读取到的变量值赋到线程内存的副本中，供线程使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use（使用）：&lt;/strong&gt;读取线程内存的作用值，用来执行我们定义的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Assign（赋值）：&lt;/strong&gt;在线程操作中变量的值进行了改变，使用此操作刷新&lt;strong&gt;线程内存&lt;/strong&gt;的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Store（储存）：&lt;/strong&gt;将当前线程内存的变量值同步到主内存中，与write操作一起作用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write（写）：&lt;/strong&gt;将线程内存中store的值写入到主内存中，主内存中的变量值进行变更。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　可能有同学会不理解read和load、store和write的区别，觉得这两对的操作类似，可以这样理解：一个是申请操作，另一个是审核通过（允许赋值）。例如：线程内存A向主内存提交了变更变量的申请（&lt;strong&gt;store&lt;/strong&gt;操作），主内存通过之后修改变量的值（&lt;strong&gt;write&lt;/strong&gt;操作）。可以通过下面的图来理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191009213156848-129308951.jpg&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参照《深入理解Java虚拟机》&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191009214842024-945806624.png&quot; alt=&quot;&quot; width=&quot;789&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　对于普通的变量来说（非volatile修饰的变量），虚拟机要求read、load有相对顺序即可，例如从主内存读取i、j两个变量，可能的操作是read i-&amp;gt;read j-&amp;gt;load j-&amp;gt; load i，并不一定是连续的。此外虚拟机还为这8种操作定制了操作的规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;（read，load）、（store，write）不允许出现单独的操作。&lt;/strong&gt;也就是说这两种操作一定是以组的形式出现的，有&lt;strong&gt;read&lt;/strong&gt;就有&lt;strong&gt;load&lt;/strong&gt;，有&lt;strong&gt;store&lt;/strong&gt;就有&lt;strong&gt;write&lt;/strong&gt;，不能读取了变量值而不加载到线程内存中，也不能储存了变量值而不写到主内存中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不允许线程放弃最近的assign操作。&lt;/strong&gt;也就是说当线程使用assign操作对私有内存的变量副本进行了变更的时候，其必须使用write操作将其同步到主内存当中去。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不允许一个线程无原因地（没有进行assign操作）将私有内存的变量同步到主内存中。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变量必须从主内存产生，即不允许在私有内存中使用未初始化（未进行load或者assgin操作）的变量。&lt;/strong&gt;也就是说，在use之前必须保证执行了load操作，在store之前必须保证执行了assign操作，例如有成员变量a和局部变量b，如果想进行a = b的操作，必须先初始化b。（一开始说了，变量指的是可以放在堆内存的变量）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个变量一次只能同时允许一个线程对其进行lock操作。&lt;/strong&gt;一个主内存的变量被一个线程使用lock操作之后，在这个线程执行unlock操作之前，其他线程不能对此变量进行操作。但是一个线程可以对一个变量进行多次锁，只要最后释放锁的次数和加锁的次数一致才能解锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当线程使用lock操作时，清除所有私有内存的变量副本。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用unlock操作时，必须在此操作之前将变量同步到主内存当中。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不允许对没有进行lock操作的变量执行unlock操作，也不允许线程去unlock其他线程lock的变量。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　对于关键字&lt;strong&gt;volatile&lt;/strong&gt;，大家都知道其一般作为并发的轻量级关键字，并且具有&lt;strong&gt;两个重要的语义&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;保证内存的可见性：&lt;/strong&gt;使用volatile修饰的变量在变量值发生改变的时候，会立刻同步到主内存，并使其他线程的变量副本失效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;禁止指令重排序：&lt;/strong&gt;用volatile修饰的变量在代码语句的前后会加上一些内存屏障来禁止指令的重新排序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但这两个语义都是因为在使用&lt;strong&gt;volatile&lt;/strong&gt;关键字修饰变量的时候，内存间变量的交互规则会发生一些变化：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;在对变量执行use操作之前，其前一步操作必须为对该变量的load操作；在对变量执行load操作之前，其后一步操作必须为该变量的use操作。&lt;/strong&gt;也就是说，使用volatile修饰的变量其read、load、use都是连续出现的，所以每次使用变量的时候都要从主内存读取最新的变量值，替换私有内存的变量副本值（如果不同的话）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在对变量执行assign操作之前，其后一步操作必须为store；在对变量执行store之前，其前一步必须为对相同变量的assign操作。&lt;/strong&gt;也就是说，其对&lt;strong&gt;同一变量的&lt;/strong&gt;assign、store、write操作都是连续出现的，所以每次对变量的改变都会立马同步到主内存中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在主内存中有变量a、b，动作A为当前线程对变量a的use或者assign操作，动作B为与动作A对应load或store操作，动作C为与动作B对应的read或write操作；动作D为当前线程对变量b的use或assign操作，动作E为与D对应的load或store操作，动作F为与动作E对应的read或write操作；如果动作A先于动作D，那么动作C要先于动作F。&lt;/strong&gt;也就是说，如果当前线程对变量a执行的use或assign操作在对变量buse或assign之前执行的话，那么当前线程对变量a的read或write操作肯定要在对变量b的read或write操作之前执行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上面&lt;strong&gt;volatile&lt;/strong&gt;的特殊规则中，我们可以知道1、2条其实就是volatile&lt;strong&gt;内存可见性&lt;/strong&gt;的语义，第三条就是&lt;strong&gt;禁止指令重排序&lt;/strong&gt;的语义。另外还有其他的一些特殊规则，例如对于&lt;strong&gt;非volatile修饰&lt;/strong&gt;的double或者long这两个64位的数据类型中，虚拟机&lt;strong&gt;允许对其当做两次32位的操作来进行&lt;/strong&gt;，也就是说可以分解成&lt;strong&gt;非原子性&lt;/strong&gt;的两个操作，但是这种可能性出现的情况也相当的小。因为Java内存模型虽然允许这样子做，但却&lt;strong&gt;“强烈建议”虚拟机选择实现这两种类型操作的原子性&lt;/strong&gt;，所以平时不会出现读到“半个变量”的情况。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;volatile不具备原子性&lt;/h2&gt;
&lt;p&gt;　　虽然volatile修饰的变量可以&lt;strong&gt;强制刷新内存&lt;/strong&gt;，但是其并不具备原子性，稍加思考就可以理解，虽然其要求对变量的（read、load、use）、（assign、store、write）必须是连续出现，即以组的形式出现，但是这两组操作还是分开的。比如说，两个线程同时完成了第一组操作（read、load、use），但是还没进行第二组操作（assign、store、write），此时是没错的，然后两个线程开始第二组操作，这样最终其中一个线程的操作会被覆盖掉，导致数据的不准确。如果你觉得这是JOJO的奇妙比喻，可以看下面的代码来理解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestForVolatile {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建四个线程，每个线程对i执行一定次数的自增操作&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k++ &amp;lt; 10000&lt;span&gt;) {
                i&lt;/span&gt;++&lt;span&gt;;
            }
            System.err.println(&lt;/span&gt;&quot;线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;&lt;span&gt;);
        }).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k++ &amp;lt; 10000&lt;span&gt;) {
                i&lt;/span&gt;++&lt;span&gt;;
            }
            System.err.println(&lt;/span&gt;&quot;线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;&lt;span&gt;);
        }).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k++ &amp;lt; 10000&lt;span&gt;) {
                i&lt;/span&gt;++&lt;span&gt;;
            }
            System.err.println(&lt;/span&gt;&quot;线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;&lt;span&gt;);
        }).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k++ &amp;lt; 10000&lt;span&gt;) {
                i&lt;/span&gt;++&lt;span&gt;;
            }
            System.err.println(&lt;/span&gt;&quot;线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;&lt;span&gt;);
        }).start();
　　　　　// 睡眠一定时间确保四个线程全部执行完毕
        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);&lt;br/&gt;　　　　　　// 最终结果为33555，没有预期的4W
        System.out.println(i);&lt;br/&gt;　　　　　　
    }

}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 结果图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742516/201910/1742516-20191009225858707-1491090556.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　　解释一下：因为i++操作其实为i = i + 1，假设在主内存i = 99的时候同时有两个线程完成了第一组操作（read、load、use），也就是完成了&lt;strong&gt;等号后面变量i的读取操作&lt;/strong&gt;，这时候是没问题的，然后进行运算，都得出i+1=100的结果，接着&lt;strong&gt;对变量i进行赋值操作，这就开始第二组操作（assign、store、write）&lt;/strong&gt;，是不是同时赋值的无所谓，这样一来，两个线程都会以i = 100把值写到主内存中，也就是说，&lt;strong&gt;其中一个线程的操作结果会被覆盖&lt;/strong&gt;，相当于无效操作，这就导致上面程序最终结果的不准确。&lt;/p&gt;
&lt;p&gt;　　如果要保证原子性的话可以使用synchronize关键字，其可以保证&lt;strong&gt;原子性&lt;/strong&gt;和&lt;strong&gt;内存可见性&lt;/strong&gt;（但是不具备有&lt;strong&gt;禁止指令重排序&lt;/strong&gt;的语义，这也是为什么double-check的单例模式中，实例要用&lt;strong&gt;volatile&lt;/strong&gt;修饰的原因）；当然你也可以使用JUC包的原子类AtomicInteger之类的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　暂时写到这里，其他关于重排序、内存屏障和happens-before原则等内容后面再进行补充。如果文章有任何不对的地方望大家指出，感激不尽！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 09 Oct 2019 15:24:00 +0000</pubDate>
<dc:creator>张小云的博客</dc:creator>
<og:description>本文的内存模型只写虚拟机内存模型，物理机的不予描述。 Java内存模型 在Java中，虚拟机将运行时区域分成6中，如下图： 由于类和方法的信息难以确定，不好设定大小，太大则影响年老代，太小容易内存溢出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangweicheng/p/11638841.html</dc:identifier>
</item>
<item>
<title>拉勾网企业招聘信息分析报告 - 梦醒时夜续</title>
<link>http://www.cnblogs.com/nkqlhqc/p/11644900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nkqlhqc/p/11644900.html</guid>
<description>&lt;p&gt;明年的五六月份，包括笔者在内的一大批大学生就要走出校门，结束十六年的学业生涯，并开始长达数十年的职业生涯，在这个时间点上，我们最期望的莫过于找到一份称心的工作，这是家人的期盼，更是我们自己的期盼。&lt;br/&gt;　　我们中的每一个人，都或多或少的感受到了就业的压力，尤其是计算机行业，在这种&lt;strong&gt;低端人才饱和，高端人才紧缺&lt;/strong&gt;的大环境下，找到一份称心的工作着实不是件容易的事情。刚走出校门的我们由于经验不足只能选择低端岗位，令人担忧的是全球智能化革命的兴起将消灭大量的低端岗位，所以未来的竞争只会越来越激烈。&lt;br/&gt;　　前段时间，一个偶然的机会我在互联网上浏览到了几则招聘信息，读着读着我脑子中便闪过一个念头，何不动用一些技术手段将这些招聘信息采集下来，然后对这些信息进行分析呢？这样就可以从整体上看清行业招聘的趋势了。在强大的好奇心的驱使下我设计并编写了计算机程序，程序运行了大概三天的时间，终于将这些招聘信息采集了下来，数据经过清洗与分析过后，利用数据可视化技术加以展现。现在我将分析结果分享出来，以下是文章正文部分。&lt;/p&gt;
&lt;p&gt;提示：正文包含六十七张图片，将消耗你大概8MB的流量，你一定是个慷慨的人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文同步发布在笔者的个人博客上：&lt;a href=&quot;https://blog.zizaixian.top/archives/426&quot; class=&quot;uri&quot;&gt;https://blog.zizaixian.top/archives/426&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;笔者已将文中的图片打包成了压缩文件，读者可自行下载：&lt;a href=&quot;http://cdn.zizaixian.top/user/files/technology.zip&quot;&gt;点我下载&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在最前面的话&quot;&gt;写在最前面的话&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;本文展现的数据均采集于正规的招聘网站，数据的可信性是毋庸置疑的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有采集到的数据仅用作学习与交流，笔者承诺不会将其用作商业用途。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;文中不免夹杂一些笔者的个人观点，你可以反对我的观点，但是我拒不接受。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我并非权威的数据分析员，文章标题用 &lt;em&gt;报告&lt;/em&gt; 二字纯粹是为了装逼。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关于数据量的解释&quot;&gt;关于数据量的解释&lt;/h3&gt;
&lt;p&gt;　　数据均采集于&lt;a href=&quot;https://www.lagou.com&quot;&gt;拉勾网&lt;/a&gt;。相比于其它招聘信息服务网站，拉勾网专为IT从业人员提供信息服务，也就是说拉勾网上面的招聘信息全部都是与IT互联网相关的，无其它行业的招聘信息，因此选择拉勾网作为数据采集对象再合适不过了。&lt;br/&gt;　　此次共采集到招聘信息十一万两千八百六十五条，去除重复与无效的数据后剩余八万零三百五十条，数据采集日期为二零一九年九月下旬。 岗位涉及技术、产品、设计、运营、市场、销售、职能、游戏八个方向，由于绝大部分的学生在刚毕业时还是会选择技术岗，所以我仅仅分析了技术岗的数据，这部分数据共计两万八千六百七十一条。也许两万八千余条的数据量并不算大，但是我认为有时候不一定需要从宏观角度出发才能认清一件事情，从微观角度出发也可以很清晰的看到事物整体的面貌，这是一种透过微观看宏观的观察问题的方式。就比如我们交朋友，我们往往能通过对方的一些细节来判断这个人是否值得深交，而无需经过什么大事。&lt;br/&gt;　　每条招聘信息都包含工作地区、薪资区间、学历要求、经验要求、技能要有、岗位职责、企业所属领域、企业融资情况等数据，下面我将从十个方面对这部分数据做一个简单的分析。&lt;/p&gt;
&lt;h3 id=&quot;哪个城市最吸引人才&quot;&gt;哪个城市最吸引人才？&lt;/h3&gt;
&lt;p&gt;　　毕业之后，有些人想去自己向往已久的城市，有些人看见别人去哪了他就去哪，而很多的父母也不愿意子女远行。选择一个城市对我们将来的影响是不容小觑的，因为它直接决定了我们下半辈子在哪当房奴，甚至连房奴都当不上。下面是各城市需求岗位数量分布图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1823.jpg&quot; title=&quot;各城市需求岗位数量分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1823.jpg&quot; title=&quot;各城市需求岗位数量分布&quot; alt=&quot;各城市需求岗位数量分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　北京毫无疑问的是最吸引人才的城市，主要还是因为北京的IT企业相对较多一些。排在其身后的分别是深圳、上海、广州、杭州、成都、武汉、南京，其中深圳与上海的需求量基本持平，再往后就是岗位需求不太旺盛的城市了，这个分布也基本符合我们的认知。&lt;/p&gt;
&lt;h3 id=&quot;你需要什么样的学历&quot;&gt;你需要什么样的学历&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1503.jpg&quot; title=&quot;总体学历要求分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1503.jpg&quot; title=&quot;总体学历要求分布&quot; alt=&quot;总体学历要求分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，本科及以上学历占到一半以上，接着按比例排列分别是大专及以上、学历不限、硕士及以上、博士及以上。虽然本科及以上占比最大，但不要觉得自己是本科学历就高兴的太早，其一，不同的岗位对学历的要求是不同的，这里展现的仅仅是整体的学历要求分布，忽略了这种不同；其二，企业不仅仅要看你的学历，经验也是重要的考量；其三，学历低往往意味着薪资低；其四，学历低的不只你一个，你有多大的把握竞争过同类的人？这些都是客观存在的问题。&lt;br/&gt;　　提升学历真是件不错的事情，这么想的肯定也不只我一个，不然就不会出现下面这种情况了：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/pic1.jpg&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/pic1.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/pic2.jpg&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/pic2.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;你需要几年的经验&quot;&gt;你需要几年的经验&lt;/h3&gt;
&lt;p&gt;工作经验是IT企业招聘人才时的重要考量，以下展示的整体上经验要求的分布：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1526.jpg&quot; title=&quot;总体经验要求分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1526.jpg&quot; title=&quot;总体经验要求分布&quot; alt=&quot;总体经验要求分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　从图上可以看出，经验3-5年占比最高，接着是经验1-3年、经验5-10年、经验不限、经验应届毕业生、经验1年以下、经验10年以上。经验多意味着什么自然不必多说，但我强烈反对经验多就意味着头发少这种言论，虽然理论上是这样的，但也有例外不是。&lt;/p&gt;
&lt;h3 id=&quot;学历-and-经验&quot;&gt;学历 And 经验&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1606.jpg&quot; title=&quot;总体学历与经验分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1606.jpg&quot; title=&quot;总体学历与经验分布&quot; alt=&quot;总体学历与经验分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　上图展示的是不同学历下的经验要求分布，从中可以看出不管是何种学历，绝大多数岗位都要求3-5年或者1-3年的工作经验，也可以这么说，学历不行可以靠经验来补充，经验不足最好靠学历来补充，学历与经验都不足，需要在缝隙中生存。&lt;/p&gt;
&lt;h3 id=&quot;哪个领域最需要人才&quot;&gt;哪个领域最需要人才&lt;/h3&gt;
&lt;p&gt;　　不同的企业都有自己专属的领域，比如有的企业搞社交，有的企业搞金融，有的企业搞医疗，而有的企业涉足多个领域，比如乐视公司，咱也不知道贾跃亭老板回国了没有。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2135.jpg&quot; title=&quot;各领域需求工作岗位数量分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2135.jpg&quot; title=&quot;各领域需求工作岗位数量分布&quot; alt=&quot;各领域需求工作岗位数量分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　上图展示的是不同领域需要的人才数量分布，移动互联网一马当先，这与我国移动互联网的普及程度是密不可分的。&lt;br/&gt;　　&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/%E6%88%AA%E5%9B%BE_2019-10-06_23-37-04.png&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/%E6%88%AA%E5%9B%BE_2019-10-06_23-37-04.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;2019年8月30日，中国互联网络信息中心(CNNIC)第44次中国互联发展状况统计报告指出：截止到2019年6月，中国网民规模达8.54亿，用户月均使用移动流量达7.2GB。其中45.5%的网民为30岁以下的年轻群体，本科以下学历（不含本科）网民占比为90.4%&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　比较热门的领域还有企业服务、数据服务、金融、电商、游戏、文娱、教育等等。如果是给人打工的话自然是不用考虑企业所属领域的，如果创业的话那就要好好考虑考虑了。&lt;/p&gt;
&lt;h3 id=&quot;企业融资情况&quot;&gt;企业融资情况&lt;/h3&gt;
&lt;p&gt;下图展示了共计7257个公司的融资情况：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1722.jpg&quot; title=&quot;企业融资情况&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1722.jpg&quot; title=&quot;企业融资情况&quot; alt=&quot;企业融资情况&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　其中：上市公司859个，占比11.83%；不需要融资的公司2311个，占比31.85%；未融资的公司1698个，占比23.4%；A轮融资公司884个，占比12.18%；B轮融资公司561个，占比7.73%；C轮融资公司250个，占比3.44%；D轮及以上融资公司186个，占比2.56%；天使轮融资公司508个，占比7%&lt;/p&gt;
&lt;blockquote readability=&quot;0.51136363636364&quot;&gt;
&lt;p&gt;科普：&lt;a href=&quot;https://www.zhihu.com/question/28498812/answer/290736672&quot; title=&quot;融资 A 轮、B 轮 和 C 轮 有什么区别？ - 苏老湿的回答 - 知乎&quot;&gt;融资 A 轮、B 轮 和 C 轮 有什么区别？ - 苏老湿的回答 - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;总体薪资分布&quot;&gt;总体薪资分布&lt;/h3&gt;
&lt;p&gt;　　下图以饼图的形式展示了总体上薪资的分布，从1K到30K以2K为一个区间段，30K往后以5K为一个区间段，饼图的每个扇区代表落在该薪资区间的比例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1424.jpg&quot; title=&quot;总体薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1424.jpg&quot; title=&quot;总体薪资分布&quot; alt=&quot;总体薪资分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　总体的薪资分布并无实际参考意义，因为影响的薪资的因素是很多的，不同职位、学历、工作经验、公司融资情况、地区都会影响到薪资，下面就将展示不同因素影响下的薪资分布情况。&lt;/p&gt;
&lt;h3 id=&quot;不同因素影响下的薪资分布情况&quot;&gt;不同因素影响下的薪资分布情况&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;提示：前方核能多图预警。&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;本节采用饼图的形式展示不同因素对薪资分布的影响，这里需要强调的是“分布”二字，我们可以从图上看出哪些薪资区间占比较大，哪些薪资区间占比较小，但是不能够从图上看出某一因素对薪资的直接影响，现实中还要基于我们自身的考量。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;地区因素&quot;&gt;地区因素&lt;/h4&gt;
&lt;p&gt;下面展示了最吸引人才的六大城市的平均薪资分布：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%8C%97%E4%BA%AC.jpg&quot; title=&quot;北京地区薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%8C%97%E4%BA%AC.jpg&quot; title=&quot;北京地区薪资分布&quot; alt=&quot;北京地区薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%B7%B1%E5%9C%B3.jpg&quot; title=&quot;深圳地区薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%B7%B1%E5%9C%B3.jpg&quot; title=&quot;深圳地区薪资分布&quot; alt=&quot;深圳地区薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E4%B8%8A%E6%B5%B7.jpg&quot; title=&quot;上海地区薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E4%B8%8A%E6%B5%B7.jpg&quot; title=&quot;上海地区薪资分布&quot; alt=&quot;上海地区薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%B9%BF%E5%B7%9E.jpg&quot; title=&quot;广州地区薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%B9%BF%E5%B7%9E.jpg&quot; title=&quot;广州地区薪资分布&quot; alt=&quot;广州地区薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%9D%AD%E5%B7%9E.jpg&quot; title=&quot;杭州地区薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%9D%AD%E5%B7%9E.jpg&quot; title=&quot;杭州地区薪资分布&quot; alt=&quot;杭州地区薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%88%90%E9%83%BD.jpg&quot; title=&quot;成都地区薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%88%90%E9%83%BD.jpg&quot; title=&quot;成都地区薪资分布&quot; alt=&quot;成都地区薪资分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　通过对比可以看出，北京的平均薪资还是较其它几个城市高的，在11K-13K、15K-17K、19K-21K、21K-23K、29-31K都有较大的分布，上海的薪资分布与北京无太大差异，而成都明显是低薪资区间占比大，如果去国家统计局查一下各个城市的物价的话，这几张图到是十分合理的。&lt;/p&gt;
&lt;h4 id=&quot;学历因素&quot;&gt;学历因素&lt;/h4&gt;
&lt;p&gt;下面展示了不同学历的平均薪资分布：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%AD%A6%E5%8E%86%E4%B8%8D%E9%99%90.jpg&quot; title=&quot;学历不限薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%AD%A6%E5%8E%86%E4%B8%8D%E9%99%90.jpg&quot; title=&quot;学历不限薪资分布&quot; alt=&quot;学历不限薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%A4%A7%E4%B8%93%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;大专及以上薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%A4%A7%E4%B8%93%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;大专及以上薪资分布&quot; alt=&quot;大专及以上薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;大专及以上学历一万元薪资以下占据一半以上比例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%9C%AC%E7%A7%91%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;本科及以上薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%9C%AC%E7%A7%91%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;本科及以上薪资分布&quot; alt=&quot;本科及以上薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;本科及以上学历的薪资分布是比较均匀的，从整体上来看一万元至两万元的薪资大概占据50%。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%A1%95%E5%A3%AB%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;硕士及以上薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%A1%95%E5%A3%AB%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;硕士及以上薪资分布&quot; alt=&quot;硕士及以上薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;很明显，相比本科学历高出一个层级后，硕士学历的低薪资区间占比明显缩小，高薪资区间占比明显增加，其中21K-23K、29K-30K、35K-40K占比较大，从整体上看一万五千元至三万五千元的薪资占据约50%。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%8D%9A%E5%A3%AB%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;博士及以上薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%8D%9A%E5%A3%AB%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;博士及以上薪资分布&quot; alt=&quot;博士及以上薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;这个就很变态了，一万元薪资以下占比为零，一万元至两万元薪资占比很小，三万元以上薪资占比超75%，五万元薪资以上占比更是逼近25%。&lt;/p&gt;
&lt;p&gt;　　学历因素对薪资分布的影响给予我们最直观的启示就是：拥有什么样的学历有可能会决定今后的上升空间，学历低不意味着没有机会。&lt;/p&gt;
&lt;h4 id=&quot;经验因素&quot;&gt;经验因素&lt;/h4&gt;
&lt;p&gt;下面展示了不同工作经验的平均薪资分布：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C%E4%B8%8D%E9%99%90.jpg&quot; title=&quot;经验不限薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C%E4%B8%8D%E9%99%90.jpg&quot; title=&quot;经验不限薪资分布&quot; alt=&quot;经验不限薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C%E5%BA%94%E5%B1%8A%E6%AF%95%E4%B8%9A%E7%94%9F.jpg&quot; title=&quot;经验应届毕业生薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C%E5%BA%94%E5%B1%8A%E6%AF%95%E4%B8%9A%E7%94%9F.jpg&quot; title=&quot;经验应届毕业生薪资分布&quot; alt=&quot;经验应届毕业生薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C1%E5%B9%B4%E4%BB%A5%E4%B8%8B.jpg&quot; title=&quot;经验1年以下薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C1%E5%B9%B4%E4%BB%A5%E4%B8%8B.jpg&quot; title=&quot;经验1年以下薪资分布&quot; alt=&quot;经验1年以下薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C1-3%E5%B9%B4.jpg&quot; title=&quot;经验1-3年薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C1-3%E5%B9%B4.jpg&quot; title=&quot;经验1-3年薪资分布&quot; alt=&quot;经验1-3年薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C3-5%E5%B9%B4.jpg&quot; title=&quot;经验3-5年薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C3-5%E5%B9%B4.jpg&quot; title=&quot;经验3-5年薪资分布&quot; alt=&quot;经验3-5年薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C5-10%E5%B9%B4.jpg&quot; title=&quot;经验5-10年薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C5-10%E5%B9%B4.jpg&quot; title=&quot;经验5-10年薪资分布&quot; alt=&quot;经验5-10年薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C10%E5%B9%B4%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;经验10年以上薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%BB%8F%E9%AA%8C10%E5%B9%B4%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;经验10年以上薪资分布&quot; alt=&quot;经验10年以上薪资分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　从上面七张图我们可以看出随着工作经验的增加，低薪资区间占比越来越小，高薪资区间占比越来越大，这与学历增加后平均薪资的走势是一样的。&lt;/p&gt;
&lt;p&gt;　　经验少则薪资低，经验多则薪资高，这是谁都知道的道理。但是值得我们思考的一个问题是：学历与经验哪个因素对薪资的影响更大一些呢？我还没有找出一个合理的算法或公式来下一个结论，凭借着对图的直观感觉我认为这两个因素对薪资的影响都挺大的（听起来像是句废话）。&lt;/p&gt;
&lt;h4 id=&quot;职位因素&quot;&gt;职位因素&lt;/h4&gt;
&lt;p&gt;不同职位的薪资分布是有所差异的，但这仅仅代表着分布的差异，不能够抛开学历、经验等因素说某个职位比另一个职位好，这是没有任何意义的。下面分别展示了前端开发、后端开发、移动开发、运维、高端职位、人工智能这六种职位的薪资分布情况：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;前端开发薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;前端开发薪资分布&quot; alt=&quot;前端开发薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;后端开发薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;后端开发薪资分布&quot; alt=&quot;后端开发薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;移动开发薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;移动开发薪资分布&quot; alt=&quot;移动开发薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E8%BF%90%E7%BB%B4.jpg&quot; title=&quot;运维薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E8%BF%90%E7%BB%B4.jpg&quot; title=&quot;运维薪资分布&quot; alt=&quot;运维薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E9%AB%98%E7%AB%AF%E8%81%8C%E4%BD%8D.jpg&quot; title=&quot;高端职位薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E9%AB%98%E7%AB%AF%E8%81%8C%E4%BD%8D.jpg&quot; title=&quot;高端职位薪资分布&quot; alt=&quot;高端职位薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.jpg&quot; title=&quot;人工智能薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.jpg&quot; title=&quot;人工智能薪资分布&quot; alt=&quot;人工智能薪资分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　尽管我们不能直接比较哪个职位更好一些，但是从不同职位的资分布情况来看，我们仍然能够看出有些职位的薪资上升空间是比较小的，而像人工智能这种对学历要求极高的职位薪资上升空间就相对大一些。&lt;/p&gt;
&lt;h4 id=&quot;技术因素&quot;&gt;技术因素&lt;/h4&gt;
&lt;p&gt;　　技术是最容易引起人们争论的话题，而且大多数是无意义的争论。整天考虑该选择什么样的技术来实现自己的想法是一种避重就轻的行为，就像每个月都发布的 &lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot; title=&quot;TIOBE编程语言排行榜&quot;&gt;TIOBE编程语言排行榜&lt;/a&gt;一样，它只能反映编程语言的热门程度 ，但是就是有很多自媒体或培训机构喜欢拿它来说事，下一些类似“某种编程语言好”、“某种编程语言有前途”这种愚蠢的结论。&lt;/p&gt;
&lt;p&gt;计算机行业技术门类过于繁多，下面仅仅列举了比较热门的技术，仅当参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505C.jpg&quot; title=&quot;C薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505C.jpg&quot; title=&quot;C薪资分布&quot; alt=&quot;C薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505C-1.jpg&quot; title=&quot;C-1薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505C-1.jpg&quot; title=&quot;C-1薪资分布&quot; alt=&quot;C++薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505Java.jpg&quot; title=&quot;Java薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505Java.jpg&quot; title=&quot;Java薪资分布&quot; alt=&quot;Java薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505JavaScript.jpg&quot; title=&quot;JavaScript薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505JavaScript.jpg&quot; title=&quot;JavaScript薪资分布&quot; alt=&quot;JavaScript薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505Node.js.jpg&quot; title=&quot;Node.js薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505Node.js.jpg&quot; title=&quot;Node.js薪资分布&quot; alt=&quot;Node.js薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505PHP.jpg&quot; title=&quot;PHP薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505PHP.jpg&quot; title=&quot;PHP薪资分布&quot; alt=&quot;PHP薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505Android.jpg&quot; title=&quot;Android薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505Android.jpg&quot; title=&quot;Android薪资分布&quot; alt=&quot;Android薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505Python.jpg&quot; title=&quot;Python薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505Python.jpg&quot; title=&quot;Python薪资分布&quot; alt=&quot;Python薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505web%E5%89%8D%E7%AB%AF.jpg&quot; title=&quot;web前端薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505web%E5%89%8D%E7%AB%AF.jpg&quot; title=&quot;web前端薪资分布&quot; alt=&quot;web前端薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0.jpg&quot; title=&quot;深度学习薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0.jpg&quot; title=&quot;深度学习薪资分布&quot; alt=&quot;深度学习薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%8C%BA%E5%9D%97%E9%93%BE.jpg&quot; title=&quot;区块链薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%8C%BA%E5%9D%97%E9%93%BE.jpg&quot; title=&quot;区块链薪资分布&quot; alt=&quot;区块链薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88.jpg&quot; title=&quot;算法工程师薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88.jpg&quot; title=&quot;算法工程师薪资分布&quot; alt=&quot;算法工程师薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB.jpg&quot; title=&quot;图像识别薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB.jpg&quot; title=&quot;图像识别薪资分布&quot; alt=&quot;图像识别薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88.jpg&quot; title=&quot;运维工程师薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88.jpg&quot; title=&quot;运维工程师薪资分布&quot; alt=&quot;运维工程师薪资分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;企业融资因素&quot;&gt;企业融资因素&lt;/h4&gt;
&lt;p&gt;下面展示了不同融资情况的企业的薪资分布情况：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E4%B8%8D%E9%9C%80%E8%A6%81%E8%9E%8D%E8%B5%84.jpg&quot; title=&quot;不需要融资薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E4%B8%8D%E9%9C%80%E8%A6%81%E8%9E%8D%E8%B5%84.jpg&quot; title=&quot;不需要融资薪资分布&quot; alt=&quot;不需要融资薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%9C%AA%E8%9E%8D%E8%B5%84.jpg&quot; title=&quot;未融资薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E6%9C%AA%E8%9E%8D%E8%B5%84.jpg&quot; title=&quot;未融资薪资分布&quot; alt=&quot;未融资薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%A4%A9%E4%BD%BF%E8%BD%AE.jpg&quot; title=&quot;天使轮薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E5%A4%A9%E4%BD%BF%E8%BD%AE.jpg&quot; title=&quot;天使轮薪资分布&quot; alt=&quot;天使轮薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505A%E8%BD%AE.jpg&quot; title=&quot;A轮薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505A%E8%BD%AE.jpg&quot; title=&quot;A轮薪资分布&quot; alt=&quot;A轮薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505B%E8%BD%AE.jpg&quot; title=&quot;B轮薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505B%E8%BD%AE.jpg&quot; title=&quot;B轮薪资分布&quot; alt=&quot;B轮薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505C%E8%BD%AE.jpg&quot; title=&quot;C轮薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505C%E8%BD%AE.jpg&quot; title=&quot;C轮薪资分布&quot; alt=&quot;C轮薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505D%E8%BD%AE%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;D轮及以上薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505D%E8%BD%AE%E5%8F%8A%E4%BB%A5%E4%B8%8A.jpg&quot; title=&quot;D轮及以上薪资分布&quot; alt=&quot;D轮及以上薪资分布&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1505%E4%B8%8A%E5%B8%82%E5%85%AC%E5%8F%B8.jpg&quot; title=&quot;上市公司薪资分布&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1505%E4%B8%8A%E5%B8%82%E5%85%AC%E5%8F%B8.jpg&quot; title=&quot;上市公司薪资分布&quot; alt=&quot;上市公司薪资分布&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;职位诱惑&quot;&gt;职位诱惑&lt;/h3&gt;
&lt;p&gt;　　几乎每个企业都会在招聘公告上写一些自己公司的“优势”，也叫职位诱惑，下面用词云的形式展示了职位诱惑中出现频率最高的50个词汇：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t1655.jpg&quot; title=&quot;职位诱惑词频统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t1655.jpg&quot; title=&quot;职位诱惑词频统计&quot; alt=&quot;职位诱惑词频统计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：分词器把“五险一金”分成了“五险”和“一金”两个词，实际上这是一个词。&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;科普：五险一金，指中国用人单位给予劳动者的几种保障性待遇的合称。“五险”指五种社会保险，包括养老保险、医疗保险、失业保险、工伤保险、生育保险，“一金”是指住房公积金。--- 摘自维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;技能要求&quot;&gt;技能要求&lt;/h3&gt;
&lt;p&gt;每个企业都会在招聘公告上明确的指出求职者应该具备哪些技能，不同职位的技能要求侧重点是不同的，但是也有一些普遍的要求。下面仍然采用词云的形式展示了几个热门职位或技术的技能要求高频词汇：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;后端开发技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;后端开发技能要求词汇统计&quot; alt=&quot;后端开发技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;前端开发技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;前端开发技能要求词汇统计&quot; alt=&quot;前端开发技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88.jpg&quot; title=&quot;全栈工程师技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88.jpg&quot; title=&quot;全栈工程师技能要求词汇统计&quot; alt=&quot;全栈工程师技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;移动开发技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91.jpg&quot; title=&quot;移动开发技能要求词汇统计&quot; alt=&quot;移动开发技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008%E8%BF%90%E7%BB%B4.jpg&quot; title=&quot;运维技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008%E8%BF%90%E7%BB%B4.jpg&quot; title=&quot;运维技能要求词汇统计&quot; alt=&quot;运维技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008C.jpg&quot; title=&quot;C++技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008C.jpg&quot; title=&quot;C++技能要求词汇统计&quot; alt=&quot;C++技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008Java.jpg&quot; title=&quot;Java技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008Java.jpg&quot; title=&quot;Java技能要求词汇统计&quot; alt=&quot;Java技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008PHP.jpg&quot; title=&quot;PHP技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008PHP.jpg&quot; title=&quot;PHP技能要求词汇统计&quot; alt=&quot;PHP技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008Python.jpg&quot; title=&quot;Python技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008Python.jpg&quot; title=&quot;Python技能要求词汇统计&quot; alt=&quot;Python技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cdn.zizaixian.top/2019/10/t2008%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.jpg&quot; title=&quot;人工智能技能要求词汇统计&quot;&gt;&lt;img src=&quot;http://cdn.zizaixian.top/2019/10/t2008%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.jpg&quot; title=&quot;人工智能技能要求词汇统计&quot; alt=&quot;人工智能技能要求词汇统计&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【注】统计高频词汇的过程中已经过滤掉了无意义的词，例如“熟悉”、“精通”、“具备”、“掌握”、“扎实”等词汇，保留“经验”一词旨在说明企业十分看中求职者对某一特定技术的使用经验。&lt;/p&gt;
&lt;h3 id=&quot;不要迷信数据与他人&quot;&gt;不要迷信数据与他人&lt;/h3&gt;
&lt;p&gt;　　数据分析只是一个工具，它不是万能的，万不要盲目的相信数据，未来选择什么样的职业，还要自己凭主观定夺，也就是你自己说了算。对未来迷茫了就去多读书，不要迷信数据，更不要听旁人瞎扯。&lt;br/&gt;　　我在这里列举两类人，如果这两类人对你的职业有任何指导的话，你大可不必去听。这第一类人是大学教师，尤其是系里的领导，这类人由于在学校呆的太久，与外界基本处于隔离的状态。教师是一个相对安逸的职业，安逸的环境势必会打消人学习的热情，学习的热情一旦没有了，不再为自己充电了，那就基本上等于落后于时代了，对未来的判断更是无从谈起。计算机行业的发展速度远超过王思聪换女朋友的速度，我们的大学教师面对这样的发展速度能否给予学生一个正确的指导呢？我想他们是不能的。如果有教师为你的未来提供什么指导的话，他们也是在拿数年前的眼光告诉你现在该怎么去做，或者借用自媒体噱头式的宣传来鼓励你去做那些看起来很有前景的事情。&lt;br/&gt;　　第二类人，是培训机构的人。培训机构的人为了自身的利益，不可避免的要用夸张式的语气宣扬一种事物，或去贬低一种事物，我觉得这是无可厚非的，毕竟赚钱才是培训机构的首要任务，而非培养人才。我只想说兼听则明，偏信则暗，如果任由单方面的话语在我们耳边徘徊的话，那我们对未来的判断是不是失去了平衡呢？我曾经&lt;strong&gt;被动的&lt;/strong&gt;接受过五家培训机构的宣传，在此我也非常有兴趣点名一家培训机构，这家培训机构的名字叫北京AAA教育，在被动的听完该机构某位中年女士的宣讲后，我只想借诸葛亮的话形容一下当时的心情：我从未见过有如此厚颜无耻之人。为了自己的那点利益，把学生当傻子，信口胡说，颠倒黑白，四十分钟的宣讲将其无知、无耻的一面表现的淋漓尽致。在此衷心祝愿该培训机构早日倒闭，免得毒害更多的学生。&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;p&gt;　　首先要感谢您能读到这里，感谢您在百忙之中读完我的这篇不严谨且存在诸多纰漏的文章。我从没有系统的学习过数据分析，只是凭借着兴趣做了这件事情，如果您能对文中的数据分析提出任何异议或者建设性意见的话，不胜感激。&lt;/p&gt;
&lt;p&gt;　　未来的路还很长，也许有些人在刚走出校门时会遇到一些困难，而有的人可能会走的相对顺利一些。每个人的都有属于自己的目标与理想，没必要攀比些什么，做好眼前的每一件小事，向往着一个不会比今天更糟的明天，一切都会有个好的结果。&lt;/p&gt;
&lt;p&gt;　　最后，一首冯唐的诗，送给自己以及即将迈出校门的年轻人：&lt;br/&gt;　　&lt;strong&gt;尚未佩妥剑，转眼便江湖。&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;愿历尽千帆，归来仍少年。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Oct 2019 14:38:00 +0000</pubDate>
<dc:creator>梦醒时夜续</dc:creator>
<og:description>明年的五六月份，包括笔者在内的一大批大学生就要走出校门，结束十六年的学业生涯，并开始长达数十年的职业生涯，在这个时间点上，我们最期望的莫过于找到一份称心的工作，这是家人的期盼，更是我们自己的期盼。 我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nkqlhqc/p/11644900.html</dc:identifier>
</item>
</channel>
</rss>