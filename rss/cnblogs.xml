<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇] - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-05-06.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-05-06.html</guid>
<description>&lt;p&gt;.NET Core采用的这个全新的配置模型的一个主要的特点就是对多种不同配置源的支持。我们可以将内存变量、命令行参数、环境变量和物理文件作为原始配置数据的来源。如果采用物理文件作为配置源，我们可以选择不同的格式(比如XML、JSON和INI等)。如果这些默认支持的配置源形式还不能满足你的需求，我们还可以通过注册自定义IConfigurationSource的方式将其他形式数据作为配置来源。&lt;/p&gt;

&lt;p&gt;在之前的实例演示都在使用MemoryConfigurationSource来提供原始的配置。我们知道MemoryConfigurationSource配置源采用一个字典对象（具体来说应该是一个元素类型为&lt;span&gt;KeyValuePair&amp;lt;string, string&amp;gt;&lt;/span&gt;的集合）作为存放原始配置数据的容器。作为一个IConfigurationSource对象，它总是通过创建某个对应的IConfigurationProvider对象来完成具体的配置数据读取工作，那么MemoryConfigurationSource会提供一个怎样的IConfigurationProvider呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MemoryConfigurationSource : IConfigurationSource
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; InitialData { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfigurationProvider Build(IConfigurationBuilder builder) =&amp;gt; &lt;span&gt;new&lt;/span&gt; MemoryConfigurationProvider(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面给出的代码片段体现了MemoryConfigurationSource的完整定义，我们可以看到它具有一个IEnumerable&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt;类型的属性&lt;span&gt;InitialData&lt;/span&gt;来存放初始的配置数据。从Build方法的实现可以看出，真正被它用来读取原始配置数据的是一个MemoryConfigurationProvider类型的对象，该类型的定义如下面的代码片段所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MemoryConfigurationProvider : ConfigurationProvider,  IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MemoryConfigurationProvider(MemoryConfigurationSource source);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Add(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerator&amp;lt;KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码片段可以看出，MemoryConfigurationProvider派生于抽象类ConfigurationProvider，同时还实现了IEnumerable&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt;接口。我们知道ConfigurationProvider对象直接使用一个Dictionary&amp;lt;string, string&amp;gt;来保存配置数据，当我们根据一个MemoryConfigurationSource对象调用构造函数创建MemoryConfigurationProvider的时候，它只需要将通过InitialData属性保存的配置数据转移到这个字典中即可。MemoryConfigurationProvider还定义了一个Add方法使我们可以在任何时候都可以向配置字典中添加一个新的配置项。&lt;/p&gt;
&lt;p&gt;通过前面对配置模型的介绍，我们知道IConfigurationProvider对象在配置模型中所起的作用就是&lt;span&gt;读取原始的配置数据并将其转换成配置字典&lt;/span&gt;。在所有的预定义的IConfigurationProvider实现类型中，MemoryConfigurationProvider最为简单直接，因为它对应的配置源就是一个配置字典，所以根本不需要作任何的结构转换。&lt;/p&gt;
&lt;p&gt;在利用MemoryConfigurationSource生成配置的时候，我们需要将它注册到IConfigurationBuilder对象之上。具体来说，我们可以像前面演示的实例一样直接调用IConfigurationBuilder接口的Add方法，也可以调用如下所示的两个重载的AddInMemoryCollection扩展方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MemoryConfigurationBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddInMemoryCollection(  &lt;span&gt;this&lt;/span&gt;&lt;span&gt; IConfigurationBuilder configurationBuilder);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddInMemoryCollection(  &lt;span&gt;this&lt;/span&gt; IConfigurationBuilder configurationBuilder,   IEnumerable&amp;lt;KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; initialData);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;顾名思义，环境变量就是描述当前执行环境并影响进程执行行为的变量。按照作用域的不同，我们将环境变量划分成三类，即分别针对当前系统、当前用户和当前进程的环境变量。对于Windows系统来说，系统和用户级别的环境变量保存在注册表中，其路径分别为“HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment”和“HKEY_CURRENT_USER\Environment ”。&lt;/p&gt;
&lt;p&gt;环境变量的提取和维护可以通过静态类型Environment来完成。具体来说，我们可以调用它的静态方法&lt;span&gt;GetEnvironmentVariable&lt;/span&gt;获得某个指定名称的环境变量的值，而&lt;span&gt;GetEnvironmentVariables&lt;/span&gt;方法则会返回所有的环境变量，EnvironmentVariableTarget枚举类型的参数代表环境变量作用域决定的存储位置。如果在调用GetEnvironmentVariable或者GetEnvironmentVariables方法时没有显式指定target参数或者将参数指定为EnvironmentVariableTarget.Process，在进程初始化前存在的所有环境变量（包括针对系统、当前用户和当前进程）将会作为候选列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Environment
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetEnvironmentVariable(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; variable);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetEnvironmentVariable(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; variable,  EnvironmentVariableTarget target);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IDictionary GetEnvironmentVariables();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IDictionary GetEnvironmentVariables( EnvironmentVariableTarget target);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetEnvironmentVariable(&lt;span&gt;string&lt;/span&gt; variable, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetEnvironmentVariable(&lt;span&gt;string&lt;/span&gt; variable, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value,  EnvironmentVariableTarget target);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; EnvironmentVariableTarget
{
      Process,
      User,
      Machine
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;环境变量的添加、修改和删除均由SetEnvironmentVariable方法来完成，如果没有显式指定target参数，默认采用的是EnvironmentVariableTarget.Process。如果希望删除指定名称的环境变量，我们只需要在调用这个方法的时候将value参数设置为Null或者空字符串即可。&lt;/p&gt;
&lt;p&gt;除了在程序中利用静态类型Environment，我们还可以采用命令行的方式查看和设置环境变量。除此之外，我们在&lt;span&gt;开发环境&lt;/span&gt;中还可以利用“系统属性（System Properties）”设置工具以可视化的方式查看和设置系统和用户级别的环境变量（“This PC”&amp;gt;“Properties”&amp;gt;“Change Settings”&amp;gt;“Advanced”&amp;gt;“Environment Variables”）。如果采用Visual Studio 来调试我们编写的应用，我们可以采用设置项目属性的方式来设置进程级别的环境变量（“Properties” &amp;gt; “Debug”&amp;gt; “Environment Variables” ）。在第1章 “全新的开发体验” 中我们提到过，设置的环境变量会被保存到&lt;span&gt;launchSettings.json&lt;/span&gt;文件中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191219084221290-91952509.png&quot;&gt;&lt;img width=&quot;353&quot; height=&quot;166&quot; title=&quot;6-16、&quot; alt=&quot;6-16、&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191219084221836-775426612.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;针对环境变量的配置源通过如下这个 EnvironmentVariablesConfigurationSource类型来表示，该类型定义在NuGet包“Microsoft.Extensions.Configuration.EnvironmentVariables”之中。该类型定义了一个字符串类型的属性Prefix，它表示环境变量名的前缀。如果我们设置了这个Prefix属性，系统只会选择名称以此作为前缀的环境变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnvironmentVariablesConfigurationSource : IConfigurationSource
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Prefix { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfigurationProvider Build(IConfigurationBuilder builder)=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EnvironmentVariablesConfigurationProvider(Prefix);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过前面给出的代码片段我们可以看出EnvironmentVariablesConfigurationSource配置源会利用对应的EnvironmentVariablesConfigurationProvider对象来读取环境变量，此操作体现在如下所示的Load方法中。由于环境变量本身就是一个数据字典，所以EnvironmentVariables&lt;br/&gt;ConfigurationProvider对象无需再进行结构上的转换。当Load方法被执行之后，它只需要将符合条件的环境变量筛选出来并添加到自己的配置字典中即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnvironmentVariablesConfigurationProvider : ConfigurationProvider
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _prefix;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EnvironmentVariablesConfigurationProvider(&lt;span&gt;string&lt;/span&gt; prefix = &lt;span&gt;null&lt;/span&gt;) =&amp;gt;  _prefix = prefix ?? &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Load()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dictionary =&lt;span&gt; Environment.GetEnvironmentVariables()
            .Cast&lt;/span&gt;&amp;lt;DictionaryEntry&amp;gt;&lt;span&gt;()
            .Where(it &lt;/span&gt;=&amp;gt;&lt;span&gt; it.Key.ToString().StartsWith( _prefix, StringComparison.OrdinalIgnoreCase))
            .ToDictionary(it &lt;/span&gt;=&amp;gt; it.Key.ToString().Substring(_prefix.Length),   it =&amp;gt;&lt;span&gt; it.Value.ToString());
        Data &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;( dictionary, StringComparer.OrdinalIgnoreCase);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;值得一提的是，如果我们在创建EnvironmentVariablesConfigurationProvider对象时指定了用于筛选环境变量的前缀，当符合条件的环境变量被添加到自身的配置字典之后，&lt;span&gt;配置项的名称会将此前缀剔除&lt;/span&gt;。比如前缀设置为“FOO_”，环境变量“FOO_BAR”被添加到配置字典之后，配置项 名称会变成“BAR”，这个细节也体现在上面定义的Load方法中。&lt;/p&gt;
&lt;p&gt;在使用EnvironmentVariablesConfigurationSource的时候，我们可以调用Add方法将它注册到指定的IConfigurationBuilder对象上。除此之外，EnvironmentVariablesConfigurationSource的注册还可以直接调用IConfigurationBuilder接口的如下三个重载的扩展方法AddEnvironmentVariables来完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnvironmentVariablesExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddEnvironmentVariables(  &lt;span&gt;this&lt;/span&gt;&lt;span&gt; IConfigurationBuilder configurationBuilder);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddEnvironmentVariables(  &lt;span&gt;this&lt;/span&gt; IConfigurationBuilder builder,  Action&amp;lt;EnvironmentVariablesConfigurationSource&amp;gt;&lt;span&gt; configureSource);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddEnvironmentVariables(  &lt;span&gt;this&lt;/span&gt; IConfigurationBuilder configurationBuilder, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; prefix);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们照例编写一个简单的实例来演示如何利用环境变量作为配置源。如下面的代码片段所示，我们调用Environment的静态方法SetEnvironmentVariable方法设置了四个环境变量，变量名称具有相同的前缀TEST_。我们调用方法AddEnvironmentVariables创建一个Environment&lt;br/&gt;VariablesConfigurationSource对象并将其注册到创建的&lt;a&gt;ConfigurationBuilder&lt;/a&gt; 之上，在调用该方法时我们将环境变量名称前缀 设置为 “TEST_”。我们最终将由ConfigurationBuilder构建出的IConfiguration对象绑定成一个Profile对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Environment.SetEnvironmentVariable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST_GENDER&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Environment.SetEnvironmentVariable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST_AGE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Environment.SetEnvironmentVariable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST_CONTACTINFO:EMAILADDRESS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foobar@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Environment.SetEnvironmentVariable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST_CONTACTINFO:PHONENO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; profile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
            .AddEnvironmentVariables(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .Build()
            .Get&lt;/span&gt;&amp;lt;Profile&amp;gt;&lt;span&gt;();

        Debug.Assert(profile.Equals(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Profile(Gender.Male, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foobar@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在很多情况下，我们会采用Self-Host的方式将一个ASP.NET Core应用寄宿到一个托管进程中，在这种情况下我们倾向于采用命令行的方式来启动寄宿程序。当以命令行的形式启动一个ASP.NET Core应用时，我们希望直接使用命名行开关（Switch）来控制应用的一些行为，所以命令行开关自然也就成为了配置常用的来源之一。配置模型针对这种配置源的支持是通过CommandLineConfigurationSource来实现的，该类型定义在NuGet包 “Microsoft.Extensions.Configuration.CommandLine”中。&lt;/p&gt;
&lt;p&gt;在以命令行的形式执行某个命令的时候，命令行开关（包括名称和值）体现为一个简单的字符串数组，所以CommandLineConfigurationSource的根本目的在于将命名行开关从字符串数组转换成配置字典。要充分理解这个转换规则，我们先得来了解一下CommandLine&lt;br/&gt;ConfigurationSource支持的命令行开关究竟采用怎样的形式来指定。我们通过一个简单的实例来说明命令行开关的几种指定方式。假设我们有一个命令“exec”并采用如下所示的方式执行某个托管程序（app）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
exec app {options}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在执行这个命令的时候我们通过相应的命令行开关指定多个选项。总的来说，命令行开关的指定形式大体上分为两种，我将它们称为“&lt;span&gt;单参数（Single Argument&lt;/span&gt;）”和“&lt;span&gt;双参数（Double Arguments）&lt;/span&gt;”。所谓单参数形式就是采用&lt;span&gt;等号&lt;/span&gt;（“=”）将命令行开关的名称和值通过如下方法采用一个参数来指定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{name}=&lt;span&gt;{value}
{prefix}{name}&lt;/span&gt;={value}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于第二种单参数命令行开关的指定形式，我们可以在开关名称前面添加一个前缀，目前的前缀支持“&lt;span&gt;/&lt;/span&gt;”、“&lt;span&gt;--&lt;/span&gt;”和“&lt;span&gt;-&lt;/span&gt;”三种。遵循这样的格式，我们可以采用如下三种方式将命令行开关architecture设置为“x64”。下面的列表之所以没有使用“-”前缀，是因为这个前缀要求使用“命令行开关映射（Switch Mapping）”，我们稍后会对此作单独介绍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
exec app architecture=&lt;span&gt;x64
exec app &lt;/span&gt;/architecture=&lt;span&gt;x64
exec app &lt;/span&gt;--architecture=x64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了采用单参数形式，我们还可以采用双参数形式来指定命令行开关，所谓的“双参数”就是使用两个参数分别定义命令行开关的名称和值。这种形式采用的具体格式为“{prefix}{name} {value}”，所以上述的这个命令行开关architecture也可以采用如下的方式来指定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
exec app /&lt;span&gt;architecture x64
exec app –&lt;/span&gt;-architecture x64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行开关的全名和缩写之间具有一个&lt;span&gt;映射关系（Switch Mapping）&lt;/span&gt;。以上述的这两个命令行开关为例，我们可以采用首字母“a”来代替“architecture”。如果使用“-”作为前缀，不论采用单参数还是双参数形式，都必须使用映射后的开关名称。值得一提的是，同一个命令行开关可以具有多个映射，比如我们也可以同时将“architecture”映射为“arch”。假设“architecture”具有了这两种映射，我们就可以按照如下两种方式指定CPU架构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
exec app -a=&lt;span&gt;x64
exec app &lt;/span&gt;-arch=&lt;span&gt;x64
exec app &lt;/span&gt;-&lt;span&gt;a x64
exec app &lt;/span&gt;-arch x64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在了解了命令行开关的指定形式之后，我们接着来说说CommandLineConfigurationSource类型和由它提供的CommandLineConfigurationProvider。由于原始的命令行参数总是体现为一个采用空格分隔的字符串，这样的字符串可以进一步转换成一个字符串集合，所以CommandLineConfigurationSource对象以字符串集合作为配置源。如下面的代码片断所示，CommandLineConfigurationSource类型具有Args和SwitchMappings两个属性，前者代表承载着原始命令行参数的字符串集合，后者则保存了命令行开关的缩写与全称之间的映射关系。&lt;a&gt;CommandLineConfigurationSource&lt;/a&gt;实现 的Build方法会根据这两个属性创建并返回一个CommandLineConfigurationProvider对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommandLineConfigurationSource : IConfigurationSource
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Args { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; SwitchMappings { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfigurationProvider Build(IConfigurationBuilder builder) =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CommandLineConfigurationProvider( Args,SwitchMappings); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具有如下定义的CommandLineConfigurationProvider对象依然是抽象类ConfigurationProvider的继承者。CommandLineConfigurationProvider对象的目的很明确，就是对体现为字符串集合的原始命令行参数进行解析，并将解析出来的参数名称和值添加到配置字典中 ，这一切都是在重写的Load方法中完成的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommandLineConfigurationProvider : ConfigurationProvider
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Args { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CommandLineConfigurationProvider(IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; args,  IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; switchMappings = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Load();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在采用基于命令行参数作为配置源的时候，我们可以创建一个CommandLineConfigurationSource并将其注册到ConfigurationBuilder上。我们也可以调用IConfigurationBuilder接口的如下三个扩展方法AddCommandLine将两个步骤合二为一。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommandLineConfigurationExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddCommandLine(  &lt;span&gt;this&lt;/span&gt; IConfigurationBuilder builder,  Action&amp;lt;CommandLineConfigurationSource&amp;gt;&lt;span&gt; configureSource);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddCommandLine(  &lt;span&gt;this&lt;/span&gt; IConfigurationBuilder configurationBuilder, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddCommandLine(  &lt;span&gt;this&lt;/span&gt; IConfigurationBuilder configurationBuilder, &lt;span&gt;string&lt;/span&gt;[] args,  IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; switchMappings);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了让读者朋友们对CommandLineConfigurationSource/CommandLineConfigurationProvider解析命令行参数采用的策略有一个深刻的认识，我们来演示一个简单的实例。如下面的代码片段所示，我们创建了一个ConfigurationBuilder对象并调用AddCommandLine方法注册了针对命令行参数的配置源，Main方法的参数args直接作为原始的命令行参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mapping = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
            {
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]     = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;architecture&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-arch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]     = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;architecture&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configuration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
                .AddCommandLine(args, mapping)
                .Build();
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Architecture: {configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;architecture&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error: {ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在调用扩展方法AddCommandLine注册CommandLineConfigurationSource的时候，我们指定了一个命令行开关映射表，它将命令行开关 “architecture” 映射为 “a” 和 “arch” 。需要注意的是，在通过字典定义命令行开关映射的时候，作为目标名称的Key应该添加 “-” 前缀。接下来我们调用ConfigurationBuilder的Build方法创建出IConfiguration对象，并从中提取出 “architecture” 配置项的值并打印出来。如下图所示，我们采用命令行的形式启动这个程序并以不同的形式指定 “architecture” 的值。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191219084222083-613785024.png&quot;&gt;&lt;img width=&quot;278&quot; height=&quot;308&quot; title=&quot;6-17&quot; alt=&quot;6-17&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191219084222365-598942796.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[1]：读取配置数据[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[2]：读取配置数据[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[3]：配置模型总体设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[4]：将配置绑定为对象&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[5]：配置数据与数据源的实时同步&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[7]：多样化的配置源[中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[8]：多样化的配置源[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[9]：自定义配置源&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Dec 2019 00:42:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>.NET Core采用的这个全新的配置模型的一个主要的特点就是对多种不同配置源的支持。我们可以将内存变量、命令行参数、环境变量和物理文件作为原始配置数据的来源。如果采用物理文件作为配置源，我们可以选择</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-05-06.html</dc:identifier>
</item>
<item>
<title>flask之SQLAlchemy - tomjoy</title>
<link>http://www.cnblogs.com/guapitomjoy/p/12065772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guapitomjoy/p/12065772.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;1.介绍&lt;/h2&gt;
&lt;p&gt;SQLAlchemy是一个基于Python实现的ORM框架。该框架建立在 DB API之上，使用关系对象映射进行数据库操作，简言之便是：将类和对象转换成SQL，然后使用数据API执行SQL并获取执行结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip3 install sqlalchemy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组成部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Engine，框架的引擎
Connection Pooling ，数据库连接池
Dialect，选择连接数据库的DB API种类
Schema/Types，架构和类型
SQL Exprression Language，SQL表达式语言&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQLAlchemy本身无法操作数据库，其必须以来pymsql等第三方插件，Dialect用于和数据API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MySQL-Python
    mysql+mysqldb://&amp;lt;user&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;[:&amp;lt;port&amp;gt;]/&amp;lt;dbname&amp;gt;
    
pymysql
    mysql+pymysql://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;/&amp;lt;dbname&amp;gt;[?&amp;lt;options&amp;gt;]
    
MySQL-Connector
    mysql+mysqlconnector://&amp;lt;user&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;[:&amp;lt;port&amp;gt;]/&amp;lt;dbname&amp;gt;
    
cx_Oracle
    oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;amp;key=value...]
    
更多：http://docs.sqlalchemy.org/en/latest/dialects/index.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;django中如何反向生成models&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py inspectdb &amp;gt; app/models.py&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;简单使用能创建表删除表不能修改表&quot;&gt;2.简单使用（能创建表，删除表，不能修改表）&lt;/h2&gt;
&lt;p&gt;修改表：在数据库添加字段，类对应上&lt;/p&gt;
&lt;p&gt;1执行原生sql（不常用）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading
import sqlalchemy
from sqlalchemy import create_engine
from sqlalchemy.engine.base import Engine

engine = create_engine(
    &quot;mysql+pymysql://root:123456@127.0.0.1:3306/test?charset=utf8&quot;,
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 池中没有线程最多等待的时间，否则报错
    pool_recycle=-1  # 多久之后对线程池中的线程进行一次连接的回收（重置）
)
def task(arg):
    conn = engine.raw_connection()
    cursor = conn.cursor()
    cursor.execute(
        &quot;select * from app01_book&quot;
    )
    result = cursor.fetchall()
    print(result)
    cursor.close()
    conn.close()

for i in range(20):
    t = threading.Thread(target=task, args=(i,))
    t.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2 orm使用&lt;/p&gt;
&lt;p&gt;models.py&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import datetime
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime, UniqueConstraint, Index
Base = declarative_base()

class Users(Base):
    __tablename__ = 'users'  # 数据库表名称
    id = Column(Integer, primary_key=True)  # id 主键
    name = Column(String(32), index=True, nullable=False)  # name列，索引，不可为空
    # email = Column(String(32), unique=True)
    #datetime.datetime.now不能加括号，加了括号，以后永远是当前时间
    # ctime = Column(DateTime, default=datetime.datetime.now)
    # extra = Column(Text, nullable=True)

    __table_args__ = (
        # UniqueConstraint('id', 'name', name='uix_id_name'), #联合唯一
        # Index('ix_id_name', 'name', 'email'), #索引
    )

def init_db():
    &quot;&quot;&quot;
    根据类创建数据库表
    :return:
    &quot;&quot;&quot;
    engine = create_engine(
        &quot;mysql+pymysql://root:123456@127.0.0.1:3306/aaa?charset=utf8&quot;,
        max_overflow=0,  # 超过连接池大小外最多创建的连接
        pool_size=5,  # 连接池大小
        pool_timeout=30,  # 池中没有线程最多等待的时间，否则报错
        pool_recycle=-1  # 多久之后对线程池中的线程进行一次连接的回收（重置）
    )

    Base.metadata.create_all(engine)

def drop_db():
    &quot;&quot;&quot;
    根据类删除数据库表
    :return:
    &quot;&quot;&quot;
    engine = create_engine(
        &quot;mysql+pymysql://root:123456@127.0.0.1:3306/aaa?charset=utf8&quot;,
        max_overflow=0,  # 超过连接池大小外最多创建的连接
        pool_size=5,  # 连接池大小
        pool_timeout=30,  # 池中没有线程最多等待的时间，否则报错
        pool_recycle=-1  # 多久之后对线程池中的线程进行一次连接的回收（重置）
    )

    Base.metadata.drop_all(engine)

if __name__ == '__main__':
    # drop_db()
    init_db()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;app.py&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine
from models import Users
#&quot;mysql+pymysql://root@127.0.0.1:3306/aaa&quot;
engine = create_engine(&quot;mysql+pymysql://root:123456@127.0.0.1:3306/aaa&quot;, max_overflow=0, pool_size=5)
Connection = sessionmaker(bind=engine)

# 每次执行数据库操作时，都需要创建一个Connection
con = Connection()

# ############# 执行ORM操作 #############
obj1 = Users(name=&quot;cxk&quot;)
con.add(obj1)
# 提交事务
con.commit()

# 关闭session，其实是将连接放回连接池
con.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一对多关系&quot;&gt;3.一对多关系&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Hobby(Base):
    __tablename__ = 'hobby'
    id = Column(Integer, primary_key=True)
    caption = Column(String(50), default='篮球')


class Person(Base):
    __tablename__ = 'person'
    nid = Column(Integer, primary_key=True)
    name = Column(String(32), index=True, nullable=True)
    # hobby指的是tablename而不是类名，uselist=False
    hobby_id = Column(Integer, ForeignKey(&quot;hobby.id&quot;))
    
    # 跟数据库无关，不会新增字段，只用于快速链表操作
    # 类名，backref用于反向查询
    hobby=relationship('Hobby',backref='pers')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;多对多关系&quot;&gt;4.多对多关系&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Boy2Girl(Base):
    __tablename__ = 'boy2girl'
    id = Column(Integer, primary_key=True, autoincrement=True)
    girl_id = Column(Integer, ForeignKey('girl.id'))
    boy_id = Column(Integer, ForeignKey('boy.id'))


class Girl(Base):
    __tablename__ = 'girl'
    id = Column(Integer, primary_key=True)
    name = Column(String(64), unique=True, nullable=False)


class Boy(Base):
    __tablename__ = 'boy'

    id = Column(Integer, primary_key=True, autoincrement=True)
    hostname = Column(String(64), unique=True, nullable=False)
    
    # 与生成表结构无关，仅用于查询方便,放在哪个单表中都可以
    servers = relationship('Girl', secondary='boy2girl', backref='boys')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;操作数据表&quot;&gt;5.操作数据表&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine
from models import Users
  
engine = create_engine(&quot;mysql+pymysql://root:123456@127.0.0.1:3306/aaa&quot;, max_overflow=0, pool_size=5)
Session = sessionmaker(bind=engine)
  
# 每次执行数据库操作时，都需要创建一个session
session = Session()
  
# ############# 执行ORM操作 #############
obj1 = Users(name=&quot;lqz&quot;)
session.add(obj1)
  
# 提交事务
session.commit()
# 关闭session
session.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于scoped_session实现线程安全&quot;&gt;6.基于scoped_session实现线程安全&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine
from sqlalchemy.orm import scoped_session
from models import Users

engine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6&quot;, max_overflow=0, pool_size=5)
Session = sessionmaker(bind=engine)

&quot;&quot;&quot;
# 线程安全，基于本地线程实现每个线程用同一个session
# 特殊的：scoped_session中有原来方法的Session中的以下方法：

public_methods = (
    '__contains__', '__iter__', 'add', 'add_all', 'begin', 'begin_nested',
    'close', 'commit', 'connection', 'delete', 'execute', 'expire',
    'expire_all', 'expunge', 'expunge_all', 'flush', 'get_bind',
    'is_modified', 'bulk_save_objects', 'bulk_insert_mappings',
    'bulk_update_mappings',
    'merge', 'query', 'refresh', 'rollback',
    'scalar'
)
&quot;&quot;&quot;
#scoped_session类并没有继承Session,但是却又它的所有方法
session = scoped_session(Session)
# ############# 执行ORM操作 #############
obj1 = Users(name=&quot;cxk2&quot;)
session.add(obj1)

# 提交事务
session.commit()
# 关闭session
session.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基本增删查改&quot;&gt;7.基本增删查改&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy import create_engine
from sqlalchemy.sql import text

from _3models import Users

engine = create_engine(&quot;mysql+pymysql://tomjoy:123456@127.0.0.1:3306/aaa&quot;, max_overflow=0, pool_size=5)
Session = sessionmaker(bind=engine)

session = Session()

# ################ 添加 ################

# obj1 = Users(name=&quot;wupeiqi&quot;,age=10)
# session.add(obj1)

# session.add_all([
#     Users(name=&quot;kobe&quot;,age=123),
#     Users(name=&quot;james&quot;,age=45),
# ])
# session.commit()


# ################ 删除 ################

# session.query(Users).filter(Users.id == 2).delete()
# session.commit()

# ################ 修改 ################

#传字典
# session.query(Users).filter(Users.id == 3).update({&quot;name&quot; : &quot;yao&quot;,&quot;age&quot;:38})
#类似于django的F查询
# session.query(Users).filter(Users.id == 3).update({Users.name: Users.name + &quot;099&quot;}, synchronize_session=False)
# session.query(Users).filter(Users.id == 3).update({&quot;age&quot;: Users.age + 1}, synchronize_session=&quot;evaluate&quot;)
#session.commit()

# ################ 查询 ################

# r1 = session.query(Users).all()
# print(r1)
# #如果不加all或者first就是sql语句
#
#只取age列，把name重命名为xx
# r2 = session.query(Users.name.label('xx'), Users.age.label(&quot;age1&quot;)).all()
# print(r2[0].xx)  # name=xx
# r2 = session.query(Users.name, Users.age).all()
# print(r2[0].name)
# #filter传的是表达式，filter_by传的是参数
# r3 = session.query(Users).filter(Users.name == &quot;kobe&quot;).first()
# print(r3)
# r4 = session.query(Users).filter_by(name='kobe').all()
# print(r4)
# r5 = session.query(Users).filter_by(name='kobe').first()
# print(r5)


#增，删，改都要commit()
session.commit()
session.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常用操作&quot;&gt;8.常用操作&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#　条件
ret = session.query(Users).filter_by(name='lqz').all()
#表达式，and条件连接
ret = session.query(Users).filter(Users.id &amp;gt; 1, Users.name == 'eric').all()
ret = session.query(Users).filter(Users.id.between(1, 3), Users.name == 'eric').all()
# 注意下划线
ret = session.query(Users).filter(Users.id.in_([1,3,4])).all()
#~非，除。。外
ret = session.query(Users).filter(~Users.id.in_([1,3,4])).all()
#二次筛选
ret = session.query(Users).filter(Users.id.in_(session.query(Users.id).filter_by(name='eric'))).all()
from sqlalchemy import and_, or_
#or_包裹的都是or条件，and_包裹的都是and条件
ret = session.query(Users).filter(and_(Users.id &amp;gt; 3, Users.name == 'eric')).all()
ret = session.query(Users).filter(or_(Users.id &amp;lt; 2, Users.name == 'eric')).all()
ret = session.query(Users).filter(
    or_(
        Users.id &amp;lt; 2,
        and_(Users.name == 'eric', Users.id &amp;gt; 3)
    )).all()


# 通配符，以e开头，不以e开头，第二个为e
ret = session.query(Users).filter(Users.name.like('e%')).all()
ret = session.query(Users).filter(~Users.name.like('e%')).all()
ret = session.query(Users).filter(~Users.name.like('_e%')).all()

# 限制，用于分页，区间
ret = session.query(Users)[1:2]

# 排序，根据name降序排列（从大到小）
ret = session.query(Users).order_by(Users.name.desc()).all()
# 第一个条件重复后，再按第二个条件升序排
ret = session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()

# 分组
from sqlalchemy.sql import func

ret = session.query(Users).group_by(Users.extra).all()
# 分组之后取最大id，id之和，最小id
ret = session.query(
    func.max(Users.id),
    func.sum(Users.id),
    func.min(Users.id)).group_by(Users.name).all()
# haviing筛选
ret = session.query(
    func.max(Users.id),
    func.sum(Users.id),
    func.min(Users.id)).group_by(Users.name).having(func.min(Users.id) &amp;gt;2).all()

# 连表（默认用forinkey关联）

ret = session.query(Users, Favor).filter(Users.id == Favor.nid).all()
#join表，默认是inner join
ret = session.query(Person).join(Favor).all()
# isouter=True 外连，表示Person left join Favor，没有右连接，反过来即可
ret = session.query(Person).join(Favor, isouter=True).all()
#打印原生sql
aa=session.query(Person).join(Favor, isouter=True)
print(aa)
# 自己指定on条件（连表条件）,第二个参数，支持on多个条件，用and_,同上
ret = session.query(Person).join(Favor,Person.id==Favor.id, isouter=True).all()
# 组合（了解）UNION 操作符用于合并两个或多个 SELECT 语句的结果集
#union和union all的区别？
q1 = session.query(Users.name).filter(Users.id &amp;gt; 2)
q2 = session.query(Favor.caption).filter(Favor.nid &amp;lt; 2)
ret = q1.union(q2).all()

q1 = session.query(Users.name).filter(Users.id &amp;gt; 2)
q2 = session.query(Favor.caption).filter(Favor.nid &amp;lt; 2)
ret = q1.union_all(q2).all()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;执行原生sql&quot;&gt;9.执行原生sql&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy import create_engine
from sqlalchemy.sql import text
from sqlalchemy.engine.result import ResultProxy
from db import Users, Hosts

engine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6&quot;, max_overflow=0, pool_size=5)
Session = sessionmaker(bind=engine)

session = Session()

# 查询
# cursor = session.execute('select * from users')
# result = cursor.fetchall()

# 添加
cursor = session.execute('insert into users(name) values(:value)',params={&quot;value&quot;:'lqz'})
session.commit()
print(cursor.lastrowid)

session.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一对多&quot;&gt;10.一对多&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy import create_engine
from sqlalchemy.sql import text
from sqlalchemy.engine.result import ResultProxy
from db import Users, Hosts, Hobby, Person

engine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6?charset=utf8&quot;, max_overflow=0, pool_size=5)
Session = sessionmaker(bind=engine)
session = Session()
# 添加
&quot;&quot;&quot;
session.add_all([
    Hobby(caption='乒乓球'),
    Hobby(caption='羽毛球'),
    Person(name='张三', hobby_id=3),
    Person(name='李四', hobby_id=4),
])

person = Person(name='张九', hobby=Hobby(caption='姑娘'))
session.add(person)
#添加二
hb = Hobby(caption='人妖')
hb.pers = [Person(name='文飞'), Person(name='博雅')]
session.add(hb)

session.commit()
&quot;&quot;&quot;

# 使用relationship正向查询
&quot;&quot;&quot;
v = session.query(Person).first()
print(v.name)
print(v.hobby.caption)
&quot;&quot;&quot;

# 使用relationship反向查询
&quot;&quot;&quot;
v = session.query(Hobby).first()
print(v.caption)
print(v.pers)
&quot;&quot;&quot;
#方式一，自己链表
# person_list=session.query(models.Person.name,models.Hobby.caption).join(models.Hobby,isouter=True).all()
person_list=session.query(models.Person,models.Hobby).join(models.Hobby,isouter=True).all()
for row in person_list:
    # print(row.name,row.caption)
    print(row[0].name,row[1].caption)

#方式二：通过relationship

person_list=session.query(models.Person).all()
for row in person_list:
    print(row.name,row.hobby.caption)
#查询喜欢姑娘的所有人
obj=session.query(models.Hobby).filter(models.Hobby.id==1).first()
persons=obj.pers
print(persons)
session.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;多对多&quot;&gt;11.多对多&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy import create_engine
from sqlalchemy.sql import text
from sqlalchemy.engine.result import ResultProxy
from db import Users, Hosts, Hobby, Person, Group, Server, Server2Group

engine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6?charset=utf8&quot;, max_overflow=0, pool_size=5)
Session = sessionmaker(bind=engine)
session = Session()
# 添加
&quot;&quot;&quot;
session.add_all([
    Server(hostname='c1.com'),
    Server(hostname='c2.com'),
    Group(name='A组'),
    Group(name='B组'),
])
session.commit()

s2g = Server2Group(server_id=1, group_id=1)
session.add(s2g)
session.commit()


gp = Group(name='C组')
gp.servers = [Server(hostname='c3.com'),Server(hostname='c4.com')]
session.add(gp)
session.commit()


ser = Server(hostname='c6.com')
ser.groups = [Group(name='F组'),Group(name='G组')]
session.add(ser)
session.commit()
&quot;&quot;&quot;


# 使用relationship正向查询
&quot;&quot;&quot;
v = session.query(Group).first()
print(v.name)
print(v.servers)
&quot;&quot;&quot;

# 使用relationship反向查询
&quot;&quot;&quot;
v = session.query(Server).first()
print(v.hostname)
print(v.groups)
&quot;&quot;&quot;


session.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其它&quot;&gt;12.其它&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy import create_engine
from sqlalchemy.sql import text, func
from sqlalchemy.engine.result import ResultProxy
from db import Users, Hosts, Hobby, Person, Group, Server, Server2Group

engine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6?charset=utf8&quot;, max_overflow=0, pool_size=5)
Session = sessionmaker(bind=engine)
session = Session()

# 关联子查询:correlate(Group)表示跟Group表做关联，as_scalar相当于对该sql加括号，用于放在后面当子查询
subqry = session.query(func.count(Server.id).label(&quot;sid&quot;)).filter(Server.id == Group.id).correlate(Group).as_scalar()
result = session.query(Group.name, subqry)
&quot;&quot;&quot;
SELECT `group`.name AS group_name, (SELECT count(server.id) AS sid 
FROM server 
WHERE server.id = `group`.id) AS anon_1 
FROM `group`
&quot;&quot;&quot;
'''

select * from tb where id in [select id from xxx];

select id,
        name,
        #必须保证此次查询只有一个值
        (select max(id) from xxx) as mid
from tb

例如，第三个字段只能有一个值
id name  mid
1  lqz   1，2  不合理
2  egon   2


'''
'''
成绩表：
id sid    cid    score
1  1      物理      99 
2  1      化学      88
3  2      物理      95

学生表：
id   name  每个学生总分数
1     xx      88
2     yy       77

select id，name,
(select avr(score) from 成绩表 where 成绩表.sid=学生表.id) as x
from 学生表
subqry = session.query(func.count(成绩表.scort).label(&quot;sc&quot;)).filter(学生表.id == 成绩表.sid).correlate(学生表).as_scalar()
result = session.query(学生表.name, subqry)

'''

# 原生SQL
&quot;&quot;&quot;
# 查询
cursor = session.execute('select * from users')
result = cursor.fetchall()

# 添加
cursor = session.execute('insert into users(name) values(:value)',params={&quot;value&quot;:'wupeiqi'})
session.commit()
print(cursor.lastrowid)
&quot;&quot;&quot;

session.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;flask-sqlalchemy&quot;&gt;13.Flask-SQLAlchemy&lt;/h2&gt;
&lt;p&gt;flask和SQLAchemy的管理者，通过他把他们做连接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db = SQLAlchemy()
    - 包含配置
    - 包含ORM基类
    - 包含create_all
    - engine
    - 创建连接&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;离线脚本，创建表&lt;/p&gt;
&lt;p&gt;详见代码&lt;/p&gt;
&lt;p&gt;flask-migrate&lt;br/&gt;python3 manage.py db init 初始化：只执行一次&lt;/p&gt;
&lt;p&gt;python3 manage.py db migrate 等同于 makemigartions&lt;br/&gt;python3 manage.py db upgrade 等同于migrate&lt;/p&gt;
</description>
<pubDate>Thu, 19 Dec 2019 00:40:00 +0000</pubDate>
<dc:creator>tomjoy</dc:creator>
<og:description>SQLAlchemy 1.介绍 SQLAlchemy是一个基于Python实现的ORM框架。该框架建立在 DB API之上，使用关系对象映射进行数据库操作，简言之便是：将类和对象转换成SQL，然后使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guapitomjoy/p/12065772.html</dc:identifier>
</item>
<item>
<title>2019年终总结：10场演讲、内推20人、公众号2万粉丝、Code Runner 1000万下载 - formulahendry</title>
<link>http://www.cnblogs.com/formulahendry/p/12063876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/formulahendry/p/12063876.html</guid>
<description>&lt;div readability=&quot;43.871217141595&quot;&gt;
&lt;p&gt;2019年是值得记录的一年，成长许多，也收获许多。&lt;/p&gt;
&lt;p&gt;做了 10 场大会的技术演讲，成功内推 20 人拿到微软 Offer，知乎 Live 2000 听众，公众号 2 万粉丝，GitHub 2万 star，Code Runner 突破 1000 万下载量，成立了 VS Code 中文社区。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-0&quot;&gt;10 场演讲&lt;/h2&gt;
&lt;p&gt;2018 年，只有在 Microsoft Tech Summit 上做过一场大型的公开演讲。而 2019 年却一发不可收拾，不算公司内部的演讲，公开的演讲已经有 10 场了。&lt;/p&gt;
&lt;p&gt;我还开玩笑地说：除了 PHPCon，我可能都参加了呢~&lt;/p&gt;
&lt;p&gt;唯一可惜的是，由于今年实在太忙，我参加的大会都是在上海的。婉拒了深圳、成都和杭州的几场技术大会的分享，希望明年有更多时间能去到其他城市与大家见面。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-1&quot;&gt;内推 20 人&lt;/h2&gt;
&lt;p&gt;2019 年正值微软中国扩招，于是也帮忙开始做内推。特别是帮自己所在的 Visual Studio China 组推荐了不少人。&lt;/p&gt;
&lt;p&gt;一共收到 600 多份简历，推了 200 多人，最后有 20 人成功拿到微软的 Offer。&lt;/p&gt;
&lt;p&gt;对于内推的候选人，我将全程 follow up，从职位 match，到面试建议与准备，再到面试流程，再到入职，以及大大小小各类事务（比如班车，未来园区的地铁线路规划的信息，周围的租房、学区房等等）。如果大家想试试微软的机会，也欢迎找我~&lt;/p&gt;
&lt;p&gt;之前写的这篇面经也帮助到许多人~&lt;/p&gt;

&lt;h2 data-id=&quot;heading-2&quot;&gt;知乎 Live 2000 听众&lt;/h2&gt;
&lt;p&gt;知乎 Live 是我一次新的尝试。之前做的 VS Code 相关的线下技术分享，由于时间限制，很多东西不能讲全。今年尝试了知乎 Live，通过一个半小时的时间，希望把更多 VS Code 的内容分享给大家。带领大家快速玩转 VS Code！&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;https://www.zhihu.com/lives/1124809477068849152&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;VS Code 从入门到进阶&lt;/a&gt;》&lt;/p&gt;
&lt;h2 data-id=&quot;heading-3&quot;&gt;公众号 2 万粉丝&lt;/h2&gt;
&lt;p&gt;2019 年年初开始建立了“玩转VS Code”微信公众号。公众号除了包含编程开发、业界资讯等干货外，还希望能和大家分享一下 VS Code 使用和开发的一些经验，主要希望提供的内容包括但不限于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;VS Code 快速入门&lt;/li&gt;
&lt;li&gt;VS Code 使用技巧&lt;/li&gt;
&lt;li&gt;VS Code 插件推荐&lt;/li&gt;
&lt;li&gt;VS Code 插件开发&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运营不到一年的时间，关注者已经突破了 20000！&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1857417/201912/1857417-20191219084120303-1562216514.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2 data-id=&quot;heading-4&quot;&gt;GitHub 2万 star&lt;/h2&gt;

&lt;p&gt;是的，就是我！嘿嘿~&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1857417/201912/1857417-20191218214616481-963087323.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;
&lt;h2 data-id=&quot;heading-6&quot;&gt;Code Runner 突破 1000 万下载量&lt;/h2&gt;
&lt;/p&gt;

&lt;div readability=&quot;9.4977168949772&quot;&gt;记得三年多前，韩老师那时还在写 PHP（是的，没错！在微软写 PHP），同时需要写 Python 和 Node.js 。所以在那时，支持多种语言的 VS Code 已经是笔者的主力编辑器了。唯一不足的是，韩老师希望在 VS Code 里，能有一种快捷的方式来运行各类的代码，甚至是代码片段。正是因为这个来自于自身的需求，韩老师开发了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//marketplace.visualstudio.com/items%3FitemName%3Dformulahendry.code-runner&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;📦 Code Runner插件&lt;/a&gt;。&lt;/div&gt;
&lt;p&gt;时至今日，Code Runner 已经有了超过 1000 万的下载量了！开心！！！&lt;/p&gt;
&lt;h2 data-id=&quot;heading-6&quot;&gt;成立了 VS Code 中文社区&lt;/h2&gt;

&lt;p&gt;从毕业到现在，完成了从撸代码，到做产品，然后到布道师，再到构建社区的成长。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;撸代码：毕业之初，只是一个普普通通的 CRUD 小码农。&lt;/li&gt;
&lt;li&gt;做产品：接触了 VS Code，开始&lt;a href=&quot;https://zhuanlan.zhihu.com/p/54098451&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;自己设计、开发、推广、维护 VS Code 插件&lt;/a&gt;。不只是 Developer，也是 PM、Marketing、Data Scientist。&lt;/li&gt;
&lt;li&gt;布道师：授人以鱼不如授人以渔。不只是开发插件，还把 VS Code 的经验在各类技术大会上分享给大家。&lt;/li&gt;
&lt;li&gt;构建社区：到如今，不只是一个人，我们是一个社区，一起打造 VS Code 中文社区！&lt;/li&gt;
&lt;/ol&gt;&lt;h2 data-id=&quot;heading-7&quot;&gt;展望&lt;/h2&gt;
&lt;p&gt;2019 年，是成长与收获的一年。2020 年，希望会更好！&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Thu, 19 Dec 2019 00:40:00 +0000</pubDate>
<dc:creator>formulahendry</dc:creator>
<og:description>2019年是值得记录的一年，成长许多，也收获许多。 做了 10 场大会的技术演讲，成功内推 20 人拿到微软 Offer，知乎 Live 2000 听众，公众号 2 万粉丝，GitHub 2万 sta</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/formulahendry/p/12063876.html</dc:identifier>
</item>
<item>
<title>软件设计的哲学：第八章 降低复杂性 - peida</title>
<link>http://www.cnblogs.com/peida/p/12065701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peida/p/12065701.html</guid>
<description>&lt;p&gt;本章介绍了另一种思考如何创建更深层次类的方法。假设您正在开发一个新模块，并且发现了一个不可避免的复杂性。&lt;strong&gt;哪个会更好呢：应该让模块的用户处理复杂性，还是应该在模块内部处理复杂性？&lt;/strong&gt; 如果复杂性与模块提供的功能有关，那么第二个答案通常是正确的。大多数模块的用户都比开发人员多，所以开发人员比用户遭罪更好。作为一个模块开发人员，您应该努力使您模块的使用用户生活的尽可能轻松，即使这意味着您需要额外的工作。表达这一思想的另一种方式是， 对于模块来说，&lt;strong&gt;拥有一个简单的接口比简单的实现更重要&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为一名开发人员，很容易采取相反的方式：解决简单的问题，把困难的问题推给其他人。&lt;/strong&gt; 如果出现不确定如何处理的情况，最简单的方法是抛出异常，让调用者处理它。如果您不确定要实现什么策略，您可以定义一些配置参数来控制策略，并让系统管理员为它们找出最佳值。&lt;/p&gt;
&lt;p&gt;这样的方法在短期内会使你的生活更容易，但它们会增加复杂性，因此许多人必须处理一个问题，而不是一个人。例如，如果一个类抛出一个异常，那么该类的每个调用者都必须处理它。如果类导出配置参数，则每个安装中的每个系统管理员都必须学习如何设置它们。&lt;/p&gt;
&lt;h2 id=&quot;示例编辑器文本类&quot;&gt;8.1 示例：编辑器文本类&lt;/h2&gt;
&lt;p&gt;考虑为GUI文本编辑器管理文件文本的类，这在第6章和第7章中讨论过。该类提供了将文件从磁盘读入内存、查询和修改文件在内存中的副本以及将修改后的版本写回磁盘的方法。当学生必须实现这个类时，他们中的许多人选择了一个面向行的接口，该接口具有读取、插入和删除整行文本的方法。这导致了类的简单实现，但也为更高级别的软件带来了复杂性。在用户界面级别，操作很少涉及整行。例如，击键会导致在现有行中插入单个字符;复制或删除选择项可以修改几个不同行的部分。使用面向行的文本界面，为了实现用户界面，高级软件必须分割和连接行。&lt;/p&gt;
&lt;p&gt;面向字符的接口(如6.3节中描述的接口)将复杂性拉低。用户界面软件现在可以插入和删除任意范围的文本，而不需要分割和合并行，因此变得更加简单。text类的实现可能会变得更加复杂:如果它在内部将文本表示为行集合，那么它将不得不分割和合并行来实现面向字符的操作。这种方法更好，因为它封装了文本类中分割和合并的复杂性，从而降低了系统的整体复杂性。&lt;/p&gt;
&lt;h2 id=&quot;示例配置参数&quot;&gt;8.2 示例：配置参数&lt;/h2&gt;
&lt;p&gt;配置参数是一个向上而不是向下移动复杂性的例子。类可以导出一些控制其行为的参数，而不是在内部确定特定的行为，例如缓存的大小或放弃之前重试请求的次数。然后该类的用户必须为参数指定适当的值。配置参数在当今的系统中非常流行;有些系统有数百个。&lt;/p&gt;
&lt;p&gt;支持者认为配置参数是好的，因为它们允许用户根据自己的特定需求和工作负载调整系统。在某些情况下，底层基础结构代码很难知道应用的最佳策略，而用户对他们的域要熟悉得多。例如，用户可能知道某些请求比其他请求的时间要求更严格，因此用户为这些请求指定更高的优先级是有意义的。在这种情况下，配置参数可以在更广泛的领域内获得更好的性能。&lt;/p&gt;
&lt;p&gt;然而，配置参数也为避免处理重要问题并将其传递给其他人提供了一个简单的借口。在许多情况下，用户或管理员很难或不可能确定参数的正确值。在其他情况下，只需在系统实现中做一点额外的工作，就可以自动确定正确的值。考虑一个必须处理丢失的包的网络协议。如果它发送了一个请求，但是在特定的时间段内没有收到响应，它将重新发送请求。确定重试间隔的一种方法是引入配置参数。但是，传输协议可以自己计算一个合理的值，方法是测量成功请求的响应时间，然后对重试间隔使用该时间的倍数。这种方法降低了复杂性，使用户不必确定正确的重试间隔。它还具有动态计算重试间隔的额外优点，因此如果操作条件发生变化，它将自动调整。相反，配置参数很容易过时。&lt;/p&gt;
&lt;p&gt;因此，您应该尽可能避免配置参数。在导出配置参数之前，先问问自己:“用户(或更高级别的模块)能够确定比我们在这里确定的更好的值吗?”当你创建配置参数时，看看你是否能自动计算出合理的默认值，这样用户只需要在特殊情况下提供值。理想情况下，每个模块应该完全解决一个问题;配置参数导致解决方案不完整，增加了系统的复杂性。&lt;/p&gt;
&lt;h2 id=&quot;做过了头&quot;&gt;8.3 做过了头&lt;/h2&gt;
&lt;p&gt;当把复杂性往下传递时要谨慎，这种想法很容易被夸大。一种极端的方法是将整个应用程序的所有功能都放到一个类中，这显然是没有意义的。如果(a)被降低的复杂性与类的现有功能密切相关，(b)降低复杂性将导致应用程序中其他地方的许多简化，(c)降低复杂性将简化类的接口，那么降低复杂性是最有意义的。请记住，&lt;strong&gt;目标是最小化整个系统的复杂性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第6章描述了一些学生如何在反映用户界面的text类中定义方法，例如实现backspace键功能的方法。这似乎是件好事，因为它将复杂性向下传递。但是，将用户界面的知识添加到text类并不能简化高级代码，而且用户界面知识也与text类的核心功能无关。在这种情况下，降低复杂性只会导致信息泄漏。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;8.4 结论&lt;/h2&gt;
&lt;p&gt;在开发模块时，寻找机会让自己承担一些额外的痛苦，以减少用户的痛苦。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Dec 2019 23:51:00 +0000</pubDate>
<dc:creator>peida</dc:creator>
<og:description>在开发模块时，寻找机会让自己承担一些额外的痛苦，以减少用户的痛苦。把复杂留给自己，简单留给用户。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/peida/p/12065701.html</dc:identifier>
</item>
<item>
<title>Elasticsearch系列---补充几个知识点 - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/12065697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/12065697.html</guid>
<description>&lt;h3 id=&quot;概要&quot;&gt;概要&lt;/h3&gt;
&lt;h3 id=&quot;bulk-api有趣的json格式&quot;&gt;bulk api有趣的json格式&lt;/h3&gt;
&lt;p&gt;前面《简单入门实战》一节中，有介绍bulk的使用示例，大家一定很奇怪，还有这么有趣的JSON格式，必须严格照他的换行来做，我想把JSON搞得美观可读性好一点，居然给我报错！&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{&quot;action&quot;: {&quot;meta&quot;}}\n
{&quot;data&quot;}\n
{&quot;action&quot;: {&quot;meta&quot;}}\n
{&quot;data&quot;}\n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它为什么要这样规定？&lt;/p&gt;
&lt;p&gt;我们想想bulk设计的初衷，批处理的执行效率肯定是第一优先级，此时效率&amp;gt;可读性，如果我们允许随意换行，用标准格式的JSON串，会有什么区别？&lt;/p&gt;
&lt;p&gt;如果是标准格式的JSON串，处理流程一般会是这样：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将整个json数组全部加载，解析为JSONArray对象，这时内存中同时有json串文本和JSONArray对象。&lt;/li&gt;
&lt;li&gt;循环遍历JSONArray对象，获取每个请求中的document进行路由信息。&lt;/li&gt;
&lt;li&gt;把路由到同一个shard的请求合在一组，开辟一个新的请求数组，将JSONObject放在数组里。&lt;/li&gt;
&lt;li&gt;序列化请求数组，发送到对应的节点上去。&lt;/li&gt;
&lt;li&gt;收集各节点的响应，汇总后返回给Coordinate Node。&lt;/li&gt;
&lt;li&gt;Coordinate Node收到所有的汇总信息，返回给客户端。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种方式唯一的缺点就是占用内存多，一份json串，解析为JSONArray对象，内存占用翻番，bulk里面多则几千条请求，如果JSON报文大一点，这内存耗费不是开玩笑的，如果bulk占用的内存过多，就可能会挤压其他请求的内存使用量，如搜索请求、数据分析请求等，整体性能会急速下降，严重的情况可能会触发Full GC，会导致整个JVM工作线程暂停。&lt;/p&gt;
&lt;p&gt;再看看现有的格式定义：除了delete操作占一行，其他操作都是占两行的，ES收到bulk请求时，就可以简单的按行进行切割，也不用转成json对象了，切割完的JSON读取里面的meta信息，直接路由到相应的shard，收集完响应返回即可。&lt;br/&gt;这样的好处切割逻辑更简单，都是处理小json字符串，内存快拿快放，整个ES避免对内存的大块占用，尽可能保证性能。&lt;/p&gt;
&lt;h3 id=&quot;增删改文档内部原理&quot;&gt;增删改文档内部原理&lt;/h3&gt;
&lt;p&gt;增删改的过程整体与查询文档过程一致，只是多了一个数据同步的步骤，整个过程如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201912/1834889-20191219074224236-144282120.png&quot; alt=&quot;增删改过程图示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相似的步骤不赘述。&lt;br/&gt;步骤3的前提是primary shard操作成功，异步请求，所有的replica都返回成功后，node2响应操作成功的消息给Coordinate Node，最后Coordinate Node向客户端返回成功消息，此时所有的primary shard和replica shard均已完成数据同步，数据是一致的。&lt;/p&gt;
&lt;h3 id=&quot;查询文档内部原理&quot;&gt;查询文档内部原理&lt;/h3&gt;
&lt;p&gt;当我们使用客户端（Java或Restful API）向Elasticsearch搜索文档数据时，可以向任意一个node发送请求，此时接受请求的node就是Coordinate Node，整个过程如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201912/1834889-20191219074224608-83984155.png&quot; alt=&quot;查询过程图示&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Coordinate Node接收到请求后，根据_id信息或routing信息，确定该document的路由信息，即在哪个shard里，比如说P0。&lt;/li&gt;
&lt;li&gt;Coordinate Node转发请求，使用round-robin随机轮询算法 ，在primary shard或replica shard随机挑一个，让读请求负载均衡，如node-3的R0-1&lt;/li&gt;
&lt;li&gt;接收请求的node-3搜索完成后，响应结果给Coordinate Node。&lt;/li&gt;
&lt;li&gt;Coordinate Node将响应结果返回给客户端。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意一个问题，如果document还在建立索引过程中，可能只有primary shard有，任何一个replica shard都没有，此时可能会无法读取到document，但是等document完成索引建立后，primary shard和replica shard就都有了，这个时间间隔，大概1秒左右。&lt;/p&gt;
&lt;h4 id=&quot;写一致性要求&quot;&gt;写一致性要求&lt;/h4&gt;
&lt;p&gt;Elasticsearch在尝试执行一个写操作时，可以带上consistency参数，声明我们的写一致性的级别，正确地使用这个级别，为了避免因分区故障执行写操作，导致数据不一致，这个参数有三个值供选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;one：只要有一个primary shard是active活跃可用的，就可以执行写操作&lt;/li&gt;
&lt;li&gt;all：必须所有的primary shard和replica shard都是活跃的，才可以执行这个写操作&lt;/li&gt;
&lt;li&gt;quorum：默认的值，要求所有的shard中，必须是大部分的shard都是活跃的，可用的，才可以执行这个写操作&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;这个大部分该怎么算呢&quot;&gt;这个大部分，该怎么算呢？&lt;/h5&gt;
&lt;p&gt;这个大部分，叫规定数量(quorum)，有个计算公式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int( (primary + number_of_replicas) / 2 ) + 1&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;primary 即一个索引下的primary shard数量；&lt;/li&gt;
&lt;li&gt;number_of_replicas即每个primary shard拥有的副本数量，注意不是一个索引所有的副本数量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果一个索引有3个primary shard，每个shard拥有1个replica shard，共6个shard，这样number_of_replicas就是1，代入公式计算：&lt;br/&gt;quorum = int ((3 + 1) / 2) + 1 = 3&lt;/p&gt;
&lt;p&gt;所以6个shard中必须有3个是活跃的，才让你写，如果你只启用2个node，这样活跃的replica shard只会有1个，加上primarys shard ，结果最多是2。这样是达不到quorun的值，因此将无法索引和删除任何文档。&lt;br/&gt;此时你必须启动3个节点，才能满足quorum写一致性的要求。&lt;/p&gt;
&lt;h5 id=&quot;quorum不够时的超时处理&quot;&gt;quorum不够时的超时处理&lt;/h5&gt;
&lt;p&gt;如果写操作检查前，活跃的shard不够导致无法写入时，Elasticsearch会等待，希望宕机的node能够恢复，默认60秒，可以使用timeout参数修改默认值。&lt;/p&gt;
&lt;h5 id=&quot;单node的写一致性&quot;&gt;单node的写一致性&lt;/h5&gt;
&lt;p&gt;照上面的公式算，1个node的，1个索引1个primary shard，number_of_replicas为1的情况，计算公式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;quorum = int ((1 + 1) / 2) + 1 = 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;实际只有一个primary shard是活跃的，岂不是永远无法写入？我研发机器只启动一个node，不照样增删改查？&lt;/p&gt;
&lt;p&gt;原来是Elasticsearch为了避免单一node的无法写入问题，加了判断逻辑：只有number_of_replicas大于1的时候，quorum才会生效。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本篇从性能优先的角度简单对bulk的设计作了一些补充，并对文档查询，写操作的原理过程，一致性级别，quorum的计算做了一些简单讲解，谢谢。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201912/1834889-20191219074224799-503956424.jpg&quot; alt=&quot;Java架构社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Dec 2019 23:42:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>Elasticsearch系列，补充bulk，一致性几个知识点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/12065697.html</dc:identifier>
</item>
<item>
<title>TypeScript躬行记（3）——类 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/11676023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/11676023.html</guid>
<description>&lt;p&gt;　　类是对对象的抽象，描述了对象的特征和行为，而对象就是类的实例。ES6引入了类的概念（相关内容可参考&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/10364124.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ES类&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;和&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/10364274.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ES6类的继承&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;两节），TypeScript在此基础上，不仅根据ES7等规范完善了类的语法，还添加了许多其它语法。而在使用TypeScript的类时，不必关心兼容性问题，因为这些工作已由编译器完成。&lt;/p&gt;
&lt;p&gt;　　下面是一个简单的类，包含3个成员：带private修饰符的name属性、构造函数constructor()和getName()方法，最后一句使用new运算符创建了Person类的实例，并调用了一次它的构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
  }
  getName() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
  }
}
let worker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　编译后的代码如下所示，通过传统的构造函数和基于原型的继承来模拟一个类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Person = &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* @class &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
  }
  Person.prototype.getName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
  };
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Person;
})();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; worker = &lt;span&gt;new&lt;/span&gt; Person(&quot;strick&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在ES6中，实例属性（即自有属性）得作为this对象的属性存在，并且一般都会在构造函数中执行初始化，而TypeScript允许在类中直接定义实例属性，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
  }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TypeScript中的实例属性&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不仅如此，TypeScript还提供了存在于类本身上的静态属性，即不需要实例化就能调用的属性。在下面的示例中，为age属性添加了static关键字，使其成为静态属性，通过类的名称就能直接调用它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; age: number;
}
Person.age &lt;/span&gt;= &lt;span&gt;28&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　修饰符是用于限定成员或类型的一种符号，TypeScript包含三个访问修饰符：public、private和protected，以及一个成员修饰符：readonly。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）public&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在TypeScript中，成员默认都是public的，即在派生类（也叫子类）或类的外部都能被访问。在下面的示例中，Person类中的name属性是公共的，Programmer类继承了Person类。注意，当派生类包含一个构造函数时，必须调用super()方法，执行基类（即父类）的构造函数，并且该方法得在访问this对象之前调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
  }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Programmer extends Person {
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    super(name);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在初始化Person类或Programmer类之后，就能通过创建的实例来访问name属性，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let person = &lt;span&gt;new&lt;/span&gt; Person(&quot;strick&quot;&lt;span&gt;);
person.name;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;strick&quot;&lt;/span&gt;
let programmer = &lt;span&gt;new&lt;/span&gt; Programmer(&quot;freedom&quot;&lt;span&gt;);
programmer.name;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;freedom&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）private&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当成员被修饰为private时，只能在类的内部访问它，例如在基类Person中声明一个私有的age属性，在类的实例或派生类的实例中访问age属性都会在编译阶段报错，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; age: number;
}
person.age;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
programmer.age;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当构造函数被修饰为private时（如下所示），包含它的类既不能实例化，也不能被继承。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; constructor(name: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）protected&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　此修饰符与private的行为类似，只是有一点不同，即在派生类中还是可以访问它的，例如在基类Person中声明一个受保护的school属性，在派生类中就能访问到它，如下所示（省略了基类的构造函数）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; school: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Programmer extends Person {
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    super(name);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.school = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;university&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当构造函数被修饰为protected时（如下所示），包含它的类不能实例化，但可以被继承。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; constructor(name: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）readonly&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当成员被修饰为readonly时，它就变成只读的，只能在声明时或构造函数里初始化，其它地方对它的修改都是禁止的，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt; gender: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
&lt;span&gt;  constructor() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.gender = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;            　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
&lt;span&gt;  }
}
let person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person.gender &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;            　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当readonly与其它修饰符一起使用时，需跟在它们后面，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; gender: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　参数属性可以便捷的在构造函数中声明并初始化一个类的属性，此类参数会与三个访问修饰符或readonly组合使用，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  constructor(&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;) { }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　构造函数中的name是一个参数属性，相当于在Person类中声明一个name属性，并在构造函数中为其初始化，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　抽象类是供其它派生类继承的基类，它与接口一样，不能被实例化，但可以包含成员的实现细节。在声明一个类时，如果包含abstract关键字，那么这就是一个抽象类，如下所示，当对其进行实例化时，会在编译时报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person { }
let person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在抽象类中，会声明一个或多个带abstract类修饰符的抽象方法，它们只有名称，不包含实现细节，可与访问修饰符组合使用，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; work(): &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　派生类中必须实现继承的抽象方法（如下所示），否则会在编译阶段报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Programmer extends Person {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; work(): &lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
    console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 18 Dec 2019 23:16:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>类是对对象的抽象，描述了对象的特征和行为，而对象就是类的实例。ES6引入了类的概念（相关内容可参考ES类和ES6类的继承两节），TypeScript在此基础上，不仅根据ES7等规范完善了类的语法，还添</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/11676023.html</dc:identifier>
</item>
<item>
<title>Java并发编程系列-(6) Java线程池 - 后端精进之路</title>
<link>http://www.cnblogs.com/way2backend/p/12064625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/way2backend/p/12064625.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1g9m74n4c2sj21ts0usnpd.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;线程池&quot;&gt;6. 线程池&lt;/h2&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;6.1 基本概念&lt;/h3&gt;
&lt;p&gt;在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。&lt;/p&gt;
&lt;p&gt;那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。&lt;/p&gt;
&lt;h4 id=&quot;什么时候使用线程池&quot;&gt;什么时候使用线程池？&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;单个任务处理时间比较短&lt;/li&gt;
&lt;li&gt;需要处理的任务数量很大&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用线程池好处&quot;&gt;使用线程池好处&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实现自己的线程池&quot;&gt;6.2 实现自己的线程池&lt;/h3&gt;
&lt;p&gt;实现的线程池需要满足以下基本条件：&lt;/p&gt;
&lt;p&gt;1、线程必须在池子已经创建好了，并且可以保持住，要有容器保存多个线程；&lt;br/&gt;2、线程还要能够接受外部的任务，运行这个任务。容器保持这个来不及运行的任务.&lt;/p&gt;
&lt;p&gt;以下是线程池的具体实现：&lt;/p&gt;
&lt;p&gt;线程池中实现了任务队列，用来保存所有的任务；工作线程，来执行具体的任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThreadPool2 {
    // 线程池中默认线程的个数为5
    private static int WORK_NUM = 5;
    // 队列默认任务个数为100
    private static int TASK_COUNT = 100;  
    
    // 用户在构造这个池，希望的启动的线程数
    private final int worker_num;
    // 工作线程组
    private WorkThread[] workThreads;
    // 任务队列，作为一个缓冲
    private final BlockingQueue&amp;lt;Runnable&amp;gt; taskQueue;

    // 创建具有默认线程个数的线程池
    public MyThreadPool2() {
        this(WORK_NUM,TASK_COUNT);
    }

    // 创建线程池,worker_num为线程池中工作线程的个数
    public MyThreadPool2(int worker_num,int taskCount) {
        if (worker_num&amp;lt;=0) worker_num = WORK_NUM;
        if(taskCount&amp;lt;=0) taskCount = TASK_COUNT;
        this.worker_num = worker_num;
        taskQueue = new ArrayBlockingQueue&amp;lt;&amp;gt;(taskCount);
        workThreads = new WorkThread[worker_num];
        for(int i=0;i&amp;lt;worker_num;i++) {
            workThreads[i] = new WorkThread();
            workThreads[i].start();
        }
    }

    // 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定
    public void execute(Runnable task) {
        try {
            taskQueue.put(task);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁
    public void destroy() {
        // 工作线程停止工作，且置为null
        System.out.println(&quot;ready close pool.....&quot;);
        for(int i=0;i&amp;lt;worker_num;i++) {
            workThreads[i].stopWorker();
            workThreads[i] = null;//help gc
        }
        taskQueue.clear();// 清空任务队列
    }

    // 覆盖toString方法，返回线程池信息：工作线程个数和已完成任务个数
    @Override
    public String toString() {
        return &quot;WorkThread number:&quot; + worker_num
                + &quot;  wait task number:&quot; + taskQueue.size();
    }

    /**
     * 内部类，工作线程
     */
    private class WorkThread extends Thread{
        
        @Override
        public void run(){
            Runnable r = null;
            try {
                while (!isInterrupted()) {
                    r = taskQueue.take();
                    if(r!=null) {
                        System.out.println(getId()+&quot; ready exec :&quot;+r);
                        r.run();
                    }
                    r = null;//help gc;
                } 
            } catch (Exception e) {
                // TODO: handle exception
            }
        }
        
        public void stopWorker() {
            interrupt();
        }
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是测试程序：&lt;/p&gt;
&lt;p&gt;分别创建多个任务，并放入线程池进行执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TestMyThreadPool {
    public static void main(String[] args) throws InterruptedException {
        // 创建3个线程的线程池
        MyThreadPool2 t = new MyThreadPool2(3,0);
        t.execute(new MyTask(&quot;testA&quot;));
        t.execute(new MyTask(&quot;testB&quot;));
        t.execute(new MyTask(&quot;testC&quot;));
        t.execute(new MyTask(&quot;testD&quot;));
        t.execute(new MyTask(&quot;testE&quot;));
        t.execute(new MyTask(&quot;testF&quot;));
        t.execute(new MyTask(&quot;testG&quot;));
        t.execute(new MyTask(&quot;testH&quot;));
        System.out.println(t);
        Thread.sleep(10000);
        t.destroy();// 所有线程都执行完成才destory
        System.out.println(t);
    }

    // 任务类
    static class MyTask implements Runnable {

        private String name;
        private Random r = new Random();

        public MyTask(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        @Override
        public void run() {// 执行任务
            try {
                Thread.sleep(r.nextInt(1000)+2000);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getId()+&quot; sleep InterruptedException:&quot;
                        +Thread.currentThread().isInterrupted());
            }
            System.out.println(&quot;任务 &quot; + name + &quot; 完成&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;executor框架&quot;&gt;6.3 Executor框架&lt;/h3&gt;
&lt;p&gt;Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。&lt;/p&gt;
&lt;p&gt;Executor框架的类继承关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1g9t5dk1r60j213m0pg0xl.jpg&quot; alt=&quot;Screen Shot 2019-12-11 at 10.21.49 PM.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;J.U.C中有三个Executor接口：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Executor：一个运行新任务的简单接口；&lt;/li&gt;
&lt;li&gt;ExecutorService：扩展了Executor接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；&lt;/li&gt;
&lt;li&gt;ScheduledExecutorService：扩展了ExecutorService。支持Future和定期执行任务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面分别进行介绍：&lt;/p&gt;
&lt;h4 id=&quot;executor接口&quot;&gt;1. Executor接口&lt;/h4&gt;
&lt;p&gt;Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Executor {
    void execute(Runnable command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;executor.execute(new Thread())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。&lt;/p&gt;
&lt;h4 id=&quot;executorservice接口&quot;&gt;2. ExecutorService接口&lt;/h4&gt;
&lt;p&gt;ExecutorService接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。增加了shutDown()，shutDownNow()，invokeAll()，invokeAny()和submit()等方法。如果需要支持即时关闭，也就是shutDownNow()方法，则任务需要正确处理中断。&lt;/p&gt;
&lt;h4 id=&quot;scheduledexecutorservice接口&quot;&gt;3. ScheduledExecutorService接口&lt;/h4&gt;
&lt;p&gt;ScheduledExecutorService扩展ExecutorService接口并增加了schedule方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的scheduleAtFixedRate()方法和scheduleWithFixedDelay()方法。&lt;/p&gt;
&lt;h4 id=&quot;executor框架基本使用流程&quot;&gt;4. Executor框架基本使用流程&lt;/h4&gt;
&lt;p&gt;基本使用流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1g9ty8pe5ffj20qw0k2n26.jpg&quot; alt=&quot;Picture1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;threadpoolexecutor分析&quot;&gt;6.4 ThreadPoolExecutor分析&lt;/h3&gt;
&lt;p&gt;ThreadPoolExecutor继承自AbstractExecutorService，也实现了ExecutorService接口。JDK中的提供的内置线程池基本都基于ThreadPoolExecutor实现，后面会仔细介绍。&lt;/p&gt;
&lt;h4 id=&quot;构造函数及参数意义&quot;&gt;构造函数及参数意义&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize &amp;lt; 0 ||
        maximumPoolSize &amp;lt;= 0 ||
        maximumPoolSize &amp;lt; corePoolSize ||
        keepAliveTime &amp;lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;构造方法中的字段含义如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li&gt;&lt;strong&gt;corePoolSize&lt;/strong&gt;：线程池中核心线程数，运行的线程数&amp;lt;corePoolSize，就会创建新线程，&amp;gt;= corePoolSize，这个任务就会保存到BlockingQueue，如果调用prestartAllCoreThreads（）方法就会一次性的启动corePoolSize个数的线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maximumPoolSize&lt;/strong&gt;: 允许的最大线程数，BlockingQueue也满了，&amp;lt; maximumPoolSize时候就会再次创建新的线程.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;keepAliveTime&lt;/strong&gt;: 线程空闲下来后，存活的时间，这个参数只在 &amp;gt;corePoolSize 才有用.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TimeUnit&lt;/strong&gt; unit: 存活时间的单位值.&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;workQueue&lt;/strong&gt;：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;使用直接切换队列：这种方式常用的队列是SynchronousQueue.&lt;/li&gt;
&lt;li&gt;使用无界队列：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。&lt;/li&gt;
&lt;li&gt;使用有界队列：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;threadFactory&lt;/strong&gt;：它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;handler&lt;/strong&gt;：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;线程池提供了4种策略：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AbortPolicy：直接抛出异常，这是默认策略；&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：用调用者所在的线程来执行任务；&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；&lt;/li&gt;
&lt;li&gt;DiscardPolicy：直接丢弃任务；&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;任务执行&quot;&gt;任务执行&lt;/h4&gt;
&lt;p&gt;提交任务执行，主要有execute和submit两种方式，主要区别是后者需要有返回值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;execute(Runnable command)&lt;/li&gt;
&lt;li&gt;Future submit(Callable task)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面主要介绍execute的流程：&lt;/p&gt;
&lt;p&gt;简单来说，在执行execute()方法时且状态一直是RUNNING时，的执行过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果&lt;code&gt;workerCount &amp;lt; corePoolSize&lt;/code&gt;，则创建并启动一个线程来执行新提交的任务；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;workerCount &amp;gt;= corePoolSize&lt;/code&gt;，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;workerCount &amp;gt;= corePoolSize &amp;amp;&amp;amp; workerCount &amp;lt; maximumPoolSize&lt;/code&gt;，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;workerCount &amp;gt;= maximumPoolSize&lt;/code&gt;，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整个流程可以用下图来总结：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1g9t6zixpi5j20fa0ez76k.jpg&quot; alt=&quot;Picture1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来结合代码进行分析：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * clt记录着runState和workerCount
     */
    int c = ctl.get();
    /*
     * workerCountOf方法取出低29位的值，表示当前活动的线程数；
     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；
     * 并把任务添加到该线程中。
     */
    if (workerCountOf(c) &amp;lt; corePoolSize) {
        /*
         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；
         * 如果为true，根据corePoolSize来判断；
         * 如果为false，则根据maximumPoolSize来判断
         */
        if (addWorker(command, true))
            return;
        /*
         * 如果添加失败，则重新获取ctl值
         */
        c = ctl.get();
    }
    /*
     * 如果当前线程池是运行状态并且任务添加到队列成功
     */
    if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
        // 重新获取ctl值
        int recheck = ctl.get();
        // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，
        // 这时需要移除该command
        // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回
        if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
            reject(command);
        /*
         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法
         * 这里传入的参数表示：
         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；
         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；
         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。
         */
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    /*
     * 如果执行到这里，有两种情况：
     * 1. 线程池已经不是RUNNING状态；
     * 2. 线程池是RUNNING状态，但workerCount &amp;gt;= corePoolSize并且workQueue已满。
     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；
     * 如果失败则拒绝该任务
     */
    else if (!addWorker(command, false))
        reject(command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        // 获取运行状态
        int rs = runStateOf(c);
        /*
         * 这个if判断
         * 如果rs &amp;gt;= SHUTDOWN，则表示此时不再接收新任务；
         * 接着判断以下3个条件，只要有1个不满足，则返回false：
         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务
         * 2. firsTask为空
         * 3. 阻塞队列不为空
         * 
         * 首先考虑rs == SHUTDOWN的情况
         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；
         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，
         * 因为队列中已经没有任务了，不需要再添加线程了
         */
        // Check if queue empty only if necessary.
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
            ! (rs == SHUTDOWN &amp;amp;&amp;amp;
               firstTask == null &amp;amp;&amp;amp;
               ! workQueue.isEmpty()))
            return false;
        for (;;) {
            // 获取线程数
            int wc = workerCountOf(c);
            // 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；
            // 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，
            // 如果为false则根据maximumPoolSize来比较。
            // 
            if (wc &amp;gt;= CAPACITY ||
                wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                return false;
            // 尝试增加workerCount，如果成功，则跳出第一个for循环
            if (compareAndIncrementWorkerCount(c))
                break retry;
            // 如果增加workerCount失败，则重新获取ctl的值
            c = ctl.get();  // Re-read ctl
            // 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 根据firstTask来创建Worker对象
        w = new Worker(firstTask);
        // 每一个Worker对象都会创建一个线程
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());
                // rs &amp;lt; SHUTDOWN表示是RUNNING状态；
                // 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。
                // 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务
                if (rs &amp;lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    // workers是一个HashSet
                    workers.add(w);
                    int s = workers.size();
                    // largestPoolSize记录着线程池中出现过的最大线程数量
                    if (s &amp;gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 启动线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;关闭线程池&quot;&gt;关闭线程池&lt;/h4&gt;
&lt;p&gt;关闭线程池通常有如下两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;shutdownNow():设置线程池的状态，还会尝试停止正在运行或者暂停任务的线程&lt;/li&gt;
&lt;li&gt;shutdown()：设置线程池的状态，只会中断所有没有执行任务的线程&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;线程池的参数配置&quot;&gt;线程池的参数配置&lt;/h4&gt;
&lt;p&gt;通常来讲，根据任务的性质来分，可以划分为：计算密集型（CPU），IO密集型，混合型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算密集型：加密，大数分解，正则等，线程数适当小一点，最大推荐：机器的Cpu核心数+1，为什么+1，防止页缺失，(机器的Cpu核心=Runtime.getRuntime().availableProcessors();)&lt;/li&gt;
&lt;li&gt;IO密集型：读取文件，数据库连接，网络通讯, 线程数适当大一点，可以设置为机器的Cpu核心数*2。&lt;/li&gt;
&lt;li&gt;混合型：尽量拆分，IO密集型&amp;gt;&amp;gt;计算密集型，拆分意义不大，IO密集型~=计算密集型&lt;br/&gt;队列的选择上，应该使用有界，无界队列可能会导致内存溢出，发生OOM。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;线程池的状态&quot;&gt;线程池的状态&lt;/h4&gt;
&lt;p&gt;线程池的运行状态. 线程池一共有五种状态, 分别是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务；&lt;/li&gt;
&lt;li&gt;SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；&lt;/li&gt;
&lt;li&gt;STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；&lt;/li&gt;
&lt;li&gt;TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。&lt;/li&gt;
&lt;li&gt;TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。&lt;br/&gt;进入TERMINATED的条件如下：
&lt;ul&gt;&lt;li&gt;线程池不是RUNNING状态；&lt;/li&gt;
&lt;li&gt;线程池状态不是TIDYING状态或TERMINATED状态；&lt;/li&gt;
&lt;li&gt;如果线程池状态是SHUTDOWN并且workerQueue为空；&lt;/li&gt;
&lt;li&gt;workerCount为0；&lt;/li&gt;
&lt;li&gt;设置TIDYING状态成功。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下图是线程池的状态转换过程，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1g9u13iz3mfj21ek0hy14a.jpg&quot; alt=&quot;Screen Shot 2019-12-12 at 4.39.35 PM.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;executors内置线程池&quot;&gt;6.5 Executors内置线程池&lt;/h3&gt;
&lt;p&gt;通常开发者都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。&lt;br/&gt;Executors 目前提供了 5 种不同的线程池创建配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    /**
     * Creates a thread pool that creates new threads as needed, but
     * will reuse previously constructed threads when they are
     * available.  These pools will typically improve the performance
     * of programs that execute many short-lived asynchronous tasks.
     * Calls to {@code execute} will reuse previously constructed
     * threads if available. If no existing thread is available, a new
     * thread will be created and added to the pool. Threads that have
     * not been used for sixty seconds are terminated and removed from
     * the cache. Thus, a pool that remains idle for long enough will
     * not consume any resources. Note that pools with similar
     * properties but different details (for example, timeout parameters)
     * may be created using {@link ThreadPoolExecutor} constructors.
     *
     * @return the newly created thread pool
     */
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;newFixedThreadPool(int nThreads)，创建固定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;newSingleThreadExecutor()，它的特点在于工作线程数目被限制为1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
                                    threadFactory));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public ForkJoinPool() {
        this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),
             defaultForkJoinWorkerThreadFactory, null, false,
             0, MAX_CAP, 1, null, DEFAULT_KEEPALIVE, TimeUnit.MILLISECONDS);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是ScheduledThreadPoolExecutor的构造函数，该类继承于ThreadPoolExecutor，可以看到任务存放在DelayedWorkQueue。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE,
              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
              new DelayedWorkQueue());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类中提供了多种执行定时任务的方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ScheduledFuture&amp;lt;?&amp;gt; schedule(Runnable command, long delay, TimeUnit unit)；
public &amp;lt;V&amp;gt; ScheduledFuture&amp;lt;V&amp;gt; schedule(Callable&amp;lt;V&amp;gt; callable, long delay, TimeUnit unit)；
public ScheduledFuture&amp;lt;?&amp;gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)；
public ScheduledFuture&amp;lt;?&amp;gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结下来，主要分三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;schedule：只执行一次，任务还可以延时执行&lt;/li&gt;
&lt;li&gt;scheduleAtFixedRate：提交固定时间间隔的任务&lt;/li&gt;
&lt;li&gt;scheduleWithFixedDelay：提交固定延时间隔执行的任务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意scheduleAtFixedRate和scheduleWithFixedDelay的区别，下图给出了两者执行任务时间上的示意图。scheduleAtFixedRate总是间隔固定的时间来执行task，但是如果下图中Task1执行超时，也就是超过了Fixed Time，当Task1执行完之后，Task2将立刻执行。scheduleWithFixedDelay不同的是，每个任务总是在上一个任务结束之后，等待固定的Fixed Delay Time后开始执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1g9txg873uij21360dkwft.jpg&quot; alt=&quot;Screen Shot 2019-12-12 at 2.33.08 PM.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ScheduleWorkerTime implements Runnable{
    public final static int Long_8 = 8;//任务耗时8秒
    public final static int Short_2 = 2;//任务耗时2秒
    public final static int Normal_5 = 5;//任务耗时5秒

    public static SimpleDateFormat formater = new SimpleDateFormat(
            &quot;HH:mm:ss&quot;);
    public static AtomicInteger count = new AtomicInteger(0);
    
    @Override
    public void run() {
        if(count.get()==0) {
            System.out.println(&quot;Long_8....begin:&quot;+formater.format(new Date()));
            SleepTools.second(Long_8);
            System.out.println(&quot;Long_8....end:&quot;+formater.format(new Date())); 
            count.incrementAndGet();
        }else if(count.get()==1) {
            System.out.println(&quot;Short_2 ...begin:&quot;+formater.format(new Date()));
            SleepTools.second(Short_2);
            System.out.println(&quot;Short_2 ...end:&quot;+formater.format(new Date()));
            count.incrementAndGet();            
        }else {
            System.out.println(&quot;Normal_5...begin:&quot;+formater.format(new Date()));
            SleepTools.second(Normal_5);
            System.out.println(&quot;Normal_5...end:&quot;+formater.format(new Date()));
            count.incrementAndGet(); 
        }
    }
    
    public static void main(String[] args) {
            ScheduledThreadPoolExecutor schedule = new ScheduledThreadPoolExecutor(1);
            //任务间隔6秒
            schedule.scheduleAtFixedRate(new ScheduleWorkerTime(),
                    0, 6000, TimeUnit.MILLISECONDS);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中定义了3个任务，分别执行8s，2s，5s，设置的固定间隔为6s。从输出结果可以看到，第一个场任务结束后，第二个任务立刻开始执行，第二个任务执行完时，到了10s，此时等待2s后，第三个任务开始执行。由此可以看到，当前序任务没超时，后续任务会按照指定的时间进行执行；如果有超时，则会马上执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;执行结果如下：
Long_8....begin:14:56:27
Long_8....end:14:56:35
Short_2 ...begin:14:56:35
Short_2 ...end:14:56:37
Normal_5...begin:14:56:39
Normal_5...end:14:56:44&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意最好在提交给ScheduledThreadPoolExecutor的任务要catch异常，否则发生异常之后，程序会终止运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;completionservice&quot;&gt;6.6 CompletionService&lt;/h3&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;当向Executor提交多个任务并且希望获得它们在完成之后的结果，如果用FutureTask，可以循环获取task，并调用get方法去获取task执行结果，但是如果task还未完成，获取结果的线程将阻塞直到task完成，由于不知道哪个task优先执行完毕，使用这种方式效率不会很高。&lt;/p&gt;
&lt;p&gt;在jdk5时候提出接口CompletionService，它整合了Executor和BlockingQueue的功能，可以更加方便在多个任务执行时，按任务完成顺序获取结果。&lt;/p&gt;
&lt;h4 id=&quot;使用流程&quot;&gt;使用流程&lt;/h4&gt;
&lt;p&gt;CompletionService的使用流程如下：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;声明task执行载体，线程池executor；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;声明CompletionService，来包装执行task的线程池，存放已完成状态task的阻塞队列，队列默认为基于链表结构的阻塞队列LinkedBlockingQueue；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用submit方法提交task；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用take方法获取已完成状态task。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class CompletionServiceTest {
    
    // 声明线程池
    private static ExecutorService executorService = Executors.newFixedThreadPool(100);
    
    public void test() {
        
        // 声明CompletionService包装Executor
        CompletionService&amp;lt;Long&amp;gt;  completionService = new ExecutorCompletionService&amp;lt;Long&amp;gt;(executorService);
        
        final int groupNum = 10000000 / 100;
        
        for ( int i = 1; i &amp;lt;= 100; i++) {
            int start = (i-1) * groupNum + 1;
            int end = i * groupNum;
            
            completionService.submit(new Callable&amp;lt;Long&amp;gt;() {
                
                @Override
                public Long call() throws Exception {
                    Long sum = 0L;
                    
                    for (int j = start; j &amp;lt;= end; j++) {
                        sum += j;
                    }
                    return sum;
                }
            });
        }
        
        long result = 0L;
        try {
            for (int i = 0; i &amp;lt; 100; i++) {
                long taskResult = completionService.take().get();
                System.out.println(taskResult);
                result += taskResult;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        System.out.println(&quot;the result is &quot; + result);
    }
    
    public static void main(String[] args) {
        new CompletionServiceTest().test();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;源码分析&quot;&gt;源码分析&lt;/h4&gt;
&lt;p&gt;CompletionService接口提供五个方法：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Future submit(Callable task)&lt;br/&gt;提交Callable类型的task；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Future submit(Runnable task, V result)&lt;br/&gt;提交Runnable类型的task；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Future take() throws InterruptedException&lt;br/&gt;获取并移除已完成状态的task，如果目前不存在这样的task，则等待；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Future poll()&lt;br/&gt;获取并移除已完成状态的task，如果目前不存在这样的task，返回null；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Future poll(long timeout, TimeUnit unit) throws InterruptedException&lt;br/&gt;获取并移除已完成状态的task，如果在指定等待时间内不存在这样的task，返回null。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CompletionService与普通用FutureTask获取结果的最大不同是，可以按照任务完成的顺序返回结果。具体是如何实现的呢？&lt;/p&gt;
&lt;p&gt;内部封装了一个QueueingFuture对象，并且实现了done方法，在task执行完成之后将当前task添加到completionQueue。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private static class QueueingFuture&amp;lt;V&amp;gt; extends FutureTask&amp;lt;Void&amp;gt; {
        QueueingFuture(RunnableFuture&amp;lt;V&amp;gt; task,
                       BlockingQueue&amp;lt;Future&amp;lt;V&amp;gt;&amp;gt; completionQueue) {
            super(task, null);
            this.task = task;
            this.completionQueue = completionQueue;
        }
        private final Future&amp;lt;V&amp;gt; task;
        private final BlockingQueue&amp;lt;Future&amp;lt;V&amp;gt;&amp;gt; completionQueue;
        protected void done() { completionQueue.add(task); }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;done方法将在FutureTask的finishCompletion方法中被调用。只是默认done方法是空的，completionQueue实现了该方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * Removes and signals all waiting threads, invokes done(), and
     * nulls out callable.
     */
    private void finishCompletion() {
        // assert state &amp;gt; COMPLETING;
        for (WaitNode q; (q = waiters) != null;) {
            if (WAITERS.weakCompareAndSet(this, q, null)) {
                for (;;) {
                    Thread t = q.thread;
                    if (t != null) {
                        q.thread = null;
                        LockSupport.unpark(t);
                    }
                    WaitNode next = q.next;
                    if (next == null)
                        break;
                    q.next = null; // unlink to help gc
                    q = next;
                }
                break;
            }
        }

        done();

        callable = null;        // to reduce footprint
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;https://www.jianshu.com/p/c4a31f914cc7&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;本文由『后端精进之路』原创，首发于博客 http://teckee.github.io/ , 转载请注明出处&lt;/p&gt;
&lt;p&gt;搜索『后端精进之路』关注公众号，立刻获取最新文章和&lt;strong&gt;价值2000元的BATJ精品面试课程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1g9v9luujswj21n10l9jux.jpg&quot; alt=&quot;后端精进之路.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Dec 2019 15:36:00 +0000</pubDate>
<dc:creator>后端精进之路</dc:creator>
<og:description>6. 线程池 6.1 基本概念 在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：如果并发的请求数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/way2backend/p/12064625.html</dc:identifier>
</item>
<item>
<title>初探three.js几何体 - Vadim</title>
<link>http://www.cnblogs.com/vadim-web/p/12064604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vadim-web/p/12064604.html</guid>
<description>&lt;p&gt;今天说说three.js的几何体，常见的几何体今天就不说了，今天说一说如何画直线，圆弧线，以及高级几何体。&lt;/p&gt;
&lt;h3&gt;1. 画一条直线&lt;/h3&gt;
&lt;p&gt;画直线我们使用THREE.Geometry()对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给空白几何体添加点信息，geometry会把这些点自动组合成线。&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; material = &lt;span&gt;new&lt;/span&gt; THREE.LineBasicMaterial({color: 0x00ff00&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; geometry = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Geometry();
geometry.vertices.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; THREE.Vector3(0,0,0&lt;span&gt;));
geometry.vertices.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; THREE.Vector3(10,10,10&lt;span&gt;));
geometry.vertices.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; THREE.Vector3(0,20,0&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; line = &lt;span&gt;new&lt;/span&gt; THREE.Line(geometry, material);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就在空间画出了一条折线。&lt;/p&gt;
&lt;h3&gt;2.画一条圆弧线&lt;/h3&gt;
&lt;p&gt;画圆弧线我们借助THREE.ArcCurve()对象。这个对象有点类似于d3.js中的布局（layout），它的本质就是根据参数生成一系列点坐标，他有一些方法.getPoints()从圆弧线均匀获得圆弧上面点的坐标。下面是THREE.ArcCurve()的部分源码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
THREE.ArcCurve = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    THREE.EllipseCurve.call( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以知道有6个参数，并且继承自THREE.EllipseCurve()。加下来我们来画圆弧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arc = &lt;span&gt;new&lt;/span&gt; THREE.ArcCurve(0, 0, 30, 0, Math.PI * 2, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; points = arc.getPoints(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ring = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Geometry();
points.forEach(v &lt;/span&gt;=&amp;gt; ring.vertices.push(&lt;span&gt;new&lt;/span&gt; THREE.Vector3(v.x,0&lt;span&gt;,v.y)));
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mat = &lt;span&gt;new&lt;/span&gt; THREE.LineBasicMaterial({color: 0x999900&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; line = &lt;span&gt;new&lt;/span&gt; THREE.LineLoop(ring, mat);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意points都是XY平面上面的点。最后使用THREE.LineLoop来绘制圆弧线。&lt;/p&gt;
&lt;h3&gt;3. 使用ConvexGeometry()凸包&lt;/h3&gt;
&lt;p&gt;什么是凸包？简单地说凸包就是，在空间中每三个不在一条直线的点都可以组成一个平面，如果空间中有一组点，那么会组成很多平面，如果平面不透明，我们只能看到最外层的若干个面，这个面组成的几个体就是凸包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1339752/201912/1339752-20191218232301047-1646476814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;like this !（这个只是加了岩石纹理）&lt;/p&gt;
&lt;p&gt;凸包使用起来非常简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let asteroidMate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.MeshBasicMaterial();
let points &lt;/span&gt;=&lt;span&gt; [];
let rad &lt;/span&gt;= Math.pow(Math.random(), 3) *&lt;span&gt; ASTERIODRADIUS;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0; j&amp;lt;30; j++&lt;span&gt;) {
    points.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; THREE.Vector3(Math.random() * 10, Math.random() * 10, Math.random() * 10&lt;span&gt;))
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; asteroidGeom = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.ConvexGeometry(points);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; asterMesh = &lt;span&gt;new&lt;/span&gt; THREE.Mesh(asteroidGeom, asteroidMate);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是30个点组成的随机凸包。大家可以试试用它来自定义图形或者制作随机图形。&lt;/p&gt;
&lt;h3&gt;4. LatheGeometry() 旋转体&lt;/h3&gt;
&lt;p&gt;旋转体就是将由一组点组成的线绕固定轴旋转形成的几何体，LatheGeometry有4个参数，第一个是points点数组，第二个是分段数，第三个是旋转开始角度，第四个是旋转角度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1339752/201912/1339752-20191218233433780-1079494116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
ar points =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=-12; i&amp;lt;=10; i = i + 0.5&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i &amp;lt; 0&lt;span&gt;) {
        console.log(Math.sqrt(&lt;/span&gt;36 - Math.pow(i + 6, 2)) * 1.2&lt;span&gt;, i)
        points.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; THREE.Vector3(Math.sqrt(36 - Math.pow(i + 6, 2)) * 1.2&lt;span&gt;, i))
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(i &amp;lt; 8 &amp;amp;&amp;amp; i &amp;gt;= 0&lt;span&gt;) {
        console.log(Math.sqrt(&lt;/span&gt;16 - Math.pow(i - 4, 2)) * 1.2&lt;span&gt;, i)
        points.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; THREE.Vector3(Math.sqrt(16 - Math.pow(i - 4, 2)) * 1.2&lt;span&gt;, i))
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        console.log(Math.sqrt(&lt;/span&gt;1 - Math.pow(i - 9, 2)) * 1.2&lt;span&gt;, i)
        points.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; THREE.Vector3(Math.sqrt(1 - Math.pow(i - 9, 2)) * 1.2&lt;span&gt;, i))
    }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; latheGeo = &lt;span&gt;new&lt;/span&gt; THREE.LatheGeometry(points, 30, 0, Math.PI * 2&lt;span&gt;);
latheMesh &lt;/span&gt;= createMesh(latheGeo);;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5. ExtrudeGeometry()拉伸几何体&lt;/h3&gt;
&lt;p&gt;拉伸几何体就是将一个几何体沿着Z轴拉伸形成的几何体。它的参数比较多但是不难理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1339752/201912/1339752-20191218233517805-450717277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; material = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.MeshNormalMaterial();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; shapeGeomery = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Shape();
shape.moveTo(&lt;/span&gt;-10, -10&lt;span&gt;);
shape.lineTo(&lt;/span&gt;10, -10&lt;span&gt;);
shape.lineTo(&lt;/span&gt;10, 10&lt;span&gt;);
shape.lineTo(&lt;/span&gt;-10,10&lt;span&gt;);
shape.lineTo(&lt;/span&gt;-10, -10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; geometry = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.ExtrudeGeometry(shapeGeomery, {
    amount: &lt;/span&gt;2, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉伸的深度&lt;/span&gt;
    bevelThickness: 2,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;斜角的深度&lt;/span&gt;
    bevelSize: 3,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;斜角的高度&lt;/span&gt;
    bevelSegments: 30,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;斜角分段数&lt;/span&gt;
    bevelEnabled: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启斜角&lt;/span&gt;
    curveSegments: 12,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉伸的段数&lt;/span&gt;
    steps: 1  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;沿深度方向的段数&lt;/span&gt;
&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; shape = &lt;span&gt;new&lt;/span&gt; THREE.Mesh(geometry, material);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里注意几点，&lt;br/&gt;1.ExtrudeGeometry()的第一个参数是一个shape对象，&lt;br/&gt;2.区分一下这三个分段数，bevelSegments是斜角的分段，它影响斜角的光滑程度，curveSegments是拉伸曲线的段数，steps是沿深度方向的段数。&lt;/p&gt;
&lt;h3&gt;6.TubeGeometry()沿曲线拉伸&lt;/h3&gt;
&lt;p&gt;这个方法很简单，就是验证曲线拉伸成一根管，简单的东西直接上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; points =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; controls.numberOfPoints; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; randomX = -20 + Math.round(Math.random() * 50&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; randomY = -15 + Math.round(Math.random() * 40&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; randomZ = -20 + Math.round(Math.random() * 40&lt;span&gt;);

    points.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Vector3(randomX, randomY, randomZ));
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tubeGeometry = &lt;span&gt;new&lt;/span&gt; THREE.TubeGeometry(&lt;span&gt;new&lt;/span&gt; THREE.SplineCurve3(points), 64, 3, 16, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; meshMaterial = &lt;span&gt;new&lt;/span&gt; THREE.MeshBasicMaterial({color: 0x00ff00, transparent: &lt;span&gt;true&lt;/span&gt;, opacity: 0.2&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tubeMesh = &lt;span&gt;new&lt;/span&gt; THREE.Mesh(tubeGeometry, meshMaterial)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里只需注意TubeGeometry()的第一个参数是一个SplineCurve3对象，需要将三维点数组用SplineCurve3处理成三维曲线。&lt;/p&gt;
&lt;h3&gt;7.ParametricGeometry()基于等式的几何体&lt;/h3&gt;
&lt;p&gt;这个东西类似于高数中的参数方程，通过三阶等式来创建空间曲面,使用ParametricGeometry()的时候，我特意使用了v69版本和v104两个版本，使用方法是不同的。下面我们从代码中寻找区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1339752/201912/1339752-20191218233535947-825557099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; v69&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; oldVersion = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (u, v) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = u * 50 - 25&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; z = v * 50 - 25&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = Math.sin(u * 50 - 25) + Math.sin(v * 50 - 25) +  Math.pow((Math.pow((u - 0.5), 2) + Math.pow((v - 0.5), 2)) * 10, 2) - 10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Vector3(x, y, z);
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; geometry = &lt;span&gt;new&lt;/span&gt; THREE.ParametricGeometry(oldVersion, 120, 120)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; newVersion = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (u, v, target) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = u * 50 - 25&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; z = v * 50 - 25&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = Math.sin(u * 50 - 25) + Math.sin(v * 50 - 25) +  Math.pow((Math.pow((u - 0.5), 2) + Math.pow((v - 0.5), 2)) * 10, 2) - 10&lt;span&gt;;
    target.set(x,y,z);
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; geometry = &lt;span&gt;new&lt;/span&gt; THREE.ParametricGeometry(newVersion, 120, 120)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出方法中传递了第三个参数，这里使用set方法做了优化，（所以说每当出现新的js标准后，都出新生一些框架或者出现新版本）。相信喜欢数学的小伙伴都会非常喜欢这个几何体。下面随便展示一个demo&lt;/p&gt;
&lt;p&gt;### 8. 组合网格&lt;br/&gt;未完待续。。。（这将是一个非常有意思的几何体）&lt;br/&gt;### 9. Geometry()实现自定义面&lt;br/&gt;未完待续。。。（同样可以很发散）&lt;/p&gt;

&lt;p&gt;更多demo请移步至原文&lt;/p&gt;
&lt;p&gt;转载请注明原文地址 &lt;a title=&quot;http://www.bettersmile.cn&quot; href=&quot;http://www.bettersmile.cn&quot; target=&quot;_blank&quot;&gt;http://www.bettersmile.cn&lt;/a&gt; 郭志强的博客&lt;/p&gt;
</description>
<pubDate>Wed, 18 Dec 2019 15:32:00 +0000</pubDate>
<dc:creator>Vadim</dc:creator>
<og:description>今天说说three.js的几何体，常见的几何体今天就不说了，今天说一说如何画直线，圆弧线，以及高级几何体。 1. 画一条直线 画直线我们使用THREE.Geometry()对象。 //给空白几何体添加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vadim-web/p/12064604.html</dc:identifier>
</item>
<item>
<title>【朝花夕拾】Android多线程之（三）runOnUiThread篇——程序猿们的贴心小棉袄 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/12064596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/12064596.html</guid>
<description>&lt;p&gt;       runOnUiThread()的使用以及原理实在是太简单了，简单到笔者开始都懒得单独开一篇文章来写它。当然这里说的简单，是针对对Handler比较熟悉的童鞋而言的。不过麻雀虽小，五脏俱全，runOnUiThread()好歹也算得上是一方诸侯，在子线程切换到主线程的众多方法中，有着自己的一席之地，所以，必须得给它单独列传。&lt;/p&gt;
&lt;p&gt;       好了，闲话休提，言归正传。runOnUiThread()是Activity类中的方法，它用于从子线程中切换到主线程来执行一些需要再主线程执行的操作。这里先直接看一个例子，看看它是如何使用的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; TextView textView;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        setContentView(R.layout.activity_main);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         textView =&lt;span&gt; findViewById(R.id.tv_test);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something takes long time in the work-thread&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 MainActivity.&lt;span&gt;this&lt;/span&gt;.runOnUiThread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                         textView.setText(&quot;test&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单吧，在子线程中直接调用runOnUiThread方法，第15行就切换到主线程了，直接修改UI。如果使用Lambda表达式，看起来就更简单了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something takes long time in the work-thread&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     MainActivity.&lt;span&gt;this&lt;/span&gt;.runOnUiThread(() -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         textView.setText(&quot;test&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相比于通过显示使用Handler，重写AsyncTask方法来说，是不是爽得不要不要的？&lt;/p&gt;
&lt;p&gt;       不仅仅使用简单，其原理也非常简单，底层实际上也是封装的Handler来实现的，如下是关键代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=========Activity=========&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Handler mHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Handler();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Thread mUiThread;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; attach(...）{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     mUiThread =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * Runs the specified action on the UI thread. If the current thread is the UI
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * thread, then the action is executed immediately. If the current thread is
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * not the UI thread, the action is posted to the event queue of the UI thread.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; action the action to run on the UI thread
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; runOnUiThread(Runnable action) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Thread.currentThread() !=&lt;span&gt; mUiThread) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        mHandler.post(action);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        action.run();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mHander是Activity的成员变量，在Activity实例化的时候也跟着初始化了，MainActivity继承自Activity，这里mHandler使用的looper自然是main looper了。attach方法也是在主线程中调用的，mUiThread就表示主线程了。第19行的方法就很容易理解了，如果该方法是运行在主线程，Runnable的run方法会马上运行；而如果不是在主线程，就post到主线程的looper的MessageQueue中排队执行。&lt;/p&gt;
&lt;p&gt;       基本使用和基本原理就讲完了，够简单吧，也确实没多少重要的东西可讲的了！真不愧是广大程序猿们的贴心小棉袄，要是Android的各个方法都这么简单，想必就没有那么多秃顶了！&lt;/p&gt;
&lt;p&gt;       好了，洗澡睡觉！&lt;/p&gt;
</description>
<pubDate>Wed, 18 Dec 2019 15:29:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>runOnUiThread()是Activity类中的方法，它用于从子线程中切换到主线程来执行一些操作。相比于通过显示使用Handler，重写AsyncTask方法来说，它的使用和原理要简单得多。真不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/andy-songwei/p/12064596.html</dc:identifier>
</item>
<item>
<title>React中setState学习总结 - 消逝的风i</title>
<link>http://www.cnblogs.com/abc-x/p/12051364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abc-x/p/12051364.html</guid>
<description>&lt;p&gt;react中setState方法到底是异步还是同步，其实这个是分在什么&lt;strong&gt;条件&lt;/strong&gt;下是异步或者同步。&lt;/p&gt;
&lt;p&gt;1.先来回顾一下react组件中改变state的几种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;

class Index extends Component {
    state&lt;/span&gt;=&lt;span&gt;{
        count:&lt;/span&gt;1&lt;span&gt;
    }
    test1 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过回调函数的形式&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
            count:state.count&lt;/span&gt;+1&lt;span&gt;
        }));
        console.log(&lt;/span&gt;'test1 setState()之后',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
    }
    test2 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过对象的方式(注意：此方法多次设置会合并且只调用一次！)&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
            count:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;
        });
        console.log(&lt;/span&gt;'test2 setState()之后',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
    }
    test3 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不能直接修改state的值，此方法强烈不建议！！！因为不会触发重新render&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.state.count += 1&lt;span&gt;;
    }
    test4 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在第二个callback拿到更新后的state&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
            count:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;
        },()&lt;/span&gt;=&amp;gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在状态更新且页面更新(render)后执行&lt;/span&gt;
            console.log('test4 setState()之后',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        });
    }
    render() {
        console.log(&lt;/span&gt;'render'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div&amp;gt;
                &amp;lt;h1&amp;gt;currentState:{&lt;span&gt;this&lt;/span&gt;.state.count}&amp;lt;/h1&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.test1}&amp;gt;测试1&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.test2}&amp;gt;测试2&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.test3} style={{color:'red'}}&amp;gt;测试3&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.test4}&amp;gt;测试4&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
&lt;span&gt;        )
    }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Index;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.setState()更新状态是异步还是同步：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要判断执行setState的位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步：&lt;/strong&gt;在react控制的回调函数中：生命周期钩子/react事件监听回调&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;

class Index extends Component {
    state&lt;/span&gt;=&lt;span&gt;{
        count:&lt;/span&gt;1&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
    react事件监听回调中，setState()是异步状态
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    update1 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'update1 setState()之前',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
            count:state.count&lt;/span&gt;+1&lt;span&gt;
        }));
        console.log(&lt;/span&gt;'update1 setState()之后',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
    react生命周期钩子中，setState()是异步更新状态
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    componentDidMount() {
        console.log(&lt;/span&gt;'componentDidMount setState()之前',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
            count:state.count&lt;/span&gt;+1&lt;span&gt;
        }));
        console.log(&lt;/span&gt;'componentDidMount setState()之后',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
    }
    
    render() {
        console.log(&lt;/span&gt;'render'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div&amp;gt;
                &amp;lt;h1&amp;gt;currentState:{&lt;span&gt;this&lt;/span&gt;.state.count}&amp;lt;/h1&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update1}&amp;gt;测试1&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update2}&amp;gt;测试2&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
&lt;span&gt;        )
    }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Index;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;异步：&lt;/strong&gt;非react控制的异步回调函数中：定时器回调/原生事件监听回调/Promise&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;

class Index extends Component {
    state&lt;/span&gt;=&lt;span&gt;{
        count:&lt;/span&gt;1&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
    定时器回调
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    update1 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        setTimeout(()&lt;/span&gt;=&amp;gt;&lt;span&gt;{
            console.log(&lt;/span&gt;'setTimeout setState()之前',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
                count:state.count&lt;/span&gt;+1&lt;span&gt;
            }));
            console.log(&lt;/span&gt;'setTimeout setState()之后',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;        });
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
    原生事件回调
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    update2 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        const h1 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refs.count;
        h1.onclick &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'onClick setState()之前',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
                count:state.count&lt;/span&gt;+1&lt;span&gt;
            }));
            console.log(&lt;/span&gt;'onClick setState()之后',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;        }
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
    Promise回调
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    update3 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        Promise.resolve().then(value&lt;/span&gt;=&amp;gt;&lt;span&gt;{
            console.log(&lt;/span&gt;'Promise setState()之前',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
                count:state.count&lt;/span&gt;+1&lt;span&gt;
            }));
            console.log(&lt;/span&gt;'Promise setState()之后',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;        });
    }
    
    render() {
        console.log(&lt;/span&gt;'render'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div&amp;gt;
                &amp;lt;h1 ref='count'&amp;gt;currentState:{&lt;span&gt;this&lt;/span&gt;.state.count}&amp;lt;/h1&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update1}&amp;gt;测试1&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update2}&amp;gt;测试2&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update3}&amp;gt;测试3&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
&lt;span&gt;        )
    }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Index;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.setState()多次调用的问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步的setState()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）多次调用，处理方法：&lt;/p&gt;
&lt;p&gt;setState({})：合并更新一次状态，只调用一次render()更新界面，多次调用会合并为一个，后面的值会覆盖前面的值。&lt;/p&gt;
&lt;p&gt;setState(fn)：更新多次状态，只调用一次render()更新界面，多次调用&lt;strong&gt;不会&lt;/strong&gt;合并为一个，后面的值会覆盖前面的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;

class Index extends Component {
    state&lt;/span&gt;=&lt;span&gt;{
        count:&lt;/span&gt;1&lt;span&gt;
    }
    update1 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'update1 setState()之前',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
            count:state.count&lt;/span&gt;+1&lt;span&gt;
        }));
        console.log(&lt;/span&gt;'update1 setState()之后',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        console.log(&lt;/span&gt;'update1 setState()之前2',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
            count:state.count&lt;/span&gt;+1&lt;span&gt;
        }));
        console.log(&lt;/span&gt;'update1 setState()之后2',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
    }
    update2 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'update2 setState()之前',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
            count:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;
        });
        console.log(&lt;/span&gt;'update2 setState()之后',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        console.log(&lt;/span&gt;'update2 setState()之前2',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
            count:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;
        });
        console.log(&lt;/span&gt;'update2 setState()之后2',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
    }
    update3 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'update3 setState()之前',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
            count:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;
        });
        console.log(&lt;/span&gt;'update3 setState()之后',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        console.log(&lt;/span&gt;'update3 setState()之前2',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
            count:state.count&lt;/span&gt;+1&lt;span&gt;
        }));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里需要注意setState传参为函数模式时，state会确保拿到的是最新的值&lt;/span&gt;
        console.log('update3 setState()之后2',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
    }
    update4 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'update4 setState()之前',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState((state,props)=&amp;gt;&lt;span&gt;({
            count:state.count&lt;/span&gt;+1&lt;span&gt;
        }));
        console.log(&lt;/span&gt;'update4 setState()之后',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        console.log(&lt;/span&gt;'update4 setState()之前2',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
            count:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;
        });&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里需要注意的是如果setState传参为对象且在最后，那么会与之前的setState合并&lt;/span&gt;
        console.log('update4 setState()之后2',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.count);
    }
    render() {
        console.log(&lt;/span&gt;'render'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div&amp;gt;
                &amp;lt;h1&amp;gt;currentState:{&lt;span&gt;this&lt;/span&gt;.state.count}&amp;lt;/h1&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update1}&amp;gt;测试1&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update2}&amp;gt;测试2&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update3}&amp;gt;测试3&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update4}&amp;gt;测试4&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
&lt;span&gt;        )
    }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Index;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）如何得到setState异步更新后的状态数据：&lt;/p&gt;
&lt;p&gt;在setState()的callback回调函数中&lt;/p&gt;
&lt;p&gt;4.react中常见的setState面试题（setState执行顺序）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setState执行顺序&lt;/span&gt;
&lt;span&gt;class Index extends Component {
    state&lt;/span&gt;=&lt;span&gt;{
        count:&lt;/span&gt;0&lt;span&gt;
    }
    componentDidMount() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({count:&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;});
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({count:&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;});
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 =&amp;gt; 0&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setState(state=&amp;gt;({count:state.count+1&lt;span&gt;}));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState(state=&amp;gt;({count:state.count+1&lt;span&gt;}));
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3 =&amp;gt; 0&lt;/span&gt;
        setTimeout(() =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({count:&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;});
            console.log(&lt;/span&gt;'setTimeout',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10 =&amp;gt; 6&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.setState({count:&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;});
            console.log(&lt;/span&gt;'setTimeout',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 12 =&amp;gt; 7&lt;/span&gt;
&lt;span&gt;        });
        Promise.resolve().then(value&lt;/span&gt;=&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({count:&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;});
            console.log(&lt;/span&gt;'Promise',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6 =&amp;gt; 4&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.setState({count:&lt;span&gt;this&lt;/span&gt;.state.count+1&lt;span&gt;});
            console.log(&lt;/span&gt;'Promise',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8 =&amp;gt; 5&lt;/span&gt;
&lt;span&gt;        });
    }
    render() {
        console.log(&lt;/span&gt;'render',&lt;span&gt;this&lt;/span&gt;.state.count);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1 =&amp;gt; 0  // 4 =&amp;gt; 3 // 5 =&amp;gt; 4 // 7 =&amp;gt; 5 // 9 =&amp;gt; 6 // 11 =&amp;gt; 7&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div&amp;gt;
                &amp;lt;h1&amp;gt;currentState:{&lt;span&gt;this&lt;/span&gt;.state.count}&amp;lt;/h1&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update1}&amp;gt;测试1&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update2}&amp;gt;测试2&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update3}&amp;gt;测试3&amp;lt;/button&amp;gt;
                &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.update4}&amp;gt;测试4&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
&lt;span&gt;        )
    }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Index;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;总结：react中setState()更新状态的2种写法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）setState(updater，[callback])&lt;/p&gt;
&lt;p&gt;updater：为返回stateChange对象的函数：(state,props)=&amp;gt;stateChange，接收的&lt;strong&gt;state和props都保证为最新&lt;/strong&gt;的&lt;/p&gt;
&lt;p&gt;2）setState(stateChange，[callback])&lt;/p&gt;
&lt;p&gt;stateChange为对象，callback是可选的回调函数，在&lt;strong&gt;状态更新且界面更新&lt;/strong&gt;后才执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象是函数方式的简写方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果新状态不依赖于原状态，则使用对象方式；&lt;/p&gt;
&lt;p&gt;如果新状态依赖于原状态，则使用函数方式；&lt;/p&gt;
&lt;p&gt;如果需要在setState()后获取最新的状态数据，在第二个callback函数中获取&lt;/p&gt;
</description>
<pubDate>Wed, 18 Dec 2019 15:20:00 +0000</pubDate>
<dc:creator>消逝的风i</dc:creator>
<og:description>react中setState方法到底是异步还是同步，其实这个是分在什么条件下是异步或者同步。 1.先来回顾一下react组件中改变state的几种方式： import React, { Compone</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/abc-x/p/12051364.html</dc:identifier>
</item>
</channel>
</rss>