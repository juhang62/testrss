<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>死磕 java集合之ConcurrentHashMap源码分析（三） - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-sourcecode.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-sourcecode.html</guid>
<description>&lt;p&gt;本章接着上两章，链接直达：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rlyoQp4ngTX8mjGDJgJIRA&quot;&gt;死磕 java集合之ConcurrentHashMap源码分析（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/_Bf6XcH51lssC0mdF_oW9A&quot;&gt;死磕 java集合之ConcurrentHashMap源码分析（二）&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;删除元素&quot;&gt;删除元素&lt;/h3&gt;
&lt;p&gt;删除元素跟添加元素一样，都是先找到元素所在的桶，然后采用分段锁的思想锁住整个桶，再进行操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public V remove(Object key) {
    // 调用替换节点方法
    return replaceNode(key, null, null);
}

final V replaceNode(Object key, V value, Object cv) {
    // 计算hash
    int hash = spread(key.hashCode());
    // 自旋
    for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
        Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0 ||
                (f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null)
            // 如果目标key所在的桶不存在，跳出循环返回null
            break;
        else if ((fh = f.hash) == MOVED)
            // 如果正在扩容中，协助扩容
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // 标记是否处理过
            boolean validated = false;
            synchronized (f) {
                // 再次验证当前桶第一个元素是否被修改过
                if (tabAt(tab, i) == f) {
                    if (fh &amp;gt;= 0) {
                        // fh&amp;gt;=0表示是链表节点
                        validated = true;
                        // 遍历链表寻找目标节点
                        for (Node&amp;lt;K,V&amp;gt; e = f, pred = null;;) {
                            K ek;
                            if (e.hash == hash &amp;amp;&amp;amp;
                                    ((ek = e.key) == key ||
                                            (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                // 找到了目标节点
                                V ev = e.val;
                                // 检查目标节点旧value是否等于cv
                                if (cv == null || cv == ev ||
                                        (ev != null &amp;amp;&amp;amp; cv.equals(ev))) {
                                    oldVal = ev;
                                    if (value != null)
                                        // 如果value不为空则替换旧值
                                        e.val = value;
                                    else if (pred != null)
                                        // 如果前置节点不为空
                                        // 删除当前节点
                                        pred.next = e.next;
                                    else
                                        // 如果前置节点为空
                                        // 说明是桶中第一个元素，删除之
                                        setTabAt(tab, i, e.next);
                                }
                                break;
                            }
                            pred = e;
                            // 遍历到链表尾部还没找到元素，跳出循环
                            if ((e = e.next) == null)
                                break;
                        }
                    }
                    else if (f instanceof TreeBin) {
                        // 如果是树节点
                        validated = true;
                        TreeBin&amp;lt;K,V&amp;gt; t = (TreeBin&amp;lt;K,V&amp;gt;)f;
                        TreeNode&amp;lt;K,V&amp;gt; r, p;
                        // 遍历树找到了目标节点
                        if ((r = t.root) != null &amp;amp;&amp;amp;
                                (p = r.findTreeNode(hash, key, null)) != null) {
                            V pv = p.val;
                            // 检查目标节点旧value是否等于cv
                            if (cv == null || cv == pv ||
                                    (pv != null &amp;amp;&amp;amp; cv.equals(pv))) {
                                oldVal = pv;
                                if (value != null)
                                    // 如果value不为空则替换旧值
                                    p.val = value;
                                else if (t.removeTreeNode(p))
                                    // 如果value为空则删除元素
                                    // 如果删除后树的元素个数较少则退化成链表
                                    // t.removeTreeNode(p)这个方法返回true表示删除节点后树的元素个数较少
                                    setTabAt(tab, i, untreeify(t.first));
                            }
                        }
                    }
                }
            }
            // 如果处理过，不管有没有找到元素都返回
            if (validated) {
                // 如果找到了元素，返回其旧值
                if (oldVal != null) {
                    // 如果要替换的值为空，元素个数减1
                    if (value == null)
                        addCount(-1L, -1);
                    return oldVal;
                }
                break;
            }
        }
    }
    // 没找到元素返回空
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）计算hash；&lt;/p&gt;
&lt;p&gt;（2）如果所在的桶不存在，表示没有找到目标元素，返回；&lt;/p&gt;
&lt;p&gt;（3）如果正在扩容，则协助扩容完成后再进行删除操作；&lt;/p&gt;
&lt;p&gt;（4）如果是以链表形式存储的，则遍历整个链表查找元素，找到之后再删除；&lt;/p&gt;
&lt;p&gt;（5）如果是以树形式存储的，则遍历树查找元素，找到之后再删除；&lt;/p&gt;
&lt;p&gt;（6）如果是以树形式存储的，删除元素之后树较小，则退化成链表；&lt;/p&gt;
&lt;p&gt;（7）如果确实删除了元素，则整个map元素个数减1，并返回旧值；&lt;/p&gt;
&lt;p&gt;（8）如果没有删除元素，则返回null；&lt;/p&gt;
&lt;h3 id=&quot;获取元素&quot;&gt;获取元素&lt;/h3&gt;
&lt;p&gt;获取元素，根据目标key所在桶的第一个元素的不同采用不同的方式获取元素，关键点在于find()方法的重写。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public V get(Object key) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; e, p; int n, eh; K ek;
    // 计算hash
    int h = spread(key.hashCode());
    // 如果元素所在的桶存在且里面有元素
    if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (e = tabAt(tab, (n - 1) &amp;amp; h)) != null) {
        // 如果第一个元素就是要找的元素，直接返回
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek)))
                return e.val;
        }
        else if (eh &amp;lt; 0)
            // hash小于0，说明是树或者正在扩容
            // 使用find寻找元素，find的寻找方式依据Node的不同子类有不同的实现方式
            return (p = e.find(h, key)) != null ? p.val : null;

        // 遍历整个链表寻找元素
        while ((e = e.next) != null) {
            if (e.hash == h &amp;amp;&amp;amp;
                    ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek))))
                return e.val;
        }
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）hash到元素所在的桶；&lt;/p&gt;
&lt;p&gt;（2）如果桶中第一个元素就是该找的元素，直接返回；&lt;/p&gt;
&lt;p&gt;（3）如果是树或者正在迁移元素，则调用各自Node子类的find()方法寻找元素；&lt;/p&gt;
&lt;p&gt;（4）如果是链表，遍历整个链表寻找元素；&lt;/p&gt;
&lt;p&gt;（5）获取元素没有加锁；&lt;/p&gt;
&lt;h3 id=&quot;获取元素个数&quot;&gt;获取元素个数&lt;/h3&gt;
&lt;p&gt;元素个数的存储也是采用分段的思想，获取元素个数时需要把所有段加起来。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int size() {
    // 调用sumCount()计算元素个数
    long n = sumCount();
    return ((n &amp;lt; 0L) ? 0 :
            (n &amp;gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                    (int)n);
}

final long sumCount() {
    // 计算CounterCell所有段及baseCount的数量之和
    CounterCell[] as = counterCells; CounterCell a;
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i &amp;lt; as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）元素的个数依据不同的线程存在在不同的段里；（见addCounter()分析）&lt;/p&gt;
&lt;p&gt;（2）计算CounterCell所有段及baseCount的数量之和；&lt;/p&gt;
&lt;p&gt;（3）获取元素个数没有加锁；&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）ConcurrentHashMap是HashMap的线程安全版本；&lt;/p&gt;
&lt;p&gt;（2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；&lt;/p&gt;
&lt;p&gt;（3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多；&lt;/p&gt;
&lt;p&gt;（4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等；&lt;/p&gt;
&lt;p&gt;（5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；&lt;/p&gt;
&lt;p&gt;（6）sizeCtl = -1，表示正在进行初始化；&lt;/p&gt;
&lt;p&gt;（7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；&lt;/p&gt;
&lt;p&gt;（8）sizeCtl &amp;gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；&lt;/p&gt;
&lt;p&gt;（9）sizeCtl = (resizeStamp &amp;lt;&amp;lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；&lt;/p&gt;
&lt;p&gt;（10）更新操作时如果正在进行扩容，当前线程协助扩容；&lt;/p&gt;
&lt;p&gt;（11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想；&lt;/p&gt;
&lt;p&gt;（12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键；&lt;/p&gt;
&lt;p&gt;（13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕；&lt;/p&gt;
&lt;p&gt;（14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现；&lt;/p&gt;
&lt;p&gt;（15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用；&lt;/p&gt;
&lt;p&gt;（16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）；&lt;/p&gt;
&lt;p&gt;（17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的；&lt;/p&gt;
&lt;p&gt;（18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；&lt;/p&gt;
&lt;p&gt;（19）ConcurrentHashMap中不能存储key或value为null的元素；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋值得学习的技术&quot;&gt;彩蛋——值得学习的技术&lt;/h2&gt;
&lt;p&gt;ConcurrentHashMap中有哪些值得学习的技术呢？&lt;/p&gt;
&lt;p&gt;我认为有以下几点：&lt;/p&gt;
&lt;p&gt;（1）CAS + 自旋，乐观锁的思想，减少线程上下文切换的时间；&lt;/p&gt;
&lt;p&gt;（2）分段锁的思想，减少同一把锁争用带来的低效问题；&lt;/p&gt;
&lt;p&gt;（3）CounterCell，分段存储元素个数，减少多线程同时更新一个字段带来的低效；&lt;/p&gt;
&lt;p&gt;（4）@sun.misc.Contended（CounterCell上的注解），避免伪共享；（p.s.伪共享我们后面也会讲的^^）&lt;/p&gt;
&lt;p&gt;（5）多线程协同进行扩容；&lt;/p&gt;
&lt;p&gt;（6）你又学到了哪些呢？&lt;/p&gt;
&lt;h2 id=&quot;彩蛋不能解决的问题&quot;&gt;彩蛋——不能解决的问题&lt;/h2&gt;
&lt;p&gt;ConcurrentHashMap不能解决什么问题呢？&lt;/p&gt;
&lt;p&gt;请看下面的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static final Map&amp;lt;Integer, Integer&amp;gt; map = new ConcurrentHashMap&amp;lt;&amp;gt;();

public void unsafeUpdate(Integer key, Integer value) {
    Integer oldValue = map.get(key);
    if (oldValue == null) {
        map.put(key, value);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里如果有多个线程同时调用unsafeUpdate()这个方法，ConcurrentHashMap还能保证线程安全吗？&lt;/p&gt;
&lt;p&gt;答案是不能。因为get()之后if之前可能有其它线程已经put()了这个元素，这时候再put()就把那个线程put()的元素覆盖了。&lt;/p&gt;
&lt;p&gt;那怎么修改呢？&lt;/p&gt;
&lt;p&gt;答案也很简单，使用putIfAbsent()方法，它会保证元素不存在时才插入元素，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void safeUpdate(Integer key, Integer value) {
    map.putIfAbsent(key, value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，如果上面oldValue不是跟null比较，而是跟一个特定的值比如1进行比较怎么办？也就是下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void unsafeUpdate(Integer key, Integer value) {
    Integer oldValue = map.get(key);
    if (oldValue == 1) {
        map.put(key, value);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话就没办法使用putIfAbsent()方法了。&lt;/p&gt;
&lt;p&gt;其实，ConcurrentHashMap还提供了另一个方法叫replace(K key, V oldValue, V newValue)可以解决这个问题。&lt;/p&gt;
&lt;p&gt;replace(K key, V oldValue, V newValue)这个方法可不能乱用，如果传入的newValue是null，则会删除元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void safeUpdate(Integer key, Integer value) {
    map.replace(key, 1, value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，如果if之后不是简单的put()操作，而是还有其它业务操作，之后才是put()，比如下面这样，这该怎么办呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void unsafeUpdate(Integer key, Integer value) {
    Integer oldValue = map.get(key);
    if (oldValue == 1) {
        System.out.println(System.currentTimeMillis());
        /**
         * 其它业务操作
         */
        System.out.println(System.currentTimeMillis());
      
        map.put(key, value);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候就没办法使用ConcurrentHashMap提供的方法了，只能业务自己来保证线程安全了，比如下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void safeUpdate(Integer key, Integer value) {
    synchronized (map) {
        Integer oldValue = map.get(key);
        if (oldValue == null) {
            System.out.println(System.currentTimeMillis());
            /**
             * 其它业务操作
             */
            System.out.println(System.currentTimeMillis());

            map.put(key, value);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样虽然不太友好，但是最起码能保证业务逻辑是正确的。&lt;/p&gt;
&lt;p&gt;当然，这里使用ConcurrentHashMap的意义也就不大了，可以换成普通的HashMap了。&lt;/p&gt;
&lt;p&gt;上面只是举一个简单的例子，我们不能听说ConcurrentHashMap是线程安全的，就认为它无论什么情况下都是线程安全的，还是那句话尽信书不如无书。&lt;/p&gt;
&lt;p&gt;这也正是我们读源码的目的之一，了解其本质，才能在我们的实际工作中少挖坑，不论是挖给别人还是挖给自己^^。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 15:42:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>死磕 java集合之ConcurrentHashMap源码分析（三） ConcurrentHashMap查询是否也加锁？ ConcurrentHashMap有哪些值得我们学习的技术？ Concu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-sourcecode.html</dc:identifier>
</item>
<item>
<title>基于Log4Net本地日志服务简单实现 - MeetYan</title>
<link>http://www.cnblogs.com/MeetYan/p/10687029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeetYan/p/10687029.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;ol readability=&quot;3.4098360655738&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;项目开发中，我们或多或少会使用诸如NLog，Log4Net，Kafka+ELK等等日志套件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;基于关注点分离原则，业务开发的时候不应该关注日志具体实现；并且后续能方便切换其他日志套件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这里先实现基于文件的日志服务，在下一篇将实现基于Kafka+ELK；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.57692307692308&quot;&gt;
&lt;p&gt;具体源码：&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief&quot;&gt;MasterChief&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Nuget：Install-Package MasterChief.DotNet.Core.Log&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;欢迎Star，欢迎Issues；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;日志接口定义&quot;&gt;日志接口定义&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
///     日志记录接口
/// &amp;lt;/summary&amp;gt;
public interface ILogService
{
    #region Methods
 
    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Debug(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Debug(string message, Exception ex);
 
    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Error(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Error(string message, Exception ex);
 
    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Fatal(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Fatal(string message, Exception ex);
 
    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Info(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Info(string message, Exception ex);
 
    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Warn(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Warn(string message, Exception ex);
 
    #endregion Methods
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于log4net本地文件日志服务实现&quot;&gt;基于Log4Net本地文件日志服务实现&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
///     基于Log4Net的文件日志记录
/// &amp;lt;/summary&amp;gt;
public sealed class FileLogService : ILogService
{
    #region Constructors
 
    static FileLogService()
    {
        DebugLogger = LogManager.GetLogger(DebugLoggerName);
        InfoLogger = LogManager.GetLogger(InfoLoggerName);
        WarnLogger = LogManager.GetLogger(WarnLoggerName);
        ErrorLogger = LogManager.GetLogger(ErrorLoggerName);
        FatalLogger = LogManager.GetLogger(FatalLoggerName);
    }
 
    #endregion Constructors
 
    #region Fields
 
    /// &amp;lt;summary&amp;gt;
    ///     The debug logger name
    /// &amp;lt;/summary&amp;gt;
    public const string DebugLoggerName = &quot;DEBUG_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The error logger name
    /// &amp;lt;/summary&amp;gt;
    public const string ErrorLoggerName = &quot;ERROR_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The fatal logger name
    /// &amp;lt;/summary&amp;gt;
    public const string FatalLoggerName = &quot;FATAL_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The information logger name
    /// &amp;lt;/summary&amp;gt;
    public const string InfoLoggerName = &quot;INFO_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The warn logger name
    /// &amp;lt;/summary&amp;gt;
    public const string WarnLoggerName = &quot;WARN_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The debug logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog DebugLogger;
 
    /// &amp;lt;summary&amp;gt;
    ///     The error logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog ErrorLogger;
 
    /// &amp;lt;summary&amp;gt;
    ///     The fatal logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog FatalLogger;
 
    /// &amp;lt;summary&amp;gt;
    ///     The information logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog InfoLogger;
 
    /// &amp;lt;summary&amp;gt;
    ///     The warn logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog WarnLogger;
 
    #endregion Fields
 
    #region Methods
 
    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Debug(string message)
    {
        if (DebugLogger.IsDebugEnabled) DebugLogger.Debug(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Debug(string message, Exception ex)
    {
        if (DebugLogger.IsDebugEnabled) DebugLogger.Debug(message, ex);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Error(string message)
    {
        if (ErrorLogger.IsErrorEnabled) ErrorLogger.Error(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Error(string message, Exception ex)
    {
        if (ErrorLogger.IsErrorEnabled) ErrorLogger.Error(message, ex);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Fatal(string message)
    {
        if (FatalLogger.IsFatalEnabled) FatalLogger.Fatal(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Fatal(string message, Exception ex)
    {
        if (FatalLogger.IsFatalEnabled) FatalLogger.Fatal(message, ex);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Info(string message)
    {
        if (InfoLogger.IsInfoEnabled) InfoLogger.Info(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Info(string message, Exception ex)
    {
        if (InfoLogger.IsInfoEnabled) InfoLogger.Info(message, ex);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Warn(string message)
    {
        if (WarnLogger.IsWarnEnabled) WarnLogger.Warn(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Warn(string message, Exception ex)
    {
        if (WarnLogger.IsWarnEnabled) WarnLogger.Warn(message, ex);
    }
 
    #endregion Methods
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;log4net-配置文件&quot;&gt;Log4Net 配置文件&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler&quot; /&amp;gt;
  &amp;lt;/configSections&amp;gt;
  &amp;lt;log4net&amp;gt;
    &amp;lt;!-- FileLogger --&amp;gt;
    &amp;lt;logger name=&quot;FATAL_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;FATAL_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&quot;ERROR_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;ERROR_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&quot;WARN_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;WARN_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&quot;INFO_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;INFO_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&quot;DEBUG_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;DEBUG_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;!-- AdoNetLogger --&amp;gt;
    &amp;lt;!--&amp;lt;logger name=&quot;AdoNetLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;AdoNetAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;--&amp;gt;
    &amp;lt;!-- ConsoleLogger --&amp;gt;
    &amp;lt;logger name=&quot;ConsoleLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;ColoredConsoleAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
 
    &amp;lt;!--使用Rolling方式记录日志按照日来记录日志--&amp;gt;
    &amp;lt;appender name=&quot;FATAL_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\FATAL\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;ERROR_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\ERROR\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;WARN_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\WARN\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;INFO_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\INFO\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;DEBUG_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\DEBUG\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;!--使用AdoNetAppender方式记录日志按照日来记录日志--&amp;gt;
    &amp;lt;!--&amp;lt;appender name=&quot;AdoNetAppender&quot; type=&quot;log4net.Appender.AdoNetAppender&quot;&amp;gt;
      &amp;lt;bufferSize value=&quot;1&quot; /&amp;gt;
      &amp;lt;connectionType value=&quot;System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; /&amp;gt;
      &amp;lt;connectionString value=&quot;DATABASE=Sample;SERVER=.\SQLEXPRESS;UID=sa;PWD=sasa;Connect Timeout=15;&quot; /&amp;gt;
      &amp;lt;commandText value=&quot;INSERT INTO [Log4Net] ([Date],[Host],[Thread],[Level],[Logger],[Message],[Exception]) VALUES (@log_date, @host, @thread, @log_level, @logger, @message, @exception)&quot; /&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@log_date&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;DateTime&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.RawTimeStampLayout&quot; /&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@thread&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;255&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%thread&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
 
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@host&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;50&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%property{log4net:HostName}&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@log_level&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;50&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%level&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@logger&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;255&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%logger&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@message&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;4000&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%message&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@exception&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;4000&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.ExceptionLayout&quot; /&amp;gt;
      &amp;lt;/parameter&amp;gt;
    &amp;lt;/appender&amp;gt;--&amp;gt;
    &amp;lt;!--使用ConsoleAppender方式记录日志按照日来记录日志--&amp;gt;
    &amp;lt;appender name=&quot;ColoredConsoleAppender&quot; type=&quot;log4net.Appender.ColoredConsoleAppender&quot;&amp;gt;
      &amp;lt;mapping&amp;gt;
        &amp;lt;level value=&quot;INFO&quot; /&amp;gt;
        &amp;lt;foreColor value=&quot;White, HighIntensity&quot; /&amp;gt;
        &amp;lt;backColor value=&quot;Green&quot; /&amp;gt;
      &amp;lt;/mapping&amp;gt;
      &amp;lt;mapping&amp;gt;
        &amp;lt;level value=&quot;DEBUG&quot; /&amp;gt;
        &amp;lt;foreColor value=&quot;White, HighIntensity&quot; /&amp;gt;
        &amp;lt;backColor value=&quot;Blue&quot; /&amp;gt;
      &amp;lt;/mapping&amp;gt;
      &amp;lt;mapping&amp;gt;
        &amp;lt;level value=&quot;WARN&quot; /&amp;gt;
        &amp;lt;foreColor value=&quot;Yellow, HighIntensity&quot; /&amp;gt;
        &amp;lt;backColor value=&quot;Purple&quot; /&amp;gt;
      &amp;lt;/mapping&amp;gt;
      &amp;lt;mapping&amp;gt;
        &amp;lt;level value=&quot;ERROR&quot; /&amp;gt;
        &amp;lt;foreColor value=&quot;Yellow, HighIntensity&quot; /&amp;gt;
        &amp;lt;backColor value=&quot;Red&quot; /&amp;gt;
      &amp;lt;/mapping&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level%newline事件来源：%logger%newline事件行号：%line%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;UdpAppender&quot; type=&quot;log4net.Appender.UdpAppender&quot;&amp;gt;
      &amp;lt;remoteAddress value=&quot;127.0.0.1&quot; /&amp;gt;
      &amp;lt;remotePort value=&quot;7071&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.XmlLayoutSchemaLog4j&quot; /&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;root&amp;gt;
      &amp;lt;appender-ref ref=&quot;UdpAppender&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
  &amp;lt;/log4net&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;怎么使用&quot;&gt;怎么使用&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private IKernel _kernel = null;
private ILogService _logService = null;
 
[TestInitialize]
public void SetUp()
{
    _kernel = new StandardKernel(new LogModule());
    Assert.IsNotNull(_kernel);
 
    _logService = _kernel.Get&amp;lt;ILogService&amp;gt;();
}
 
[TestMethod()]
public void DebugTest()
{
    _logService.Debug(&quot;DebugTest&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;整个实现很简单，就是业务或者功能不依赖具体实现类，这也是开发中最基本原则；&lt;/li&gt;
&lt;li&gt;小弟不才，大佬轻拍；&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 10 Apr 2019 15:42:00 +0000</pubDate>
<dc:creator>MeetYan</dc:creator>
<og:description>背景 1. 项目开发中，我们或多或少会使用诸如NLog，Log4Net，Kafka+ELK等等日志套件； 2. 基于关注点分离原则，业务开发的时候不应该关注日志具体实现；并且后续能方便切换其他日志套件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MeetYan/p/10687029.html</dc:identifier>
</item>
<item>
<title>TypeScript 上手教程 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/typescript_starter_tutorial.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/typescript_starter_tutorial.html</guid>
<description>&lt;p&gt;无疑，对于大型项目来说，Vanilla Js 无法满足工程需求。早在 2016 年 Anuglar 在项目中引入 TypeScript 时，大概也是考虑到强类型约束对于大型工程的必要性，具体选型考虑可参考&lt;a href=&quot;https://vsavkin.com/writing-angular-2-in-typescript-1fa77c78d8e8&quot; rel=&quot;nofollow&quot;&gt;这篇文章&lt;/a&gt;。然后可以看到 TypeScript 在社区中逐渐升温。但凡社区中举足轻重的库，如果不是原生使用 TypeScript 编写，那么也是通过声明文件的方式对 TypeScript 提供支持，比如 React（虽然不是包含在官方仓库中，而是通过 &lt;code&gt;@types/react&lt;/code&gt;），同时官方脚手架工具（&lt;a href=&quot;https://github.com/facebook/create-react-app/releases/tag/v2.1.0&quot;&gt;v2.1.0&lt;/a&gt; 之后）也开始提供开箱即用的 TypeScript 支持，通过 &lt;code&gt;--typescript&lt;/code&gt; 参数开启。&lt;/p&gt;
&lt;p&gt;所以 TypeScript 绝对是趋势。它所带来的工程效率上的提升，是在使用 Vanilla Js 时无法体会到的。可能前期反而会因为类型约束而变得束手束脚影响效率，但这是个学习成本的问题，对于任何一门技术而言都会存在。&lt;/p&gt;
&lt;p&gt;如果你有 Java 或 C# 的基础，那 TypeScript 学起来几乎没什么成本。&lt;/p&gt;
&lt;h2&gt;安装与配置&lt;/h2&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ npm install -g typescript
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; or&lt;/span&gt;
$ yarn global add typescript
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装成功后，其 cli 命令为 &lt;code&gt;tsc&lt;/code&gt;，比如查看版本，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ tsc --version
Version 3.3.3333
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用的命令：&lt;/p&gt;
&lt;h4&gt;编译文件&lt;/h4&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ tsc main.ts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译时传递编译参数：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ tsc --target es3 main.ts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的编译参数可在官网 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot; rel=&quot;nofollow&quot;&gt;Compiler Options 文档&lt;/a&gt;中查阅。&lt;/p&gt;
&lt;h4&gt;初始化配置文件&lt;/h4&gt;
&lt;p&gt;除了通过 CLI 传递编译参数控制编译的行为，也可通过创建 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件指定编译参数。对于项目中使用来说，肯定是使用配置文件比较方便，而且，有些参数只支持通过配置文件来设置，比如 &lt;code&gt;path&lt;/code&gt;，&lt;code&gt;rootDirs&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ tsc --init
message TS6071: Successfully created a tsconfig.json file.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该命令在当前目录创建一个 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件，每个配置都包含注释。完整的配置项也可在官网&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot; rel=&quot;nofollow&quot;&gt;Compiler Options 文档&lt;/a&gt;中查阅，根据自己需要和项目需求进行合理配置。大部分情况下你只会因为有某个需求才会去刻意研究如何配置，比如要改变输出类型设置 &lt;code&gt;target&lt;/code&gt;，写码过程中发现 &lt;code&gt;Object.assign&lt;/code&gt; 不可用发现需要添加 &lt;code&gt;lib&lt;/code&gt; 插件。所以不必被庞大的配置参数惊吓到，只用的时候再搜索即可。&lt;/p&gt;
&lt;details readability=&quot;33.5&quot;&gt;tsconfig.json
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
{
  &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;compilerOptions&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Basic Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;target&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;es5&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;module&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;commonjs&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;allowJs&quot;: true,                       /* Allow javascript files to be compiled. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;checkJs&quot;: true,                       /* Report errors in .js files. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;declaration&quot;: true,                   /* Generates corresponding '.d.ts' file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;sourceMap&quot;: true,                     /* Generates corresponding '.map' file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;outFile&quot;: &quot;./&quot;,                       /* Concatenate and emit output to single file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;outDir&quot;: &quot;./&quot;,                        /* Redirect output structure to the directory. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;composite&quot;: true,                     /* Enable project compilation */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;removeComments&quot;: true,                /* Do not emit comments to output. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noEmit&quot;: true,                        /* Do not emit outputs. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;importHelpers&quot;: true,                 /* Import emit helpers from 'tslib'. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Strict Type-Checking Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;strict&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Enable all strict type-checking options. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noImplicitAny&quot;: true,                 /* Raise error on expressions and declarations with an implied 'any' type. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;strictBindCallApply&quot;: true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noImplicitThis&quot;: true,                /* Raise error on 'this' expressions with an implied 'any' type. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Additional Checks &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Module Resolution Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;paths&quot;: {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */&lt;/span&gt;
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;esModuleInterop&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Source Map Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Experimental Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;h3&gt;VS Code 上手&lt;/h3&gt;
&lt;p&gt;TS 带来的一大好处是其静态类型检查能跟编辑器很好地结合，智能健全的自动提示自不必说。推荐 &lt;a href=&quot;https://code.visualstudio.com&quot; rel=&quot;nofollow&quot;&gt;VS Code&lt;/a&gt; 作为编辑，其对 TypeScript 有原生的支持。&lt;/p&gt;
&lt;p&gt;用好这几个快捷键，更是提升效率的关键。&lt;/p&gt;
&lt;h4&gt;重命名&lt;/h4&gt;
&lt;p&gt;通过 &lt;kbd&gt;F2&lt;/kbd&gt; 对标识符重重命名。这里标识符可以是变量名，方法函数名，类名或者其他字面量。如果写代码过程中发现命名不合理想重命名，一定使用这个快捷键来操作，它的好处是，只需改一处，其他与该标识符有关的地方，将自动被批量替换成新的，甚至该标识符使用的地方不在同一个文件中，也能被正确地自动应用上变更后的名称。省去了人工替换和检查代码的麻烦。关键人工容易出错，搜索加替换的方式只是根据字符串来进行的，而该命令是通过分析代码的语法树进行的。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686721-560ae880-5997-11e9-8d74-7dfe51482e3a.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686721-560ae880-5997-11e9-8d74-7dfe51482e3a.gif&quot; alt=&quot;使用 &amp;lt;kbd&amp;gt;F2&amp;lt;/kbd&amp;gt; 进行变量重命名的展示&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;使用 &lt;kbd&gt;F2&lt;/kbd&gt; 进行变量重命名的展示&lt;/p&gt;
&lt;h4&gt;快速跳转&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;F12&lt;/kbd&gt; 跳转到定义。这应该是使用最为频繁的了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686738-894d7780-5997-11e9-86b5-188661edce21.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686738-894d7780-5997-11e9-86b5-188661edce21.gif&quot; alt=&quot;跳转到定义&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;跳转到定义&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;F7&lt;/kbd&gt; 当前文件中相同的标识符间循环切换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686747-a5511900-5997-11e9-8d88-0e5e31b4cf3a.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686747-a5511900-5997-11e9-8d88-0e5e31b4cf3a.gif&quot; alt=&quot;标识符间的跳转切换&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;标识符间的跳转切换&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;F8&lt;/kbd&gt; 在错误处循环切换。这个跳转可让你在修正代码中的错误时变得非常快捷。它直接将光标定位到错误处，修改好本处的错误后，继续 &lt;kbd&gt;F8&lt;/kbd&gt; 跳转到下一处。一个很好的应用场景是对 js 代码的迁移，将文件扩展名由 &lt;code&gt;.js&lt;/code&gt; 改为 &lt;code&gt;.ts&lt;/code&gt;，大概率你会看到满屏飘红的错误提示，通过不断地 &lt;kbd&gt;F8&lt;/kbd&gt; 来由上往下定位修改简直再顺畅不过了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686754-bef26080-5997-11e9-9a83-ba658e949e26.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686754-bef26080-5997-11e9-9a83-ba658e949e26.gif&quot; alt=&quot;在报错处循环切换&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;在报错处循环切换&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;-&lt;/kbd&gt;/&lt;kbd&gt;=&lt;/kbd&gt; 在鼠标历史位置间来回切换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686764-d7627b00-5997-11e9-8cc0-98619c3f8a4c.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686764-d7627b00-5997-11e9-8cc0-98619c3f8a4c.gif&quot; alt=&quot;光标位置的来回切换&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;光标位置的来回切换&lt;/p&gt;
&lt;h4&gt;命令面板&lt;/h4&gt;
&lt;p&gt;通过 &lt;kbd&gt;command&lt;/kbd&gt; + &lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;p&lt;/kbd&gt; 打开命令面板。几乎所有功能可以通过这里的命令来完成。&lt;/p&gt;
&lt;p&gt;比如，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码折叠与展开&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686777-f4974980-5997-11e9-9fe0-6e65db5e6910.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686777-f4974980-5997-11e9-9fe0-6e65db5e6910.gif&quot; alt=&quot;代码折叠与展开&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;代码折叠与展开&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主题的切换&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686786-1395db80-5998-11e9-902f-d793a71720b0.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686786-1395db80-5998-11e9-902f-d793a71720b0.gif&quot; alt=&quot;主题的切换&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;主题的切换&lt;/p&gt;
&lt;p&gt;最后，你始终可通过搜索 &lt;code&gt;keyboard shortcurt&lt;/code&gt; 来查看所有的快捷键。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686796-3aeca880-5998-11e9-802c-5bf62345f291.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686796-3aeca880-5998-11e9-802c-5bf62345f291.gif&quot; alt=&quot;快捷键列表&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;快捷键列表&lt;/p&gt;
&lt;h3&gt;在线工具&lt;/h3&gt;
&lt;p&gt;如果本地没有环境，可通过 &lt;a href=&quot;http://www.typescriptlang.org/play/&quot; rel=&quot;nofollow&quot;&gt;Playground ・ TypeScript&lt;/a&gt; 这个在线的编辑器，编辑 TypeScript 和时实查看输出。&lt;/p&gt;
&lt;h2&gt;类型声明&lt;/h2&gt;
&lt;p&gt;TypeScript 中，通过在变量后面添加冒号指定其类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; fruit&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 🚨Variable 'fruit' is used before being assigned.&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(fruit);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当声明 &lt;code&gt;fruit&lt;/code&gt; 为字符串之后，TypeScript 会保证该变量的类型始终是字符串。但在未赋值之前，其实它真实的类型是 undefined。这种情况下，TypeScript 会报错以阻止你在未初始化之前就使用。&lt;/p&gt;
&lt;p&gt;函数的类型包含了入参的类型和返回值的类型。入参自不必说，像上面那样冒号后指定，而返回值的类型，则是通过在入参列表结束的括号后添加冒号来指定的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;): number {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; num &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果每次写个变量或函数都需要手动指定其类型，岂不是很麻烦。所以，在一切能够推断类型的情况下，是不必手动指定的。比如声明变量并初始化，会根据初始化的值来推断变量类型。函数会根据其 return 的值来推断其返回类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 推断出的函数类型为：(num: number) =&amp;gt; number &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; num &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; age:number &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;18&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;virtualAge&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(age);

&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;在下虚岁 &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;virtualAge&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TypeScript 中的类型&lt;/h2&gt;
&lt;p&gt;JavaScript 中原生有 7 中数据类型，其中 Ojbect 为可看成数据集合，而其他 6 种（布尔，字符串，数字，&lt;code&gt;undefined&lt;/code&gt;， &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;），则是原始（primitive）数据类型。&lt;/p&gt;
&lt;p&gt;虽然 JavaScript 中有数据类型的概念，但它是动态的，变量的类型根据所存储的值而变化。TypeScript 作为其超集，将上面的数据类型进行了扩充，在 TypeScript 里，可以通过各种组合创建出更加复杂的数据类型。同时，TypeScript 让数据类型固定，成为静态可分析的。&lt;/p&gt;
&lt;p&gt;比如，如果一个函数的入参指定为数字，那么调用的时候传递了字符串，这个错误在写码过程中就直接可检查到并抛出。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; num &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨Argument of type '&quot;blah&quot;' is not assignable to parameter of type 'number'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;blah&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JavaScript 原始类型加上扩展的几个类型（Any, Never, Void, Enum）组成了 TypeScript 中基本的类型。更加详细的信息可参考 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html&quot; rel=&quot;nofollow&quot;&gt;Basic Types&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Boolean&lt;/h3&gt;
&lt;p&gt;布尔值，其值只能是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; isEmployee&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; boolean &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;hasPermission&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;): boolean {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; role &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;admin&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Number&lt;/h3&gt;
&lt;p&gt;数字类型，不区分整形与浮点，所有数字均当作浮点数字对待。同时也支持二进制，八进制，十六进制数字。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; decimal&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; hex&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0xf00d&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; binary&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0b1010&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; octal&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0o744&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;String&lt;/h3&gt;
&lt;p&gt;字符串类型。TypeScript 中可使用 ES6 以之后这些还未实现的功能，所以模板字符串是可以放心使用的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; fruit&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Apple&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;My favourite fruit is &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;fruit&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Symbol&lt;/h3&gt;
&lt;p&gt;ES6 中新增，由 &lt;code&gt;Symbol()&lt;/code&gt; 返回的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; sym &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; sym; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;symbol&quot;&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;sym&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toString&lt;/span&gt;(); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Symbol(foo)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，因为是新特性，需要在 &lt;code&gt;tsconfig.json&lt;/code&gt; 中添加相应的库支持，否则编译会报错。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
{
      &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;lib&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;dom&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;es2015&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;] &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Specify library files to be included in the compilation. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Object&lt;/h3&gt;
&lt;p&gt;除了 JavaScript 中 6 个原始类型之外的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(source);
}

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;({});
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;window&lt;/span&gt;);

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 🚨Argument of type 'undefined' is not assignable to parameter of type 'Object'&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;);

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 🚨Argument of type 'undefined' is not assignable to parameter of type 'Object'.ts(2345)&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;undefined&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Null 与 Undefined&lt;/h3&gt;
&lt;p&gt;两者其实是其他任意类型的子类型。比如，一个变量定义后没有初始化，此时其值自动为 &lt;code&gt;undefined&lt;/code&gt;。这说明，&lt;code&gt;undefined&lt;/code&gt; 是可以赋值给这个类型的。当我们想把变量的值取消，将其置空时，可将其设置为 &lt;code&gt;null&lt;/code&gt;，&lt;code&gt;null&lt;/code&gt; 也是可以赋值给其他类型变量的，前提是 &lt;code&gt;tsconfig.json&lt;/code&gt; 中没有开启 &lt;code&gt;strict:true&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(age); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; undefined&lt;/span&gt;

age &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;9&lt;/span&gt;;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(age); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 9&lt;/span&gt;

age &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(age); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当开启 &lt;code&gt;strict:true&lt;/code&gt; 强制检查后，TypeScript 会对类型进行严格的检查。上面就不能在未初始化的情况下使用变量，同时也不能将 &lt;code&gt;null&lt;/code&gt; 赋值给 &lt;code&gt;number&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;对于这两种类型，在强制检查下，除非显式对变量进行声明其可空可未初始化。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; let age: number | null | undefined;&lt;/span&gt;
console.log(age); // undefined

age = 9;
console.log(age); // 9

age = null;
console.log(age); // null
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里 &lt;code&gt;number | null | undefined&lt;/code&gt; 是一个组合类型（union type），后面会有提到。&lt;/p&gt;
&lt;p&gt;一般来说，建议开启强制检查，这样 TypeScript 能够最大化帮我们发现代码中的错误，在写码时就发现问题。&lt;/p&gt;
&lt;h3&gt;Any&lt;/h3&gt;
&lt;p&gt;表示任意类型。此时等同于普通的 JavaScript 代码，因为标记为 &lt;code&gt;any&lt;/code&gt; 后将会跳过 TypeScript 的类型检查。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; someVar&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any;
someVar &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;饭后百步走，活到 99&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
someVar &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;99&lt;/span&gt;; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
someVar &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;undefined&lt;/span&gt;; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
someVar &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即便在开启强制检查的情况下，上面的操作是没有任何问题的。一般情况下，只在一些特殊情况下使用 any，比如老代码的兼容，三方库代码的引入。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
declare &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; $&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any;

&lt;span class=&quot;pl-smi&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;extenfd&lt;/span&gt;({}, { foo&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，因为 jQuery 是没有类型的三方库代码，但我们知道页面中引入后是可以调用它上面的方法的，只是 TypeScript 不识别，所以我们通过声明一个 &lt;code&gt;any&lt;/code&gt; 类型的变量来&lt;strong&gt;快速&lt;/strong&gt;解决这个问题。不快速的办法就是自己动手为其编写类型&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html&quot; rel=&quot;nofollow&quot;&gt;声明文件&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Void&lt;/h3&gt;
&lt;p&gt;常见于函数没有返回值的情况。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; () =&amp;gt; void &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo works&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将变量显式设置为 &lt;code&gt;void&lt;/code&gt;，没有多大实际意义。因为变量始终是要用来承载有用的值的，如果你发现有这种需要，可使用 &lt;code&gt;null|undefiend&lt;/code&gt; 代替。&lt;/p&gt;
&lt;h3&gt;Never&lt;/h3&gt;
&lt;p&gt;这个类型就比较有意思了，正如其名，表示永远也不会发生的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;): never {
  &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Error&lt;/span&gt;(message);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于 &lt;code&gt;never&lt;/code&gt; 类型，印象中最巧妙的一个示例来自 TypeScript &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/advanced-types.html&quot; rel=&quot;nofollow&quot;&gt;Advanced Types&lt;/a&gt; 文档中关于 Discriminated Unions 的描述。既然是&lt;strong&gt;高级类型&lt;/strong&gt;，下面的示例对于初学者来说如果看不懂就先跳过吧。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Square {
  kind&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;square&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  size&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Rectangle {
  kind&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;rectangle&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  width&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
  height&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Circle {
  kind&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;circle&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  radius&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}

type Shape &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; Square &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Rectangle &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Circle;

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;assertNever&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;never&lt;/span&gt;): never {
  &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Unexpected object: &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; x);
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;area&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Shape&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;switch&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;kind&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;square&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;:
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;size&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;rectangle&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;:
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;width&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;circle&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;:
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;radius&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt;:
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;assertNever&lt;/span&gt;(s); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; error here if there are missing cases&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里定义了三种基础的形状类型 &lt;code&gt;Square&lt;/code&gt;，&lt;code&gt;Rectangle&lt;/code&gt;，&lt;code&gt;Circle&lt;/code&gt;。同时将三种类型进行组合创建了一个联合类型 （Union Type） &lt;code&gt;Shape&lt;/code&gt;。 函数 &lt;code&gt;area&lt;/code&gt; 接收一个 &lt;code&gt;Shape&lt;/code&gt; 类型的数据并对其进行处理。因为 &lt;code&gt;Shape&lt;/code&gt; 实际上有可能是三种类型中的其中一种，并不确定，所以需要对每个类型走不同的逻辑来处理。这里通过 &lt;code&gt;never&lt;/code&gt; 实现了这样一个功能：假如后面我们又增加了一种新的形状类型，此时 &lt;code&gt;area&lt;/code&gt; 函数能够自动抛错，告诉我们新增的类型没有相应的 &lt;code&gt;case&lt;/code&gt; 分支来处理。&lt;/p&gt;
&lt;h3&gt;数组&lt;/h3&gt;
&lt;p&gt;数组本身是容器，需要上面的基本类型联合使用。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 字符串数组 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; names&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;string&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 存放数字的数组 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; nums&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;number&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 数组中各元素类型不确定 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; data&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;any&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可通过下面的方式来表示：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 字符串数组 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; names&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string[];

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 存放数字的数组 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; nums&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number[];

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 数组中各元素类型不确定 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; data&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any[];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当数组中元数个数有限且提前知晓每个位置的类型时，可将这种数据声明成元组（tuple，如果你用过 Python 应该不会陌生）。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; point&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; [number, number] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;5&lt;/span&gt;];
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; formValidateResult&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; [booelan, string] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;请输入用户名&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;枚举&lt;/h3&gt;
&lt;p&gt;枚举类型在强类型语言中是很常见的，用来标识变量可取的候选值。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;enum&lt;/span&gt; Gender {
    Male,
    Female
}

&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;Gender&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;Female&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;枚举实质上是通过更加语义化的符号来表示数字类型的值，比如上面 &lt;code&gt;Gender.Female&lt;/code&gt; 代表的值是 &lt;code&gt;1&lt;/code&gt;，因为枚举默认从 0 开始。&lt;/p&gt;
&lt;p&gt;可通过手动指定的方式来改变默认的 0。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
enum Gender {
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  Male = 1,&lt;/span&gt;
  Female
}

console.log(Gender.Female); // 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，你也可以让枚举表示其他类型的值，而不是数字。只不过需要手动指定。如果手动指定非数字类型的值，那么枚举中的项是无法像数字那样自动自增以初始化自己，所以需要手动为每个项都显式指定一下它应该代表的值。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;enum&lt;/span&gt; Gender {
  Male &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  Female &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 🚨 Enum member must have initializer.&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正确的做法：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;enum&lt;/span&gt; Gender {
  Male &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  Female &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;female&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
}

&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;Gender&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;Female&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; female&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;枚举中的值也不一定都得是同一类型，所以下面这样也是可以的：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;enum&lt;/span&gt; Gender {
  Male &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  Female &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅also ojbk&lt;/span&gt;
}
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;Gender&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;Female&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;函数类型&lt;/h3&gt;
&lt;p&gt;函数的类型包含了入参及返回值两部分。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; string;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来像其他静态类型语言比如 Java 中的抽象方法，只有声明没有实现的样子。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Calculator {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  &lt;span class=&quot;pl-en&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; number;
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Computer&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;implements&lt;/span&gt; Calculator {
  &lt;span class=&quot;pl-en&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;) {}
  &lt;span class=&quot;pl-en&quot;&gt;calculate&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; y;
  }
}

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; counter&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Calculator&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;counter&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;pl-en&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; y;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;code&gt;interface&lt;/code&gt; 与 &lt;code&gt;type&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;通过上面的基本类型，可以抽象并定义对象。通过 &lt;code&gt;interface&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 关键词，均可定义组合的复杂类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
type Role &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;manager&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;employee&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Person {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
  role&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; Role;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;code&gt;type&lt;/code&gt; 定义的类型，又叫 &lt;code&gt;type alias&lt;/code&gt;，除了通过它创建类型，还可方便地为现有类型创建别名，体现了其 &lt;code&gt;alias&lt;/code&gt; 的本意。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
type Name &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; string;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; myName&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Tom&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例意义不大， type alias 在&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/advanced-types.html&quot; rel=&quot;nofollow&quot;&gt;高级类型&lt;/a&gt;中的作用会非常明显，能够为复杂类型创建别名从而使用的时候只需要写别名即可。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
type Name &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; string;
type &lt;span class=&quot;pl-en&quot;&gt;NameResolver&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; string;
type NameOrResolver &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; Name &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; NameResolver;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;getName&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;NameOrResolver&lt;/span&gt;): Name {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; n &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;string&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; n;
  } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;n&lt;/span&gt;();
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两种类型在使用上，没多大差别，只是尽量在代码中保持风格统一。更加具体的差异分析可继续阅读 &lt;a href=&quot;https://github.com/wayou/wayou.github.io/issues/42&quot; data-hovercard-type=&quot;issue&quot; data-hovercard-url=&quot;/wayou/wayou.github.io/issues/42/hovercard&quot;&gt;TypeScript: type alias 与 interface&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;交叉类型与联合类型&lt;/h2&gt;
&lt;p&gt;交叉类型（Intersection Types）与联合类型（Union Types）也是属性高级类型中的内容，前面示例中有涉及到所以这里简单介绍。&lt;/p&gt;
&lt;p&gt;交叉类型是通过 &lt;code&gt;&amp;amp;&lt;/code&gt; 操作符创建的类型，表示新的类型为参与操作的这些类型的并集。它实际上是将多个类型进行合并，而不是像其名称那样取交集。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Student {
  id&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}

&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Employee {
  companyId&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
}

type SocialMan &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; Student &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt; Employee;

&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; tom&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; SocialMan;

&lt;span class=&quot;pl-smi&quot;&gt;tom&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;tom&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;companyId&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;CID5241&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;tom&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;ID3241&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当一个学生加上工人的属性，他成了一个社会人，嗯。&lt;/p&gt;
&lt;p&gt;联合类型（Union Types）正如创建这种类型所使用的操作符 &lt;code&gt;|&lt;/code&gt; 一样，他表示或的关系。新类型是个叠加态，在实际运行前，你不知道它到底所属哪种类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;) {
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨 Operator '+' cannot be applied to types 'string | number' and '1'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; num &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如对入参加一的方法，JavaScript 中我们是可以这样干的，如果传入的是字符串，加号操作符会对其中一个做隐式转换。但结果可能不是你想要的数字加 1 而是变成了字符串相加。&lt;/p&gt;
&lt;p&gt;而 TypeScript 在此时就体现了其静态类型的优点，因为入参在这里是不确定的类型，随着输入的不同得到的结果是不可预期的，这大概率会导致 bug。而这个 bug 在 TypeScript 里被提前找了出来。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
function addOne(num: number | string) {
  // ✅ 
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  return Number(num) + 1;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了像上面入参不确定的情形，像前面示例有用到过的，将多个字符串联合，也是很常见的用法。甚至最佳实践中，建议你用联合字符串来代替枚举类型。But why? &lt;a href=&quot;https://medium.com/@martin_hotell/10-typescript-pro-tips-patterns-with-or-without-react-5799488d6680&quot; rel=&quot;nofollow&quot;&gt;参见这里&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
type Role &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;manager&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;employee&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;类型断言&lt;/h2&gt;
&lt;p&gt;某些情况下，TypeScript 无法自动推断类型，此时可人工干预，对类型进行显式转换，我们称之为类型断言（Type assertions）。通过在值的前面放置尖括号，括号中指定需要的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; someValue&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;this is a string&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; strLength&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;string&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;someValue).&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为尖括号在写 React 组件时会有问题，&lt;strong&gt;容易被错误地当成 JSX 标签&lt;/strong&gt;，所以 TypeScript 还支持另一种类型转换的操作，通过 &lt;code&gt;as&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; someValue&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;this is a string&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; strLength&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (someValue as string).&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看一个更加实际的情况：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Person {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  gender&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;female&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;sayName&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Person&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(person);
}

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;tom&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;tom&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  gender&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
};

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨Type 'string' is not assignable to type '&quot;male&quot; | &quot;female&quot;' &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;sayName&lt;/span&gt;(tom);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里 &lt;code&gt;tom&lt;/code&gt; 没有显式指定为 &lt;code&gt;Person&lt;/code&gt; 类型，但其实因为 TypeScript 的类型约束的是数据的结构，只要是形状上兼容，就可以将 &lt;code&gt;tom&lt;/code&gt; 赋值给接收 &lt;code&gt;Person&lt;/code&gt; 类型的入参。 这种机制也类似于你声明了一个变量并赋值个数字，这个变量自动就被推断出类型为数字一样，然后可以在任何地方当作数字来用，即便你并没有显式指明。&lt;/p&gt;
&lt;p&gt;所以这个示例中，我们需要修正一下初始化 &lt;code&gt;tom&lt;/code&gt; 的对象中 &lt;code&gt;gender&lt;/code&gt; 字段的类型，然后 TypeScript 就能正确推断出 &lt;code&gt;tom&lt;/code&gt; 是个 &lt;code&gt;Person&lt;/code&gt; 类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Person {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  gender&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;female&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;sayName&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Person&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(person);
}

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;tom&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;tom&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  gender&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; as &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;female&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
};

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; ✅ ojbk &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;sayName&lt;/span&gt;(tom);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结合前面提到的类型别名，这里可以用 &lt;code&gt;type&lt;/code&gt; 为性别创建一个别名类型，减少冗余。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; type Gender = &quot;male&quot; | &quot;female&quot;;&lt;/span&gt;

interface Person {
  name: string;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  gender: Gender;&lt;/span&gt;
}

function sayName(person: Person) {
  console.log(person);
}

const tom = {
  name: &quot;tom&quot;,
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  gender: &quot;male&quot; as Gender&lt;/span&gt;
};


sayName(tom);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;可选参数与可空字段&lt;/h2&gt;
&lt;p&gt;定义类型时，如果字段后跟随一个问号，表示该字段可空，此时效果相当于是该类型自动与 &lt;code&gt;undefined&lt;/code&gt; 进行了联合操作。以下两个类型是等效的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
type Person &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string,
  age&lt;span class=&quot;pl-k&quot;&gt;?:&lt;/span&gt; number
};

type Person2 &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string,
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;undefined&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于函数入参而言，入参加上问号后，可将入参标识为可选，调用时可不传递。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; (y &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但此时可选的入参需要在参数列表中位于非可选的后面，像这样交换顺序后是不行的：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨 A required parameter cannot follow an optional parameter. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; (y &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;了解了一些基本的类型知识和写法就可以进行简单的业务编写了。你可以从官方的这个&lt;a href=&quot;https://www.typescriptlang.org/samples/&quot; rel=&quot;nofollow&quot;&gt;模板页面&lt;/a&gt;找到适合自己的技术栈作为练手的开始。&lt;/p&gt;
&lt;p&gt;然后，可以系统地浏览一遍 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html&quot; rel=&quot;nofollow&quot;&gt;Handbook&lt;/a&gt;，对 TypeScript 整体有个健全的了解。&lt;/p&gt;
&lt;p&gt;其中 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/advanced-types.html&quot; rel=&quot;nofollow&quot;&gt;Advanced Types&lt;/a&gt; 章节里可以学习到进阶的类型定义和花式玩法，高级类型对于库的作者或写通用公共模块来说很有必要去了解。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Wed, 10 Apr 2019 15:41:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>无疑，对于大型项目来说，Vanilla Js 无法满足工程需求。早在 2016 年 Anuglar 在项目中引入 TypeScript 时，大概也是考虑到强类型约束对于大型工程的必要性，具体选型考虑可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/typescript_starter_tutorial.html</dc:identifier>
</item>
<item>
<title>设计模式-序 - 疯子·策天</title>
<link>http://www.cnblogs.com/planheaven/p/10686967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/planheaven/p/10686967.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　一、什么是设计模式？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次的使用该方案而不必做重复的劳动”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　二、模式四个基本要素&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1.模式名称 （pattern name）&lt;/strong&gt; 一个助记名，用一两个词来描述模式的问题、解决方案和效果。也便于我们与他人交流设计思想和设计结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.问题（problem）&lt;/strong&gt; 描述了应该在何时使用模式。解释了设计问题和问题存在的前因后果。有时候问题部分会包括使用模式必须满足的一系列先决条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3.解决方案（solution）&lt;/strong&gt; 描述了设计的组成成分，它们之间的相互关系及各自的指责和协作方式。模式就像是一个模板，可以应用于多种不同的场合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4.效果（consequences）&lt;/strong&gt; 描述了模式应用的效果及使用模式应权衡的问题。软件大多关注时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性，扩充性（扩展性）或可移植性的影响，显示的列出这些效果对理解和评价模式很有帮助。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　三、模式编目&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　按首字母顺序依次为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　  Abstract Factory 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Adapter 适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Bridge 桥接模式：将抽象部分与它的实现部分分离，使他们都可以独立的变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Builder 建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Chain of Responsibility 责任链模式： 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Command 命令模式：将请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Composite 组合模式：将对象组合成树形结构以表示 “部分-整体”的层次结构。 Composite使得客户对单个对象和复合对象的使用具有一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Decorator 装饰者模式：动态的给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更灵活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Facade  外观模式：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Factory Method 工厂方法：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Flyweight 享元模式： 运用共享技术有效地支持大量细粒度的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Interpreter 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Iterator  迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Mediator 中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Memento 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Observer 观察者模式：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Prototype 原型模式：用原型实例指定创建对象的种类，并通过拷贝这个原型来创建新的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Proxy 代理模式：为其他对象提供一个代理以控制对这个对象的访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Singleton 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　State 状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它所属的类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Strategy 策略模式：定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可以独立于使用它的客户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Template Method 模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Visitor 访问者模式：表示一个作用于某个对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　四、模式分类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　模式分类依据两条准则：目的准则，范围准则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目的准则，即模式是用来完成什么工作的。模式依据其目的可以分为 &lt;strong&gt;创建型（Creational）&lt;/strong&gt;、&lt;strong&gt;结构型（Structural）&lt;/strong&gt;、和&lt;strong&gt;行为型（Behavioral）&lt;/strong&gt;三种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　范围准则，指定模式主要用于类还是用于对象。&lt;strong&gt;类模式&lt;/strong&gt;处理类与子类之间的关系，这些关系通过继承建立，是静态的，在编译的时刻便确立下来了。&lt;strong&gt;对象模式&lt;/strong&gt;处理对象间的关系，这些关系在运行时刻是可以变化的，更具有动态性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　模式分类如下图 4-1所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188576/201904/1188576-20190410232818631-33640463.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　图4-1模式的分类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 15:29:00 +0000</pubDate>
<dc:creator>疯子&amp;#183;策天</dc:creator>
<og:description>一、什么是设计模式？ “每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次的使用该方案而不必做重复的劳动”。 二、模式四个基本要素 1.模式名称 （p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/planheaven/p/10686967.html</dc:identifier>
</item>
<item>
<title>WPF 通过线程使用ProcessBar - 风幻影</title>
<link>http://www.cnblogs.com/hglSV/p/10686958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hglSV/p/10686958.html</guid>
<description>&lt;p&gt;WPF下使用进度条也是非常方便的，如果直接采用循环然后给ProcessBar赋值，理论上是没有问题的，不过这样会卡主主UI线程，我们看到的效果等全部都结束循环后才出现最后的值。&lt;/p&gt;
&lt;p&gt;所以需要采用线程或者后台方式给进度条赋值的方式，以下通过线程来触发事件触发的方式来实现给进度条赋值。这样就可以模拟我们在实际过程中处理数据的一种进度方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Controls;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Data;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Documents;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Input;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Media;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Media.Imaging;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Navigation;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Shapes;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WpfTestProcessBar
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; MainWindow.xaml 的交互逻辑
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainWindow : Window
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ProgressDelegate(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; percent);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainWindow()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            InitializeComponent();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             ProgressEvent +=&lt;span&gt; MainWindow_ProgressEvent;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            beginImport();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; MainWindow_ProgressEvent(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; percent)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Dispatcher.Invoke(&lt;span&gt;new&lt;/span&gt; Action&amp;lt;System.Windows.DependencyProperty, &lt;span&gt;object&lt;/span&gt;&amp;gt;(Pro.SetValue), System.Windows.Threading.DispatcherPriority.Background, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { ProgressBar.ValueProperty, Convert.ToDouble(percent+ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) });
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             Dispatcher.Invoke(&lt;span&gt;new&lt;/span&gt; Action&amp;lt;System.Windows.DependencyProperty, &lt;span&gt;object&lt;/span&gt;&amp;gt;(label.SetValue), System.Windows.Threading.DispatcherPriority.Background, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { Label.ContentProperty, Convert.ToString((percent + &lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) }); 
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; ProgressDelegate ProgressEvent;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beginImport()
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             Pro.Maximum = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             Pro.Value = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             label.Content = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             ThreadPool.QueueUserWorkItem(state =&amp;gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 Thread.Sleep(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (ProgressEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                        ProgressEvent(i);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     Thread.Sleep(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上只是一种实现方式，希望给有需要的人提供帮助。&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/696166/201904/696166-20190410232451533-1451188072.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 10 Apr 2019 15:27:00 +0000</pubDate>
<dc:creator>风幻影</dc:creator>
<og:description>WPF下使用进度条也是非常方便的，如果直接采用循环然后给ProcessBar赋值，理论上是没有问题的，不过这样会卡主主UI线程，我们看到的效果等全部都结束循环后才出现最后的值。 所以需要采用线程或者后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hglSV/p/10686958.html</dc:identifier>
</item>
<item>
<title>线上一个数组查询遇到的坑 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10686892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10686892.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;中午12点半，接到了线上MongoDB 数据库异常的告警通报：&lt;/p&gt;
&lt;p&gt;“CPU不间断飙升到百分百，业务也相应出现了抖动现象。”&lt;/p&gt;
&lt;p&gt;通过排查数据库主节点的日志，发现了这样的一个慢语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2019-03-07T10:56:43.470+0000 I COMMAND [conn2544772] command nlp.ApplicationDevice appName: &quot;nlp&quot; command: 
find { find: &quot;ApplicationDevice&quot;, filter: { appId: &quot;Gf93VvCfOdttrxSOemt_03ff&quot;, tags.tagName: &quot;pipeline&quot;,
tags.tagValue: &quot;multi&quot;, _id: { $gt: ObjectId('000000000000000000000000') } }, projection: { $sortKey: { $meta: &quot;sortKey&quot; } }, 
sort: { _id: 1 }, limit: 10, shardVersion: [ Timestamp 1000|1000, ObjectId('5c64f941c81e2b922e48e347') ] } 
planSummary: IXSCAN { appId: 1, tags.tagName: 1, tags.tagValue: 1, _id: 1 } 
keysExamined:1000002 docsExamined:1000001 hasSortStage:1 cursorExhausted:1 numYields:7829 
nreturned:10 reslen:7102 locks:{ Global: { acquireCount: { r: 15660 } }, 
Database: { acquireCount: { r: 7830 } }, Collection: { acquireCount: { r: 7830 } } } protocol:op_command 4008ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从语句中初步判断，&lt;strong&gt;&quot;keysExamined&quot;&lt;/strong&gt;和&lt;strong&gt;docsExamined&lt;/strong&gt; 显示扫描了100W 条记录，其中也用到了下面的索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ appId: 1, tags.tagName: 1, tags.tagValue: 1, _id: 1 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟研发兄弟确认过后，该查询的目的是 找到&lt;strong&gt;某些应用下带指定标签的设备信息&lt;/strong&gt;，按ID分段去获取，每次只查询10条。&lt;br/&gt;关于索引的设计也已经确认过是最优的了，而且此前在开发环境中一直没有出现过问题，不知道为什么这次就出问题了。&lt;/p&gt;
&lt;h2 id=&quot;详细分析&quot;&gt;详细分析&lt;/h2&gt;
&lt;p&gt;接下来，看了下该集合的模型，大致是长下面的样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* 1 */
{
    &quot;appId&quot; : &quot;Gf93VvCfOdttrxSOemt_03ff&quot;,
    &quot;deviceId&quot; : &quot;bbc-lmc-03991933&quot;,
    &quot;nodeType&quot; : &quot;FACTORY&quot;,
    &quot;creationTime&quot; : ISODate(&quot;2019-03-01T10:11:39.852Z&quot;),
    &quot;lastModifiedTime&quot; : ISODate(&quot;2019-03-03T10:45:40.249Z&quot;),
    &quot;tags&quot; : [ 
        {
            &quot;tagName&quot; : &quot;pipeline&quot;,
            &quot;tagValue&quot; : &quot;multi&quot;,
            &quot;tagType&quot; : 1
        }
    ],
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;br/&gt;除了其他的属性之外，tags字段采用了嵌套文档数组的结构；&lt;br/&gt;每一个元素都对应了一个tag对象，包含 tagName/tagValue/tagType几个字段。&lt;/p&gt;
&lt;p&gt;然后是&lt;strong&gt;查询的模式&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
//过滤条件
{ 
  appId: &quot;Gf93VvCfOdttrxSOemt_03ff&quot;, 
  tags.tagName: &quot;pipeline&quot;, 
  tags.tagValue: &quot;multi&quot;, 
  _id: { $gt: ObjectId('000000000000000000000000')
}

//排序
sort: { _id: 1 }

//限制条数
limit: 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这从索引的前缀匹配来看，是应该没有问题的，索引的定义如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ appId: 1, tags.tagName: 1, tags.tagValue: 1, _id: 1 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了避免对线上环境造成影响，我们找了一个测试环境来做了尝试复现，执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.ApplicationDevice.find({
  &quot;appId&quot;:&quot;Gf93VvCfOdttrxSOemt_03ff&quot;,
  &quot;tags.tagName&quot;:&quot;pipeline&quot;,
  &quot;tags.tagValue&quot;:&quot;multi&quot;,
  _id:{$gt:ObjectId(&quot;000000000000000000000000&quot;)}})
  .sort({&quot;_id&quot; : 1})
  .explain()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果却跟线上的情况不大一样，这次选中的是**_id**索引！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;winningPlan&quot; : {
&quot;stage&quot; : &quot;LIMIT&quot;,
&quot;limitAmount&quot; : 10,
&quot;inputStage&quot; : {
    &quot;stage&quot; : &quot;SHARDING_FILTER&quot;,
    &quot;inputStage&quot; : {
            &quot;stage&quot; : &quot;FETCH&quot;,
            &quot;filter&quot; : {
                    &quot;$and&quot; : [
                        {
                           &quot;appId&quot; : {
                                   &quot;$eq&quot; : &quot;Gf93VvCfOdttrxSOemt_03ff&quot;
                           }
                        },
                        {
                           &quot;tags.tagName&quot; : {
                                   &quot;$eq&quot; : &quot;pipeline&quot;
                           }
                        },
                        {
                           &quot;tags.tagValue&quot; : {
                                   &quot;$eq&quot; : &quot;multi&quot;
                           }
                        }
                    ]
            },
            &quot;inputStage&quot; : {
                    &quot;stage&quot; : &quot;IXSCAN&quot;,
                    &quot;keyPattern&quot; : {
                            &quot;_id&quot; : 1
                    },
                    &quot;indexName&quot; : &quot;_id_&quot;,
                    &quot;isMultiKey&quot; : false,
                    &quot;multiKeyPaths&quot; : {
                            &quot;_id&quot; : [ ]
                    },
                    &quot;isUnique&quot; : true,
                    &quot;isSparse&quot; : false,
                    &quot;isPartial&quot; : false,
                    &quot;indexVersion&quot; : 2,
                    &quot;direction&quot; : &quot;forward&quot;,
                    &quot;indexBounds&quot; : {
                            &quot;_id&quot; : [
                                    &quot;(ObjectId('000000000000000000000000'), ObjectId('ffffffffffffffffffffffff')]&quot;
                            ]
                    }
            }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而同样的是也扫描了100W+的记录数，于是大家认为可能索引的选择器出了问题，但就算是选择器的问题也仍然没办法解释线上出现的现象(线上的索引可是命中的)&lt;br/&gt;为了一探究竟，我们使用 hint 强制让查询命中 **appId_1_tags.tagName_1_tags.tagValue_1__id_1**这个索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.ApplicationDevice.find({
    &quot;appId&quot;:&quot;Gf93VvCfOdttrxSOemt_03ff&quot;,
    &quot;tags.tagName&quot;:&quot;pipeline&quot;,&quot;tags.tagValue&quot;:&quot;multi&quot;,
    _id:{$gt:ObjectId(&quot;000000000000000000000000&quot;)}})
 .sort({&quot;_id&quot; : 1}).limit(10)
    .hint(&quot;appId_1_tags.tagName_1_tags.tagValue_1__id_1&quot;)
 .explain(&quot;executionStats&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一次的结果显示确实命中了对应的索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;winningPlan&quot; : {
&quot;stage&quot; : &quot;SORT&quot;,
&quot;sortPattern&quot; : {
    &quot;_id&quot; : 1.0
},
&quot;limitAmount&quot; : 10,
&quot;inputStage&quot; : {
    &quot;stage&quot; : &quot;SORT_KEY_GENERATOR&quot;,
    &quot;inputStage&quot; : {
        &quot;stage&quot; : &quot;FETCH&quot;,
        &quot;filter&quot; : {
            &quot;tags.tagValue&quot; : {
                &quot;$eq&quot; : &quot;multi&quot;
            }
        },
        &quot;inputStage&quot; : {
            &quot;stage&quot; : &quot;IXSCAN&quot;,
            &quot;keyPattern&quot; : {
                &quot;appId&quot; : 1.0,
                &quot;tags.tagName&quot; : 1.0,
                &quot;tags.tagValue&quot; : 1.0,
                &quot;_id&quot; : 1.0
            },
            &quot;indexName&quot; : &quot;appId_1_tags.tagName_1_tags.tagValue_1__id_1&quot;

    ...

&quot;executionStats&quot; : {
    &quot;executionSuccess&quot; : true,
    &quot;nReturned&quot; : 10,
    &quot;executionTimeMillis&quot; : 3665,
    &quot;totalKeysExamined&quot; : 1000002,
    &quot;totalDocsExamined&quot; : 1000001,
    &quot;executionStages&quot; : {
        &quot;stage&quot; : &quot;SORT&quot;,
        &quot;nReturned&quot; : 10,
        &quot;executionTimeMillisEstimate&quot; : 3513,
        &quot;works&quot; : 1000014,
        &quot;sortPattern&quot; : {
            &quot;_id&quot; : 1.0
        },
        &quot;memUsage&quot; : 6660,
        &quot;memLimit&quot; : 33554432,
        &quot;limitAmount&quot; : 10,
        &quot;inputStage&quot; : {
            &quot;stage&quot; : &quot;SORT_KEY_GENERATOR&quot;,
            &quot;nReturned&quot; : 500001,
            &quot;executionTimeMillisEstimate&quot; : 3333,
            &quot;works&quot; : 1000003,
            &quot;advanced&quot; : 500001,
            &quot;needTime&quot; : 500001,
            &quot;inputStage&quot; : {
                &quot;stage&quot; : &quot;FETCH&quot;,
                &quot;filter&quot; : {
                        &quot;tags.tagValue&quot; : {
                            &quot;$eq&quot; : &quot;multi&quot;
                        }
                    },
                    &quot;nReturned&quot; : 500001,
                    &quot;executionTimeMillisEstimate&quot; : 3087,
                    &quot;works&quot; : 1000002,
                    &quot;advanced&quot; : 500001,
                    &quot;needTime&quot; : 500000,
                    &quot;docsExamined&quot; : 1000001,
                    &quot;alreadyHasObj&quot; : 0,
                    &quot;inputStage&quot; : {
                        &quot;stage&quot; : &quot;IXSCAN&quot;,
                        &quot;nReturned&quot; : 1000001,
                        &quot;executionTimeMillisEstimate&quot; : 1117,
                        &quot;works&quot; : 1000002,
                        &quot;advanced&quot; : 1000001,
                        &quot;keyPattern&quot; : {
                            &quot;appId&quot; : 1.0,
                            &quot;tags.tagName&quot; : 1.0,
                            &quot;tags.tagValue&quot; : 1.0,
                            &quot;_id&quot; : 1.0
                        },
                        &quot;indexName&quot; : &quot;appId_1_tags.tagName_1_tags.tagValue_1__id_1&quot;,
                        &quot;isMultiKey&quot; : true,
                        &quot;multiKeyPaths&quot; : {
                            &quot;appId&quot; : [],
                            &quot;tags.tagName&quot; : [ 
                                &quot;tags&quot;
                            ],
                            &quot;tags.tagValue&quot; : [ 
                                &quot;tags&quot;
                            ],
                            &quot;_id&quot; : []
                        },
                        &quot;indexBounds&quot; : {
                            &quot;appId&quot; : [ 
                                &quot;[\&quot;Gf93VvCfOdttrxSOemt_03ff\&quot;, \&quot;Gf93VvCfOdttrxSOemt_03ff\&quot;]&quot;
                            ],
                            &quot;tags.tagName&quot; : [ 
                                &quot;[\&quot;pipeline\&quot;, \&quot;pipeline\&quot;]&quot;
                            ],
                            &quot;tags.tagValue&quot; : [ 
                                &quot;[MinKey, MaxKey]&quot;
                            ],
                            &quot;_id&quot; : [ 
                                &quot;(ObjectId('000000000000000000000000'), ObjectId('ffffffffffffffffffffffff')]&quot;
                            ]
                        },
                        &quot;keysExamined&quot; : 1000002,
                        &quot;dupsTested&quot; : 1000001,
                    }
                }
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，在整个执行过程中(executionStats)，出现了内存排序(SORT)。&lt;br/&gt;而且，从一开始命中** appId_1_tags.tagName_1_tags.tagValue_1__id_1 **这个索引的阶段中，就已经扫描了100W条记录，简直不可思议！&lt;/p&gt;
&lt;p&gt;但同时，我们也从&lt;strong&gt;indexBounds&lt;/strong&gt;的指示中找到了端倪：&lt;br/&gt;appId、tags.tagName 都命中了单值，在 &lt;strong&gt;tags.tagValue&lt;/strong&gt; 的路径节点上却覆盖了全部范围！&lt;br/&gt;**由于中间索引节点出现了大范围覆盖，导致最终需要在内存中对大量的数据做 _id字段的排序**，这个就是导致慢操作的原因！&lt;/p&gt;
&lt;h2 id=&quot;解决问题&quot;&gt;解决问题&lt;/h2&gt;
&lt;p&gt;既然从前面的分析中找到了问题的来源，我们的推论如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;既然索引的命中没有问题，那么导致大范围扫描的只可能是查询模式的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再次拿出前面的查询条件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ 
  appId: &quot;Gf93VvCfOdttrxSOemt_03ff&quot;, 
  tags.tagName: &quot;pipeline&quot;, 
  tags.tagValue: &quot;multi&quot;, 
  _id: { $gt: ObjectId('000000000000000000000000')
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在索引的匹配中，只能单键命中&lt;strong&gt;tags.tagName: &quot;pipeline&quot;&lt;/strong&gt; 这一个条件，那么由于 tags是一个嵌套文档的数组，&lt;br/&gt;对于上面的查询，语义上是指那些 &lt;strong&gt;包含某个元素 可命中tagName，且包含某个元素 可命中 tagValue&lt;/strong&gt;的文档，这里面并不要求 同一个元素同时命中tagName和tagValue。&lt;/p&gt;
&lt;p&gt;但 MongoDB 在嵌套数组索引的构建上是按照同一个元素的字段组合去构建的。 关于这点，可以参考下面的地址：&lt;br/&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/core/index-multikey/#multikey-embedded-documents&quot; class=&quot;uri&quot;&gt;https://docs.mongodb.com/manual/core/index-multikey/#multikey-embedded-documents&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于数组元素的条件匹配，应该使用 &lt;strong&gt;$elemMatch&lt;/strong&gt;，其用法可&lt;a href=&quot;https://docs.mongodb.com/manual/tutorial/query-array-of-documents/&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为此，我们构建了下面的查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.ApplicationDevice.find({
    &quot;appId&quot;:&quot;Gf93VvCfOdttrxSOemt_03ff&quot;,
    &quot;tags&quot;: {$elemMatch: { &quot;tagName&quot;:&quot;pipeline&quot;,&quot;tagValue&quot;:&quot;multi&quot; }},
    _id:{$gt:ObjectId(&quot;000000000000000000000000&quot;)}})
 .sort({&quot;_id&quot; : 1}).limit(10)
   .explain(&quot;executionStats&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;winningPlan&quot; : {
    &quot;stage&quot; : &quot;LIMIT&quot;,
    &quot;limitAmount&quot; : 10,
    &quot;inputStage&quot; : {
        &quot;stage&quot; : &quot;IXSCAN&quot;,
        &quot;keyPattern&quot; : {
            &quot;appId&quot; : 1.0,
            &quot;tags.tagName&quot; : 1.0,
            &quot;tags.tagValue&quot; : 1.0,
            &quot;_id&quot; : 1.0
        },
        &quot;indexName&quot; : &quot;appId_1_tags.tagName_1_tags.tagValue_1__id_1&quot;,
    }
},
&quot;executionStats&quot; : {
&quot;executionSuccess&quot; : true,
&quot;nReturned&quot; : 10,
&quot;executionTimeMillis&quot; : 3,
&quot;totalKeysExamined&quot; : 10,
&quot;totalDocsExamined&quot; : 10,
&quot;executionStages&quot; : {
    &quot;stage&quot; : &quot;LIMIT&quot;,
    &quot;nReturned&quot; : 10,
    &quot;inputStage&quot; : {
        &quot;stage&quot; : &quot;FETCH&quot;,
        &quot;filter&quot; : {...},
        &quot;nReturned&quot; : 10,,
        &quot;inputStage&quot; : {
            &quot;stage&quot; : &quot;IXSCAN&quot;,
            &quot;nReturned&quot; : 10,
            &quot;executionTimeMillisEstimate&quot; : 0,
            &quot;works&quot; : 10,
            &quot;advanced&quot; : 10,
            &quot;isEOF&quot; : 0,
            &quot;indexName&quot; : &quot;appId_1_tags.tagName_1_tags.tagValue_1__id_1&quot;,
            &quot;isMultiKey&quot; : true,
            &quot;indexBounds&quot; : {
                &quot;appId&quot; : [ 
                    &quot;[\&quot;Gf93VvCfOdttrxSOemt_03ff\&quot;, \&quot;Gf93VvCfOdttrxSOemt_03ff\&quot;]&quot;
                ],
                &quot;tags.tagName&quot; : [ 
                    &quot;[\&quot;pipeline\&quot;, \&quot;pipeline\&quot;]&quot;
                ],
                &quot;tags.tagValue&quot; : [ 
                    &quot;[\&quot;multi\&quot;, \&quot;multi\&quot;]&quot;
                ],
                &quot;_id&quot; : [ 
                    &quot;(ObjectId('000000000000000000000000'), ObjectId('ffffffffffffffffffffffff')]&quot;
                ]
            }
    ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个结果是令人满意的，除了自动命中合适的索引之外，这个查询过程也达到了最优的路径匹配，扫描记录数才10条！&lt;br/&gt;最后，根据该方案调整了查询模式，线上的问题得到恢复。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;看似很简单的一个查询语句，没想到会出现这么大的坑，其实无论是作为开发人员还是DBA，都应当谨慎对待你的SQL。&lt;br/&gt;重要的事情说三遍！！！ SQl查询上线前务必 explain、务必分析到位，这难道没有道理？&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 15:13:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>背景 中午12点半，接到了线上MongoDB 数据库异常的告警通报： “CPU不间断飙升到百分百，业务也相应出现了抖动现象。” 通过排查数据库主节点的日志，发现了这样的一个慢语句： 从语句中初步判断，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10686892.html</dc:identifier>
</item>
<item>
<title>[java初探10]__关于数字处理类 - 小舍先生</title>
<link>http://www.cnblogs.com/gemuxiaoshe/p/10686551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gemuxiaoshe/p/10686551.html</guid>
<description>&lt;ul&gt;&lt;li&gt;前言&lt;br/&gt;在我们的日常开发过程中,我们会经常性的使用到数字类型的数据,同时,也会有众多的对数字处理的需求,针对这个方面的问题,在JAVA语言中.提供解决方法的类就是数字处理类&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;java中的数字处理类包括:&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;DecimalFormat类,用于格式化数字&lt;/li&gt;
&lt;li&gt;Math类,为各种数学计算提供了工具方法&lt;/li&gt;
&lt;li&gt;Random类,为java处理随机数问题提供了各种方法&lt;/li&gt;
&lt;li&gt;BigInteger类与BigDecimal类,为java处理大数字提供了相应的数学运算操作方法.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;DecimalFormat类&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;数字的格式化在解决实际问题时,使用非常普遍,如超市的商品价格,银行的余额显示,都需要对小数的精度有特定的要求,java主要对浮点数进行格式化.JAVA语言就是通过DecimalFormat类来对其进行格式化操作的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DecimalFromat类是继承与NumberFormat类的,NumberFormat类又是Format类的子类,这里我们就可以很明显的观察到java类的继承机制是如何在Java类库中存在的.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DecimalFormat extends NumberFormat {
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-f2c510a1ccb9c237.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-02.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DecimalFormat类用以格式化十进制数字.他可以将一些数字格式化为整数,浮点数,百分数等.通过该类可以为要输出的数字加上单位或控制数字的精度.一般通过实例化DecimalFormat对象是传递数字格式,也可以通过类中的applyPattern方法来实现数字的格式化.&lt;/p&gt;
&lt;p&gt;需要注意的是:&lt;br/&gt;在格式化数字的时候,DecimalFormat类中使用了一些特殊字符构成一个格式化的模版,使数字按照一定的特殊字符来进行匹配.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-4b04f60d45bf1e94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-03.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;格式化方法体的代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; // 第一种格式化方法,直接通过构造方法传入格式控制参数patten.
    private void NumFormating(String patten, double adouble){  // 传入两个参数,第一个控制格式,第二个为传入的数值.
    DecimalFormat format = new DecimalFormat(patten);
    System.out.println(format.format(adouble)); // 通过format方法格式化参数adouble
    }
    // 第二种格式化方法,通过类的方法applyPattern方法传入格式控制参数patten
    private void NumFormating1(String patten,double adouble){
    DecimalFormat format = new DecimalFormat();
    format.applyPattern(patten);
    System.out.println(format.format(adouble)); // 通过format方法,格式化参数adouble
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试一下:&lt;br/&gt;在主方法中通过实例化对象调用我们编写的格式化方法来对不同的特殊字符组进行示例输出:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; public static void main(String[] args) {
        Sty_DigitalProcessing digitalProcessing = new Sty_DigitalProcessing();
        digitalProcessing.NumFormating(&quot;000,000.0000&quot;,12345.67);
        digitalProcessing.NumFormating1(&quot;###,###.####&quot;,12345.67);
        digitalProcessing.NumFormating(&quot;###,###.####kg&quot;,12345.67);
        System.out.println();
        digitalProcessing.NumFormating(&quot;#.###%&quot;,0.345);
        digitalProcessing.NumFormating(&quot;0.000%&quot;,0.345);
        System.out.println();
        digitalProcessing.NumFormating(&quot;0.0000\u2030&quot;,0.123456);
        digitalProcessing.NumFormating(&quot;#.####\u2030&quot;,0.123456);
        System.out.println();
        digitalProcessing.NumFormating(&quot;000,000,000.0000\u00A4&quot;,1234567.89);
        digitalProcessing.NumFormating(&quot;###,###,###.##'#'&quot;,1234567.89);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;结果&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-f639b743d563eaeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-04.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;我们可以很明显的看出来,0和#之间的区别,前者,在位数不足时会补零,后者则不会补零.通常情况下,我们知道,一般是不会在数字前补零的,补零的情况通常出现在小数后面.&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Math类&lt;/strong&gt;&lt;br/&gt;Math类主要给我们提供了一些数学上的众多运算方法,我们知道,一个科学计算器是具有着非常强大功能的,而我们最基本的运算符只有&quot;+,-,*,/&quot;.所以很多运算方法,在java语言中,都是是通过Math类实现的和提供的.&lt;br/&gt;同时,Math类也提供有众多的常量定义,因为Math中的方法是通用的,可以适用于程序的任何时候任何地方的数学运算中,所以Math类中的方法都被构建为静态的方法,使得他们都可以直接被调用.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-7a33af37e00eec94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-05.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-458084e8c84f9bac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-06.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Math中常用的方法&lt;br/&gt;Math中常用的数学运算方法有很多,其大致可以分为4类.三角函数方法,指数函数方法,取整方法以及取最大最小值和绝对值函数方法.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;三角函数方法&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-6875c6a6ef231348.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-07.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它们都是静态的,所以可以直接通过类名.方法名调用.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; System.out.println(Math.sin(subtense)); // 返回正弦
        System.out.println(Math.cos(subtense)); // 返回余弦
        System.out.println(Math.tan(subtense)); // 返回正切
        System.out.println(Math.asin(subtense)); // 返回一个值的反正弦
        System.out.println(Math.acos(subtense)); // 返回一个值的反余弦
        System.out.println(Math.atan(subtense)); // 返回一个值的反正切
        System.out.println(Math.toRadians(angdeg)); // 将角度转换为弧度
        System.out.println(Math.toDegrees(angdeg)); // 将弧度转换为角度&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;指数函数方法&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-e3e2d708230e522a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-08.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-f971815cc6c55c36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-09.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; // 指数函数方法
    private void styindex(double adouble,double adouble1){
        System.out.println(Math.exp(adouble)); // 用于获取e的a次方
        System.out.println(Math.log(adouble)); // 用于取自然对数,lna的值
        System.out.println(Math.log10(adouble)); // 用于取底数为10的整数
        System.out.println(Math.sqrt(adouble)); // 用于取a的平方根,其中a的值不能为负值.
        System.out.println(Math.cbrt(adouble)); // 用于取a的立方根
        System.out.println(Math.pow(adouble,adouble1)); // 用于取a的b次方
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;取整函数方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-6da07e7de43cf506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-11.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private void styAdjustment(double adouble,float afloat){
        System.out.println(Math.ceil(adouble)); // 返回大于等于参数的最小整数.
        System.out.println(Math.floor(adouble)); // 返回小于等于参数的最大整数.
        System.out.println(Math.rint(adouble)); // 返回与参数最接近的整数(若为0.5取偶数,即加一)
        System.out.println(Math.round(adouble)); // 将参数家上0.5返回与参数最近的整数
        System.out.println(Math.round(afloat)); // 将参数加上0.5后返回与参数最近的整数,然后强转为长整型.
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;取绝对值,最大最小值的函数方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-8d18b1267069f971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-12.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /**
     *  取最大值,最小值,绝对值函数方法.
     *  其方法都重载有多个类型的,满足不同类型参数的最大最小值,绝对值的获取.
     */
    private void stytakequals(double adouble,double adouble1){
        System.out.println(Math.max(adouble,adouble1)); // 取两个double型参数的最大值
        System.out.println(Math.min(adouble,adouble1));
        System.out.println(Math.abs(adouble)); // 返回double型参数的绝对值
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;随机数&lt;/strong&gt;&lt;br/&gt;随机数的获取有两种方式,Math.random方法给我们提供了double型随机数的获取.Random类则要更加广泛一些,可以生成任何类型的随机数.这里直接通过代码表示了:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; /**
     * 随机数
     * Math类中有提供random方法来生产随机数.
     * 该方法默认生成0.0-1.0之间的double型随机数.
     * 但该方法通过处理后还是可以生成任何范围的随机数的.
     * ;将该方法*n后强转为int型输出,可以得到0-n范围的随机数.
     * 而m+(int)Math.random()*n,将上面的式子+m后,就可以得到m-(m+n)范围的随机数.
     */
    private void styrandom(){
        System.out.println(Math.random());
        System.out.println((int)(Math.random()*100));
        System.out.println((int)(10+Math.random()*15));
        System.out.println((char)('a'+ Math.random()*('z'-'a'+1))); // 这里其实可以封装成一个获取固定范围的随机字符的方法.
    }
    /**
     * Random类
     * Random类提供各种类型随机数的构造方法
     * 通过实例化对象调用.
     * 比Math.random更为强大.
     */
    private void styRandom(int n){ // 传入参数n 控制范围
        Random random = new Random(10000);
        System.out.println(random.nextInt());
        System.out.println(random.nextDouble());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于random seedvalue的说明参看:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.grasshopper3d.com/forum/topics/what-are-random-seed-values&quot;&gt;一篇关于什么是随机种子的博文&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;大数字运算&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;BigInteger类&lt;br/&gt;BigInteger类型的数范围比Integer类的要打的多,我们知道int型最大为2^31-1;而BigInteger类支持任意大小精度的整数.并且提供一些基本的运算方法,加减乘除等,这里就不多加说明了,在BigInteger类的结构视窗中可以找到他们.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BigInteger类通过构造方法来直接将某个值转换为BigInteger类型.其构造方法有很多.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-b9d74234820eba37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-10-10.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private void styBigInteger(){
        BigInteger bigInteger = new BigInteger(&quot;12345678901234567890&quot;); // 直接通过构造法方法,将值转为BigInteger型.
        BigInteger bigInteger1 = new BigInteger(&quot;43534645376574567314253543&quot;);
        System.out.println(bigInteger.add(bigInteger1)); // 简单的运算
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;BigDecimal类&lt;/strong&gt;&lt;br/&gt;相对的,BigInteger类只是针对与大整数之间的运算而BigDecimal类较其更加完善的一点就是,引入了小数概念,所以BigDecimal类支持任何精度的定点数.&lt;br/&gt;同样的BigDecimal类也提供有一些基本的运算方法.可以在类中查看.&lt;br/&gt;BigDecimal类也是通过构造方法直接转换值的类型:&lt;br/&gt;BigDecimal(double val)方法和BigDecimal(String val)方法.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;BigDecimal bigDecimal = new BigDecimal(1231234345634.546756734563);
BigDecimal bigDecimal1 = new BigDecimal(&quot;124235345645765.783452352342534&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;关于java数字处理类就了解到这么多了,其实其中还有很多方法都没有涉及到,关于java的类库,其中值得学习的,涵盖着各个方面的类和方法,需要在之后的不断学习的过程中不断接触了解才能够渐渐掌握,这里也仅仅只是对其中极少的一部分基本知识做总结学习.&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;后记&lt;br/&gt;关于java语言的基本知识大致就学到这里了,之后会新开一个笔记系列,接着学习java的核心知识,接口,继承封装,多态,类的高级特性,异常处理,Swing窗口程序设计.等等.&lt;br/&gt;可以说这才是刚刚跨入java语言的门槛吧?任务还十分艰巨,革命还需百倍努力啊!&lt;br/&gt;之后我会在出一篇关于java初探阶段的整理笔记,将这段时间的学习做一个总结归纳,并整理一下笔记的顺序,捋一捋思路.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后也祝愿大家都能够在自己前进的道路上披荆斩棘,共同进步,走向成功.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;更新时间:&lt;br/&gt;2019-4-10&lt;br/&gt;22:06&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 14:12:00 +0000</pubDate>
<dc:creator>小舍先生</dc:creator>
<og:description>前言 在我们的日常开发过程中,我们会经常性的使用到数字类型的数据,同时,也会有众多的对数字处理的需求,针对这个方面的问题,在JAVA语言中.提供解决方法的类就是数字处理类 java中的数字处理类包括:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gemuxiaoshe/p/10686551.html</dc:identifier>
</item>
<item>
<title>【重学计算机】操作系统D2章：处理器管理 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/10669853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/10669853.html</guid>
<description>[unable to retrieve full-text content]1. 指令与处理器模式 指令执行周期：取指、译码、执行 指令分类（根据权限） 特权指令：只能被操作系统内核使用（启动IO，置PC值） 非特权指令：所有程序都能使用 处理器模式： 共有四种：0内核模式，1系统调用，2共享库程序，3用户模式 一般来说：只有0内核模式（能执行全部指令）和3用户模式（只能执</description>
<pubDate>Wed, 10 Apr 2019 11:21:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<og:description>操作系统、进程、线程、CPU</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flashsun/p/10669853.html</dc:identifier>
</item>
<item>
<title>机器学习导图系列（4）：算法(含61公式) - CaiYongji</title>
<link>http://www.cnblogs.com/takeurhand/p/10685467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takeurhand/p/10685467.html</guid>
<description>&lt;p&gt;机器学习导图系列教程旨在帮助引导开发者对机器学习知识网络有一个系统的概念，其中有些具体释义并未完善，需要开发者自己探索才能对具体知识有深入的掌握。本项目灵感来自Daniel Formoso的github开源项目。本文作者对其项目进行翻译、整理、批注等二次创作，其中不乏生僻的数学名词，对于没有留过学的作者来说费了很多功夫。我又将导图整理成了知识卡片，方便大家查看。由于机器学习的知识网络很大，导致完整的导图过大，文章中的图片可能经过压缩，如需完整图片可查看github项目&lt;strong&gt;machine-learning-mindmap-cn&lt;/strong&gt;下载高清原图。本系列还在持续创作中，你的点赞、留言、star都会成为我持续创作的动力。&lt;/p&gt;
&lt;p&gt;machine-learning-mindmap-cn: &lt;a href=&quot;https://github.com/caiyongji/machine-learning-mindmap-cn&quot; class=&quot;uri&quot;&gt;https://github.com/caiyongji/machine-learning-mindmap-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;机器学习导图系列分为五大模块。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;机器学习数据处理&lt;/li&gt;
&lt;li&gt;机器学习概念&lt;/li&gt;
&lt;li&gt;机器学习过程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机器学习算法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;机器学习模型及神经网络模型&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191527189-1408904623.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性代数&quot;&gt;线性代数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191559384-2120459137.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;统计&quot;&gt;统计&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191547589-204693906.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;优化&quot;&gt;优化&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191608672-1054615388.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;正则化&quot;&gt;正则化&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191622714-1032496050.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191629710-1034633915.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;概率&quot;&gt;概率&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191638641-1575072628.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分布&quot;&gt;分布&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191650404-2047334073.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;信息论&quot;&gt;信息论&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191700469-1758221476.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;密度估计&quot;&gt;密度估计&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/678094/201904/678094-20190410191707017-616915827.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 11:17:00 +0000</pubDate>
<dc:creator>CaiYongji</dc:creator>
<og:description>机器学习导图系列教程旨在帮助引导开发者对机器学习知识网络有一个系统的概念，其中有些具体释义并未完善，需要开发者自己探索才能对具体知识有深入的掌握。本项目灵感来自Daniel Formoso的githu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takeurhand/p/10685467.html</dc:identifier>
</item>
<item>
<title>【.NET异步编程系列1】：await&amp;async语法糖让异步编程如鱼得水 - Julian_酱</title>
<link>http://www.cnblogs.com/mi12205599/p/10678887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mi12205599/p/10678887.html</guid>
<description>&lt;h3 id=&quot;1350-1554563253220&quot;&gt;前导&lt;/h3&gt;
&lt;p&gt;　　Asynchronous programming Model（APM）异步编程模型以BeginMethod(...) 和 EndMethod(...)结对出现。&lt;/p&gt;
&lt;div readability=&quot;54.420158218576&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
IAsyncResult  BeginGetResponse(AsyncCallback callback, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; state)
WebResponse  EndGetResponse(IAsyncResult asyncResult)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　Event-based Asynchronous Pattern（EAP）模型以MethodAsync(...) 和CancelAsync(...) 结对出现，由Completed事件设置回调函数。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;WebClient类中通过DownloadStringAsync方法开启一个异步任务，并由DownloadStringCompleted事件供设置回调函数，能通过CancelAsync方法取消异步任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　.Net4.5开始Task Parallel Library（TPL） 为异步和并行编程提供新的模型，使异步和并发操作有统一的编程入口，&lt;/p&gt;
&lt;p&gt;该模型常定义以Async后缀结尾的函数名、返回带有awaitable属性的Task/Task&amp;lt;T&amp;gt;对象， 如果你的program target设置为4.5+，可用Task-based Asynchronous Pattern (TAP)取代以上2种模型。&lt;/p&gt;

&lt;h3&gt;TAP&lt;/h3&gt;
&lt;p&gt;　　TPL的核心是Task类，Task，Task&amp;lt;TResult&amp;gt;可以将其理解为&lt;strong&gt;一个包装委托（通常就是Action或Func委托）并执行的容器&lt;/strong&gt;，有了Task几乎不用去和Thread 打交道，使用者只需要关注具体业务对应的Job，Task背后有一个 TaskScheduler 的类来负责调度Task的执行，这样Task对象将在默认的TaskScheduler调度下执行，TaskScheduler使用线程池中的线程，至于是新建还是使用已有线程这个对用户是完全透明的，也可以通过重载函数的参数传入自定义的TaskScheduler。&lt;/p&gt;
&lt;p&gt;Task任务状态：&lt;/p&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;0&quot; frame=&quot;hsides&quot; rules=&quot;none&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr&gt;&lt;td&gt; 状态&amp;amp; 枚举值&lt;/td&gt;
&lt;td&gt; 说明&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; Created = 0&lt;/td&gt;
&lt;td&gt; The task has been initialized but has not yet been scheduled&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt; WaitingForActivation = 1&lt;/td&gt;
&lt;td&gt; The task is waiting to be activated and scheduled internally by the .NET Framework infrastructure.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; WaitingToRun = 2&lt;/td&gt;
&lt;td&gt; The task has been scheduled for execution but has not yet begun executing.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; Running = 3&lt;/td&gt;
&lt;td&gt; The task is running but has not yet completed.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt; WaitingForChildrenToComplete = 4&lt;/td&gt;
&lt;td&gt; The task has finished executing and is implicitly waiting for attached child tasks to complete.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; RanToCompletion = 5&lt;/td&gt;
&lt;td&gt; The task completed execution successfully&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;Canceled = 6&lt;/td&gt;
&lt;td&gt; The task acknowledged cancellation by throwing an OperationCanceledException with its own CancellationToken while the token was in signaled state, or the task's CancellationToken was already signaled before the task started executing&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; Faulted = 7&lt;/td&gt;
&lt;td&gt; The task completed due to an unhandled exception&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;明确Task和线程的关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务是架构在线程之上的，也就是说任务最终还是要抛给线程去执行&lt;/li&gt;
&lt;li&gt;任务跟线程不是一对一的关系，比如开10个任务并不是说会开10个线程，在.NET面向任务异步编程模型中，你只需要关注业务概念的任务，具备底层实现会由Task包装完成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Task相比ThreadPool的优势:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ThreadPool不支持线程取消、完成、失败通知等交互新操作&lt;/li&gt;
&lt;li&gt;ThreadPool不支持线程执行的先后顺序。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;await/async 语法糖&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在异步编程实践中，将网络、数据库同步访问称为 I/O-bound；将等待CPU计算结果称为CPU-bound&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　TAP异步编程模型的核心是塑造异步操作的Task、Task&amp;lt;T&amp;gt;对象，这是awaitable 对象，await/async语法糖简化了写法&lt;/p&gt;
&lt;p&gt;　　魔法发生在await关键字，会将控制权上交给执行Async方法的上层调用者。&lt;/p&gt;
&lt;p&gt;　　在C#语言底层，编译器将你的await/async 代码转换为状态机， 记录了&lt;strong&gt;当await发生时控制权上交&lt;/strong&gt;和&lt;strong&gt;后台工作完成时恢复执行&lt;/strong&gt;的标记。&lt;/p&gt;

&lt;p&gt;　　异步编程在实践时需要理解：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;异步代码可用于I/O -bound 和CPU-bound 代码， 但是2个场景的写法是不同的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;异步编程利用Task和Task&amp;lt;T&amp;gt;对象来 塑造需要在后台完成的工作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;async关键字将方法转变为异步方法，这样可在方法体使用await关键词， 如果async方法内不包含await关键词，那将不会上交控制权&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当await动作发生时，将会暂停（注意是suspend 而不是block）方法，并将控制权上交给调用者（直到awaitable任务完成）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;await 只能被用在async方法内部&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行操作的“异步方式”&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt; 执行以下操作…&lt;/td&gt;
&lt;td&gt; 替换以下方式…&lt;/td&gt;
&lt;td&gt; 使用以下方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt; 检索后台任务的结果&lt;/td&gt;
&lt;td&gt; Task.Wait / Task.Result&lt;/td&gt;
&lt;td&gt; await&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; 等待任何任务完成&lt;/td&gt;
&lt;td&gt; Task.WaitAny&lt;/td&gt;
&lt;td&gt; await Task.WhenAny&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; 检索多个任务的结果&lt;/td&gt;
&lt;td&gt; Task.WaitAll&lt;/td&gt;
&lt;td&gt; await Task.WhenAll&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 等待一段时间&lt;/td&gt;
&lt;td&gt; Thread.Sleep&lt;/td&gt;
&lt;td&gt; await Task.Delay&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br/&gt;下面是一个I/O-bound的例子:    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Test
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
       {
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; asyncMethod =&lt;span&gt;  AccessTheWebAsync();
         Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;go on ...... &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt; Thread.CurrentThread.ManagedThreadId );
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待异步线程处理完毕,没有以下句子，await使控制回到调用方，主线程即终止。&lt;/span&gt;
&lt;span&gt;         asyncMethod.Wait();
       }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; AccessTheWebAsync()
      {
          HttpClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GetStringAsync returns a Task&amp;lt;string&amp;gt;.
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; That means that when you await the task you'll get a string (urlContents).&lt;/span&gt;
          Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; getStringTask = client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://msdn.microsoft.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; You can do work here that doesn't rely on the string from GetStringAsync.&lt;/span&gt;
&lt;span&gt;         DoIndependentWork();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The await operator suspends AccessTheWebAsync.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - AccessTheWebAsync can't continue until getStringTask is complete.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - Meanwhile, control returns to the caller of AccessTheWebAsync.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - Control resumes here when getStringTask is complete.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - The await operator then retrieves the string result from getStringTask.&lt;/span&gt;
    
         &lt;span&gt;string&lt;/span&gt; urlContents = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; getStringTask;
         Console.WriteLine(urlContents.Length&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;....... &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;Thread.CurrentThread.ManagedThreadId );
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The return statement specifies an integer result.
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Any methods that are awaiting AccessTheWebAsync retrieve the length value.&lt;/span&gt;
         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; urlContents.Length;
       } 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DoIndependentWork()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;work ......&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;Thread.CurrentThread.ManagedThreadId);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201904/587720-20190409184608946-1138610121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上代码在ASP.NET 或GUI程序可能会发生死锁， 具体参见《.NET异步编程系列3：掌握SynchronizationContext避免deadlock》；控制台程序经过验证在.NET Core 和.Net Framework上都没有SynchronizationContext，故不会发生死锁。&lt;/p&gt;
&lt;p&gt;Task对象提供了丰富的API帮助我们完成 基于任务的异步操作， 让我们专注&lt;strong&gt;业务概念的任务&lt;/strong&gt;。&lt;/p&gt;

&lt;div id=&quot;MySignature&quot;&gt;
&lt;div readability=&quot;8.2598870056497&quot;&gt;

&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;感谢您的认真阅读，如有问题请大胆斧正，如果您觉得本文对你有用，不妨右下角点个&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201902/587720-20190214132632297-2118004512.png&quot; alt=&quot;&quot;/&gt;或加关注。&lt;/p&gt;
&lt;p&gt;本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置注明本文的&lt;strong&gt;作者及原文链接&lt;/strong&gt;，否则保留追究法律责任的权利。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Wed, 10 Apr 2019 10:19:00 +0000</pubDate>
<dc:creator>Julian_酱</dc:creator>
<og:description>前导 Asynchronous programming Model（APM）异步编程模型以BeginMethod(...) 和 EndMethod(...)结对出现。 IAsyncResult Beg</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mi12205599/p/10678887.html</dc:identifier>
</item>
</channel>
</rss>