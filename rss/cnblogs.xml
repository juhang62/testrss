<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小白学 Python（24）：Excel 基础操作（下） - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11886983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11886983.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191119084332084-1078984866.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我选Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/12/2870915863/&quot;&gt;小白学 Python（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/13/2870915864/&quot;&gt;小白学 Python（2）：基础数据类型（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/15/25090937/&quot;&gt;小白学 Python（3）：基础数据类型（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/17/2392286754/&quot;&gt;小白学 Python（4）：变量基础操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/18/999362065/&quot;&gt;小白学 Python（5）：基础运算符（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/20/2416267271/&quot;&gt;小白学 Python（6）：基础运算符（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/22/979409150/&quot;&gt;小白学 Python（7）：基础流程控制（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/2184234984/&quot;&gt;小白学 Python（8）：基础流程控制（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/3066758654/&quot;&gt;小白学 Python（9）：基础数据结构（列表）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/25/1277177083/&quot;&gt;小白学 Python（10）：基础数据结构（列表）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/26/1783681326/&quot;&gt;小白学 Python（11）：基础数据结构（元组）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/1304658395/&quot;&gt;小白学 Python（12）：基础数据结构（字典）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/2327215405/&quot;&gt;小白学 Python（13）：基础数据结构（字典）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/29/2327215406/&quot;&gt;小白学 Python（14）：基础数据结构（集合）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/30/3105860436/&quot;&gt;小白学 Python（15）：基础数据结构（集合）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/31/3818474124/&quot;&gt;小白学 Python（16）：基础数据类型（函数）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/01/619492986/&quot;&gt;小白学 Python（17）：基础数据类型（函数）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/01/3195979051/&quot;&gt;小白学 Python（18）：基础文件操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/01/3195979051/&quot;&gt;小白学 Python（18）：基础文件操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/03/271169345/&quot;&gt;小白学 Python（19）：基础异常处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/05/1111962512/&quot;&gt;小白学 Python（20）：迭代器基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/06/988349733/&quot;&gt;小白学 Python（21）：生成器基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/07/908307735/&quot;&gt;小白学 Python（22）：time 和 calendar 模块简单使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/07/3507147382/&quot;&gt;小白学 Python（23）：Excel 基础操作（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这里首先恭喜各位看到本篇连载的同学，本篇连载为 《小白学 Python 基础系列》 最后一篇，恭喜各位在学习 Python 的道路上迈出了坚实的一大步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191119084332783-167627100.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写入-excel&quot;&gt;写入 Excel&lt;/h2&gt;
&lt;p&gt;首先当然是安装第三方模块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install openpyxl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们需要先创建一个 WorkBook ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import xlsxwriter

workbook = xlsxwriter.Workbook('demo.xlsx')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在所有操作之前，需要记得先导入我们刚才安装的 &lt;code&gt;xlsxwriter&lt;/code&gt; 的模块。&lt;/p&gt;
&lt;p&gt;接下来，我们创建一个 Sheet ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sheet1 = workbook.add_worksheet('test_sheet')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建完成后，需要关闭 workbook ，这一步会将我们刚才创建的 workbook 进行保存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;workbook.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，我们已经创建好了一个 excel ，操作结束，下课。&lt;/p&gt;
&lt;p&gt;老师，你回来，这就完了？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191119084333066-1912392377.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们接着介绍如何将数据写入至 Excel 中。&lt;/p&gt;
&lt;p&gt;首先我们可以先设置一些的单元格的格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;workfomat = workbook.add_format()
# 字体加粗
workfomat.set_bold(True)
# 单元格边框宽度
workfomat.set_border(1)
# 对齐方式
workfomat.set_align('left')
# 格式化数据格式为小数点后两位
workfomat.set_num_format('0.00')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们将内容写入，具体内容小编懒得想了，直接复制上一篇文章中的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;heads = ['', '语文', '数学', '英语']
datas = [
    ['小明', 76, 85, 95],
    ['小红', 85, 58, 92],
    ['小王', 98, 96, 91]
]

sheet1.write_row('A1', heads, workfomat)

sheet1.write_row('A2', datas[0], workfomat)
sheet1.write_row('A3', datas[1], workfomat)
sheet1.write_row('A4', datas[2], workfomat)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行程序，我们来看下最终输出的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191119084333362-1268360778.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了可以这样输出以外，我们还可以指定输出的单元格格式：&lt;/p&gt;
&lt;p&gt;我们列举一个比较复杂的输出日期类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fomat1 = workbook.add_format({'num_format': 'yy/mm/dd/ hh:mm:ss'})

sheet1.write_datetime('E5', datetime.datetime(2019, 11, 9, 22, 44, 26), fomat1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 上面的格式化一定要加，否则在 Excel 中显示出来的只会是一个时间戳。&lt;/p&gt;
&lt;p&gt;其他的输出类型小编这里就不一一举例了，下面列出一些常用的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 字符串类型
sheet1.write_string()
# 数字型
sheet1.wirte_number()
# 空类型
sheet1.write_blank()
# 公式
sheet1.write_formula()
# 布尔型
sheet1.write_boolean()
# 超链接
sheet1.write_url()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以在 Excel 中插入图片，样例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sheet1.insert_image('I6', 'wx.jpg')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert_image(row, col, image[, options])

row：行坐标，起始索引值为0；
col：列坐标，起始索引值为0；
image：string类型，是图片路径；
options：dict类型，是可选参数，用于指定图片位置，如URL等信息；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以在 Excel 中绘图，支持包括面积、条形图、柱状图、折线图、散点图等。&lt;/p&gt;
&lt;p&gt;图表对象是通过 &lt;code&gt;Workbook add_chart()&lt;/code&gt; 方法创建的，其中指定了图表类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chart = workbook.add_chart({'type': 'column'})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见的图表样式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;area：面积样式的图表
bar：条形图
column：柱状图
line：线条样式的图表
pie：饼形图
scatter：散点图
stock：股票样式的图表
radar：雷达样式的图表&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用 &lt;code&gt;insert_chart()&lt;/code&gt; Worksheet方法将其作为嵌入的图表插入到工作表中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sheet1.insert_chart('A7', chart)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chart = workbook.add_chart({'type': 'column'})

chart.add_series({'values': '=test_sheet!$B$2:$B$4'})
chart.add_series({'values': '=test_sheet!$C$2:$C$4'})
chart.add_series({'values': '=test_sheet!$D$2:$D$4'})

sheet1.insert_chart('A7', chart)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191119084334136-1312757554.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一些常用的简单的操作就介绍到这里，想了解更多的同学可以访问官方文档，链接小编已经找出来了：&lt;a href=&quot;https://xlsxwriter.readthedocs.io/&quot; class=&quot;uri&quot;&gt;https://xlsxwriter.readthedocs.io/&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/base-excel&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/base-excel&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Nov 2019 00:44:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我选Python 前文传送门 '小白学 Python（1）：开篇' '小白学 Python（2）：基础数据类型（上）' '小白学 Python（3）：基础数据类型（下）' '小白学 Pyth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11886983.html</dc:identifier>
</item>
<item>
<title>Python 命令行之旅：深入 click 之选项篇 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11882154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11882154.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201911/759200-20191104220305180-1564290170.jpg&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;br/&gt;作者：HelloGitHub-&lt;strong&gt;Prodesire&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 的《讲解开源项目》系列，项目地址：https://github.com/HelloGitHub-Team/Article&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;在上一篇文章中，我们介绍了 &lt;code&gt;click&lt;/code&gt; 中的“参数”，本文将继续深入了解 &lt;code&gt;click&lt;/code&gt;，着重讲解它的“选项”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;本系列文章默认使用 Python 3 作为解释器进行讲解。
若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二选项&quot;&gt;二、选项&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;click.option&lt;/code&gt; 可以给命令增加选项，并通过配置函数的参数来配置不同功能的选项。&lt;/p&gt;
&lt;h3 id=&quot;给选项命名&quot;&gt;2.1 给选项命名&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;click.option&lt;/code&gt; 中的命令规则可参考&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/parameters/#parameter-names&quot;&gt;参数名称&lt;/a&gt;。它接受的前两个参数为长、短选项（顺序随意），其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;长选项以 “--” 开头，比如 “--string-to-echo”&lt;/li&gt;
&lt;li&gt;短选项以 “-” 开头，比如 “-s”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第三个参数为选项参数的名称，如果不指定，将会使用长选项的下划线形式名称：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('-s', '--string-to-echo')
def echo(string_to_echo):
    click.echo(string_to_echo)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示指定为 string&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('-s', '--string-to-echo', 'string')
def echo(string):
    click.echo(string)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基本值选项&quot;&gt;2.2 基本值选项&lt;/h3&gt;
&lt;p&gt;值选项是非常常用的选项，它接受一个值。如果在命令行中提供了值选项，则需要提供对应的值；反之则使用默认值。若没在 &lt;code&gt;click.option&lt;/code&gt; 中指定默认值，则默认值为 &lt;code&gt;None&lt;/code&gt;，且该选项的类型为 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.STRING&quot;&gt;STRING&lt;/a&gt;；反之，则选项类型为默认值的类型。&lt;/p&gt;
&lt;p&gt;比如，提供默认值为 1，则选项类型为 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.INT&quot;&gt;INT&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--n', default=1)
def dots(n):
    click.echo('.' * n)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要求选项为必填，则可指定 &lt;code&gt;click.option&lt;/code&gt; 的 &lt;code&gt;required=True&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--n', required=True, type=int)
def dots(n):
    click.echo('.' * n)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果选项名称和 Python 中的关键字冲突，则可以显式的指定选项名称。比如将 &lt;code&gt;--from&lt;/code&gt; 的名称设置为 &lt;code&gt;from_&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--from', '-f', 'from_')
@click.option('--to', '-t')
def reserved_param_name(from_, to):
    click.echo(f'from {from_} to {to}')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要在帮助中显式默认值，则可指定 &lt;code&gt;click.option&lt;/code&gt; 的 &lt;code&gt;show_default=True&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--n', default=1, show_default=True)
def dots(n):
    click.echo('.' * n)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ dots --help
Usage: dots [OPTIONS]

Options:
  --n INTEGER  [default: 1]
  --help       Show this message and exit.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多值选项&quot;&gt;2.3 多值选项&lt;/h3&gt;
&lt;p&gt;有时，我们会希望命令行中一个选项能接收多个值，通过指定 &lt;code&gt;click.option&lt;/code&gt; 中的 &lt;code&gt;nargs&lt;/code&gt; 参数（必须是大于等于 0）。这样，接收的多值选项就会变成一个元组。&lt;/p&gt;
&lt;p&gt;比如，在下面的示例中，当通过 &lt;code&gt;--pos&lt;/code&gt; 指定多个值时，&lt;code&gt;pos&lt;/code&gt; 变量就是一个元组，里面的每个元素是一个 &lt;code&gt;float&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--pos', nargs=2, type=float)
def findme(pos):
    click.echo(pos)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ findme --pos 2.0 3.0
(1.0, 2.0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有时，通过同一选项指定的多个值得类型可能不同，这个时候可以指定 &lt;code&gt;click.option&lt;/code&gt; 中的 &lt;code&gt;type=(类型1, 类型2, ...)&lt;/code&gt; 来实现。而由于元组的长度同时表示了值的数量，所以就无须指定 &lt;code&gt;nargs&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--item', type=(str, int))
def putitem(item):
    click.echo('name=%s id=%d' % item)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ putitem --item peter 1338
name=peter id=1338&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多选项&quot;&gt;2.4 多选项&lt;/h3&gt;
&lt;p&gt;不同于多值选项是通过一个选项指定多个值，多选项则是使用多个相同选项分别指定值，通过 &lt;code&gt;click.option&lt;/code&gt; 中的 &lt;code&gt;multiple=True&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;当我们定义如下多选项：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--message', '-m', multiple=True)
def commit(message):
    click.echo('\n'.join(message))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;便可以指定任意数量个选项来指定值，获取到的 &lt;code&gt;message&lt;/code&gt; 是一个元组：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ commit -m foo -m bar --message baz
foo
bar
baz&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;计值选项&quot;&gt;2.5 计值选项&lt;/h3&gt;
&lt;p&gt;有时我们可能需要获得选项的数量，那么可以指定 &lt;code&gt;click.option&lt;/code&gt; 中的 &lt;code&gt;count=True&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;最常见的使用场景就是指定多个 &lt;code&gt;--verbose&lt;/code&gt; 或 &lt;code&gt;-v&lt;/code&gt; 选项来表示输出内容的详细程度。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('-v', '--verbose', count=True)
def log(verbose):
    click.echo(f'Verbosity: {verbose}')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ log -vvv
Verbosity: 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的例子，&lt;code&gt;verbose&lt;/code&gt; 就是数字，表示 &lt;code&gt;-v&lt;/code&gt; 选项的数量，由此可以进一步使用该值来控制日志的详细程度。&lt;/p&gt;
&lt;h3 id=&quot;布尔选项&quot;&gt;2.6 布尔选项&lt;/h3&gt;
&lt;p&gt;布尔选项用来表示真或假，它有多种实现方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过 &lt;code&gt;click.option&lt;/code&gt; 的 &lt;code&gt;is_flag=True&lt;/code&gt; 参数来实现：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys

@click.command()
@click.option('--shout', is_flag=True)
def info(shout):
    rv = sys.platform
    if shout:
        rv = rv.upper() + '!!!!111'
    click.echo(rv)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ info --shout
LINUX!!!!111&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过在 &lt;code&gt;click.option&lt;/code&gt; 的选项定义中使用 &lt;code&gt;/&lt;/code&gt; 分隔表示真假两个选项来实现：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys

@click.command()
@click.option('--shout/--no-shout', default=False)
def info(shout):
    rv = sys.platform
    if shout:
        rv = rv.upper() + '!!!!111'
    click.echo(rv)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ info --shout
LINUX!!!!111
$ info --no-shout
linux&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Windows 中，一个选项可以以 &lt;code&gt;/&lt;/code&gt; 开头，这样就会真假选项的分隔符冲突了，这个时候可以使用 &lt;code&gt;;&lt;/code&gt; 进行分隔：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('/debug;/no-debug')
def log(debug):
    click.echo(f'debug={debug}')

if __name__ == '__main__':
    log()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 cmd 中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt; log /debug
debug=True&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;特性切换选项&quot;&gt;2.7 特性切换选项&lt;/h3&gt;
&lt;p&gt;所谓特性切换就是切换同一个操作对象的不同特性，比如指定 &lt;code&gt;--upper&lt;/code&gt; 就让输出大写，指定 &lt;code&gt;--lower&lt;/code&gt; 就让输出小写。这么来看，布尔值其实是特性切换的一个特例。&lt;/p&gt;
&lt;p&gt;要实现特性切换选项，需要让多个选项都有相同的参数名称，并且定义它们的标记值 &lt;code&gt;flag_value&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys

@click.command()
@click.option('--upper', 'transformation', flag_value='upper',
              default=True)
@click.option('--lower', 'transformation', flag_value='lower')
def info(transformation):
    click.echo(getattr(sys.platform, transformation)())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ info --upper
LINUX
$ info --lower
linux
$ info
LINUX&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的示例中，&lt;code&gt;--upper&lt;/code&gt; 和 &lt;code&gt;--lower&lt;/code&gt; 都有相同的参数值 &lt;code&gt;transformation&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当指定 &lt;code&gt;--upper&lt;/code&gt; 时，&lt;code&gt;transformation&lt;/code&gt; 就是 &lt;code&gt;--upper&lt;/code&gt; 选项的标记值 &lt;code&gt;upper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当指定 &lt;code&gt;--lower&lt;/code&gt; 时，&lt;code&gt;transformation&lt;/code&gt; 就是 &lt;code&gt;--lower&lt;/code&gt; 选项的标记值 &lt;code&gt;lower&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进而就可以做进一步的业务逻辑处理。&lt;/p&gt;
&lt;h3 id=&quot;选择项选项&quot;&gt;2.8 选择项选项&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;选择项选项&lt;/code&gt; 和 上篇文章中介绍的 &lt;code&gt;选择项参数&lt;/code&gt; 类似，只不过是限定选项内容，依旧是通过 &lt;code&gt;type=click.Choice&lt;/code&gt; 实现。此外，&lt;code&gt;case_sensitive=False&lt;/code&gt; 还可以忽略选项内容的大小写。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--hash-type',
              type=click.Choice(['MD5', 'SHA1'], case_sensitive=False))
def digest(hash_type):
    click.echo(hash_type)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ digest --hash-type=MD5
MD5

$ digest --hash-type=md5
MD5

$ digest --hash-type=foo
Usage: digest [OPTIONS]
Try &quot;digest --help&quot; for help.

Error: Invalid value for &quot;--hash-type&quot;: invalid choice: foo. (choose from MD5, SHA1)

$ digest --help
Usage: digest [OPTIONS]

Options:
  --hash-type [MD5|SHA1]
  --help                  Show this message and exit.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提示选项&quot;&gt;2.9 提示选项&lt;/h3&gt;
&lt;p&gt;顾名思义，当提供了选项却没有提供对应的值时，会提示用户输入值。这种交互式的方式会让命令行变得更加友好。通过指定 &lt;code&gt;click.option&lt;/code&gt; 中的 &lt;code&gt;prompt&lt;/code&gt; 可以实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;code&gt;prompt=True&lt;/code&gt; 时，提示内容为选项的参数名称&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--name', prompt=True)
def hello(name):
    click.echo(f'Hello {name}!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ hello --name=John
Hello John!
$ hello
Name: John
Hello John!&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;code&gt;prompt='Your name please'&lt;/code&gt; 时，提示内容为指定内容&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--name', prompt='Your name please')
def hello(name):
    click.echo(f'Hello {name}!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ hello
Your name please: John
Hello John!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于提示选项，我们还可以指定 &lt;code&gt;hide_input=True&lt;/code&gt; 来隐藏输入，&lt;code&gt;confirmation_prompt=True&lt;/code&gt; 来让用户进行二次输入，这非常适合输入密码的场景。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--password', prompt=True, hide_input=True,
              confirmation_prompt=True)
def encrypt(password):
    click.echo(f'Encrypting password to {password.encode(&quot;rot13&quot;)}')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，也可以直接使用 &lt;code&gt;click.password_option&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.password_option()
def encrypt(password):
    click.echo(f'Encrypting password to {password.encode(&quot;rot13&quot;)}')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以给提示选项设置默认值，通过 &lt;code&gt;default&lt;/code&gt; 参数进行设置，如果被设置为函数，则可以实现动态默认值。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--username', prompt=True,
              default=lambda: os.environ.get('USER', ''))
def hello(username):
    print(&quot;Hello,&quot;, username)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详情请阅读 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/options/#dynamic-defaults-for-prompts&quot;&gt;Dynamic Defaults for Prompts&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;范围选项&quot;&gt;2.10 范围选项&lt;/h3&gt;
&lt;p&gt;如果希望选项的值在某个范围内，就可以使用范围选项，通过指定 &lt;code&gt;type=click.IntRange&lt;/code&gt; 来实现。它有两种模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认模式（非强制模式），如果值不在区间范围内将会引发一个错误。如 &lt;code&gt;type=click.IntRange(0, 10)&lt;/code&gt; 表示范围是 [0, 10]，超过该范围报错&lt;/li&gt;
&lt;li&gt;强制模式，如果值不在区间范围内，将会强制选取一个区间临近值。如 &lt;code&gt;click.IntRange(0, None, clamp=True)&lt;/code&gt; 表示范围是 [0, +∞)，小于 0 则取 0，大于 20 则取 20。其中 &lt;code&gt;None&lt;/code&gt; 表示没有限制&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.option('--count', type=click.IntRange(0, None, clamp=True))
@click.option('--digit', type=click.IntRange(0, 10))
def repeat(count, digit):
    click.echo(str(digit) * count)

if __name__ == '__main__':
    repeat()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ repeat --count=1000 --digit=5
55555555555555555555
$ repeat --count=1000 --digit=12
Usage: repeat [OPTIONS]

Error: Invalid value for &quot;--digit&quot;: 12 is not in the valid range of 0 to 10.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;回调和优先&quot;&gt;2.11 回调和优先&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;回调&lt;/strong&gt;&lt;br/&gt;通过 &lt;code&gt;click.option&lt;/code&gt; 中的 &lt;code&gt;callback&lt;/code&gt; 可以指定选项的回调，它会在该选项被解析后调用。回调函数的签名如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def callback(ctx, param, value):
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;使用回调函数可以完成额外的参数校验逻辑。比如，通过 --rolls 的选项来指定摇骰子的方式，内容为“{N}d{M}”，表示 M 面的骰子摇 N 次，N 和 M 都是数字。在真正的处理 rolls 前，我们需要通过回调函数来校验它的格式：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def validate_rolls(ctx, param, value):
    try:
        rolls, dice = map(int, value.split('d', 2))
        return (dice, rolls)
    except ValueError:
        raise click.BadParameter('rolls need to be in format NdM')

@click.command()
@click.option('--rolls', callback=validate_rolls, default='1d6')
def roll(rolls):
    click.echo('Rolling a %d-sided dice %d time(s)' % rolls)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，当我们输入错误格式时，变会校验不通过：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ roll --rolls=42
Usage: roll [OPTIONS]

Error: Invalid value for &quot;--rolls&quot;: rolls need to be in format NdM&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入正确格式时，则正常输出信息：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ roll --rolls=2d12
Rolling a 12-sided dice 2 time(s)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优先&lt;/strong&gt;&lt;br/&gt;通过 &lt;code&gt;click.option&lt;/code&gt; 中的 &lt;code&gt;is_eager&lt;/code&gt; 可以让该选项成为优先选项，这意味着它会先于所有选项处理。&lt;/p&gt;
&lt;p&gt;利用回调和优先选项，我们就可以很好地实现 &lt;code&gt;--version&lt;/code&gt; 选项。不论命令行中写了多少选项和参数，只要包含了 &lt;code&gt;--version&lt;/code&gt;，我们就希望它打印版本就退出，而不执行其他选项的逻辑，那么就需要让它成为优先选项，并且在回调函数中打印版本。&lt;/p&gt;
&lt;p&gt;此外，在 &lt;code&gt;click&lt;/code&gt; 中每个选项都对应到命令处理函数的同名参数，如果不想把该选项传递到处理函数中，则需要指定 &lt;code&gt;expose_value=True&lt;/code&gt;，于是有：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def print_version(ctx, param, value):
    if not value or ctx.resilient_parsing:
        return
    click.echo('Version 1.0')
    ctx.exit()

@click.command()
@click.option('--version', is_flag=True, callback=print_version,
              expose_value=False, is_eager=True)
def hello():
    click.echo('Hello World!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然 &lt;code&gt;click&lt;/code&gt; 提供了便捷的 &lt;code&gt;click.version_option&lt;/code&gt; 来实现 &lt;code&gt;--version&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.version_option(version='0.1.0')
def hello():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;yes-选项&quot;&gt;2.12 Yes 选项&lt;/h3&gt;
&lt;p&gt;基于前面的学习，我们可以实现 Yes 选项，也就是对于某些操作，不提供 &lt;code&gt;--yes&lt;/code&gt; 则进行二次确认，提供了则直接操作：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def abort_if_false(ctx, param, value):
    if not value:
        ctx.abort()

@click.command()
@click.option('--yes', is_flag=True, callback=abort_if_false,
              expose_value=False,
              prompt='Are you sure you want to drop the db?')
def dropdb():
    click.echo('Dropped all tables!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然 &lt;code&gt;click&lt;/code&gt; 提供了便捷的 &lt;code&gt;click.confirmation_option&lt;/code&gt; 来实现 Yes 选项：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@click.command()
@click.confirmation_option(prompt='Are you sure you want to drop the db?')
def dropdb():
    click.echo('Dropped all tables!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中调用则有：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ dropdb
Are you sure you want to drop the db? [y/N]: n
Aborted!
$ dropdb --yes
Dropped all tables!&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其他增强功能&quot;&gt;2.11 其他增强功能&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;click&lt;/code&gt; 支持从环境中读取选项的值，这是 &lt;code&gt;argparse&lt;/code&gt; 所不支持的，可参阅官方文档的 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/options/#values-from-environment-variables&quot;&gt;Values from Environment Variables&lt;/a&gt; 和 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/options/#multiple-values-from-environment-values&quot;&gt;Multiple Values from Environment Values&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;click&lt;/code&gt; 支持指定选项前缀，你可以不使用 &lt;code&gt;-&lt;/code&gt; 作为选项前缀，还可使用 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;/&lt;/code&gt;，当然在一般情况下并不建议这么做。详情参阅官方文档的 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/options/#other-prefix-characters&quot;&gt;Other Prefix Characters&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;可以看出，&lt;code&gt;click&lt;/code&gt; 对命令行选项的支持非常丰富和强大，除了支持 &lt;code&gt;argarse&lt;/code&gt; 所支持的所有选项类型外，还提供了诸如 &lt;code&gt;计值选项&lt;/code&gt;、&lt;code&gt;特性切换选项&lt;/code&gt;、&lt;code&gt;提示选项&lt;/code&gt; 等更丰富的选项类型。此外，还提供了从环境中读变量等方便易用的增强功能。简直就是开发命令行程序的利器。&lt;/p&gt;
&lt;p&gt;在下篇文章中，我们着重介绍下 &lt;code&gt;click&lt;/code&gt; 的命令和组，这可是实现它的重要特性（任意嵌套命令）的方式。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;『讲解开源项目系列』&lt;/strong&gt;——让对开源项目感兴趣的人不再畏惧、让开源项目的发起者不再孤单。跟着我们的文章，你会发现编程的乐趣、使用和发现参与开源项目如此简单。欢迎留言联系我们、加入我们，让更多人爱上开源、贡献开源～&lt;/p&gt;
</description>
<pubDate>Tue, 19 Nov 2019 00:44:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub Prodesire HelloGitHub 的《讲解开源项目》系列，项目地址：https://github.com/HelloGitHub Team/Article 一、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11882154.html</dc:identifier>
</item>
<item>
<title>CMDB连接方式 - 追梦NAN</title>
<link>http://www.cnblogs.com/zdqc/p/11886984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zdqc/p/11886984.html</guid>
<description>&lt;h2 id=&quot;agent&quot;&gt;1.agent&lt;/h2&gt;
&lt;p&gt;agent （放在每台客户端服务器上，定时任务） 脚本演示&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 采集本机的信息  执行命令
import subprocess

v1 = subprocess.getoutput('ipconfig')
v1 = v1[20:30]
#print(v1)

v2 = subprocess.getoutput('dir')
v2 = v2[2:12]
#print(v2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;paramikossh&quot;&gt;2.paramiko(SSH)&lt;/h2&gt;
&lt;p&gt;pip install paramiko&lt;/p&gt;
&lt;p&gt;连接服务器&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import paramiko

private_key = paramiko.RSAKey.from_private_key_file(r'C:/Users/Administrator/.ssh/id_rsa')

# 创建SSH对象
ssh = paramiko.SSHClient()
# 允许连接不在know_hosts文件中的主机
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
# 连接服务器 #password密码  #pkey密钥
ssh.connect(hostname='192.168.16.85', port=22, username='root', pkey=private_key) 

# 执行命令
stdin, stdout, stderr = ssh.exec_command('df')
# 获取命令结果
result = stdout.read()
print(result.decode('utf-8'))
# 关闭连接
ssh.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;远程执行命令【公钥和私钥】(公钥必须提前上传到服务器)&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import paramiko
#密钥
private_key = paramiko.RSAKey.from_private_key_file(r'C:/Users/Administrator/.ssh/id_rsa')

transport = paramiko.Transport(('192.168.16.85', 22))
transport.connect(username='root', password='123456') #pkey=private_key
sftp = paramiko.SFTPClient.from_transport(transport)


# 将location.py 上传至服务器 /tmp/test.py
# sftp.put('wy.txt', '/data/wy.txt')
sftp.get('/data/wy.txt', 'xx.txt')

transport.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者将密钥写入文件&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;key = &quot;&quot;&quot;-----BEGIN RSA PRIVATE KEY-----&quot;&quot;&quot;

import paramiko
from io import StringIO

private_key = paramiko.RSAKey(file_obj=StringIO(key))

# 创建SSH对象
ssh = paramiko.SSHClient()
# 允许连接不在know_hosts文件中的主机
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
# 连接服务器
ssh.connect(hostname='192.168.16.85', port=22, username='root', pkey=private_key)

# 执行命令
stdin, stdout, stderr = ssh.exec_command('df')
# 获取命令结果
result = stdout.read()
print(result.decode('utf-8'))
# 关闭连接
ssh.close()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分发密钥命令&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;ssh-copy-id -i ~.ssh/id_rsa.pub root@192.168.16.85 &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;salt&quot;&gt;3.salt&lt;/h2&gt;
&lt;p&gt;master&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo yum install https://repo.saltstack.com/py3/redhat/salt-py3-repo-latest.el7.noarch.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;yum install salt-master -y 

配置：

/etc/salt/master  

interface: 0.0.0.0

启动： service salt-master start 

授权：

    salt-key -L  查看

    salt-key -a   id  接受某一个 

    salt-key -A   接受所有

    salt-key -d  id   删除某一个&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;minion&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo yum install https://repo.saltstack.com/py3/redhat/salt-py3-repo-latest.el7.noarch.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;yum install salt-minion -y 

配置：/etc/salt/minion

master: 192.168.16.37

启动： service salt-minion start &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;命令行：&lt;/p&gt;
&lt;p&gt;服务端指定某个服务器执行命令&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;salt '*'  cmd.run 'ifconfig'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;python接口：&lt;/p&gt;
&lt;p&gt;pip3 install salt -i https://pypi.tuna.tsinghua.edu.cn/simple&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#pycharm 中要安装salt
import salt.client
local = salt.client.LocalClient()
result = local.cmd('c2.salt.com', 'cmd.run', ['ifconfig'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据交互&quot;&gt;4.数据交互&lt;/h2&gt;
&lt;p&gt;发送数据&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import   requests

requests.post(
    url='http://127.0.0.1:8000/api/v1/server/',
    json={&quot;server&quot;:&quot;47.93.255.102&quot;,&quot;data&quot;:data}
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;api (django程序)&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
from django.shortcuts import render,HttpResponse

def index(request):
    if request.method == &quot;POST&quot;:
        print(request.POST)
        return HttpResponse(&quot;接受到了&quot;)

    else:
        return HttpResponse(&quot;index&quot;)
&quot;&quot;&quot;

    
from rest_framework.views import APIView
from rest_framework.response import Response
class ServerViews(APIView):
    def post(self,request,*args,**kwargs):
        print(request.data)
        return  Response('1')&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 19 Nov 2019 00:44:00 +0000</pubDate>
<dc:creator>追梦NAN</dc:creator>
<og:description>1.agent agent （放在每台客户端服务器上，定时任务） 脚本演示 2.paramiko(SSH) pip install paramiko 连接服务器 远程执行命令【公钥和私钥】(公钥必须提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zdqc/p/11886984.html</dc:identifier>
</item>
<item>
<title>redhat、centos7系列破解密码 - southtianmen</title>
<link>http://www.cnblogs.com/southtianmen/p/11886970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/southtianmen/p/11886970.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;redhat或者centos7，破解密码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1、开机出现引导菜单时按下e键&lt;/p&gt;
&lt;p&gt;2、找到linux16行，在其后追加 rd.break 参数 console=tty0&lt;/p&gt;

&lt;p&gt;3、启动到特定的模式，由于更改密码需要用到/sysroot这个分区中的数据，而这个分区默认情况下是只读的，所以需要对它进行重新挂载，并赋予rw权限：&lt;/p&gt;
&lt;p&gt;1) mount -o remount,rw /sysroot&lt;/p&gt;
&lt;p&gt;2) chroot /sysroot&lt;/p&gt;
&lt;p&gt;3) echo &quot;123456&quot; | passwd --stdin root&lt;/p&gt;
&lt;p&gt;4) touch /.autorelabel（若Selinux已经禁用则无须执行这一步）&lt;/p&gt;
&lt;p&gt;5) exit centos7进入单用户模式 需要修改开机自启文件 /etc/rc.d/rc.local，不想让脚本执行 1.开机出现引导菜单时按下e键 2.修改r/o为r/w（以linuxefi或linux16开头的那行），否则shell中只读无操作权限 3.找到linux16行，删除rhgb quiet参数，在本行末尾添加init = /bin/sh&lt;/p&gt;
&lt;p&gt;4.按下ctrl+x重启系统，此时应进入sh界面&lt;/p&gt;
</description>
<pubDate>Tue, 19 Nov 2019 00:41:00 +0000</pubDate>
<dc:creator>southtianmen</dc:creator>
<og:description>redhat或者centos7，破解密码： 1、开机出现引导菜单时按下e键 2、找到linux16行，在其后追加 rd.break 参数 console=tty0 3、启动到特定的模式，由于更改密码需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/southtianmen/p/11886970.html</dc:identifier>
</item>
<item>
<title>第 1 份工作，我只干了 2 周就被辞退了 | 十年系列 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/11886899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/11886899.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;1.写在前面&lt;/h2&gt;
&lt;p&gt;我将用系列文章，回顾十年程序生涯，一方面是对职场生涯的阶段性总结，另一方面希望这些经历，对读者往后职场生涯有所启发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一只站在树上的鸟儿，从来不会害怕树枝断裂，因为它相信的不是树枝，而是它自己的翅膀。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;十年系列文章：&lt;/p&gt;
&lt;h2 id=&quot;我的第一份工作&quot;&gt;2.我的第一份工作&lt;/h2&gt;
&lt;p&gt;毕业后很多年，我都不好意思和别人提起这件事，第一份工作只上了 2 周班就被辞退了！这是我第一次被人主动辞退，当然也是我职场上的最后一次。&lt;/p&gt;
&lt;p&gt;今天回想起来，如果当初没有被这家公司辞退，我还能成为今天的我吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人生有时候就是这么神奇。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到底是怎么回事，我给大家详细讲讲。&lt;/p&gt;
&lt;p&gt;上篇文章&lt;a href=&quot;http://www.ityouknow.com/life/2019/10/31/training-10year.html&quot;&gt;《我的培训机构经历》&lt;/a&gt;&lt;br/&gt;中讲到，从培训机构培训完后我找到了一份满意的工作，也是我从校园出来的第一份工作，我们一个培训班进了5个人，所以大家租房上班都在一起，每天高高兴兴的上班下班，我对工作也充满了信心和期待。&lt;/p&gt;
&lt;p&gt;这个香港来的电信公司还不错，五险一金和其它福利在西安同等公司里面算好的，最最重要的是这家公司还会给每个入职的同事做一个月的免费培训，主要的培训内容就是 Oracle 和 Linux 相关知识。&lt;/p&gt;
&lt;h2 id=&quot;入职培训&quot;&gt;3.入职培训&lt;/h2&gt;
&lt;p&gt;我们那一期总共有18个人入职一起培训，培训的地点就在西安软件园的地下一层，每次早上都是老师先在前面给大家培训 Sql 的使用，然后再给大家出几道练习题实践。&lt;/p&gt;
&lt;p&gt;那个时候刚从学校的氛围里面出来，完全不知道职场是怎么回事。我旁边坐的小伙伴也是和我一样从培训班出来的，他就非常的聪明，每次实践自己做出来之后，就会主动的喊老师过来看一下他的运行结果。&lt;/p&gt;
&lt;p&gt;反观我这边，有些简单的或者复杂的实践题，有的我做出来了有的没有做出来，做出来之后也不好意思找老师去看，就默默的坐在工位上，整个人感觉都是木木的，缺乏表现。&lt;/p&gt;
&lt;p&gt;前排经常有一些同事，只是解出了其中的一些步骤，都会主动的喊老师过来检查，这样在老师的帮助下也很快的完成了，多次交流和老师也熟悉了一点。&lt;/p&gt;
&lt;p&gt;我自己有时候搞不定，请求隔壁小伙伴的时候，他很聪明直接把电脑屏幕转个90度，让老师看到，感觉我就像是抄他的一样，其实也确实是抄。&lt;/p&gt;
&lt;p&gt;而有时候我解出来程序，他没有做出来的时候，就参考我的内容完成，然后再举手让老师看他解决了出来，我坐在里面也没有给老师反馈，老师可能也觉得我没有做出来，就这样过去了。&lt;/p&gt;
&lt;h2 id=&quot;被辞退&quot;&gt;4.被辞退&lt;/h2&gt;
&lt;p&gt;两个星期之后，老师宣布要从18个人里面淘汰掉 2 个同事，其中就有我。&lt;/p&gt;
&lt;p&gt;现在回想起来如果我是那位培训的老师，我可能也会选择淘汰掉当时的我，入职之后完全没有转变过来学生的身份，仍然像上大学一样，坐在最后一排默默的干自己的事情。&lt;/p&gt;
&lt;p&gt;现在反思当时的自己，应该有以下几个问题：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;① 不积极不主动，这不是学校，这是人家给你钱上班，需要给公司解决问题的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;② 缺乏即时反馈，当你的工作做完之后就应该需要让你的领导知道。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;③ 工作状态不对，没有尽全力去学习工作，试用期正是考验员工的时候呀。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;④ 技术能力不行，刚从培训班出来技术很菜，自己却不知道。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;⑤ 心态转变太差，还是学生时代的心态，没有融入到职场。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;⑥ 精神面貌不对，在职场不说穿得多好多正式，至少要精神一点，自己当时穿衣确实不像上班的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于以上各种我认为的原因，我被开除了！&lt;/p&gt;
&lt;p&gt;那次培训18个人，2个人被辞退，当我把这个信息告诉我姐的时候，我姐说关键人家就只淘汰了2个人，其中就有你，我无言以对。&lt;/p&gt;
&lt;h2 id=&quot;又开始重新找工作&quot;&gt;5.又开始重新找工作&lt;/h2&gt;
&lt;p&gt;从培训班毕业后身上就没有多少钱了，入职第一家公司的时候，培训班的几个同学都说第一笔工资怎么怎么花，有的说要请一家人吃饭，有的说要给女朋友送个礼物，有的说要犒劳一下自己。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我当时什么话也没说，因为我的钱谁也给不了，我要留着吃饭交房租。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被辞退后，我就开始一个人在网上疯狂的投起简历来，当时对 IT 行业理解也不深，并不知道什么是互联网公司，什么是传统软件公司，什么是外包公司，但凡只要招聘 Java 工程师的我都投递了简历。&lt;/p&gt;
&lt;p&gt;就这样陆陆续续的收到了几家公司的面试邀请，我这里印象比较深刻的有三家公司，因为就这三家公司给了我 Offer。&lt;/p&gt;
&lt;p&gt;第一家公司是个小老板，给 2000 的工资但不给交社保，公司一共也就十几个人，其中只有5、6个程序员，老板本身也是程序员出身，主要业务是给别的公司做项目。&lt;/p&gt;
&lt;p&gt;第二家公司是深圳易思博，当时华为、中兴纷纷在西安创建了研发基地，国内比较著名的外包公司也都纷纷跟了过来，易思博也是当时的外包公司之一。&lt;/p&gt;
&lt;p&gt;当时大部分外包都是人力外包，就是别的公司招聘你，你直接去甲方公司上班，但是是乙方公司给你发工资的，当时去华为做人力外包也是需要华为的人来面试的。&lt;/p&gt;
&lt;p&gt;第三家公司是一家电信公司，具体是负责中国电信旗下的一个项目，面试官年纪比较大当时和我聊得很不错，现在还记得他当时主要问我关于 IO 的几个问题，有些没有回答好，在他的提示下也都给出了答案。&lt;/p&gt;
&lt;p&gt;在这家公司面试的时候非常舒服，就像和一位老大哥在探讨技术一样，就算回答不出来的问题，他也会帮忙给与解释，让我学习到了很多。&lt;/p&gt;
&lt;h2 id=&quot;新的选择&quot;&gt;6.新的选择&lt;/h2&gt;
&lt;p&gt;用了差不多两周的时间，我又重新收获了 3 份 Offer，其实毕业以来我的面试通过率一般都挺高的，我都觉得自己挺擅长面试的，工资从 1800-2100 差别不是很大。&lt;/p&gt;
&lt;p&gt;当时给我姐打了很多电话，让她帮忙给我参考，但她其实也不太懂这个行业，只是说应该大公司的更保险一点吧。&lt;/p&gt;
&lt;p&gt;最终我纠结了3天，选择了其中一家工资最高的公司，没想到这又跳入了另外一个坑里面。具体是掉进什么样的坑里面，下篇再和大家细聊。&lt;/p&gt;
&lt;h2 id=&quot;毕业生如何选择-offer&quot;&gt;7.毕业生如何选择 Offer&lt;/h2&gt;
&lt;p&gt;还是想和刚毕业的朋友聊两句，第一份工作对我们的选择来讲很重要，很有可能决定了你未来职场的发展方向，所以职场选择的时候我给大家提供几个建议：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第一：优先选择大的互联网公司，也就是我们所说的大厂，大厂有比较完整的培训体系和成长环境，可以学到中国甚至世界级的系统设计；另外工作两三年后有大厂经历，再次出来面试会有加分。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第二：选有潜力的独角兽公司，比如当初的头条或者美团都是非常好的选择，这类公司的发展非常迅速，个人可以跟随着公司的快速发展一起成长，早期还可以拿到比较多的期权，有可能选择好一家公司就可以实现财富自由。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第三：选择传统软件公司，比如：神州数码、中兴、华为、用友软件等公司，传统软件公司的技术栈往往相对保守，这是公司的产品性质决定，同时发展速度有限，这些年有些传统软件公司也迭代很快，这里只说大部分传统软件公司。华为在这些传统软件公司中比较特殊一点，我有几个朋友也在华为呆了很多年，华为确实给的钱很多，同时工作压力也非常大，所以需要个人来结合自己情况来选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第四：谨慎选择小的创业公司，创业公司的死亡率非常高，很多公司到后面都出现了拖欠工资等现象，公司情况完全依赖于老板的情怀。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后希望大家避免我的经历，积极、认真、主动的对待人生第一份工作，迎接好走向社会的第一步，希望读者们都能找到自己的理想生活。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Nov 2019 00:23:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<og:description>1.写在前面 我将用系列文章，回顾十年程序生涯，一方面是对职场生涯的阶段性总结，另一方面希望这些经历，对读者往后职场生涯有所启发。 一只站在树上的鸟儿，从来不会害怕树枝断裂，因为它相信的不是树枝，而是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ityouknow/p/11886899.html</dc:identifier>
</item>
<item>
<title>结合参数接收响应转换原理讲解SpringBoot常用注解 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11886850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11886850.html</guid>
<description>&lt;h2 id=&quot;一常用注解回顾&quot;&gt;一、常用注解回顾&lt;/h2&gt;
&lt;h3 id=&quot;requestbody与responsebody&quot;&gt;1.1 @RequestBody与@ResponseBody&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;
//注意并不要求@RequestBody与@ResponseBody成对使用。
public @ResponseBody  AjaxResponse saveArticle(@RequestBody ArticleVO article)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@RequestBody修饰请求参数，注解用于接收HTTP的body，默认是使用JSON的格式&lt;/li&gt;
&lt;li&gt;@ResponseBody修饰返回值，注解用于在HTTP的body中携带响应数据，默认是使用JSON的格式。如果不加该注解，spring响应字符串类型，是跳转到模板页面或jsp页面的开发模式。说白了：加上这个注解你开发的是一个数据接口，不加这个注解你开发的是一个页面跳转控制器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我们有一个问题：如果我们想接收或XML数据该怎么办？我们想响应excel的数据格式该怎么办？我们后文来回答这个问题。&lt;/p&gt;
&lt;h3 id=&quot;requestmapping注解&quot;&gt;1.2. @RequestMapping注解&lt;/h3&gt;
&lt;p&gt;@RequestMapping注解是所有常用注解中，最有看点的一个注解，用于标注HTTP服务端点。它的很多属性对于丰富我们的应用开发方式方法，都有很重要的作用。如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;value： 应用请求端点，最核心的属性，用于标志请求处理方法的唯一性；&lt;/li&gt;
&lt;li&gt;method： HTTP协议的method类型， 如：GET、POST、PUT、DELETE等；&lt;/li&gt;
&lt;li&gt;consumes： HTTP协议请求内容的数据类型（Content-Type），例如application/json, text/html;&lt;/li&gt;
&lt;li&gt;produces: HTTP协议响应内容的数据类型。下文会详细讲解。&lt;/li&gt;
&lt;li&gt;params： HTTP请求中必须包含某些参数值的时候，才允许被注解标注的方法处理请求。&lt;/li&gt;
&lt;li&gt;headers： HTTP请求中必须包含某些指定的header值，才允许被注解标注的方法处理请求。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
@RequestMapping(value = &quot;/article&quot;, method = POST)
@PostMapping(value = &quot;/article&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中两种写法起到的是一样的效果，也就是PostMapping等同于@RequestMapping的method等于POST。同理：@GetMapping、@PutMapping、@DeleteMapping也都是简写的方式。&lt;/p&gt;
&lt;h3 id=&quot;restcontroller与controller&quot;&gt;1.3. @RestController与@Controller&lt;/h3&gt;
&lt;p&gt;@Controller注解是开发中最常使用的注解，它的作用有两层含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是告诉Spring，被该注解标注的类是一个Spring的Bean，需要被注入到Spring的上下文环境中。&lt;/li&gt;
&lt;li&gt;二是该类里面所有被RequestMapping标注的注解都是HTTP服务端点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;@RestController相当于 @Controller和@ResponseBody结合。它有两层含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是作为Controller的作用，将控制器类注入到Spring上下文环境，该类RequestMapping标注方法为HTTP服务端点。&lt;/li&gt;
&lt;li&gt;二是作为ResponseBody的作用，请求响应默认使用的序列化方式是JSON，而不是跳转到jsp或模板页面。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;pathvariable-与requestparam&quot;&gt;1.4. @PathVariable 与@RequestParam&lt;/h3&gt;
&lt;p&gt;PathVariable用于URI上的{参数}，如下方法用于删除一篇文章，其中id为文章id。如：我们的请求URL为“/article/1”,那么将匹配DeleteMapping并且PathVariable接收参数id=1。而RequestParam用于接收普通表单方式或者ajax模拟表单提交的参数数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@DeleteMapping(&quot;/article/{id}&quot;)
public @ResponseBody AjaxResponse deleteArticle(@PathVariable Long id) {

@PostMapping(&quot;/article&quot;)
public @ResponseBody AjaxResponse deleteArticle(@RequestParam Long id) {&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二接收复杂嵌套对象参数&quot;&gt;二、接收复杂嵌套对象参数&lt;/h2&gt;
&lt;p&gt;有一些朋友可能还无法理解RequestBody注解存在的真正意义，表单数据提交用RequestParam就好了，为什么还要搞出来一个RequestBody注解呢？RequestBody注解的真正意义在于能够使用对象或者嵌套对象接收前端数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191119080954963-666489776.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细看上面的代码，是一个paramData对象里面包含了一个bestFriend对象。这种数据结构使用RequestParam就无法接收了，RequestParam只能接收平面的、一对一的参数。像上文中这种数据结构的参数，就需要我们在java服务端定义两个类，一个类是ParamData，一个类是BestFriend.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ParamData {
    private String name;
    private int id;
    private String phone;
    private BestFriend bestFriend;
    
    public static class BestFriend {
        private String address;
        private String sex;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;注意上面代码中省略了GET、SET方法等必要的java plain model元素。&lt;/li&gt;
&lt;li&gt;注意成员变量名称一定要和JSON属性名称对应上。&lt;/li&gt;
&lt;li&gt;注意接收不同类型的参数，使用不同的成员变量类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完成以上动作，我们就可以使用&lt;code&gt;@RequestBody ParamData paramData&lt;/code&gt;，一次性的接收以上所有的复杂嵌套对象参数了，参数对象的所有属性都将被赋值。&lt;/p&gt;
&lt;h2 id=&quot;三http数据转换的原理&quot;&gt;三、Http数据转换的原理&lt;/h2&gt;
&lt;p&gt;大家现在使用JSON都比较普遍了，其方便易用、表达能力强，是绝大部分数据接口式应用的首选。那么如何响应其他的类型的数据？其中的判别原理又是什么？下面就来给大家介绍一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191119080955233-601428796.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当一个HTTP请求到达时是一个InputStream，通过HttpMessageConverter转换为java对象，从而进行参数接收。&lt;/li&gt;
&lt;li&gt;当对一个HTTP请求进行响应时，我们首先输出的是一个java对象，然后由HttpMessageConverter转换为OutputStream输出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当我们在Spring Boot应用中集成了jackson的类库之后，如下的一些HttpMessageConverter将会被加载。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;22.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;StringHttpMessageConverter&lt;/td&gt;
&lt;td&gt;将请求信息转为字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FormHttpMessageConverter&lt;/td&gt;
&lt;td&gt;将表单数据读取到MultiValueMap中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;XmlAwareFormHttpMessageConverter&lt;/td&gt;
&lt;td&gt;扩展与FormHttpMessageConverter，如果部分表单属性是XML数据，可用该转换器进行读取&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ResourceHttpMessageConverter&lt;/td&gt;
&lt;td&gt;读写org.springframework.core.io.Resource对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;BufferedImageHttpMessageConverter&lt;/td&gt;
&lt;td&gt;读写BufferedImage对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ByteArrayHttpMessageConverter&lt;/td&gt;
&lt;td&gt;读写二进制数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SourceHttpMessageConverter&lt;/td&gt;
&lt;td&gt;读写java.xml.transform.Source类型的对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;MarshallingHttpMessageConverter&lt;/td&gt;
&lt;td&gt;通过Spring的org.springframework,xml.Marshaller和Unmarshaller读写XML消息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Jaxb2RootElementHttpMessageConverter&lt;/td&gt;
&lt;td&gt;通过JAXB2读写XML消息，将请求消息转换为标注的XmlRootElement和XmlType连接的类中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;MappingJacksonHttpMessageConverter&lt;/td&gt;
&lt;td&gt;利用Jackson开源包的ObjectMapper读写JSON数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RssChannelHttpMessageConverter&lt;/td&gt;
&lt;td&gt;读写RSS种子消息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;AtomFeedHttpMessageConverter&lt;/td&gt;
&lt;td&gt;和RssChannelHttpMessageConverter能够读写RSS种子消息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter。当使用RequestBody或ResponseBody时，再结合前端发送的Accept数据类型，会自动判定优先使用MappingJacksonHttpMessageConverter作为数据转换器。但是，不仅JSON可以表达对象数据类型，XML也可以。如果我们希望使用XML格式该怎么告知Spring呢，那就要使用到produces属性了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping(value =&quot;/demo&quot;,produces = MediaType.APPLICATION_XML_VALUE)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们明确的告知了返回的数据类型是xml，就会使用Jaxb2RootElementHttpMessageConverter作为默认的数据转换器。当然实现XML数据响应比JSON还会更复杂一些，还需要结合@XmlRootElement、@XmlElement等注解实体类来使用。同理consumes属性你是不是也会用了呢。&lt;/p&gt;
&lt;h2 id=&quot;四自定义httpmessageconverter&quot;&gt;四、自定义HttpMessageConverter&lt;/h2&gt;
&lt;p&gt;其实绝大多数的数据格式都不需要我们自定义HttpMessageConverter，都有第三方类库可以帮助我们实现(包括下文代码中的Excel格式)。但有的时候，有些数据的输出格式并没有类似于Jackson这种类库帮助我们处理，需要我们自定义数据格式。该怎么做?下面代码只是帮助我们理解的一个例子，不要用于生产：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class TeamToXlsConverter extends AbstractHttpMessageConverter&amp;lt;Team&amp;gt; {

    private static final MediaType EXCEL_TYPE = MediaType.valueOf(&quot;application/vnd.ms-excel&quot;);

    TeamToXlsConverter() {
        super(EXCEL_TYPE);
    }

    @Override
    protected Team readInternal(final Class&amp;lt;? extends Team&amp;gt; clazz, final HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {
        return null;
    }

    @Override
    protected boolean supports(final Class&amp;lt;?&amp;gt; clazz) {
        return (Team.class == clazz);
    }

    @Override
    protected void writeInternal(final Team team, final HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
        try (final Workbook workbook = new HSSFWorkbook()) {
            final Sheet sheet = workbook.createSheet();
            int rowNo = 0;
            for (final TeamMember member : team.getMembers()) {
                final Row row = sheet.createRow(rowNo++);
                row.createCell(0)
                   .setCellValue(member.getName());
            }
            workbook.write(outputMessage.getBody());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.86363636363636&quot;&gt;&lt;li&gt;实现AbstractHttpMessageConverter接口&lt;/li&gt;
&lt;li&gt;指定该转换器是针对哪种数据格式的？如上文代码中的&quot;application/vnd.ms-excel&quot;&lt;/li&gt;
&lt;li&gt;指定该转换器针对那些对象数据类型？如上文代码中的supports函数&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用writeInternal对数据进行输出处理，上例中是输出为Excel格式。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;博主最近新写了一本书：&lt;a href=&quot;http://springboot.zimug.com&quot;&gt;《手摸手教您学习SpringBoot系列-16章97节》&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.82758620689655&quot;&gt;
&lt;p&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 19 Nov 2019 00:10:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、常用注解回顾 1.1 @RequestBody与@ResponseBody 如上代码所示： @RequestBody修饰请求参数，注解用于接收HTTP的body，默认是使用JSON的格式 @Res</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11886850.html</dc:identifier>
</item>
<item>
<title>[springboot 开发单体web shop] 6. 商品分类和轮播广告展示 - IsaacZhang</title>
<link>http://www.cnblogs.com/zhangpan1244/p/11886832.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangpan1244/p/11886832.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;&lt;em&gt;因最近又被困在了OSGI技术POC，更新进度有点慢，希望大家不要怪罪哦。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000020972616&quot;&gt;上节&lt;/a&gt; 我们实现了登录之后前端的展示，如：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191119075805174-531964967.png&quot; alt=&quot;登录展示效果&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191119075806199-1187906692.png&quot; alt=&quot;子分类&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，我们来实现左侧分类栏目的功能。&lt;/p&gt;
&lt;h2 id=&quot;商品分类productcategory&quot;&gt;## 商品分类|ProductCategory&lt;/h2&gt;
&lt;p&gt;从上图我们可以看出，商品的分类其实是有层级关系的，而且这种关系一般都是无限层级。在我们的实现中，为了效果的展示，我们仅仅是展示3级分类，在大多数的中小型电商系统中，三级分类完全足够应对SKU的分类。&lt;/p&gt;
&lt;h2 id=&quot;需求分析&quot;&gt;### 需求分析&lt;/h2&gt;
&lt;p&gt;先来分析分类都包含哪些元素，以&lt;code&gt;jd&lt;/code&gt;为例：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191119075814119-1781486402.png&quot; alt=&quot;京东分类&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;logo(logo) 有的分类文字前面会有小标&lt;/li&gt;
&lt;li&gt;分类展示主图(img_url)&lt;/li&gt;
&lt;li&gt;主标题(title)&lt;/li&gt;
&lt;li&gt;副标题/Slogan&lt;/li&gt;
&lt;li&gt;图片跳转地址（img_link_url）-- 大多数时候我们点击分类都会&lt;code&gt;分类Id&lt;/code&gt;跳转到固定的分类商品列表展示页面，但是在一些特殊的场景，比如我们要做一个活动，希望可以点击某一个分类的主图直接定位到活动页面，这个url就可以使用了。&lt;/li&gt;
&lt;li&gt;上级分类(parent_id)&lt;/li&gt;
&lt;li&gt;背景色(bg_color)&lt;/li&gt;
&lt;li&gt;顺序（sort）&lt;/li&gt;
&lt;li&gt;当前分类级别（type）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;开发梳理&quot;&gt;### 开发梳理&lt;/h2&gt;
&lt;p&gt;在上一小节，我们简单分析了一下要实现商品分类的一些&lt;code&gt;points&lt;/code&gt;，那么我们最好在每次拿到需求【开发之前】，对需求进行拆解，然后分解开发流程，这样可以保证我们更好的理解需求，以及在开发之前发现一部分不合理的需求，并且如果需求设计不合理的话，开发人员完全有权，也有责任告知PM。大家的终极目的都是为了我们做的产品更加合理，好用，受欢迎！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首次展示，仅仅读取一级分类（Root）&lt;/li&gt;
&lt;li&gt;根据一级分类查询二三级子分类&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编码实现&quot;&gt;### 编码实现&lt;/h2&gt;
&lt;h4 id=&quot;查询一级分类&quot;&gt;查询一级分类&lt;/h4&gt;
&lt;h5 id=&quot;service实现&quot;&gt;Service实现&lt;/h5&gt;
&lt;p&gt;1.在&lt;code&gt;com.liferunner.service&lt;/code&gt;中创建service 接口&lt;code&gt;ICategoryService.java&lt;/code&gt;, 编写查询所有一级分类的方法&lt;code&gt;getAllRootCategorys&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.liferunner.service;
import com.liferunner.dto.CategoryResponseDTO;
import com.liferunner.dto.SecondSubCategoryResponseDTO;
import java.util.List;
/**
 * ICategoryService for : 分类service
 *
 * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
 * @since 2019/11/13
 */
public interface ICategoryService {
    /**
     * 获取所有有效的一级分类（根节点）
     *
     * @return
     */
    List&amp;lt;CategoryResponseDTO&amp;gt; getAllRootCategorys();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.编写实现类&lt;code&gt;com.liferunner.service.ICategoryService.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Slf4j
public class CategorySericeImpl implements ICategoryService {
    @Autowired
    private CategoryMapper categoryMapper;
    
    @Override
    public List&amp;lt;CategoryResponseDTO&amp;gt; getAllRootCategorys() {
        Example example = new Example(Category.class);
        val conditions = example.createCriteria();
        conditions.andEqualTo(&quot;type&quot;, CategoryTypeEnum.ROOT.type);
        val categoryList = this.categoryMapper.selectByExample(example);
        //声明返回对象
        List&amp;lt;CategoryResponseDTO&amp;gt; categoryResponseDTOS = new ArrayList&amp;lt;&amp;gt;();
        if (!CollectionUtils.isEmpty(categoryList)) {
            //赋值
            CategoryResponseDTO dto;
            for (Category category : categoryList) {
                dto = new CategoryResponseDTO();
                BeanUtils.copyProperties(category, dto);
                categoryResponseDTOS.add(dto);
            }
        }
        return categoryResponseDTOS;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码很好理解，创建&lt;code&gt;tk.mybatis.mapper.entity.Example&lt;/code&gt;，将条件传入，然后使用&lt;code&gt;通用Mapper&lt;/code&gt;查询到&lt;code&gt;type=1&lt;/code&gt;的一级分类，接着将查到的对象列表转换为DTO对象列表。&lt;/p&gt;
&lt;h5 id=&quot;controller实现&quot;&gt;Controller实现&lt;/h5&gt;
&lt;p&gt;一般情况下，此类查询都会出现在网站的首页，因此我们来创建一个&lt;code&gt;com.liferunner.api.controller.IndexController&lt;/code&gt;,并对外暴露一个查询一级分类的接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.liferunner.api.controller;

import com.liferunner.service.ICategoryService;
import com.liferunner.service.IProductService;
import com.liferunner.service.ISlideAdService;
import com.liferunner.utils.JsonResponse;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import java.util.Collections;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.CollectionUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
/**
 * IndexController for : 首页controller
 *
 * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
 * @since 2019/11/12
 */
@RestController
@RequestMapping(&quot;/index&quot;)
@Api(value = &quot;首页信息controller&quot;, tags = &quot;首页信息接口API&quot;)
@Slf4j
public class IndexController {
    @Autowired
    private ICategoryService categoryService;

    @GetMapping(&quot;/rootCategorys&quot;)
    @ApiOperation(value = &quot;查询一级分类&quot;, notes = &quot;查询一级分类&quot;)
    public JsonResponse findAllRootCategorys() {
        log.info(&quot;============查询一级分类==============&quot;);
        val categoryResponseDTOS = this.categoryService.getAllRootCategorys();
        if (CollectionUtils.isEmpty(categoryResponseDTOS)) {
            log.info(&quot;============未查询到任何分类==============&quot;);
            return JsonResponse.ok(Collections.EMPTY_LIST);
        }
        log.info(&quot;============一级分类查询result：{}==============&quot;, categoryResponseDTOS);
        return JsonResponse.ok(categoryResponseDTOS);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;test-api&quot;&gt;Test API&lt;/h5&gt;
&lt;p&gt;编写完成之后，我们需要对我们的代码进行测试验证，还是通过使用&lt;code&gt;RestService&lt;/code&gt;插件来实现，当然，大家也可以通过Postman来测试。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;status&quot;: 200,
  &quot;message&quot;: &quot;OK&quot;,
  &quot;data&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;name&quot;: &quot;烟酒&quot;,
      &quot;type&quot;: 1,
      &quot;parentId&quot;: 0,
      &quot;logo&quot;: &quot;img/cake.png&quot;,
      &quot;slogan&quot;: &quot;吸烟受害健康&quot;,
      &quot;catImage&quot;: &quot;http://www.life-runner.com/shop/category/cake.png&quot;,
      &quot;bgColor&quot;: &quot;#fe7a65&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;服装&quot;,
      &quot;type&quot;: 1,
      &quot;parentId&quot;: 0,
      &quot;logo&quot;: &quot;img/cookies.png&quot;,
      &quot;slogan&quot;: &quot;我选择我喜欢&quot;,
      &quot;catImage&quot;: &quot;http://www.life-runner.com/shop/category/cookies.png&quot;,
      &quot;bgColor&quot;: &quot;#f59cec&quot;
    },
    {
      &quot;id&quot;: 3,
      &quot;name&quot;: &quot;鞋帽&quot;,
      &quot;type&quot;: 1,
      &quot;parentId&quot;: 0,
      &quot;logo&quot;: &quot;img/meat.png&quot;,
      &quot;slogan&quot;: &quot;飞一般的感觉&quot;,
      &quot;catImage&quot;: &quot;http://www.life-runner.com/shop/category/meat.png&quot;,
      &quot;bgColor&quot;: &quot;#b474fe&quot;
    }
  ],
  &quot;ok&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;根据一级分类查询子分类&quot;&gt;根据一级分类查询子分类&lt;/h4&gt;
&lt;p&gt;因为根据一级id查询子分类的时候，我们是在同一张表中做自连接查询，因此，通用mapper已经不适合我们的使用，因此我们需要自定义mapper来实现我们的需求。&lt;/p&gt;
&lt;h5 id=&quot;自定义mybatis-mapper实现&quot;&gt;自定义Mybatis Mapper实现&lt;/h5&gt;
&lt;p&gt;在之前的编码中，我们都是使用的插件帮我们实现的通用&lt;code&gt;Mapper&lt;/code&gt;,但是这种查询只能处理简单的单表&lt;code&gt;CRUD&lt;/code&gt;，一旦我们需要SQL 包含一部分逻辑处理的时候，那就必须得自己来编写了，let's code.&lt;br/&gt;1.在项目&lt;code&gt;mscx-shop-mapper&lt;/code&gt;中，创建一个新的&lt;code&gt;custom package&lt;/code&gt;,在该目录下创建自定义mapper&lt;code&gt;com.liferunner.custom.CategoryCustomMapper&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface CategoryCustomMapper {
    List&amp;lt;SecondSubCategoryResponseDTO&amp;gt; getSubCategorys(Integer parentId);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.&lt;code&gt;resources&lt;/code&gt;目录下创建目录&lt;code&gt;mapper.custom&lt;/code&gt;,以及创建和上面的接口相同名称的&lt;code&gt;XML&lt;/code&gt;文件&lt;code&gt;mapper/custom/CategoryCustomMapper.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.liferunner.custom.CategoryCustomMapper&quot;&amp;gt;
    &amp;lt;resultMap id=&quot;subCategoryDTO&quot; type=&quot;com.liferunner.dto.SecondSubCategoryResponseDTO&quot;&amp;gt;
        &amp;lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&amp;gt;
        &amp;lt;result column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&amp;gt;
        &amp;lt;result column=&quot;type&quot; jdbcType=&quot;INTEGER&quot; property=&quot;type&quot;/&amp;gt;
        &amp;lt;result column=&quot;parentId&quot; jdbcType=&quot;INTEGER&quot; property=&quot;parentId&quot;/&amp;gt;
        &amp;lt;collection property=&quot;thirdSubCategoryResponseDTOList&quot; ofType=&quot;com.liferunner.dto.ThirdSubCategoryResponseDTO&quot;&amp;gt;
            &amp;lt;id column=&quot;subId&quot; jdbcType=&quot;INTEGER&quot; property=&quot;subId&quot;/&amp;gt;
            &amp;lt;result column=&quot;subName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;subName&quot;/&amp;gt;
            &amp;lt;result column=&quot;subType&quot; jdbcType=&quot;INTEGER&quot; property=&quot;subType&quot;/&amp;gt;
            &amp;lt;result column=&quot;subParentId&quot; jdbcType=&quot;INTEGER&quot; property=&quot;subParentId&quot;/&amp;gt;
        &amp;lt;/collection&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&quot;getSubCategorys&quot; resultMap=&quot;subCategoryDTO&quot; parameterType=&quot;INTEGER&quot;&amp;gt;
        SELECT p.id as id,p.`name` as `name`,p.`type` as `type`,p.father_id as parentId,
        c.id as subId,c.`name` as subName,c.`type` as subType,c.parent_id as subParentId
        FROM category p
        LEFT JOIN category c
        ON p.id = c.parent_id
        WHERE p.parent_id = ${parentId};
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;TIPS&lt;/strong&gt;&lt;br/&gt;上述创建的package,一定要在项目的启动类&lt;code&gt;com.liferunner.api.ApiApplication&lt;/code&gt;中修改&lt;code&gt;@MapperScan(basePackages = { &quot;com.liferunner.mapper&quot;, &quot;com.liferunner.custom&quot;})&lt;/code&gt;,如果不把我们的&lt;code&gt;custom&lt;/code&gt; package加上，会造成扫描不到而报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上面的xml中，我们定义了两个DTO对象，分别用来处理二级和三级分类的DTO，实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@ToString
public class SecondSubCategoryResponseDTO {
    /**
     * 主键
     */
    private Integer id;

    /**
     * 分类名称
     */
    private String name;

    /**
     * 分类类型
     1:一级大分类
     2:二级分类
     3:三级小分类
     */
    private Integer type;

    /**
     * 父id
     */
    private Integer parentId;

    List&amp;lt;ThirdSubCategoryResponseDTO&amp;gt; thirdSubCategoryResponseDTOList;
}
---
    
@Data
@ToString
public class ThirdSubCategoryResponseDTO {
    /**
     * 主键
     */
    private Integer subId;

    /**
     * 分类名称
     */
    private String subName;

    /**
     * 分类类型
     1:一级大分类
     2:二级分类
     3:三级小分类
     */
    private Integer subType;

    /**
     * 父id
     */
    private Integer subParentId;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;service实现-1&quot;&gt;Service实现&lt;/h5&gt;
&lt;p&gt;编写完自定义mapper之后，我们就可以继续编写service了，在&lt;code&gt;com.liferunner.service.ICategoryService&lt;/code&gt;中新增一个方法：&lt;code&gt;getAllSubCategorys(parentId)&lt;/code&gt;.如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ICategoryService {
    ...
    /**
     * 根据一级分类获取子分类
     *
     * @param parentId 一级分类id
     * @return 子分类list
     */
    List&amp;lt;SecondSubCategoryResponseDTO&amp;gt; getAllSubCategorys(Integer parentId);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;com.liferunner.service.impl.CategorySericeImpl&lt;/code&gt;实现上述方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Slf4j
public class CategorySericeImpl implements ICategoryService {
    @Autowired
    private CategoryMapper categoryMapper;

    @Autowired
    private CategoryCustomMapper categoryCustomMapper;
    ...
    @Override
    @Transactional(propagation = Propagation.SUPPORTS)
    public List&amp;lt;SecondSubCategoryResponseDTO&amp;gt; getAllSubCategorys(Integer parentId) {
        return this.categoryCustomMapper.getSubCategorys(parentId);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;controller实现-1&quot;&gt;Controller实现&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/index&quot;)
@Api(value = &quot;首页信息controller&quot;, tags = &quot;首页信息接口API&quot;)
@Slf4j
public class IndexController {
    @Autowired
    private ICategoryService categoryService;
    ...
    @GetMapping(&quot;/subCategorys/{parentId}&quot;)
    @ApiOperation(value = &quot;查询子分类&quot;, notes = &quot;根据一级分类id查询子分类&quot;)
    public JsonResponse findAllSubCategorys(
            @ApiParam(name = &quot;parentId&quot;, value = &quot;一级分类id&quot;, required = true)
            @PathVariable Integer parentId) {
        log.info(&quot;============查询id = {}的子分类==============&quot;, parentId);
        val categoryResponseDTOS = this.categoryService.getAllSubCategorys(parentId);
        if (CollectionUtils.isEmpty(categoryResponseDTOS)) {
            log.info(&quot;============未查询到任何分类==============&quot;);
            return JsonResponse.ok(Collections.EMPTY_LIST);
        }
        log.info(&quot;============子分类查询result：{}==============&quot;, categoryResponseDTOS);
        return JsonResponse.ok(categoryResponseDTOS);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;test-api-1&quot;&gt;Test API&lt;/h5&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;status&quot;: 200,
  &quot;message&quot;: &quot;OK&quot;,
  &quot;data&quot;: [
    {
      &quot;id&quot;: 11,
      &quot;name&quot;: &quot;国产&quot;,
      &quot;type&quot;: 2,
      &quot;parentId&quot;: 1,
      &quot;thirdSubCategoryResponseDTOList&quot;: [
        {
          &quot;subId&quot;: 37,
          &quot;subName&quot;: &quot;中华&quot;,
          &quot;subType&quot;: 3,
          &quot;subParentId&quot;: 11
        },
        {
          &quot;subId&quot;: 38,
          &quot;subName&quot;: &quot;冬虫夏草&quot;,
          &quot;subType&quot;: 3,
          &quot;subParentId&quot;: 11
        },
        {
          &quot;subId&quot;: 39,
          &quot;subName&quot;: &quot;南京&quot;,
          &quot;subType&quot;: 3,
          &quot;subParentId&quot;: 11
        },
        {
          &quot;subId&quot;: 40,
          &quot;subName&quot;: &quot;云烟&quot;,
          &quot;subType&quot;: 3,
          &quot;subParentId&quot;: 11
        }
      ]
    },
    {
      &quot;id&quot;: 12,
      &quot;name&quot;: &quot;外烟&quot;,
      &quot;type&quot;: 2,
      &quot;parentId&quot;: 1,
      &quot;thirdSubCategoryResponseDTOList&quot;: [
        {
          &quot;subId&quot;: 44,
          &quot;subName&quot;: &quot;XXXXX&quot;,
          &quot;subType&quot;: 3,
          &quot;subParentId&quot;: 12
        },
        {
          &quot;subId&quot;: 45,
          &quot;subName&quot;: &quot;RRRRR&quot;,
          &quot;subType&quot;: 3,
          &quot;subParentId&quot;: 12
        }
      ]
    }
  ],
  &quot;ok&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上我们就已经实现了和&lt;code&gt;jd&lt;/code&gt;类似的商品分类的功能实现。&lt;/p&gt;
&lt;h2 id=&quot;轮播广告slidead&quot;&gt;## 轮播广告|SlideAD&lt;/h2&gt;
&lt;h3 id=&quot;需求分析-1&quot;&gt;需求分析&lt;/h3&gt;
&lt;p&gt;这个就是&lt;code&gt;jd&lt;/code&gt;或者&lt;code&gt;tb&lt;/code&gt;首先的最顶部的广告图片是一样的，每隔1秒自动切换图片。接下来我们分析一下轮播图中都包含哪些信息：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191119075818270-1815843980.png&quot; alt=&quot;Slide Images&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图片(img_url)是最基本的&lt;/li&gt;
&lt;li&gt;图片跳转连接（img_link_url），这个是在我们点击这个图片的时候需要跳转到的页面&lt;/li&gt;
&lt;li&gt;有的可以直接跳转到商品详情页面&lt;/li&gt;
&lt;li&gt;有的可以直接跳转到某一分类商品列表页面&lt;/li&gt;
&lt;li&gt;轮播图的播放顺序（sort）&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;开发梳理-1&quot;&gt;开发梳理&lt;/h3&gt;
&lt;p&gt;直接查询出所有的&lt;code&gt;有效的&lt;/code&gt;轮播图片，并且进行&lt;code&gt;排序&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;编码实现-1&quot;&gt;编码实现&lt;/h3&gt;
&lt;h4 id=&quot;service-实现&quot;&gt;Service 实现&lt;/h4&gt;
&lt;p&gt;和商品分类实现一样，在&lt;code&gt;mscx-shop-service&lt;/code&gt;中创建&lt;code&gt;com.liferunner.service.ISlideAdService&lt;/code&gt;并实现，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ISlideAdService {
    /**
     * 查询所有可用广告并排序
     * @param isShow
     * @return
     */
    List&amp;lt;SlideAdResponseDTO&amp;gt; findAll(Integer isShow, String sortRanking);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Slf4j
public class SlideAdServiceImpl implements ISlideAdService {

    // 注入mapper
    private final SlideAdsMapper slideAdsMapper;

    @Autowired
    public SlideAdServiceImpl(SlideAdsMapper slideAdsMapper) {
        this.slideAdsMapper = slideAdsMapper;
    }

    @Override
    public List&amp;lt;SlideAdResponseDTO&amp;gt; findAll(Integer isShow, String sortRanking) {
        Example example = new Example(SlideAds.class);
        //设置排序
        if (StringUtils.isBlank(sortRanking)) {
            example.orderBy(&quot;sort&quot;).asc();
        } else {
            example.orderBy(&quot;sort&quot;).desc();
        }
        val conditions = example.createCriteria();
        conditions.andEqualTo(&quot;isShow&quot;, isShow);
        val slideAdsList = this.slideAdsMapper.selectByExample(example);
        //声明返回对象
        List&amp;lt;SlideAdResponseDTO&amp;gt; slideAdResponseDTOList = new ArrayList&amp;lt;&amp;gt;();
        if (!CollectionUtils.isEmpty(slideAdsList)) {
            //赋值
            SlideAdResponseDTO dto;
            for (SlideAds slideAds : slideAdsList) {
                dto = new SlideAdResponseDTO();
                BeanUtils.copyProperties(slideAds, dto);
                slideAdResponseDTOList.add(dto);
            }
        }
        return slideAdResponseDTOList;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述可以看到，这里我使用的是&lt;code&gt;构造函数注入SlideAdsMapper&lt;/code&gt;，其余代码单表查询没什么特别的，根据条件查询轮播图，并返回结果，返回的对象是&lt;code&gt;com.liferunner.dto.SlideAdResponseDTO&lt;/code&gt;列表，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@ApiModel(value = &quot;轮播广告返回DTO&quot;, description = &quot;轮播广告返回DTO&quot;)
public class SlideAdResponseDTO{
    /**
     * 主键
     */
    private String id;

    /**
     * 图片地址
     */
    private String imageUrl;

    /**
     *  背景颜色
     */
    private String backgroundColor;

    /**
     * 商品id
     */
    private String productId;

    /**
     * 商品分类id
     */
    private String catId;

    /**
     * 图片跳转URL
     */
    private String imageLinkUrl;

    /**
     * 轮播图类型 用于判断，可以根据商品id或者分类进行页面跳转，1：商品 2：分类 3：链接url
     */
    private Integer type;

    /**
     * 轮播图展示顺序 轮播图展示顺序，从小到大
     */
    private Integer sort;

    /**
     * 是否展示 是否展示，1：展示    0：不展示
     */
    private Integer isShow;

    /**
     * 创建时间 创建时间
     */
    private Date createTime;

    /**
     * 更新时间 更新
     */
    private Date updateTime;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;controller实现-2&quot;&gt;Controller实现&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;com.liferunner.api.controller.IndexController&lt;/code&gt;中，新添加一个查询轮播图API，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Autowired
    private ISlideAdService slideAdService;

    @GetMapping(&quot;/slideAds&quot;)
    @ApiOperation(value = &quot;查询轮播广告&quot;, notes = &quot;查询轮播广告接口&quot;)
    public JsonResponse findAllSlideList() {
        log.info(&quot;============查询所有轮播广告,isShow={},sortRanking={}==============&quot;
                , 1, &quot;desc&quot;);
        val slideAdsList = this.slideAdService.findAll(1, &quot;desc&quot;);
        if (CollectionUtils.isEmpty(slideAdsList)) {
            log.info(&quot;============未查询到任何轮播广告==============&quot;);
            return JsonResponse.ok(Collections.EMPTY_LIST);
        }
        log.info(&quot;============轮播广告查询result：{}==============&quot;
                , slideAdsList);
        return JsonResponse.ok(slideAdsList);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;test-api-2&quot;&gt;Test API&lt;/h4&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;status&quot;: 200,
  &quot;message&quot;: &quot;OK&quot;,
  &quot;data&quot;: [
    {
      &quot;id&quot;: &quot;slide-100002&quot;,
      &quot;imageUrl&quot;: &quot;http://www.life-runner.com/2019/11/CpoxxF0ZmH6AeuRrAAEZviPhyQ0768.png&quot;,
      &quot;backgroundColor&quot;: &quot;#55be59&quot;,
      &quot;productId&quot;: &quot;&quot;,
      &quot;catId&quot;: &quot;133&quot;,
      &quot;type&quot;: 2,
      &quot;sort&quot;: 2,
      &quot;isShow&quot;: 1,
      &quot;createTime&quot;: &quot;2019-10-11T21:33:01.000+0000&quot;,
      &quot;updateTime&quot;: &quot;2019-10-11T21:33:02.000+0000&quot;
    },
    {
      &quot;id&quot;: &quot;slide-100003&quot;,
      &quot;imageUrl&quot;: &quot;http://www.life-runner.com/2019/11/CpoxxF0ZmHuAPlXvAAFe-H5_-Nw961.png&quot;,
      &quot;backgroundColor&quot;: &quot;#ff9801&quot;,
      &quot;productId&quot;: &quot;y200008&quot;,
      &quot;catId&quot;: &quot;&quot;,
      &quot;type&quot;: 1,
      &quot;sort&quot;: 1,
      &quot;isShow&quot;: 1,
      &quot;createTime&quot;: &quot;2019-10-11T21:33:01.000+0000&quot;,
      &quot;updateTime&quot;: &quot;2019-10-11T21:33:02.000+0000&quot;
    }
  ],
  &quot;ok&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;福利讲解&quot;&gt;福利讲解&lt;/h3&gt;
&lt;p&gt;在我们的实现代码中，有心的同学可以看到，我使用了3种不同的Bean注入方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;属性注入&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Autowired
    private ISlideAdService slideAdService;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;构造函数注入&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 注入mapper
    private final SlideAdsMapper slideAdsMapper;

    @Autowired
    public SlideAdServiceImpl(SlideAdsMapper slideAdsMapper) {
        this.slideAdsMapper = slideAdsMapper;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Lombok插件注入(本质也是构造器注入，代码会动态生成。)&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class ProductServiceImpl implements IProductService {
    // RequiredArgsConstructor 构造器注入
    private final ProductCustomMapper productCustomMapper;
    private final ProductsMapper productsMapper;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，这几种注入都有什么区别呢？首先我们下了解一下Spring的注入是干什么的？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过Spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。&lt;br/&gt;依赖注入的另一种说法是&quot;控制反转&quot;。通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员， 而控制反转是指new实例工作不由我们程序员来做而是交给Spring容器来做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在传统的SpringMVC中，大家使用的都是&lt;code&gt;XML注入&lt;/code&gt;，比如：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--配置bean,配置后该类由spring管理--&amp;gt; 
&amp;lt;bean name=&quot;CategorySericeImpl&quot; class=&quot;com.liferunner.service.impl.CategorySericeImpl&quot;&amp;gt; 
&amp;lt;!--注入配置当前类中相应的属性--&amp;gt; 
&amp;lt;property name=&quot;categoryMapper&quot; ref=&quot;categoryMapper&quot;&amp;gt;&amp;lt;/property&amp;gt; 
&amp;lt;/bean&amp;gt; 
&amp;lt;bean name=&quot;categoryMapper&quot; class=&quot;com.liferunner.mapper.CategoryMapper&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注入之后，使用&lt;code&gt;@Autowired&lt;/code&gt;,我们可以很方便的自动从IOC容器中查找属性，并返回。&lt;/p&gt;
&lt;blockquote readability=&quot;7.8051948051948&quot;&gt;
&lt;p&gt;&lt;strong&gt;@Autowired的原理&lt;/strong&gt;&lt;br/&gt;在启动spring IoC时，容器自动装载了一个&lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt;后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。&lt;br/&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;br/&gt;在使用@Autowired时，首先在容器中查询对应类型的bean&lt;br/&gt;如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据&lt;br/&gt;如果查询的结果不止一个，那么@Autowired会根据名称来查找。&lt;br/&gt;如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/caoyc/p/5626365.html&quot;&gt;source传送门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述三种注解方式，其实本质上还是注入的2种:&lt;code&gt;set属性注入&lt;/code&gt; &amp;amp; &lt;code&gt;构造器注入&lt;/code&gt;，使用方式都可以，根据个人喜好来用，本人喜欢使用&lt;code&gt;lombok插件注入&lt;/code&gt;是因为，它将代码整合在一起，更加符合我们Spring自动注入的规范。&lt;/p&gt;
&lt;h2 id=&quot;源码下载&quot;&gt;## 源码下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Isaac-Zhang/expensive-shop&quot;&gt;Github 传送门&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://gitee.com/IsaacZhang/expensive-shop&quot;&gt;Gitee 传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;下节预告&quot;&gt;## 下节预告&lt;/h2&gt;
&lt;p&gt;下一节我们将继续开发我们电商的核心部分-商品列表和详情展示，在过程中使用到的任何开发组件，我都会通过专门的一节来进行介绍的，兄弟们末慌！&lt;/p&gt;
&lt;p&gt;gogogo！&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 23:58:00 +0000</pubDate>
<dc:creator>IsaacZhang</dc:creator>
<og:description>商品分类&amp;轮播广告 因最近又被困在了OSGI技术POC，更新进度有点慢，希望大家不要怪罪哦。 '上节' 我们实现了登录之后前端的展示，如： 接着，我们来实现左侧分类栏目的功能。 商品分类|Produc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangpan1244/p/11886832.html</dc:identifier>
</item>
<item>
<title>大学生活这样过，校招 offer 飞来找 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11886830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11886830.html</guid>
<description>&lt;h3 id=&quot;开门见山&quot;&gt;01、开门见山&lt;/h3&gt;
&lt;p&gt;由于&lt;a href=&quot;https://mp.weixin.qq.com/s/feoOINGSyivBO8Z1gaQVOA&quot;&gt;我&lt;/a&gt;比较喜欢分享的原因，认识了不少大学生。其中有不少佼佼者，比如说一年读 50 本书的璐璐，校招斩获一线大厂 Offer 的晓峰，通过运营公众号实现经济独立的帅土。&lt;/p&gt;
&lt;p&gt;当然也有一些不知所措的，对未来&lt;a href=&quot;https://mp.weixin.qq.com/s/50Wimh236R3rl6Riem9gDA&quot;&gt;充满疑惑的年轻人&lt;/a&gt;。他们有些在文章底部留言，有些通过微信咨询，还有一些在星球提问。每次我都认真地回答，他们也对我的热情表示感谢。&lt;/p&gt;
&lt;p&gt;我想着，不如把自己的心得经验通过文章的形式分享出来，这样就能够给更多的大学生提供参照。如果你读完这篇文章后，有所收获，就把它分享给更多的人。&lt;/p&gt;
&lt;h3 id=&quot;往事不可追&quot;&gt;02、往事不可追&lt;/h3&gt;
&lt;p&gt;苏联作家尼古拉·奥斯特洛夫斯基的小说《钢铁是怎样炼成的》里面有这样一句至理名言——&lt;strong&gt;人生最宝贵的是生命，生命属于人只有一次。一个人的生命应当这样度过：当他回忆往事的时候，他不致因虚度年华而悔恨，也不致因碌碌无为而羞愧&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;说来惭愧，回忆起我的大学时光，涌上心头的是满满的悔恨和羞愧。&lt;/p&gt;
&lt;p&gt;我参加过两次高考。第一次的成绩真实地反映出了我平常的水准，我自己心里也像明镜一样。没有努力就不会有超水平的发挥。这也恰好给了我复读的勇气：只要努把力，没准就会有惊喜。&lt;/p&gt;
&lt;p&gt;于是我从洛宁县的一个二流高中辗转去了平顶山市一高，下了很大的决心。结果呢，第二次的成绩又真实地反映出了我平常的水准——意料之外却也是情理之中，差二本线的分数和第一年完全一样。&lt;/p&gt;
&lt;p&gt;当时我几乎放弃了上大学的打算，还去搬了一个月的砖。详情可以查看之前写的文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/V8EHy5-eoM7WCZBwON1-_A&quot;&gt;搬砖，真的是我第一次赚钱的经历！&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;后来实在是迫于无奈（身板不够结实，搬不了几块砖），就听从了同学的建议，志愿上填了郑州的一所大专。幸好专业服从了调剂，否则大专也上不了。我们学校录取的分数当时蛮高的，最高分比一本线要高出一大截。大家之所以挤破头想去，是因为学校最好的专业毕业后可以直接到国家电网上班，大多数人梦寐以求的工作。&lt;/p&gt;
&lt;p&gt;而我呢，比最低分只高出了零分。可想而知，我调剂后的专业「计算机网络」在学校是多么的不受待见。专业课的老师们秉持着和我们一起共同成长的理念，而我们秉持着和老师们一起沉沦的信心。&lt;/p&gt;
&lt;p&gt;上课的时候我带着笔记本电脑在教室打游戏，下课的时候我带着笔记本电脑在宿舍打游戏。除了周末去郑州大学找女朋友散散心，我的大学生活过得是一塌糊涂，要多糟糕有多糟糕。&lt;/p&gt;
&lt;p&gt;可以这么说，和璐璐、晓峰、帅土比起来，我是一个不折不扣的反面教材。可正因为如此，我接下来给出的建议那可就十足的宝贵了。多么痛的领悟！&lt;/p&gt;
&lt;h3 id=&quot;积累项目经验&quot;&gt;03、积累项目经验&lt;/h3&gt;
&lt;p&gt;不少大学生以为，大学期间就应该深入学习理论知识，实战经验并不重要，等到工作以后再实践也不晚。但这真的是一个错误的认知啊，理论知识确实非常重要，但要记住一点：学以致用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果学到的理论知识不能够应用于实战当中，就好像我们手里有一把南瓜子，却没有洒向肥沃的土壤&lt;/strong&gt;。这样的话，这些南瓜子就永远只能是南瓜子，无法生根发芽，结出新的南瓜。更残忍的是，这些南瓜子还会被我们吃进肚子里。&lt;/p&gt;
&lt;p&gt;我随手查阅了一些企业的校招要求，里面明确要求要有一定的项目经验。这就意味着如果没有项目经验，就无法找到工作；找不到工作，就不会有项目经验。好像是一个死结唉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2019/11/life-daxue-should-duguo-1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2019/11/life-daxue-should-duguo-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也许这些校招要求过于苛刻了。说实话，我也应付不来。但我们应该知道，“人外有人，天外有天”，优秀的大学生多着呢，我们应付不来，他们一定能够胜任。&lt;/p&gt;
&lt;p&gt;那有些同学可能会抱怨道，我就是一名普通的大学生，我没他们那么优秀，我该怎么办？况且，谁会乐意把项目交给我来说呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;别恐慌，别着急给自己设限&lt;/strong&gt;。我之前认识一个同学，叫小曾。他说他们学校有一个群，里面会不定期发布一些项目（企业网站、小商城等等），费用一般在 7K 左右。他缺钱的时候就找几个宿友一起做。两三年下来，自己主导的项目就有 3 个，还不带辅助参与的。&lt;/p&gt;
&lt;p&gt;虽然是廉价劳动力，但总比无所事事强得多。毕业的时候他就感觉像旅欧回来的足球运动员，成长特别大。也成功斩获了网易的一个 Offer。&lt;/p&gt;
&lt;p&gt;项目经验嘛，没必要非得是多么大的项目，只要了解了项目的流程，有过思考和总结，有过入坑和爬坑，就是不可多得的项目经验。&lt;/p&gt;
&lt;p&gt;再多说一句，小曾有时候会把一些搞不定的项目外包出去，赚取一些差价。你一定会觉得我在胡侃，但我想表达的是，这就是我们认识的方式。&lt;strong&gt;人与人之间的差距，和年龄无关，只和认知有关&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我只上过两年大学，还一心扑在游戏上，我的荣誉勋章上只有一个——挂科了三次，每次和同学们吹牛逼，我都要炫耀一番自己当年有多二。和同年龄段的小曾相比，我当时实在是弱爆了。我希望你以我为戒。&lt;/p&gt;
&lt;h3 id=&quot;真正的实习&quot;&gt;04、真正的实习&lt;/h3&gt;
&lt;p&gt;在知乎上看到一个神奇的问题：“想做一个程序员，一定要走培训吗？”这个问题的神奇之处就好像在问一个医生：“我感冒了，一定要做个手术才能好吗？”&lt;/p&gt;
&lt;p&gt;我大三的时候就因为这样的无知，被骗进了一家软件培训机构。现在回想起来，胸口不免隐隐作痛。我大学两年，学的是 Java 编程语言，虽然说荒唐度日，但好歹做过仿 QQ 聊天工具的，多多少少有点底子的。&lt;/p&gt;
&lt;p&gt;如果肯去一些招聘网站上寻找机会的话，也不会一无所获。毕竟那时候的 Java 工程师也蛮吃香的。只是老师们没有告诉我方法，我也没有找到知心的大佬咨询建议。于是连招聘网站都没有上过，愚昧啊。&lt;/p&gt;
&lt;p&gt;但不管怎么说，&lt;a href=&quot;https://mp.weixin.qq.com/s/qnSkDUU9mKgCbzjlpCuJzw&quot;&gt;我通过培训找到了一份实习的工作&lt;/a&gt;。而实习是一个提高自己、接触社会的绝佳机会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，实习是有工资的&lt;/strong&gt;。这一点特别重要，它让我们摆脱了向父母伸手要钱的日子，有一种“翅膀长硬了”的感觉。尽管这份工资没多少，但它证明我们对公司是有价值的。假如某个公司提倡“零工资”实习，那简直是不要脸，不是真正的实习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次，实习是有实际工作的&lt;/strong&gt;。这一点也特别重要，它能够让我们茁壮地成长，有一种必须要变强的感觉。尽管每一个任务的工作量都很小，但它证明公司是重视我们的。假如公司把实习生放在一个角落没人管，那简直是浪费生命，不是真正的实习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，实习是有师父带的&lt;/strong&gt;。这一点千万别忽视，它能够让我们更少犯错、更快提高、更有收获。尽管指导我们不是师父应尽的义务，但它证明公司是尽职尽责的。假如我们遇到的师父是负责任的，那么谢天谢地谢师父吧。&lt;/p&gt;
&lt;p&gt;我在实习期的表现还不错，顺利的拿到了公司的正式邀请。毕业后一直在这家公司干，直到三年半后回到洛阳。这段工作的记忆至今依然非常美好。&lt;/p&gt;
&lt;p&gt;那除了培训，还有什么方法可以找到实习工作吗？&lt;/p&gt;
&lt;p&gt;当然有，有很多！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）学校官网&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;千万不要忽视这一点啊！尽管学校官网的主页一般做得稀耙烂，迎面扑来一种浓厚的“闰土”气息，但上面的信息还是挺有价值的。&lt;/p&gt;
&lt;p&gt;下图是我在郑州大学的招生就业栏目中找到的招聘信息，更新日期为上一个工作日，蛮及时的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2019/11/life-daxue-should-duguo-3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一定要未雨绸缪，不要等毕业的时候再去关注，那恐怕就有点晚了。最好从大一就开始持续关注。为什么呢？&lt;/p&gt;
&lt;p&gt;如果一家企业从大一到毕业那年都在招聘，那就可以间接地说明这家企业运作的还不错：要么规模在扩大，要么人员在流动，很良性，值得信赖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）网上渠道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我就不再推荐网站了，免得我有打广告的嫌疑。只要你在搜索引擎里输入“校园招聘”就会找到答案。去关注一些自己感兴趣的公司，尤其是一些大厂，遇到心仪的就及时跟进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）朋友介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是实习找工作，还是正式找工作，朋友介绍永远是最值得我们信赖的。这里的“朋友”可不是躺在微信好友或者 QQ 好友列表里的那些“占坑”朋友，而是经常有技术上的交流，生活中的交流的朋友。&lt;/p&gt;
&lt;p&gt;怎么去认识这些朋友呢？教你一招，想尽一切办法联系上各大知识分享社区上的大佬，那些排名比较靠前的，手头都会有一些内推的机会。&lt;/p&gt;
&lt;p&gt;当然，前提是你有证明你很优秀的资本。&lt;/p&gt;
&lt;h3 id=&quot;new-一个对象&quot;&gt;05、new 一个对象&lt;/h3&gt;
&lt;p&gt;好吧，我承认，我大学做的最正确的一件事就是——找了一个女朋友。是她，是她，就是她，让我乏味的大学生活不再空虚寂寞冷。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/PBqR_uj6dd4xKEX8SUWIYQ&quot;&gt;学 Java 的同学都知道&lt;/a&gt;，没有对象就容易出现 &lt;code&gt;NullPointerException&lt;/code&gt;。有了的话要注意安全，嘘。&lt;/p&gt;
&lt;p&gt;这个话题我不打算谈得太多，毕竟我不是情感博主。唯一给同学们的建议就是：&lt;strong&gt;如果遇到合适的人，认真谈一场恋爱吧&lt;/strong&gt; ！&lt;/p&gt;
&lt;h3 id=&quot;最后的建议&quot;&gt;06、最后的建议&lt;/h3&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;开复老师：就要毕业了。&lt;/p&gt;&lt;p&gt;回头看自己所谓的大学生活，&lt;/p&gt;&lt;p&gt;我想哭，不是因为离别，而是因为什么都没学到。&lt;/p&gt;&lt;p&gt;我不知，简历该怎么写，若是以往我会让它空白。&lt;/p&gt;&lt;p&gt;最大的收获也许是……对什么都没有的忍耐和适应……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这段内容是一位同学写给李开复老师的一封信，看完后我的眼泪一直在眼眶里打转，因为他说出了我大二结束后的心声。&lt;/p&gt;
&lt;p&gt;李开复老师给出的回复是：读大学时，你应当掌握这七项，学好自修之道、基础知识、实践贯通、兴趣培养、积极主动、掌控时间、为人处事。&lt;/p&gt;
&lt;p&gt;在我看来，这更像是对整个人生的建议。如果你来问我的话，我的回答就是以上你看到的这些内容。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;谢谢大家的阅读，原创不易，喜欢就随手点个赞，这将是我最强的写作动力。如果你觉得文章对你有所帮助，也蛮有趣的，就关注一下我的微信公众号「&lt;strong&gt;沉默王二&lt;/strong&gt;」，拜谢。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 23:56:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>01、开门见山 由于 '我' 比较喜欢分享的原因，认识了不少大学生。其中有不少佼佼者，比如说一年读 50 本书的璐璐，校招斩获一线大厂 Offer 的晓峰，通过运营公众号实现经济独立的帅土。 当然也有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11886830.html</dc:identifier>
</item>
<item>
<title>3. 彤哥说netty系列之Java BIO NIO AIO进化史 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11886807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11886807.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191119073509304-1586448715.png&quot; alt=&quot;nio&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你好，我是彤哥，本篇是netty系列的第三篇。&lt;/p&gt;

&lt;p&gt;上一章我们介绍了IO的五种模型，实际上Java只支持其中的三种，即BIO/NIO/AIO。&lt;/p&gt;
&lt;p&gt;本文将介绍Java中这三种IO的进化史，并从使用的角度剖析它们背后的故事。&lt;/p&gt;

&lt;h2 id=&quot;bio概念解析&quot;&gt;BIO概念解析&lt;/h2&gt;
&lt;p&gt;BIO，Blocking IO，阻塞IO，它是Java的上古产品，自出生就有的东西（JDK 1.0）。&lt;/p&gt;
&lt;p&gt;使用BIO则数据准备和数据从内核空间拷贝到用户空间两个阶段都是阻塞的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191119073509594-1020206933.png&quot; alt=&quot;blocking-io&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;bio使用案例&quot;&gt;BIO使用案例&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EchoServer {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(8080);
        while (true) {
            System.out.println(&quot;start accept&quot;);
            Socket socket = serverSocket.accept();
            System.out.println(&quot;new conn: &quot; + socket.getRemoteSocketAddress());

            new Thread(()-&amp;gt;{
                try {
                    BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                    String msg;
                                        // 读取消息，本文来源公从号彤哥读源码
                    while ((msg = reader.readLine()) != null) {
                        if (msg.equalsIgnoreCase(&quot;quit&quot;)) {
                            reader.close();
                            socket.close();
                            break;
                        } else {
                            System.out.println(&quot;receive msg: &quot; + msg);
                        }
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端可以使用telnet来测试，而且你可以使用多个telnet来测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[c:\~]$ telnet 127.0.0.1 8080


Connecting to 127.0.0.1:8080...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.
hello world
我是人才
quit
Connection closed by foreign host.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BIO的使用方式非常简单，服务端接收到一个连接就启动一个线程来处理这个连接的所有请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191119073509866-928891526.png&quot; alt=&quot;bio_nio_aio&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，BIO最大的缺点就是浪费资源，只能处理少量的连接，线程数随着连接数线性增加，连接越多线程越多，直到抗不住。&lt;/p&gt;

&lt;h2 id=&quot;nio概念解析&quot;&gt;NIO概念解析&lt;/h2&gt;
&lt;p&gt;NIO，New IO，JDK1.4开始支持，内部是基于多路复用的IO模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191119073510106-1179621449.png&quot; alt=&quot;multiplexing-io&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有个歧义，很多人认为Java的NIO是Non-Blocking IO的缩写，其实并不是。&lt;/p&gt;
&lt;p&gt;使用NIO则多条连接的数据准备阶段会阻塞在select上，数据从内核空间拷贝到用户空间依然是阻塞的。&lt;/p&gt;
&lt;p&gt;因为第一阶段并不是连接本身处于阻塞阶段，所以通常来说NIO也可以看作是同步非阻塞IO。&lt;/p&gt;
&lt;h2 id=&quot;nio使用案例&quot;&gt;NIO使用案例&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EchoServer {
    public static void main(String[] args) throws IOException {
        Selector selector = Selector.open();
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.bind(new InetSocketAddress(8080));
        serverSocketChannel.configureBlocking(false);
        // 将accept事件绑定到selector上
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        while (true) {
            // 阻塞在select上
            selector.select();
            Set&amp;lt;SelectionKey&amp;gt; selectionKeys = selector.selectedKeys();
            // 遍历selectKeys
            Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeys.iterator();
            while (iterator.hasNext()) {
                SelectionKey selectionKey = iterator.next();
                // 如果是accept事件
                if (selectionKey.isAcceptable()) {
                    ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();
                    SocketChannel socketChannel = ssc.accept();
                    System.out.println(&quot;accept new conn: &quot; + socketChannel.getRemoteAddress());
                    socketChannel.configureBlocking(false);
                    socketChannel.register(selector, SelectionKey.OP_READ);
                } else if (selectionKey.isReadable()) {
                    // 如果是读取事件，本文来源公从号彤哥读源码
                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
                    ByteBuffer buffer = ByteBuffer.allocate(1024);
                    // 将数据读入到buffer中
                    int length = socketChannel.read(buffer);
                    if (length &amp;gt; 0) {
                        buffer.flip();
                        byte[] bytes = new byte[buffer.remaining()];
                        // 将数据读入到byte数组中
                        buffer.get(bytes);

                        // 换行符会跟着消息一起传过来
                        String content = new String(bytes, &quot;UTF-8&quot;).replace(&quot;\r\n&quot;, &quot;&quot;);
                        if (content.equalsIgnoreCase(&quot;quit&quot;)) {
                            selectionKey.cancel();
                            socketChannel.close();
                        } else {
                            System.out.println(&quot;receive msg: &quot; + content);
                        }
                    }
                }
                iterator.remove();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里同样使用telnet测试，而且你可以使用多个telnet来测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[c:\~]$ telnet 127.0.0.1 8080


Connecting to 127.0.0.1:8080...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.
hello world
我是人才
quit
Connection closed by foreign host.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO的使用方式就有点复杂了，但是一个线程就可以处理很多连接。&lt;/p&gt;
&lt;p&gt;首先，需要注册一个ServerSocketChannel并把它注册到selector上并监听accept事件，然后accept到连接后会获取到SocketChannel，同样把SocketChannel也注册到selector上，但是监听的是read事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191119073510364-796504126.png&quot; alt=&quot;bio_nio_aio&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NIO最大的优点，就是一个线程就可以处理大量的连接，缺点是不适合处理阻塞性任务，因为阻塞性任务会把这个线程占有着，其它连接的请求将得不到及时处理。&lt;/p&gt;

&lt;h2 id=&quot;aio概念介绍&quot;&gt;AIO概念介绍&lt;/h2&gt;
&lt;p&gt;AIO，Asynchronous IO，异步IO，JDK1.7开始支持，算是一种比较完美的IO，Windows下比较成熟，但Linux下还不太成熟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191119073510873-5027551.png&quot; alt=&quot;asynchronous-io&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用异步IO则会在请求时立即返回，并在数据已准备且已拷贝到用户空间后进行回调处理，两个阶段都不会阻塞。&lt;/p&gt;
&lt;h2 id=&quot;aio使用案例&quot;&gt;AIO使用案例&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EchoServer {
    public static void main(String[] args) throws IOException {
        AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open();
        serverSocketChannel.bind(new InetSocketAddress(8080));
        // 监听accept事件，本文来源公从号彤哥读源码
        serverSocketChannel.accept(null, new CompletionHandler&amp;lt;AsynchronousSocketChannel, Object&amp;gt;() {
            @Override
            public void completed(AsynchronousSocketChannel socketChannel, Object attachment) {
                try {
                    System.out.println(&quot;accept new conn: &quot; + socketChannel.getRemoteAddress());
                    // 再次监听accept事件
                    serverSocketChannel.accept(null, this);

                    // 消息的处理
                    while (true) {
                        ByteBuffer buffer = ByteBuffer.allocate(1024);
                        // 将数据读入到buffer中
                        Future&amp;lt;Integer&amp;gt; future = socketChannel.read(buffer);
                        if (future.get() &amp;gt; 0) {
                            buffer.flip();
                            byte[] bytes = new byte[buffer.remaining()];
                            // 将数据读入到byte数组中
                            buffer.get(bytes);

                            String content = new String(bytes, &quot;UTF-8&quot;);
                            // 换行符会当成另一条消息传过来
                            if (content.equals(&quot;\r\n&quot;)) {
                                continue;
                            }
                            if (content.equalsIgnoreCase(&quot;quit&quot;)) {
                                socketChannel.close();
                                break;
                            } else {
                                System.out.println(&quot;receive msg: &quot; + content);
                            }
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void failed(Throwable exc, Object attachment) {
                System.out.println(&quot;failed&quot;);
            }
        });

        // 阻塞住主线程
        System.in.read();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里同样使用telnet测试，而且你可以使用多个telnet来测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[c:\~]$ telnet 127.0.0.1 8080


Connecting to 127.0.0.1:8080...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.
hello world
我是人才
quit
Connection closed by foreign host.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AIO的使用方式不算太复杂，默认会启一组线程来处理用户的请求，而且如果在处理阻塞性任务，还会自动增加新的线程来处理其它连接的任务。&lt;/p&gt;
&lt;p&gt;首先，创建一个AsynchronousServerSocketChannel并调用其accept方法，这一步相当于监听了accept事件，在收到accept事件后会获取到AsynchronousSocketChannel，然后就可以在回调方法completed()里面读取数据了，当然也要继续监听accept事件。&lt;/p&gt;
&lt;p&gt;AIO最大的优点，就是少量的线程就可以处理大量的连接，而且可以处理阻塞性任务，但不能大量阻塞，否则线程数量会膨胀。&lt;/p&gt;

&lt;p&gt;（1）三种IO的实现方式中对于换行符的处理竟然都不一样，BIO中不会把换行符带过来（其实是带过来了，因为用了readLine()方法，所以换行符没了），NIO中会把换行符加在消息末尾，AIO中会把换行符当成一条新的消息传过来，很神奇，为啥不统一处理呢，也很疑惑。&lt;/p&gt;
&lt;p&gt;（2）JDK自带的ByteBuffer是一个难用的东西。&lt;/p&gt;

&lt;p&gt;本文我们从概念和使用两个角度分别介绍了BIO/NIO/AIO三种IO模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看起来JDK的实现似乎很完美啊，为什么还会有Netty呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，也欢迎来我的公从号&lt;strong&gt;彤哥读源码&lt;/strong&gt;系统地学习&lt;strong&gt;源码&amp;amp;架构&lt;/strong&gt;的知识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/code.gif&quot; alt=&quot;code&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 23:35:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>你好，我是彤哥，本篇是netty系列的第三篇。 简介 上一章我们介绍了IO的五种模型，实际上Java只支持其中的三种，即BIO/NIO/AIO。 本文将介绍Java中这三种IO的进化史，并从使用的角度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11886807.html</dc:identifier>
</item>
<item>
<title>设计模式（Java语言）-单例模式 - rainple</title>
<link>http://www.cnblogs.com/rainple/p/11886524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainple/p/11886524.html</guid>
<description>&lt;p&gt;　　单例模式，简而言之就是在整个应用程序里面有且仅有一个实例，在程序的任何时候，任何地方获取到的该对象都是同一个对象。单例模式解决了一个全局的类被频繁创建和销毁的，或者每次创建或销毁都需要消耗大量cpu资源的对象的问题。单例模式总的可以分为懒汉模式和饿汉模式，顾名思义，懒汉模式是一个非常懒的汉子，只要你没有使用到它，它就永远不会实例化。饿汉模式的意思就是，汉子非常饥渴，只要在程序的编译阶段就给你分配内存，创建好对象。&lt;/p&gt;
&lt;p&gt;　　将懒汉模式和饿汉模式细分，又可以分为：&lt;/p&gt;
&lt;p&gt;　　1、懒汉模式&lt;/p&gt;
&lt;p&gt;　　2、饿汉模式&lt;/p&gt;
&lt;p&gt;　　3、双检模式&lt;/p&gt;
&lt;p&gt;　　4、静态内部类模式&lt;/p&gt;
&lt;p&gt;　　5、枚举模式&lt;/p&gt;
&lt;p&gt;　　不管是用哪一种方式实现的单例模式，其创建流程基本都是一直的：首先将构造方法声明为private的，这样就防止直接new出一个新的对象。第二，声明一个私有的成员变量，即单例对象。第三步，声明一个public的静态方法，用于获取或创建单例对象，外部想要获取该对象必须通过这个方法获取。&lt;/p&gt;
&lt;p&gt;　　一、懒汉模式1--线程安全&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 饿汉模式1
 */
public class HungrySingleton1 {

    private static HungrySingleton1 singleton = new HungrySingleton1();

    private HungrySingleton1(){}

    public static HungrySingleton1 getInstance() {
        return singleton;
    }


}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种懒汉模式的优点是实现非常简单。缺点是并起到懒加载的效果，如果项目没有使用到这个对象的就会造成资源的浪费。&lt;/p&gt;

&lt;p&gt;　　二、饿汉模式1--线程不安全&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 懒汉模式1
 */
public class LazySingleton1 {

    private static LazySingleton1 singleton;

    private LazySingleton1(){}

    public static LazySingleton1 getInstance() {
        if (singleton == null) {
            singleton = new LazySingleton1();
        }
        return singleton;
    }


}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种写法虽然实现了懒加载的效果，但是严格意义上并不是单例模式，因为在多线程的环境下有可能会创建出多个不同的对象，至于为什么，不懂的可以看一下我之间写的关于Java内存模型的文章。这种写法只能应用于单线程的环境下，局限性很大。实际中强烈不建议使用这种方法。&lt;/p&gt;

&lt;p&gt;　　三、懒汉模式2--线程安全&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 懒汉模式2
 */
public class LazySingleton2 {

    private static LazySingleton2 singleton;

    private LazySingleton2(){}

    public static synchronized LazySingleton2 getInstance() {
        if (singleton == null) {
            singleton = new LazySingleton2();
        }
        return singleton;
    }


}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种写法咋看跟上面的方法一样，这种写法在方法上添加了 synchronized  关键字，这样就保证了每次只能有一个线程进入方法体中，解决了懒汉模式1中出现的问题。这种写法的优点是实现了懒加载的效果，缺点是效率非常低，当多个线程同时获取实例时，有可能会造成线程阻塞的情况。不推荐使用。&lt;/p&gt;

&lt;p&gt;　　懒汉模式3--线程不安全&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 懒汉模式3
 */
public class LazySingleton3 {

    private static LazySingleton3 singleton;

    private LazySingleton3(){}

    public static LazySingleton3 getInstance() {
        if (singleton == null) {
            synchronized (LazySingleton3.class) {
                if (singleton == null) {
                    singleton = new LazySingleton3();
                }
            }
        }
        return singleton;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种写法进行了两次 singleton == null 的判断，在实际的应用中当我们调用这个方法时，其实99%的几率是实例就已经创建好了，因此第一个 singleton == null 能过滤掉99%的调用，不用将方法锁起来，从而提高了效率。这种方法的优点是实现懒加载的效果，效率和很高。缺点是代码设计仍然后缺陷，jvm在为对象分配内存和赋值并不是一个原子操作，即 singleton = new LazySingleton3() 这段代码在jvm中是由三个步骤实现的，首先jvm会在堆中为对象分配一定的内存空间，然后完成对象的初始化工作，然后将内存地址指向到对象中。但是，我们知道，jvm在编译的时候并不总是根据我们编写的代码的顺序来执行了，而是根据jvm觉得最优的顺序执行（这个过程就叫做指令重排序），所以有可能在执行了步骤1后就执行了步骤3，这时候第二个线程进来的发现singleton并不为空，因此就直接返回了该对象，因此造成空指针异常。&lt;/p&gt;

&lt;p&gt;　　四、双重检查锁模式---线程安全&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 懒汉模式4
 */
public class LazySingleton4 {

    private volatile static LazySingleton4 singleton;

    private LazySingleton4(){}

    public static LazySingleton4 getInstance() {
        if (singleton == null) {
            synchronized (LazySingleton4.class) {
                if (singleton == null) {
                    singleton = new LazySingleton4();
                }
            }
        }
        return singleton;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　相较于上面的方式，这种方式只是在成员变量中添加了 volatile  关键字，解决了指令重排序的问题，同时确保当前线程修改了这个变量时，其他的线程能够及时读到最新的值。这种方法缺点是写起来比较复杂，要求程序员对jvm比较理解。优点是既保证了线程安全，同时也能够保证了比较高的效率。&lt;/p&gt;

&lt;p&gt;　　五、静态内部类模式--线程安全&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 懒汉模式5
 */
public class LazySingleton5 {

    private LazySingleton5(){}

    private static class Holder {
        private static final LazySingleton5 INSTANCE = new LazySingleton5();
    }

    public static LazySingleton5 getInstance() {
        return Holder.INSTANCE;
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种写法实现比较简单，即实现了懒加载的效果，同时也保证的多线程环境下的线程安全问题。推荐使用这种方式。&lt;/p&gt;

&lt;p&gt;　　六、枚举模式 -- 线程安全&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37.5&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 懒汉模式6
 */
public enum  LazySingleton6 {

   INSTANCE

}&lt;p&gt;//使用方法
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;6&quot;&gt;
public class Test {&lt;p&gt;public static void main(String[] args) {&lt;br/&gt;LazySingleton6 instance = LazySingleton6.INSTANCE;&lt;br/&gt;LazySingleton6 instance1 = LazySingleton6.INSTANCE;&lt;br/&gt;System.out.println(instance == instance1);&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　推荐写法，简单高效。充分利用枚举类的特性，只定义了一个实例，且枚举类是天然支持多线程的。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 16:10:00 +0000</pubDate>
<dc:creator>rainple</dc:creator>
<og:description>单例模式，简而言之就是在整个应用程序里面有且仅有一个实例，在程序的任何时候，任何地方获取到的该对象都是同一个对象。单例模式解决了一个全局的类被频繁创建和销毁的，或者每次创建或销毁都需要消耗大量cpu资</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rainple/p/11886524.html</dc:identifier>
</item>
</channel>
</rss>