<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>在 CentOS/Fedora 下安装 JAVA 环境 - kelsen</title>
<link>http://www.cnblogs.com/kelsen/p/10657596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kelsen/p/10657596.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;本教程将向您展示如何在 CentOS 7（6/6.5）、 Fedora、RHEL 上安装 Java。Java是一个流行的软件平台，允许您运行Java应用程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文涵盖了以下Java版本的安装：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OpenJDK 8&lt;/li&gt;
&lt;li&gt;Oracle Java 8&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;先决条件&quot;&gt;先决条件&lt;/h2&gt;
&lt;p&gt;在开始本指南之前，您应该有一个能够执行 root 权限命令的用户账户。&lt;/p&gt;
&lt;h2 id=&quot;java的变化&quot;&gt;Java的变化&lt;/h2&gt;
&lt;p&gt;Java平台有三个不同版本：标准版（SE）、企业版（EE）和微型版（ME）。本教程主要关注Java SE。&lt;/p&gt;
&lt;p&gt;可以安装两个不同的Java SE包：Java运行时环境（JRE）和Java Development Kit（JDK）。JRE是Java虚拟机（JVM）的一种实现，它允许您运行已编译的Java应用程序和applet。JDK包括JRE和开发和编译Java应用所需的其他软件。&lt;/p&gt;
&lt;p&gt;还有两种不同的Java实现：OpenJDK 和 Oracle Java。这两种实现都基于相同的代码，但 OpenJDK（Java的参考实现）是完全开源的，而Oracle Java包含一些专有代码。&lt;/p&gt;
&lt;p&gt;您可以在单个系统上安装各种版本的Java，但大多数人只需要一次安装。考虑到这一点，请尝试仅安装运行或开发应用程序所需的Java版本。&lt;/p&gt;
&lt;h2 id=&quot;安装openjdk-8&quot;&gt;安装OpenJDK 8&lt;/h2&gt;
&lt;p&gt;本节将向您展示如何使用yum包管理器安装预构建的OpenJDK 8 JRE和JDK包，这类似于Ubuntu / Debian的apt-get。&lt;/p&gt;
&lt;h3 id=&quot;安装openjdk-8-jre&quot;&gt;安装OpenJDK 8 JRE&lt;/h3&gt;
&lt;p&gt;要使用yum 安装OpenJDK 8 JRE，请运行以下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo yum install java-1.8.0-openjdk&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在确认提示下，输入y然后RETURN继续安装。&lt;/p&gt;
&lt;h3 id=&quot;安装openjdk-8-jdk&quot;&gt;安装OpenJDK 8 JDK&lt;/h3&gt;
&lt;p&gt;要使用 yum 安装OpenJDK 8 JDK，请运行以下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo yum install java-1.8.0-openjdk-devel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在确认提示下，输入y然后RETURN继续安装。&lt;/p&gt;
&lt;h3 id=&quot;安装oracle-java-8&quot;&gt;安装Oracle Java 8&lt;/h3&gt;
&lt;p&gt;本指南的这一部分将向您展示如何安装Oracle Java 8 JRE和JDK（64位）。&lt;strong&gt;注意：在安装Oracle Java之前，您必须接受Java SE的Oracle二进制代码许可协议，这是包含的步骤之一。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装oracle-java-8-jre&quot;&gt;安装Oracle Java 8 JRE&lt;/h3&gt;
&lt;p&gt;注意：要安装Oracle Java 8 JRE，您需要转到Oracle Java 8 JRE下载页面，接受许可协议，并复制相应Linux .rpm软件包的下载链接。替换复制的下载链接代替wget命令的突出显示部分。&lt;/p&gt;
&lt;p&gt;切换到您的主目录并使用以下命令下载Oracle Java 8 JRE RPM：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd ~
wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://link_copied_from_site&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用此yum命令安装RPM（如果您下载了其他版本，请在此处替换文件名）：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo yum localinstall jre-8u161-linux-x64.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在确认提示下，输入y然后RETURN继续安装。&lt;/p&gt;
&lt;p&gt;现在Java应该安装在&lt;code&gt;/usr/java/jre1.8.0_161/bin/java&lt;/code&gt;，并从&lt;code&gt;/usr/java/jre1.8.0_161/bin/java&lt;/code&gt;链接。&lt;/p&gt;
&lt;p&gt;您可以删除先前下载的存档文件：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;rm ~/jre-8u161-linux-x64.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装oracle-java-8-jdk&quot;&gt;安装Oracle Java 8 JDK&lt;/h3&gt;
&lt;p&gt;注意：要安装Oracle Java 8 JDK，您需要转到Oracle Java 8 JDK下载页面，接受许可协议，并复制相应Linux .rpm软件包的下载链接。替换复制的下载链接代替wget命令的突出显示部分。&lt;/p&gt;
&lt;p&gt;切换到您的主目录并使用以下命令下载Oracle Java 8 JDK RPM：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd ~
wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://link_copied_from_site&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用此yum命令安装RPM（如果您下载了其他版本，请在此处替换文件名）：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo yum localinstall jdk-8u161-linux-x64.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在确认提示下，输入y然后RETURN继续安装。&lt;/p&gt;
&lt;p&gt;现在Java应该安装在&lt;code&gt;/usr/java/jdk1.8.0_161/jre/bin/java&lt;/code&gt;，并从&lt;code&gt;/usr/java/jdk1.8.0_161/jre/bin/java&lt;/code&gt;链接。&lt;/p&gt;
&lt;p&gt;您可以删除先前下载的存档文件：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;rm ~/jdk-8u161-linux-x64.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设置默认java&quot;&gt;设置默认Java&lt;/h2&gt;
&lt;p&gt;如果您安装了多个版本的Java，则需要将其中的某一个设置为默认值（即用户运行java命令时将运行的版本）。此外，某些应用程序需要设置某些环境变量来定位要使用的Java安装。本节将向您展示如何执行此操作。&lt;/p&gt;
&lt;p&gt;顺便说一句，要检查默认Java的版本，请运行以下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ java -version&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用-alternatives&quot;&gt;使用 Alternatives&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;alternatives&lt;/code&gt; 命令通过符号链接管理默认命令，可用于选择默认Java命令。&lt;/p&gt;
&lt;p&gt;要打印提供java由其管理的命令的程序alternatives，请使用以下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo alternatives --config java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出应该类似以下结果：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;output
There are 5 programs which provide 'java'.

  Selection    Command
-----------------------------------------------
   1           java-1.7.0-openjdk.x86_64 (/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.161-2.6.12.0.el7_4.x86_64/jre/bin/java)
   2           java-1.8.0-openjdk.x86_64 (/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.151-5.b12.el7_4.x86_64/jre/bin/java)
   3           /usr/lib/jvm/jre-1.6.0-openjdk.x86_64/bin/java
*+ 4           /usr/java/jre-9.0.4/bin/java
   5           /usr/java/jdk-9.0.4/bin/java




Enter to keep the current selection[+], or type selection number: 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需输入选择号即可选择java默认情况下应使用的可执行文件。&lt;/p&gt;
&lt;h3 id=&quot;使用环境变量&quot;&gt;使用环境变量&lt;/h3&gt;
&lt;p&gt;许多Java应用程序使用JAVA_HOME或JRE_HOME环境变量来确定java要使用的可执行文件。&lt;/p&gt;
&lt;p&gt;例如，如果您安装Java在 &lt;code&gt;/usr/java/jdk1.8.0_161/jre/bin&lt;/code&gt;（即可java执行文件位于/usr/java/jdk1.8.0_161/jre/bin/java），您可以设置环境变量 JAVA_HOME 在bash shell或脚本中，如下所示：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;export JAVA_HOME=/usr/java/jdk1.8.0_161/jre&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要将环境变量 JAVA_HOME 在系统上为每个用户可用，请运行以下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo sh -c &quot;echo export JAVA_HOME=/usr/java/jdk1.8.0_161/jre &amp;gt;&amp;gt; /etc/environment&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;恭喜，您现在可以运行和/或开发Java应用程序了！&lt;/p&gt;
</description>
<pubDate>Thu, 04 Apr 2019 15:43:00 +0000</pubDate>
<dc:creator>kelsen</dc:creator>
<og:description>介绍 本教程将向您展示如何在 CentOS 7（6/6.5）、 Fedora、RHEL 上安装 Java。Java是一个流行的软件平台，允许您运行Java应用程序。 本文涵盖了以下Java版本的安装：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kelsen/p/10657596.html</dc:identifier>
</item>
<item>
<title>昂首阔步进入后互联网时代，我们有必要了解一下互联网是怎么互联的 - 土豆的奥特之父</title>
<link>http://www.cnblogs.com/xguo/p/10657584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xguo/p/10657584.html</guid>
<description>&lt;p&gt;在这个世界上有俩种人，一种是天天趴在网上，跟计算机网络亲密接触的人，另一种是天外飞仙，不食人间烟火，自然也不使用互联网的人😀。&lt;/p&gt;
&lt;p&gt;所以，无论你是互联网世界的新用户，或者，你已经投身互联网工作很长时间了，亦或是你每天喜欢使用计算机和网络的网民，你都应该了解基本的网络知识，特别是计算机网络。&lt;/p&gt;
&lt;p&gt;如果你维护过服务器，或者是一个服务端的开发者，你了解远程的用户是如何连接到你的服务器或者访问到你的服务的吗？&lt;br/&gt;发现大部分人的回答是模糊的，有的根本不明就理，所以，本文就尽可能多的来聊一聊，有关这类计算机网络与网络组件的基本知识。&lt;/p&gt;
&lt;p&gt;我们先来给计算机网络下个定义：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;计算机网络可以被定义为，借助于数据传输介质（例如电缆、光纤等），连接贯穿世界各地的计算机，并交换网络数据包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-container-fill&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201904/57355-20190404233520814-1397131216.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这个图中包含了基本的网络组成结构，和常见的网络设施，以及一些网络术语，例如：因特网Internet、互联网服务提供商ISPs、路由器Router等，我们接下来，看一下这些组件是如何工作的，以及之间的交互关系。&lt;/p&gt;
&lt;h2&gt;计算机网络常用术语&lt;/h2&gt;
&lt;h3&gt;网络节点&lt;/h3&gt;
&lt;p&gt;节点在计算机网络中的意思是各种计算设备，例如个人PC、移动手机、平板电脑、服务器等等，可用通过网络与类似的设备进行数据包的交换。&lt;/p&gt;
&lt;h3&gt;互联网协议&lt;/h3&gt;
&lt;p&gt;任何沟通都需要一致的沟通基础，我们通常称为 协议，例如人类沟通的协议，包括各种地方语言、手语、表情等，都是需要事先约定好的规则。&lt;/p&gt;
&lt;p&gt;而互联网是一个远距离传输信息的协议，在传输之前，需要先知道对方的位置。&lt;br/&gt;比如，你考虑在你女朋友过生日的时候，送她一份礼物，你需要先知道把礼物送到哪里，她的家庭或工作地址。&lt;/p&gt;
&lt;p&gt;如何给网络节点设置地址呢？&lt;br/&gt;任何技术都不是凭空产生的，必须踩着前人的肩膀，参考现有技术的启发，演变而来的。&lt;br/&gt;早期计算机科学家们，想通过唯一的ID，来识别网络中在计算机，他们想到了当今的电话号码（telephone number），由此，也想出了一个IP（Internet Protocol）的概念。&lt;/p&gt;
&lt;p&gt;这个IP是计算设备在计算机网络中的地址，从技术的角度来讲，它是一个用于标识这个网络设备的32位数字，所有的网络设备都基于它们的IP地址往返通信。&lt;/p&gt;
&lt;p&gt;例如你上传一个文件到一个网站，或者从一个网站下载一个文件。在网络通信中，文件会被转化成网络中若干个数据包，每个 “包” 含有网络节点的目的地（ip和端口，服务端操作系统收到这个包以后，进行按序拼接，之后交给监听这个端口的进程，也就是一个程序）。&lt;/p&gt;
&lt;p&gt;IP地址分为俩个类别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IPv4，由4组数字组成，二进制每组1kb，8bits，所以共32bits来定义一个IP地址，例如 104.244.42.129 这个ip地址是 twitter.com 的全球唯一地址，它一般是稳定不变的；&lt;/li&gt;
&lt;li&gt;IPv6，IPv6地址是继IPv4之后，由于网络设备大量涌现，IPv4出现不够用的情况，而定义的一个新的网络地址协议，基于8个16进制数，用“:”来分割，例如：2001:0cb8:85a3:0000:0000:8a2e:0370:7334，由于还不太稳定，目前没有被广泛使用，出于稳定性的考虑，目前互联网主要还是使用IPv4协议。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;IPv4，为了方便治理，对它进行了分类，包括Class A, B, C, D, E等五类，每个类别可分配不同数量的IP地址，使得路由表能够做的非常小, 路由器能够快速地处理网络转发，根据网络规模需求（例如设备的数量），采用不同的IP分类，得到更好的网络性能。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;777&quot; data-height=&quot;435&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201904/57355-20190404233532744-1500553900.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;em&gt;32位IP地址，用第一组数字来区分IP所属种类，更多关于IP分类的信息请自行科普“IP分类”，其实就是对所有的ip地址进行了人为分段&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;俩种类型的IPv4地址：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态， 随着时间的变化，这些设备的地址保持不变。例如一些远程服务器的ip地址通常是的固定不变的，确保用户每次都能访问到它。&lt;/li&gt;
&lt;li&gt;动态，一般来说，这些ip在网络中通常分配给普通计算机使用，例如在本地局域网中，内网设备的ip是由所在路由器来动态分配的，设备每次接入或者路由器从新启动，这些设备的ip地址都有可能发生变化。这个是DHCP(Dynamic Host Configuration Protocol）协议，一般路由器会集成这个服务。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要注意的一点，每个设备都有可能同时有几个ip地址，例如一台计算机同时连接了有线和无线网络，那它就有俩个ip地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;路由器&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;920&quot; data-height=&quot;527&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201904/57355-20190404233543816-2134359429.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;顾名思义，路由器是一个物理的网络组件，负责转发数据包到指定的目的网络设备。网络中的设备本身是不知道自己通信的对方的具体位置，由路由器根据路由器自身维护的路由表，加上数据包中的目的设备地址来转发数据包的请求。&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Routing &lt;span class=&quot;hljs-selector-tag&quot;&gt;table:
&lt;span class=&quot;hljs-selector-tag&quot;&gt;Destination  &lt;span class=&quot;hljs-selector-tag&quot;&gt;Gateway     &lt;span class=&quot;hljs-selector-tag&quot;&gt;Genmask        &lt;span class=&quot;hljs-selector-tag&quot;&gt;Flags &lt;span class=&quot;hljs-selector-tag&quot;&gt;Metric &lt;span class=&quot;hljs-selector-tag&quot;&gt;Refs &lt;span class=&quot;hljs-selector-tag&quot;&gt;Iface
&lt;span class=&quot;hljs-selector-tag&quot;&gt;default      192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.1 0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0        &lt;span class=&quot;hljs-selector-tag&quot;&gt;UG    1024   233  &lt;span class=&quot;hljs-selector-tag&quot;&gt;eth0
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0  *           255&lt;span class=&quot;hljs-selector-class&quot;&gt;.255&lt;span class=&quot;hljs-selector-class&quot;&gt;.255&lt;span class=&quot;hljs-selector-class&quot;&gt;.0  &lt;span class=&quot;hljs-selector-tag&quot;&gt;UC    0      0    &lt;span class=&quot;hljs-selector-tag&quot;&gt;wlan0
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0  *           255&lt;span class=&quot;hljs-selector-class&quot;&gt;.255&lt;span class=&quot;hljs-selector-class&quot;&gt;.255&lt;span class=&quot;hljs-selector-class&quot;&gt;.0  &lt;span class=&quot;hljs-selector-tag&quot;&gt;UH    0      2    &lt;span class=&quot;hljs-selector-tag&quot;&gt;eth0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Destination，目地设备的ip地址；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Gateway，网关，网络与网络连接的中间设备，例如俩台路由器的连接，然而，俩台路由器不能直接连接，需要借助另一台路由器，这台路由器就是网关。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;子网掩码（Genmask/Subnet mask），仅仅是为了划分网络，子网掩码结合ip地址可以分割成相对较小的ip逻辑区域，便于管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Flags，接入网络设备的标记，例如UG，U表示是路由器，G表示是网关。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Iface（网络接口），接入网络的网络类型，例如你的设备接入的Wifi，那这个网络接口就是“wlan”，如果接入的是有线LAN，那网络接口iface就是“eth”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以上主要是网络基础层面的内容，主要包括ip地址和路由器俩大网络核心技术，如何识别设备，以及设备彼此之间如何通信，接下来咱们看看如何实现更高层的技术应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;NAT&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;926&quot; data-height=&quot;759&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201904/57355-20190404233553189-108674148.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;Network Address Translation ，网络地址转换，为了让有限的公有ip连接更多网络设备，就需要用到NAT，网络地址转换，这个功能通常也是由路由器来实现。路由器一头与Internet服务商获取一个公网ip，另一头挂了很多网络设备，路由器为每一个设备分配一个内部私有的ip地址，只有这个路由器内部的设备之间可见，之外是无法与这些设备直接连接，需要通过路由器来转发信号，这就是NAT技术。&lt;br/&gt;例如，你在家里通过电脑访问Twitter，网络连接大概是这样的，电脑随机选择一个端口，去连接路由器，路由器随机选择一个端口去连接Twitter服务器，如下：&lt;/p&gt;
&lt;pre class=&quot;hljs ruby&quot;&gt;
&lt;code class=&quot;ruby&quot;&gt;Private IP   &lt;span class=&quot;hljs-params&quot;&gt;|PrivatePort |PublicIP &lt;span class=&quot;hljs-params&quot;&gt;|PublicPort |Remote &lt;span class=&quot;hljs-params&quot;&gt;|RemotePort
------------- ------------ --------- ----------- ------- -----------
192.168.1.100 | &lt;span class=&quot;hljs-number&quot;&gt;37641 &lt;span class=&quot;hljs-params&quot;&gt;| 104.244.42.129 | &lt;span class=&quot;hljs-number&quot;&gt;59273 &lt;span class=&quot;hljs-params&quot;&gt;| 104.244.42.129 | &lt;span class=&quot;hljs-number&quot;&gt;80
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Private IP 和 PrivatePort 是你电脑的ip和端口，PublicIP 和 PublicPort 是路由器的公有ip和路由器的端口，而 Remote 和 RemotePort 是Twitter服务器的ip和端口。&lt;/p&gt;
&lt;h2&gt;DHCP&lt;/h2&gt;
&lt;p&gt;DHCP，Dynamic Host Configuration Protocol，&lt;br/&gt;Internet网络服务商和路由器都有这个功能，为网络设备动态分配地址，例如你的电脑第一次接入路由器的时候，可有手动的设置一个静态的ip地址，也可有由路由器随机分配一个ip地址，当然，路由器与Internet服务商的网络连接的时候，也可有动态获取一个ip地址。&lt;/p&gt;
&lt;h2&gt;DNS&lt;/h2&gt;
&lt;p&gt;DNS，Domain Name System/Server，&lt;br/&gt;我们现在都知道，所有的网络设备都有ip地址，无论是公有ip还是私有ip，通过这个ip就可以访问响应的网络设备或者网络服务，例如，我们访问 &lt;code&gt;104.244.42.129&lt;/code&gt; 这个地址的时候就能打开Twitter的网站，因为这是Twitter服务器的ip地址。&lt;/p&gt;
&lt;p&gt;但是，这个地址没有可解释性，就是几个随机的数字，人类很难记忆，或者可被记住的数量非常有线，所有，DNS就应用而生了，其实就是一个翻译的过程，将ip地址和人类容易理解的文字相互转换，这些文字叫做 域名，例如google.com, twitter.com等，我们访问这些地址的时候，DNS会将其对应的ip地址找到，然后通过ip去访问对应的服务器。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1073&quot; data-height=&quot;601&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201904/57355-20190404233605514-2015125542.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;h4&gt;DNS是怎么工作的？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;DNS是由Internet网络服务商来管理和维护的；&lt;/li&gt;
&lt;li&gt;在自己的电脑或者路由器上配置DNS服务的地址；&lt;/li&gt;
&lt;li&gt;当我们在浏览器敲入一个地址的时候，浏览器会向DNS服务商询问这个域名对应的ip地址，如果这个DNS服务商没有找到，就会向上级询问，直到对顶层，如果还没有找到，就返回域名无效的信息。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;域名的结构：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1031&quot; data-height=&quot;413&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201904/57355-20190404233619103-1196015076.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;包括协议，域名名字，后缀等。&lt;/p&gt;
&lt;h2&gt;互联网服务提供商（ISPs）&lt;/h2&gt;
&lt;p&gt;注意，Internet 和 internet 不是同一个东西，&lt;br/&gt;internet是互联网，泛指所有可以互联互通的网络，而Internet是一个具体的互联网，叫因特网，就好比 人 和 黑人、白人、男人、女人的区别，一个是概念，一个是具象的东西。&lt;/p&gt;
&lt;p&gt;Internet是通过TCP/IP实现的internet，当然还有基于其他协议的internet，而，目前最大，应用范围最广的internet就是Internet（因特网）。&lt;/p&gt;
&lt;p&gt;而，ISPs（Internet Service Providers）就是Internet网络服务提供商，可以让人们很方便的接入Internet，实现与Internet互联，据说Internet的前身是ARPAnet，美国高等研究计划署开发的世界上第一个运营的网络，是全球Internet的鼻祖。&lt;/p&gt;
&lt;p&gt;Internet服务商是分层组织结构，包括1级、2级和3级，如下图：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1003&quot; data-height=&quot;694&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201904/57355-20190404233631433-1418864407.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;1级服务商是Internet的主要服务商，国际级别，这些互联网服务提供商通过海底的大电缆相互连接，并且为2级服务商提供接入的服务。&lt;/p&gt;
&lt;h2&gt;小结：&lt;/h2&gt;
&lt;p&gt;整个Internet的结构看起来如下图：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1032&quot; data-height=&quot;753&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201904/57355-20190404233643364-76354603.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;可见路由器是网络中非常重要的一个关键环节，对外通过公有ip相互通信，内部为各个设备分配私有的ip地址，然后通过NAT协议实现网络转发，形成了局域网。&lt;br/&gt;而不同的ISPs实现了上层网络的跨区域连接，形成了广域网，而最终形成的整张大网就是Internet，因特网，也就是我们天天都离不开的互联网。&lt;/p&gt;

&lt;p&gt;而，每个网络设备之间到底是如何传输数据，经过了哪些网络设备和转换，以及各种网络服务是如何，用什么方式对外提供的，这就是开放式系统互联通信模型（Open System Interconnection Reference Model，简称OSI），定义了不同设备互联的标准，是设计和描述计算机网络通信的基本框架。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1892&quot; data-height=&quot;1260&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201904/57355-20190404233652404-626356003.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fmedium.freecodecamp.org%2Fcomputer-networks-and-how-to-actually-understand-them-c1401908172d&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://medium.freecodecamp.org/computer-networks-and-how-to-actually-understand-them-c1401908172d&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 04 Apr 2019 15:40:00 +0000</pubDate>
<dc:creator>土豆的奥特之父</dc:creator>
<og:description>在这个世界上有俩种人，一种是天天趴在网上，跟计算机网络亲密接触的人，另一种是天外飞仙，不食人间烟火，自然也不使用互联网的人😀。 所以，无论你是互联网世界的新用户，或者，你已经投身互联网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xguo/p/10657584.html</dc:identifier>
</item>
<item>
<title>https://github.com/996icu/996.ICU/blob/master/blacklist/blacklist.md - 大激动</title>
<link>http://www.cnblogs.com/zhengze/p/10657535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengze/p/10657535.html</guid>
<description>&lt;p&gt;以实际行动声援996icu项目。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/996icu/996.ICU/blob/master/blacklist/blacklist.md&quot;&gt;https://github.com/996icu/996.ICU/blob/master/blacklist/blacklist.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;996公司黑名单，京东，华为等大公司赫然在列。&lt;/p&gt;
&lt;p&gt;加班最严重的公司是哪家？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/578402/201904/578402-20190404231116770-770542224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看看弱西是如何对待他口中的&quot;兄弟们&quot;的：&lt;a href=&quot;https://www.bianews.com/news/details?id=33843&quot;&gt;https://www.bianews.com/news/details?id=33843&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/578402/201904/578402-20190404235207343-1229516414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/578402/201904/578402-20190404235218670-2040934168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;弱西不会开除一个兄弟，开除的都不是兄弟。&lt;/p&gt;

&lt;p&gt;任正非，任老先生，我姑且尊重你一下，毕竟你年纪打了。&lt;/p&gt;
&lt;p&gt;你口中的“狼性文化”“奋斗精神”给谁洗脑呢？你真的以为员工都心甘情愿给你卖力？&lt;/p&gt;
&lt;p&gt;还逼着员工签什么“自愿奋斗”协议。&lt;a href=&quot;http://focus.news.163.com/10/0921/15/6H460OOP00011SM9.html&quot;&gt;http://focus.news.163.com/10/0921/15/6H460OOP00011SM9.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你们这种人嘴上说一套，背地里另一套。&lt;/p&gt;
&lt;p&gt;你们这些剥削阶级，不要把广大无产阶级逼急了。&lt;/p&gt;
&lt;p&gt;你，华为，枉为民族企业。&lt;/p&gt;
&lt;p&gt; 再来看苏宁，某领导(孙岩)指责技术负责人晚上十二点睡觉很养生。再说一遍，苏宁这位领导叫孙岩，孙岩，孙岩。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/UW63ZqpKxwlRL1/article/details/80970600&quot;&gt;https://blog.csdn.net/UW63ZqpKxwlRL1/article/details/80970600&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/578402/201904/578402-20190404234001479-285317229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/578402/201904/578402-20190404234110584-27517859.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由此不难想象，苏宁的员工每天都在过着什么样的日子。&lt;/p&gt;
&lt;p&gt;对于头条，员工晚上十一点能下班的都很开心。加班没什么，只要不猝死就---&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.douban.com/group/topic/118739214/?from=recommend&quot;&gt;https://www.douban.com/group/topic/118739214/?from=recommend&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;生命诚可贵，且行且珍惜。&lt;/p&gt;
</description>
<pubDate>Thu, 04 Apr 2019 15:17:00 +0000</pubDate>
<dc:creator>大激动</dc:creator>
<og:description>以实际行动声援996icu项目。 https://github.com/996icu/996.ICU/blob/master/blacklist/blacklist.md 996公司黑名单，京东，华为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhengze/p/10657535.html</dc:identifier>
</item>
<item>
<title>sprigcloud Eureka Server环境搭建 - cui5445</title>
<link>http://www.cnblogs.com/cuijiale/p/10657522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cuijiale/p/10657522.html</guid>
<description>&lt;p&gt;1、搭建springcloud的Erueka组件，现在搭建这些套件已经变的很方便了，进入https://start.spring.io/页面，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1060053/201904/1060053-20190404230250176-689396580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、选择好Eureka Server，点击Generate Project - alt下载demo&lt;/p&gt;
&lt;p&gt;3、解压demo.zip,打开idea导入下载好的模块，配置好maven&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1060053/201904/1060053-20190404230759823-2128813477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会引入需要导入的spring jar包，新导入的项目配置文件是没有详细的配置的；&lt;/p&gt;
&lt;p&gt;4、这里我们增加新的配置，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1060053/201904/1060053-20190404230951535-1994005056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置好后，还需加入Eureka注解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1060053/201904/1060053-20190404231059550-812240341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此注解标明该服务为Eureka的注册服务，一切准备好后，可以运行springboot项目了&lt;/p&gt;
&lt;p&gt;启动起来后可以访问http://localhost:7001/该地址，就可以看到Eureka注册信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1060053/201904/1060053-20190404231339587-159736938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一切ok！！！&lt;/p&gt;

</description>
<pubDate>Thu, 04 Apr 2019 15:15:00 +0000</pubDate>
<dc:creator>cui5445</dc:creator>
<og:description>1、搭建springcloud的Erueka组件，现在搭建这些套件已经变的很方便了，进入https://start.spring.io/页面，如下图： 2、选择好Eureka Server，点击Gen</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cuijiale/p/10657522.html</dc:identifier>
</item>
<item>
<title>排序思想 - 张小仑</title>
<link>http://www.cnblogs.com/zclun/p/10657518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zclun/p/10657518.html</guid>
<description>


&lt;h2&gt;冒泡排序：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;思想：&lt;/strong&gt;比较相邻元素，违反排序顺序则交换，每次冒出一个最大值，直到所有相对的最大值冒出，完成排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最基本的排序，不必多说。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复杂度：最坏：O(n*n)；最好：&lt;/strong&gt;O(n)；O(n*n)。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bubblesort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length - 1; i++) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; n-1趟&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; arr.length - 1 - i; j++) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每趟比n-1-i次&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (arr[j] &amp;gt; arr[j + 1&lt;span&gt;]) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; temp = arr[j + 1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                 arr[j + 1] =&lt;span&gt; arr[j];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 arr[j] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 快速排序：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;思想：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复杂度：&lt;/strong&gt;最坏：O(n*n)；最好：O(n*logn)；平均：O(n*logn)。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; quickSort(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; end) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (start &amp;gt; end)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出口&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; stard = arr[start];&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将数组的首值设为参照值&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; low = start;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录需要排序的下标&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; high =&lt;span&gt; end;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (low &amp;lt; high) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环找出比参照值大和小的数&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (low &amp;lt; high &amp;amp;&amp;amp; stard &amp;lt;= arr[high]) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右边的数比参照大&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 high--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }            
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             arr[low] = arr[high];&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时跳出内层循环遇到arr[high]&amp;lt;stard；用右边的数替换左边的数&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (low &amp;lt; high &amp;amp;&amp;amp; stard &amp;gt;= arr[low]) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左边的数比参照小&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 low++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         arr[high] = arr[low];&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时arr[low]&amp;gt;atard&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }    
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         arr[low] = stard;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将参照赋给low位置的数&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         quickSort(arr, start, low - 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理所有的小的数字&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         quickSort(arr, low + 1, end);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理所有的大的数字&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;



&lt;h2&gt;&lt;span&gt;简单插排：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;思想：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设待插入元素之前的元素已经是排序完成的，则每一步将一个待排序的元素，按其值的大小插入前面已经排序的序列中适当位置上，直到全部插入完为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中插入具体是指：对于待插入元素temp,如果i位置还不是插入合适的位置，则把i-1位置的元素填到i位置，直到找到合适的位置，或者遍历到0位置，将temp填在i位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复杂度：最坏：O(n*n)；最好：O(n*n)；平均：O(n*n)。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; arr.length; i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从第二个元素开始遍历&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (arr[i] &amp;lt; arr[i - 1]) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遇到当前元素比前一个元素小的情况&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; temp = arr[i]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存当前元素&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; j;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于遍历前面所有的情况&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; temp; j--) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 往前遍历，找到合适的插入位置&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                     arr[j + 1] =&lt;span&gt; arr[j];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 arr[j + 1] = temp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将保存的值存入，即插入到合适的位置，完成排序&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;希尔排序：&lt;span&gt;又称缩小增量排序&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;思想：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按除2递减的步长将序列分组，每组使用直接插排，直到每组都进行插排后完成排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复杂度：&lt;/strong&gt;最坏：O(n*logn*logn)；最好：O(n)；平均：取决于间隔序列。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shellSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历步长&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; step = arr.length / 2; step &amp;gt; 0; step /= 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次进行直接插入排序&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = step; i &amp;lt; arr.length; i +=&lt;span&gt; step) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (arr[i] &amp;lt; arr[i -&lt;span&gt; step]) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; arr[i];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (j = i - step; j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; temp; j -=&lt;span&gt; step) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         arr[j + step] =&lt;span&gt; arr[j];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     arr[j + step] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;3.&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 04 Apr 2019 15:13:00 +0000</pubDate>
<dc:creator>张小仑</dc:creator>
<og:description>一.几种排序思想 1.交换排序：冒泡排序与快速排序 冒泡排序： 思想：比较相邻元素，违反排序顺序则交换，每次冒出一个最大值，直到所有相对的最大值冒出，完成排序。 最基本的排序，不必多说。 复杂度：最坏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zclun/p/10657518.html</dc:identifier>
</item>
<item>
<title>机器学习——决策树，DecisionTreeClassifier参数详解，决策树可视化查看树结构 - Baby-Lily</title>
<link>http://www.cnblogs.com/baby-lily/p/10646226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baby-lily/p/10646226.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;0.决策树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;决策树是一种树型结构，其中每个内部节结点表示在一个属性上的测试，每一个分支代表一个测试输出，每个叶结点代表一种类别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　决策树学习是以实例为基础的归纳学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　决策树学习采用的是自顶向下的递归方法，其基本思想是以信息熵为度量构造一棵熵值下降最快的树。到叶子节点的处的熵值为零，此时每个叶结点中的实例都属于同一类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190402230404498-1592445748.jpg&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;298&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.决策树学习算法的特点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;决策树算法的最大优点是可以自学习。在学习的过程中，不需要使用者了解过多知识背景，只需要对训练实例进行较好的标注，就能够进行学习了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在决策树的算法中，建立决策树的关键，即在当前状态下选择哪个属性作为分类依据。根据不同的目标函数，建立决策树主要有一下三种算法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ID3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C4.5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CART&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;主要的区别就是选择的目标函数不同，ID3使用的是信息增益，C4.5使用信息增益率，CART使用的是Gini系数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.信息熵&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在信息论与概率统计中，熵(entropy)是表示随机变量不确定性的度量。设X是一个区有限个值的离散随机变量，其概率分布为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlcl9OyP6rI47lRwV1XwHX4rQiaNE3ofoIKd07yWhLRrUTHw1lIEfGGNLicA/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;201&quot; height=&quot;28&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclbrZJpRJl5Eiajiaicibicgmic3qmU1ftz2oUxAU2lNviaTXSWjk14LP6lnDVA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;603.5611510791367&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;84.0251798561151&quot; data-ratio=&quot;0.13930348258706468&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;603&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;则随机变量X的熵的定义为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclmYicH2zibz1VrKxqic74U7DRSibnm8Qv3hqGXic2OWywwTdFhRziaL0zu8Cw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;126&quot; height=&quot;40&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclXVzuviaic6ibUrRPu9jq3qPNCjIVqKWQa22yjVWF3OXO23sMiaMEiagABbA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;482.8381294964029&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;153.6798561151079&quot; data-ratio=&quot;0.31742738589211617&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;482&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在上述式中，若pi=0，则定义0log0=0，通常，式中的对数以2为底或者以e为底(自然对数)，这时熵的单位分别称作比特(bit)或者纳特(nat)。由定义可知，熵只依赖于X的分布，而与X的取值无关，所以也可以将X的熵记作H(p)，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclnHpZIqweLEO640aB8pcWPLk5Keia6vh67m9FgquRZ1NOEnNKEjVSEuQ/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;129&quot; height=&quot;40&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclx6aQI15pd3ha37pCgohSr5NluEDH93icM0EKWMs9DHZarEyBKavUH7g/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;466.863309352518&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;145.06474820143882&quot; data-ratio=&quot;0.3111587982832618&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;466&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　熵越大，随机变量的不确定性就越大。从定义可以验证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlcl8D4iaZKYcZuI29icia58gEo2ShAKt30puywfkUxP06gubicxxLCpEibvqBA/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;124&quot; height=&quot;27&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlcljCIBTpvW5RibWXt3qg0ndV5T76IQ4QAibbTgXSYo0qmzrWIQLnSsNWrQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;381&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;83&quot; data-ratio=&quot;0.2178477690288714&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当随机变量确定时，熵的值最小为0，当熵值最大时，随机变量不确定性最大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　设有随机变量（X,Y），其联合概率分布为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclFdGSoDzcG9I7cmLHdapibImS0L5Z6LJ70Zia13UsmzdTsdedzJY6uPDQ/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;35&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlcl94912ndALkbibd3iaObG536oTxNBC21dichUaRmdV5OUVWdtqreC5aaEA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1023.8309352517986&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;93.07553956834533&quot; data-ratio=&quot;0.09090909090909091&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性，随机变量X给定的条件下随机变量Y的条件熵H(Y|X)，定义为X给定条件下Y的条件概率分布的熵对X的数学期望：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclwM4ibBTQMDlLPvoHjvn3YWpADEFzMFvoqao2icfDmiaia2ufQYFpSWtCzg/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;193&quot; height=&quot;41&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclhhFO1E3fTES0NQzeVRejHWV9QI4tUC6dH9lfFmnNug5LOtQNdNS2ng/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;670.888489208633&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;142.05395683453236&quot; data-ratio=&quot;0.21194029850746268&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里，pi=P(X=xi)，i=1,2,......,n&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当熵和条件熵中的概率是有数据估计(极大似然估计)得到时，所对应的熵与条件熵分别称为经验熵和条件经验熵。此时，如果有0概率，则令0log0=0.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　信息增益表示得知特征X的信息而使得类Y的信息的不确定性减少的程度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;特征A对数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A的经验条件熵H(D|A)之差，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclLBcJUrBJG1VkXBffQibeJCetbibqCEjcoQYtJ5sF9ackdPUcbY4icfw3g/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;230&quot; height=&quot;31&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/lHFia39YNeNbcgEaV8D0ZYwZRRmxMvlclt3CuAl2gkffpnlVibQMvxzdYDic6Br2e4SPyfhYZfDTc2SbfJbcrKLZQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;616&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;83.09352517985612&quot; data-ratio=&quot;0.13474025974025974&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般地，熵H(Y)与条件熵H(Y|X)之差称为互信息。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.模型建立&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　具体的决策树算法流程，我们在这里就不仔细介绍了，详细算法可以参阅李航老师的《统计学习方法》一书。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;107&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib as mpl
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.tree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DecisionTreeClassifier
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; iris_type(s):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     it = {b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris-setosa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris-versicolor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1, b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris-virginica&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; it[s]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; iris_feature = u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;花萼长度&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;花萼宽度&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;花瓣长度&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;花瓣宽度&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     mpl.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font.sans-serif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = [u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SimHei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]  
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     mpl.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axes.unicode_minus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     path = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../dataSet/iris.data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据文件路径&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     data = np.loadtxt(path, dtype=float, delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, converters={4&lt;span&gt;: iris_type})
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     x_prime, y = np.split(data, (4,), axis=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     feature_pairs = [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3&lt;span&gt;]]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     plt.figure(figsize=(10, 9), facecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#FFFFFF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i, pair &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(feature_pairs):
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 准备数据&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         x =&lt;span&gt; x_prime[:, pair]
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 决策树学习&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         clf = DecisionTreeClassifier(criterion=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;entropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, min_samples_leaf=3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         dt_clf =&lt;span&gt; clf.fit(x, y)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 画图&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         N, M = 500, 500  
&lt;span&gt;33&lt;/span&gt;         x1_min, x1_max =&lt;span&gt; x[:, 0].min(), x[:, 0].max()  
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         x2_min, x2_max = x[:, 1].min(), x[:, 1&lt;span&gt;].max()  
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         t1 =&lt;span&gt; np.linspace(x1_min, x1_max, N)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         t2 =&lt;span&gt; np.linspace(x2_min, x2_max, M)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         x1, x2 =&lt;span&gt; np.meshgrid(t1, t2)  
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         x_test = np.stack((x1.flat, x2.flat), axis=1&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;   
&lt;span&gt;41&lt;/span&gt;         y_hat =&lt;span&gt; dt_clf.predict(x)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         y = y.reshape(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         c = np.count_nonzero(y_hat == y)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 统计预测正确的个数&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;特征：  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, iris_feature[pair[0]], &lt;span&gt;'&lt;/span&gt;&lt;span&gt; + &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, iris_feature[pair[1&lt;span&gt;]])
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t预测正确数目：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, c)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t准确率: %.2f%%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (100 * float(c) /&lt;span&gt; float(len(y))))
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 显示&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         cm_light = mpl.colors.ListedColormap([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#A0FFA0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#FFA0A0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#A0A0FF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         cm_dark = mpl.colors.ListedColormap([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         y_hat = dt_clf.predict(x_test)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 预测值&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;         y_hat =&lt;span&gt; y_hat.reshape(x1.shape)  
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         plt.subplot(2, 3, i+1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         plt.pcolormesh(x1, x2, y_hat, cmap=&lt;span&gt;cm_light) 
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         plt.scatter(x[:, 0], x[:, 1], c=y, edgecolors=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, cmap=&lt;span&gt;cm_dark)  
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         plt.xlabel(iris_feature[pair[0]], fontsize=14&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         plt.ylabel(iris_feature[pair[1]], fontsize=14&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        plt.xlim(x1_min, x1_max)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        plt.ylim(x2_min, x2_max)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        plt.grid()
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     plt.suptitle(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;决策树对鸢尾花数据的两特征组合的分类结果&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontsize=18&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     plt.tight_layout(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     plt.subplots_adjust(top=0.92&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在书面的代码中，为了可视化的方便，我们采用特征组合的方式，将鸢尾花的四个两两进行组合，分别建立决策树模型，并对其进行验证。&lt;/p&gt;
&lt;p&gt;　　DecisionTreeClassifier(criterion='entropy', min_samples_leaf=3)函数为创建一个决策树模型，其函数的参数含义如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;criterion&lt;/strong&gt;：gini或者entropy,前者是基尼系数，后者是信息熵。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;splitter&lt;/strong&gt;： best or random 前者是在所有特征中找最好的切分点 后者是在部分特征中，默认的”best”适合样本量不大的时候，而如果样本数据量非常大，此时决策树构建推荐”random” 。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;max_features&lt;/strong&gt;：None（所有），log2，sqrt，N  特征小于50的时候一般使用所有的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;max_depth&lt;/strong&gt;：  int or None, optional (default=None) 设置决策随机森林中的决策树的最大深度，深度越大，越容易过拟合，推荐树的深度为：5-20之间。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;min_samples_split&lt;/strong&gt;：设置结点的最小样本数量，当样本数量可能小于此值时，结点将不会在划分。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;min_samples_leaf&lt;/strong&gt;： 这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;min_weight_fraction_leaf&lt;/strong&gt;： 这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝默认是0，就是不考虑权重问题。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;max_leaf_nodes&lt;/strong&gt;： 通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;class_weight&lt;/strong&gt;： 指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多导致训练的决策树过于偏向这些类别。这里可以自己指定各个样本的权重，如果使用“balanced”，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;min_impurity_split&lt;/strong&gt;： 这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值则该节点不再生成子节点。即为叶子节点 。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　plt.suptitle(u'决策树对鸢尾花数据的两特征组合的分类结果', fontsize=18）设置整个大画布的标题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　plt.tight_layout(2) 调整图片的布局&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;em id=&quot;__mceDel&quot;&gt;plt.subplots_adjust(top=0.92)&lt;/em&gt; 自适应，绘图距顶部的距离为0.92&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190404211301573-1570911568.png&quot; alt=&quot;&quot; width=&quot;507&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;
















&lt;p&gt;不同的特征组合的决策树模型的准确率：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190404211448267-1193050386.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.决策树的保存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当我们通过建立好决策树之后，我们应该怎样查看建立好的决策树呢？sklearn已经帮助我们写好了方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt; tree  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;需要导入的包&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../dataSet/iris_tree.dot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; tree.export_graphviz(model.get_params(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DTC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DTC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], out_file=f)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们运行之后，程序会生成一个.dot的文件，我们能够通过word打开这个文件，你看到的是树节点的一些信息，我们通过graphviz工具能够查看树的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190404212618141-1516844978.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201904/1636554-20190404212716387-2063570666.png&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;385&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 04 Apr 2019 13:32:00 +0000</pubDate>
<dc:creator>Baby-Lily</dc:creator>
<og:description>0.决策树 决策树是一种树型结构，其中每个内部节结点表示在一个属性上的测试，每一个分支代表一个测试输出，每个叶结点代表一种类别。 决策树学习是以实例为基础的归纳学习 决策树学习采用的是自顶向下的递归方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baby-lily/p/10646226.html</dc:identifier>
</item>
<item>
<title>Java数据解析之JSON - 故事爱人</title>
<link>http://www.cnblogs.com/WUXIAOCHANG/p/10657050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WUXIAOCHANG/p/10657050.html</guid>
<description>&lt;h2&gt;文章大纲&lt;/h2&gt;
&lt;p&gt;一、JSON介绍&lt;br/&gt;二、常见框架介绍与实战&lt;br/&gt;三、Studio中GsonFormat插件使用&lt;br/&gt;四、项目源码下载（含参考资料）&lt;br/&gt;五、参考文档&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;817&quot; data-height=&quot;642&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-80f9c49a41eaf50b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/817/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-80f9c49a41eaf50b.png&quot; data-original-width=&quot;817&quot; data-original-height=&quot;642&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;101402&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;一、JSON介绍&lt;/h2&gt;
&lt;h3&gt;1. 简介&lt;/h3&gt;
&lt;p&gt;  JSON 的全称是 JavaScript Object Notation,是一种轻量级的数据交换格 式。&lt;/p&gt;
&lt;h3&gt;2. 特点&lt;/h3&gt;
&lt;p&gt;(1)JSON 比 XML 数据传输的有效性要高出很多&lt;br/&gt;(2)JSON 完全独立于编程语言&lt;br/&gt;(3)本质就是具有特定格式的字符串&lt;/p&gt;
&lt;h3&gt;3. JSON 数据格式&lt;/h3&gt;
&lt;p&gt;整体结构&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;String json1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;{&quot;&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;span class=&quot;hljs-string&quot;&gt;&quot;:12,&quot;name&lt;span class=&quot;hljs-string&quot;&gt;&quot;:&quot;Tom&lt;span class=&quot;hljs-string&quot;&gt;&quot;}&quot;
String json2 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;[{&quot;&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;span class=&quot;hljs-string&quot;&gt;&quot;:12,&quot;name&lt;span class=&quot;hljs-string&quot;&gt;&quot;:&quot;Tom&lt;span class=&quot;hljs-string&quot;&gt;&quot;},{&quot;&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;span class=&quot;hljs-string&quot;&gt;&quot;:12,&quot;name&lt;span class=&quot;hljs-string&quot;&gt;&quot;:&quot;Tom&lt;span class=&quot;hljs-string&quot;&gt;&quot;}]&quot;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Json 数组&lt;br/&gt;(1)Json 数组的结构: [value1, value2, value3]&lt;br/&gt;(2)例子:&lt;br/&gt;[1, “ab”,[], {“n”:123, “b”:”abc”}] 正确 [1, “a”:3] 错误&lt;/p&gt;
&lt;p&gt;Json 对象&lt;br/&gt;(1)Json 对象的结构: {key1:value1, key2:value2, key3:value3}&lt;br/&gt;(2)key 的数据类型: 字符串&lt;br/&gt;(3)value 的数据类型: 数值、字符串、null、json 数组 []、json 对象 {} (4)例子:&lt;br/&gt;{“name”:”TOM”,“age”:12} 正确 {“aa”:“a”, 3} 错误&lt;/p&gt;
&lt;h3&gt;4. 原始的JSON解析实战&lt;/h3&gt;
&lt;p&gt;将json格式的字符窜{}转换为java对象&lt;/p&gt;
&lt;p&gt;API:JsonObject&lt;br/&gt;JSONObject(String json) : 将 json 字符串解析为 json 对象&lt;br/&gt;Xxx getXxx(String name) : 根据 name, 在 json 对象中得到对应的 Value&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;jsonToJavaObjectByNative&lt;span class=&quot;hljs-params&quot;&gt;() {
        
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将json格式的字符窜{}转换为java对象的list&lt;/p&gt;
&lt;p&gt;API:JSONArray&lt;br/&gt;JSONArray(String json) : 将 json 字符串解析为 json 数组&lt;br/&gt;int length() : 得到 json 数组中元素的个数&lt;br/&gt;Xxx getXxx(int index) : 根据下标得到 json 数组中对应的元素数据&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;jsonToJavaListByNative&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂json数据解析&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;/&gt;
&lt;/pre&gt;
&lt;h2&gt;二、常见框架介绍与实战&lt;/h2&gt;
&lt;h3&gt;1. GSON&lt;/h3&gt;
&lt;p&gt;简介&lt;br/&gt;  GSON是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个Json字符转成一个Java对象，或者将一个Java转化为Json字符串。&lt;/p&gt;
&lt;p&gt;特点&lt;br/&gt;（1）快速、高效&lt;br/&gt;（2）代码量少、简洁&lt;br/&gt;（3）面向对象&lt;br/&gt;（4）数据传递和解析方便&lt;/p&gt;
&lt;h4&gt;代码实战&lt;/h4&gt;
&lt;p&gt;将 json 格式的字符串{}转换为 Java 对象&lt;br/&gt;（1）用到的 API&lt;br/&gt;  &amp;lt;T&amp;gt; T fromJson(String json, Class&amp;lt;T&amp;gt; classOfT);//将 json 对象转换为 Java 对象的方法&lt;br/&gt;  注意:要求 json 对象中的 key 的名称与 java 对象对应的类中的属性名要相同&lt;br/&gt;（2）使用步骤&lt;br/&gt;  将 Gson 的 jar 包导入到项目中&lt;br/&gt;  创建Gson对象 : Gson gson = new Gson(); (3)通过创建的Gson对象调用fromJson()方法,返回该JSON数据对应的Java对象&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;将json格式的字符窜{}转换为java对象的list&lt;br/&gt;（1）用到的 API&lt;br/&gt;  T fromJson(String json, Type typeOfT);//将 json 数组转换为 Java 对象的 list 注意:要求 json 对象中的 key 的名称与 java 对象对应的类中的属性名要相同&lt;br/&gt;（2）使用步骤&lt;br/&gt;  将 Gson 的 jar 包导入到项目中&lt;br/&gt;  创建Gson对象 : Gson gson = new Gson(); (3)通过创建的Gson对象调用fromJson()方法,返回该JSON数据对应的Java集合: List&amp;lt;ShopInfo&amp;gt; shops = gson.fromJson(json, new&lt;br/&gt;TypeToken&amp;lt;List&amp;lt;ShopInfo&amp;gt;&amp;gt;() {}.getType());&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;jsonToJavaListByGson&lt;span class=&quot;hljs-params&quot;&gt;() {
        
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将java对象转换为json字符窜&lt;br/&gt;（1）用到的 API&lt;br/&gt;  String toJson(Object src);&lt;br/&gt;（2）使用步骤&lt;br/&gt;  将 Gson 的 jar 包导入到项目中&lt;br/&gt;  创建Gson对象 : Gson gson = new Gson(); (3)通过创建的Gson对象调用toJson()方法,返回json数据:&lt;br/&gt;ShopInfo shop = new ShopInfo(1, &quot;鲍鱼&quot;, 250.0, &quot;&quot;); String json = gson.toJson(shop);&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;javaToJSONByGson&lt;span class=&quot;hljs-params&quot;&gt;() {
        
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 Java 对象的 List 转换为 json 字符串[]&lt;br/&gt;（1）用到的 API&lt;br/&gt;  String toJson(Object src);&lt;br/&gt;（2）使用步骤&lt;br/&gt;  将 Gson 的 jar 包导入到项目中&lt;br/&gt;  创建Gson对象 : Gson gson = new Gson(); (3)通过创建的Gson对象调用toJson()方法,返回json数据:&lt;br/&gt;List&amp;lt;ShopInfo&amp;gt; shops = new ArrayList&amp;lt;&amp;gt;(); String json = gson.toJson(shops);&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;/&gt;
&lt;/pre&gt;
&lt;h3&gt;2. FastJson&lt;/h3&gt;
&lt;p&gt;简介&lt;br/&gt;  在日常的java项目开发中，JSON的使用越来越频繁，对于Json的处理工具也有很多。接下来就介绍一下阿里开源的一个高性能的JSON框架FastJson，功能完善，完全支持&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fjson.org%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;标准JSON库&lt;/a&gt;，现在已经越来越受到开发者的青睐。&lt;/p&gt;
&lt;p&gt;2. 特点&lt;br/&gt;  Fastjson 是一个 Java 语言编写的高性能功能完善的 JSON 库。它采用一种“假定有序快速匹配”的算法,把JSONParse的性能提升到极致,是目前Java语言中最快的JSON库。&lt;/p&gt;
&lt;h4&gt;代码实战&lt;/h4&gt;
&lt;p&gt;将 json 格式的字符串{}转换为 Java 对象&lt;br/&gt;（1）用到的 API&lt;br/&gt;  &amp;lt; T &amp;gt; T parseObject(String json, Class&amp;lt;T&amp;gt; classOfT); //将 json 对象转换为 Java对象的方法&lt;br/&gt;  注意:要求 json 对象中的 key 的名称与 java 对象对应的类中的属性名要相同&lt;br/&gt;（2）使用步骤&lt;br/&gt;  导入 fastjson 的 jar 包 (2)JSON调用parseObject()方法,获取转换后的Java对象&lt;/p&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;code class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private void jsonToJavaObjectByFastJson() {

&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 json 格式的字符串[]转换为 Java 对象的 List&lt;br/&gt;（1）用到的 API&lt;br/&gt;  List&amp;lt;T&amp;gt; parseArray(String json,Class&amp;lt;T&amp;gt; classOfT);//将 json 数组转换为 Java 对象的 list&lt;br/&gt;  注意:要求 json 对象中的 key 的名称与 java 对象对应的类中的属性名要相同&lt;br/&gt;（2）使用步骤&lt;br/&gt;  导入 fastjson 的 jar 包 (2)JSON调用parseArray()方法,获取转换后的Java集合&lt;/p&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;code class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private void jsonToJavaListByFastJson() {

&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 Java 对象转换为 json 字符串&lt;br/&gt;（1）用到的 API&lt;br/&gt;  String toJSONString(Object object);&lt;br/&gt;（2）使用步骤&lt;br/&gt;  导入 fastjson 的 jar 包&lt;br/&gt;  JSON调用toJSONString()方法,获取转换后的json数据&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;javaToJsonObjectByFastJson&lt;span class=&quot;hljs-params&quot;&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 Java 对象的 List 转换为 json 字符串[]&lt;br/&gt;（1）用到的 API&lt;br/&gt;  String toJSONString(Object object);&lt;br/&gt;（2）使用步骤&lt;br/&gt;  导入 fastjson 的 jar 包&lt;br/&gt;  JSON调用toJSONString()方法,获取转换后的json数据&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;javaToJsonArrayByFastJson&lt;span class=&quot;hljs-params&quot;&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;三、Studio中GsonFormat插件使用&lt;/h2&gt;
&lt;h3&gt;1. GsonFormat是什么&lt;/h3&gt;
&lt;p&gt;  可根据xml内容快速生成bean类的插件&lt;/p&gt;
&lt;h3&gt;2. 使用方法&lt;/h3&gt;
&lt;p&gt;打开 Android studio 页面,点击设置按钮&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;729&quot; data-height=&quot;153&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-86e8b01fd4a04d83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/729/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-86e8b01fd4a04d83.png&quot; data-original-width=&quot;729&quot; data-original-height=&quot;153&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;74225&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;点击 Plugins 按钮&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;722&quot; data-height=&quot;481&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-b6929d772c420f45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/722/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-b6929d772c420f45.png&quot; data-original-width=&quot;722&quot; data-original-height=&quot;481&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;136793&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在右侧输入框中输入 gsonformat,然后点击中间部位的 Browse(必须在联网情况下点击)&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;716&quot; data-height=&quot;484&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-087470b684f9803d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/716/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-087470b684f9803d.png&quot; data-original-width=&quot;716&quot; data-original-height=&quot;484&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;83469&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;选择 GsonFormat,点击右侧的安装插件&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;717&quot; data-height=&quot;593&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-70614fcca4101205.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/717/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-70614fcca4101205.png&quot; data-original-width=&quot;717&quot; data-original-height=&quot;593&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;83148&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;重启一下 Android studio&lt;/p&gt;
&lt;p&gt;在 Android studio 中创建一个类&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;724&quot; data-height=&quot;219&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-fa3d2b3af5e8b275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/724/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-fa3d2b3af5e8b275.png&quot; data-original-width=&quot;724&quot; data-original-height=&quot;219&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;62138&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在该类中同时按下 alt+shift+s,并点击 GsonFormat&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;715&quot; data-height=&quot;473&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-968eadc855442b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/715/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-968eadc855442b35.png&quot; data-original-width=&quot;715&quot; data-original-height=&quot;473&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;58454&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;四、项目源码下载（含参考资料）&lt;/h2&gt;
&lt;p&gt;链接:&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F1PEz1jMc6B2CvB8HQn6A-pg&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1PEz1jMc6B2CvB8HQn6A-pg&lt;/a&gt;&lt;br/&gt;密码:rpjy&lt;/p&gt;
&lt;h2&gt;五、参考文档&lt;/h2&gt;

</description>
<pubDate>Thu, 04 Apr 2019 12:59:00 +0000</pubDate>
<dc:creator>故事爱人</dc:creator>
<og:description>文章大纲 一、JSON介绍二、常见框架介绍与实战三、Studio中GsonFormat插件使用四、项目源码下载（含参考资料）五、参考文档 一、JSON介绍 1. 简介 JSON 的全称是 JavaSc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WUXIAOCHANG/p/10657050.html</dc:identifier>
</item>
<item>
<title>并发系列（3）之 AbstractQueuedSynchronizer 源码分析 - 三枣</title>
<link>http://www.cnblogs.com/sanzao/p/10657020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanzao/p/10657020.html</guid>
<description>&lt;p&gt;本文将主要讲述 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 的内部结构和实现逻辑，在看本文之前最好先了解一下 &lt;code&gt;CLH&lt;/code&gt; 队列锁，&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 就是根据 &lt;code&gt;CLH&lt;/code&gt; 队列锁的变种实现的，因为本身 &lt;code&gt;AQS&lt;/code&gt; 比较复杂不容易看清楚他本身的实现逻辑，所以查看 &lt;code&gt;CLH&lt;/code&gt; 队列锁的实现，可以帮助我们理清楚他内部的关系；关于队列锁的内容可以参考 ，&lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10567529.html&quot;&gt;CLH、MCS 队列锁简介&lt;/a&gt; ；&lt;/p&gt;
&lt;h2 id=&quot;一aqs-结构概述&quot;&gt;一、AQS 结构概述&lt;/h2&gt;
&lt;p&gt;在 JDK 中除 &lt;code&gt;synchronized&lt;/code&gt; 内置锁外，其他的锁和同步组件，基本可以分为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;面向用户的逻辑部分（对于锁而言就是 Lock interface）；&lt;/li&gt;
&lt;li&gt;面向底层的线程调度部分；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 即同步队列则是 &lt;strong&gt;Doug Lea&lt;/strong&gt; 大神为我们提供的底层线程调度的封装；&lt;code&gt;AQS&lt;/code&gt; 本身是根据 &lt;code&gt;CLH&lt;/code&gt; 队列锁实现的，这一点在注释中有详细的介绍，&lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10567529.html&quot;&gt;CLH、MCS 队列锁简介&lt;/a&gt; ；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201904/1119937-20190404205201499-1704385750.png&quot; width=&quot;700&quot; alt=&quot;clh&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来讲，&lt;code&gt;CLH&lt;/code&gt; 队列锁就是一个单项链表，想要获取锁的线程封装为节点添加到尾部，然后&lt;strong&gt;阻塞检查前任节点的状态&lt;/strong&gt; （一定要注意是前任节点，因为这样更容易实现取消、超时等功能，同时这也是选择 CLH 队列锁的原因），而头结点则是当前已经&lt;strong&gt;获得锁的线程&lt;/strong&gt;，其主要作用是通知后继节点（也就是说在没有发生竞争的情况下，是不需要头结点的，这一点后面会详细分析）；&lt;/p&gt;

&lt;p&gt;而对于 &lt;code&gt;AQS&lt;/code&gt; 的结构大致可以表述为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201904/1119937-20190404204716176-1178569833.png&quot; width=&quot;700&quot; alt=&quot;clh&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
  protected AbstractQueuedSynchronizer() { }
  
  private transient volatile Node head;  // 懒加载，只有在发生竞争的时候才会初始化；
  private transient volatile Node tail;  // 同样懒加载；
  private volatile int state;  // 自定义的锁状态，可以用来表示锁的个数，以实现互斥锁和共享锁；
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的可以直观的看到链表结构的变化，其实next链表只是相当于遍历的优化，而node节点的变化才是主要的更新；&lt;/p&gt;
&lt;h3 id=&quot;node-结构&quot;&gt;1. Node 结构&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static final class Node {
  static final Node SHARED = new Node();  // 共享模式
  static final Node EXCLUSIVE = null;     // 互斥模式

  static final int CANCELLED =  1; // 表示线程取消获取锁
  static final int SIGNAL    = -1; // 表示后继节点需要被唤醒
  static final int CONDITION = -2; // 表示线程位于条件队列
  static final int PROPAGATE = -3; // 共享模式下节点的最终状态，确保在doReleaseShared的时候将共享状态继续传播下去

  /**
   * 节点状态（初始为0，使用CAS原则更新）
   * 互斥模式：0，SIGNAL，CANCELLED
   * 共享模式：0，SIGNAL，CANCELLED，PROPAGATE
   * 条件队列：CONDITION
   */
  volatile int waitStatus;
  
  volatile Node prev;     // 前继节点
  volatile Node next;     // 后继节点
  volatile Thread thread; // 取锁线程
  Node nextWaiter;        // 模式标识，取值：SHARED、EXCLUSIVE

  // Used by addWaiter，用于添加同队队列
  Node(Thread thread, Node mode) {   
    this.nextWaiter = mode;
    this.thread = thread;
  }

  // Used by Condition，同于添加条件队列
  Node(Thread thread, int waitStatus) { 
    this.waitStatus = waitStatus;
    this.thread = thread;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上面的代码和注释已经可以看到 &lt;code&gt;AQS&lt;/code&gt; 为我们提供了两种模式，独占模式和共享模式（彼此独立可以同时使用）；其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AbstractQueuedSynchronizer.state&lt;/code&gt; : 表示锁的资源状态，是我们上面所说的面向用户逻辑的部分；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Node.waitStatus&lt;/code&gt; ： 表示节点在队列中的状态，是面向底层线程调度的部分；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个变量一定要分清楚，在后面的代码中也很容易弄混；&lt;/p&gt;

&lt;h3 id=&quot;aqs-运行逻辑&quot;&gt;2. AQS 运行逻辑&lt;/h3&gt;
&lt;p&gt;AQS 的运行逻辑可以简单表述为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201904/1119937-20190404204753875-194981604.png&quot; width=&quot;800&quot; alt=&quot;AQS2&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你熟悉 &lt;code&gt;synchronized&lt;/code&gt; ，应该已经发现他们的运行逻辑其实是差不多的，都用同步队列和条件队列，值得注意的是这里的条件队列和 &lt;code&gt;Condition&lt;/code&gt; 一一对应，可能有多个；根据上图可以将 &lt;code&gt;AQS&lt;/code&gt; 提供的功能总结为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步状态的原子性管理；&lt;/li&gt;
&lt;li&gt;线程的阻塞与解除阻塞；&lt;/li&gt;
&lt;li&gt;队列的管理；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;入队&quot;&gt;3. 入队&lt;/h3&gt;
&lt;p&gt;因为独占模式和共享模式彼此独立可以同时使用，所以在入队的时候需要首先指定 &lt;code&gt;Node&lt;/code&gt; 的类型，同时入队的时候有竞争的可能，所以需要 CAS 入队；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Node addWaiter(Node mode) {
  Node node = new Node(Thread.currentThread(), mode); // SHARED、EXCLUSIVE
  // Try the fast path of enq; backup to full enq on failure
  Node pred = tail;
  if (pred != null) {
    node.prev = pred;
    if (compareAndSetTail(pred, node)) {
      pred.next = node;
      return node;
    }
  }
  enq(node);
  return node;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中注释也说明了，此处快速尝试入队，是一种优化手段，因为就一般情况而言大多数时候是没有竞争的；失败后在循环入队；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Node enq(final Node node) {
  for (;;) {
    Node t = tail;
    if (t == null) { // Must initialize
      if (compareAndSetHead(new Node())) // 此时head和tail才初始化
        tail = head;
    } else {
      node.prev = t;
      if (compareAndSetTail(t, node)) {
        t.next = node;
        return t;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而对于出队则稍微复杂一点，独占模式下直接出队，因为没有竞争；共享模式下，则需要 CAS 设置头结点，因为可能对有多个节点同时出队，同时还需要向后传播状态，保证后面的线程可以及时获得锁；此外还可能发生中断或者异常出队，此时则需要考虑头尾的情况，保证不会影响队列的结构；具体内容将会在源码中一次讲解；&lt;/p&gt;

&lt;h2 id=&quot;二独占模式&quot;&gt;二、独占模式&lt;/h2&gt;
&lt;h3 id=&quot;应用&quot;&gt;1. 应用&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Mutex implements Lock {
  private final Sync sync = new Sync();
  private static final int lock = 1;
  private static final int unlock = 0;

  @Override
  public void lock() {
    sync.acquire(lock);
  }

  @Override
  public boolean tryLock() {
    return sync.tryAcquire(lock);
  }

  @Override
  public void unlock() {
    sync.release(unlock);
  }

  private static class Sync extends AbstractQueuedSynchronizer {
    @Override
    protected boolean isHeldExclusively() {
      return getState() == lock;
    }

    @Override
    public boolean tryAcquire(int acquires) {
      if (compareAndSetState(unlock, lock)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
      }
      return false;
    }

    @Override
    protected boolean tryRelease(int releases) {
      if (getState() == unlock)
        throw new IllegalMonitorStateException();
      setExclusiveOwnerThread(null);
      setState(unlock);
      return true;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意代码中特意将 &lt;code&gt;AbstractQueuedSynchronizer.state&lt;/code&gt; 取值定为&lt;code&gt;lock\unlock&lt;/code&gt; ，主要是便于理解 &lt;code&gt;state&lt;/code&gt; 的含义，在互斥锁中可以任意取值，当然也可以是负数，但是一般情况下令其表示为锁的资源数量（也就是0、1）和共享模式对比，比较容易理解；&lt;/p&gt;
&lt;h3 id=&quot;获取锁&quot;&gt;2. 获取锁&lt;/h3&gt;
&lt;p&gt;对于独占模式取锁而言有一共有四中方式，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;tryAcquire：&lt;/strong&gt; 快速尝试取锁，成功时返回true；这是独占模式必须要重写的方法，其他方式获取锁时，也会先尝试快速获取锁；同时 &lt;code&gt;tryAcquire&lt;/code&gt; 也就决定了，这个锁时公平锁/非公平锁，可重入锁/不重冲入锁等；（比如上面的实例就是不可重入非公平锁，具体分析以后还会详细讲解）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;acquire：&lt;/strong&gt; 不响应中断，阻塞获取锁；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;acquireInterruptibly：&lt;/strong&gt; 响应中断，阻塞获取锁；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tryAcquireNanos：&lt;/strong&gt; 响应中断，超时阻塞获取锁；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;acquire-方法&quot;&gt;acquire 方法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;流程图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201904/1119937-20190404204830368-1538394766.png&quot; width=&quot;800&quot; alt=&quot;acquire&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码分析：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquire(int arg) {
  if (!tryAcquire(arg) &amp;amp;&amp;amp;                                                           // 首先尝试快速获取锁
       acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 失败后入队，然后阻塞获取
    selfInterrupt();                                  // 最后如果取锁的有中断，则重新设置中断
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
  boolean failed = true;
  try {
    boolean interrupted = false;           // 只要取锁过程中有一次中断，返回时都要重新设置中断
    for (;;) {
      final Node p = node.predecessor();   // 一直阻塞到前继节点为头结点
      if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {  // 获取同步状态
        setHead(node);                     // 设置头结点，此时头部不存在竞争，直接设置
        // next 主要起优化作用，并且在入队的时候next不是CAS设置
        // 也就是通过next不一定可以准确取到后继节点，所以在唤醒的时候不能依赖next，需要反向遍历
        p.next = null; // help GC          
        failed = false;
        return interrupted;
      }
      if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; // 判断并整理前继节点
        parkAndCheckInterrupt())                   // 当循环最多第二次的时候，必然阻塞
        interrupted = true;
    }
  } finally {
    if (failed)  // 异常时取消获取
      cancelAcquire(node);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
  int ws = pred.waitStatus;
  if (ws == Node.SIGNAL) return true;
  if (ws &amp;gt; 0) {  // 大于0说明，前继节点异常或者取消获取，直接跳过；
    do {
      node.prev = pred = pred.prev;  // 跳过pred并建立连接
    } while (pred.waitStatus &amp;gt; 0);
    pred.next = node;
  } else {
    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  // 标记后继节点需要唤醒
  }
  return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;node.prev = pred = pred.prev;&lt;/code&gt; 相关的内存分析可以查看 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10278070.html&quot;&gt;JAVA 连等赋值问题&lt;/a&gt;；&lt;/p&gt;

&lt;h4 id=&quot;acquireinterruptibly-方法&quot;&gt;acquireInterruptibly 方法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;流程图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201904/1119937-20190404204859630-923276691.png&quot; width=&quot;800&quot; alt=&quot;acquireInterruptibly&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码分析：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquireInterruptibly(int arg) throws InterruptedException {
  if (Thread.interrupted()) throw new InterruptedException();  // 中断退出
  if (!tryAcquire(arg))           // 获取同步状态
    doAcquireInterruptibly(arg);  // 中断获取
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void doAcquireInterruptibly(int arg) throws InterruptedException {
  final Node node = addWaiter(Node.EXCLUSIVE);   // 加入队尾
  boolean failed = true;
  try {
    for (;;) {
      final Node p = node.predecessor();
      if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
        setHead(node);
        p.next = null; // help GC
        failed = false;
        return;
      }
      if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;   // 判断并整理前继节点
        parkAndCheckInterrupt())                     // 等待
        throw new InterruptedException();
    }
  } finally {
    if (failed)
      cancelAcquire(node);
  }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;tryacquirenanos-方法&quot;&gt;tryAcquireNanos 方法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;流程图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201904/1119937-20190404204923647-1936820732.png&quot; width=&quot;800&quot; alt=&quot;tryAcquireNanos&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码分析：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {
  if (Thread.interrupted()) throw new InterruptedException();
  return tryAcquire(arg) ||
    doAcquireNanos(arg, nanosTimeout);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {
  if (nanosTimeout &amp;lt;= 0L) return false;
  final long deadline = System.nanoTime() + nanosTimeout;
  final Node node = addWaiter(Node.EXCLUSIVE);
  boolean failed = true;
  try {
    for (;;) {
      final Node p = node.predecessor();
      if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
        setHead(node);
        p.next = null; // help GC
        failed = false;
        return true;
      }
      nanosTimeout = deadline - System.nanoTime();
      if (nanosTimeout &amp;lt;= 0L) return false;          // 超时退出
      if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
        nanosTimeout &amp;gt; spinForTimeoutThreshold)
        LockSupport.parkNanos(this, nanosTimeout);
      if (Thread.interrupted())
        throw new InterruptedException();
    }
  } finally {
    if (failed)
      cancelAcquire(node);
  }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;释放锁&quot;&gt;3. 释放锁&lt;/h3&gt;
&lt;p&gt;释放锁时，判断有后继节点需要唤醒，则唤醒后继节点，然后退出；有唤醒的后继节点重新设置头结点，并标记状态&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final boolean release(int arg) {
  if (tryRelease(arg)) {   // 由用户重写，尝试释放
    Node h = head;
    if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
      unparkSuccessor(h);  // 唤醒后继节点
    return true;
  }
  return false;
}   &lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三共享模式&quot;&gt;三、共享模式&lt;/h2&gt;
&lt;h3 id=&quot;应用-1&quot;&gt;1. 应用&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ShareLock implements Lock {
  private Syn sync;

  public ShareLock(int count) { this.sync = new Syn(count); }

  @Override
  public void lock() { sync.acquireShared(1); }

  @Override
  public void lockInterruptibly() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
  }

  @Override
  public boolean tryLock() { return sync.tryAcquireShared(1) &amp;gt;= 0; }

  @Override
  public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireSharedNanos(1, unit.toNanos(time));
  }

  @Override
  public void unlock() { sync.releaseShared(1); }

  @Override
  public Condition newCondition() { throw new UnsupportedOperationException(); }

  private static final class Syn extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = 5854536238831876527L;
    Syn(int count) {
      if (count &amp;lt;= 0) {
        throw new IllegalArgumentException(&quot;count must large than zero.&quot;);
      }
      setState(count);
    }

    @Override
    public int tryAcquireShared(int reduceCount) {
      for (; ; ) {
        int current = getState();
        int newCount = current - reduceCount;
        //如果新的状态小于0 则返回值，则表示没有锁资源，直接返回
        if (newCount &amp;lt; 0 || compareAndSetState(current, newCount)) {
          return newCount;
        }
      }
    }

    @Override
    public boolean tryReleaseShared(int retrunCount) {
      for (; ; ) {
        int current = getState();
        int newCount = current + retrunCount;
        if (compareAndSetState(current, newCount)) {
          return true;
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中的 &lt;code&gt;AbstractQueuedSynchronizer.state&lt;/code&gt; 表示锁的资源数，但是仍然是不可重入的；&lt;/p&gt;

&lt;h3 id=&quot;获取锁-1&quot;&gt;2. 获取锁&lt;/h3&gt;
&lt;p&gt;同样对于共享模式取锁也有四中方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;tryAcquireShared：&lt;/strong&gt; 快速尝试取锁，由用户重写&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;acquireShared：&lt;/strong&gt; 不响应中断，阻塞获取锁；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;acquireSharedInterruptibly：&lt;/strong&gt; 响应中断，阻塞获取锁；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tryAcquireSharedNanos：&lt;/strong&gt; 响应中断，超时阻塞获取锁；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;tryacquireshared-方法&quot;&gt;tryAcquireShared 方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public int tryAcquireShared(int reduceCount) {
  for (; ; ) {
    int current = getState();
    int newCount = current - reduceCount;
    //如果新的状态小于0 则返回值，则表示没有锁资源，直接返回
    if (newCount &amp;lt; 0 || compareAndSetState(current, newCount)) {
      return newCount;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;tryAcquireShared&lt;/code&gt; 方法是快速尝试获取锁，并更新锁状态，如果失败则必然锁资源不足，返回负值；&lt;/p&gt;
&lt;h4 id=&quot;acquireshared-方法&quot;&gt;acquireShared 方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquireShared(int arg) {
  if (tryAcquireShared(arg) &amp;lt; 0)  // 快速获取失败
    doAcquireShared(arg);         // 阻塞获取锁
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void doAcquireShared(int arg) {
  final Node node = addWaiter(Node.SHARED);
  boolean failed = true;
  try {
    boolean interrupted = false;
    for (;;) {
      final Node p = node.predecessor();
      if (p == head) {
        int r = tryAcquireShared(arg);
        if (r &amp;gt;= 0) {
          setHeadAndPropagate(node, r);     // 设置头结点，并是情况将信号传播下去
          p.next = null; // help GC
          if (interrupted) selfInterrupt(); // 重新设置中断状态
          failed = false;
          return;
        }
      }
      if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
        parkAndCheckInterrupt())
        interrupted = true;
    }
  } finally {
    if (failed)
      cancelAcquire(node);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// propagate 表示线程获取锁后，共享锁剩余的锁资源
private void setHeadAndPropagate(Node node, int propagate) {
  Node h = head; // Record old head for check below
  setHead(node);
  
  // propagate &amp;gt; 0 ：表示还有剩余的资源
  // h.waitStatus &amp;lt; 0 ： 表示后继节点需要被唤醒
  // 其余还做了很多保守判断，确保后面的节点能及时那到锁
  if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
    (h = head) == null || h.waitStatus &amp;lt; 0) {
    Node s = node.next;
    if (s == null || s.isShared())
      doReleaseShared();  // 唤醒后继节点
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上面的代码可以看到，共享模式和独占模式获取锁的主要区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享模式可以有多个锁&lt;/li&gt;
&lt;li&gt;设置头结点的时候，同时还要将状态传播下去&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其余的思路和独占模式差不多，他家可以自己看源码；&lt;/p&gt;
&lt;h3 id=&quot;释放锁-1&quot;&gt;3. 释放锁&lt;/h3&gt;
&lt;p&gt;同样 &lt;code&gt;tryReleaseShared&lt;/code&gt; 是由用户自己重写的，这里需要注意的是如果不能确保释放成功（因为共享模式释放锁的时候可能有竞争，所以可能失败），则在外层 &lt;code&gt;Lock&lt;/code&gt; 接口使用的时候，就需要额外处理；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public boolean tryReleaseShared(int retrunCount) {
  for (; ; ) {
    int current = getState();
    int newCount = current + retrunCount;
    if (compareAndSetState(current, newCount)) {
      return true;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;releaseshared-方法&quot;&gt;&lt;strong&gt;releaseShared 方法&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final boolean releaseShared(int arg) {
  if (tryReleaseShared(arg)) {  // 尝试取锁成功，此时锁资源已重新设置
    doReleaseShared();          // 唤醒后继节点
    return true;
  }
  return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;doReleaseShared&lt;/code&gt; 方法必然执行两次，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一次头结点释放锁，然后唤醒后继节点&lt;/li&gt;
&lt;li&gt;第二次后继设置头结点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终使得头结点的状态必然是 &lt;code&gt;PROPAGATE&lt;/code&gt;；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void doReleaseShared() {
  for (;;) {
    Node h = head;
    if (h != null &amp;amp;&amp;amp; h != tail) {
      int ws = h.waitStatus;
      if (ws == Node.SIGNAL) {
        if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
          continue;      // loop to recheck cases
        unparkSuccessor(h);
      }
      else if (ws == 0 &amp;amp;&amp;amp;
           !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
        continue;        // loop on failed CAS
    }
    if (h == head)       // loop if head changed
      break;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四条件队列&quot;&gt;四、条件队列&lt;/h2&gt;
&lt;h3 id=&quot;conditionobject-结构&quot;&gt;1. ConditionObject 结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201904/1119937-20190404204956597-1049427624.png&quot; width=&quot;800&quot; alt=&quot;condition&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ConditionObject implements Condition, java.io.Serializable {
  private transient Node firstWaiter;
  private transient Node lastWaiter;
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如代码所示条件队列是一个由 &lt;code&gt;Node&lt;/code&gt; 组成的链表，注意这里的链表不同于同步队列，是通过 &lt;code&gt;nextWaiter&lt;/code&gt; 连接的，在同步队列中 &lt;code&gt;nextWaiter&lt;/code&gt; 用来表示独占和共享模式，所以区分条件队列的方法就有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Node.waitStatus = Node.CONDITION；&lt;/li&gt;
&lt;li&gt;Node.next = null &amp;amp; Node.prev= null；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;await&quot;&gt;2. await&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void await() throws InterruptedException {
  if (Thread.interrupted()) throw new InterruptedException();
  Node node = addConditionWaiter();     // 添加节点到条件队列
  int savedState = fullyRelease(node);  // 确保释放锁，并唤醒后继节点
  int interruptMode = 0;
  while (!isOnSyncQueue(node)) {        // node 不在同步队列中
    LockSupport.park(this);             // 阻塞
    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
      break;
  }
  if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
    interruptMode = REINTERRUPT;
  if (node.nextWaiter != null) // clean up if cancelled
    unlinkCancelledWaiters();
  if (interruptMode != 0)
    reportInterruptAfterWait(interruptMode);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;signal&quot;&gt;3. signal&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void signal() {
  if (!isHeldExclusively()) throw new IllegalMonitorStateException();
  Node first = firstWaiter;
  if (first != null)  
    doSignal(first);  // 从头结点一次唤醒
}

private void doSignal(Node first) {
  do {
    if ( (firstWaiter = first.nextWaiter) == null)
      lastWaiter = null;
    first.nextWaiter = null;
  } while (!transferForSignal(first) &amp;amp;&amp;amp;  // 将节点移动到同步节点中
       (first = firstWaiter) != null);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为篇幅有点长了，所以条件队列讲的也就相对简单了一点，但是大体的思路还是讲了；&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;AbstractQueuedSynchronizer 通过私有变量继承方式使用&lt;/li&gt;
&lt;li&gt;观察 AbstractQueuedSynchronizer ，其实和 synchronized 的结构基本相同，但是 synchronized 还会自动根据使用情况进行锁升级&lt;/li&gt;
&lt;li&gt;此外本文的主要参考资料是《java 并发编程的艺术》，有兴趣的可以自行查看；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 04 Apr 2019 12:51:00 +0000</pubDate>
<dc:creator>三枣</dc:creator>
<og:description>本文将主要讲述 的内部结构和实现逻辑，在看本文之前最好先了解一下 队列锁， 就是根据 队列锁的变种实现的，因为本身 比较复杂不容易看清楚他本身的实现逻辑，所以查看 队列锁的实现，可以帮助我们理清楚他内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanzao/p/10657020.html</dc:identifier>
</item>
<item>
<title>海思uboot启动流程详细分析（二） - yooooooo</title>
<link>http://www.cnblogs.com/linhaostudy/p/10656968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linhaostudy/p/10656968.html</guid>
<description>&lt;h2 id=&quot;第二个start.s&quot;&gt;1. 第二个start.S&lt;/h2&gt;
&lt;p&gt;从&lt;code&gt;start_armboot&lt;/code&gt;开始，在&lt;code&gt;startup.c&lt;/code&gt;中有包含&lt;code&gt;#include &amp;lt;config.h&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在config.h中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Automatically generated - do not edit */
#define CONFIG_BOARDDIR board/hisilicon/hi3559av100
#include &amp;lt;config_defaults.h&amp;gt;
#include &amp;lt;config_uncmd_spl.h&amp;gt;
#include &amp;lt;configs/hi3559av100.h&amp;gt;
#include &amp;lt;asm/config.h&amp;gt;
#include &amp;lt;config_fallbacks.h&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;hi3559av100.h&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define CONFIG_SYS_TEXT_BASE            0x48800000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;hi3559av100.h&lt;/code&gt;中，看到了&lt;code&gt;CONFIG_SYS_TEXT_BASE&lt;/code&gt;的宏&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* CONFIG_SYS_TEXT_BASE needs to align with where ATF loads bl33.bin */
#define CONFIG_SYS_TEXT_BASE        0x48800000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看u-boot.map在这里又来到了上一层的start.S中来，所以可以知道这两个是由两个文件组成的，一个是u-boot.bin和reg_info.bin，就是说两个不同的start.S的流程来合成一个最终的&lt;code&gt;u-boot-hi3559av100.bin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个便是正常的流程了：&lt;/p&gt;
&lt;p&gt;本文将结合u-boot的“board—&amp;gt;machine—&amp;gt;arch—&amp;gt;cpu”框架，介绍u-boot中平台相关部分的启动流程。并通过对启动流程的简单分析，掌握u-boot移植的基本方法。&lt;/p&gt;
&lt;h2 id=&quot;多平台架构&quot;&gt;2. 多平台架构&lt;/h2&gt;
&lt;p&gt;这些问题的本质，是软件工程中的抽象和封装，以最简洁、最高效的方式，实现尽可能多的功能。u-boot作为一个跨平台、跨设备的bootloader，同样会面临这些问题。它的解决方案，就是“board—&amp;gt;machine—&amp;gt;arch—&amp;gt;cpu”框架，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.wowotech.net/content/uploadfile/201605/e7215155d7155fe2ab1797c385af49ba20160519144243.gif&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于图片1的架构，u-boot和平台有关的初始化流程，显得比较直观、清晰：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;1）u-boot启动后，会先执行CPU（如armv8）的初始化代码。&lt;/p&gt;
&lt;p&gt;2）CPU相关的代码，会调用ARCH的公共代码（如arch/arm）。&lt;/p&gt;
&lt;p&gt;3）ARCH的公共代码，在适当的时候，调用board有关的接口。u-boot的功能逻辑，大多是由common代码实现，部分和平台有关的部分，则由公共代码声明，由board代码实现。&lt;/p&gt;
&lt;p&gt;4）board代码在需要的时候，会调用machine（arch/arm/mach-xxx）提供的接口，实现特定的功能。因此machine的定位是提供一些基础的代码支持，不会直接参与到u-boot的功能逻辑中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;平台相关部分的启动流程分析&quot;&gt;3. 平台相关部分的启动流程分析&lt;/h2&gt;
&lt;p&gt;本文先不涉及u-boot和平台相关的Kconfig/Makefile部分，以ARM64为例，假定u-boot首先从“arch/arm/cpu/armv8/start.S”的_start接口开始执行。因此我们从_start开始分析。&lt;/p&gt;
&lt;h3 id=&quot;start-_start是u-boot启动后的第一个执行地址对armv8来说它只是简单的跳转到reset处执行如下&quot;&gt;3.1 _start&lt;br/&gt;_start是u-boot启动后的第一个执行地址，对armv8来说，它只是简单的跳转到reset处执行，如下：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;.globl  _start
_start:
    b   reset&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reset&quot;&gt;3.2 reset&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;reset:
    /* Allow the board to save important registers */
    b   save_boot_params
.globl  save_boot_params_ret
save_boot_params_ret:

#ifdef CONFIG_SYS_RESET_SCTRL
    bl reset_sctrl
#endif
    /*
     * Could be EL3/EL2/EL1, Initial State:
     * Little Endian, MMU Disabled, i/dCache Disabled
     */
    adr x0, vectors
    switch_el x1, 3f, 2f, 1f
3:  msr vbar_el3, x0
    mrs x0, scr_el3
    orr x0, x0, #0xf            /* SCR_EL3.NS|IRQ|FIQ|EA */
    msr scr_el3, x0
    msr cptr_el3, xzr           /* Enable FP/SIMD */
#ifdef COUNTER_FREQUENCY
    ldr x0, =COUNTER_FREQUENCY
    msr cntfrq_el0, x0          /* Initialize CNTFRQ */
#endif
    b   0f
2:  msr vbar_el2, x0
    mov x0, #0x33ff
    msr cptr_el2, x0            /* Enable FP/SIMD */
    b   0f
1:  msr vbar_el1, x0
    mov x0, #3 &amp;lt;&amp;lt; 20
    msr cpacr_el1, x0           /* Enable FP/SIMD */
0:

    /* Apply ARM core specific erratas */
    bl  apply_core_errata

    /*
     * Cache/BPB/TLB Invalidate
     * i-cache is invalidated before enabled in icache_enable()
     * tlb is invalidated before mmu is enabled in dcache_enable()
     * d-cache is invalidated before enabled in dcache_enable()
     */

    /* Processor specific initialization */
    bl  lowlevel_init&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）reset SCTRL寄存器&lt;/p&gt;
&lt;p&gt;具体可参考reset_sctrl函数，由CONFIG_SYS_RESET_SCTRL控制，一般不需要打开。该配置项的解释如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5.6&quot;&gt;
&lt;p&gt;Reset the SCTRL register at the very beginning of execution to avoid interference from stale mappings set up by early firmware/loaders/etc.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://lists.denx.de/pipermail/u-boot/2015-April/211147.html&quot; class=&quot;uri&quot;&gt;http://lists.denx.de/pipermail/u-boot/2015-April/211147.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2）根据当前的EL级别，配置中断向量、MMU、Endian、i/d Cache等。&lt;/p&gt;
&lt;p&gt;3）配置ARM的勘误表&lt;/p&gt;
&lt;p&gt;具体可参考apply_core_errata函数，由CONFIG_ARM_ERRATA_XXX控制，在项目的初期，可以不打开，后续根据实际情况打开）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;就是ARM有一些bug，但可以通过软件的方法绕过去，由u-boot的代码注释可知，应该只有Cortex-A57才有。具体什么bug，我也没有去研究&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4）调用lowlevel_init的功能解释如下（具体可参考u-boot的readme文档）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;purpose: essential init to permit execution to reach board_init_f()&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code&gt;   - no global_data or BSS

   - there is no stack (ARMv7 may have one but it will soon be removed)

   - must not set up SDRAM or use console

   - must only do the bare minimum to allow execution to continue to

           board_init_f()

   - this is almost never needed

   - return normally from this function&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;海思的和原生uboot代码的start.S其实就是增加以下内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811006/201904/811006-20190404203234679-1314850758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5）如果是多CPU的场景，处理其它的CPU的boot&lt;/p&gt;
&lt;p&gt;多CPU功能由CONFIG_ARMV8_MULTIENTRY控制，不需要打开。&lt;/p&gt;
&lt;p&gt;6）跳转到arm公共的_main中执行&lt;/p&gt;
&lt;p&gt;ARM64平台的_main位于crt0_64.S文件中，具体请参考下面的描述。&lt;/p&gt;
&lt;h3 id=&quot;main&quot;&gt;3.3 _main&lt;/h3&gt;
&lt;p&gt;crt0是C-runtime Startup Code的简称，意思就是运行C代码之前的准备工作。关于_main函数，crt0_64.S中有非常详细的注释（这一点要给u-boot点100个赞！），大家可以参考。该函数的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ENTRY(_main)

/*
 * Set up initial C runtime environment and call board_init_f(0).
 */
#if defined(CONFIG_SPL_BUILD) &amp;amp;&amp;amp; defined(CONFIG_SPL_STACK)
    ldr x0, =(CONFIG_SPL_STACK)
#else
    ldr x0, =(CONFIG_SYS_INIT_SP_ADDR)
#endif
    bic sp, x0, #0xf/* 16-byte alignment for ABI compliance */
    mov x0, sp
    bl  board_init_f_alloc_reserve
    mov sp, x0
    /* set up gd here, outside any C code */
    mov x18, x0
    bl  board_init_f_init_reserve

    mov x0, #0
    bl  board_init_f

#if !defined(CONFIG_SPL_BUILD)
/*
 * Set up intermediate environment (new sp and gd) and call
 * relocate_code(addr_moni). Trick here is that we'll return
 * 'here' but relocated.
 */
    ldr x0, [x18, #GD_START_ADDR_SP]/* x0 &amp;lt;- gd-=&quot;&quot;&amp;gt;start_addr_sp */
    bic sp, x0, #0xf/* 16-byte alignment for ABI compliance */
    ldr x18, [x18, #GD_BD]      /* x18 &amp;lt;- gd-=&quot;&quot;&amp;gt;bd */
    sub x18, x18, #GD_SIZE      /* new GD is below bd */

    adr lr, relocation_return
    ldr x9, [x18, #GD_RELOC_OFF]    /* x9 &amp;lt;- gd-=&quot;&quot;&amp;gt;reloc_off */
    add lr, lr, x9/* new return address after relocation */
    ldr x0, [x18, #GD_RELOCADDR]    /* x0 &amp;lt;- gd-=&quot;&quot;&amp;gt;relocaddr */
    b   relocate_code

relocation_return:

/*
 * Set up final (full) environment
 */
    bl  c_runtime_cpu_setup /* still call old routine */

/* TODO: For SPL, call spl_relocate_stack_gd() to alloc stack relocation */

/*
 * Clear BSS section
 */
    ldr x0, =__bss_start    /* this is auto-relocated! */
    ldr x1, =__bss_end  /* this is auto-relocated! */
    mov x2, #0
clear_loop:
    str x2, [x0]
    add x0, x0, #8
    cmp x0, x1
    b.lo    clear_loop

    /* call board_init_r(gd_t *id, ulong dest_addr) */
    mov x0, x18         /* gd_t */
    ldr x1, [x18, #GD_RELOCADDR]    /* dest_addr */
    b   board_init_r        /* PC relative jump */

    /* NOTREACHED - board_init_r() does not return */

#endif /* !CONFIG_SPL_BUILD */

ENDPROC(_main)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;功能可总结为（大部分翻译自crt0_64.S中的注释）：&lt;/p&gt;
&lt;p&gt;1）设置C代码的运行环境，为调用board_init_f接口做准备。包括：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a）设置堆栈（C代码的函数调用，堆栈是必须的）。如果当前的编译是SPL（由CONFIG_SPL_BUILD定义），可单独定义堆栈基址（CONFIG_SPL_STACK），否则，通过CONFIG_SYS_INIT_SP_ADDR定义堆栈基址。

b）调用board_init_f_alloc_reserve接口，从堆栈开始的地方，为u-boot中大名鼎鼎的GD ('global data') 数据结构，分配空间。

c）调用board_init_f_init_reserve接口，对GD进行初始化。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）调用board_init_f函数，完成一些前期的初始化工作，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a）点亮一个Debug用的LED灯，表示u-boot已经活了。

b）初始化DRAM、DDR等system范围的RAM等。

c）计算后续代码需要使用的一些参数，包括relocation destination、the future stack、the future GD location等。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注5：关于u-boot的relocation操作，后续会有专门的文章介绍。&lt;/p&gt;
&lt;p&gt;3）如果当前是SPL（由CONFIG_SPL_BUILD控制），则_main函数结束，直接返回。如果是正常的u-boot，则继续执行后续的动作。&lt;/p&gt;
&lt;p&gt;4）根据board_init_f指定的参数，执行u-boot的relocation操作。&lt;/p&gt;
&lt;p&gt;5）清除BBS段。&lt;/p&gt;
&lt;p&gt;6）调用board_init_r函数，执行后续的初始化操作（已经不再本文的讨论范围了，具体请参考后续的分析文章）。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;h3 id=&quot;spl功能&quot;&gt;4.1 SPL功能&lt;/h3&gt;
&lt;p&gt;SPL是Secondary Program Loader的简称，之所以称作secondary，是相对于ROM code来说的。SPL是u-boot中独立的一个代码分支，由CONFIG_SPL_BUILD配置项控制，是为了在正常的u-boot image之外，提供一个独立的、小size的SPL image，通常用于那些SRAM比较小（或者其它限制）、无法直接装载并运行整个u-boot的平台。&lt;/p&gt;
&lt;p&gt;如果使用了SPL功能，u-boot的启动流程通常是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ROM code加载SPL并运行；

SPL进行必要的初始化之后，加载u-boot并运行；

u-boot进行后续的操作。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，如果使用SPL功能，需要尽可能的减少SPL的代码量，以减小它的size。&lt;/p&gt;
&lt;h3 id=&quot;配置项总结&quot;&gt;4.2 配置项总结&lt;/h3&gt;
&lt;p&gt;经过第3章的流程分析，我们可以总结出和“平台相关部分的启动流程”有关的配置项，记录如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CONFIG_SYS_RESET_SCTRL，控制是否在启动的时候reset SCTRL寄存器，一般不需要打开；

CONFIG_ARM_ERRATA_XXX，控制ARM core的勘误信息，一般不需要打开；

CONFIG_GICV2、CONFIG_GICV3，控制GIC的版本，用到的时候再说明；

CONFIG_ARMV8_MULTIENTRY，控制是否在u-boot中使用多CPU，一般不需要；

CONFIG_SPL_BUILD，是否是能SPL的编译，需要的话可以打开；

CONFIG_SPL_STACK，如果配置了CONFIG_SPL_BUILD，是否为SPL image配置单独的stack（SP基址），如果需要，通过该配置项配置，如果不需要，则使用CONFIG_SYS_INIT_SP_ADDR；&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 04 Apr 2019 12:38:00 +0000</pubDate>
<dc:creator>yooooooo</dc:creator>
<og:description>1. 第二个start.S 从 开始，在 中有包含 在config.h中： 在 中： 在 中，看到了 的宏 查看u boot.map在这里又来到了上一层的start.S中来，所以可以知道这两个是由两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linhaostudy/p/10656968.html</dc:identifier>
</item>
<item>
<title>C#8.0可空引用类型的使用注意要点 - 自来喵的野</title>
<link>http://www.cnblogs.com/zlmdy/p/10656793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zlmdy/p/10656793.html</guid>
<description>&lt;p&gt;最近VS2019正式版发布了，装下来顺便试用了一下C#8.0，最大的看点应该就是可空引用类型了。不过C#8.0仍然处于Beta的状态，而且试用时也遇到了几个坑。&lt;/p&gt;
&lt;p&gt;背景知识说明：&lt;/p&gt;
&lt;p&gt;所谓的可空引用类型是指，一旦启用了可空引用类型这个新特征，引用类型将默认被视为不可空，无法赋予null，除非手工将它设为可空引用类型。&lt;/p&gt;
&lt;p&gt;实战示例：&lt;/p&gt;
&lt;p&gt;首先是新建一个C#的项目，在 项目文件(.csproj)里加入两行配置，目的是启用“C#8.0语言”和“可空引用类型”：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LangVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LangVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NullableContextOptions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;enable&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;NullableContextOptions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个文件看起来是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404183426007-434162777.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就算是整个项目全局启用了可空引用类型了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在VS2019正式版中，使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NullableContextOptions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;enable&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;NullableContextOptions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不是使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NullableReferenceTypes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;NullableReferenceTypes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后者在正式版中已经失效了。&lt;/p&gt;

&lt;p&gt;如果不希望全局启用可空引用类型的话，可以在程序代码中加入以下编译指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
#nullable enable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样可以在加入了该指令的文件中，单独启用可空引用类型。但是，极度不推荐这种做法。为什么呢？因为该指令仅仅在该文件中有效，不能跨文件生效，从而无法阻止null逃逸到使用了该指令的文件中，也就是说，用了也等于没用。&lt;/p&gt;
&lt;p&gt;一个很简单的例子足以证明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404184840961-675439892.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意上面项目文件中并没有全局启用可空引用类型，而下面的Class1.cs中使用了编译器指令来单独启用可空引用类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404184555541-1515234382.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404184607374-1811696195.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从运行结果可见，空引用仍然逃逸到使用了该指令的作用域中了。别说编译错误，连编译警告都没有。完全达不到理想的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404184617974-722338998.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;因此，强烈建议在项目文件中全局启用可空引用类型，而不是在某个源文件中单独使用。&lt;/p&gt;
&lt;p&gt;另外，还有一点要注意的是，即使启用了可空引用类型后，默认情况下，即使对不可空引用赋予null，编译器也只会生成编译警告，而不是编译错误。仍然是能够编译通过的。一个大项目中，编译警告不可避免，甚至可能会很多，从而淹没了“给不可空引用类型赋予空值”这种不起眼的警告。&lt;/p&gt;
&lt;p&gt;因此，建议将特定的警告视为错误。警告编号为8600、8625、8618、8604，或者将所有警告视为错误。具体是在项目文件中加入以下设置（见图一）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;WarningsAsErrors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8600 8625 8618 8604&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;WarningsAsErrors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者在项目编辑器中设置也可以：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404185906402-1062426938.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我自己测试得出的结果，可能还有其它潜在的相关警告编号我没有测试出来。如果有谁知道的话，告诉我一下，谢谢。&lt;/p&gt;
&lt;p&gt;做好这些配置之后，可以看到引用类型默认都不能赋予空值了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404190130705-1183531902.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候普通的引用类型的变量和参数都不能设为null了。&lt;/p&gt;
&lt;p&gt;这样可以防止空值扩散开来，引起恼人的空引用异常。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，这里有个坑需要注意！！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;struct里不适用可空引用的规则！！&lt;/p&gt;
&lt;p&gt;struct里不适用可空引用的规则！！&lt;/p&gt;
&lt;p&gt;struct里不适用可空引用的规则！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404190813389-1221110084.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况下直接运行，仍然会抛出空引用异常！！！C#8.0仍未能完全封堵住空引用的逃逸。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404191053234-1881133041.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实我还是比较赞同用不可空引用类型的方案的，而不是可空引用类型的方案。毕竟我想要的，只不过是一个不可空的断言，只是想利用不可空引用来划分安全边界，从而防止空值的扩散。简单来说就是想将变量和参数明确声明为不可空引用类型。因为历史和现实的原因，大量的库都还没能全面使用可空引用类型。这种情况下，只有我使用可空引用类型，是不靠谱的。无法划分安全边界。&lt;/p&gt;
&lt;p&gt;然而C#选择了可空引用类型的方案，而且还不是强制启用，而且默认只是警告。。跟没有一样。。。&lt;/p&gt;
&lt;p&gt;比方说，我使用了一个第三方库项目，而空值的来源是正好是该库项目的，而我对这个库并没有源代码或者修改权限。这时候就无法阻止空值逃逸到我的项目中了。&lt;/p&gt;
&lt;p&gt;还是之前的代码，只是稍微做一下修改。新增了一个库项目ClassLibrary1，这个库并没有使用可空引用类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404193605929-1432827544.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;库的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404193801093-1117448907.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很简单，就是LibClass3.GetInstance()本应该返回LibClass2的实例，但是出于某种原因，返回了null。但是我的项目中使用了LibClass2和LibClass3。我的项目是全局启用了可空引用类型的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404194232878-699082170.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404194251325-1772049382.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译正常，毫无警告和错误。一旦运行，则抛出空引用异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/453950/201904/453950-20190404194421034-1187645696.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，目前来说，C#8.0的可空引用类型并不能解决外源性的空值扩散，只能解决内源性的空值扩散，无法跨模块生效。还是洗洗睡吧。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/index&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/nullable-reference-types-specification#the-null-forgiving-operator&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/nullable-reference-types-specification#the-null-forgiving-operator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/roslyn/blob/master/docs/features/nullable-reference-types.md#setting-project-level-nullable-context&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/roslyn/blob/master/docs/features/nullable-reference-types.md#setting-project-level-nullable-context&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=VdC0aoa7ung&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=VdC0aoa7ung&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/54852880/what-is-the-difference-between-nullablecontextoptions-and-nullablereferencetypes&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/54852880/what-is-the-difference-between-nullablecontextoptions-and-nullablereferencetypes&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Apr 2019 11:57:00 +0000</pubDate>
<dc:creator>自来喵的野</dc:creator>
<og:description>最近VS2019正式版发布了，装下来顺便试用了一下C#8.0，最大的看点应该就是可空引用类型了。不过C#8.0仍然处于Beta的状态，而且试用时也遇到了几个坑。 背景知识说明： 所谓的可空引用类型是指</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zlmdy/p/10656793.html</dc:identifier>
</item>
</channel>
</rss>