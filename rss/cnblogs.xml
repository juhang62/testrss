<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java安全编码指南之:声明和初始化 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/13620709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/13620709.html</guid>
<description>&lt;p&gt;在java对象和字段的初始化过程中会遇到哪些安全性问题呢？一起来看看吧。&lt;/p&gt;

&lt;p&gt;根据JLS（Java Language Specification）中的定义，class在初始化过程中，需要同时初始化class中定义的静态初始化程序和在该类中声明的静态字段（类变量）的初始化程序。&lt;/p&gt;
&lt;p&gt;而对于static变量来说，如果static变量被定义为final并且它值是编译时常量值，那么该static变量将会被优先初始化。&lt;/p&gt;
&lt;p&gt;那么使用了final static变量，是不是就没有初始化问题了呢？&lt;/p&gt;
&lt;p&gt;我们来看下面一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StaticFiledOrder {
    private final int result;
    private static final StaticFiledOrder instance = new StaticFiledOrder();
    private static final int intValue=100;
    public StaticFiledOrder(){
        result= intValue - 10;
    }

    public static void main(String[] args) {
        System.out.println(instance.result);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果是什么呢？&lt;/p&gt;
&lt;p&gt;答案是90。 根据我们提到的规则，intValue是final并且被编译时常量赋值，所以是最先被初始化的，instance调用了StaticFiledOrder类的构造函数，最终导致result的值是90。&lt;/p&gt;
&lt;p&gt;接下来，我们换个写法，将intValue改为随机变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StaticFiledOrder {
    private final int result;
    private static final StaticFiledOrder instance = new StaticFiledOrder();
    private static final int intValue=(int)Math.random()* 1000;
    public StaticFiledOrder(){
        result= intValue - 10;
    }

    public static void main(String[] args) {
        System.out.println(instance.result);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果是什么呢？&lt;/p&gt;
&lt;p&gt;答案是-10。为什么呢？&lt;/p&gt;
&lt;p&gt;因为instance在调用StaticFiledOrder构造函数进行初始化的过程中，intValue还没有被初始化，所以它有一个默认的值0，从而导致result的最终值是-10。&lt;/p&gt;
&lt;p&gt;怎么修改呢？&lt;/p&gt;
&lt;p&gt;将顺序调换一下就行了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StaticFiledOrder {
    private final int result;
    private static final int intValue=(int)Math.random()* 1000;
    private static final StaticFiledOrder instance = new StaticFiledOrder();
    public StaticFiledOrder(){
        result= intValue - 10;
    }

    public static void main(String[] args) {
        System.out.println(instance.result);
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;既然static变量可以调用构造函数，那么可不可以调用其他类的方法呢？&lt;/p&gt;
&lt;p&gt;看下这个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CycleClassA {
    public static final int a = CycleClassB.b+1;
}
public class CycleClassB {
    public static final int b = CycleClassA.a+1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就是一个循环初始化的例子，上面的例子中CycleClassA中的a引用了CycleClassB的b，而同样的CycleClassB中的b引用了CycleClassA的a。&lt;/p&gt;
&lt;p&gt;这样循环引用虽然不会报错，但是根据class的初始化顺序不同，会导致a和b生成两种不同的结果。&lt;/p&gt;
&lt;p&gt;所以在我们编写代码的过程中，一定要避免这种循环初始化的情况。&lt;/p&gt;

&lt;p&gt;java标准库中为我们定义了很多非常优秀的类，我们在搭建自己的java程序时候可以很方便的使用。&lt;/p&gt;
&lt;p&gt;但是我们在写自定义类的情况下，一定要注意避免使用和java标准库中一样的名字。&lt;/p&gt;
&lt;p&gt;这个应该很好理解，就是为了避免混淆。以免造成不必要的意外。&lt;/p&gt;
&lt;p&gt;这个很简单，就不举例子了。&lt;/p&gt;

&lt;p&gt;我们在遍历集合和数组的过程中，除了最原始的for语句之外，java还为我们提供了下面的增强的for循环：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for (I #i = Expression.iterator(); #i.hasNext(); ) {
    {VariableModifier} TargetType Identifier =
        (TargetType) #i.next();
    Statement
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在遍历的过程中，#i其实相当于一个本地变量，对这个本地变量的修改是不会影响到集合本身的。&lt;/p&gt;
&lt;p&gt;我们看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public void noncompliantUsage(){
        int[] intArray = new int[]{1,2,3,4,5,6};
        for(int i: intArray){
            i=0;
        }
        for(int i: intArray){
            System.out.println(i);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在遍历过程中，尝试将i都设置为0，但是最后输出intArray的结果，发现没有任何变化。&lt;/p&gt;
&lt;p&gt;所以，一般来说我们需要在增强的for语句中，将#i设置成为final，从而消除这种不必要的逻辑误会。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public void compliantUsage(){
        int[] intArray = new int[]{1,2,3,4,5,6};
        for(final int i: intArray){
        }
        for(int i: intArray){
            System.out.println(i);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文的例子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ddean2009/learn-java-base-9-to-20/tree/master/security&quot;&gt;learn-java-base-9-to-20/tree/master/security&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.8171206225681&quot;&gt;
&lt;p&gt;本文已收录于 &lt;a href=&quot;http://www.flydean.com/java-security-code-line-dlc/&quot;&gt;http://www.flydean.com/java-security-code-line-dlc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最通俗的解读，最深刻的干货，最简洁的教程，众多你不知道的小技巧等你来发现！&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:「程序那些事」,懂技术，更懂你！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 06 Sep 2020 00:58:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 在java对象和字段的初始化过程中会遇到哪些安全性问题呢？一起来看看吧。 初始化顺序 根据JLS（Java Language Specification）中的定义，class在初始化过程中，需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/13620709.html</dc:identifier>
</item>
<item>
<title>图解进程线程、互斥锁与信号量-看完不懂你来打我 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13620696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13620696.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200906085125268-309001835.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上学的时候，老师讲到进程与线程的时候可能是这样讲的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单元，是应用程序运行的载体。&lt;/li&gt;
&lt;li&gt;线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200906085125540-574779434.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那个时候为了考试我都背下来了，但是心里想说：what？这都是些什么东西？&lt;/strong&gt; 下面让我来试着用更通俗的语言来给你说说进程、线程、互斥锁、信号量的那些事。&lt;/p&gt;
&lt;h2 id=&quot;一、房子与居住者&quot;&gt;一、房子与居住者&lt;/h2&gt;
&lt;p&gt;我们可以将自己平时住的房子类比为一个进程，每一个房间及其占用者比喻为一个线程。房子本身并不会做任何的事情，但是线程是房子里面每一个活跃的人，他们平时洗衣、做饭、看电视……，就像线程执行自己的代码一样在运行着。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200906085125775-812974745.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单线程&lt;/strong&gt;&lt;br/&gt;单线程就是一个叫做“进程”的房子里面，只住了你一个人，你可以在这个房子里面任何时间去做任何的事情。你是看电视、还是玩电脑，全都有你自己说的算。想干什么干什么，想什么时间做什么就什么时间做什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程&lt;/strong&gt;&lt;br/&gt;但是如果你处在一个“多人”的房子里面，每个房子里面都有叫做“线程”的住户：线程1、线程2、线程3、线程4，情况就不得不发生变化了。假如这些线程是你的老婆、孩子、父母。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父母老人午睡的时候你不能开音响&lt;/li&gt;
&lt;li&gt;老婆要看“甄嬛传”，你就不能看球赛&lt;/li&gt;
&lt;li&gt;孩子没睡觉，你就别想看书&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;多线程出现这些问题的根本原因在于”共享资源“：时间、电视、厕所、厨房……等等。那我们下面来看看，如何处理协调使用这些&quot;共享资源&quot;？&lt;/p&gt;
&lt;h2 id=&quot;二、锁互斥锁&quot;&gt;二、锁(互斥锁)&lt;/h2&gt;
&lt;p&gt;在多线程编程中有”锁”的概念，在你的房子里面也有锁。如果你的老婆在上厕所并锁上门，她就是在独享这个“房子(进程)”里面的公共资源“卫生间”，如果你的家里只有这一个卫生间，你作为另外一个线程就只能先等待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200906085126116-2106562712.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程对锁的占用是有优先级的，就像在你的家里也有优先级。当你家只有一个卫生间的时候，孩子、老婆、你同时要去上厕所，通常来说 你的优先级是1，你老婆的优先级是100，你孩子的优先级是255。需要说明的是：数值越小优先级越低。但是不同的情况下会有不同的优先级调度算法，关键核心因子是优先级设置与等待时间，如果你确实等待了很长时间，老婆孩子可能看你快憋不住了，让你先去使用洗手间也是可以的。&lt;/p&gt;
&lt;h2 id=&quot;三、信号量&quot;&gt;三、信号量&lt;/h2&gt;
&lt;p&gt;现在让我们从卫生间走入厨房，首先我们要明确的一点是：厨房里面可以有一个人，也可以有多个人。&lt;br/&gt;那我们怎么控制使用“厨房”这个公共资源的人数（线程数）？一个比较好的方法就是使用信号量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200906085126756-1777778742.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“信号量”在编程术语中使用单词semaphore，那什么是“信号量”？信号量就好比你家厨房入口架子上摆了三把锅：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你的孩子热奶拿走一把，你的老婆热汤拿走一把，你的妈妈做菜拿走一把，你想煮面条就没有锅了。当你看到这种情况，你就不会进入厨房了，也就说厨房按照“锅的数量”作为信号量，只能容纳三个人(线程)。&lt;/li&gt;
&lt;li&gt;当你的老婆热完汤之后，把锅重新放回架子上，你就可以去获得一个锅，你就可以进入厨房了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以说：当信号量总数为1的时候，也就是你家只有一把锅，此时信号量作用就等同于互斥锁。&lt;/p&gt;
&lt;h2 id=&quot;四、专业点好么&quot;&gt;四、专业点好么&lt;/h2&gt;
&lt;p&gt;来一张专业点的图，别让您误会我是讲故事的。讲技术，我可是认真的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200906085127267-2860215.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sun, 06 Sep 2020 00:51:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在上学的时候，老师讲到进程与线程的时候可能是这样讲的： 进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单元，是应用程序运行的载体。 线程是程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13620696.html</dc:identifier>
</item>
<item>
<title>【MySQL】我这样分析MySQL中的事务，面试官对我刮目相看！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13620501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13620501.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;相信大部分小伙伴在面试过程中，只会针对面试官提出的表面问题来进行回答。其实不然，面试官问的每一个问题都是经过深思熟虑的，面试的时间相对来说也是短暂的，面试官不可能在很短的时间内就对你非常了解，他想通过几个问题来考察你所掌握的知识的深度和广度，如果你只是回答面试官表面问你的问题，向挤牙膏一样，问一点，答一点，结果不用说，肯定是凉凉了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;面试问题&quot;&gt;面试问题&lt;/h2&gt;
&lt;p&gt;说说什么是事务？并发事务会带来哪些问题呢？&lt;/p&gt;
&lt;h2 id=&quot;分析问题&quot;&gt;分析问题&lt;/h2&gt;
&lt;p&gt;表面上看，面试官是问了两个问题。一个是：什么是事务，也就是让你说说事务的基本概念；另一个是：并发事务会带来哪些问题。&lt;/p&gt;
&lt;p&gt;实则不然，听到面试官这样问，你不要随意回答。要用极短的时间思考一下，面试官究竟想要得到什么答案。&lt;/p&gt;
&lt;p&gt;对于第一个问题：说说什么是事务？就只是让你简单的说说事务的基本概念吗？基本概念相信是个学过数据库的小学生都会，面试官为什么会问你这个问题呢？此时，你需要揣测面试官的心理。此时的面试官其实想问你的不久是事务的基本概念，而且他也想让你说出事务的特性，也就是四大属性。这才是这个问题的核心所在！&lt;/p&gt;
&lt;p&gt;对于第二个问题：并发事务会带来哪些问题呢？就只是想问一下会带来哪些问题吗？知道问题，不知道如何解决问题，这样的面试者面试官能要吗？究其本质，面试官是想问你并发事务会带来哪些问题，有哪些解决方案能够解决这些问题！这才是面试官想要的答案！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综上，面试官本质上问的问题是：什么是事务？事务的四大特性是什么？并发事务会带来哪些问题？有哪些解决方案？你只有深刻理解了面试官提问的本质，才能更好的回答面试官所提出的问题。不然，你应付面试官，面试官也会应付你。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是事务？&quot;&gt;什么是事务？&lt;/h2&gt;
&lt;p&gt;事务的概念理解起来还比较简单的：事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。&lt;/p&gt;
&lt;h2 id=&quot;事务的四大特性&quot;&gt;事务的四大特性&lt;/h2&gt;
&lt;h3 id=&quot;原子性（atomicity&quot;&gt;原子性（Atomicity)&lt;/h3&gt;
&lt;p&gt;事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。比如转账，要么转账成功，账户余额增加（减少）；要么转账失败，账户余额不变。&lt;/p&gt;
&lt;h3 id=&quot;一致性consistency&quot;&gt;一致性(Consistency)&lt;/h3&gt;
&lt;p&gt;事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。某些维护一致性的责任由应用程序开发人员承担，他们必须确保应用程序已强制所有已知的完整性约束。例如，当开发用于转帐的应用程序时，应避免在转帐过程中任意移动小数点。&lt;/p&gt;
&lt;h3 id=&quot;隔离性isolation&quot;&gt;隔离性(Isolation)&lt;/h3&gt;
&lt;p&gt;由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为隔离性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。当事务可序列化时将获得最高的隔离级别。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。&lt;/p&gt;
&lt;h3 id=&quot;持久性durability&quot;&gt;持久性(Durability)&lt;/h3&gt;
&lt;p&gt;事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。&lt;/p&gt;
&lt;p&gt;例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。&lt;/p&gt;
&lt;h2 id=&quot;并发事务带来的问题&quot;&gt;并发事务带来的问题&lt;/h2&gt;
&lt;h3 id=&quot;脏写问题&quot;&gt;脏写问题&lt;/h3&gt;
&lt;p&gt;当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。&lt;/p&gt;
&lt;p&gt;例如，T1和T2同时修改一条数据，T2的修改覆盖了T1的修改；如果在T1之后T2才能进行更改，则可以避免该问题。&lt;/p&gt;
&lt;p&gt;我们来看一个经典的转账问题，开始小明和小刚都有1000元钱，在事务T1中，小明为小刚转账100元，在事务T2中，小刚为小明转账200元。则正常情况下，结果为：小明有1100元，小刚为900元。如果发生了脏写的问题，则结果可能为：小明1200元，小刚800元。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906013454699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;脏读问题&quot;&gt;脏读问题&lt;/h3&gt;
&lt;p&gt;一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。&lt;/p&gt;
&lt;p&gt;例如：在事务T1中，小明为小刚转账100元，在转账的过程中，事务未提交或者未回滚时，此时事务T2读取到了事务T1未提交的内容，也就是说在事务T2中读取到了小明900元，小刚1100元的记录。可以用下图表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906013504130.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;不可重复读问题&quot;&gt;不可重复读问题&lt;/h3&gt;
&lt;p&gt;一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变！这种现象就叫做“不可重复读”。&lt;/p&gt;
&lt;p&gt;指事务T2读取数据后，事务T1执行更新操作，使T2无法读取前一次结果。&lt;/p&gt;
&lt;p&gt;例如，在事务T1中执行小明为小刚转账100元的操作，在事务未提交之前，在事务T2中读取的数据还是小明为1000元，小刚为1000元。待事务T1提交后，事务T2中读取的数据为小明900元，小刚1100元。如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906013512620.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;幻读问题&quot;&gt;幻读问题&lt;/h3&gt;
&lt;p&gt;一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。&lt;/p&gt;
&lt;p&gt;事务t2读取到了事务t1体提交的新增、删除数据，不符合隔离性。&lt;/p&gt;
&lt;p&gt;幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。&lt;/p&gt;
&lt;p&gt;例如，在事务T1中插入两条分别为小明和小刚的数据，在事务提交之前，事务T2中读取的数据记录为10，随后事务T1提交，则在事务T2中读取的记录为12，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906013530509.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;并发事务问题的解决方案&quot;&gt;并发事务问题的解决方案&lt;/h2&gt;
&lt;p&gt;为了避免上面出现的几种情况，在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。以下四种不同的隔离级别限制由低到高，性能从高到底。&lt;/p&gt;
&lt;h3 id=&quot;读未提交&quot;&gt;读未提交&lt;/h3&gt;
&lt;p&gt;读未提交（Read Uncommitted）：允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。&lt;/p&gt;
&lt;p&gt;不可避免 脏读、不可重复读、虚读。&lt;/p&gt;
&lt;h3 id=&quot;读已提交&quot;&gt;读已提交&lt;/h3&gt;
&lt;p&gt;读已提交（Read Committed）：允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。&lt;/p&gt;
&lt;p&gt;可避免 脏读，不可避免 不可重复读、虚读。Oracle采用读已提交。&lt;/p&gt;
&lt;h3 id=&quot;可重复度&quot;&gt;可重复度&lt;/h3&gt;
&lt;p&gt;可重复读取（Repeatable Read）：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。&lt;/p&gt;
&lt;p&gt;可避免 脏读、不可重复读， 不可避免 虚读。MySQL采用可重复读。&lt;/p&gt;
&lt;h3 id=&quot;序列化&quot;&gt;序列化&lt;/h3&gt;
&lt;p&gt;序列化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。&lt;/p&gt;
&lt;p&gt;可避免 脏读、不可重复读、幻读情况的发生。&lt;/p&gt;
&lt;p&gt;事务的四种隔离级别总结起来如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906013541923.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常看当前数据库的事务隔离级别: show variables like 'tx_isolation';&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置事务隔离级别：set tx_isolation='REPEATABLE-READ';&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，后台回复 “&lt;strong&gt;设计模式&lt;/strong&gt;” 关键字领取《&lt;strong&gt;深入浅出Java 23种设计模式&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;Java8&lt;/strong&gt;”关键字领取《&lt;strong&gt;Java8新特性教程&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;限流&lt;/strong&gt;”关键字获取《&lt;strong&gt;亿级流量下的分布式限流解决方案&lt;/strong&gt;》PDF文档，三本PDF均是由冰河原创并整理的超硬核教程，面试必备！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906013715889.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 Sep 2020 17:46:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 相信大部分小伙伴在面试过程中，只会针对面试官提出的表面问题来进行回答。其实不然，面试官问的每一个问题都是经过深思熟虑的，面试的时间相对来说也是短暂的，面试官不可能在很短的时间内就对你非常了解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13620501.html</dc:identifier>
</item>
<item>
<title>跨域方式及其实现 - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/13620361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/13620361.html</guid>
<description>&lt;h2 id=&quot;NcUSL&quot; data-lake-id=&quot;c94f416d0109fcc25b9fe9a72e6d81ea&quot;&gt;产生原因&lt;/h2&gt;
&lt;p data-lake-id=&quot;d5f19972466694e594cab1ed2dd16499&quot;&gt;为什么会产生跨域呢，因为浏览器为了安全采用了一系列的安全机制，其中有一个是同源策略。何为同源策略（same-origin policy）。简单来讲同源策略就是浏览器为了保证用户信息的安全，防止恶意的网站窃取数据，禁止不同域之间的JS进行交互。对于浏览器而言只要域名、协议、端口其中一个不同就会引发同源策略。&lt;/p&gt;
&lt;blockquote readability=&quot;2.3369565217391&quot;&gt;
&lt;p data-lake-id=&quot;0057f06e596e1ff23dda3570a991fa19&quot;&gt;关于浏览器安全和同源策略详解 &lt;a href=&quot;https://www.yuque.com/suihangadam/liulanqi/pog4pf&quot; target=&quot;_blank&quot;&gt;https://www.yuque.com/suihangadam/liulanqi/pog4pf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;HdANH&quot; data-lake-id=&quot;2c40444e8d80f88e86f5ff45849d5589&quot;&gt;为何要跨域&lt;/h2&gt;
&lt;p data-lake-id=&quot;36bc030a69c15f351d334bc943c38fe0&quot;&gt;公司内部可能有多个不同的子域，比如一个是location.company.com ,而应用是放在app.company.com , 这时想从 app.company.com去访问 location.company.com 的资源就属于跨域。&lt;/p&gt;
&lt;h2 id=&quot;pKaE8&quot; data-lake-id=&quot;d76e22b7fff75887545ff78fdc41c6b7&quot;&gt;跨域方式&lt;/h2&gt;
&lt;div id=&quot;XTHAM&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;mindmap&quot; data-card-value=&quot;data:%7B%22diagramData%22%3A%22x%C2%9C%C2%A5%C2%94%C3%8BN%5Cu0014A%5Cu0014%C2%86_%C2%85%C2%94K%C2%A7%26u%C3%AB%C2%BA%C3%8CN%60Ht!F%C2%96%C2%86E%5D%C2%99%C3%89Lw%C2%8F%C3%93%C2%8D%C2%80d%5Cu0012%5Cu0017j4F%C3%81%C2%8DKY%C2%B8111%C2%BA0F%C3%A4i%5Cf%5Cu0003%C3%ACx%5Cu0005%C2%AB%C2%81%C3%8CE%5Cu0019%5Cr%C2%9AN%3A%5D%C3%9D%C2%A7%C3%BE%C3%BF%C3%8B_%7D%C3%8E6hy%C3%AD%40c%5Cu001b%3C%C3%B0%C3%BD%C2%A2%C2%9Dg%C2%A0%5Cu0001H%5Cu001d%C3%95%5Cu0011%C2%A8%C2%81r%C2%AB%C3%A7%C3%A32mg.%C3%95%3D0%C2%A8%5Cu0001%C2%93%C2%BB-%C3%90%C2%B8%C2%B7%5Cr%C3%9Aq%5Cu000b%60Z0e%C2%B9%C2%89%C2%A5%C2%AD2%C3%AD%C3%867'_%C3%9F%5Cu000f%C3%B7%C3%B6%C2%8E%C3%9E%7C%5Cu001b%5Cu001e%C3%AC%C3%BCx%C3%B4%C3%A2w%C2%8D%5Cu001a%C2%B0%C2%ADv%C3%97%C3%B5%7Dv%26s%C2%B1-%C2%96nx%C3%93%C3%93%C2%B63%C3%BC%C3%B8%C3%B6%C3%B8%C3%95%C2%A7s%C2%99X%C3%9C%C3%95%5B%C3%B9zY%C3%91%C3%9D_%C3%97%C2%AE%C2%AF%C2%B3%C3%B8L%5C%22G%C3%99%C3%B7%C2%BE%C3%A9%C3%96%7C%C3%B5%C2%A5(%C3%BBy%C2%A7%C3%B2%C2%B8%C3%96d2%5E%5Cu0015%C3%A7%5Cu0019%C2%9E%C2%B7%C2%82%5Cu001bN%5Cu0003d%C2%A4%C2%BA%C3%A9%60%C2%A1d%C3%81A%C2%97%5Cu0010%C3%AD%C2%BD%C2%94%5C%5C84%5Cr%C2%B4Z%5Cu0003%5Cu000fof%C3%8Eo%C2%82%C2%86%5Cu001c%C3%94%26%C3%B1%C2%B2%C3%B6Z%C2%B69%C3%9Cy9%C3%9C%7D%7D%C3%B8%C3%BD%C3%9D%C3%B1%C3%AE%C3%93%C3%BF%5Cu0002%C2%BDA%C2%A4h%C3%A2%5Cu0011%C2%A8R%5Cbs%C2%84%5CrT%5Cu000eI%C3%88%5Cu0014%25P%5B%C2%A4%C2%A1e%5Cba%C3%A1%C2%99%5Cu000fb6%C2%A8%C2%98%5Cu0006%C2%8D9%C3%8E%5Cu0015%C2%B9%C3%AD%C3%B8%C2%B2%C2%B82%C2%96%C3%84%5C%5C%C3%8D%2F%C2%8D%C2%B0%5Cu0010%5Cn%5Cu0006y%C2%A5%C2%A0v%C3%92A%C3%86%C2%8D%C2%87%5Cu0006%5Cu0007%5Cu0005%C2%95w%C2%9C%5Cu0005%C2%A3%C2%8C%C2%94~%26%5Cu0016%C2%9F%C3%86ZX%C2%BE%C2%BBrz%C3%B0%C3%AC%3C%C2%AF%C2%93%2F%C2%8F%C2%8F%C3%B6w%C2%87O%3E%5Cu001f%C3%AE%7F8%3Dx~e%C3%8E%C3%85%C2%A5y%C2%99%2C%C2%8E8%C2%A5!%C2%94pb!%5Cu000e%5Cu0002C%C2%96(%5Cr%5Cr%C2%AD%C3%92T%C2%8E%5Cu0012%5Cu001d%C2%94%C2%936%C2%99%C3%89%C2%99Lsvs%C2%AB%C3%8B%C3%98%5Cu0005%C3%B5%C2%96.Zs%C3%97%C3%A7%C3%9A%C2%A1%C2%AFS%7FeB!%5Cu0016%C2%A8%C3%A4%C3%A3%3FQ%C3%A9%C2%A0yB!%5Cu0011%2C%26)M%5Cu0002%C2%8D%C3%83%5Cu001cz%C2%8F%C2%83%C2%B4(1L%C3%92%C2%99%C2%84%C3%AC%C2%97%5Cu0003%C2%8E%C2%9D%C2%94o%C3%94%7ByQ%C2%A6%C2%BE(%C3%B4%C2%9A%C3%BFw%C3%8C%C3%85%C2%A6%C3%84%5Cu000bcL%C3%8C4%C2%A7J%5Cb%C2%88%C2%85V%C2%90%5Cu0019E%C2%A0%C3%A2%C2%8EBO%C2%89%C2%A1%C2%91%C3%93%C2%A1%40fb%C3%92%5Cn%C3%B3%C3%BC%3C(%C2%92%5Cu0006%5Cu001b5%5Cu001e%5Cu000b%C2%B7V%C2%96o%C3%9F%C2%B9%C2%98%5Cu0007%7Fi%C2%88%C3%8B%C3%85%C3%89H%5Cu001cq%C2%A6H%C2%A0v%2C%C3%AEr%C2%BB%C2%9E%C3%BA%C2%AC%C2%AC%C2%BB%3C%C3%95%C3%ADl%C2%A6%C3%87x%3A%5C%5C%C3%AE%C2%81G%5Cu001e%C3%812%C2%9B%5Cu00106%C3%A1q%5Cu0011z%5Cu0016C%C2%9EL%C3%BBr%C2%A3%C3%98D%C2%B8%C3%B9%5Cu0007%234%C2%98X%C2%A8%C3%81%C3%AA%C3%A0''R%C3%95N%22%2C%22margin%22%3Atrue%2C%22id%22%3A%22XTHAM%22%2C%22viewportSetting%22%3A%7B%22zoom%22%3A1%2C%22scrollLeft%22%3A420.5%2C%22scrollTop%22%3A314%2C%22viewBox%22%3A%5B-744%2C-470.5%2C1540%2C956%5D%7D%2C%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1599321325211-bcc63a75-5ba6-4cfe-a919-946cc5633bef.png%22%2C%22search%22%3A%22%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E2%80%8B%20JSONP%E2%80%8B%20document.domain%20window.name%20%2B%20iframe%20%E2%80%8Bwindow.postmessage%20%2B%20iframe%20%E2%80%8Blocation.hash%20%2B%20iframe%20%E2%80%8BCORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%20%E2%80%8Bweb%20sockets%20%E2%80%8Bnignx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%20%E2%80%8Bwebpack%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%22%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1599321325211-bcc63a75-5ba6-4cfe-a919-946cc5633bef.png&quot; width=&quot;518&quot; height=&quot;269&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;EToLH&quot; data-lake-id=&quot;89e3e807decee910815d8195aee62500&quot;&gt;JSONP&lt;/h3&gt;
&lt;p data-lake-id=&quot;df6c8059bc7a3d08450186cdda9e7e30&quot;&gt;jsonp是一种非正式的传输协议&lt;/p&gt;
&lt;p data-lake-id=&quot;90062ae89a62153604a330eac5bb9f20&quot;&gt;&lt;strong&gt;跨域原理：&lt;/strong&gt; 利用了src不受同源策略的影响 ，可以访问其他页面的数据。&lt;/p&gt;
&lt;p data-lake-id=&quot;d13e87ea59d771ebf9471aa1bacd4ba3&quot;&gt;&lt;strong&gt;注意⚠️&lt;/strong&gt;：jsonp并不能解决所有的跨域问题，因为使用jsonp跨域需要被提供jsonp接口&lt;/p&gt;
&lt;div id=&quot;87gNw&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%201.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%5Cnfunction%20callBack%20(data)%20%7B%5Cn%5Ctconsole.log(data)%3B%5Cn%7D%5Cn%2F%2F%202.%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAscript%E6%A0%87%E7%AD%BE%5Cnvar%20currentScript%20%3D%20document.createElement(%5C%22script%5C%22)%3B%5Cn%2F%2F%203.%E7%BB%99%E6%A0%87%E7%AD%BE%E7%9A%84src%E8%B5%8B%E5%80%BC%EF%BC%88%E5%8D%B3%E6%8E%A5%E5%8F%A3%E7%9A%84url%EF%BC%89%2C%E5%B9%B6%E5%B0%86%E5%87%BD%E6%95%B0%E9%99%84%E5%8A%A0%E5%88%B0url%E4%B8%8A%EF%BC%8C%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%A4%A7%E9%83%A8%E5%88%86jonsp%E6%8E%A5%E5%8F%A3%E9%83%BD%E4%B8%BAcallback%EF%BC%8C%E7%99%BE%E5%BA%A6%E7%9A%84jsonp%E6%8E%A5%E5%8F%A3%E4%B8%BAcb%5CncurrentScript.src%20%3D%20%5C%22http%3Awww.baidu.com%3Fa%3D1%26b%3D2%26cb%3DcallBack%5C%22%3B%5Cn%2F%2F%204.%E5%B0%86%E6%A0%87%E7%AD%BE%E6%8F%92%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E4%B8%8A%5Cndocument.body.appendChild(script1)%3B%5Cn%2F%2F%205.%E5%B0%86%E6%A0%87%E7%AD%BE%E5%8A%A0%E8%BD%BD%E5%AE%8C%E5%90%8E%E5%88%A0%E9%99%A4%20%5Cnscript1.onload%20%3D%20function()%7B%5Cn%5Ctthis.remove()%5Cn%7D%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%2287gNw%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建一个全局函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; callBack (data) {
    console.log(data);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.动态创建一个script标签&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; currentScript = document.createElement(&quot;script&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.给标签的src赋值（即接口的url）,并将函数附加到url上，注意：大部分jonsp接口都为callback，百度的jsonp接口为cb&lt;/span&gt;
currentScript.src = &quot;http:www.baidu.com?a=1&amp;amp;b=2&amp;amp;cb=callBack&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.将标签插入到页面上&lt;/span&gt;
&lt;span&gt;document.body.appendChild(script1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.将标签加载完后删除 &lt;/span&gt;
script1.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remove()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;JDCEg&quot; data-lake-id=&quot;f9c58b70b8b5fa70ad42cca1f3a1f5f0&quot;&gt;修改document.domain来跨子域&lt;/h3&gt;
&lt;p data-lake-id=&quot;cd61b5d430bd87bb744dd7f87bfe6c08&quot;&gt;&lt;strong&gt;跨域原理：&lt;/strong&gt;两个网页一级域名相同，只是二级域名不同，浏览器允许通过设document.domain共享 Cookie或者处理iframe。&lt;/p&gt;
&lt;p data-lake-id=&quot;44c50fa216c1ac9714fd93549d02727e&quot;&gt;&lt;strong&gt;注意⚠️&lt;/strong&gt;：用来处理Cookie 和 iframe，&lt;/p&gt;
&lt;p data-lake-id=&quot;9ea3ca4e3f7981ee649de19a44d3c452&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;处理Cookie&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;Bq7w5&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22document.domain%20%3D%20'example.com'%3B%5Cn%2F%2F%E7%8E%B0%E5%9C%A8%EF%BC%8CA%E7%BD%91%E9%A1%B5%E9%80%9A%E8%BF%87%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%20Cookie%E3%80%82%5Cndocument.cookie%20%3D%20%5C%22test1%3Dhello%5C%22%3B%5Cn%2F%2FB%E7%BD%91%E9%A1%B5%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%88%B0%E8%BF%99%E4%B8%AA%20Cookie%E3%80%82%5Cnvar%20allCookie%20%3D%20document.cookie%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22Bq7w5%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
document.domain = 'example.com'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在，A网页通过脚本设置一个 Cookie。&lt;/span&gt;
document.cookie = &quot;test1=hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;B网页就可以读到这个 Cookie。&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; allCookie = document.cookie;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;ca3bfd185db4809b688b7fef207ea238&quot;&gt;注意⚠️：这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 &lt;/p&gt;
&lt;p data-lake-id=&quot;d80f73420588cbe04b3dd151a31ed03f&quot;&gt;另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。&lt;/p&gt;
&lt;div id=&quot;HveEY&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22Set-Cookie%3A%20key%3Dvalue%3B%20domain%3D.example.com%3B%20path%3D%2F%5Cn%2F%2F%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%92%8C%E4%B8%89%E7%BA%A7%E5%9F%9F%E5%90%8D%E4%B8%8D%E7%94%A8%E5%81%9A%E4%BB%BB%E4%BD%95%E8%AE%BE%E7%BD%AE%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%8F%96%E8%BF%99%E4%B8%AACookie%E3%80%82%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22HveEY%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Set-Cookie: key=value; domain=.example.com; path=/
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;4ab49ddbbd7b62768e9bc6b5bf1fa40c&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;处理iframe&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;0904406750a879a93c17460115b0f4fd&quot;&gt;不同的iframe 之间（父子或同辈），是能够获取到彼此的window对象的，但是你却不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外，还有些浏览器比如ie6也可以使用top、parent等少数几个属性)，总之，你可以当做是只能获取到一个几乎无用的window对象。 &lt;/p&gt;
&lt;p data-lake-id=&quot;db477452736fba0898b36f95a3e6a7bc&quot;&gt;首先说明一下同域之间的iframe是可以操作的。比如&lt;a href=&quot;http://127.0.0.1/JSONP/a.html&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1/JSONP/a.html&lt;/a&gt;里面嵌入一个iframe指向&lt;a href=&quot;http://127.0.0.1/myPHP/b.html&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1/myPHP/b.html&lt;/a&gt;。那么在a.html里面是可以操作iframe里面的DOM的。&lt;/p&gt;
&lt;div id=&quot;30QDt&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%5Cn%3Ciframe%20src%3D%5C%22http%3A%2F%2F127.0.0.1%2FmyPHP%2Fb.html%5C%22%20frameborder%3D%5C%221%5C%22%3E%3C%2Fiframe%3E%5Cn%3Cbody%3E%5Cn%3Cscript%20type%3D%5C%22text%2Fjavascript%5C%22%3E%5Cnvar%20iframe%20%3D%20document.querySelector(%5C%22iframe%5C%22)%3B%5Cniframe.onload%20%3D%20function()%7B%5Cn%20%20%20%20var%20win%20%3D%20iframe.contentWindow%3B%5Cn%20%20%20%20var%20doc%20%3D%20win.document%3B%5Cn%20%20%20%20var%20ele%20%3D%20doc.querySelector(%5C%22.text1%5C%22)%3B%5Cn%20%20%20%20var%20text%20%3D%20ele.innerHTML%3D%5C%22123456%5C%22%3B%5Cn%7D%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%2230QDt%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;iframe src=&quot;http://127.0.0.1/myPHP/b.html&quot; frameborder=&quot;1&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt;var&lt;/span&gt; iframe = document.querySelector(&quot;iframe&quot;&lt;span&gt;);
iframe.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; win =&lt;span&gt; iframe.contentWindow;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; doc =&lt;span&gt; win.document;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ele = doc.querySelector(&quot;.text1&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; text = ele.innerHTML=&quot;123456&quot;&lt;span&gt;;
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;fa41eeafe8ae4154f550834727c77320&quot;&gt;注意⚠️：如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。如果两个窗口一级域名相同，只是二级域名不同，那么document.domain属性，就可以规避同源政策，拿到&lt;strong&gt;DOM&lt;/strong&gt;。 &lt;/p&gt;
&lt;h3 id=&quot;cFQgx&quot; data-lake-id=&quot;f507c7386c07b86d09b6e0a35e135824&quot;&gt;window.name + iframe&lt;/h3&gt;
&lt;p data-lake-id=&quot;4bd9b97d266fabe0a293c5398b689e8c&quot;&gt;&lt;strong&gt;跨域原理：&lt;/strong&gt;即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面window.name都有读写的权限。&lt;/p&gt;
&lt;p data-lake-id=&quot;26519343fb684adfc5119a45213a2ec0&quot;&gt;&lt;strong&gt;注意⚠️：&lt;/strong&gt;是在一个窗口！并且window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器。&lt;/p&gt;
&lt;p data-lake-id=&quot;ae2965833e07255c02515bb8e84006e1&quot;&gt;&lt;strong&gt;简单栗子🌰&lt;/strong&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;5331e523c130e541a731518b908c751e&quot;&gt;1.创建一个a.html&lt;/p&gt;
&lt;div id=&quot;MylUq&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cscript%3E%5Cn%20%20%20%20window.name%20%3D%20%5C%22%E5%93%88%E5%93%88%EF%BC%8C%E6%88%91%E6%98%AF%E9%A1%B5%E9%9D%A2a%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%80%BC%E5%93%9F%EF%BC%81%5C%22%3B%5Cn%20%20%20%20%2F%2F%E8%AE%BE%E7%BD%AEwindow.name%E7%9A%84%E5%80%BC%5Cn%20%20%20%20setTimeout(function()%7B%5Cn%20%20%20%20%20%20%20%20window.location%20%3D%20'b.html'%3B%5Cn%20%20%20%20%7D%2C3000)%3B%2F%2F3%E7%A7%92%E5%90%8E%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%96%B0%E9%A1%B5%E9%9D%A2%E8%BD%BD%E5%85%A5%E5%BD%93%E5%89%8Dwindow%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22MylUq%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    window.name &lt;/span&gt;= &quot;哈哈，我是页面a设置的值哟！&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置window.name的值&lt;/span&gt;
    setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        window.location &lt;/span&gt;= 'b.html'&lt;span&gt;;
    },&lt;/span&gt;3000);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3秒后把一个新页面载入当前window&lt;/span&gt;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;ec7b9bb82b7c1d4d7b0b8cf684010b07&quot;&gt;2.在b.html读取&lt;/p&gt;
&lt;div id=&quot;5GAEN&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cscript%3E%5Cn%20%20%20%20alert(window.name)%3B%2F%2F%E8%AF%BB%E5%8F%96window.name%E7%9A%84%E5%80%BC%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%225GAEN%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    alert(window.name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取window.name的值&lt;/span&gt;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;cm-s-default&quot;&gt;
&lt;span&gt;3.a.html载入3秒后，跳转到b.html页面中，结果为&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;dfe387c7eb89a6b24a12e4b140d50171&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1599310935566-d96d4598-7c64-4fa7-a294-014ad36710d2.png&quot; alt=&quot;image.png&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;166px&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;65b6500e25120e10fc54f69e01d6a012&quot;&gt;&lt;strong&gt;跨域栗子🌰&lt;/strong&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;1c93956a9323ab8a5789e41cda5f839d&quot;&gt;比如：有一个example.com/a.html页面,需要通过a.html页面里的js来获取另一个位于不同域上的页面cnblogs.com/data.html里的数据。&lt;/p&gt;
&lt;p data-lake-id=&quot;6b215d931d23b57cfb0d11c7ddae4a79&quot;&gt;1.创建cnblogs.com/data.html代码&lt;/p&gt;
&lt;div id=&quot;b7CAn&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cscript%3E%5Cn%20%20%20%20window.name%20%3D%20%5C%22%E6%88%91%E6%98%AFdata.html%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%89%80%E6%9C%89%E5%8F%AF%E4%BB%A5%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E4%BC%A0%E9%80%92%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%AF%94%E5%A6%82%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E4%BC%A0%E9%80%92Json%E6%95%B0%E6%8D%AE%5C%22%3B%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22b7CAn%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    window.name &lt;/span&gt;= &quot;我是data.html的数据，所有可以转化为字符串来传递的数据都可以在这里使用，比如这里可以传递Json数据&quot;&lt;span&gt;;
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;2add61047c165fc4995df12215d7a3cc&quot;&gt;2.创建example.com/a.html的代码&lt;/p&gt;
&lt;p data-lake-id=&quot;9ad86c785dcd5c6365e48775a66be157&quot;&gt;想要即使a.html页面不跳转也能得到data.html里的数据。在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取data.html的数据，然后a.html再去得到iframe获取到的数据。&lt;/p&gt;
&lt;div id=&quot;L5mo7&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Ciframe%20id%20%3D%20%5C%22iframe%5C%22%20src%20%3D%20%5C%22cnblogs.com%2Fdata.html%5C%22%20style%20%3D%20%5C%22display%3Anone%5C%22%20onload%20%3D%20%5C%22getData()%5C%22%3E%3C%2Fiframe%3E%5Cn%3Cscript%3E%5Cn%20%20%20%20function%20getData()%7B%5Cn%20%20%20%20%2F%2Fiframe%E8%BD%BD%E5%85%A5data.html%E9%A1%B5%E9%9D%A2%E4%BC%9A%E6%89%A7%E8%A1%8C%E6%AD%A4%E5%87%BD%E6%95%B0%5Cn%20%20%20%20%20%20%20%20var%20ifr%20%3D%20document.getElementById(%5C%22iframe%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20ifr.onload%20%3D%20function()%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99iframe%E5%92%8Ca.html%E5%B7%B2%E7%BB%8F%E5%A4%84%E4%BA%8E%E5%90%8C%E4%B8%80%E6%BA%90%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BA%92%E7%9B%B8%E8%AE%BF%E9%97%AE%5Cn%20%20%20%20%20%20%20%20%20%20%20%20var%20data%20%3D%20ifr.contentWindow.name%3B%5Cn%2F%2F%E8%8E%B7%E5%8F%96iframe%E4%B8%AD%E7%9A%84window.name%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AFdata.html%E4%B8%AD%E7%BB%99%E5%AE%83%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE%5Cn%20%20%20%20%20%20%20%20%20%20%20%20alert(data)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20ifr.src%20%3D%20'b.html'%3B%2F%2F%E8%BF%99%E9%87%8C%E7%9A%84b.html%E4%B8%BA%E9%9A%8F%E4%BE%BF%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%8F%AA%E8%A6%81%E4%B8%8Ea.html%E5%90%8C%E6%BA%90%E5%B0%B1%E8%A1%8C%EF%BC%8C%E7%9B%AE%E7%9A%84%E6%98%AF%E8%AE%A9a.html%E8%83%BD%E5%A4%9F%E8%AE%BF%E9%97%AE%E5%88%B0iframe%E4%B8%AD%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%8C%E5%90%A6%E5%88%99%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0%5Cn%20%20%20%20%7D%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22L5mo7%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;iframe id = &quot;iframe&quot; src = &quot;cnblogs.com/data.html&quot; style = &quot;display:none&quot; onload = &quot;getData()&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getData(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;iframe载入data.html页面会执行此函数&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; ifr = document.getElementById(&quot;iframe&quot;&lt;span&gt;);
        ifr.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个时候iframe和a.html已经处于同一源，可以互相访问&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; ifr.contentWindow.name;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取iframe中的window.name，也就是data.html中给它设置的数据&lt;/span&gt;
&lt;span&gt;            alert(data);
        }
        ifr.src &lt;/span&gt;= 'b.html';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的b.html为随便一个页面，只要与a.html同源就行，目的是让a.html能够访问到iframe中的东西，否则访问不到&lt;/span&gt;
&lt;span&gt;    }
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;ZArhK&quot; data-lake-id=&quot;b3d4907afb92d52172aadc68b54ce99c&quot;&gt;&lt;strong&gt;window.postMessage + iframe&lt;/strong&gt;&lt;/h3&gt;
&lt;p data-lake-id=&quot;423b72c8fa5e1d623bb4869d91ed33d7&quot;&gt;&lt;strong&gt;跨域原理：&lt;/strong&gt;可以使用window.postMessage()来向其它的window对象发送消息，无论这个window对象是属于同源或不同源(可实现跨域)，其他的页面通过window.onmessage来接收。&lt;/p&gt;
&lt;p data-lake-id=&quot;0d43eb63af3e0f5cd8eb8976045ea2d7&quot;&gt;&lt;strong&gt;注意⚠️&lt;/strong&gt;：window.postMessage(message,targetOrigin) 方法是html5新引进的特性，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。但IE6、IE7不支持&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p data-lake-id=&quot;6c842672a06b53fdb8bd6df4c151b7b9&quot;&gt;message：为要发送的消息，类型只能为字符串；&lt;/p&gt;
&lt;p data-lake-id=&quot;6c501fc9a53e3c9eb4bb48569870e1bb&quot;&gt;targetOrigin：用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 “*”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-lake-id=&quot;3638dd1bfd67e227a1acfebf3d98c96b&quot;&gt;&lt;strong&gt;栗子🌰&lt;/strong&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;e3e14f73fcbf5a2f06d3dc281478f3f5&quot;&gt;1.创建www.test.com/a.html页面代码&lt;/p&gt;
&lt;div id=&quot;iGZIy&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Ciframe%20id%3D%5C%22iframe%5C%22%20src%3D%5C%22www.script.com%2Fb.html%5C%22%20onload%3D%5C%22onLoad()%5C%22%3E%3C%2Fiframe%3E%5Cn%3Cscript%3E%5Cnfunction%20onLoad()%7B%5Cn%20%20%20%20var%20iframe%20%3D%20document.getElementById(%5C%22iframe%5C%22)%3B%5Cn%20%20%20%20var%20win%20%3D%20iframe.contentWindow%3B%5Cn%20%20%20%20win.postMessage('%E5%93%88%E5%93%88%EF%BC%8C%E6%88%91%E6%98%AF%E6%9D%A5%E8%87%AA%E9%A1%B5%E9%9D%A2a.html%E7%9A%84%E4%BF%A1%E6%81%AF%E5%93%9F%EF%BC%81'%2C'*')%3B%2F%2F%E5%90%91%E4%B8%8D%E5%90%8C%E5%9F%9F%E7%9A%84www.script.com%2Fb.html%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%5Cn%7D%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22iGZIy%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;iframe id=&quot;iframe&quot; src=&quot;www.script.com/b.html&quot; onload=&quot;onLoad()&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script&amp;gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; onLoad(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iframe = document.getElementById(&quot;iframe&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; win =&lt;span&gt; iframe.contentWindow;
    win.postMessage(&lt;/span&gt;'哈哈，我是来自页面a.html的信息哟！','*');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向不同域的www.script.com/b.html发送消息&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;9298f259ed20cce610098e14cb2aaed1&quot;&gt;2.创建www.script.com/b.html页面代码&lt;/p&gt;
&lt;div id=&quot;JGsaR&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cscript%3E%5Cnwindow.onmessage%20%3D%20function(e)%7B%5Ct%2F%2F%E6%B3%A8%E5%86%8Cmessage%E6%97%B6%E9%97%B4%E6%9D%A5%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%5Cn%20%20%20%20e%20%3D%20e%20%7C%7C%20event%3B%20%20%20%20%20%20%20%20%20%20%20%20%5Ct%2F%2F%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E5%AF%B9%E8%B1%A1%5Cn%20%20%20%20alert(e.data)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ct%2F%2F%E9%80%9A%E8%BF%87data%E5%B1%9E%E6%80%A7%E6%9D%A5%E5%BE%97%E5%88%B0%E4%BC%A0%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%5Cn%7D%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22JGsaR%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
window.onmessage &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(e){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册message时间来接收消息&lt;/span&gt;
    e = e || event;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取时间对象&lt;/span&gt;
    alert(e.data);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过data属性来得到传送的消息&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;Ejwjz&quot; data-lake-id=&quot;1455ebb20fa56b1e7127628c72d0b2af&quot;&gt;&lt;strong&gt;使用location.hash+iframe&lt;/strong&gt;&lt;/h3&gt;
&lt;p data-lake-id=&quot;cbde70d6fa3ddbdb1f7054296ee02ba9&quot;&gt;&lt;strong&gt;跨域原理：&lt;/strong&gt;使用location.hash和iframe来绕过同源策略&lt;/p&gt;
&lt;p data-lake-id=&quot;b88b0a131736fd10b43bc2171fd3318a&quot;&gt;&lt;strong&gt;注意⚠️：需要借用两个iframe&lt;/strong&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;9793121269f96b7bdccc80ead9fdc0dc&quot;&gt;假设域名test.com下的文件a.html要和csdnblogs.com域名下的b.html传递信息&lt;/p&gt;
&lt;p data-lake-id=&quot;bc91aac35c6706a350026b28cfb0abed&quot;&gt;1.创建test.com下的a.html页面， 同时在a.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值&lt;/p&gt;
&lt;p data-lake-id=&quot;1dee5df21099072073d14abd4247fe7c&quot;&gt;www.test.com下a.html代码&lt;/p&gt;
&lt;div id=&quot;n8hIo&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cscript%3E%5Cnfunction%20startRequest()%7B%5Cn%20%20%20%20var%20ifr%20%3D%20document.createElement('iframe')%3B%5Cn%20%20%20%20%2F%2F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9A%90%E8%97%8F%E7%9A%84iframe%5Cn%20%20%20%20ifr.style.display%20%3D%20'none'%3B%5Cn%20%20%20%20ifr.src%20%3D%20'http%3A%2F%2Fwww.csdnblogs.com%2Fb.html%23paramdo'%3B%5Cn%20%20%20%20%2F%2F%E4%BC%A0%E9%80%92%E7%9A%84location.hash%20%5Cn%20%20%20%20document.body.appendChild(ifr)%3B%5Cn%7D%5Cn%5Cnfunction%20checkHash()%20%7B%5Cn%20%20%20%20try%20%7B%5Cn%20%20%20%20%20%20%20%20var%20data%20%3D%20location.hash%20%3F%20location.hash.substring(1)%3A''%3B%5Cn%20%20%20%20%20%20%20%20if%20(console.log)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20console.log('Now%20the%20data%20is%20'%20%2B%20data)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%20catch%20(e)%20%7B%7D%3B%5Cn%7D%5CnsetInterval(checkHash%2C%205000)%3B%5Cnwindow.onload%20%3D%20startRequest%3B%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22n8hIo%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; startRequest(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ifr = document.createElement('iframe'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个隐藏的iframe&lt;/span&gt;
    ifr.style.display = 'none'&lt;span&gt;;
    ifr.src &lt;/span&gt;= 'http://www.csdnblogs.com/b.html#paramdo'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递的location.hash &lt;/span&gt;
&lt;span&gt;    document.body.appendChild(ifr);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkHash() {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = location.hash ? location.hash.substring(1):''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (console.log) {
            console.log(&lt;/span&gt;'Now the data is ' +&lt;span&gt; data);
        }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {};
}
setInterval(checkHash, &lt;/span&gt;5000&lt;span&gt;);
window.onload &lt;/span&gt;=&lt;span&gt; startRequest;
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;af81f09764f1180a072e8a8ba4d84879&quot;&gt;2.b.html响应请求后再将通过修改test.com域名下的文件c.html来间接a.html的hash值来传递数据，代码如下：&lt;/p&gt;
&lt;p data-lake-id=&quot;9df10ee9ea5e94c60de0a5ea93d8f448&quot;&gt;www.csdnblogs.com域名下b.html代码&lt;/p&gt;
&lt;div id=&quot;3sDuY&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cscript%3E%5Cnfunction%20checkHash()%20%7B%5Cn%20%20%20%20var%20data%20%3D%20''%3B%5Cn%20%20%20%20%2F%2F%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%5Cn%20%20%20%20switch%20(location.hash)%20%7B%5Cn%20%20%20%20%20%20%20%20case%20'%23paramdo'%3A%5Cn%20%20%20%20%20%20%20%20%20%20%20%20data%20%3D%20'somedata'%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20break%3B%5Cn%20%20%20%20%20%20%20%20case%20'%23paramset'%3A%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2Fdo%20something%E2%80%A6%E2%80%A6%5Cn%20%20%20%20%20%20%20%20%20%20%20%20break%3B%5Cn%20%20%20%20%20%20%20%20default%3A%5Cn%20%20%20%20%20%20%20%20%20%20%20%20break%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20data%20%26%26%20callBack('%23'%20%2B%20data)%3B%5Cn%7D%5Cn%5Cnfunction%20callBack(hash)%20%7B%5Cn%20%20%20%20%2F%2F%20ie%E3%80%81chrome%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E6%97%A0%E6%B3%95%E4%BF%AE%E6%94%B9parent.location.hash%5Cn%20%20%20%20%2F%2F%E6%89%80%E4%BB%A5%E8%A6%81%E5%88%A9%E7%94%A8%E4%B8%80%E4%B8%AA%E4%B8%AD%E9%97%B4%E7%9A%84www.csdnblogs.com%E5%9F%9F%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86iframe%5Cn%20%20%20%20var%20proxy%20%3D%20document.createElement('iframe')%3B%5Cn%20%20%20%20proxy.style.display%20%3D%20'none'%3B%5Cn%20%20%20%20proxy.src%20%3D%20'http%3A%2F%2Fwww.csdnblogs.com%2Fc.html'%20%2B%20hash%3B%20%5Cn%20%20%20%20%2F%2F%20%E6%B3%A8%E6%84%8F%E8%AF%A5%E6%96%87%E4%BB%B6%E5%9C%A8%5C%22www.test.com%5C%22%E5%9F%9F%E4%B8%8B%5Cn%20%20%20%20document.body.appendChild(proxy)%3B%5Cn%7D%5Cnwindow.onload%20%3D%20checkHash%3B%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%223sDuY%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkHash() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = ''&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟一个简单的参数处理操作&lt;/span&gt;
    &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (location.hash) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; '#paramdo'&lt;span&gt;:
            data &lt;/span&gt;= 'somedata'&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; '#paramset'&lt;span&gt;:
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something……&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    data &lt;/span&gt;&amp;amp;&amp;amp; callBack('#' +&lt;span&gt; data);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; callBack(hash) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ie、chrome的安全机制无法修改parent.location.hash&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以要利用一个中间的www.csdnblogs.com域下的代理iframe&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; proxy = document.createElement('iframe'&lt;span&gt;);
    proxy.style.display &lt;/span&gt;= 'none'&lt;span&gt;;
    proxy.src &lt;/span&gt;= 'http://www.csdnblogs.com/c.html' +&lt;span&gt; hash; 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意该文件在&quot;www.test.com&quot;域下&lt;/span&gt;
&lt;span&gt;    document.body.appendChild(proxy);
}
window.onload &lt;/span&gt;=&lt;span&gt; checkHash;
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;d31d5b712ae7473dccdbc57c4376f396&quot;&gt;www.test.com下c.html代码&lt;/p&gt;
&lt;div id=&quot;f6ymH&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cscript%3E%5Cn%2F%2F%E5%9B%A0%E4%B8%BAparent.parent%E5%92%8C%E8%87%AA%E8%BA%AB%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E5%9F%9F%EF%BC%8C%E6%89%80%E4%BB%A5%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%85%B6location.hash%E7%9A%84%E5%80%BC%5Cnparent.parent.location.hash%20%3D%20self.location.hash.substring(1)%3B%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22f6ymH%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值&lt;/span&gt;
parent.parent.location.hash = self.location.hash.substring(1&lt;span&gt;);
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;fw584&quot; data-lake-id=&quot;07adc0c355a58254b12cee87f6e721dd&quot;&gt;&lt;strong&gt;跨域资源共享（CORS）&lt;/strong&gt;&lt;/h3&gt;
&lt;p data-lake-id=&quot;01d287f73051f67355a231d336b14c06&quot;&gt;&lt;strong&gt;跨域原理：&lt;/strong&gt;一种跨域访问的机制，可以让AJAX实现跨域访问；CORS允许一个域上的网络应用向另一个域提交跨域AJAX请求。&lt;/p&gt;
&lt;p data-lake-id=&quot;8853cf1e8d307693f017738d6f2638f7&quot;&gt;&lt;strong&gt;注意⚠️：&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-lake-id=&quot;956ab35f25ee442074086b56a70fa0e8&quot;&gt;&lt;li data-lake-id=&quot;0702b7daa1a45537e8d328cd3c298bf7&quot;&gt;只有服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求。就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。&lt;/li&gt;
&lt;li data-lake-id=&quot;ef62c9a461a437a9bc58c43ec5f13082&quot;&gt;CORS机制是同源策略出让的安全性之一。其余两个为允许嵌入第三方资源和跨文档消息机制(window.postmessage)。详情：&lt;a href=&quot;https://www.yuque.com/suihangadam/liulanqi/pog4pf&quot; target=&quot;_blank&quot;&gt;https://www.yuque.com/suihangadam/liulanqi/pog4pf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-lake-id=&quot;2907544270249b4b236b26dc10ef2f94&quot;&gt;&lt;strong&gt;IE中对CORS的实现是通过xdr&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;Lf8KZ&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20xdr%20%3D%20new%20XDomainRequest()%3B%5Cnxdr.onload%20%3D%20function()%7B%5Cn%20%20%20%20console.log(xdr.responseText)%3B%5Cn%7D%5Cnxdr.open('get'%2C%20'http%3A%2F%2Fwww.test.com')%3B%5Cn......%5Cnxdr.send(null)%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22Lf8KZ%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; xdr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XDomainRequest();
xdr.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(xdr.responseText);
}
xdr.open(&lt;/span&gt;'get', 'http://www.test.com'&lt;span&gt;);
......
xdr.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;3f40297efa368a01805c4dbe0bc0e345&quot;&gt;&lt;strong&gt;其它浏览器中的实现就在xhr中&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;9GhlF&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20xhr%20%3D%20%20new%20XMLHttpRequest()%3B%5Cnxhr.onreadystatechange%20%3D%20function%20()%20%7B%5Cn%20%20if(xhr.readyState%20%3D%3D%3D%204%20%26%26%20xhr.status%20%3D%3D%3D%20200)%7B%5Cn%20%20%20%20%20%20%20%20console.log(xhr.responseText)%3B%5Cn%20%20%20%20%20%20%20%20%7D%20%5Cn%20%20%20%20%7D%5Cn%7D%5Cnxhr.open('get'%2C%20'http%3A%2F%2Fwww.test.com')%3B%5Cn......%5Cnxhr.send(null)%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%229GhlF%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; xhr =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
xhr.onreadystatechange &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xhr.readyState === 4 &amp;amp;&amp;amp; xhr.status === 200&lt;span&gt;){
        console.log(xhr.responseText);
        } 
    }
}
xhr.open(&lt;/span&gt;'get', 'http://www.test.com'&lt;span&gt;);
......
xhr.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;1bb1fb260525e824c9ed9dce68a19d4e&quot;&gt;&lt;strong&gt;实现跨浏览器的CORS&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;MBhWC&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20createCORS(method%2C%20url)%7B%5Cn%20%20%20%20var%20xhr%20%3D%20new%20XMLHttpRequest()%3B%5Cn%20%20%20%20if('withCredentials'%20in%20xhr)%7B%5Cn%20%20%20%20%20%20%20%20xhr.open(method%2C%20url%2C%20true)%3B%5Cn%20%20%20%20%7Delse%20if(typeof%20XDomainRequest%20!%3D%20'undefined')%7B%5Cn%20%20%20%20%20%20%20%20var%20xhr%20%3D%20new%20XDomainRequest()%3B%5Cn%20%20%20%20%20%20%20%20xhr.open(method%2C%20url)%3B%5Cn%20%20%20%20%7Delse%7B%5Cn%20%20%20%20%20%20%20%20xhr%20%3D%20null%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20xhr%3B%5Cn%7D%5Cnvar%20request%20%3D%20createCORS('get'%2C%20'http%3A%2F%2Fwww.test.com')%3B%5Cnif(request)%7B%5Cn%20%20%20%20request.onload%20%3D%20function()%7B%5Cn%20%20%20%20%20%20%20%20......%5Cn%20%20%20%20%7D%3B%5Cn%20%20%20%20request.send()%3B%5Cn%7D%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22MBhWC%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createCORS(method, url){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;('withCredentials' &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xhr){
        xhr.open(method, url, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; XDomainRequest != 'undefined'&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XDomainRequest();
        xhr.open(method, url);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        xhr &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xhr;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request = createCORS('get', 'http://www.test.com'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(request){
    request.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        ......
    };
    request.send();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;7utx1&quot; data-lake-id=&quot;5c8b817dc197cc1761d71bb6b4dd5c1c&quot;&gt;&lt;strong&gt;Web sockets&lt;/strong&gt;&lt;/h3&gt;
&lt;p data-lake-id=&quot;324796771af79a5246c7c9136a91bdac&quot;&gt;&lt;strong&gt;跨域原理：&lt;/strong&gt; 是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)，在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。&lt;/p&gt;
&lt;div id=&quot;TiliQ&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%3Cscript%3E%5Cn%20%20var%20socket%20%3D%20new%20WebSockt('ws%3A%2F%2Fwww.test.com')%3B%5Cn%20%20%2F%2Fhttp-%3Ews%3B%20https-%3Ewss%5Cn%20%20socket.send('hello%20WebSockt')%3B%5Cn%20%20socket.onmessage%20%3D%20function(event)%7B%5Cn%20%20%20%20%20%20var%20data%20%3D%20event.data%3B%5Cn%20%20%7D%5Cn%3C%2Fscript%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22TiliQ%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
  &lt;span&gt;var&lt;/span&gt; socket = &lt;span&gt;new&lt;/span&gt; WebSockt('ws://www.test.com'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;http-&amp;gt;ws; https-&amp;gt;wss&lt;/span&gt;
  socket.send('hello WebSockt'&lt;span&gt;);
  socket.onmessage &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; event.data;
  }
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;XCDf6&quot; data-lake-id=&quot;ab452ab45b705a1b84a56381251207a8&quot;&gt;使用nginx进行反向代理&lt;/h3&gt;
&lt;p data-lake-id=&quot;15f18cef45fbd7cf337b42673d62c8ce&quot;&gt;&lt;strong&gt;跨域原理&lt;/strong&gt;：Nginx反向代理将对真实服务器的请求转移到本机服务器来避免浏览器的&quot;同源策略限制&quot;。&lt;/p&gt;
&lt;p data-lake-id=&quot;7d6d0302ee41e2f4dc8f5c40381ff463&quot;&gt;Nginx是一个高性能的HTTP和&lt;a href=&quot;https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488&quot; target=&quot;_blank&quot;&gt;反向代理&lt;/a&gt;web服务器&lt;/p&gt;
&lt;p data-lake-id=&quot;c129c1e8f3d5ca825117b7cddd1c8609&quot;&gt;&lt;span class=&quot;lake-card-margin-top lake-card-margin-bottom lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1599320715725-55c076aa-1d7e-4032-a6ec-5c935d08e689.png%22%2C%22originWidth%22%3A423%2C%22originHeight%22%3A325%2C%22name%22%3A%22image.png%22%2C%22size%22%3A81587%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A319.79565%2C%22y%22%3A89.92758%2C%22width%22%3A41.076419999999985%2C%22height%22%3A9.494485999999995%2C%22text%22%3A%22server%22%7D%2C%7B%22x%22%3A319.121%2C%22y%22%3A180.00572%2C%22width%22%3A42.280700000000024%2C%22height%22%3A10.658080000000012%2C%22text%22%3A%22server2%22%7D%2C%7B%22x%22%3A167.48984%2C%22y%22%3A189.10753%2C%22width%22%3A88.68046000000001%2C%22height%22%3A10.889849999999996%2C%22text%22%3A%22www.baidu.com%22%7D%2C%7B%22x%22%3A41.929157%2C%22y%22%3A208.55603%2C%22width%22%3A28.352953000000007%2C%22height%22%3A11.200680000000006%2C%22text%22%3A%22local%22%7D%2C%7B%22x%22%3A315.63998%2C%22y%22%3A278.6993%2C%22width%22%3A43.83179000000001%2C%22height%22%3A11.709569999999985%2C%22text%22%3A%22server3%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22server%20server2%20www.baidu.com%20local%20server3%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A211.5%2C%22height%22%3A163%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1599320715725-55c076aa-1d7e-4032-a6ec-5c935d08e689.png&quot; alt=&quot;image.png&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;163px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;6b808c500a8fdcb6c68051241074448e&quot;&gt;注意⚠️： 反向代理隐藏了真实的服务器&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p data-lake-id=&quot;2dfebe278feed17c16f0e6c5379ac67d&quot;&gt;扩展：正向代理隐藏了真实的客户端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-lake-id=&quot;5fbae179c3fc63f1a51b059a01849324&quot;&gt;&lt;strong&gt;Nginx 反向代理模块 proxy_pass&lt;/strong&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;87269babc2c1cf8fa2ab1483096320cc&quot;&gt;proxy_pass 后面跟着一个 URL，用来将请求反向代理到 URL 参数指定的服务器上。例如我们上面例子中的 proxy_pass &lt;a href=&quot;https://api.shanbay.com&quot; target=&quot;_blank&quot;&gt;https://api.shanbay.com&lt;/a&gt;，则将匹配的请求反向代理到 &lt;a href=&quot;https://api.shanbay.com/&quot; target=&quot;_blank&quot;&gt;https://api.shanbay.com&lt;/a&gt;。&lt;/p&gt;
&lt;p data-lake-id=&quot;51fba9f9d16cf85a6ad0e8d39bf53355&quot;&gt;通过在配置文件中增加proxy_pass 你的服务器ip,就可以完成反向代理。&lt;/p&gt;
&lt;div id=&quot;9RV3J&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22server%20%7B%5Cn%20%20%20%20listen%20%20%20%20%20%20%2080%3B%5Cn%20%20%20%20server_name%20%20localhost%3B%5Cn%20%20%20%20%23%23%20%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%20localhost%EF%BC%8C%E5%88%99%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%B0https%3A%2F%2Fapi.shanbay.com%5Cn%20%20%20%20location%20%2F%20%7B%5Cn%20%20%20%20%20%20%20%20root%20%20%20html%3B%5Cn%20%20%20%20%20%20%20%20index%20%20index.html%20index.htm%3B%5Cn%20%20%20%20%20%20%20%20proxy_pass%20https%3A%2F%2Fapi.shanbay.com%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%229RV3J%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
    listen       &lt;/span&gt;80&lt;span&gt;;
    server_name  localhost;
    ## 用户访问 localhost，则反向代理到https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;api.shanbay.com&lt;/span&gt;
    location /&lt;span&gt; {
        root   html;
        index  index.html index.htm;
        proxy_pass https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;api.shanbay.com;&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;2.0779220779221&quot;&gt;
&lt;p data-lake-id=&quot;1615c6835b558322e30d296cabe73930&quot;&gt;nginx反向代理详细配置：&lt;a href=&quot;https://www.cnblogs.com/ddlove/p/9945988.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ddlove/p/9945988.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;TQiIH&quot; data-lake-id=&quot;bc80ed91e73777d85e207e839c541280&quot;&gt;使用webpack配置代理&lt;/h3&gt;
&lt;p data-lake-id=&quot;47c09432efd74e37135da31dcb3e8cbe&quot;&gt;&lt;strong&gt;前提条件&lt;/strong&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;86866a09dd616cdc903bb1c5153a4cc6&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;1、需要使用本地开发插件：&lt;a href=&quot;https://github.com/webpack/webpack-dev-server&quot; target=&quot;_blank&quot;&gt;webpack-dev-server&lt;/a&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;cc9f37bae2e3c88bb22980720f485055&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;2、webpack-dev-server使用的是&lt;a href=&quot;https://github.com/chimurai/http-proxy-middleware&quot; target=&quot;_blank&quot;&gt;http-proxy-middleware&lt;/a&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;来实现跨域代理的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;3ysmT&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22module.exports%20%3D%20%7B%5Cn%20%20%2F%2F...%5Cn%20%20devServer%3A%20%7B%5Cn%20%20%20%20proxy%3A%20%7B%5Cn%20%20%20%20%20%20'%2Fapi'%3A%20%7B%5Cn%20%20%20%20%20%20%20%20target%3A%20'http%3A%2F%2Fwww.baidu.com%2F'%2C%5Cn%20%20%20%20%20%20%20%20pathRewrite%3A%20%7B'%5E%2Fapi'%20%3A%20''%7D%2C%5Cn%20%20%20%20%20%20%20%20changeOrigin%3A%20true%2C%20%20%20%20%20%2F%2F%20target%E6%98%AF%E5%9F%9F%E5%90%8D%E7%9A%84%E8%AF%9D%EF%BC%8C%E9%9C%80%E8%A6%81%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%5Cn%20%20%20%20%20%20%20%20secure%3A%20false%2C%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%AE%BE%E7%BD%AE%E6%94%AF%E6%8C%81https%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BB%A3%E7%90%86%5Cn%20%20%20%20%20%20%7D%2C%5Cn%20%20%20%20%20%20'%2Fapi2'%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20.....%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%7D%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%223ysmT%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;  devServer: {
    proxy: {
      &lt;/span&gt;'/api'&lt;span&gt;: {
        target: &lt;/span&gt;'http://www.baidu.com/'&lt;span&gt;,
        pathRewrite: {&lt;/span&gt;'^/api' : ''&lt;span&gt;},
        changeOrigin: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; target是域名的话，需要这个参数，&lt;/span&gt;
        secure: &lt;span&gt;false&lt;/span&gt;,          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置支持https协议的代理&lt;/span&gt;
&lt;span&gt;      },
      &lt;/span&gt;'/api2'&lt;span&gt;: {
          .....
      }
    }
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;1.2931034482759&quot;&gt;
&lt;p data-lake-id=&quot;9b35c72110b725f5c1489f4243da764d&quot;&gt;参考自&lt;/p&gt;
&lt;p data-lake-id=&quot;1a1048333c4922cc6939c62cb2b75da8&quot;&gt;百度百科&lt;/p&gt;
&lt;p data-lake-id=&quot;002986b9e73704d8afa5bdf43b686d38&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/wangchengiii/article/details/78081032&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/wangchengiii/article/details/78081032&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;1a5ee93c418e5b5b4f92dbd5c6d48eba&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/mmy67/p/10032915.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/mmy67/p/10032915.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;3521a6aa7ae2b55bd9e8fbdcd3ad7fed&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/mmy67/p/10032915.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/mmy67/p/10032915.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-lake-id=&quot;a86c400e6d715fd2e57fb30ed0ab8055&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 05 Sep 2020 16:03:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>产生原因 为什么会产生跨域呢，因为浏览器为了安全采用了一系列的安全机制，其中有一个是同源策略。何为同源策略（same-origin policy）。简单来讲同源策略就是浏览器为了保证用户信息的安全，防</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suihang/p/13620361.html</dc:identifier>
</item>
<item>
<title>MySQL 事务操作 - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/13620295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/13620295.html</guid>
<description>&lt;p&gt;　　 事务是指对一组&lt;code&gt;SQL&lt;/code&gt;语句进行一个原子化的操作，即如果这一组&lt;code&gt;SQL&lt;/code&gt;语句中有一条发生错误，那么其他的同组&lt;code&gt;SQL&lt;/code&gt;就都不会被执行。&lt;/p&gt;
&lt;p&gt;　　 你可以把它当作一个测试，当你执行完一组&lt;code&gt;SQL&lt;/code&gt;语句后，可以查看一下结果是否正确，如果正确后可以选择提交，如果不正确则可以进行回滚，恢复到原本的状态。&lt;/p&gt;
&lt;p&gt;　　 在&lt;code&gt;MySQL&lt;/code&gt;中，所有的操作默认都是自动进行提交，当开启事务后则变为手动提交。&lt;/p&gt;

&lt;h2&gt;单独开启&lt;/h2&gt;
&lt;p&gt;　　 单独开启是指对某一组的&lt;code&gt;SQL&lt;/code&gt;语句开启事务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE user(
        id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
        name CHAR(12) NOT NULL,
        balance INT UNSIGNED 
); -- 创建用户表

INSERT INTO user(name,balance) VALUES
        (&quot;Yunya&quot;,1000),
        (&quot;Ken&quot;,500); -- 插入数据


start transaction; -- 开启事务，增删改操作均要手动提交

        UPDATE user SET balance = 500 WHERE name = &quot;Yunya&quot;; -- Yunya对Ken转账500
        UPDATE user SET balance = 1000 WHERE name = &quot;Ken&quot;;
        SELECT * FROM user; -- 验证是否出错

        COMMIT; -- 提交事务：手动提交上面两条UPDATE
        -- ROLLBACK; -- 事务回滚：转账金额不对时使用回滚

BEGIN -- 关闭事务，增删改操作均自动提交
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;全局开启&lt;/h2&gt;
&lt;p&gt;　　 如果所有&lt;code&gt;SQL&lt;/code&gt;都使用事务操作，我们可以通过 &lt;code&gt;SET AUTOCOMMIT=0&lt;/code&gt; 关闭自动提交来开启事务机制，这样所有语句都是事务类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 关闭自动提交
SET AUTOCOMMIT = 0;

INSERT INTO user(name,balance) VALUES
        ('Jack',8000);
        
COMMIT;

-- 开启自动提交
SET AUTOCOMMIT = 1;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;并发问题&lt;/h2&gt;
&lt;p&gt;　　 当高并发访问会遇到多个事务的隔离问题，可能会出现以下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据&lt;/li&gt;
&lt;li&gt;不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。&lt;/li&gt;
&lt;li&gt;幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;　　 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表&lt;/p&gt;
&lt;h2&gt;隔离级别&lt;/h2&gt;
&lt;p&gt;　　 系统默认隔离级别为3级，可能出现幻读的情况。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;中文释义&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;read uncommitted&lt;/td&gt;
&lt;td&gt;读未提交&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;read committed&lt;/td&gt;
&lt;td&gt;不可重复读&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;repeatable read&lt;/td&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;serializable&lt;/td&gt;
&lt;td&gt;串行化&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 一般来说系统默认的3级就足以应付大部分应用场景，但是设计金融类数据时一定要慎重。&lt;/p&gt;
&lt;h2&gt;查询设置&lt;/h2&gt;
&lt;p&gt;　　 查询隔离级别&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot; lang=&quot;text&quot;&gt;select @@tx_isolation;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 设置隔离级别&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot; lang=&quot;text&quot;&gt;set session transaction isolation level read uncommitted; -- set session只对当前会话有效，set global则对全局有效
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 05 Sep 2020 15:35:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>基础知识 事务是指对一组SQL语句进行一个原子化的操作，即如果这一组SQL语句中有一条发生错误，那么其他的同组SQL就都不会被执行。 你可以把它当作一个测试，当你执行完一组SQL语句后，可以查看一下结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/13620295.html</dc:identifier>
</item>
<item>
<title>利用递归方法实现链表反转、前N个节点反转以及中间部分节点反转 - CHAN_傑</title>
<link>http://www.cnblogs.com/Code-CHAN/p/13620048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Code-CHAN/p/13620048.html</guid>
<description>&lt;h3 id=&quot;一、反转整个链表&quot;&gt;一、反转整个链表&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//单链表的实现结构
public class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x;}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反转链表利用迭代不难实现，如果使用递归则有些许难度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先来看源码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ListNode reverse(ListNode head) {
  if(head == null || head.next == null)
    return head;
  ListNode ret = reverse(head.next);
  head.next.next = head;
  head.next = null;
  return ret;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是否看起来不知所云，而又被这如此简洁的代码所震撼？让我们一起探索一下其中的奥秘。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于递归算法，最重要的是明确递归函数的定义。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的&lt;code&gt;reverse&lt;/code&gt;函数的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入一个节点&lt;code&gt;head&lt;/code&gt;,将以&lt;code&gt;head&lt;/code&gt;为起点的链表反转，并返回反转之后的头节点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2134418/202009/2134418-20200905222603142-1095795832.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;明白了函数的定义后，在来看这个问题。比如我们想反转这个链表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gig4tmomavj32990u0dj9.jpg&quot; alt=&quot;截屏2020-09-05 21.06.50&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么输入&lt;code&gt;reverse（head）&lt;/code&gt;后，会在&lt;code&gt;ListNode ret = reverse(head.next);&lt;/code&gt;进行递归&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要跳进递归！&lt;/strong&gt;（你的脑袋能压几个栈呀？）&lt;/p&gt;
&lt;p&gt;根据&lt;code&gt;reverse&lt;/code&gt;函数的定义，函数调用后会返回反转之后的头节点，我们用变量&lt;code&gt;ret&lt;/code&gt;接收&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gig4tm51hlj317k0g4wfo.jpg&quot; alt=&quot;截屏2020-09-05 21.14.18&quot; loading=&quot;lazy&quot;/&gt;现在再来看一下代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;head.next.next = head;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gig4tjjd3gj31860ieq4e.jpg&quot; alt=&quot;截屏2020-09-05 21.16.19&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;head.next = null;
return ret;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gig4tlhsaij317m0he3zw.jpg&quot; alt=&quot;截屏2020-09-05 21.18.16&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再跳出这层递归就会得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gig4tirt6hj318s0hyq47.jpg&quot; alt=&quot;截屏2020-09-05 21.19.41&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;神不神奇，这样整个链表就反转过来了！&lt;/p&gt;
&lt;p&gt;递归代码就是这么简洁优雅，但要注意两个问题：&lt;/p&gt;
&lt;p&gt;1、递归函数要有base case，不然就会一直递归，导致栈溢出&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if (head == null || head.next == null) return head;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;即链表为空或只有一个节点，直接返回&lt;/p&gt;
&lt;p&gt;2、当链表递归反转后，新的头节点为&lt;code&gt;ret&lt;/code&gt;,而&lt;code&gt;head&lt;/code&gt;变成了最后一个节点，应该令链表的某尾指向&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;head.next = null;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;理解这两个问题之后，我们可以进一步深入研究链表反转的问题，接下来的问题其实均为在这个算法上的扩展。&lt;/p&gt;
&lt;h3 id=&quot;二、反转链表前n个节点&quot;&gt;二、反转链表前N个节点&lt;/h3&gt;
&lt;p&gt;接下来我们来看这个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;反转链表前N个节点，并返回链表头节点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;1 &amp;lt;= N &amp;lt;= 链表长度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, n = 4
输出: 4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;5-&amp;gt;NULL
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决思路和反转整个链表差不多，只需稍加修改&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ListNode successor = null; // 后驱节点（第 n + 1 个节点）

ListNdoe reverseN(ListNode head, int n) {
  if (n == 1) {
    successor = head.next;
    return head;
  }
  // 以 head.next 为起点，需要反转前 n - 1 个节点
  ListNode ret = reverseN(head.next, n - 1);
  head.next.next = head;
  head.next = successor; // 将反转后的 head 与后面节点连接
  return ret;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体区别：&lt;/p&gt;
&lt;p&gt;1、base case 变为&lt;code&gt;n == 1&lt;/code&gt;, 同时需要&lt;strong&gt;记录后驱节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2、之前把&lt;code&gt;head.next&lt;/code&gt; 设置为&lt;code&gt;null&lt;/code&gt;,因为整个链表反转后，&lt;code&gt;head&lt;/code&gt;变为最后一个节点。&lt;/p&gt;
&lt;p&gt;现在&lt;code&gt;head&lt;/code&gt;节点在递归反转后不一定为最后一个节点，故应记录后驱&lt;code&gt;successor&lt;/code&gt;(第 n + 1 个节点), 反转之后将&lt;code&gt;head&lt;/code&gt;连接上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2134418/202009/2134418-20200905222640702-566505710.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，如果这个函数你也能看懂，就离实现&lt;strong&gt;反转一部分链表&lt;/strong&gt;不远了。&lt;/p&gt;
&lt;h3 id=&quot;三、反转链表的一部分&quot;&gt;三、反转链表的一部分&lt;/h3&gt;
&lt;p&gt;现在我们开始解决这个问题，给一个索引区间&lt;code&gt;[m, n]&lt;/code&gt;（索引从1开始），仅仅反转区间中的链表元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;1 &amp;lt;= m &amp;lt;= n &amp;lt;= 链表长度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4
输出: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;猛一看很难想到思路。&lt;/p&gt;
&lt;p&gt;试想一下，如果&lt;code&gt;m == 1&lt;/code&gt;,就相当于反转链表的前 n 元素嘛，也就是我们刚才实现的功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ListNode reverseBetween(ListNode head, int m, int n) {
  //base case
  if (m == 1) {
    return reverseN(head, n); // 相当于反转前 n 个元素
  }
  // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那如果&lt;code&gt;m != 1&lt;/code&gt; 该怎么办？&lt;/p&gt;
&lt;p&gt;如果把&lt;code&gt;head&lt;/code&gt;的索引视为&lt;code&gt;1&lt;/code&gt;，那么我们是想从第&lt;code&gt;m&lt;/code&gt;个元素开始反转；&lt;/p&gt;
&lt;p&gt;如果把&lt;code&gt;head.next&lt;/code&gt;的索引视为&lt;code&gt;1&lt;/code&gt;，那么我们是想从第&lt;code&gt;m - 1&lt;/code&gt; 个元素开始反转；&lt;/p&gt;
&lt;p&gt;如果把&lt;code&gt;head.next.next&lt;/code&gt;的索引视为&lt;code&gt;1&lt;/code&gt;，那么我们是想从第&lt;code&gt;m - 2&lt;/code&gt; 个元素开始反转；&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;区别于迭代思想，这就是递归的思想，所以我们可以完成代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ListNode reverseBetween(ListNode head, int m, int n) {
  // base case
  if (m == 1) {
    return reverseN(head, n);
  }
  // 递归前进到触发 base case （m == 1）
  head.next = reverseBetween(head.next, m - 1, n - 1);
  return head;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们终于干掉了大BOSS！&lt;/p&gt;
</description>
<pubDate>Sat, 05 Sep 2020 14:23:00 +0000</pubDate>
<dc:creator>CHAN_傑</dc:creator>
<og:description>一、反转整个链表 问题：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1-&amp;amp;gt;2-&amp;amp;gt;3-&amp;amp;gt;4-&amp;amp;gt;5-&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Code-CHAN/p/13620048.html</dc:identifier>
</item>
<item>
<title>ctf常见源码泄露 - Lmg66</title>
<link>http://www.cnblogs.com/Lmg66/p/13598803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lmg66/p/13598803.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在ctf中发现很多源码泄露的题，总结一下，对于网站的搭建要注意删除备份文件，和一些工具的使用如git，svn等等的规范使用，避免备份文件出现在公网&lt;/p&gt;
&lt;h2 id=&quot;svn源码泄露&quot;&gt;SVN源码泄露&lt;/h2&gt;
&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;
&lt;p&gt;SVN（subversion）是源代码版本管理软件，造成SVN源代码漏洞的主要原因是管理员操作不规范。“在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但一些网站管理员在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，黑客可以借助其中包含的用于版本信息追踪的‘entries’文件，逐步摸清站点结构。”（可以利用.svn/entries文件，获取到服务器源码、svn服务器账号密码等信息）&lt;/p&gt;
&lt;p&gt;更严重的问题在于，SVN产生的.svn目录下还包含了以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录），如果服务器没有对此类后缀做解析，黑客则可以直接获得文件源代码。&lt;/p&gt;
&lt;h3 id=&quot;利用工具svnhack&quot;&gt;利用工具SvnHack&lt;/h3&gt;
&lt;p&gt;github项目地址:&lt;a href=&quot;https://github.com/callmefeifei/SvnHack&quot;&gt;https://github.com/callmefeifei/SvnHack&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;使用需要python2的环境&lt;/strong&gt;&lt;br/&gt;列取目录:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python SvnHack.py -u http://trafficbonus.com/.svn/entries
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202009/2092671-20200901205006339-12260316.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;列取指定目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python SvnHack.py -u http://trafficbonus.com/.svn/entries -d sql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取指定代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python SvnHack.py -u http://trafficbonus.com/.svn/entries -r index.php
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202009/2092671-20200901205558516-409628849.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;下载整站&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python SvnHack.py -u http://trafficbonus.com/.svn/entries --download
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202009/2092671-20200901205733169-437490455.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;git源码泄露&quot;&gt;git源码泄露&lt;/h2&gt;
&lt;h3 id=&quot;原理-2&quot;&gt;原理&lt;/h3&gt;
&lt;p&gt;Git是一个开源的分布式版本控制系统，在执行git init初始化目录的时候，会在当前目录下自动创建一个.git目录，用来记录代码的变更记录等。发布代码的时候，如果没有把.git这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码。&lt;/p&gt;
&lt;h3 id=&quot;利用githack需要python2环境&quot;&gt;利用githack(需要python2环境)&lt;/h3&gt;
&lt;p&gt;github项目地址：&lt;a href=&quot;https://github.com/lijiejie/GitHack&quot;&gt;https://github.com/lijiejie/GitHack&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python GitHack.py http://www.openssl.org/.git/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;hg源码泄露&quot;&gt;hg源码泄露&lt;/h2&gt;
&lt;h3 id=&quot;原理-3&quot;&gt;原理&lt;/h3&gt;
&lt;p&gt;Mercurial 是一种轻量级分布式版本控制系统，使用 hg init的时候会生成.hg文件&lt;/p&gt;
&lt;h3 id=&quot;利用需要perl&quot;&gt;利用需要perl&lt;/h3&gt;
&lt;p&gt;github项目地址：&lt;a href=&quot;https://github.com/kost/dvcs-ripper&quot;&gt;https://github.com/kost/dvcs-ripper&lt;/a&gt;&lt;br/&gt;使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl rip-hg.pl -v -u http://www.example.com/.hg/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202009/2092671-20200901213121294-1874485432.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cvs漏洞泄露&quot;&gt;cvs漏洞泄露&lt;/h2&gt;
&lt;h3 id=&quot;原理-4&quot;&gt;原理&lt;/h3&gt;
&lt;p&gt;CVS是一个C/S系统，是一个常用的代码版本控制软件。主要在开源软件管理中使用。与它相类似的代码版本控制软件有subversion。多个开发人员通过一个中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。CVS版本控制系统是一种GNU软件包，主要用于在多人开发环境下的源码的维护。但是由于之前CVS编码的问题，大多数软件开发公司都使用SVN替代了CVS。主要是针对 CVS/Root以及CVS/Entries目录，直接就可以看到泄露的信息。&lt;br/&gt;&lt;a href=&quot;http://url/CVS/Root&quot;&gt;http://url/CVS/Root&lt;/a&gt; 返回根信息&lt;br/&gt;&lt;a href=&quot;http://url/CVS/Entries&quot;&gt;http://url/CVS/Entries&lt;/a&gt; 返回所有文件的结构&lt;/p&gt;
&lt;h3 id=&quot;利用&quot;&gt;利用&lt;/h3&gt;
&lt;p&gt;github项目地址：&lt;a href=&quot;https://github.com/kost/dvcs-ripper.git&quot;&gt;https://github.com/kost/dvcs-ripper.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;运行示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl rip-cvs.pl -v -u http://www.example.com/CVS/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bazaarbzr泄露&quot;&gt;Bazaar/bzr泄露&lt;/h2&gt;
&lt;h3 id=&quot;原理-5&quot;&gt;原理&lt;/h3&gt;
&lt;p&gt;Bazaar（bzr）是另一个开源的 DVCS（Distributed Version Control System，即分布式版本控制系统），它试图给 SCM（Source Code Management，即源码管理） 的世界里带来一些新的东西。&lt;br/&gt;　　bzr 是 Canonical 公司支持的一个项目，也就是 Ubuntu Linux 的发行公司。简单来说，bzr 是用 python 编写的，用于版本控制。&lt;/p&gt;
&lt;h3 id=&quot;利用-2&quot;&gt;利用&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;perl rip-bzr.pl -v -u http://www.example.com/.bzr/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202009/2092671-20200901214523375-276363481.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;网站备份压缩文件&quot;&gt;网站备份压缩文件&lt;/h2&gt;
&lt;p&gt;管理员将网站源代码备份在Web目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。&lt;/p&gt;
&lt;h3 id=&quot;常见备份文件后缀&quot;&gt;常见备份文件后缀&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;.index.php.swp
index.php.swp
index.php.bak
.index.php~
index.php.bak_Edietplus
index.php.~
index.php.~1~
index.php
index.php~
index.php.rar
index.php.zip
index.php.7z
index.php.tar.gz
www.zip
www.rar
www.zip
www.7z
www.tar.gz
www.tar
web.zip
web.rar
web.zip
web.7z
web.tar.gz
web.tar
wwwroot.rar
web.rar
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;web-infwebxml-泄露&quot;&gt;WEB-INF/web.xml 泄露&lt;/h2&gt;
&lt;p&gt;WEB-INF是Java的WEB应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。&lt;/p&gt;
&lt;p&gt;WEB-INF 主要包含一下文件或目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.
WEB-INF/database.properties : 数据库配置文件
WEB-INF/classes/ : 一般用来存放Java类文件(.class)
WEB-INF/lib/ : 用来存放打包好的库(.jar)
WEB-INF/src/ : 用来放源代码(.asp和.php等)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，再通过反编译 class 文件，得到网站源码。&lt;/p&gt;
&lt;h2 id=&quot;swp-文件泄露&quot;&gt;SWP 文件泄露&lt;/h2&gt;
&lt;p&gt;swp即swap文件，在编辑文件时产生的临时文件，它是隐藏文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，文件名为 .filename.swp。&lt;/p&gt;
&lt;p&gt;漏洞利用：直接访问.swp文件，下载回来后删掉末尾的.swp，获得源码文件。&lt;/p&gt;
&lt;h2 id=&quot;github源码泄露&quot;&gt;github源码泄露&lt;/h2&gt;
&lt;p&gt;GitHub是一个面向开源及私有软件项目的托管平台，很多人喜欢把自己的代码上传到平台托管。攻击者通过关键词进行搜索，可以找到关于目标站点的敏感信息，甚至可以下载网站源码。&lt;/p&gt;
&lt;h3 id=&quot;github常见搜索语法&quot;&gt;github常见搜索语法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;in:name test               #仓库标题搜索含有关键字 SpringCloud
in:descripton test         #仓库描述搜索含有关键字
in:readme test             #Readme文件搜素含有关键字
stars:&amp;gt;3000 test           #stars数量大于3000的搜索关键字
stars:1000..3000 test      #stars数量大于1000小于3000的搜索关键字
forks:&amp;gt;1000 test           #forks数量大于1000的搜索关键字
forks:1000..3000 test      #forks数量大于1000小于3000的搜索关键字
size:&amp;gt;=5000 test           #指定仓库大于5000k(5M)的搜索关键字
pushed:&amp;gt;2019-02-12 test    #发布时间大于2019-02-12的搜索关键字
created:&amp;gt;2019-02-12 test   #创建时间大于2019-02-12的搜索关键字
user:test                  #用户名搜素
license:apache-2.0 test    #明确仓库的 LICENSE 搜索关键字
language:java test         #在java语言的代码中搜索关键字
user:test in:name test     #组合搜索,用户名test的标题含有test的
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;google邮箱搜索&quot;&gt;Google邮箱搜索&lt;/h3&gt;
&lt;p&gt;使用 Github 进行邮件配置信息收集&lt;/p&gt;
&lt;p&gt;很多网站及系统都会使用 pop3 和 smtp 发送来邮件，不少开发者由于安全意识不足会把相关的配置信息也放到Github上，所以如&lt;/p&gt;
&lt;p&gt;果这时候我们动用一下google搜索命令语句，构造一下关键字，就能把这些信息给找出来了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;site:Github.com smtp
 
site:Github.com smtp @qq.com
 
site:Github.com smtp @126.com
 
site:Github.com smtp @163.com
 
site:Github.com smtp @sina.com.cn

site:Github.com smtp password

site:Github.com String password smtp
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据库信息搜集&quot;&gt;数据库信息搜集&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;site:Github.com sa password
 
site:Github.com root password
 
site:Github.com User ID=’sa’;Password
 
site:Github.com inurl:sql
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ds_store泄露&quot;&gt;.DS_Store泄露&lt;/h2&gt;
&lt;p&gt;.DS_Store 文件利用 .DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。###&lt;/p&gt;
&lt;h3 id=&quot;利用-3&quot;&gt;利用&lt;/h3&gt;
&lt;p&gt;github项目地址:&lt;a href=&quot;https://github.com/lijiejie/ds_store_exp&quot;&gt;https://github.com/lijiejie/ds_store_exp&lt;/a&gt;&lt;br/&gt;使用下载后，进入目录更新python2库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;python ds_store_exp.py http://6974-59fce729-40f6-4124-a2c9-a5a66673dc66node3.buuoj.cn:28261/.DS_Store
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;buuctf中的一道题演示，成功拉取了目录&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202009/2092671-20200905140209782-55550966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202009/2092671-20200905140252510-1297482429.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个ctf目录扫描小工具&quot;&gt;一个ctf目录扫描小工具&lt;/h2&gt;
&lt;p&gt;当然也可以自己编写字典，编写脚本，或用dirsearch，御剑等工具扫描，下面介绍一个自己用的ctf目录扫描&lt;br/&gt;项目地址:&lt;a href=&quot;https://github.com/kingkaki/ctf-wscan&quot;&gt;https://github.com/kingkaki/ctf-wscan&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;python3 ctf-wscan.py &lt;a href=&quot;http://beed29ec-8f77-4e15-a1d6-c327148dab8e.node3.buuoj.cn/&quot;&gt;http://beed29ec-8f77-4e15-a1d6-c327148dab8e.node3.buuoj.cn/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202009/2092671-20200905145320882-1349294604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;参数k可以设置关键词&lt;br/&gt;config.py还可以设置关键词，线程，请求方式，是否记录等等，如果你懒得写脚本可以使用，好吧我是懒狗&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202009/2092671-20200905173339131-130526595.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考文章及说明&quot;&gt;参考文章及说明&lt;/h2&gt;
&lt;p&gt;文件的泄露基本都是人为的不正常操作导致的，如直接复制网站发布，github同步，git的.git未删除，注意使用规范，查看自己网站的目录的文件特别是隐藏文件就能很容易的发现，文件的泄露。&lt;br/&gt;参考文章:&lt;a href=&quot;https://www.cnblogs.com/yesec/p/12232045.html&quot;&gt;https://www.cnblogs.com/yesec/p/12232045.html&lt;/a&gt;&lt;br/&gt;最后欢迎访问我的个人博客：&lt;a href=&quot;https://lmg66.github.io/&quot;&gt;https://lmg66.github.io/&lt;/a&gt;&lt;br/&gt;说明：本文仅限技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担&lt;/p&gt;
</description>
<pubDate>Sat, 05 Sep 2020 14:19:00 +0000</pubDate>
<dc:creator>Lmg66</dc:creator>
<og:description>前言 在ctf中发现很多源码泄露的题，总结一下，对于网站的搭建要注意删除备份文件，和一些工具的使用如git，svn等等的规范使用，避免备份文件出现在公网 SVN源码泄露 ###原理 SVN（subve</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lmg66/p/13598803.html</dc:identifier>
</item>
<item>
<title>设计模式-享元模式 - 煮诗君</title>
<link>http://www.cnblogs.com/FindTheWay/p/13620023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FindTheWay/p/13620023.html</guid>
<description>&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;运用&lt;strong&gt;共享技术&lt;/strong&gt;有效地支持大量细粒度的对象。&lt;/p&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;
&lt;p&gt;例如，数据库连接，线程的创建开销都比较大，并且创建频率也非常高，因此就需要用到数据库连接池技术和线程池技术来共享数据库连接和线程。再例如，应用系统中通常存在最多的就是字符串，并且往往会大量重复，如果每次都创建新的字符串，可能会导致内存溢出、GC阻塞等性能问题，因此也就有了字符串驻留池技术。应用场景虽然天差地别，但是无论哪一种场景，往往都会具备如下两个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统会用到大量相同或相似的对象；&lt;/li&gt;
&lt;li&gt;对象创建比较耗时。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;目的&quot;&gt;目的&lt;/h2&gt;
&lt;p&gt;而享元模式正是为了应对上述问题，并达到如下两个目的而存在的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少创建对象的数量；&lt;/li&gt;
&lt;li&gt;对象全局共享。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;其实，说到享元模式，我们最先应该提到的就是活字印刷术，因为它就是享元模式在生活中的一种最佳实践。我们知道，出版一本哪怕百万字的著作，其实常用汉字也不过三千多个，这其中会有大量重复。传统的雕版印刷，每次印刷都需要先花大量的时间刻雕版，并且还不能重复使用，但是活字印刷就将共享和复用的特点发挥到了极致，省去了大量的时间。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202009/474750-20200905194239264-350889662.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;其实，这种例子生活中并不罕见，例如，图书馆借书，共享单车，共享雨伞，共享马扎等哪个不是享元模式思想的体现？因为享元模式的核心思想正是&lt;strong&gt;共享&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们下面还是以活字印刷举例，通过代码的方式来实现一个印刷&lt;code&gt;HELLO WORLD&lt;/code&gt;的例子加以说明。&lt;/p&gt;
&lt;h2 id=&quot;模式演进&quot;&gt;模式演进&lt;/h2&gt;
&lt;p&gt;首先，我们先把字模刻出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public abstract class Typeface
{
    public abstract string Print();
}

public class DTypeface : Typeface
{
    public override string Print()
    {
        return &quot;D&quot;;
    }
}

public class ETypeface : Typeface
{
    public override string Print()
    {
        return &quot;E&quot;;
    }
}

...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是简单的示意，其他字母以此类推，表示一个个的字模。通过这些字模我们就可以印刷出版了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;static void Main(string[] args)
{
    Typeface h = new HTypeface();
    Typeface e = new ETypeface();
    Typeface l = new LTypeface();
    Typeface o = new OTypeface();
    Typeface w = new WTypeface();
    Typeface r = new RTypeface();
    Typeface d = new DTypeface();

    Console.WriteLine($&quot;{h.Print()}{e.Print()}{l.Print()}{l.Print()}{o.Print()} {w.Print()}{o.Print()}{r.Print()}{l.Print()}{d.Print()}&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是很遗憾，虽然印刷成功了，但是这些字模并不能全局共享，说到底还是一次性的，换一个地方还得重新创建一次。不过说到全局共享，我们前面好像就有一种模式可以办到，没错，就是单例模式。我们不妨先用单例模式试试看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public class ETypeface : Typeface
{
    private static readonly Typeface _instance = new ETypeface();

    private ETypeface() { }

    public static Typeface Instance =&amp;gt; _instance;

    public override string Print()
    {
        return &quot;E&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将每个字模都实现成如上所示的单例，再看看调用的地方：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;static void Main(string[] args)
{
    Console.WriteLine($&quot;{HTypeface.Instance.Print()}&quot; +
        $&quot;{ETypeface.Instance.Print()}{LTypeface.Instance.Print()}&quot; +
        $&quot;{LTypeface.Instance.Print()}{OTypeface.Instance.Print()}&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;印刷成功了，并且也全局共享了。不过中国汉字何其多，全部实现成单例，类爆炸了，一个系统中成千上万个单例，想想都可怕。不过好在处理类爆炸我们是有经验的，没错，就是合并：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public class TypefaceFactory
{
    private static readonly Typeface _h = new HTypeface();
    private static readonly Typeface _e = new ETypeface();
    private static readonly Typeface _l = new LTypeface();
    private static readonly Typeface _o = new OTypeface();

    public static Typeface H =&amp;gt; _h;
    public static Typeface E =&amp;gt; _e;
    public static Typeface L =&amp;gt; _l;
    public static Typeface O =&amp;gt; _o;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们额外定义一个类，把所有单例字模都合并进去，不过我们这时静态属性如果还叫&lt;code&gt;Instance&lt;/code&gt;就命名冲突了，直接以字母命名好了，这样我们就把所有单例都消灭了。虽然有所改善，不过字模太多的问题依然严峻，因为这个类中会封装成千上万的字模，并且随时可能更改，这导致这个类极不稳定。不过好在所有字模都继承自同一个基类，因此，我们可以用一个字典存储，并且通过一个静态方法获取字模：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public class TypefaceFactory
{
    private static readonly IDictionary&amp;lt;Type, Typeface&amp;gt; _typefaces 
        = new Dictionary&amp;lt;Type, Typeface&amp;gt;();

    public static Typeface GetTypeface&amp;lt;TTypeface&amp;gt;() where TTypeface : Typeface
    {
        Type type = typeof(TTypeface);
        if (_typefaces.ContainsKey(type))
        {
            return _typefaces[type];
        }

        Typeface typeface = Activator.CreateInstance(typeof(TTypeface)) as Typeface;
        _typefaces.Add(type, typeface);
        return typeface;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话就好多了，可以管理大量细粒度的对象，并且也可以全局共享了，满足了我们的需求，不知大家有没有发现，这里非常像简单工厂模式，只不过这里用到了一个静态字典做缓存，并非每次都全新创建对象，其实这就是享元模式。&lt;/p&gt;
&lt;h2 id=&quot;uml类图&quot;&gt;UML类图&lt;/h2&gt;
&lt;p&gt;再来抽象一下，看看享元模式的类图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202009/474750-20200905194548575-1264274848.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;FlyweightFactory&lt;/strong&gt;：享元工厂，用来创建并管理Flyweight对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flyweight&lt;/strong&gt;：享元类的基类或接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteFlyweight&lt;/strong&gt;：具体的Flyweight子类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UnsharedConcreteFlyweight&lt;/strong&gt;：不需要共享的Flyweight子类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在本例中，&lt;strong&gt;UnsharedConcreteFlyweight&lt;/strong&gt;并没有用到，但是作为享元模式中的一个角色确实是存在的，只是不可共享而已。例如，字模中有规范汉字，也有非规范汉字，但是出版刊物必须使用规范汉字，而不能使用非规范汉字。不过，我们软件开发中会较少用到，因为，既然用不到，就没必要去实现了。&lt;/p&gt;
&lt;h2 id=&quot;优缺点&quot;&gt;优缺点&lt;/h2&gt;
&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;节省内存空间，因为全局共享一个或者少数几个对象而已；&lt;/li&gt;
&lt;li&gt;提高效率，因为不用每次都进行费时的初始化操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;p&gt;增加了系统的复杂度，其实我们通过线程池和数据库连接池就不难发现，确实复杂了很多。&lt;/p&gt;
&lt;h2 id=&quot;改进&quot;&gt;改进&lt;/h2&gt;
&lt;p&gt;其实，到这里我们并没有结束，如果还记得单例模式的话，我们知道这种实现是存在并发问题的，没错，既然同样是用静态字段做共享，那么这里同样存在这并发问题，不过这里并发的是一个代码段，而不是简单的一个字段，因此就不能简单的通过&lt;code&gt;Lazy&lt;/code&gt;关键字解决了，这里必须使用双检锁：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public class TypefaceFactory
{
    private static readonly IDictionary&amp;lt;Type, Typeface&amp;gt; _typefaces 
        = new Dictionary&amp;lt;Type, Typeface&amp;gt;();

    private static readonly object _locker = new object();
    public static Typeface GetTypeface&amp;lt;TTypeface&amp;gt;() where TTypeface : Typeface
    {
        Type type = typeof(TTypeface);
        if (!_typefaces.ContainsKey(type))
        {
            lock (_locker)
            {
                if (!_typefaces.ContainsKey(type))
                {
                    Typeface typeface = Activator.CreateInstance(typeof(TTypeface)) as Typeface;
                    _typefaces.Add(type, typeface);
                }
            }
        }

        return _typefaces[type];
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，这次完美了。&lt;/p&gt;
&lt;p&gt;不过呢，不知大家有没有疑惑，从上面演进步骤看，享元模式好像是单例模式和简单工厂模式的综合运用，为什么享元模式会归类到结构型模式而不是创建型模式呢？其实，原因很简单，从表面上看，好像享元模式的享元工厂也在负责创建对象，但实际上，享元模式最主要的目的是对象的管理而不是创建，例如，我们还可以通过如下方式实现享元模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public class TypefaceFactory
{
    private static readonly IDictionary&amp;lt;string, Typeface&amp;gt; _typefaces
        = new Dictionary&amp;lt;string, Typeface&amp;gt;();


    private static readonly object _locker = new object();

    public static void SetTypeface(string key, Typeface typeface)
    {
        if (!_typefaces.ContainsKey(key))
        {
            lock (_locker)
            {
                if (!_typefaces.ContainsKey(key))
                {
                    _typefaces.Add(key, typeface);
                }
            }
        }
    }

    public static Typeface GetTypeface(string key)
    {
        if (_typefaces.ContainsKey(key))
        {
            return _typefaces[key];
        }

        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到了吗？这里就把对象的创建交给了客户端完成，而享元工厂只负责对象的管理，并不负责对象创建了。&lt;/p&gt;
&lt;h2 id=&quot;与单例模式的区别&quot;&gt;与单例模式的区别&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;享元模式是共享大量类的大量实例，而单例是一个类一个实例；&lt;/li&gt;
&lt;li&gt;单例模式针对的是对象的创建，而享元模式针对的是对象的管理；&lt;/li&gt;
&lt;li&gt;单例模式不能单独创建，而享元模式中的类可以单独创建。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;与简单工厂模式的区别&quot;&gt;与简单工厂模式的区别&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;享元模式在简单工厂模式的基础上加入了缓存；&lt;/li&gt;
&lt;li&gt;简单工厂模式的作用仅仅是创建对象，而享元模式虽然也创建对象，但其主要作用是管理和共享对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;享元模式实现起来非常灵活，它更重要体现的是一种思想，它不仅在生活中被广泛运用，在软件开发过程中也被广泛运用。不妨把上述享元工厂再换一个场景，例如把静态字典换成&lt;code&gt;Redis&lt;/code&gt;，再把&lt;code&gt;GetTypeface&lt;/code&gt;方法换成高并发环境下的查询接口，再去看看执行流程。发现了吧？就是我们每天都在写的代码。&lt;br/&gt;用心发现，享元模式真的是无处不在！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ZShijun/DesignPattern.git&quot;&gt;源码链接&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 Sep 2020 14:19:00 +0000</pubDate>
<dc:creator>煮诗君</dc:creator>
<og:description>运用共享技术有效地支持大量细粒度的对象。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FindTheWay/p/13620023.html</dc:identifier>
</item>
<item>
<title>AQS源码分析 - 辣鸡小篮子</title>
<link>http://www.cnblogs.com/funyoung/p/13619854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funyoung/p/13619854.html</guid>
<description>&lt;p&gt;AQS全称AbstractQueuedSynchronizer（抽象队列同步器）&lt;/p&gt;
&lt;p&gt;AQS中维护了一个被volatile修饰的int类型的同步状态state，以及CLH等待队列。&lt;/p&gt;
&lt;p&gt;state同步状态用于维护同步资源被使用的情况，AQS本身并不关心state的值及其含义，完全由AQS的子类去定义以及维护。&lt;/p&gt;
&lt;p&gt;CLH等待队列是由一个双向链表来实现的，存在head和tail指针分别指向链表中的头节点以及尾节点，同时链表中的节点由AQS中的Node静态内部类来表示。&lt;/p&gt;
&lt;p&gt;ReentrantLock、ReentrantReadWriteLock、CountDownLatch、CyclicBarrier、Semaphore底层都是基于AQS来实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1337502/202009/1337502-20200905214651298-1959428182.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;aqs支持的模式&quot;&gt;AQS支持的模式&lt;/h2&gt;
&lt;p&gt;AQS支持两种模式，一种是独占模式，一种是共享模式。&lt;/p&gt;
&lt;p&gt;独占模式表示，同步资源在同一时刻只能被一个线程所持有，对应AQS的acquire()以及release()方法。&lt;/p&gt;
&lt;p&gt;共享模式表示，同步资源在同一时刻可以被多个线程所持有，对应AQS的acquireShared()以及releaseShared()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;acquire()方法：独占模式下获取同步资源。

release()方法：独占模式下释放同步资源。

acquireShared()方法：共享模式下获取同步资源。

releaseShared()方法：共享模式下释放同步资源。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AQS使用了模板方法设计模式，在acquire()、release()、acquireShared()、releaseShared()方法中都会调用其对应的try方法，比如acquire()方法中会调用tryAcquire()方法，release()方法中会调用tryRelease()方法，AQS子类只需要重写AQS提供的tryAcquire()、tryRelease()或tryAcquireShared()、tryReleaseShared()方法即可，同时需要保证方法的实现是线程安全的。&lt;/p&gt;
&lt;p&gt;tryAcquire()、tryRelease()、tryAcquireShared()、tryReleaseShared()方法都没有使用abstract进行修饰，同时方法中都会直接抛出UnsupportedOperationException异常，好处是不需要强制子类同时实现独占模式和共享模式中的方法，因为大多数AQS的子类都仅支持一种模式，用户只需要根据实际情况进行选择即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;tryAcquire(int arg)方法：独占模式下尝试获取同步资源，同时AQS规定，如果获取同步资源成功则返回true，否则返回false。

tryRelease(int arg)方法：独占模式下尝试释放同步资源，同时AQS规定，如果释放同步资源成功则返回true，否则返回false。

tryAcquireShared(int arg)方法：共享模式下尝试获取同步资源，同时AQS规定，如果获取同步资源失败则返回负数，否则返回剩余的资源个数。

tryReleaseShared(int arg)方法：共享模式下尝试释放同步资源，同时AQS规定，如果释放同步资源成功则返回true，否则返回false。
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;剖析aqs中的node类&quot;&gt;剖析AQS中的Node类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1337502/202009/1337502-20200905214740587-2048898934.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Node类提供的核心属性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 节点封装的线程
volatile Thread thread;

// 指向前驱节点的指针
volatile Node prev;

// 指向后继节点的指针
volatile Node next;

// 节点的等待状态（默认为0）（默认为0）（默认为0） 
volatile int waitStatus;

// 下一个正在等待的节点
Node nextWaiter;

// 共享模式下的标识节点
static final Node SHARED = new Node();

// 独占模式下的标识节点
static final Node EXCLUSIVE = null;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时Node类中维护了一系列节点的等待状态值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// CANCELLED状态，表示线程已超时等等，处于CANCELLED状态的节点会从等待队列中剔除，不会参与到同步资源的竞争当中
static final int CANCELLED =  1;

// SIGNAL状态，如果节点的等待状态为SIGNAL，那么当它释放同步资源时，将会唤醒离它最近的同时等待状态不为CANCELLED的后继节点（同时也能说明节点存在后继节点）
static final int SIGNAL    = -1;

// 表示线程在指定的条件下进行等待
static final int CONDITION = -2;

// PROPAGATE状态，表示实际存在可用资源，需要再往下传播（唤醒）
static final int PROPAGATE = -3;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此每个Node节点中都会包含节点封装的线程、分别指向前驱和后继节点的指针、节点的等待状态、指向下一个正在等待的节点的指针。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;自定义aqs独占模式下的同步器来实现独享锁&quot;&gt;自定义AQS独占模式下的同步器来实现独享锁&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 自定义AQS独占模式下的同步器来实现独享锁
 */
public class Mutex implements Lock, java.io.Serializable {

    /**
     * 自定义AQS独占模式下的同步器
     * 使用state为0表示当前锁没有被线程所持有
     * 使用state为1表示当前锁已经被线程所持有
     */
    private static class Sync extends AbstractQueuedSynchronizer {

        /**
         * 判断锁是否被当前线程所持有
         */
        protected boolean isHeldExclusively() {
            return getExclusiveOwnerThread() == Thread.currentThread();
        }

        /**
         * 尝试获取锁
         * 判断锁是否存在，如果锁不存在则获取锁（通过CAS控制）
         */
        public boolean tryAcquire(int acquires) {
            assert acquires == 1; // 值必须是1（独享锁只有一把锁嘛）
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread()); // 将当前线程设置为独占模式下拥有同步资源的线程
                return true;
            }
            return false;
        }

        /**
         * 尝试释放锁（要求被谁加的锁只能被谁释放）
         * 判断当前拥有同步资源的线程是否为当前线程，如果不是则抛出异常，否则释放锁
         * 这里有三种调用情况，锁空闲的状态下调用、锁已经被线程所持有但被并非拥有锁的线程调用、锁已经被线程所持有并被拥有锁的线程调用，只有第三种情况才能够解锁成功
         */
        protected boolean tryRelease(int releases) {
            assert releases == 1; // 值必须是1（独享锁只有一把锁嘛）
            if (Thread.currentThread() != getExclusiveOwnerThread()) // 要求被谁加的锁只能被谁释放
                throw new IllegalMonitorStateException();
            if (getState() == 0) throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null); // 将独占模式中拥有同步资源的线程置为NULL
            setState(0);
            return true;
        }

        /**
         * 提供一个Condition实例
         */
        Condition newCondition() {
            return new ConditionObject();
        }

        /**
         * 判断锁是否被线程所持有
         */
        final boolean isLocked() {
            return getState() == 1;
        }
    }

    /**
     * 同步器
     */
    private final Sync sync = new Sync();

    /**
     * 加锁
     */
    public void lock() {
        sync.acquire(1);
    }

    /**
     * 尝试获取锁
     */
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    /**
     * 解锁
     * 解锁只能调用同步器的release()，不能调用tryRelease()方法，因为tryRelease()方法只是简单的修改一下同步状态的值而已，并没有去唤醒等待队列中的线程，正常是需要唤醒等待队列中离头节点最近的同时等待状态不为CANCELLED的节点
     */
    public void unlock() {
        sync.release(1);
    }

    /**
     * 返回与此Mutex绑定的Condition实例
     */
    public Condition newCondition() {
        return sync.newCondition();
    }

    /**
     * 判断锁是否被线程所持有
     */
    public boolean isLocked() {
        return sync.isLocked();
    }

    /**
     * 判断是否有线程在等待获取锁
     */
    public boolean hasQueuedThreads() {
        return sync.hasQueuedThreads();
    }

    /**
     * 可能抛出InterruptedException的加锁（如果线程被设置了中断标识那么直接抛出异常）
     */
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    /**
     * 在指定的时间内尝试获取锁
     */
    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AQS子类（同步器）一般都是通过内部类实现，然后作为内部组件来使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {

    static class MyRunnable implements Runnable {

        private Mutex mutex = new Mutex();

        @Override
        public void run() {
            System.out.println(String.format(&quot;%s Running&quot;, Thread.currentThread().getName()));
            mutex.lock();
            System.out.println(String.format(&quot;%s加锁&quot;, Thread.currentThread().getName()));
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            mutex.unlock();
            System.out.println(String.format(&quot;%s解锁&quot;, Thread.currentThread().getName()));
        }

    }

    public static void main(String[] args) {
        Runnable runnable = new MyRunnable();
        Thread threadA = new Thread(runnable, &quot;线程A&quot;);
        Thread threadB = new Thread(runnable, &quot;线程B&quot;);
        Thread threadC = new Thread(runnable, &quot;线程C&quot;);
        threadA.start();
        threadB.start();
        threadC.start();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1337502/202009/1337502-20200905215329962-1856682298.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到该独享锁是公平锁，多线程按照申请锁的顺序获取锁。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;独占模式下获取同步资源的源码分析&quot;&gt;独占模式下获取同步资源的源码分析&lt;/h2&gt;
&lt;h3 id=&quot;acquire方法&quot;&gt;acquire()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：当线程要获取同步资源时，可以调用acquire()或者tryAcquire()方法，acquire()方法中会调用AQS子类的tryAcquire()方法，尝试获取同步资源，如果获取同步资源成功，则直接返回，做自己的事情，否则将会执行addWaiter()方法，将当前线程封装成Node节点然后加入到等待队列当中，然后执行acquireQueued()方法，用于自旋获取同步资源，如果所有条件都满足那么最后将会执行selfInterrupt()方法。&lt;/p&gt;
&lt;h3 id=&quot;addwaiter方法&quot;&gt;addWaiter()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Node addWaiter(Node mode) {
    // 将当前线程封装成Node节点，并且指定为独占模式，独占模式Node.EXCLUSIVE为NULL，也就是说节点的nextWaiter为NULL
    Node node = new Node(Thread.currentThread(), mode);
    // 将节点加入到队尾当中
    Node pred = tail;
    if (pred != null) {
        // 将当前节点的前驱指针指向尾节点
        node.prev = pred; 
        // 通过CAS设置尾节点（如果pred指针所指向的尾节点就是当前的尾节点，也就是在这个过程当中没有其他节点插入到队尾，则将tail指针指向当前节点）
        if (compareAndSetTail(pred, node)) { 
            // 将之前尾节点的后继指针指向当前节点
            pred.next = node; 
            return node;
        }
    }
    // 如果不存在尾节点，也就是队列为空，或者通过CAS设置尾节点失败（也就是在这个过程当中有其他节点插入到队尾），那么将会通过enq()方法死循环进行设置。
    enq(node); 
    // 无论怎么样该方法最终都会返回封装了当前线程的节点。
    return node;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：addWaiter()方法用于将当前线程封装成Node节点然后加入到等待队列当中，如果在这个过程中，等待队列为空或者通过CAS设置尾节点失败，那么将会通过enq()方法死循环进行设置。&lt;/p&gt;
&lt;h3 id=&quot;enq方法&quot;&gt;enq()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Node enq(final Node node) {
    // 死循环
    for (;;) {
        Node t = tail;
        // 如果尾节点为空则初始化队列，创建一个空的节点，并且将head和tail指针都指向这个节点
        if (t == null) { 
            if (compareAndSetHead(new Node()))
                tail = head;
        } else { 
            // 将当前节点的前驱指针指向尾节点
            node.prev = t;  
            // 通过CAS设置尾节点（如果t指针所指向的节点就是当前的尾节点，也就是在这个过程当中没有其他节点插入到队尾，则将tail指针指向当前节点）
            if (compareAndSetTail(t, node)) {
                // 将之前的尾节点的后继指针指向当前节点
                t.next = node; 
                return t;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：enq()方法中使用死循环初始化队列以及通过CAS设置尾节点，直到尾节点被设置成功，同时需要注意的是当队列初始化后会有一个空的头节点，该节点不包含任何的线程，然后再将当前节点加入到队列当中。&lt;/p&gt;
&lt;h3 id=&quot;acquirequeued方法&quot;&gt;acquireQueued()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final boolean acquireQueued(final Node node, int arg) {
    // 失败标识
    boolean failed = true; 
    try {
         // 中断标识
        boolean interrupted = false;
        // 自旋
        for (;;) { 
            // 获取节点的前驱节点
            final Node p = node.predecessor(); 
            // 如果节点的前驱节点是头节点那么尝试获取同步资源
            // 强制要求队列中的节点获取同步资源的顺序必须是从队头到队尾，否则将会造成节点丢失，丢失了的节点中的线程将会永远处于阻塞状态，同时只有当线程获取了同步资源后，它才能成为头节点（队列初始化后的头节点除外），因此头节点肯定是已经获取过同步资源的（队列初始化后的头节点除外），因此为了遵循队列中的节点获取同步资源的顺序必须是从队头到队尾，所以永远只有头节点的后继节点拥有尝试获取同步资源的权利，因此当在尝试获取同步资源之前，需要先判断一下当前节点的前驱节点是否是头节点，如果不是就不用获取了
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) { 
                // 当获取同步资源成功，则将当前节点设置为头节点
                setHead(node); 
                // 将之前头节点的后继指针设置为null，帮助GC
                p.next = null; 
                failed = false; 
                // 返回中断标识
                return interrupted; 
            }

            // 如果节点的前驱节点不是头节点，或者尝试获取同步资源失败，那么将会调用shouldParkAfterFailedAcquire()方法，判断线程能否进行阻塞，当线程能够被阻塞时，将会调用parkAndCheckInterrupt()方法阻塞线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        // 如果在执行该方法的过程中，抛出了异常（线程超时等等），则failed标识为true，那么将会执行cancelAcquire()方法，将当前节点的等待状态设置为CANCELLED，同时从等待队列中剔除。
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：acquireQueued()方法用于自旋获取同步资源，同时该方法的方法出口只有一个，也就是当节点的前驱节点是头节点，同时尝试获取同步资源成功，那么就会将当前节点设置为头节点，否则就会调用shouldParkAfterFailedAcquire()方法，判断线程能否进行阻塞，当线程能够被阻塞时，将会调用parkAndCheckInterrupt()方法阻塞线程，等待被唤醒，同时在执行acquireQueued()方法的过程中，如果抛出了异常，则failed标识为true，那么将会执行cancelAcquire()方法，将当前节点的等待状态设置为CANCELLED，同时从等待队列中剔除。&lt;/p&gt;
&lt;h3 id=&quot;shouldparkafterfailedacquire方法&quot;&gt;shouldParkAfterFailedAcquire()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    // 获取节点的前驱节点的等待状态
    int ws = pred.waitStatus;
    // 如果前驱节点的等待状态为SIGNAL，那么当它释放同步资源时，将会自动唤醒离它最近的同时等待状态不为CANCELLED的后继节点，因此当前节点就可以直接阻塞了，等待被唤醒时再去尝试获取同步资源
    if (ws == Node.SIGNAL)
        return true;
    
    // 如果前驱节点的等待状态为CANCELLED，那么通过循环找到前一个不为CANCELLED状态的节点，并且将当前节点的前驱指针指向该节点，将该节点的后继指针指向当前节点
    if (ws &amp;gt; 0) {
        do {
            node.prev = pred = pred.prev; 
        } while (pred.waitStatus &amp;gt; 0);
        pred.next = node;
    } else { 
        // 通过CAS将前驱节点的等待状态设置为SIGNAL
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：shouldParkAfterFailedAcquire()方法用于判断线程能否进行阻塞，以及剔除被设置为CANCELLED状态的节点。&lt;/p&gt;
&lt;p&gt;正常情况下，线程第一次进来shouldParkAfterFailedAcquire()方法时，会将前驱节点的等待状态设置为SIGNAL，然后再次自旋进来该方法，判断到前驱节点的等待状态为SIGNAL，直接返回，然后就进入待阻塞状态。&lt;/p&gt;
&lt;p&gt;当该节点的前驱节点被CANCELLED时，如果前驱节点的前驱节点是头节点，那么将会唤醒当前节点，那么它会再次自旋进来该方法，判断到前驱节点的等待状态为CANCELLED，就会将当前节点的前驱指针指向前一个不为CANCELLED状态的节点，也就是头节点，然后再将头节点的后继指针指向当前节点，然后再次自旋进来该方法，判断到前驱节点的等待状态为SIGNAL，直接返回，再次进入待阻塞状态。&lt;/p&gt;
&lt;p&gt;无论怎么样通过shouldParkAfterFailedAcquire()方法的所有节点最终都会进入待阻塞状态，也就是说等待队列中除了头节点以外的所有线程都会处于阻塞状态。&lt;/p&gt;
&lt;h3 id=&quot;parkandcheckinterrupt方法&quot;&gt;parkAndCheckInterrupt()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final boolean parkAndCheckInterrupt() {
    // 阻塞当前线程，blocker对象使用当前对象
    LockSupport.park(this);
    // 当被唤醒时返回线程的中断标识
    return Thread.interrupted(); 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：parkAndCheckInterrupt()方法用于阻塞线程，同时当线程被唤醒时会返回线程的中断标识，尽管如果线程被设置了中断标识，但也不会影响线程继续往下执行，只不过当它成功获取到同步资源时，会调用一次selfInterrupt()方法，再次为线程设置中断标识。&lt;/p&gt;
&lt;h3 id=&quot;selfinterrupt方法&quot;&gt;selfInterrupt()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static void selfInterrupt() {
    // 为线程设置中断标识
    Thread.currentThread().interrupt();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：当获取了同步资源的线程被设置了中断标识，才会调用selfInterrupt()方法，再次为线程设置中断标识，因为在parkAndCheckInterrupt()方法中已经调用过一次Thread.interrupted()方法，避免外部又再次调用Thread.interrupted()方法导致线程的中断标识被清除。&lt;/p&gt;
&lt;h3 id=&quot;cancelacquire方法&quot;&gt;cancelAcquire()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void cancelAcquire(Node node) {
    
    if (node == null)
        return;
        // 将当前节点封装的线程设置为NULL
    node.thread = null;

    // 通过循环获取当前节点不为CANCELLED状态的前驱节点
    Node pred = node.prev;
    while (pred.waitStatus &amp;gt; 0)
        node.prev = pred = pred.prev;

    // 获取前驱节点的后继节点（如果节点的前驱节点不是CANCELLED状态，那么前驱节点的后继节点就是它自己）
    Node predNext = pred.next;

    // 将节点的等待状态设置为CANCELLED
    node.waitStatus = Node.CANCELLED;

    // 如果当前节点是尾节点，则直接通过CAS将tail指针指向当前节点不为CANCELLED状态的前驱节点，同时通过CAS将前驱节点的后继指针设置为NULL
    if (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {
        compareAndSetNext(pred, predNext, null);
    } else { 
        int ws;
        // 如果当前节点的前驱节点不是头节点 同时 前驱节点的等待状态为SIGNAL(如果不是SIGNAL那就设置为SIGNAL) 且 前驱节点封装的线程不为NULL
        if (pred != head &amp;amp;&amp;amp;
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             (ws &amp;lt;= 0 &amp;amp;&amp;amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;amp;&amp;amp;
            pred.thread != null) {
            // 获取节点的后继节点 
            Node next = node.next;
            // 如果后继节点的等待状态不为CANCELLED，则通过CAS将前驱节点的后继指针指向当前节点的后继节点
            if (next != null &amp;amp;&amp;amp; next.waitStatus &amp;lt;= 0)
                compareAndSetNext(pred, predNext, next); // 这里并没有将当前节点的后继节点的前驱指针指向前驱节点（不用设置，unparkSuccessor()方法会自动跳过）
        } else {
            // 如果当前节点的前驱节点是头节点，则直接唤醒当前节点的后继节点，让它来剔除当前节点
            unparkSuccessor(node);
        }

        node.next = node;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：如果线程在阻塞的过程当中抛出了异常，也就是直接中断acquireQueued()方法，然后执行finally语句块，由于failed标识为true，因此会执行cancelAcquire()方法，将当前节点的等待状态设置为CANCELLED，如果当前节点是尾节点，则直接通过CAS将tail指针指向当前节点不为CANCELLED状态的前驱节点，同时将该前驱节点的后继指针设置为NULL，如果当前节点的前驱节点不是头节点，则通过CAS将前驱节点的后继指针指向当前节点的后继节点，如果当前节点的前驱节点是头节点，那么唤醒当前节点的后继节点，让它来剔除当前节点。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;独占模式下释放同步资源的源码分析&quot;&gt;独占模式下释放同步资源的源码分析&lt;/h2&gt;
&lt;h3 id=&quot;release方法&quot;&gt;release()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final boolean release(int arg) {
    if (tryRelease(arg)) { 
        Node h = head; 
        // 如果队列不等于空，同时头节点的等待状态不为0，也就是头节点存在后继节点，那么调用unparkSuccessor()方法，唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点。
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0) 
            unparkSuccessor(h);
        return true;
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：当获取了同步资源的线程释放同步资源时（外部线程或者头节点中的线程），将会调用release()方法，release()方法中会调用AQS子类的tryRelease()方法，尝试释放同步资源，如果释放同步资源成功，同时队列不为空以及头节点的等待状态不为0，也就是头节点存在后继节点，那么就会调用unparkSuccessor()方法，唤醒离头节点最近的（也就是头节点的后继节点）同时等待状态不为CANCELLED的后继节点，那么该节点将会通过自旋尝试获取同步资源。&lt;/p&gt;
&lt;h3 id=&quot;unparksuccessor方法&quot;&gt;unparkSuccessor()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void unparkSuccessor(Node node) {
    // 获取节点的等待状态
    int ws = node.waitStatus; 
    // 如果节点的等待状态不为CANCELLED，则通过CAS将节点的等待状态设置为0（恢复成队列初始化后的状态）
    if (ws &amp;lt; 0) 
        compareAndSetWaitStatus(node, ws, 0);

    // 获取节点的后继节点
    Node s = node.next;
    // 如果节点的后继指针为NULL（不能说明节点就没有后继节点）或者后继节点为CANCELLED状态，那么就从后往前寻找离当前节点最近的同时等待状态不为CANCELLED的后继节点
    if (s == null || s.waitStatus &amp;gt; 0) { 
        s = null;
        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
            if (t.waitStatus &amp;lt;= 0)
                s = t;
    }
    if (s != null)
        // 唤醒该后继节点中的线程
        LockSupport.unpark(s.thread);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：unparkSuccessor()方法用于唤醒离节点最近的同时等待状态不为CANCELLED的后继节点，如果节点的后继指针为NULL，不能说明节点就没有后继节点，或者后继节点的等待状态为CANCELLED，则从后往前，寻找离节点最近的同时等待状态不为CANCELLED的节点，最终唤醒该节点中的线程。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;独占模式下源码分析后的总结&quot;&gt;独占模式下源码分析后的总结&lt;/h2&gt;
&lt;p&gt;1.当线程要获取同步资源时，可以调用acquire()或者tryAcquire()方法，acquire()方法中会调用AQS子类的tryAcquire()方法，尝试获取同步资源，如果获取同步资源成功，则直接返回，做自己的事情，否则将会执行addWaiter()方法，将当前线程封装成Node节点然后加入到等待队列当中，然后执行acquireQueued()方法，用于自旋获取同步资源，如果所有条件都满足那么最终将会执行selfInterrupt()方法。&lt;/p&gt;
&lt;p&gt;2.addWaiter()方法用于将当前线程封装成Node节点然后加入到等待队列当中，如果在这个过程中，等待队列为空或者通过CAS设置尾节点失败（也就是当前指针所指向的尾节点并不是真正的尾节点，也就是在这个过程当中有其他节点插入到队尾），那么将会通过enq()方法死循环进行设置。&lt;/p&gt;
&lt;p&gt;3.enq()方法中使用死循环初始化队列以及通过CAS设置尾节点，直到尾节点被设置成功，同时需要注意的是当队列初始化后会有一个空的头节点，该节点不包含任何的线程，然后再将当前节点加入到队列当中。&lt;/p&gt;
&lt;p&gt;4.acquireQueued()方法用于自旋获取同步资源，同时该方法的方法出口只有一个，也就是当节点的前驱节点是头节点，同时尝试获取同步资源成功，那么就会将当前节点设置为头节点，否则就会调用shouldParkAfterFailedAcquire()方法，判断线程能否进行阻塞，当线程能够被阻塞时，将会调用parkAndCheckInterrupt()方法阻塞线程，等待被唤醒，同时在执行acquireQueued()方法的过程中，如果抛出了异常，则failed标识为true，那么将会执行cancelAcquire()方法，将当前节点的等待状态设置为CANCELLED，同时从等待队列中剔除。&lt;/p&gt;
&lt;p&gt;5.shouldParkAfterFailedAcquire()方法用于判断线程能否进行阻塞，以及剔除被设置为CANCELLED状态的节点，正常情况下，线程第一次进来shouldParkAfterFailedAcquire()方法时，会将前驱节点的等待状态设置为SIGNAL，然后再次自旋进来该方法，判断到前驱节点的等待状态为SIGNAL，直接返回，然后就进入待阻塞状态，当该节点的前驱节点被CANCELLED时，如果前驱节点的前驱节点是头节点，那么将会唤醒当前节点，那么它会再次自旋进来该方法，判断到前驱节点的等待状态为CANCELLED，就会将当前节点的前驱指针指向前一个不为CANCELLED状态的节点，也就是头节点，然后再将头节点的后继指针指向当前节点，然后再次自旋进来该方法，判断到前驱节点的等待状态为SIGNAL，直接返回，再次进入待阻塞状态，无论怎么样通过shouldParkAfterFailedAcquire()方法的所有节点最终都会进入待阻塞状态，也就是说等待队列中除了头节点以外的所有线程都会处于阻塞状态。&lt;/p&gt;
&lt;p&gt;6.parkAndCheckInterrupt()方法用于阻塞线程，同时当线程被唤醒时会返回线程的中断标识，尽管如果线程被设置了中断标识，但也不会影响线程继续往下执行，只不过当它成功获取到同步资源时，会调用一次selfInterrupt()方法，再次为线程设置中断标识，因为在parkAndCheckInterrupt()方法中已经调用过一次Thread.interrupted()方法，避免外部又再次调用Thread.interrupted()方法导致线程的中断标识被清除。&lt;/p&gt;
&lt;p&gt;此时等待队列中除了头节点以外的所有线程都会处于阻塞状态&lt;/p&gt;
&lt;p&gt;1.如果线程在阻塞的过程当中抛出了异常，也就是直接中断acquireQueued()方法，然后执行finally语句块，由于failed标识为true，因此会执行cancelAcquire()方法，将当前节点的等待状态设置为CANCELLED，如果当前节点是尾节点，则直接通过CAS将tail指针指向当前节点不为CANCELLED状态的前驱节点，同时将该前驱节点的后继指针设置为NULL，如果当前节点的前驱节点不是头节点，则通过CAS将前驱节点的后继指针指向当前节点的后继节点，如果当前节点的前驱节点是头节点，那么唤醒当前节点的后继节点，让它来剔除当前节点。&lt;/p&gt;
&lt;p&gt;2.当获取了同步资源的线程释放同步资源时（外部线程或者头节点中的线程），将会调用release()方法，release()方法中会调用AQS子类的tryRelease()方法，尝试释放同步资源，如果释放同步资源成功，同时队列不为空以及头节点的等待状态不为0，也就是头节点存在后继节点，那么就会调用unparkSuccessor()方法，唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点，那么该节点将会通过自旋尝试获取同步资源。&lt;/p&gt;
&lt;p&gt;3.在调用unparkSuccessor()方法唤醒离节点最近的同时等待状态不为CANCELLED的后继节点时，如果节点的后继指针为NULL，不能说明节点就没有后继节点，或者后继节点的等待状态为CANCELLED，则从后往前，寻找离节点最近的同时等待状态不为CANCELLED的节点，最终唤醒该节点中的线程。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;独占模式faq&quot;&gt;独占模式FAQ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么要用CAS设置尾节点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在设置尾节点的这个过程当中，有其他节点插入到队尾，然后将tail指针指向当前节点，当前节点的前驱指针指向之前的尾节点，之前的尾节点的后继指针指向当前节点，那么中间插入的节点就会丢失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在acquireQueued()方法中，为什么尝试获取同步资源之前，需要先判断一下当前节点的前驱节点是否是头节点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强制要求等待队列中的节点获取同步资源的顺序必须是从队头到队尾，否则将会造成节点丢失，丢失了的节点中的线程将会永远处于阻塞状态（当同步资源被释放时，还没来得及唤醒离头节点最近同时等待状态不为CANCELLED的后继节点时，等待队列中一个排在很后的节点被唤醒，然后它将会通过自旋尝试获取同步资源，一旦它获取了同步资源，那么它将成为头节点，最终它与之前头节点之间的所有节点中的线程将会永远处于阻塞状态），同时只有当线程获取了同步资源后，它才能成为头节点（队列初始化后的头节点除外），因此头节点肯定是已经获取过同步资源的（队列初始化后的头节点除外），因此为了遵循队列中的节点获取同步资源的顺序必须是从队头到队尾，所以永远只有头节点的后继节点拥有尝试获取同步资源的权利，因此当在尝试获取同步资源之前，需要先判断一下当前节点的前驱节点是否是头节点，如果不是就不用获取了，至于头节点释放同步资源后，能否被后继节点获取到同步资源另说，因为当同步资源被释放时，被唤醒的后继节点可能还没来得获取同步资源，此时就被外部线程直接获取了，因此被唤醒的这个线程又只能再次进入阻塞状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么在unparkSuccessor()方法中，如果节点的后继指针为NULL，需要从后往前寻找离节点最近的同时等待状态不为CANCELLED的后继节点，而不从前往后进行寻找？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果节点的后继指针为NULL，不能说明节点就没有后继节点，因为无论是在addWaiter()方法还是enq()方法将节点加入到队列，它总是先将当前节点的前驱指针指向尾节点，然后再通过CAS将tail指针指向当前节点，如果在将之前尾节点的后继指针指向当前节点之前，需要唤醒尾节点的后继节点，由于此时尾节点的后继指针仍然为NULL，因此无法通过next指针从前往后寻找，只能通过pred指针从后往前寻找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程在什么情况会被唤醒？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程被唤醒只有两种情况&lt;/p&gt;
&lt;p&gt;一种是外部线程或者头节点释放同步资源时，需要唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点，那么该节点就会通过自旋尝试获取同步资源。&lt;/p&gt;
&lt;p&gt;一种是当节点的前驱节点被CANCELLED时，如果前驱节点的前驱节点是头节点，那么将会唤醒当前节点，将当前节点的前驱指针指向前一个不为CANCELLED状态的节点，也就是头节点，然后再将头节点的后继指针指向当前节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;等待队列中处于CANCELLED状态的节点什么时候被剔除？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cancelAcquire()和shouldParkAfterFailedAcquire()方法都可以剔除等待队列中处于CANCELLED状态的节点。&lt;/p&gt;
&lt;p&gt;*在unparkSuccessor()中需要剔除处于CANCELLED状态的节点是为了避免同步问题，可能存在一个处于CANCELLED状态的节点未来得及被剔除，然后它又作为要唤醒的节点的后继节点。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;自定义aqs共享模式下的同步器来实现共享锁&quot;&gt;自定义AQS共享模式下的同步器来实现共享锁&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 自定义AQS共享模式下的同步器来实现共享锁
 */
public class Share {

    /**
     * 自定义AQS共享模式下的同步器
     */
    private static class Sync extends AbstractQueuedSynchronizer {

        /**
         * 存储线程获取同步资源的情况
         */
        private static ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = new ThreadLocal&amp;lt;&amp;gt;();

        /**
         * 初始化同步资源
         */
        public Sync(int state) {
            setState(state);
        }

        /**
         * 尝试获取同步资源（需要保证是线程安全的）
         */
        @Override
        protected int tryAcquireShared(int arg) {
            int state = getState();
            int available = state - arg;
            if (available &amp;gt;= 0 &amp;amp;&amp;amp; compareAndSetState(state, available)) { // 通过CAS保证原子性
                threadLocal.set(arg);
                return available;
            }
            return -1;
        }

        /**
         * 释放同步资源（线程释放同步资源的个数必须等于它获取同步资源的个数）
         */
        @Override
        protected boolean tryReleaseShared(int arg) {
            if (threadLocal.get() != arg)
                throw new UnsupportedOperationException();
            if (compareAndSetState(getState(), getState() + arg)) { // 通过CAS保证原子性
                threadLocal.set(null);
                return true;
            }
            return false;
        }

    }

    /**
     * 初始化同步器的同步资源
     */
    public Share(int permits) {
        sync = new Sync(permits);
    }

    public Sync sync;

    /**
     * 获取许可
     */
    public void acquire(int permits) {
        sync.acquireShared(permits);
    }

    /**
     * 尝试获取许可
     */
    public boolean tryAcquire(int permits) {
        return sync.tryAcquireShared(permits) &amp;gt;= 0;
    }

    /**
     * 释放许可
     */
    public boolean release(int permits) {
        return sync.releaseShared(permits);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {

    static class MyRunnable implements Runnable {

        private Share share;

        private int permits;

        @Override
        public void run() {
            System.out.println(String.format(&quot;%s Running&quot;, Thread.currentThread().getName()));
            share.acquire(permits);
            System.out.println(String.format(&quot;%s获取了%s个许可&quot;, Thread.currentThread().getName(), permits));
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            share.release(permits);
            System.out.println(String.format(&quot;%s释放了%s个许可&quot;, Thread.currentThread().getName(), permits));
        }

        public MyRunnable(Share share, int permits) {
            this.share = share;
            this.permits = permits;
        }
    }

    public static void main(String[] args) {
        Share share = new Share(10);
        Thread threadA = new Thread(new MyRunnable(share,5),&quot;线程A&quot;);
        Thread threadB = new Thread(new MyRunnable(share,4),&quot;线程B&quot;);
        Thread threadC = new Thread(new MyRunnable(share,3),&quot;线程C&quot;);
        threadA.start();
        threadB.start();
        threadC.start();
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1337502/202009/1337502-20200905215358990-1155081685.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;共享模式下获取同步资源的源码分析&quot;&gt;共享模式下获取同步资源的源码分析&lt;/h2&gt;
&lt;h3 id=&quot;acquireshared方法&quot;&gt;acquireShared()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &amp;lt; 0)
        doAcquireShared(arg);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：当线程要获取同步资源时，可以调用acquireShared()或tryAcquireShared()方法，acquireShared()方法中会调用AQS子类的tryAcquireShared()方法，尝试获取同步资源，如果获取同步资源成功，则直接返回，做自己的事情，否则将会调用doAcquireShared()方法。&lt;/p&gt;
&lt;h3 id=&quot;doacquireshared方法&quot;&gt;doAcquireShared()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doAcquireShared(int arg) {
    // 将当前线程封装成Node节点，然后加入到等待队列当中
    // 当前节点会被指定为共享模式，共享模式Node.SHARED为一个空的节点，也就是说节点的nextWaiter不为NULL（isShared()方法返回true）
    // 在调用addWaiter()方法的过程中，如果等待队列为空或者通过CAS设置尾节点失败，那么将会通过enq()方法死循环进行设置
    final Node node = addWaiter(Node.SHARED);
    // 失败标识
    boolean failed = true;
    try {
        // 中断标识
        boolean interrupted = false;
        // 自旋
        for (;;) {
            // 获取节点的前驱节点
            final Node p = node.predecessor();
            // 如果节点的前驱节点是头节点，则尝试获取同步资源
            if (p == head) {
                int r = tryAcquireShared(arg);
                // 如果获取同步资源成功，则调用setHeadAndPropagate()方法
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    // 将之前的头节点的后继指针设置为NULL，help gc
                    p.next = null;
                    // 如果获取了同步资源的线程被设置了中断标识，那么调用selfInterrupt()方法，再次为线程设置一个中断标识
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            // 如果节点的前驱节点不是头节点，或者尝试获取同步资源失败，那么将会调用shouldParkAfterFailedAcquire()方法，判断线程能否进行阻塞，当线程能够被阻塞时，将会调用parkAndCheckInterrupt()方法阻塞线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        // 如果在执行该方法的过程中，抛出了异常（线程超时等等），则failed标识为true，那么将会执行cancelAcquire()方法，将当前节点的等待状态设置为CANCELLED，同时从等待队列中剔除。
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：doAcquireShared()方法用于将当前线程封装成Node节点然后加入到等待队列当中，然后通过自旋获取同步资源，同时该方法的方法出口只有一个，也就是当节点的前驱节点是头节点，同时尝试获取同步资源成功，那么就会调用setHeadAndPropagate()方法，否则将会调用shouldParkAfterFailedAcquire()方法，判断线程能否进行阻塞，当线程能够被阻塞时，将会调用parkAndCheckInterrupt()方法阻塞线程，等待被唤醒，同时在执行doAcquireShared()方法的过程中，如果抛出了异常，则failed标识为true，那么将会执行cancelAcquire()方法，将当前节点的等待状态设置为CANCELLED，同时从等待队列中剔除。&lt;/p&gt;
&lt;h3 id=&quot;setheadandpropagate方法&quot;&gt;setHeadAndPropagate()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void setHeadAndPropagate(Node node, int propagate) {
    // 获取头节点
    Node h = head; 
    // 将当前节点设置为头节点
    setHead(node);
    
    //如果线程获取了同步资源后，仍然有剩余的可用资源（正常情况），或没有剩余的可用资源但旧的和新的头节点的等待状态为PROPAGATE时（说明实际存在可用资源），那么将会调用doReleaseShared()方法
    if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
        (h = head) == null || h.waitStatus &amp;lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared()) // 排除等待队列中不为共享模式的节点
            doReleaseShared();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：setHeadAndPropagate()方法用于将当前节点设置为头节点，同时如果当线程获取了同步资源后，仍然有剩余的可用资源（正常情况），或没有剩余的可用资源但旧的和新的头节点的等待状态为PROPAGATE时（说明实际存在可用资源），那么将会调用doReleaseShared()方法。&lt;/p&gt;
&lt;h3 id=&quot;doreleaseshared方法&quot;&gt;doReleaseShared()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doReleaseShared() {
    // 使用死循环来保证CAS操作最终肯定成功
    for (;;) {
        // 获取头节点
        Node h = head;
        // 如果head指针和tail指针不是指向同一个节点，说明头节点肯定存在后继节点（使用head != tail可以避免头节点存在后继节点但是头节点的后继指针又为NULL的情况）
        if (h != null &amp;amp;&amp;amp; h != tail) {
            // 获取头节点的等待状态，如果等待状态为SIGNAL，则通过CAS将头节点的等待状态设置为0（重置），然后唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) 
                    continue;            
                unparkSuccessor(h);
            }
            // 如果头节点的等待状态为0，则通过CAS将头节点的等待状态设置为PROPAGATE
            else if (ws == 0 &amp;amp;&amp;amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                
        }
        if (h == head) // 如果执行完以上步骤后，h指针指向的头节点仍然为当前的头节点，则退出循环，完成释放过程，然后做自己的事情
            break;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：当等待队列中的线程获取了同步资源后，仍然有剩余的可用资源，或没有剩余的可用资源但旧的和新的头节点的等待状态为PROPAGATE，或者当线程释放同步资源这两种情况，都会调用doReleaseShared()方法，该方法使用死循环来保证CAS操作最终肯定成功，如果头节点存在后继节点，同时头节点的等待状态为SIGNAL时，那么将会通过CAS将头节点的等待状态设置为0（重置），然后唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点，如果判断到头节点的等待状态为0，那么将会通过CAS将节点的等待状态设置为PROPAGATE，表示需要传播下去。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;共享模式下释放同步资源的源码分析&quot;&gt;共享模式下释放同步资源的源码分析&lt;/h2&gt;
&lt;h3 id=&quot;releaseshared方法&quot;&gt;releaseShared()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：当获取了同步资源的线程释放同步资源时，将会调用releaseShared()方法，releaseShared()方法中会调用AQS子类的tryReleaseShared()方法，尝试释放同步资源，如果释放同步资源成功，则会调用doReleaseShared()方法，唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;共享模式下源码分析后的总结&quot;&gt;共享模式下源码分析后的总结&lt;/h2&gt;
&lt;p&gt;1.当线程要获取同步资源时，可以调用acquireShared()或tryAcquireShared()方法，acquireShared()方法中会调用AQS子类的tryAcquireShared()方法，尝试获取同步资源，如果获取同步资源成功，则直接返回，做自己的事情，否则将会调用doAcquireShared()方法。&lt;/p&gt;
&lt;p&gt;2.doAcquireShared()方法用于将当前线程封装成Node节点然后加入到等待队列当中，然后通过自旋获取同步资源，同时该方法的方法出口只有一个，也就是当节点的前驱节点是头节点，同时尝试获取同步资源成功，那么就会调用setHeadAndPropagate()方法，否则将会调用shouldParkAfterFailedAcquire()方法，判断线程能否进行阻塞，当线程能够被阻塞时，将会调用parkAndCheckInterrupt()方法阻塞线程，等待被唤醒，同时在执行doAcquireShared()方法的过程中，如果抛出了异常，则failed标识为true，那么将会执行cancelAcquire()方法，将当前节点的等待状态设置为CANCELLED，同时从等待队列中剔除。&lt;/p&gt;
&lt;p&gt;3.setHeadAndPropagate()方法用于将当前节点设置为头节点，同时如果当线程获取了同步资源后，仍然有剩余的可用资源（正常情况），或没有剩余的可用资源但旧的和新的头节点的等待状态为PROPAGATE时（说明实际存在可用资源），那么将会调用doReleaseShared()方法。&lt;/p&gt;
&lt;p&gt;4.当等待队列中的线程获取了同步资源后，仍然有剩余的可用资源，或没有剩余的可用资源但旧的和新的头节点的等待状态为PROPAGATE，或者当线程释放同步资源这两种情况，都会调用doReleaseShared()方法，该方法使用死循环来保证CAS操作最终肯定成功，如果头节点存在后继节点，同时头节点的等待状态为SIGNAL时，那么将会通过CAS将头节点的等待状态设置为0（重置），然后唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点，如果判断到头节点的等待状态为0（表示并发释放同步资源），那么将会通过CAS将节点的等待状态设置为PROPAGATE，表示需要传播下去。&lt;/p&gt;
&lt;p&gt;5.当获取了同步资源的线程释放同步资源时，将会调用releaseShared()方法，releaseShared()方法中会调用AQS子类的tryReleaseShared()方法，尝试释放同步资源，如果释放同步资源成功，则会调用doReleaseShared()方法，唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;共享模式faq&quot;&gt;共享模式FAQ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;有哪些场景会将节点的等待状态设置为PROPAGATE，以及它的作用是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.当线程A释放同步资源时，将当前的头节点的等待状态设置为0，然后唤醒离头节点最近的同时等待状态不为CANCELLED的后继节点，如果被唤醒的节点获取了同步资源，然后在调用setHeadAndPropagate()方法之前，线程B释放了同步资源，此时判断到头节点的等待状态为0，那么就会将头节点的等待状态设置为PROPAGATE，表示并发释放了同步资源，目前还有可用的同步资源，然后被唤醒的节点在执行setHeadAndPropagate()方法时，如果没有剩余的可用资源，但是判断到旧的头节点的等待状态为PROPAGATE，说明实际存在可用资源，那么会再次调用doReleaseShared()方法，去唤醒后继节点，尝试获取同步资源。&lt;/p&gt;
&lt;p&gt;2.如果被唤醒的节点获取了同步资源，在将当前节点设置为头节点之后，线程A和B释放了同步资源，那么就跟场景1一样，线程B会将头节点的等待状态设置为PROPAGATE，然后被唤醒的节点在执行setHeadAndPropagate()方法时，如果没有剩余的可用资源，除了判断旧的头节点的等待状态是否为PROPAGATE以外，还需要判断新的头节点的等待状态是否为PROPAGATE。&lt;/p&gt;
&lt;p&gt;场景一和场景二的区别是获取同步资源的线程在设置头节点之前还是头节点之后。&lt;/p&gt;
</description>
<pubDate>Sat, 05 Sep 2020 14:10:00 +0000</pubDate>
<dc:creator>辣鸡小篮子</dc:creator>
<og:description>AQS源码分析 AQS全称AbstractQueuedSynchronizer（抽象队列同步器） AQS中维护了一个被volatile修饰的int类型的同步状态state，以及CLH等待队列。 sta</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/funyoung/p/13619854.html</dc:identifier>
</item>
<item>
<title>git 如何比较不同分支的差异 - 良许Linux</title>
<link>http://www.cnblogs.com/yychuyu/p/13619923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yychuyu/p/13619923.html</guid>
<description>&lt;p&gt;前两天，良许在做集成的时候碰到了一件闹心事。事情是这样的，良许的一位同事不小心把一个错误的 dev 分支 merge 到了 master 分支上，导致了良许编译不通过。于是，我们需要将版本回退到 merge 之前的状态。&lt;/p&gt;
&lt;p&gt;如果是下面这个状态，那很好处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1218435/202009/1218435-20200905220317879-152925682.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，我们只需一个 &lt;code&gt;git reset&lt;/code&gt; 命令即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git reset --hard HEAD~
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，如果下面这种状态，情况就没那么简单了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1218435/202009/1218435-20200905220350133-2139809618.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，就不能简单使用 &lt;code&gt;git reset&lt;/code&gt; 命令了。这就是良许这次碰到的问题。为了解决这个问题，我们就需要找出合并后的分支与合并前的分支的差异，再进行版本回退。这种情况下的版本回退，就不能单用 &lt;code&gt;git reset&lt;/code&gt; 了，而是要配合 &lt;code&gt;git revert&lt;/code&gt; 了，在后面我们将详细介绍如何优雅的进行版本回退。&lt;/p&gt;
&lt;p&gt;回到正题，我们如何找出合并后的分支与合并前分支的差异呢？这里我们需要使用到 &lt;code&gt;git log&lt;/code&gt; 命令了。我们先模拟出这两个分支的提交情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dev 分支提交情况：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[alvin@VM_0_16_centos git-log]$ git log dev
commit b191410906ae20a865fde3f163bb01fd6cfc1f11
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:03:13 2018 +0800

    [dev] 版本6

commit 793c9582ab0a45c4f8f548be36c06bc5ca427c62
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:02:30 2018 +0800

    [dev] 版本5

commit dbe54166608772486408c1dea05304de45dba430
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:00:27 2018 +0800

    [both] 版本3

commit 31894364b1396b00d2935373387397ef930416e4
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 20:59:26 2018 +0800

    [both] 版本2

commit 4872f653a8fd7c8541abb4a292d628dc7625884b
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 20:58:05 2018 +0800

    [dev] 版本4

commit fac6c60ed28c5acfcd01284336d4201cc55ee2e7
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 20:57:01 2018 +0800

    [both] 版本1

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;master 分支提交情况：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[alvin@VM_0_16_centos git-log]$ git log master
commit c690054c67b833b22dce4120899526743b20d36d
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sun Dec 9 07:31:47 2018 +0800

    [master] 版本7

commit dbe54166608772486408c1dea05304de45dba430
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:00:27 2018 +0800

    [both] 版本3

commit 31894364b1396b00d2935373387397ef930416e4
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 20:59:26 2018 +0800

    [both] 版本2

commit fac6c60ed28c5acfcd01284336d4201cc55ee2e7
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 20:57:01 2018 +0800

    [both] 版本1

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这些提交里 &lt;strong&gt;[both]&lt;/strong&gt; 表示两个分支都有的提交， &lt;strong&gt;[dev]&lt;/strong&gt; 表示只有在 dev 分支的提交，&lt;strong&gt;[master]&lt;/strong&gt; 表示只在 master 分支的提交&lt;/p&gt;
&lt;h4 id=&quot;1-查看dev有，而-master-分支没有的提交&quot;&gt;1. 查看dev有，而 master 分支没有的提交&lt;/h4&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git log dev ^master
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[alvin@VM_0_16_centos git-log]$ git log dev ^master
commit b191410906ae20a865fde3f163bb01fd6cfc1f11
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:03:13 2018 +0800

    [dev] 版本6

commit 793c9582ab0a45c4f8f548be36c06bc5ca427c62
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:02:30 2018 +0800

    [dev] 版本5

commit 4872f653a8fd7c8541abb4a292d628dc7625884b
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 20:58:05 2018 +0800

    [dev] 版本4

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显看到，版本4，5，6这三个提交只在 dev 分支里。&lt;/p&gt;
&lt;p&gt;相反，如果想看到 &lt;strong&gt;master&lt;/strong&gt; 分支有，而 &lt;strong&gt;dev&lt;/strong&gt; 分支没有的提交，就可以使用如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git log master ^dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[alvin@VM_0_16_centos git-log]$ git log master ^dev
commit c690054c67b833b22dce4120899526743b20d36d
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sun Dec 9 07:31:47 2018 +0800

    [master] 版本7

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git log master..dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想查看只在 master 分支，而不在 dev 分支的提交，则将 master 与 dev 对调过来即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git log dev..master
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两条命令的执行结果与上述相同，故不重复贴结果了。&lt;/p&gt;
&lt;h4 id=&quot;2-提前未知两个分支提交情况，如何查看两个分支的差异？&quot;&gt;2. 提前未知两个分支提交情况，如何查看两个分支的差异？&lt;/h4&gt;
&lt;p&gt;在这种情况下，上述的几个命令都跑一遍，其实也可以知道个大概了。但有没有更简单的办法呢？git 同样为你想到了这个问题，也提供了解决办法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git log master...dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[alvin@VM_0_16_centos git-log]$ git log master...dev
commit c690054c67b833b22dce4120899526743b20d36d
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sun Dec 9 07:31:47 2018 +0800

    [master] 版本7

commit b191410906ae20a865fde3f163bb01fd6cfc1f11
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:03:13 2018 +0800

    [dev] 版本6

commit 793c9582ab0a45c4f8f548be36c06bc5ca427c62
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:02:30 2018 +0800

    [dev] 版本5

commit 4872f653a8fd7c8541abb4a292d628dc7625884b
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 20:58:05 2018 +0800

    [dev] 版本4

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，在这里，master 与 dev 之间有三个点，有别于之前的命令（两个点）。而且，这个命令的执行结果与 &lt;code&gt;git log dev...master&lt;/code&gt; 完全一样。&lt;/p&gt;
&lt;p&gt;我们这里是为了方便演示，加了 &lt;strong&gt;[master]&lt;/strong&gt; 、 &lt;strong&gt;[dev]&lt;/strong&gt; 、 &lt;strong&gt;[both]&lt;/strong&gt; 这样的记号，但在实际开发过程中，很少会这样操作。那我们在执行 &lt;code&gt;git log master...dev&lt;/code&gt; 时，怎么知道有差异的提交是在 master 分支里，还是 dev 分支里？我们只需加上 &lt;code&gt;--left-right&lt;/code&gt; 选项即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git log --left-right master...dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[alvin@VM_0_16_centos git-log]$ git log --left-right master...dev
commit &amp;lt; c690054c67b833b22dce4120899526743b20d36d
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sun Dec 9 07:31:47 2018 +0800

    [master] 版本7

commit &amp;gt; b191410906ae20a865fde3f163bb01fd6cfc1f11
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:03:13 2018 +0800

    [dev] 版本6

commit &amp;gt; 793c9582ab0a45c4f8f548be36c06bc5ca427c62
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 21:02:30 2018 +0800

    [dev] 版本5

commit &amp;gt; 4872f653a8fd7c8541abb4a292d628dc7625884b
Author: Liangxu &amp;lt;yychuyu@163.com&amp;gt;
Date:   Sat Dec 8 20:58:05 2018 +0800

    [dev] 版本4

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们会发现，在 commit 与哈希值之间多了个 &lt;strong&gt;&amp;lt;&lt;/strong&gt; 或 &lt;strong&gt;&amp;gt;&lt;/strong&gt; ，其中 &lt;strong&gt;&amp;lt;&lt;/strong&gt; 表示只在 master 分支的提交， &lt;strong&gt;&amp;gt;&lt;/strong&gt; 表示只在 dev 分支的提交。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;公众号：良许Linux&lt;/p&gt;
&lt;img src=&quot;https://pic.downk.cc/item/5e618d2f98271cb2b8f65fe8.jpg&quot;/&gt;&lt;h3 id=&quot;有收获？希望老铁们来个三连击，给更多的人看到这篇文章&quot;&gt;有收获？希望老铁们来个三连击，给更多的人看到这篇文章&lt;/h3&gt;
</description>
<pubDate>Sat, 05 Sep 2020 14:04:00 +0000</pubDate>
<dc:creator>良许Linux</dc:creator>
<og:description>前两天，良许在做集成的时候碰到了一件闹心事。事情是这样的，良许的一位同事不小心把一个错误的 dev 分支 merge 到了 master 分支上，导致了良许编译不通过。于是，我们需要将版本回退到 me</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yychuyu/p/13619923.html</dc:identifier>
</item>
</channel>
</rss>