<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>API做翻页的两种思路 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/10706881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/10706881.html</guid>
<description>&lt;p&gt;在开发API的时候，有时候数据太多了，就需要分页读取。&lt;/p&gt;

&lt;p&gt;这种方式就是会提供一个每页笔数（page size）来定义返回条目的最大数，提供一个页数（page number）来表示从哪里开始读取数据。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
SELECT * FROM &quot;CampusResumes&quot; ORDER BY &quot;Name&quot; DESC LIMIT 5 OFFSET 10;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句话的意思就是从该表中读取数据，按照Name字段降序排序，从第10笔数据后开始读取，一共读取5笔（可能不足5笔）。&lt;/p&gt;
&lt;p&gt;这就相当于page size = 5，page number = 3的分页读取。&lt;/p&gt;

&lt;p&gt;Offset-based分页方式实现起来非常的简单，对用户来说体验也比较好。但是还有有一些劣势的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对于大规模的数据集，效率不够高。&lt;/strong&gt;因为数据库需要进行count和skip操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果数据经常发生变化，那么结果不可信。&lt;/strong&gt;在查询的时候如果插入或删除了数据，那么某条数据可能会出现两次或者翻页的时候越界了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在分布式系统中实现起来略麻烦。&lt;/strong&gt;这种情况下，你可能需要扫描不同的数据碎片，然后才能得到想要的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总体来说，当允许结果出现误差的时候，Offset-based分页还是很好用的。&lt;/p&gt;


&lt;p&gt;为了解决Offset-based分页的那些问题，可以采用Cursor-based分页。&lt;/p&gt;
&lt;p&gt;这种方式是这样的：客户端首先发送请求，请求里提供所需数据的数量。然后服务器响应请求，返回这些数量的数据（如果有这么多数据的话），同时还会返回一个游标（Cursor）。在下一次请求中，客户端除了发送请求数据的数量之外，还把这个cursor也传送过去，这个cursor就表示这次所要读取的数据的开始位置。&lt;/p&gt;
&lt;p&gt;这看起来和Offset-based分页差别不大，但是却更有效率。数据库里面的数据可以根据cursor值来获取。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
SELECT * FROM &quot;CampusResumes&quot; WHERE &quot;Id&quot; &amp;gt; 15 ORDER BY &quot;Id&quot; LIMIT 5;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子里，上次请求返回的cursor（Id字段）值为15，这次要获取Id比15大的连续的5条数据。&lt;/p&gt;
&lt;p&gt;这里的Id字段本身就是一个索引，所以查询起来非常快。&lt;/p&gt;
&lt;p&gt;在这次请求的响应里，可以把本次结果的最后一条的Id作为cursor再返回去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201904/986268-20190414205234764-366424215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以返回的cursor值为23，以供下次读取。&lt;/p&gt;

&lt;p&gt;Cursor-based翻页的&lt;strong&gt;优点&lt;/strong&gt;是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;性能好&lt;/strong&gt;。因为cursor字段通常都是索引列，查起来很快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;。添加和删除数据并不影响返回的结果，翻页时同一笔数据也只会被返回一次。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Cursor-based翻页通常适用于大量和动态的数据集，但是它也有一些&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;无法跳转到指定的页&lt;/strong&gt;。Cursor-based翻页只能一页一页遍历结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果必须基于一个唯一并且顺序的字段&lt;/strong&gt;。不可以让添加记录到任意位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现起来比Offset-based复杂一点&lt;/strong&gt;，尤其对客户端来说。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于Cursor字段的选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Id&lt;/strong&gt;，顺序的主键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间戳&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加密字符串&lt;/strong&gt;。它们看起来像随机字符串，但实际上通常是Cursor里加入了额外的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总体来说Cursor-based翻页还是更适合于高吞吐的应用，这种情况下客户端通常需要扫描整个数据集。&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;strong&gt;设定每页的最大笔数限制。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;针对大数据集，尽量不要使用Offset-based分页。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分页的默认排序，通常会把新的数据先返回，旧的数据往后翻。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没分页的API尽量去实现分页。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分页的时候，最好把下一页的链接一同返回，并鼓励客户端使用这个链接，参考HATEOAS。&lt;/strong&gt;这样以后你改变翻页策略的时候，客户端不会爆掉。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要在Cursor里加入敏感信息&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 14 Apr 2019 22:29:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<og:description>在开发API的时候，有时候数据太多了，就需要分页读取。 基于偏移量的分页（Offset-based） 这种方式就是会提供一个每页笔数（page size）来定义返回条目的最大数，提供一个页数（page</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/10706881.html</dc:identifier>
</item>
<item>
<title>[java核心篇02]__内部类 - 小舍先生</title>
<link>http://www.cnblogs.com/gemuxiaoshe/p/10708507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gemuxiaoshe/p/10708507.html</guid>
<description>&lt;ul&gt;&lt;li&gt;前言&lt;br/&gt;其实我们在前面已经初步接触到内部类了,但是我们去对它的作用并不胜了解.只是简单的知道了类的定义也是可以嵌套的,定义在一个类里面的类就是内部类.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;class out{
private String name;
private int age;
    class in{
        private String sex;
  }
public String getName(){
return this.name;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是关于内部类有什么作用,有什么分类都不是很了解,通过这篇文章来对java内部类的学习进行加深.&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;内部类的特点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。&lt;br/&gt;2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。&lt;br/&gt;3、创建内部类对象的时刻并不依赖于外围类对象的创建。&lt;br/&gt;4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。&lt;br/&gt;5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。&lt;br/&gt;6、内部类可以访问包括私有成员在内的外部类的所有成员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部类的作用&lt;/strong&gt;&lt;br/&gt;书上的描述并不详细,于是google了下相关的文章,感觉还是说法不一, 具体的作用有很多,于是大致总结两点:
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;内部类并不象外部类一样,它可以使用provate,proteced,这意味着它可以更好的封装,更好的隐藏起来,在我们需要隐藏某些方法的实现细节时,可以使用到内部类.而外部类则不行.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;另外一个作用就是能够更好的解决java多继承的问题,我们知道,在java语言中秉性的是单继承,而内部类与外部类的继承关系是互不干扰的,我们在前面知道了,java类可以通过接口的多继承解决多继承的问题,但那并没有彻底解决这个问题,而通过内部类则可以彻底解决这个问题,我们可以通过内部类实现类的多继承(可以定义多个内部类继承多个抽象类或具体类)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内部类的分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;静态内部类与非静态内部类&lt;/strong&gt;&lt;br/&gt;内部类更具其定义方法分为静态内部类和非静态内部类.其区别:
&lt;ul&gt;&lt;li&gt;静态内部类可以有静态成员变量，而非静态内部类则不能有静态成员变量。&lt;/li&gt;
&lt;li&gt;静态内部类可以访问外部类的静态变量，但不可访问外部类的非静态变量；&lt;/li&gt;
&lt;li&gt;非静态内部类的非静态成员方法可以访问外部类的非静态变量,也可以访问静态变量。&lt;/li&gt;
&lt;li&gt;静态内部类的创建不依赖于外部类，而非静态内部类必须依赖于外部类的创建而创建。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通过一个例子看看:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class sty_internalClass {
    public static void main(String[] args) {
        // 创建内部类实例化对象的第一种方式..
        textclass text = new textclass(); // 实例化外部类对象
        textclass.internaltextclass internaltextclass = text.new internaltextclass();  // 实例化内部类的对象要通过外部类对象来实现.
        // 创建内部类的实例化对象的第二种方式
        textclass.internaltextclass internaltextclass1 = new textclass().new internaltextclass();
        // 创建静态内部类实例化对象
        textclass.astaticinclass astaticinclass = new textclass.astaticinclass(); // 静态内部类的实例化不需要依赖外部类.
    }
}

 class textclass{
    private String name;
    static private int age;

    public class internaltextclass{  // 内部类
        String sex=&quot;男&quot;;
        internaltextclass(){ // 构造方法
            name = &quot;小舍&quot;;
            age = 23;
        }
        void input(){
            System.out.println(&quot;这是内部类的一个方法&quot;);
            System.out.println(age);
        }
    }
    public static class astaticinclass{
        void funtion(){
            System.out.println(age);
        }
    }
    
    public internaltextclass getinternaltextclass(){
        return new internaltextclass();
    }

    void ainput(){  // 外部类的一个方法,调用内部类的属性和方法.
        internaltextclass internaltextclass = new internaltextclass();
        internaltextclass.sex = &quot;男&quot;;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以观察出:非静态内部类的实例化必须依赖外部类(需要通过一个外部类的实例化对象创建对象)&lt;br/&gt;而静态内部类是不依赖外部类的(可以直接创建实例化对象)&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非静态内部类:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;成员内部类&lt;/li&gt;
&lt;li&gt;方法(局部)内部类&lt;/li&gt;
&lt;li&gt;匿名内部类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成员内部类&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就其文字含义而言,它就是作为一个类的成员存在的内部类.我们可以将它看做一个类的一个成员,只不过这个成员的类型是一个类而已.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; class textclass{
    private String name;
    static private int age;
    public class internaltextclass{  // 内部类
        String sex=&quot;男&quot;;
        internaltextclass(){ // 构造方法
            name = &quot;小舍&quot;;
            age = 23;
        }
        void input(){
            System.out.println(&quot;这是内部类的一个方法&quot;);
            ainput();  // 可以没有任何限制的调用外部类的方法.
        }
    }
     void ainput(){  // 外部类的一个方法,调用内部类的属性和方法.
         internaltextclass internaltextclass = new internaltextclass();
         internaltextclass.sex = &quot;男&quot;;
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们甚至可以通过定义get方法来获得一个成员内部类的对象.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public internaltextclass getinternaltextclass(){
        return new internaltextclass();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以观察到:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;成员内部类的定义是更成员变量并列的,所以可以看成是外部类的一个成员.&lt;/li&gt;
&lt;li&gt;成员内部类的好处就是可以没有任何限制的访问外部类的属性和方法.不管是静态还是非静态.&lt;/li&gt;
&lt;li&gt;用内部类定义在外部类中不可访问的属性。这样就在外部类中实现了比外部类的private还要小的访问权限,更好的封装隐藏性。&lt;br/&gt;&lt;strong&gt;(成员内部类不能有静态成员变量和方法,这是因为成员内部类不能被定义为静态的,定义为静态就成了静态内部类了,而之所以静态内部类不叫静态成员内部类,这应该是因为静态内部类对象的创建不依赖于外部类,所以严格来说算不上是外部类的一个成员.)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法(局部)内部类&lt;/strong&gt;&lt;br/&gt;很多文章都喜欢将它称为局部内部类,但是我觉得这样并不贴切,很模糊概念.其实局部内部类就是定义在一个方法体中的内部类.它与局部变量类似,其作用范围也只有方法体大小,其访问权限也只有方法体大小,这里我们就可以察觉到,那么局部内部类真的是太适合封装了,其隐蔽性更加高了.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们放大上面例子中的ainput方法(外部类的普通方法),在里面加入一个局部内部类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   void ainput(){  // 外部类的一个方法,调用内部类的属性和方法.
         final String[] a = new String[0];
         internaltextclass internaltextclass = new internaltextclass(); // 通过实例化内部类来调用内部类的成员变量.
         internaltextclass.sex = &quot;男&quot;;
         // 定义局部内部类
         class Localinclass{
             
             void Local(){
                 a[0] = &quot;外部方法体中的变量&quot;;
                 System.out.println(&quot;局部内部类中的方法&quot;);
                 System.out.println(a[0]);
             }
         }
         //在方法体中调用局部内部类.
         Localinclass localinclass = new Localinclass();
         localinclass.Local();
     }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以观察到,在方法体中的内部类,只能从上往下运行(调用只能再内部类的下面,否则无法识别到,这应该是是因为java运行的机制,在方法体中是从上到下的.)&lt;/p&gt;
&lt;p&gt;另外,在局部内部类中,我们只能访问到方法体中的final型变量.&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;匿名内部类&lt;/strong&gt;&lt;br/&gt;匿名内部类比较特殊,它的创建不需要类名(当然也不需要class关键字),但其必须继承一个抽象类或是一个接口(只能是一个).&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;匿名内部类的定义是这样的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new 父类构造器(参数){  // new一个父类的引用
类体部分
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;new 接口(){
类体部分
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;匿名内部类实际完成的工作其实就是实现抽象类或接口中的方法.然后作为一个实例的对象被创建.&lt;/p&gt;
&lt;p&gt;我们来看一个例子.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package java02.day_4_14;

/**
 * @outhor xiaoshe
 * @date 2019/4/15  - @time 1:55
 * 匿名内部类
 */
public class sty_anonymous {
    public void outman(man m){
        System.out.println(m.toout());
    }
    public static void main(String[] args) {
        sty_anonymous styAnonymous = new sty_anonymous();
        // 匿名内部类的使用
        styAnonymous.outman(new man() {
            @Override
            String sex() {
              return &quot;男&quot;;
            }
            @Override
            String name() {
            return &quot;男人&quot;;
            }
            @Override
            String toout() {
                return(this.name()+&quot;\n&quot;+this.sex());
            }
        });
    }
}
// 定义一个抽象类
abstract class man{
    private String name;
    private String sex;
    abstract String sex(); // 定义一个抽象方法
    abstract String name(); // 定义一个抽象方法
    abstract String toout();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看出,匿名内部类在这里的功能是实现抽象类中的抽象方法,应为抽象类是不能直接实例化的,所以这里通过了匿名内部类继承了抽象类man,而这里的&lt;code&gt;new man{...}&lt;/code&gt;就是整个匿名内部类,它在这里不是作为方法&lt;code&gt;outman(man m)&lt;/code&gt;中的man类实例对象&lt;code&gt;m&lt;/code&gt;二存在的(因为抽象类不能直接实例化对象), 而是作为一个继承了抽象类man的匿名内部类(即&lt;code&gt;new man{...}&lt;/code&gt;)的实例化对象而存在的.同时抽象类被继承后其抽象方法必须全部实现.&lt;/p&gt;
&lt;p&gt;我们将整个匿名内部类收起来:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-bfa97f06b3fd31f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时我们应该注意到,匿名内部类的使用范围是十分有限的,一个匿名内部类只能被使用一次(只在一个方法中当做一个实例化对象来使用)&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;ps:发现昨天核心以的关于抽象类和接口的知识点有很大差错,这次记住教训,学东西不能图快,切勿没完全整明白就跳过.明天重新总结,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检讨之&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;更新时间:&lt;br/&gt;2019-4-15&lt;br/&gt;2:30&lt;/p&gt;
</description>
<pubDate>Sun, 14 Apr 2019 18:36:00 +0000</pubDate>
<dc:creator>小舍先生</dc:creator>
<og:description>前言 其实我们在前面已经初步接触到内部类了,但是我们去对它的作用并不胜了解.只是简单的知道了类的定义也是可以嵌套的,定义在一个类里面的类就是内部类. 但是关于内部类有什么作用,有什么分类都不是很了解,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gemuxiaoshe/p/10708507.html</dc:identifier>
</item>
<item>
<title>浅析一款扫描dom-xss的浏览器插件 - ka1n4t</title>
<link>http://www.cnblogs.com/litlife/p/10708488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/litlife/p/10708488.html</guid>
<description>&lt;h3 id=&quot;x00-前言&quot;&gt;0x00 前言&lt;/h3&gt;
&lt;p&gt;这款插件的名字叫 &lt;a href=&quot;https://github.com/dpnishant/ra2-dom-xss-scanner&quot;&gt;ra2-dom-xss-scanner&lt;/a&gt;，其作者刚好也是jsprime的开发者，后续有可能会继续跟进一下jsprime。这个ra2比较老了，大概是七年前的一款，后来也就没有更新过。下面简单的分析一下其扫描的原理。&lt;/p&gt;
&lt;h3 id=&quot;x01-浅析&quot;&gt;0x01 浅析&lt;/h3&gt;
&lt;p&gt;其大致的原理如下，首先构造payload，然后在浏览器中创建一个tab，然后再通过脚本，在响应页面中寻找（这与正常扫描器的区别就是它会经过一层js的渲染，也正是它的优势所在）。&lt;/p&gt;
&lt;p&gt;看一下payload会发现，其所有的payload中都包含scanPage()方法。后面会讲到scanPage()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190415013306380-295623827.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看一下核心的漏洞检测规则&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190415013319574-2547288.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;600、601、602行是三个regex，用于匹配html中的一些scanPage()的输出位置，结合扫描器的payload来理解，也就是找输出点。这三个regex分别代表的位置是：标签的on事件、a等标签的href属性、script等标签的src属性。找到匹配的点后，将所有的匹配点拼接成一个字符串，以&amp;lt;br&amp;gt;隔开，然后作为id为ratwoeventthreat的标签的value。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190415013331851-1091404227.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190415013340411-145481434.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面再看一下这个scanPage()是干什么的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190415013352057-463635134.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;652-654行构建了一个变量d1，其用于将payload中的scanPage()关键字改成alert(1)，这里主要是为了使用户可见。构建完了就到了655行，很明显，这里构建了一个url，构建的这个url中包括前面说的d1，而这个url的域名就是这个插件的后端程序，主要用于存储数据。紧接着通过ajax，请求了这个url。&lt;/p&gt;
&lt;p&gt;再来看一下后端的程序如何处理params。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190415013403707-720315464.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Apr 2019 17:39:00 +0000</pubDate>
<dc:creator>ka1n4t</dc:creator>
<og:description>[TOC] 0x00 前言 这款插件的名字叫 'ra2 dom xss scanner' ，其作者刚好也是jsprime的开发者，后续有可能会继续跟进一下jsprime。这个ra2比较老了，大概是七年</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/litlife/p/10708488.html</dc:identifier>
</item>
<item>
<title>评论系统数据库设计及实现 - Mario_Xue</title>
<link>http://www.cnblogs.com/godlovesme/p/10708358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/godlovesme/p/10708358.html</guid>
<description>&lt;h3 id=&quot;需求分析&quot;&gt;需求分析&lt;/h3&gt;
&lt;p&gt;一般我们浏览网站的时候经常能看到如下图的这种效果（图片来自CSDN）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/0079MVdAly1g22kaulq08j30j80k8dms.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种评论层层嵌套，每个评论下面还挂着若干个对评论的回复。&lt;/p&gt;
&lt;p&gt;这种结构类似于树状结构，用户看起来一目了然，也是一种非常主流的评论系统设计。&lt;/p&gt;
&lt;h3 id=&quot;数据库设计&quot;&gt;数据库设计&lt;/h3&gt;
&lt;p&gt;在以评论为主的树形结构中，数据库的设计非常灵活，可以是单表设计，每个评论都有一个parent_id指向父评论。还可以分开为两个表，评论一张表，对评论的回复是另一张表。&lt;/p&gt;
&lt;p&gt;这里我使用的是单表设计。&lt;/p&gt;
&lt;p&gt;数据表设计如下。由于我开发的是一个新闻系统，所以我就直接以项目举例。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;commentId&lt;/td&gt;
&lt;td&gt;评论的id，自增值，每个评论都对应一个唯一的commentId&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;newsId    &lt;/td&gt;
&lt;td&gt;评论所对应的新闻的id                                &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;content  &lt;/td&gt;
&lt;td&gt;评论的内容                                          &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;userId    &lt;/td&gt;
&lt;td&gt;发出该评论用户的id                                  &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;parentId  &lt;/td&gt;
&lt;td&gt;指向父评论的id,如果不是对评论的回复,那么该值为null  &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;date      &lt;/td&gt;
&lt;td&gt;评论产生日期                                        &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;SQL语句：&lt;/p&gt;
&lt;p&gt;评论表：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;create table if not exists comments
(
    commentId bigint auto_increment primary key,
    newsId    bigint not null,
    parentId  bigint,
    content   text   not null,
    userId    bigint not null,
    date      timestamp default current_timestamp(),
    foreign key (parentID) references comments (commentId),
    foreign key (userID) references users (userId),
    foreign key (newsID) references news (newsId)
) charset = utf8mb4;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查询语句：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;SELECT a.commentId,a.newsId,a.parentId,a.newsId,b.nickname,b.avatar,a.content,a.date
        FROM comments AS a,users AS b WHERE a.newsId=#{newsId} AND a.userId=b.userId&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了减少数据库查询次数，直接一次将一个新闻下的所有评论都查询了出来，然后通过程序来编排评论的显示结构。通过适当的冗余来提高性能也是常用的优化手段之一&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;评论的实体类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import lombok.Data;
import java.util.Date;
import java.util.List;

@Data
public class Comment {
    Long commentId;
    Long newsId;
    Long parentId;
    Long userId;
    String nickname;
    String avatar;
    String content;
    Date date;
    List&amp;lt;Comment&amp;gt; child;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里给出一段通过程序来组织所有评论的代码（为了文章的精简，只写逻辑相关的代码）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;Comment&amp;gt; getComments(Long newsId) {
        List&amp;lt;Comment&amp;gt; allComments = commentMapper.getComments(newsId);
        if (allComments == null || allComments.size() == 0) {
            return new ArrayList&amp;lt;&amp;gt;();
        }
        List&amp;lt;Comment&amp;gt; comments = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;Comment&amp;gt; parents = new ArrayList&amp;lt;&amp;gt;();
        for (Comment comment : allComments) {
            if (comment.getParentId()==null) {
                comments.add(comment);
                parents.add(comment);
            } else {
                boolean foundParent=false;
                for (Comment parent : parents) {
                    if (comment.getParentId() == parent.getCommentId()) {
                        if (parent.getChild() == null) {
                            parent.setChild(new ArrayList&amp;lt;&amp;gt;());
                        }
                        parent.getChild().add(comment);
                        parents.add(comment);
                        foundParent=true;
                        //如果对list迭代过程中同时修改list，会报java.util.ConcurrentModificationException 的异常，所以我们需要break,当然break也可以提高算法效率
                        break;
                    }
                }
                if (!foundParent) {
                    throw new RuntimeException(&quot;can not find the parent comment&quot;);
                }
            }
        }
        return comments;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终形成的效果图。&lt;br/&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/0079MVdAly1g22lckjz18j30ew0aqglq.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口返回的数据如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;code&quot;: &quot;success&quot;,
    &quot;message&quot;: &quot;获取评论成功&quot;,
    &quot;status&quot;: &quot;200&quot;,
    &quot;data&quot;: [
        {
            &quot;id&quot;: &quot;236051&quot;,
            &quot;author_name&quot;: &quot;Jianbo&quot;,
            &quot;author_url&quot;: &quot;https://wx.qlogo.cn/mmopen/vi_32/Qib5jkFMntPJnT8b2nyzKicoYSuXLeyl07ia1dianxx1fWcic9hJL4UOEuIJvoWWbx7IFia3olUGqiabZvTe0dmeFBicHQ/132&quot;,
            &quot;date&quot;: &quot;6小时前&quot;,
            &quot;content&quot;: &quot;tt&quot;,
            &quot;userid&quot;: &quot;24&quot;,
            &quot;child&quot;: []
        },
        {
            &quot;id&quot;: &quot;236028&quot;,
            &quot;author_name&quot;: &quot;起航&quot;,
            &quot;author_url&quot;: &quot;https://wx.qlogo.cn/mmopen/vi_32/7Aq39lKL2jxoWSMgbiaYkQzOR0mOMTm2TLjVhRicYaFXAzg20I8gpcqySYYYQMWG60p8r5kibG3ibiav3CC8Bzibjblw/132&quot;,
            &quot;date&quot;: &quot;2019-04-11&quot;,
            &quot;content&quot;: &quot;很朴实的文字，又让人感动唏嘘&quot;,
            &quot;formId&quot;: null,
            &quot;userid&quot;: &quot;9676&quot;,
            &quot;child&quot;: [
                {
                    &quot;id&quot;: &quot;236032&quot;,
                    &quot;author_name&quot;: &quot;Jianbo&quot;,
                    &quot;author_url&quot;: &quot;https://wx.qlogo.cn/mmopen/vi_32/Qib5jkFMntPJnT8b2nyzKicoYSuXLeyl07ia1dianxx1fWcic9hJL4UOEuIJvoWWbx7IFia3olUGqiabZvTe0dmeFBicHQ/132&quot;,
                    &quot;date&quot;: &quot;2天前&quot;,
                    &quot;content&quot;: &quot;:-)&quot;,
                    &quot;userid&quot;: &quot;24&quot;,
                    &quot;child&quot;: [
                        {
                            &quot;id&quot;: &quot;236040&quot;,
                            &quot;author_name&quot;: &quot;God loves me&quot;,
                            &quot;author_url&quot;: &quot;https://wx.qlogo.cn/mmopen/vi_32/QTU6iasloiaun5OX6ZcZB964vhHLAc5RuIf8kMR3nwIXvy0HibYOe9RJ9o8escDOIj7MB1vica5ibZ2XSDXIibfQMsJA/132&quot;,
                            &quot;date&quot;: &quot;1天前&quot;,
                            &quot;content&quot;: &quot;为什么有人会选择安乐死呢，活着难道比不上痛苦吗&quot;,
                            &quot;userid&quot;: &quot;9663&quot;,
                            &quot;child&quot;: [
                                {
                                    &quot;id&quot;: &quot;236042&quot;,
                                    &quot;author_name&quot;: &quot;Jianbo&quot;,
                                    &quot;author_url&quot;: &quot;https://wx.qlogo.cn/mmopen/vi_32/Qib5jkFMntPJnT8b2nyzKicoYSuXLeyl07ia1dianxx1fWcic9hJL4UOEuIJvoWWbx7IFia3olUGqiabZvTe0dmeFBicHQ/132&quot;,
                                    &quot;date&quot;: &quot;1天前&quot;,
                                    &quot;content&quot;: &quot;如果无法有尊严的活着，就难受&quot;,
                                    &quot;child&quot;: []
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            &quot;id&quot;: &quot;236024&quot;,
            &quot;author_name&quot;: &quot;倡萌&quot;,
            &quot;author_url&quot;: &quot;../../images/gravatar.png&quot;,
            &quot;date&quot;: &quot;2019-04-11&quot;,
            &quot;content&quot;: &quot;每个人都有自己难以忘怀的过往，昨天今天明天，努力过好每一天！&quot;,
            &quot;userid&quot;: &quot;0&quot;,
            &quot;child&quot;: [
                {
                    &quot;id&quot;: &quot;236041&quot;,
                    &quot;author_name&quot;: &quot;Jianbo&quot;,
                    &quot;author_url&quot;: &quot;https://wx.qlogo.cn/mmopen/vi_32/Qib5jkFMntPJnT8b2nyzKicoYSuXLeyl07ia1dianxx1fWcic9hJL4UOEuIJvoWWbx7IFia3olUGqiabZvTe0dmeFBicHQ/132&quot;,
                    &quot;date&quot;: &quot;1天前&quot;,
                    &quot;content&quot;: &quot;过好今天，很重要&quot;，
                    &quot;userid&quot;: &quot;24&quot;,
                    &quot;child&quot;: []
                }
            ]
        },
        {
            &quot;id&quot;: &quot;236018&quot;,
            &quot;author_name&quot;: &quot;Jielinfan&quot;,
            &quot;author_url&quot;: &quot;https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBXIvvpMo5nXdlk6Mxwia9chS9E8VHGEQbDmyEAx8opRibztDzmpGHpbC3lR5vh8l4fsScZWoyEWyQ/132&quot;,
            &quot;date&quot;: &quot;2019-04-08&quot;,
            &quot;content&quot;: &quot;祝福老哥。&quot;,
            &quot;userid&quot;: &quot;280&quot;,
            &quot;child&quot;: [
                {
                    &quot;id&quot;: &quot;236019&quot;,
                    &quot;author_name&quot;: &quot;Jianbo&quot;,
                    &quot;author_url&quot;: &quot;https://wx.qlogo.cn/mmopen/vi_32/Qib5jkFMntPJnT8b2nyzKicoYSuXLeyl07ia1dianxx1fWcic9hJL4UOEuIJvoWWbx7IFia3olUGqiabZvTe0dmeFBicHQ/132&quot;,
                    &quot;date&quot;: &quot;2019-04-09&quot;,
                    &quot;content&quot;: &quot;:-)&quot;,
                    &quot;userid&quot;: &quot;24&quot;,
                    &quot;child&quot;: []
                }
            ]
        },
        {
            &quot;id&quot;: &quot;236017&quot;,
            &quot;author_name&quot;: &quot;增大网&quot;,
            &quot;author_url&quot;: &quot;../../images/gravatar.png&quot;,
            &quot;date&quot;: &quot;2019-04-08&quot;,
            &quot;content&quot;: &quot;送你一片大海，让你一帆风顺；送你一个太阳，让你热情奔放；送你一份真诚，祝你开心快乐；送你一份祝福，让你快乐天天！&quot;,
            &quot;formId&quot;: null,
            &quot;userid&quot;: &quot;0&quot;,
            &quot;child&quot;: []
        },
        {
            &quot;id&quot;: &quot;236011&quot;,
            &quot;author_name&quot;: &quot;今日新闻&quot;,
            &quot;author_url&quot;: &quot;../../images/gravatar.png&quot;,
            &quot;date&quot;: &quot;2019-04-07&quot;,
            &quot;content&quot;: &quot;文章不错非常喜欢&quot;,
            &quot;userid&quot;: &quot;0&quot;,
            &quot;child&quot;: [
                {
                    &quot;id&quot;: &quot;236052&quot;,
                    &quot;author_name&quot;: &quot;Jianbo&quot;,
                    &quot;author_url&quot;: &quot;https://wx.qlogo.cn/mmopen/vi_32/Qib5jkFMntPJnT8b2nyzKicoYSuXLeyl07ia1dianxx1fWcic9hJL4UOEuIJvoWWbx7IFia3olUGqiabZvTe0dmeFBicHQ/132&quot;,
                    &quot;date&quot;: &quot;6小时前&quot;,
                    &quot;content&quot;: &quot;谢谢&quot;,
                    &quot;userid&quot;: &quot;24&quot;,
                    &quot;child&quot;: []
                }
            ]
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 14 Apr 2019 15:58:00 +0000</pubDate>
<dc:creator>Mario_Xue</dc:creator>
<og:description>评论系统数据库设计及实现 需求分析 一般我们浏览网站的时候经常能看到如下图的这种效果（图片来自CSDN） 这种评论层层嵌套，每个评论下面还挂着若干个对评论的回复。 这种结构类似于树状结构，用户看起来一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/godlovesme/p/10708358.html</dc:identifier>
</item>
<item>
<title>STC15单片机最小系统DIY - lulipro</title>
<link>http://www.cnblogs.com/lulipro/p/10707441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulipro/p/10707441.html</guid>
<description>&lt;h2&gt;DIY计划简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;STC15F2K60S2简介：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;STC-Y5高速内核，工作频率可配置为1T（sysclk=mclk）&lt;/li&gt;
&lt;li&gt;2K RAM(256字节 idata + 1792字节 xdata) + 60K Flash ROM&lt;/li&gt;
&lt;li&gt;2个UART&lt;/li&gt;
&lt;li&gt;1个SPI&lt;/li&gt;
&lt;li&gt;38个IO（DIP封装）&lt;/li&gt;
&lt;li&gt;8通道10位ADC&lt;/li&gt;
&lt;li&gt;工作电压：3.8V~5.5V&lt;/li&gt;
&lt;li&gt;工作频率：5MHz~28MHz&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;DIY所需主要器件：&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;器件&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数量&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;STC15F2K60S2 PDIP40 单片机 &lt;/td&gt;
&lt;td&gt;1      &lt;/td&gt;
&lt;td&gt;         &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;22.1184MHz晶振&lt;/td&gt;
&lt;td&gt;1       &lt;/td&gt;
&lt;td&gt; 主晶振&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;30pF电容&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1uF电容&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;100nF电容&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1K电阻&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt; LED限流&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3mm LED&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MicroUSB模块&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt; USB供电接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3pin拨动开关&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt; 电源开关&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;排针&lt;/td&gt;
&lt;td&gt;按需&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;排母&lt;/td&gt;
&lt;td&gt;按需&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;跳线&lt;/td&gt;
&lt;td&gt;按需&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;9cmx15cm洞洞板&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt; 母版&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;最小系统原理图&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;为了保持原理图简单易懂，我没有画出IO引出排母/排针的电路，电源扩展引出电路。具体可以看下面的实物图。&lt;/li&gt;
&lt;li&gt;STC15F2K60S2内置RC震荡电路，可以省掉外部的晶振电路，但是我认为外部晶振比较精准一点，且受环境影响小。&lt;/li&gt;
&lt;li&gt;测试LED用于测试整个硬件/软件系统是否完好，有时候需要此LED来排错，比较实用。测试LED使用P5.5拉电流驱动。&lt;/li&gt;
&lt;li&gt;STC15F2K60S2内置了复位电路，其P5.4可以用来实现外部复位。我没有做外部复位电路，通过断电再上电来实现复位，这样P5.4就可以作为普通IO使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858860/201904/858860-20190414222741732-1708925513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;成品实物图&lt;/h2&gt;
&lt;p&gt;1、电源使用MicroUSB模块接入。&lt;/p&gt;
&lt;p&gt;2、用排母引出了GND和+5V电源接口。&lt;/p&gt;
&lt;p&gt;3、引出了所有的IO，每个IO使用了排母和排针两种连接器，方便使用杜邦线搭建电路。正面走了一根跳线，用热胶固定。&lt;/p&gt;
&lt;p&gt;4、LED使用的是3mm规格的，5mm的太大。&lt;/p&gt;
&lt;p&gt;5、蓝色LED为测试LED。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858860/201904/858860-20190414220807547-1919599641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/858860/201904/858860-20190414220909960-1067529309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;问题总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如何确定DIP封装的芯片引脚编号？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将芯片如下图摆放，最左下角为1脚，然后逆时针依次数下去就是2，3，4...40脚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858860/201904/858860-20190414230129075-1096284243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何给此最小系统下载程序？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常下载电路可以板载，也可以外置。由于我有ch340的USB-TTL模块，而且考虑到这种电路不好焊接，且为了保持简单，简洁，所以我没有板载下载电路。 可以使用下图的接法给单片机下载程序。&lt;/p&gt;
&lt;p&gt;下载步骤：闭合开关给单片机上电，然后使用STC-ISP软件选择好串口端口号，选择hex文件，点击【下载/编程】按钮，然后STC-ISP软件提示：【正在检测目标单片机 ...】时，就可以断开开关，再重新闭合开关上电，此时就开始了下载。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/858860/201904/858860-20190414225240257-160861074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Apr 2019 15:31:00 +0000</pubDate>
<dc:creator>lulipro</dc:creator>
<og:description>DIY计划简介 STC15F2K60S2简介： STC-Y5高速内核，工作频率可配置为1T（sysclk=mclk） 2K RAM(256字节 idata + 1792字节 xdata) + 60K</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lulipro/p/10707441.html</dc:identifier>
</item>
<item>
<title>http Content-Type 知多少 - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/10708204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/10708204.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;作为前端开发，工作中少不了与接口请求打交道。对于常见的content-type，也能说上来几个，感觉还算了解。直到有一天，我要在查看google的批量接口合并时发现Content-Type: multipart/mixed以及Content-Type: application/http时，有点措手不及。赶紧深入研究下Content-Type相关内容来弥补下自己的不足，从前端的角度来看看Content-Type。&lt;/p&gt;
&lt;h2 id=&quot;content-type&quot;&gt;Content-Type&lt;/h2&gt;
&lt;p&gt;Content-Type:实体头部用于指示资源的MIME类型。如果未指定 ContentType，默认为text/html&lt;br/&gt;有两种场景：&lt;br/&gt;在请求中 (如POST 或 PUT)，客户端告诉服务器实际发送的数据类型。&lt;/p&gt;
&lt;p&gt;在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。&lt;/p&gt;
&lt;p&gt;简而言之就是标识资源或者所需资源的MIME类型。&lt;/p&gt;
&lt;p&gt;句法如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Content-Type: text/html; charset=utf-8
Content-Type: multipart/form-data; boundary=something&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数一般media-type、charset、boundary三种。&lt;br/&gt;我们的关注点在于media-type的取值以及其适用场景。&lt;/p&gt;
&lt;h3 id=&quot;media-type&quot;&gt;media-type&lt;/h3&gt;
&lt;p&gt;更多的是作为MIME type( Multipurpose Internet Mail Extensions)出现，即多用途Internet邮件扩展。&lt;br/&gt;其目的是用一种标准化的方式来标识文档的性质和格式。&lt;br/&gt;浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；&lt;br/&gt;因此服务器设置正确以将正确的MIME类型附加到响应对象的头部是非常重要的。&lt;/p&gt;
&lt;h4 id=&quot;结构&quot;&gt;结构&lt;/h4&gt;
&lt;p&gt;MIME 组成结构如下：&lt;br/&gt;由类型与子类型两个字符串中间用'/'分隔而组成。不允许空格存在。对大小写不敏感，但传统都是小写。&lt;br/&gt;允许额外参数，如后面所示：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type/subtype;parameter=value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type对应通用类目，例如：text/video等。&lt;/li&gt;
&lt;li&gt;subtype对应准确的子类，例如text下面细分为plain(纯文本)、html(html源码)、calendar（.ics）文件等。&lt;/li&gt;
&lt;li&gt;parameter可选一般是charset或者bundaary等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;types&quot;&gt;Types&lt;/h3&gt;
&lt;p&gt;类目包括两种类型：独立类型和Multipart类型。&lt;/p&gt;
&lt;h4 id=&quot;独立类型&quot;&gt;独立类型&lt;/h4&gt;
&lt;p&gt;独立类型指只代表一个单独的文件或者媒体的类型，表明了对文件的分类。&lt;br/&gt;常见类型和实例如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;text&lt;br/&gt;文本数据包括一些人类可读的内容或者源码。例如：text/plain, text/csv, text/html.&lt;/li&gt;
&lt;li&gt;application&lt;br/&gt;数据为二进制的一种，例如application/octet-stream,application/pdf,application/pkcs8,application/zip.&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;audio&lt;br/&gt;音频或者音乐数据，例如audio/mpeg, audio/vorbis&lt;/li&gt;
&lt;li&gt;video&lt;br/&gt;视频数据或者文件，例如video/mp4&lt;/li&gt;
&lt;li&gt;image&lt;br/&gt;图像或图形数据，包括位图和矢量静止图像以及静止图像格式的动画版本。例如image/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;multipart类型&quot;&gt;Multipart类型&lt;/h4&gt;
&lt;p&gt;Multipart类型指明被分为几部分的一种文档的类目，且经常有不同的MIME类型。也可以用来表示属于相同事物的多个且独立的文件，这些独立的文件构成一个复杂的文档。在电子邮件场景中常见。&lt;br/&gt;有两种Multipart类型：message和multipart。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;message&lt;br/&gt;一个包括其他信息的消息，常用于下面的场景，例如指明一个邮件包含转发信息或者在多种信息的情况下，允许以chunk的形式发送数据量很大的信息。包括message/rfc822和message/partial&lt;/li&gt;
&lt;li&gt;multipart&lt;br/&gt;由多个不同MIME类型组件构成的数据，例如 multipart/form-data(使用FormData API生成的数据)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看完了基本定义，下面看看常见的类型及使用场景。&lt;/p&gt;
&lt;h3 id=&quot;常见类型及使用场景&quot;&gt;常见类型及使用场景&lt;/h3&gt;
&lt;h4 id=&quot;静态资源图片媒体类&quot;&gt;静态资源、图片、媒体类&lt;/h4&gt;
&lt;p&gt;对于静态资源、图片和媒体类，也就是text、image、video等比较清晰明了，不再详细描述。&lt;/p&gt;
&lt;h4 id=&quot;application类&quot;&gt;application类&lt;/h4&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;application/json&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着json这种轻量级的数据交互格式的流行，特别是和脚本交互的便利，使得在前后接口中，越来越多采用json格式。对于http协议来说，最终传输的还是字符。这里不再多进行描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;application/x-www-form-urlencoded&lt;/strong&gt;&lt;br/&gt;作为表单提交中默认的类型，其表明数据以标准的编码格式被编码为键值对。&lt;br/&gt;数据被编码成以 '&amp;amp;' 分隔的键-值对, 同时以 '=' 分隔键和值. 非字母或数字的字符会被 percent-encoding: 这也就是为什么这种类型不支持二进制数据的原因 (应使用 multipart/form-data 代替).&lt;br/&gt;我们以新浪为例，可以看到其请求报文(formdata那里选择，view source可以看得比较清楚)：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/14/16a1c6f743d8b587?w=1600&amp;amp;h=468&amp;amp;f=jpeg&amp;amp;s=128274&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;multipart/form-data&lt;/strong&gt;&lt;br/&gt;这里为了对比，就也放到这里来说了。&lt;br/&gt;一般用于涉及文件的表单提交，用于post请求，其格式如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;Content-Type: multipart/form-data; boundary=aBoundaryString&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中boundary指明了请求体中每部分的分割符(对于multipart的类目，都会存在该字段，以区分请求体中数据的分割)，其请求体中则是对应表单每部分的内容。每部分都会有自己的请求体和相关内容。&lt;br/&gt;例如如下的文档结构：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;  &amp;lt;form action=&quot;http://localhost:8000/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;
  &amp;lt;input type=&quot;text&quot; name=&quot;myTextField&quot;&amp;gt;
  &amp;lt;input type=&quot;checkbox&quot; name=&quot;myCheckBox&quot;&amp;gt;Check&amp;lt;/input&amp;gt;
  &amp;lt;input type=&quot;file&quot; name=&quot;myFile&quot;&amp;gt;
  &amp;lt;button&amp;gt;Send the file&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其请求信息如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;POST / HTTP/1.1
Host: localhost:8000
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
// 以 ---------------------------8721656041911415653955004498 作为分割符
Content-Type: multipart/form-data; boundary=---------------------------8721656041911415653955004498
Content-Length: 465

-----------------------------8721656041911415653955004498
// 分段一 文本相关信息
Content-Disposition: form-data; name=&quot;myTextField&quot;
// 对应value
Test
-----------------------------8721656041911415653955004498
// checkbox
Content-Disposition: form-data; name=&quot;myCheckBox&quot;

on
-----------------------------8721656041911415653955004498
// 文件
Content-Disposition: form-data; name=&quot;myFile&quot;; filename=&quot;test.txt&quot;
Content-Type: text/plain

Simple file.
-----------------------------8721656041911415653955004498--&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3.4813167259786&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;application/javascript application/x-javascript text/javascript&lt;/strong&gt;&lt;br/&gt;对于js文件，常见MIME类型为text/javascript，但是前两种应该会有见到过。三者之间多少还是有点区别的。&lt;br/&gt;传统的js程序对应的MIME类型为text/javascript，其他的还有&quot;application/x-javascript&quot;（x前缀表示这是实验性类型）， 因为text/javascript是最常见的类型，所以RFC4329定义了“text/javascript”。不过，js文件实际上并不是真正的文本类型，因此推出了application/javascript类型，不过现行的支持性并不好，所以常常会用application/x-javascript来代替。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;application/zip application/gzip&lt;/strong&gt;&lt;br/&gt;zip 对应zip压缩文件，gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.9634146341463&quot;&gt;
&lt;p&gt;&lt;strong&gt;application/http&lt;/strong&gt;&lt;br/&gt;这一种大家可能就不常见了，从类型可以知道，是http请求，但具体用途还是要翻下&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/http&quot;&gt;规范&lt;/a&gt;才能找到的。&lt;br/&gt;此类型包含的http请求包含在binary消息体中，在邮件协议传输中需要指明Content-Transfer-Encoding。&lt;br/&gt;在批量处理请求时会遇到，其表现如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;--batch_0123456789
Content-Type: application/http
Content-ID: 
// 必须的字段，表明传送内容的编码格式 即二进制流
Content-Transfer-Encoding: binary

POST https://www.googleapis.com/analytics/v3/management/accounts/XXXXXX/webproperties/UA-XXXXXX-1/customDimensions
Content-Type: application/json
Content-Length: 68

{
 &quot;name&quot;: &quot;Campaign Group&quot;,
 &quot;scope&quot;: &quot;SESSION&quot;,
 &quot;active&quot;: true
} &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;multipart类型-1&quot;&gt;multipart类型&lt;/h4&gt;
&lt;p&gt;正如上文所述，multipart一般对应单个消息头对应多个消息体。&lt;br/&gt;常见语法如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中boundary字段是必须的，用于区分消息体中的数据边界，一般是两个'-'的格式作为该端的开头，例如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;--gc0p4Jq0M2Yt08jU534c0p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们主要关注的也就是下面几种：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;multipart/form-data&lt;/strong&gt;&lt;br/&gt;见上面application部分。下面这几部分可能不是那么常见，不过还是可以了解一下，以免遇到的时候懵逼。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;multipart/mixed&lt;/strong&gt;&lt;br/&gt;该类型用于，消息体由多个独立的部分组成且想连续的展示。并且子数据类型有任一种无法被识别(此处指被浏览器直接识别的类型，例如text等)的类型时，都应该为mixed。&lt;br/&gt;概括而言就是该邮件有二进制内容，非可以直接识别的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;POST /batch/farm/v1 HTTP/1.1
Authorization: Bearer your_auth_token
Host: www.googleapis.com
Content-Type: multipart/mixed; boundary=batch_foobarbaz
Content-Length: total_content_length

--batch_foobarbaz
// 子内容为http请求 不过是boundary编码过的
Content-Type: application/http
Content-ID: &amp;lt;item1:12930812@barnyard.example.com&amp;gt;

GET /farm/v1/animals/pony

--batch_foobarbaz
Content-Type: application/http
Content-ID: &amp;lt;item2:12930812@barnyard.example.com&amp;gt;

PUT /farm/v1/animals/sheep
Content-Type: application/json
Content-Length: part_content_length
If-Match: &quot;etag/sheep&quot;

{
  &quot;animalName&quot;: &quot;sheep&quot;,
  &quot;animalAge&quot;: &quot;5&quot;
  &quot;peltColor&quot;: &quot;green&quot;,
}

--batch_foobarbaz
Content-Type: application/http
Content-ID: &amp;lt;item3:12930812@barnyard.example.com&amp;gt;

GET /farm/v1/animals
If-None-Match: &quot;etag/animals&quot;

--batch_foobarbaz--&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里消息体中的内容就是http请求，在google批量接口协议中用使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;multipart/alternative&lt;/strong&gt;&lt;br/&gt;该类型与mixed的语法相同，但语义不同。其表明，消息体中的不同部分应该是相同信息的不同版本。即内容相同传输类型不同，以适应不同的接受者。&lt;br/&gt;还是举例：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;From:  Nathaniel Borenstein &amp;lt;nsb@bellcore.com&amp;gt; 
To: Ned Freed &amp;lt;ned@innosoft.com&amp;gt; 
Subject: Formatted text mail 
MIME-Version: 1.0 
Content-Type: multipart/alternative; boundary=boundary42 


--boundary42 
Content-Type: text/plain; charset=us-ascii 

...plain text version of message goes here.... 

--boundary42 
Content-Type: text/richtext 

.... richtext version of same message goes here ... 
--boundary42 
Content-Type: text/x-whatever 

.... fanciest formatted version of same  message  goes  here 
... 
--boundary42-- &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如用户的系统可以识别 text/x-whatever 类型，那么其将会只看到这一部分。不同的用户看到什么内容取决于其系统支持何种类型。&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/drive/api/v3/batch?hl=zh-cn&quot; class=&quot;uri&quot;&gt;https://developers.google.com/drive/api/v3/batch?hl=zh-cn&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html&quot; class=&quot;uri&quot;&gt;https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里常见的content-type就介绍完了，感谢以上参考文章，此外水平有限可能有错误之处欢迎指出。对于前端同学来说，网络请求也是我们需要关注的部分，提升深度的同时也要注意落款广度，希望对有需要的同学有所裨益。&lt;/p&gt;
</description>
<pubDate>Sun, 14 Apr 2019 15:23:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<og:description>前言 作为前端开发，工作中少不了与接口请求打交道。对于常见的content type，也能说上来几个，感觉还算了解。直到有一天，我要在查看google的批量接口合并时发现Content Type: m</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/10708204.html</dc:identifier>
</item>
<item>
<title>基于Jenkins Pipeline的ASP.NET Core持续集成实践 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/edc_aspnetcore_jenkins_pipeline_introduction.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/edc_aspnetcore_jenkins_pipeline_introduction.html</guid>
<description>&lt;p&gt;最近在公司实践持续集成，使用到了Jenkins的Pipeline来提高团队基于ASP.NET Core API服务的集成与部署，因此这里总结一下。&lt;/p&gt;

&lt;h2&gt;1.1 持续集成相关概念&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/46653/201612/46653-20161230152143648-2113509642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成(Continuous integration，简称 CI) 。 &lt;/p&gt;
&lt;p&gt;　　持续集成指的是，&lt;strong&gt;频繁地 (一天多次) 将代码集成到主干&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　它的好处主要有两个：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;（1）&lt;strong&gt;快速发现错误&lt;/strong&gt;。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;防止分支大幅偏离主干&lt;/strong&gt;。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　持续集成的目的，就是&lt;strong&gt;让产品可以快速迭代，同时还能保持高质量&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Martin Fowler&lt;/strong&gt;&lt;/em&gt; 说：“ 持续集成并不能消除 Bug，而是让它们非常容易发现和改正。”　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　与持续集成相关的，还有持续交付和持续部署。&lt;/p&gt;
&lt;p&gt;　　持续交付指的是：&lt;strong&gt;频繁地将软件的新版本，交付给质量团队或者用户，以供评审&lt;/strong&gt;。如果评审通过，代码就进入生产阶段。它强调的是，&lt;strong&gt;不管怎么更新，软件是随时随地可以交付的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;CD&quot; src=&quot;https://images2015.cnblogs.com/blog/46653/201612/46653-20161230152159039-1261178652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　持续部署是持续交付的下一步，指的是&lt;strong&gt;代码通过评审以后，自动部署到生产环境&lt;/strong&gt;。它强调的是&lt;strong&gt;代码在任何时刻都是可部署的，可以进入生产阶段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;CD&quot; src=&quot;https://images2015.cnblogs.com/blog/46653/201612/46653-20161230152211445-454212849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.2 Jenkins Pipeline&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180808233203683-1020834546.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Jenkins 是一款流行的开源持续集成（CI）与持续部署（CD）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。有关Jenkins的安装，可以参考我的这一篇&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/CD_foundation_based_on_jenkins_and_docker.html&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;进行安装。&lt;/p&gt;
&lt;p&gt;　　相信很多童鞋都已经在使用Jenkins或者计划使用Jenkins来代替传统的人工发布流程了，因此我们创建了很多自由风格（Free Style）的构建任务用于多个Job，而我们经常会听到说流水线任务，那么流水线是什么呢？&lt;/p&gt;
&lt;p&gt;　　流水线Pipeline是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的&lt;strong&gt;复杂流程编排与可视化&lt;/strong&gt;。下图是一个Jenkins Pipeline的实例效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190411221446969-1021990733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Pipeline ：Build =&amp;gt; Test =&amp;gt; Deploy&lt;/p&gt;
&lt;p&gt;　　这里涉及到Pipeline中的几个重要概念，需要了解一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;&lt;strong&gt;Stage&lt;/strong&gt;&lt;/em&gt;: 阶段，一个Pipeline可以划分为若干个Stage，每个Stage代表一组操作。注意，Stage是一个逻辑分组的概念，可以跨多个Node。如上图所示，Build，Test和Deploy就是Stage，代表了三个不同的阶段：编译、测试和部署。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Node&lt;/strong&gt;&lt;/em&gt;: 节点，一个Node就是一个Jenkins节点，或者是Master，或者是Slave，是执行Step的具体运行期环境。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Step&lt;/strong&gt;&lt;/em&gt;: 步骤，Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenkins Plugin提供。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.1 安装Docker环境&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726221105300-1650411740.png&quot; alt=&quot;&quot; width=&quot;334&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以参考我的这一篇《&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnetcore_on_docker_foundation.html&quot;&gt;.NET Core微服务之ASP.NET Core on Docker&lt;/a&gt;》来安装和配置Docker环境，建议在Linux环境下配置。&lt;/p&gt;
&lt;h2&gt;2.2 安装SFTP服务&lt;/h2&gt;
&lt;p&gt;　　在Linux下，SSH服务默认会安装，而在Windows Server下，需要单独安装，可以借助FreeSSHD这个免费工具来实现。由于我的物理机都是Windows Server，物理机上的VM是Linux（Docker运行环境），所以需要给物理机配置FreeSSHD，用来实现从CI服务器发布Release到物理服务器中的VM。&lt;/p&gt;
&lt;p&gt;　　至于如何安装配置FreeSSHD，可以参考这一篇《&lt;a href=&quot;https://www.cnblogs.com/Kevin00/p/6339925.html&quot;&gt;freeSSHD在windows环境下搭建SFTP服务器&lt;/a&gt;》。&lt;/p&gt;

&lt;h2&gt;3.1 总体目标&lt;/h2&gt;
&lt;p&gt;　　（1）持续集成：实现编译+单元测试的自动运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414223341375-100845605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里我要实现的目标是：当有人push代码到git server中（这里我使用的git server是Gogs，需要给Gogs设置一个Webhook，如下图所示，需要注意的是设置的密钥文本要和在Pipeline中填写的一致，否则Jenkins无法正确接收Web钩子），git server会触发一个webhook发送一个post的请求给CI server，CI server会触发Pipeline任务的构建，一路pull代码+编译+单元测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414223825644-1797545720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）持续发布：实现编译+发布到具体的测试环境&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414224246145-1048664321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由于在开发阶段，我不需要每次Push都进行发布，因此我这里设置的是手动在Jenkins中触发发布任务来实现自动化发布。&lt;/p&gt;
&lt;h2&gt;3.2 全局设置&lt;/h2&gt;
&lt;p&gt;　　首先，肯定是Jenkins的插件安装了。&lt;/p&gt;
&lt;p&gt;　　（1）Generic WebHook Trigger =&amp;gt; 触发WebHook必备&lt;/p&gt;
&lt;p&gt;　　（2）Gogs Plugin =&amp;gt; 因为我使用的Git Server是Gogs搭建的&lt;/p&gt;
&lt;p&gt;　　（3）MSBuild Plugin =&amp;gt; 进行sln、csproj项目文件的编译&lt;/p&gt;
&lt;p&gt;　　（4）MSTest &amp;amp; xUnit =&amp;gt; 进行基于MSTest或基于xUnit的单元测试&lt;/p&gt;
&lt;p&gt;　　（5）Nuget Plugin =&amp;gt; 拉取Nuget包必备&lt;/p&gt;
&lt;p&gt;　　（6）Pipeline =&amp;gt; 实现Pipeline任务必备，建议将Pipeline相关插件都安装上&lt;/p&gt;
&lt;p&gt;　　（7）Powershell Plugin =&amp;gt; 如果你的CI服务器是基于Windows的，那么安装一下Powershell插件来执行命令吧&lt;/p&gt;
&lt;p&gt;　　（8）Publish Over SSH =&amp;gt; 远程发布Release必备&lt;/p&gt;
&lt;p&gt;　　（9）WallDisplay =&amp;gt; 电视投屏构建任务列表必备&lt;/p&gt;
&lt;p&gt;　　其次，为了提示邮件，也要Email插件（Email Extension）的支持，并进行以下配置：&lt;/p&gt;
&lt;p&gt;　　（1）第一处：Jenkins Location&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414224530052-2111943239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）第二处：Email扩展插件全局变量设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414224825881-1087563711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里主要是需要设置Subject和Content，就可以在各个Pipeline中使用了。因此，这里贴出我的Default Content内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${ENV, var=&quot;JOB_NAME&quot;}-第${BUILD_NUMBER}次构建日志&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
  
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;leftmargin&lt;/span&gt;&lt;span&gt;=&quot;8&quot;&lt;/span&gt;&lt;span&gt; marginwidth&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; topmargin&lt;/span&gt;&lt;span&gt;=&quot;8&quot;&lt;/span&gt;&lt;span&gt; marginheight&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt;  
    offset&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;=&quot;95%&quot;&lt;/span&gt;&lt;span&gt; cellpadding&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; cellspacing&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;  style&lt;/span&gt;&lt;span&gt;=&quot;font-size: 11pt; font-family: Microsoft YaHei, Tahoma, Arial, Helvetica&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;各位同事，大家好，以下为 ${PROJECT_NAME } 构建任务信息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;  
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;font-weight:bold; color:#66cc00&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;构建信息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;100%&quot;&lt;/span&gt;&lt;span&gt; align&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;任务名称 ： ${PROJECT_NAME}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;构建编号 ： 第${BUILD_NUMBER}次构建&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;触发原因： ${CAUSE}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;构建状态： &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;font-weight:bold; color:#FF0000&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${BUILD_STATUS}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;构建日志： &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;${BUILD_URL}console&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${BUILD_URL}console&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;构建  Url ： &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;${BUILD_URL}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${BUILD_URL}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;工作目录 ： &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;${PROJECT_URL}ws&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${PROJECT_URL}ws&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;项目  Url ： &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;${PROJECT_URL}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${PROJECT_URL}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414224703855-719999543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了能够发给更多的人，建议勾选以上两个选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414225033301-1709451843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里是Email通知必填的SMTP服务器配置。&lt;/p&gt;
&lt;p&gt;　　最后，是SSH服务器的声明，指定可以进行SSH发布的服务器有哪些，IP又是多少：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414230103829-1232685046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.3 新增Pipeline脚本&lt;/h2&gt;
&lt;p&gt;　　（1）持续集成Pipeline&lt;/p&gt;
&lt;p&gt;　　首先，填写Webhook的密钥文本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414230855749-767949624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其次，Build Triggers的时机选择“Build when a change is pushed to Gogs”，即有人push代码到仓库就触发。当然，这里需要提前在Gogs设置Webhook。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414225820854-501711250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其次，编写Pipeline脚本，各个Stage写清楚职责：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190414230213917-281363752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　具体的Pipeline脚本在下边：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('13321a9b-a6a9-4dc9-b4b1-4fae22d9cc5c')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_13321a9b-a6a9-4dc9-b4b1-4fae22d9cc5c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_13321a9b-a6a9-4dc9-b4b1-4fae22d9cc5c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('13321a9b-a6a9-4dc9-b4b1-4fae22d9cc5c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_13321a9b-a6a9-4dc9-b4b1-4fae22d9cc5c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pipeline{
    agent any
    stages {
        stage('XDP Core Services Checkout') {
            steps{
             checkout([&lt;/span&gt;&lt;span&gt;$class&lt;/span&gt;: 'GitSCM', branches: [[name: '*/dev-xds']], doGenerateSubmoduleConfigurations: &lt;span&gt;false&lt;/span&gt;, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '35b9890b-2338-45e2-8a1a-78e9bbe1d3e2', url: 'http://192.168.18.150:3000/EDC.ITC.XDP.Core/&lt;span&gt;EDC.XDP.Core.git']]])
             echo 'Core Services Checkout Done' 
            }
        }
        stage('XDP Core Services Build') {
            steps{
              bat  '''cd &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\Jenkins\\workspace\\XDS.Dev.CI.Pipeline\\src\\services\\EDC.XDP.Core\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
              dotnet build EDC.XDP.Core&lt;/span&gt;-&lt;span&gt;All.sln'''
              echo 'Core Services Build Done' 
            }
        }
        stage('Core Delivery Service Unit Test') {
            steps{
                bat  '''cd &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\Jenkins\\workspace\\XDS.Dev.CI.Pipeline\\src\\services\\EDC.XDP.Core\\Services\\EDC.XDP.Core.Delivery.UnitTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                dotnet test &lt;/span&gt;-v n --no-&lt;span&gt;build EDC.XDP.Core.Delivery.UnitTest.csproj'''
                echo 'Core Delivery Service Unit Test Done'  
            }
        }
        stage('XDS Delivery Service Checkout') {
            steps{
             checkout([&lt;/span&gt;&lt;span&gt;$class&lt;/span&gt;: 'GitSCM', branches: [[name: '*/dev-service']], doGenerateSubmoduleConfigurations: &lt;span&gt;false&lt;/span&gt;, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '35b9890b-2338-45e2-8a1a-78e9bbe1d3e2', url: 'http://192.168.18.150:3000/EDC.ITC.XDP.XDS/&lt;span&gt;EDC.XDP.XDS.git']]])
             echo 'Core Delivery Service Checkout Done' 
            }
        }
        stage('XDS Delivery Service Build') {
            steps{
               bat  '''cd &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\Jenkins\\workspace\\XDS.Dev.CI.Pipeline\\src\\services\\EDC.XDP.XDS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               dotnet build EDC.XDP.XDS.sln'''
               echo 'XDS Service Build Done' 
            }
        }
        stage('XDS Delivery Service Unit Test') {
            steps{
                bat  '''cd &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\Jenkins\\workspace\\XDS.Dev.CI.Pipeline\\src\\services\\EDC.XDP.XDS\\EDC.XDP.XDS.Delivery.UnitTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                dotnet test &lt;/span&gt;-v n --no-&lt;span&gt;build EDC.XDP.XDS.Delivery.UnitTest.csproj'''
                echo 'XDS Service Unit Test Done'  
            }
        } 
    }
    post{
        failure {
            emailext (
                subject: '&lt;/span&gt;&lt;span&gt;${DEFAULT_SUBJECT}&lt;/span&gt;&lt;span&gt;',
                body: '&lt;/span&gt;&lt;span&gt;${DEFAULT_CONTENT}&lt;/span&gt;&lt;span&gt;',
                to: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;edisonchou@qq.com,xxxxx@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　（2）持续发布Pipeline&lt;/p&gt;
&lt;p&gt;　　持续发布Pipeline与持续集成Pipeline类似，只是在脚本处有所不同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bec6f76a-777d-4967-9deb-ccb029191197')&quot; readability=&quot;70.5&quot;&gt;&lt;img id=&quot;code_img_closed_bec6f76a-777d-4967-9deb-ccb029191197&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bec6f76a-777d-4967-9deb-ccb029191197&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bec6f76a-777d-4967-9deb-ccb029191197',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bec6f76a-777d-4967-9deb-ccb029191197&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;136&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pipeline{
    agent any
    stages {
        stage('Core Delivery Service Checkout') {
            steps{
             checkout([&lt;/span&gt;&lt;span&gt;$class&lt;/span&gt;: 'GitSCM', branches: [[name: '*/dev-xds']], doGenerateSubmoduleConfigurations: &lt;span&gt;false&lt;/span&gt;, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '35b9890b-2338-45e2-8a1a-78e9bbe1d3e2', url: 'http://192.168.18.150:3000/EDC.ITC.XDP.Core/&lt;span&gt;EDC.XDP.Core.git']]])
             echo 'Core Delivery Service Dev Branch Checkout Done' 
            }
        }
        stage('Core Delivery Service Build &lt;/span&gt;&amp;amp;&lt;span&gt; Publish') {
            steps{
              bat  '''cd &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\Jenkins\\workspace\\XDS.API.Dev.CD.Pipeline\\src\\services\\EDC.XDP.Core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               dotnet build EDC.XDP.Core&lt;/span&gt;-&lt;span&gt;DataServices.sln
               dotnet publish &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%WORKSPACE%\\src\\services\\EDC.XDP.Core\\Services\\EDC.XDP.Core.Delivery.API\\EDC.XDP.Core.Delivery.API.csproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%WORKSPACE%\\EDC.XDP.Core.Delivery.API/publish&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --framework netcoreapp2.1&lt;span&gt;
               '''
               echo 'Core Delivery Service Build &lt;/span&gt;&amp;amp;&lt;span&gt; Publish Done'
            }
        }
        stage('Core Delivery Service Deploy To &lt;/span&gt;190&lt;span&gt; Server') {
            steps{
            sshPublisher(publishers: [sshPublisherDesc(configName: 'XDP&lt;/span&gt;-DEV-Server', transfers: [sshTransfer(cleanRemote: &lt;span&gt;false&lt;/span&gt;, excludes: '', execCommand: '''docker stop xdp_core_deliveryservice; docker rm xdp_core_deliveryservice; docker run --ulimit core=0 --restart=always -v /etc/localtime:/etc/localtime -d -e ASPNETCORE_ENVIRONMENT=dev --privileged=&lt;span&gt;true&lt;/span&gt; --name=xdp_core_deliveryservice -p 8010:80 -v /XiLife/publish/EDC.XDP.Core.Delivery.API/:/app -w /app xdp_service_runtime:latest  dotnet EDC.XDP.Core.Delivery.API.dll''', execTimeout: 120000, flatten: &lt;span&gt;false&lt;/span&gt;, makeEmptyDirs: &lt;span&gt;false&lt;/span&gt;, noDefaultExcludes: &lt;span&gt;false&lt;/span&gt;, patternSeparator: '[, ]+', remoteDirectory: 'EDC.XDP.Core.Delivery.API/', remoteDirectorySDF: &lt;span&gt;false&lt;/span&gt;, removePrefix: 'EDC.XDP.Core.Delivery.API/publish/', sourceFiles: 'EDC.XDP.Core.Delivery.API/publish/**')], usePromotionTimestamp: &lt;span&gt;false&lt;/span&gt;, useWorkspaceInPromotion: &lt;span&gt;false&lt;/span&gt;, verbose: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)])
            echo 'Delivery Service Deploy To &lt;/span&gt;190&lt;span&gt; Done'    
            }
        }
        stage('Core Delivery Service Deploy To &lt;/span&gt;175&lt;span&gt; Server') {
            steps{
            sshPublisher(publishers: [sshPublisherDesc(configName: 'XDP&lt;/span&gt;-DEV-MT-Server', transfers: [sshTransfer(cleanRemote: &lt;span&gt;false&lt;/span&gt;, excludes: '', execCommand: '''docker stop xdp_core_deliveryservice; docker rm xdp_core_deliveryservice; docker run --ulimit core=0 --restart=always -v /etc/localtime:/etc/localtime -d -e ASPNETCORE_ENVIRONMENT=devmt --privileged=&lt;span&gt;true&lt;/span&gt; --name=xdp_core_deliveryservice -p 8010:80 -v /XiLife/publish/EDC.XDP.Core.Delivery.API/:/app -w /app xdp_service_runtime:latest  dotnet EDC.XDP.Core.Delivery.API.dll''', execTimeout: 120000, flatten: &lt;span&gt;false&lt;/span&gt;, makeEmptyDirs: &lt;span&gt;false&lt;/span&gt;, noDefaultExcludes: &lt;span&gt;false&lt;/span&gt;, patternSeparator: '[, ]+', remoteDirectory: 'EDC.XDP.Core.Delivery.API/', remoteDirectorySDF: &lt;span&gt;false&lt;/span&gt;, removePrefix: 'EDC.XDP.Core.Delivery.API/publish/', sourceFiles: 'EDC.XDP.Core.Delivery.API/publish/**')], usePromotionTimestamp: &lt;span&gt;false&lt;/span&gt;, useWorkspaceInPromotion: &lt;span&gt;false&lt;/span&gt;, verbose: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)])
            echo 'Delivery Service Deploy To &lt;/span&gt;175&lt;span&gt; Done'    
            }
        }
        stage('XDS Delivery Service Checkout') {
            steps{
             checkout([&lt;/span&gt;&lt;span&gt;$class&lt;/span&gt;: 'GitSCM', branches: [[name: '*/dev-service']], doGenerateSubmoduleConfigurations: &lt;span&gt;false&lt;/span&gt;, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '35b9890b-2338-45e2-8a1a-78e9bbe1d3e2', url: 'http://192.168.18.150:3000/EDC.ITC.XDP.XDS/&lt;span&gt;EDC.XDP.XDS.git']]])
             echo 'XDS Delivery Service Checkout Done' 
            }
        }
        stage('XDS Delivery Service Build &lt;/span&gt;&amp;amp;&lt;span&gt; Publish') {
            steps{
              bat  '''cd &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\Jenkins\\workspace\\XDS.API.Dev.CD.Pipeline\\src\\services\\EDC.XDP.XDS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               dotnet build EDC.XDP.XDS.sln
               dotnet publish &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%WORKSPACE%\\src\\services\\EDC.XDP.XDS\\EDC.XDP.XDS.Delivery.API\\EDC.XDP.XDS.Delivery.API.csproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%WORKSPACE%\\EDC.XDP.XDS.Delivery.API/publish&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --framework netcoreapp2.1&lt;span&gt;
               '''
               echo 'XDS Delivery Service Build &lt;/span&gt;&amp;amp;&lt;span&gt; Publish Done' 
            }
        }
        stage('XDS Delivery Service Deploy To &lt;/span&gt;190&lt;span&gt; Server') {
            steps{
            sshPublisher(publishers: [sshPublisherDesc(configName: 'XDP&lt;/span&gt;-DEV-Server', transfers: [sshTransfer(cleanRemote: &lt;span&gt;false&lt;/span&gt;, excludes: '', execCommand: '''docker stop xdp_xds_delivery_service;docker rm xdp_xds_delivery_service; docker run --ulimit core=0 --restart=always -v /etc/localtime:/etc/localtime -d -e ASPNETCORE_ENVIRONMENT=dev --privileged=&lt;span&gt;true&lt;/span&gt; --name=xdp_xds_delivery_service -p 9020:80 -v /XiLife/publish/EDC.XDP.XDS.Delivery.API/:/app -w /app xdp_service_runtime:latest  dotnet EDC.XDP.XDS.Delivery.API.dll''', execTimeout: 120000, flatten: &lt;span&gt;false&lt;/span&gt;, makeEmptyDirs: &lt;span&gt;false&lt;/span&gt;, noDefaultExcludes: &lt;span&gt;false&lt;/span&gt;, patternSeparator: '[, ]+', remoteDirectory: 'EDC.XDP.XDS.Delivery.API/', remoteDirectorySDF: &lt;span&gt;false&lt;/span&gt;, removePrefix: 'EDC.XDP.XDS.Delivery.API/publish/', sourceFiles: 'EDC.XDP.XDS.Delivery.API/publish/**')], usePromotionTimestamp: &lt;span&gt;false&lt;/span&gt;, useWorkspaceInPromotion: &lt;span&gt;false&lt;/span&gt;, verbose: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)])
            echo 'XDS Delivery Service Deploy to &lt;/span&gt;190&lt;span&gt; Done'    
            }
        }
        stage('XDS Delivery Service Deploy To &lt;/span&gt;175&lt;span&gt; Server') {
            steps{
            sshPublisher(publishers: [sshPublisherDesc(configName: 'XDP&lt;/span&gt;-DEV-MT-Server', transfers: [sshTransfer(cleanRemote: &lt;span&gt;false&lt;/span&gt;, excludes: '', execCommand: '''docker stop xdp_xds_delivery_service;docker rm xdp_xds_delivery_service; docker run --ulimit core=0 --restart=always -v /etc/localtime:/etc/localtime -d -e ASPNETCORE_ENVIRONMENT=devmt --privileged=&lt;span&gt;true&lt;/span&gt; --name=xdp_xds_delivery_service -p 9020:80 -v /XiLife/publish/EDC.XDP.XDS.Delivery.API/:/app -w /app xdp_service_runtime:latest  dotnet EDC.XDP.XDS.Delivery.API.dll''', execTimeout: 120000, flatten: &lt;span&gt;false&lt;/span&gt;, makeEmptyDirs: &lt;span&gt;false&lt;/span&gt;, noDefaultExcludes: &lt;span&gt;false&lt;/span&gt;, patternSeparator: '[, ]+', remoteDirectory: 'EDC.XDP.XDS.Delivery.API/', remoteDirectorySDF: &lt;span&gt;false&lt;/span&gt;, removePrefix: 'EDC.XDP.XDS.Delivery.API/publish/', sourceFiles: 'EDC.XDP.XDS.Delivery.API/publish/**')], usePromotionTimestamp: &lt;span&gt;false&lt;/span&gt;, useWorkspaceInPromotion: &lt;span&gt;false&lt;/span&gt;, verbose: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)])
            echo 'XDS Delivery Service Deploy to &lt;/span&gt;175&lt;span&gt; Done'    
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　这里由于我的测试环境分为两个，一个是开发人员联调环境190，另一个是集成测试环境175，统一在一个Pipeline任务中进行发布。&lt;/p&gt;
&lt;p&gt;　　对于Master分支，我们还可以将Web系统的发布也集成到同一个Pipeline任务中，实现一个一条龙的发布流水线任务，由于各个Web系统的实现技术不一样，这里就不再贴脚本了。&lt;/p&gt;

&lt;p&gt;　　（1）持续集成示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190412171101885-121564805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）持续发布示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190412171135938-265578859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）构建失败告警&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190412171202704-189482496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）构建大屏显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190412171315266-338498862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再来一张投屏到工作区域电视屏幕中的效果，大家抬头就可以看到构建结果，是绿了还是红了？当然，我们都喜欢“绿”的，呼呼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190412172458230-952457504.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　借助持续集成和持续发布，我们开发人员可以节省很多质量保证和发布部署的时间，从而减少很多因为人为QA和Deploy造成的失误影响，从另一个层面上，它也可以使我们避免996（好吧，虽然关联有点牵强）。后续，我还会探索K8S，到时候希望能够分享一个ASP.NET Core on K8S的系列文章，敬请期待。&lt;/p&gt;

&lt;p&gt;大宝鱼，《&lt;a href=&quot;https://blog.csdn.net/diantun00/article/details/81075007&quot; target=&quot;_blank&quot;&gt;玩转Jenkins Pipeline&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;李志强，《&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/10115583.html&quot;&gt;Jenkins高级用法 - Pipeline 安装&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;李志强，《&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/10115589.html&quot;&gt;Jenkins高级用法 - Jenkinsfile 介绍及实战经验&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;三只松鼠，《&lt;a href=&quot;https://www.cnblogs.com/shenh/p/8963688.html&quot;&gt;jenkins + pipeline构建自动化部署&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;ofnhkb1，《&lt;a href=&quot;https://www.cnblogs.com/ofnhkb1/p/7801220.html&quot;&gt;.NET项目从CI到CD-Jenkins_Pipeline的应用&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 14 Apr 2019 15:19:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>最近在公司实践持续集成，使用到了Jenkins的Pipeline来提高团队基于ASP.NET Core API服务的集成与部署，因此这里总结一下。 一、关于持续集成与Jenkins Pipeline</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/edc_aspnetcore_jenkins_pipeline_introduction.html</dc:identifier>
</item>
<item>
<title>Python爬虫使用lxml模块爬取豆瓣读书排行榜并分析 - Berryguo</title>
<link>http://www.cnblogs.com/berryguotoshare/p/10708143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/berryguotoshare/p/10708143.html</guid>
<description>&lt;p&gt;上次使用了BeautifulSoup库爬取电影排行榜，爬取相对来说有点麻烦，爬取的速度也较慢。本次使用的lxml库，我个人是最喜欢的，爬取的语法很简单，爬取速度也快。&lt;/p&gt;
&lt;p&gt;本次爬取的豆瓣书籍排行榜的首页地址是：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.douban.com/doulist/1264675/?start=0&amp;amp;sort=time&amp;amp;playable=0&amp;amp;sub_type=&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.douban.com/doulist/1264675/?start=0&amp;amp;sort=time&amp;amp;playable=0&amp;amp;sub_type=&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该排行榜一共有22页，且发现更改网址的 &lt;span&gt;start=0 &lt;span&gt;的  &lt;span&gt;&lt;strong&gt;0&lt;/strong&gt; &lt;span&gt;为25、50就可以跳到排行榜的第二、第三页，所以后面只需更改这个数字然后通过遍历就可以爬取整个排行榜的书籍信息。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本次爬取的内容有&lt;span&gt;书名&lt;/span&gt;、&lt;span&gt;评分&lt;/span&gt;、&lt;span&gt;评价数&lt;/span&gt;、&lt;/span&gt;&lt;span&gt;出版社&lt;/span&gt;、&lt;span&gt;出版年份&lt;/span&gt;以及&lt;span&gt;书籍封面图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，封面图保存为图片，其他数据存为csv文件，方面后面读取分析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本次的项目步骤：一、分析网页，确定爬取数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　二、使用lxml库爬取内容并保存&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　三、读取数据并选择部分内容进行分析&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;步骤一：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201904/1526536-20190414181848252-76832351.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;529&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分析网页源代码可以看到，书籍信息在属性为 &lt;span&gt;&lt;span&gt;class&lt;/span&gt;=&quot;doulist-item&quot;&lt;/span&gt;的&lt;span&gt;div&lt;/span&gt;标签中,打开发现，我们需要爬取的信息都在标签内部，通过xpath语法我们可以很简便的爬取所需内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201904/1526536-20190414221438068-156055217.png&quot; alt=&quot;&quot;/&gt;(书籍各类信息所在标签）&lt;/p&gt;
&lt;p&gt;所需爬取的内容在 class为post、title、rating、abstract的div标签中。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;步骤二：&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;ol&gt;&lt;li&gt;先定义爬取函数，爬取所需内容&lt;/li&gt;
&lt;li&gt;执行函数，并存入csv文件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体代码如下：　　&lt;span&gt;注：转载代码请标明出处&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; csv
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;信息头&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义爬取函数&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; douban_booksrank(url):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     res = requests.get(url, headers=&lt;span&gt;headers)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     selector =&lt;span&gt; etree.HTML(res.text)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     contents = selector.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;article&quot;]/div[contains(@class,&quot;doulist-item&quot;)]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;循环点&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; content &lt;span&gt;in&lt;/span&gt;&lt;span&gt; contents:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             title = content.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div/div[2]/div[3]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;书名&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             scores = content.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div/div[2]/div[4]/span[2]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;评分&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             scores.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为有一些书没有评分，导致列表为空，此处添加一个默认评分，若无评分则默认为9.0&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             score =&lt;span&gt; scores[0]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             comments = content.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div/div[2]/div[4]/span[3]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;评论数量&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             author = content.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div/div[2]/div[5]/text()[1]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;作者&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             publishment = content.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div/div[2]/div[5]/text()[2]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0]   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;出版社&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             pub_year = content.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div/div[2]/div[5]/text()[3]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;出版时间&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             img_url = content.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div/div[2]/div[2]/a/img/@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;书本图片的网址&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             img = requests.get(img_url) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;解析图片网址，为下面下载图片&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             img_name_file = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:/Users/lenovo/Desktop/douban_books/{}.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format((title.strip())[:3])   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;图片存储位置，图片名只取前3&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入csv&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\lenovo\Desktop\\douban_books.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, newline=&lt;span&gt;''&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)as fp:   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;newline 使不隔行&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                 writer =&lt;span&gt; csv.writer(fp)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                writer.writerow((title, score, comments, author, publishment, pub_year, img_url))
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;下载图片，为防止图片名导致格式错误，加入try...except&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 with open(img_name_file, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)as imgf:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    imgf.write(img.content)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt; FileNotFoundError &lt;span&gt;or&lt;/span&gt;&lt;span&gt; OSError:
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             time.sleep(0.5) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;睡眠0.5s&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; IndexError:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行程序&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;爬取所以书本，共22页的内容&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     urls = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.douban.com/doulist/1264675/?start={}&amp;amp;sort=time&amp;amp;playable=0&amp;amp;sub_type=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(str(i))&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0,550,25&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写csv首行&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\lenovo\Desktop\\douban_books.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, newline=&lt;span&gt;''&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)as f:
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         writer =&lt;span&gt; csv.writer(f)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         writer.writerow((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;comment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;publishment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pub_year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;img_url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历所有网页，执行爬取程序&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; urls:
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         douban_booksrank(url)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;爬取结果截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201904/1526536-20190414224034570-1254945812.png&quot; alt=&quot;保存csv格式的爬取数据&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1526536/201904/1526536-20190414224138066-1010440255.png&quot; alt=&quot;爬取的封面图片&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;步骤三：&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;本次使用Python常用的数据分析库pandas来提取所需内容。pandas的&lt;span&gt;read_csv()&lt;span&gt;函数可以读取csv文件并根据文件格式转换为Series、DataFrame或面板对象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;此处我们提取的数据转变为DataFrame（数据帧）对象，然后通过Matplotlib绘图库来进行绘图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;具体代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot as plt
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; plt.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font.sans-serif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SimHei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来正常显示中文标签&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; plt.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axes.unicode_minus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=False &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来正常显示负号&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; plt.subplots_adjust(hspace=0.5) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;调整subplot上下子图间的距离&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; pd.set_option(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;display.max_rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, None) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置使dataframe 所有行都显示&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; df = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\lenovo\Desktop\\douban_books.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取csv文件，并赋为dataframe对象&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; comment = re.findall(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\((.*?)人评价&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, str(df.comment), re.S)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用正则表达式获取评论人数&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将comment的元素化为整型&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; new_comment =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; comment:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    new_comment.append(int(i))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; pub_year = re.findall(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\d{4}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, str(df.pub_year),re.S)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取书籍出版年份&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;同上&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; new_pubyear =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pub_year:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    new_pubyear.append(int(n))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘图&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1、绘制书籍评分范围的直方图&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; plt.subplot(2,2,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; plt.hist(df.score, bins=16, edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;豆瓣书籍排行榜评分分布&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontweight=700&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; plt.xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scores&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;numbers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制书籍评论数量的直方分布图&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; plt.subplot(222&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; plt.hist(new_comment, bins=16, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yellow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;豆瓣书籍排行榜评价分布&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontweight=700&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; plt.xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;评价数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;书籍数量（单位/本）&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制书籍出版年份分布图&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; plt.subplot(2,2,3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; plt.hist(new_pubyear, bins=30, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;indigo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;书籍出版年份分布&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontweight=700&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; plt.xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;出版年份/year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;书籍数量/本&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;寻找关系&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; plt.subplot(224&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; plt.bar(new_pubyear,new_comment, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;书籍出版年份与评论数量的关系&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontweight=700&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; plt.xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;出版年份/year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;评论数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; plt.savefig(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\lenovo\Desktop\\douban_books_analysis.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)   #保存图片
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的是，使用了&lt;span&gt;正则表达式&lt;/span&gt;来提取评论数和出版年份，将其中的符合和问题剔除。&lt;/p&gt;
&lt;p&gt;分析结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;豆瓣排行榜图书数据&quot; src=&quot;https://img2018.cnblogs.com/blog/1526536/201904/1526536-20190414225442490-1957197694.png&quot; alt=&quot;数据图像化的结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本次分析的内容也较为简单，从上面的几个图形中我们也能得出一些结论。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这些高分书籍中绝大多数的评论数量都在50000以下；&lt;/li&gt;
&lt;li&gt;多数排行榜上的高分书籍都出版在2000年以后；&lt;/li&gt;
&lt;li&gt;出版年份在2000年后的书籍有更多的评论数量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上数据也见解的说明了在进入二十世纪后我国的图书需求量更大了，网络更发达，更多人愿意发表自己的看法。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本次的分享到此。若有错误，欢迎指正。有建议的话也可以留言。&lt;/p&gt;

</description>
<pubDate>Sun, 14 Apr 2019 15:10:00 +0000</pubDate>
<dc:creator>Berryguo</dc:creator>
<og:description>Python爬取豆瓣图书排行榜</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/berryguotoshare/p/10708143.html</dc:identifier>
</item>
<item>
<title>Python后台开发Django（会话控制） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10496876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10496876.html</guid>
<description>&lt;h2&gt;页面跳转&lt;/h2&gt;
&lt;p&gt;页面跳转的url中必须在最后会自动添加【\】，所以在urls.py的路由表中需要对应添加【\】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt; redirect &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;本地页面跳转&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/dongxiaodong/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;其他网站跳转&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本地跳转需要参考urls.py的路由表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
urlpatterns =&lt;span&gt; [
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, admin.site.urls),
    path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,views.homex),&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加URL对应关系&lt;/span&gt;
]
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;Cookie&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;设置&lt;span lang=&quot;EN-US&quot;&gt;cookie&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 本地页面跳转&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt; redirect  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; retx = redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回文件,并匹配值&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt; render &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; retx= render(requestx, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loginx.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongkk1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;替换值1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongkk2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;替换值2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}) 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回字符串&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HttpResponse
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; retx=HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;东小东【dongxiaodong】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置cookie&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; retx.set_cookie(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; retx.set_cookie(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dname2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodongxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,max_age=100)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置超时时间，单位为秒&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; retx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;获取cookie&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dnamex=requestx.COOKIES.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置cookie的超时时间为过去时间即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookie加密&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
retx.set_signed_cookie(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong33&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,salt=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任意字符串（密文）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;cookie通过密文加密&lt;/span&gt;
dnamex3 = requestx.get_signed_cookie(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, salt=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;对应设置cookie时的密文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取cookie&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Session&lt;/h2&gt;
&lt;p&gt;依赖于cookie的sessionid的随机字符串，默认超时时间为浏览器不退出情况下的两周或者浏览器退出就立即失效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
requestx.session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodongsss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
requestx.session.set_expiry(&lt;/span&gt;60*60)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置超时时间，单位为秒&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;获取&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
dnamex = requestx.session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
dnamex &lt;/span&gt;= requestx.session.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;无该键时程序不会报错&lt;/span&gt;
ssid = requestx.session.session_key &lt;span&gt;#&lt;/span&gt;&lt;span&gt;得到sessionid,值与cookie保存的相同&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;del&lt;/span&gt; requestx.session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
requestx.session.clear() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;清空所有session&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;相关配置（setting.py）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; SESSION_COOKIE_NAME=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sessionid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; SESSION_COOKIE_PATH=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存的路径（默认）&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; SESSION_COOKIE_DOMAIN = None             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存的域名（默认）&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; SESSION_COOKIE_SECURE = False            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否Https传输cookie（默认）&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; SESSION_COOKIE_HTTPONLY = True           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否Session的cookie只支持http传输（默认）&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; SESSION_COOKIE_AGE = 1209600              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie失效日期（2周）（默认）&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; SESSION_EXPIRE_AT_BROWSER_CLOSE = False   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否关闭浏览器使得Session过期（默认）&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否每次请求都保存Session，默认修改之后才保存（默认）&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果SESSION_SAVE_EVERY_REQUEST = True时，可以配合requestx.session.set_expiry(60*60)，实现无操作一分钟后页面session清除，页面失效&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; SESSION_SAVE_EVERY_REQUEST = False
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;中间件&lt;/h2&gt;
&lt;p&gt;所有的请求都会先进入中间件处理，执行完所有中间件（MIDDLEWARE = [ ]）才会进入urls.py进行路由，然后进入对应的APP的views.py中执行逻辑处理，中间件可以获取到请求的任意数据，可以做一些IP黑名单等处理&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSR保护&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Post提交数据时，Django自动会进行CSR验证，在POST提交数据端需要提交一条随机字符串，服务器会匹配其的内容&lt;/p&gt;
&lt;p&gt;设置是否需要全局csr保护&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;全局设置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要在setting.py设置MIDDLEWARE = [ ]，&lt;/p&gt;
&lt;p&gt;如果注释【'django.middleware.csrf.CsrfViewMiddleware',】则表示不用验证，反之&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;部分设置（优先级高）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在APP对应views.py下添加函数装饰器即可实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.views.decorators.csrf &lt;span&gt;import&lt;/span&gt;&lt;span&gt; csrf_exempt,csrf_protect
@csrf_protect  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;强制添加保护&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; xx1(requestx):
   &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
@csrf_exempt   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;强制取消保护&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; xx2(requestx):
   &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Form表单里的post请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% csrf_token %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;xx&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交了&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ajax里的post请求，需要获取cookie的csrf值，并以请求头的方式发送到服务器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
headers:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-CSRFtoken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:$.cookie(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;csrftoken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;添加中间件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在工程下建立任意名字的文件夹，然后在文件夹中建立任意名字的python文件，如在工程同名目录下建立ruledong.py文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; django.utils.deprecation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MiddlewareMixin
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义中间件1&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dong1(MiddlewareMixin):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self,requestx):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong1111111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的设备基本信息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, requestx.environ.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP_USER_AGENT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的IP地址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, requestx.environ.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;REMOTE_ADDR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义中间件2&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dong2(MiddlewareMixin):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self,requestx):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong22222222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; requestx.GET.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;idx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回字符串,以此为终点，中断所有&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HttpResponse
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;东小东【请求失败】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在setting的MIDDLEWARE = [ ]的最后添加，添加规则为前面的先被执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dongjg.ruledong.Dong1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dongjg.ruledong.Dong2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 14 Apr 2019 15:09:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>页面跳转 页面跳转的url中必须在最后会自动添加【\】，所以在urls.py的路由表中需要对应添加【\】 本地跳转需要参考urls.py的路由表 Cookie 设置cookie 获取cookie 删除</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10496876.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第15期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10707413.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10707413.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;Hedgehog新站点&quot; &quot;Bolero 0.4发布，增加远程认证&quot; &quot;FsToolkit.ErrorHandling与Cvdm.ErrorHandling合并了&quot; &quot;F 里的3D图形编程与游戏开发&quot; &quot;有趣的3D——浏览器里F 3D绘制&quot; &quot;F CNTK：变分自动编码器例子——从2D隐空间</description>
<pubDate>Sun, 14 Apr 2019 15:06:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 'Hedgehog新站点' 'Bolero 0.4发布，增加远程认证' 'FsToolkit.ErrorHandling与Cvdm.ErrorHandling合并了' 'F 里的3D图形编程与游</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10707413.html</dc:identifier>
</item>
</channel>
</rss>