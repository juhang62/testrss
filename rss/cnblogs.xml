<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>DJL 之 Java 玩转多维数组，就像 NumPy 一样 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13603551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13603551.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文适合有 Java 基础的人群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202009/759200-20200902192041033-519825032.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;strong&gt;DJL-Lanking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列。有幸邀请到了亚马逊 + Apache 的工程师：Lanking（ &lt;a href=&quot;https://github.com/lanking520&quot;&gt;https://github.com/lanking520&lt;/a&gt; ），为我们讲解 DJL —— 完全由 Java 构建的深度学习平台，本文为系列的第二篇。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202009/759200-20200902192049791-985485922.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着数据科学在生产中的应用逐步增加，使用 N维数组 灵活的表达数据变得愈发重要。我们可以将过去数据科学运算中的多维循环嵌套运算简化为简单几行。由于进一步释放了计算并行能力，这几行简单的代码运算速度也会比传统多维循环快很多。&lt;/p&gt;
&lt;p&gt;这种数学计算的包已经成为数据科学、图形学以及机器学习领域的标准。同时它的影响力还在不断的扩大到其他领域。&lt;/p&gt;
&lt;p&gt;在 Python 的世界，调用 NDArray（N维数组）的标准包叫做 NumPy。但是如今在 Java 领域中，并没有与之同样标准的库。为了给 Java 开发者创造同一种使用环境，亚马逊云服务开源了 DJL 一个基于 Java 的深度学习库。&lt;/p&gt;
&lt;p&gt;尽管它包含了深度学习模块，但是它最核心的 NDArray 系统可以被用作 N维数组 的标准。它具备优良的可扩展性、全平台支持以及强大的后端引擎支持 (TensorFlow、PyTorch、Apache MXNet）。无论是 CPU 还是 GPU、PC 还是安卓，DJL 都可以轻而易举的完成任务。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6304347826087&quot;&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/awslabs/djl/&quot;&gt;https://github.com/awslabs/djl/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个文章中，我们将带你了解 NDArray，并且教你如何写与 Numpy 同样简单的 Java 代码以及如何将 NDArray 使用在现实中的应用之中。&lt;/p&gt;
&lt;h2 id=&quot;二、安装-djl&quot;&gt;二、安装 DJL&lt;/h2&gt;
&lt;p&gt;可以通过下方的配置来配置你的 gradle 项目。或者你也可以跳过设置直接使用我们在线 JShell 。&lt;/p&gt;
&lt;blockquote readability=&quot;1.8032786885246&quot;&gt;
&lt;p&gt;在线 JShell 链接: &lt;a href=&quot;https://djl.ai/website/demo.html#jshell&quot;&gt;https://djl.ai/website/demo.html#jshell&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;plugins {
    id 'java'
}
repositories {                           
    jcenter()
}
dependencies {
    implementation &quot;ai.djl:api:0.6.0&quot;
    // PyTorch
    runtimeOnly &quot;ai.djl.pytorch:pytorch-engine:0.6.0&quot;
    runtimeOnly &quot;ai.djl.pytorch:pytorch-native-auto:1.5.0&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们就可以开始上手写代码了。&lt;/p&gt;
&lt;h2 id=&quot;三、基本操作&quot;&gt;三、基本操作&lt;/h2&gt;
&lt;p&gt;我们首先尝试建立一个 try block 来包含我们的代码（如果使用在线 JShell 可跳过此步）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;try(NDManager manager = NDManager.newBaseManager()) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NDManager 是 DJL 中的一个 class 可以帮助管理 NDArray 的内存使用。通过创建 NDManager 我们可以更及时的对内存进行清理。当这个 block 里的任务运行完成时，内部产生的 NDArray 都会被清理掉。这个设计保证了我们在大规模使用 NDArray 的过程中，可以通过清理其中的 NDManager 来更高效的利用内存。&lt;/p&gt;
&lt;p&gt;为了做对比，我们可以参考 NumPy 在 Python 之中的应用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;31-创建-ndarray&quot;&gt;3.1 创建 NDArray&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ones&lt;/code&gt; 是一个创建全是1的N维数组操作.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python (Numpy)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;nd = np.ones((2, 3))
&quot;&quot;&quot;
[[1. 1. 1.]
 [1. 1. 1.]]
&quot;&quot;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java (DJL NDArray)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;NDArray nd = manager.ones(new Shape(2, 3));
/*
ND: (2, 3) cpu() float32
[[1., 1., 1.],
 [1., 1., 1.],
]
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以尝试生成随机数。比如我们需要生成一些从 0 到 1 的随机数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python (Numpy)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;nd = np.random.uniform(0, 1, (1, 1, 4))
# [[[0.7034806  0.85115891 0.63903668 0.39386125]]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java (DJL NDArray)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;NDArray nd = manager.randomUniform(0, 1, new Shape(1, 1, 4));
/*
ND: (1, 1, 4) cpu() float32
[[[0.932 , 0.7686, 0.2031, 0.7468],
 ],
]
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这只是简单演示一些常用功能。现在 NDManager 支持多达 20 种在 NumPy 中 NDArray 创建的方法。&lt;/p&gt;
&lt;h3 id=&quot;32-数学运算&quot;&gt;3.2 数学运算&lt;/h3&gt;
&lt;p&gt;你可以使用 NDArray 进行一系列的数学操作。假设你想做对数据做一个&lt;a href=&quot;https://baike.baidu.com/item/%E8%BD%AC%E7%BD%AE&quot;&gt;转置&lt;/a&gt;操作，然后对所有数据加一个数的操作。你可以参考如下的实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python (Numpy)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;nd = np.arange(1, 10).reshape(3, 3)
nd = nd.transpose()
nd = nd + 10
&quot;&quot;&quot;
[[11 14 17]
 [12 15 18]
 [13 16 19]]
&quot;&quot;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java (DJL NDArray)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;NDArray nd = manager.arange(1, 10).reshape(3, 3);
nd = nd.transpose();
nd = nd.add(10);
/*
ND: (3, 3) cpu() int32
[[11, 14, 17],
 [12, 15, 18],
 [13, 16, 19],
]
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DJL 现在支持 60 多种不同的 NumPy 数学运算，基本涵盖了大部分的应用场景。&lt;/p&gt;
&lt;h3 id=&quot;33-get-和-set&quot;&gt;3.3 Get 和 Set&lt;/h3&gt;
&lt;p&gt;其中一个对于 NDArray 最重要的亮点就是它轻松简单的数据设置/获取功能。我们参考了 NumPy 的设计，将 Java 过去对于数据表达中的困难做了精简化处理。&lt;/p&gt;
&lt;p&gt;假设我们想筛选一个N维数组所有小于10的数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python (Numpy)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;nd = np.arange(5, 14)
nd = nd[nd &amp;gt;= 10]
# [10 11 12 13]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java (DJL NDArray)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;NDArray nd = manager.arange(5, 14);
nd = nd.get(nd.gte(10));
/*
ND: (4) cpu() int32
[10, 11, 12, 13]
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是非常简单？接下来，我们看一下一个稍微复杂一些的应用场景。假设我们现在有一个3x3的矩阵，然后我们想把第二列的数据都乘以2:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python (Numpy)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;nd = np.arange(1, 10).reshape(3, 3)
nd[:, 1] *= 2
&quot;&quot;&quot;
[[ 1  4  3]
 [ 4 10  6]
 [ 7 16  9]]
&quot;&quot;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java (DJL NDArray)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NDArray nd = manager.arange(1, 10).reshape(3, 3);
nd.set(new NDIndex(&quot;:, 1&quot;), array -&amp;gt; array.mul(2));
/*
ND: (3, 3) cpu() int32
[[ 1,  4,  3],
 [ 4, 10,  6],
 [ 7, 16,  9],
]
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的案例中，我们在 Java 引入了一个 NDIndex 的 class。它复刻了大部分在 NumPy 中对于 NDArray 支持的 get/set 操作。只需要简单的放进去一个字符串表达式，开发者在 Java 中可以轻松玩转各种数组的操作。&lt;/p&gt;
&lt;h2 id=&quot;四、现实中的应用场景&quot;&gt;四、现实中的应用场景&lt;/h2&gt;
&lt;p&gt;上述的操作对于庞大的数据集是十分有帮助的。现在我们来看一下这个应用场景：基于单词的分类系统训练。在这个场景中，开发者想要利用从用户中获取的数据来进行情感分析预测。&lt;/p&gt;
&lt;p&gt;NDArray 被应用在了对于数据进行前后处理的工作中。&lt;/p&gt;
&lt;h3 id=&quot;41-分词操作&quot;&gt;4.1 分词操作&lt;/h3&gt;
&lt;p&gt;在输入到 NDArray 数据前，我们需要对于输入的字符串进行分词操作并编码成数字。下面代码中看到的 tokenizer 是一个 &lt;code&gt;Map&amp;lt;String, Integer&amp;gt;&lt;/code&gt;，它是一个单词到字典位置的映射。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String text = &quot;The rabbit cross the street and kick the fox&quot;;
String[] tokens = text.toLowerCase().split(&quot; &quot;);
int[] vector = new int[tokens.length];
/*
String[9] { &quot;the&quot;, &quot;rabbit&quot;, &quot;cross&quot;, &quot;the&quot;, &quot;street&quot;,
&quot;and&quot;, &quot;kick&quot;, &quot;the&quot;, &quot;fox&quot; }
*/
for (int i = 0; i &amp;lt; tokens.length; i++) {
    vector[i] = tokenizer.get(tokens[i]);
}
vector
/*
int[9] { 1, 6, 5, 1, 3, 2, 8, 1, 12 }
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-ndarray-处理&quot;&gt;4.2 NDArray 处理&lt;/h3&gt;
&lt;p&gt;经过了编码操作后，我们创建了 NDArray 之后，我们需要转化数据的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;NDArray array = manager.create(vector);
array = array.reshape(new Shape(vector.length, 1)); // form a batch
array = array.div(10.0);
/*
ND: (9, 1) cpu() float64
[[0.1],
 [0.6],
 [0.5],
 [0.1],
 [0.3],
 [0.2],
 [0.8],
 [0.1],
 [1.2],
]
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，我们将数据传入深度学习模型中。如果使用 Java 要达到这些需要更多的工作量：如果我们需要实现类似于 reshape 的方法，我们需要创建一个N维数组：&lt;code&gt;List&amp;lt;List&amp;lt;List&amp;lt;...List&amp;lt;Float&amp;gt;...&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 来保证不同维度的可操作性。同时我们需要能够支持插入新的 &lt;code&gt;List&amp;lt;Float&amp;gt;&lt;/code&gt; 来创建最终的数据格式。&lt;/p&gt;
&lt;h2 id=&quot;五、ndarray-的实现过程&quot;&gt;五、NDArray 的实现过程&lt;/h2&gt;
&lt;p&gt;你也许会好奇 NDArray 究竟是如何在 DJL 之中构建的呢？接下来，我们会讲解一下 NDArray 在 DJL 内部中的架构。架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202009/759200-20200902192109533-376436098.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示 NDArray 有三个关键的层。&lt;/p&gt;
&lt;p&gt;界面层 (Interface) 包含了你所用到的 NDArray ，它只是一个 Java 的界面并定义了 NDArray 的输入输出结构。我们很仔细的分析了每一个方式的使用方法以便尽可能的将它们和用户的应用场景统一以及便于使用。&lt;/p&gt;
&lt;p&gt;在引擎提供者层 (EngineProvider)，是 DJL 各种深度学习引擎为 NDArray 界面开发的包。这个层把原生的深度学习引擎算子表达映射在 NumPy 之上。这样经过这样一层转译，我们在不同引擎上看到 NDArray 的表现都是一致的而且同时兼顾了 NumPy 的表现。&lt;/p&gt;
&lt;p&gt;在 C++ 层，为了更便于 Java 使用，我们构建了 JNI 和 JNA 暴露出 C/C++ 的等方法，它可以保证我们有足够的方法来构建 NDArray 所需要的功能。同时 C++ 与 Java 的直接调用也可以保证 NDArray 拥有最好的性能。&lt;/p&gt;
&lt;h2 id=&quot;六、为什么应该使用-ndarray-呢&quot;&gt;六、为什么应该使用 NDArray 呢?&lt;/h2&gt;
&lt;p&gt;经过了这个教程，你应该获得了基本的 NDArray 在 Java 中的使用体验。但是这仍然只是表象，它的很多内在价值只有在生产环境中才能体现出来。总结一下 NDArray 具有如下几个优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;易如反掌：轻松使用超过 60+ 个在 Java 中的方式实现与 NumPy 相同的结果。&lt;/li&gt;
&lt;li&gt;快如闪电：具备各路深度学习框架加持，DJL NDArray 具备了各种硬件平台的加速，比如在 CPU 上的 MKLDNN 加速以及 GPU 上的 CUDA 加速，无论多大的数据集都可以轻松应对。&lt;/li&gt;
&lt;li&gt;深度学习：同时具备高维数组、离散数组支持。你可以轻松的将 DJL 与其他大数据或者流数据平台结合起来应用：比如分布式处理的 Apache Spark 平台以及 Apache Flink 流数据平台。为你现有的方案构建一层深度学习的中间件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;NDArray 的到来帮助 DJL 成功转变为 Java 在深度学习领域中最好的工具。它具备平台自检测机制，无需任何额外设置，便可以在应用中构建基于 CPU/GPU 的代码。感兴趣的小伙伴快跟着教程感受下吧！&lt;/p&gt;
&lt;blockquote readability=&quot;1.9636363636364&quot;&gt;
&lt;p&gt;更多详情尽在 NDArray 文档：&lt;a href=&quot;https://javadoc.io/doc/ai.djl/api/latest/ai/djl/ndarray/NDArray.html%E2%80%8B%E2%80%8B&quot;&gt;https://javadoc.io/doc/ai.djl/api/latest/ai/djl/ndarray/NDArray.html​​&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于-djl&quot;&gt;关于 DJL&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202009/759200-20200902192120469-1416094295.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Deep Java Library (DJL) 是一个基于 Java 的深度学习框架，同时支持训练以及推理。 DJL 博取众长，构建在多个深度学习框架之上 (TenserFlow、PyTorch、MXNet 等) 也同时具备多个框架的优良特性。你可以轻松使用 DJL 来进行训练然后部署你的模型。&lt;/p&gt;
&lt;p&gt;它同时拥有着强大的模型库支持：只需一行便可以轻松读取各种预训练的模型。现在 DJL 的模型库同时支持高达 70 个来自 GluonCV、 HuggingFace、TorchHub 以及 Keras 的模型。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6304347826087&quot;&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/awslabs/djl/&quot;&gt;https://github.com/awslabs/djl/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在最新的版本中 DJL 0.6.0 添加了对于 MXNet 1.7.0、PyTorch 1.5.0、TensorFlow 2.2.0 的支持。我们同时也添加了 ONNXRuntime 以及 PyTorch 在安卓平台的支持。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200825184537931-2074943966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注 HelloGitHub 公众号&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 03 Sep 2020 00:47:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文适合有 Java 基础的人群 作者：DJL-Lanking HelloGitHub 推出的《讲解开源项目》系列。有幸邀请到了亚马逊 + Apache 的工程师：Lanking（ https://g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13603551.html</dc:identifier>
</item>
<item>
<title>JS深浅拷贝及其实现 - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/13605612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/13605612.html</guid>
<description>&lt;h2 id=&quot;ruuNH&quot; data-lake-id=&quot;d443fd7d836b5d5b01f7cff535ed7573&quot;&gt; &lt;/h2&gt;
&lt;div id=&quot;PW8Vt&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;mindmap&quot; data-card-value=&quot;data:%7B%22diagramData%22%3A%22x%C2%9C%7DT%C3%8Bj%5Cu001cG%5Cu0014%C3%BD%C2%97%C3%8EF%C2%86)Q%C3%AF%C2%87v%5Cu000eh%C2%91%2C%C3%A2%C2%85%C2%97A%C2%8B%5B%2Fi%5Cu001ciF%C3%8C%5Cf!%C2%B2%5Cu0018%5Cu0010!%C2%81%5CbE!%C2%88L%C2%B2%C3%B1cc%C2%8C%5Cu001d%C2%84%5Cu0012%5Cu0011%5Cu000b%C3%A1%C3%88%C2%89%C3%BF%C3%85%C3%90%3D%C3%8A_%C3%B8%C3%8EH%23w'i%C3%91%C2%AB%C3%9BT%C2%9Ds%C3%AA%C2%9CS%C2%B5%5Bl%24%C2%88%C3%85%C3%8An%C3%B1e%5Cu001a%5Cf%C2%BB%C3%BD%5E%C2%B1R%C3%B0e%C2%BAL%C2%8BN1%C3%9A%C3%99N8nu%7Bq%5Cu000b%C2%B6%C2%8Bq%C2%A7%C3%B0%C3%BD%C2%B8S%C2%AC%7C%C2%BE%5BtqK!%C3%81H%5Cu0017%C2%B4%C3%87%C2%A5%5Cu001b%C2%A3%C2%ADM%C3%BCS%C2%9D%C2%9FVg%C3%9FV%5Cu0007%C3%A7%C2%97%C2%AF%5Cu001e%C2%BF%C3%9B%3B%C3%B8%2FF%C2%A7%5Cb%5Cu001b%C3%9D%C3%8D8H%C2%BD%5Cu000f0VP%C3%AB%C2%99w5%C2%98%C3%89%C3%AF%C3%95%C3%A1%C3%89%C3%B4%C3%B4%C2%A2%7Crp%5Cr3Hi5%C2%AE%C2%A7%C2%99%C3%90%C3%A1h%C3%90%C3%BFb%5Cu0006%C3%BA%C3%91%5Dn%C3%8D*%C2%9B%5Ctk%C2%A0%5E%C2%A3%C3%A0%C3%8E%C3%B2%C3%A9%C2%9F%C3%95%C2%A3%C3%A3%3A%5Cu001cb%C3%8DI%C2%A3SA%5Cu0019%C3%A0%24%C2%A7%5CfDF%C3%83%C2%88u%C3%8A%5Cu0010%5Cu00138%5Cu000f%C3%9E%C3%B3l%C2%B3h%C2%AA%5D%C3%AB%5Cu0014%5Cu000f%3F%C3%A9%C3%85%C3%B4U%C2%B1%5C%22%C3%86%C2%9D%5Cu0006%C3%8B%C2%9B%C3%89%C3%B4%C2%A7%5Cu0017%C3%BF%C3%87%C2%A24%C2%97V)F%5C%5C%C3%A0%C2%8EH%C2%9A%3Dq%C3%91E%C2%A2%5Cu0012%C3%95Y%C2%B2%C3%A0%C2%A4%C2%91%C2%AD%2Cr%5C%5C%5Cu001b%C3%B8%C2%8Cr%C2%8EI%C2%B5t%3C%C2%8BP%C2%B3kay%C2%ABQ%C2%AB%C3%92%C3%A2%C3%97fT%C3%B9%C3%B7%C2%AF%C3%93%5Cu001f~%C2%BB%3C%3B(%C3%B7%C3%9E%5C%5C%C3%99%3D'%C3%B2%C2%81%C2%814%3A%C2%93%C3%80%C2%A3!2%5Cu001bO%C3%80zK%C2%B2c%C2%96e%C2%AE%C2%93c%C2%A1U%C2%BCjZT%C3%AD%C2%BF%2CO'%C2%97o%7F%C2%9C%C2%9E%C3%BC2%3D~%C2%BE%C2%A00%C3%86%2B%C2%99%C2%84'%5Cu001e4C%7F%C3%90%24%5Cu000f%3C%C2%91%60%C2%8DI%5Cu0006%C2%93%C3%88%C2%91%C2%B6R%C3%A8%26%C3%85%3D%C3%BF%20%C2%85%C3%912%5Cf%C2%87%C3%9D%C3%B5%C3%9E%C3%92%C2%9D%5Cu0005Ef*z%5Cu0003%C2%9Ax%5Cu00150h%C3%86%5Cu0014qN%5B%C2%A2%C2%B2%C3%B2%C3%96di%40%C2%A9V%5CnS%C2%A3%C3%80%7C%C2%A7%5Cu0017%C3%9FT%3F%C2%BF%C2%AE%C3%BE%C2%98%C3%94%5C%5C%C3%A2%5Cu0001%C2%A8%5Cu0005%C3%AC%C2%90%C3%8F%5Cu0001%23v%5Cu0011%C2%99RJD%C3%91%5Cb%5C%5C%5Cu0006%5Cu000e2%C3%90%7F%C3%97%C3%BE%5Cu001a1%5Cu000f%C3%BA%5B5%C2%A4%C2%AC%5Cu001d0%C2%A3)%5Ct%C2%89q4%5Cu0003%C3%90%5Cu0016%5Cu0014H%C2%B8WY%C2%8A%5Cu0010%C2%A5%C2%89%C2%A6U%C2%A9k%C2%9A1%C3%9C%C3%AC%C2%86%C2%B4%5Cu0000%C2%A6%C2%908%5Cu0000%5Cu0003b5%C3%B5D%5Cn%C2%95%C2%89g%C2%8A%5Cu0012CQ%5Cu001cs%C3%A0%25e%C2%AD%C3%80%C2%8C6%C2%91C%C2%BF%5Cu0017%60%C2%B4%C2%80v%C2%9E%C2%A1%C3%A6%C2%88J%C2%A5VD%5Cu0006%C2%90%5Cu0004P*%C2%91V%5Cu0000%3A%C2%9B%C2%84%C3%B4%C2%BA%5Cu001d%C2%9A%C3%95%5Cu001bn%C3%AB%5Cu0003%C2%BB%C2%A9%7B%5Cu000e2(4%C2%B2%C3%B9%C3%88%C3%9C%5Ew%C3%AD%3Ef%C2%AB%C2%ADu%C3%BF%C3%B4%C3%BE%C2%BD%C3%8F%C2%96%C2%B7a0L%C3%A5%C3%91%C3%B7%C3%B3af%C3%98h%C3%90%C3%AD%C2%ADw%C3%B3%C3%8E%C3%8D%C3%95%C3%B5%C2%8CK%5Cu0001%C2%89%24%C2%AB%C3%B0%3C%C3%8Eq4Mj%5C%22dr%26X%C3%87%C2%9C%C2%8F%C3%AD'%C3%A3M%C3%93%C3%BE%C3%99%3B*%C3%BF%3A%C2%BAR%C2%BD4%3D%C3%99%2B%5Cu000f'%C3%93%C3%BD%C3%AFn%3A%5Cu001a%C2%83qBdl%C2%8EM%C2%98%7C0%5Cu0018P%C2%8C%C2%91%C3%84%5CfL%5Cu000b%5Cn%C2%86%C3%9E%5Cu0016%C2%90%C2%B8%C2%85%C2%AB%7CvX%3D%C3%BE%C2%BA%C3%8E%25l%C3%B4%5Cu0018%5Cu001a%5Cu001e%C2%84%C3%8B%C2%8C%C2%B7%C3%9A%5Ct%C2%82Y%C3%A1%3B%5Cb%5E%C2%83%C3%82%C2%AA%C2%A8yqZ%C2%B8%5Cu001ao%5Cu0012m%24%C2%A6%C3%86k%C3%A3%C3%B7%C2%9F%C3%94)%C3%96%22%2C%22margin%22%3Atrue%2C%22id%22%3A%22PW8Vt%22%2C%22viewportSetting%22%3A%7B%22zoom%22%3A1%2C%22scrollLeft%22%3A350%2C%22scrollTop%22%3A203%2C%22viewBox%22%3A%5B-566%2C-378%2C1540%2C792%5D%7D%2C%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1599093349248-24c508a9-9653-4377-818d-1ed8fd42ef67.png%22%2C%22search%22%3A%22%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E2%80%8B%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%8B%20%E2%80%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%8B%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E6%B5%85%E6%8B%B7%E8%B4%9D%20%E5%BE%AA%E7%8E%AF%E8%B5%8B%E5%80%BC%E2%80%8B%20%E2%80%8B%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%20%E2%80%8BObject.assign()%20%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E2%80%8B%20from%E2%80%8B%20%E2%80%8Bslice%20%E2%80%8Bconcat%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%20JSON.parse%E5%92%8CJSON.%E2%80%8Bstringify%20%E2%80%8B%E9%80%92%E5%BD%92%E6%8B%B7%E8%B4%9D(%E7%AE%80%E5%8D%95%E7%89%88)%20%E2%80%8B%E9%80%92%E5%BD%92%E6%8B%B7%E8%B4%9D(%E5%A4%8D%E6%9D%82%E7%89%88)%22%2C%22height%22%3A378%7D&quot; readability=&quot;7&quot;&gt;　　　　　　　　　　　　　　&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1599093349248-24c508a9-9653-4377-818d-1ed8fd42ef67.png&quot; width=&quot;360&quot; height=&quot;343&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;BKyXr&quot; data-lake-id=&quot;40c8571debcb461bd498ce49a39c2b43&quot;&gt;基本数据类型和引用数据类型&lt;/h2&gt;
&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;JS数据分为基本数据类型和引用数据类型。基本数据类型的变量存储在栈中，引用数据类型则存储在堆中，引用数据类型的存储地址则保存在栈中。&lt;/p&gt;
&lt;p data-lake-id=&quot;66482d561d466f4b2406e41c4473be42&quot;&gt;&lt;span class=&quot;lake-card-margin-top lake-card-margin-bottom lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1598661091208-f3380231-1467-4e6e-9c38-af89067e1dd2.png%22%2C%22originWidth%22%3A1594%2C%22originHeight%22%3A994%2C%22name%22%3A%22image.png%22%2C%22size%22%3A87011%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A297.10477%2C%22y%22%3A131.35915%2C%22width%22%3A58.22439000000003%2C%22height%22%3A54.60755%2C%22text%22%3A%22%E6%A0%88%22%7D%2C%7B%22x%22%3A738.8644%2C%22y%22%3A358.95197%2C%22width%22%3A192.22579999999994%2C%22height%22%3A34.36678999999998%2C%22text%22%3A%22%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%22%7D%2C%7B%22x%22%3A247.82802%2C%22y%22%3A538.158%2C%22width%22%3A169.61333%2C%22height%22%3A27.845659999999953%2C%22text%22%3A%22%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%22%7D%2C%7B%22x%22%3A280.71375%2C%22y%22%3A571.32367%2C%22width%22%3A100.95619999999997%2C%22height%22%3A27.169070000000033%2C%22text%22%3A%22%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80%22%7D%2C%7B%22x%22%3A232.30907%2C%22y%22%3A683.83203%2C%22width%22%3A193.9781%2C%22height%22%3A33.356019999999944%2C%22text%22%3A%22%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E6%A0%88%20%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%20%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A797%2C%22height%22%3A497%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1598661091208-f3380231-1467-4e6e-9c38-af89067e1dd2.png?x-oss-process=image%2Fresize%2Cw_1500&quot; alt=&quot;image.png&quot; width=&quot;432&quot; height=&quot;269&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;497px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;ddac515b190d166b26b4ad11131760ad&quot;&gt;下面来看一个小例子🌰&lt;/p&gt;
&lt;div id=&quot;ZLfKh&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20%20%20%20%2F%2F%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%5Cn%20%20%20%20let%20intType%20%3D%201%3B%5Cn%20%20%20%20console.log('%E5%88%9D%E5%A7%8BintType%3A'%20%2B%20intType)%3B%5Cn%20%20%20%20let%20copyIntType%20%3D%20intType%3B%5Cn%20%20%20%20copyIntType%20%3D%202%3B%5Cn%20%20%20%20console.log('%E6%9B%B4%E6%94%B9%E5%90%8EintType%3A'%20%2B%20intType)%3B%5Cn%20%20%20%20console.log('%E6%9B%B4%E6%94%B9%E5%90%8EcopyIntType%3A'%20%2B%20intType)%3B%5Cn%20%20%20%20let%20object%20%3D%20%7B%5Cn%20%20%20%20%20%20%20%20a%3A%201%5Cn%20%20%20%20%7D%3B%5Cn%20%20%20%20%2F%2F%20%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%5Cn%20%20%20%20let%20copyObject%20%3D%20object%5Cn%20%20%20%20console.log('%E5%88%9D%E5%A7%8Bobject%3A')%3B%5Cn%20%20%20%20console.log(object)%3B%5Cn%20%20%20%20copyObject.a%20%3D%202%3B%5Cn%20%20%20%20console.log('%E6%9B%B4%E6%94%B9%E5%90%8E%E7%9A%84object%3A')%3B%5Cn%20%20%20%20console.log(object)%3B%5Cn%20%20%20%20console.log('%E6%9B%B4%E6%94%B9%E5%90%8E%E7%9A%84copyObject%3A')%3B%5Cn%20%20%20%20console.log(copyObject)%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22ZLfKh%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基本数据类型&lt;/span&gt;
    let intType = 1&lt;span&gt;;
    console.log(&lt;/span&gt;'初始intType:' +&lt;span&gt; intType);
    let copyIntType &lt;/span&gt;=&lt;span&gt; intType;
    copyIntType &lt;/span&gt;= 2&lt;span&gt;;
    console.log(&lt;/span&gt;'更改后intType:' +&lt;span&gt; intType);
    console.log(&lt;/span&gt;'更改后copyIntType:' +&lt;span&gt; intType);
    let object &lt;/span&gt;=&lt;span&gt; {
        a: &lt;/span&gt;1&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引用数据类型&lt;/span&gt;
    let copyObject =&lt;span&gt; object
    console.log(&lt;/span&gt;'初始object:'&lt;span&gt;);
    console.log(object);
    copyObject.a &lt;/span&gt;= 2&lt;span&gt;;
    console.log(&lt;/span&gt;'更改后的object:'&lt;span&gt;);
    console.log(object);
    console.log(&lt;/span&gt;'更改后的copyObject:'&lt;span&gt;);
    console.log(copyObject);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;764da962a2454e957f8b1f84b68cedc8&quot;&gt;结果：&lt;/p&gt;
&lt;p data-lake-id=&quot;71b420da3cda8fe0fcdd059a3615ef87&quot;&gt;&lt;span class=&quot;lake-card-margin-top lake-card-margin-bottom lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1598663240872-1d578aa2-e493-44cd-82bd-e70c03058070.png%22%2C%22originWidth%22%3A868%2C%22originHeight%22%3A398%2C%22name%22%3A%22image.png%22%2C%22size%22%3A35598%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A35.54295%2C%22y%22%3A16.454672%2C%22width%22%3A180.83602000000002%2C%22height%22%3A26.137808000000003%2C%22text%22%3A%22%E5%88%9D%E5%A7%8BintType%3A1%22%7D%2C%7B%22x%22%3A36.68349%2C%22y%22%3A56.393726%2C%22width%22%3A204.10658999999998%2C%22height%22%3A26.741373999999993%2C%22text%22%3A%22%E6%9B%B4%E6%94%B9%E5%90%8EintType%3A1%22%7D%2C%7B%22x%22%3A36.47353%2C%22y%22%3A96.61291%2C%22width%22%3A263.02195%2C%22height%22%3A28.292485999999997%2C%22text%22%3A%22%E6%9B%B4%E6%94%B9%E5%90%8EcopyIntType%3A1%22%7D%2C%7B%22x%22%3A34.85844%2C%22y%22%3A132.31825%2C%22width%22%3A152.15%2C%22height%22%3A31.695220000000006%2C%22text%22%3A%22%E5%88%9D%E5%A7%8Bobject%3A%22%7D%2C%7B%22x%22%3A50.888187%2C%22y%22%3A178.35594%2C%22width%22%3A94.73930299999999%2C%22height%22%3A26.59259%2C%22text%22%3A%22fa%3A13%22%7D%2C%7B%22x%22%3A36.87134%2C%22y%22%3A219.11566%2C%22width%22%3A197.01794%2C%22height%22%3A31.376650000000012%2C%22text%22%3A%22%E6%9B%B4%E6%94%B9%E5%90%8E%E7%9A%84object%3A%22%7D%2C%7B%22x%22%3A61.664635%2C%22y%22%3A263.26166%2C%22width%22%3A84.32720499999999%2C%22height%22%3A26.71472%2C%22text%22%3A%22fa%3A2%22%7D%2C%7B%22x%22%3A37.169346%2C%22y%22%3A304.00256%2C%22width%22%3A253.948954%2C%22height%22%3A28.01218%2C%22text%22%3A%22%E6%9B%B4%E6%94%B9%E5%90%8E%E7%9A%84copyobject%3A%22%7D%2C%7B%22x%22%3A58.890327%2C%22y%22%3A348.0846%2C%22width%22%3A86.794773%2C%22height%22%3A25.695979999999963%2C%22text%22%3A%22fa%3A2%5D%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E5%88%9D%E5%A7%8BintType%3A1%20%E6%9B%B4%E6%94%B9%E5%90%8EintType%3A1%20%E6%9B%B4%E6%94%B9%E5%90%8EcopyIntType%3A1%20%E5%88%9D%E5%A7%8Bobject%3A%20fa%3A13%20%E6%9B%B4%E6%94%B9%E5%90%8E%E7%9A%84object%3A%20fa%3A2%20%E6%9B%B4%E6%94%B9%E5%90%8E%E7%9A%84copyobject%3A%20fa%3A2%5D%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A434%2C%22height%22%3A199%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1598663240872-1d578aa2-e493-44cd-82bd-e70c03058070.png&quot; alt=&quot;image.png&quot; width=&quot;364&quot; height=&quot;167&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;199px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;e63dde166f406f773afeb4826749eb8d&quot;&gt;基本数据类型在复制的时候会创建一个值的副本，并将该副本赋值给新变量。引用类型在复制的时候其实复制的是指针。&lt;/p&gt;
&lt;p data-lake-id=&quot;bfd916cab7038235f1a3979337fed5b3&quot;&gt;&lt;span class=&quot;lake-card-margin-top lake-card-margin-bottom lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1598667183616-f078984f-05ed-4a6f-b528-3db06ba5be56.png%22%2C%22originWidth%22%3A1470%2C%22originHeight%22%3A706%2C%22name%22%3A%22image.png%22%2C%22size%22%3A58409%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A250.97273%2C%22y%22%3A180.08992%2C%22width%22%3A116.76551999999998%2C%22height%22%3A33.89372%2C%22text%22%3A%22intType%22%7D%2C%7B%22x%22%3A761.72784%2C%22y%22%3A180.21352%2C%22width%22%3A99.66206%2C%22height%22%3A30.381950000000018%2C%22text%22%3A%22object%22%7D%2C%7B%22x%22%3A275.76205%2C%22y%22%3A309.84024%2C%22width%22%3A71.95075000000003%2C%22height%22%3A38.29316%2C%22text%22%3A%22%E5%A4%8D%E5%88%B6%22%7D%2C%7B%22x%22%3A1191.3011%2C%22y%22%3A313.83987%2C%22width%22%3A79.66260000000011%2C%22height%22%3A35.73947999999996%2C%22text%22%3A%22f%3A1%22%7D%2C%7B%22x%22%3A216.57661%2C%22y%22%3A448.11203%2C%22width%22%3A186.10344%2C%22height%22%3A34.73027000000002%2C%22text%22%3A%22copylntType%22%7D%2C%7B%22x%22%3A721.33606%2C%22y%22%3A449.70624%2C%22width%22%3A180.16937000000007%2C%22height%22%3A31.320060000000012%2C%22text%22%3A%22copyobject%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22intType%20object%20%E5%A4%8D%E5%88%B6%20f%3A1%20copylntType%20copyobject%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A735%2C%22height%22%3A353%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1598667183616-f078984f-05ed-4a6f-b528-3db06ba5be56.png&quot; alt=&quot;image.png&quot; width=&quot;481&quot; height=&quot;231&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;353px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;J6DXB&quot; data-lake-id=&quot;190b848a95aee49d664437527c15c966&quot;&gt;深浅拷贝&lt;/h2&gt;
&lt;ul data-lake-id=&quot;6d5a20b6b2d7978821a53edada3757d4&quot;&gt;&lt;li data-lake-id=&quot;57facde6676e2c000ac4f8f9ba71c5af&quot;&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;：仅仅是复制了引用，彼此之间的操作会互相影响&lt;/li&gt;
&lt;li data-lake-id=&quot;f9f266f92f83a49218c22f5a0f5032f5&quot;&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;：在堆中重新分配内存，不同的地址，相同的值，互不影响&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;zlxbK&quot; data-lake-id=&quot;22c8026d809610e712cb1dcfe4a0eff8&quot;&gt;浅拷贝&lt;/h3&gt;
&lt;p data-lake-id=&quot;9180f112c19a004b64673d6cebefc8b6&quot;&gt;创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。实现方式如下&lt;/p&gt;
&lt;p data-lake-id=&quot;a7315f6b72106a6b0def7157767ec49c&quot;&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-lake-id=&quot;815b31e53ddfb120e2f6ca13e0032ffe&quot;&gt;&lt;li data-lake-id=&quot;6d4586f4e772d1cfeab19f4b4af4925d&quot;&gt;遍历赋值实现&lt;/li&gt;
&lt;li data-lake-id=&quot;7fc930d233a5a8e683ec54fda9480926&quot;&gt;ES6扩展运算符&lt;/li&gt;
&lt;li data-lake-id=&quot;7fe90145297ae7b694efa7aabb18394a&quot;&gt;ES6方法Object.assign()&lt;/li&gt;
&lt;li data-lake-id=&quot;4b14038a96c4b45c31719f29152b5020&quot;&gt;数组方法（只适用于类数组对象）&lt;/li&gt;
&lt;/ul&gt;&lt;p data-lake-id=&quot;e3538febec2f020f5be71c082d0308f2&quot;&gt;　　　　Array.from(arrayLike)&lt;/p&gt;
&lt;p data-lake-id=&quot;fbb1ce3380b905538ce55b1ab9398626&quot;&gt;　　　　Array.prototype.concat()&lt;/p&gt;
&lt;p data-lake-id=&quot;0b5a3373495acbca4bcd8f9c338bb723&quot;&gt;　　　　Array.prototype.slice()&lt;/p&gt;
&lt;h4 id=&quot;6BMQn&quot; data-lake-id=&quot;cd9392ef81f86016ffefe949e2611e39&quot;&gt;遍历赋值实现&lt;/h4&gt;
&lt;div id=&quot;FkqOu&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20obj%20%3D%20%7B%20a%3A1%2C%20arr%3A%20%5B2%2C3%5D%20%7D%3B%5Cn%2F%2F%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%5Cnfor%20(var%20prop%20in%20obj)%7B%5Cn%20%20%20%20if(obj.hasOwnProperty(prop))%7B%5Cn%20%20%20%20%20%20%20%20shallowObj%5Bprop%5D%20%3D%20obj%5Bprop%5D%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22FkqOu%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj = { a:1, arr: [2,3&lt;span&gt;] };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;浅拷贝实现&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; prop &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(obj.hasOwnProperty(prop)){
        shallowObj[prop] &lt;/span&gt;=&lt;span&gt; obj[prop];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;8i3UR&quot; data-lake-id=&quot;e7554fecdef330fcdd167c3dc8971421&quot;&gt;ES6扩展运算符&lt;/h4&gt;
&lt;div id=&quot;l0cal&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20obj%20%3D%20%7B%20a%3A1%2C%20arr%3A%20%5B2%2C3%5D%20%7D%3B%5Cnvar%20obj1%20%3D%20%7B...obj%7D%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22l0cal%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj = { a:1, arr: [2,3&lt;span&gt;] };
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj1 = {...obj}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;59gwD&quot; data-lake-id=&quot;7890347d41f3b5660c6731babbe96972&quot;&gt;ES6方法Object.assign()&lt;/h4&gt;
&lt;div id=&quot;IFJmK&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20obj%20%3D%20%7B%20a%3A1%2C%20arr%3A%20%5B2%2C3%5D%20%7D%3B%5Cnvar%20obj1%20%3D%20Object.assign(%7B%7D%2C%20obj)%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22IFJmK%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj = { a:1, arr: [2,3&lt;span&gt;] };
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj1 = Object.assign({}, obj);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;6GNZs&quot; data-lake-id=&quot;77b40930b7453f68836ddfd1972253f7&quot;&gt;数组方法（仅&lt;strong&gt;适用于类数组对象）&lt;/strong&gt;&lt;/h4&gt;
&lt;p data-lake-id=&quot;c6ed7a665c0192da629fb2a6521b76a2&quot;&gt;&lt;strong&gt;Array.from(arrayLike)&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;9t7Zx&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20array1%20%3D%20%5B'a'%2C%20%5B'b'%2C%20'c'%5D%2C%20'd'%5D%3B%5Cnvar%20array2%20%3D%20Array.from(array1)%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%229t7Zx%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array1 = ['a', ['b', 'c'], 'd'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array2 = Array.from(array1);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;f6d3a2c8ee5bbe0d7787773dd03a9e58&quot;&gt;&lt;strong&gt;Array.prototype.concat()&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;GjiZJ&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20array1%20%3D%20%5B'a'%2C%20%5B'b'%2C%20'c'%5D%2C%20'd'%5D%3B%5Cnvar%20array2%20%3D%20array1.concat(%5B1%2C2%5D)%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22GjiZJ%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array1 = ['a', ['b', 'c'], 'd'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array2 = array1.concat([1,2]);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;8d7f409a7832ac0043d45b5ab7dfb18e&quot;&gt;&lt;strong&gt;Array.prototype.slice()&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;Lx4cL&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20array1%20%3D%20%5B'a'%2C%20%5B'b'%2C%20'c'%5D%2C%20'd'%5D%3B%5Cnvar%20array2%20%3D%20array1.slice(0%2C2)%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22Lx4cL%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array1 = ['a', ['b', 'c'], 'd'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array2 = array1.slice(0,2);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p data-lake-id=&quot;9e833a204f50bc645b156115162fd8a1&quot;&gt;引用赋值：地址的赋值，将对象指针赋值给一个变量，让此变量指向对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;YG08U&quot; data-lake-id=&quot;bb766cbb93265bc69cfa7b199e09f44e&quot;&gt;深拷贝&lt;/h3&gt;
&lt;p data-lake-id=&quot;f6180604fe495fd3bcde5baee0167454&quot;&gt;将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象&lt;/p&gt;
&lt;p data-lake-id=&quot;fa4c77afdbe4e58d2670c4658504f7b9&quot;&gt;实现方式如下：&lt;/p&gt;
&lt;ul data-lake-id=&quot;70312a5740b8d5963c08e4444a234b96&quot;&gt;&lt;li data-lake-id=&quot;16e3dfc1d8f1c6ce5cc6081db4e847ae&quot;&gt;JSON.parse()和JSON.stringify()&lt;/li&gt;
&lt;li data-lake-id=&quot;1b339bd87ad0a46f2cef645cc251160c&quot;&gt;递归&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;0yXv8&quot; data-lake-id=&quot;3d7cab5e60698293c7e481d94b7ba37a&quot;&gt;JSON.parse()和JSON.stringify()&lt;/h4&gt;
&lt;div id=&quot;UFEkA&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20%20%20%20let%20parseObject%20%3D%20%7B%5Cn%20%20%20%20%20%20%20%20a%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20b%3A%201%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20let%20cloneParseObject%20%3D%20JSON.parse(JSON.stringify(parseObject))%3B%5Cn%20%20%20%20parseObject.a.b%20%3D%202%3B%5Cn%20%20%20%20console.log('cloneParseObject')%3B%5Cn%20%20%20%20console.log(cloneParseObject)%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22UFEkA%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    let parseObject =&lt;span&gt; {
        a: {
            b: &lt;/span&gt;1&lt;span&gt;
        }
    }
    let cloneParseObject &lt;/span&gt;=&lt;span&gt; JSON.parse(JSON.stringify(parseObject));
    parseObject.a.b &lt;/span&gt;= 2&lt;span&gt;;
    console.log(&lt;/span&gt;'cloneParseObject'&lt;span&gt;);
    console.log(cloneParseObject);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;73991492ef087db101c2612cdba3edfd&quot;&gt;&lt;span class=&quot;lake-card-margin-top lake-card-margin-bottom lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1598668287424-bbb1c951-d5be-44dc-a2de-d7c4903be7ae.png%22%2C%22originWidth%22%3A1172%2C%22originHeight%22%3A206%2C%22name%22%3A%22image.png%22%2C%22size%22%3A17010%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A120.17485%2C%22y%22%3A7.3399076%2C%22width%22%3A59.82288999999999%2C%22height%22%3A28.0363054%2C%22text%22%3A%22fo%5D%22%7D%2C%7B%22x%22%3A65.78788%2C%22y%22%3A10.110679%2C%22width%22%3A36.370180000000005%2C%22height%22%3A22.937745%2C%22text%22%3A%22fa%3A%22%7D%2C%7B%22x%22%3A124.44929%2C%22y%22%3A106.381294%2C%22width%22%3A234.98919%2C%22height%22%3A24.763375999999994%2C%22text%22%3A%22protoobject%22%7D%2C%7B%22x%22%3A113.281204%2C%22y%22%3A137.44302%2C%22width%22%3A224.267496%2C%22height%22%3A25.540010000000024%2C%22text%22%3A%22proto_%3Aobject%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22fo%5D%20fa%3A%20protoobject%20proto_%3Aobject%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A586%2C%22height%22%3A103%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1598668287424-bbb1c951-d5be-44dc-a2de-d7c4903be7ae.png&quot; alt=&quot;image.png&quot; width=&quot;484&quot; height=&quot;85&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;103px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;9b8d6fc73ced5ad64c6ff9e0c8a04aec&quot;&gt;缺陷：&lt;/p&gt;
&lt;ul data-lake-id=&quot;30b7eaf00e2134952fef6cd178d27451&quot;&gt;&lt;li data-lake-id=&quot;aed36dcf5bbb7dc1465dde9e70552dac&quot;&gt;会忽略 undefined&lt;/li&gt;
&lt;li data-lake-id=&quot;04330e74284145573e1f0e4de11e894d&quot;&gt;会忽略 symbol&lt;/li&gt;
&lt;li data-lake-id=&quot;e9c8149433124da4ce7f04aa5ac6090f&quot;&gt;无法对function进行处理 需要确认.&lt;/li&gt;
&lt;li data-lake-id=&quot;4e09c171174eec99d648c293cc7e01e7&quot;&gt;不能解决循环引用的对象&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;csEw4&quot; data-lake-id=&quot;3e2a28fba84981ea6350963fedbdf4e3&quot;&gt;递归（简单版）&lt;/h4&gt;
&lt;div id=&quot;ln4bl&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%5Cnfunction%20cloneDeep(obj)%20%7B%5Cn%20%20if%20(!obj%20%26%26%20typeof%20obj%20!%3D%3D%20'object')%20%7B%5Cn%20%20%20%20throw%20new%20Error('%E9%94%99%E8%AF%AF%E5%8F%82%E6%95%B0')%3B%5Cn%20%20%7D%5Cn%20%20const%20targetObj%20%3D%20Array.isArray(obj)%20%3F%20%5B%5D%20%3A%20%7B%7D%3B%5Cn%20%20for%20(let%20key%20in%20obj)%20%7B%5Cn%20%20%20%20%2F%2F%E5%8F%AA%E5%AF%B9%E5%AF%B9%E8%B1%A1%E8%87%AA%E6%9C%89%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E6%8B%B7%E8%B4%9D%5Cn%20%20%20%20if%20(obj.hasOwnProperty(key))%20%7B%5Cn%20%20%20%20%20%20if%20(obj%5Bkey%5D%20%26%26%20typeof%20obj%5Bkey%5D%20%3D%3D%3D%20'object')%20%7B%5Cn%20%20%20%20%20%20%20%20targetObj%5Bkey%5D%20%3D%20cloneDeep(obj%5Bkey%5D)%3B%5Cn%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20targetObj%5Bkey%5D%20%3D%20obj%5Bkey%5D%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20return%20targetObj%3B%5Cn%7D%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22ln4bl%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 深拷贝&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; cloneDeep(obj) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!obj &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; obj !== 'object'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('错误参数'&lt;span&gt;);
  }
  const targetObj &lt;/span&gt;= Array.isArray(obj) ?&lt;span&gt; [] : {};
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只对对象自有属性进行拷贝&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (obj.hasOwnProperty(key)) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj[key] &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; obj[key] === 'object'&lt;span&gt;) {
        targetObj[key] &lt;/span&gt;=&lt;span&gt; cloneDeep(obj[key]);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        targetObj[key] &lt;/span&gt;=&lt;span&gt; obj[key];
      }
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetObj;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p data-lake-id=&quot;e8b28ec783f83badc0e7b5155f2618bc&quot;&gt;&lt;strong&gt;关键点&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-lake-id=&quot;9e0ef6c436b49211d122ab1542196f4e&quot;&gt;&lt;li data-lake-id=&quot;2f89c5c8d5e72b9ac01bd51305a05088&quot;&gt;判断参数类型&lt;/li&gt;
&lt;li data-lake-id=&quot;27072b41044ec19e4a5147fab15d9147&quot;&gt;判断是否是数组&lt;/li&gt;
&lt;li data-lake-id=&quot;7384ab7e40601ccdfa8e81d5226b9059&quot;&gt;for in遍历&lt;/li&gt;
&lt;li data-lake-id=&quot;ec76037b022cc430e2b77215b026ee08&quot;&gt;判断是否是自有对象&lt;/li&gt;
&lt;li data-lake-id=&quot;531fbfca07acbd7aef00119797b0e644&quot;&gt;判断子属性是否是对象，是对象则递归&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;uBnhm&quot; data-lake-id=&quot;cf1188605affb5b7024acd5b6df7b5eb&quot;&gt;递归（复杂版）&lt;/h4&gt;
&lt;div id=&quot;9KudK&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%C2%A0mapTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Map%5D'%3B%5Cnconst%C2%A0setTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Set%5D'%3B%5Cnconst%C2%A0arrayTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Array%5D'%3B%5Cnconst%C2%A0objectTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Object%5D'%3B%5Cnconst%C2%A0argsTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Arguments%5D'%3B%5Cn%5Cnconst%C2%A0boolTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Boolean%5D'%3B%5Cnconst%C2%A0dateTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Date%5D'%3B%5Cnconst%C2%A0numberTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Number%5D'%3B%5Cnconst%C2%A0stringTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0String%5D'%3B%5Cnconst%C2%A0symbolTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Symbol%5D'%3B%5Cnconst%C2%A0errorTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Error%5D'%3B%5Cnconst%C2%A0regexpTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0RegExp%5D'%3B%5Cnconst%C2%A0funcTag%C2%A0%3D%C2%A0'%5Bobject%C2%A0Function%5D'%3B%5Cn%5Cnconst%C2%A0deepTag%C2%A0%3D%C2%A0%5BmapTag%2C%C2%A0setTag%2C%C2%A0arrayTag%2C%C2%A0objectTag%2C%C2%A0argsTag%5D%3B%5Cn%5Cn%5Cnfunction%C2%A0forEach(array%2C%C2%A0iteratee)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0let%C2%A0index%C2%A0%3D%C2%A0-1%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0length%C2%A0%3D%C2%A0array.length%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0while%C2%A0(%2B%2Bindex%C2%A0%3C%C2%A0length)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0iteratee(array%5Bindex%5D%2C%C2%A0index)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0array%3B%5Cn%7D%5Cn%5Cnfunction%C2%A0isObject(target)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0type%C2%A0%3D%C2%A0typeof%C2%A0target%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0target%C2%A0!%3D%3D%C2%A0null%C2%A0%26%26%C2%A0(type%C2%A0%3D%3D%3D%C2%A0'object'%C2%A0%7C%7C%C2%A0type%C2%A0%3D%3D%3D%C2%A0'function')%3B%5Cn%7D%5Cn%5Cnfunction%C2%A0getType(target)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0Object.prototype.toString.call(target)%3B%5Cn%7D%5Cn%5Cnfunction%C2%A0getInit(target)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0Ctor%C2%A0%3D%C2%A0target.constructor%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0new%C2%A0Ctor()%3B%5Cn%7D%5Cn%5Cnfunction%C2%A0cloneSymbol(targe)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0Object(Symbol.prototype.valueOf.call(targe))%3B%5Cn%7D%5Cn%5Cnfunction%C2%A0cloneReg(targe)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0reFlags%C2%A0%3D%C2%A0%2F%5C%5Cw*%24%2F%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0result%C2%A0%3D%C2%A0new%C2%A0targe.constructor(targe.source%2C%C2%A0reFlags.exec(targe))%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0result.lastIndex%C2%A0%3D%C2%A0targe.lastIndex%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0result%3B%5Cn%7D%5Cn%5Cnfunction%C2%A0cloneFunction(func)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0bodyReg%C2%A0%3D%C2%A0%2F(%3F%3C%3D%7B)(.%7C%5C%5Cn)%2B(%3F%3D%7D)%2Fm%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0paramReg%C2%A0%3D%C2%A0%2F(%3F%3C%3D%5C%5C().%2B(%3F%3D%5C%5C)%5C%5Cs%2B%7B)%2F%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0funcString%C2%A0%3D%C2%A0func.toString()%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0if%C2%A0(func.prototype)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0param%C2%A0%3D%C2%A0paramReg.exec(funcString)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0body%C2%A0%3D%C2%A0bodyReg.exec(funcString)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0if%C2%A0(body)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0if%C2%A0(param)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0paramArr%C2%A0%3D%C2%A0param%5B0%5D.split('%2C')%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0new%C2%A0Function(...paramArr%2C%C2%A0body%5B0%5D)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%7D%C2%A0else%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0new%C2%A0Function(body%5B0%5D)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%7D%C2%A0else%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0null%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%C2%A0else%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0eval(funcString)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%7D%5Cn%5Cnfunction%C2%A0cloneOtherType(targe%2C%C2%A0type)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0Ctor%C2%A0%3D%C2%A0targe.constructor%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0switch%C2%A0(type)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0case%C2%A0boolTag%3A%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0case%C2%A0numberTag%3A%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0case%C2%A0stringTag%3A%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0case%C2%A0errorTag%3A%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0case%C2%A0dateTag%3A%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0new%C2%A0Ctor(targe)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0case%C2%A0regexpTag%3A%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0cloneReg(targe)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0case%C2%A0symbolTag%3A%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0cloneSymbol(targe)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0case%C2%A0funcTag%3A%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0cloneFunction(targe)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0default%3A%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0null%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%7D%5Cn%5Cnfunction%C2%A0clone(target%2C%C2%A0map%C2%A0%3D%C2%A0new%C2%A0WeakMap())%C2%A0%7B%5Cn%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%2F%2F%C2%A0%E5%85%8B%E9%9A%86%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0if%C2%A0(!isObject(target))%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0target%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%2F%2F%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0type%C2%A0%3D%C2%A0getType(target)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0let%C2%A0cloneTarget%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0if%C2%A0(deepTag.includes(type))%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0cloneTarget%C2%A0%3D%C2%A0getInit(target%2C%C2%A0type)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%C2%A0else%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0cloneOtherType(target%2C%C2%A0type)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%2F%2F%C2%A0%E9%98%B2%E6%AD%A2%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%5Cn%C2%A0%C2%A0%C2%A0%C2%A0if%C2%A0(map.get(target))%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0map.get(target)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%C2%A0%C2%A0%C2%A0%C2%A0map.set(target%2C%C2%A0cloneTarget)%3B%5Cn%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%2F%2F%C2%A0%E5%85%8B%E9%9A%86set%5Cn%C2%A0%C2%A0%C2%A0%C2%A0if%C2%A0(type%C2%A0%3D%3D%3D%C2%A0setTag)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0target.forEach(value%C2%A0%3D%3E%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0cloneTarget.add(clone(value%2C%C2%A0map))%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%7D)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0cloneTarget%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%2F%2F%C2%A0%E5%85%8B%E9%9A%86map%5Cn%C2%A0%C2%A0%C2%A0%C2%A0if%C2%A0(type%C2%A0%3D%3D%3D%C2%A0mapTag)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0target.forEach((value%2C%C2%A0key)%C2%A0%3D%3E%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0cloneTarget.set(key%2C%C2%A0clone(value%2C%C2%A0map))%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%7D)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0cloneTarget%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%2F%2F%C2%A0%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84%5Cn%C2%A0%C2%A0%C2%A0%C2%A0const%C2%A0keys%C2%A0%3D%C2%A0type%C2%A0%3D%3D%3D%C2%A0arrayTag%C2%A0%3F%C2%A0undefined%C2%A0%3A%C2%A0Object.keys(target)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0forEach(keys%C2%A0%7C%7C%C2%A0target%2C%C2%A0(value%2C%C2%A0key)%C2%A0%3D%3E%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0if%C2%A0(keys)%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0key%C2%A0%3D%C2%A0value%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%7D%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0cloneTarget%5Bkey%5D%C2%A0%3D%C2%A0clone(target%5Bkey%5D%2C%C2%A0map)%3B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0%7D)%3B%5Cn%5Cn%C2%A0%C2%A0%C2%A0%C2%A0return%C2%A0cloneTarget%3B%5Cn%7D%5Cn%5Cnmodule.exports%C2%A0%3D%C2%A0%7B%5Cn%C2%A0%C2%A0%C2%A0%C2%A0clone%5Cn%7D%3B%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%229KudK%22%7D&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;lake-codeblock-content&quot;&gt;
&lt;div class=&quot;CodeMirror-sizer&quot; readability=&quot;18&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
const mapTag = '[object Map]'&lt;span&gt;;
const setTag &lt;/span&gt;= '[object Set]'&lt;span&gt;;
const arrayTag &lt;/span&gt;= '[object Array]'&lt;span&gt;;
const objectTag &lt;/span&gt;= '[object Object]'&lt;span&gt;;
const argsTag &lt;/span&gt;= '[object Arguments]'&lt;span&gt;;

const boolTag &lt;/span&gt;= '[object Boolean]'&lt;span&gt;;
const dateTag &lt;/span&gt;= '[object Date]'&lt;span&gt;;
const numberTag &lt;/span&gt;= '[object Number]'&lt;span&gt;;
const stringTag &lt;/span&gt;= '[object String]'&lt;span&gt;;
const symbolTag &lt;/span&gt;= '[object Symbol]'&lt;span&gt;;
const errorTag &lt;/span&gt;= '[object Error]'&lt;span&gt;;
const regexpTag &lt;/span&gt;= '[object RegExp]'&lt;span&gt;;
const funcTag &lt;/span&gt;= '[object Function]'&lt;span&gt;;

const deepTag &lt;/span&gt;=&lt;span&gt; [mapTag, setTag, arrayTag, objectTag, argsTag];


&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; forEach(array, iteratee) {
    let index &lt;/span&gt;= -1&lt;span&gt;;
    const length &lt;/span&gt;=&lt;span&gt; array.length;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (++index &amp;lt;&lt;span&gt; length) {
        iteratee(array[index], index);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isObject(target) {
    const type &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; target;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; target !== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (type === 'object' || type === 'function'&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getType(target) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Object.prototype.toString.call(target);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getInit(target) {
    const Ctor &lt;/span&gt;=&lt;span&gt; target.constructor;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ctor();
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; cloneSymbol(targe) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Object(Symbol.prototype.valueOf.call(targe));
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; cloneReg(targe) {
    const reFlags &lt;/span&gt;= /\w*$/&lt;span&gt;;
    const result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; targe.constructor(targe.source, reFlags.exec(targe));
    result.lastIndex &lt;/span&gt;=&lt;span&gt; targe.lastIndex;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; cloneFunction(func) {
    const bodyReg &lt;/span&gt;= /(?&amp;lt;={)(.|\n)+(?=})/&lt;span&gt;m;
    const paramReg &lt;/span&gt;= /(?&amp;lt;=\().+(?=\)\s+{)/&lt;span&gt;;
    const funcString &lt;/span&gt;=&lt;span&gt; func.toString();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (func.prototype) {
        const param &lt;/span&gt;=&lt;span&gt; paramReg.exec(funcString);
        const body &lt;/span&gt;=&lt;span&gt; bodyReg.exec(funcString);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (body) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (param) {
                const paramArr &lt;/span&gt;= param[0].split(','&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Function(...paramArr, body[0&lt;span&gt;]);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Function(body[0&lt;span&gt;]);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; eval(funcString);
    }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; cloneOtherType(targe, type) {
    const Ctor &lt;/span&gt;=&lt;span&gt; targe.constructor;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (type) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; boolTag:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; numberTag:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; stringTag:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; errorTag:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; dateTag:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ctor(targe);
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; regexpTag:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cloneReg(targe);
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; symbolTag:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cloneSymbol(targe);
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; funcTag:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cloneFunction(targe);
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; clone(target, map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WeakMap()) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 克隆原始类型&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isObject(target)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化&lt;/span&gt;
    const type =&lt;span&gt; getType(target);
    let cloneTarget;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (deepTag.includes(type)) {
        cloneTarget &lt;/span&gt;=&lt;span&gt; getInit(target, type);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cloneOtherType(target, type);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止循环引用&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (map.get(target)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map.get(target);
    }
    map.set(target, cloneTarget);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 克隆set&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (type ===&lt;span&gt; setTag) {
        target.forEach(value &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            cloneTarget.add(clone(value, map));
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cloneTarget;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 克隆map&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (type ===&lt;span&gt; mapTag) {
        target.forEach((value, key) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            cloneTarget.set(key, clone(value, map));
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cloneTarget;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 克隆对象和数组&lt;/span&gt;
    const keys = type === arrayTag ?&lt;span&gt; undefined : Object.keys(target);
    forEach(keys &lt;/span&gt;|| target, (value, key) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (keys) {
            key &lt;/span&gt;=&lt;span&gt; value;
        }
        cloneTarget[key] &lt;/span&gt;=&lt;span&gt; clone(target[key], map);
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cloneTarget;
}
module.exports &lt;/span&gt;=&lt;span&gt; {
    clone
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;1.7763157894737&quot;&gt;
&lt;p data-lake-id=&quot;5ab332d82e9fd27af00324d0a8d6130f&quot;&gt;复杂递归实现详解：&lt;a href=&quot;https://mp.weixin.qq.com/s/vXbFsG59L1Ba0DMcZeU2Bg&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/vXbFsG59L1Ba0DMcZeU2Bg&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;neqJX&quot; data-lake-id=&quot;104b702280487933d46ead129175b00a&quot;&gt;示例代码&lt;/h2&gt;
&lt;p data-lake-id=&quot;c2e590167c2e76fa5c1cf15f67c476c3&quot;&gt;&lt;span id=&quot;8o0mX&quot; class=&quot;lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;file&quot; data-card-value=&quot;data:%7B%22uid%22%3A%221599093649350-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fhtml%2F305942%2F1599093649390-2a0e74e8-fc2c-45ae-af89-ce6629373186.html%22%2C%22name%22%3A%22%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D.html%22%2C%22size%22%3A6423%2C%22type%22%3A%22text%2Fhtml%22%2C%22ext%22%3A%22html%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%228o0mX%22%7D&quot;&gt;&lt;a href=&quot;https://www.yuque.com/attachments/yuque/0/2020/html/305942/1599093649390-2a0e74e8-fc2c-45ae-af89-ce6629373186.html&quot;&gt;📎深浅拷贝.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;df0ee058d978a9243b4c54fe3079905b&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;0.48695652173913&quot;&gt;
&lt;p data-lake-id=&quot;1de307fdc704e8d70940d5b429621f94&quot;&gt;参考&lt;/p&gt;
&lt;p data-lake-id=&quot;646e6c7f02e7fe20933e1e9f2f90eb4c&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vXbFsG59L1Ba0DMcZeU2Bg&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/vXbFsG59L1Ba0DMcZeU2Bg&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;3b30690c7bb5fb6d4348f0c4f5f49ebb&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/a2013126370/article/details/89035722&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/a2013126370/article/details/89035722&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 03 Sep 2020 00:47:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>基本数据类型和引用数据类型 JS数据分为基本数据类型和引用数据类型。基本数据类型的变量存储在栈中，引用数据类型则存储在堆中，引用数据类型的存储地址则保存在栈中。 下面来看一个小例子&amp;#127792;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suihang/p/13605612.html</dc:identifier>
</item>
<item>
<title>Python开发的入门教程(八)-迭代 - 谁主沉浮oo7</title>
<link>http://www.cnblogs.com/feifuzeng/p/13541142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feifuzeng/p/13541142.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;本文主要介绍Python中&lt;strong&gt;迭代&lt;/strong&gt;的基本知识和使用&lt;/p&gt;
&lt;h2 id=&quot;什么是迭代&quot;&gt;什么是迭代&lt;/h2&gt;
&lt;p&gt;在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。&lt;/p&gt;
&lt;p&gt;在Python中，迭代是通过 for ... in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (i=0; i&amp;lt;list.length; i++) {
    n = list[i];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，Python的for循环抽象程度要高于Java的for循环。&lt;/p&gt;
&lt;p&gt;因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。&lt;/p&gt;
&lt;p&gt;因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。&lt;/p&gt;
&lt;p&gt;注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;有序集合：list，tuple，str和unicode；&lt;/li&gt;
&lt;li&gt;无序集合：set&lt;/li&gt;
&lt;li&gt;无序集合并且具有 key-value 对：dict&lt;br/&gt;而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。&lt;/p&gt;
&lt;h2 id=&quot;索引迭代&quot;&gt;索引迭代&lt;/h2&gt;
&lt;p&gt;Python中，迭代永远是取出元素本身，而非元素的索引。&lt;/p&gt;
&lt;p&gt;对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？&lt;/p&gt;
&lt;p&gt;方法是使用 enumerate() 函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']
&amp;gt;&amp;gt;&amp;gt; for index, name in enumerate(L):
...     print index, '-', name
... 
0 - Adam
1 - Lisa
2 - Bart
3 - Paul
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['Adam', 'Lisa', 'Bart', 'Paul']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变成了类似：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[(0, 'Adam'), (1, 'Lisa'), (2, 'Bart'), (3, 'Paul')]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，迭代的每一个元素实际上是一个tuple：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for t in enumerate(L):
    index = t[0]
    name = t[1]
    print index, '-', name
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for index, name in enumerate(L):
    print index, '-', name
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样不但代码更简单，而且还少了两条赋值语句。&lt;/p&gt;
&lt;p&gt;可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。&lt;/p&gt;
&lt;h2 id=&quot;迭代dict的value&quot;&gt;迭代dict的value&lt;/h2&gt;
&lt;p&gt;我们已经了解了dict对象本身就是可迭代对象，用for循环直接迭代dict，可以每次拿到dict的一个key。&lt;br/&gt;如果我们希望迭代 dict 对象的value，应该怎么做？&lt;br/&gt;dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
print d.values()
# [85, 95, 59]
for v in d.values():
    print v
# 85
# 95
# 59
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
print d.itervalues()
# &amp;lt;dictionary-valueiterator object at 0x106adbb50&amp;gt;
for v in d.itervalues():
    print v
# 85
# 95
# 59
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那这两个方法有何不同之处呢？&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;values() 方法实际上把一个 dict 转换成了包含 value 的list。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;但是&lt;strong&gt;itervalues()&lt;/strong&gt;方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;打印 itervalues() 发现它返回一个 对象，这说明在Python中，&lt;strong&gt;for循环可作用的迭代对象远不止list，tuple，str，unicode，dict等&lt;/strong&gt;，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。&lt;br/&gt;&lt;strong&gt;如果一个对象说自己可迭代，那我们就直接用for循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;迭代dict的key和value&quot;&gt;迭代dict的key和value&lt;/h2&gt;
&lt;p&gt;我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。&lt;/p&gt;
&lt;p&gt;首先，我们看看 dict 对象的 items() 方法返回的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
&amp;gt;&amp;gt;&amp;gt; print d.items()
[('Lisa', 85), ('Adam', 95), ('Bart', 59)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for key, value in d.items():
...     print key, ':', value
... 
Lisa : 85
Adam : 95
Bart : 59
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;欢迎关注微信公众号『码仔zonE』，专注于分享Java、云计算相关内容，包括SpringBoot、SpringCloud、微服务、Docker、Kubernetes、Python等领域相关技术干货，期待与您相遇！&lt;br/&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/c4sDyQ4RqeSvZzxFxWLrhb94asLZsOiagMmXhYl1MMAqkzygAR4DbuLdGQALFujG5M1kuXOc04JfS28lRqO8ZQg/0?wx_fmt=png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 03 Sep 2020 00:46:00 +0000</pubDate>
<dc:creator>谁主沉浮oo7</dc:creator>
<og:description>介绍 本文主要介绍Python中迭代的基本知识和使用 什么是迭代 在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Ite</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feifuzeng/p/13541142.html</dc:identifier>
</item>
<item>
<title>手机没网了，却还能支付，这是什么原理？ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13605601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13605601.html</guid>
<description>&lt;p&gt;现在生活已经离不开微信/支付宝电子支付，平常出去吃饭、购物只要带个手机，就可以解决一切，以致于现在已经好久没摸过真💰了。&lt;/p&gt;
&lt;p&gt;有一次出去吃饭，排着队付钱，等着过程非常无聊，准备拔出手机来把荒野乱斗，却发现这个地方竟然连不上网 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084258108-174125349.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;看着手机明明信号满格，但是就是显示网络无连接，苹果手机用户痛，谁用谁知道。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;画外音:真的要 Diss 一下使用英特尔基带的 Iphone，📶好差，没事网络就会闪断~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说回正题，由于没有网络，而我又没带钱，所以就怕付钱的时候因为手机没网，没办法使用支付宝扣款。正想着时，已经排到了我，不管三七二十一，先用下支付宝试试，实在不行爷不吃了。&lt;/p&gt;
&lt;p&gt;不过没想到，当商家用扫码抢扫描支付宝上付款码支付以后，虽然我的手机最终没有弹出支付成功的页面，但是商家端显示支付成功，并成功打印出了小票，过了一会，我的手机收到支付宝扣款短信。&lt;/p&gt;
&lt;p&gt;因为我最近的工作对都是与微信/支付宝有关，整体支付流程还是比较清楚，但是付款码为什么能离线支付确实不是很清楚，所以研究了一番，于是有了今天的文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084258265-1975570204.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;科普支付方式&quot;&gt;科普支付方式&lt;/h2&gt;
&lt;p&gt;在聊付款码离线原理之前，我们先给不熟悉支付宝/微信支付方式同学先科普一下常见的两种支付方式。&lt;/p&gt;
&lt;p&gt;微信、支付宝线下支付常用支付方式有两种，一种是我们打开手机，主动扫描商家提供码牌，这种支付方式一般称为主扫支付（用户主动扫码）。&lt;/p&gt;
&lt;p&gt;以支付宝为例，付款流程如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084258471-1092312591.jpg&quot; alt=&quot;图片来自支付宝官网&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二种则是我们打开手机，展示我们的付款码，然后商家使用扫码枪等工具获取付款码完成支付，这种支付方式一般称为被扫支付（用户被扫码）。&lt;/p&gt;
&lt;p&gt;以支付宝为例，付款流程如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084258757-1945687815.jpg&quot; alt=&quot;图片来自支付宝官网&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于第一种方式，需要手机端 APP 扫码，然后弹窗确认付款，这种方式是没有办法在手机没有网络的情况完成支付，所以我们上文说的没有网络的情况特指付款码支付的场景。&lt;/p&gt;
&lt;h2 id=&quot;付款码付款流程&quot;&gt;付款码付款流程&lt;/h2&gt;
&lt;p&gt;在聊付款码离线支付的前提前，我们先来来看下付款码的整体流程，以超市购物为例，一次付款码的支付信息流如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259038-399486180.jpg&quot; alt=&quot;参考知乎@天顺&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个过程商家后台系统是需要调用的支付宝条码支付的接口，完成支付。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于商家后台需要在线联网与支付宝后台通讯，所以说付款码的离线支付，指的是客户端没有的网络的情况，商家端其实必须实时联网在线。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一次付款码接口调用流程如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259392-963235151.jpg&quot; alt=&quot;来自支付宝官网&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面两张图，我们整体了解付款码交互流程。&lt;/p&gt;
&lt;p&gt;付款码的技术方案其实可以分为客户端在线与离线的两种情况，下面我们来看下两种方案具体实现方式。&lt;/p&gt;
&lt;h2 id=&quot;在线码方案&quot;&gt;在线码方案&lt;/h2&gt;
&lt;p&gt;客户端在线码的方案，这个应该比较容易想到，只要支付宝/微信在登录的情况下，点击付款按钮，客户端调用后台系统的申请付款码接口。&lt;/p&gt;
&lt;p&gt;后台系统受到请求之后，生成一个付款码，然后在数据库保存付款码与用户的关系，并且返回给客户端。&lt;/p&gt;
&lt;p&gt;只要客户端在有效期内展示该付款码，就可以完成支付，否则该二维码就将会过期。&lt;/p&gt;
&lt;p&gt;使用这种方案，相对来说比较安全，因为每次都是服务端生成码，服务端可以控制幂等，没有客户端伪造的风险的。&lt;/p&gt;
&lt;p&gt;另外即使需要对付款码规则调整，比如付款码位数增加一位，我们只要调整服务端代码即可，客户端都无需升级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不过这种方案缺点也比较明显，客户端必须实时在线联网，没有网络则无法获取付款码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，现在有一些智能设备也开始支持支付宝支付，这些设备中很大一部分是没有联网的功能（&lt;em&gt;比如小米手环四&lt;/em&gt;），那这种情况是没办法使用在线码方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259568-1378830885.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于这种情况，所以开始有了离线码方案。&lt;/p&gt;
&lt;h2 id=&quot;离线码方案&quot;&gt;离线码方案&lt;/h2&gt;
&lt;p&gt;说起离线码大家可能比较陌生，但是实际上你如果仔细观察，其实很多场景都用到了离线码。&lt;/p&gt;
&lt;p&gt;比如说以前去黑网吧玩梦幻西游的时候，账号总是被盗。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259736-1623577831.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;没办法，花了一笔重资买了一个网易将军令，每次登录的时候，除了输入用户名与密码以外，还需要输入动态口令。从此账号就很少被盗了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259872-97493341.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;又比如说每次网易支付的时候，我们除了输入银行卡密码以外，还需要输入网银盾上动态码，这样才能完成支付。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300001-909222687.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;画外音：&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300156-503110690.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;这里又要吐槽一下，网银盾以前真的超难用，动不动就驱动不兼容。还记得当初用网银充值黄钻，搞了一下午都没有成功--！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然上面这些可能已经是&lt;em&gt;老古董&lt;/em&gt;了，很多人都可能没用过，现在比较流行是&lt;strong&gt;手机验证器APP&lt;/strong&gt;，比如 &lt;strong&gt;Google Authenticator&lt;/strong&gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300339-900696701.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种令牌器，动态产生一次性口令（&lt;strong&gt;OTP, One-time Password&lt;/strong&gt;），可以防止密码被盗用引发的安全风险。&lt;/p&gt;
&lt;p&gt;其实付款码离线方案技术原型就是基于这种方案，所以下面我们就基于 Google Authenticator，来了解一下这其中的原理。&lt;/p&gt;
&lt;h3 id=&quot;动态口令技术原理&quot;&gt;动态口令技术原理&lt;/h3&gt;
&lt;p&gt;首先如果我们需要使用 &lt;strong&gt;Google Authenticator&lt;/strong&gt;，我们需要在网站上开启二次验证功能，以 Google 账号为例，在设置两步验证的地方可以找到如下设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300560-1624461624.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们点击设置，将会弹出一个二维码，然后使用 &lt;strong&gt;Google Authenticator&lt;/strong&gt; APP 扫码绑定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300775-1871222912.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们绑定之后， &lt;strong&gt;Google Authenticator&lt;/strong&gt; APP 将会展示动态码。&lt;/p&gt;
&lt;p&gt;我们来解析一下这个二维码，对应下面这个字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;otpauth://totp/Google%3Ayourname@gmail.com?secret=xxxx&amp;amp;issuer=Google
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的字符串中，最重要就是这一串密钥 &lt;code&gt;secret&lt;/code&gt;，这个是一个经过 &lt;strong&gt;BASE32&lt;/strong&gt; 编码之后的字符串，真正使用时需要将其使用&lt;strong&gt;BASE32&lt;/strong&gt; 解码，处理伪码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;original_secret = xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
secret = BASE32_DECODE(TO_UPPERCASE(REMOVE_SPACES(original_secret)))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这个密钥客户端与服务端将会同时保存一份，两端将会同样的算法计算，以此用来比较动态码的正确性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们以客户端为例，生成一个动态码，首先我们需要经过一个签名函数，这里 **Google Authenticator **采用的 &lt;strong&gt;HMAC-SHA1&lt;/strong&gt;，这是一种基于哈希的消息验证码，可以用比较安全的单向哈希函数（如 SHA1）来产生签名。&lt;/p&gt;
&lt;p&gt;签名函数伪码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;hmac = SHA1(secret + SHA1(secret + input))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面函数中的，&lt;code&gt;input&lt;/code&gt; 使用当前时间整除 30 的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;input = CURRENT_UNIX_TIME() / 30
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里时间就充当一个动态变参，这样可以源源不断产生动态码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外这里整除 30，是为了赋予验证码一个 30 秒的有效期。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样对于用户输入来讲，可以有充足时间准备输入这个动态码，另外一点客户端与服务端可能存在时间偏差，30 秒的间隔可以很大概率的屏蔽这种差异。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;画外音：这个有效时间其实很考量，如果比较长，安全性就差。&lt;/p&gt;
&lt;p&gt;如果比较短，用户体验就很差，不容易输入准备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过 &lt;strong&gt;HMAC-SHA1&lt;/strong&gt; 签名函数以后，我们得到一个长度为 40 的字符串，我们还需要将其转化为 6 位数字，方便用户输入。处理的伪码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;four_bytes = hmac[LAST_BYTE(hmac):LAST_BYTE(hmac) + 4]
large_integer = INT(four_bytes)
small_integer = large_integer % 1,000,000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的算法伪码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;original_secret = xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
secret = BASE32_DECODE(TO_UPPERCASE(REMOVE_SPACES(original_secret)))
input = CURRENT_UNIX_TIME() / 30
hmac = SHA1(secret + SHA1(secret + input))
four_bytes = hmac[LAST_BYTE(hmac):LAST_BYTE(hmac) + 4]
large_integer = INT(four_bytes)
small_integer = large_integer % 1,000,000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当客户端将动态码上传给服务端，服务端查询数据库获取到用户对应的密钥，然后使用同样的算法进行处理生成一个动态码，最后比较客户端上传动态码与服务端生成是否一致。&lt;/p&gt;
&lt;h3 id=&quot;付款码离线方案&quot;&gt;付款码离线方案&lt;/h3&gt;
&lt;p&gt;上面我们了解了动态口令的实现方案，付款码生成原理其实也大致如此。&lt;/p&gt;
&lt;p&gt;不过付款码离线方案采用动态密钥的方式(&lt;strong&gt;全局唯一&lt;/strong&gt;)，定时请求服务端更换密钥，以此保证更高的安全性。&lt;/p&gt;
&lt;p&gt;另外在一次性动态口令方案，需要双方基于同样的秘钥，所以服务端需要明确知道这&lt;strong&gt;背后正确用户&lt;/strong&gt;。以上面的登录场景为例，登录过程输入用户名,服务端就可以根据这个在数据库中查询相应的密钥。&lt;/p&gt;
&lt;p&gt;但是在付款码的支付场景中，支付过程仅仅传递一个付款码，就可以向相应的用户扣款。不用想，这个付款码这串数字一定包含相应的用户信息。&lt;/p&gt;
&lt;p&gt;所以付款码的相应的算法相比动态码会更加复杂，这样才可以有效保证安全性。&lt;/p&gt;
&lt;p&gt;看到这里，不知道你们是否想了解这套算法那？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300952-579485567.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哈哈，开个玩笑，这种算法岂能是我们能掌握的。&lt;/p&gt;
&lt;p&gt;支付宝核心算法咱不知道，但是我们可以从其他人公开设计方案了解一个皮毛。&lt;/p&gt;
&lt;p&gt;这里小黑哥给你一个知乎网友&lt;a href=&quot;https://www.zhihu.com/question/49811134/answer/135886638&quot;&gt;@反方向的钟回答&lt;/a&gt;的离线二维码实现方式，给你 look look。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084301103-1719620198.png&quot; alt=&quot;来自：https://www.zhihu.com/question/49811134/answer/135886638&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;付款码离线码的劣势&quot;&gt;付款码离线码的劣势&lt;/h3&gt;
&lt;p&gt;最后我们来看下付款码离线方案的劣势：&lt;/p&gt;
&lt;p&gt;第一，算法调整不灵活，如果相关算法较大的调整，可能需要升级客户端,并且这个期间服务端还需要兼容新老算法产生的付款码。&lt;/p&gt;
&lt;p&gt;第二，安全性问题，正常的情况相关密钥无法被普通用户获取，但是架不住有有心之人。他们可能通过获取手机用户 Root 权限或者越狱手机，利用恶意程序获取密钥，然后随意生成付款码。&lt;/p&gt;
&lt;p&gt;看到这一点，大家可能会担心自己的钱包安全了。不过这一点，我觉得不过过分担心，蚂蚁集团这么多大神，不是吃干饭的，他们肯定有很多措施保证支付安全。&lt;/p&gt;
&lt;p&gt;第三数据碰撞问题，A 用户生成付款码算出来与 B 用户一致，这就 Hash 算法一样，再怎么优秀的算法，也有概率才生一样的额 Hash 值。&lt;/p&gt;
&lt;p&gt;这就导致原本是扣用户 A 的钱，最后却扣了 B 用户。这样一来，确实很乌龙，对于 B 用户来讲，莫名其妙被扣钱了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084301259-857416869.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过放心，这种事放到放到现在，我觉得还是比买彩票中奖低，所以这种事还是不用过分担心了。&lt;/p&gt;
&lt;p&gt;即使真被误扣了，放心，支付宝这么大体量肯定会跟客户赔钱的。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;最后总结一下，我们平常使用付款码支付，其实原理就是商家端获取我们手机 APP 付款码（&lt;strong&gt;其实就是一串数字&lt;/strong&gt;），然后后台调用支付宝支付接口完成扣款。&lt;/p&gt;
&lt;p&gt;这个流程商家端后台程序必须联网在线，但是对于我们客户端来讲可以在线，也可以离线。&lt;/p&gt;
&lt;p&gt;如果我们客户端在线，那就可以通过服务端向客户端发送付款码，这种方式更加安全，灵活，但是对于弱网环境下，体验就很差。&lt;/p&gt;
&lt;p&gt;如果我们客户端没网，那就通过客户端通过一定算法生成付款码，服务端收到经过相关校验，确认是哪个用户，确认码有效性，并且完成扣款。这种方式，适合客户端没有网络的情况，不过相对不灵活，且安全性稍差。&lt;/p&gt;
&lt;p&gt;嘿嘿，了解原理，有没有觉得还是挺有意思的~&lt;/p&gt;
&lt;p&gt;下次排队付款钱,如果手机没网，不要担心尴尬，放心拿出手机付钱~&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/49811134/answer/135886638&quot;&gt;https://www.zhihu.com/question/49811134/answer/135886638&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://garbagecollected.org/2014/09/14/how-google-authenticator-works/&quot;&gt;https://garbagecollected.org/2014/09/14/how-google-authenticator-works/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 03 Sep 2020 00:43:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>现在生活已经离不开微信/支付宝电子支付，平常出去吃饭、购物只要带个手机，就可以解决一切，以致于现在已经好久没摸过真&amp;amp;#128176;了。 有一次出去吃饭，排着队付钱，等着过程非常无聊，准备拔出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13605601.html</dc:identifier>
</item>
<item>
<title>SQL Server解惑——标识列的限制和跳号现象 - 潇湘隐者</title>
<link>http://www.cnblogs.com/kerrycode/p/13605564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kerrycode/p/13605564.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1：每个表只能创建一个标识列。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如下测试所示，如果表中有一个标识列，新增一个标识列就会遇到错误&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Multiple identity columns specified for table 'TEST'. Only one identity column per table is allowed.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;6.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
    ID        &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(1,1) ,
&lt;/pre&gt;
&lt;pre&gt;
    NAME        &lt;span&gt;VARCHAR&lt;/span&gt;(32)
&lt;/pre&gt;
&lt;pre&gt;
);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; dbo.TEST &lt;span&gt;ADD&lt;/span&gt;  ID1 &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(10,1)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082841229-672083687.png&quot;&gt;&lt;img title=&quot;clip_image001&quot; border=&quot;0&quot; alt=&quot;clip_image001&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082841816-1554723464.png&quot; width=&quot;652&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2：标识列不能被更新。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;如果你更新标识列，就会遇到类似下面这样的错误。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;Cannot update identity column 'xxx'.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3：SQL Server不能通过ALTER语句修改标识列的increment值大小。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果非要调整标识列的increment值大小，只能通过重建表来实现。如果想通过增加列或删除列的方法，非常麻烦。很多情况下也是不行的。例如，有些情况下需要你对新增的自增标识列更新数据才能保证数据一致性。还有一种非常规方法就是修改系统基表sys.syscolpars。这个后续整理一篇。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;4：SQL Server不能通过ALTER语句修改表标识列的SEED的大小&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;但是可以DBCC CHECKIDENT命令调整。SEED可以调大也可以调小，但是有一些限制！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;#查看某个表中的自增列当前的值：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;DBCC CHECKIDENT (TableName,NORESEED)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;#调整标识列的当前值（SEED）为50&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;DBCC CHECKIDENT('dbo.TEST', RESEED, 50);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通过DBCC CHECKIDENT命令调整SEED值大小，也是有限制的，如下实验所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;10&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt; AdventureWorks2014;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; 1 &lt;span&gt;FROM&lt;/span&gt; sys.objects &lt;span&gt;WHERE&lt;/span&gt; type=&lt;span&gt;'U'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; name=&lt;span&gt;'TEST'&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; test;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;END&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
    ID        &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(1,1) ,
&lt;/pre&gt;
&lt;pre&gt;
    NAME    &lt;span&gt;VARCHAR&lt;/span&gt;(32)
&lt;/pre&gt;
&lt;pre&gt;
);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
        (  NAME )
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K1'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K2'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K3'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K4'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K5'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K6'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;IDENTITY_INSERT&lt;/span&gt; dbo.TEST &lt;span&gt;ON&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
        ( ID, NAME )
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 13, &lt;span&gt;'k13'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;IDENTITY_INSERT&lt;/span&gt; dbo.TEST &lt;span&gt;OFF&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DBCC&lt;/span&gt; CHECKIDENT(test)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DBCC&lt;/span&gt; CHECKIDENT(&lt;span&gt;'test'&lt;/span&gt;, RESEED ,9);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
        (  NAME )
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K9'&lt;/span&gt;  &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K10'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K11'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K12'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K13'&lt;/span&gt; ;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; dbo.TEST;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082842337-26693900.png&quot;&gt;&lt;img title=&quot;clip_image002&quot; border=&quot;0&quot; alt=&quot;clip_image002&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082842846-752689775.png&quot; width=&quot;652&quot; height=&quot;337&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果你修改一下表结构，标识列为主键或有唯一约束的话，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
    ID        &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(1,1) &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;,
&lt;/pre&gt;
&lt;pre&gt;
    NAME      &lt;span&gt;VARCHAR&lt;/span&gt;(32)
&lt;/pre&gt;
&lt;pre&gt;
);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那么上面脚本运行到插入数据时就会报主键冲突。错误如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;Msg 2627, Level 14, State 1, Line 38&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;Violation of PRIMARY KEY constraint 'PK__TEST__3214EC2731C41DF1'. Cannot insert duplicate key in object 'dbo.TEST'. The duplicate key value is (13).&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那么接下来，我们将上面的脚本稍微调整一下，你会看到完全不同的结果。如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;10&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt; AdventureWorks2014;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; 1 &lt;span&gt;FROM&lt;/span&gt; sys.objects &lt;span&gt;WHERE&lt;/span&gt; type=&lt;span&gt;'U'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; name=&lt;span&gt;'TEST'&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; test;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;END&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
    ID        &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(1,1) ,
&lt;/pre&gt;
&lt;pre&gt;
    NAME      &lt;span&gt;VARCHAR&lt;/span&gt;(32)
&lt;/pre&gt;
&lt;pre&gt;
);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
        (  NAME )
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K1'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K2'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K3'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K4'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K5'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K6'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;IDENTITY_INSERT&lt;/span&gt; dbo.TEST &lt;span&gt;ON&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
        ( ID, NAME )
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 13, &lt;span&gt;'k13'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;IDENTITY_INSERT&lt;/span&gt; dbo.TEST &lt;span&gt;OFF&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DBCC&lt;/span&gt; CHECKIDENT(&lt;span&gt;'test'&lt;/span&gt;, RESEED ,9);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DBCC&lt;/span&gt; CHECKIDENT(test);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
        (  NAME )
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K9'&lt;/span&gt;  &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K10'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K11'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K12'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K13'&lt;/span&gt; ;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; dbo.TEST;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082843340-305192315.png&quot;&gt;&lt;img title=&quot;clip_image003&quot; border=&quot;0&quot; alt=&quot;clip_image003&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082843879-19460480.png&quot; width=&quot;652&quot; height=&quot;339&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这个是实验测试时意外发现的一个问题，当时，它导致我得出&lt;strong&gt;&lt;span&gt;&lt;span&gt;不同的实验结果，结论也搞错了&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;，问题出在DBCC CHECKIDENT (table_name)，如果表的当前标识值小于标识列中存储的最大标识值，则使用标识列中的最大值对其进行重置。我使用DBCC&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CHECKIDENT(test)本意是来查看标识列的当前值，所以正确的做法应该用DBCC&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CHECKIDENT(test, NORESEED)这条命令。其实这里也衍生了一个问题，由于可以人为调整SEED的值，所以标识列的值的唯一性，必须通过&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;PRIMARY KEY&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;或&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;UNIQUE&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;约束或者通过&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;UNIQUE&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;索引来实现。将字段设置为标识列并不能保证值的唯一值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4： 不能通过ALTER语句将已经存在的一个字段改为标识列&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
    ID        &lt;span&gt;INT&lt;/span&gt; ,
&lt;/pre&gt;
&lt;pre&gt;
    NAME      &lt;span&gt;VARCHAR&lt;/span&gt;(32)
&lt;/pre&gt;
&lt;pre&gt;
);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
--这种语法是不允许的
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; dbo.TEST  &lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;COLUMN&lt;/span&gt; ID &lt;span&gt;IDENTITY&lt;/span&gt;(10,1) 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;5：在内存优化表中，种子和增量必须分别设置为 1、1。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;将种子或增量设置为 1 以外的值会导致以下错误：内存优化表不支持使用 1 以外的种子和增量值。另外，必须同时指定种子和增量，或者二者都不指定。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果二者都未指定，则取默认值 (1,1)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;6：如果事务回滚会导致标识列跳号。如下实验所示，这种现象和Oracle、MySQL数据库的行为一致。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
--事务回滚导致标识列自增跳号
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
        (  NAME )
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K1'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K2'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K3'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K4'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K5'&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K6'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
        (  NAME )
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'K7'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ROLLBACK&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
        (  NAME )
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'KKK'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; dbo.TEST;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;7: 事务内部，可能出现标识列的跳号。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如下实验所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;9&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt; AdventureWorks2014;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; 1 &lt;span&gt;FROM&lt;/span&gt; sys.objects &lt;span&gt;WHERE&lt;/span&gt; type=&lt;span&gt;'U'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; name=&lt;span&gt;'TEST_TRAN'&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TEST_TRAN;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;END&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; dbo.TEST_TRAN
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
    ID        &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(1,1) &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;,
&lt;/pre&gt;
&lt;pre&gt;
    TRN_NAME    &lt;span&gt;VARCHAR&lt;/span&gt;(32)
&lt;/pre&gt;
&lt;pre&gt;
);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在会话1和会话2同时执行下面SQL语句，模拟并发的事务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;--会话1：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @row_index &lt;span&gt;INT&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @row_index =1;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHILE&lt;/span&gt; @row_index &amp;lt;=10
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    INSERT &lt;span&gt;INTO&lt;/span&gt; TEST_TRAN
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'TRANS_1'&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;SET&lt;/span&gt; @row_index +=1;
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;WAITFOR&lt;/span&gt; DELAY &lt;span&gt;'00:00:01'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;END&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;--会话2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @row_index &lt;span&gt;INT&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @row_index =1;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHILE&lt;/span&gt; @row_index &amp;lt;=10
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    INSERT &lt;span&gt;INTO&lt;/span&gt; TEST_TRAN
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'TRANS_2'&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;SET&lt;/span&gt; @row_index +=1;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;WAITFOR&lt;/span&gt; DELAY &lt;span&gt;'00:00:01'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;END&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;执行完上面脚本后，我们可以看到在并发情况下，同一事务内可能出现跳号。这个可以称其为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;逻辑跳号&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082844401-1044105627.png&quot;&gt;&lt;img title=&quot;clip_image004&quot; border=&quot;0&quot; alt=&quot;clip_image004&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082844979-2064065382.png&quot; width=&quot;652&quot; height=&quot;381&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;7&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;数据库实例非正常重启（崩溃，故障转移或关闭而导致SQL Server服务意外重启），出现标识列的跳号&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span&gt;关于这个，官方文档有简单介绍。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;Consecutive values after server restart or other failures&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;-SQL Server might cache identity values for performance reasons and some of the assigned values can be lost during a database failure or server restart. This can result in gaps in the identity value upon insert. If gaps are not acceptable then the application should use its own mechanism to generate key values. Using a sequence generator with the &lt;strong&gt;NOCACHE&lt;/strong&gt; option can limit the gaps to transactions that are never committed.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;个人简单测试了一下，发现在SQL Server 2012在服务器&lt;strong&gt;非正常重启&lt;/strong&gt;（崩溃，故障转移或关闭而导致SQL Server服务意外重启）后会出现跳号（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;identity column jump&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）情况。可以通过启用踪标志272解决这个问题（参考下面链接），SQL Server 2014下测试时，也是如此。注意：&lt;strong&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;正常重启SQL Server实例，并不会出现这种情况&lt;/span&gt;&lt;/strong&gt;。这个跟&lt;a href=&quot;https://www.cnblogs.com/kerrycode/p/7461180.html&quot; target=&quot;_blank&quot;&gt;ORACLE SEQUENCE跳号总结&lt;/a&gt;中的情况有点类似。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://www.dfarber.com/computer-consulting-blog/articles/how-to-solve-identity-problem-in-sql-2012/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://blog.sqlauthority.com/2017/03/24/sql-server-jump-identity-column-restart/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://blog.sqlauthority.com/2018/01/24/sql-server-identity-jumping-1000-identity_cache/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://www.codeproject.com/Tips/668042/SQL-Server-2012-Auto-Identity-Column-Value-Jump-Is&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个人测试，在任务管理器，杀掉SQL Server的进程后，发现标识列跳号的大小为1000，根据上面博客资料，标识列跳号的多少还跟标识列的数据类型有关。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082845479-349932291.png&quot;&gt;&lt;img title=&quot;clip_image005&quot; border=&quot;0&quot; alt=&quot;clip_image005&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082846009-2091787454.png&quot; width=&quot;652&quot; height=&quot;308&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;不过在SQL Server 2017，引入了新特性IDENTITY_CACHE来解决这个问题！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;按照网上搜索的资料来看，踪标志272让SQL Server使用以前的代码来实现标识列的功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;That flag sets SQL 2012 back to the prior code for IDENTITY fields. However, unless you are actually running out of numbers, there is no reason to use that flag. IDENTITY fields are unique, not sequential. You probably need to rethink your method.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那么我们想搞清楚标识列的下一个值保存在哪里呢？ SQL Server数据库有个系统视图sys.identity_columns可以查看某个表的标识列的当前值和下一个值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  name ,
&lt;/pre&gt;
&lt;pre&gt;
        is_identity ,
&lt;/pre&gt;
&lt;pre&gt;
        seed_value ,
&lt;/pre&gt;
&lt;pre&gt;
        increment_value ,
&lt;/pre&gt;
&lt;pre&gt;
        last_value
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt;    sys.identity_columns
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt;   object_id = OBJECT_ID(&lt;span&gt;'TEST'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但是 sys.identity_columns是一个系统视图，它的数据来自sys.syscolpars，而视图的字段last_value的值是通过内置函数IdentityProperty计算出来的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;51.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;98&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; QUOTED_IDENTIFIER &lt;span&gt;ON&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; ANSI_NULLS &lt;span&gt;ON&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;VIEW&lt;/span&gt; sys.identity_columns &lt;span&gt;AS&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;SELECT&lt;/span&gt; object_id = id,
&lt;/pre&gt;
&lt;pre&gt;
        name = name,
&lt;/pre&gt;
&lt;pre&gt;
        column_id = colid,
&lt;/pre&gt;
&lt;pre&gt;
        system_type_id = xtype,
&lt;/pre&gt;
&lt;pre&gt;
        user_type_id = utype,
&lt;/pre&gt;
&lt;pre&gt;
        max_length = length,
&lt;/pre&gt;
&lt;pre&gt;
        &lt;span&gt;precision&lt;/span&gt; = prec,
&lt;/pre&gt;
&lt;pre&gt;
        scale = scale,
&lt;/pre&gt;
&lt;pre&gt;
        collation_name = &lt;span&gt;convert&lt;/span&gt;(sysname,CollationPropertyFromId(collationid,&lt;span&gt;'name'&lt;/span&gt;)),
&lt;/pre&gt;
&lt;pre&gt;
        is_nullable = sysconv(&lt;span&gt;bit&lt;/span&gt;, 1 - (status &amp;amp; 1)),     -- CPM_NOTNULL
&lt;/pre&gt;
&lt;pre&gt;
        is_ansi_padded = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 2),     -- CPM_NOTRIM
&lt;/pre&gt;
&lt;pre&gt;
        is_rowguidcol = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 8),     -- CPM_ROWGUIDCOL
&lt;/pre&gt;
&lt;pre&gt;
        is_identity = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 4),         -- CPM_IDENTCOL
&lt;/pre&gt;
&lt;pre&gt;
        is_filestream = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 32),     -- CPM_FILESTREAM
&lt;/pre&gt;
&lt;pre&gt;
        is_replicated = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 0x20000),     -- CPM_REPLICAT
&lt;/pre&gt;
&lt;pre&gt;
        is_non_sql_subscribed = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 0x40000),     -- CPM_NONSQSSUB
&lt;/pre&gt;
&lt;pre&gt;
        is_merge_published = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 0x80000),         -- CPM_MERGEREPL
&lt;/pre&gt;
&lt;pre&gt;
        is_dts_replicated = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 0x100000),         -- CPM_REPLDTS
&lt;/pre&gt;
&lt;pre&gt;
        is_xml_document = sysconv(&lt;span&gt;bit&lt;/span&gt;, 0),
&lt;/pre&gt;
&lt;pre&gt;
        xml_collection_id = sysconv(&lt;span&gt;int&lt;/span&gt;, 0),
&lt;/pre&gt;
&lt;pre&gt;
        default_object_id = sysconv(&lt;span&gt;int&lt;/span&gt;, 0),
&lt;/pre&gt;
&lt;pre&gt;
        rule_object_id = sysconv(&lt;span&gt;int&lt;/span&gt;, 0),
&lt;/pre&gt;
&lt;pre&gt;
        seed_value = IdentityProperty(id, &lt;span&gt;'SeedValue'&lt;/span&gt;),
&lt;/pre&gt;
&lt;pre&gt;
        increment_value = IdentityProperty(id, &lt;span&gt;'IncrementValue'&lt;/span&gt;),
&lt;/pre&gt;
&lt;pre&gt;
        last_value = IdentityProperty(id, &lt;span&gt;'LastValue'&lt;/span&gt;),
&lt;/pre&gt;
&lt;pre&gt;
        is_not_for_replication = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 0x10000),    -- CPM_ID_REPL
&lt;/pre&gt;
&lt;pre&gt;
        is_computed = sysconv(&lt;span&gt;bit&lt;/span&gt;, status &amp;amp; 16),            -- CPM_COMPUTED                
&lt;/pre&gt;
&lt;pre&gt;
        sysconv(&lt;span&gt;bit&lt;/span&gt;, 0) &lt;span&gt;as&lt;/span&gt; is_sparse,
&lt;/pre&gt;
&lt;pre&gt;
        sysconv(&lt;span&gt;bit&lt;/span&gt;, 0) &lt;span&gt;as&lt;/span&gt; is_column_set
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;FROM&lt;/span&gt; sys.syscolpars
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;WHERE&lt;/span&gt; number = 0    -- SOC_COLUMN
&lt;/pre&gt;
&lt;pre&gt;
        &lt;span&gt;AND&lt;/span&gt; (status &amp;amp; 4) = 4     -- CPM_IDENTCOL
&lt;/pre&gt;
&lt;pre&gt;
        &lt;span&gt;AND&lt;/span&gt; has_access(&lt;span&gt;'CO'&lt;/span&gt;, id) = 1
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
GO
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;无法获取系统内置函数（built-in function）的定义，所以无法进一步分析标识列是如何保存last_value的，但是个人猜测可能跟系统基表&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;sys&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;syscolpars&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的&lt;span lang=&quot;X-NONE&quot;&gt;idtval&lt;/span&gt;字段有关系。&lt;span lang=&quot;X-NONE&quot;&gt;DAC&lt;/span&gt;模式下查询跟踪，你会发现标识列&lt;span lang=&quot;X-NONE&quot;&gt;ID&lt;/span&gt;变化后，&lt;span lang=&quot;X-NONE&quot;&gt;idtval&lt;/span&gt;字段的值也变化了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082846572-1770667820.png&quot;&gt;&lt;img title=&quot;clip_image006&quot; border=&quot;0&quot; alt=&quot;clip_image006&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082847074-231280591.png&quot; width=&quot;702&quot; height=&quot;241&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;新建三个表，标识列的自增值分别为1、2、3&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;11&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; test1(id &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(1,1), name &lt;span&gt;VARCHAR&lt;/span&gt;(10))
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; test2(id &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(1,2), name &lt;span&gt;VARCHAR&lt;/span&gt;(10))
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; test3(id &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(1,3), name &lt;span&gt;VARCHAR&lt;/span&gt;(10))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082847553-1351940028.png&quot;&gt;&lt;img title=&quot;image&quot; border=&quot;0&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200903082848048-1047229313.png&quot; width=&quot;802&quot; height=&quot;247&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;8：TRUNCATE表后，标识列的当前值会变为1&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;9：与标识列相关的系统函数的区别。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;IDENT_CURRENT&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;'dbo.TEST_TRAN'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;IDENT_INCR&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;'dbo.TEST_TRAN'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;IDENT_SEED&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;'dbo.TEST_TRAN'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SCOPE_IDENTITY&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;@@IDENTITY&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;IDENT_CURRENT&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;类似于&lt;span lang=&quot;X-NONE&quot;&gt;SQL Server 2000 (8.x)&lt;/span&gt;的标识函数 &lt;span lang=&quot;X-NONE&quot;&gt;SCOPE_IDENTITY&lt;/span&gt; 和 &lt;span lang=&quot;X-NONE&quot;&gt;@@IDENTITY&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;这三个函数都返回最后生成的标识值。&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;但是，上述每个函数中定义的&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的作用域和会话有所不同&lt;span lang=&quot;X-NONE&quot;&gt;**&lt;/span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;·&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;IDENT_CURRENT&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;返回为某个会话和用域中的指定表生成的最新标识值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;·&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;@@IDENTITY&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;返回为跨所有作用域的当前会话中的任何表生成的最后一个标识值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;·&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;SCOPE_IDENTITY&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;返回为当前会话和当前作用域中的某个表生成的最新标识值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果 &lt;span lang=&quot;X-NONE&quot;&gt;IDENT_CURRENT&lt;/span&gt; 值为 &lt;span lang=&quot;X-NONE&quot;&gt;NULL&lt;/span&gt;（因为表从未包含行或已被截断），&lt;span lang=&quot;X-NONE&quot;&gt;IDENT_CURRENT&lt;/span&gt; 函数将返回种子值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/t-sql/statements/create-table-transact-sql-identity-property?view=sql-server-ver15&quot;&gt;&lt;span&gt;&lt;span&gt;https://docs.microsoft.com/zh-cn/sql/t-sql/statements/create-table-transact-sql-identity-property?view=sql-server-ver15&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;a href=&quot;https://www.dfarber.com/computer-consulting-blog/articles/how-to-solve-identity-problem-in-sql-2012/&quot;&gt;&lt;span&gt;&lt;span&gt;https://www.dfarber.com/computer-consulting-blog/articles/how-to-solve-identity-problem-in-sql-2012/&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://www.codeproject.com/Tips/668042/SQL-Server-2012-Auto-Identity-Column-Value-Jump-Is&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Thu, 03 Sep 2020 00:29:00 +0000</pubDate>
<dc:creator>潇湘隐者</dc:creator>
<og:description>1：每个表只能创建一个标识列。 如下测试所示，如果表中有一个标识列，新增一个标识列就会遇到错误“Multiple identity columns specified for table &amp;#39;T</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kerrycode/p/13605564.html</dc:identifier>
</item>
<item>
<title>微信小程序事件绑定 - BWH_Steven</title>
<link>http://www.cnblogs.com/ideal-20/p/13605526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ideal-20/p/13605526.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC9lNmQxZjc1NjlmOTY0Yjk2OGRlNWE0YjE3ZDI1MDU2Yn50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;一-给出代码&quot;&gt;(一) 给出代码&lt;/h2&gt;
&lt;p&gt;我们直接通过一个实例来引入我们想要讲解的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;input type=&quot;text&quot; bindinput=&quot;handleInput&quot; /&amp;gt;
&amp;lt;button bindtap=&quot;handletap&quot; data-operation=&quot;{{1}}&quot;&amp;gt;+&amp;lt;/button&amp;gt;
&amp;lt;button bindtap=&quot;handletap&quot; data-operation=&quot;{{-1}}&quot;&amp;gt;-&amp;lt;/button&amp;gt;

&amp;lt;view&amp;gt;你输入的是：{{number}}&amp;lt;/view&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码就四行，首先是一个 input 输入框，目的是用来输入一些值，同时下面标签就会显示，接着是两个 button 用来分别执行 +1 或者 -1 的操作，最后一个 view 标签就是为了 进行数据输入或变化的回显&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;Page({
  data: {
    number:0
  },
  handleInput(e){
    this.setData({
      number:e.detail.value
    })
  },
  handletap(e){
    const operation = e.currentTarget.dataset.operation
    this.setData({
      number:this.data.number + operation
      // number:this.data.number * 1 + e.currentTarget.dataset.operation
    })
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里给出的就是对应的 js 代码，涉及到了对于输入以及 +1 或者 -1 操作的一个具体逻辑处理，核心就是围绕 data 中定义的 number 变量进行处理（具体逻辑接着会提到），结合前面的 wxml 代码分析一下：&lt;/p&gt;
&lt;h2 id=&quot;二-分析代码&quot;&gt;(二) 分析代码&lt;/h2&gt;
&lt;p&gt;分析标签中属性中的部分：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bindinput=&quot;handleInput&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bindtap=&quot;handletap&quot; data-operation=&quot;{{-1}}&quot;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;绑定事件的关键字是 &lt;code&gt;bind&lt;/code&gt; 例如上面用到的 &lt;code&gt;bindinput&lt;/code&gt; 和 &lt;code&gt;bindtap&lt;/code&gt; 就是分别对于输入和点击事件的一个绑定&lt;/li&gt;
&lt;li&gt;而后面的一个名称例如 handleInput 就是自定义的事件名称，我们在 js 中书写方法也是与这个后面的名称相对应&lt;/li&gt;
&lt;li&gt;注：绑定关键字为 bind 仅针对此例，并非只是 bind&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;补充几个 input 中相对常用的事件绑定属性&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;bindinput&lt;/td&gt;
&lt;td&gt;eventhandle&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;键盘输入时触发，event.detail = {value, cursor, keyCode}，keyCode 为键值，2.1.0 起支持，处理函数可以直接 return 一个字符串，将替换输入框的内容。&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;bindfocus&lt;/td&gt;
&lt;td&gt;eventhandle&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;输入框聚焦时触发，event.detail = { value, height }，height 为键盘高度，在基础库 1.9.90 起支持&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bindblur&lt;/td&gt;
&lt;td&gt;eventhandle&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;输入框失去焦点时触发，event.detail = {value: value}&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果想要获取到输入框的值，通过时间源对象来获取 e.detail.value&lt;/p&gt;
&lt;h3 id=&quot;1-js-中赋值问题&quot;&gt;(1) JS 中赋值问题&lt;/h3&gt;
&lt;p&gt;输入框中输入的值赋值给 data 中的 number，如果按惯性思维直接赋值是有问题的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;this.setData({
        number:e.detail.value
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-js-中按钮传参问题&quot;&gt;(2) JS 中按钮传参问题&lt;/h3&gt;
&lt;p&gt;添加按钮点击事件：关键字是 &lt;code&gt;bindtap&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们按钮想要达到的目的是，点击按钮进行 number 的 +1 或者 -1 ，通过根据我们上面的 js 代码可以看出，这里所采用实现的方式是根据页面属性中传来的参数，进行相加，例如 number + 1 或者 number + (-1) 达到加减效果&lt;/p&gt;
&lt;p&gt;但是，直接传参是有问题的！！！只能通过属性赋值&lt;/p&gt;
&lt;p&gt;正解：&lt;code&gt;bindtap=&quot;handletap&quot; data-operation=&quot;{{-1}}&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-忘记想要的值对应在哪里&quot;&gt;(3) 忘记想要的值对应在哪里&lt;/h3&gt;
&lt;p&gt;说明：如果记不住例如：e.detail.value、e.currentTarget.dataset.operation 则可以使用如下的方式，先把事件打印出来&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;handleInput(e){
    console.log(e);
},
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在找到对应的层级&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC9iNTRiODVmYmU3ZmY0YzFhYmI4NGRmNDI2M2FjMDk5YX50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;一-分类&quot;&gt;(一) 分类&lt;/h2&gt;
&lt;p&gt;我们上面的例子使用了 bind 这个事件绑定关键字，但是它会发生冒泡事件&lt;/p&gt;
&lt;p&gt;我们还有一些别的选择，我们下面在 (3) (4) 中会一个一个进行分析&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;bind&lt;/strong&gt;：普通绑定（会发生冒泡事件）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;catch&lt;/strong&gt;：可以阻止事件冒泡&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;capture-bind&lt;/strong&gt;： 捕获阶段绑定（后面的捕获流程和冒泡流程还会继续执行）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;capture-catch&lt;/strong&gt;：中断捕获阶段和取消冒泡阶段，在捕获阶段阻止事件的传递&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二-冒泡事件列表&quot;&gt;(二) 冒泡事件列表&lt;/h2&gt;
&lt;p&gt;在分析前，我们还要补充一个点，那就是 WXML 的冒泡事件列表：&lt;/p&gt;
&lt;p&gt;我们起码现在知道了 bind 和 catch 的作用，但是正例如我们上面用到的 bindinput 或者 bindtap ，bind 后面的内容又是什么呢？是固定的还是自定义的呢？这一段我直接贴一段官网的文档说明&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;触发条件&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.3685534591195&quot;&gt;&lt;tr&gt;&lt;td&gt;touchstart&lt;/td&gt;
&lt;td&gt;手指触摸动作开始&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;touchmove&lt;/td&gt;
&lt;td&gt;手指触摸后移动&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;touchcancel&lt;/td&gt;
&lt;td&gt;手指触摸动作被打断，如来电提醒，弹窗&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;touchend&lt;/td&gt;
&lt;td&gt;手指触摸动作结束&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tap&lt;/td&gt;
&lt;td&gt;手指触摸后马上离开&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.8936170212766&quot;&gt;&lt;td&gt;longpress&lt;/td&gt;
&lt;td&gt;手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html&quot;&gt;1.5.0&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;longtap&lt;/td&gt;
&lt;td&gt;手指触摸后，超过350ms再离开（推荐使用longpress事件代替）&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;transitionend&lt;/td&gt;
&lt;td&gt;会在 WXSS transition 或 wx.createAnimation 动画结束后触发&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;animationstart&lt;/td&gt;
&lt;td&gt;会在一个 WXSS animation 动画开始时触发&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;animationiteration&lt;/td&gt;
&lt;td&gt;会在一个 WXSS animation 一次迭代结束时触发&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;animationend&lt;/td&gt;
&lt;td&gt;会在一个 WXSS animation 动画完成时触发&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.8518518518519&quot;&gt;&lt;td&gt;touchforcechange&lt;/td&gt;
&lt;td&gt;在支持 3D Touch 的 iPhone 设备，重按时会触发&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html&quot;&gt;1.9.90&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 form 的submit事件，input 的input事件，scroll-view 的scroll事件，(详见各个组件)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看完上面的表格，应该就比较清楚了，正因为我们很多事件都是通过手机点一下某个组件等进行，所以 tap 是比较常用的&lt;/p&gt;
&lt;h2 id=&quot;三--bind-和-catch&quot;&gt;(三) bind 和 catch&lt;/h2&gt;
&lt;p&gt;说明：代码在下面自取&lt;/p&gt;
&lt;h3 id=&quot;1-bind&quot;&gt;(1) bind&lt;/h3&gt;
&lt;p&gt;前面我们提到了，使用 bind 会发生冒泡事件，我们来模拟一下&lt;/p&gt;
&lt;p&gt;首先我们写了三个嵌套的 view 标签，然后接着使用 bindtap 进行事件绑定，进行一个基本的打印逻辑，看看会有什么情况发生&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC9hY2Y5YTIwZmU0ODY0MWU2YjczMjhmNDM3N2Y0MThkYX50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当点击中间层后，首先执行了中间层的事件效果，但是最外层的事件效果也被执行了，这也就是冒泡事件发生了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC85ZTE5OWQ3N2YwNjI0NDBiYjFjODNlYzI4NjAxOTFjYn50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;冒泡事件&lt;/strong&gt;：当一个组件上的事件被触发后，该事件会向父节点传递&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非冒泡事件&lt;/strong&gt;：当一个组件上的事件被触发后，该事件不会向父节点传递&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3-catch&quot;&gt;(3) catch&lt;/h3&gt;
&lt;p&gt;这一次我们仍然点击中间这一层，如果在上面的基础上，我们将中间层的事件绑定使用 catch，而不是 bind ，结果会是怎样呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC84NDM1MDYxNTk0YjE0YjcyYjI3ODQyM2ZkYzJjMDY3ZH50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果就是冒泡事件被阻止了，点击后只显示中间层的事件&lt;/p&gt;
&lt;h2 id=&quot;四--capture-bind-和-capture-catch&quot;&gt;(四) capture-bind 和 capture-catch&lt;/h2&gt;
&lt;p&gt;前面提及到这两个内容的时候，我们提到了一个概念也就是事件的捕获阶段，简单说一下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;自基础库版本 1.5.0 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-capture-bindtap&quot;&gt;(1) capture-bind:tap&lt;/h3&gt;
&lt;p&gt;依旧是刚才的例子，将三层的属性都修改为 &lt;code&gt;capture-bind:tap=&quot;handleTap1&quot;&lt;/code&gt; 这种形式的&lt;/p&gt;
&lt;p&gt;当我们点击最里层的内容时，执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC9jMGM4MGEzNjI0NjM0MTBhYjA0ZjE0YWU5NTlhOTIzNX50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即它与包裹它的两层都执行了，且是从外至内&lt;/p&gt;
&lt;h3 id=&quot;2-capture-catchtap&quot;&gt;(2) capture-catch:tap&lt;/h3&gt;
&lt;p&gt;将三层属性修改为 &lt;code&gt;capture-catch:tap=&quot;handleTap1&quot;&lt;/code&gt; 这种形式，点击任意一层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC8xYTcwMDZiMDI3YTU0ODVmOWU4Njc3MTZjYzdhYjA2N350cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果都是只执行最外层的&lt;/p&gt;
&lt;h2 id=&quot;五-简单总结&quot;&gt;(五) 简单总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;bind&lt;/strong&gt;：点击会触发它和包裹它的所有事件，且从内向外执行（冒泡事件）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;catch&lt;/strong&gt;：点击哪个就触发哪个，独立的（阻止冒泡事件）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;capture-bind&lt;/strong&gt;： 点击会触发它和包裹它的所有事件，且从外向内执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;capture-catch&lt;/strong&gt;：如何点击都只会触发最外层的事件&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;六-代码提取&quot;&gt;(六) 代码提取&lt;/h2&gt;
&lt;p&gt;代码给出的是 capture-bind:tap 的情况， bindtap 或者 catchtap 以及 capture-catch 只需要将 capture-bind:tap 替换就行了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wxml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;view class=&quot;outer&quot; capture-bind:tap=&quot;handleTap1&quot;&amp;gt;
  这是最外层
  &amp;lt;view class=&quot;middle&quot; capture-bind:tap=&quot;handleTap2&quot;&amp;gt;
    这是中间层
    &amp;lt;view class=&quot;inner&quot; capture-bind:tap=&quot;handleTap3&quot;&amp;gt;
      这是最里层
    &amp;lt;/view&amp;gt;
  &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;wxss&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.outer {
    text-align: center;
    background-color: red;
    height: 300rpx;
}
.middle {
    background-color: orange;
    width: 60%;
    height: 200rpx;
}
.inner {
    background-color: yellow;
    width: 60%;
    height: 100rpx;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果文章中有什么不足，欢迎大家留言交流，感谢朋友们的支持！&lt;/p&gt;
&lt;p&gt;如果能帮到你的话，那就来关注我吧！如果您更喜欢微信文章的阅读方式，可以关注我的公众号&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在这里的我们素不相识，却都在为了自己的梦而努力 ❤&lt;/p&gt;
&lt;p&gt;一个坚持推送原创开发技术文章的公众号：理想二旬不止&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC9iNGU4ZDIzNTk2NzA0NGY4YmQ3NzY3ZTZhNTQ3OTVmYX50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;e&lt;/p&gt;
</description>
<pubDate>Thu, 03 Sep 2020 00:09:00 +0000</pubDate>
<dc:creator>BWH_Steven</dc:creator>
<og:description>微信小程序事件绑定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ideal-20/p/13605526.html</dc:identifier>
</item>
<item>
<title>09.redis 哨兵主备切换时数据丢失的解决方案 - MrMirror</title>
<link>http://www.cnblogs.com/mrmirror/p/13605507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrmirror/p/13605507.html</guid>
<description>&lt;h2 id=&quot;一、两种数据丢失的情况&quot;&gt;一、两种数据丢失的情况&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;1-异步复制导致的数据丢失&quot;&gt;1. 异步复制导致的数据丢失&lt;/h3&gt;
&lt;p&gt;  因为master-&amp;gt;slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了&lt;/p&gt;
&lt;h3 id=&quot;2-脑裂导致的数据丢失&quot;&gt;2. 脑裂导致的数据丢失&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;脑裂是什么&lt;/strong&gt;&lt;br/&gt;  某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着。此时哨兵可能就会认为master宕机了，然后开启选举将其他slave切换成了master。集群里就会有两个master，也就是所谓的脑裂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引发的问题&lt;/strong&gt;：&lt;br/&gt;  此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了。因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据&lt;/p&gt;
&lt;p&gt; &lt;br/&gt; &lt;/p&gt;
&lt;h2 id=&quot;二、解决方案&quot;&gt;二、解决方案&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;1-redis层面：通过配置控制同步时间&quot;&gt;1. redis层面：通过配置控制同步时间&lt;/h3&gt;
&lt;p&gt;redis.conf配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;min-slaves-to-write 1
min-slaves-max-lag 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;含义：&quot;&gt;含义：&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;要求至少有1个slave，数据复制和同步延迟不能超过10秒&lt;br/&gt;如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么master就会拒绝接收任何请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;作用&quot;&gt;作用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;减少异步复制的数据丢失&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置min-slaves-max-lag为10s后，根据目前master-&amp;gt;slave的复制速度，如果数据同步完成所需要时间超过10s，就会认为master未来宕机后损失的数据会很多，master就拒绝写入新请求。&lt;br/&gt;这样就能将master和slave数据差控制在10s内，即使master宕机也只是这未复制的10s数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;减少脑裂的数据丢失&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝写入新请求。这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失。&lt;br/&gt;因此在脑裂场景下，最多就丢失10秒的数据&lt;/p&gt;

&lt;h3 id=&quot;2-生产者层面：做降级限流&quot;&gt;2. 生产者层面：做降级限流&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;降级&lt;/strong&gt;：&lt;br/&gt;  先讲消息写到本地磁盘中或者放到临时消息队列中，每隔10分钟去本地磁盘或者队列里取来尝试重新发给master&lt;br/&gt;&lt;strong&gt;限流&lt;/strong&gt;：&lt;br/&gt;  在网关减慢请求涌入的速度。&lt;/p&gt;
</description>
<pubDate>Wed, 02 Sep 2020 23:52:00 +0000</pubDate>
<dc:creator>MrMirror</dc:creator>
<og:description>一、两种数据丢失的情况 1. 异步复制导致的数据丢失 因为master-&amp;amp;gt;slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrmirror/p/13605507.html</dc:identifier>
</item>
<item>
<title>5000字 | 24张图带你彻底理解21种并发锁 - 悟空聊架构</title>
<link>http://www.cnblogs.com/jackson0714/p/lock.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/lock.html</guid>
<description>&lt;p&gt;本篇是我在博客园的第201篇博客，用图解的方式分析了Java中的21种锁。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;270.14828524424&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200903/YBxyWIaptJEu.png?imageslim&quot; alt=&quot;封面&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本篇主要内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200902/Vofn1VFQBdLv.png?imageslim&quot; alt=&quot;本篇主要内容&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本篇文章已收纳到我的&lt;a href=&quot;https://www.cnblogs.com/jackson0714/p/www.jayh.club&quot;&gt;Java在线文档&lt;/a&gt;、 &lt;a href=&quot;https://github.com/Jackson0714/PassJava-Learning&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的&lt;a href=&quot;https://github.com/Jackson0714&quot;&gt;SpringCloud实战项目&lt;/a&gt;持续更新中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;帮你总结好的锁：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;锁名称&lt;/th&gt;
&lt;th&gt;应用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;乐观锁&lt;/td&gt;
&lt;td&gt;CAS&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;悲观锁&lt;/td&gt;
&lt;td&gt;synchronized、vector、hashtable&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;自旋锁&lt;/td&gt;
&lt;td&gt;CAS&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;可重入锁&lt;/td&gt;
&lt;td&gt;synchronized、Reentrantlock、Lock&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;读写锁&lt;/td&gt;
&lt;td&gt;ReentrantReadWriteLock，CopyOnWriteArrayList、CopyOnWriteArraySet&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;公平锁&lt;/td&gt;
&lt;td&gt;Reentrantlock(true)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;非公平锁&lt;/td&gt;
&lt;td&gt;synchronized、reentrantlock(false)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;共享锁&lt;/td&gt;
&lt;td&gt;ReentrantReadWriteLock中读锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;独占锁&lt;/td&gt;
&lt;td&gt;synchronized、vector、hashtable、ReentrantReadWriteLock中写锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;重量级锁&lt;/td&gt;
&lt;td&gt;synchronized&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;轻量级锁&lt;/td&gt;
&lt;td&gt;锁优化技术&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;偏向锁&lt;/td&gt;
&lt;td&gt;锁优化技术&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;分段锁&lt;/td&gt;
&lt;td&gt;concurrentHashMap&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;互斥锁&lt;/td&gt;
&lt;td&gt;synchronized&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;同步锁&lt;/td&gt;
&lt;td&gt;synchronized&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;死锁&lt;/td&gt;
&lt;td&gt;相互请求对方的资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;锁粗化&lt;/td&gt;
&lt;td&gt;锁优化技术&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;锁消除&lt;/td&gt;
&lt;td&gt;锁优化技术&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;1、乐观锁&quot;&gt;1、乐观锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200830/Wyc6mrRznpzC.png?imageslim&quot; alt=&quot;乐观锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;乐观锁&lt;/code&gt;是一种乐观思想&lt;/strong&gt;，假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前 与期望值是否相同，如果相同则进行更新（更新期间加锁，保证是原子性的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java中的&lt;code&gt;乐观锁&lt;/code&gt;：&lt;/strong&gt; &lt;code&gt;CAS&lt;/code&gt;，比较并替换，比较当前值（主内存中的值），与预期值（当前线程中的值，主内存中值的一份拷贝）是否一样，一样则更新，否则继续进行CAS操作。&lt;/p&gt;
&lt;p&gt;如上图所示，可以同时进行读操作，读的时候其他线程不能进行写操作。&lt;/p&gt;
&lt;h2 id=&quot;2、悲观锁&quot;&gt;2、悲观锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200830/YUJ07gduGwuo.png?imageslim&quot; alt=&quot;悲观锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;悲观锁&lt;/code&gt;是一种悲观思想&lt;/strong&gt;，即认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java中的&lt;code&gt;悲观锁&lt;/code&gt;：&lt;/strong&gt; &lt;code&gt;synchronized&lt;/code&gt;修饰的方法和方法块、&lt;code&gt;ReentrantLock&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如上图所示，只能有一个线程进行读操作或者写操作，其他线程的读写操作均不能进行。&lt;/p&gt;
&lt;h2 id=&quot;3、自旋锁&quot;&gt;3、自旋锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200830/mSX77A4GvB92.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;自旋锁&lt;/code&gt;是一种技术：&lt;/strong&gt; 为了让线程等待，我们只须让线程执行一个忙循环（自旋）。&lt;/p&gt;
&lt;p&gt;现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;自旋锁&lt;/code&gt;的优点：&lt;/strong&gt; 避免了线程切换的开销。挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;自旋锁&lt;/code&gt;的缺点：&lt;/strong&gt; 占用处理器的时间，如果占用的时间很长，会白白消耗处理器资源，而不会做任何有价值的工作，带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;自旋&lt;/code&gt;次数默认值：&lt;/strong&gt;10次，可以使用参数-XX:PreBlockSpin来自行更改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自适应&lt;code&gt;自旋&lt;/code&gt;：&lt;/strong&gt; 自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越精准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java中的&lt;code&gt;自旋锁&lt;/code&gt;：&lt;/strong&gt; CAS操作中的比较操作失败后的自旋等待。&lt;/p&gt;
&lt;h2 id=&quot;4、可重入锁（递归锁）&quot;&gt;4、可重入锁（递归锁）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/133828291.png&quot; alt=&quot;可重入锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;可重入锁&lt;/code&gt;是一种技术：&lt;/strong&gt; 任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;可重入锁&lt;/code&gt;的原理：&lt;/strong&gt; 通过组合自定义同步器来实现锁的获取与释放。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;再次获取锁：识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。获取锁后，进行计数自增，&lt;/li&gt;
&lt;li&gt;释放锁：释放锁时，进行计数自减。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Java中的&lt;code&gt;可重入锁&lt;/code&gt;：&lt;/strong&gt; ReentrantLock、synchronized修饰的方法或代码段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;可重入锁&lt;/code&gt;的作用：&lt;/strong&gt; 避免死锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试题1：&lt;/strong&gt; 可重入锁如果加了两把，但是只释放了一把会出现什么问题？&lt;/p&gt;
&lt;p&gt;答：程序卡死，线程不能出来，也就是说我们申请了几把锁，就需要释放几把锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试题2：&lt;/strong&gt; 如果只加了一把锁，释放两次会出现什么问题？&lt;/p&gt;
&lt;p&gt;答：会报错，java.lang.IllegalMonitorStateException。&lt;/p&gt;
&lt;h2 id=&quot;5、读写锁&quot;&gt;5、读写锁&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;读写锁&lt;/code&gt;是一种技术：&lt;/strong&gt; 通过&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;类来实现。为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。 读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读锁：&lt;/strong&gt; 允许多个线程获取读锁，同时访问同一个资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/134522461.png&quot; alt=&quot;读锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写锁：&lt;/strong&gt; 只允许一个线程获取写锁，不允许同时访问同一个资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/134543264.png&quot; alt=&quot;写锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* 创建一个读写锁
* 它是一个读写融为一体的锁，在使用的时候，需要转换
*/
private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取读锁和释放读锁&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 获取读锁
rwLock.readLock().lock();

// 释放读锁
rwLock.readLock().unlock();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取写锁和释放写锁&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 创建一个写锁
rwLock.writeLock().lock();

// 写锁 释放
rwLock.writeLock().unlock();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java中的读写锁：&lt;/strong&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;6、公平锁&quot;&gt;6、公平锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/142320333.png&quot; alt=&quot;公平锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;公平锁&lt;/code&gt;是一种思想：&lt;/strong&gt; 多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不为空，则加入到等待队列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。&lt;/p&gt;
&lt;h2 id=&quot;7、非公平锁&quot;&gt;7、非公平锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/142226223.png&quot; alt=&quot;非公平锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;非公平锁&lt;/code&gt;是一种思想：&lt;/strong&gt; 线程尝试获取锁，如果获取不到，则再采用公平锁的方式。多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的线程优先获取锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 非公平锁的性能高于公平锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 有可能造成线程饥饿（某个线程很长一段时间获取不到锁）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java中的非公平锁：&lt;/strong&gt;synchronized是非公平锁，ReentrantLock通过构造函数指定该锁是公平的还是非公平的，默认是非公平的。&lt;/p&gt;
&lt;h2 id=&quot;8、共享锁&quot;&gt;8、共享锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/143841487.png&quot; alt=&quot;共享锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;共享锁&lt;/code&gt;是一种思想：&lt;/strong&gt; 可以有多个线程获取读锁，以共享的方式持有锁。和乐观锁、读写锁同义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java中用到的共享锁：&lt;/strong&gt; &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;9、独占锁&quot;&gt;9、独占锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/143937306.png&quot; alt=&quot;独占锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;独占锁&lt;/code&gt;是一种思想：&lt;/strong&gt; 只能有一个线程获取锁，以独占的方式持有锁。和悲观锁、互斥锁同义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java中用到的独占锁：&lt;/strong&gt; synchronized，ReentrantLock&lt;/p&gt;
&lt;h2 id=&quot;10、重量级锁&quot;&gt;10、重量级锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/151155360.png&quot; alt=&quot;重量级锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重量级锁是一种称谓：&lt;/strong&gt; &lt;code&gt;synchronized&lt;/code&gt;是通过对象内部的一个叫做监视器锁（&lt;code&gt;monitor&lt;/code&gt;）来实现的，监视器锁本身依赖底层的操作系统的 &lt;code&gt;Mutex Lock&lt;/code&gt;来实现。操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系统 &lt;code&gt;Mutex Lock&lt;/code&gt;来实现的锁称为重量级锁。为了优化&lt;code&gt;synchonized&lt;/code&gt;，引入了&lt;code&gt;轻量级锁&lt;/code&gt;，&lt;code&gt;偏向锁&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java中的重量级锁：&lt;/strong&gt; synchronized&lt;/p&gt;
&lt;h2 id=&quot;11、轻量级锁&quot;&gt;11、轻量级锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/165155825.png&quot; alt=&quot;轻量级锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;轻量级锁&lt;/code&gt;是JDK6时加入的一种锁优化机制：&lt;/strong&gt; 轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。轻量级是相对于使用操作系统互斥量来实现的重量级锁而言的。轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁将不会有效，必须膨胀为重量级锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 如果没有竞争，通过CAS操作成功避免了使用互斥量的开销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 如果存在竞争，除了互斥量本身的开销外，还额外产生了CAS操作的开销，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。&lt;/p&gt;
&lt;h2 id=&quot;12、偏向锁&quot;&gt;12、偏向锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/165117039.png&quot; alt=&quot;偏向锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;偏向锁&lt;/code&gt;是JDK6时加入的一种锁优化机制：&lt;/strong&gt; 在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。偏是指偏心，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。&lt;/p&gt;
&lt;h2 id=&quot;13、分段锁&quot;&gt;13、分段锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200831/CuekN2tTsPIl.png?imageslim&quot; alt=&quot;分段锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;分段锁&lt;/code&gt;是一种机制：&lt;/strong&gt; 最好的例子来说明分段锁是ConcurrentHashMap。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConcurrentHashMap原理：&lt;/strong&gt;它内部细分了若干个小的 HashMap，称之为段(Segment)。 默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。如果需要在 ConcurrentHashMap 添加一项key-value，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该key-value应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的key-value不存放在同一个段中，则线程间可以做到真正的并行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程安全：&lt;/strong&gt;ConcurrentHashMap 是一个 Segment 数组， Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全&lt;/p&gt;
&lt;h2 id=&quot;14、互斥锁&quot;&gt;14、互斥锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200901/KpCUo6O6af43.png?imageslim&quot; alt=&quot;互斥锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;互斥锁与悲观锁、独占锁同义，表示某个资源只能被一个线程访问，其他线程不能访问。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读-读互斥&lt;/li&gt;
&lt;li&gt;读-写互斥&lt;/li&gt;
&lt;li&gt;写-读互斥&lt;/li&gt;
&lt;li&gt;写-写互斥&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Java中的同步锁：&lt;/strong&gt; synchronized&lt;/p&gt;
&lt;h2 id=&quot;15、同步锁&quot;&gt;15、同步锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200902/170626659.png&quot; alt=&quot;同步锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步锁与互斥锁同义，表示并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java中的同步锁：&lt;/strong&gt; synchronized&lt;/p&gt;
&lt;h2 id=&quot;16、死锁&quot;&gt;16、死锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200901/OqeFr9aRRHPb.png?imageslim&quot; alt=&quot;死锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;死锁是一种现象：&lt;/strong&gt;如线程A持有资源x，线程B持有资源y，线程A等待线程B释放资源y，线程B等待线程A释放资源x，两个线程都不释放自己持有的资源，则两个线程都获取不到对方的资源，就会造成死锁。&lt;/p&gt;
&lt;p&gt;Java中的死锁不能自行打破，所以线程死锁后，线程不能进行响应。所以一定要注意程序的并发场景，避免造成死锁。&lt;/p&gt;
&lt;h2 id=&quot;17、锁粗化&quot;&gt;17、锁粗化&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200902/1cFknzpJLTEu.png?imageslim&quot; alt=&quot;锁粗化&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;锁粗化&lt;/code&gt;是一种优化技术：&lt;/strong&gt; 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。&lt;/p&gt;
&lt;h2 id=&quot;18、锁消除&quot;&gt;18、锁消除&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200902/mP6xP3Wadz7y.png?imageslim&quot; alt=&quot;锁消除&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;锁消除&lt;/code&gt;是一种优化技术：&lt;/strong&gt; 就是把锁干掉。当Java虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。&lt;/p&gt;
&lt;p&gt;那如何判断共享数据不会被线程竞争？&lt;/p&gt;
&lt;p&gt;利用&lt;code&gt;逃逸分析技术&lt;/code&gt;：分析对象的作用域，如果对象在A方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。&lt;/p&gt;
&lt;p&gt;在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待，认为它是线程私有的，同步加锁就不需要了。&lt;/p&gt;
&lt;h2 id=&quot;19、synchronized&quot;&gt;19、synchronized&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200902/B07fDP18NBBE.png?imageslim&quot; alt=&quot;synchronized&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是Java中的关键字：用来修饰方法、对象实例。属于独占锁、悲观锁、可重入锁、非公平锁。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1.作用于实例方法时，锁住的是对象的实例(this)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2.当作用于静态方法时，锁住的是 Class类，相当于类的一个全局锁，&lt;br/&gt;会锁所有调用该方法的线程；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;3.synchronized 作用于一个非 NULL的对象实例时，锁住的是所有以该对象为锁的代码块。 它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个对象都有个 monitor 对象， 加锁就是在竞争 monitor 对象，代码块加锁是在代码块前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的。&lt;/p&gt;
&lt;h2 id=&quot;20、lock和synchronized的区别&quot;&gt;20、Lock和synchronized的区别&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200829/qSlM4sQyhCTs.png?imageslim&quot; alt=&quot;自动挡和手动挡的区别&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Lock&lt;/code&gt;：&lt;/strong&gt; 是Java中的接口，可重入锁、悲观锁、独占锁、互斥锁、同步锁。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.Lock需要手动获取锁和释放锁。就好比自动挡和手动挡的区别&lt;/li&gt;
&lt;li&gt;2.Lock 是一个接口，而 synchronized 是 Java 中的关键字， synchronized 是内置的语言实现。&lt;/li&gt;
&lt;li&gt;3.synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。&lt;/li&gt;
&lt;li&gt;4.Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。&lt;/li&gt;
&lt;li&gt;5.通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。&lt;/li&gt;
&lt;li&gt;6.Lock 可以通过实现读写锁提高多个线程进行读操作的效率。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;synchronized的优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;足够清晰简单，只需要基础的同步功能时，用synchronized。&lt;/li&gt;
&lt;li&gt;Lock应该确保在finally块中释放锁。如果使用synchronized，JVM确保即使出现异常，锁也能被自动释放。&lt;/li&gt;
&lt;li&gt;使用Lock时，Java虚拟机很难得知哪些锁对象是由特定线程锁持有的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;21、reentrantlock-和synchronized的区别&quot;&gt;21、ReentrantLock 和synchronized的区别&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200902/scLj1SjWvaOO.png?imageslim&quot; alt=&quot;Lock、ReentrantLock、shnchronzied&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;是Java中的类 ：&lt;/strong&gt; 继承了Lock类，可重入锁、悲观锁、独占锁、互斥锁、同步锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;划重点&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相同点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.主要解决共享变量如何安全访问的问题&lt;/li&gt;
&lt;li&gt;2.都是可重入锁，也叫做递归锁，同一线程可以多次获得同一个锁，&lt;/li&gt;
&lt;li&gt;3.保证了线程安全的两大特性：可见性、原子性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;不同点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1.ReentrantLock 就像手动汽车，需要显示的调用lock和unlock方法， synchronized 隐式获得释放锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2.ReentrantLock 可响应中断， synchronized 是不可以响应中断的，ReentrantLock 为处理锁的不可用性提供了更高的灵活性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3.ReentrantLock 是 API 级别的， synchronized 是 JVM 级别的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;4.ReentrantLock 可以实现公平锁、非公平锁，默认非公平锁，synchronized 是非公平锁，且不可更改。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;5.ReentrantLock 通过 Condition 可以绑定多个条件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;彩蛋：&lt;/strong&gt; 讲了那么多锁，都跟阻塞相关，宝宝想听阻塞呀！&lt;/p&gt;
&lt;p&gt;&lt;u&gt;我是悟空，一只努力变强的码农！我要变身超级赛亚人啦！&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200902/101843020.png&quot; alt=&quot;我的资料&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.8539553752536&quot;&gt;
&lt;p&gt;你好，我是&lt;code&gt;悟空哥&lt;/code&gt;，&lt;strong&gt;7年项目开发经验，全栈工程师，开发组长，超喜欢图解编程底层原理&lt;/strong&gt;。正在编写两本PDF，分别是 1、Spring Cloud实战项目（&lt;a href=&quot;http://jayh2018.gitee.io/passjava-learning/#/&quot;&gt;佳必过&lt;/a&gt;），2、Java并发必知必会。我还&lt;code&gt;手写了2个小程序&lt;/code&gt;，Java刷题小程序，PMP刷题小程序，点击我的公众号菜单打开！另外有111本架构师资料以及1000道Java面试题，都整理成了PDF，可以关注公众号 悟空聊架构 回复 &lt;code&gt;悟空&lt;/code&gt; 领取优质资料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200902/inztGHDPxIuc.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转发-&amp;gt;在看-&amp;gt;点赞-&amp;gt;收藏-&amp;gt;评论！！！&lt;/strong&gt;是对我最大的支持！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《Java并发必知必会》系列：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jackson0714/p/java_volatile.html&quot;&gt;1.反制面试官 | 14张原理图 | 再也不怕被问 volatile!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jackson0714/p/CAS.html&quot;&gt;2.程序员深夜惨遭老婆鄙视，原因竟是CAS原理太简单？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jackson0714/p/ABA.html&quot;&gt;3.用积木讲解ABA原理 | 老婆居然又听懂了！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jackson0714/p/thread_safe_collections.html&quot;&gt;4.全网最细 | 21张图带你领略集合的线程不安全&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 02 Sep 2020 22:54:00 +0000</pubDate>
<dc:creator>悟空聊架构</dc:creator>
<og:description>本篇是我在博客园的第201篇博客，用图解的方式分析了Java中的21种锁。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackson0714/p/lock.html</dc:identifier>
</item>
<item>
<title>关于哈希的一切，都在这里了！ - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/13605460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/13605460.html</guid>
<description>&lt;blockquote readability=&quot;4.0625&quot;&gt;
&lt;p&gt;本文收录于专辑：&lt;a href=&quot;http://dwz.win/HjK&quot;&gt;http://dwz.win/HjK&lt;/a&gt;，点击解锁更多数据结构与算法的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是彤哥。&lt;/p&gt;
&lt;p&gt;上一节，我们一起学习了，在Java中如何构建高性能队列，里面牵涉到很多底层的知识，不知道你有Get到多少呢？！&lt;/p&gt;
&lt;p&gt;本节，我想跟着大家一起重新学习下关于哈希的一切——哈希、哈希函数、哈希表。&lt;/p&gt;
&lt;p&gt;这三者有什么样的爱恨情仇？&lt;/p&gt;
&lt;p&gt;为什么Object类中需要有一个hashCode()方法？它跟equals()方法有什么关系？&lt;/p&gt;
&lt;p&gt;如何编写一个高性能的哈希表？&lt;/p&gt;
&lt;p&gt;Java中的HashMap中的红黑树可以使用其它数据结构替换吗？&lt;/p&gt;

&lt;p&gt;Hash，是指把任意长度的输入通过一定的算法变成&lt;strong&gt;固定长度的输出&lt;/strong&gt;的过程，这个输出称作Hash值，或者Hash码，这个算法叫做Hash算法，或者Hash函数，这个过程我们一般就称作Hash，或者计算Hash，Hash翻译为中文有哈希、散列、杂凑等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062330714-1109427952.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然是固定长度的输出，那就意味着输入是无限多的，输出是有限的，必然会出现不同的输入可能会得到相同的输出的情况，所以，Hash算法一般来说也是不可逆的。&lt;/p&gt;
&lt;p&gt;那么，Hash算法有哪些用途呢？&lt;/p&gt;

&lt;p&gt;哈希算法，是一种广义的算法，或者说是一种思想，它没有一个固定的公式，只要满足上面定义的算法，都可以称作Hash算法。&lt;/p&gt;
&lt;p&gt;通常来说，它具有以下用途：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加密密码，比如，使用MD5+盐的方式来加密密码；&lt;/li&gt;
&lt;li&gt;快速查询，比如，哈希表的使用，通过哈希表能够快速查询元素；&lt;/li&gt;
&lt;li&gt;数字签名，比如，系统间调用加上签名，可以防止篡改数据；&lt;/li&gt;
&lt;li&gt;文件检验，比如，下载腾讯游戏的时候通常都有有一个MD5值，安装包下载下来之后计算出来一个MD5值与官方的MD5值进行对比，就可知道下载过程中有没有文件损坏，有没有被篡改等；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，说起Hash算法，或者Hash函数，在Java中，所有对象的父类Object都有一个Hash函数，即hashCode()方法，为什么Object类中需要定义这么一个方法呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;严格来说，Hash算法和Hash函数还是有点区别的，相信你能根据语境进行区分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们来看看JDK源码的注释怎么说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062331578-1990686650.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请看红框的部分，翻译一下大致为：为这个对象返回一个Hash值，它是为了更好地支持哈希表而存在的，比如HashMap。简单点说，这个方法就是给HashMap等哈希表使用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 默认返回的是对象的内部地址
public native int hashCode();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们不得不提起Object类中的另一个方法——equals()。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 默认是直接比较两个对象的地址是否相等
public boolean equals(Object obj) {
    return (this == obj);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hashCode()和equals又有怎样的纠缠呢？&lt;/p&gt;
&lt;p&gt;通常来说，hashCode()可以看作是一种弱比较，回归Hash的本质，将不同的输入映射到固定长度的输出，那么，就会出现以下几种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入相同，输出必然相同；&lt;/li&gt;
&lt;li&gt;输入不同，输出可能相同，也可能不同；&lt;/li&gt;
&lt;li&gt;输出相同，输入可能相同，也可能不同；&lt;/li&gt;
&lt;li&gt;输出不同，输入必然不同；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而equals()是严格比较两个对象是否相等的方法，所以，如果两个对象equals()为true，那么，它们的hashCode()一定要相等，如果不相等会怎样呢？&lt;/p&gt;
&lt;p&gt;如果equals()返回true，而hashCode()不相等，那么，试想将这两个对象作为HashMap的key，它们很大可能会定位到HashMap不同的槽中，此时就会出现一个HashMap中插入了两个相等的对象，这是不允许的，这也是为什么重写了equals()方法一定要重写hashCode()方法的原因。&lt;/p&gt;
&lt;p&gt;比如，String这个类，我们都知道它的equals()方法是比较两个字符串的内容是否相等，而不是两个字符串的地址，下面是它的equals()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，对于下面这两个字符串对象，使用equals()比较它们是相等的，而它们的内存地址并不相同：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String a = new String(&quot;123&quot;);
String b = new String(&quot;123&quot;);
System.out.println(a.equals(b)); // true
System.out.println(a == b); // false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，如果不重写hashCode()方法，那么，a和b将返回不同的hash码，对于我们常常使用String作为HashMap的key将造成巨大的干扰，所以，String重写的hashCode()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int hashCode() {
    int h = hash;
    if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
        char val[] = value;

        for (int i = 0; i &amp;lt; value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个算法也很简单，用公式来表示为：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]。&lt;/p&gt;
&lt;p&gt;好了，既然这里屡次提到哈希表，那我们就来看看哈希表是如何一步步进化的。&lt;/p&gt;

&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;
&lt;p&gt;讲哈希表之前，我们先来看看数据结构的鼻祖——数组。&lt;/p&gt;
&lt;p&gt;数组比较简单，我就不多说了，大家都会都懂，见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062332307-1982483189.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数组的下标一般从0开始，依次往后存储元素，查找指定元素也是一样，只能从头（或从尾）依次查找元素。&lt;/p&gt;
&lt;p&gt;比如，要查找4这个元素，从头开始查找的话需要查找3次。&lt;/p&gt;
&lt;h2 id=&quot;早期的哈希表&quot;&gt;早期的哈希表&lt;/h2&gt;
&lt;p&gt;上面讲了数组的缺点，查找某个元素只能从头或者从尾依次查找元素，直到匹配为止，它的均衡时间复杂是O(n)。&lt;/p&gt;
&lt;p&gt;那么，利用数组有没有什么方法可以快速的查找元素呢？&lt;/p&gt;
&lt;p&gt;聪明的程序员哥哥们想到一种方法，通过哈希函数计算元素的值，用这个值确定元素在数组中的位置，这样时间复杂度就能缩短到O(1)了。&lt;/p&gt;
&lt;p&gt;比如，有5个元素分别为3、5、4、1，把它们放入到数组之前先通过哈希函数计算位置，精确放置，而不是像简单数组那样依次放置元素（基于索引而不是元素值来查找位置）。&lt;/p&gt;
&lt;p&gt;假如，这里申请的数组长度为8，我们可以造这么一个哈希函数为hash(x) = x % 8，那么最后的元素就变成了下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062333027-856324006.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候我们再查找4这个元素，先算一下它的hash值为hash(4) = 4 % 8 = 4，所以直接返回4号位置的元素就可以了。&lt;/p&gt;
&lt;h2 id=&quot;进化的哈希表&quot;&gt;进化的哈希表&lt;/h2&gt;
&lt;p&gt;事情看着挺完美，但是，来了一个元素13，要插入的哈希表中，算了一下它的hash值为hash(13) = 13 % 8 = 5，纳尼，它计算的位置也是5，可是5号已经被人先一步占领了，怎么办呢？&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;哈希冲突&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;为什么会出现哈希冲突呢？&quot;&gt;为什么会出现哈希冲突呢？&lt;/h3&gt;
&lt;p&gt;因为我们申请的数组是有限长度的，把无限的数字映射到有限的数组上早晚会出现冲突，即多个元素映射到同一个位置上。&lt;/p&gt;
&lt;p&gt;好吧，既然出现了哈希冲突，那么我们就要解决它，必须干！&lt;/p&gt;
&lt;p&gt;How to？&lt;/p&gt;
&lt;h3 id=&quot;线性探测法&quot;&gt;线性探测法&lt;/h3&gt;
&lt;p&gt;既然5号位置已经有主了，那我元素13认怂，我往后挪一位，我到6号位置去，这就是线性探测法，当出现冲突的时候依次往后挪直到找到空位置为止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062333753-811420866.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然鹅，又来了个新元素12，算得其hash值为hash(12) = 12 % 8 = 4，What？按照这种方式，要往后移3次到7号位置才有空位置，这就导致了插入元素的效率很低，查找也是一样的道理，先定位的4号位置，发现不是我要找的人，再接着往后移，直到找到7号位置为止。&lt;/p&gt;
&lt;h3 id=&quot;二次探测法&quot;&gt;二次探测法&lt;/h3&gt;
&lt;p&gt;使用线性探测法有个很大的弊端，冲突的元素往往会堆积在一起，比如，12号放到7号位置，再来个14号一样冲突，接着往后再数组结尾了，再从头开始放到0号位置，你会发现冲突的元素有聚集现象，这就很不利于查找了，同样不利于插入新的元素。&lt;/p&gt;
&lt;p&gt;这时候又有聪明的程序员哥哥提出了新的想法——二次探测法，当出现冲突时，我不是往后一位一位这样来找空位置，而是使用原来的hash值加上i的二次方来寻找，i依次从1，2，3...这样，直到找到空位置为止。&lt;/p&gt;
&lt;p&gt;还是以上面的为例，插入12号元素，过程是这样的，本文来源于公主号彤哥读源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062334356-1098418262.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就能很快地找到空位置放置新元素，而且不会出现冲突元素堆积的现象。&lt;/p&gt;
&lt;p&gt;然鹅，又来了新元素20，你瞅瞅放哪？&lt;/p&gt;
&lt;p&gt;发现放哪都放不进去了。&lt;/p&gt;
&lt;p&gt;研究表明，使用二次探测法的哈希表，当放置的元素超过一半时，就会出现新元素找不到位置的情况。&lt;/p&gt;
&lt;p&gt;所以又引出一个新的概念——扩容。&lt;/p&gt;
&lt;h3 id=&quot;什么是扩容？&quot;&gt;什么是扩容？&lt;/h3&gt;
&lt;p&gt;已放置元素达到总容量的x%时，就需要扩容了，这个x%时又叫作&lt;strong&gt;扩容因子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很显然，扩容因子越大越好，表明哈希表的空间利用率越高。&lt;/p&gt;
&lt;p&gt;所以，很遗憾，二次探测法无法满足我们的目标，扩容因子太小了，只有0.5，一半的空间都是浪费的。&lt;/p&gt;
&lt;p&gt;这时候又到了程序员哥哥们发挥他们聪明特性的时候了，经过996头脑风暴后，又想出了一种新的哈希表实现方式——链表法。&lt;/p&gt;
&lt;h2 id=&quot;链表法&quot;&gt;链表法&lt;/h2&gt;
&lt;p&gt;不就是解决冲突嘛！出现冲突我就不往数组中去放了，我用一个链表把同一个数组下标位置的元素连接起来，这样不就可以充分利用空间了嘛，啊哈哈哈哈~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062335043-1233933680.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嘿嘿嘿嘿，完美△△。&lt;/p&gt;
&lt;p&gt;真的完美嘛，我是一名黑客，我一直往里面放*%8=4的元素，然后你就会发现几乎所有的元素都跑到同一个链表中去了，呵呵，最后的结果就是你的哈希表退化成了链表，查询插入元素的效率都变成了O(n)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062335693-27248227.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，当然有办法，扩容因子干啥滴？&lt;/p&gt;
&lt;p&gt;比如扩容因子设置为1，当元素个数达到8个时，扩容成两倍，一半的元素还在4号位置，一半的元素去到了12号位置，能缓解哈希表的压力。&lt;/p&gt;
&lt;p&gt;然鹅，依旧不是很完美，也只是从一个链表变成两个链表，本文来源于公主号彤哥读源码。&lt;/p&gt;
&lt;p&gt;聪明的程序员哥哥们这次开启了一次长大9127的头脑风暴，终于搞出了一种新的结构——链表树法。&lt;/p&gt;
&lt;h2 id=&quot;链表树法&quot;&gt;链表树法&lt;/h2&gt;
&lt;p&gt;虽然上面的扩容在元素个数比较少的时候能解决一部分问题，整体的查找插入效率也不会太低，因为元素个数少嘛。&lt;/p&gt;
&lt;p&gt;但是，黑客还在攻击，元素个数还在持续增加，当增加到一定程度的时候，总会导致查找插入效率特别低。&lt;/p&gt;
&lt;p&gt;所以，换个思路，既然链表的效率低，我把它升级一下，当链表长的时候升级成红黑树怎么样？&lt;/p&gt;
&lt;p&gt;嗯，我看行，说干就干。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062336486-1661579977.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，不错不错，妈妈再也不怕我遭到黑客攻击了，红黑树的查询效率为O(log n)，比链表的O(n)要高不少。&lt;/p&gt;
&lt;p&gt;所以，到这就结束了吗？&lt;/p&gt;
&lt;p&gt;你想多了，每次扩容还是要移动一半的元素好么，一颗树分化成两颗树，这样真的好么好么好么？&lt;/p&gt;
&lt;p&gt;程序员哥哥们太难了，这次经过了12127的头脑风暴，终于想出个新玩意——一致性Hash。&lt;/p&gt;
&lt;h2 id=&quot;一致性hash&quot;&gt;一致性Hash&lt;/h2&gt;
&lt;p&gt;一致性Hash更多地是运用在分布式系统中，比如说Redis集群部署了四个节点，我们把所有的hash值定义为0~2^32个，每个节点上放置四分之一的元素。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此处只为举例，实际Redis集群的原理是这样的，具体数值不是这样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时，假设需要给Redis增加一个节点，比如node5，放在node3和node4中间，这样只需要把node3到node4中间的元素从node4移动到node5上面就行了，其它的元素保持不变。&lt;/p&gt;
&lt;p&gt;这样，就增加了扩容的速度，而且影响的元素比较少，大部分请求几乎无感知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202009/1648938-20200903062337150-1614607641.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，到这里关于哈希表的进化历史就讲到这里了，你有没有Get到呢？&lt;/p&gt;

&lt;p&gt;本节，我们一起重新学习了关于哈希、哈希函数、哈希表相关的知识，在Java中，HashMap的终极形态是以数组+链表+红黑树的形式呈现的。&lt;/p&gt;
&lt;p&gt;据说，这个红黑树还可以换成其它的数据结构，比如跳表，你造吗？&lt;/p&gt;
&lt;p&gt;下一节，我们就来聊聊&lt;strong&gt;跳表&lt;/strong&gt;这个数据结构，并使用它来改写HashMap，欲获取最新推广，快点来关注我吧！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注公号主“彤哥读源码”，解锁更多源码、基础、架构知识。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 02 Sep 2020 22:24:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>前言 本文收录于专辑：http://dwz.win/HjK，点击解锁更多数据结构与算法的知识。 你好，我是彤哥。 上一节，我们一起学习了，在Java中如何构建高性能队列，里面牵涉到很多底层的知识，不知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/13605460.html</dc:identifier>
</item>
<item>
<title>设计模式-装饰器模式 - 煮诗君</title>
<link>http://www.cnblogs.com/FindTheWay/p/13605360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FindTheWay/p/13605360.html</guid>
<description>&lt;p&gt;装饰器模式动态地给一个对象增加一些额外的职责。就增加功能而言，装饰器模式比生成子类更为灵活。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;149.81275356288&quot;&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;对于装饰器模式，我想先不谈概念，而是先从一个例子开始说起，看看面对这样的需求，我们应该如何处理，并希望由此逐步引出装饰器模式以加深理解。&lt;/p&gt;
&lt;h3 id=&quot;需求&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;假设现在需要开一个奶茶店，奶茶种类繁多，如红豆奶茶，布丁奶茶，珍珠奶茶，红豆珍珠奶茶等。种类虽多，但实质上都是在奶茶中加了各种配料而已。为了简化实现，继续假设奶茶的价格根据奶茶本身加上不同配料累计计算而成。然后，根据每个客户的要求，每种奶茶又可以加糖或者加冰，加糖加冰不额外收费。&lt;/p&gt;
&lt;h3 id=&quot;初级方案&quot;&gt;初级方案&lt;/h3&gt;
&lt;p&gt;在学习设计模式之前，或许最容易想到的方案就是继承了，即先定义奶茶类，然后再定义各种奶茶子类继承自奶茶类，考虑到以后或许还会有更多的饮品，例如咖啡，因此再定义一个饮品的抽象基类，让奶茶类继承自饮品基类，这样一来，最终设计可能会如下类图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202009/474750-20200902231106742-1365136058.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部分代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public abstract class Drink
{
    public string Name { get; set; }

    public int Price { get; set; }

    public abstract string Desc { get; }

    public abstract int Cost { get; }
}

public class Naicha : Drink
{
    public Naicha()
    {
        Name = &quot;奶茶&quot;;
        Price = 8;
    }
    public override string Desc =&amp;gt; this.Name;
    public override int Cost =&amp;gt; this.Price;
}

public class HongDouNaicha : Naicha
{
    public HongDouNaicha()
    {
        Name += &quot;+红豆&quot;;
        Price += 1;
    }
}

public class ZhenzhuNaicha : Naicha
{
    public ZhenzhuNaicha()
    {
        Name += &quot;+珍珠&quot;;
        Price += 3;
    }
}

...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;问题&quot;&gt;问题&lt;/h4&gt;
&lt;p&gt;不难想象，这种设计是一种灾难，因为它至少会出现如下四个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类爆炸，代码虽然只列了部分，但通过类图可以看出类的数量必定会达到一个恐怖的地步；&lt;/li&gt;
&lt;li&gt;如果加冰改为收费，需要多处修改价格，代码维护困难，严重违反开闭原则；&lt;/li&gt;
&lt;li&gt;如果新增配料，类的数量会急剧增加，代码维护困难，严重违反开闭原则；&lt;/li&gt;
&lt;li&gt;无法实现加多份配料，如多冰、多糖等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;改进一&quot;&gt;改进一&lt;/h3&gt;
&lt;p&gt;由于上述问题，现实促使我们不得不对方案进行改进，不过好在对于类爆炸的问题，我们是有经验的，我们在学习工厂方法模式的时候就出现过类爆炸，我们通过合并的方式就演化出了抽象工厂模式，这里我们也可以依葫芦画瓢，对类进行合并。&lt;br/&gt;合并后的类图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202009/474750-20200902233025655-2058076279.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public abstract class Drink
{
    public string Name { get; set; }

    public int Price { get; set; }

    public abstract string Desc { get; }

    public abstract int Cost { get; }

    public abstract void AddBuding();

    public abstract void AddHongdou();

    public abstract void AddZhenzhu();

    public abstract void AddBing();

    public abstract void AddTang();
}

public class Naicha : Drink
{
    private string _desc = string.Empty;
    private int _cost = 0;
    public Naicha()
    {
        Name = &quot;奶茶&quot;;
        Price = 8;
    }

    public override string Desc =&amp;gt; this.Name + _desc;
    public override int Cost =&amp;gt; this.Price + _cost;

    public override void AddBing()
    {
        _desc += &quot;+冰&quot;;
    }

    public override void AddBuding()
    {
        _desc += &quot;+布丁&quot;;
        _cost += 2;
    }

    public override void AddHongdou()
    {
        _desc += &quot;+红豆&quot;;
        _cost += 1;
    }

    public override void AddTang()
    {
        _desc += &quot;+糖&quot;;
    }

    public override void AddZhenzhu()
    {
        _desc += &quot;+珍珠&quot;;
        _cost += 3;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;p&gt;将各种子类都直接改成抽象方法放到Drink父类中，效果简直立杆见影，起码解决了初级方案中的两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消除了类爆炸的问题，代码简洁，一下子就只剩下两个类了；&lt;/li&gt;
&lt;li&gt;配料可以任意搭配组合，并且也可以加入多份。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;p&gt;但是新的问题也随之而来：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;如果修改价格或新增配料就需要新增方法，违反了开闭原则；&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;如果新增饮品咖啡，这时也会变得麻烦，因为咖啡需要冰和糖，同时还需要咖啡伴侣，但是不需要布丁、珍珠、红豆等。
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public abstract class Drink
{
    ...

    public abstract void AddKafeibanlv();
}

public class Naicha : Drink
{
    ...

    public override void AddKafeibanlv()
    {

    }
}

public class Kafei : Drink
{
    ...

    public override void AddBuding()
    {

    }

    public override void AddHongdou()
    {

    }

    public override void AddZhenzhu()
    {

    }

    public override void AddKafeibanlv()
    {
        _desc += &quot;+咖啡伴侣&quot;;
        _cost += 2;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
可以看到，增加了咖啡之后，父类以及每个子类的代码都要跟着修改，而且每个子类都必须继承大量无用的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;改进二&quot;&gt;改进二&lt;/h3&gt;
&lt;p&gt;因此，我们还需要进一步改进，这次我们改进的方向是将这些方法抽象并合并，因为我们可以看到，上面的方案之所以会有这么多问题就是因为面向了实现编程，每个方法都代表了一种配料，如果我们将这些配料全部继承自同一个抽象类，然后提供一个面向抽象的&lt;code&gt;AddPeiliao(Peiliao peiliao)&lt;/code&gt;方法不就可以这个问题了吗？于是我们就有了如下改进：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202009/474750-20200903000501303-1891572441.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了满足这个需求，我们对饮品基类也进行了较大的改造，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public abstract class Drink
{
    protected List&amp;lt;Peiliao&amp;gt; Peiliaos = new List&amp;lt;Peiliao&amp;gt;();
    public string Name { get; set; }

    public int Price { get; set; }

    public int Cost
    {
        get
        {
            int cost = this.Price;
            foreach (var peiliao in Peiliaos)
            {
                cost += peiliao.Price;
            }
            return cost;
        }
    }

    public string Desc
    {
        get
        {
            string desc = this.Name;
            foreach (var peiliao in Peiliaos)
            {
                desc += &quot;+&quot; + peiliao.Name;
            }
            return desc;
        }
    }

    public void AddPeiliao(Peiliao peiliao)
    {
        Peiliaos.Add(peiliao);
    }
}

public class Naicha : Drink
{
    public Naicha()
    {
        Name = &quot;奶茶&quot;;
        Price = 8;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于配料全部通过一个集合组合到了基类中，因此，不需要通过抽象方法让子类计算价格，而是直接在基类中循环叠加计算，同时，由于大部分的功能都在基类中实现了，子类变得干净简洁了。&lt;/p&gt;
&lt;p&gt;再看看配料：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public abstract class Peiliao
{
    public abstract string Name { get; }

    public abstract int Price { get; }
}

public class Buding : Peiliao
{
    public override string Name =&amp;gt; &quot;布丁&quot;;

    public override int Price =&amp;gt; 2;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的简洁干净。&lt;/p&gt;
&lt;h4 id=&quot;优点-2&quot;&gt;优点&lt;/h4&gt;
&lt;p&gt;这样的改进优点是巨大的，几乎解决了所有问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配料可任意搭配组合，并且满足新增饮品的需求；&lt;/li&gt;
&lt;li&gt;新增饮品和配料均只需要增加新的类即可，满足开闭原则&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点-2&quot;&gt;缺点&lt;/h4&gt;
&lt;p&gt;感觉上好像挺不错的，堪称完美！难道这就是今天的主角---装饰器模式？其实，我们忽略了两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个方案以及上一个方案都犯了一个致命的错误，就是修改了饮品类，这在很多时候是不被允许的，或者说根本做不到的，就好比我们要给手机加个装饰---贴个膜，难道我们要先改一下手机的内部结构吗？这明显是不合理，也是做不到的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add&lt;/code&gt;方法也不太合理，饮料不应该具有添加配料的能力，这好比给了手机一个膜，手机自己贴上了，总觉得哪里怪怪的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;改进三&quot;&gt;改进三&lt;/h3&gt;
&lt;p&gt;其实，从设计原则的角度来讲，上一个方案的改进已经很接近了，因为它已经满足了开闭原则，扩展性方面也非常优秀，唯一的问题就是需要修改奶茶类，这通常是不能实现的。那么，我们思路再次转变一下，奶茶类不能改，但是配料可以改啊，我们换个依赖方向，将奶茶聚合到配料中不就可以了吗？于是就有了如下类图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202009/474750-20200903003155770-911825483.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public abstract class Drink
{
    public string Name { get; set; }

    public int Price { get; set; }

    public abstract string Desc { get; }

    public abstract int Cost { get; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;饮品类还原到了最初状态，没做任何修改。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CSharp&quot;&gt;public class Peiliao:Drink
{
    protected readonly Drink Drink;

    public Peiliao(Drink drink)
    {
        Drink = drink;
    }

    public override string Desc
    {
        get
        {
            return Drink.Desc + &quot;+&quot; + this.Name;
        }
    }

    public override int Cost
    {
        get
        {
            return Drink.Cost + this.Price;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将饮品类聚合到了配料类中，但是这里和前一个方案又有所不同，因为配料毕竟是配料，聚合方向换了之后，通过&lt;code&gt;new&lt;/code&gt;就只能得到配料而得不到奶茶了,因此，为了最终能得到奶茶，我们的配料也必须继承自饮品类，这看起来很怪，但妙也妙在这里，通过聚合+继承的方式改进，可使得饮品的扩展更灵活，同时也遵守了开闭原则。其中，聚合是为了实现功能，而继承是为了约束类型，这就是装饰者模式。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;装饰器模式&lt;strong&gt;动态地给一个对象增加一些额外的职责&lt;/strong&gt;。就增加功能而言，装饰器模式比生成子类更为灵活。&lt;/p&gt;
&lt;h2 id=&quot;uml类图&quot;&gt;UML类图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202009/474750-20200903004038527-1228034817.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;优缺点&quot;&gt;优缺点&lt;/h2&gt;
&lt;h3 id=&quot;优点-3&quot;&gt;优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;可动态的给一个对象增加额外的职责&lt;/li&gt;
&lt;li&gt;有很好地可扩展性&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;缺点-3&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;增加了程序的复杂度，刚接触理解起来会比较困难&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;跟代理模式的区别&quot;&gt;跟代理模式的区别&lt;/h2&gt;
&lt;p&gt;装饰器模式跟代理模式类图十分相似，但是，它们之间却有很大的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;装饰器模式关注于在一个对象上动态的添加方法，而代理模式关注于控制对对象的访问。&lt;/li&gt;
&lt;li&gt;装饰器模式通常用聚合的方式，而代理模式通常采用组合的方式。&lt;/li&gt;
&lt;li&gt;装饰器模式通常会套用多层，而代理模式通常只有一层。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是由于他们的结构十分相似，因此很多时候二者可以做同样的事，比如装饰器模式和代理模式都可用于实现AOP（面向切面编程）。&lt;/p&gt;
&lt;h2 id=&quot;经典案例&quot;&gt;经典案例&lt;/h2&gt;
&lt;p&gt;在.NET类库中，&lt;code&gt;System.IO.Stream&lt;/code&gt;就是装饰者模式的一个经典案例，不过在这个案例中没有用到Decorator基类。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202009/474750-20200903004210871-1750420968.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;装饰器模式可以说是结构型设计模式的巅峰之作，其中设计思想十分精妙，但理解起来也确实有些困难，因此，可能还是需自己动手撸码，加深体会。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ZShijun/DesignPattern.git&quot;&gt;源码链接&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 02 Sep 2020 17:21:00 +0000</pubDate>
<dc:creator>煮诗君</dc:creator>
<og:description>装饰器模式动态地给一个对象增加一些额外的职责。就增加功能而言，装饰器模式比生成子类更为灵活。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FindTheWay/p/13605360.html</dc:identifier>
</item>
</channel>
</rss>