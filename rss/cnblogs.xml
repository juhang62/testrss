<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET编程周记第3期-2020年1月19日 - 陈嘉栋</title>
<link>http://www.cnblogs.com/murongxiaopifu/p/12215231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/murongxiaopifu/p/12215231.html</guid>
<description>&lt;p&gt;整理了2020年1月19日这周阅读的几篇有趣的和.NET开发相关的文章。在这里和大家分享。&lt;/p&gt;
&lt;h2&gt;0x00 Introducing Nullable Reference Types in C#&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-825274e2a6da017398914d0faa73c5ea_hd.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;510&quot; data-original=&quot;https://pic3.zhimg.com/v2-825274e2a6da017398914d0faa73c5ea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-825274e2a6da017398914d0faa73c5ea_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如标题所示，本文介绍了在C# 8之后引入的可空引用类型。&lt;/li&gt;
&lt;li&gt;在本文的开头，介绍了空引用的起源以及Tony Hoare的“十亿美元的错误”，这是一段有趣的历史背景介绍。&lt;/li&gt;
&lt;li&gt;介绍了在处理空引用时存在的问题，以及如何在C＃8中解决这些问题的方法，即他们添加了可空引用类型来表达引用可能为空的意图。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;LinkCard-backdrop&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/nullable-reference-types-in-csharp/&quot;&gt;https://devblogs.microsoft.com/dotnet/nullable-reference-types-in-csharp/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;0x01 A look at the internals of ‘boxing’ in the CLR&lt;/h2&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-bd8ef0708c22b4c204c29fb2427930aa_hd.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;366&quot; data-original=&quot;https://pic3.zhimg.com/v2-bd8ef0708c22b4c204c29fb2427930aa_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bd8ef0708c22b4c204c29fb2427930aa_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你想知道CLR中的装箱实现，你只需要阅读这篇很有帮助的文章！&lt;/li&gt;
&lt;li&gt;本文首先介绍CLR规范中的装箱定义。然后讨论与CLR中的装箱/拆箱相关的il操作码和jit代码。相关操作会直接连接到对应的CLR代码。&lt;/li&gt;
&lt;li&gt;在本文的结尾，有一些有用的链接，例如CLR代码中与装箱/拆箱相关的注释，StackOverflow上的相关问题等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;LinkCard-backdrop&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;&lt;a href=&quot;https://mattwarren.org/2017/08/02/A-look-at-the-internals-of-boxing-in-the-CLR/&quot;&gt;https://mattwarren.org/2017/08/02/A-look-at-the-internals-of-boxing-in-the-CLR/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;0x02 Structuring Unit Tests&lt;/h2&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-9346442e5fc3ae55dcfec15e16411412_hd.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;386&quot; data-original=&quot;https://pic3.zhimg.com/v2-9346442e5fc3ae55dcfec15e16411412_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9346442e5fc3ae55dcfec15e16411412_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文已有些过时，但是本文的内容仍然非常有启发性。&lt;/li&gt;
&lt;li&gt;本文介绍的测试结构在是对每个要被测试的类中都有一个测试类来对应，有趣的是针对每个要被测试的方法也要有一个测试类来对应。你可以在NuGetGallery这个项目的代码库中找到一些示例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;LinkCard-backdrop&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;&lt;a href=&quot;https://haacked.com/archive/2012/01/02/structuring-unit-tests.aspx/&quot;&gt;https://haacked.com/archive/2012/01/02/structuring-unit-tests.aspx/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;0x03 The Book of the Runtime&lt;/h2&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-88fa3ca0dc4f758e0f7217759b2ff0d4_hd.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;439&quot; data-original=&quot;https://pic1.zhimg.com/v2-88fa3ca0dc4f758e0f7217759b2ff0d4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-88fa3ca0dc4f758e0f7217759b2ff0d4_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《运行时之书》是一组文档，描述了CLR和BCL中的组件。它们旨在更多地关注CLR的体系结构。&lt;/li&gt;
&lt;li&gt;有一些有趣的主题，例如CLR的垃圾回收设计，类型系统等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;&lt;a class=&quot;LinkCard LinkCard--noImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/README.md&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-za-detail-view-id=&quot;172&quot;&gt;https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/README.md&lt;span class=&quot;LinkCard-meta&quot;&gt;​github.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;0x04 Hidden Features of C#?&lt;/h2&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-0202f5534a5d6383ab28abcc999504da_hd.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;432&quot; data-original=&quot;https://pic3.zhimg.com/v2-0202f5534a5d6383ab28abcc999504da_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0202f5534a5d6383ab28abcc999504da_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个来自Stack Overflow被查看了685k次的问题。 原始的问题已经有些过时了。但是有下面的回答包含了很多关于C#的隐藏功能或者是技巧。&lt;/li&gt;
&lt;li&gt;可以找到许多C#技巧。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;LinkCard-backdrop&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/questions/9033/hidden-features-of-c?page=1&amp;amp;tab=votes#tab-top&quot;&gt;https://stackoverflow.com/questions/9033/hidden-features-of-c?page=1&amp;amp;tab=votes#tab-top&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;0x05 Web Scraping with C#&lt;/h2&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-6f0c7d615a0166a0dbae1818c5d1979e_hd.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;504&quot; data-original=&quot;https://pic3.zhimg.com/v2-6f0c7d615a0166a0dbae1818c5d1979e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6f0c7d615a0166a0dbae1818c5d1979e_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这篇文章总结了很多有关使用C#进行网络抓取的文章。&lt;/li&gt;
&lt;li&gt;可以在Github上找到一些有用的项目，例如AngleSharp。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://www.dotnetswede.com/web-scraping-with-csharp/&quot;&gt;https://www.dotnetswede.com/web-scraping-with-csharp/&lt;/a&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;&lt;a class=&quot;LinkCard LinkCard--noImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.dotnetswede.com/web-scraping-with-csharp/&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;欢迎大家关注我的公众号&quot;慕容的游戏编程&quot;：chenjd01&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;content_image lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-8517ab7cc89fbdbfa23b8e5679ed2256_hd.jpg&quot; alt=&quot;&quot; width=&quot;258&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;258&quot; data-rawheight=&quot;258&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-8517ab7cc89fbdbfa23b8e5679ed2256_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 00:59:00 +0000</pubDate>
<dc:creator>陈嘉栋</dc:creator>
<og:description>整理了2020年1月19日这周阅读的几篇有趣的和.NET开发相关的文章。在这里和大家分享。 0x00 Introducing Nullable Reference Types in C# 如标题所示，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/murongxiaopifu/p/12215231.html</dc:identifier>
</item>
<item>
<title>如何设计一个高可用系统？要考虑哪些地方？ - JavaGuide</title>
<link>http://www.cnblogs.com/javaguide/p/12216564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaguide/p/12216564.html</guid>
<description>&lt;blockquote readability=&quot;6.1680327868852&quot;&gt;
&lt;p&gt;本文已经收录自笔者开源的 JavaGuide: &lt;a href=&quot;https://github.com/Snailclimb&quot; class=&quot;uri&quot;&gt;https://github.com/Snailclimb&lt;/a&gt; (69k+Star【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识)如果觉得不错的还，不妨去点个Star，鼓励一下!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一篇短小的文章，面试经常遇到的这个问题。本文主要包括下面这些内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高可用的定义&lt;/li&gt;
&lt;li&gt;哪些情况可能会导致系统不可用？&lt;/li&gt;
&lt;li&gt;有些提高系统可用性的方法？只是简单的提一嘴，更具体内容在后续的文章中介绍，就拿限流来说，你需要搞懂：何为限流？如何限流？为什么要限流？如何做呢？说一下原理？。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;什么是高可用可用性的判断标准是啥&quot;&gt;什么是高可用？可用性的判断标准是啥？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间都是可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;哪些情况会导致系统不可用&quot;&gt;哪些情况会导致系统不可用？&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;黑客攻击；&lt;/li&gt;
&lt;li&gt;硬件故障，比如服务器坏掉。&lt;/li&gt;
&lt;li&gt;并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。&lt;/li&gt;
&lt;li&gt;代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。&lt;/li&gt;
&lt;li&gt;网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。&lt;/li&gt;
&lt;li&gt;自然灾害或者人为破坏。&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;有哪些提高系统可用性的方法&quot;&gt;有哪些提高系统可用性的方法？&lt;/h2&gt;
&lt;h3 id=&quot;注重代码质量测试严格把关&quot;&gt;1. 注重代码质量，测试严格把关&lt;/h3&gt;
&lt;p&gt;我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！&lt;/p&gt;
&lt;p&gt;另外，安利这个对提高代码质量有实际效果的宝贝：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。&lt;/li&gt;
&lt;li&gt;Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。&lt;/li&gt;
&lt;li&gt;IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;使用集群减少单点故障&quot;&gt;2.使用集群，减少单点故障&lt;/h3&gt;
&lt;p&gt;先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例，不到一秒就会有另外一台 Redis 实例顶上。&lt;/p&gt;
&lt;h3 id=&quot;限流&quot;&gt;3.限流&lt;/h3&gt;
&lt;p&gt;流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 alibaba-&lt;a href=&quot;https://github.com/alibaba/Sentinel&quot; title=&quot;Sentinel&quot;&gt;Sentinel&lt;/a&gt; 的 wiki。&lt;/p&gt;
&lt;h3 id=&quot;超时和重试机制设置&quot;&gt;4.超时和重试机制设置&lt;/h3&gt;
&lt;p&gt;一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。&lt;/p&gt;
&lt;h3 id=&quot;熔断机制&quot;&gt;5.熔断机制&lt;/h3&gt;
&lt;p&gt;超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的是流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。&lt;/p&gt;
&lt;h3 id=&quot;异步调用&quot;&gt;6.异步调用&lt;/h3&gt;
&lt;p&gt;异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 &lt;strong&gt;适当修改业务流程进行配合&lt;/strong&gt;，比如&lt;strong&gt;用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功&lt;/strong&gt;。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。&lt;/p&gt;
&lt;h3 id=&quot;使用缓存&quot;&gt;7.使用缓存&lt;/h3&gt;
&lt;p&gt;如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;8.其他&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;核心应用和服务优先使用更好的硬件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控系统资源使用情况增加报警设置。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意备份，必要时候回滚。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灰度发布：&lt;/strong&gt; 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定期检查/更换硬件：&lt;/strong&gt; 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。&lt;/li&gt;
&lt;li&gt;.....(想起来再补充！也欢迎各位欢迎补充！)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1843652/202001/1843652-20200120084737985-1857886764.png&quot; alt=&quot;如何设计高可用系统？&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 00:48:00 +0000</pubDate>
<dc:creator>JavaGuide</dc:creator>
<og:description>本文已经收录自笔者开源的 JavaGuide: &amp;quot;https://github.com/Snailclimb&amp;quot; (69k+Star【Java学习+面试指南】 一份涵盖大部分Java</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javaguide/p/12216564.html</dc:identifier>
</item>
<item>
<title>上周热点回顾（1.13-1.19） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/12216563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/12216563.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · 咸鱼程序员北漂五年，租房需要多少钱？ (那是山)· 一个由&quot;2020年1月7日 京东出现的重大 Bug 漏洞&quot;引起的思考... (豆姐姐)· 程序员不得不了解的硬核知识大全 (cxuan)· Go和Java的性能对比,真的如此吗？ (阿伟~)· 真·程序员必修书单 (削微寒)· 《大</description>
<pubDate>Mon, 20 Jan 2020 00:46:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>热点随笔： &amp;#183;&amp;#160;咸鱼程序员北漂五年，租房需要多少钱？&amp;#160;(那是山)&amp;#183;&amp;#160;一个由&amp;quot;2020年1月7日 京东出现的重大 Bug 漏洞&amp;quot;引起</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/12216563.html</dc:identifier>
</item>
<item>
<title>Redis系列(二)：Redis的5种数据结构及其常用命令 - 申城异乡人</title>
<link>http://www.cnblogs.com/zwwhnly/p/12216550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwwhnly/p/12216550.html</guid>
<description>&lt;p&gt;上一篇博客，我们讲解了什么是Redis以及在Windows和Linux环境下安装Redis的方法，&lt;/p&gt;
&lt;p&gt;没看过的同学可以点击以下链接查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zwwhnly/p/12185696.html&quot;&gt;Redis系列(一)：Redis简介及环境安装&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本篇博客我们来讲解下Redis的5种数据结构及其常用命令，5种数据结构分别为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字符串String&lt;/li&gt;
&lt;li&gt;列表List&lt;/li&gt;
&lt;li&gt;集合Set&lt;/li&gt;
&lt;li&gt;散列Hash&lt;/li&gt;
&lt;li&gt;有序集合ZSet&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意事项：Redis可以存储键(key)值(value)对的映射，其中键(key)一直是String，而值可以是上面提到的5种数据结构中的一种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;字符串string&quot;&gt;1. 字符串String&lt;/h2&gt;
&lt;p&gt;在Redis中，字符串可以存储以下3种类型的值：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字节串(byte string)&lt;/li&gt;
&lt;li&gt;整数&lt;/li&gt;
&lt;li&gt;浮点数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经常使用的字符串命令主要分为以下3种类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;常用命令&lt;/li&gt;
&lt;li&gt;自增自减命令&lt;/li&gt;
&lt;li&gt;子串命令&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来，我们一一讲解。&lt;/p&gt;
&lt;h3 id=&quot;常用命令&quot;&gt;1.1 常用命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;常用命令主要有：GET、SET、DEL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GET、SET、DEL命令的功能如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;获取指定键的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SET&lt;/td&gt;
&lt;td&gt;设置指定键的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DEL&lt;/td&gt;
&lt;td&gt;删除指定键的值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;然后我们打开一个redis-cli交互式客户端，执行下上面的命令看下效果。&lt;/p&gt;
&lt;p&gt;以下是这些命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200117_133343.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自增自减命令&quot;&gt;1.2 自增自减命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;自增自减命令主要有：INCR、DECR、INCRBY、DECRBY、INCRBYFLOAT。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当用户将一个值存储到Redis字符串的时候，如果这个值可以被转化为整数或者浮点数，那么Redis会察觉到这一点，并允许用户对这个字符串执行各种&lt;code&gt;INCR*&lt;/code&gt;和&lt;code&gt;DECR*&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;INCR、DECR命令的功能如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;INCR&lt;/td&gt;
&lt;td&gt;INCR keyname&lt;/td&gt;
&lt;td&gt;将键存储的值加1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;DECR&lt;/td&gt;
&lt;td&gt;DECR keyname&lt;/td&gt;
&lt;td&gt;将键存储的值减1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以下是可能存在的3个异常场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对一个不存在的键执行自增或者自减操作，Redis在执行操作时会将这个键的值当作0来处理。&lt;/li&gt;
&lt;li&gt;对一个保存了空串的键执行自增或者自减操作，Redis在执行操作时会将这个键的值当作0来处理。&lt;/li&gt;
&lt;li&gt;对一个值无法被解释为整数或者浮点数的字符串键执行自增或者自减操作，Redis将返回一个错误。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下是这些命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200117_140149.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200117_140322.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;INCRBY、DECRBY命令的功能和上面的INCR、DECR命令类似，不过INCRBY、DECRBY可以指定每次自增或者自减的数值，而INCR、DECR每次都自增或者自减1。&lt;/p&gt;
&lt;p&gt;INCRBYFLOAT命令与INCRBY命令类似，不过INCRBYFLOAT命令用来自增或者自减浮点，而INCRBY命令用来自增或者自减整数。&lt;/p&gt;
&lt;p&gt;INCRBY、DECRBY、INCRBYFLOAT命令的功能如下所示如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;INCRBY&lt;/td&gt;
&lt;td&gt;INCR keyname amount&lt;/td&gt;
&lt;td&gt;将键存储的值加上整数amount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DECRBY&lt;/td&gt;
&lt;td&gt;DECR keyname amount&lt;/td&gt;
&lt;td&gt;将键存储的值减去整数amount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;INCRBYFLOAT&lt;/td&gt;
&lt;td&gt;INCRBYFLOAT keyname amount&lt;/td&gt;
&lt;td&gt;将键存储的值加上浮点数amount&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们可以打开一个redis-cli交互式客户端，执行上面的命令看下效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200117_142843.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;子串命令&quot;&gt;1.3 子串命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;子串命令主要有：APPEND、GETRANGE、SETRANGE。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;APPEND命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;命令：APPEND&lt;/p&gt;
&lt;p&gt;语法：APPEND keyname value&lt;/p&gt;
&lt;p&gt;功能：将值value追加到指定键keyname当前存储的值的末尾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GETRANGE命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令：GETRANGE&lt;/p&gt;
&lt;p&gt;语法：GETRANGE keyname start end&lt;/p&gt;
&lt;p&gt;功能：获取一个由偏移量start(包含start)至偏移量end(包含end)范围内所有字符组成的子串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SETRANGE命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;命令：SETRANGE&lt;/p&gt;
&lt;p&gt;语法：SETRANGE keyname start value&lt;/p&gt;
&lt;p&gt;功能：将从start偏移量开始的子串设置为给定值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是这些命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200117_151032.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;列表list&quot;&gt;2. 列表List&lt;/h2&gt;
&lt;p&gt;Redis中的列表主要有以下2个特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;有序地存储多个字符串&lt;/li&gt;
&lt;li&gt;列表里面的元素是可以重复的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经常使用的列表命令主要分为以下3种类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;常用命令&lt;/li&gt;
&lt;li&gt;阻塞弹出命令&lt;/li&gt;
&lt;li&gt;元素移动命令&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来，我们一一讲解。&lt;/p&gt;
&lt;h3 id=&quot;常用命令-1&quot;&gt;2.1 常用命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;常用命令主要有：RPUSH、LPUSH、RPOP、LPOP、LINDEX、LRANGE、LTRIM。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RPUSH命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;命令：RPUSH&lt;/p&gt;
&lt;p&gt;语法：RPUSH keyname value [value ...]&lt;/p&gt;
&lt;p&gt;功能：将一个或多个值推入列表的右端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LPUSH命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;命令：LPUSH&lt;/p&gt;
&lt;p&gt;语法：LPUSH keyname value [value ...]&lt;/p&gt;
&lt;p&gt;功能：将一个或多个值推入列表的左端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RPOP命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;命令：RPOP&lt;/p&gt;
&lt;p&gt;语法：RPOP keyname&lt;/p&gt;
&lt;p&gt;功能：移除并返回列表最右端的元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LPOP命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;命令：LPOP&lt;/p&gt;
&lt;p&gt;语法：LPOP keyname&lt;/p&gt;
&lt;p&gt;功能：移除并返回列表最左端的元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LINDEX命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;命令：LINDEX&lt;/p&gt;
&lt;p&gt;语法：LINDEX keyname offset&lt;/p&gt;
&lt;p&gt;功能：返回列表中偏移量为offset的元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LRANGE命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令：LRANGE&lt;/p&gt;
&lt;p&gt;语法：LRANGE keyname start end&lt;/p&gt;
&lt;p&gt;功能：返回列表从start(包含start)偏移量到end偏移量(包含end)范围内的所有元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LTRIM命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令：LTRIM&lt;/p&gt;
&lt;p&gt;语法：LTRIM keyname start end&lt;/p&gt;
&lt;p&gt;功能：对列表进行修剪，只保留从start(包含start)偏移量到end偏移量(包含end)范围内的元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是这些命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200117_154947.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;阻塞弹出命令&quot;&gt;2.2 阻塞弹出命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;阻塞弹出命令主要有：BLPOP、BRPOP。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BLPOP命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令：BLPOP&lt;/p&gt;
&lt;p&gt;语法：BLPOP keyname [keyname ...] timeout&lt;/p&gt;
&lt;p&gt;功能：从第一个非空列表中弹出最左端的元素，如果没有，则在timeout秒之内阻塞并等待可弹出的元素出现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BRPOP命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令：BRPOP&lt;/p&gt;
&lt;p&gt;语法：BRPOP keyname [keyname ...] timeout&lt;/p&gt;
&lt;p&gt;功能：从第一个非空列表中弹出最右端的元素，如果没有，则在timeout秒之内阻塞并等待可弹出的元素出现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是这些命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200117_161819.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;元素移动命令&quot;&gt;2.3 元素移动命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;元素移动命令主要有：RPOPLPUSH、BRPOPLPUSH。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RPOPLPUSH命令的功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令：RPOPLPUSH&lt;/p&gt;
&lt;p&gt;语法：RPOPLPUSH source-key dest-key&lt;/p&gt;
&lt;p&gt;功能：从source-key列表中弹出最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这 个元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BRPOPLPUSH命令可以认为是RPOPLPUSH命令的阻塞实现，功能如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;命令：BRPOPLPUSH&lt;/p&gt;
&lt;p&gt;语法：BRPOPLPUSH source-key dest-key timeout&lt;/p&gt;
&lt;p&gt;功能：从source-key列表中弹出最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这 个元素，&lt;strong&gt;如果source-key为空，那么在timeout秒之内阻塞并等待可弹出的元素出现&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是这些命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200117_163638.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;集合set&quot;&gt;3. 集合Set&lt;/h2&gt;
&lt;p&gt;Redis的集合以&lt;strong&gt;无序&lt;/strong&gt;的方式来存储多个&lt;strong&gt;各不相同&lt;/strong&gt;的元素。&lt;/p&gt;
&lt;p&gt;与上面提到的列表相比，Redis中的集合主要有以下2个特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无序地存储多个字符串&lt;/li&gt;
&lt;li&gt;集合里面的元素是不可以重复的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经常使用的集合命令主要分为以下3种类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;常用命令&lt;/li&gt;
&lt;li&gt;元素移动命令&lt;/li&gt;
&lt;li&gt;差集/交集/并集命令&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来，我们一一讲解。&lt;/p&gt;
&lt;h3 id=&quot;常用命令-2&quot;&gt;3.1 常用命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;常用命令主要有：SADD、SMEMBERS、SISMEMBER、SREM、SCARD。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上命令的功能描述如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SADD&lt;/td&gt;
&lt;td&gt;SADD keyname item [item ...]&lt;/td&gt;
&lt;td&gt;将一个或多个元素添加到集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SMEMBERS&lt;/td&gt;
&lt;td&gt;SMEMBERS keyname&lt;/td&gt;
&lt;td&gt;返回集合包含的所有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SISMEMBER&lt;/td&gt;
&lt;td&gt;SISMEMBER keyname item&lt;/td&gt;
&lt;td&gt;检查元素item是否存在于集合keyname中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SREM&lt;/td&gt;
&lt;td&gt;SREM keyname item [item ...]&lt;/td&gt;
&lt;td&gt;从集合里删除一个或多个元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SCARD&lt;/td&gt;
&lt;td&gt;SCARD keyname&lt;/td&gt;
&lt;td&gt;返回集合包含元素的数量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以下是这些命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200118_231118.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_140855.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;元素移动命令-1&quot;&gt;3.2 元素移动命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;元素移动命令主要有：SMOVE。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上命令的功能描述如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;语法：SMOVE sourcekey destkey item&lt;/p&gt;
&lt;p&gt;功能：将集合sourcekey中的元素item移除，并将元素item添加到集合destkey中&lt;/p&gt;
&lt;p&gt;​ 如果item被成功移除，返回1，否则返回0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是SMOVE命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_141728.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;差集交集并集命令&quot;&gt;3.3 差集/交集/并集命令&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;交集/并集/差集命令主要有：SDIFF、SDIFFSTORE、SINTER、SINTERSTORE、SUNION、SUNIONSTORE。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上命令的功能描述如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SDIFF&lt;/td&gt;
&lt;td&gt;SDIFF keyname [key-name ...]&lt;/td&gt;
&lt;td&gt;返回存在于第1个集合，不存在于其他集合的元素（差集运算）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;SDIFFSTORE&lt;/td&gt;
&lt;td&gt;SDIFFSTORE destkey keyname [key-name ...]&lt;/td&gt;
&lt;td&gt;将存在于第1个集合，不存在于其他集合的元素（差集运算）存储到destkey集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SINTER&lt;/td&gt;
&lt;td&gt;SINTER keyname [key-name ...]&lt;/td&gt;
&lt;td&gt;返回同时存在于所有集合中的元素（交集运算）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SINTERSTORE&lt;/td&gt;
&lt;td&gt;SINTERSTORE destkey keyname [key-name ...]&lt;/td&gt;
&lt;td&gt;将同时存在于所有集合中的元素（交集运算）存储到destkey集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SUNION&lt;/td&gt;
&lt;td&gt;SUNION keyname [key-name ...]&lt;/td&gt;
&lt;td&gt;返回至少存在于一个集合中的元素（并集运算）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SUNIONSTORE&lt;/td&gt;
&lt;td&gt;SUNIONSTORE destkey keyname [key-name ...]&lt;/td&gt;
&lt;td&gt;将至少存在于一个集合中的元素（并集运算）存储到destkey集合&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以下是这些命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_143338.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;散列hash&quot;&gt;4. 散列Hash&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关于数据结构Hash，有些书籍叫做散列，有些书籍叫做哈希，本文中使用名称：散列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redis的散列可以存储多个键值对之间的映射，即可以让用户将多个键值对存储到一个Redis键里面，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_144924.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们了解下经常使用的散列命令。&lt;/p&gt;
&lt;h3 id=&quot;添加键值对&quot;&gt;4.1 添加键值对&lt;/h3&gt;
&lt;p&gt;往散列里添加键值对有2个命令，分别是HSET、HMSET，其中HSET一次只能添加1个键值对，而HMSET一次可以添加多个键值对。&lt;/p&gt;
&lt;p&gt;以下是这2个命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_150339.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时的hash-key包含3个键值对，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_150432.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取键值对&quot;&gt;4.2 获取键值对&lt;/h3&gt;
&lt;p&gt;获取散列里键值对有以下5个命令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HGET 从散列里获取指定键的值&lt;/li&gt;
&lt;li&gt;HMGET 从散列里获取一个或多个键的值&lt;/li&gt;
&lt;li&gt;HKEYS 获取散列包含的所有键&lt;/li&gt;
&lt;li&gt;HVALS 获取散列包含的所有值&lt;/li&gt;
&lt;li&gt;HGETALL 获取散列包含的所有键值对&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下是这5个命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_151459.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取键值对数量&quot;&gt;4.3 获取键值对数量&lt;/h3&gt;
&lt;p&gt;可以通过&lt;code&gt;HLEN&lt;/code&gt;命令来获取散列包含的键值对数量。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;HLEN&lt;/code&gt;命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_151756.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;判断键是否存在&quot;&gt;4.4 判断键是否存在&lt;/h3&gt;
&lt;p&gt;可以通过&lt;code&gt;HEXISTS&lt;/code&gt;命令来检查某个键是否存在于散列中。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;HEXISTS&lt;/code&gt;命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_152150.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自增自减&quot;&gt;4.5 自增/自减&lt;/h3&gt;
&lt;p&gt;和字符串的自增，自减命令功能类似，在散列里，我们可以使用&lt;code&gt;HINCRBY&lt;/code&gt;命令将某个键存储的值加上个整数，使用&lt;code&gt;HINCRBYFLOAT&lt;/code&gt;命令将某个键存储的值加上个浮点数。&lt;/p&gt;
&lt;p&gt;以下是这2个命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_153713.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除键值对&quot;&gt;4.6 删除键值对&lt;/h3&gt;
&lt;p&gt;可以通过&lt;code&gt;HDEL&lt;/code&gt;命令来删除散列中的一个或多个键。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;HDEL&lt;/code&gt;命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_153955.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;有序集合zset&quot;&gt;5. 有序集合ZSet&lt;/h2&gt;
&lt;p&gt;有序集合和散列一样，可以用于存储多个键值对之间的映射，其中有序集合的键被称为成员(member)，每个成员都是各不相同的，有序集合的值被称为分值(score)，分值必须为浮点数。&lt;/p&gt;
&lt;p&gt;下图表示1个包含2个元素的有序集合示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_155909.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们了解下经常使用的有序集合命令。&lt;/p&gt;
&lt;h3 id=&quot;添加元素&quot;&gt;5.1 添加元素&lt;/h3&gt;
&lt;p&gt;可以通过&lt;code&gt;ZADD&lt;/code&gt;命令往有序集合中添加元素。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;ZADD&lt;/code&gt;命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_161149.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时的zset-key包含3个成员与分值之间的映射，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_161220.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取元素&quot;&gt;5.2 获取元素&lt;/h3&gt;
&lt;p&gt;获取有序集合里元素有以下2个命令：&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;ZRANGE&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;语法：ZRANGE keyname start stop [WITHSCORES]&lt;/p&gt;
&lt;p&gt;功能：返回有序集合中排名介于start和stop之间的成员，如果给定了可选的WITHSCORES选项，&lt;/p&gt;
&lt;p&gt;​ 那么会将成员的分值一并返回&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;ZRANGEBYSCORE&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;语法：ZRANGEBYSCORE keyname min max [WITHSCORES] [LIMIT offset count]&lt;/p&gt;
&lt;p&gt;功能：返回有序集合中分值介于min和max之间的成员，如果给定了可选的WITHSCORES选项，&lt;/p&gt;
&lt;p&gt;​ 那么会将成员的分值一并返回&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下是这2个命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_162819.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取元素数量&quot;&gt;5.3 获取元素数量&lt;/h3&gt;
&lt;p&gt;可以通过&lt;code&gt;ZCARD&lt;/code&gt;命令来获取有序集合包含的成员数量。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;ZCARD&lt;/code&gt;命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_163012.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还可以通过ZCOUNT命令来获取有序集合中分值处于某个区间的成员数量。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;ZCOUNT&lt;/code&gt;命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_163425.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自增自减-1&quot;&gt;5.4 自增/自减&lt;/h3&gt;
&lt;p&gt;和字符串的自增，自减命令功能类似，在有序集合里，我们可以使用&lt;code&gt;ZINCRBY&lt;/code&gt;命令将某个成员的分值加上个整数。&lt;/p&gt;
&lt;p&gt;以下是这&lt;code&gt;ZINCRBY&lt;/code&gt;命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_163836.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除元素&quot;&gt;5.5 删除元素&lt;/h3&gt;
&lt;p&gt;可以通过&lt;code&gt;ZREM&lt;/code&gt;命令来删除有序集合中的一个或多个成员。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;ZREM&lt;/code&gt;命令的使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.zwwhnly.com/picture/2020/01/snipaste_20200119_164105.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想了解更多的Redis命令，可以查看官网地址：&lt;a href=&quot;https://redis.io/commands&quot; class=&quot;uri&quot;&gt;https://redis.io/commands&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;源码及参考&quot;&gt;6. 源码及参考&lt;/h2&gt;
&lt;p&gt;Josiah L. Carlson 《Reids实战》&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 00:40:00 +0000</pubDate>
<dc:creator>申城异乡人</dc:creator>
<og:description>Redis的5种数据结构及其常用命令。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zwwhnly/p/12216550.html</dc:identifier>
</item>
<item>
<title>我的2019归零，2020走你 - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/12216551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/12216551.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/202001/1583165-20200120083938933-990764146.png&quot;/&gt;&lt;br/&gt;作为生长在内蒙的，不会套马的，酒精过敏的，不吃羊肉的，也不魁梧的奇葩，单曲循环听着腾格尔大爷的翻唱歌曲「可能否」，还是开始写了 2019 年总结，这个总结比 2002 😆 年来的更晚一些，因为在等待 2019 年末的一个 PMP(拍马屁)的成绩，赶不上各个平台的总结比赛了，写下来给自己个答复&lt;/p&gt;
&lt;p&gt;年初的一次旅行之后，回来倍感惶恐，总觉得应该做点什么继续充实自己的生活。写博客记录和维护公众号的想法也就随之浮现在脑海中&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/202001/1583165-20200120083940248-257242241.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻看历史记录，在 2015 年就已经尝试搭建自己的博客了，奈何没有坚持分享，中途夭折。「种一棵树最好的时间是十年前，其次是现在」。这一刻，我要种一棵树，陪她长大，我变老，她茁壮长青&lt;/p&gt;
&lt;h2 id=&quot;公众号与博客&quot;&gt;公众号与博客&lt;/h2&gt;
&lt;p&gt;磕磕碰碰一点点摸索着完成了公众号的注册「日拱一兵」。&lt;code&gt;日拱一卒，功不唐捐&lt;/code&gt;，这个名字真是非常质朴了，奈何日拱一卒被注册了，但幸运的是日拱一兵没有被注册，否则我就得「車/馬/炮」的尝试下去了，如果到了&lt;code&gt;日拱一 pao&lt;/code&gt;的地步我应该就放弃这个 ID 了吧 😂&lt;/p&gt;
&lt;p&gt;搜查肚子里有限的墨水，2019 年 5 月 22 号，我战战兢兢又满怀期待的发布了第一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/hR1TqkVzwZ_T8fuMnsM4hQ&quot;&gt;如何设计好的 RESTful API&lt;/a&gt;。我像做传销的一样，先从亲朋好友开始坑，让他们关注评论，现在一看已经有了 17 个&lt;code&gt;在看&lt;/code&gt;，他们一定贡献很多 😜&lt;/p&gt;
&lt;p&gt;2019 年 7 月 11 日，突然收到一个赞赏通知，开始我以为是朋友的安慰，反复确认后，才发现这就是读者朋友的赞赏，那一刻我觉得我是百万富翁，怀着无比激动的心情回复「我会努力输出高质量原创内容」&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/202001/1583165-20200120083941067-123092093.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生孩子容易，养育孩子难，不关注粉丝的增长一定是假的。我也需要小小的成就感来驱动，一天下来，每增长一个粉丝都使我足够兴奋，第二天起床又焦虑的期盼第二个粉丝的到来，就这样朝朝暮暮......&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dayarch.top/&quot;&gt;个人博客&lt;/a&gt;重新运营了起来，在维护过程中差点迷失在定制炫酷的效果中，幸亏没有走火如魔，回归到了博文内容本质以及博客功能增强等，作为后端程序猿的我，也为主题功能贡献了个 PR，还请各位大声嘲笑&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/202001/1583165-20200120083941703-2093407677.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;住的离公司很近，无聊的时候就可以跑到公司写点东西静静心，不到一年写了 39 篇原创文章，不算代码，累计字数将近 10 万字，长度不到地球一周😝&lt;/p&gt;
&lt;h2 id=&quot;信仰&quot;&gt;信仰&lt;/h2&gt;
&lt;p&gt;为了做好这些内容，我为我的思想注入两条信仰:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你有一个思想，我有一个思想，我们交换后，一个人就有了两个思想&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个信仰让我勇于与他人交流，进行思想碰撞，甚至产生 1+1&amp;gt;2 的效果，乐于分享也让我收获颇多快乐，你会发现，每个个体的思想真的很奇妙&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;If you can NOT explain it simply, you do NOT understand it well enough&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;技术有时会枯燥，所以本着将复杂问题简单化，将抽象问题图形化的方式来输出文章。在讲解的过程中也加深了我对问题的理解层次&lt;/p&gt;
&lt;h2 id=&quot;阅读&quot;&gt;阅读&lt;/h2&gt;
&lt;p&gt;2019 年读 30 多本杂书，已经放到了&lt;a href=&quot;https://dayarch.top/books/&quot;&gt;博客书架&lt;/a&gt;，遗憾的是没怎么写完整书评，我热衷于看纸质书籍，都是边读边写边画了，这里仅仅说几个印象深刻的感悟&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;入一行，先别惦记着能赚钱，先学着让自己值钱，变内行人。没有哪个行业的钱是好赚的，学习是让自己快速增值的最好途径。让人迷茫的原因只有一个，那就是本该拼搏的年纪，却想得太多，做得太少——摘自「褚时健传」&lt;/li&gt;
&lt;li&gt;心理学相关的书解读了我日常一些疯狂的思想和行为，如果没有他们的解读，我可能觉得我是个变态😂，现在心安了许多&lt;/li&gt;
&lt;li&gt;你的灯还亮着吗？始终让我带着追问去思考问题，每篇公众号推文的「灵魂追问」环节的灵感也来源于此&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;读书只为取悦自己&lt;/p&gt;
&lt;h2 id=&quot;工作&quot;&gt;工作&lt;/h2&gt;
&lt;p&gt;2019 年在工作上整体节奏依然平稳。和伙伴们并肩战斗，多个产品线也如期上线。很意外申请下来一个专利「证件文字信息获取方法、装置以及电子设备」，同时有一篇文章入选公司技术期刊。请允许我骄傲一秒钟&lt;/p&gt;
&lt;p&gt;骄傲结束......😂&lt;/p&gt;
&lt;h2 id=&quot;相识幸运的起点&quot;&gt;相识，幸运的起点&lt;/h2&gt;
&lt;p&gt;业余时间为 &lt;a href=&quot;http://www.spring4all.com/&quot;&gt;Spring4All 社区&lt;/a&gt; 贡献翻译内容，慢慢结识了&lt;code&gt;程序猿 DD&lt;/code&gt; 和 &lt;code&gt;泥瓦匠 BYSocket&lt;/code&gt;，被前辈的态度折服，更被一些故事感动。他们自然是我学习和追赶的榜样&lt;/p&gt;
&lt;p&gt;维护个人博客和公众号少不了并肩战斗的伙伴，&lt;code&gt;乱敲代码&lt;/code&gt;，&lt;code&gt;码农小胖哥&lt;/code&gt;，&lt;code&gt;辉哥&lt;/code&gt;，&lt;code&gt;锅外的大佬&lt;/code&gt;，&lt;code&gt;二师兄&lt;/code&gt;等，我和群里小伙伴无数次的探讨方向和修补改进方案等，增长了见识同时也坚定了做好的态度和信念&lt;/p&gt;
&lt;p&gt;认识了各大网站的运营小姐姐，小哥哥，偶尔发的文章能被翻牌到首页「侍寝」着实幸运，我亲爱的小伙伴和朋友们，感谢与你相遇，更感恩相遇和相知🙏&lt;/p&gt;
&lt;h2 id=&quot;pmp&quot;&gt;PMP&lt;/h2&gt;
&lt;p&gt;PMP(Project Management Professional)，俗称「拍马屁」，和「别摸我」有异曲同工之处😂。毕业后就没考过试，感觉前 20 多年的技能包快丢没了，看到朋友有拿到PMP 证书的，恰逢公司还给报销部分费用(这很关键)，决定尝试一遭，2019 年 9 月报名，12 月 7 日考试，2020 年 1 月 17 日拿到结果，5A 通过考试，顺利拿到纪念版红色证书。&lt;/p&gt;
&lt;p&gt;考试本身感觉没什么意义，但是感觉学习过程的思维，思考模式以及一些软技能还是值得长期深入思考琢磨的。有兴趣的朋友咱们聊一聊&lt;/p&gt;
&lt;h2 id=&quot;运动&quot;&gt;运动&lt;/h2&gt;
&lt;p&gt;整个一年还是保持了相对规律的运动节奏，基本一周一场羽毛球，Keep 晨练(早晨练一会瑜伽拉伸一下筋骨感觉一天都轻松了许多)。每天多几秒的累加训练，平板支撑（plank）可以做到坚持 12 分钟。&lt;/p&gt;
&lt;p&gt;以为自己要起飞，买了健腹轮，核心力量还是不足，腰部受伤，一下回到解放前。目前已经恢复训练了。除了指定季节的过敏性鼻炎外(有良方，还请伸出援助之手)，身体基本上没什么问题。&lt;/p&gt;
&lt;h2 id=&quot;鸡汤&quot;&gt;鸡汤&lt;/h2&gt;
&lt;p&gt;鸡汤不喝不行，但喝多了我认为会中毒，我找到了我的专属鸡汤，比如下面这款味道醇香的鸡汤，喝过之后让我飘飘欲仙&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/202001/1583165-20200120083944065-1735477640.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有这稍微发涩的鸡汤，喝过之后回味无穷啊😂&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/202001/1583165-20200120083944538-1395321840.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;鸡汤味道不同，都很补人。得到肯定，保持节奏继续前进；获得批评，总结反思加以提高&lt;/p&gt;
&lt;h2 id=&quot;小成果&quot;&gt;小成果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/202001/1583165-20200120083945399-1775866675.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2019 至此归零......，「幸运」和「踏实」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;走你&quot;&gt;2020 走你&lt;/h2&gt;
&lt;p&gt;不敢憧憬太多，先奖励自己一双羽毛球鞋吧，球场不受伤，生活不感伤，腹肌再向下挪两块，全新呵护这颗 2019 年种下的树，脚踏实地......&lt;/p&gt;
&lt;p&gt;单曲还在循环，写到这什么心情呢？看看这首歌的评论吧，就是这种撞南墙的心态吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/202001/1583165-20200120083954557-1482495900.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;南墙撞的还是挺疼，写到这吧，感谢看到这里的帅哥美女们，诚实的为自己拉上一票，喜欢的话给个赞，分享，关注(奢求有点多)，背后创作不易，坚持做优而美的技术公众号。致敬朋友，干杯🍺 (这是饮料，我酒精过敏)&lt;/p&gt;
&lt;p&gt;真的到这里了，我要排版了.....&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;欢迎持续关注公众号日拱一兵&quot;&gt;欢迎持续关注公众号：「日拱一兵」&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;前沿 Java 技术干货分享&lt;/li&gt;
&lt;li&gt;高效工具汇总 | 回复「工具」&lt;/li&gt;
&lt;li&gt;面试问题分析与解答&lt;/li&gt;
&lt;li&gt;技术资料领取 | 回复「资料」&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/202001/1583165-20200120083957665-2080649629.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 00:40:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>作为生长在内蒙的，不会套马的，酒精过敏的，不吃羊肉的，也不魁梧的奇葩，单曲循环听着腾格尔大爷的翻唱歌曲「可能否」，还是开始写了 2019 年总结，这个总结比 2002 &amp;#128518; 年来的更晚一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/12216551.html</dc:identifier>
</item>
<item>
<title>线程上下文类加载器ContextClassLoader内存泄漏隐患 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/12216546.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/12216546.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;今天（&lt;code&gt;2020-01-18&lt;/code&gt;）在编写&lt;code&gt;Netty&lt;/code&gt;相关代码的时候，从&lt;code&gt;Netty&lt;/code&gt;源码中的&lt;code&gt;ThreadDeathWatcher&lt;/code&gt;和&lt;code&gt;GlobalEventExecutor&lt;/code&gt;追溯到两个和线程上下文类加载器&lt;code&gt;ContextClassLoader&lt;/code&gt;内存泄漏相关的&lt;code&gt;Issue&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;两个&lt;code&gt;Issue&lt;/code&gt;分别是两位前辈在&lt;code&gt;2017-12&lt;/code&gt;的时候提出的，描述的是同一类问题，最后被&lt;code&gt;Netty&lt;/code&gt;的负责人采纳，并且修复了对应的问题从而关闭了&lt;code&gt;Issue&lt;/code&gt;。这里基于这两个&lt;code&gt;Issue&lt;/code&gt;描述的内容，对&lt;code&gt;ContextClassLoader&lt;/code&gt;内存泄漏隐患做一次复盘。&lt;/p&gt;
&lt;h2 id=&quot;classloader相关的内容&quot;&gt;ClassLoader相关的内容&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一个&lt;code&gt;JVM&lt;/code&gt;实例（&lt;code&gt;Java&lt;/code&gt;应用程序）里面的所有类都是通过&lt;code&gt;ClassLoader&lt;/code&gt;加载的。&lt;/li&gt;
&lt;li&gt;不同的&lt;code&gt;ClassLoader&lt;/code&gt;在&lt;code&gt;JVM&lt;/code&gt;中有不同的命名空间，一个类实例（&lt;code&gt;Class&lt;/code&gt;）的唯一标识是全类名 + &lt;code&gt;ClassLoader&lt;/code&gt;，也就是不同的&lt;code&gt;ClassLoader&lt;/code&gt;加载同一个类文件，也会得到不相同的&lt;code&gt;Class&lt;/code&gt;实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt;不提供类卸载的功能，从目前参考到的资料来看，类卸载需要满足下面几点：
&lt;ul&gt;&lt;li&gt;条件一：&lt;code&gt;Class&lt;/code&gt;的所有实例不被强引用（不可达）。&lt;/li&gt;
&lt;li&gt;条件二：&lt;code&gt;Class&lt;/code&gt;本身不被强引用（不可达）。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;条件三&lt;/span&gt;：加载该&lt;code&gt;Class&lt;/code&gt;的&lt;code&gt;ClassLoader&lt;/code&gt;实例不被强引用（不可达）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有些场景下需要实现类的热部署和卸载，例如定义一个接口，然后由外部动态传入代码的实现。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这一点很常见，最典型的就是在线编程，代码传到服务端再进行编译和运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于应用启动期所有非&lt;code&gt;JDK&lt;/code&gt;类库的类都是由&lt;code&gt;AppClassLoader&lt;/code&gt;加载，我们没有办法通过&lt;code&gt;AppClassLoader&lt;/code&gt;去加载非类路径下的已存在同名的类文件（对于一个&lt;code&gt;ClassLoader&lt;/code&gt;而言，每个类文件只能加载一次，生成唯一的&lt;code&gt;Class&lt;/code&gt;），所以为了动态加载类，每次必须使用完全不同的自定义&lt;code&gt;ClassLoader&lt;/code&gt;实例加载同一个类文件或者使用同一个自定义的&lt;code&gt;ClassLoader&lt;/code&gt;实例加载不同的类文件。类的热部署这里举个简单例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 此文件在项目类路径
package club.throwable.loader;
public class DefaultHelloService implements HelloService {

    @Override
    public String sayHello() {
        return &quot;default say hello!&quot;;
    }
}

// 下面两个文件编译后放在I盘根目录
// I:\\DefaultHelloService1.class
package club.throwable.loader;
public class DefaultHelloService1 implements HelloService {

    @Override
    public String sayHello() {
        return &quot;1 say hello!&quot;;
    }
}
// I:\\DefaultHelloService2.class
package club.throwable.loader;
public class DefaultHelloService2 implements HelloService {

    @Override
    public String sayHello() {
        return &quot;2 say hello!&quot;;
    }
}

// 接口和运行方法
public interface HelloService {

    String sayHello();

    static void main(String[] args) throws Exception {
        HelloService helloService = new DefaultHelloService();
        System.out.println(helloService.sayHello());
        ClassLoader loader = new ClassLoader() {

            @Override
            protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
                String location = &quot;I:\\DefaultHelloService1.class&quot;;
                if (name.contains(&quot;DefaultHelloService2&quot;)) {
                    location = &quot;I:\\DefaultHelloService2.class&quot;;
                }
                File classFile = new File(location);
                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                try {
                    InputStream stream = new FileInputStream(classFile);
                    int b;
                    while ((b = stream.read()) != -1) {
                        outputStream.write(b);
                    }
                } catch (IOException e) {
                    throw new IllegalArgumentException(e);
                }
                byte[] bytes = outputStream.toByteArray();
                return super.defineClass(name, bytes, 0, bytes.length);
            }
        };
        Class&amp;lt;?&amp;gt; klass = loader.loadClass(&quot;club.throwable.loader.DefaultHelloService1&quot;);
        helloService = (HelloService) klass.newInstance();
        System.out.println(helloService.sayHello());
        klass = loader.loadClass(&quot;club.throwable.loader.DefaultHelloService2&quot;);
        helloService = (HelloService) klass.newInstance();
        System.out.println(helloService.sayHello());
    }
}

// 控制台输出
default say hello!
1 say hello!
2 say hello!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果新建过多的&lt;code&gt;ClassLoader&lt;/code&gt;实例和&lt;code&gt;Class&lt;/code&gt;实例，会占用大量的内存，如果由于上面几个条件无法全部满足，也就是这些&lt;code&gt;ClassLoader&lt;/code&gt;实例和&lt;code&gt;Class&lt;/code&gt;实例一直堆积无法卸载，那么就会导致内存泄漏（&lt;code&gt;memory leak&lt;/code&gt;，后果很严重，有可能耗尽服务器的物理内存，因为&lt;code&gt;JDK1.8+&lt;/code&gt;类相关元信息存在在元空间&lt;code&gt;metaspace&lt;/code&gt;，而元空间使用的是&lt;code&gt;native memory&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;线程中的contextclassloader&quot;&gt;线程中的ContextClassLoader&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ContextClassLoader&lt;/code&gt;其实指的是线程类&lt;code&gt;java.lang.Thread&lt;/code&gt;中的&lt;code&gt;contextClassLoader&lt;/code&gt;属性，它是&lt;code&gt;ClassLoader&lt;/code&gt;类型，也就是类加载器实例。有些场景下，&lt;code&gt;JDK&lt;/code&gt;提供了一些标准接口需要第三方提供商去实现（最常见的就是&lt;code&gt;SPI&lt;/code&gt;，&lt;code&gt;Service Provider Interface&lt;/code&gt;，例如&lt;code&gt;java.sql.Driver&lt;/code&gt;），这些标准接口类是由启动类加载器(&lt;code&gt;Bootstrap ClassLoader&lt;/code&gt;)加载，但是这些接口的实现类需要从外部引入，本身不属于&lt;code&gt;JDK&lt;/code&gt;的原生类库，无法用启动类加载器加载。为了解决此困境，引入了线程上下文类加载器&lt;code&gt;Thread Context ClassLoader&lt;/code&gt;。线程&lt;code&gt;java.lang.Thread&lt;/code&gt;实例在初始化的时候会调用&lt;code&gt;Thread#init()&lt;/code&gt;方法，&lt;code&gt;Thread&lt;/code&gt;类和&lt;code&gt;contextClassLoader&lt;/code&gt;相关的核心代码块如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 线程实例的初始化方法,new Thread()的时候一定会调用
private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc,
                      boolean inheritThreadLocals) {
    // 省略其他代码
    Thread parent = currentThread();
    // 省略其他代码
    if (security == null || isCCLOverridden(parent.getClass()))
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    // 省略其他代码
}

public void setContextClassLoader(ClassLoader cl) {
    SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
        sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));
    }
    contextClassLoader = cl;
}

@CallerSensitive
public ClassLoader getContextClassLoader() {
    if (contextClassLoader == null)
        return null;
    SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
        ClassLoader.checkClassLoaderPermission(contextClassLoader, Reflection.getCallerClass());
    }
    return contextClassLoader;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先明确两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Thread&lt;/code&gt;实例允许手动设置&lt;code&gt;contextClassLoader&lt;/code&gt;属性，覆盖当前的线程上下文类加载器实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread&lt;/code&gt;在初始化实例（调用&lt;code&gt;new Thread()&lt;/code&gt;）的时候一定会调用&lt;code&gt;Thread#init()&lt;/code&gt;方法，新建的子线程实例会继承父线程的&lt;code&gt;contextClassLoader&lt;/code&gt;属性，而应用主线程&lt;code&gt;[main]&lt;/code&gt;的&lt;code&gt;contextClassLoader&lt;/code&gt;一般是应用类加载器（&lt;code&gt;Application ClassLoader&lt;/code&gt;，有时也称为系统类加载器），其他用户线程都是主线程派生出来的后代线程，如果不覆盖&lt;code&gt;contextClassLoader&lt;/code&gt;，那么新建的后代线程的&lt;code&gt;contextClassLoader&lt;/code&gt;就是应用类加载器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分析到这里，笔者只想说明一个结论：后代线程的线程上下文类加载器会继承父线程的线程上下文类加载器，其实这里用继承这个词语也不是太准确，准确来说应该是&lt;strong&gt;后代线程的线程上下文类加载器和父线程的上下文类加载器完全相同，如果都派生自主线程，那么都是应用类加载器&lt;/strong&gt;。对于这个结论可以验证一下（下面例子在&lt;code&gt;JDK8&lt;/code&gt;中运行）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadContextClassLoaderMain {

    public static void main(String[] args) throws Exception {
        AtomicReference&amp;lt;Thread&amp;gt; grandSonThreadReference = new AtomicReference&amp;lt;&amp;gt;();
        Thread sonThread = new Thread(() -&amp;gt; {
            Thread thread = new Thread(()-&amp;gt; {},&quot;grand-son-thread&quot;);
            grandSonThreadReference.set(thread);
        }, &quot;son-thread&quot;);
        sonThread.start();
        Thread.sleep(100);
        Thread main = Thread.currentThread();
        Thread grandSonThread = grandSonThreadReference.get();
        System.out.println(String.format(&quot;ContextClassLoader of [main]:%s&quot;, main.getContextClassLoader()));
        System.out.println(String.format(&quot;ContextClassLoader of [%s]:%s&quot;,sonThread.getName(), sonThread.getContextClassLoader()));
        System.out.println(String.format(&quot;ContextClassLoader of [%s]:%s&quot;, grandSonThread.getName(), grandSonThread.getContextClassLoader()));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ContextClassLoader of [main]:sun.misc.Launcher$AppClassLoader@18b4aac2
ContextClassLoader of [son-thread]:sun.misc.Launcher$AppClassLoader@18b4aac2
ContextClassLoader of [grand-son-thread]:sun.misc.Launcher$AppClassLoader@18b4aac2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;印证了前面的结论，主线程、子线程、孙子线程的线程上下文类加载器都是&lt;code&gt;AppClassLoader&lt;/code&gt;类型，并且指向同一个实例&lt;code&gt;sun.misc.Launcher$AppClassLoader@18b4aac2&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;contextclassloader设置不当导致内存泄漏的隐患&quot;&gt;ContextClassLoader设置不当导致内存泄漏的隐患&lt;/h2&gt;
&lt;p&gt;只要有大量热加载和卸载动态类的场景，就需要警惕后代线程&lt;code&gt;ContextClassLoader&lt;/code&gt;设置不当导致内存泄漏。画个图就能比较清楚：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412331/202001/1412331-20200120083627021-1925098407.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;父线程中设置了一个自定义类加载器，用于加载动态类，&lt;strong&gt;子线程新建的时候直接使用了父线程的自定义类加载器，导致该自定义类加载器一直被子线程强引用&lt;/strong&gt;，结合前面的类卸载条件分析，所有由该自定义类加载器加载出来的动态类都不能被卸载，导致了内存泄漏。这里还是基于文章前面的那个例子做改造：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新增一个线程&lt;code&gt;X&lt;/code&gt;用于进行类加载，新建一个自定义类加载器，设置线程&lt;code&gt;X&lt;/code&gt;的上下文类加载器为该自定义类加载器。&lt;/li&gt;
&lt;li&gt;线程&lt;code&gt;X&lt;/code&gt;运行方法中创建一个新线程&lt;code&gt;Y&lt;/code&gt;，用于接收类加载成功的事件并且进行打印。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface HelloService {

    String sayHello();

    BlockingQueue&amp;lt;String&amp;gt; CLASSES = new LinkedBlockingQueue&amp;lt;&amp;gt;();

    BlockingQueue&amp;lt;String&amp;gt; EVENTS = new LinkedBlockingQueue&amp;lt;&amp;gt;();

    AtomicBoolean START = new AtomicBoolean(false);

    static void main(String[] args) throws Exception {
        Thread thread = new Thread(() -&amp;gt; {
            ClassLoader loader = new ClassLoader() {

                @Override
                protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
                    String location = &quot;I:\\DefaultHelloService1.class&quot;;
                    if (name.contains(&quot;DefaultHelloService2&quot;)) {
                        location = &quot;I:\\DefaultHelloService2.class&quot;;
                    }
                    File classFile = new File(location);
                    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                    try {
                        InputStream stream = new FileInputStream(classFile);
                        int b;
                        while ((b = stream.read()) != -1) {
                            outputStream.write(b);
                        }
                    } catch (IOException e) {
                        throw new IllegalArgumentException(e);
                    }
                    byte[] bytes = outputStream.toByteArray();
                    Class&amp;lt;?&amp;gt; defineClass = super.defineClass(name, bytes, 0, bytes.length);
                    try {
                        EVENTS.put(String.format(&quot;加载类成功,类名:%s&quot;, defineClass.getName()));
                    } catch (Exception ignore) {

                    }
                    return defineClass;
                }
            };
            Thread x = new Thread(() -&amp;gt; {
                try {
                    if (START.compareAndSet(false, true)) {
                        Thread y = new Thread(() -&amp;gt; {
                            try {
                                for (; ; ) {
                                    String event = EVENTS.take();
                                    System.out.println(&quot;接收到事件,事件内容:&quot; + event);
                                }
                            } catch (Exception ignore) {

                            }
                        }, &quot;Y&quot;);
                        y.setDaemon(true);
                        y.start();
                    }
                    for (; ; ) {
                        String take = CLASSES.take();
                        Class&amp;lt;?&amp;gt; klass = loader.loadClass(take);
                        HelloService helloService = (HelloService) klass.newInstance();
                        System.out.println(helloService.sayHello());
                    }
                } catch (Exception ignore) {

                }
            }, &quot;X&quot;);
            x.setContextClassLoader(loader);
            x.setDaemon(true);
            x.start();
        });
        thread.start();
        CLASSES.put(&quot;club.throwable.loader.DefaultHelloService1&quot;);
        CLASSES.put(&quot;club.throwable.loader.DefaultHelloService2&quot;);
        Thread.sleep(5000);
        System.gc();
        Thread.sleep(5000);
        System.gc();
        Thread.sleep(Long.MAX_VALUE);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;接收到事件,事件内容:加载类成功,类名:club.throwable.loader.DefaultHelloService1
1 say hello!
接收到事件,事件内容:加载类成功,类名:club.throwable.loader.DefaultHelloService2
2 say hello!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开&lt;code&gt;VisualVM&lt;/code&gt;，&lt;code&gt;Dump&lt;/code&gt;对应进程的内存快照，多执行几次&lt;code&gt;GC&lt;/code&gt;，发现了所有动态类都没有被卸载（这里除非主动终止线程&lt;code&gt;Y&lt;/code&gt;释放自定义&lt;code&gt;ClassLoader&lt;/code&gt;，否则永远都不可能释放该强引用），验证了前面的结论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412331/202001/1412331-20200120083604824-1133508242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，这里只是加载了两个动态类，如果在特殊场景之下，例如在线编码和运行代码，那么有可能极度频繁动态编译和动态类加载，如果出现了上面类似的内存泄漏，那么很容易导致服务器内存耗尽。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;参考那两个&lt;code&gt;Issue&lt;/code&gt;，解决方案（或者说预防手段）基本上有两个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不需要使用自定义类加载器的线程（如事件派发线程等）优先初始化，那么一般它的线程上下文类加载器是应用类加载器。&lt;/li&gt;
&lt;li&gt;新建后代线程的时候，手动覆盖它的线程上下文类加载器，参考&lt;code&gt;Netty&lt;/code&gt;的做法，在线程初始化的时候做如下的操作：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// ThreadDeathWatcher || GlobalEventExecutor
AccessController.doPrivileged(new PrivilegedAction&amp;lt;Void&amp;gt;() {
    @Override
    public Void run() {
        watcherThread.setContextClassLoader(null);
        return null;
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这篇文章算是近期研究得比较深入的一篇文章，&lt;code&gt;ContextClassLoader&lt;/code&gt;内存泄漏的隐患归根到底是引用使用不当导致一些本来在方法栈退出之后需要释放的引用无法释放导致的。这种问题有些时候隐藏得很深，而一旦命中了同样的问题并且在并发的场景之下，那么内存泄漏的问题会恶化得十分快。这类问题归类为性能优化，而性能优化是十分大的专题，以后应该也会遇到类似的各类问题，这些经验希望能对未来产生正向的作用。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《深入理解Java虚拟机 - 3rd》&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;我的个人博客&quot;&gt;我的个人博客&lt;/h2&gt;
&lt;p&gt;（本文完 c-2-d e-a-20200119）&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 00:37:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 今天（ ）在编写 相关代码的时候，从 源码中的 和`GlobalEventExecutor ContextClassLoader Issue`： &amp;quot;ThreadDeathWatcher</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/12216546.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] Options[7]: 与配置系统的整合 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-06-07.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-06-07.html</guid>
<description>&lt;p&gt;Options模型本身与配置系统完全没有关系，但是配置在大部分情况下会作为绑定Options对象的数据源，所以有必要将两者结合在一起。与《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-06.html&quot;&gt;扩展与定制&lt;/a&gt;》演示的两个例子一样，针对配置系统的集成同样是通过定制Options模型相应的对象来实现的。具体来说，集成配置系统需要解决如下两个问题:&lt;/p&gt;
&lt;p&gt;第一个问题涉及针对Options对象的初始化问题，这自然是通过自定义IConfigureOptions&amp;lt;TOptions&amp;gt;实现类型来解决的，具体来说就是下面的NamedConfigureFromConfigurationOptions&amp;lt;TOptions&amp;gt;类型，它定义在NuGet包“Microsoft.Extensions.Options.ConfigurationExtensions”中。如下面的代码片段所示，&lt;span&gt;NamedConfigureFromConfigurationOptions&amp;lt;TOptions&amp;gt;&lt;/span&gt;通过调用ConfigurationBinder的静态方法Bind利用配置绑定机制来实现配置数据向Options对象的转换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NamedConfigureFromConfigurationOptions&amp;lt;TOptions&amp;gt; : ConfigureNamedOptions&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; NamedConfigureFromConfigurationOptions(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, IConfiguration config)
        : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;(name, options =&amp;gt;&lt;span&gt; ConfigurationBinder.Bind(config, options))
    {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个问题则采用自定义的IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;实现类型来解决，具体提供的就是下面的&lt;span&gt;ConfigurationChangeTokenSource&amp;lt;TOptions&amp;gt;。&lt;/span&gt;从给出的代码片段可以看出，GetChangeToken方法直接调用IConfiguration对象的GetReloadToken方法得到返回的IChangeToken对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConfigurationChangeTokenSource&amp;lt;TOptions&amp;gt; : IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IConfiguration _config;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigurationChangeTokenSource(IConfiguration config) : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;(Options.DefaultName, config)
    { }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigurationChangeTokenSource(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, IConfiguration config)
    {
        _config &lt;/span&gt;=&lt;span&gt; config;
        Name &lt;/span&gt;= name ??&lt;span&gt; Options.DefaultName;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IChangeToken GetChangeToken() =&amp;gt;&lt;span&gt; _config.GetReloadToken()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将IConfiguration对象绑定为Options对象的NamedConfigureFromConfigurationOptions&amp;lt;TOptions&amp;gt;和用来检测配置数据变化的ConfigurationChangeTokenSource&amp;lt;TOptions&amp;gt;都是通过下面的Configure&amp;lt;TOptions&amp;gt;扩展方法来注册的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionsConfigurationServiceCollectionExtensions
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection services, IConfiguration config) &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
        =&amp;gt; services.Configure&amp;lt;TOptions&amp;gt;&lt;span&gt;(Options.Options.DefaultName, config);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;string&lt;/span&gt; name, IConfiguration config)  &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
        =&amp;gt;&lt;span&gt; services
         .AddSingleton&lt;/span&gt;&amp;lt;IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;&amp;gt;( &lt;span&gt;new&lt;/span&gt; ConfigurationChangeTokenSource&amp;lt;TOptions&amp;gt;&lt;span&gt;(name, config))
         .AddSingleton&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;( &lt;span&gt;new&lt;/span&gt; NamedConfigureFromConfigurationOptions&amp;lt;TOptions&amp;gt;&lt;span&gt;(name, config));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[1]: 配置选项的正确使用方式[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[2]: 配置选项的正确使用方式[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[3]: Options模型[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[4]: Options模型[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[5]: 依赖注入&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[6]: 扩展与定制&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[7]: 与配置系统的整合&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 00:36:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>Options模型本身与配置系统完全没有关系，但是配置在大部分情况下会作为绑定Options对象的数据源，所以有必要将两者结合在一起。与《扩展与定制》演示的两个例子一样，针对配置系统的集成同样是通过定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-06-07.html</dc:identifier>
</item>
<item>
<title>如何快速融入团队并成为团队核心(三) - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/12216540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/12216540.html</guid>
<description>&lt;p&gt;如何快速融入团队，看似是个简单的问题，其实并非如此。&lt;/p&gt;
&lt;p&gt;有时取决于你的性格、有时取决于你的机会，有时取决于企业是否拥有开放的心态或那些拥有开放心态的伙伴，还有时取决于企业的愿景、使命和价值观，以及这些因素的综合作用，同时也包括企业与你是否存在基因上的契合，或者企业文化本身，乃至企业的江湖规矩。&lt;/p&gt;

&lt;p&gt;基因是个奇妙的东西，似乎在吴军老师撰写《浪潮之巅》之前并不怎么引人注目，而随着吴军老师在书中将基因论作为企业能否顺应互联网的浪潮，并取得辉煌成就的关键因素后，就在坊间开始盛行起来。&lt;/p&gt;
&lt;p&gt;这个理论最早被美国管理大师Noel Tichy引入的概念，他把企业称为一个具有活力的生命体，来自于资本和劳动力的双螺旋结构，在创始人、机制、技术和文化等环境因素的共同激励下，促使企业以飞快的速度得以成长。&lt;/p&gt;
&lt;p&gt;基因看似是很重要的东西，但是也并非每家企业都一定被基因主导。吴军老师也提到了一些公司，从原本看起来不起眼的制造业，转型成为更加具有高附加值的创新型企业，公司管理层所具备的高瞻远瞩精神和善于创新、积极拥抱创新的态度，是企业得以长盛不衰的关键因素，他把这种称为转基因。&lt;/p&gt;
&lt;p&gt;从我们的角度来说，或许基因是个很远的东西，是对我们产生了某些看不到、客观存在的影响。&lt;/p&gt;
&lt;p&gt;例如，阿里巴巴的电商基因，使阿里巴巴人更具有应对风险和危机的意识，并透过企业管理一系列流程体现在公司的文化中。那些有幸加入过阿里巴巴的人，许多人都具有一种独特的气质，这种气质使他能够在困难面前无所畏惧，同时又能更好的适应变化的存在。大概这种气质也正是来源于阿里巴巴企业基因中最核心价值观的投影。&lt;/p&gt;
&lt;p&gt;也有人曾经有人说腾讯为何以前面向B端转型一直不太成果，大概是由于腾讯的基因都是游戏或社交基因，而除了主阵地之外的其他领域几乎都毫无建树，就连有吴军老师加持的腾讯地图，也未能在LBS领域获得多大的市场。不过随着腾讯云的兴起，这些局面已经有所改观，但是腾讯在智慧产业方面的布局，是否能够重现其在云端市场的效果，依然值得期待。&lt;/p&gt;
&lt;p&gt;企业基因的客观存在，或多或少会在我们的每一段职场经历产生积极或消极的影响。例如从公司获得了高层资源、人脉、解决问题的方法，这些都会对我们的未来产生商业上积极的促进作用。企业基因或多或少影响了职场基因。如果说初入职场的我们的职场基因看起来毫无特色，那么在职场中的不断挑战和历练，已经让我们的职场基因受到了大量的诱因而不断蜕变，从而形成了今天更加完美的个体。&lt;/p&gt;

&lt;p&gt;越来越多的人重视企业文化的存在，因为企业文化如饮水、如呼吸般时刻存在，对凝聚集体，形成战斗力，一起共同思考公司的发展方向。优秀的企业文化也是企业得以长盛不衰的驱动力和灵魂。&lt;/p&gt;
&lt;p&gt;企业文化的价值在于唤醒和激发团队的每一位成员对于企业的认同感、使命感和价值感。&lt;/p&gt;
&lt;p&gt;基因与文化的耦合是如此紧密，以至于“基因和文化不可分离地连载一起，任何一个变化都将不可避免地迫使另一个也发生变化”。文化进化能塑造基因组，但也可以说基因对文化也存在必然的影响。&lt;/p&gt;
&lt;p&gt;创业公司或者中小公司或许都不重视企业文化的存在，因为企业认为可以依靠员工的自驱力来实现认同感和使命感，甚至也有许多人认为在创业公司谈文化是一种非常奢侈的行为，因为要刻意营造一个企业文化的氛围，往往需要从公司层面做好规划，例如采取绩效激励的策略，鼓励积极乐观正向有利于企业发展的文化，往往也会导致企业中好不容易招到的人才会逐渐流失，进而影响了创业企业的发展。&lt;/p&gt;
&lt;p&gt;但随着公司的逐渐增长，等发展到一定规模时，往往再构建一套企业文化体系，同样会带来不小的阵痛期，因为团队已经形成了一定的“江湖规矩”，如果这样的江湖规矩能够与企业文化完美的契合，或许还能平滑的过度，但是如果彼此发生了抵触，那显然会带来巨大的过度成本，有时候甚至会导致团队分崩离析。&lt;/p&gt;
&lt;p&gt;有一个经典的管理学理论“湿猴理论”是这么说的：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;把A、B、C、D、E五只饿了极了的猴子关在一个笼子里，笼子上头掉着一串香蕉，正下方是一个箱子，如果猴子要拿香蕉必须爬上箱子。实验人员装了一个自动装置，若是侦测到有猴子要去爬箱子，就会有大水喷向笼子，这五只猴子马上会被淋湿。首先会有猴子想去拿香蕉，马上水喷出来，它们慌忙用手抱住头，当手离开香蕉的时候，水就立即停止喷射。每只猴子都去尝试了，都得到了同样的结果，开始不明白为什么，但后来知道只要去爬箱子拿香蕉，就会有大水喷来。於是猴子们达到一个共识：不要去拿香蕉！因为有水会喷出来！&lt;br/&gt;后来实验人员把其中的一只猴子换掉，换一只新猴子（称为F猴子好了）关到笼子里。这只F猴子看到香蕉，马上想要去拿，结果被其他四只旧猴子揍了一顿。因为其他四只猴子认为新猴子会害他们被水淋到，所以制止这新猴子去拿香蕉。这新猴子尝试了几次，被打的满头包，还是没有拿到香蕉，当然这五只猴子就没有被水喷到。后来实验人员再把一只旧猴子换掉，换另外一只新猴子（称为G猴子好了）关到笼子里，这支G猴子看到香蕉，当然也是马上要去拿，结果也是被其他四只猴子揍了一顿。那只F猴子打的特别用力,G猴子试了几次总是被打的很惨，只好作罢。&lt;br/&gt;后来慢慢的一只一只的，所有的旧猴子都换成新猴子了。大家都不敢去动那香蕉，但是他们都不知道为什么，只知道去动香蕉会被其他猴子扁。这就是“传统”的由来，这个故事被用来介绍企业文化的建立等诸多管理方面有很好的寓意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;企业文化的建立，就像这个理论中所说，如果在早期采取某些措施有意无意的培养，营造更加积极乐观进取的企业文化氛围，并找对契合企业文化的人才，在发展过程中逐渐的对这些文化意识进行增强，实际上将会对企业的快速发展提供巨大的助力。&lt;/p&gt;

&lt;p&gt;“有人的地方就有江湖”。&lt;/p&gt;
&lt;p&gt;IT公司也同样如此，许多时候往往还没形成企业文化，反而会先形成江湖规矩。而江湖规矩有许多种。&lt;/p&gt;
&lt;p&gt;例如某种大哥文化，在公司发展的早期，往往会依托创始人的个人魅力招揽到一批与其情投意合的人，随着公司的发展，却并非每个人都以打造完美的公司为目标，有的早期员工难免加入公司的目的，就是为了早点占好山头，作威作福。于是公司倒是发展好了，但是大哥却成为最难啃的骨头，或是任人唯亲，或是贪污受贿，或是故意把控住某些关键命门，让全公司都必须看他的脸色行事。&lt;/p&gt;
&lt;p&gt;例如某种荤段子文化和烟文化，好吧，听某大型互联网公司朋友说的。在他们的某些部门，荤段子文化特别严重，所以加入了公司就得接受公司的规矩，从能听荤段子开始，到能讲荤段子，那就说明你已经被组织熏陶得非常到位了。除此之外，有的部门烟文化特别严重，像极了某些国企部门，依托烟文化来维系人际关系，不得不说依然是中国人获得人脉的不二法门。&lt;/p&gt;
&lt;p&gt;譬如游戏文化，鄙人曾经呆过的一家公司就以团队对战游戏Dota进行团队建设当成公司核心企业文化的一部分，于是那些对Dota这种游戏毫无兴趣、或者不愿意在公司玩RPG游戏、或者不喜欢乱糟糟的氛围的人，就很难融入团队中，直到流失。&lt;/p&gt;
&lt;p&gt;即便有了企业文化，往往依然有江湖规矩。如果把企业文化理解为宗教中形而上的思想哲学，那江湖规矩就是具体执行层面的道德约束，如果只是口头上宣讲企业文化的正面，而忽略了同样需要改革甚至破除的影响企业良性发展的“丑陋”的江湖规矩，往往体现了公司在执行层面的巨大缺失，也将为公司的发展埋下隐患。&lt;/p&gt;

&lt;p&gt;软件企业的发展，往往并非一朝一夕的爆发，更是从内功到外功的修炼之路，始于企业基因，成于企业文化，毁于江湖规矩，恰好就像一个个体的发育过程中精神修炼，那如何强身健体呢？&lt;/p&gt;
&lt;p&gt;大概还有团队建设、目标建设、和时间管理吧。接下来的三章，我们来探讨一下这三个问题。&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 00:35:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>一 引子 如何快速融入团队，看似是个简单的问题，其实并非如此。 有时取决于你的性格、有时取决于你的机会，有时取决于企业是否拥有开放的心态或那些拥有开放心态的伙伴，还有时取决于企业的愿景、使命和价值观，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/12216540.html</dc:identifier>
</item>
<item>
<title>—信息安全威胁 - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/12216081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/12216081.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;懒惰等于将一个人活埋。——泰勒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;h3 align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/midou-tech/articles&quot; target=&quot;_blank&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;h4&gt;&lt;span&gt;点关注，不迷路！！！&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt; 上一期我们罗列了密码学的基础框架以后，不少小伙伴就已经迫不及待的催更了，那么，来了来了来了，从今天《每天懂点密码学》系列就要正式输出了，今天先给大家讲第一趴，也就是对一些预备知识及进行一次彻底的扫盲运动，清除障碍，轻松上路，你离老司机还远吗？😏&lt;/p&gt;
&lt;p&gt; 这一pa要讲的是信息在传递过程中可能面临的一些威胁，为什么要把这个放在最开始讲呢，因为正是有了对信息的威胁，才迫切的需要我们利用密码来保护我们的信息，不信？您接着瞧&lt;/p&gt;
&lt;h5 id=&quot;h&quot;&gt;&lt;span&gt;信息安全所面临的威胁:&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 信息安全所面临的威胁有很多方面，而且这种威胁不是一成不变的，他们在随着时间的变化而变化。这些威胁可以大概分为&lt;strong&gt;人为威胁&lt;/strong&gt;和&lt;strong&gt;自然威胁&lt;/strong&gt;。自然威胁就不必多说，主要讲讲一些人为的威胁，在信息的传输过程中，人们利用系统的弱点，可以通过一些手段对信息进行篡改，可能对发送方或者接收方造成一定的损失。&lt;/p&gt;
&lt;p&gt; 人为攻击一般分为被动攻击和主动攻击，被动攻击一种是指直接获取消息的内容，还有一种是对消息的某些特征进行分析，虽然不能得到完整的消息内容但也可以推测出信息的一些特点，而这些特点有可能是通信双方不想被泄露的。但是被动攻击一般情况下不会改变消息的内容，所以我们很难检测到，只能提前预防。主动攻击是指对数据的篡改来产生某些假的数据，防止主动攻击一般都非常困难，需要提前预防。&lt;/p&gt;
&lt;h5 id=&quot;h-1&quot;&gt;&lt;span&gt;信息安全模型：&lt;/span&gt;&lt;/h5&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200119154742245.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI4NzM4,size_16,color_FFFFFF,t_70&quot; alt=&quot;信息安全模型&quot; title=&quot;信息安全模型&quot;/&gt;信息安全模型
&lt;p&gt; 用户之间如果想要传递某一个消息，首先需要在网络中定义从发送方到接收方的一个路由，然后在该路由上共同执行通信协议，通信双方只有建立这样的信道，才能保证信息传递的效率。一般情况下，我们如果需要防止所传信息遭遇敌手的威胁，例如对其保密性、认证性等的破坏，则需要考虑通信的安全性。&lt;/p&gt;
&lt;p&gt; 安全传输技术主要包括两部分，一是指对消息的安全传输，包括对消息的加密和认证。加密的目的是将消息搞乱以使攻击者无法读懂，认证的目的是检查发送者的身份。二是通信双方共享的某些秘密信息，如加密密钥。为获得消息的安全传输，可能还需要一个可信的第三方，其作用可能是负责向通信双方发布秘密信息或者在通信双方有争议时进行仲裁。&lt;/p&gt;
&lt;h5 id=&quot;h-2&quot;&gt;&lt;span&gt;保密通信系统：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;明文：&lt;/strong&gt;发送方所要发送的消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;密文：&lt;/strong&gt;明文经过加密以后变成了看似没有关联的随机消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加密：&lt;/strong&gt;利用加密密钥通过加密算法将明文变成密文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解密：&lt;/strong&gt;利用解密密钥通过解密算法密文反过来变成明文&lt;/p&gt;
&lt;p&gt; 传统密码体制所用的加密密钥和解密密钥是相同的，也就是说，我们可以非常容易从一个得出另一个，称其为单钥或对称密码体制。若加密密钥和解密密钥不相同，即从一个难于推出另一个，则称为双钥或非对称密码体制(下文详解)。密钥的存在对于整个加密系统的存在就像是心脏对于一个人一样重要，不同的加密算法需要不同的密钥，emem…以后再说这个。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200114142633975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI4NzM4,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; 保密通信系统就像一个大家庭一样，拥有很多家庭成员：明文消息M，密文消息C，密钥K1和K2（在单钥体制下K1 = K2 = K），加密变换Ek1 : M→ C，由加密器完成；解密变换 Dk2 : C→ M，由解密器实现。称总体 ( M, C, K1 , K2 , EK1 , DK2 ) 为保密通信系统。&lt;/p&gt;
&lt;p&gt; 对于我们已知的明文消息 m，密钥 k1， 加密算法的工作就是将明文 m 变换为密文 c, 即 c = f ( m, k1 ) = Ek1 ( m)，而另一端的用户则是通过安全信道送来的密钥 k或用本地密钥发生器产生的解密密钥 k2（just为了区别一下）控制解密操作 D，对收到的密文进行变换得到恢复的明文消息，即: m = Dk2 ( c)，而一些专业的密码分析人员就是则用变换函数 h，对截获的密文 c 进行变换，得到的明文是明文空间中的某个元素，如果该元素等于明文m，也就是分析成功。&lt;/p&gt;
&lt;h5 id=&quot;h-3&quot;&gt;&lt;span&gt;密码体制分类 ：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 密码体制从原理上可分为两大类，即&lt;strong&gt;单钥体制&lt;/strong&gt;和&lt;strong&gt;双钥体制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;单钥体制&lt;/strong&gt;的加密密钥和解密密钥相同。采用单钥体制的系统的保密性主要取决于密钥的保密性，与算法的保密性无关 , 即由密文和加解密算法不可能得到明文。换句话说，算法无需保密，需保密的仅是密钥。根据单钥密码体制的这种特性，单钥加解密算法可通过低费用的芯片来实现。密钥可由发送方产生然后再经一个安全可靠的途径送至接收方，或由第三方产生后安全可靠地分配给通信双方。密钥产生、分配、存储、销毁等问题, 统称为密钥管理。这是影响系统安全的关键因素，即使密码算法再好，若密钥管理问题处理不好，就很难保证系统的安全保密性。单钥体制对明文消息的加密有两种方式：一是明文消息按字符( 如二元数字) 逐位地加密, 称之为流密码；另一种是将明文消息分组( 含有多个字符)，逐组地进行加密，称之为分组密码。单钥体制不仅可用于数据加密，也可用于消息的认证。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;双钥体制&lt;/strong&gt;是由 Diffie 和 Hellman 于 1976 年首先引入的。采用双钥体制的每个用户都有一对选定的密钥，一个是可以公开的，可以像电话号码一样进行注册公布；另一个则是秘密的。所以又称为公钥体制。双钥密码体制的主要特点是将加密和解密能力分开，因而可以实现多个用户加密的消息只能由一个用户解读，或由一个用户加密的消息而使多个用户可以解读。前者可用于公共网络中实现保密通信，而后者可用于实现对用户的认证。&lt;/p&gt;
&lt;h5 id=&quot;h-4&quot;&gt;&lt;span&gt;密码攻击：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 有密码必然有攻击，密码攻击简单点来说就是破解密码，在对密码进行攻破的方面呢，主要有4 种攻击类型, 类型的划分由攻击者可获取的信息量决定。以下四种破解方式快来学学，说不定你就是下一个&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;惟密文攻击（Ciphtext-only attack）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 在惟密文攻击中，密码分析者知道密码算法，但仅能根据截获的密文进行分析，以得出明文或密钥。由于密码分析者所能利用的数据资源仅为密文，这是对密码分析者最不利的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;已知明文攻击（Plaintext-known attack）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 已知明文攻击是指密码分析者除了有截获的密文外，还有一些已知的明文-密文对来破译密码。密码分析者的任务目标是推出用来加密的密钥或某种算法，这种算法可以对用该密钥加密的任何新的消息进行解密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;明文攻击（Chosen-plaintext attack）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 选择明文攻击是指密码分析者不仅可得到一些明文-密文对，还可以选择被加密的明文，并获得相应的密文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择密文攻击 (Chosen—ciphenext attack)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 选择密文攻击是指密码分析者可以选择一些密文，并得到相应的明文。密码分析者的任务目标是推出密钥。这种 密码分析多用于攻击 公钥密码体制。&lt;/p&gt;
&lt;p&gt; 看到这里，你是不是明白了怎么加密解密，为什么加密，怎样破解密码，还远远不够，我还有好多知识没有讲给你听呢，比如对称密码体制还有一个爱情故事，类似于洪世贤，林品如和艾利的关系的这样一个故事（说着说着，这个该死的音乐已经在脑中响起….)，想听吗？想听就&lt;strong&gt;关注我&lt;/strong&gt;，龙叔讲给你听。&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200119215735776.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h4&gt;&lt;span&gt;求点赞👍 求关注❤️&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;「转发」是明目张胆的喜欢，「在看」是偷偷摸摸的爱。&lt;/span&gt;&lt;/h4&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200119220000969.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;code&gt;如果有人想发文章，我这里提供&lt;/code&gt;&lt;span&gt;&lt;strong&gt;有偿征文&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;(具体细则微信联系)，欢迎投稿或推荐你的项目。提供以下几种投稿方式：&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;去我的github提交 issue:&lt;/code&gt; https://github.com/midou-tech/articles&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;发送到邮箱: 2507367760@qq.com 或者 longyueshier@163.com 或者 longyueshier@gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;微信发送: 扫描下面二维码，公众号里面有作者微信号。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;精选文章都同步在公众号里面，公众号看起会更方便，随时随地想看就看。微信搜索&lt;/code&gt; &lt;strong&gt;&lt;code&gt;龙跃十二&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;或者扫码即可订阅。&lt;/code&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1galsp9a07kj30p00dwae3.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 00:29:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>互联网时代，信息安全越来越受到重视，本文将带领大家进行信息安全扫盲。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/12216081.html</dc:identifier>
</item>
<item>
<title>Spring（二）核心容器 - 简介 、BeanFactory、ApplicationContext - 龙四丶</title>
<link>http://www.cnblogs.com/loongk/p/12216526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loongk/p/12216526.html</guid>
<description>&lt;p&gt;在上篇文章中，和大家一起讨论了 Spring 的整体架构，其大致分为五个模块：核心容器、AOP、Web、Data 数据访问、Test模块。其中核心容器是 Spring 的核心部分，其它模块也都依赖于该容器。这里和就大家一起深入讨论 Spring 的容器，它的作用是什么、怎么实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;容器顾名思义就是用来装东西的，装的是什么？装的是 Bean。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bean 是 Spring 的基本单位，在基于 Spring 的 Java EE 应用中，所有的组件都被当成 Bean 处理，包括数据源、Hibernate 的 SessionFactory、事务管理器等。在 Spring 中，Bean 是一个非常广义的概念，任何 Java 对象、Java 组件都被当成 Bean 处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那容器仅仅是用来保存 Bean 这么简单么？不是。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们需要使用某个 Bean 时，容器会自动帮我们创建，并在适当时销毁。还有一种情况，当某个 Bean 中需创建另一个 Bean 时，也就是 Bean 之间有依赖关系，这种依赖的 Bean 也是由容器自动创建。在外界有一个标准的名词，前者称呼为 IOC，也就是控制反转，后者称呼为 DI，也就是依赖注入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IOC/DI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IOC (Inversion of Control) 控制反转：所谓控制反转，就是当我们需要某个 Bean 时，将 Bean 的名称告知容器，由容器去创建该 Bean，而不是我们手动 new 一个，这里 Bean 创建管理的控制权都交给了容器，所以这是一种控制权的反转。其通俗点讲就是需要什么东西让别人送过来，而不是自己去拿。&lt;/p&gt;
&lt;p&gt;DI (Dependency Injection) 依赖注入：就是指当 A Bean 里面需创建 B Bean 时，会在创建 A Bean 的时候，自动将依赖的 B Bean 注入进去，其 B Bean 是被动接受注入而不是自己主动去找。换句话说就是指 A Bean 不是从容器中查找它依赖的 B Bean，而是在容器创建 A Bean 候主动将它依赖的 B Bean 注入给它。&lt;/p&gt;
&lt;p&gt;IOC 和 DI 其实归根结底实现的功能是相同的，只是同样的功能站在不同的角度来阐述罢了，不过我们通常喜欢将这两个概念统称为 IOC。当然，在真实场景中，交由 Spring 容器创建的 Bean 泛指在应用程序中的表现层、业务层、持久层等各层对应的 Bean，如 Controller、Service 等；进行数据交互的模型，如 DTO、VO 等就不需交由 Spring 来创建。&lt;/p&gt;
&lt;p&gt;所以，容器本质上可以也可以看作是 Bean 工厂，该工厂管理 Bean 的生命周期，以及 Bean 之间的依赖关系。外界也将 Spring 容器称为 IOC 容器。当然，这里容器仅仅是 Spring 的抽象概念，代码中将其具象化为 BeanFactory 或 ApplicationContext，容器功能也由具象化的类进行处理。&lt;/p&gt;

&lt;p&gt;容器的实现类并不是唯一的，Spring 框架提供了多个容器的实现，这些容器分为两套体系：一套是早期的 BeanFactory 体系；还有一套是现在常用的 ApplicationContext，也可称为应用上下文，它继承了 BeanFactory，它除了有 BeanFactory 的功能外&lt;br/&gt;，还提供了其他服务，例如事务和 AOP 服务、国际化（il8n）的消息源以及应用程序事件处理等企业级的服务。&lt;/p&gt;
&lt;p&gt;说到这，就不得不说 Spring 的两种配置方式，在早期都是 XML 配置文件的方式，而现在使用的是注解配置的方式。BeanFactory 体系的容器一般用来处理 XML 配置文件的方式，而 ApplicationContext 体系则都可以处理。&lt;/p&gt;
&lt;h2 id=&quot;beanfactory&quot;&gt;2.1 BeanFactory&lt;/h2&gt;
&lt;p&gt;BeanFactory 是容器最基础的类，它定义了容器的基本功能规范：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanFactory {

    // 对 FactoryBean 的转义定义，因为如果使用 bean 的名字检索 FactoryBean 得到的对象是工厂生成的对象，
    // 如果需要得到工厂本身，需要转义（FactoryBean 在后续会详细介绍）
    String FACTORY_BEAN_PREFIX = &quot;&amp;amp;&quot;;
    
    // 根据 bean 的名字，获取在容器中 bean 实例
    Object getBean(String name) throws BeansException;
    
    //根据 bean 的名字和 Class 类型来得到 bean 实例，增加了类型安全验证机制。
    &amp;lt;T&amp;gt; T getBean(String name, @Nullable Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
    Object getBean(String name, Object... args) throws BeansException;
    &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
    &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, Object... args) throws BeansException;
    
    // 提供对 bean 的检索，看看是否在容器有这个名字的 bean
    boolean containsBean(String name);
    
    // 根据 bean 名字，判断这个 bean 是不是单例
    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
    
    // 根据 bean 名字，判断这个 bean 是不是原型
    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
    
    // 根据 bean 名字，判断是否与指定的类型匹配
    boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
    boolean isTypeMatch(String name, @Nullable Class&amp;lt;?&amp;gt; typeToMatch) throws NoSuchBeanDefinitionException;
    
    // 得到 bean 实例的 Class 类型
    Class&amp;lt;?&amp;gt; getType(String name) throws NoSuchBeanDefinitionException;
    
    // 得到bean 的别名，如果根据别名检索，那么其原名也会被检索出来
    String[] getAliases(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 BeanFactory 里只对容器的基本行为作了定义，其根本不关心你的 Bean 是如何定义怎样加载的。&lt;br/&gt;正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。而要知道工厂是如何产生对象的，我们就需要看具体的容器了，也就是 BeanFactory 的子类。&lt;/p&gt;
&lt;p&gt;BeanFactory 体系中常用的实现类有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ListableBeanFactory：提供容器中 bean 迭代的功能。如返回所有 Bean 的名字、容器中 Bean 的数量等。&lt;/li&gt;
&lt;li&gt;HierarchicalBeanFactory：提供父容器的访问功能，可通过 ConfigurableBeanFactory 的 setParentBeanFactory 方法设置父容器。&lt;/li&gt;
&lt;li&gt;AutowireCapableBeanFactory：为 Spring 容器之外的 Bean ，也就是未交由 Spring 管理的 Bean ，提供依赖注入的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上三个是 BeanFactory 的直系亲属，这个三个直系亲属下面又派生了两个复杂的容器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConfigurableBeanFactory：其继承了 HierarchicalBeanFactory 和 SingletonBeanRegistry 这两个接口，其提供了很多方法，如：定义类加载器、类型转化、属性编辑器、注册依赖 Bean 、销毁 bean 等，且该接口被大多数的容器继承、实现。&lt;/li&gt;
&lt;li&gt;ConfigurableListableBeanFactory：这个接口继承了 ListableBeanFactory、 AutowireCapableBeanFactory、ConfigurableBeanFactory，自身主要提供用于分析和修改 bean 定义以及预先实例化单例 Bean 的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后是核心容器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DefaultListableBeanFactory：它实现了以上所有的接口，在 BeanFactory 体系中可以作为一个独立的容器使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BeanFactory 大致的继承关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gb1kkgacvqj315s0r4155.jpg&quot; alt=&quot;BeanFactory 结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实以前常用的容器是 XmlBeanFactory ，它是 DefaultListableBeanFactory 的实现类，现已被废除，原因还未找到，有知道的小伙伴，可在底下留言告知。&lt;/p&gt;
&lt;p&gt;但我们基本不单独使用 BeanFactory ，而是直接使用 ApplicationContext ，因为 ApplicationContext 包含了 BeanFactory。&lt;/p&gt;
&lt;h2 id=&quot;applicationcontext&quot;&gt;2.2 ApplicationContext&lt;/h2&gt;
&lt;p&gt;上面说过 ApplicationContext 是 BeanFactory 子类，它不仅包含 BeanFactory 所有功能，还对其进行了扩展，而我们喜欢将 ApplicationContext 称为应用上下文，因为容器只是它的基本功能。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
        MessageSource, ApplicationEventPublisher, ResourcePatternResolver {

    // 返回此应用程序上下文的唯一ID
    @Nullable
    String getId();

    // 返回此上下文所属的应用程序名称
    String getApplicationName();

    // 返回应用上下文具像化的类名
    String getDisplayName();

    // 返回第一次加载此上下文时的时间戳
    long getStartupDate();

    // 获取父级应用上下文
    @Nullable
    ApplicationContext getParent();

    // 将 AutowireCapableBeanFactory 接口暴露给外部使用
    AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ApplicationContext 自身提供的方法非常简单，但它继承了六个接口，来扩展自身功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EnvironmentCapable：获取 Environment。&lt;/li&gt;
&lt;li&gt;ListableBeanFactory、HierarchicalBeanFactory：这是 BeanFactory 体系接口，分别提供 Bean 迭代和访问父容器的功能。&lt;/li&gt;
&lt;li&gt;MessageSource：支持国际化功能。&lt;/li&gt;
&lt;li&gt;ApplicationEventPublisher：应用事件发布器，封装事件发布功能的接口。&lt;/li&gt;
&lt;li&gt;ResourcePatternResolver：该接口继承至 ResourceLoader ，作用是加载多个 Resource。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ApplicationContext 同样提供了非常多的实现类，其又可细分为两大类， ConfigurableApplicationContext 和 WebApplicationContext。&lt;/p&gt;
&lt;h3 id=&quot;configurableapplicationcontext&quot;&gt;2.2.1 ConfigurableApplicationContext&lt;/h3&gt;
&lt;p&gt;该接口是比较重要的一个接口，几乎所有的应用上下文都实现了该接口。该接口在ApplicationContext的基础上提供了配置应用上下文的能力，此外提供了生命周期的控制能力。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable {

    // 应用上下文配置时，这些符号用于分割多个配置路径
    String CONFIG_LOCATION_DELIMITERS = &quot;,; \t\n&quot;;

    // BeanFactory中，ConversionService类所对应的bean的名字。如果没有此类的实例的话吗，则使用默认的转换规则
    String CONVERSION_SERVICE_BEAN_NAME = &quot;conversionService&quot;;

    //LoadTimeWaver类所对应的Bean在容器中的名字。如果提供了该实例，上下文会使用临时的 ClassLoader ，这样，LoadTimeWaver就可以使用bean确切的类型了 
    String LOAD_TIME_WEAVER_BEAN_NAME = &quot;loadTimeWeaver&quot;;

    // Environment 类在容器中实例的名字
    String ENVIRONMENT_BEAN_NAME = &quot;environment&quot;;

    // System 系统变量在容器中对应的Bean的名字
    String SYSTEM_PROPERTIES_BEAN_NAME = &quot;systemProperties&quot;;

    // System 环境变量在容器中对应的Bean的名字
    String SYSTEM_ENVIRONMENT_BEAN_NAME = &quot;systemEnvironment&quot;;

    // 设置容器的唯一ID
    void setId(String id);

    // 设置此容器的父容器
    void setParent(@Nullable ApplicationContext parent);

    // 设置容器的 Environment 变量
    void setEnvironment(ConfigurableEnvironment environment);

    // 以 ConfigurableEnvironment 的形式返回此容器的环境变量。以使用户更好的进行配置
    @Override
    ConfigurableEnvironment getEnvironment();

    // 此方法一般在读取应用上下文配置的时候调用，用以向此容器中增加BeanFactoryPostProcessor。增加的Processor会在容器refresh的时候使用。
    void addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor);

    // 向容器增加一个 ApplicationListener，增加的 Listener 用于发布上下文事件，如 refresh 和 shutdown 等
    void addApplicationListener(ApplicationListener&amp;lt;?&amp;gt; listener);

    // 向容器中注入给定的 Protocol resolver
    void addProtocolResolver(ProtocolResolver resolver);

    // 这是初始化方法，因此如果调用此方法失败的情况下，要将其已经创建的 Bean 销毁。
    // 换句话说，调用此方法以后，要么所有的Bean都实例化好了，要么就一个都没有实例化
    void refresh() throws BeansException, IllegalStateException;

    // 向JVM注册一个回调函数，用以在JVM关闭时，销毁此应用上下文
    void registerShutdownHook();

    // 关闭此应用上下文，释放其所占有的所有资源和锁。并销毁其所有创建好的 singleton Beans
    @Override
    void close();

    // 检测此 FactoryBean 是否被启动过
    boolean isActive();

    // 返回此应用上下文的容器。
    // 千万不要使用此方法来对 BeanFactory 生成的 Bean 做后置处理，因为单例 Bean 在此之前已经生成。
    // 这种情况下应该使用 BeanFactoryPostProcessor 来在 Bean 生成之前对其进行处理
    ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该接口下又有几个重要的实现类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AbstractApplicationContext：这是个抽象类，仅实现了公共的上下文特性。这个抽象类使用了模板方法设计模式，需要具体的实现类去实现这些抽象的方法。&lt;/li&gt;
&lt;li&gt;GenericApplicationContext：该类继承自 AbstractApplicationContext，是为通用目的设计的，它能加载各种配置文件，例如 xml，properties 等等。它的内部持有一个 DefaultListableBeanFactory 的实例，实现了 BeanDefinitionRegistry 接口，以便允许向其应用任何 bean 的定义的读取器。&lt;/li&gt;
&lt;li&gt;AnnotationConfigApplicationContext：该类继承自 GenericApplicationContext ，提供了注解配置（例如：@Configuration、@Component等）和类路径扫描（scan方法）的支持。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;webapplicationcontext&quot;&gt;2.2.2 WebApplicationContext&lt;/h3&gt;
&lt;p&gt;该接口是专门为 Web 应用准备的，其允许从相对于 Web 根目录的路径中装载配置文件完成初始化。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface WebApplicationContext extends ApplicationContext {

    // 整个 Web 应用上下文是作为属性放置在 ServletContext 中的，该常量就是应用上下文在 ServletContext 属性列表中的 key
    String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + &quot;.ROOT&quot;;

    // 定义了三个作用域的名称
    String SCOPE_REQUEST = &quot;request&quot;;
    String SCOPE_SESSION = &quot;session&quot;;
    String SCOPE_APPLICATION = &quot;application&quot;;

    // 在工厂中的 bean 名称
    String SERVLET_CONTEXT_BEAN_NAME = &quot;servletContext&quot;;

    // ServletContext 初始化参数名称
    String CONTEXT_PARAMETERS_BEAN_NAME = &quot;contextParameters&quot;;

    // 在工厂中 ServletContext 属性值环境bean的名称
    String CONTEXT_ATTRIBUTES_BEAN_NAME = &quot;contextAttributes&quot;;

    // 用来获取 ServletContext 对象
    @Nullable
    ServletContext getServletContext();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该接口的核心实现类有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConfigurableWebApplicationContext：该接口同时继承了 WebApplicationContext 和 ConfigurableApplicationContext，提供了 Web 应用上下文的可配置的能力。&lt;/li&gt;
&lt;li&gt;GenericWebApplicationContext：该类继承自 GenericApplicationContext，实现了 ConfigurableWebApplicationContext。&lt;/li&gt;
&lt;li&gt;XmlWebApplicationContext：该上下文是使用 Xml 配置文件的方式，不过是在 Web 环境中使用的。&lt;/li&gt;
&lt;li&gt;AnnotationConfigServletWebServerApplicationContext：该类是被 SpringBoot 扩展而来的，SpringBoot 使用的就是该上下文。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;差异对比&quot;&gt;2.3 差异对比&lt;/h2&gt;
&lt;p&gt;从上面可以看出 BeanFactory 是 Sping 框架的基础接口，一般是面向 Spring 本身；而 ApplicationContext 是以 BeanFactory 为基础进行综合能力扩展，用于满足大型业务应用的创建， ApplicationContext 一般面向使用 Sping 框架的开发者。几乎所有的应用场合我们都是直接使用 ApplicationContet 而非底层的 BeanFactory。&lt;/p&gt;
&lt;p&gt;下表列出了BeanFactory 和 ApplicationContext 接口和实现所提供的功能：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Bean 实例化/装配&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;BeanPostProcessor 自动注册&lt;/td&gt;
&lt;td&gt;没有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;BeanFactoryPostProcessor 自动注册&lt;/td&gt;
&lt;td&gt;没有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;MessageSource 便捷访问（针对i18n）&lt;/td&gt;
&lt;td&gt;没有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ApplicationEvent 发布&lt;/td&gt;
&lt;td&gt;没有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;两者还有一个区别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ApplicationContext 在容器启动时，一次性创建了所有的 Bean。&lt;/li&gt;
&lt;li&gt;BeanFactory 在容器启动时，并未创建 Bean，直到第一次访问某个 Bean 时才创建目标 Bean。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在真实环境中，一般通过集成 SSM 或者 SpringBoot 来自动创建 ApplicationContext。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先从 SSM 开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、在 web.xml 配置监听器&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- spring监听器 --&amp;gt;
&amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、容器启动时会调用 ContextLoaderListener 中的 contextInitialized 方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ContextLoaderListener extends ContextLoader implements ServletContextListener {
    
    ...
    
    @Override
    public void contextInitialized(ServletContextEvent event) {
        initWebApplicationContext(event.getServletContext());
    }
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、调用父类的 initWebApplicationContext 方法，在该方法中创建、启动上下文。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ContextLoader {
    
    ...
    
    public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
        
        ...

        try {
            
            if (this.context == null) {
            
                // 通过 createWebApplicationContext 方法创建上下文，默认创建 XmlWebApplicationContext
                this.context = createWebApplicationContext(servletContext);
            }
            if (this.context instanceof ConfigurableWebApplicationContext) {
                ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
                if (!cwac.isActive()) {
                    
                    ...
                    // 在该方法中调用上下文的 refresh 方法，refresh 就是启动上下文的入口
                    configureAndRefreshWebApplicationContext(cwac, servletContext);
                }
            }
            ...
        }
        ...
    }
    ...
    
    protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {
        
        ... 
        
        wac.refresh();
    }
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot 启动 ApplicationContext&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、从启动类开始&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class DiveInSpringBootApplication {
    public static void main(String[] args) {
        SpringApplication.run(DiveInSpringBootApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、找到 SpringApplication 中，最后重载的 run 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ConfigurableApplicationContext run(String... args) {
    
    ...
    
    ConfigurableApplicationContext context = null;
    
    ...
    
    try {
        ...
        // 通过 createApplicationContext 方法创建上下文，根据 Web 环境不同创建的上下文也不同
        context = createApplicationContext();
    
        ...
        // 该方法用于启动上下文
        refreshContext(context);
        ...
    
    }
    catch (Throwable ex) {
        ...
    }
    
    context = createApplicationContext();
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、进入 refreshContext 方法，里面调用了 refresh 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void refreshContext(ConfigurableApplicationContext context) {
    refresh(context);
    if (this.registerShutdownHook) {
        try {
            context.registerShutdownHook();
        }
        catch (AccessControlException ex) {
            // Not allowed in some environments.
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、这里，最终也是调用 ApplicationContext 的 refresh 方法来启动上下文&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void refresh(ApplicationContext applicationContext) {
    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);
    ((AbstractApplicationContext) applicationContext).refresh();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注：这里主要讨论容器的创建和启动部分，所以省略了其他部分的代码。其中 SpringBoot 启动上下文在前几篇 《SpringBoot系列》文章有详细介绍，感兴趣的伙伴可自行查阅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到虽然 SSM 和 SpringBoot 的上下文对象不同，但最终都是调用上下文中的 refresh 方法来启动。该方法是 ApplicationContext 的核心，如 Bean 注册、注入、解析 XML 、解析注解等是从该方法开始，其内部实现大致如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // 1. 初始化 refresh 的上下文环境，就是记录下容器的启动时间、标记已启动状态、处理配置文件中的占位符
        prepareRefresh();

        // 2. 初始化 BeanFactory，加载并解析配置
        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();

        /* ---至此，已经完成了简单容器的所有功能，下面开始对简单容器进行增强--- */

        // 3. 对 BeanFactory 进行功能增强，如设置BeanFactory的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean
        prepareBeanFactory(beanFactory);

        try {
            // 4. 后置处理 beanFactory，交由子类实现
            postProcessBeanFactory(beanFactory);

            // 5. 调用已注册的 BeanFactoryPostProcessor
            invokeBeanFactoryPostProcessors(beanFactory);

            // 6. 注册 BeanPostProcessor，仅仅是注册，调用在getBean的时候
            registerBeanPostProcessors(beanFactory);

            // 7. 初始化国际化资源
            initMessageSource();

            // 8. 初始化事件广播器
            initApplicationEventMulticaster();

            // 9. 留给子类实现的模板方法
            onRefresh();

            // 10. 注册事件监听器
            registerListeners();

            // 11. 实例化所有非延迟加载的单例
            finishBeanFactoryInitialization(beanFactory);

            // 12. 完成刷新过程，发布应用事件
            finishRefresh();
            
        } catch (BeansException ex) {
            if (logger.isWarnEnabled()) {
                logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + ex);
            }
            
            // 13.销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源
            this.destroyBeans();
            
            // Reset 'active' flag.
            this.cancelRefresh(ex);
            // Propagate exception to caller.
            throw ex;
        } finally {
            // Reset common introspection caches in Spring's core, since we
            // might not ever need metadata for singleton beans anymore...
            this.resetCommonCaches();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来的文章，将对 refresh 方法中的各部分进行详细讨论。&lt;/p&gt;

&lt;p&gt;最后来做个整体的总结。文章从 Spring 的整体架构开始讨论，整体分为五个模块：核心容器、AOP、Web、Data 数据访问、Test模块，而核心容器又是 Spring 的基础。容器的作用是什么？提供 IOC/DI 功能；怎么实现的？其核心是 BeanFactory 和 ApplicationContext ，一般使用 ApplicationContext ，其包含了 BeanFactory 的所有功能，并对其进行扩展。在 SSM 和 SpringBoot 中自动创建 ApplicationContext 并调用它的 refresh 方法进行启动，它的 refresh 就是实现容器一系列功能的入口。&lt;/p&gt;
&lt;p&gt;以上就是本章内容，如果文章中有错误或者需要补充的请及时提出，本人感激不尽。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/09120912zhang/p/7746252.html&lt;br/&gt;https://docs.spring.io/spring/docs/5.2.3.RELEASE/spring-framework-reference/core.html#context-introduction&lt;br/&gt;https://www.jianshu.com/p/2854d8984dfc&lt;br/&gt;https://blog.csdn.net/baidu_36327010/article/details/87983262&lt;br/&gt;https://www.cnblogs.com/zhangfengxian/p/11192054.html&lt;br/&gt;https://www.cnblogs.com/sharpest/p/10885820.html&lt;/p&gt;
</description>
<pubDate>Mon, 20 Jan 2020 00:19:00 +0000</pubDate>
<dc:creator>龙四丶</dc:creator>
<og:description>[toc] 前言 在上篇文章中，和大家一起讨论了 Spring 的整体架构，其大致分为五个模块：核心容器、AOP、Web、Data 数据访问、Test模块。其中核心容器是 Spring 的核心部分，其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/loongk/p/12216526.html</dc:identifier>
</item>
</channel>
</rss>