<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《ASP.NET Core 3框架揭秘》读者群，欢迎加入 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-aspnet-core-3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-aspnet-core-3.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/artech/158198/o_200307001346inside-asp-net-core.jpg&quot; class=&quot;desc_img&quot;/&gt;ASP.NET Core 3框架揭秘》（上下册）在本月正式上市，为此出版社专门创建了一个微信群，。由于目前人数已经超过200人，只能通过邀请方能加入。有兴趣的朋友可以搜索微信账号“broadview002”（博文小丸子）并添加为好友，并在申请消息中指定本书书号“38462”，出版社工作人员将自动帮你添加到该微信群。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;163.812612442&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200307080027598-533205146.jpg&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;240&quot; title=&quot;WeChat Image_20200307073158&quot; align=&quot;left&quot; alt=&quot;WeChat Image_20200307073158&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200307080028114-361353988.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;作为一个17年的.NET开发者，我对一件事特别不能理解：我们的计算机图书市场充斥着一系列介绍ASP.NET Web Forms、ASP.NET MVC、ASP.NET Web API的书籍，但是却找不到一本专门介绍ASP.NET自身框架的著作。我们知道上述这些Web开发框架都是建立在ASP.NET这个底层框架之上，底层的ASP.NET框架才是根基所在。在过去的这些年里，我接触过很多资深的ASP.NET开发人员，发现他们对ASP.NET框架大都没有深入的了解。&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200307080028480-1618757835.png&quot;&gt;&lt;img width=&quot;447&quot; height=&quot;384&quot; title=&quot;image&quot; align=&quot;right&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200307080028794-1156886157.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2014年，在向出版社提交了《ASP.NET MVC 5框架揭秘》的终版稿件之后，我本打算写一本《ASP.NET框架揭秘》。在新书的准备过程中，微软推出了ASP.NET Core（那时还被称为ASP.NET 5，当时还没有.NET Core的概念）。为此我及时转移到了针对ASP.NET Core的学习和研究，并在之后开始了本书的写作。&lt;/p&gt;
&lt;p&gt;在我过去尚算丰富的写作经历中，《ASP.NET Core 3框架揭秘》算作耗时最长（差不多5年），投入心血最多的一本书。2015年初，我们敲下了本书的第一行文字，微软在2016年6月正式发布.NET Core 1.0的时候，本书的绝大部分内容就已经完成。 随后微软不断推出新的版本，本书的内容也在不断的快速“迭代”中。你手中的这本书共计800多页，我在写作过程中删除的文字也能达到这个数字。&lt;/p&gt;
&lt;p&gt;有的人可能会说，我每天只是做一些简单的编程工作，根本没有必要去了解底层原理和设计方面的内容。其实不论我们从事何种层次的工作，最根本的目的只有一个，那就是解决问题。解决方案分两种，一种叫做“扬汤止沸”，另一种被称为“釜底抽薪”。由于只看到锅里不断沸腾的水，你只能不断地往锅里浇冷水，我们希望这本书能够让你看到锅底熊熊燃烧的薪火。&lt;/p&gt;
&lt;p&gt;《ASP.NET Core 3框架揭秘》（上下册）在本月正式上市，为此出版社专门创建了一个微信群，。由于目前人数已经超过200人，只能通过邀请方能加入。有兴趣的朋友可以搜索微信账号“&lt;span&gt;broadview002&lt;/span&gt;”（博文小丸子）并添加为好友，并在申请消息中指定本书书号“&lt;span&gt;38462&lt;/span&gt;”，出版社工作人员将自动帮你添加到该微信群。对于在群的朋友们，你也可以邀请感兴趣的人加入。&lt;/p&gt;

&lt;p&gt;ASP.NET Core一个全新的Web开发平台，它为我们构建一个可复用和可定制的请求处理管道，微软在它上面构建了MVC、SingalR、GRPC、Orleans这样广泛使用的Web框架，我们也可以利用它构建自己的Web框架（比如我曾经在ASP.NET Core构建了一款GraphQL框架）。本书只关注最本质的东西，即ASP.NET Core请求处理管道，并不会涉及上述这些Web框架，本书的内容主要划分为如下四个部分。&lt;/p&gt;
&lt;h2&gt;跨平台的开发体现和实现原理&lt;/h2&gt;
&lt;p&gt;跨平台是.NET Core区别于传统.NET Framework最大的特征，作为开篇入门材料，本书第1章“跨平台的开发体验”会通过几个简单的Hello World程序让读者体验在Windows、Mac OS、Linux平台上开发.NET Core应用，以及通过Docker容器部署ASP.NET Core应用的乐趣。随后的第2章 “跨平台的奥秘” 将告诉你.NET Core的跨平究竟是如何实现的。&lt;/p&gt;
&lt;h2&gt;基础框架&lt;/h2&gt;
&lt;p&gt;ASP.NET Core框架依赖一些基础框架，其中最重要的就是依赖注入框架。由于依赖注入框架不仅仅是构建ASP.NET Core请求处理管道的基石，而且依赖注入也成为了ASP.NET Core应用的基本编程模式，所以本书采用两章的内容（第3章 “依赖注入（上篇）” 和第4章 “依赖注入（下篇）” ）对依赖注入原理以及依赖注入框架的设计和编程方式进行了详细介绍。&lt;/p&gt;
&lt;p&gt;ASP.NET Core应用具有很多读取文件内容的场景，所以它构建了一个抽象的文件系统，本书第5章 “文件系统” 会对这个文件系统的设计模型和两种实现方式（物理文件系统和程序集内嵌文件系统）进行详细介绍。&lt;/p&gt;
&lt;p&gt;.NET Core针对 “配置” 的支持是传统.NET 开发人员所不能想象的，我们同样采用两章的篇幅对这一主题进行讲解。第6章 “配置选项（上篇） “旨在介绍支持多种数据源的配置系统。不论是开发ASP.NET Core应用还是组件，我们推荐采用Options模式来读取配置选项，第7章 “配置选项（下篇）” 会着重讲述这种强类型的配置选项编程方式。&lt;/p&gt;
&lt;p&gt;.NET Core在错误诊断方面给我们非常多的选择，第8章 “诊断日志（上篇）” 会介绍五种常用的记录诊断日志的方式。.NET Core还提供了一个支持多种输出渠道的日志系统，针对该日志系统在第9章 “诊断日志（下篇）” 具有非常详细的介绍。&lt;/p&gt;
&lt;h2&gt;管道详解&lt;/h2&gt;
&lt;p&gt;.NET Core的服务承载系统用来承载那些需要长时间运行的服务，ASP.NET Core作为最为重要的服务类型被承载与该系统中，第10章 “承载系统” 会对该服务承载系统进行系统介绍。由于请求处理管道是整本书的核心所在，所以我们采用了整整三章的篇幅来介绍这个部分。第11章 “管道（上篇）” 主要从编程模型的角度来认识管道。第12章 “管道（中篇）” 提供了一个极简版的模拟框架来展示ASP.NET Core框架的总体设计。在随后的第13章 “管道（下篇）” 中，我们以这个模拟框架为基础，采用渐进的方式补充一些遗漏的细节，进而将ASP.NET Core框架真实的管道展现在读者眼前。&lt;/p&gt;
&lt;h2&gt;中间件&lt;/h2&gt;
&lt;p&gt;ASP.NET Core框架的请求处理管道由服务器和中间件组成，管道利用服务器来监听和接收请求，将完整最终对请求的响应，应用针对请求的处理则体现在有序排列的中间件上。微软为我们提供了一系列原生的中间件，针对这些中间件的介绍全部放在了本书的下册。&lt;/p&gt;
&lt;p&gt;这部分涉及用来处理文件请求（第14章 “静态文件” ）、路由（第15章 “路由” ）、异常处理（第16章 “异常处理” ）的中间件，也包括用来响应缓存（第17章 “缓存” ）和会话（第18章 “会话” ）的中间件，还包括用来实现认证（第19章 “认证” ）、授权 “（第20章 “授权” ）、跨域资源共享（第21章 “跨域资源共享” ）等与安全相关的中间件。&lt;/p&gt;
&lt;p&gt;这部分还介绍了针对本地化（第22章“本地化”）和健康检查（第23章“健康检查”）的中间件。除此之外，我们还提供用来实现主机名过滤、HTTP重写、设置基础路径等功能的中间件，这些零散的中间件全部被收入最后一章（第24章“补遗”）中。&lt;/p&gt;

&lt;p&gt;《ASP.NET Core 3框架揭秘》算是揭秘系列的第6本书了。在过去十来年里，我得到了很多来自热心读者的反馈，这些反馈对书的内容基本上都持正面的评价，但对写作技巧和表达方式的评价则不尽相同。虽然每个作者都由属于自己的写作风格，每个读者的学习思维方式也不仅相同，两者很难出现100%的契合，但是我还是决定在这本书上做出改变。&lt;/p&gt;
&lt;p&gt;本书的内容采用了不一样的组织方式，我觉得这样的方式更符合系统地学习一门全新技术的“流程”。对于每一个模块，我会采用“体验先行”的原则，提供一些简单的实例演示让读者对当前模块的基本功能特性和编程模式具有大致的了解。我们会在编程体验中抽取出一些核心的对象，并利用它们构建出当前模块的抽象模型，读者读懂了这个模型也就了解了当前模块的总体设计。接下来我们从抽象转向具体，进一步深入介绍抽象模型的实现原理。为了让读者能够将在真实项目中灵活自如地运用当前的模块，我们会介绍一些面向应用的扩展和最佳实践。总地来说，本书采用 “编程体验”、“总体设计”、“具体实现”和“灵活运用”这样流程来让读者循序渐进地学习ASP.NET Core的每个功能模块。&lt;/p&gt;
&lt;p&gt;本书综合运用了三种不同的“语言”来讲述每一个技术主题，它们分别是文字语言、图表语言和编程语言。一图胜千言，我在每一章节中都精心设计了很多图表，这些具象的图表能够帮助读者朋友们更容易地理解技术模块的总体设计、执行流程和交互方式。除了利用编程语言描述应用编程接口（API）之外，全书提供了近200个实例，这些实例具有不同的作用，它们有的是为了演示某个实用的编程技巧或者最佳实践，有的是为了强调一些容易忽视但很重要的技术细节，还有的是为了探测和证明所述的论点。&lt;/p&gt;
&lt;p&gt;本书在很对地方会展示一些类型的代码，但是这些代码是和真正的源代码是有差异的，两者差异源于几个原因：第一、源代码在版本更替中一直在发生改变；第二、由于篇幅的限制，我会刻意删除一些细枝末节的代码，比如针对参数的验证、诊断日志的输出和异常处理等；第三、很多源代码其实都具有优化的空间。综上所述，本书中提供的代码片段旨在揭示设计原理和实现逻辑，不是为了向读者展示源代码。&lt;/p&gt;

&lt;p&gt;虽然《ASP.NET Core 3框架揭秘》关注的是ASP.NET Core自身框架提供请求处理管道，而不是具体某个应用编程框架（比如MVC、SingalR、GRPC等），但是这本书适合所有.NET技术从业人员。&lt;/p&gt;
&lt;p&gt;我个人觉得任何好的设计都应该是简单的设计，唯有简单的设计才能应对后续版本更替中出现的复杂问题。从这个意义上讲，ASP.NET框架的设计就是“好的设计“，因为自它正式推出的那一刻起，其总体设计基本上就没有发生改变。ASP.NET Core的设计同样是” 好的设计 “，其简单的管道式设计在未来的版本更替中也不会发生太大的改变，既然是好的设计，它就应该简单。&lt;/p&gt;
&lt;p&gt;正如上面所说，本书采用的“渐进式”的写作方式，即使对于那些完全没有接触过ASP.NET Core的开发人员，都会很容易通过本书深入并系统掌握这门技术。由于本书提供的大部分内容都是独一无二的，即使是非常资深的.NET开发设计人员，我相信也能在书中找到很多不甚了解的盲点。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/inside-asp-net-core-3-contents-1.pdf&quot;&gt;ASP.NET Core 3框架揭秘（上册）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/inside-asp-net-core-3-contents-2.pdf&quot;&gt;ASP.NET Core 3框架揭秘（下册）&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>作为一个17年的.NET开发者，我对一件事特别不能理解：我们的计算机图书市场充斥着一系列介绍ASP.NET Web Forms、ASP.NET MVC、ASP.NET Web API的书籍，但是却找不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-aspnet-core-3.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 中间件应用实践中你不知道的那些事 - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12430522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12430522.html</guid>
<description>&lt;p&gt;中间件和Filter 有哪些区别，分别的作用又是什么，使用Endpoint 终结者路由的应用场景有哪些，怎么使用Endpoint 终结者路由进行中间件的开发；我们知道，任何的一个web框架都是把http请求封装成一个管道，每一次的请求都是经过管道的一系列操作，最终到达我们写的代码中。那么中间件就是在应用程序管道中的一个组件，用来拦截请求过程进行一些其他处理和响应。中间件可以有很多个，每一个中间件都可以对管道中的请求进行拦截，它可以决定是否将请求转移给下一个中间件&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;149.58883248731&quot;&gt;
&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;这篇文章主要分享&lt;code&gt;Endpoint&lt;/code&gt; 终结点路由的&lt;code&gt;中间件&lt;/code&gt;的应用场景及实践案例，不讲述其工作原理，如果需要了解工作原理的同学，&lt;br/&gt;可以点击查看以下两篇解读文章：&lt;/p&gt;
&lt;h3 id=&quot;中间件middleware的作用&quot;&gt;1.1 中间件(Middleware)的作用&lt;/h3&gt;
&lt;p&gt;我们知道，任何的一个web框架都是把http请求封装成一个管道，每一次的请求都是经过管道的一系列操作，最终到达我们写的代码中。那么中间件就是在应用程序管道中的一个组件，用来拦截请求过程进行一些其他处理和响应。中间件可以有很多个，每一个中间件都可以对管道中的请求进行拦截，它可以决定是否将请求转移给下一个中间件。&lt;/p&gt;
&lt;p&gt;asp.net core 提供了&lt;code&gt;IApplicationBuilder&lt;/code&gt;接口来让把中间件注册到asp.net的管道请求当中去，中间件是一个典型的&lt;code&gt;AOP&lt;/code&gt;应用。 下面是一个微软官方的一个中间件管道请求图：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDYzNjQwOS04Y2IwNTQ0YmQwOTExZjZmLnBuZw?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;中间件和过滤器的区别&quot;&gt;1.2 中间件和过滤器的区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Filter&lt;/code&gt;是延续ASP.NET MVC的产物，同样保留了五种的Filter，分别是Authorization Filter、Resource Filter、Action Filter、Exception Filter及Result Filter。&lt;br/&gt;具体可以查看我上次分享的一篇&lt;a href=&quot;https://www.cnblogs.com/jlion/p/12394949.html&quot;&gt;Asp.Net Core Filter 深入浅出的那些事-AOP&lt;/a&gt; 的文章.&lt;/p&gt;
&lt;p&gt;根据描述，可以看出中间件和过滤器的功能类似，那么他们有什么区别？为什么又要搞一个中间件呢？&lt;br/&gt;其实，过滤器和中间件他们的关注点是不一样的，也就是说职责不一样，干的事情就不一样。&lt;/p&gt;
&lt;p&gt;同作为两个&lt;code&gt;AOP&lt;/code&gt;利器，&lt;code&gt;Filter&lt;/code&gt;（过滤器）更贴合业务，它关注于应用程序本身，比如你看&lt;code&gt;ActionFilter&lt;/code&gt; 和 &lt;code&gt;ResultFilter&lt;/code&gt;，它都直接和你的&lt;code&gt;Action&lt;/code&gt;，&lt;code&gt;ActionResult&lt;/code&gt;交互了，是不是离你很近的感觉，那我有一些比如对我的输出结果进行格式化，对我的请求的ViewModel进行数据验证啦，肯定就是用Filter无疑了。它是MVC的一部分，它可以拦截到你Action上下文的一些信息，而中间件是没有这个能力的。&lt;/p&gt;
&lt;p&gt;可以看到，每一个中间件都都可以在请求之前和之后进行操作。请求处理完成之后传递给下一个请求&lt;/p&gt;
&lt;h3 id=&quot;中间件的使用场景&quot;&gt;1.3 中间件的使用场景&lt;/h3&gt;
&lt;p&gt;那么，何时使用中间件呢？我的理解是在我们的应用程序当中和业务关系不大的一些需要在管道中做的事情可以使用，比如身份验证，Session存储，日志记录等。其实我们的 Asp.net core项目中本身已经包含了很多个中间件。比如 身份认证中间件 &lt;code&gt;UseAuthorization()&lt;/code&gt;等系列.&lt;/p&gt;
&lt;h2 id=&quot;二中间件实战&quot;&gt;二、中间件实战&lt;/h2&gt;
&lt;p&gt;需求场景：通过后端记录每一次的访问请求日志，同时需要根据需要排除一些&lt;code&gt;Controller&lt;/code&gt; 或者&lt;code&gt;Action&lt;/code&gt; 不记录请求的日志信息。&lt;/p&gt;
&lt;p&gt;思考：经过分析我需要创建一个全局的中间件进行拦截路由，并且写入日志；同时需要添加一个特性&lt;code&gt;Attribute&lt;/code&gt; 进行标注那些&lt;code&gt;Controller&lt;/code&gt;或者&lt;code&gt;Action&lt;/code&gt; 不需要进行日志记录。&lt;/p&gt;
&lt;p&gt;我们来创建&lt;code&gt;LogsMiddleware&lt;/code&gt; 中间件代码，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LogsMiddleware
{
        private readonly RequestDelegate _next;

        public LogsMiddleware(RequestDelegate next)
        {
            this._next = next;
        }

        public async Task Invoke(HttpContext context)
        {
            var endpoint = context.Features.Get&amp;lt;IEndpointFeature&amp;gt;()?.Endpoint;
            if (endpoint == null)
            {
                await _next(context);
                return;
            }

            using (var scope = context.RequestServices.CreateScope())
            {
                var _logger = scope.ServiceProvider.GetService&amp;lt;ILogger&amp;lt;LogsMiddleware&amp;gt;&amp;gt;();

                var attruibutes = endpoint.Metadata.OfType&amp;lt;NoLogsAttriteFilter&amp;gt;();
                if (attruibutes.Count()==0)
                {
                    _logger.LogInformation($&quot; url:{context.Request.Path}, 访问时间:{DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;)}&quot;);
                }

                //记录 排除的特殊Message 信息
                foreach (var attribute in attruibutes)
                {
                    _logger.LogInformation(attribute.Message);
                }
            }
            await _next(context);
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NoLogsAttriteFilter&lt;/code&gt; 过滤器代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NoLogsAttriteFilter : Attribute
{
        /// &amp;lt;summary&amp;gt;
        /// 这里加这个主要是把获取到的信息在中间件中打印出来，区分中间件的拦截用处
        /// &amp;lt;/summary&amp;gt;
        public string Message = &quot;&quot;;

        public NoLogsAttriteFilter(string message)
        {
            Message = message;
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Startup&lt;/code&gt; 中的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler(&quot;/Home/Error&quot;);
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }

            app.UseRouting();
            app.UseAuthorization();
            app.UseMiddleware&amp;lt;LogsMiddleware&amp;gt;();//添加日志记录中间件
            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllerRoute(
                    name: &quot;default&quot;,
                    pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
            });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;HomeController&lt;/code&gt; 控制器中的两个Action 代码如下:：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 访问该路由会记录访问日志
public IActionResult Index()
{
        return View();
}

//访问该路由不会记录访问日志
[NoLogsAttriteFilter(&quot;Manage 不需要记录访问日志&quot;)]
public IActionResult Manage()
{
       return View();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就自定义日志中间件就已经完成了我上面的需求，不依赖于任何业务独立存在于系统中；从代码中我们可以看到中间件通过&lt;code&gt;context.Features.Get&amp;lt;IEndpointFeature&amp;gt;()?.Endpoint;&lt;/code&gt; 方法获得终结点路由方式进行匹配，并且可以通过&lt;code&gt;endpoint.Metadata.OfType&amp;lt;NoLogsAttriteFilter&amp;gt;()&lt;/code&gt; 方式获得&lt;code&gt;Action&lt;/code&gt; 中的特性信息数据，并通过该拦截进行我的需求&lt;br/&gt;自定义中间件教程文章请点击&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/write?view=aspnetcore-3.1&quot;&gt;自定义中间件官方教程&lt;/a&gt; 一文。&lt;/p&gt;
&lt;p&gt;现在我们再来印证下我上一篇关于 &lt;a href=&quot;https://www.cnblogs.com/jlion/p/12423301.html&quot;&gt;Asp.Net Core EndPoint 终结点路由工作原理解读&lt;/a&gt; 一文 中提及到&lt;code&gt;UseRouting()&lt;/code&gt; 中间件是遍历所有的&lt;code&gt;Endpoint&lt;/code&gt; 终结点路由以匹配当前请求的 &lt;code&gt;Endpoint&lt;/code&gt; 终结点路由一说，我把注册&lt;code&gt;LogsMiddleware&lt;/code&gt;中间件和&lt;code&gt;UseRouting()&lt;/code&gt; 路由中间件代码顺序调整一下，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler(&quot;/Home/Error&quot;);
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }

            // 中间件注册放到了UseRouting() 之前
            app.UseMiddleware&amp;lt;LogsMiddleware&amp;gt;();//添加日志记录中间件
            
            app.UseRouting();
            app.UseAuthorization();
            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllerRoute(
                    name: &quot;default&quot;,
                    pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
            });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看看运行调试的结果如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200306192048263-1034398120.png&quot; alt=&quot;运行调试结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从调试的结果图中可以看出 &lt;code&gt;endpoint&lt;/code&gt; 变量是 null；所有需要使用到&lt;code&gt;Endpoint&lt;/code&gt; 终结点路由必须注册在&lt;code&gt;UseRouting()&lt;/code&gt; 中间件之后。&lt;/p&gt;
&lt;h2 id=&quot;三官方常用中间件&quot;&gt;三、官方常用中间件&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;异常/错误处理&lt;br/&gt;当应用在开发环境中运行时：&lt;br/&gt;开发人员异常页中间件 (&lt;code&gt;UseDeveloperExceptionPage&lt;/code&gt;) 报告应用运行时错误。&lt;br/&gt;数据库错误页中间件报告数据库运行时错误。&lt;br/&gt;当应用在生产环境中运行时：&lt;br/&gt;异常处理程序中间件 (&lt;code&gt;UseExceptionHandler&lt;/code&gt;) 捕获以下中间件中引发的异常。&lt;br/&gt;HTTP 严格传输安全协议 (HSTS) 中间件 (UseHsts) 添加 Strict-Transport-Security 标头。&lt;/li&gt;
&lt;li&gt;HTTPS 重定向中间件 (&lt;code&gt;UseHttpsRedirection&lt;/code&gt;) 将 HTTP 请求重定向到 HTTPS。&lt;/li&gt;
&lt;li&gt;静态文件中间件 (&lt;code&gt;UseStaticFiles&lt;/code&gt;) 返回静态文件，并简化进一步请求处理。&lt;/li&gt;
&lt;li&gt;Cookie 策略中间件 (&lt;code&gt;UseCookiePolicy&lt;/code&gt;) 使应用符合欧盟一般数据保护条例 (GDPR) 规定。&lt;/li&gt;
&lt;li&gt;用于路由请求的路由中间件 (&lt;code&gt;UseRouting&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;身份验证中间件 (&lt;code&gt;UseAuthentication&lt;/code&gt;) 尝试对用户进行身份验证，然后才会允许用户访问安全资源。&lt;/li&gt;
&lt;li&gt;用于授权用户访问安全资源的授权中间件 (&lt;code&gt;UseAuthorization&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;会话中间件 (&lt;code&gt;UseSession&lt;/code&gt;) 建立和维护会话状态。 如果应用使用会话状态，请在 Cookie 策略中间件之后和 MVC 中间件之前调用会话中间件。&lt;/li&gt;
&lt;li&gt;用于将 &lt;code&gt;Razor Pages&lt;/code&gt; 终结点添加到请求管道的终结点路由中间件（带有 MapRazorPages 的 &lt;code&gt;UseEndpoints&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果您觉的不错，请微信扫码关注 【dotNET博士】公众号，后续给您带来更精彩的分享&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200302122728756-456586765.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上如果有错误的地方，请大家积极纠正，谢谢大家的支持！！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 06 Mar 2020 23:34:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>中间件和Filter 有哪些区别，分别的作用又是什么，使用Endpoint 终结者路由的应用场景有哪些，怎么使用Endpoint 终结者路由进行中间件的开发；我们知道，任何的一个web框架都是把htt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12430522.html</dc:identifier>
</item>
<item>
<title>图解MySQL索引(上)—MySQL有中“8种”索引？ - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/12432236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/12432236.html</guid>
<description>&lt;p&gt;关于MySQL索引相关的内容，一直是一个让人头疼的问题，尤其是对于初学者来说。笔者曾在很长一段时间内深陷其中，无法分清&lt;strong&gt;“覆盖索引，辅助索引，唯一索引，Hash索引，B-Tree索引……”到底是些什么东西&lt;/strong&gt;，导致在面试过程中进入比较尴尬的局面。&lt;/p&gt;
&lt;p&gt;很多人可能会抱怨”&lt;strong&gt;面试造火箭，工作拧螺丝，很多知识都是为了面试学的，工作中根本用不到！&lt;/strong&gt;“。庆幸的是，MySQL中索引不仅是面试必考知识，还是工作中用到最为频繁的必备技能，在笔者看来，索引是&lt;strong&gt;MySQL中性价比最高的一部分内容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于MySQL中支持多种存储引擎，在不同的存储引擎中实现略微有所差距，索引下文中如果没有特殊声明，默认指的都是InnoDB存储引擎，下文中索引基于这张user表来进行演示。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;Lily&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;Tom&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;003&lt;/td&gt;
&lt;td&gt;Jack&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;004&lt;/td&gt;
&lt;td&gt;John&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;005&lt;/td&gt;
&lt;td&gt;Alice&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;006&lt;/td&gt;
&lt;td&gt;Lucy&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;007&lt;/td&gt;
&lt;td&gt;Rose&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;008&lt;/td&gt;
&lt;td&gt;Steven&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;一、索引的底层数据结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;首先，&lt;strong&gt;索引是高效获取数据的数据结构&lt;/strong&gt;。就像书中的目录一样，我们可以通过它快速定位到数据所在的位置，从而提高数据查询的效率。&lt;/p&gt;
&lt;p&gt;在MySQL中有许多关于索引的名词和概念，对于初学者来说很容易被迷惑。为了方便理解，我建立了一张表，从具体的案例中尝试说清楚这些概念到底是什么。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hash索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如上文中说到，索引是提高查询效率的数据结构，而能够提高查询效率的数据结构有很多，如二叉搜索树，红黑树，跳表，哈希表（散列表）等，而MySQL中用到了B+Tree和散列表（Hash表）作为索引的底层数据结构。&lt;/p&gt;
&lt;p&gt;需要注意的是，MySQL&lt;strong&gt;并没有显式支持Hash索引，而是作为内部的一种优化，对于热点的数据会自动生成Hash索引，也叫自适应Hash索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Hash索引在等值查询中，可以O（1）时间复杂度定位到数据，效率非常高，但是不支持范围查询。在许多编程语言以及数据库中都会用到这个数据结构，如Redis支持的Hash数据结构。具体结构如下：&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003062222_485.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;p&gt;B+Tree索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提到B+Tree首先不的不提&lt;strong&gt;B-Tree&lt;/strong&gt;，B-Tree（多路搜索树，并不是二叉的）是一种常见的数据结构。使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003062247_592.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;B+ 树&lt;/strong&gt;是基于B-Tree升级后的一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。&lt;/p&gt;
&lt;p&gt;MySQL索引的实现也是基于这种高效的数据结构。具体数据结构如下：&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003062246_930.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;笔者首先要声明一下，不要将&lt;strong&gt;B树，B-Tree以及B+Tree&lt;/strong&gt;弄混淆。首先，B-Tree就是B树，中间的“-”是一个中划线，而不是减号，并不存在&quot;B减树&quot;这种数据结构。其次，就是B+Tree和B-Tree实现索引时有两个区别，具体可见下图&lt;/p&gt;
&lt;p&gt;①B+Tree只在叶子节点存储数据，而B-Tree的数据存储在各个节点中&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003062231_313.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;②B+Tree的叶子节点间通过指针链接，可以通过遍历叶子节点即可获取所有数据。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003062301_57.gif?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;B+Tree是一种神奇的数据结构，如果用语言来讲可能会优点费劲，感兴趣的同学可以&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot;&gt;点击这里&lt;/a&gt;进行数据结构可视化，操作一番后想必会有所收获，下图是笔者演示B+Tree的数据插入方式（自下而上）。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003062304_443.gif?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;二，数据组织方式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;根据数据的组织方式，可以分为聚簇索引和非聚簇索引（也叫聚集索引和非聚集索引）。如果是索引组织数据，就称之为聚簇索引，否则称之为非聚簇索引，简单来说&lt;strong&gt;索引和数据是否存储在一起&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;strong&gt;这种索引划分方式通常用来体现不同存储引擎的组织数据方式的差异&lt;/strong&gt;（通常指的是InnoDB和MyISAM存储引擎）。而&lt;strong&gt;InnoDB中的辅助索引并不能称之为非聚簇索引&lt;/strong&gt;，关于辅助索引的内容，下文会进行详细介绍。InnoDB中是通过索引来组织数据，为聚簇索引。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003062319_207.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;而MyISAM中索引和数据文件分开存储，为非聚簇索引。B+Tree的叶子节点存储的是&lt;strong&gt;数据存放的地址&lt;/strong&gt;，而不是具体的数据 。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003062321_115.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;三，索引字段个数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;为了能应对不同的数据检索需求，索引即可以仅包含一个字段，也可以同时包含多个字段。单个字段组成的索引可以称为单值索引，否则称之为复合索引（或者称为组合索引或多值索引）。上文中演示的都是单值索引，所以接下来展示一下复合索引作为对比。&lt;/p&gt;
&lt;p&gt;复合索引的索引的数据顺序跟字段的顺序相关，包含多个值的索引中，如果当前面字段的值重复时，将会按照其后面的值进行排序。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003062340_16.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h2 id=&quot;h-3&quot;&gt;&lt;span&gt;四, 是否存储完整数据行&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;MySQL中是根据&lt;strong&gt;主键&lt;/strong&gt;来组织数据，所以每张表都必须有主键索引，&lt;strong&gt;主键索引只能有一个，不能为null同时必须保证唯一性&lt;/strong&gt;。建表时如果没有指定主键索引，则会自动生成一个隐藏的字段作为主键索引。&lt;/p&gt;
&lt;p&gt;如果不是主键索引，则就可以称之为&lt;strong&gt;非主键索引&lt;/strong&gt;，又可以称之为辅助索引，二级索引。主键索引的叶子节点存储了完整的数据行，而&lt;strong&gt;非主键索引的叶子节点存储的则是主键索引值&lt;/strong&gt;，通过非主键索引查询数据时，会先查找到主键索引，然后再到主键索引上去查找对应的数据，这个过程叫做&lt;strong&gt;回表&lt;/strong&gt;（下文中会再次提到）。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003070007_551.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h2 id=&quot;h-4&quot;&gt;&lt;span&gt;五，其他分类&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;唯一索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;唯一索引，不允许具有索引值相同的行，从而禁止重复的索引或键值。系统在创建该索引时检查是否有重复的键值，并在每次使用 INSERT 或 UPDATE 语句添加数据时进行检查， 如果有重复的值，则会操作失败，抛出异常。&lt;/p&gt;
&lt;p&gt;需要注意的时，主键索引一定时唯一索引，而唯一索引不一定时主键索引。&lt;strong&gt;唯一索引可以理解为仅仅是将索引设置一个唯一性的属性&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;覆盖索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上文提到了一个回表的概念，既如果通过非主键索引查询数据时，会先查询到主键索引的值，然后再去主键索引中查询具体的数据，整个查询流程需要扫描两次索引，显然回表是一个耗时的操作。&lt;/p&gt;
&lt;p&gt;为了减少回表次数，再设计索引时我们可以&lt;strong&gt;让索引中包含要查询的结果&lt;/strong&gt;，在辅助索引中检索到数据后直接返回，而不需要进行回表操作。&lt;/p&gt;
&lt;p&gt;但是需要注意的是，使用覆盖索引的前提是字段长度比较短，对于值长度较长的字段则不适合使用覆盖索引，原因有很多，比如索引一般存储在内存中，如果占用空间较大，则可能会从磁盘中加载，影响性能。当然还有其他原因，具体情况将会在下一篇文章中介绍。&lt;/p&gt;
&lt;h2 id=&quot;h-5&quot;&gt;&lt;span&gt;六，总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;本文从不同维度介绍了MySQL中的索引，索引从不同维度划分可以有很多种名称，但是需要明确一个问题就是，&lt;strong&gt;索引的本质是一种数据结构&lt;/strong&gt;，其他索引的划分则是针对实际应用而言。具体分类如下图所示：&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202003070129_290.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;目的是让大家对于索引有个初步且清晰的认识，解决&lt;strong&gt;What&lt;/strong&gt;的问题。后续将会针对&lt;strong&gt;Why&lt;/strong&gt;以及&lt;strong&gt;How&lt;/strong&gt;，进行深入探讨，当然，首先应当能区分本章文章中讲述的概念性问题。&lt;/p&gt;
&lt;h2 id=&quot;hqa&quot;&gt;&lt;span&gt;七、Q&amp;amp;A&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 为什么MySQL索引使用B+Tree实现，而不是搜索二叉树，红黑树或者跳表？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个综合性问题，远不止看起来那么简单，小伙伴们可以&lt;strong&gt;把答案写在留言区&lt;/strong&gt;我们一起探讨，同样笔者将会在下一篇文章中重点介绍为什么，以及如何正确使用索引。&lt;br/&gt;&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202002212337_444.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;</description>
<pubDate>Fri, 06 Mar 2020 18:04:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>一起聊聊覆盖索引，辅助索引，唯一索引，Hash索引，B-Tree索引......”到底是些什么东西？？？？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/12432236.html</dc:identifier>
</item>
<item>
<title>修改gridfilters.js源码，往后台多传递一个参数，并设置NumericFilter、StringFilter默认提示信息 - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/12431909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/12431909.html</guid>
<description>&lt;p&gt;　　创作不易，转载请注明出处！！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1504448/202003/1504448-20200306235957785-12874299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1504448/202003/1504448-20200307000009104-91470629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　在最后面添加3行，重写方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1504448/202003/1504448-20200307000313772-1153537598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;代码拷贝区&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Ext.override(Ext.ux.grid.GridFilters, {
    menuFilterText: &lt;/span&gt;&quot;筛选&quot;&lt;span&gt;
});

Ext.override(Ext.ux.grid.filter.DateFilter, {
    afterText: &lt;/span&gt;&quot;大于&quot;&lt;span&gt;,
    beforeText: &lt;/span&gt;&quot;小于&quot;&lt;span&gt;,
    onText: &lt;/span&gt;&quot;等于&quot;&lt;span&gt;
});
Ext.override(Ext.ux.grid.filter.String, {
    emptyText: &lt;/span&gt;'Enter Filter Text...'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　我这里把js压缩过的代码，格式化过，格式地址：&lt;a href=&quot;http://lzw.me/pages/jsbeautify/&quot;&gt;http://lzw.me/pages/jsbeautify/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;修改NumericFiltert提示信息(&lt;span&gt;也就是input标签中的，placeholder&lt;/span&gt;)&lt;/h2&gt;
&lt;p&gt;　　在源码的第1859行附近&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1504448/202003/1504448-20200307001227262-1306874527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;修改addFilters&lt;/h2&gt;
&lt;p&gt;　　源码的第1463行附近&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1504448/202003/1504448-20200307001446425-1164741352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;修改getFilterData&lt;/h2&gt;
&lt;p&gt;　　源码的第1492附近&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1504448/202003/1504448-20200307001805941-1594716647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;修改buildQuery&lt;/h2&gt;
&lt;p&gt;　　源码的第1522附近&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1504448/202003/1504448-20200307002047287-600548102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Mar 2020 16:22:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>创作不易，转载请注明出处！！！ 效果 修改：ext-extend.js源码 在最后面添加3行，重写方法 代码拷贝区 Ext.override(Ext.ux.grid.GridFilters, { me</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/12431909.html</dc:identifier>
</item>
<item>
<title>基于JS正则实现模板数据动态渲染 - 码农小明</title>
<link>http://www.cnblogs.com/CodeKjm/p/12431849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CodeKjm/p/12431849.html</guid>
<description>&lt;p&gt;最近业务上需要动态渲染模板数据，好久没写前端代码了，有点生疏，将思路简单写下来，防老：&lt;/p&gt;
&lt;p&gt;一、业务需求：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前端后端定义好模板以及变量名，保存数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;订单数据是前端根据支付结果获取的，最终渲染完的数据模板需要调用打印机打印出来&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;模板相对商家来说比较固定，但是每个商家需要的模板都有可能不一样，所以需要每次登录后，查询一次模板缓存前端，后续每次支付后，动态渲染数据即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;二、考点：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;正则表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;精简代码量，尽量减少前端的工作量​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;三、实现思路：&lt;/p&gt;
&lt;p&gt;1.需要渲染数据的模板，以${变量名}区分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; t=&quot;银行：${bankName}，商家名称：${merchantName}，订单号：${orderNum}&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.正则匹配获取所有变量名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; keys=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = t.match(/\$\{(.*?)\}/&lt;span&gt;g);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s=arr[key].replace(&quot;${&quot;,&quot;&quot;).replace(&quot;}&quot;,&quot;&quot;&lt;span&gt;);
    keys.push(s);
}
alert(keys);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.组装订单数据，注意变量属性名与模板里的变量名要保持一致&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; order=&lt;span&gt;{
 &lt;/span&gt;&quot;bankName&quot;: &quot;工行&quot;&lt;span&gt;,
 &lt;/span&gt;&quot;merchantName&quot;: &quot;小卖部&quot;&lt;span&gt;,
 &lt;/span&gt;&quot;orderNum&quot;: &quot;123456&quot;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.渲染数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;keys.length;i++&lt;span&gt;){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key=&lt;span&gt;keys[i];
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value=&lt;span&gt;order[key];
 t&lt;/span&gt;= t.replace(&quot;${&quot;+key+&quot;}&quot;&lt;span&gt;,value);
}
alert(t);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.查看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1295385/202003/1295385-20200306235531190-661178711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.有人会说，直接拼接字符串不是更快？比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; t=`银行：${order.bankName}，商家名称：${order.merchantName}，订单号：${order.orderNum}`;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;​这种方式在模板固定且数据量少的时候是挺好用的，但是业务上，虽然模板和数据对于商家来说相对固定，但是系统里面很多商家，每个商家的小票模板可能都不一样，需要渲染的变量也挺多，前端不可能根据每个商家都改一套模板的，总而言之，适合才是最好的！&lt;/p&gt;

</description>
<pubDate>Fri, 06 Mar 2020 16:03:00 +0000</pubDate>
<dc:creator>码农小明</dc:creator>
<og:description>最近业务上需要动态渲染模板数据，好久没写前端代码了，有点生疏，将思路简单写下来，防老： 一、业务需求： 前端后端定义好模板以及变量名，保存数据库 订单数据是前端根据支付结果获取的，最终渲染完的数据模板</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CodeKjm/p/12431849.html</dc:identifier>
</item>
<item>
<title>Swift --闭包表达式与闭包(汇编分析) - 国孩</title>
<link>http://www.cnblogs.com/guohai-stronger/p/12421590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guohai-stronger/p/12421590.html</guid>
<description>&lt;p&gt;在Swift中，可以通过&lt;span&gt;&lt;strong&gt;func&lt;/strong&gt;&lt;/span&gt;定义一个函数，也可以通过&lt;strong&gt;&lt;span&gt;闭包表达式&lt;/span&gt;&lt;/strong&gt;定义一个函数！&lt;/p&gt;
&lt;h3&gt;一、闭包表达式&lt;/h3&gt;
&lt;h4&gt;概念&lt;/h4&gt;
&lt;p&gt;闭包表达式与定义函数的语法相对比，有区别如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;去除了func&lt;/li&gt;
&lt;li&gt;去除函数名&lt;/li&gt;
&lt;li&gt;返回值类型添加了关键字in&lt;/li&gt;
&lt;li&gt;{ }放在形参列表的前边&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;闭包表达式的形式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{ 

　　 (参数列表) &lt;/span&gt;-&amp;gt; 返回值类型 &lt;span&gt;in&lt;/span&gt;&lt;span&gt;

    　函数体代码

 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;讲解&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;举例1  &lt;/strong&gt;闭包表达式作为变量或者常量的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200305220208788-1448351093.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;412&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 调用闭包表达式不需要写参数v1，v2，直接调用fn0(10,20)就可以&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例2 闭包表达式作为函数的返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200305230308658-2103911552.jpg&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;473&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例3 闭包表达式作为函数的实参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200305223440397-1594755013.png&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面讲述sorted(by:)方法定义和语法优化方式,来展示闭包表达式不同的表达方式达到同样的效果!&lt;/p&gt;
&lt;p&gt;讲述之前先简单介绍下sorted方法, Swift标准库提供了sorted(by:)方法,会将已知类型数组中的值进行排序. 一旦进行了排序会返回和原数组大小相同,包含同类型元素并且是正确排序的数组,如例3. &lt;/p&gt;
&lt;p&gt;sorted(by:)方法接受一个闭包,该闭包函数需要传入元素类型的两个值,并返回Bool值,完成排序,排序闭包函数类型需为(String, String) -&amp;gt; Bool&lt;/p&gt;
&lt;p&gt;在上面的两种写法中,都写成了(String, String) -&amp;gt; Bool, 在闭包表达式中函数和返回值类型都写在了大括号内,而不是大括号之外.&lt;/p&gt;
&lt;p&gt;下面不断简化的如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
let arr = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guohai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;闭包表达式当做参数&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法一&lt;/span&gt;
let sortArr0 = arr.sorted{(str1: String, str2: String) -&amp;gt; Bool &lt;span&gt;in&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; str1 &amp;lt;&lt;span&gt; str2
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法二: 省去了参数类型&lt;/span&gt;
let sortArr1 = arr.sorted{(str1, str2) -&amp;gt; Bool &lt;span&gt;in&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; str1 &amp;lt;&lt;span&gt; str2
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法三: 如果返回值是单一表达式,可省去return&lt;/span&gt;
let sortArr2 = arr.sorted{(str1, str2) -&amp;gt; Bool &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
    str1 &lt;/span&gt;&amp;lt;&lt;span&gt; str2
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法四: 如果编译器可以确定返回值,可以去除返回值类型&lt;/span&gt;
let sortArr3 = arr.sorted{(str1, str2) &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
    str1 &lt;/span&gt;&amp;lt;&lt;span&gt; str2
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法四: Swift闭包表达式可以不明显写出参数名,可以用美元符$表示&lt;/span&gt;
let sortArr4 = arr.sorted{$&lt;span&gt;0&lt;/span&gt; &amp;lt; $&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法五: 编译器,对于$0 &amp;lt; $1和直接&amp;lt;效果一样&lt;/span&gt;
let sortArr5 = arr.sorted(by: &amp;lt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;尾随闭包&lt;/h4&gt;
&lt;p&gt;如果将很长的闭包表达式作为函数的&lt;span&gt;&lt;strong&gt;最后一个实参&lt;/strong&gt;&lt;/span&gt;,使用尾随闭包可以增强函数的可读性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;尾随闭包是一个被书写在函数调用括号外面(后面)的闭包表达式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200306141650519-1351505604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如果闭包表达式是函数的唯一实参,而且使用了尾随闭包的语法, 那就不需要在函数名后写圆括号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200306142353312-1758399423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;二、闭包&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;闭包: 一个函数和它所捕获的变量/常量环境组合起来&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;一般指定义在函数内部的函数&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;一般它捕获的是外层函数的局部变量/常量&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看如下闭包,返回的plus和num形成了闭包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typealias Fn = (Int) -&amp;gt;&lt;span&gt; Int
func getFn() &lt;/span&gt;-&amp;gt;&lt;span&gt; Fn {
    &lt;strong&gt;var num &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;= &lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
    func plus(_ i: Int) &lt;/span&gt;-&amp;gt;&lt;span&gt;Int {
        &lt;strong&gt;num &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;+=&lt;span&gt; i
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; plus
}
var fn &lt;/span&gt;=&lt;span&gt; getFn()
print(fn(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
print(fn(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;))
print(fn(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;))
print(fn(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果大家看不出上面的结果,可以将var num = 0放在外面是全局变量,如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200306151032390-781650436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 全局变量num时,结果是不断的叠加,如果还是回到上一个,将num = 0移植到函数内部变成局部变量,和plus形成闭包,结果又如何呢? &lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200306152847803-60109365.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 发现结果是一样的,下面来探究本质!&lt;/p&gt;
&lt;p&gt;查看上面代码汇编代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200306223906984-1955274418.png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上面四次fn操作，调用访问的同一内存num，因为闭包的作用将局部变量num放进了堆空间，所以num不会被销毁！&lt;/p&gt;
&lt;p&gt;拓展：（iOS底层堆空间分配的大小是16的倍数--常识）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200306225810658-1147296694.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;508&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 06 Mar 2020 15:48:00 +0000</pubDate>
<dc:creator>国孩</dc:creator>
<og:description>在Swift中，可以通过func定义一个函数，也可以通过闭包表达式定义一个函数！ 一、闭包表达式 概念 闭包表达式与定义函数的语法相对比，有区别如下： 去除了func 去除函数名 返回值类型添加了关键</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guohai-stronger/p/12421590.html</dc:identifier>
</item>
<item>
<title>Nginx之反向代理配置（二） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12430543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12430543.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200227010408o_200226171105timg.jpeg&quot; class=&quot;desc_img&quot;/&gt; 总结一点，nginx代理动态资源和代理http资源的思想是类似的，只是使用的指令不一样；尤其对于缓存，两者的思想几乎完全一致，只是使用的模块和指令不同而已；对于动态资源我们除了要指定被代理的地址外，还需要指定被代理端资源路径，导入nginx变量与fastcgi变量对应的配置指令文件；对于缓存，两者没有什么区别；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;163.27521663778&quot;&gt;
&lt;p&gt;　　前文我们聊了Nginx的防盗链、反向代理以及开启nginx代理缓存，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12417130.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12417130.html&lt;/a&gt;；今天我们继续说nginx的反向代理，上一篇主要就说了下nginx反向代理http协议的使用，被代理RUL包含和不包含RUI的处理逻辑；我们可以把这种前后端都用同样的协议理解为同构代理，就是说前端用户访问nginx是http或https协议，代理服务器访问后端的真正提供服务的服务器也是基于http协议，这种前后端都是使用同一种协议，我们就说这是同构；同理有同构就有异构，异构就是前后端使用的协议不同，比如前端用户使用http或https协议，代理和后端服务器使用fastcgi协议，这种就叫异构；互联网上绝大部分网站都不是纯html静态网页，很多网站都是有自己的应用服务器，比如，我们用户访问的数据是需要一段脚本，或者某一程序执行后的数据，那么我们就把后面需要执行脚本的服务器叫应用服务器；nginx作为web服务器它虽然有很多功能，但是它自己没有执行某些脚本的能力比如php脚本，通俗的讲，nginx只可以处理静态文本，不能自己执行php脚本（需借助其他应用服务器），它和httpd类似，httpd还可以动态的加载php模块，让其拥有执行php脚本的能力，nginx没有，为了实现这样的功能，nginx就支持通过fastcgi协议向后端代理客户端请求一个自己不能处理的资源；当然类似的协议还有很多比如，scgi、uwsgi等等；像这种异构的架构上，它的原理是这样的，客户端请求某一脚本资源，比如，index.php这个文件，如果我们不把用户的请求代理到后端应用服务器上，客户端看到的数据是index.php里的脚本内容，这显然是不合情理的；那怎么办呢？通常情况我们需要在nginx服务器上配置，用户访问某某.php结尾的URL时，我们就让它干嘛干嘛，通过这种匹配用户的URL去做代理，把用户的请求代理到后端服务器，让后端应用服务器把脚本执行完，然后把执行后的数据返回给代理，再由代理响应给客户端；如果是后端应用服务器需要某些数据，需要到数据库里去拿数据，很可能应用服务器此时还会扮演客户端角色，通过某种协议去数据库拿数据；我们可以看到最终我们用户看到的网页里的内容，它来自很多服务器，所以说一个动态网站上由很多台服务器共同完成一个处理请求的结果，我们可以理解成，每个服务器处理自己擅长的事务，分工合作，最后把处理好的数据由代理响应给客户端；&lt;/p&gt;
&lt;p&gt;　　ngx_http_fastcgi_module：此模块实现了nginx允许将用户请求代理至fastcgi 服务器&lt;/p&gt;
&lt;p&gt;　　　　1、fastcgi_pass address：设置fastcgi服务器的地址，此地址可以是IP加端口的形式，也可以是域名或者UNIX域套接字路径；此选项可用于location 和if in location 配置段中&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
fastcgi_pass localhost：9000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上配置意思是，通过fastcgi协议反代本机的9000端口上的服务响应；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
fastcgi_pass Unix：/tmp/fastcgi.socket;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上表示设置fastcgi地址是本机/tmp/fastcgi.socket文件；&lt;/p&gt;
&lt;p&gt;　　2、fastcgi_index name;设置fastcgi的默认主页资源名称；此指令可用于http、server、location配置段中&lt;/p&gt;
&lt;p&gt;　　3、fastcgi_param parameter value [if_not_empty]：设置一个参数，用于传递给后端fastcgi服务器，参数的值可以是文本，变量，或者二者的组合。&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上配置表示把SCRIPT_FILENAME等于/home/www/scripts/php$fastcgi_script_name传递给fastcgi服务器，$fastcgi_script_name表示用户请求的脚本名称；意思是告诉fastcgi服务器该把那个脚本执行了返回给客户端（这里的客户端通常指代理服务器）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
fastcgi_param QUERY_STRING $query_string;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们知道一个脚本传递不同的参数，执行的结果就会不同；以上配置表示把请求的脚本的参数通过QUERY_STRING变量保存，并传递给后端fastcgi服务器，让其运行某脚本时，把QUERY_STRING保存的值作为参数传递给脚本；当然我们向后端传递的东西很多，不便一一写出来，也不太可能一一写到配置文件中，在nginx的配置目录里有一个文件，专门存放nginx上的变量对应后端fastcgi服务器上的变量的一个配置文件fastcgi.conf  通常我们把这个配置文件用include指令来导入到我们需要定义nginx变量通过fastcgi变量传递给fastcgi服务器；&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
location ~* \.php$ {
        root           /usr/share/nginx/html;
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/html$fastcgi_script_name;
        include        fastcgi_params;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上配置表示匹配用户URI，如果用户URI是以.php结尾的，就通过fastcgi协议代理至本机的127.0.0.1：9000端口进行处理（执行），fastcgi服务器默认主页资源名叫index.php，并告诉fastcgi服务器到/usr/share/nginx/html/下去找用户请求的资源脚本，如果还有其他参数和指令要传递，就使用/etc/nginx/fastcgi_params中的定义来把nginx的变量保存的值传递给后端fastcgi服务器，以上是反代动态php网页的配置示例，有了以上配置 nginx就可以作为代理服务器响应客户端请求动态脚本php的能力了；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www nginx]# vim /etc/nginx/conf.d/proxy.conf 
  


server {

        server_name www.test.com;

        proxy_cache proxy_cache;
#       proxy_cache_key $request_uri;
#       proxy_cache_methods GET HEAD;
        proxy_cache_valid 200 302 15m;
        proxy_cache_valid 404 1m;
#       proxy_cache_use_stale http_500 http_502;
        location  /en/docs/ {
                proxy_pass http://nginx.org;
        }
        location ~* /(.*).php$ {
                root /app/php_scripts;
                fastcgi_pass 127.0.0.1:9000;
                fastcgi_index index.php;
                fastcgi_param SCRIPT_FILENAME /app/php_scripts$fastcgi_script_name;
                include /etc/nginx/fastcgi_params;
        }
}
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
~                                                                                                                                                                          
&quot;conf.d/proxy.conf&quot; 23L, 500C written
[root@www nginx]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@www nginx]# mkdir /app/php_scripts -p
[root@www nginx]# cat &amp;gt;&amp;gt; /app/php_scripts/test.php 
&amp;lt;?php
        phpinfo();
?&amp;gt;
^C
[root@www nginx]# cat /app/php_scripts/test.php 
&amp;lt;?php
        phpinfo();
?&amp;gt;
[root@www nginx]# nginx -s reload
[root@www nginx]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在上面配置前需要先安装好php-fpm，安装好后需要更改/etc/php-fpm.d/www.conf里的user 和group,通常情况要看前端代理是用那个用户启动的，我们后端就用那个用户启动即可，我们前端代理商nginx，这里需要更改成nginx即可，这样修改后，保存配置，然后启动php-fpm，然后在本机就可以看到127.0.0.1：9000就处于监听状态了;以上配置表示用户请求.php结尾的资源都反代至127.0.01：9000进行处理；并且明确说明了后端fastcgi主页资源名称为index.php，后端应用服务器的根路径为/app/php_scripts；fastcgi_param  SCRIPT_FILENAME /app/php_scripts$fastcgi_script_name同nginx里的root alias指令的作用相同，指定用户访问的URI对应磁盘上的路径，相当于指定后端fastcgi服务器的工作目录吧；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200306221430159-1291552610.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们访问test.php是能够被php-fpm服务器执行并返回执行后的结果；&lt;/p&gt;
&lt;p&gt;　　4、fastcgi_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];此指令同proxy_cache_path一样，作用定义fastcgi的代理缓存；其中levels表示定义缓存目录的级别，最多3级，每级最多2个字符；keys_zone=name:size表示k/v映射的内存空间的名称及大小；inactive=time表示非活动时长；max_size=size表示指定磁盘上用于缓存路径的存放缓存的空间上限；&lt;/p&gt;
&lt;p&gt;　　5、fastcgi_cache zone |off;调用指定的缓存空间来缓存数据；可用于http,server,location配置段中&lt;/p&gt;
&lt;p&gt;　　6、fastcgi_cache_key string;定义用作缓存项的key的字符串；&lt;/p&gt;
&lt;p&gt;　　7、fastcgi_cache_methods GET|HEAD|POST ……；定义那些请求方法使用缓存；默认是GET和HEAD&lt;/p&gt;
&lt;p&gt;　　8、fastcgi_cache_min_uses number；定义缓存空间中的缓存项在inactive定义的非活动时间内至少要被访问到此处所指定的次数方可被认为活动的缓存项，不被清理；&lt;/p&gt;
&lt;p&gt;　　9、fastcgi_cache_valid[code] tiem;设定不同的响应码各自缓存的时长；&lt;/p&gt;
&lt;p&gt;　　10、fastcgi_keep_conn on | off;：设置是否保持连接，&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot; data-section=&quot;0&quot; data-sentence=&quot;0&quot;&gt;默认情况下，FastCGI服务器将在发送响应后立即关闭连接。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot; data-section=&quot;0&quot; data-sentence=&quot;1&quot;&gt;但是，当这个指令被设置为值on时，nginx将指示FastCGI服务器保持连接打开。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1503305/202003/1503305-20200306223453269-1568004700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：在定义缓存空间时，必须要在http配置段定义，以上表示定义一个fastcgi的缓存空间，其名称为php_cache,在内存中使用10m的空间，在物理磁盘上的路径为/cache/proxy/php-fpm/目录下，最大空间为2g;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1503305/202003/1503305-20200306224655735-1748148377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置表示使用fastcgi的缓存空间php_cache,缓存key为$request_uri，就是把用户请求的uri hash作为缓存路由，什么意思呢，就是nginx查找缓存是通过hash什么来查找缓存的，上面的配置就是定义nginx把用户请求的URI作为hash对象；对用户请求用的方法是GET 或HEAD方法时，使用缓存；缓存最小命中次数为3次，也就说在非活动时长内，该缓存项命中次数小于3次就会被认为该缓存是无效的，在下次检查缓存的有效性，就会被清理；对响应码是200 或302的资源缓存15分钟，对404响应码的资源缓存1分钟；开启和后端的fastcgi服务器的长连接；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200306230803283-798812306.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们访问test.php页面时，在我们定义的缓存空间里生成了缓存，但是我们访问了test.php这一个页面，为什么会缓存三项呢？其实我们可以打开浏览器的web开发者模式，查看它请求和响应的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1503305/202003/1503305-20200306231139019-1962941959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到我们访问test.php这个页面，其背后是3次请求，所以我们在缓存空间里看到有三条缓存项，其实缓存空间里的缓存项每一个缓存项就代表一个缓存资源，我们是可以通过cat命令查看缓存项里的内容的；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1503305/202003/1503305-20200306231556940-1570751175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：我们可以看到里面的缓存项纪录的信息，其中有一项KEY 就是我们指定的fastcgi_cache_key 说指定变量的值；我们查看缓存项里的内容很可能出现乱码，原因是缓存的内容有二进制，或者其他字符编码的内容；&lt;/p&gt;
&lt;p&gt;　　以上就是nginx作为反向代理服务器代理动态资源的介绍，总结一点，nginx代理动态资源和代理http资源的思想是类似的，只是使用的指令不一样；尤其对于缓存，两者的思想几乎完全一致，只是使用的模块和指令不同而已；对于动态资源我们除了要指定被代理的地址外，还需要指定被代理端资源路径，导入nginx变量与fastcgi变量对应的配置指令文件；对于缓存，两者没有什么区别；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 06 Mar 2020 15:46:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊了Nginx的防盗链、反向代理以及开启nginx代理缓存，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/12417130.html；今天我们继续说ng</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12430543.html</dc:identifier>
</item>
<item>
<title>2，Java中的数据结构 - 平凡的神灯</title>
<link>http://www.cnblogs.com/shendeng23/p/12431729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shendeng23/p/12431729.html</guid>
<description>&lt;div readability=&quot;38&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1，字符串（String）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···String为特殊的引用类型，不可变。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···常用实例方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    获取子串：substring(start, end);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    获取索引：indexOf(char);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    获取字符：charAt(index)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···常用静态方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    格式字符串：String.format(&quot;%s&quot;, 12);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    转为字符串：String.valueOf();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    格式拼接：String.join(&quot;, &quot;, list);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···扩展：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    StringBuilder：可变对象，用来高效拼接字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    StringBuffer：是StringBuilder的线程安全版。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;··· 注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;·&lt;/strong&gt; String.valueOf()比str.toString()安全；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;  ·&lt;/strong&gt; 常量池默认只会在编译期对字符串字面量和常量进行优化；可以通过&quot;&quot;.intern()方法在运行期将堆中的字符串放入常量池。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2，数组&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···可以通过索引访问，初始化必须指定大小，并且不可改变。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···常用方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    排序：Arrays.sort(int[]);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    转list：Arrays.asList(int[]);  // 返回的list是固定长度的，不能改变。最好用for一个个转。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    扩容：Arrays.copyOf(int[], newlenght);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    填充：Arrays.fill(int[], int);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···转Set：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    Set&amp;lt;T&amp;gt; set = new HashSet&amp;lt;&amp;gt;(Arrays.aslist(int[]));&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    由于Set构造方法的参数必须继承自Collection接口，所以要先把数组转list。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···逆序排序：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    Integer[] a = new Integer[5];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    Comparator&amp;lt;Integer&amp;gt; cmp = new Comparator&amp;lt;&amp;gt;() {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    @Override&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    public int compare(Integer o1, Integer o2) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           return o2 - o1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    };&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Arrays.sort(a, cmp);&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1201165/202003/1201165-20200306233346893-2018800674.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://www.cnblogs.com/shendeng23/p/3，Java中的数据结构_files/Java中的容器类型.jpg&quot; alt=&quot;&quot; data-filename=&quot;Java中的容器类型.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div readability=&quot;41&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3，列表（List）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···实现类：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ArrayList：数组实现；LinkedList：链表实现；Vector：线程安全；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···常用实例方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    根据索引查找：get(index);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    判断是否存在：contains(obj);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    查找索引：indexOf(obj);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    排序：sort(Comparator)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    合并两个list：addAll(list);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    转数组：toArray(new Obj[]{});&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;···常用静态方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    排序：Collections.sort(list,Comparator);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    逆序：Collections.reverse(list);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    求最值：Collections.max(list); Collection.min(list)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    浅拷贝：Collections.copy(dest, src);  // dest的实际长度必须大于或等于src&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···List的stream方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(1,2,3));&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    List&amp;lt;Integer&amp;gt; a = list.stream().map(x-&amp;gt; x*2).collect(Collectors.toList());&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4，&lt;/span&gt;集合（Set）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···实现类：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    HashSet：数组实现，无序(有规律)；TreeSet：自动排序；LinkedHashSet：链表实现，保持原序；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     由于Set也继承自Collection接口，所以其他方法与List类似，底层实现也是Hash，相当于是没有value的Map。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;34&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5，&lt;/span&gt;键值对（Map）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···实现类：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    HashMap：数组实现，无序；TreeSet：根据Key排序；LinkedHashMap：保持原序；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···常用实例方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    获得所有Key：KeySet()，返回值为Set类型；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    获得所有Value：values();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···排序：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    先把map.entrySet()放入list，再用Collection.sort(list, Compartor)；对list的value排序，再把list放入LinkedHashMap中即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    HashMap中的key和value都可以为null。而Hashtable不可以。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;··· &lt;span&gt;*底层理解*：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;·大致实现：&lt;/strong&gt;HashMap底层使用的是哈希表加链表。输入的key是对象的hashCode；哈希函数是&lt;/span&gt;hashCode &amp;amp; （lenght - 1）；哈希冲突的解决办法是使用链表保存哈希值相同的对象。当链表长度大于8时使用红黑树保存(jdk1.8开始)；查询时先通过对象的hashCode找到对象在数组的位置，然后通过equals()遍历链表，找到目标对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;·细节优化：&lt;/strong&gt; 哈希函数hashCode &amp;amp; (lenght-1)是位运算， 比模运算快很多；由于哈希函数是hashCode &amp;amp; (lenght-1)，所以当哈希表的长度lenght是2的幂次方时哈希表的利用率最高，哈希冲突也就越小，比如：当lenght为15时hashCode &amp;amp; 14，hashCode &amp;amp; 1110 时第一位0与上任何数都为0，所以哈希函数的结果永远不会出现第一位为1的情况，即0001、0011等位置上永远不会存值，导致实际利用长度变小，也就越容易出现哈希冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;·扩容：&lt;/strong&gt;由于数组的长度固定(默认是16)，所以当实际长度超过最大长度的75%时，需要对哈希数组进行扩容，增大为原最大长度的2倍，并将旧哈希表的元素重新计算哈希值放入新的哈希表中，非常消耗性能，所以在初始化时尽量指定长度，以避免扩容。例如：需要存放1000个元素时，指定初始化大小为2048（1024*75%&amp;lt;1000所以还会扩容，因此选择2048）。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6，包装类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···概念：&lt;/strong&gt;包装类型是把基本类型包装为引用类型，把基本类型转为引用类型称为装箱，反之为拆箱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;···优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;  ·&lt;/strong&gt; 与基本类型相比，包装类型提供了大量实用的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;· &lt;/strong&gt;在项目中尽量使用包装类型，因为包装类型的null和0可以区分有值和没值。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意事项&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    · a=a+12 与 a+=12 的区别：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;当a为short时，使用会把12当成int类型；而使用 += 时，会把右边的字面量12转为左边变量的类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;·&lt;/strong&gt; &lt;strong&gt;进制显示：&lt;/strong&gt;二进制(0b)：int b=0b101;  八进制(0)：int e=032;  十六进制(0x)：int h=0xf1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;· Boolean类型：&lt;/strong&gt;boolean类型可以进行 位运算，并且运算符优先级：&amp;gt;, &amp;amp;, &amp;amp;&amp;amp;，且位运算符与逻辑运算符的效果一样，但是不会短路。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 06 Mar 2020 15:35:00 +0000</pubDate>
<dc:creator>平凡的神灯</dc:creator>
<og:description>1，字符串（String） &amp;#183;&amp;#183;&amp;#183;String为特殊的引用类型，不可变。 &amp;#183;&amp;#183;&amp;#183;常用实例方法： 获取子串：substring(start,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shendeng23/p/12431729.html</dc:identifier>
</item>
<item>
<title>【Django】接收照片，储存文件  前端代码 - PythonNew_Mr.Wang</title>
<link>http://www.cnblogs.com/wanghong1994/p/12431691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanghong1994/p/12431691.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;后端:
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIView
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; car &lt;span&gt;import&lt;/span&gt;&lt;span&gt; settings
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render, redirect, HttpResponse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; dal &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.http &lt;span&gt;import&lt;/span&gt;&lt;span&gt; JsonResponse
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

&lt;span&gt;BASE_DIR &lt;/span&gt;&lt;/span&gt;= os.path.dirname(os.path.dirname(os.path.abspath(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;)))

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Image(APIView):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self, request):
        file_obj &lt;/span&gt;= request.FILES.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;send&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,None)

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file_obj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,file_obj.name)

        &lt;span&gt;file_path &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= os.path.join(BASE_DIR, 'media', 'user/img', file_obj.name)

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file_path&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, file_path)

        with open(file_path, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; chunk &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file_obj.chunks():
                f.write(chunk)

        message &lt;/span&gt;=&lt;span&gt; {}
        message[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 200

        &lt;span&gt;return&lt;/span&gt; JsonResponse(message)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端ajax:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;form method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/upload/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; enctype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multipart/form-data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; target=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ifm1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;


       &lt;span&gt; &amp;lt;input type=&quot;file&quot; name=&quot;send&quot;/&amp;gt;&lt;/span&gt;


        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form表单提交&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 06 Mar 2020 15:28:00 +0000</pubDate>
<dc:creator>PythonNew_Mr.Wang</dc:creator>
<og:description>后端: from rest_framework.views import APIView from car import settings from django.shortcuts import r</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wanghong1994/p/12431691.html</dc:identifier>
</item>
<item>
<title>Python 中的集合 --set - 啄木先生</title>
<link>http://www.cnblogs.com/techfix/p/12431696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techfix/p/12431696.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;在Python中,我们用&lt;code&gt;[]&lt;/code&gt;来表示列表&lt;code&gt;list&lt;/code&gt;，用&lt;code&gt;()&lt;/code&gt;来表示元组&lt;code&gt;tuple&lt;/code&gt;，那&lt;code&gt;{}&lt;/code&gt;呢？&lt;code&gt;{}&lt;/code&gt;不光可用来定义字典&lt;code&gt;dict&lt;/code&gt;，还可以用来表示集合&lt;code&gt;set&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;集合 set&lt;/h3&gt;

&lt;p&gt;集合（set）是一个无序的不重复元素序列，集合中的元素不能重复且没有顺序，所以不能通过索引和分片进行操作。&lt;/p&gt;

&lt;h3&gt;如何创建&lt;code&gt;set&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;•set() 创建一个集合，需要提供一个序列（可迭代的对象）作为输入参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;字符串&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;列表&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; set([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;元组&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; set((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 集合中的元素不重复&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aabc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;整数&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; set(123&lt;span&gt;)

Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;pyshell#3&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 1, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;span&gt;
    set(&lt;/span&gt;123&lt;span&gt;)
TypeError: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; object &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; iterable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;•{}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; {1,2,3&lt;span&gt;}
{&lt;/span&gt;1, 2, 3&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a = {1,2,3&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; type(a)
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但注意 利用 {} 来创建集合不能创建空集合，因为 {} 是用来创造一个空的字典&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;set&lt;/code&gt;的常用方法&lt;/h3&gt;

&lt;p&gt;•set`的添加和删除，更新&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; a = set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; a
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加元素&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; a.add(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; a
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重复添加无效果&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; a.add(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; a
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除元素&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; a.remove(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; a
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;update 把要传入的元素拆分，作为个体传入到集合中&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; a.update(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abdon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; a
{a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;d&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;o&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;n&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;•&lt;code&gt;set&lt;/code&gt;的集合操作符&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1922553/202003/1922553-20200306232729576-1086532309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; a = set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; b = set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cdef&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a&amp;amp;&lt;span&gt;b
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a |&lt;span&gt; b  
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a -&lt;span&gt;b
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a
True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a
False
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a !=&lt;span&gt; b
True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a ==&lt;span&gt; b
False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;集合还有不可变集合&lt;code&gt;frozenset&lt;/code&gt;,用的不多，有兴趣的同学可以自行学习下!&lt;/p&gt;
&lt;p&gt; 更多交流公众号：猿桌派&lt;/p&gt;
</description>
<pubDate>Fri, 06 Mar 2020 15:28:00 +0000</pubDate>
<dc:creator>啄木先生</dc:creator>
<og:description>前言 在Python中,我们用[]来表示列表list，用()来表示元组tuple，那{}呢？{}不光可用来定义字典dict，还可以用来表示集合set。 集合 set 集合（set）是一个无序的不重复元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techfix/p/12431696.html</dc:identifier>
</item>
</channel>
</rss>