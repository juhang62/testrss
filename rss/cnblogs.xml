<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据结构-线性表 - 如果可以，我选择忘记</title>
<link>http://www.cnblogs.com/if-it-is-possible/p/11406880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/if-it-is-possible/p/11406880.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 顺序表逆置问题&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;int temp ;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;int a [maxSize] = {1,2,3,4,5,7,6} ;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;for(int i = left , j = right ; i &amp;lt; j ; i++ ,j--)
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;    temp = a[i];
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;    a[i] = a[j];
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;    a[j] = temp;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.链表逆置问题&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;//t指向的是p-&amp;gt;next ;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;//p指向的最开始的节点；
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;//q始终指向的是最初的末尾节点
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;//p 和 q 是定向的指针 ， 而 t 是动态的指针 ； LNode * p ; LNode * q ； LNode *&amp;amp;t ;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;while（p-&amp;gt;next != q ）    
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    t = p-&amp;gt;next ;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    p-&amp;gt;next = t-&amp;gt;next;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    t-&amp;gt;next = q-&amp;gt;next;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    q-&amp;gt;next = t ;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.真题演练2&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;题目：
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;1）将一长度为n的数组的前端k(k&amp;lt;n)个元素逆序后移动到数组后端，
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;   要求原数组中的数据不丢失。
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;2）将一长度为n的数组的前端k(k&amp;lt;n)个元素保持原序移动到数组后端，
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;   要求原数组中的数据不丢失。
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;3）将数组中的元素（X0 , X1, ...Xn-1），经过移动后变为：
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;  （Xp,Xp+1,...Xn-1,X0,X1,...Xp-1）,即循环左移p(0&amp;lt;p&amp;lt;n)个位置。
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;   
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;1）
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;#include&amp;lt;iostream&amp;gt;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;using namespace std ;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;void reverse (int a [] , int left , int right , int k)
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    int temp ;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;    for(int i = left , j = right ; i &amp;lt; j &amp;amp;&amp;amp; i &amp;lt; left + k ; i++ , j-- )
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;        temp = a [ i ];
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        a [ i ] = a [ j ];
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        a [ j ] = temp ;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;2）
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;自己的思路
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;void reverse (int k , int a [] , int left , int right ,int length)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    for( int i = 0 ; i &amp;lt; k ; i++ )
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;        for(int j = 0 ; j &amp;lt; length + 1 ; j++ )
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            a[length - i ] = a[i] ;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;            a[j] = a[j+1];
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;率辉
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;//两次逆值使其顺序变为正序，
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;1.第一次逆值是将前k个元素进行逆值
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;2.第二次就是第一题的原理，正好得出相反的结果
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;void movetoEnd (int a [] , int n , int k )
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;    reverse(a , 0 , k-1 , k );
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;    reverse(a , 0 , n-1 , k );
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;3）
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;通过三次的逆置实现
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;1. 0 ~ p-1 
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;2. p ~ n 
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;3. 0 ~ n 
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;void moveP (int a[] , int n , int p )
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;    reverse(a,0,p-1,p);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;    reverse(a,p,n-1,n-p);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;    reverse(a,0,n-1,n);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 25 Aug 2019 00:40:00 +0000</pubDate>
<dc:creator>如果可以，我选择忘记</dc:creator>
<og:description>将线性表分为几个模块来学习： 1.单链表头插法建表 2.单链表尾插法建表 3.归并 4.划分 5.逆置 6.顺序表建表 7.顺序表删除 8.顺序表添加 9.最值问题 10.真题演练 1.单链表头插法建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/if-it-is-possible/p/11406880.html</dc:identifier>
</item>
<item>
<title>不为人知的华为和小米真相 - 初码</title>
<link>http://www.cnblogs.com/chuma/p/11406783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chuma/p/11406783.html</guid>
<description>&lt;h3 id=&quot;导读&quot;&gt;导读&lt;/h3&gt;
&lt;p&gt;    一、华为是集体意识的集大成者&lt;br/&gt;    二、小米为中国人生活质量的提升做出了巨大的贡献&lt;br/&gt;    三、小米是典型的当婊子立牌坊的技术商人&lt;br/&gt;    四、集体主义下的华为的研发效率极其低下&lt;br/&gt;    五、离开销售和营销，华为难有建树，举步维艰&lt;br/&gt;    六、华为的销售、宣传、公关实在无敌&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;    &lt;strong&gt;小米前几天公布了漂亮的财报（真心话，确实挺漂亮的，有兴趣的&lt;a href=&quot;https://image.aliyun.cdn.chuma.cn/CMCore/WSA/Blog/Pic/2539DDEB180243DDAC6962D89B4C5E30.jpg&quot;&gt;点击观看&lt;/a&gt;），但报后却股价大跌，把连续几天的涨势一次抹平。市场似乎并不买账，这样的滑稽场景伴随着小米在香港上市起就源源不断，让人哭笑不得...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;而华为这边呢，毛衣战加持下，一路高歌猛进，国外订单不跌，国内订单激增，满眼光鲜亮丽...&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;虽然严格来说华为的业务体系和小米并不一样，企业类型也大相径庭，但作为普通消费者，有用华为手机的，也有用小米手机的，在直觉上依然会拿两家出来比较，甚至在长期的比较过程中，出现了一些“深入人心”的结论：华为是完全自己研发的高端企业，小米是组装代工的百货商店。乍一看，这种言论似乎真的就是两家内在本质的外在表现，但真相到底如何，恐怕早已湮没在了狂热中...&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;    &lt;strong&gt;作为一个数码爱好者，两个品牌都有我喜欢和推崇的地方，我也使用过无数的华为和小米设备，也恰好对行业有一些经历和了解，在我看来，目前舆论已经走偏了，出于逻辑正义感，我觉得有必要把自己了解的一些东西讲出来，从不一样的视角还原一些不为人知的真相&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;鉴于目前的白色高压环境，我想先说一句自保的话&lt;/strong&gt;：&lt;br/&gt;    &lt;strong&gt;我不是高高在上的行业分析师，我也不是新闻调查记者，我就是一个对相关领域较为了解、喜欢做一些深度思考的普通人，写下文本只因逻辑正义，也为促进两家公司更好的发展，我没有收钱，更不是FH势力，两家公司特别是华为的公关不要向我挥舞法务铁拳。本文是思考和讨论，无意对华为和小米做任何的商誉侵犯，请不要送我跨省刑拘。我始终觉得有批评才有进步，如果说一句四大发明无用就要被送进道德监狱，就要被挖坟连坐，那这样的社会形态真的是挺没劲也挺恐怖的。如有疑问欢迎邮件&lt;a href=&quot;mailto:zhangrou@chuma.cn&quot;&gt;（zhangrou@chuma.cn）&lt;/a&gt; 交流&lt;/strong&gt;。&lt;br/&gt;    &lt;strong&gt;同时也预先告知一些小FH们，严格来说，本文是严肃的分析文章，如果看不进去或者看不懂可以止步，但请手下留情，不要用没有逻辑的言论在自己未知的领域指手画脚啦。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;一华为是集体意识的集大成者&quot;&gt;&lt;strong&gt;一、华为是集体意识的集大成者&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://image.aliyun.cdn.chuma.cn/CMCore/WSA/Blog/Pic/E11660CB2F2141B5A2697986A0AE302F.jpg&quot; alt=&quot;社会主义铁拳&quot;/&gt;&lt;/p&gt;
&lt;p&gt;华为能有今天的成就，不谈各种细节过程，只从较高的层面看，我的理解和总结就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;在一定的历史机遇下华为的集体意识成就了数十年的稳定与高速发展&quot;&gt;&lt;strong&gt;在一定的历史机遇下，华为的集体意识成就了数十年的稳定与高速发展&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体来说，&lt;strong&gt;对内对外都是很强的集体意识&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;内部&quot;&gt;内部&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;外行管理内行、制度指挥技术、逻辑服从战略，这些是华为的管理常态，一旦目标订立，所有人不惜一切代价集体达成。&lt;/li&gt;
&lt;li&gt;重要的头部技术研发，可以启用特别的人才，给予特别的待遇。但是对于中部和日常项目，要求任何技术人员都可以替代，不允许出现A走了B顶不上的情况。&lt;strong&gt;允许你有拔尖的能力和机会，但决不允许你在内部有翻天的行为和影响&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;校园招聘这样的典型场景，华为不像BAT会用严格的HR流程筛选出极其拔尖的985头部人才。反而很多时候也会选择南邮北邮西电这样的通讯对口专业进行批量招聘，&lt;strong&gt;愿意吃苦的中庸人才更加易于管理管控&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;外部&quot;&gt;外部&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;我会真心诚意的搞研发，制造出最优的产品给顾客你使用。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;但如果我出现了问题，我可以自己解决，顾客你不能说我的不好，也不能指责我的问题。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;我默认任何对我的称赞哪怕是捧誉，也会自动过滤对我的批评和责怪。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;我在任何时候，都是无比强大的凝聚在一起的一个团队和品牌，&lt;strong&gt;这种对外凝聚力的对内要求，即有任务式的，也有发自内心的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;一些事是否已被忘记&quot;&gt;一些事是否已被忘记&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;大家都知道今日华为5G基站的优秀，不知是否还有人记得十来年前华为交换机在苦苦追赶思科路上的种种辛苦，&lt;strong&gt;性能指标落后，代码被指抄袭&lt;/strong&gt;，硬是靠&lt;strong&gt;运营商采购和持续使用，站稳了销售&lt;/strong&gt;，为今天的成果奠定了基础。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;大家也都惊叹于华为今日麒麟980处理器完全不虚高通三星，SOC的5G模块性能指标甚至碾压竞争对手，但不知是否有人用过&lt;strong&gt;海思K3V2的手机&lt;/strong&gt;，我曾经买过一台好玩的防水手机华为D2，那种出厂就卡，各种卡和热到让人崩溃的体验至今难忘，事实上，直到&lt;strong&gt;麒麟960（Mate9 P10）&lt;/strong&gt;，华为手机才勉强达到友商的绝对性能，才开始走上SOC崛起之路，&lt;strong&gt;靠着这些坑过用户的麒麟芯手机的持续销量，终于堆出了一个真正强大的中国芯&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;是的崛起之路确实需要过程牺牲而且是牺牲花钱的客户&quot;&gt;&lt;strong&gt;是的，崛起之路，确实需要过程牺牲，而且是牺牲花钱的客户。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;也说一个有意思的小细节，华为手机有一些列应用和机制，或者说有一套体系，叫&lt;strong&gt;省电精灵&lt;/strong&gt;，终极目的是维护自己省电、低能耗比的形象，是的，在此理念的运作之下，华为各类手机确实极其省电，但这并不是用户体验驱动的，用户并不是First的，“&lt;strong&gt;省电的品牌形象&lt;/strong&gt;”才是第一位的。&lt;strong&gt;当你有多个App同时操作的工作需求时，你会被EMUI不顾后台常驻选项规则，执着的杀你App和降频搞到崩溃不已&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;是的，这样的集体意识，就是要求&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;忘记历史共同背负艰难成就下一刻的荣耀&quot;&gt;&lt;strong&gt;忘记历史，共同背负艰难，成就下一刻的荣耀&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信很多人看到这已经察觉到了，&lt;strong&gt;这种发展轨迹，和30年来的改革开放极其相似，甚至有不少缩影映射&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;作为消费者和传统的技术人我确实有时候比较反感和反对这样的价值形态但是我不评价也没有资格评价这种意识形态的好与坏同时在民族角度我也真心的支持和称赞这种集体意识无论如何确实拔地而起一个中国巨头带来了越来越佳的消费和商业体验华为也成为了中华民族对外冲突时一股坚强的力量不能要求更多了&quot;&gt;&lt;strong&gt;作为消费者和传统的技术人，我确实有时候比较反感和反对这样的价值形态，但是我不评价也没有资格评价这种意识形态的好与坏。同时在民族角度，我也真心的支持和称赞这种集体意识，无论如何，确实拔地而起一个中国巨头，带来了越来越佳的消费和商业体验，华为也成为了中华民族对外冲突时一股坚强的力量，不能要求更多了。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二小米为中国人生活质量的提升做出了巨大的贡献&quot;&gt;&lt;strong&gt;二、小米为中国人生活质量的提升做出了巨大的贡献&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://image.aliyun.cdn.chuma.cn/CMCore/WSA/Blog/Pic/4F9FC825BE7940BC92052AA2BF927DA3.jpg&quot; alt=&quot;美好生活&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小米，可以说是和华为完全不一样的性格与基因，小米成立伊始，就走了一条&lt;strong&gt;科技、性价比、互联网产品&lt;/strong&gt;的路，虽说世界上永远不缺优秀的产品，但是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;小米从提升性价比和降低价格门槛入手常年专注于互联网对传统消费品的赋能并落地想法和创新确确实实的通过各种高性价比产品把获得高质量生活满足感的代价降低了n个门槛而小米所创造了一系列的互联网产品观和价值观也影响和带动了无数的周边企业品牌和产业&quot;&gt;&lt;strong&gt;小米，从提升性价比和降低价格门槛入手，常年专注于互联网对传统消费品的赋能并落地想法和创新。&lt;/strong&gt;确确实实的通过各种高性价比产品，把获得高质量生活满足感的代价降低了N个门槛&lt;strong&gt;，而小米所创造了一系列的互联网产品观和价值观，也影响和带动了无数的周边企业、品牌和产业。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;基于小米对用户、对产业做出的贡献，如此夸赞绝不过誉&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;小米的伟大贡献，不在于产品有多么高的绝对高度，而在于“&lt;strong&gt;降低门槛&lt;/strong&gt;”这四个字。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MIUI的不断深度和用心研发，本身就低价的手机还附送这么一个业内最好的Rom，就这样持续的为用户降低手机使用难度、提升移动办公效率。&lt;/li&gt;
&lt;li&gt;小米介入移动电源领域，弄出了&lt;strong&gt;既便宜（甚至是最便宜）&lt;/strong&gt;、又超高安全和质量（应该已经&lt;strong&gt;全球头部技术含量&lt;/strong&gt;了）的移动电源，好用无比。&lt;/li&gt;
&lt;li&gt;小米介入电视领域，第一次让人惊讶的看到大屏电视可以这么便宜，小米盒子还能这么玩，最近75寸好像已经降到7000以内了，这种在产业上从&lt;strong&gt;价格搅局开始&lt;/strong&gt;，至&lt;strong&gt;完全健康发展后依然保持低价的业态&lt;/strong&gt;，是小米价值观的一个缩影。&lt;/li&gt;
&lt;li&gt;小米手环更不用说了，最近出的小米手环4，200不到的价格，从纯硬件参数看，真心是便宜。回看第一代小米手环，也是几十块的低价就实现了闹钟、睡眠检测、运动模式等基本功能。&lt;strong&gt;用苹果watch的人还真别瞧不上，这种高性价比手环，对没有用过手环的大部分人来说，几十块就带来了巨大生活品质的提升，真的是无与伦比的赞&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;除此之外还有小米空调、洗衣机、扫地机等高性价比产品。还有小米引领的智能家庭IOT生态互联的概念、小米商城的线上抢购直销、小米之家线下科技杂货店等各种&lt;strong&gt;创新的行业模式&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;如此小米非常值得尊重在历史上是有位置的&quot;&gt;&lt;strong&gt;如此小米，非常值得尊重，在历史上是有位置的&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三小米是典型的当婊子立牌坊的技术商人&quot;&gt;&lt;strong&gt;三、小米是典型的当婊子立牌坊的技术商人&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://image.aliyun.cdn.chuma.cn/CMCore/WSA/Blog/Pic/A19A0C2B66D9489DAD73BFAC620D51F2.jpg&quot; alt=&quot;站着把钱挣了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小米既然如此伟大，&lt;strong&gt;经营也非常健康&lt;/strong&gt;，但为何落得如今这样&lt;strong&gt;股价腰斩，众多指责&lt;/strong&gt;的下场呢，我觉得：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;当雷军这样一个程序员从较为闭塞的金山这样一个半技术半商业环境走出来投身完全商业化的手机等领域时总是无法准确把握情怀和资本的关系而这种定位失衡进而自上而下给公司带来一系列的困扰觉得自己应该少赚钱让利消费者得到品牌赞誉又觉得自己能讲好资本故事对得起投资者结果呢做好事得坏名是近些年来小米在这种失衡心态下不断的弄巧成拙而小米在营销上依然一副技术和逻辑驱动的理念学别人的狼性营销又学不来搞的不上不下莫名其妙然后我们能看到的就是小米的伟大贡献并未收获等值的品牌形象而随着模仿者追赶者越来越多伟大贡献已经被消费者忘的差不多了但小米的初心却在商业环境中表现不出绝对的竞争力和战斗力能料想到的是这种消费者与资本两头不讨好的情况还会持续下去&quot;&gt;&lt;strong&gt;当雷军这样一个程序员从较为闭塞的金山这样一个半技术半商业环境走出来，投身完全商业化的手机等领域时，总是无法准确把握情怀和资本的关系，而这种定位失衡进而自上而下给公司带来一系列的困扰，“觉得自己应该少赚钱让利消费者得到品牌赞誉，又觉得自己能讲好资本故事对得起投资者”。结果呢？“做好事，得坏名”是近些年来小米在这种失衡心态下不断的弄巧成拙。而小米在营销上依然一副技术和逻辑驱动的理念，学别人的狼性营销又学不来，搞的不上不下莫名其妙。然后我们能看到的就是：小米的伟大贡献并未收获等值的品牌形象，而随着模仿者、追赶者越来越多。伟大贡献已经被消费者忘的差不多了，但小米的初心却在商业环境中表现不出绝对的竞争力和战斗力。能料想到的是，这种消费者与资本两头不讨好的情况还会持续下去。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一些印象深刻的场景&quot;&gt;一些印象深刻的场景&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;小米上市了，送了雷军价值接近100亿的2%市值的奖励，其实预先计提这些收益无可厚非，刘强东也做过类似的事，马云也说为了家庭要进行套现，可是从我能看到的小米通稿新闻中，看到的和感受到的气息都是，雷军不知道这个事，是董事会送给雷军的礼物和惊喜，本人事先完全不知情，也会捐给慈善基金。可作为旁观者，即使我不去恶意揣测这个过程，&lt;strong&gt;一股技术人员的牌坊恶臭已扑面而来&lt;/strong&gt;，真的没有必要，不需要这样。&lt;strong&gt;光明正大的套现原本是优秀商人的权利&lt;/strong&gt;。&lt;strong&gt;但如此糟糕公关操作却让这个新闻的负面持久发酵，甚至成为一个被黑粉持续提及的污点&lt;/strong&gt;，很简单呗，普通人就是不信呀，你明明挣钱了却说不是自己的想要的。接地气一点不好吗，非要树立一个不为金钱只为顾客的理想形象吗？&lt;strong&gt;这样的糟糕公关真是小米日常翻车的缩影&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;从商业逻辑角度，雷军多次提及到的&lt;strong&gt;现金流、库存以及相关风险管控&lt;/strong&gt;，我是极其赞同的，其企业健康发展的理念和理论是对投资人负责，也是对消费者负责。但这理念的背后，就是大家津津乐道的两个字“&lt;strong&gt;耍猴&lt;/strong&gt;”，高性价比旗舰手机常年抢购没货，&lt;strong&gt;猴王雷军也得名于此&lt;/strong&gt;。其实小米的相关高管也不止一次的透露过小米的供货策略，就是严谨的测算出货量后，&lt;strong&gt;不压库存，快速流通，企业的健康才能换来长久的优质服务&lt;/strong&gt;。这本是好事，但偏偏小米执着的要打造自己价格宽厚、极高性价比、为广大群众着想的高大形象。结果就是一次又一次的消耗米粉的耐心，&lt;strong&gt;实实在在的好机器，非要搞到最后一机难求，二级市场溢价购买&lt;/strong&gt;。我绝对相信发布会上的良心定价是雷军和小米的初心，但在商业上又不能100%做到供应顺畅，结果就&lt;strong&gt;是一副看起来口不对心的虚伪&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;小米小店也是类似的畸形产物，羡慕人家VIVO、OPPO甚至华为有各类线下店，销量利润双丰收。然后自己也去玩这套模式，可大家看看玩的都是个啥？OV和华为讲究的是给&lt;strong&gt;代理商很高的溢价激励你去卖手机&lt;/strong&gt;，同时配套铺天盖地广告，最后联合代理商一起割韭菜。可小米是怎么玩的，小米和小店店主说你得和我一起有初心，一起要给米粉最好的性价比手机，&lt;strong&gt;溢价很低&lt;/strong&gt;，还要&lt;strong&gt;扛起整个小店的精神面貌和价值观&lt;/strong&gt;，然后小米小店的渠道空间和线上比毫无优势，淘宝的黄牛都比不过。这一系列的混乱操作真是看的一言难尽。&lt;strong&gt;为了那仅有一点初心“面子”，弄出无数的畸形来&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;有关代言人操作也是如此，学OV请明星，可问题是你小米自己本来就是走性价比路线的，自己就给自己代言，这么莫名其妙又请来收割韭菜的流量明显，请问你的&lt;strong&gt;定价策略如何才能匹配这种明星策略&lt;/strong&gt;？最令人心痛的就是小米9这款机器了，我算是资深的小米用户了，我非常清楚从米8开始相机有了巨大的飞跃，到了米9更是能玩能打，而米9本身的硬件配置&lt;strong&gt;相当水桶甚至拔尖&lt;/strong&gt;，但在&lt;strong&gt;耍猴+流量明星的畸形加持下&lt;/strong&gt;，最后只卖了200多万台。连米8都不如。这种手机难道不应该&lt;strong&gt;通过健康的策略像RedmiNote7那样不需要代言人也至少卖个2000万台吗&lt;/strong&gt;？小米社区有几个帖子，无数的米粉强烈希望把乱七八糟的代言费投入到研发和对社区的反馈上，他们根本不在乎有没有代言人，小米就是自己给自己代言，雷总可否也听听真实的小米受众的呼声呢？&lt;/li&gt;
&lt;li&gt;最近的&lt;strong&gt;小米CC又一次开始重蹈这样的覆辙&lt;/strong&gt;，一波宣传操作猛如虎，但着实让是人看不懂，故弄玄虚在宣传中说美图品牌依然存在的，结果最后推出个小米CC，竟然还有小米CC美图版，1000多到2000多的售价，简直尴尬到爆，请问：这种机器到底卖给谁？你雷军去问一问那些网红和明星们，本来是带来面子和虚荣心的美图手机，4000-5000都想买，现在弄出所谓的“进化版”降低门槛的1000多块的美颜手机？这不搞笑吗，你看看原来美图手机的这些美女们还会继续买小米CC吗？嫌丢人都来不及。好，那既然收割不到原来那波人的韭菜了，现在这定位（&lt;strong&gt;小米CC并不是现价比手机，有较高利润&lt;/strong&gt;）是要收割谁呢？是那些一直买高性价比红米手机中的厂妹和女学生吗？如果是这样，一边在那边说友商都是混蛋的，所以我们推出了良心的Redmi Note，一边这边告诉大家小米CC9也自拍非常好快来买，&lt;strong&gt;你是不是人格分裂&lt;/strong&gt;？这不，几天小米CC还又请了个美女明星来代言，&lt;strong&gt;请问这手机的定位到底是什么？四不像&lt;/strong&gt;！惨淡的销量已经说明了一切，这整个CC系列的策划人难道不应该原地爆炸和开除吗？&lt;/li&gt;
&lt;li&gt;小米的用人也是很迷，这不是我一个人在说，&lt;strong&gt;无数的手机圈KOL都在说&lt;/strong&gt;，有那么一些小米雇佣的高管，包括&lt;strong&gt;投资领域、产品设计领域、营销公关领域&lt;/strong&gt;等等，任何心智正常的人通过看他们的日常微博都能看出来，他们&lt;strong&gt;并不是小米“初心”价值观的拥护者&lt;/strong&gt;，他们只是很&lt;strong&gt;精致主义的打工者&lt;/strong&gt;，但是他们却又按照总部的布置对外传递小米的“初心”价值观，最后的结果就是，&lt;strong&gt;非常滑稽，不伦不类&lt;/strong&gt;，甚至有时候有些人看上去非常虚伪，让人怀疑这些人的能力也无法匹配他们的薪资和岗位。&lt;/li&gt;
&lt;li&gt;当然了，印象最最深刻的还是看过的一个雷军接受的采访，他大概说了一个意思，就是说自己在金山也很努力自己和团队也很强，但是并没有做到和阿里腾讯类似的规模，原因是没有踩到风口，他觉得风口的机遇比努力更重要。看完我其实很难过，&lt;strong&gt;雷军原本在我心里的形象是知乎上碾压罗永浩这种投机骗子的真正的知识强人&lt;/strong&gt;。但这一刻的雷军，我觉得多了很多很矫情的不安，当一个技术、逻辑、良心驱动的科学商人开始羡慕别人的商业规模时，我觉得这是就&lt;strong&gt;雷军的心魔，也是小米的心魔&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想起电影《剑雨》中转轮王对连绳说，“&lt;strong&gt;你要练变戏法就变戏法，练武功就练武功，你总喜欢把他们混为一谈，能活到今天也算是件奇事啊&lt;/strong&gt;”。小米也是如此，你学OV割韭菜就好好割韭菜，你保持MIUI的初心就把初心贯彻到底，做上市就好好搞资本故事骗投资者，每个领域的规则和策略都是不一样的，千万不要混为一谈，&lt;strong&gt;眼里馋着韭菜，初心又在头上弄了道紧箍咒，这真的行不通啊！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;四集体主义下的华为的研发效率极其低下&quot;&gt;&lt;strong&gt;四、集体主义下的华为的研发效率极其低下&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://image.aliyun.cdn.chuma.cn/CMCore/WSA/Blog/Pic/A9FC8C5F542A4FB5910A6D62BDF26381.jpg&quot; alt=&quot;惊不惊喜&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然批评小米畸形的商业价值观，但无论如何，小米也和BAT一样，是一个非常正常的互联网公司。这里要补充一个实事，就是无论是BAT也好，京东、今日头条等也好，这样的公司，可能最终的产品形态和业务规模不尽相同，但他们有个共同点，就是&lt;strong&gt;通过严格的HR流程以及很高的HR标准，都筛选出了自己的有较强研发力的研发团队，并且给予这些研发团队充分的自由空间，很多时候，突出的个体价值在这种环境下因为机遇而得到爆发进而转化为贡献巨大的产品或业务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而小米最近有个天大的委屈，大概意思就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;华为1年研发1000亿投入小米才50亿不到你看这就是国产当自强和组装工厂的区别&quot;&gt;&lt;strong&gt;华为1年研发1000亿投入，小米才50亿不到，你看，这就是国产当自强和组装工厂的区别&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;说真的，这种误导的言论，除了能热血沸腾一下，真的对社会发展毫无裨益，任何做过科技企业的人都能感受和理解一个道理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;研发的产出和投入绝不是线性关系甚至大部分情况下都不是线性关系&quot;&gt;&lt;strong&gt;研发的产出和投入绝不是线性关系，甚至大部分情况下都不是线性关系&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;而更让你意想不到的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;华为的研发效率是极其低下的&quot;&gt;&lt;strong&gt;华为的研发效率，是极其低下的&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因如下：&lt;br/&gt;（这里PS：看过我文章的人都知道，我是一个极其讲逻辑和求证据的人，我既然能说出一些观点，那就绝非杜撰或者臆测，都是我轻身经历过或者根据自己的经历用科学道理谨慎揣测的，你可以看不懂不说话，也可以看不明白来和我讨论，但不要看不懂还不舒服，然后就乱喷...）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;华为的集体主义和高营收，使得员工有&lt;strong&gt;极强的收入稳定的归属感&lt;/strong&gt;，但&lt;strong&gt;却没有很高的工作突破的荣誉感&lt;/strong&gt;，这使得华为的&lt;strong&gt;头部研发&lt;/strong&gt;，特别是需要&lt;strong&gt;技术深度突破、重大创新的地方&lt;/strong&gt;，无法从内部突破，往往都采用了超级高薪挖人、外部引入的方式。而这样员工，看钱做事，看资源做事，并无任何归属感，从一些公开的新闻中也可以看到，华为从外部引入的一些高级技术人员和管理人员，流动性很大。&lt;strong&gt;这样的头部研发策略往往会带来负担很重的研发支出&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;同样是因为集体主义的管理策略，中部研发部分，包括&lt;strong&gt;各类硬件模块，各类中小软件系统或应用&lt;/strong&gt;等，在华为内部往往是采用&lt;strong&gt;堆人+任务&lt;/strong&gt;式的方式，完成研发任务，此类工作&lt;strong&gt;无特别深度的研发难度，只有工作强度和代码数量&lt;/strong&gt;。那么这样的中部研发模式带来的结果一般是什么呢？我用自己举例，我写了接近20年程序，做了快10年软件工程，我能从开发框架、开发模式开始，整套的自己造轮子，那么我可以说，当需要写一个比如企业ERP系统的时候，我大概可以1个人抵普通5-10年经验的程序员10个人，甚至速度、效率、质量比10个人还快还好。我很厉害吗？不是，&lt;strong&gt;BAT类型的企业中有无数像我这样的人&lt;/strong&gt;。BAT会允许让某个人、某些小团队去承担重要责任和突破，而华为绝不会如此，更不会让项目在一个人手上，华为喜欢用管理来约束项目，堆砌成果。所以华为的中部研发和BAT类型的企业差别就在这，这其中&lt;strong&gt;研发结果可能相同，但研发效率差别如何是高下立判&lt;/strong&gt;的。&lt;strong&gt;更糟糕的是，这样的中部研发模式，使得华为在某些非顶尖研发上，也常常投入力量后一无所获&lt;/strong&gt;，就我所认识的华为朋友里，这样的事情无数次发生，&lt;strong&gt;50个人抵不过别的公司1个人&lt;/strong&gt;真的是常态中的常态！甚至我们&lt;strong&gt;可以开玩笑的说，和BAT相比，华为的中部研发团队就是辆国企老马车&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;特别要指出的是，刚才所说的华为普通程序员的说法，也并非说华为都是庸才，华为也在校园招聘和社会招聘中吸纳了很多优秀拔尖的人才，但是这些人才，一旦进入到华为的集体主义制度中去，本身的创造力是会&lt;strong&gt;打非常大的折扣的&lt;/strong&gt;，在一个要求缺了你也能运转的环境和一个相当官僚的中部体系里，&lt;strong&gt;任何人才都可能会经历想做事、被打压、不得志、离开的过程&lt;/strong&gt;。这种华为故事，我着实也听过不少。特别有意思的是，我写完这段文字后，心有不安的又去做了一些搜索想印证我的想法， 结果搜到一个华为博士离职率20%-40%的文章，其实一切都已经不言而喻了，&lt;strong&gt;制度的力量在此刻显示出了他强有力的对市场调节的手腕&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以到这里大概可以给小米正个名了，带点严肃的调侃一下：“&lt;strong&gt;小米的50亿的研发投入，大约相当于华为500亿吧&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成也集体主义，败也集体主义&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;在宣传上华为的高研发投入是品牌旗帜但在内部这种低效的研发投入模式在长远看会变成巨大的人力资源包袱我相信这已经成为了任正非心中的巨大的担忧&quot;&gt;&lt;strong&gt;在宣传上，华为的高研发投入是品牌旗帜，但在内部，这种低效的研发投入模式在长远看会变成巨大的人力资源包袱，我相信这已经成为了任正非心中的巨大的担忧。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;刚才又去看了一下，2018华为薪酬支出1124亿，相较于华为的产品线，这真的是让人咋舌，&lt;strong&gt;有点过于高企和低效了，这是相当危险的&lt;/strong&gt;，营收只要稍微跟不上，就会带来连锁反映。希望华为未来能妥善解决好这个问题吧。&lt;/p&gt;
&lt;h3 id=&quot;五离开销售和营销华为难有建树举步维艰&quot;&gt;&lt;strong&gt;五、离开销售和营销，华为难有建树，举步维艰&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://image.aliyun.cdn.chuma.cn/CMCore/WSA/Blog/Pic/98ACA10EBA6A44EDBEA46A3230B51EA5.jpg&quot; alt=&quot;我太难了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然华为的研发效率不高，那企业达到如此之高度靠的是什么呢？我坚定的认为，靠的是&lt;strong&gt;销售能力和营销能力&lt;/strong&gt;。甚至这种能力，我觉得&lt;strong&gt;放眼全国，无可匹敌&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;可反过来看，如果你拨开云雾着眼一些华为的业务发展细节，那又一个很可怕的事实呼之欲出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;离开了销售和运营华为走的很不好所谓的研发驱动模式也完全失效了&quot;&gt;&lt;strong&gt;离开了销售和运营，华为走的很不好，所谓的研发驱动模式，也完全失效了&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近几年一直有一个看上去很有道理的被宣传出来的逻辑&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;华为十分尊重研发投入所以华为收获了今日的巨大成就&quot;&gt;华为十分尊重研发投入，所以华为收获了今日的巨大成就&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;我想说的是，NO！如果看完刚才对华为集体主义的论述后，你会发现，这样的话，并没有很严密的逻辑。&lt;/p&gt;
&lt;p&gt;华为到底是怎么壮大的，相信了解&lt;strong&gt;通信行业的&lt;/strong&gt;人，了解&lt;strong&gt;手机产业&lt;/strong&gt;的人，对华为&lt;strong&gt;交换机业务、通讯业务、消费者业务&lt;/strong&gt;的&lt;strong&gt;拓荒过程&lt;/strong&gt;是会有一些轮廓和概念的。和运营商有关的交换机通讯业务发展过程过于敏感，我就不多说了。这里说一下手机吧，中华酷联的年代，只要生产出手机，就不愁电信移动联通的运营商渠道能给卖出去，而且这种业务非常滋润，利差大，销售稳定，能赚钱，&lt;strong&gt;华为手机的原始积累正始于此&lt;/strong&gt;。类似的还有服务器业务，企业云业务等等。和&lt;strong&gt;运营商深度捆绑的华为&lt;/strong&gt;，一旦和运营商生态有关的产品制造出来时，总是不用担心卖不出去，&lt;strong&gt;销售铁军驱动下的业务发展，过程曲折，但总体还是非常顺畅的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这时候可能有人要讲话了：“&lt;strong&gt;你这不是站着说话不腰疼吗？华为要是不舍得研发投入，就算有关系有销售能力，也不会做起来的，你看联想不也是有关系吗，但是现在做的就没华为好！”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是的，你说的非常对&lt;/strong&gt;！但我也可以反过来说，联想现在活得也挺好的呀。所以我们今天不是在指责华为，我们是要&lt;strong&gt;分析背后的内因逻辑和企业发展的真实驱动力&lt;/strong&gt;，以下的逻辑思考非常重要：&lt;/p&gt;
&lt;p&gt;可能有点绕，大家慢慢的品一品：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、最近10来年华为有稳定的、高额的研发投入，是建立在什么基础上的？是建立在&lt;strong&gt;稳定的销售、稳定的高薪发放和团队稳定上&lt;/strong&gt;的。&lt;/li&gt;
&lt;li&gt;2、有钱了舍得花钱做更好的产品，和很穷憋足一股劲研发出产品卖出了钱，这两种状态是不是一回事？显然不是，&lt;strong&gt;前者锦上添花，后者雪中送炭&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;3、很穷的时候憋足劲研发出产品卖出去了，到底是因为研发出的产品的&lt;strong&gt;产品力很强&lt;/strong&gt;所以卖出去了，还是因为&lt;strong&gt;有销售路子卖出去了&lt;/strong&gt;，这两种情况是不是一回事？显然也不是，&lt;strong&gt;前者是技术公司，后者是销售公司&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;4、投入了高昂研发后，&lt;strong&gt;是否就一定能拉开了和竞争对手不可逾越的差距？也不是！&lt;/strong&gt;不说4G、5G，这不是我专长的领域，就说一下手机拍照吧，华为一直引以为豪的就是对拍照非常重视，投入了巨额资金和资源搞相机研发，包括和索尼合作做了&lt;strong&gt;大底的传感器&lt;/strong&gt;，包括挖了诺基亚团队在日本搞&lt;strong&gt;拍照算法研究&lt;/strong&gt;，成果也非常惊人，&lt;strong&gt;从P9开始的摄像水平持续提升直到全球领先坐上头把交椅&lt;/strong&gt;。但这种领先，是绝对门槛性质的吗，不是！谷歌、虹软等公司的相机算法就一直很先进，&lt;strong&gt;也有他们独到的领先优势&lt;/strong&gt;；当小米舍得花钱买算法后，&lt;strong&gt;小米8以后的拍照也上升到第一梯队&lt;/strong&gt;；三星不使用大传感器，靠一个&lt;strong&gt;祖传打磨的传感器&lt;/strong&gt;也能常年和华为争做评测排行榜第一；&lt;strong&gt;当小米意识觉醒后&lt;/strong&gt;，也和三星合作了大底传感器，相信很快也会有所作为有独到之处。&lt;/li&gt;
&lt;li&gt;5、是不是任何要突破的技术难点，&lt;strong&gt;只要投入就能有结果，就能产生突破&lt;/strong&gt;？显然必须不是！这里都不需要举华为的例子，如果是的话，那搞物理的也就不需要快200年了也说不清楚&lt;strong&gt;单电子双缝干涉&lt;/strong&gt;到底怎么解释，那搞数学的也不至于连小学生都看得懂的&lt;strong&gt;冰雹猜想&lt;/strong&gt;也解决不了了，搞医学的也不用开颅手术都做了却连最基本的&lt;strong&gt;皮肤愈合过程&lt;/strong&gt;也弄不清楚了。&lt;/li&gt;
&lt;li&gt;6、所以是不是持续的投入，就能持续的产品领先，就能创造出可持续发展的模式？完全不是！其实这个结论已经不需要再赘述了。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;但是华为长期的宣传让上面逻辑思考的23456全部都让大众产生了完全相反的理解甚至有一种华为一直研发就一直所向披靡的热血沸腾气息不停弥漫我不知道华为内部是怎么想的如果内部也是同样的理解那这种漠视客观规律的态度最终一定会反噬在自己身上&quot;&gt;&lt;strong&gt;但是华为长期的宣传让上面逻辑思考的2、3、4、5、6，全部都让大众产生了完全相反的理解，甚至有一种华为一直研发，就一直所向披靡的热血沸腾气息不停弥漫，我不知道华为内部是怎么想的，如果内部也是同样的理解，那这种漠视客观规律的态度，最终一定会反噬在自己身上。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以华为云为啥已经升级到&lt;strong&gt;一级部门和战略了&lt;/strong&gt;，依然反反复复的不成功，甚至还有转向B端服务的趋势？因为C端云服务完全和运营商沾不上强推关联的业务，也无法在一级市场硬碰硬的靠销售从C端客户这拿下单子，更有SaaS体量上去后很高技术含量的运维要求，这是一个&lt;strong&gt;对产品力有极高要求的领域&lt;/strong&gt;，这种高产品力的要求&lt;strong&gt;遇到华为的集体主义研发团队和销售驱动的运营团队时&lt;/strong&gt;，就&lt;strong&gt;歇菜了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以为啥EMUI的Rom已经在营销层面从编译器、操作系统等各个地方&lt;strong&gt;画出天大的饼&lt;/strong&gt;了，依然在开发人员眼里很难用，很难搞，却依然&lt;strong&gt;连个自己的浏览器都研发了好多年都没弄出来还得和QQ和UC合作&lt;/strong&gt;，依然在我这样的重度用户眼里和MIUI还有无比巨大的差距？因为这是&lt;strong&gt;完全脱离销售体系的纯体验性研发&lt;/strong&gt;，这是真正需要&lt;strong&gt;头部人才、突出个体&lt;/strong&gt;去突破而不是集体突破的事情，&lt;strong&gt;集体研发遇到Rom细节改造时，连细节目标都定不出来，谈何突破呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;所以为啥荣耀智慧屏电视虽然上市了还&lt;strong&gt;加持鸿蒙热血&lt;/strong&gt;，但依然销量惨淡，所以为啥荣耀手机之外，其他像素级模仿小米生态链的产品都并不坚挺？因为这些都是&lt;strong&gt;直面实打实的消费者去竞争产品力的领域&lt;/strong&gt;，并不简单，也不是单纯的“研发”可以解决问题的（什么？你的意思是华为手机、荣耀手机难道不是实打实的消费者竞争领域吗？我的回答是：&lt;strong&gt;显然不完全是，如果真的纯粹拼产品力的话，华为手机走不到今天，同时哪怕是今天，华为的真实产品力的获客能力也远小于实际销量&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;研发是客观而复杂的，你也要尊重他的规律，纵观世界商业史，从来没有一个企业说靠着研发持续投入，就能持续占有市场，就能持续推出好的产品。&lt;strong&gt;因为这其中真的没有太大的因果关系，淹没在商业失败背后的艰辛投入更是数不胜数&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;华为取得今日的成就和舍得投入研发具备研发理念有一定的密不可分的关系但这种关系在短期内可以有助于行业领先从长远看并不是甚至完全不是核心驱动力&quot;&gt;&lt;strong&gt;华为取得今日的成就和舍得投入研发、具备研发理念，有一定的密不可分的关系，但这种关系在短期内可以有助于行业领先，从长远看，并不是甚至完全不是核心驱动力。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我极其赞同任何企业都要有研发精神，都要尊重技术&lt;/strong&gt;，但我为什么还要写很大篇幅来厘清华为研发投入和今日成就之间的因果关系呢：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;不希望很多初上路的企业家和创业者因为不懂刚才23456的逻辑而走向牛角尖极端&quot;&gt;&lt;strong&gt;1、不希望很多初上路的企业家和创业者因为不懂刚才23456的逻辑而走向牛角尖极端&lt;/strong&gt;&lt;/h4&gt;
&lt;h4 id=&quot;如果华为的研发宣传只是营销策略那另当别论但如果真的是发自内心的想法那我真心的希望华为和任正非老先生不要在假象中迷失自我&quot;&gt;&lt;strong&gt;2、如果华为的研发宣传只是营销策略那另当别论，但如果真的是发自内心的想法，那我真心的希望华为和任正非老先生不要在假象中迷失自我。&lt;/strong&gt;&lt;/h4&gt;
&lt;h4 id=&quot;我确实不太喜欢华为这样说技术驱动之话却行管理营销驱动之实的做法&quot;&gt;&lt;strong&gt;3、我确实不太喜欢华为这样说技术驱动之话，却行管理营销驱动之实的做法。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;说一个有趣的事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;任正非老先生不止一次的公开场合说过未来人工智能就是统计学看完采访画面我真是哭笑不得甚至知乎还有一帮一知半解的科学家们在尴尬解释任正非的这番话那些敢直指此言论是胡说八道的真正的专家早就被湮没在了骂声中&quot;&gt;&lt;strong&gt;任正非老先生不止一次的公开场合说过，未来人工智能就是统计学，看完采访画面我真是哭笑不得，甚至知乎还有一帮一知半解的“科学家们”在尴尬解释任正非的这番话，那些敢直指此言论是胡说八道的真正的专家，早就被湮没在了骂声中。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;原本我通过看一些华为的内部文件，&lt;strong&gt;以为任正非非常清楚华为是一个管理驱动、销售驱动的企业，他也对这种完全可控的管理模式非常引以为豪&lt;/strong&gt;，但随着某些言论和画面的不断闪现，我甚至怀疑是否任老自己也&lt;strong&gt;真的相信了华为是一个研发驱动企业&lt;/strong&gt;，&lt;strong&gt;也真的相信了他们口中对研发和科技的言论得到了下面科研人员的认可和拥护&lt;/strong&gt;。。如果真的是这样的话，那真的是一言难尽了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;如果说上一章节提到的低效研发导致的人力资源的风险是可控可管的话那这种对公司本质驱动力误判的风险我认为是更大的是值得华为引起巨大重视的&quot;&gt;&lt;strong&gt;如果说上一章节提到的低效研发导致的人力资源的风险是可控可管的话，那这种对公司本质驱动力误判的风险，我认为是更大的，是值得华为引起巨大重视的&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;四华为的销售宣传公关实在无敌&quot;&gt;四、华为的销售、宣传、公关实在无敌&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://image.aliyun.cdn.chuma.cn/CMCore/WSA/Blog/Pic/DF3476F325524A358FC227C3D1B4ABC0.jpg&quot; alt=&quot;无敌是多么寂寞&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然前面诸多唇舌来论证华为并不是靠研发走到今天的，那华为到底靠的是什么呢？企业端的销售就不说了，上一章节也说了这是华为的核心优势，那么消费者领域呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;我认为华为在消费者板块有一种在价值观驱动下的文理混合双打的营销模式非常非常非常的无敌&quot;&gt;&lt;strong&gt;我认为华为在消费者板块，有一种在价值观驱动下的文理混合双打的营销模式，非常非常非常的无敌！&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种宣传模式&lt;strong&gt;以价值观为导向&lt;/strong&gt;，&lt;strong&gt;以坚定的脸皮为支撑&lt;/strong&gt;，用&lt;strong&gt;持续的半文半理的文字输出为武器&lt;/strong&gt;，&lt;strong&gt;加持法务和公关&lt;/strong&gt;，在长期的品牌宣传过程中，&lt;strong&gt;获取了对市场和舆论的绝对把控&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;这套模式我甚至觉得已经&lt;strong&gt;理论化、模式化&lt;/strong&gt;，但我觉得自己还不具备总结能力，我尽量通俗的用&lt;strong&gt;小故事&lt;/strong&gt;解释给大家听吧&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;功夫1出现问题死不承认时间流逝后那就是没有问题&quot;&gt;&lt;strong&gt;功夫1：出现问题，死不承认，时间流逝后，那就是没有问题！&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;记得华为有过著名的闪存门事件，&lt;strong&gt;P10的手机混用EMMC存储和UFS存储&lt;/strong&gt;，首先这个问题上如果不能理解这两种存储到底是多大差距的朋友，就别来喷了，和你讨论毫无意义，我们的讨论建立在能&lt;strong&gt;够理解这种混用就好比花1000块你可能会被随机分配到丽晶酒店和丽晶大宾馆&lt;/strong&gt;。发生混用事件后，华为所有渠道拒绝承认问题所在，余承东撰写长文，&lt;strong&gt;非常严肃、强硬的表示两种区别对消费者没有任何影响&lt;/strong&gt;。这其实就是华为对品牌问题解决策略的一个缩影，&lt;strong&gt;背后是有非常扎实的运营策略的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;华为对售后的处理也是如此，微博时常会有华为产品软硬件问题的负面帖子或者截图，能看到华为客服会积极留言解决问题，华为也一定会非常尊重消费者去解决问题，但体现在文字上的，永远都是您好，我们的产品没有问题。&lt;strong&gt;知道问题、积极解决问题、对外没有问题&lt;/strong&gt;。&lt;strong&gt;就是这样的策略！&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;功夫2提出一个复杂的难以量化的技术和产品模型自说自话久了就成了民间技术神话&quot;&gt;&lt;strong&gt;功夫2：提出一个复杂的难以量化的技术和产品模型，自说自话久了，就成了民间技术神话&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;首先登场的就是&lt;strong&gt;GPU Turbo&lt;/strong&gt;，先不说原理到底如何，但这个东西登场就是一系列非常扎眼的文字，&lt;strong&gt;“很吓人的技术”、“低端手机也能达到高端手机的流畅度”、“性能提高了60%，功效下降了30%”&lt;/strong&gt;，这里面的奥秘是啥，奥秘就是每一个说法都不是技术性的，都无法让技术人员准确的从架构、从代码去考究，&lt;strong&gt;但在普通人看来，这就是技术性的，就是技术巨大提升&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;然后就是18个月不卡啦，想到这个点子的人真是奇才，在宣传上，是“&lt;strong&gt;通过文件系统的优化和各种黑科技，达成了18个月都不会卡的奇迹&lt;/strong&gt;”，作为技术人员会怎么想呢，会觉得这卡不卡除了文件系统、除了系统优化，还得看用户习惯吧，还得看有没有被垃圾App骚扰吧，也得看使用时长的轻重吧，更得看使用习惯造成了多少文件系统碎片，有些用户场景，就算顶配也会卡，有些用户场景，垃圾手机也不会卡呀。&lt;strong&gt;如果一个解决方案能把这些问题都一次性给解决了，那我才能够说这手机18个月都不会卡吧&lt;/strong&gt;？不不不，就不，华为的宣传人才不管，&lt;strong&gt;我就是解决了XXX，所以我不卡，哈哈哈&lt;/strong&gt;。而这种18个不卡的说法，我相信经过了这两年的推广宣传，已经深入人心了吧。&lt;/li&gt;
&lt;li&gt;最新登场的得是方舟编译器和鸿蒙操作系统架构了吧，&lt;strong&gt;这两个新说法，真的是华为这门功夫的极高升华&lt;/strong&gt;，高到什么程度呢，高到&lt;strong&gt;文理混合的宣传和说法的神乎其技的程&lt;/strong&gt;度，让我这种真正明白编译原理、安卓体系、操作系统原理的人，已经不敢妄加评论了，是真的把我吓到了，不停地看华为的资料，再去找第三方资料，再去知乎看看是不是自己水平太差不能理解，结果发现知乎很多很厉害的大神也是&lt;strong&gt;很谨慎的发表了自己所知道的一些东西而不敢妄加揣测&lt;/strong&gt;，我心里很清楚这玩意能不能成，吹牛程度大概有多少，但是在这些公开宣传的资料面前，我是真心的觉得除非自己是Anders这种超级大神，除非后面华为被打脸了，否则我是没资格说任何公开评价的话的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你让小米的MIUI技术总监去公开打造一个18个月不卡的故事，他估计&lt;strong&gt;会羞耻到脸红，更会害怕被同行笑话&lt;/strong&gt;，你让谷歌的产品经理说自己的拍照比上一版本提升60%，&lt;strong&gt;他会觉得这种量化比较很无厘头，根本不符合技术逻辑，没有这种说法&lt;/strong&gt;。但华为这门功夫厉害之处在于&lt;strong&gt;想出这些名堂的都是没有技术思维负担的运营级人才&lt;/strong&gt;。刚好写这篇文章的时候刷微博看到一个支付宝的官方申明，支付宝辟谣了秒开技术并没有使用方舟编译器，在真正的技术人员看来，&lt;strong&gt;所谓使用方舟编译器来实现秒开技术，根本就是个无厘头莫名其妙的话&lt;/strong&gt;，支付宝官方也在知乎帖子里面公开了秒开项目背后的技术点，包括容器框架原生化、虚拟机调优、线程调度管控、扫码混合对焦、GPU运算等。&lt;strong&gt;这才是真正的技术公司在运营层面该说的话，是什么技术就是什么，说的清楚，讲的明白。而不是抛出一个技术人员谁都搞不清楚，但对普通人牛逼就完了的东西。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;华为这门功夫，真的是绝了，甚至引得业内其他公司争相模仿，作为一个技术创业者，我对此服的是五体投地！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;功夫3使用一批培养一批非常忠于价值观的宣传能人&quot;&gt;&lt;strong&gt;功夫3：使用一批、培养一批非常忠于价值观的宣传能人&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信&lt;strong&gt;HW前HR&lt;/strong&gt;的大名在数码圈无人不知无人不晓，你可以猜测他是华为支持的民间KOL，但我是真心的觉得他是对华为价值观理解的集大成者，&lt;strong&gt;在了解一些技术情况下，又不是技术出身的人，从而没有任何技术包袱，可以一嘴通天&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HW前HR有很多技能，包括&lt;strong&gt;长期自说自话、双标对待、话术强行解释、复读机别人黑点说一辈子、借助圈子掀起舆论、外行话解释内行&lt;/strong&gt;等等，这些就不一一赘述了，但他&lt;strong&gt;对于价值观的忠诚和讲这种忠诚去落地的能力的强大&lt;/strong&gt;，是很多人忽视的，甚至有人说他水平不行，我是真心笑了，这是真正的营销人才，是真正的营销能力。&lt;/li&gt;
&lt;li&gt;同样的还有华为的一个小高管，&lt;strong&gt;荣耀老熊&lt;/strong&gt;，有类似的营销策略和方法，我这里说一个非常非常经典的故事，是这一套玩法的缩影。某一天荣耀老熊发了一个照片，大概意思是发了说荣耀20Pro的夜景照片和iPhone某款的夜景照片的对比，荣耀照片很亮，他说这是5000元以下的最强拍照手机，很快这个说法就被某微博大V用很专业的方法分析驳斥，大概意思是&lt;strong&gt;荣耀20Pro的照片只是亮，但是解析度不行，过曝严重&lt;/strong&gt;，iPhone的照片只是没有默认提亮，这个分析其实非常严谨，也得到了很多不明所以的网友的认可。&lt;strong&gt;但最精彩的很快来了&lt;/strong&gt;，后来荣耀老熊又发了一个微博，放出了另一个荣耀20Pro在相同场景下的照片，全文暗示说某大V你别得意，我刚才只是钓鱼，没有拿出最好的照片，就是等着你们这些人瞎说八道，刚才的照片是普通夜景模式，现在的这个超级夜景模式的照片，你们看，远胜iPhone。实际情况是什么，实际情况是新放出的这个超级夜景的照片，依然解析力不行，依然过曝，之前那个大V对此行为已经不太想搭理了，直斥无聊。这时候，牛逼的事情出现了，荣耀老熊的这个新动作，&lt;strong&gt;被他自说自话定义为“反转”，进而一群相关人士把反转升级为“很有智慧的钓鱼打脸”&lt;/strong&gt;，再往后，一系列的营销号同步行动，新闻通稿甚至都出来了，&lt;strong&gt;铺天盖地的荣耀20Pro用实力反转打脸大V的新闻出现了&lt;/strong&gt;，试问，什么都不懂的普通消费者和不明真相的网友哪能扛得住这种宣传阵势，于是销量收割到手。&lt;strong&gt;说真心的，荣耀老熊这一波操作，价值6个月年终奖&lt;/strong&gt;。如果小米高管发生同样的时，我相信结局一定惨不忍睹...&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;功夫4法务公关铁拳出击让普通人瑟瑟发抖&quot;&gt;&lt;strong&gt;功夫4：法务公关铁拳出击，让普通人瑟瑟发抖&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信很多人都收到过华为的公关或者法务的私信或者律师函（相信我这篇发出去后，可能很快也会收到），&lt;strong&gt;虽然说靠财力和时间碾压小人物是很多公司的通常做法，无可厚非&lt;/strong&gt;。但华为在这方面的做法，是&lt;strong&gt;更加果断、更加低阈值的&lt;/strong&gt;。目的就是震慑与华为宣传导向不一致的声音或者做法。怎么说呢，&lt;strong&gt;我也没资格评价这种做法的好坏，我也切实看到了这种做法对华为的益处&lt;/strong&gt;，说一句古话吧，“&lt;strong&gt;做人留一线日后好相&lt;/strong&gt;见”&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;好啦所谓的内幕到这里就写完啦写下今日之文章绝非为了推倒品牌我也推不倒品牌华为还有至少10年的5g红利小米的现金流和主要产品业务线也健康的很都不会倒都是非常健康的具有可持续发展能力的企业写下这样的文章于公只是希望反面或者负面的讨论能够搬上台面能够畅通无阻的给大家讨论无论如何从长远看这些对企业都是有利无弊的于私希望华为能够更加尊重技术因为作为一名真正的技术人员每每看到华为对技术的定义和做法我是感觉十分受辱的同时也希望小米能够更豁达一些初心真的很好也会很持久也能支撑企业发展少一点技术面子包袱能做出更多的技术和互联网驱动的优秀产品来两家公司的产品我都会一直买下去的&quot;&gt;&lt;strong&gt;好啦，所谓的“内幕”到这里就写完啦，写下今日之文章，绝非为了推倒品牌，我也推不倒品牌，华为还有至少10年的5G红利，小米的现金流和主要产品业务线也健康的很，都不会倒，都是非常健康的具有可持续发展能力的企业，写下这样的文章，于公：只是希望反面或者负面的讨论能够搬上台面，能够畅通无阻的给大家讨论，无论如何，从长远看，这些对企业都是有利无弊的。于私：希望华为能够更加尊重技术，因为作为一名真正的技术人员，每每看到华为对技术的定义和做法，我是感觉十分受辱的。同时也希望小米能够更豁达一些，初心真的很好，也会很持久，也能支撑企业发展，少一点技术面子包袱，能做出更多的技术和互联网驱动的优秀产品来。两家公司的产品我都会一直买下去的。&lt;/strong&gt;&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://image.aliyun.cdn.chuma.cn/CMCore/WSA/Blog/Pic/4A4CE337D549434D9CB8B5D6854613A6.png&quot; alt=&quot;初码聚栈&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Aug 2019 18:27:00 +0000</pubDate>
<dc:creator>初码</dc:creator>
<og:description>华为和小米都是好公司，听一听不同的声音也是好事情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chuma/p/11406783.html</dc:identifier>
</item>
<item>
<title>Spring中的循环依赖解决详解 - 张曾经</title>
<link>http://www.cnblogs.com/zzq6032010/p/11406405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzq6032010/p/11406405.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        说起Spring中循环依赖的解决办法，相信很多园友们都或多或少的知道一些，但当真的要详细说明的时候，可能又没法一下将它讲清楚。本文就试着尽自己所能，对此做出一个较详细的解读。另，需注意一点，下文中会出现类的实例化跟类的初始化两个短语，为怕园友迷惑，事先声明一下，本文的实例化是指刚执行完构造器将一个对象new出来，但还未填充属性值的状态，而初始化是指完成了属性的依赖注入。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、先说说Spring解决的循环依赖是什么&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        Java中的循环依赖分两种，一种是构造器的循环依赖，另一种是属性的循环依赖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        构造器的循环依赖就是在构造器中有属性循环依赖&lt;/strong&gt;，如下所示的两个类就属于构造器循环依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Teacher teacher;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student (Teacher teacher) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;Student init1:&quot; +&lt;span&gt; teacher);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; learn () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;Student learn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Student student;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Teacher (Student student) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;Teacher init1:&quot; +&lt;span&gt; student);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; teach () {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;teach:&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        student.learn();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        这种循环依赖没有什么解决办法，因为JVM虚拟机在对类进行实例化的时候，需先实例化构造器的参数，而由于循环引用这个参数无法提前实例化，故只能抛出错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        Spring解决的循环依赖就是指属性的循环依赖&lt;/strong&gt;，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Student student;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Teacher () {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;Teacher init1:&quot; +&lt;span&gt; student);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; teach () {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;teach:&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        student.learn();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Teacher teacher;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student () {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;Student init:&quot; +&lt;span&gt; teacher);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; learn () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;Student learn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试扫描类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @ComponentScan(value = &quot;myPackage&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ScanConfig {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试启动类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         AnnotationConfigApplicationContext applicationContext = &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(ScanConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         applicationContext.getBean(Teacher.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).teach();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类执行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Student init:&lt;span&gt;null&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; Teacher init:&lt;span&gt;null&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;teach:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; Student learn
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        可以看到，在构造器执行的时候未完成属性的注入，而在调用方法的时候已经完成了注入。下面就一起看看Spring内部是在何时完成的属性注入，又是如何解决的循环依赖。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、循环依赖与&lt;strong&gt;属性注入&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、对于非懒加载的类，是在refresh方法中的 &lt;span&gt;finishBeanFactoryInitialization&lt;/span&gt;(beanFactory) 方法完成的包扫描以及bean的初始化&lt;/strong&gt;，下面就一起追踪下去。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他代码
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instantiate all remaining (non-lazy-init) singletons.&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        beanFactory.preInstantiateSingletons();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到调用了beanFactory的一个方法，此处的beanFactory就是指我们最常见的那个DefaultListableBeanFactory，下面看它里面的这个方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、DefaultListableBeanFactory的preInstantiateSingletons方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; preInstantiateSingletons() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         
&lt;span&gt; 3&lt;/span&gt;         List&amp;lt;String&amp;gt; beanNames = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionNames);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Trigger initialization of all non-lazy singleton beans...&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String beanName : beanNames) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             RootBeanDefinition bd =&lt;span&gt; getMergedLocalBeanDefinition(beanName);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !&lt;span&gt;bd.isLazyInit()) { // 判断为非抽象类、是单例、非懒加载 才给初始化
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isFactoryBean(beanName)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无关代码（针对FactoryBean的处理）&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重要！！！普通bean就是在这里初始化的&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    getBean(beanName);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他无关代码&lt;/span&gt;  
&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，就是在此方法中循环Spring容器中所有的bean，依次对其进行初始化，初始化的入口就是getBean方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、AbstractBeanFactory的getBean跟doGetBean方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;追踪getBean方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Object getBean(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; doGetBean(name, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见引用了重载的doGetBean方法，继续追踪之：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; T doGetBean(&lt;span&gt;final&lt;/span&gt; String name, @Nullable &lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt;&lt;span&gt; requiredType,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             @Nullable &lt;span&gt;final&lt;/span&gt; Object[] args, &lt;span&gt;boolean&lt;/span&gt; typeCheckOnly) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; String beanName =&lt;span&gt; transformedBeanName(name);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        Object bean;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                
&lt;span&gt; 7&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法1）从三个map中获取单例类&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         Object sharedInstance =&lt;span&gt; getSingleton(beanName);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略无关代码&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是多例的循环引用，则直接报错&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isPrototypeCurrentlyInCreation(beanName)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCurrentlyInCreationException(beanName);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略若干无关代码&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create bean instance.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mbd.isSingleton()) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法2) 获取单例对象&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                     sharedInstance = getSingleton(beanName, () -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;try&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法3) 创建ObjectFactory中getObject方法的返回值&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; createBean(beanName, mbd, args);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeansException ex) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Explicitly remove instance from singleton cache: It might have been put there
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eagerly by the creation process, to allow for circular reference resolution.
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Also remove any beans that received a temporary reference to the bean.&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                            destroySingleton(beanName);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     bean =&lt;span&gt; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;          &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略若干无关代码&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) bean;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法比较长，对于解决循环引用来说，上面标出来的3个方法起到了至关重要的作用，下面我们挨个攻克。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1） getSingleton(beanName)方法&lt;/strong&gt;： &lt;span&gt;&lt;strong&gt;注意该方法跟方法2）是重载方法，名字一样内部逻辑却大相径庭。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; Object getSingleton(String beanName, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; allowEarlyReference) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Object singletonObject = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects.get(beanName);// 步骤A
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; isSingletonCurrentlyInCreation(beanName)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 singletonObject = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlySingletonObjects.get(beanName);// 步骤B
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; allowEarlyReference) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     ObjectFactory&amp;lt;?&amp;gt; singletonFactory = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonFactories.get(beanName);// 步骤C
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (singletonFactory != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                         singletonObject =&lt;span&gt; singletonFactory.getObject();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlySingletonObjects.put(beanName, singletonObject);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonFactories.remove(beanName);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; singletonObject;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        通过上面的步骤可以看出这三个map的优先级。其中singletonObjects里面存放的是初始化之后的单例对象；earlySingletonObjects中存放的是一个已完成实例化未完成初始化的早期单例对象；而singletonFactories中存放的是ObjectFactory对象，此对象的getObject方法返回值即刚完成实例化还未开始初始化的单例对象。&lt;strong&gt;&lt;span&gt;所以先后顺序是，单例对象先存在于singletonFactories中，后存在于earlySingletonObjects中，最后初始化完成后放入singletonObjects中&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;        当debug到此处时，以上述Teacher和Student两个循环引用的类为例，如果第一个走到这一步的是Teacher，则从此处这三个map中get到的值都是空，因为还未添加进去。这个方法主要是给循环依赖中后来过来的对象用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2）getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory)方法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt;&lt;span&gt; singletonFactory) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Assert.notNull(beanName, &quot;Bean name must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             Object singletonObject = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects.get(beanName);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略无关代码&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                beforeSingletonCreation(beanName); // 步骤A
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;boolean&lt;/span&gt; newSingleton = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略无关代码&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     singletonObject =&lt;span&gt; singletonFactory.getObject();// 步骤B
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     newSingleton = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略无关代码&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (recordSuppressedExceptions) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.suppressedExceptions = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    afterSingletonCreation(beanName);// 步骤C
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (newSingleton) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    addSingleton(beanName, singletonObject);// 步骤D
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; singletonObject;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;获取单例对象的主要逻辑就是此方法实现的&lt;/strong&gt;&lt;/span&gt;，主要分为上面四个步骤，继续挨个看：&lt;/p&gt;
&lt;p&gt;步骤A：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeSingletonCreation(String beanName) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断，并首次将beanName即teacher放入singletonsCurrentlyInCreation中&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.inCreationCheckExclusions.contains(beanName) &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonsCurrentlyInCreation.add(beanName)) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCurrentlyInCreationException(beanName);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤C：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterSingletonCreation(String beanName) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到单例对象后，再讲beanName从singletonsCurrentlyInCreation中移除&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.inCreationCheckExclusions.contains(beanName) &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonsCurrentlyInCreation.remove(beanName)) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Singleton '&quot; + beanName + &quot;' isn't currently in creation&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤D：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addSingleton(String beanName, Object singletonObject) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects.put(beanName, singletonObject);//添加单例对象到map中
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonFactories.remove(beanName);//从早期暴露的工厂中移除，此map在解决循环依赖中发挥了关键的作用
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlySingletonObjects.remove(beanName);//从早期暴露的对象map中移除
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registeredSingletons.add(beanName);//添加到已注册的单例名字集合中
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤B：&lt;/p&gt;
&lt;p&gt;        此处调用了ObjectFactory的getObject方法，此方法是在哪里实现的呢？返回的又是什么？且往回翻，找到3中的方法3，对java8函数式编程有过了解的园友应该能看出来，方法3 【createBean(beanName, mbd, args)】的返回值就是getObject方法的返回值，即方法3返回的就是我们需要的单例对象，下面且追踪方法3而去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3）AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[]) 方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanCreationException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略无关代码&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Object beanInstance =&lt;span&gt; doCreateBean(beanName, mbdToUse, args);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanInstance;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略无关代码&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;去掉无关代码之后，关键方法只有doCreateBean方法，追踪之：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; Object doCreateBean(&lt;span&gt;final&lt;/span&gt; String beanName, &lt;span&gt;final&lt;/span&gt; RootBeanDefinition mbd, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; @Nullable Object[] args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanCreationException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         BeanWrapper instanceWrapper = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略代码&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (instanceWrapper == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化bean&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             instanceWrapper =&lt;span&gt; createBeanInstance(beanName, mbd, args);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.allowCircularReferences &amp;amp;&amp;amp;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                isSingletonCurrentlyInCreation(beanName));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (earlySingletonExposure) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重点！！！将实例化的对象添加到singletonFactories中 &lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             addSingletonFactory(beanName, () -&amp;gt;&lt;span&gt; getEarlyBeanReference(beanName, mbd, bean));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化bean&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         Object exposedObject =&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            populateBean(beanName, mbd, instanceWrapper);//也很重要
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             exposedObject =&lt;span&gt; initializeBean(beanName, exposedObject, mbd);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略无关代码&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; exposedObject;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        上面注释中标出的重点是此方法的关键。在addSingletonFactory方法中，将第二个参数ObjectFactory存入了singletonFactories供其他对象依赖时调用。然后下面的&lt;strong&gt;&lt;span&gt;populateBean方法对刚实例化的bean进行属性注入（该方法关联较多，本文暂时不展开追踪了，有兴趣的园友自行查看即可）&lt;/span&gt;&lt;/strong&gt;，如果遇到Spring中的对象属性，则再通过getBean方法获取该对象。至此，循环依赖在Spring中的处理过程已经追溯完毕，下面我们总结一下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        属性注入主要是在populateBean方法中进行的。对于循环依赖，以我们上文中的Teacher中注入了Student、Student中注入了Teacher为例来说明，假定Spring的加载顺序为先加载Teacher，再加载Student。&lt;/p&gt;
&lt;p&gt;getBean方法触发Teacher的初始化后：&lt;/p&gt;
&lt;p&gt;    a. 首先走到3中的方法1），此时map中都为空，获取不到实例；&lt;/p&gt;
&lt;p&gt;    b. 然后走到方法2）中，步骤A、步骤C、步骤D为控制map中数据的方法，实现简单，可暂不关注。其中步骤B的getObject方法触发对方法3)的调用；&lt;/p&gt;
&lt;p&gt;    c. 在方法3）中，先通过createBeanInstance实例化Teacher对象，又将该实例化的对象通过addSingletonFactory方法放入singletonFactories中，完成Teacher对象早期的暴露；&lt;/p&gt;
&lt;p&gt;    d. 然后在方法3）中通过populateBean方法对Teacher对象进行属性的注入，发现它有一个Student属性，则触发getBean方法对Student进行初始化&lt;/p&gt;
&lt;p&gt;    e. 重复a、b、c步骤，只是此时要初始化的是Student对象&lt;/p&gt;
&lt;p&gt;    f. 走到d的时候，调用populateBean对Student对象进行属性注入，发现它有一个Teacher属性，则触发getBean方法对Teacher进行初始化；&lt;/p&gt;
&lt;p&gt;    g. 对Teacher进行初始化，又来到a，但此时map已经不为空了，因为之前在c步骤中已经将Teacher实例放入了singletonFactories中，a中得到Teacher实例后返回；&lt;/p&gt;
&lt;p&gt;    h.完成f中对Student的初始化，继而依次往上回溯完成Teacher的初始化；&lt;/p&gt;
&lt;p&gt;完成Teacher的初始化后，Student的初始化就简单了，因为map中已经存了这个单例。&lt;/p&gt;
&lt;p&gt;至此，Spring循环依赖的总结分析结束，一句话来概括一下：&lt;span&gt;&lt;strong&gt;Spring通过将实例化后的对象提前暴露给Spring容器中的singletonFactories，解决了循环依赖的问题&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

</description>
<pubDate>Sat, 24 Aug 2019 18:02:00 +0000</pubDate>
<dc:creator>张曾经</dc:creator>
<og:description>前言 说起Spring中循环依赖的解决办法，相信很多园友们都或多或少的知道一些，但当真的要详细说明的时候，可能又没法一下将它讲清楚。本文就试着尽自己所能，对此做出一个较详细的解读。另，需注意一点，下文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzq6032010/p/11406405.html</dc:identifier>
</item>
<item>
<title>.net必问的面试题系列之基本概念和语法 - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/11406751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/11406751.html</guid>
<description>&lt;p&gt;上个月离职了，这几天整理了一些常见的面试题，整理成一个系列给大家分享一下，机会是给有准备的人，面试造火箭，工作拧螺丝，不慌，共勉。&lt;br/&gt;1.net必问的面试题系列之基本概念和语法&lt;br/&gt;2.net必问的面试题系列之面向对象&lt;br/&gt;3.net必问的面试题系列之设计模式&lt;br/&gt;4.net必问的面试题系列之集合、异常、泛型&lt;br/&gt;5.net必问的面试题系列之简单算法&lt;br/&gt;6.net必问的面试题系列之数据库&lt;br/&gt;7.net必问的面试题系列之web前端&lt;/p&gt;
&lt;h5 id=&quot;字符串中string-strnull和string-str的区别&quot;&gt;1. 字符串中string str=null和string str=&quot;&quot;的区别&lt;/h5&gt;
&lt;p&gt;string str=&quot;&quot; ,初始化对象，并分配一个空字符串的内存空间&lt;br/&gt;string str=null,初始化对象，不会分配内存空间&lt;/p&gt;
&lt;h5 id=&quot;byte-b-a-byte-c-1-byte-d-ab-byte-e-啊-byte-g-256-这些变量有些错误是错再哪里&quot;&gt;2. byte b = 'a'; byte c = 1; byte d = 'ab'; byte e = '啊'; byte g = 256; 这些变量有些错误是错再哪里?&lt;/h5&gt;
&lt;p&gt;a 本题考查的是数据类型能承载数据的大小。&lt;br/&gt;b 1byte =8bit，1个汉字=2个byte，1个英文=1个byte=8bit&lt;br/&gt;c 所以bc是对的，deg是错的。'a'是char类型，a错误&lt;br/&gt;d java byte取值范围是-128~127, 而C#里一个byte是0~255&lt;/p&gt;
&lt;h5 id=&quot;string和stringbuilder的区别两者性能的比较&quot;&gt;3.string和StringBuilder的区别,两者性能的比较&lt;/h5&gt;
&lt;p&gt;a 都是引用类型，分配再堆上&lt;br/&gt;b StringBuilder默认容量是16，可以允许扩充它所封装的字符串中字符的数量.每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。&lt;br/&gt;c 对于简单的字符串连接操作，在性能上stringbuilder不一定总是优于string。因为stringbulider对象的创建也消耗大量的性能，在字符串连接比较少的情况下，过度滥用stringbuilder会导致性能的浪费而非节约，只有大量无法预知次数的字符串操作才考虑stringbuilder的使用。从最后分析可以看出如果是相对较少的字符串拼接根本看不出太大差别。&lt;br/&gt;d Stringbulider的使用，最好制定合适的容量值，否则优于默认值容量不足而频繁的进行内存分配操作，是不妥的实现方法。&lt;br/&gt;参考链接：&lt;a href=&quot;https://www.cnblogs.com/haofuqi/p/4826262.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/haofuqi/p/4826262.html&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;什么是扩展方法&quot;&gt;4.什么是扩展方法？&lt;/h5&gt;
&lt;p&gt;a 一句话解释，扩展方法使你能够向现有类型“添加”方法，无需修改类型&lt;br/&gt;b 条件：按扩展方法必须满足的条件，1.必须要静态类中的静态方法2.第一个参数的类型是要扩展的类型，并且需要添加this关键字以标识其为扩展方法&lt;br/&gt;c建议：通常，只在不得已的情况下才实现扩展方法，并谨慎的实现&lt;br/&gt;d使用：不能通过类名调用，直接使用类型来调用&lt;/p&gt;
&lt;h5 id=&quot;byte-a-255a5a的值是多少&quot;&gt;5.byte a =255;a+=5;a的值是多少？&lt;/h5&gt;
&lt;p&gt;byte的取值范围是-2的8次方至2的8次方-1，-256至258，a+=1时，a的值时0，a+=5时，a的值是0，所以a+=5时，值是4&lt;/p&gt;
&lt;h5 id=&quot;什么是装箱和拆箱&quot;&gt;6.什么是装箱和拆箱？&lt;/h5&gt;
&lt;p&gt;装箱就是隐式地将一个值类型转换成引用类型，如：&lt;br/&gt;int i=0;&lt;br/&gt;Syste.Object obj=i;&lt;br/&gt;拆箱就是将引用类型转换成值类型，如：&lt;br/&gt;int i=0;&lt;br/&gt;System.Object obj=i;&lt;br/&gt;int j=(int)obj;（将obj拆箱）&lt;/p&gt;
&lt;h5 id=&quot;值类型和引用类型的区别&quot;&gt;7.值类型和引用类型的区别&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;值类型变量是直接包含值。将一个值类型变量赋给另一个值类型变量，是复制包含的值，默认值是0。引用类型变量的赋值只复制对对象的引用，而不复制对象本身，默认值是null&lt;/li&gt;
&lt;li&gt;值类型有整形、浮点型、bool、枚举。引用类型有class、delegate、Object、string&lt;/li&gt;
&lt;li&gt;值类型存储在栈中，引用了类型存储在堆中&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;new关键字的作用&quot;&gt;8.new关键字的作用&lt;/h5&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;运算符：创建对象实例&lt;/li&gt;
&lt;li&gt;修饰符：在派生类定义一个重名的方法，隐藏掉基类方法&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;约束：泛型约束定义，约束可使用的泛型类型&lt;/p&gt;
&lt;p&gt;public class ItemFactory where T : IComparable, new()&lt;br/&gt;{&lt;br/&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;int和int有什么区别&quot;&gt;9. int?和int有什么区别&lt;/h5&gt;
&lt;p&gt;int？为可空类型，默认值可以是null，int默认值是0，int?是通过int装箱为引用类型实现&lt;/p&gt;
&lt;h5 id=&quot;c中的委托是什么&quot;&gt;10. C#中的委托是什么？&lt;/h5&gt;
&lt;p&gt;一句话解释就是：将方法当作参数传入另一个方法的参数。&lt;br/&gt;.net中有很多常见的委托如：Func 、Action&lt;br/&gt;作用：提高方法的扩展性&lt;/p&gt;
&lt;h5 id=&quot;用最有效的方法算出2乘以8等于几&quot;&gt;11.用最有效的方法算出2乘以8等于几？&lt;/h5&gt;
&lt;p&gt;位运算是最快，使用的是位运算 逻辑左位移&amp;lt;&amp;lt;。&lt;br/&gt;方法是2&amp;lt;&amp;lt;3相当于0000 0000 0000 0010 （2的16位int二进制）左移三位就是 0000 0000 0001 0000（16的二进制）&lt;br/&gt;相关参考链接：&lt;a href=&quot;https://www.cnblogs.com/zhangmumu/p/10781201.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zhangmumu/p/10781201.html&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;const和readonly有什么区别&quot;&gt;12.const和readonly有什么区别？&lt;/h5&gt;
&lt;p&gt;都可以标识一个常量。主要有以下区别：&lt;/p&gt;
&lt;p&gt;1、初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以在静态构造方法（必须是静态构造方法，普通构造方法不行）里赋值。&lt;br/&gt;2、修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段&lt;br/&gt;3、const是编译时常量，在编译时确定该值；readonly是运行时常量，在运行时确定该值。&lt;br/&gt;4、const默认是静态的；而readonly如果设置成静态需要显示声明&lt;br/&gt;5、修饰引用类型时不同，const只能修饰string或值为null的其他引用类型；readonly可以是任何类型。&lt;/p&gt;
&lt;h5 id=&quot;现有一个整数number请写一个方法判断这个整数是否是2的n次方&quot;&gt;13.现有一个整数number，请写一个方法判断这个整数是否是2的N次方&lt;/h5&gt;
&lt;p&gt;4（100）、5（101）、8（1000）、16（10000）&lt;br/&gt;取模运算：&lt;br/&gt;用number%2==0可以判断，但是这个有点低级&lt;br/&gt;位运算：（使用位运算逻辑并，两个位上的都为1才是1，其余都是0，判断是否等于0）&lt;br/&gt;4&amp;amp;3相当于100&amp;amp;011 ，结果是000等于0，所以4是2的n次方&lt;br/&gt;5&amp;amp;4相当于101&amp;amp;100，结果是100不等于0，所以5不是2的n次方&lt;br/&gt;如果要问如果是2的N次方，这个N是多少？这该怎么算？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private static byte get(int n)
{
    byte number = 1;
    while (n/2!=1)
    {
        n = n / 2;
        number += 1;
    }
    return number;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;ctsclsclr分别作何解释&quot;&gt;14.CTS、CLS、CLR分别作何解释&lt;/h5&gt;
&lt;p&gt;CTS：通用语言系统。CLS：通用语言规范。CLR：公共语言运行库。&lt;/p&gt;
&lt;p&gt;CTS：Common Type System 通用类型系统。Int32、Int16→int、String→string、Boolean→bool。每种语言都定义了自己的类型，.Net通过CTS提供了公共的类型，然后翻译生成对应的.Net类型。&lt;/p&gt;
&lt;p&gt;CLS：Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.Net通过CLS提供了公共的语法，然后不同语言翻译生成对应的.Net语法。&lt;/p&gt;
&lt;p&gt;CLR：Common Language Runtime 公共语言运行时，就是GC、JIT等这些。有不同的CLR，比如服务器CLR、Linux CLR（Mono）、Silverlight CLR(CoreCLR)。相当于一个发动机，负责执行IL。&lt;/p&gt;
&lt;h5 id=&quot;在.net中配件的意思是&quot;&gt;15.在.net中，配件的意思是？&lt;/h5&gt;
&lt;p&gt;程序集。（中间语言，源数据，资源，装配清单）&lt;/p&gt;
&lt;h5 id=&quot;分析下面代码ab的值是多少&quot;&gt;16.分析下面代码，a、b的值是多少？&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;        string strTmp = &quot;a1某某某&quot;;
         int a = System.Text.Encoding.Default.GetBytes(strTmp).Length;
         int b = strTmp.Length;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析：一个字母、数字占一个byte，一个中文占占两个byte，所以a=8,b=5&lt;/p&gt;
&lt;h5 id=&quot;strings-new-stringxyz创建了几个string-object&quot;&gt;17.Strings = new String(“xyz”);创建了几个String Object?&lt;/h5&gt;
&lt;p&gt;两个对象，一个是“xyz”,一个是指向“xyz”的引用对象s。&lt;/p&gt;
&lt;h6 id=&quot;能用foreach遍历访问的对象需要实现-______接口或声明______方法的类型&quot;&gt;18.能用foreach遍历访问的对象需要实现 ______接口或声明______方法的类型。&lt;/h6&gt;
&lt;p&gt;IEnumerable 、 GetEnumerator&lt;/p&gt;
&lt;h6 id=&quot;静态成员和非静态成员的区别&quot;&gt;19.静态成员和非静态成员的区别&lt;/h6&gt;
&lt;p&gt;1.静态成员用statis修饰符声明，在类被实例化时创建，通过类进行访问&lt;br/&gt;2.不带statis的变量时非静态变量，在对象被实例化时创建，通过对象进行访问，&lt;br/&gt;3.静态方法里不能使用非静态成员，非静态方法可以使用静态成员&lt;br/&gt;4.静态成员属于类，而不属于对象&lt;/p&gt;
&lt;h6 id=&quot;c可否对内存直接操作&quot;&gt;20.c#可否对内存直接操作&lt;/h6&gt;
&lt;p&gt;C#在unsafe 模式下可以使用指针对内存进行操作, 但在托管模式下不可以使用指针，C#NET默认不运行带指针的，需要设置下，选择项目右键-&amp;gt;属性-&amp;gt;选择生成-&amp;gt;“允许不安全代码”打勾-&amp;gt;保存&lt;/p&gt;
&lt;h5 id=&quot;short-s1-1-s1-s1-1有什么错-short-s1-1-s1-1有什么错&quot;&gt;21.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?&lt;/h5&gt;
&lt;p&gt;s1+1不能显式转换成short类型，可以修改为s1 =(short)(s1 + 1) 。short s1 = 1; s1 += 1正确&lt;/p&gt;
&lt;h5 id=&quot;什么是强类型什么是弱类型哪种更好些为什么&quot;&gt;22.什么是强类型，什么是弱类型？哪种更好些？为什么?&lt;/h5&gt;
&lt;p&gt;强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译型编程语言，如c++,java,c#,pascal等,弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活，多用于解释型编程语言，如javascript,vb,php等&lt;/p&gt;
&lt;h5 id=&quot;using关键字的作用&quot;&gt;23.using关键字的作用&lt;/h5&gt;
&lt;p&gt;1.引用命名空间&lt;br/&gt;2.释放资源，实现了IDisposiable的类在using中创建，using结束后会自定调用该对象的Dispose方法，释放资源。&lt;/p&gt;
&lt;h5 id=&quot;ref和out有什么区别&quot;&gt;24.ref和out有什么区别&lt;/h5&gt;
&lt;p&gt;1.都是按引用类型进行传递&lt;br/&gt;2.属性不是变量不能作为out、ref参数传递&lt;br/&gt;3.ref参数必须初始化。out不需要初始化&lt;br/&gt;4.作用，当方法有多个返回值时，out非常有用&lt;/p&gt;
&lt;h5 id=&quot;a.equalsb和ab一样吗&quot;&gt;25.a.Equals(b)和a==b一样吗？&lt;/h5&gt;
&lt;p&gt;不一样，a==b仅仅表示a和b值相等，a.Equals(b)表示a与b一致&lt;/p&gt;
&lt;h6 id=&quot;下面这段代码求值&quot;&gt;26.下面这段代码求值&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;class Class1
{
    internal static int count = 0;
    static Class1()
    {
        count++;
    }
    public Class1()
    {
        count++;
    }
}
Class1 o1 = new Class1();
Class1 o2 = new Class1();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;o1.count的值是多少？&lt;br/&gt;答案：3，静态 构造方法计算一次，两个实例化对象计算两次。&lt;/p&gt;
&lt;h5 id=&quot;关于构造函数说法正确的是哪个&quot;&gt;27.关于构造函数说法正确的是哪个？&lt;/h5&gt;
&lt;p&gt;a)构造函数可以声明返回类型。&lt;/p&gt;
&lt;p&gt;b)构造函数不可以用private修饰&lt;/p&gt;
&lt;p&gt;c)构造函数必须与类名相同&lt;/p&gt;
&lt;p&gt;d)构造函数不能带参数&lt;br/&gt;答案：c ，构造函数必须与类名相同，可以传递多个传递，作用就是便于初始化对象成员，不能有任何返回类型&lt;/p&gt;
&lt;h5 id=&quot;math.round11.5等於多少-math.round-11.5等於多少&quot;&gt;28.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?&lt;/h5&gt;
&lt;p&gt;c#里面都是12&lt;/p&gt;
&lt;h6 id=&quot;和的区别&quot;&gt;29.&amp;amp;和&amp;amp;&amp;amp;的区别&lt;/h6&gt;
&lt;p&gt;&amp;amp;是位运算逻辑与运算符，如true&amp;amp;true 结果是true,0&amp;amp;0结果是0，2&amp;amp;3的结果是（10&amp;amp;11=10）2&lt;br/&gt;&amp;amp;&amp;amp;是与运算符，两个都为true才是true&lt;br/&gt;参考链接https://www.cnblogs.com/zhangmumu/p/10781201.html&lt;/p&gt;
&lt;h5 id=&quot;i和i有什么区别&quot;&gt;30. i++和++i有什么区别？&lt;/h5&gt;
&lt;p&gt;1.i++是先赋值，然后再自增；++i是先自增，后赋值。&lt;br/&gt;2.i=0，i++=0，++i=1； Console.WriteLine(++i==i++); 结果位true&lt;/p&gt;
&lt;h5 id=&quot;float-f-3.4-是否正确&quot;&gt;31.float f = 3.4; 是否正确？&lt;/h5&gt;
&lt;p&gt;不正确，。3.4是double类型双精度的，double向下转型float会造成精度缺失（类似于long转int），因此需要强制转换，float f =3.4F 或者float f =(float)3.4&lt;/p&gt;
&lt;h5 id=&quot;什么是自动转换什么是强制转换什么时候需要自动转换什么时候需要强制转换&quot;&gt;32.什么是自动转换，什么是强制转换，什么时候需要自动转换，什么时候需要强制转换&lt;/h5&gt;
&lt;p&gt;1.自动类型转换:编译器自动完成类型转换，不需要在程序中编写代码。&lt;br/&gt;2.强制类型转换:强制编译器进行类型转换，必须在程序中编写代码&lt;br/&gt;3.转换规则：从存储范围小的类型到存储范围大的类型，是自动转换，如byte=&amp;gt;short=&amp;gt;int=&amp;gt;long&lt;/p&gt;
</description>
<pubDate>Sat, 24 Aug 2019 17:30:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<og:description>上个月离职了，这几天整理了一些常见的面试题，整理成一个系列给大家分享一下，机会是给有准备的人，面试造火箭，工作拧螺丝，不慌，共勉。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangmumu/p/11406751.html</dc:identifier>
</item>
<item>
<title>Mybatis多表查询之一对一查询的多种实现-XML配置 - 全me村的希望</title>
<link>http://www.cnblogs.com/hopeofthevillage/p/11406649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hopeofthevillage/p/11406649.html</guid>
<description>&lt;p&gt;        Mybatis 中对于多表查询提供了非常强大的实现方式，主要是通过resultMap的结果映射对于多表查询后的返回值进行封装，让我们来看一下官网上对于resultMap的解释：&lt;tt&gt;resultMap&lt;/tt&gt; 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC &lt;tt&gt;ResultSets&lt;/tt&gt; 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 &lt;tt&gt;resultMap&lt;/tt&gt; 能够代替实现同等功能的长达数千行的代码。ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。通过描述对象之间的关系将查询后的结果映射到我们定义的实体类中。&lt;/p&gt;
&lt;p&gt;　　首先介绍一下本例中的实体类以及其映射关系，Demo中存在User类以及Account类，其关系为一个用户对应零个、一个或者多个账户，账户中为了简单单单保存用户的账户余额以及所属用户的ID。我们实现的查询的目标为：每次查询一个账户的时候同时将其所属的用户信息也展示出来。为了更好的帮助理解，我们将展示一种非mybatis方式以及两种mybatis方式的实现来实现。User类以及Accoun类t的内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e6b99de0-fc26-4f3b-9c5e-65bfc04f96e3')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_e6b99de0-fc26-4f3b-9c5e-65bfc04f96e3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e6b99de0-fc26-4f3b-9c5e-65bfc04f96e3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e6b99de0-fc26-4f3b-9c5e-65bfc04f96e3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e6b99de0-fc26-4f3b-9c5e-65bfc04f96e3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Account &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer uid;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double money;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; User user;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getUser() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUser(User user) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.user =&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getUid() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uid;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUid(Integer uid) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.uid =&lt;span&gt; uid;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Double getMoney() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; money;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMoney(Double money) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.money =&lt;span&gt; money;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Account{&quot; +
&lt;span&gt;44&lt;/span&gt;                 &quot;id=&quot; + id +
&lt;span&gt;45&lt;/span&gt;                 &quot;, uid=&quot; + uid +
&lt;span&gt;46&lt;/span&gt;                 &quot;, money=&quot; + money +
&lt;span&gt;47&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('98fbf407-4e05-4442-b13c-b14009c6eed3')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_98fbf407-4e05-4442-b13c-b14009c6eed3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_98fbf407-4e05-4442-b13c-b14009c6eed3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('98fbf407-4e05-4442-b13c-b14009c6eed3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_98fbf407-4e05-4442-b13c-b14009c6eed3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date birthday;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String address;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getBirthday() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; birthday;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBirthday(Date birthday) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.birthday =&lt;span&gt; birthday;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex() {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSex(String sex) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAddress() {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAddress(String address) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.address =&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User{&quot; +
&lt;span&gt;54&lt;/span&gt;                 &quot;id=&quot; + id +
&lt;span&gt;55&lt;/span&gt;                 &quot;, username='&quot; + username + '\'' +
&lt;span&gt;56&lt;/span&gt;                 &quot;, birthday=&quot; + birthday +
&lt;span&gt;57&lt;/span&gt;                 &quot;, sex='&quot; + sex + '\'' +
&lt;span&gt;58&lt;/span&gt;                 &quot;, address='&quot; + address + '\'' +
&lt;span&gt;59&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;数据库的建表语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     id &lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; auto_increment,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     username &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     birthday &lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;生日&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     sex &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;default&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;性别&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     address &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;256&lt;/span&gt;) &lt;span&gt;default&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (id)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; )ENGINE&lt;span&gt;=&lt;/span&gt;InnoDB &lt;span&gt;default&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;老王&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-27 17:47:08&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;石家庄&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;老李&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-27 17:47:08&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;石家庄&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;老郭&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-27 17:47:08&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;石家庄&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; account;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; account(
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; ID &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; UID &lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户编号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;MONEY&lt;/span&gt; &lt;span&gt;DOUBLE&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;金额&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (ID),
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; FK_Reference_8 (UID),
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;CONSTRAINT&lt;/span&gt; FK_Reference_8 &lt;span&gt;FOREIGN&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (UID) &lt;span&gt;REFERENCES&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt; (id)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; )ENGINE&lt;span&gt;=&lt;/span&gt;INNODB &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; accountc (ID,UID,&lt;span&gt;MONEY&lt;/span&gt;) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;46&lt;/span&gt;,&lt;span&gt;1000&lt;/span&gt;),(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;45&lt;/span&gt;,&lt;span&gt;1000&lt;/span&gt;),(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;46&lt;/span&gt;,&lt;span&gt;2000&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      搭建项目的过程就不展示了，主要的核心实体类和对应的数据库表如上，接下来我们展示我们所要展示的三种方式实现一对一的联表查询。&lt;/p&gt;
&lt;h2&gt;      1.非mybatis的高级结果映射方式实现联表查询。&lt;/h2&gt;
&lt;p&gt;　　这种方式的原理为通过创建一个新的类AccountUser类继承Account类并在AccountUser类中添加我们想要查询的User的信息，并且在账户查询的Dao.xml文件中配置相应的sql语句即可实现。假如我们查询Account的信息的时候同时想要查询用户的名称以及地址，那就在AccountUser的类中声明用户的名称以及地址。这种实现方式只是作为一种拓展的实现方式，在实际使用过程中并不推荐使用。&lt;/p&gt;
&lt;p&gt;　　（1）声明AccountUser类　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bab58e8f-0745-4f21-9b70-b7a9c80751c0')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_bab58e8f-0745-4f21-9b70-b7a9c80751c0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bab58e8f-0745-4f21-9b70-b7a9c80751c0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bab58e8f-0745-4f21-9b70-b7a9c80751c0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bab58e8f-0745-4f21-9b70-b7a9c80751c0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountUser &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Account {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String address;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAddress() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAddress(String address) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.address =&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.toString() + &quot;       &quot;+&quot;AccountUser{&quot; +
&lt;span&gt;24&lt;/span&gt;                 &quot;username='&quot; + username + '\'' +
&lt;span&gt;25&lt;/span&gt;                 &quot;, address='&quot; + address + '\'' +
&lt;span&gt;26&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是该类继承了Account类，声明了我们需要的User类中的用户名称以及地址，对AccountUser类的toString()方法进行了改造，添加了super.toString(),方便我们打印的时候可以打印出从父类中继承的属性的属性值。&lt;/p&gt;
&lt;p&gt;　　（2）在AccountDao类中声明查询账户信息的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查找所有账户同时包含用户的姓名和地址
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    List&lt;/span&gt;&amp;lt;AccountUser&amp;gt; findAllAccountUser();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）在AccountDao.xml中配置findAllAccountUser方法的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findAllAccountUser&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.example.domain.AccountUser&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT a.*,u.username,u.address FROM USER u,account a WHERE a.UID= u.id;
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（4）测试该方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; findAllAccounUsertTest(){
        List&lt;/span&gt;&amp;lt;AccountUser&amp;gt; accountList =&lt;span&gt; accountDao.findAllAccountUser();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (AccountUser account:accountList){
            System.out.println(account);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765949/201908/1765949-20190824221809653-240432704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　2.通过Mybatis中的高级结果映射的resultMap的关联属性（association）来实现多表的一对一查询。&lt;/h2&gt;
&lt;p&gt;　　关联属性主要用来处理“有一个”类型的关系，关联的关键之处是我们需要告诉 MyBatis 如何加载关联。在MyBatis 中有两种不同的方式加载关联：一是嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。二是嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。通过这两种不同的方式衍生出两种不同的方式去实现多表的一对一查询。&lt;/p&gt;
&lt;h3&gt;　　　　1.关联的嵌套SELECT查询&lt;/h3&gt;
&lt;p&gt;　　　　（1）因为我们要实现的是在查询账户的时候期望可以得到账户所属用户的某些信息，所以我们需要在Account类中声明User对象，用来将查询到的结果进行封装。如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; User user;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getUser() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUser(User user) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.user =&lt;span&gt; user;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　（2）AccountDao类中添加查询的方法的声明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查找所有账户同时包含用户的所有信息
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    List&lt;/span&gt;&amp;lt;Account&amp;gt; findAll();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　（3）在AccountDao.xml中配置findAll方法的的结果映射。首先声明结果映射关系resultMap，resultMap的id为该结果映射的唯一标识，type为结果类的完全限定名，resultMap中的属性说明：&lt;em&gt;id&lt;/em&gt; 和 &lt;em&gt;result&lt;/em&gt; 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。这两者之间的唯一不同是，&lt;em&gt;id&lt;/em&gt; 元素表示的结果将是对象的标识属性，这会在比较对象实例时用到。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。id和result中的属性说明：property&lt;/p&gt;
&lt;p&gt;映射到列结果的字段或属性，其实就是实体类中属性的名称。column是指数据库中的列名，对应实体类的属性。在下面的&amp;lt;id property=&quot;id&quot; column=&quot;aid&quot;/&amp;gt;中的column属性的值aid没有完全匹配上数据中的id，是因为在查询语句中对account中的id字段设置了别名aid。association的属性的 property为user对应实体类中声明的user对象，其类型使用javaType属性指定为User类，column为数据表的列名，并作为参数传递给此 select 语句。select属性用于加载复杂类型属性的映射语句的 ID，它会从 column 属性中指定的列检索数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;accountUserMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.example.domain.Account&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;aid&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;money&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;money&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;关联的嵌套的select查询&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;association &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; javaType&lt;/span&gt;&lt;span&gt;=&quot;com.example.domain.User&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;&lt;span&gt; select&lt;/span&gt;&lt;span&gt;=&quot;selectUser&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　（4）在AccountDao.xml中配置结果映射中的&amp;lt;association property=&quot;user&quot; javaType=&quot;com.example.domain.User&quot; column=&quot;uid&quot; select=&quot;selectUser&quot;/&amp;gt;的select=&quot;&lt;span&gt;selectUser&lt;/span&gt;&quot;的实现以及findAll方法的实现，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectUser&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT * FROM  USER WHERE ID = #{id};
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findAll&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;accountUserMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
       SELECT u.*,a.id AS aid,a.uid,a.money FROM USER u,account a WHERE a.UID= u.id;
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里我们有两个 select 查询语句：一个用来加载账户信息（Account），另外一个用来加载用户信息（User），而且accountUserMap的结果映射描述了应该使用 &lt;tt&gt;selectUser&lt;/tt&gt; 语句加载它的 user属性，其它的列名和属性名相匹配的属性将会被自动加载。&lt;/p&gt;
&lt;p&gt;　　　　（5）查询测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; findAllTest(){
        List&lt;/span&gt;&amp;lt;User&amp;gt; userList =&lt;span&gt; userDao.findAll();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (User user: userList){
            System.out.println(user);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765949/201908/1765949-20190824230121391-910981220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2.关联的嵌套结果映射实现1。&lt;/h3&gt;
&lt;p&gt;　　(1)(2)步骤是上一方法是相同的。&lt;/p&gt;
&lt;p&gt;　　(3)主要是修改了上一种方式中第三步中的resultMap中的association关联属性，将其替换为：&amp;lt;association property=&quot;user&quot; javaType=&quot;com.example.domain.User&quot; column=&quot;uid&quot; resultMap=&quot;userMap&quot;/&amp;gt;，在association 中添加了resultMap=&quot;userMap&quot;属性，userMap为结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象中，也就是将关联属性user的结果映射到映射ID为userMap的resultMap中。userMap的声明如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;resultMap id=&quot;userMap&quot; type=&quot;com.example.domain.User&quot;&amp;gt;
        &amp;lt;id property=&quot;id&quot; column=&quot;id&quot;/&amp;gt;
        &amp;lt;result property=&quot;username&quot; column=&quot;username&quot;/&amp;gt;
        &amp;lt;result property=&quot;birthday&quot; column=&quot;birthday&quot; jdbcType=&quot;DATE&quot;/&amp;gt;
        &amp;lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&amp;gt;
        &amp;lt;result property=&quot;address&quot; column=&quot;address&quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）AccountDao.xml的findAll方法的映射则只需要findAll方法，不再需要上一个方式中的selectUser映射的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findAll&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;accountUserMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
       SELECT u.*,a.id AS aid,a.uid,a.money FROM USER u,account a WHERE a.UID= u.id;
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）(6)查询代码以及测试结果不再贴出&lt;/p&gt;
&lt;h3&gt;　3.关联的嵌套结果映射实现2。&lt;/h3&gt;
&lt;p&gt;　　　第二种实现方式中使用了外部的结果映射元素来映射关联。这使得 User的结果映射可以被重用。 然而，如果我们不需要重用它（在上个例子中他是userMap），或者你更喜欢将你所有的结果映射放在一个具有描述性的结果映射元素中。 你可以直接将结果映射作为子元素嵌套在内。&lt;/p&gt;
&lt;p&gt;　　(1)(2)步骤是上一方法是相同的。&lt;/p&gt;
&lt;p&gt;　　(3)仍然是修改了上一种方式中第三步中的resultMap结果映射中的association关联属性，将其替换如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;关联的嵌套的结果映射2&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;association &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; javaType&lt;/span&gt;&lt;span&gt;=&quot;com.example.domain.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;birthday&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;birthday&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;DATE&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;association&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样实现与第二种实现大同小异，只是将关联对象的属性配置直接在association中进行了配置。&lt;/p&gt;
&lt;p&gt;（4）AccountDao.xml的findAll方法的映射的findAll方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&amp;gt;&lt;span&gt;
       SELECT u.*,a.id AS aid,a.uid,a.money FROM USER u,account a WHERE a.UID= u.id;
    &amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）(6)查询代码以及测试结果不再贴出&lt;/p&gt;
&lt;h2&gt;　　总结：通过上述例子可以初步窥探了Mybatis中多表联查(一对一)的使用方式，主要是通过resultMap的高级结果映射来实现的，在本例中最关键的属性是resultMap的关联属性association，association也是我们告诉Mybatis对象之间的关系的桥梁，同时也介绍了resultMap的属性的说明，通过解释其属性再加上Demo可以更好的理解结果映射的含义以及使用，这只是最简单的一种使用方式，以后会详细介绍一对多、多对多、多对一等复杂情况在Mybatis中的如何查询映射。&lt;/h2&gt;
&lt;p&gt;　　参考网址：mybatis中文官网  http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html&lt;/p&gt;
</description>
<pubDate>Sat, 24 Aug 2019 16:10:00 +0000</pubDate>
<dc:creator>全me村的希望</dc:creator>
<og:description>Mybatis 中对于多表查询提供了非常强大的实现方式，主要是通过resultMap的结果映射对于多表查询后的返回值进行封装，让我们来看一下官网上对于resultMap的解释：resultMap&amp;#1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hopeofthevillage/p/11406649.html</dc:identifier>
</item>
<item>
<title>go 学习笔记之是否支持以及如何实现继承 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/11406613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/11406613.html</guid>
<description>&lt;p&gt;熟悉面向对象的小伙伴们可能会知道封装,继承和多态是最主要的特性,为什么前辈们会如此看重这三种特性,真的那么重要吗?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-82498195b3e8d051.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-concept.jpeg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是封装&quot;&gt;什么是封装&lt;/h2&gt;
&lt;p&gt;什么是封装,封装有什么好处以及怎么实现封装?&lt;/p&gt;
&lt;p&gt;相信大多数小伙伴们都有自己的理解,简而言之,言而简之,封装是屏蔽内部实现细节,仅仅对外暴露出有价值接口.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-4029612c5eb73578.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-computer.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正如平时工作中使用的电脑一样,我们并不关心电脑的内部组成,只要会开机关机等基本操作就能正常使用电脑,即便坏了的话,也是送去专业维修店进行修理,作为使用者来说,我们从始至终并不关心电脑的工作原理以及它如何工作,唯一在乎的就是怎么能够上网.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-15dfe084ebd980ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-computer-online.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之所以我们能如何方便地使用电脑进行网上冲浪,完全得益于电脑设计者对普通用户屏蔽了无关细节,只暴露有价值的操作方法,这种实现方式就是封装.&lt;/p&gt;
&lt;p&gt;回到编程语言上,&lt;code&gt;Go&lt;/code&gt; 语言作为一种通用的编程语言,和其他主流的编程语言一样支持封装,&lt;code&gt;Go&lt;/code&gt; 语言关于封装的实现主要包括两部分:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据结构的封装&lt;/li&gt;
&lt;li&gt;行为方法的控制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中数据结构的封装主要是使用结构体关键字 &lt;code&gt;struct&lt;/code&gt; 实现,而行为方法的控制是用首字母大小写区分是否对外可见.&lt;/p&gt;
&lt;blockquote readability=&quot;3.8760330578512&quot;&gt;
&lt;p&gt;关于 &lt;code&gt;Go&lt;/code&gt; 如何实现封装的细节,可以参考前一篇文章: &lt;a href=&quot;https://mp.weixin.qq.com/s/fXIKWsPqi6m2IEV--8lBsg&quot;&gt;go 学习笔记之详细说一说封装是怎么回事&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;继承是怎么回事&quot;&gt;继承是怎么回事&lt;/h2&gt;
&lt;p&gt;说完封装,接着说一下继承是怎么回事?&lt;/p&gt;
&lt;p&gt;继承正是在封装的基础上逐步发展产生的概念,我们知道封装是对某一类行为事物模型的抽象,而这种抽象恰恰是由人定义实现的,因人而异也就导致了封装并没有统一的标准答案.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-32d77037ea7a8bc1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-diff-anyone.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是乎就可能存在着这么一种情况,对于生活中常见的猫和狗,两个人分别有两种封装方式:&lt;/p&gt;
&lt;p&gt;A: 猫是一种宠物,淘气可爱会卖萌,看家本领抓老鼠,偶尔还会喵喵喵.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-e488d09162b327b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-one-cat.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B: 狗是一种宠物,忠实听话能看家,嗅觉灵敏会破案,一言不合汪汪汪.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-526cb2a04ac24455.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-one-dog.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C: 我想要买一个宠物,文能卖萌,武可退敌,明个一早给我送来吧!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-19d11979e8e581d0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-one-pet.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于客户C并没有特别说明要的是猫还是狗,A以为是猫,因为猫安静的时候很萌很可爱,生气的时候用小爪爪挠你!&lt;br/&gt;B以为是狗,汪星人的名气可不是自吹自擂,真的要惹怒了它,咬住不放能生生撕下一块肉,你说这种武力值强不强大?&lt;/p&gt;
&lt;p&gt;于是第二天,客户C懵逼了,怎么一下子送来了猫狗两个宠物啊,可是又不能食言,因为A和B说的都有道理啊!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-2afd7f209eaea8da.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-no-word.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等 A和 B走了后,C望着送来的猫和狗,不禁陷入了深思:我只是想要一个宠物而已,非要给我猫和狗两个选择,我有选择困难症啊!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-32cc8eb48992f1fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-hard-choose.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说完这个故事,刚开始会觉得有些滑稽,C只要随便选择一种宠物不就好了吗,干嘛非要全盘接收弄得自己不开心呢?&lt;/p&gt;
&lt;p&gt;不知道正在看的读者有没有选择困难症的经历,面对多种选择,一时不知道到底选择哪一个,最终结果可能有三种情况:全盘肯定,全盘否定和部分肯定.&lt;/p&gt;
&lt;p&gt;上述故事中,C选择的是全盘肯定,A和B送来的猫和狗都是宠物,没理由拒绝任何一个,于是C选择全盘肯定,当然至于以后是否后悔只有 C自己心里清楚.&lt;/p&gt;
&lt;p&gt;前车之鉴可以为师矣,如果下次我们也遇到这种情况应该如何选择呢?&lt;/p&gt;
&lt;p&gt;相信聪明的你心中已经有了自己的答案,大声的说出来吧!我就要喵喵喵!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-6426050bdf8115fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-inheritance-one-cat.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述案例就好比同事间一起去吃饭,点餐时问你点些什么?你说随便!&lt;/p&gt;
&lt;p&gt;原本是好意,以为能自己这么说能方便其他人,其实这种看似不挑剔的做法,对他人来说可能也是最难办的事情.&lt;/p&gt;
&lt;p&gt;因为随便的范围太宽泛了,什么都可以也就意味着很大可能上并不会令你满意,你在方便别人的同时,他人也在想法设法取悦于你,不知道你的喜好,心里就犯嘀咕了,这个他喜不喜欢吃呢?&lt;/p&gt;
&lt;p&gt;所以,请不要再说随便,勇敢亮出你的观点态度,哪怕不被认可满足.&lt;/p&gt;
&lt;p&gt;故事中 A觉得猫是宠物,B觉得狗是宠物,因而当客户真的要宠物时,A和 B都把各自的宠物送上去了,因此问题出现在宠物的定义上,到底什么算是宠物?&lt;/p&gt;
&lt;p&gt;其实C心中已经有了宠物的定义,那就是&quot;文能卖萌,武可退敌&quot;,而猫和狗恰好都具备这种特性,因此对外宣传时就不要再说这种默认的属性,应该亮出自己的特色!&lt;/p&gt;
&lt;p&gt;A: 猫会抓老鼠&lt;br/&gt;B: 狗能认清路&lt;/p&gt;
&lt;p&gt;C: 我要一种宠物,出现意外时能帮助到我的话,那就再好不过了!&lt;/p&gt;
&lt;p&gt;如果一开始他们就这样说的话,C真正需要的宠物到底是猫还是狗就一目了然了,也不会陷入选择困难症了!&lt;/p&gt;
&lt;h2 id=&quot;如何实现继承&quot;&gt;如何实现继承&lt;/h2&gt;
&lt;p&gt;回到封装的话题上来,转换成编程语言就是A把猫封装成宠物了,B把狗封装成宠物了,而 C需要宠物时,猫和狗都是宠物,最终结果要么是程序依旧正常运行,要么是程序意外挂掉了,因为很可能某一种宠物可能并不符合特定需求.&lt;/p&gt;
&lt;p&gt;这种重复定义问题归咎于封装的标准不同,猫和狗两者的封装过程是独立进行的,并没有在一起商量着看看能不能继续抽象出通用模型,混乱的封装导致了猫是宠物,狗也是宠物.&lt;/p&gt;
&lt;p&gt;这种多种相关概念的封装很容易出现此类问题,所以适当进行统一分析继续抽象出更高层次的封装概念尤为重要,基于此,原来的封装就能从这种通用概念中解放出来,仅仅保留自己的特色就好,大大简化了模型的语义.&lt;/p&gt;
&lt;p&gt;普通封装的概念和更高层次的抽象封装概念的关系就是面向对象中的继承,即猫继承于宠物,表示猫不但拥有宠物的特点还有猫自己的亮点.&lt;/p&gt;
&lt;p&gt;对于狗也是一样,狗是宠物,狗也是狗自己本身,体现了自己的特点.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 语言和其他主流的面向对象语言有所不同,&lt;code&gt;Go&lt;/code&gt; 并不支持继承特性,因而也没有单继承,多继承,重写方法等复杂概念.&lt;/p&gt;
&lt;p&gt;那 &lt;code&gt;Go&lt;/code&gt; 是如何描述这种普通封装和抽象封装之间的关系呢?&lt;/p&gt;
&lt;p&gt;肯定不是把猫定义成宠物,狗也定义成宠物那种方式!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 实现继承的语义不是通过 &lt;code&gt;extends&lt;/code&gt; 关键字而是通过结构体组合的方式,请看相关代码.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;宠物就应该能文能武,这里不关心结构体的字段,因而并没有定义相关字段.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Pet struct {
}

func (p *Pet) Skill() {
    fmt.Println(&quot;能文能武的宠物&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;猫是能够抓老鼠的宠物,&lt;code&gt;Go&lt;/code&gt; 采用组合的方式表达继承的语义.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Cat struct {
    p *Pet
}

func (c *Cat) Catch() {
    fmt.Println(&quot;老鼠天敌喵喵喵&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;狗是自带导航功能的宠物,看我导盲犬的超能力!&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;
type Dog struct {
    p *Pet
}

func (d *Dog) Navigate() {
    fmt.Println(&quot;自带导航汪汪汪&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来,C开始检验猫和狗作为宠物是否具备能文能武的基本要求,与此同时有没有自身的特色?&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func TestExtendInstance(t *testing.T) {
    p := new(Pet)

    d := new(Dog)
    d.p = p

    // 自带导航汪汪汪
    d.Navigate()
    // 能文能武的宠物
    d.p.Skill()

    fmt.Println()

    c := new(Cat)
    c.p = p

    // 老鼠天敌喵喵喵
    c.Catch()
    // 能文能武的宠物
    c.p.Skill()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述结果证明,&lt;code&gt;Go&lt;/code&gt; 语言虽然不支持 &lt;code&gt;extends&lt;/code&gt; 关键字表达的继承特性,但是采用组合的方式也是可以实现继承语义的,毕竟,黑猫还是白猫,抓住老鼠的才是好猫!&lt;/p&gt;
&lt;p&gt;面向对象的封装和继承暂时告一段落,下一篇文章中将开始讲解接口,以及面向对象中最后的一个概念: 多态!&lt;/p&gt;
&lt;p&gt;感谢你的阅读,如果本文对你有所帮助,还望你能留言告诉我,也欢迎分享转发哟!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-87b6ebe013dd5f67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;雪之梦技术驿站.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Aug 2019 15:53:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>熟悉面向对象的小伙伴们可能会知道封装,继承和多态是最主要的特性,为什么前辈们会如此看重这三种特性,真的那么重要吗? 什么是封装 什么是封装,封装有什么好处以及怎么实现封装? 相信大多数小伙伴们都有自己</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snowdreams1006/p/11406613.html</dc:identifier>
</item>
<item>
<title>NN入门，手把手教你用Numpy手撕NN(一) - ITryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/11406576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/11406576.html</guid>
<description>&lt;p&gt;&lt;strong&gt;这是一篇包含极少数学推导的NN入门文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大概从今年4月份起就想着学一学NN，但是无奈平时时间不多，而且空闲时间都拿去做比赛或是看动漫去了，所以一拖再拖，直到这8月份才正式开始NN的学习。&lt;/p&gt;
&lt;p&gt;这篇文章主要参考了《深度学习入门：基于Python的理论与实现》一书，感觉这本书很不错，偏向实践，蛮适合入门。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话不多说，下面开始我们的NN入门(手撕NN)之旅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里只对张量进行简单介绍，关于矩阵运算之类的，就靠你们自己另外学啦。&lt;/p&gt;
&lt;h2 id=&quot;标量0d张量&quot;&gt;标量（0D张量）&lt;/h2&gt;
&lt;p&gt;仅包含一个数字的张量叫作标量（scalar，也叫标量张量、零维张量、0D 张量）。在 Numpy 中，一个 float32 或 float64 的数字就是一个标量张量（或标量数组）。你可以用 ndim 属性来查看一个 Numpy 张量的轴的个数。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import numpy as np 
&amp;gt;&amp;gt;&amp;gt; x = np.array(1) 
&amp;gt;&amp;gt;&amp;gt; x 
array(1) 
&amp;gt;&amp;gt;&amp;gt; x.ndim 
0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;向量1d张量&quot;&gt;向量（1D张量）&lt;/h2&gt;
&lt;p&gt;数字组成的数组叫作向量（vector）或一维张量（1D 张量）。一维张量只有一个轴。下面是 一个 Numpy 向量。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = np.array([1, 2, 3, 4, 5]) 
&amp;gt;&amp;gt;&amp;gt; x 
array([1, 2, 3, 4, 5]) 
&amp;gt;&amp;gt;&amp;gt; x.ndim 
1 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个向量有5 个元素，也被称为5D 向量。&lt;/p&gt;
&lt;h2 id=&quot;矩阵2d张量&quot;&gt;矩阵（2D张量）&lt;/h2&gt;
&lt;p&gt;向量组成的数组叫作矩阵（matrix）或二维张量（2D 张量）。矩阵有 2 个轴（通常叫作行和列），下面是一个 Numpy 矩阵。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = np.array([[5, 78, 2, 34, 0],                   
                  [6, 79, 3, 35, 1],                   
                  [7, 80, 4, 36, 2]]) 
&amp;gt;&amp;gt;&amp;gt; x.ndim 
2 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个轴上的元素叫作行（row），第二个轴上的元素叫作列（column）。在上面的例子中， [5, 78, 2, 34, 0] 是 x 的第一行，[5, 6, 7] 是第一列。&lt;/p&gt;
&lt;h2 id=&quot;d张量与更高维张量&quot;&gt;3D张量与更高维张量&lt;/h2&gt;
&lt;p&gt;将多个矩阵组合成一个新的数组，可以得到一个3D 张量，可以将其直观地理解为数字 组成的立方体。下面是一个 Numpy 的 3D 张量。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = np.array([[[5, 78, 2, 34, 0],                    
                   [6, 79, 3, 35, 1],                    
                   [7, 80, 4, 36, 2]],                   
                  [[5, 78, 2, 34, 0],                    
                   [6, 79, 3, 35, 1],                    
                   [7, 80, 4, 36, 2]],                   
                  [[5, 78, 2, 34, 0],                    
                   [6, 79, 3, 35, 1],                    
                   [7, 80, 4, 36, 2]]]) 
&amp;gt;&amp;gt;&amp;gt; x.ndim  
3 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将多个3D 张量组合成一个数组，可以创建一个4D 张量，以此类推。深度学习处理的一般 是 0D 到 4D 的张量，但处理视频数据时可能会遇到 5D 张量。&lt;/p&gt;

&lt;p&gt;神经网络实际上是由多个&lt;code&gt;层（神经网络的基本数据结构）&lt;/code&gt;堆叠而成，层是一个数据处理模块，可以将一个 或多个输入张量转换为一个或多个输出张量。下图是一个最简单的网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201908/1413964-20190824234119227-1840973844.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个三层神经网络（但实质上只有2层神经元有权重，因此也可称其为“2层网络”），包括&lt;code&gt;输入层&lt;/code&gt;、&lt;code&gt;中间层（隐藏层）&lt;/code&gt;和&lt;code&gt;输出层&lt;/code&gt;。(个人认为，对于任意一个网络，都可以简化成上图所示的一个三层的神经网络，数据从输入层进入，经过一层运算进入隐藏层，然后在隐藏层中进行各种运算，最后再通过一层运算到达输出层，输出我们所需的结果)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，对于一个最简单的网络，每一层的运算是如何的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201908/1413964-20190824234127831-669058379.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，假设我们输入了 &lt;span class=&quot;math inline&quot;&gt;\(x_1, x_2\)&lt;/span&gt;， &lt;span class=&quot;math inline&quot;&gt;\(x_1, x_2\)&lt;/span&gt; 分别乘上到下一层的权重，再加上偏置，得到一个y值，这个y值将作为下一层的输入，用公式表达如下&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y = w_1x_1+w_2x_2+b {\tag 1} \]&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;可想而知，如果所有的计算都是这样的话，那神经网络就只是一个线性模型，那要如何使其具有非线性呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很简单，可以加入激活函数&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;，那么，我们的公式便可改成&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ a=w_1x_1+w_2x_2+b {\tag {2.1}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ y=h(a) {\tag {2.2}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先，式（2.1）计算加权输入信号和偏置的总和，记为a。然后，式（2.2） 用h(x)函数将a转换为输出y。&lt;/p&gt;
&lt;h2 id=&quot;激活函数&quot;&gt;激活函数&lt;/h2&gt;
&lt;p&gt;这里介绍下常用的激活函数&lt;/p&gt;
&lt;h3 id=&quot;sigmoid函数&quot;&gt;sigmoid函数&lt;/h3&gt;
&lt;p&gt;说到非线性，比较容易想到的应该是阶跃函数，比如下面代码所示的&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def step_function(x):    
    if x &amp;gt; 0:        
        return 1    
    else:        
        return 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，由于阶跃函数只有两个值，不存在平滑性，在计算过程中表示能力肯定不够好，所以，又想到sigmoid函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def sigmoid(x):    
    return 1 / (1 + np.exp(-x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sigmoid函数的平滑性对神经网络的学习具有重要意义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201908/1413964-20190824234141109-624612154.png&quot; alt=&quot;sigmoid函数图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201908/1413964-20190824234202077-1288375965.png&quot; alt=&quot;阶跃函数与sigmoid函数&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;relu函数&quot;&gt;ReLU函数&lt;/h3&gt;
&lt;p&gt;在神经网络发展的历史上，sigmoid函数很早就开始被使用了，而最近则主要使用ReLU（Rectified Linear Unit）函数。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ h(x)= \begin{cases} x,\quad x &amp;gt; 0\\ 0,\quad x&amp;lt;=0 \end{cases} \tag{3} \]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def relu(x):    
    return np.maximum(0, x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201908/1413964-20190824234227529-1876387320.png&quot; alt=&quot;ReLU函数&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;恒等函数和softmax函数输出层激活函数&quot;&gt;恒等函数和softmax函数（输出层激活函数）&lt;/h3&gt;
&lt;p&gt;神经网络可以用在分类问题和回归问题上，不过需要根据情况改变输出 层的激活函数。一般而言，回归问题用恒等函数，分类问题用softmax函数。&lt;/p&gt;
&lt;p&gt;恒等函数会将输入按原样输出，对于输入的信息，不加以任何改动地直 接输出。因此，在输出层使用恒等函数时，输入信号会原封不动地被输出。&lt;/p&gt;
&lt;p&gt;分类问题中使用的softmax函数可以用下面的式子表示。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y_k = \frac{exp(a_k)}{\sum^n_{i=1}exp(a_i)} \tag{4} \]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def softmax(a):    
    exp_a = np.exp(a)    
    sum_exp_a = np.sum(exp_a)    
    y = exp_a / sum_exp_a
    return y&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的softmax函数的实现在计算机的运算上存在有溢出问题。softmax函数的实现中要进行指数函数的运算，但是此时指数函数的值很容易变得非常大。比如，&lt;span class=&quot;math inline&quot;&gt;\(e^{10}\)&lt;/span&gt;的值 会超过20000，&lt;span class=&quot;math inline&quot;&gt;\(e^{100}\)&lt;/span&gt;会变成一个后面有40多个0的超大值，&lt;span class=&quot;math inline&quot;&gt;\(e^{1000}\)&lt;/span&gt;的结果会返回 一个表示无穷大的inf。如果在这些超大值之间进行除法运算，结果会出现“不确定”的情况。&lt;/p&gt;
&lt;p&gt;因此对softmax做如下改进&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def softmax(a):    
    c = np.max(a)    
    exp_a = np.exp(a - c) # 溢出对策    
    sum_exp_a = np.sum(exp_a)    
    y = exp_a / sum_exp_a
    return y
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;网络的学习&quot;&gt;网络的学习&lt;/h2&gt;
&lt;p&gt;从之前的介绍来看，设置好神经网络的参数，设置好激活函数，似乎就可以利用该神经网络来做预测了，事实也是入此。但这里存在一个很重要的问题，网络的各个权重参数如何设置？1. 人为设置，这好像就成了人工神经网络，并且十分不现实，一旦网络结构比较大，具有数万个神经元的时候，完全无法设置参数。2. 从数据中学习，这是所有机器学习、深度学习模型的一个很重要的特征，从数据中学习。&lt;/p&gt;
&lt;p&gt;下面将介绍神经网络在学习中需要的一些东西&lt;/p&gt;
&lt;h3 id=&quot;损失函数loss-function&quot;&gt;损失函数（loss function）&lt;/h3&gt;
&lt;p&gt;相信有机器学习基础的对此都不陌生。神经网络每次在学习时，会更新一组权重，通过这组新的权重然后产生一组预测值，那我们如何判断这组权重是否是较优的呢？通过损失函数即可，这里介绍两个损失函数（可跳过）。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;损失函数是表示神经网络性能的“恶劣程度”的指标，即当前的 神经网络对监督数据在多大程度上不拟合，在多大程度上不一致。 以“性能的恶劣程度”为指标可能会使人感到不太自然，但是如 果给损失函数乘上一个负值，就可以解释为“在多大程度上不坏”， 即“性能有多好”。并且，“使性能的恶劣程度达到最小”和“使性 能的优良程度达到最大”是等价的，不管是用“恶劣程度”还是“优 良程度”，做的事情本质上都是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;均方误差mean-squared-error&quot;&gt;均方误差（mean squared error)&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ E=\frac{1}{2}\sum_k(y_k-t_k)^2 \tag{5} \]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def mean_squared_error(y, t):    
    return 0.5 * np.sum((y-t)**2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该损失函数常用于回归问题&lt;/p&gt;
&lt;h5 id=&quot;交叉熵误差cross-entropy-error&quot;&gt;交叉熵误差（cross entropy error)&lt;/h5&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ E=-\sum_k{t_klogy_k} \tag{6} \]&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def cross_entropy_error(y, t):    
    delta = 1e-7    
    return -np.sum(t * np.log(y + delta))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，参数y和t是NumPy数组。函数内部在计算np.log时，加上了一 个微小值delta。这是因为，当出现np.log(0)时，np.log(0)会变为负无限大的-inf，这样一来就会导致后续计算无法进行。作为保护性对策，添加一个微小值可以防止负无限大的发生。&lt;/p&gt;
&lt;p&gt;交叉熵误差常用于分类问题上&lt;/p&gt;
&lt;h3 id=&quot;mini-batch-学习&quot;&gt;mini-batch 学习&lt;/h3&gt;
&lt;p&gt;介绍了损失函数之后，其实已经可以利用损失函数开始训练我们的神经网络了，但是，我们每次训练都不止一条数据，如果想要训练出比较好的神经网络模型，在计算损失函数时就必须将所有的训练数据作为对象。以交叉熵误差为例，损失函数改写成下面的式子&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ E=-\frac{1}{N}\sum_n\sum_kt_{nk}logy_{nk} \tag{7} \]&lt;/span&gt;&lt;br/&gt;但是，同时需考虑，在MNIST数据集中，训练数据有60000条，如果以全部数据为对象求损失函数的和，则计算过程需要花费较长的时间。再者，如果遇到大数据， 数据量会有几百万、几千万之多，这种情况下以全部数据为对象计算损失函数是不现实的。因此，我们从全部数据中选出一部分，作为全部数据的“近似”。神经网络的学习也是从训练数据中选出一批数据（称为mini-batch,小 批量），然后对每个mini-batch进行学习。比如，从60000个训练数据中随机选择200笔，再用这200笔数据进行学习。这种学习方式称为mini-batch学习。&lt;/p&gt;
&lt;p&gt;此时交叉熵代码实现如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cross_entropy_error(y, t):    
    if y.ndim == 1:        
        t = t.reshape(1, t.size)        
        y = y.reshape(1, y.size)
        
    batch_size = y.shape[0]    
    return -np.sum(t * np.log(y + 1e-7)) / batch_size
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当监督数据是标签形式（非one-hot表示，而是像“2”“ 7”这样的标签）时，交叉熵误差可通过如下代码实现。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cross_entropy_error(y, t):    
    if y.ndim == 1:        
        t = t.reshape(1, t.size)        
        y = y.reshape(1, y.size)
    batch_size = y.shape[0]    
    return -np.sum(np.log(y[np.arange(batch_size), t] + 1e-7)) / batch_size
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参数权重和偏置优化&quot;&gt;参数（权重和偏置）优化&lt;/h3&gt;
&lt;p&gt;上面介绍了更新权重时需要的损失函数，但是，我们要如何利用损失函数来更新权重呢？这里用到了我们熟知的梯度法。&lt;/p&gt;
&lt;h4 id=&quot;梯度法&quot;&gt;梯度法&lt;/h4&gt;
&lt;p&gt;机器学习的主要任务是在学习时寻找最优参数。同样地，神经网络也必 须在学习时找到最优参数（权重和偏置）。这里所说的最优参数是指损失函数取最小值时的参数。但是，一般而言，损失函数很复杂，参数空间庞大，我 们不知道它在何处能取得最小值。而通过巧妙地使用梯度来寻找函数最小值 （或者尽可能小的值）的方法就是梯度法，数学表示如下&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ x_0=x_0-\eta \frac{\partial f}{\partial x_0} \\ x_1=x_1-\eta \frac{\partial f}{\partial x_1} \tag{8} \]&lt;/span&gt;&lt;br/&gt;式中η表示更新量，在神经网络的学习中，称为&lt;code&gt;学习率（learning rate）&lt;/code&gt;。学习率决定在一次学习中，应该学习多少，以及在多大程度上更新参数。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def numerical_gradient(f, x):    
    h = 1e-4 # 0.0001    
    grad = np.zeros_like(x) # 生成和x形状相同的数组
    it = np.nditer(x, flags=['multi_index'], op_flags=['readwrite'])
    while not it.finished:
        idx = it.multi_index
        tmp_val = x[idx]        
        # f(x+h)的计算        
        x[idx] = tmp_val + h        
        fxh1 = f(x)
        
        # f(x-h)的计算        
        x[idx] = tmp_val - h        
        fxh2 = f(x)
        grad[idx] = (fxh1 - fxh2) / (2*h)
        
        x[idx] = tmp_val # 还原值
        it.iternext()
        
    return grad

def gradient_descent(f, init_x, lr=0.01, step_num=100):    
    x = init_x
    for i in range(step_num):        
        grad = numerical_gradient(f, x)        
        x -= lr * grad
        
    return x
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;参数f&lt;/code&gt;是要进行最优化的函数，&lt;code&gt;init_x&lt;/code&gt;是初始值，&lt;code&gt;lr&lt;/code&gt;是学习率learning rate，&lt;code&gt;step_num&lt;/code&gt;是梯度法的重复次数。&lt;code&gt;numerical_gradient(f,x)&lt;/code&gt;会求函数的梯度，用该梯度乘以学习率得到的值进行更新操作，由step_num指定重复的 次数。&lt;/p&gt;
&lt;p&gt;学习率需要事先确定为某个值，比如0.01或0.001。一般而言，这个值 过大或过小，都无法抵达一个“好的位置”。在神经网络的学习中，一般会 一边改变学习率的值，一边确认学习是否正确进行了。&lt;/p&gt;
&lt;h5 id=&quot;神经网络的梯度&quot;&gt;神经网络的梯度&lt;/h5&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{W}=\left( \begin{matrix} w_{11} &amp;amp; w_{12} &amp;amp; w_{13} \\ w_{21} &amp;amp; w_{22} &amp;amp; w_{23} \end{matrix} \right) \\ \frac{\partial L}{\partial \mathbf{W}} = \left( \begin{matrix} \frac{\partial L}{\partial w_{11}} &amp;amp; \frac{\partial L}{\partial w_{12}} &amp;amp;\frac{\partial L}{\partial w_{13}} \\ \frac{\partial L}{\partial w_{21}} &amp;amp; \frac{\partial L}{\partial w_{22}} &amp;amp;\frac{\partial L}{\partial w_{23}} \end{matrix} \right) \tag{9} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;就是需要一个一个算比较麻烦，但是计算机就无所谓了&lt;/p&gt;
&lt;p&gt;迭代伪代码如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt; def f(W):    
     return net.loss(x, t) 
     
 dW = numerical_gradient(f, net.W) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;学习算法的实现&quot;&gt;学习算法的实现&lt;/h3&gt;
&lt;p&gt;根据前面的介绍，差不多可以理清神经网络的学习步骤了&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;mini-batch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从训练数据中随机选出一部分数据，这部分数据称为mini-batch。我们 的目标是减小mini-batch的损失函数的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;梯度计算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度。 梯度表示损失函数的值减小最多的方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;更新参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将权重参数沿梯度方向进行微小更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;迭代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重复步骤1、步骤2、步骤3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;神经网络的学习按照上面4个步骤进行。这个方法通过梯度下降法更新参数，不过因为这里使用的数据是随机选择的mini batch数据，所以又称为 &lt;code&gt;随机梯度下降法（stochastic gradient descent）&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面给出一个两层的简单神经网络的实现&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class TwoLayerNet:
    def __init__(self, input_size, hidden_size, output_size,                 weight_init_std=0.01):
        &quot;&quot;&quot;
        :param: input_size - 输入层的神经元数
        :param: hidden_size - 隐藏层的神经元数
        ;param: output_size - 输出层的神经元数
        &quot;&quot;&quot;
        # 初始化权重        
        self.params = {}        
        self.params['W1'] = weight_init_std * np.random.randn(input_size, hidden_size)       
        self.params['b1'] = np.zeros(hidden_size)        
        self.params['W2'] = weight_init_std * np.random.randn(hidden_size, output_size)           self.params['b2'] = np.zeros(output_size)

    def predict(self, x):        
        W1, W2 = self.params['W1'], self.params['W2']        
        b1, b2 = self.params['b1'], self.params['b2']
        a1 = np.dot(x, W1) + b1        
        z1 = sigmoid(a1)        
        a2 = np.dot(z1, W2) + b2        
        y = softmax(a2)
        return y
    
     # x:输入数据, t:监督数据    
     def loss(self, x, t):        
        y = self.predict(x)
        return cross_entropy_error(y, t)
    
    def accuracy(self, x, t):        
        y = self.predict(x)        
        y = np.argmax(y, axis=1)        
        t = np.argmax(t, axis=1)
        accuracy = np.sum(y == t) / float(x.shape[0])        
        return accuracy
 
     # x:输入数据, t:监督数据    
     def numerical_gradient(self, x, t):        
        loss_W = lambda W: self.loss(x, t)
        grads = {}        
        grads['W1'] = numerical_gradient(loss_W, self.params['W1'])        
        grads['b1'] = numerical_gradient(loss_W, self.params['b1'])        
        grads['W2'] = numerical_gradient(loss_W, self.params['W2'])        
        grads['b2'] = numerical_gradient(loss_W, self.params['b2'])
        
        return grads

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 数据加载代码
try:
    import urllib.request
except ImportError:
    raise ImportError('You should use Python 3.x')
import os.path
import gzip
import pickle
import os
import numpy as np
url_base = 'http://yann.lecun.com/exdb/mnist/'
key_file = {
    'train_img':'train-images-idx3-ubyte.gz',
    'train_label':'train-labels-idx1-ubyte.gz',
    'test_img':'t10k-images-idx3-ubyte.gz',
    'test_label':'t10k-labels-idx1-ubyte.gz'
}

dataset_dir = os.path.dirname(os.path.abspath(__file__))
save_file = dataset_dir + &quot;/mnist.pkl&quot;

train_num = 60000
test_num = 10000
img_dim = (1, 28, 28)
img_size = 784

def _download(file_name):
    file_path = dataset_dir + &quot;/&quot; + file_name

    if os.path.exists(file_path):
        return

    print(&quot;Downloading &quot; + file_name + &quot; ... &quot;)
    urllib.request.urlretrieve(url_base + file_name, file_path)
    print(&quot;Done&quot;)

def download_mnist():
    for v in key_file.values():
       _download(v)

def _load_label(file_name):
    file_path = dataset_dir + &quot;/&quot; + file_name

    print(&quot;Converting &quot; + file_name + &quot; to NumPy Array ...&quot;)
    with gzip.open(file_path, 'rb') as f:
            labels = np.frombuffer(f.read(), np.uint8, offset=8)
    print(&quot;Done&quot;)

    return labels

def _load_img(file_name):
    file_path = dataset_dir + &quot;/&quot; + file_name

    print(&quot;Converting &quot; + file_name + &quot; to NumPy Array ...&quot;)
    with gzip.open(file_path, 'rb') as f:
            data = np.frombuffer(f.read(), np.uint8, offset=16)
    data = data.reshape(-1, img_size)
    print(&quot;Done&quot;)

    return data

def _convert_numpy():
    dataset = {}
    dataset['train_img'] =  _load_img(key_file['train_img'])
    dataset['train_label'] = _load_label(key_file['train_label'])
    dataset['test_img'] = _load_img(key_file['test_img'])
    dataset['test_label'] = _load_label(key_file['test_label'])

    return dataset

def init_mnist():
    download_mnist()
    dataset = _convert_numpy()
    print(&quot;Creating pickle file ...&quot;)
    with open(save_file, 'wb') as f:
        pickle.dump(dataset, f, -1)
    print(&quot;Done!&quot;)

def _change_one_hot_label(X):
    T = np.zeros((X.size, 10))
    for idx, row in enumerate(T):
        row[X[idx]] = 1

    return T

def load_mnist(normalize=True, flatten=True, one_hot_label=False):
    if not os.path.exists(save_file):
        init_mnist()

    with open(save_file, 'rb') as f:
        dataset = pickle.load(f)

    if normalize:
        for key in ('train_img', 'test_img'):
            dataset[key] = dataset[key].astype(np.float32)
            dataset[key] /= 255.0

    if one_hot_label:
        dataset['train_label'] = _change_one_hot_label(dataset['train_label'])
        dataset['test_label'] = _change_one_hot_label(dataset['test_label'])

    if not flatten:
         for key in ('train_img', 'test_img'):
            dataset[key] = dataset[key].reshape(-1, 1, 28, 28)

    return (dataset['train_img'], dataset['train_label']), (dataset['test_img'], dataset['test_label'])
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# NN训练代码
(x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, one_hot_ laobel = True)
train_loss_list = [] 
train_acc_list = [] 
test_acc_list = [] 
# 平均每个epoch的重复次数 
iter_per_epoch = max(train_size / batch_size, 1)

# 超参数 
iters_num = 10000 
batch_size = 100 
learning_rate = 0.1

network = TwoLayerNet(input_size=784, hidden_size=50, output_size=10)

for i in range(iters_num):    
    # 获取mini-batch    
    batch_mask = np.random.choice(train_size, batch_size)    
    x_batch = x_train[batch_mask]    
    t_batch = t_train[batch_mask]
    # 计算梯度    
    grad = network.numerical_gradient(x_batch, t_batch)    
    # grad = network.gradient(x_batch, t_batch) # 高速版!
    
    # 更新参数    
    for key in ('W1', 'b1', 'W2', 'b2'):        n
        etwork.params[key] -= learning_rate * grad[key]
    loss = network.loss(x_batch, t_batch)    
    train_loss_list.append(loss)    
    # 计算每个epoch的识别精度    
    if i % iter_per_epoch == 0:        
        train_acc = network.accuracy(x_train, t_train)        
        test_acc = network.accuracy(x_test, t_test)        
        train_acc_list.append(train_acc)        
        test_acc_list.append(test_acc)        
        print(&quot;train acc, test acc | &quot; + str(train_acc) + &quot;, &quot; + str(test_acc))

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这篇中介绍了NN的一些基础知识，也给出了一个用numpy实现的十分简单的一个2层神经网络的实现，将在下篇中介绍反向传播法，对现在实现的神经网络进行更进一步的优化。&lt;/p&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https://zhuanlan.zhihu.com/c_1092003351746777088&quot;&gt;我的知乎&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Aug 2019 15:44:00 +0000</pubDate>
<dc:creator>ITryagain</dc:creator>
<og:description>前言 这是一篇包含极少数学推导的NN入门文章 大概从今年4月份起就想着学一学NN，但是无奈平时时间不多，而且空闲时间都拿去做比赛或是看动漫去了，所以一拖再拖，直到这8月份才正式开始NN的学习。 这篇文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csu-lmw/p/11406576.html</dc:identifier>
</item>
<item>
<title>理解ConcurrentHashMap1.8源码 - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11406557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11406557.html</guid>
<description>&lt;p&gt;其实ConcurrentHashMap我自己已经看过很多遍了，但是今天在面试阿里的时候自己在描述ConcurrentHashMap发现自己根本讲不清楚什么是ConcurrentHashMap，以及里面是怎么实现的，搞的我突然发现自己什么都不懂，所以我想要再次的来分析一下这个源码，完全理解ConcurrentHashMap，而不是以为自己懂了，实际上自己不懂。&lt;/p&gt;
&lt;p&gt;首先我们看一下put方法，put方法会调用到putVal方法上面。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
      //如果put进去的是个链表，这个参数表示链表的大小
    int binCount = 0;
    for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
        Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
              //初始化链表
            tab = initTable();
            //如果这个槽位没有数据
        else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) {        
                //使用CAS将这个新的node设置到hash桶里面去
            if (casTabAt(tab, i, null,
                         new Node&amp;lt;K,V&amp;gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
            //帮助迁移
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
                //获取锁
            V oldVal = null;
            synchronized (f) {
                    //双重检查锁
                if (tabAt(tab, i) == f) {
                        //如果hash值大于等于0，那么代表这个节点里的数据是链表
                    if (fh &amp;gt;= 0) {
                        binCount = 1;
                            //每次遍历完后binCount加1，表示链表长度
                        for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {
                            K ek;
                                //如果hash值和key值都相同，那么覆盖，break结束循环
                            if (e.hash == hash &amp;amp;&amp;amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                                //下一个节点为null，说明遍历到尾节点了，那么直接在尾节点设值一个新的值
                            Node&amp;lt;K,V&amp;gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                         //如果是红黑树
                    else if (f instanceof TreeBin) {
                        Node&amp;lt;K,V&amp;gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount &amp;gt;= TREEIFY_THRESHOLD)
                      //如果链表个数大于8，那么就调用这个方法
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释一下上面的源码做了什么：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先做一下判断，不允许key和value中任意一个为空，否则抛出异常&lt;/li&gt;
&lt;li&gt;计算key的hash值，然后遍历table数组&lt;/li&gt;
&lt;li&gt;如果table数组为null或为空，那么就调用initTable做初始化&lt;/li&gt;
&lt;li&gt;为了保证可见性，会使用tab去table数组里获取数据，如果没有数据，那么用&lt;em&gt;casTabAt&lt;/em&gt;通过CAS将新Node设置到table数组里。（注：这里也体现了和hashmap不一样的地方，hashmap直接通过数据拿就好了， 这个获取数据和设值都要保证可见性和线程安全性）&lt;/li&gt;
&lt;li&gt;如果当前槽位所对应的hash值是MOVED，说明当前的table正在扩容迁移节点，那么就调用helpTransfer帮助迁移&lt;/li&gt;
&lt;li&gt;走到这里，说明这个槽位里面的元素不止一个，有很多个，所以给头节点加上锁&lt;/li&gt;
&lt;li&gt;如果当前的hash所对应的的槽位不是空的，并且hash值大于等于0，那么就说明这个槽位里面的对象是一个链表，那么就遍历链表
&lt;ol&gt;&lt;li&gt;如果所遍历的链表里面有元素的hash值并且key和当前要插入的数据的是一样的，那么就覆盖原来的值&lt;/li&gt;
&lt;li&gt;如果遍历到最后的节点都没有元素和要插入的值key是一样的，那么就新建一个Node节点，插入到链表的最后&lt;/li&gt;
&lt;li&gt;每遍历一个节点就把binCount+1&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;如果当前的节点是TreeBin，那么说明该槽位里面的数据是红黑树，那么调用相应方法插入数据&lt;/li&gt;
&lt;li&gt;最后如果binCount已经大于或等于8了，那么就调用treeifyBin&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来我们先看initTable 方法，再看treeifyBin和helpTransfer&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final Node&amp;lt;K,V&amp;gt;[] initTable() {
    Node&amp;lt;K,V&amp;gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
            //一开始的时候sizeCtl为0
        if ((sc = sizeCtl) &amp;lt; 0)
            Thread.yield(); // lost initialization race; just spin
            //将sizeCtl用CAS设置成-1
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                        //因为sc一开始为0，所以n取DEFAULT_CAPACITY为16
                    int n = (sc &amp;gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n];
                        //将table赋值为大小为16的Node数组
                    table = tab = nt;
                        //将sc的设置为总容量的75%，如果 n 为 16 的话，那么这里 sc = 12
                    sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2);
                }
            } finally {
                    //最后将sizeCtl设置为sc的值
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法里面初始化了一个很重要的变量sizeCtl，初始值为总容量的75%，table初始化为一个容量为16的数组&lt;/p&gt;
&lt;p&gt;下面我们在看看treeifyBin方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int index) {
    Node&amp;lt;K,V&amp;gt; b; int n, sc;
    if (tab != null) {
            //如果数据的长度小于64，那么调用tryPresize进行扩容
        if ((n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
            tryPresize(n &amp;lt;&amp;lt; 1);
            //如果这个槽位里面的元素是链表
        else if ((b = tabAt(tab, index)) != null &amp;amp;&amp;amp; b.hash &amp;gt;= 0) {          
                //给链表头加上锁
            synchronized (b) {
                if (tabAt(tab, index) == b) {
                    TreeNode&amp;lt;K,V&amp;gt; hd = null, tl = null;
                     //遍历链表，然后初始化红黑树对象
                    for (Node&amp;lt;K,V&amp;gt; e = b; e != null; e = e.next) {
                        TreeNode&amp;lt;K,V&amp;gt; p =
                            new TreeNode&amp;lt;K,V&amp;gt;(e.hash, e.key, e.val,
                                              null, null);
                        if ((p.prev = tl) == null)
                            hd = p;
                        else
                            tl.next = p;
                        tl = p;
                    }
                        //给tab槽位为index的元素设置新的对象
                    setTabAt(tab, index, new TreeBin&amp;lt;K,V&amp;gt;(hd));
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;treeifyBin这个方法里面并不是只是将链表转化为红黑树，而是当tab的长度大于64的时候才会将链表转成红黑树，否则的话，会调用tryPresize方法。&lt;/p&gt;
&lt;p&gt;然后我们进入到tryPresize方法里面看看，tryPresize传入的参数是当前tab数组长度的两倍。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final void tryPresize(int size) {
        //原本传进来的size已经是两倍了，这里会再往上取最近的 2 的 n 次方
    int c = (size &amp;gt;= (MAXIMUM_CAPACITY &amp;gt;&amp;gt;&amp;gt; 1)) ? MAXIMUM_CAPACITY :
        tableSizeFor(size + (size &amp;gt;&amp;gt;&amp;gt; 1) + 1);
    int sc;
    while ((sc = sizeCtl) &amp;gt;= 0) {
        Node&amp;lt;K,V&amp;gt;[] tab = table; int n;
            // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码
        if (tab == null || (n = tab.length) == 0) {
            n = (sc &amp;gt; c) ? sc : c;
            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if (table == tab) {
                        @SuppressWarnings(&quot;unchecked&quot;)
                        Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n];
                        table = nt;
                        sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
            }
        }
        else if (c &amp;lt;= sc || n &amp;gt;= MAXIMUM_CAPACITY)
            break;
        else if (tab == table) {
            int rs = resizeStamp(n);
                //一开始进来的时候sc是大于0的
            if (sc &amp;lt; 0) {
                Node&amp;lt;K,V&amp;gt;[] nt;
                if ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &amp;lt;= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
                //将SIZECTL设置为一个很大的复数
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法里面，会对tab数据进行校验，如果没有初始化的话会重新进行初始化大小，如果是第一次进来的话会将&lt;em&gt;SIZECTL&lt;/em&gt;设置成一个很大的复数，然后调用transfer方法，传如当前的tab数据和null。&lt;/p&gt;
&lt;p&gt;接着我们来看transfer方法，这个方法比较长，主要的扩容和转移节点都在这个方法里面实现，我们将这个长方法分成代码块，一步步分析：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final void transfer(Node&amp;lt;K,V&amp;gt;[] tab, Node&amp;lt;K,V&amp;gt;[] nextTab) {
        //如果当前tab数组长度为16
    int n = tab.length, stride;
        //那么(n &amp;gt;&amp;gt;&amp;gt; 3) / NCPU  = 0 小于MIN_TRANSFER_STRIDE
    if ((stride = (NCPU &amp;gt; 1) ? (n &amp;gt;&amp;gt;&amp;gt; 3) / NCPU : n) &amp;lt; MIN_TRANSFER_STRIDE)
            //将stride设置为 16 
        stride = MIN_TRANSFER_STRIDE; // subdivide range
    if (nextTab == null) {            // initiating
        try {
            @SuppressWarnings(&quot;unchecked&quot;)
            Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n &amp;lt;&amp;lt; 1];
            //如果n是16，那么nextTab就是一个容量为32的空数组
            nextTab = nt;
        } catch (Throwable ex) {      // try to cope with OOME
            sizeCtl = Integer.MAX_VALUE;
            return;
        }
        nextTable = nextTab;
            //将transferIndex赋值为16
        transferIndex = n;
    }
        ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个代码块主要是做nextTable、transferIndex 、stride的赋值操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;...
//初始化nextn为32
int nextn = nextTab.length;
//新建一个ForwardingNode对象，里面放入长度为32的nextTab数组
ForwardingNode&amp;lt;K,V&amp;gt; fwd = new ForwardingNode&amp;lt;K,V&amp;gt;(nextTab);
boolean advance = true;
boolean finishing = false;
//初始化bound为0
for (int i = 0, bound = 0;;) {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的代码会全部包裹在这个for循环里面，所以我们来分析一下这个for循环里面的代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;for (int i = 0, bound = 0;;) {
        
        Node&amp;lt;K,V&amp;gt; f; int fh;
        while (advance) {
            int nextIndex, nextBound;
            if (--i &amp;gt;= bound || finishing)
                advance = false;
                //将nextIndex设置为transferIndex，一开始16
            else if ((nextIndex = transferIndex) &amp;lt;= 0) {
                i = -1;
                advance = false;
            }
                //一开始的时候nextIndex是和stride相同，那么nextBound为0，TRANSFERINDEX也为0
            else if (U.compareAndSwapInt
                     (this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex &amp;gt; stride ?
                                   nextIndex - stride : 0))) {
                    //这里bound也直接为0
                bound = nextBound;
                    //i = 15
                i = nextIndex - 1;
                advance = false;
            }
        }
        ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法是为了设置transferIndex这个属性，transferIndex一开始是原tab数组的长度，每次会向前移动stride大小的值，如果transferIndex减到了0或小于0，那么就设置I等于-1，i在下面的代码会说到。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;for (int i = 0, bound = 0;;) {
        ...
        //在上面一段代码块中，如果transferIndex已经小于等于0了，就会把i设置为-1
        if (i &amp;lt; 0 || i &amp;gt;= n || i + n &amp;gt;= nextn) {
            int sc;
                //表示迁移已经完成
            if (finishing) {
                    //将nextTable置空，表示不需要迁移了
                nextTable = null;
                    //将table设置为新的数组
                table = nextTab;
                    //sizeCtl设置为n的 1.5倍
                sizeCtl = (n &amp;lt;&amp;lt; 1) - (n &amp;gt;&amp;gt;&amp;gt; 1);
                return;
            }
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                if ((sc - 2) != resizeStamp(n) &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT)
                    return;
                // 到这里，说明 (sc - 2) == resizeStamp(n) &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT，
                 // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了
                finishing = advance = true;
                i = n; // recheck before commit
            }
        }
...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法是用来表示已经迁移完毕了，可以退出。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;for (int i = 0, bound = 0;;) {
    ...
    //如果该槽位没有元素，那么直接把tab的i槽位设置为fwd
    else if ((f = tabAt(tab, i)) == null)
        advance = casTabAt(tab, i, null, fwd);
    //说明这个槽位已经有其他线程迁移过了
    else if ((fh = f.hash) == MOVED)
        advance = true; // already processed
    //走到这里，说明tab的这个槽位里面有数据，那么我们需要获得槽位的头节点的监视器锁
    else {
        synchronized (f) {  
            if (tabAt(tab, i) == f) {
                ...
            } 
          }
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个代码块中，i会从最后一个元素一个个往前移动，然后根据i这个index来判断tab里面槽位的情况。&lt;/p&gt;
&lt;p&gt;下面的代码我们来分析监视器锁里面的内容：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized (f) {
    if (tabAt(tab, i) == f) {
        //fh是当前节点的hash值
        if (fh &amp;gt;= 0) {
            int runBit = fh &amp;amp; n;
            //lastRun设置为头节点
            Node&amp;lt;K,V&amp;gt; lastRun = f;
        // 需要将链表一分为二，
        //   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的
        //   lastRun 之前的节点需要进行克隆，然后分到两个链表中
            for (Node&amp;lt;K,V&amp;gt; p = f.next; p != null; p = p.next) {
                int b = p.hash &amp;amp; n;
                if (b != runBit) {
                    runBit = b;
                    lastRun = p;
                }
            }
            if (runBit == 0) {
                ln = lastRun;
                hn = null;
            }
            else {
                hn = lastRun;
                ln = null;
            }
            for (Node&amp;lt;K,V&amp;gt; p = f; p != lastRun; p = p.next) {
                int ph = p.hash; K pk = p.key; V pv = p.val;
                if ((ph &amp;amp; n) == 0)
                    ln = new Node&amp;lt;K,V&amp;gt;(ph, pk, pv, ln);
                else
                    hn = new Node&amp;lt;K,V&amp;gt;(ph, pk, pv, hn);
            }
            //其中的一个链表放在新数组的位置 i
            setTabAt(nextTab, i, ln);
            //另一个链表放在新数组的位置 i+n
            setTabAt(nextTab, i + n, hn);
            //将原数组该位置处设置为 fwd，代表该位置已经处理完毕
            //其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了
            setTabAt(tab, i, fwd);
            //advance 设置为 true，代表该位置已经迁移完毕
            advance = true;
        }
        //下面红黑树的迁移和上面差不多
        else if (f instanceof TreeBin) {
            ....
        }
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法主要是将头节点里面的链表拆分成两个链表，然后设置到新的数组中去，再给老的数组设置为fwd，表示这个节点已经迁移过了。&lt;/p&gt;
&lt;p&gt;到这里transfer方法已经分析完毕了。&lt;br/&gt;这里我再举个例子，让大家根据透彻的明白多线程之间是怎么进行迁移工作的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我们假设stride还是默认的16，第一次进来nextTab为null，但是tab的长度为32。

一开始的赋值：
1. n会设置成32，并且n只会赋值一次，代表被迁移的数组长度 
2. nextTab会被设置成一个大小为64的数组，并塞入到新的ForwardingNode对象中去。
3. transferIndex会被赋值为32

进入循环：
    初始化i为0，bound为0；
    第一次循环：
        1. 由于advance初始化为true，所以会进入到while循环中，循环出来后，transferIndex会被设置成16，bound被设置成16，i设置成31。这里你可能会问
        2. 将原来tab[i]的元素迁移到新的数组中去，并将tab[i]设置为fwd，将advance设置成为true

    第二次循环：
        1. --i，变为30，--i &amp;gt;= bound成立，并将advance设置成false
        2. 将原来tab[i]的元素迁移到新的数组中去，并将tab[i]设置为fwd，将advance设置成为true
    。。。
    第十六次循环：
        1. --i，变为15，将transferIndex设置为0，bound也设置为0，i设置为15
        2. 将原来tab[i]的元素迁移到新的数组中去，并将tab[i]设置为fwd，将advance设置成为true
    第三十二次循环：
        1. 这个时候--i等于-1，并且(nextIndex = transferIndex) &amp;lt;= 0成立，那么会将i设置为-1，advance设置为false
        2. 会把SIZECTL用CAS设置为原来的值加1，然后设置finishing为true

    第三十三次循环：
        1. 由于finishing为true，那么nextTable设置为null，table设置为新的数组值，sizeCtl设置为旧tab的长度的1.5倍&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 24 Aug 2019 15:28:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>ConcurrentHashMap源码分析 其实ConcurrentHashMap我自己已经看过很多遍了，但是今天在面试阿里的时候自己在描述ConcurrentHashMap发现自己根本讲不清楚什么是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11406557.html</dc:identifier>
</item>
<item>
<title>Log2Net的部署和运维 - 三河散人</title>
<link>http://www.cnblogs.com/yuchen1030/p/11406454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuchen1030/p/11406454.html</guid>
<description>
&lt;p&gt;前面几节中，笔者介绍了Log2Net组件的方方面面。但是，有人说，我用不起来，各种头疼的小问题。下面，我们就具体的看一看要怎么把这个组件应用到实际的项目中吧。&lt;/p&gt;
&lt;h2&gt;一、Log2Net组件的发布&lt;/h2&gt;
&lt;p&gt;前文中，我们说这个组件已发布到了Nuget，应用时只需要从Nuget安装Log2Net即可。但是，它是怎么发布到Nuget的呢。修改这个组件后，想要发布到本局域网内，该怎么办呢？下文一一介绍。&lt;/p&gt;
&lt;p&gt;1.1 发布组件到Nuget&lt;/p&gt;
&lt;p&gt;（1）在VS开发环境中，设置组件的包属性，将组件发布为nupkg包，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1710111/201908/1710111-20190824205023816-710110560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在项目属性--&amp;gt;打包中设置的属性如上图所示。然后发布方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1710111/201908/1710111-20190824203730059-114005755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里的目标框架只显示了第一个net45，而实际上是支持在项目文件Log2Net.csproj的TargetFrameworks节点配置的所有框架的。 &lt;/p&gt;
&lt;p&gt;（2）在&lt;a class=&quot;uri&quot; title=&quot;https://www.nuget.org/&quot; href=&quot;https://www.nuget.org/&quot;&gt;https://www.nuget.org/&lt;/a&gt; 上注册账号（可使用微软账号），设置你的API Key，并将该key保存到本地txt文档中；&lt;/p&gt;
&lt;p&gt;（3）从 &lt;a href=&quot;https://github.com/NuGetPackageExplorer/NuGetPackageExplorer&quot;&gt;https://github.com/NuGetPackageExplorer/NuGetPackageExplorer&lt;/a&gt; 下载Nuget包管理器，然后打开第一步生成的包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1710111/201908/1710111-20190824211106846-248092809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）点击NuGetPackageExplorer 的File--&amp;gt;Publish，并在随后的窗口中填入你的API Key，然后发布即可（你可以在此步骤中修改nupkg包的属性）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1710111/201908/1710111-20190824211746158-382793730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，就将组件发布到Nuget公网啦，就可以供所有人使用啦。&lt;/p&gt;
&lt;p&gt;1.2 发布组件到本地服务器&lt;/p&gt;
&lt;p&gt;在有些时候，我们需要将组件进行修改后再使用，或者不想发布到公网。这时，我们也许可以直接引用生成后的DLL。但是，这样可能造成组件的版本混乱和不一致，并且在.NetCore中不能直接引用DLL，必须通过Nuget的方式引用DLL。这时，我们可以将组件发布到本地服务器（使用Nuget.Server）。方法介绍如下。&lt;/p&gt;
&lt;p&gt;（1）新建一个空白的网站项目名为CompanyNuGetServer，NuGet中搜索NuGet.Server并安装；安装完成后，项目中会自动生成一些文件，如下图；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1710111/201908/1710111-20190824213413381-1239642275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）将该项目发布到你公司/组织的服务器上，假设为192.168.0.88:16000；&lt;/p&gt;
&lt;p&gt;（3）将nupkg包 Log2Net.1.0.6.nupkg&lt;span&gt;放到&lt;/span&gt; 192.168.0.88:16000&lt;span&gt;的&lt;/span&gt; Packages&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;夹下；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）各业务系统在使用时，在Nuget程序包设置Nuget包管理器—&amp;gt;程序包源中添加 http://192.168.0.88:16000/nuget 。&lt;/p&gt;
&lt;p&gt;这样，你就将包发布到了192.168.0.88:16000上，所有能访问该网站的人都可使用该服务器上的程序包。&lt;/p&gt;
&lt;h2&gt;二、其他组件的配置和使用&lt;/h2&gt;
&lt;p&gt;各业务网站可通过前文&lt;a href=&quot;https://www.cnblogs.com/yuchen1030/p/10992259.html&quot;&gt;https://www.cnblogs.com/yuchen1030/p/10992259.html&lt;/a&gt; 中介绍的方法使用Log2Net组件，发布和配置参照常规网站项目。若有业务网站有特殊的组件配置，则需要对这些组件/服务进行配置和部署。若业务网站不需要这些服务，则不需要部署这些组件。&lt;/p&gt;
&lt;p&gt;2.1 RabmitMQ服务&lt;/p&gt;
&lt;p&gt;若业务网站需要RabmitMQ方式写到数据库，则需要安装RabmitMQ组件。安装方法可参考&lt;a href=&quot;https://www.cnblogs.com/sam-uncle/p/9050242.html&quot;&gt;https://www.cnblogs.com/sam-uncle/p/9050242.html&lt;/a&gt; 。安装后，将其作为服务启动。&lt;/p&gt;
&lt;p&gt;2.2 InfluxDB服务&lt;/p&gt;
&lt;p&gt;若业务网站配置需要将数据写到InfluxDB数据库，则需要安装InfluxDB数据库。安装方法可参考 &lt;a href=&quot;https://www.cnblogs.com/shuzhenyu/p/9268506.html&quot;&gt;https://www.cnblogs.com/shuzhenyu/p/9268506.html&lt;/a&gt;。安装后，将其作为服务启动（可使用NSSM工具将其封装为服务自启动）。&lt;/p&gt;
&lt;p&gt;2.3 日志查询网站的部署&lt;/p&gt;
&lt;p&gt;若查询网站和业务网站的日志数据库使用了SQL Swever的读写分离，则需要查询网站服务器和数据库服务器&lt;span&gt;启用&lt;/span&gt;MSDTC分布式交易协调器，数据库服务器需要开启SQL代理，写服务器先事务发布，然后读服务器订阅该发布。&lt;/p&gt;
&lt;p&gt;2.4 健康检查服务&lt;/p&gt;
&lt;p&gt;Log2Net组件提供了定时采集网站服务器运行情况日志的方法。然而，我们不能保证网站服务器一直处于活跃状态。一旦网站进入休眠状态，定时服务可能会暂时停止。我们需要有一套机制来保证网站一直处于活动状态。本组件是通过定时的健康检查来实现的。&lt;/p&gt;
&lt;p&gt;健康检查组件是一个Winform开发的小程序，为exe文件，它自动定时检查各网站，在某网站无响应时，给相关人员发送邮件（每小时内仅发送一次）。用户可可以手动检查各网站是否可访问。该组件的下载路径为  &lt;a href=&quot;https://github.com/yuchen1030/Log2Net/tree/master/Resource/WebHealthCheck&quot;&gt;https://github.com/yuchen1030/Log2Net/tree/master/Resource/WebHealthCheck&lt;/a&gt;。效果如下图所示：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1710111/201908/1710111-20190824225645076-973188988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用NSSM工具，将该exe文件封装为自启动的服务。NSSM的下载地址为&lt;a href=&quot;http://www.nssm.cc/&quot;&gt;http://www.nssm.cc/&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/yuchen1030/Log2Net/tree/master/Resource/NSSM/nssm-V2.24.rar&quot;&gt;https://github.com/yuchen1030/Log2Net/tree/master/Resource/NSSM/nssm-V2.24.rar&lt;/a&gt;，使用方法参考&lt;a href=&quot;https://www.cnblogs.com/TianFang/p/7912648.html&quot;&gt;https://www.cnblogs.com/TianFang/p/7912648.html&lt;/a&gt; 。&lt;/p&gt;
&lt;h2&gt; 三、Oracle中日志组件的使用&lt;/h2&gt;
&lt;p&gt;还记得在日志组件的配置中，有两项配置叫 initTraceDBWhenOracle 和 initMonitorDBWhenOracle，分别表示是否使用EF初始化数据库Trace 表和数据库Monitor表，它们的默认值是不使用。笔者为什么要这么配置呢？这要从Oracle本身的特性谈起。&lt;/p&gt;
&lt;p&gt;Oracle表和字段是有大小写的区别，oracle默认是大写，并且没有自增字段的概念（要使用序列来实现）。在SQL语句中，如果我们把表名/字段名用双引号括起来的就区分大小写，如果没有，系统会自动转成大写。而EF、Navicat等第三方工具在创建表/字段时，会自动加上双引号，所以对日志组件来说，EF创建的表名和字段名是区分大小写的，在SQL查询时必须加上引号才能查出数据，这对程序员来说是不友好的。因此我们不使用EF自动创建数据库，而是手动创建数据库，并使用序列实现ID字段的自增，SQL语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bb14d54f-1307-4151-bf7b-35b7d3801b8d')&quot; readability=&quot;54&quot;&gt;&lt;img id=&quot;code_img_closed_bb14d54f-1307-4151-bf7b-35b7d3801b8d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bb14d54f-1307-4151-bf7b-35b7d3801b8d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bb14d54f-1307-4151-bf7b-35b7d3801b8d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb14d54f-1307-4151-bf7b-35b7d3801b8d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;103&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;  CREATE TABLE Log_OperateTrace 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    (    Id NUMBER(&lt;span&gt;19&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    LogTime TIMESTAMP NOT NULL , 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     UserID NVARCHAR2(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     UserName NVARCHAR2(&lt;span&gt;200&lt;/span&gt;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     LogType NUMBER(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     SystemID NUMBER(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ServerHost NVARCHAR2(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     ServerIP NVARCHAR2(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     ClientHost NVARCHAR2(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     ClientIP NVARCHAR2(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     TabOrModu NVARCHAR2(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     Detail NVARCHAR2(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     Remark NVARCHAR2(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     CONSTRAINT PK_Log_OperateTrace PRIMARY KEY (Id)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;   )  ;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; create sequence Log_OperateTrace_tb_pk_seq minvalue &lt;span&gt;1&lt;/span&gt; maxvalue &lt;span&gt;9999999999999999999&lt;/span&gt;    
&lt;span&gt;20&lt;/span&gt;          increment by &lt;span&gt;1&lt;/span&gt;    
&lt;span&gt;21&lt;/span&gt;          start with &lt;span&gt;1&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;步长为1&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;   
&lt;span&gt;22&lt;/span&gt;  
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;create trigger Log_OperateTrace_tb_pk_tri      
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;before insert on Log_OperateTrace    
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;  &lt;span&gt;for&lt;/span&gt;&lt;span&gt; each row      
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;begin     
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;  Log_OperateTrace_tb_pk_seq.nextval into :&lt;span&gt;new&lt;/span&gt;.Id &lt;span&gt;from&lt;/span&gt;&lt;span&gt; dual;       
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;end;  
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;  CREATE TABLE Log_SystemMonitor 
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;    (    Id NUMBER(&lt;span&gt;19&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    LogTime TIMESTAMP NOT NULL , 
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     SystemID NUMBER(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     ServerHost NVARCHAR2(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     ServerIP NVARCHAR2(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     OnlineCnt NUMBER(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     AllVisitors NUMBER(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    RunHours BINARY_DOUBLE NOT NULL , 
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    CpuUsage BINARY_DOUBLE NOT NULL , 
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    MemoryUsage BINARY_DOUBLE NOT NULL , 
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     ProcessNum NUMBER(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     ThreadNum NUMBER(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     CurProcThreadNum NUMBER(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) NOT NULL , 
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    CurProcMem BINARY_DOUBLE NOT NULL , 
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    CurProcMemUse BINARY_DOUBLE NOT NULL , 
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    CurProcCpuUse BINARY_DOUBLE NOT NULL , 
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    CurSubProcMem BINARY_DOUBLE NOT NULL , 
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     PageViewNum NVARCHAR2(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     DiskSpace NVARCHAR2(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     Remark NVARCHAR2(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;     CONSTRAINT PK_Log_SystemMonitor PRIMARY KEY (Id)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;  
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;   )  ;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;  
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; create sequence Log_SystemMonitor_tb_pk_seq minvalue &lt;span&gt;1&lt;/span&gt; maxvalue &lt;span&gt;9999999999999999999&lt;/span&gt;    
&lt;span&gt;59&lt;/span&gt;          increment by &lt;span&gt;1&lt;/span&gt;    
&lt;span&gt;60&lt;/span&gt;          start with &lt;span&gt;1&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;步长为1&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;   
&lt;span&gt;61&lt;/span&gt;  
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;create trigger Log_SystemMonitor_tb_pk_tri      
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;before insert on Log_SystemMonitor    
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;  &lt;span&gt;for&lt;/span&gt;&lt;span&gt; each row      
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;begin     
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;  Log_SystemMonitor_tb_pk_seq.nextval into :&lt;span&gt;new&lt;/span&gt;.Id &lt;span&gt;from&lt;/span&gt;&lt;span&gt; dual;       
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;end;  
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 以上SQL创建的数据库和字段全部为大写，在SQL语句查询时可不加引号，随意使用大小写，方便程序员使用。&lt;/p&gt;

&lt;p&gt;至此，Log2Net组件介绍完毕，从组件的使用方法开始，剥丝抽茧地分析了其代码，最后介绍了其部署和注意事项。欢迎使用，欢迎提出问题~~&lt;/p&gt;
</description>
<pubDate>Sat, 24 Aug 2019 15:27:00 +0000</pubDate>
<dc:creator>三河散人</dc:creator>
<og:description>前面几节中，笔者介绍了Log2Net组件的方方面面。但是，有人说，我用不起来，各种头疼的小问题。下面，我们就具体的看一看要怎么把这个组件应用到实际的项目中吧。 一、Log2Net组件的发布 前文中，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuchen1030/p/11406454.html</dc:identifier>
</item>
<item>
<title>SpringBoot 配置 AOP 打印日志 - 风尘博客</title>
<link>http://www.cnblogs.com/vandusty/p/11406536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vandusty/p/11406536.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在项目开发中，日志系统是必不可少的，用&lt;code&gt;AOP&lt;/code&gt;在Web的请求做入参和出参的参数打印，同时对异常进行日志打印，避免重复的手写日志，完整案例见文末源码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一spring-aop&quot;&gt;一、&lt;code&gt;Spring AOP&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;AOP&lt;/code&gt;(Aspect-Oriented Programming，面向切面编程)，它利用一种&quot;横切&quot;的技术，将那些多个类的共同行为封装到一个可重用的模块。便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;AOP&lt;/code&gt;中有以下概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Aspect&lt;/code&gt;（切面）：声明类似于&lt;code&gt;Java&lt;/code&gt;中的类声明，在&lt;code&gt;Aspect&lt;/code&gt;中会包含一些Pointcut及相应的Advice。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Joint point&lt;/code&gt;（连接点）：表示在程序中明确定义的点。包括方法的调用、对类成员的访问等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pointcut&lt;/code&gt;（切入点）：表示一个组&lt;code&gt;Joint point&lt;/code&gt;，如方法名、参数类型、返回类型等等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Advice&lt;/code&gt;（通知）：&lt;code&gt;Advice&lt;/code&gt;定义了在&lt;code&gt;Pointcut&lt;/code&gt;里面定义的程序点具体要做的操作，它通过(&lt;code&gt;before&lt;/code&gt;、&lt;code&gt;around&lt;/code&gt;、&lt;code&gt;after&lt;/code&gt;(&lt;code&gt;return&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt;)、&lt;code&gt;finally&lt;/code&gt;来区别实在每个&lt;code&gt;Joint&lt;/code&gt; &lt;code&gt;point&lt;/code&gt;之前、之后还是执行 前后要调用的代码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Before&lt;/code&gt;：在执行方法前调用&lt;code&gt;Advice&lt;/code&gt;，比如请求接口之前的登录验证。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Around&lt;/code&gt;：在执行方法前后调用&lt;code&gt;Advice&lt;/code&gt;，这是最常用的方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;After&lt;/code&gt;：在执行方法后调用&lt;code&gt;Advice&lt;/code&gt;，&lt;code&gt;after&lt;/code&gt;、&lt;code&gt;return&lt;/code&gt;是方法正常返回后调用，&lt;code&gt;after\throw&lt;/code&gt;是方法抛出异常后调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Finally&lt;/code&gt;：方法调用后执行&lt;code&gt;Advice&lt;/code&gt;，无论是否抛出异常还是正常返回。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AOP proxy&lt;/code&gt;：&lt;code&gt;AOP proxy&lt;/code&gt;也是&lt;code&gt;Java&lt;/code&gt;对象，是由&lt;code&gt;AOP&lt;/code&gt;框架创建，用来完成上述动作，&lt;code&gt;AOP&lt;/code&gt;对象通常可以通过&lt;code&gt;JDK dynamic proxy&lt;/code&gt;完成，或者使用&lt;code&gt;CGLIb&lt;/code&gt;完成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Weaving&lt;/code&gt;：实现上述切面编程的代码织入，可以在编译时刻，也可以在运行时刻，&lt;code&gt;Spring&lt;/code&gt;和其它大多数Java框架都是在运行时刻生成代理。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;二项目示例&quot;&gt;二、项目示例&lt;/h3&gt;
&lt;p&gt;当然，在使用该案例之前，如果需要了解日志配置相关，可参考 &lt;a href=&quot;https://www.cnblogs.com/vandusty/p/11397619.html&quot;&gt;SpringBoot 异步输出 Logback 日志&lt;/a&gt;， 本文就不再概述了。&lt;/p&gt;
&lt;h4 id=&quot;在pom引入依赖&quot;&gt;2.1 在pom引入依赖&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 分析客户端信息的工具类--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;eu.bitwalker&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;UserAgentUtils&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.20&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- lombok --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;1.8.4&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;controller-切面weblogaspect&quot;&gt;2.2 &lt;code&gt;Controller&lt;/code&gt; 切面：&lt;code&gt;WebLogAspect&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
@Component
@Slf4j
public class WebLogAspect {

    /**
     * 进入方法时间戳
     */
    private Long startTime;
    /**
     * 方法结束时间戳(计时)
     */
    private Long endTime;

    public WebLogAspect() {
    }


    /**
     * 定义请求日志切入点，其切入点表达式有多种匹配方式,这里是指定路径
     */
    @Pointcut(&quot;execution(public * cn.van.log.aop.controller.*.*(..))&quot;)
    public void webLogPointcut() {
    }

    /**
     * 前置通知：
     * 1. 在执行目标方法之前执行，比如请求接口之前的登录验证;
     * 2. 在前置通知中设置请求日志信息，如开始时间，请求参数，注解内容等
     *
     * @param joinPoint
     * @throws Throwable
     */
    @Before(&quot;webLogPointcut()&quot;)
    public void doBefore(JoinPoint joinPoint) {

        // 接收到请求，记录请求内容
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        //获取请求头中的User-Agent
        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(&quot;User-Agent&quot;));
        //打印请求的内容
        startTime = System.currentTimeMillis();
        log.info(&quot;请求开始时间：{}&quot; + LocalDateTime.now());
        log.info(&quot;请求Url : {}&quot; + request.getRequestURL().toString());
        log.info(&quot;请求方式 : {}&quot; + request.getMethod());
        log.info(&quot;请求ip : {}&quot; + request.getRemoteAddr());
        log.info(&quot;请求方法 : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());
        log.info(&quot;请求参数 : {}&quot; + Arrays.toString(joinPoint.getArgs()));
        // 系统信息
        log.info(&quot;浏览器：{}&quot;, userAgent.getBrowser().toString());
        log.info(&quot;浏览器版本：{}&quot;, userAgent.getBrowserVersion());
        log.info(&quot;操作系统: {}&quot;, userAgent.getOperatingSystem().toString());
    }

    /**
     * 返回通知：
     * 1. 在目标方法正常结束之后执行
     * 1. 在返回通知中补充请求日志信息，如返回时间，方法耗时，返回值，并且保存日志信息
     *
     * @param ret
     * @throws Throwable
     */
    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLogPointcut()&quot;)
    public void doAfterReturning(Object ret) throws Throwable {
        endTime = System.currentTimeMillis();
        log.info(&quot;请求结束时间：{}&quot; + LocalDateTime.now());
        log.info(&quot;请求耗时：{}&quot; + (endTime - startTime));
        // 处理完请求，返回内容
        log.info(&quot;请求返回 : {}&quot; + ret);
    }

    /**
     * 异常通知：
     * 1. 在目标方法非正常结束，发生异常或者抛出异常时执行
     * 1. 在异常通知中设置异常信息，并将其保存
     *
     * @param throwable
     */
    @AfterThrowing(value = &quot;webLogPointcut()&quot;, throwing = &quot;throwable&quot;)
    public void doAfterThrowing(Throwable throwable) {
        // 保存异常日志记录
        log.error(&quot;发生异常时间：{}&quot; + LocalDateTime.now());
        log.error(&quot;抛出异常：{}&quot; + throwable.getMessage());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编写测试&quot;&gt;2.3 编写测试&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/log&quot;)
public class LogbackController {

    /**
     * 测试正常请求
     * @param msg
     * @return
     */
    @GetMapping(&quot;/{msg}&quot;)
    public String getMsg(@PathVariable String msg) {
        return &quot;request msg : &quot; + msg;
    }

    /**
     * 测试抛异常
     * @return
     */
    @GetMapping(&quot;/test&quot;)
    public String getException(){
        // 故意造出一个异常
        Integer.parseInt(&quot;abc123&quot;);
        return &quot;success&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;before和afterreturning部分也可使用以下代码替代&quot;&gt;2.4 &lt;code&gt;@Before&lt;/code&gt;和&lt;code&gt;@AfterReturning&lt;/code&gt;部分也可使用以下代码替代&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 在执行方法前后调用Advice，这是最常用的方法，相当于@Before和@AfterReturning全部做的事儿
     * @param pjp
     * @return
     * @throws Throwable
     */
    @Around(&quot;webLogPointcut()&quot;)
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable {
        // 接收到请求，记录请求内容
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        //获取请求头中的User-Agent
        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(&quot;User-Agent&quot;));
        //打印请求的内容
        startTime = System.currentTimeMillis();
        log.info(&quot;请求Url : {}&quot; , request.getRequestURL().toString());
        log.info(&quot;请求方式 : {}&quot; , request.getMethod());
        log.info(&quot;请求ip : {}&quot; , request.getRemoteAddr());
        log.info(&quot;请求方法 : &quot; , pjp.getSignature().getDeclaringTypeName() , &quot;.&quot; , pjp.getSignature().getName());
        log.info(&quot;请求参数 : {}&quot; , Arrays.toString(pjp.getArgs()));
    // 系统信息
        log.info(&quot;浏览器：{}&quot;, userAgent.getBrowser().toString());
        log.info(&quot;浏览器版本：{}&quot;,userAgent.getBrowserVersion());
        log.info(&quot;操作系统: {}&quot;, userAgent.getOperatingSystem().toString());
        // pjp.proceed()：当我们执行完切面代码之后，还有继续处理业务相关的代码。proceed()方法会继续执行业务代码，并且其返回值，就是业务处理完成之后的返回值。
        Object ret = pjp.proceed();
        log.info(&quot;请求结束时间：&quot;+ LocalDateTime.now());
        log.info(&quot;请求耗时：{}&quot; , (System.currentTimeMillis() - startTime));
        // 处理完请求，返回内容
        log.info(&quot;请求返回 : &quot; , ret);
        return ret;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三-测试&quot;&gt;三、 测试&lt;/h3&gt;
&lt;h4 id=&quot;请求入口logbackcontroller.java&quot;&gt;3.1 请求入口&lt;code&gt;LogbackController.java&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/log&quot;)
public class LogbackController {

    /**
     * 测试正常请求
     * @param msg
     * @return
     */
    @GetMapping(&quot;/normal/{msg}&quot;)
    public String getMsg(@PathVariable String msg) {
        return msg;
    }

    /**
     * 测试抛异常
     * @return
     */
    @GetMapping(&quot;/exception/{msg}&quot;)
    public String getException(@PathVariable String msg){
        // 故意造出一个异常
        Integer.parseInt(&quot;abc123&quot;);
        return msg;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试正常请求&quot;&gt;3.2 测试正常请求&lt;/h4&gt;
&lt;p&gt;打开浏览器，访问&lt;a href=&quot;http://localhost:8082/log/normal/hello&quot; class=&quot;uri&quot;&gt;http://localhost:8082/log/normal/hello&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;日志打印如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [65] [INFO ] 请求开始时间：2019-02-24T22:37:50.892
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [66] [INFO ] 请求Url : http://localhost:8082/log/normal/hello
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [67] [INFO ] 请求方式 : GET
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [68] [INFO ] 请求ip : 0:0:0:0:0:0:0:1
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [69] [INFO ] 请求方法 : 
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [70] [INFO ] 请求参数 : [hello]
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [72] [INFO ] 浏览器：CHROME
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [73] [INFO ] 浏览器版本：76.0.3809.100
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [74] [INFO ] 操作系统: MAC_OS_X
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [88] [INFO ] 请求结束时间：2019-02-24T22:37:50.901
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [89] [INFO ] 请求耗时：14
[2019-02-24 22:37:50.050] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-1] [91] [INFO ] 请求返回 : hello&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试异常情况&quot;&gt;3.3 测试异常情况&lt;/h4&gt;
&lt;p&gt;访问：&lt;a href=&quot;http://localhost:8082/log/exception/hello&quot; class=&quot;uri&quot;&gt;http://localhost:8082/log/exception/hello&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [65] [INFO ] 请求开始时间：2019-02-24T22:39:57.728
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [66] [INFO ] 请求Url : http://localhost:8082/log/exception/hello
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [67] [INFO ] 请求方式 : GET
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [68] [INFO ] 请求ip : 0:0:0:0:0:0:0:1
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [69] [INFO ] 请求方法 : 
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [70] [INFO ] 请求参数 : [hello]
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [72] [INFO ] 浏览器：CHROME
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [73] [INFO ] 浏览器版本：76.0.3809.100
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [74] [INFO ] 操作系统: MAC_OS_X
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [104] [ERROR] 发生异常时间：2019-02-24T22:39:57.731
[2019-02-24 22:39:57.057] [cn.van.log.aop.aspect.WebLogAspect] [http-nio-8082-exec-9] [105] [ERROR] 抛出异常：For input string: &quot;abc123&quot;
[2019-02-24 22:39:57.057] [org.apache.juli.logging.DirectJDKLog] [http-nio-8082-exec-9] [175] [ERROR] Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NumberFormatException: For input string: &quot;abc123&quot;] with root cause
java.lang.NumberFormatException: For input string: &quot;abc123&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四源码&quot;&gt;四、源码&lt;/h3&gt;
&lt;h4 id=&quot;示例代码&quot;&gt;4.1 示例代码&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/vanDusty/SpringBoot-Home/tree/master/springboot-demo-logback/log-aop&quot;&gt;Github 示例代码&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 24 Aug 2019 15:21:00 +0000</pubDate>
<dc:creator>风尘博客</dc:creator>
<og:description>在项目开发中，日志系统是必不可少的，用`AOP`在Web的请求做入参和出参的参数打印，同时对异常进行日志打印，避免重复的手写日志，完整案例见文末源码。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vandusty/p/11406536.html</dc:identifier>
</item>
</channel>
</rss>