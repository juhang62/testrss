<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Boot 2.x（六）：优雅的统一返回值 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/10188456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/10188456.html</guid>
<description>&lt;h3 id=&quot;为什么要统一返回值&quot;&gt;为什么要统一返回值&lt;/h3&gt;
&lt;p&gt;在我们做后端应用的时候，前后端分离的情况下，我们经常会定义一个数据格式，通常会包含&lt;code&gt;code&lt;/code&gt;，&lt;code&gt;message&lt;/code&gt;，&lt;code&gt;data&lt;/code&gt;这三个必不可少的信息来方便我们的交流，下面我们直接来看代码&lt;/p&gt;
&lt;h3 id=&quot;returnvo&quot;&gt;ReturnVO&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package indi.viyoung.viboot.util;

import java.util.Properties;

/**
 * 统一定义返回类
 *
 * @author yangwei
 * @since 2018/12/20
 */
public class ReturnVO {

    private static final Properties properties = ReadPropertiesUtil.getProperties(System.getProperty(&quot;user.dir&quot;) + &quot;/viboot-common/src/main/resources/response.properties&quot;);

    /**
     * 返回代码
     */
    private String code;

    /**
     * 返回信息
     */
    private String message;

    /**
     * 返回数据
     */
    private Object data;


    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    /**
     * 默认构造，返回操作正确的返回代码和信息
     */
    public ReturnVO() {
        this.setCode(properties.getProperty(ReturnCode.SUCCESS.val()));
        this.setMessage(properties.getProperty(ReturnCode.SUCCESS.msg()));
    }

    /**
     * 构造一个返回特定代码的ReturnVO对象
     * @param code
     */
    public ReturnVO(ReturnCode code) {
        this.setCode(properties.getProperty(code.val()));
        this.setMessage(properties.getProperty(code.msg()));
    }

    /**
     * 默认值返回，默认返回正确的code和message
     * @param data
     */
    public ReturnVO(Object data) {
        this.setCode(properties.getProperty(ReturnCode.SUCCESS.val()));
        this.setMessage(properties.getProperty(ReturnCode.SUCCESS.msg()));
        this.setData(data);
    }

    /**
     * 构造返回代码，以及自定义的错误信息
     * @param code
     * @param message
     */
    public ReturnVO(ReturnCode code, String message) {
        this.setCode(properties.getProperty(code.val()));
        this.setMessage(message);
    }

    /**
     * 构造自定义的code，message，以及data
     * @param code
     * @param message
     * @param data
     */
    public ReturnVO(ReturnCode code, String message, Object data) {
        this.setCode(code.val());
        this.setMessage(message);
        this.setData(data);
    }

    @Override
    public String toString() {
        return &quot;ReturnVO{&quot; +
                &quot;code='&quot; + code + '\'' +
                &quot;, message='&quot; + message + '\'' +
                &quot;, data=&quot; + data +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我提供了几个构造方法以供不同情况下使用。代码的注释已经写得很清楚了，大家也可以应该看的比较清楚~&lt;/p&gt;
&lt;h3 id=&quot;returncode&quot;&gt;ReturnCode&lt;/h3&gt;
&lt;p&gt;细心的同学可能发现了，我单独定义了一个&lt;code&gt;ReturnCode&lt;/code&gt;枚举类用于存储代码和返回的Message：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package indi.viyoung.viboot.util;

/**
 * @author yangwei
 * @since 2018/12/20
 */
public enum ReturnCode {

    /** 操作成功 */
    SUCCESS(&quot;SUCCESS_CODE&quot;, &quot;SUCCESS_MSG&quot;),

    /** 操作失败 */
    FAIL(&quot;FAIL_CODE&quot;, &quot;FAIL_MSG&quot;),

    /** 空指针异常 */
    NullpointerException(&quot;NPE_CODE&quot;, &quot;NPE_MSG&quot;),

    /** 自定义异常之返回值为空 */
    NullResponseException(&quot;NRE_CODE&quot;, &quot;NRE_MSG&quot;);


    private ReturnCode(String value, String msg){
        this.val = value;
        this.msg = msg;
    }

    public String val() {
        return val;
    }

    public String msg() {
        return msg;
    }

    private String val;
    private String msg;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我并没有将需要存储的数据直接放到枚举中，而是放到了一个配置文件中，这样既可以方便我们进行相关信息的修改，并且阅读起来也是比较方便。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;SUCCESS_CODE=2000
SUCCESS_MSG=操作成功

FAIL_CODE=5000
FAIL_MSG=操作失败

NPE_CODE=5001
NPE_MSG=空指针异常

NRE_CODE=5002
NRE_MSG=返回值为空&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，这里的属性名和属性值分别与枚举类中的value和msg相对应，这样，我们才可以方便的去通过I/O流去读取。&lt;/p&gt;
&lt;p&gt;这里需要注意一点，如果你使用的是IDEA编辑器，需要修改以下的配置，这样你编辑配置文件的时候写的是中文，实际上保存的是ASCII字节码。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181226215648564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面，来看一下读取的工具类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package indi.viyoung.viboot.util;

import java.io.*;
import java.util.Iterator;
import java.util.Properties;

/**
 * 读取*.properties中的属性
 * @author vi
 * @since 2018/12/24 7:33 PM
 */
public class ReadPropertiesUtil {

    public static Properties getProperties(String propertiesPath){
        Properties properties = new Properties();
        try {
            InputStream inputStream = new BufferedInputStream(new FileInputStream(propertiesPath));
            properties.load(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return properties;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我直接写了一个静态的方法，传入的参数是properties文件的位置，这样的话，本文最初代码中的也就得到了解释。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private static final Properties properties = ReadPropertiesUtil.getProperties(System.getProperty(&quot;user.dir&quot;) + &quot;/viboot-common/src/main/resources/response.properties&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用returnvo&quot;&gt;使用ReturnVO&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RequestMapping(&quot;/test&quot;)
    public ReturnVO test(){
        try {
           //省略
            //省略
        }  catch (Exception e) {
            e.printStackTrace();
        }
        return new ReturnVO();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们可以去访问这个接口，看看会得到什么：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181226220453427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;但是，现在问题又来了，因为&lt;code&gt;try...catch...&lt;/code&gt;的存在，总是会让代码变得重复度很高，一个接口你都至少要去花三到十秒去写这个接口，如果不知道编辑器的快捷键，更是一种噩梦。我们只想全心全意的去关注实现业务，而不是花费大量的时间在编写一些重复的&quot;刚需&quot;代码上。&lt;/p&gt;
&lt;h3 id=&quot;使用aop进行全局异常的处理&quot;&gt;使用AOP进行全局异常的处理&lt;/h3&gt;
&lt;p&gt;（这里，我只是对全局异常处理进行一个简单的讲解，后面也就是下一节中会详细的讲述）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 统一封装返回值和异常处理
 *
 * @author vi
 * @since 2018/12/20 6:09 AM
 */
@Slf4j
@Aspect
@Order(5)
@Component
public class ResponseAop {

    private static final Properties properties = ReadPropertiesUtil.getProperties(System.getProperty(&quot;user.dir&quot;) + &quot;/viboot-common/src/main/resources/response.properties&quot;);

    /**
     * 切点
     */
    @Pointcut(&quot;execution(public * indi.viyoung.viboot.*.controller..*(..))&quot;)
    public void httpResponse() {
    }

    /**
     * 环切
     */
    @Around(&quot;httpResponse()&quot;)
    public ReturnVO handlerController(ProceedingJoinPoint proceedingJoinPoint) {
        ReturnVO returnVO = new ReturnVO();
        try {
             //获取方法的执行结果
            Object proceed = proceedingJoinPoint.proceed();
            //如果方法的执行结果是ReturnVO，则将该对象直接返回
            if (proceed instanceof ReturnVO) {
                returnVO = (ReturnVO) proceed;
            } else {
                //否则，就要封装到ReturnVO的data中
                returnVO.setData(proceed);
            }
        }  catch (Throwable throwable) {
             //如果出现了异常，调用异常处理方法将错误信息封装到ReturnVO中并返回
            returnVO = handlerException(throwable);
        }
        return returnVO;
    }
    
    /**
     * 异常处理
     */ 
    private ReturnVO handlerException(Throwable throwable) {
        ReturnVO returnVO = new ReturnVO();
        //这里需要注意，返回枚举类中的枚举在写的时候应该和异常的名称相对应，以便动态的获取异常代码和异常信息
        //获取异常名称的方法
        String errorName = throwable.toString();
        errorName = errorName.substring(errorName.lastIndexOf(&quot;.&quot;) + 1);
        //直接获取properties文件中的内容
         returnVO.setMessage(properties.getProperty(ReturnCode.valueOf(errorName).msg()));
        returnVO.setCode(properties.getProperty(ReturnCode.valueOf(errorName).val()));
        return returnVO;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果，我们需要在每一个项目中都可以这么去做，需要将这个类放到一个公用的模块中，然后在pom中导入这个模块&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;indi.viyoung.course&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;viboot-common&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意一点，必须保证你的切点的正确书写！！否则就会导致切点无效，同时需要在启动类中配置：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ComponentScan(value = &quot;indi.viyoung.viboot.*&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入的正是&lt;code&gt;common&lt;/code&gt;包下的所有文件，以保证可以将&lt;code&gt;ResponseAop&lt;/code&gt;这个类加载到Spring的容器中。&lt;/p&gt;
&lt;p&gt;下面我们来测试一下，访问我们经过修改后的编写的&lt;code&gt;findAll&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RequestMapping(&quot;/findAll&quot;)
    public Object findAll(){
        return userService.list();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：这里我将返回值统一为&lt;strong&gt;Object&lt;/strong&gt;，以便数据存入&lt;code&gt;data&lt;/code&gt;，实际类型应是&lt;code&gt;Service&lt;/code&gt;接口的返回类型。如果没有返回值的话，那就可以&lt;code&gt;new&lt;/code&gt;一个&lt;code&gt;ReturnVO&lt;/code&gt;对象直接通过构造方法赋值即可。关于返回类型为&lt;code&gt;ReturnVO&lt;/code&gt;的判断，代码中也已经做了特殊的处理，并非存入&lt;code&gt;data&lt;/code&gt;，而是直接返回。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181226222309936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;下面，我们修改一下test方法，让他抛出一个我们自定义的查询返回值为空的异常：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RequestMapping(&quot;/test&quot;)
    public ReturnVO test(){
        throw new NullResponseException();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面，我们再来访问以下test接口：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181226222512701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;可以看到，正如我们properties中定义的那样，我们得到了我们想要的消息。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;源码可以去&lt;a href=&quot;https://github.com/viyog/viboot/&quot;&gt;github&lt;/a&gt;或者&lt;a href=&quot;https://gitee.com/yw18530069930/viboot&quot;&gt;码云&lt;/a&gt;上进行下载，后续的例子都会同步更新。&lt;/p&gt;
&lt;h3 id=&quot;云撸猫&quot;&gt;云撸猫&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181228073602772.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181228073632641.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;---恢复内容结束---&lt;/p&gt;
&lt;h3 id=&quot;为什么要统一返回值-1&quot;&gt;为什么要统一返回值&lt;/h3&gt;
&lt;p&gt;在我们做后端应用的时候，前后端分离的情况下，我们经常会定义一个数据格式，通常会包含&lt;code&gt;code&lt;/code&gt;，&lt;code&gt;message&lt;/code&gt;，&lt;code&gt;data&lt;/code&gt;这三个必不可少的信息来方便我们的交流，下面我们直接来看代码&lt;/p&gt;
&lt;h3 id=&quot;returnvo-1&quot;&gt;ReturnVO&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package indi.viyoung.viboot.util;

import java.util.Properties;

/**
 * 统一定义返回类
 *
 * @author yangwei
 * @since 2018/12/20
 */
public class ReturnVO {

    private static final Properties properties = ReadPropertiesUtil.getProperties(System.getProperty(&quot;user.dir&quot;) + &quot;/viboot-common/src/main/resources/response.properties&quot;);

    /**
     * 返回代码
     */
    private String code;

    /**
     * 返回信息
     */
    private String message;

    /**
     * 返回数据
     */
    private Object data;


    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    /**
     * 默认构造，返回操作正确的返回代码和信息
     */
    public ReturnVO() {
        this.setCode(properties.getProperty(ReturnCode.SUCCESS.val()));
        this.setMessage(properties.getProperty(ReturnCode.SUCCESS.msg()));
    }

    /**
     * 构造一个返回特定代码的ReturnVO对象
     * @param code
     */
    public ReturnVO(ReturnCode code) {
        this.setCode(properties.getProperty(code.val()));
        this.setMessage(properties.getProperty(code.msg()));
    }

    /**
     * 默认值返回，默认返回正确的code和message
     * @param data
     */
    public ReturnVO(Object data) {
        this.setCode(properties.getProperty(ReturnCode.SUCCESS.val()));
        this.setMessage(properties.getProperty(ReturnCode.SUCCESS.msg()));
        this.setData(data);
    }

    /**
     * 构造返回代码，以及自定义的错误信息
     * @param code
     * @param message
     */
    public ReturnVO(ReturnCode code, String message) {
        this.setCode(properties.getProperty(code.val()));
        this.setMessage(message);
    }

    /**
     * 构造自定义的code，message，以及data
     * @param code
     * @param message
     * @param data
     */
    public ReturnVO(ReturnCode code, String message, Object data) {
        this.setCode(code.val());
        this.setMessage(message);
        this.setData(data);
    }

    @Override
    public String toString() {
        return &quot;ReturnVO{&quot; +
                &quot;code='&quot; + code + '\'' +
                &quot;, message='&quot; + message + '\'' +
                &quot;, data=&quot; + data +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我提供了几个构造方法以供不同情况下使用。代码的注释已经写得很清楚了，大家也可以应该看的比较清楚~&lt;/p&gt;
&lt;h3 id=&quot;returncode-1&quot;&gt;ReturnCode&lt;/h3&gt;
&lt;p&gt;细心的同学可能发现了，我单独定义了一个&lt;code&gt;ReturnCode&lt;/code&gt;枚举类用于存储代码和返回的Message：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package indi.viyoung.viboot.util;

/**
 * @author yangwei
 * @since 2018/12/20
 */
public enum ReturnCode {

    /** 操作成功 */
    SUCCESS(&quot;SUCCESS_CODE&quot;, &quot;SUCCESS_MSG&quot;),

    /** 操作失败 */
    FAIL(&quot;FAIL_CODE&quot;, &quot;FAIL_MSG&quot;),

    /** 空指针异常 */
    NullpointerException(&quot;NPE_CODE&quot;, &quot;NPE_MSG&quot;),

    /** 自定义异常之返回值为空 */
    NullResponseException(&quot;NRE_CODE&quot;, &quot;NRE_MSG&quot;);


    private ReturnCode(String value, String msg){
        this.val = value;
        this.msg = msg;
    }

    public String val() {
        return val;
    }

    public String msg() {
        return msg;
    }

    private String val;
    private String msg;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我并没有将需要存储的数据直接放到枚举中，而是放到了一个配置文件中，这样既可以方便我们进行相关信息的修改，并且阅读起来也是比较方便。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;SUCCESS_CODE=2000
SUCCESS_MSG=操作成功

FAIL_CODE=5000
FAIL_MSG=操作失败

NPE_CODE=5001
NPE_MSG=空指针异常

NRE_CODE=5002
NRE_MSG=返回值为空&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，这里的属性名和属性值分别与枚举类中的value和msg相对应，这样，我们才可以方便的去通过I/O流去读取。&lt;/p&gt;
&lt;p&gt;这里需要注意一点，如果你使用的是IDEA编辑器，需要修改以下的配置，这样你编辑配置文件的时候写的是中文，实际上保存的是ASCII字节码。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181226215648564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面，来看一下读取的工具类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package indi.viyoung.viboot.util;

import java.io.*;
import java.util.Iterator;
import java.util.Properties;

/**
 * 读取*.properties中的属性
 * @author vi
 * @since 2018/12/24 7:33 PM
 */
public class ReadPropertiesUtil {

    public static Properties getProperties(String propertiesPath){
        Properties properties = new Properties();
        try {
            InputStream inputStream = new BufferedInputStream(new FileInputStream(propertiesPath));
            properties.load(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return properties;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我直接写了一个静态的方法，传入的参数是properties文件的位置，这样的话，本文最初代码中的也就得到了解释。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private static final Properties properties = ReadPropertiesUtil.getProperties(System.getProperty(&quot;user.dir&quot;) + &quot;/viboot-common/src/main/resources/response.properties&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用returnvo-1&quot;&gt;使用ReturnVO&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RequestMapping(&quot;/test&quot;)
    public ReturnVO test(){
        try {
           //省略
            //省略
        }  catch (Exception e) {
            e.printStackTrace();
        }
        return new ReturnVO();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们可以去访问这个接口，看看会得到什么：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181226220453427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;但是，现在问题又来了，因为&lt;code&gt;try...catch...&lt;/code&gt;的存在，总是会让代码变得重复度很高，一个接口你都至少要去花三到十秒去写这个接口，如果不知道编辑器的快捷键，更是一种噩梦。我们只想全心全意的去关注实现业务，而不是花费大量的时间在编写一些重复的&quot;刚需&quot;代码上。&lt;/p&gt;
&lt;h3 id=&quot;使用aop进行全局异常的处理-1&quot;&gt;使用AOP进行全局异常的处理&lt;/h3&gt;
&lt;p&gt;（这里，我只是对全局异常处理进行一个简单的讲解，后面也就是下一节中会详细的讲述）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 统一封装返回值和异常处理
 *
 * @author vi
 * @since 2018/12/20 6:09 AM
 */
@Slf4j
@Aspect
@Order(5)
@Component
public class ResponseAop {

    private static final Properties properties = ReadPropertiesUtil.getProperties(System.getProperty(&quot;user.dir&quot;) + &quot;/viboot-common/src/main/resources/response.properties&quot;);

    /**
     * 切点
     */
    @Pointcut(&quot;execution(public * indi.viyoung.viboot.*.controller..*(..))&quot;)
    public void httpResponse() {
    }

    /**
     * 环切
     */
    @Around(&quot;httpResponse()&quot;)
    public ReturnVO handlerController(ProceedingJoinPoint proceedingJoinPoint) {
        ReturnVO returnVO = new ReturnVO();
        try {
             //获取方法的执行结果
            Object proceed = proceedingJoinPoint.proceed();
            //如果方法的执行结果是ReturnVO，则将该对象直接返回
            if (proceed instanceof ReturnVO) {
                returnVO = (ReturnVO) proceed;
            } else {
                //否则，就要封装到ReturnVO的data中
                returnVO.setData(proceed);
            }
        }  catch (Throwable throwable) {
             //如果出现了异常，调用异常处理方法将错误信息封装到ReturnVO中并返回
            returnVO = handlerException(throwable);
        }
        return returnVO;
    }
    
    /**
     * 异常处理
     */ 
    private ReturnVO handlerException(Throwable throwable) {
        ReturnVO returnVO = new ReturnVO();
        //这里需要注意，返回枚举类中的枚举在写的时候应该和异常的名称相对应，以便动态的获取异常代码和异常信息
        //获取异常名称的方法
        String errorName = throwable.toString();
        errorName = errorName.substring(errorName.lastIndexOf(&quot;.&quot;) + 1);
        //直接获取properties文件中的内容
         returnVO.setMessage(properties.getProperty(ReturnCode.valueOf(errorName).msg()));
        returnVO.setCode(properties.getProperty(ReturnCode.valueOf(errorName).val()));
        return returnVO;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果，我们需要在每一个项目中都可以这么去做，需要将这个类放到一个公用的模块中，然后在pom中导入这个模块&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;indi.viyoung.course&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;viboot-common&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意一点，必须保证你的切点的正确书写！！否则就会导致切点无效，同时需要在启动类中配置：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ComponentScan(value = &quot;indi.viyoung.viboot.*&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入的正是&lt;code&gt;common&lt;/code&gt;包下的所有文件，以保证可以将&lt;code&gt;ResponseAop&lt;/code&gt;这个类加载到Spring的容器中。&lt;/p&gt;
&lt;p&gt;下面我们来测试一下，访问我们经过修改后的编写的&lt;code&gt;findAll&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RequestMapping(&quot;/findAll&quot;)
    public Object findAll(){
        return userService.list();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：这里我将返回值统一为&lt;strong&gt;Object&lt;/strong&gt;，以便数据存入&lt;code&gt;data&lt;/code&gt;，实际类型应是&lt;code&gt;Service&lt;/code&gt;接口的返回类型。如果没有返回值的话，那就可以&lt;code&gt;new&lt;/code&gt;一个&lt;code&gt;ReturnVO&lt;/code&gt;对象直接通过构造方法赋值即可。关于返回类型为&lt;code&gt;ReturnVO&lt;/code&gt;的判断，代码中也已经做了特殊的处理，并非存入&lt;code&gt;data&lt;/code&gt;，而是直接返回。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181226222309936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;下面，我们修改一下test方法，让他抛出一个我们自定义的查询返回值为空的异常：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RequestMapping(&quot;/test&quot;)
    public ReturnVO test(){
        throw new NullResponseException();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面，我们再来访问以下test接口：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181226222512701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;可以看到，正如我们properties中定义的那样，我们得到了我们想要的消息。&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/p&gt;
&lt;p&gt;源码可以去&lt;a href=&quot;https://github.com/viyog/viboot/&quot;&gt;github&lt;/a&gt;或者&lt;a href=&quot;https://gitee.com/yw18530069930/viboot&quot;&gt;码云&lt;/a&gt;上进行下载，后续的例子都会同步更新。&lt;/p&gt;
&lt;h3 id=&quot;云撸猫-1&quot;&gt;云撸猫&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181228073602772.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;公众号-1&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181228073632641.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 23:45:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>为什么要统一返回值 在我们做后端应用的时候，前后端分离的情况下，我们经常会定义一个数据格式，通常会包含 ，`message data`这三个必不可少的信息来方便我们的交流，下面我们直接来看代码 Ret</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viyoung/p/10188456.html</dc:identifier>
</item>
<item>
<title>集合基础 - J.FengS</title>
<link>http://www.cnblogs.com/fjfsu/p/10182902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fjfsu/p/10182902.html</guid>
<description>&lt;h2&gt;集合类的由来：&lt;/h2&gt;
&lt;p&gt;     JAVA是面向对象的，对象用来封装特有数据，对象多了就需要储存起来，当对象的个数不确定的时候，那么就用集合容器进行存储。&lt;/p&gt;
&lt;h2&gt;集合的特点：&lt;/h2&gt;
&lt;p&gt;　　1.集合的长度是可变的&lt;/p&gt;
&lt;p&gt;　　2.用于存储对象的容器&lt;/p&gt;
&lt;p&gt;　　3.不可以存储基本数据类型&lt;/p&gt;
&lt;h2&gt;体系：&lt;/h2&gt;
&lt;p&gt;　　集合容器因为内部的数据结构不同，有多种具体容器，不断的向上提取，形成了集合框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344326/201812/1344326-20181227022313055-757893177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; Collection接口：&lt;/h2&gt;
&lt;p&gt;　　常见的方法&lt;/p&gt;
&lt;p&gt;　　1.增加 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
boolean add（Object obj）//添加一个对象
boolean addAll（Collection coll）//添加一个集合
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
boolean remove(Object Obj)//删除一个对象
boolean removeAll(Collection coll)删除集合中所有与coll相同的对象
void clear()清空
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.判断&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
boolean contains(Object Obj)//判断一个对象是否存在
boolean containsAll(Collection coll)//判断集合中是否拥有coll总的所有对象
boolean isEmpty()//奇怪的很，没有元素返回true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size()//获取对象的个数
Iterator iterator()//获取对象，下面的代码是这个方法的实现&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Iterator接口&lt;/h3&gt;
&lt;p&gt;　　对集合进行迭代迭代器&lt;/p&gt;
&lt;p&gt;　　这个接口是对所有的Collection容器进行元素获取的公共接口&lt;/p&gt;
&lt;p&gt;　　hasNext（）如果next仍然有元素可以迭代，就返回true&lt;/p&gt;
&lt;p&gt;　　next（）返回迭代的下一个元素&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
            Iterator it = coll.iterator();
            while(it.hasNext()){
                System.out.println(it.next());
            }        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：节约空间，常用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
for(Iterator it = coll.iterator();it.hasNext();){
                        System.out.println(it.next());
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种迭代的获取与直接打印( print(coll) )的区别在于，打印的是一串字符串，而迭代取得是单独的对象，可以对他们单独处理&lt;/p&gt;
&lt;p&gt;　　5.其他&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
boolean retainAll（Collection coll）//取交集，删除与coll集合中不同的元素
Object  toArray()//将集合转成数组
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;List:&lt;/h2&gt;
&lt;p&gt;　　1.有序（存入和取出顺序一致）&lt;/p&gt;
&lt;p&gt;　　2.元素都有索引（脚标）&lt;/p&gt;
&lt;p&gt;　　3.元素可以重复&lt;/p&gt;
&lt;p&gt;常用子类：&lt;/p&gt;
&lt;p&gt;　　1.Vector：内部是数组数据结构，同步的，增删查询都很慢。（基本淘汰）&lt;/p&gt;
&lt;p&gt;　　2.ArrayList:内部是数组数据结构，不同步的，代替了Vector。查询很快&lt;/p&gt;
&lt;p&gt;　　3.LinkedList:内部是链表数据结构的，不同步的。增删很快&lt;/p&gt;
&lt;p&gt;常见的方法：&lt;/p&gt;
&lt;p&gt;　　1.添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
void add(index,element)//在指定的位置插入对象
void add(index,collection)//在指定的位置插入集合
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Object remove(index)//删除指定位置的对象，返回值为被删除的对象
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.修改（只有List才具有增删改查，collection都不具备）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Object set(index,element)//返回值为被修改的对象，即修改前的对象
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Object get(index)//返回值为获取的对象
List subList(from,to)//返回指定范围的对象&lt;br/&gt;int indexOf(Object)//返回对象的位置，从头开始找&lt;br/&gt;int lastIndexOf(Object)//返回对象的位置，从尾开始找
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;list特有的取出元素的方法（只有list有set不具备）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
           for(int x=0;x&amp;lt;list.size();x++){
                        System.out.println(list.get(x));
                }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;ListIterator:&lt;/h2&gt;
&lt;p&gt;　　1.Iterator的子接口&lt;/p&gt;
&lt;p&gt;　　2.可以实现在迭代过程中完成对元素的操作（增删改查）注意：只有List集合具备该迭代功能&lt;/p&gt;
&lt;p&gt;如果有下面的代码（在迭代的过程中，增加元素）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
            Iterator it =list.iterator();
                 while(it.hasNext()){
                         Object obj=it.next();
                         if(obj==&quot;b&quot;){
                                 list.add(&quot;e&quot;);
                         }else{
                                 System.out.println(obj);
                         }
                 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里会发生异常，原因是在迭代的过程中，操作集合，产生了并发。&lt;/p&gt;
&lt;p&gt;解决问题：&lt;/p&gt;
&lt;p&gt;　　1.在迭代的时候不能操作集合，容易产生异常&lt;/p&gt;
&lt;p&gt;　　2.使用ListIterator接口来完成在迭代过程中对元素的更多的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
            ListIterator it = list.listIterator();//获取列表迭代器对象
                 while(it.hasNext()){
                         Object obj=it.next();
                         if(obj==&quot;b&quot;){
                                 it.add(&quot;e&quot;);
                                 System.out.println(obj);
                         }else{
                                 System.out.println(obj);
                         }
                 }
                 while(it.hasPrevious()){//如果前一个任然有元素可以迭代，那么就返回true
                         System.out.println(it.previous());//返回前一个元素
                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;Vector：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　Enumeration：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　　　​ 1.这个接口淘汰了，基本不用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　2.这个接口的功能与Iterator接口的功能是重复来的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　3.Iterator接口添加了一个可选的移除操作，并且使用了较短的方法名。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　​ 　　4.新的实现应该考虑优先使用Iterator接口而不是Eumeration接口&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　elements:这个方法与List中的iterator方法有异曲同工之妙&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
        Vector ve=new Vector();
        ve.addElement(&quot;a&quot;);
        ve.addElement(&quot;b&quot;);
        ve.addElement(&quot;c&quot;);
        Enumeration em=ve.elements();
        while(em.hasMoreElements()){
            System.out.println(em.nextElement());
        }
        Iterator it=ve.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
//这两个方法的作用基本一样，但是前一种基本上是淘汰了
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;LinkedList:&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　1.内部是链表数据结构，是不同步的，增删很快&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​　　 2.堆栈：先进后出&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　  队列：先进先出&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　3.常用方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　增加：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　　　　　​ boolean add（ Collection&amp;lt;? extends E&amp;gt; c）//在结尾添加一个元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　　　boolean addAll（int index, Collection&amp;lt;? extends E&amp;gt; c）//在指定位置插入一个集合&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　　　void addFirst（E o）//在开头加入一个元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　　　　　​ void addLast（E o）//在结尾加入一个元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　删除：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　　　　　​ void clear()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​　　　　　　 E remove()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　获取:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　　　　　​ E getFirst()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　　　E peek();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　修改：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　　　Object set(index,Objcet)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;ArrayList:&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;下面的代码中的强转问题，可能会涉及到自动装箱问题，在这里也是可以使用的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
        ArrayList ar=new ArrayList();
        Person a=new Person(19,&quot;lao1&quot;);
        Person b=new Person(16,&quot;lao2&quot;);
        Person c=new Person(11,&quot;lao3&quot;);
        ar.add(a);
        ar.add(b);
        ar.add(c);
        for(Iterator it=ar.iterator();it.hasNext();){
            //System.out.println(((Person)it.next()).getAge()+((Person)it.next()).getName());
            //输出肯定是有问题的一直在next
            //所以解决方法如下
            Person d=(Person) it.next();//强转的原因是，在Aar.add()添加的时候，是使用Object接收的，所以person已经变成了上帝
            System.out.println(d.getAge()+d.getName());
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Set:&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　1.Set接口中的方法和Collection一致&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　​ 2.Set获取元素的方法只有迭代器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​　　 3.常用实现子类HashSet，TreeSet&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　4.元素不可重复，无序（但是可以做到有限的有序）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;HashSet:&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　​ 1.内部数据结构是哈希表，不同步&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　​ 2.如何保证该集合的元素唯一性呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　a.通过对象的hashCode和equals方法来完成对象的唯一性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​　　　　 b.如果对象的hashCode值不同，那么不用判断equals方法，直接存储到嘻哈表中（int hashCode();boolean equals(Object obj)）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　c.如果对象的hashCode值相同，那么要再次判断对象的equals方法是否为true，true则视为相同元素，不存。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　d.重点：如果元素要存储到HashSet集合中，必须覆盖hashCode方法和equals方法；一般情况下如果定义的类会产生很多对象，比如人，学生，书，通常都需要覆盖这两个方法，建立对象判断是否相同的依据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　e.扩展：Arraylist（如果要确保元素唯一的话）判断的依据是equals，而HashSet判断hashcode和equals&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;LinkedHashSet:&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　1.HashSet的直接已知实现子类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　   2.可以在唯一的情况下排序，怎么进就怎么出&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
        HashSet/LinkedHashSet ha=new LinkedHashSet();
        ha.add(&quot;a&quot;);
        ha.add(&quot;d&quot;);
        ha.add(&quot;s&quot;);
        for(Iterator it=ha.iterator();it.hasNext();){
            System.out.println(it.next());
        }
//所以需要有序唯一的话可以直接使用LinkedHashSet类
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;TreeSet：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​　　 1.可以对set集合中的元素排序。是不同步的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　2.判断元素唯一性的方式：就是根据比较方法返回结果是否为0，如果为0，就是相同元素，则不存储（所以要实现Comparable接口，覆盖compareTo方法元素和集合实现都可以；一般在做这一步的时候，也一起把排序给做了）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　3.排序的两种方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　a.让元素自身具备比较功能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　　　b.让集合自身具备比较功能（1.如果不按照对象具备的自然顺序排序2.对象不具备自然顺序；这两种情况时使用该功能）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　4.比较器（即b）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​　　　　 定义一个类实现Comparator接口，覆盖compare方法，将该类对象最为参数传递给TreeSet集合的构造函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 //比较器，按照名字
class ComparatorByName implements Comparator {
        public int compare(Object o1, Object o2) {
            Person p1 = (Person)o1;
            Person p2 = (Person)o2; 
            int temp = p1.getName().compareTo(p2.getName());    
         return temp==0?p1.getAge()-p2.getAge(): temp;
        }
}
​
//比较器，按照年龄
class ComparatorByLength implements Comparator {
    public int compare(Object o1, Object o2) {
        Person s1 = (Person)o1;
        Person s2 = (Person)o2;
        int temp = s1.getAge()-s2.getAge();
        return temp==0? s1.compareTo(s2): temp;
    }
​
}
        TreeSet tr=new TreeSet(new ComparatorByLength());//比较器的使用方法
        Person a=new Person(&quot;lao3&quot;,11);
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Thu, 27 Dec 2018 19:50:00 +0000</pubDate>
<dc:creator>J.FengS</dc:creator>
<og:description>集合类的由来： JAVA是面向对象的，对象用来封装特有数据，对象多了就需要储存起来，当对象的个数不确定的时候，那么就用集合容器进行存储。 集合的特点： 1.集合的长度是可变的 2.用于存储对象的容器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fjfsu/p/10182902.html</dc:identifier>
</item>
<item>
<title>[python] PyMouse、PyKeyboard用python操作鼠标和键盘 - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/10188434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/10188434.html</guid>
<description>
&lt;h4 id=&quot;pyuserinput-简介&quot;&gt;1、PyUserInput 简介&lt;/h4&gt;
&lt;p&gt;PyUserInput是一个使用python的跨平台的操作鼠标和键盘的模块，非常方便使用。支持的平台及依赖如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Linux - Xlib&lt;/li&gt;
&lt;li&gt;Mac - Quartz, AppKit&lt;/li&gt;
&lt;li&gt;Windows - pywin32, pyHook&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;支持python版本：我用的是3.6.7&lt;/p&gt;

&lt;h4 id=&quot;安装&quot;&gt;2、安装&lt;/h4&gt;
&lt;p&gt;直接源码安装，python3加持：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/PyUserInput/PyUserInput.git
cd PyUserInput
sudo python3 setup.py install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 推荐用python3&lt;/p&gt;

&lt;h4 id=&quot;入门&quot;&gt;3、入门&lt;/h4&gt;
&lt;p&gt;实例化一个鼠标和键盘对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from pymouse import PyMouse
from pykeyboard import PyKeyboard

m = PyMouse()
k = PyKeyboard()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;点击屏幕中间并输入&quot;hello world&quot;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x_dim, y_dim = m.screen_size()
m.click(x_dim//2, y_dim//2, 1)      #取整除 - 向下取接近除数的整数
k.type_string('Hello, World!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;PyKeyboard支持多种输入方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# pressing a key
k.press_key('H')
# which you then follow with a release of the key
k.release_key('H')
# or you can 'tap' a key which does both
k.tap_key('e')
# note that that tap_key does support a way of repeating keystrokes with a interval time between each
k.tap_key('l',n=2,interval=5)
# and you can send a string if needed too
k.type_string('o World!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;并且支持各种特殊的按键输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#Create an Alt+Tab combo
k.press_key(k.alt_key)
k.tap_key(k.tab_key)
k.release_key(k.alt_key)

k.tap_key(k.function_keys[5])  # Tap F5
k.tap_key(k.numpad_keys['Home'])  # Tap 'Home' on the numpad
k.tap_key(k.numpad_keys[5], n=3)  # Tap 5 on the numpad, thrice&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;pymouse项目分析&quot;&gt;4、PyMouse项目分析&lt;/h4&gt;
&lt;p&gt;PyUserInput开源项目维护的不太好，是将之前的PyMouse和PyKeyboard项目合到一起，而且竟然把人家之前的DEMO给删了！！！为了体验原汁原味的PyMouse我们还是单独分析吧 &lt;a href=&quot;https://github.com/pepijndevos/PyMouse&quot;&gt;&lt;strong&gt;LINK-6&lt;/strong&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;下面的一个例子展示了PyMouse的经典用法，主要用来操作鼠标 &lt;a href=&quot;https://github.com/SavinaRoja/PyUserInput/wiki/PyMouse&quot;&gt;&lt;strong&gt;LINK-4&lt;/strong&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# import the module
from pymouse import PyMouse

# instantiate an mouse object
m = PyMouse()

# move the mouse to int x and int y (these are absolute positions)
m.move(200, 200)

# click works about the same, except for int button possible values are 1: left, 2: right, 3: middle
m.click(500, 300, 1)

# get the screen size
m.screen_size()
# (1024, 768)

# get the mouse position
m.position()
# (500, 300)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我在之前写过一篇《&lt;a href=&quot;https://www.cnblogs.com/zjutlitao/p/6942729.html&quot;&gt;1、python鼠标点击、移动事件应用——写一个自动下载百度音乐的程序&lt;/a&gt;》，就是用了PyMouse。&lt;/p&gt;

&lt;h4 id=&quot;小结&quot;&gt;5、小结&lt;/h4&gt;
&lt;p&gt;PyMouse、PyKeyboard用python操作鼠标和键盘的库，使用起来比较简单，需要结合具体的应用需求才能玩出新花样。比如和openCV结合做&lt;a href=&quot;https://www.cnblogs.com/zjutlitao/p/3624500.html&quot;&gt;游戏外挂&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/zjutlitao/p/3893112.html&quot;&gt;和智能硬件结合做手势切歌&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/zjutlitao/p/4337775.html&quot;&gt;和网页解析结合做日刷千题的OJ-AC自动机&lt;/a&gt;....&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/506370/201503/141650375277405.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;: &lt;strong&gt;完～&lt;/strong&gt;&lt;br/&gt;: &lt;strong&gt;大家觉得不错，可以点推荐给更多人～&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;links&quot;&gt;LINKS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/python3/python3-basic-operators.html&quot;&gt;[1]. Python3 运算符&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/PyUserInput/PyUserInput&quot;&gt;[2]. PyUserInput GITHUB地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/SavinaRoja/PyUserInput/wiki&quot;&gt;[3]. PyUserInput 文档&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/SavinaRoja/PyUserInput/wiki/PyMouse&quot;&gt;[4]. PyMouse 文档&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/pepijndevos/PyMouse/wiki&quot;&gt;[5]. PyMouseEvent 文档&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/pepijndevos/PyMouse&quot;&gt;[6]. PyMouse GITHUB地址&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 27 Dec 2018 19:36:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>  1、PyUserInput 简介 PyUserInput是一个使用python的跨平台的操作鼠标和键盘的模块，非常方便使用。支持的平台及依赖如下： Linux Xlib Mac Quar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/10188434.html</dc:identifier>
</item>
<item>
<title>iOS自动化探索（二）WDA(WebDriverAgent) API的使用 - 周希</title>
<link>http://www.cnblogs.com/zhouxihi/p/10188297.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouxihi/p/10188297.html</guid>
<description>&lt;p&gt;前面我们已经安装好了WebdriverAgent， 现在可以用Facebook官方提供的API来进行一些操作&lt;/p&gt;
&lt;p&gt;WDA API官方页面：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/WebDriverAgent/wiki/Queries&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/facebook/WebDriverAgent/wiki/Queries&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果在终端运行的话可以使用curl来调用API，需要搭配json_header +  device_url + api组成，其中&lt;/p&gt;
&lt;p&gt;json_header一般是: &quot;Content-Type: application/json&quot;&lt;/p&gt;
&lt;p&gt;device_url一般是: http://localhost:8100/*&lt;/p&gt;

&lt;p&gt;下面我们试试调用这些API&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;功能: 查询可服务状态(Checking Service Status)

API: curl &lt;/span&gt;-X GET $JSON_HEADER $DEVICE_URL/status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用示范:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
Jackeys-MacBook-Pro:~ jackey$ curl -X GET -H &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -d &lt;span&gt;&quot;&quot;&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8100/status&lt;/span&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iOS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;11.2.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ios&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;simulatorVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;11.2.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.1.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dec 25 2018 11:48:43&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sessionId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FB941AE9-551D-437E-A376-191DDDB354FB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
}Jackeys&lt;/span&gt;-MacBook-Pro:~ jackey$ 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后面再补充...&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 16:32:00 +0000</pubDate>
<dc:creator>周希</dc:creator>
<og:description>前面我们已经安装好了WebdriverAgent， 现在可以用Facebook官方提供的API来进行一些操作 WDA API官方页面： https://github.com/facebook/WebD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouxihi/p/10188297.html</dc:identifier>
</item>
<item>
<title>Docker部署Apollo配置中心 - 惊天霸戈</title>
<link>http://www.cnblogs.com/xwgblog/p/10188064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xwgblog/p/10188064.html</guid>
<description>&lt;p&gt;开始使用Docker部署Apollo配置中心之前，首先需要机器安装Docker环境本文使用&lt;code&gt;Vresion: 2.0.0.0-mac81 (29211)&lt;/code&gt;测试部署，并使用以下镜像：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;apollo-configservice&lt;/li&gt;
&lt;li&gt;apollo-adminsrevice&lt;/li&gt;
&lt;li&gt;apollo-portal&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为本文为纯部署目的，因此不在这里讲解Apollo的一些知识，如有需要可查看官方GitHub地址（https://github.com/ctripcorp/apollo）。&lt;/p&gt;
&lt;p&gt;上面提到的镜像除了&lt;code&gt;Mysql&lt;/code&gt;以外其余三个都需要自行编译成Docker镜像，由于最初是打算部署到k8s中的，所以是按照&lt;a href=&quot;https://github.com/ctripcorp/apollo/blob/master/scripts/apollo-on-kubernetes/README.md&quot;&gt;K8s的部署文档&lt;/a&gt;来编译相应的镜像的。本文使用使用&lt;code&gt;dockre-compose&lt;/code&gt;部署dev、fat、uat、pro等环境，仅供测试时使用，详细生产环境部署可查看官方指导，这里先给出官方的分布式部署方案图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ctripcorp/apollo/master/doc/images/apollo-deployment.png&quot; alt=&quot;分布式部署指南&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于如何编译&lt;code&gt;apollo-configservice&lt;/code&gt;、&lt;code&gt;apollo-adminsrevice&lt;/code&gt;、&lt;code&gt;apollo-portal&lt;/code&gt;这三个docker镜像可点击连接查看 &lt;a href=&quot;https://github.com/ctripcorp/apollo/blob/master/scripts/apollo-on-kubernetes/README.md&quot;&gt;K8s的部署文档&lt;/a&gt; 来编译Docker镜像。&lt;/p&gt;
&lt;p&gt;Apollo使用的是Spring Cloud微服务架构，主要包括以下服务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册中心（与apollo-configservice运行在一起）&lt;/li&gt;
&lt;li&gt;配置服务（apollo-configservice）&lt;/li&gt;
&lt;li&gt;管理服务（apollo-adminservice）&lt;/li&gt;
&lt;li&gt;管理门户（apollo-portal）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Apollo主要使用Mysql存储应用的配置以及自已的运行配置，Apollo使用以下数据库完成存储：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ApolloPortalDB&lt;/li&gt;
&lt;li&gt;ApolloConfigDB&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用关系如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;配置服务&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;管理服务&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;管理门户&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面准备使用Dockere在&lt;code&gt;dev&lt;/code&gt;环境部署Apollo。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;从Github来拉取最新的Apollo代码：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git clone git@github.com:ctripcorp/apollo.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查启动Docker是否启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker info&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于使用&lt;code&gt;dockre-compose&lt;/code&gt;部署，需要有一个&lt;code&gt;dockre-compose&lt;/code&gt;配置文件，这里假设有一个&lt;code&gt;apollo-compose.yaml&lt;/code&gt;配置文件，之后的部署都会更新这个文件。如果你的机器还未安装&lt;code&gt;dockre-compose&lt;/code&gt;可查看 &lt;a href=&quot;https://docs.docker.com/compose/install/&quot;&gt;docker-compose安装指导&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置mysql服务&quot;&gt;配置Mysql服务&lt;/h2&gt;
&lt;p&gt;部署之前先将对应环境的Mysql服务启动起来，这里使用&lt;code&gt;docker-compose&lt;/code&gt;启动Mysql服务.&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: &quot;3&quot;
services:
 mysql-dev:
  image: mysql
  # restart: always
  environment:
   - MYSQL_ROOT_PASSWORD=123456
  expose:
   - &quot;3306&quot;
  volumes:
    - /Users/yjwfn/bin/apollo/scripts/sql:/sql      &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的配置代码，将在&lt;code&gt;dev&lt;/code&gt;环境运行mysql服务，这里挂载了一个目录：&lt;code&gt;/Users/yjwfn/bin/apollo/scripts/sql:/sql&lt;/code&gt;，该目录里面存放Apollo的数据库文件，详细文件可查看 &lt;a href=&quot;https://github.com/ctripcorp/apollo/tree/master/scripts/sql&quot;&gt;Apollo Sql文件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用以下命令启动&lt;code&gt;dev&lt;/code&gt;环境的mysql服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; docker-compose -f apollo-compose.yaml up -d mysql-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;apollo-compose.yaml&lt;/code&gt;是你机上&lt;code&gt;docker-compose&lt;/code&gt;配置文件，&lt;code&gt;mysql-dev&lt;/code&gt;是mysql服务的名称。&lt;/p&gt;
&lt;p&gt;启动完成后查看容器是否已经运行：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker container ps&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置apollo数据库&quot;&gt;配置Apollo数据库&lt;/h3&gt;
&lt;p&gt;mysql服务启动完成之后，需要将&lt;code&gt;apolloconfigdb.sql&lt;/code&gt;与&lt;code&gt;apolloportaldb.sql&lt;/code&gt;这两个sql文件导入到数据库中，首先连接上docker中的mysql服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker exec -it kube_mysql-dev_1 sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kube_mysql-dev_1&lt;/code&gt;是mysql服务的容器名称，连接上容器后登陆到mysql服务导入sql文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mysql -p123456
source /sql/apolloconfigdb.sql
srouce /sql/apolloportaldb.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是部署&lt;code&gt;apollo-configservice&lt;/code&gt;与&lt;code&gt;apollo-apolloportaldb&lt;/code&gt;的话只需要导入&lt;code&gt;/sql/apolloconfigdb.sql&lt;/code&gt;就行了，相应的部署&lt;code&gt;apollo-portal&lt;/code&gt;只需要导入&lt;code&gt;/sql/apolloportaldb.sql&lt;/code&gt;，方便演示这里就两个同时导入了。&lt;/p&gt;
&lt;p&gt;导入完成后数据中现在应该有&lt;code&gt;ApolloConfigDB&lt;/code&gt;与&lt;code&gt;ApolloPortalDB&lt;/code&gt;两个数据库，首先需要对&lt;code&gt;ApolloConfigDB&lt;/code&gt;里面的&lt;code&gt;ServerConfig&lt;/code&gt;做一些修改，主要是对&lt;code&gt;发服服务&lt;/code&gt;的服务器地址做一点变更：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;use ApolloConfigDB；
update ServerConfig set Value=&quot;http://apollo-configservice-dev:8080/eureka/&quot; where `key`=&quot;eureka.service.url&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;apollo-configservice-dev&lt;/code&gt;是稍后我们需要发布的&lt;code&gt;apollo-configservice&lt;/code&gt;服务的名称。修改完成之后可运行查询语句是否修改成功：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select * from ServerConfig;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完成之前退出dockre容器的连接就行了， 接下来部署&lt;code&gt;apollo-configservice&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;配置服务部署apollo-configservice&quot;&gt;配置服务部署（apollo-configservice）&lt;/h2&gt;
&lt;p&gt;Apollo&lt;code&gt;配置服务（apollo-configservice）&lt;/code&gt;与&lt;code&gt;注册中心（Eureka）&lt;/code&gt;是运行在一起的，所以一般情况下是不需要再部署&lt;code&gt;Eureka&lt;/code&gt;了。现在部署&lt;code&gt;apollo-configservice&lt;/code&gt;服务，首先在&lt;code&gt;apollo-compose.yaml&lt;/code&gt;添加&lt;code&gt;apollo-configservice&lt;/code&gt;服务：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: &quot;3&quot;
services:
 ... #省略其他服务 
 apollo-configservice-dev:  
  image:  &amp;lt;镜像地址&amp;gt;
  environment: 
   DATASOURCES_URL: jdbc:mysql://mysql-dev:3306/ApolloConfigDB?characterEncoding=utf8
   DATASOURCES_USERNAME: root
   DATASOURCES_PASSWORD: 123456
   ENV: &quot;dev&quot;
  expose:
   - &quot;8080&quot;
  depends_on:
   - &quot;mysql-dev&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;apollo-configservice-dev&lt;/code&gt;依赖了上面部署的&lt;code&gt;mysql-dev&lt;/code&gt;服务，并且注入了一些环境变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DATASOURCES_URL (mysql-dev连接地址)&lt;/li&gt;
&lt;li&gt;DATASOURCES_USERNAME （mysql-dev连接用户）&lt;/li&gt;
&lt;li&gt;DATASOURCES_PASSWORD （mysql-dev的root密码）&lt;/li&gt;
&lt;li&gt;ENV (apollo-configservice）的运行环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;服务添加完成后执行以下命令启动&lt;code&gt;apollo-configservice-dev&lt;/code&gt;服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker-compose -f apollo-compose.yaml up -d apollo-configservice-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行启动命令后等待几秒，然后查看服务是否启动成功。可通过在容器中查看启动日志来判断服务是否启动成功：&lt;/p&gt;
&lt;pre class=&quot;sheell&quot;&gt;
&lt;code&gt;docker exec -it kube_apollo-configservice-dev_1 sh
cat /opt/logs/apollo-config-server/apollo-configservice.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kube_apollo-configservice-dev_1&lt;/code&gt;是&lt;code&gt;apollo-configservice-dev&lt;/code&gt;的容器名称可通过&lt;code&gt;docker container ps&lt;/code&gt;查看，看到如下日志基本可以确定服务已经成功启动：&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;2018-12-27 21:45:51.889  INFO 40 --- [Thread-17] c.n.e.registry.AbstractInstanceRegistry  : Registered instance APOLLO-CONFIGSERVICE/f2b6896763d0:apollo-configservice:8080 with status UP (replication=true)
2018-12-27 21:45:51.889  INFO 40 --- [Thread-17] c.n.e.r.PeerAwareInstanceRegistryImpl    : Got 1 instances from neighboring DS node
2018-12-27 21:45:51.889  INFO 40 --- [Thread-17] c.n.e.r.PeerAwareInstanceRegistryImpl    : Renew threshold is: 1
2018-12-27 21:45:51.889  INFO 40 --- [Thread-17] c.n.e.r.PeerAwareInstanceRegistryImpl    : Changing status to UP
2018-12-27 21:45:51.894  INFO 40 --- [Thread-17] e.s.EurekaServerInitializerConfiguration : Started Eureka Server&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;管理服务部署apollo-adminservice&quot;&gt;管理服务部署（apollo-adminservice）&lt;/h2&gt;
&lt;p&gt;管理服务的配置基本上与&lt;code&gt;配置服务&lt;/code&gt;的配置基本相似，首先在&lt;code&gt;apollo-compose&lt;/code&gt;中添加&lt;code&gt;apollo-adminservice-dev&lt;/code&gt;服务：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: &quot;3&quot;
services:
 ... #省略其他服务配置
 apollo-adminservice-dev: 
  image:  &amp;lt;镜像名称&amp;gt;
  environment: 
   DATASOURCES_URL: &quot;jdbc:mysql://mysql-dev:3306/ApolloConfigDB?characterEncoding=utf8&quot;
   DATASOURCES_USERNAME: root
   DATASOURCES_PASSWORD: 123456
   ENV: &quot;dev&quot;
  expose:
   - &quot;8080&quot;
  depends_on:
   - &quot;mysql-dev&quot;  #管理服务依赖之前配置的mysql-dev服务
   - &quot;apollo-configservice-dev&quot; #管理服务依赖配置服务&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同&lt;code&gt;apollo-configservice-dev&lt;/code&gt;一样定义几个环境变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DATASOURCES_URL (mysql-dev连接地址)&lt;/li&gt;
&lt;li&gt;DATASOURCES_USERNAME （mysql-dev连接用户）&lt;/li&gt;
&lt;li&gt;DATASOURCES_PASSWORD （mysql-dev的root密码）&lt;/li&gt;
&lt;li&gt;ENV (apollo-configservice）的运行环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;添加服务完成后开始启动&lt;code&gt;apollo-adminservice-dev&lt;/code&gt;服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker-compose -f apollo-compose.yaml up -d apollo-adminservice-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;docker container ps&lt;/code&gt;查看容器名称，随后执行命令查看Log文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker exec -it kube_apollo-adminservice-dev_1 sh
cat /opt/logs/apollo-admin-server/apollo-adminservice.log | tail -n 50&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部分日志输出如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
2018-12-27 21:56:45.722  INFO 40 --- [DiscoveryClient-InstanceInfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_APOLLO-ADMINSERVICE/8578c069d388:apollo-adminservice:8090: registering service...
2018-12-27 21:56:45.804  INFO 40 --- [main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8090 (http) with context path ''
2018-12-27 21:56:45.810  INFO 40 --- [main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8090
2018-12-27 21:56:45.810  INFO 40 --- [DiscoveryClient-InstanceInfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_APOLLO-ADMINSERVICE/8578c069d388:apollo-adminservice:8090 - registration status: 204
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在可以确定&lt;code&gt;Eureka&lt;/code&gt;注册中心中已经有两个服务分别为&lt;code&gt;APOLLO-CONFIGSERVICE&lt;/code&gt;和&lt;code&gt;APOLLO-ADMINSERVICE&lt;/code&gt;服务。&lt;/p&gt;
&lt;h2 id=&quot;管理控制台部署apollo-portal&quot;&gt;管理控制台部署（apollo-portal）&lt;/h2&gt;
&lt;p&gt;成功部署&lt;code&gt;配置服务（apollo-configservice）&lt;/code&gt;和&lt;code&gt;管理服务（apollo-adminsrevice）&lt;/code&gt;并启动成功后，现在可以部署&lt;code&gt;管理控制台服务（apollo-portal）&lt;/code&gt;了。首先在&lt;code&gt;apollo-compose.yaml&lt;/code&gt;文件添加两个服务：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt; mysql-portal:
   image: mysql
   # restart: always
   environment:
    - MYSQL_ROOT_PASSWORD=123456
   expose:
    - &quot;3306&quot;
   volumes:
    - /Users/yjwfn/bin/apollo/scripts/sql:/sql 

 apollo-portal: 
   image: &amp;lt;镜像名称&amp;gt;
   environment: 
    DEV_META_SERVICE_NAME: apollo-configservice-dev
    DATASOURCES_URL: &quot;jdbc:mysql://mysql-portal:3306/ApolloPortalDB?characterEncoding=utf8&quot;
    DATASOURCES_USERNAME: root
    DATASOURCES_PASSWORD: 123456
   # expose:
   #  - &quot;8070&quot; 
   ports:
    - 8070:8070 #方便测试导出端口
   depends_on:
    - &quot;mysql-portal&quot;
    - &quot;apollo-configservice-dev&quot;
    - &quot;apollo-adminservice-dev&quot;
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;管理控制台服务&lt;/code&gt;使用了单独的mysql服务，没有与&lt;code&gt;apollo-configservice-dev&lt;/code&gt;和&lt;code&gt;apollo-adminservice-dev&lt;/code&gt;共享一个mysql服务，同样&lt;code&gt;mysql-portal&lt;/code&gt;也需要初始化数据库，这里我们首先启动&lt;code&gt;mysql-portal&lt;/code&gt;服务：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;#启动服务 
docker-compose -f apollo-compose.yaml up -d mysql-portal
#连接到容器执行命令
docker exec -it kube_mysql-portal_1 sh
#登陆mysql
mysql -p123456
#导入sql文件
source /sql/apolloportaldb.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mysql-portal&lt;/code&gt;启动并配置完成后开始启动&lt;code&gt;apollo-portal&lt;/code&gt;服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker-compose -f apollo-compose.yaml up -d apollo-portal&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功后可访问 &lt;a href=&quot;http://localhost:8070/&quot; class=&quot;uri&quot;&gt;http://localhost:8070&lt;/a&gt; 启动管理控制台。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;由于现在公司也正在使用Apollo做为分布式配置中心，所以决定学习下Apollo的相关知识。 此文章只涉及到部署想着的知识，里面提到的一些内容其实都可以在官方文档中找到，这里不得不提下Apollo的文档资料还是非常全的。总的来说部署的过程还是有些坑的，但是经过一段时候的摸索，还是成功的在Docker中部署了，之后还会学习Apollo的使用相关的知识，后续再来分享。&lt;/p&gt;
&lt;p&gt;最后附上完整的&lt;code&gt;apollo-compose.yaml&lt;/code&gt;文件凑凑字数：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;#坑一： mysql使用有对象设置环境变量无效

version: &quot;3&quot;
services:
 mysql-dev:
  image: mysql
  # restart: always
  environment:
   - MYSQL_ROOT_PASSWORD=123456
  expose:
   - &quot;3306&quot;
  volumes:
    - /Users/yjwfn/bin/apollo/scripts/sql:/sql      

 apollo-configservice-dev:  
  image: harbor.rcntech.cn/apollo/apollo-configservice:v1.2.0
  environment: 
   DATASOURCES_URL: jdbc:mysql://mysql-dev:3306/ApolloConfigDB?characterEncoding=utf8
   DATASOURCES_USERNAME: root
   DATASOURCES_PASSWORD: 123456
   ENV: &quot;dev&quot;
  expose:
   - &quot;8080&quot;
  depends_on:
   - &quot;mysql-dev&quot;


 apollo-adminservice-dev: 
  image: harbor.rcntech.cn/apollo/apollo-adminservice:v1.2.0
  environment: 
   DATASOURCES_URL: &quot;jdbc:mysql://mysql-dev:3306/ApolloConfigDB?characterEncoding=utf8&quot;
   DATASOURCES_USERNAME: root
   DATASOURCES_PASSWORD: 123456
   ENV: &quot;dev&quot;
  expose:
   - &quot;8080&quot;
  depends_on:
   - &quot;mysql-dev&quot;
   - &quot;apollo-configservice-dev&quot;
 mysql-portal:
   image: mysql
   # restart: always
   environment:
    - MYSQL_ROOT_PASSWORD=123456
   expose:
    - &quot;3306&quot;
   volumes:
    - /Users/yjwfn/bin/apollo/scripts/sql:/sql 

 apollo-portal: 
   image: harbor.rcntech.cn/apollo/apollo-portal:v1.2.0
   environment: 
    DEV_META_SERVICE_NAME: apollo-configservice-dev
    DATASOURCES_URL: &quot;jdbc:mysql://mysql-portal:3306/ApolloPortalDB?characterEncoding=utf8&quot;
    DATASOURCES_USERNAME: root
    DATASOURCES_PASSWORD: 123456
   ports:
    - 8070:8070
   depends_on:
    - &quot;mysql-portal&quot;
    - &quot;apollo-configservice-dev&quot;
    - &quot;apollo-adminservice-dev&quot;

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 27 Dec 2018 15:51:00 +0000</pubDate>
<dc:creator>惊天霸戈</dc:creator>
<og:description>开始使用Docker部署Apollo配置中心之前，首先需要机器安装Docker环境本文使用 测试部署，并使用以下镜像： mysql apollo configservice apollo admins</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xwgblog/p/10188064.html</dc:identifier>
</item>
<item>
<title>Linux安装jsvc，及Linux服务开发 - 水木山川</title>
<link>http://www.cnblogs.com/zengming/p/10180047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zengming/p/10180047.html</guid>
<description>&lt;p&gt;在linux上以服务的方式启动java程序，需要提前安装jsvc。linux是利用daemon(jsvc)构建java守护进程。&lt;/p&gt;
&lt;p&gt;编译 daemon 安装JSVC&lt;/p&gt;
&lt;p&gt;1 下载文件，&lt;a href=&quot;http://commons.apache.org/daemon/jsvc.html&quot; target=&quot;_blank&quot;&gt;http://commons.apache.org/daemon/jsvc.html&lt;/a&gt;&lt;br/&gt;　　commons-daemon-1.1.0-native-src.tar.gz&lt;br/&gt;2 编译：解压文件到linux，进入其子目录 'unix'，执行如下命令(如有必要执行chmod +x ./*)&lt;br/&gt;　　# &lt;span&gt;./configure --with-java=/usr/java&lt;/span&gt; 　　　　　　　　# 附带JDK（JAVA_HOME）路径&lt;br/&gt;　　#注：如果环境变量JAVA_HOME已经设置正确，就可以直接运行configure&lt;br/&gt;　　# &lt;span&gt;./configure&lt;/span&gt;&lt;br/&gt;　　# &lt;span&gt;make&lt;/span&gt; 　　　　　　　　　　　　　　　　　　　　#编译生成了可执行的文件 jsvc (在源文件目录的'unix目录下')&lt;/p&gt;
&lt;p&gt;编译jsvc包&lt;/p&gt;
&lt;p&gt;1.安装jsvc，在tomcat的bin目录下有一个jsvc.tar.gz的文件,上传jsvc.tar.gz 文件包&lt;/p&gt;
&lt;p&gt;　　#&lt;span&gt;tar xvfz jsvc.tar.gz&lt;/span&gt;&lt;br/&gt;　　#&lt;span&gt;cd jsvc-src&lt;/span&gt;&lt;br/&gt;　　#&lt;span&gt;sh support/buildconf.sh&lt;/span&gt;&lt;br/&gt;　　#&lt;span&gt;chmod 755 configure　　　　　　　　　　　　&lt;/span&gt;&lt;span&gt;#已安装JDK&lt;/span&gt;&lt;br/&gt;　　#./configure --with-java=/usr/local/java 　　　　　#手动配置JDK参数&lt;br/&gt;　　#注：如果环境变量JAVA_HOME已经设置正确，就可以直接运行configure&lt;br/&gt;　　#&lt;span&gt;make&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　开发Linux系统服务，首先需要实现org.apache.commons.daemon.&lt;span&gt;Daemon&lt;/span&gt;接口，服务在启动时会先调用 init(String[] args) 方法然后调用 start() 方法，在服务停止是会首先调用 stop() 方法，然后调用 destroy() 方法.&lt;br/&gt;　　1.将程序打包成 testjsvc.jar 放到/opt目录下&lt;br/&gt;　　2.编写启动服务脚本testjsvc（红色的修改参数）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#! /bin/&lt;span&gt;sh
#Desc:  Daemon Service &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; testjsvc
NAME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testjsvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
DESC&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Daemon Service for TestJSVC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#jdk的安装目录
JAVA_HOME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/java/jdk1.8.0_191&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#jsvc所在的目录
JSVC&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/testjsvc/jsvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#pid文件目录
PID_FILE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jsvc.pid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
PID_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/run/testjsvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
PID&lt;/span&gt;=$PID_PATH/&lt;span&gt;$PID_FILE
TMP_DIR&lt;/span&gt;=&lt;span&gt;/var/&lt;/span&gt;&lt;span&gt;&lt;span&gt;tmp&lt;/span&gt;
#启动日志输出文件路径
LOG_FILE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/testjsvc/logs/startup.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#应用程序的目录和路径
SCOREMARKER_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/testjsvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
SCOREMARKER_JAR&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/testjsvc/testjsvc.jar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#应用程序依赖包目录
CLASS_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$SCOREMARKER_JAR:$(echo $SCOREMARKER_PATH/lib/*.jar | tr ' ' ':')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CLASS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.zsm.daemon.TestJSVCMain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#程序用户
JSVC_USER&lt;/span&gt;=&lt;span&gt;&lt;span&gt;root&lt;/span&gt;
OPTION&lt;/span&gt;=&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;

execute_jsvc(){
    svc &lt;/span&gt;-cp $CLASS_PATH -home $JAVA_HOME -user $JSVC_USER -Djava.io.tmpdir=$TMP_DIR -wait &lt;span&gt;3&lt;/span&gt; -outfile $LOG_FILE -errfile $LOG_FILE -pidfile $PID $&lt;span&gt;1&lt;/span&gt;&lt;span&gt; $CLASS
}

&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$OPTION&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
    start)
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting $DESC..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$(date): Starting $DESC..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;&lt;span&gt; $LOG_FILE
        execute_jsvc
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The $DESC has started&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        echo $&lt;/span&gt;!&lt;span&gt;
    ;;
    stop)
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stoping $DESC..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$(date): Stoping $DESC..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;&lt;span&gt; $LOG_FILE
        execute_jsvc &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-stop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The $DESC has stoped&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ;;    
    restart)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ -f &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]; then
            echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Restarting $DESC..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$(date): Restarting $DESC..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;&lt;span&gt; $LOG_FILE
            execute_jsvc &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-stop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            execute_jsvc
            echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The $DESC has restarted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
            echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The $DESC is not restarted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;&lt;span&gt; $LOG_FILE
            echo $&lt;/span&gt;!
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The $DESC is not running, no action taken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            exit &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        fi
    ;;
    status)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ -f &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]; then
            echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The $DESC is running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The $DESC is not running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        fi            
    ;;
    &lt;/span&gt;*&lt;span&gt;)
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Usage: /etc/init.d/$NAME {start|stop|restart|status}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;amp;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        exit &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    ;;
esac&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.把 testjsvc 文件拷贝到 /etc/init.d/ 目录下，添加到启动服务里面去.&lt;br/&gt;　　#chmod -c 777 /etc/init.d/testjsvc 　　　　　　 　　　　　　 #赋予执行权限&lt;/p&gt;
&lt;p&gt;　　#chkconfig --add testjsvc 　　　　　　　　　　　　　　 　　 #添加服务&lt;/p&gt;
&lt;p&gt;　　#chkconfig --level 345 testjsvc on 　　　　　　　　　　　　  #设置服务的启动级别&lt;/p&gt;
&lt;p&gt;　　#service testjsvc start 　　　　　　　　　　　　　　　　　　#启动服务，并且在系统重启时会自动启动myjsvc服务&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 15:43:00 +0000</pubDate>
<dc:creator>水木山川</dc:creator>
<og:description>JSVC安装，Linux开发Daemon程序，jsvc服务脚本，Linux服务开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zengming/p/10180047.html</dc:identifier>
</item>
<item>
<title>QC API全系列揭秘之Test Execution操作（全网首发） - 泽南-Alpha</title>
<link>http://www.cnblogs.com/alphaxu/p/10188187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alphaxu/p/10188187.html</guid>
<description>&lt;p&gt;（原创文章，转载请注明出处。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、QC简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        Quality Center存在至今已经走过了10多个年头，名字从一开始的TD，到后来的QC，再到现在的ALM。所属公司从开始的Mercury到现在的HP，核心一直没变，变的只有名字。随着Mercury最核心的高层、架构师和专家的离开，现在每每的升级都带来诸多失望，再也没有当初使用Mercury工具的时候那样心潮澎湃，看看QC，看看QTP，不多言语。如果能够坚持做好的话，现在哪有TestLink、哪有禅道什么事。然而，QC框架的设计核心，拿到现在来看，依然是测试管理框架的主流。QC设计思路简单清晰，从测试需求到测试用例，再到执行测试用例、提交缺陷、跟踪缺陷，整个过程清晰且易于理解，时至今日，依然被广泛沿用。（微信公众号“诗泽园”）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、写作目的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        写此系列的目的，不是为了情怀，而是为了将QC接口的调用方式整理成册。一来是为了通过对QC接口调用的理解，去更深入的理解测试框架的概念（当然仅仅包含小部分）；二来是为了通过二次开发，解决QC使用过程中的诸多不便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、解决问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;QC当前存在以下问题：&lt;/p&gt;
&lt;p&gt;1、需求或用例的导入导出依然不完善。之前就写过一个工具解决这个问题：&lt;a title=&quot;QC Export Tool&quot; href=&quot;https://download.csdn.net/download/yoyoalphax/4441588&quot; target=&quot;_blank&quot;&gt;https://download.csdn.net/download/yoyoalphax/4441588&lt;/a&gt;，但近期依然常有人催促我更新版本，之后会专门发一篇关于用例树解析的图文。（网上资料大部分需要admin账户通过后台SQL做关键字筛选获得结果，但事实上与实际的导入导出过程有所出入。）&lt;/p&gt;
&lt;p&gt;2、用例执行顺序需要参考已有用例集，无法随心所欲变化。&lt;/p&gt;
&lt;p&gt;3、每次执行的用例集列表无法保存并复用。&lt;/p&gt;
&lt;p&gt;4、手动执行前需要处理解锁等额外步骤。&lt;/p&gt;
&lt;p&gt;5、测试结果随有统一展示，但需要人工收集结果等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、本文重点：&lt;/strong&gt;&lt;br/&gt;        本文着重介绍Test Execution部分，解决了以上罗列的后几个问题，并为某些问题提供解决的条件。其余需求树、用例树读取及写入部分以后再介绍。&lt;br/&gt;        Test Execution属于自动化测试框架的一部分，我们先从框架说起。&lt;br/&gt;        &lt;strong&gt;框架的概念：&lt;/strong&gt;&lt;br/&gt;        测试框架的话题，范围实在是太大了，我们还是围绕QC来说。我们仅仅考虑从测试用例的编写、测试用例的执行和测试报告来看。用过的同学都清楚，TestPlan里可以存放测试用例，而TestLab里可以建TestSet并形成用例集并且执行，Report里查看用例，这就是基本流程。而对于自动化测试的流程而言，用QC的方式又有所区别：首先，是测试工具的关联。QC需要安装QTP或LR的插件，使得QC的测试执行模块里可以识别这两类代码。又或者你用的是其他第三方工具或用JAVA和.Net自开发的测试工具，那你需要用VB6编写关联脚本，使得QC能够调用你写的代码，这个过程我们不在本文中讨论。其次，是测试脚本的存储。以用例的形式存储在TestPlan里，最终落到QC的后台SQL数据库里，并能实现脚本与数据的分开存储。再者是测试用例集的构成，这部分是放在TestLab里去管理。按照业务逻辑，将已有用例归集并排序，形成业务逻辑并保存。最后是测试执行，按照被测系统版本、范围，选择相应的业务节点去触发执行，获得结果。&lt;/p&gt;
&lt;p&gt;        这个过程其实分两个阶段，一个是测试开发阶段，另一个是测试执行阶段，两个阶段各有各的自动化设计方面的考虑。这个不是本文的主旨，但是我也顺便捋一下，加深理解。测试开发阶段，其实是要设计出狭义的测试框架，也就是一个可以团队合作开发的测试脚本的模式，包含底层库、业务的封装、上层调用及断言等等。有了狭义的框架后，需要有偏业务的测试人员介入，将测试脚本归集形成测试集。在测试开发阶段，往往这两块是一同进行的，边改边拼接。测试Q执行阶段，其实是要有测试执行框架去支撑的，尤其是有大批量的测试脚本和测试机需要团队去匹配执行时，这个框架就显得尤为重要。其中涉及到的关键点，如待测范围的选择及保存、测试机的管理（vmware or docker）、用例执行时的动态分配、异常处理、报告收集等等。&lt;/p&gt;
&lt;p&gt;        本文所涉及的内容应该是通过QC实现自动化测试脚本运行的前提下，实现测试范围的选择与保存，测试脚本的自动化执行并做后续的报告收集工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、QC接口规范：&lt;/strong&gt;&lt;br/&gt;        具体的接口规范你可以尝试通过百度查询“QC OTA”或者“QC对象模型”，获得接口说明及使用规范。但以下的核心代码均是本人键盘手打敲击而成，尤其是核心的业务树生成及测试执行部分，均为首次发布。还望转载或代码复用时注明出处。（出自微信公众号“诗泽园”或博客园“朝花夕拾”--https://www.cnblogs.com/alphaxu/）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、QC接口操作Test Execution：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正式切入正题：&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;定义全局变量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;真实代码中有很多控制类及展示类，都已经去除了。这里只展示核心代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;        TDConnection tdc = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TDConnection();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;        TDAPIOLELib.TSScheduler QCscheduler;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;        TDAPIOLELib.ExecutionStatus QCexecutionStatus;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt; QClistForTSTest;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hqc&quot;&gt;&lt;span&gt;QC服务器连接、登录（身份验证）及项目连接&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;服务器连接为初始化连接，好比你刚登录QC终端时它给你的反馈。一般会碰到要你reload ActiveX或者OTA初始化失败之类的错误。处理方法是把QC缓存文件夹删除，再访问，让其重新reload。这块代码里会有处理，但这类代码就不贴了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;InitConnect&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; serverName)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((tdc.Connected == &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;) || (tdc.Connected == &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt; &amp;amp;&amp;amp; tdc.ServerName != serverName))&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;                    tdc.InitConnectionEx(serverName);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;                Console.WriteLine(ex.ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;                MessageBox.Show(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Server Error&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Warning&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;        }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;GetAuthenticate&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; userName, &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; passWord)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;                tdc.Login(userName, passWord);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;                TDAPIOLELib.List projectList = tdc.get_VisibleProjects(tdc.VisibleDomains[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;].ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;                &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= projectList.Count; i++)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;                {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;                    projectsBox.Items.Add(projectList[i]);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;                    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;                }            &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;                Console.WriteLine(ex.ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;                MessageBox.Show(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Please check the User Name is correct or not.&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Warning&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LoginButton_Click&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;object&lt;/span&gt; sender, EventArgs e&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; ProjectName = projectsBox.SelectedItem.ToString();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;                tdc.Connect(tdc.VisibleDomains[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;].ToString(), ProjectName);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;                &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;                Thread td_tree = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ThreadStart(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.CreateTreeView));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;                td_tree.Start();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;                Console.WriteLine(ex.ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;                MessageBox.Show(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Please choose the project.&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Warning&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;重点之一：递归生成业务树&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;同样需要新开线程调用，先生成根节点，再递归生成业务树&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CreateTreeView&lt;/span&gt;()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;                TreeNode mainNode = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TreeNode();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;                mainNode.Name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Root&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;                mainNode.Text = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Root&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;                Add_TreeRoot(mainNode);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;                SysTreeNode test_folder;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;                TestSetFactory globalTestSetFactory;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;                List l_List;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;                TreeNode r_node = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TreeNode();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; nodeCount;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;                nodeCount = qcProjectTree.GetNodeCount(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;                TreeNode[] r_nodeArray = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TreeNode[&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;                r_nodeArray = qcProjectTree.Nodes.Find(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Root&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;                r_node = r_nodeArray[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;                TestSetTreeManager tm;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;                tm = (TDAPIOLELib.TestSetTreeManager)tdc.TestSetTreeManager;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;                test_folder = (TDAPIOLELib.SysTreeNode)tm.Root;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;                globalTestSetFactory = (TDAPIOLELib.TestSetFactory)tdc.TestSetFactory;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;                l_List = globalTestSetFactory.NewList(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;                recursiveTreeBuilder(test_folder, r_node);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;                Console.WriteLine(ex.ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;        }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;recursiveTreeBuilder&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;TDAPIOLELib.SysTreeNode folder, TreeNode parent&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;38&lt;/span&gt;            TDAPIOLELib.List folders, tests;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;39&lt;/span&gt;            TDAPIOLELib.TestSetFactory objTestSetFactory;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;40&lt;/span&gt;            TDAPIOLELib.TestSetFolder objTSFolder;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;41&lt;/span&gt;            TreeNode n;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;42&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;43&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;44&lt;/span&gt;                folders = folder.NewList();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;45&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (TDAPIOLELib.SysTreeNode f &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; folders)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;46&lt;/span&gt;                {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;47&lt;/span&gt;                    TreeNode nodeChild = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TreeNode();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;48&lt;/span&gt;                    nodeChild.Name = f.Name;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;49&lt;/span&gt;                    nodeChild.Text = f.Name;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;50&lt;/span&gt;                    nodeChild.ImageIndex = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;51&lt;/span&gt;                    Add_TreeNode(parent, nodeChild);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;52&lt;/span&gt;                    n = parent.Nodes[nodeChild.Name];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;53&lt;/span&gt;                    recursiveTreeBuilder(f, n);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;54&lt;/span&gt;                }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;55&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;56&lt;/span&gt;                objTSFolder = (TDAPIOLELib.TestSetFolder)folder;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;57&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (objTSFolder.NodeID != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;58&lt;/span&gt;                {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;59&lt;/span&gt;                    objTestSetFactory = (TDAPIOLELib.TestSetFactory)objTSFolder.TestSetFactory;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;60&lt;/span&gt;                    tests = objTestSetFactory.NewList(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;61&lt;/span&gt;                    &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (TDAPIOLELib.TestSet testSet &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; tests)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;62&lt;/span&gt;                    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;63&lt;/span&gt;                        TreeNode nodeChild1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TreeNode();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;64&lt;/span&gt;                        nodeChild1.Name = testSet.ID.ToString();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;65&lt;/span&gt;                        nodeChild1.Text = testSet.Name;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;66&lt;/span&gt;                        nodeChild1.ImageIndex = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;67&lt;/span&gt;                        Add_TreeNode(parent, nodeChild1);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;68&lt;/span&gt;                        n = parent.Nodes[nodeChild1.Name];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;69&lt;/span&gt;                        n.Tag = objTSFolder.Path + &lt;span class=&quot;hljs-string&quot;&gt;@&quot;\&quot;&lt;/span&gt; + testSet.Name;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;70&lt;/span&gt;                    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;71&lt;/span&gt;                }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;72&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;73&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;74&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;75&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;76&lt;/span&gt;                Console.WriteLine(ex.ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;77&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;78&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;79&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下代码用委托的方式生成节点，保证在业务树生成过程中可随时点击并保证界面不出现假死（跟业务树生成无直接关系，可忽略）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delegate&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Add_Node&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;TreeNode parent, TreeNode node&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Add_TreeNode&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;TreeNode parent, TreeNode node&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.InvokeRequired)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.BeginInvoke(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Add_Node(Add_TreeNode), parent, node);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;                parent.Nodes.Add(node);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;            Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成业务树后，由用户通过业务树选择需要运行的节点，形成待测试列表，就是后续代码中的TestSetList，这部分代码跟QC无关，也不列举了。&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;重点之二：测试执行&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;先看一个总体调用RunTestSetPlan，当然也是需要新开线程调用的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;        Thread td_runTestSetPlan = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ThreadStart(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.RunTestSetPlan));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;        td_runTestSetPlan.Start();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用步骤是先检验validate，然后运行run，最后收集结果monitor：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;RunTestSetPlan&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (tdc.ProjectConnected == &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;                {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;                    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (TestSetNameList.Items.Count != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;                    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;                        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; TestSetList.Items.Count; i++)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;                        {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;                            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (validateTestSetID(TestSetList.Items[i].ToString(), i) == &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;                            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;                                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (runTestSet(TestSetList.Items[i].ToString(), i) == &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;                                {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;                                    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (monitorTestSet(TestSetList.Items[i].ToString()) == &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;                                    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;                                        QCexecutionStatus.RefreshExecStatusInfo(&lt;span class=&quot;hljs-string&quot;&gt;&quot;all&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);                      &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;                                    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;                                }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;                            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;                        }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;                    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;                    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;                        MessageBox.Show(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Empty Test Set List.&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Warning&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;                }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;                    MessageBox.Show(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Connection Error, please login again.&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Warning&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;                Console.WriteLine(ex.ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;validate通过QCfilter，使用testSetID去做筛选，取得我们需要的测试集，然后根据判断测试集是否为空来确定测试集是否有效，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;validateTestSetID&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; testSetID, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;            TDAPIOLELib.TestSetFactory QCtestSetFactory = (TDAPIOLELib.TestSetFactory)tdc.TestSetFactory;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;            TDAPIOLELib.TDFilter QCfilter = (TDAPIOLELib.TDFilter)QCtestSetFactory.Filter;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;            QCfilter[&lt;span class=&quot;hljs-string&quot;&gt;&quot;CY_CYCLE_ID&quot;&lt;/span&gt;] = testSetID;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;            List QClist = QCfilter.NewList();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (QClist.Count != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;            }             &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;runTest与之前类似，获取首只测试集对象后，通过QCTSTestFactory将测试集下的所有用例形成QClistForTSTest列表，并用QCscheduler执行，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;runTestSet&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; testSetID, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;                TDAPIOLELib.TestSetFactory QCtestSetFactory = (TDAPIOLELib.TestSetFactory)tdc.TestSetFactory;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;                TDAPIOLELib.TDFilter QCfilter = (TDAPIOLELib.TDFilter)QCtestSetFactory.Filter;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;                QCfilter[&lt;span class=&quot;hljs-string&quot;&gt;&quot;CY_CYCLE_ID&quot;&lt;/span&gt;] = testSetID;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;                List QClist = QCfilter.NewList();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;                TDAPIOLELib.TestSet QCtestSet = (TDAPIOLELib.TestSet)QClist[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;                TDAPIOLELib.TestSetFolder QCtestSetFolder = (TDAPIOLELib.TestSetFolder)QCtestSet.TestSetFolder;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;                TDAPIOLELib.TSTestFactory QCTSTestFactory = (TDAPIOLELib.TSTestFactory)QCtestSet.TSTestFactory;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;                QClistForTSTest = QCTSTestFactory.NewList(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;                {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;                    &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; applicationCreationTime = File.GetCreationTime(@&lt;span class=&quot;hljs-string&quot;&gt;&quot;The path of Your application&quot;&lt;/span&gt;).ToString();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;                    &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; machineName = System.Net.Dns.GetHostEntry(&lt;span class=&quot;hljs-string&quot;&gt;&quot;IP address of test machine&quot;&lt;/span&gt;).HostName.Split(&lt;span class=&quot;hljs-string&quot;&gt;'.'&lt;/span&gt;)[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;                    QCtestSet[&lt;span class=&quot;hljs-string&quot;&gt;&quot;CY_USER_01&quot;&lt;/span&gt;] = applicationCreationTime;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;                    Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;                    QCtestSet[&lt;span class=&quot;hljs-string&quot;&gt;&quot;CY_USER_02&quot;&lt;/span&gt;] = machineName;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;                    Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;                    QCtestSet.ResetTestSet(&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;                    Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;                    QCtestSet.Post();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;                    Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;                    QCtestSet.Refresh();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;                    Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;                    QCscheduler = (TDAPIOLELib.TSScheduler)QCtestSet.StartExecution(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;                    QCscheduler.Run(QClistForTSTest);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;                    Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;5000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;                    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;                }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;                {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;                    Console.WriteLine(ex.ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;38&lt;/span&gt;                    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;39&lt;/span&gt;                }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;40&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;41&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;42&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;43&lt;/span&gt;                Console.WriteLine(ex.ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;44&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;45&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;46&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Monitor，使用QCTestExecStatus中的QCexecutionStatus作为计数器，逐个判断当前步骤是否跑完，汇总运行结果，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;monitorTestSet&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; testSetID)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;        &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;                QCexecutionStatus = (TDAPIOLELib.ExecutionStatus)QCscheduler.ExecutionStatus;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;                QCexecutionStatus.RefreshExecStatusInfo(&lt;span class=&quot;hljs-string&quot;&gt;&quot;all&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;                TDAPIOLELib.TestExecStatus QCTestExecStatus;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; checkStep = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (checkStep &amp;lt;= QCexecutionStatus.Count)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;                {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;                    QCexecutionStatus.RefreshExecStatusInfo(&lt;span class=&quot;hljs-string&quot;&gt;&quot;all&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;                    QCTestExecStatus = (TDAPIOLELib.TestExecStatus)QCexecutionStatus[checkStep];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;                    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (QCTestExecStatus.Message == &lt;span class=&quot;hljs-string&quot;&gt;&quot;Nothing&quot;&lt;/span&gt; || QCTestExecStatus.Message == &lt;span class=&quot;hljs-string&quot;&gt;&quot;Waiting...&quot;&lt;/span&gt; || QCTestExecStatus.Message == &lt;span class=&quot;hljs-string&quot;&gt;&quot;Connecting...&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;                    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;                        Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;                        QCexecutionStatus.RefreshExecStatusInfo(&lt;span class=&quot;hljs-string&quot;&gt;&quot;all&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;                    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;                    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;                    {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;                        TDAPIOLELib.TSTest QCtestOfTestSet = (TDAPIOLELib.TSTest)QClistForTSTest[checkStep];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;                        QCtestOfTestSet.Refresh();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;                        &lt;span class=&quot;hljs-keyword&quot;&gt;switch&lt;/span&gt; (QCTestExecStatus.Message)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;                        {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;                            &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Completed&quot;&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;                                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (QCtestOfTestSet.Status == &lt;span class=&quot;hljs-string&quot;&gt;&quot;Passed&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;                                    CurrentStateBar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Step &quot;&lt;/span&gt; + checkStep + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; + QCtestOfTestSet.Name + &lt;span class=&quot;hljs-string&quot;&gt;&quot; execution completed -&amp;gt; &quot;&lt;/span&gt; + QCtestOfTestSet.Status);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;                                &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;                                    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (QCtestOfTestSet.Status == &lt;span class=&quot;hljs-string&quot;&gt;&quot;Failed&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;                                        CurrentStateBar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Step &quot;&lt;/span&gt; + checkStep + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; + QCtestOfTestSet.Name + &lt;span class=&quot;hljs-string&quot;&gt;&quot; execution completed -&amp;gt; &quot;&lt;/span&gt; + QCtestOfTestSet.Status);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;                                    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;                                        CurrentStateBar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Step &quot;&lt;/span&gt; + checkStep + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; + QCtestOfTestSet.Name + &lt;span class=&quot;hljs-string&quot;&gt;&quot; execution unknown -&amp;gt; &quot;&lt;/span&gt; + QCtestOfTestSet.Status);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;                                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;                            &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;No available hosts&quot;&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;                                CurrentStateBar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Step &quot;&lt;/span&gt; + checkStep + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; + QCtestOfTestSet.Name + &lt;span class=&quot;hljs-string&quot;&gt;&quot; execution failed (No available hosts) -&amp;gt; &quot;&lt;/span&gt; + QCtestOfTestSet.Status);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;                                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;                            &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Cannot get RemoteAgent's ClassID for test type &amp;lt;TestType&amp;gt;&quot;&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;                                CurrentStateBar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Step &quot;&lt;/span&gt; + checkStep + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; + QCtestOfTestSet.Name + &lt;span class=&quot;hljs-string&quot;&gt;&quot; Cannot get RemoteAgent's ClassID for test type &amp;lt;TestType&amp;gt; -&amp;gt; &quot;&lt;/span&gt; + QCtestOfTestSet.Status);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;38&lt;/span&gt;                                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;39&lt;/span&gt;                            &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Host connected&quot;&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;40&lt;/span&gt;                                CurrentStateBar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Step &quot;&lt;/span&gt; + checkStep + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; + QCtestOfTestSet.Name + &lt;span class=&quot;hljs-string&quot;&gt;&quot; execution failed (Host connected) -&amp;gt; &quot;&lt;/span&gt; + QCtestOfTestSet.Status);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;41&lt;/span&gt;                                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;42&lt;/span&gt;                            &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;43&lt;/span&gt;                                CurrentStateBar(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Step &quot;&lt;/span&gt; + checkStep + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; + QCtestOfTestSet.Name + &lt;span class=&quot;hljs-string&quot;&gt;&quot; unhandled case -&amp;gt; &quot;&lt;/span&gt; + QCtestOfTestSet.Status);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;44&lt;/span&gt;                                &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;45&lt;/span&gt;                        }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;46&lt;/span&gt;                        checkStep = checkStep + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;47&lt;/span&gt;                    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;48&lt;/span&gt;                }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;49&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;50&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;51&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;52&lt;/span&gt;            {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;53&lt;/span&gt;                Console.WriteLine(ex.ToString());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;54&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;55&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;56&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，整个测试运行过程结束。关于收集结果中除了主线程结果刷新之外，还需要有其他线程做结果的收集和展示，否则无法实现动态实时展示，这部分代码与QC无直接关系，也暂时不展示。&lt;/p&gt;
&lt;p&gt;可以看出，本文所涉及的内容，对于测试框架来说，也仅仅是一小部分。关于其他部分，以后有时间再分拆开逐一讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1273095/201812/1273095-20181228005742347-1815150888.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 15:42:00 +0000</pubDate>
<dc:creator>泽南-Alpha</dc:creator>
<og:description>（原创文章，转载请注明出处。） 一、QC简介： Quality Center存在至今已经走过了10多个年头，名字从一开始的TD，到后来的QC，再到现在的ALM。所属公司从开始的Mercury到现在的H</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alphaxu/p/10188187.html</dc:identifier>
</item>
<item>
<title>编程实战：C语言制作垃圾回收器 - 修语谈谈C/C++</title>
<link>http://www.cnblogs.com/2f3d/p/10188181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/2f3d/p/10188181.html</guid>
<description>&lt;p&gt;人们似乎认为编写垃圾回收机制是很难的，是一种只有少数智者和&lt;a href=&quot;http://hboehm.info/gc/index.html&quot; target=&quot;_blank&quot;&gt;Hans Boehm(et al)&lt;/a&gt;才能理解的高深魔法。我认为编写垃圾回收最难的地方就是内存分配，这和阅读K&amp;amp;R所写的malloc样例难度是相当的。&lt;/p&gt;
&lt;p&gt;在开始之前有一些重要的事情需要说明一下：第一，我们所写的代码是基于Linux Kernel的，注意是Linux Kernel而不是GNU/Linux。第二，我们的代码是32bit的。第三，请不要直接使用这些代码。我并不保证这些代码完全正确，可能其中有一些我还未发现的小的bug，但是整体思路仍然是正确的。好了，让我们开始吧。&lt;/p&gt;
&lt;h3&gt;编写malloc&lt;/h3&gt;
&lt;p&gt;最开始，我们需要写一个内存分配器(memmory allocator)，也可以叫做内存分配函数(malloc function)。最简单的内存分配实现方法就是维护一个由空闲内存块组成的链表，这些空闲内存块在需要的时候被分割或分配。当用户请求一块内存时，一块合适大小的内存块就会从链表中被移除并分配给用户。如果链表中没有合适的空闲内存块存在，而且更大的空闲内存块已经被分割成小的内存块了或内核也正在请求更多的内存(译者注：就是链表中的空闲内存块都太小不足以分配给用户的情况)。那么此时，会释放掉一块内存并把它添加到空闲块链表中。&lt;/p&gt;
&lt;p&gt;在链表中的每个空闲内存块都有一个头(header)用来描述内存块的信息。我们的header包含两个部分，第一部分表示内存块的大小，第二部分指向下一个空闲内存块。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;; html-script: false ]    typedef struct header{&lt;/p&gt;
&lt;p&gt;        unsigned int  size;&lt;/p&gt;
&lt;p&gt;        struct block  *next;&lt;/p&gt;
&lt;p&gt;    } header_t;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将头(header)内嵌进内存块中是唯一明智的做法，而且这样还可以享有字节自动对齐的好处，这很重要。&lt;/p&gt;
&lt;p&gt;由于我们需要同时跟踪我们“当前使用过的内存块”和“未使用的内存块”，因此除了维护空闲内存的链表外，我们还需要一条维护当前已用内存块的链表(为了方便，这两条链表后面分别写为“空闲块链表”和“已用块链表”)。我们从空闲块链表中移除的内存块会被添加到已用块链表中，反之亦然。&lt;/p&gt;
&lt;p&gt;现在我们差不多已经做好准备来完成malloc实现的第一步了。但是再那之前，我们需要知道怎样向内核申请内存。&lt;/p&gt;
&lt;p&gt;动态分配的内存会驻留在一个叫做堆(heap)的地方，堆是介于栈(stack)和BSS(未初始化的数据段－你所有的全局变量都存放在这里且具有默认值为0)之间的一块内存。堆(heap)的内存地址起始于(低地址)BSS段的边界，结束于一个分隔地址(这个分隔地址是已建立映射的内存和未建立映射的内存的分隔线)。为了能够从内核中获取更多的内存，我们只需提高这个分隔地址。为了提高这个分隔地址我们需要调用一个叫作 sbrk 的Unix系统的系统调用，这个函数可以根据我们提供的参数来提高分隔地址，如果函数执行成功则会返回以前的分隔地址，如果失败将会返回－1。&lt;/p&gt;
&lt;p&gt;利用我们现在知道的知识，我们可以创建两个函数：morecore()和add_to_free_list()。当空闲块链表缺少内存块时，我们调用morecore()函数来申请更多的内存。由于每次向内核申请内存的代价是昂贵的，我们以页(page-size)为单位申请内存。页的大小在这并不是很重要的知识点，不过这有一个很简单解释：页是虚拟内存映射到物理内存的最小内存单位。接下来我们就可以使用add_to_list()将申请到的内存块加入空闲块链表。&lt;/p&gt;
&lt;blockquote readability=&quot;52&quot;&gt;
&lt;p&gt;; html-script: false ]/*&lt;/p&gt;
&lt;p&gt;* Scan the free list and look for a place to put the block. Basically, we're&lt;/p&gt;
&lt;p&gt;* looking for any block the to be freed block might have been partitioned from.&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;static void&lt;/p&gt;
&lt;p&gt;add_to_free_list(header_t *bp)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    header_t *p;&lt;/p&gt;

&lt;p&gt;    for (p = freep; !(bp &amp;gt; p &amp;amp;&amp;amp; bp &amp;lt; p-&amp;gt;next); p = p-&amp;gt;next)&lt;/p&gt;
&lt;p&gt;        if (p &amp;gt;= p-&amp;gt;next &amp;amp;&amp;amp; (bp &amp;gt; p || bp &amp;lt; p-&amp;gt;next))&lt;/p&gt;
&lt;p&gt;            break;&lt;/p&gt;

&lt;p&gt;    if (bp + bp-&amp;gt;size == p-&amp;gt;next) {&lt;/p&gt;
&lt;p&gt;        bp-&amp;gt;size += p-&amp;gt;next-&amp;gt;size;&lt;/p&gt;
&lt;p&gt;        bp-&amp;gt;next = p-&amp;gt;next-&amp;gt;next;&lt;/p&gt;
&lt;p&gt;    } else&lt;/p&gt;
&lt;p&gt;        bp-&amp;gt;next = p-&amp;gt;next;&lt;/p&gt;

&lt;p&gt;    if (p + p-&amp;gt;size == bp) {&lt;/p&gt;
&lt;p&gt;        p-&amp;gt;size += bp-&amp;gt;size;&lt;/p&gt;
&lt;p&gt;        p-&amp;gt;next = bp-&amp;gt;next;&lt;/p&gt;
&lt;p&gt;    } else&lt;/p&gt;
&lt;p&gt;        p-&amp;gt;next = bp;&lt;/p&gt;

&lt;p&gt;    freep = p;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;#define MIN_ALLOC_SIZE 4096 /* We allocate blocks in page sized chunks. */&lt;/p&gt;

&lt;p&gt;/*&lt;/p&gt;
&lt;p&gt;* Request more memory from the kernel.&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;static header_t *&lt;/p&gt;
&lt;p&gt;morecore(size_t num_units)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    void *vp;&lt;/p&gt;
&lt;p&gt;    header_t *up;&lt;/p&gt;

&lt;p&gt;    if (num_units &amp;lt; MIN_ALLOC_SIZE)&lt;/p&gt;
&lt;p&gt;        num_units = MIN_ALLOC_SIZE / sizeof(header_t);&lt;/p&gt;

&lt;p&gt;    if ((vp = sbrk(num_units * sizeof(header_t))) == (void *) -1)&lt;/p&gt;
&lt;p&gt;        return NULL;&lt;/p&gt;

&lt;p&gt;    up = (header_t *) vp;&lt;/p&gt;
&lt;p&gt;    up-&amp;gt;size = num_units;&lt;/p&gt;
&lt;p&gt;    add_to_free_list (up);&lt;/p&gt;
&lt;p&gt;    return freep;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在我们有了两个有力的函数，接下来我们就可以直接编写malloc函数了。我们扫描空闲块链表当遇到第一块满足要求的内存块(内存块比所需内存大即满足要求)时，停止扫描，而不是扫描整个链表来寻找大小最合适的内存块，我们所采用的这种算法思想其实就是首次适应(与最佳适应相对)。&lt;/p&gt;
&lt;p&gt;注意：有件事情需要说明一下，内存块头部结构中size这一部分的计数单位是块(Block)，而不是Byte。&lt;/p&gt;
&lt;blockquote readability=&quot;66&quot;&gt;
&lt;p&gt;; html-script: false ]    &lt;/p&gt;
&lt;p&gt;static header_t base; /* Zero sized block to get us started. */&lt;/p&gt;
&lt;p&gt;static header_t *usedp, *freep;&lt;/p&gt;
&lt;p&gt;/*&lt;/p&gt;
&lt;p&gt;* Find a chunk from the free list and put it in the used list.&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;void *&lt;/p&gt;
&lt;p&gt;GC_malloc(size_t alloc_size)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    size_t num_units;&lt;/p&gt;
&lt;p&gt;    header_t *p, *prevp;&lt;/p&gt;

&lt;p&gt;    num_units = (alloc_size + sizeof(header_t) - 1) / sizeof(header_t) + 1;  &lt;/p&gt;
&lt;p&gt;    prevp = freep;&lt;/p&gt;

&lt;p&gt;    for (p = prevp-&amp;gt;next;; prevp = p, p = p-&amp;gt;next) {&lt;/p&gt;
&lt;p&gt;        if (p-&amp;gt;size &amp;gt;= num_units) { /* Big enough. */&lt;/p&gt;
&lt;p&gt;            if (p-&amp;gt;size == num_units) /* Exact size. */&lt;/p&gt;
&lt;p&gt;                prevp-&amp;gt;next = p-&amp;gt;next;&lt;/p&gt;
&lt;p&gt;            else {&lt;/p&gt;
&lt;p&gt;                p-&amp;gt;size -= num_units;&lt;/p&gt;
&lt;p&gt;                p += p-&amp;gt;size;&lt;/p&gt;
&lt;p&gt;                p-&amp;gt;size = num_units;&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;

&lt;p&gt;            freep = prevp;&lt;/p&gt;

&lt;p&gt;            /* Add to p to the used list. */&lt;/p&gt;
&lt;p&gt;            if (usedp == NULL)  &lt;/p&gt;
&lt;p&gt;                usedp = p-&amp;gt;next = p;&lt;/p&gt;
&lt;p&gt;            else {&lt;/p&gt;
&lt;p&gt;                p-&amp;gt;next = usedp-&amp;gt;next;&lt;/p&gt;
&lt;p&gt;                usedp-&amp;gt;next = p;&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;

&lt;p&gt;            return (void *) (p + 1);&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        if (p == freep) { /* Not enough memory. */&lt;/p&gt;
&lt;p&gt;            p = morecore(num_units);&lt;/p&gt;
&lt;p&gt;            if (p == NULL) /* Request for more memory failed. */&lt;/p&gt;
&lt;p&gt;                return NULL;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意这个函数的成功与否，取决于我们第一次使用时是否使 freep = &amp;amp;base 。这点我们会在初始化函数中进行设置。&lt;/p&gt;
&lt;p&gt;尽管我们的代码完全没有考虑到内存碎片，但是它能工作。既然它可以工作，我们就可以开始下一个有趣的部分－垃圾回收！&lt;/p&gt;
&lt;h3&gt;标记和清扫&lt;/h3&gt;
&lt;p&gt;我们说过垃圾回收器会很简单，因此我们尽可能的使用简单的方法：标记和清除方式。这个算法分为两个部分：&lt;/p&gt;
&lt;p&gt;首先，我们需要扫描所有可能存在指向堆中数据(heap data)的变量的内存空间并确认这些内存空间中的变量是否指向堆中的数据。为了做到这点，对于可能内存空间中的每个字长(word-size)的数据块，我们遍历已用块链表中的内存块。如果数据块所指向的内存是在已用链表块中的某一内存块中，我们对这个内存块进行标记。&lt;/p&gt;
&lt;p&gt;第二部分是，当扫描完所有可能的内存空间后，我们遍历已用块链表将所有未被标记的内存块移到空闲块链表中。&lt;/p&gt;
&lt;p&gt;现在很多人会开始认为只是靠编写类似于malloc那样的简单函数来实现C的垃圾回收是不可行的，因为在函数中我们无法获得其外面的很多信息。例如，在C语言中没有函数可以返回分配到堆栈中的所有变量的哈希映射。但是只要我们意识到两个重要的事实，我们就可以绕过这些东西：&lt;/p&gt;
&lt;p&gt;第一，在C中，你可以尝试访问任何你想访问的内存地址。因为不可能有一个数据块编译器可以访问但是其地址却不能被表示成一个可以赋值给指针的整数。如果一块内存在C程序中被使用了，那么它一定可以被这个程序访问。这是一个令不熟悉C的编程者很困惑的概念，因为很多编程语言都会限制程序访问虚拟内存，但是C不会。&lt;/p&gt;
&lt;p&gt;第二，所有的变量都存储在内存的某个地方。这意味着如果我们可以知道变量们的通常存储位置，我们可以遍历这些内存位置来寻找每个变量的所有可能值。另外，因为内存的访问通常是字(word-size)对齐的，因此我们仅需要遍历内存区域中的每个字(word)即可。&lt;/p&gt;
&lt;p&gt;局部变量也可以被存储在寄存器中，但是我们并不需要担心这些因为寄存器经常会用于存储局部变量，而且当函数被调用的时候他们通常会被存储在堆栈中。&lt;/p&gt;
&lt;p&gt;现在我们有一个标记阶段的策略：遍历一系列的内存区域并查看是否有内存可能指向已用块链表。编写这样的一个函数非常的简洁明了：&lt;/p&gt;
&lt;blockquote readability=&quot;30&quot;&gt;
&lt;p&gt;; html-script: false ]&lt;/p&gt;
&lt;p&gt;#define UNTAG(p) (((unsigned int) (p)) &amp;amp; 0xfffffffc)&lt;/p&gt;

&lt;p&gt;/*&lt;/p&gt;
&lt;p&gt;* Scan a region of memory and mark any items in the used list appropriately.&lt;/p&gt;
&lt;p&gt;* Both arguments should be word aligned.&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;static void&lt;/p&gt;
&lt;p&gt;mark_from_region(unsigned int *sp, unsigned int *end)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    header_t *bp;&lt;/p&gt;

&lt;p&gt;    for (; sp &amp;lt; end; sp++) {&lt;/p&gt;
&lt;p&gt;        unsigned int v = *sp;&lt;/p&gt;
&lt;p&gt;        bp = usedp;&lt;/p&gt;
&lt;p&gt;        do {&lt;/p&gt;
&lt;p&gt;            if (bp + 1 &amp;lt;= v &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;                bp + 1 + bp-&amp;gt;size &amp;gt; v) {&lt;/p&gt;
&lt;p&gt;                    bp-&amp;gt;next = ((unsigned int) bp-&amp;gt;next) | 1;&lt;/p&gt;
&lt;p&gt;                    break;&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;
&lt;p&gt;        } while ((bp = UNTAG(bp-&amp;gt;next)) != usedp);&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了确保我们只使用头(header)中的两个字长(two words)我们使用一种叫做标记指针(tagged pointer)的技术。利用header中的next指针指向的地址总是字对齐(word aligned)这一特点，我们可以得出指针低位的几个有效位总会是0。因此我们将next指针的最低位进行标记来表示当前块是否被标记。&lt;/p&gt;
&lt;p&gt;现在，我们可以扫描内存区域了，但是我们应该扫描哪些内存区域呢？我们要扫描的有以下这些：&lt;/p&gt;
&lt;p&gt;BBS(未初始化数据段)和初始化数据段。这里包含了程序的全局变量和局部变量。因为他们有可能应用堆(heap)中的一些东西，所以我们需要扫描BSS与初始化数据段。&lt;/p&gt;
&lt;p&gt;已用的数据块。当然，如果用户分配一个指针来指向另一个已经被分配的内存块，我们不会想去释放掉那个被指向的内存块。&lt;/p&gt;
&lt;p&gt;堆栈。因为堆栈中包含所有的局部变量，因此这可以说是最需要扫描的区域了。&lt;/p&gt;
&lt;p&gt;我们已经了解了关于堆(heap)的一切，因此编写一个mark_from_heap函数将会非常简单：&lt;/p&gt;
&lt;blockquote readability=&quot;44&quot;&gt;
&lt;p&gt;; html-script: false ] /*&lt;/p&gt;
&lt;p&gt;* Scan the marked blocks for references to other unmarked blocks.&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;static void&lt;/p&gt;
&lt;p&gt;mark_from_heap(void)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    unsigned int *vp;&lt;/p&gt;
&lt;p&gt;    header_t *bp, *up;&lt;/p&gt;

&lt;p&gt;    for (bp = UNTAG(usedp-&amp;gt;next); bp != usedp; bp = UNTAG(bp-&amp;gt;next)) {&lt;/p&gt;
&lt;p&gt;        if (!((unsigned int)bp-&amp;gt;next &amp;amp; 1))&lt;/p&gt;
&lt;p&gt;            continue;&lt;/p&gt;
&lt;p&gt;        for (vp = (unsigned int *)(bp + 1);&lt;/p&gt;
&lt;p&gt;             vp &amp;lt; (bp + bp-&amp;gt;size + 1);&lt;/p&gt;
&lt;p&gt;             vp++) {&lt;/p&gt;
&lt;p&gt;            unsigned int v = *vp;&lt;/p&gt;
&lt;p&gt;            up = UNTAG(bp-&amp;gt;next);&lt;/p&gt;
&lt;p&gt;            do {&lt;/p&gt;
&lt;p&gt;                if (up != bp &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;                    up + 1 &amp;lt;= v &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;                    up + 1 + up-&amp;gt;size &amp;gt; v) {&lt;/p&gt;
&lt;p&gt;                    up-&amp;gt;next = ((unsigned int) up-&amp;gt;next) | 1;&lt;/p&gt;
&lt;p&gt;                    break;&lt;/p&gt;
&lt;p&gt;                }&lt;/p&gt;
&lt;p&gt;            } while ((up = UNTAG(up-&amp;gt;next)) != bp);&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;幸运的是对于BSS段和已初始化数据段，大部分的现代unix链接器可以导出 etext 和 end 符号。etext符号的地址是初始化数据段的起点(the last address past the text segment，这个段中包含了程序的机器码)，end符号是堆(heap)的起点。因此，BSS和已初始化数据段位于 &amp;amp;etext 与 &amp;amp;end 之间。这个方法足够简单，当不是平台独立的。&lt;/p&gt;
&lt;p&gt;堆栈这部分有一点困难。堆栈的栈顶非常容易找到，只需要使用一点内联汇编即可，因为它存储在 sp 这个寄存器中。但是我们将会使用的是 bp 这个寄存器，因为它忽略了一些局部变量。&lt;/p&gt;
&lt;p&gt;寻找堆栈的的栈底(堆栈的起点)涉及到一些技巧。出于安全因素的考虑，内核倾向于将堆栈的起点随机化，因此我们很难得到一个地址。老实说，我在寻找栈底方面并不是专家，但是我有一些点子可以帮你找到一个准确的地址。一个可能的方法是，你可以扫描调用栈(call stack)来寻找 env 指针，这个指针会被作为一个参数传递给主程序。另一种方法是从栈顶开始读取每个更大的后续地址并处理inexorible SIGSEGV。但是我们并不打算采用这两种方法中的任何一种，我们将利用linux会将栈底放入一个字符串并存于proc目录下表示该进程的文件中这一事实。这听起来很愚蠢而且非常间接。值得庆幸的是，我并不感觉这样做是滑稽的，因为它和Boehm GC中寻找栈底所用的方法完全相同。&lt;/p&gt;
&lt;p&gt;现在我们可以编写一个简单的初始化函数。在函数中，我们打开proc文件并找到栈底。栈底是文件中第28个值，因此我们忽略前27个值。Boehm GC和我们的做法不同的是他仅使用系统调用来读取文件来避免让stdlib库使用堆(heap)，但是我们并不在意这些。&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;; html-script: false ]/*&lt;/p&gt;
&lt;p&gt;* Find the absolute bottom of the stack and set stuff up.&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;void&lt;/p&gt;
&lt;p&gt;GC_init(void)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    static int initted;&lt;/p&gt;
&lt;p&gt;    FILE *statfp;&lt;/p&gt;

&lt;p&gt;    if (initted)&lt;/p&gt;
&lt;p&gt;        return;&lt;/p&gt;

&lt;p&gt;    initted = 1;&lt;/p&gt;

&lt;p&gt;    statfp = fopen(&quot;/proc/self/stat&quot;, &quot;r&quot;);&lt;/p&gt;
&lt;p&gt;    assert(statfp != NULL);&lt;/p&gt;
&lt;p&gt;    fscanf(statfp,&lt;/p&gt;
&lt;p&gt;           &quot;%*d %*s %*c %*d %*d %*d %*d %*d %*u &quot;&lt;/p&gt;
&lt;p&gt;           &quot;%*lu %*lu %*lu %*lu %*lu %*lu %*ld %*ld &quot;&lt;/p&gt;
&lt;p&gt;           &quot;%*ld %*ld %*ld %*ld %*llu %*lu %*ld &quot;&lt;/p&gt;
&lt;p&gt;           &quot;%*lu %*lu %*lu %lu&quot;, &amp;amp;stack_bottom);&lt;/p&gt;
&lt;p&gt;    fclose(statfp);&lt;/p&gt;

&lt;p&gt;    usedp = NULL;&lt;/p&gt;
&lt;p&gt;    base.next = freep = &amp;amp;base;&lt;/p&gt;
&lt;p&gt;    base.size = 0;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在我们知道了每个我们需要扫描的内存区域的位置，所以我们终于可以编写显示调用的回收函数了：&lt;/p&gt;
&lt;blockquote readability=&quot;74&quot;&gt;
&lt;p&gt;; html-script: false ] /*&lt;/p&gt;
&lt;p&gt;* Mark blocks of memory in use and free the ones not in use.&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;void&lt;/p&gt;
&lt;p&gt;GC_collect(void)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    header_t *p, *prevp, *tp;&lt;/p&gt;
&lt;p&gt;    unsigned long stack_top;&lt;/p&gt;
&lt;p&gt;    extern char end, etext; /* Provided by the linker. */&lt;/p&gt;

&lt;p&gt;    if (usedp == NULL)&lt;/p&gt;
&lt;p&gt;        return;&lt;/p&gt;

&lt;p&gt;    /* Scan the BSS and initialized data segments. */&lt;/p&gt;
&lt;p&gt;    mark_from_region(&amp;amp;etext, &amp;amp;end);&lt;/p&gt;

&lt;p&gt;    /* Scan the stack. */&lt;/p&gt;
&lt;p&gt;    asm volatile (&quot;movl    %%ebp, %0&quot; : &quot;=r&quot; (stack_top));&lt;/p&gt;
&lt;p&gt;    mark_from_region(stack_top, stack_bottom);&lt;/p&gt;

&lt;p&gt;    /* Mark from the heap. */&lt;/p&gt;
&lt;p&gt;    mark_from_heap();&lt;/p&gt;

&lt;p&gt;    /* And now we collect! */&lt;/p&gt;
&lt;p&gt;    for (prevp = usedp, p = UNTAG(usedp-&amp;gt;next);; prevp = p, p = UNTAG(p-&amp;gt;next)) {&lt;/p&gt;
&lt;p&gt;    next_chunk:&lt;/p&gt;
&lt;p&gt;        if (!((unsigned int)p-&amp;gt;next &amp;amp; 1)) {&lt;/p&gt;
&lt;p&gt;            /*&lt;/p&gt;
&lt;p&gt;             * The chunk hasn't been marked. Thus, it must be set free.&lt;/p&gt;
&lt;p&gt;             */&lt;/p&gt;
&lt;p&gt;            tp = p;&lt;/p&gt;
&lt;p&gt;            p = UNTAG(p-&amp;gt;next);&lt;/p&gt;
&lt;p&gt;            add_to_free_list(tp);&lt;/p&gt;

&lt;p&gt;            if (usedp == tp) {&lt;/p&gt;
&lt;p&gt;                usedp = NULL;&lt;/p&gt;
&lt;p&gt;                break;&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;

&lt;p&gt;            prevp-&amp;gt;next = (unsigned int)p | ((unsigned int) prevp-&amp;gt;next &amp;amp; 1);&lt;/p&gt;
&lt;p&gt;            goto next_chunk;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        p-&amp;gt;next = ((unsigned int) p-&amp;gt;next) &amp;amp; ~1;&lt;/p&gt;
&lt;p&gt;        if (p == usedp)&lt;/p&gt;
&lt;p&gt;            break;&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;朋友们，所有的东西都已经在这了，一个用C为C程序编写的垃圾回收器。这些代码自身并不是完整的，它还需要一些微调来使它可以正常工作，但是大部分代码是可以独立工作的。&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;一开始就打算编写完整的程序是很困难的，你编程的唯一算法就是分而治之。先编写内存分配函数，然后编写查询内存的函数，然后是清除内存的函数。最后将它们合在一起。&lt;/p&gt;
&lt;p&gt;当你在编程方面克服这个障碍后，就再也没有困难的实践了。你可能有一个算法不太了解，但是任何人只要有足够的时间就肯定可以通过论文或书理解这个算法。如果有一个项目看起来令人生畏，那么将它分成完全独立的几个部分。你可能不懂如何编写一个解释器，但你绝对可以编写一个分析器，然后看一下你还有什么需要添加的，添上它。相信自己，终会成功！&lt;/p&gt;
&lt;p&gt;喜欢小编文章的小伙伴可以给小编点赞或者转发哦！小编先感谢各位看官了！&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 15:36:00 +0000</pubDate>
<dc:creator>修语谈谈C/C++</dc:creator>
<og:description>人们似乎认为编写垃圾回收机制是很难的，是一种只有少数智者和Hans Boehm(et al)才能理解的高深魔法。我认为编写垃圾回收最难的地方就是内存分配，这和阅读K&amp;R所写的malloc样例难</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/2f3d/p/10188181.html</dc:identifier>
</item>
<item>
<title>利用OC对象的消息重定向forwardingTargetForSelector方法构建高扩展性的滤镜功能 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/10188140.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/10188140.html</guid>
<description>&lt;p&gt;在OC中，当像一个对象发送消息，而对象找到消息后，从它的类方法列表，父类方法列表，一直找到根类方法列表都没有找到与这个选择子对应的函数指针。那么这个对象就会触发消息转发机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OC对象的继承链和isa指针链如图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201812/826860-20181227230728133-1377379450.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;消息转发流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.先调用实例方法resolveInstanceMethod&lt;/p&gt;
&lt;p&gt;如果作者在这里使用runtime动态添加对应的方法，并且返回yes。就万事大吉。对象找到了处理的方法，&lt;/p&gt;
&lt;p&gt;并且将这个新增的方法添加到类的方法缓存列表&lt;/p&gt;
&lt;p&gt;2.如果上面的方法返回NO的话，对象会调用forwardingTargetForSelector方法&lt;/p&gt;
&lt;p&gt;允许作者选择其他的对象，处理这个消息。&lt;/p&gt;
&lt;p&gt;这个方法，也是待会我们要做文章的地方。画重点。&lt;/p&gt;
&lt;p&gt;3.如果上面两个方法都没有做处理，那么对象会执行最后一个方法methodSignatureForSelector,提供一个有效的方法签名，若提供了有效的方法签名，程序将会通过forwardInvocation方法执行签名。若没有提供方法签名就会触发doesNotRecognizeSelector方法，触发崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整个调用流程图如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201812/826860-20181227230936724-1782825178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 整个代码调用顺序如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
+&lt;span&gt; (BOOL)resolveClassMethod:(SEL)sel {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;1---%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NSStringFromSelector(sel));
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;1---%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NSStringFromSelector(_cmd));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NO;
}
&lt;/span&gt;+&lt;span&gt; (BOOL)resolveInstanceMethod:(SEL)sel {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;1---%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NSStringFromSelector(sel));
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;1---%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NSStringFromSelector(_cmd));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NO;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
- (&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)forwardingTargetForSelector:(SEL)aSelector {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;2---%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NSStringFromSelector(aSelector));
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;2---%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NSStringFromSelector(_cmd));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.最后一步，返回方法签名&lt;/span&gt;
-(NSMethodSignature *&lt;span&gt;)methodSignatureForSelector:(SEL)aSelector{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;3---%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NSStringFromSelector(aSelector));
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;3---%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NSStringFromSelector(_cmd));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ([NSStringFromSelector(aSelector) isEqualToString:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;gogogo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [[UnknownModel2 &lt;span&gt;new&lt;/span&gt;&lt;span&gt;] methodSignatureForSelector:aSelector];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [super methodSignatureForSelector:aSelector];
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.1处理返回的方法签名&lt;/span&gt;
-(&lt;span&gt;void&lt;/span&gt;)forwardInvocation:(NSInvocation *&lt;span&gt;)anInvocation{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;4---%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NSStringFromSelector(_cmd));
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;4-最后一步--%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,anInvocation);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ([NSStringFromSelector(anInvocation.selector) isEqualToString:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;gogogo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]) {
        [anInvocation invokeWithTarget:[UnknownModel2 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;]];
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        [super forwardInvocation:anInvocation];
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发崩溃&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)doesNotRecognizeSelector:(SEL)aSelector {
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.469445&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt;---&lt;span&gt;gogogo
 &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.469613&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt;---&lt;span&gt;resolveInstanceMethod:
 &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.469765&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;2&lt;/span&gt;---&lt;span&gt;gogogo
 &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.469873&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;2&lt;/span&gt;---&lt;span&gt;forwardingTargetForSelector:
 &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.469978&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;3&lt;/span&gt;---&lt;span&gt;gogogo
 &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.470097&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;3&lt;/span&gt;---&lt;span&gt;methodSignatureForSelector:
 &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.470247&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt;---&lt;span&gt;_forwardStackInvocation:
 &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.470355&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt;---&lt;span&gt;resolveInstanceMethod:
 &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.470765&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;4&lt;/span&gt;---&lt;span&gt;forwardInvocation:
 &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.471367&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] &lt;span&gt;4&lt;/span&gt;-最后一步--&amp;lt;NSInvocation: &lt;span&gt;0x600002442000&lt;/span&gt;&amp;gt;
 &lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;27&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;00.471969&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; iOS_KnowledgeStructure[&lt;span&gt;7940&lt;/span&gt;:&lt;span&gt;110114&lt;/span&gt;] lalalalala---gogogo
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;OC消息转发的应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当消息转发走到第二步时forwardingTargetForSelector，会让对象提供一个第三者来处理这个消息。&lt;/p&gt;
&lt;p&gt;那么可以得出结论：只要对对象发送没有实现的消息，对象最后就会寻找一个第三者来接收这个消息。&lt;/p&gt;
&lt;p&gt;下面就利用消息转发机制，构建装饰器，来实现图像滤镜功能。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 科普一下装饰器模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;装饰器模式概念：&lt;/p&gt;
&lt;p&gt;装饰器模式是向对象添加东西（行为），而不破坏原有对象内容结构的一种设计模式。举个例子，对象如同照片，装饰器如同相框。而一张照片可以放到多种相框内产生多种赏心悦目的效果，而又不会对照片产生改变。&lt;/p&gt;

&lt;p&gt;装饰器模式UML图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201812/826860-20181227231339359-890630233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明如下：&lt;/p&gt;
&lt;p&gt;1.Component为抽象父类，它为组件声明了一些操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConcreteComponent为实例组件类，相当于图像滤镜中的原材料“图片”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.Decorator为从Component父类实现而来的子抽象类，它是装饰器的抽象父类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它里面包含了组件“图片”（图中的属性：component）的引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.Component父类，Decorator父类都包含了operation接口。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.下面的“由装饰器扩展功能”的标示部分，展示了用装饰器为组件“图片”添加功能的实际使用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图像滤镜的UML类图为： &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201812/826860-20181227231546817-1157379382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图像滤镜的uml类图同装饰器类图的uml结构一致。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ImageComponent抽象父类定义接口，UIImage作为实例组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ImageFilter作为滤镜父类接口，扩充类apply方法。并且对组件(component)添加引用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重点 重点 重点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在 forwardingTargetForSelector中先调用自己的apply方法，然后返回它所引用的component.&lt;/p&gt;
&lt;p&gt;1.因为ImageFilter装饰器中没有draw:方法，所以向Image对象发送[self setNeedDisplay]消息时，ImageFilter对象会调用自己的forwardingTargetForSelector方法，这方法内包含了当前装饰器的功能扩展，会执行扩展功能。&lt;/p&gt;
&lt;p&gt;2.方法的最后有return component; 这一句是进行消息转发，让component对象进行处理这次绘制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 主要代码实现如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mageComponent抽象父类接口设计如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;&lt;span&gt;
NS_ASSUME_NONNULL_BEGIN
&lt;/span&gt;&lt;span&gt;@protocol&lt;/span&gt; ZHFImageComponent &amp;lt;NSObject&amp;gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)drawAtPoint:(CGPoint)point;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)drawAtPoint:(CGPoint)point blendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)drawInRect:(CGRect)rect;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)drawInRect:(CGRect)rect blendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)drawAsPatternInRect:(CGRect)rect;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;&lt;span&gt;
NS_ASSUME_NONNULL_END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Image实例组件代码如下：&lt;/p&gt;
&lt;p&gt;只是声明了遵守ImageComponent的协议。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;UIKit/UIKit.h&amp;gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZHFImageComponent.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
NS_ASSUME_NONNULL_BEGIN
&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt; UIImage (ZHFImageComponent) &amp;lt;ZHFImageComponent&amp;gt;
&lt;span&gt;@end&lt;/span&gt;&lt;span&gt;
NS_ASSUME_NONNULL_END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;装饰器接口代码如下：&lt;/p&gt;
&lt;p&gt; .h文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZHFImageComponent.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
NS_ASSUME_NONNULL_BEGIN
&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt; ZHFImageFilter : NSObject &amp;lt;ZHFImageComponent&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;@private&lt;/span&gt;
    &lt;span&gt;id&lt;/span&gt;&amp;lt;ZHFImageComponent&amp;gt;&lt;span&gt; component_;
}
@property (nonatomic, strong) &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&amp;lt;ZHFImageComponent&amp;gt;&lt;span&gt; component;
&lt;/span&gt;- (instancetype)initWithImageComponent:(&lt;span&gt;id&lt;/span&gt;&amp;lt;ZHFImageComponent&amp;gt;&lt;span&gt;)component;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)apply;
&lt;/span&gt;- (&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)forwardingTargetForSelector:(SEL)aSelector;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;&lt;span&gt;
NS_ASSUME_NONNULL_END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; .m文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZHFImageFilter.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ZHFImageFilter
&lt;/span&gt;&lt;span&gt;@synthesize&lt;/span&gt; component =&lt;span&gt; component_;
&lt;/span&gt;- (instancetype)initWithImageComponent:(&lt;span&gt;id&lt;/span&gt;&amp;lt;ZHFImageComponent&amp;gt;&lt;span&gt;)component {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (self =&lt;span&gt; [super init]) {
        self.component &lt;/span&gt;=&lt;span&gt; component;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self;
}
&lt;/span&gt;- (&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)forwardingTargetForSelector:(SEL)aSelector {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ([NSStringFromSelector(aSelector) hasPrefix:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;draw&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]) {
        [self apply];
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用消息转发给另一个对象处理，来实现任务处理链条，非常巧妙！！！&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; component_;
}
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;forwardingTargetForSelector方法的实现是整个装饰器的灵魂，子类其实只是调用父类的这个方法而已。&lt;/p&gt;
&lt;p&gt;形变装饰器代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZHFImageFilter.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
NS_ASSUME_NONNULL_BEGIN
&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; ZHFImageTransformFilter : ZHFImageFilter
{
    &lt;/span&gt;&lt;span&gt;@private&lt;/span&gt;&lt;span&gt;
    CGAffineTransform transform_;
}
@property (nonatomic, assign) CGAffineTransform transform;
&lt;/span&gt;- (instancetype)initWithImageComponent:(&lt;span&gt;id&lt;/span&gt;&amp;lt;ZHFImageComponent&amp;gt;&lt;span&gt;)component
                             transform:(CGAffineTransform)transform;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;&lt;span&gt;
NS_ASSUME_NONNULL_END

&lt;/span&gt;&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZHFImageTransformFilter.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ZHFImageTransformFilter
&lt;/span&gt;&lt;span&gt;@synthesize&lt;/span&gt; transform =&lt;span&gt; transform_;
&lt;/span&gt;- (instancetype)initWithImageComponent:(&lt;span&gt;id&lt;/span&gt;&amp;lt;ZHFImageComponent&amp;gt;&lt;span&gt;)component
                             transform:(CGAffineTransform)transform {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (self =&lt;span&gt; [super initWithImageComponent:component]) {
        transform_ &lt;/span&gt;=&lt;span&gt; transform;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self;
}
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)apply {
    CGContextRef context &lt;/span&gt;=&lt;span&gt; UIGraphicsGetCurrentContext();
    CGContextConcatCTM(context, transform_);
}
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，形变装饰器只是实现了apply方法，并没有对forwardingTargetForSelector方法做任何处理。&lt;/p&gt;

&lt;p&gt;调用流程如下：&lt;/p&gt;
&lt;p&gt;1.向ImageTransformFilter发送 drawInRect消息&lt;/p&gt;
&lt;p&gt;2.ImageTransformFilter因为没有drawInRect方法，而调用父类的forwardingTargetForSelector方法&lt;/p&gt;
&lt;p&gt;3.在父类的forwardingTargetForSelector方法中 包含 [selfapply];&lt;/p&gt;
&lt;p&gt;4.当在父类中调用[selfapply];代码时，会执行ImageTransformFilter的apply方法。（方法的泛型）&lt;/p&gt;
&lt;p&gt;5.最后调用returncomponent_;，将消息传给下一个图像滤镜组件。&lt;/p&gt;
&lt;p&gt;6.重复1-5的过程。完成了消息的转发过程，形成任务处理链条。&lt;/p&gt;

&lt;p&gt;完整的demo实现: https://github.com/zhfei/Objective-C_Design_Patterns&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 15:23:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>在OC中，当像一个对象发送消息，而对象找到消息后，从它的类方法列表，父类方法列表，一直找到根类方法列表都没有找到与这个选择子对应的函数指针。那么这个对象就会触发消息转发机制。 OC对象的继承链和isa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/10188140.html</dc:identifier>
</item>
<item>
<title>23种设计模式之解释器模式 - 牛牛的编程之路</title>
<link>http://www.cnblogs.com/hujingnb/p/10171605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujingnb/p/10171605.html</guid>
<description>&lt;p&gt;定义: 给定一门语言,定义它的文法的一种表示, 并定义一个解释器, 该解释器使用该表示来解释语言中的句子.&lt;/p&gt;
&lt;p&gt;其类图如下:&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/153380354639878fe4a8477&quot; alt=&quot;23种设计模式之解释器模式&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其中的角色说明:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AbstractExpression 抽象解释器: 具体的解释任务由各个实现类完成&lt;/li&gt;
&lt;li&gt;TerminalExpression 终结符表达式: 实现与文法中的元素相关联的解释操作, 通常一个解释器模式中只有一个终结符表达式, 但有多个实例,对应不同的终结符&lt;/li&gt;
&lt;li&gt;NonterminalExpression 非终结符表达式: 文法中的每条规则对应于一个非终结符表达式. 非终结符表达式根据逻辑的复杂程度而增加,原则上每个文法规则都对应一个非终结符表达式&lt;/li&gt;
&lt;li&gt;Context 环境角色&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;抽象表达式代码:&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p99.pstatp.com/large/pgc-image/1533803813234fdf8ded165&quot; alt=&quot;23种设计模式之解释器模式&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;抽象表达式通常只有一个方法, 抽象表达式是生成语法集合的关键, 每个语法集合完成指定语法解析任务, 它是通过递归调用的方式,最终由最小的语法单元进行解析完成&lt;/p&gt;
&lt;p&gt;终结符表达式代码:&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p99.pstatp.com/large/pgc-image/1533803961293b098a2d099&quot; alt=&quot;23种设计模式之解释器模式&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;通常,终结符表达式比较简单,主要是处理场景元素和数据的转换&lt;/p&gt;
&lt;p&gt;非终结符表达式:&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p99.pstatp.com/large/pgc-image/15338040953995a0c1a2911&quot; alt=&quot;23种设计模式之解释器模式&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;每个非终结符表达式都代表了一个文法规则, 并且每个文法规则都只关心自己周边的文法规则的结果, 因此这就产生了每个非终结符表达式调用自己周边的非终结符表达式, 然后最终、最小的文法规则就是终结符表达式,终结符表达式的概念就是如此, 不能够再参与比自己更小的文法运算了&lt;/p&gt;
&lt;p&gt;场景类代码:&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/15338043517592bbbe4862f&quot; alt=&quot;23种设计模式之解释器模式&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;通常Client是一个封装类, 封装的结果就是传递进来一个规范语法文件,解析器分析后产生结果并返回,避免了调用者与语法解析器的耦合关系&lt;/p&gt;

&lt;p&gt;解释器模式的优点:&lt;/p&gt;
&lt;p&gt;解释器是一个简单语法分析工具,它最显著的优点就是扩展性,修改语法规则只要修改相应的非终结符表达式就可以了, 若扩展语法, 则只要增加非终结符就可以了&lt;/p&gt;
&lt;p&gt;解释器模式的缺点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解释器模式会引起类膨胀. 每个语法都要产生一个非终结符表达式,语法规则比较复杂时,就可能产生大量的类文件, 为维护带来了非常多的麻烦&lt;/li&gt;
&lt;li&gt;解释器模式采用递归调用方法. 每个非终结符表达式之关心与自己有关的表达式,每个表达式需要知道最终的结果, 必须一层一层的剥茧,无论是面向对象的语言还是面向过程的语言,递归都是在必要条件下使用的, 它导致调试非常复杂.&lt;/li&gt;
&lt;li&gt;效率问题. 解释器模式由于使用了大量的循环和递归,效率是一个不容忽视的问题,特别是一用于解析复杂、冗长的语法时,效率是难以忍受的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;解释器模式使用的场景:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重复发生的问题可以使用解释器模式. 例如, 多个应用服务器,每天产生大量的日志,需要对日志文件进行分析处理,由于各个服务器的日志格式不同,但是数据要素是相同的,按照解释器的说法就是终结符表达式都是相同的,但是非终结符表达式就需要制定了.&lt;/li&gt;
&lt;li&gt;一个简单语法需要解释的场景. 为什么是简单?看看非中介表达式,文法规则越多,复杂度越高,而且类间还要进行递归调用. 想想看, 多个类之间的调用你需要什么样的耐心和信心去排查问题. 因此,解释器模式一般用来解析比较标准的字符集, 例如SQL语法分析,不过该部分逐渐被专用工具所取代&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;尽量不要在重要的模块中使用解释器模式,否则维护会是一个很大的问题.在项目中可以使用shell、JRuby等脚本语言来代替解释器模式,你不Java编译型语言的不足.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;解释器模式在实际的系统开发中使用的非常少, 因为它会引起效率、性能以及维护等问题,一般在大中型的框架型项目中能够找到它的身影, 如一些数据分析工具、报表设计工具、科学计算工具等, 若你确实遇到&quot;一种特定类型的问题发生的频率足够高&quot;的情况,准备使用解释器模式时, 可以考虑一下 Expression4J、MESP、Jep等开源的解析工具包,功能都异常强大,而且非常容易使用,效率也还不错,实现大多数的数学运算完全没有问题.&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;可以关注一下鄙人的公众号, 谢谢各位了!&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457859/201812/1457859-20181224224508758-2106722284.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Dec 2018 15:19:00 +0000</pubDate>
<dc:creator>牛牛的编程之路</dc:creator>
<og:description>解释器模式的定义 定义: 给定一门语言,定义它的文法的一种表示, 并定义一个解释器, 该解释器使用该表示来解释语言中的句子. 其类图如下: 其中的角色说明: 抽象表达式代码: 抽象表达式通常只有一个方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujingnb/p/10171605.html</dc:identifier>
</item>
</channel>
</rss>