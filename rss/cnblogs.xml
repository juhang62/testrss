<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kafka与.net core（三）kafka操作 - 老六代码</title>
<link>http://www.cnblogs.com/chenyishi/p/10250768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyishi/p/10250768.html</guid>
<description>&lt;div readability=&quot;32&quot;&gt;
&lt;pre&gt;
kafka-server-start.&lt;span&gt;sh&lt;/span&gt; -daemon ../config/server.properties
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Confluent.Kafka -Version &lt;span&gt;1.0&lt;/span&gt;-beta2
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using Confluent.Kafka;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;

namespace KafkaTest
{
    class Program
    {
        static void Main(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Test().Wait();
        }
        static async Task Test()
        {
           var conf &lt;/span&gt;= new ProducerConfig { BootstrapServers = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;39.**.**.**:9092&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

            Action&lt;/span&gt;&amp;lt;DeliveryReportResult&amp;lt;Null, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; handler = r =&amp;gt;&lt;span&gt;
                Console.WriteLine(&lt;/span&gt;!&lt;span&gt;r.Error.IsError
                    &lt;/span&gt;? $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delivered message to {r.TopicPartitionOffset}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    : $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delivery Error: {r.Error.Reason}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            using (var p &lt;/span&gt;= new Producer&amp;lt;Null, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(conf))
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; ++&lt;span&gt;i)
                {
                    p.BeginProduce(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my-topic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, new Message&amp;lt;Null, &lt;span&gt;string&lt;/span&gt;&amp;gt; { Value =&lt;span&gt; i.ToString() }, handler);
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait for up to 10 seconds for any inflight messages to be delivered.&lt;/span&gt;
                p.Flush(TimeSpan.FromSeconds(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Confluent.Kafka -Version &lt;span&gt;1.0&lt;/span&gt;-beta2
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using Confluent.Kafka;
using System;
using System.Linq;
using System.Text;

namespace KafkaClient
{
    class Program
    {
        static void Main(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            

            var conf &lt;/span&gt;=&lt;span&gt; new ConsumerConfig
            {
                GroupId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test-consumer-group4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                BootstrapServers &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;39.**.**.**:9092&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note: The AutoOffsetReset property determines the start offset in the event
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; there are not yet any committed offsets for the consumer group for the
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; topic/partitions of interest. By default, offsets are committed
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; automatically, so in this example, consumption will only start from the
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; earliest message in the topic 'my-topic' the first time you run the program.&lt;/span&gt;
                AutoOffsetReset =&lt;span&gt; AutoOffsetResetType.Earliest
            };

            using (var c &lt;/span&gt;= new Consumer&amp;lt;Ignore, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(conf))
            {
                c.Subscribe(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my-topic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; consuming = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The client will automatically recover from non-fatal errors. You typically
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't need to take any action unless an error is marked as fatal.&lt;/span&gt;
                c.OnError += (_, e) =&amp;gt; consuming = !&lt;span&gt;e.IsFatal;

                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (consuming)
                {
                    try
                    {
                        var cr &lt;/span&gt;=&lt;span&gt; c.Consume();
                        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Consumed message '{cr.Value}' at: '{cr.TopicPartitionOffset}'.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    catch (ConsumeException e)
                    {
                        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error occured: {e.Error.Reason}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure the consumer leaves the group cleanly and final offsets are committed.&lt;/span&gt;
&lt;span&gt;                c.Close();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Thu, 10 Jan 2019 23:12:00 +0000</pubDate>
<dc:creator>老六代码</dc:creator>
<og:description>1.Kafka相关知识 Broker：即Kafka的服务器，用户存储消息，Kafa集群中的一台或多台服务器统称为broker。 Message消息：是通信的基本单位，每个 producer 可以向一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenyishi/p/10250768.html</dc:identifier>
</item>
<item>
<title>【自考笔记】中国近现代史纲要 第一章 - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/10253377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/10253377.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;听闻同事有浪潮的内推机会，打算让其帮着问问，结果还是学历卡住了，难受加上家里有点事，睡不着，今天就通宵了，趁着处在自考学习近现代史这块，有时间就准备把代号03708的2018版《中国近现代史纲要》的重点做下笔记，持续更新。&lt;/p&gt;
&lt;h2 id=&quot;第一章-反对外国侵略的斗争&quot;&gt;第一章 反对外国侵略的斗争&lt;/h2&gt;
&lt;h3 id=&quot;重点提要&quot;&gt;重点提要&lt;/h3&gt;
&lt;p&gt;资本-帝国主义的侵略是近代中国一切灾难的总根源；近代中国半殖民地半封建社会的特点，主要矛盾和面临的主要任务；反侵略斗争失败的原因和民族意识的觉醒。&lt;/p&gt;
&lt;h4 id=&quot;第一节&quot;&gt;第一节&lt;/h4&gt;
&lt;h4 id=&quot;一鸦片战争前的中国&quot;&gt;一、鸦片战争前的中国&lt;/h4&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;鸦片战争前的中国的特点：在经济上，封建土地所有制占主导地位，小农经济是中国封建社会的基本生产结构，其主要特征是个体家庭为单位并与家庭手工业结合的自给自足的自然经济；在政治上，实行高度中央集权的封建君主专制制度；在文化上，以儒家思想为核心；在社会结构上开成族权和政权相结合的封建宗法等级制度。核心是宗族家长制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;中国封建社会的主要矛盾，是地主阶级与农民阶级的矛盾。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;中国封建社会的主要矛盾的特点：一方面，它巩固了和维系了中国封建社会长期的延续和稳定。另一方面，随着中国封建社会由盛转衰，地主同农民阶级的固有矛盾日益显现出来，造成不可克服的政治经济社会的周期性危机。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;中国封建社会末期的由盛转衰的主要表现：在政治上，中央集权进一步强化，官场腐败；经济上官吏与地主大肆兼并土地，无地或少地的农民日益增多；思想文化上，厉行专制主义，大兴文字狱；对外关系上，实行闭关锁国政策。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;二鸦片战争前的世界-一般了解&quot;&gt;二、鸦片战争前的世界 （一般了解）&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;资本主义制度的确立：1640年，英国爆发了资产阶级革命，资本主义制度在英、美、法等欧美国家先后确立，利用国家政权发展资本主义经济，工业革命首先发生于英国的纺织业上，随着蒸汽机的发明与推广，大机器取代工场手工业&lt;/li&gt;
&lt;li&gt;西方列强的殖民扩张：因为材料不足、生产多卖不出去，所以寻求新的殖民地，通过海盗式的掠夺土地和财物、欺诈性的贸易和奴隶和奴隶贩卖等方式，殖民者对一些国家进行军事、政治、经济、文化等方面的侵略，使其沦为列强垄断的商品倾销市场、廉价劳动力与廉价原料的供应地和自由投资市场。&lt;/li&gt;
&lt;li&gt;资本主义殖民扩张的原因：开辟市场和转移国内矛盾的需要&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;第二节-一般了解&quot;&gt;第二节 （一般了解）&lt;/h4&gt;
&lt;h4 id=&quot;列强对中国的侵略&quot;&gt;列强对中国的侵略&lt;/h4&gt;
&lt;p&gt;在1840年鸦片战争以来，列强在政治上侵犯中国主权，经济上掠夺中国财富，文化上麻醉中国民众，中国进入半殖民地半封建社会。（即，外国资本主义势力与中国封建势力相结合）&lt;/p&gt;
&lt;h5 id=&quot;经济上&quot;&gt;经济上&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;1840年，英国发动第一次鸦片战争，签订《南京条约》，1942年签订《五口通商章程》、《虎门条约》（省略一些不太重要的条约）1894年，日本发动甲午中日战争，1985年签订《马关条约》，1900年八国联军侵华，1901年清政府与11国签订《辛丑条约》&lt;/li&gt;
&lt;li&gt;其中，《南京条约》规定割让香港岛给英国；1849年，葡萄牙强占澳门半岛&lt;/li&gt;
&lt;li&gt;鸦片战争及第一批不平等条约的后果：
&lt;ul&gt;&lt;li&gt;特点与土地丧失&lt;/li&gt;
&lt;li&gt;社会性质改变-&amp;gt;半殖民地半封建社会&lt;/li&gt;
&lt;li&gt;通过不平等条约，资本-帝国主义列强勒索巨额赔款&lt;/li&gt;
&lt;li&gt;中国财富与文物古迹遗失与损坏&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;惨案：1894年日军 旅顺口大屠杀； 1900年八国联军杀义和团与平民1700多人，俄国制造江东六十四屯惨案。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;政治上&quot;&gt;政治上&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;通过军事侵略与不平等条约，控制中国内政与外交，列强享有领事裁决权，把持中国海关，勾结清政府镇压中国人民反抗，扶植收买代理人。&lt;/li&gt;
&lt;li&gt;1899年义和团运动在山东兴起&lt;/li&gt;
&lt;li&gt;辛丑条约标志着中国进入半殖民地半封建社会性制国家&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;经济上-1&quot;&gt;经济上&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;控制中国通商口岸、剥夺中国关税自主权、对华倾销商品和资本输出。&lt;/li&gt;
&lt;li&gt;操控中国的经济命脉：
&lt;ul&gt;&lt;li&gt;对中国近代工业的垄断&lt;/li&gt;
&lt;li&gt;迫使清政府举借外债，以还赔款，并以关税、盐税担保&lt;/li&gt;
&lt;li&gt;在中国设立银行&lt;/li&gt;
&lt;li&gt;控制中国近代交通运输业&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;文化渗透上&quot;&gt;文化渗透上&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;鼓吹“种族优劣论”&lt;/li&gt;
&lt;li&gt;宗教渗透与侵略&lt;/li&gt;
&lt;li&gt;为侵略中国制造舆论&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;帝国主义来华主要目的&quot;&gt;帝国主义来华主要目的&lt;/h5&gt;
&lt;p&gt;强迫中国成为西方列强的附庸国&lt;/p&gt;
&lt;h4 id=&quot;近代中国成为半殖民地半封建社会&quot;&gt;近代中国成为半殖民地半封建社会&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;半殖民地半封建社会特点：
&lt;ul&gt;&lt;li&gt;资本主义不但逐步操纵了中国的财政经济命脉，而且逐步控制了中国的政治，日益成为支配中国的决定性力量&lt;/li&gt;
&lt;li&gt;封建势力同外国侵略势力相勾结，成为外国列强压迫、奴役中国人民的社会基础和统治支柱&lt;/li&gt;
&lt;li&gt;中国自然经济的遭到破坏，但是封建剥削制度的根基即地主的土地所有制依然在广大地区内保持着，成为中国走向现代化和民主化的严重障碍&lt;/li&gt;
&lt;li&gt;中国资本主义有所发展，并在政治、文化生活中起了一定的作用，受压迫发展缓慢，力量软弱&lt;/li&gt;
&lt;li&gt;形成割据势力，各地区经济、政治和文化发展极不平衡，列强分别支持企图分裂中国&lt;/li&gt;
&lt;li&gt;在列强与封建势力的压迫下，广大人民尤其是农民日益贫困化及大批地破产，过着穷、饥、寒和无权利的生活&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;社会阶级关系的变动：
&lt;ul&gt;&lt;li&gt;封建统治阶级（地主阶级）拥有大量土地，掌握着国家政权，对人民实行专制统治，对农民压迫加重，农民与地主的阶级矛盾十分尖锐&lt;/li&gt;
&lt;li&gt;旧的被统治阶级不变（农民）&lt;/li&gt;
&lt;li&gt;产生新的阶级——资产阶级&lt;/li&gt;
&lt;li&gt;产生新的被压迫的阶级——工人阶级&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为什么新生资本主义没有引导中国民主革命走向胜利？
&lt;ul&gt;&lt;li&gt;尊重资本主义在参加反帝反封建的革命或斗争中保持中立&lt;/li&gt;
&lt;li&gt;自身力量弱小&lt;/li&gt;
&lt;li&gt;与外国资本主义有联系，没有革命性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为什么工人阶级革命性最强？
&lt;ul&gt;&lt;li&gt;深受帝国主义、封建势力、资产阶级三重压迫与剥削，劳动条件差，劳动时间长，工资待遇低，毫无政治权利，所以革命性最强（受压迫也最强：P）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;两大主要矛盾和两大任务&quot;&gt;两大主要矛盾和两大任务&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;两大主要矛盾：
&lt;ul&gt;&lt;li&gt;帝国主义与中华民族的矛盾（主要矛盾）&lt;/li&gt;
&lt;li&gt;封建主义与人民大众的矛盾&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;两大主要矛盾的关系：
&lt;ul&gt;&lt;li&gt;列强发动侵略战争时，民族矛盾上升到主要地位&lt;/li&gt;
&lt;li&gt;列强与封建政权勾结的时，阶级矛盾成为主要矛盾&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;近百年斗争的目的：
&lt;ul&gt;&lt;li&gt;解决中国社会的主要矛盾&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;两大任务：
&lt;ul&gt;&lt;li&gt;求得民族独立和人民解放&lt;/li&gt;
&lt;li&gt;实现国家繁荣富强和人民共同富裕&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;两大任务之间的关系：
&lt;ul&gt;&lt;li&gt;前者着重解决生产力关系问题，后者着重解决生产力问题&lt;/li&gt;
&lt;li&gt;只有完成第一大任务才能为第二大任务创造条件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中华民族近代以来最伟大的梦想是什么？
&lt;ul&gt;&lt;li&gt;实现中华民族的伟大复兴&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;第三节-民族独立的斗争&quot;&gt;第三节 民族独立的斗争&lt;/h4&gt;
&lt;h5 id=&quot;反侵略历程&quot;&gt;反侵略历程&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;人民群众的反侵略斗争：
&lt;ul&gt;&lt;li&gt;1841年5月，广州三元里起义，是近代中国人民第一次大规模反侵略斗争&lt;/li&gt;
&lt;li&gt;1862年5月，太平军多次重创侵略者&lt;/li&gt;
&lt;li&gt;1884年，中法战争期间，香港工人举行罢工，商人罢市&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;官兵的反侵略斗争：
&lt;ul&gt;&lt;li&gt;1884年刘铭传击退法舰&lt;/li&gt;
&lt;li&gt;1885年冯子材在镇南关取得关键性胜利，史称 镇南关大捷&lt;/li&gt;
&lt;li&gt;其余了解即可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;粉碎瓜分中国的图谋&quot;&gt;粉碎瓜分中国的图谋&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;19世纪70到90年代帝国主义掀起瓜分中国的狂潮，其中甲午中日战争后，帝国主义瓜分达到高潮（了解）&lt;/li&gt;
&lt;li&gt;帝国主义瓜分中国的图谋并未实现的原因？
&lt;ul&gt;&lt;li&gt;帝国主义列强之间的相互制约，是重要原因&lt;/li&gt;
&lt;li&gt;根本原因是中国人民进行了不屈不挠的反侵略斗争（义和团运动发挥了重大作用）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;反侵略斗争的失败和民族意识的觉醒&quot;&gt;反侵略斗争的失败和民族意识的觉醒&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;1840到1919年，中国的反侵略斗都失败了，其原因为：
&lt;ul&gt;&lt;li&gt;社会制度的腐败，是根本原因（历史规律：资本主义取代封建主义，先进的取代落后的）&lt;/li&gt;
&lt;li&gt;经济技术的落后，是重要原因&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;民族意识普遍觉醒是在何时？ 甲午中日战争战败后&lt;/li&gt;
&lt;li&gt;民族意识觉醒的标志：
&lt;ul&gt;&lt;li&gt;林则徐——近代中国睁眼看世界第一人，翻译编写《四洲志》&lt;/li&gt;
&lt;li&gt;1843年魏源编写《海国图志》，主张“师夷长技以制夷”&lt;/li&gt;
&lt;li&gt;1895年严复 《救国决论》发出“救亡”口号，此后 翻译《天演论》“物竞天择，适者生存”&lt;/li&gt;
&lt;li&gt;1898年 康有为 公车上书，百日维新&lt;/li&gt;
&lt;li&gt;1894年11月 孙中山创立兴中会，喊出“振兴中华”时代最强音&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;## 后记&lt;/p&gt;
&lt;p&gt;不知不觉，才记完第一章，先这样吧，有时间再更新&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 20:44:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>前言 听闻同事有浪潮的内推机会，打算让其帮着问问，结果还是学历卡住了，难受加上家里有点事，睡不着，今天就通宵了，趁着处在自考学习近现代史这块，有时间就准备把代号03708的2018版《中国近现代史纲要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellxz/p/10253377.html</dc:identifier>
</item>
<item>
<title>Python基础之类 - davieyang</title>
<link>http://www.cnblogs.com/davieyang/p/10246481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davieyang/p/10246481.html</guid>
<description>&lt;h2&gt;一、摘要&lt;/h2&gt;
&lt;p&gt;面向对象编程 是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。基于类创建对象 时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。使用面向对象编程可模拟现实情景，其逼真程度达到了令你惊讶的地步。根据类来创建对象被称为实例化 ，这让你能够使用类的实例。&lt;/p&gt;
&lt;h2&gt;二、创建和使用类&lt;/h2&gt;
&lt;p&gt;使用类几乎可以模拟任何东西。&lt;/p&gt;
&lt;p&gt;下面来编写一个表示小狗的简单类Dog ——它表示的不是特定的小狗，而是任何小狗。对于大多数宠物狗，我们都知道些什么呢？它们都有名字和年龄；我们还知道，大多数小狗还会蹲下和打滚。由于大多数小狗都具备上述两项信息（名字和年龄）和两种行为（蹲下和打滚），我们的Dog 类将包含它们。这个类让Python知道如何创建表示小狗的对象。编写这个类后，我们将使用它来创建表示特定小狗的实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;一次模拟小狗的简单尝试&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化属性name和age&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sit(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;模拟小狗被命令时蹲下&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(self.name.title() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; is now sitting.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; roll_over(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;模拟小狗被命令时打滚&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(self.name.title() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; rolled over!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;__init__()&lt;/span&gt;&lt;/strong&gt; 是一个特殊的方法，每当你根据Dog 类创建新实例时，Python都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突&lt;/p&gt;
&lt;p&gt;我们将方法__init__() 定义成了包含三个形参：self 、name 和age 。&lt;span&gt;&lt;strong&gt;在这个方法的定义中，形参self 必不可少，还必须位于其他形参的前面。为何必须在方法定义中包含形参self 呢？因为Python调用这个__init__() 方法来创建Dog 实例时，将自动传入实参self 。每个与类相关联的方法调用都自动传递实参self ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建Dog 实例时，Python将调用Dog 类的方法__init__() &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们将通过实参向Dog() 传递名字和年龄；self 会自动传递，因此我们不需要传递它。每当我们根据Dog 类创建实例时，都只需给最后两个形参（name 和age ）提供值&lt;/p&gt;
&lt;p&gt;处定义的两个变量都有前缀self 。以self 为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。self.name = name 获取存储在形参name 中的值，并将其存储到变量name 中，然后该变量被关联到当前创建的实例。self.age = age 的作用与此类似。&lt;span&gt;&lt;strong&gt;&lt;span&gt;像这样可通过实例访问的变量称为属性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;Dog 类还定义了另外两个方法：sit() 和roll_over()，由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参self 。我们后面将创建的实例能够访问这些方法，换句话说，它们都会蹲下和打滚。当前，sit() 和roll_over() 所做的有限，它们只是打印一条消息，指出小狗正蹲下或打滚。但可以扩展这些方法以模拟实际情况：如果这个类包含在一个计算机游戏中，这些方法将包含创建小狗蹲下和打滚动画效果的代码。如果这个类是用于控制机器狗的，这些方法将引导机器狗做出蹲下和打滚的动作&lt;/p&gt;
&lt;h3&gt;根据类创建实例：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog():
    &lt;/span&gt;--snip--&lt;span&gt;

my_dog &lt;/span&gt;= Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;willie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My dog's name is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + my_dog.name.title() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My dog is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(my_dog.age) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; years old.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们让Python创建一条名字为'willie' 、年龄为6 的小狗。遇到这行代码时，Python使用实参'willie' 和6 调用Dog 类中的方法__init__() 。方法__init__() 创建一个表示特定小狗的示例，并使用我们提供的值来设置属性name 和age 。方法__init__() 并未显式地包含return 语句，但Python自动返回一个表示这条小狗的实例。我们将这个实例存储在变量my_dog 中。在这里，命名约定很有用：我们通常可以认为首字母大写的名称（如Dog ）指的是类，而小写的名称（如my_dog ）指的是根据类创建的实例&lt;/p&gt;
&lt;h3&gt;访问属性：&lt;/h3&gt;
&lt;p&gt;要访问实例的属性，可使用句点表示法，如下代码来访问my_dog 的属性name 的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
my_dog.name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;句点表示法在Python中很常用，这种语法演示了Python如何获悉属性的值。在这里，Python先找到实例my_dog ，再查找与这个实例相关联的属性name 。在Dog 类中引用这个属性时，使用的是self.name 。我们使用同样的方法来获取属性age 的值。在前面的第1条print 语句中，my_dog.name.title() 将my_dog 的属性name 的值'willie' 改为首字母大写的；在第2条print 语句中，str(my_dog.age) 将my_dog 的属性age 的值6 转换为字符串。输出是有关my_dog 的摘要：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
My dog&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s name is Willie.&lt;/span&gt;
My dog &lt;span&gt;is&lt;/span&gt; 6 years old.
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;调用方法：&lt;/h3&gt;
&lt;p&gt;根据Dog 类创建实例后，就可以使用句点表示法来调用Dog 类中定义的任何方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog():
    &lt;/span&gt;--snip--&lt;span&gt;

my_dog &lt;/span&gt;= Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;willie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 6&lt;span&gt;)
my_dog.sit()
my_dog.roll_over()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要调用方法，可指定实例的名称（这里是my_dog ）和要调用的方法，并用句点分隔它们。遇到代码my_dog.sit() 时，Python在类Dog 中查找方法sit() 并运行其代码。Python以同样的方式解读代码my_dog.roll_over()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Willie &lt;span&gt;is&lt;/span&gt;&lt;span&gt; now sitting.
Willie rolled over!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在命名上，如果给属性和方法指定了合适的描述性名称，如name 、age 、sit() 和roll_over() ，即便是从未见过的代码块，我们也能够轻松地推断出它是做什么的&lt;/p&gt;
&lt;h3&gt;创建多个实例：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog():
    &lt;/span&gt;--snip--&lt;span&gt;

my_dog &lt;/span&gt;= Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;willie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 6&lt;span&gt;)
your_dog &lt;/span&gt;= Dog(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lucy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My dog's name is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + my_dog.name.title() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My dog is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(my_dog.age) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; years old.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
my_dog.sit()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nYour dog's name is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + your_dog.name.title() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your dog is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(your_dog.age) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; years old.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
your_dog.sit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就算我们给第二条小狗指定同样的名字和年龄，Python依然会根据Dog 类创建另一个实例。你可按需求根据一个类创建任意数量的实例，条件是将每个实例都存储在不同的变量中，或占用列表或字典的不同位置。&lt;/p&gt;
&lt;h2&gt;三、使用类和实例&lt;/h2&gt;
&lt;p&gt;你可以使用类来模拟现实世界中的很多情景。类编写好后，你的大部分时间都将花在使用根据类创建的实例上。你需要执行的一个重要任务是修改实例的属性。你可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;一次模拟汽车的简单尝试&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, make, model, year):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化描述汽车的属性&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.make &lt;/span&gt;=&lt;span&gt; make
        self.model &lt;/span&gt;=&lt;span&gt; model
        self.year &lt;/span&gt;=&lt;span&gt; year

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_descriptive_name(self):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;返回整洁的描述性信息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        long_name &lt;/span&gt;= str(self.year) + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; + self.make + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; self.model
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; long_name.title()

my_new_car &lt;/span&gt;= Car(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;audi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(my_new_car.get_descriptive_name())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义了方法__init__() 。与前面的Dog 类中一样，这个方法的第一个形参为self ；我们还在这个方法中包含了另外三个形参：make 、model 和year 。方法__init__() 接受这些形参的值，并将它们存储在根据这个类创建的实例的属性中。创建新的Car 实例时，我们需要指定其制造商、型号和生产年份&lt;/p&gt;
&lt;p&gt;定义了一个名为get_descriptive_name() 的方法，它使用属性year 、make 和model 创建一个对汽车进行描述的字符串，让我们无需分别打印每个属性的值。为在这个方法中访问属性的值，我们使用了self.make 、self.model 和self.year 。&lt;/p&gt;
&lt;p&gt;我们根据Car 类创建了一个实例，并将其存储到变量my_new_car中。接下来，我们调用方法get_descriptive_name() ，指出我们拥有的是一辆什么样的汽车：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
2016 Audi A4
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;给属性指定默认值：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, make, model, year):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化描述汽车的属性&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.make &lt;/span&gt;=&lt;span&gt; make
        self.model &lt;/span&gt;=&lt;span&gt; model
        self.year &lt;/span&gt;=&lt;span&gt; year
        self.odometer_reading &lt;/span&gt;=&lt;span&gt; 0

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_descriptive_name(self):
        &lt;/span&gt;--snip--

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_odometer(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;打印一条指出汽车里程的消息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car has &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(self.odometer_reading) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; miles on it.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

my_new_car &lt;/span&gt;= Car(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;audi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_new_car.get_descriptive_name())
my_new_car.read_odometer()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当Python调用方法__init__() 来创建新实例时，将像前一个示例一样以属性的方式存储制造商、型号和生产年份。接下来，Python将创建一个名为odometer_reading 的属性，并将其初始值设置为0。&lt;/p&gt;
&lt;p&gt;我们还定义了一个名为read_odometer() 的方法，它让你能够轻松地获悉汽车的里程。一开始汽车的里程为0：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2016&lt;span&gt; Audi A4
This car has 0 miles on it.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改属性的值：&lt;/h3&gt;
&lt;p&gt;可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增（增加特定的值）&lt;/p&gt;
&lt;h4&gt;直接修改属性的值：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;--snip--&lt;span&gt;
my_new_car &lt;/span&gt;= Car(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;audi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_new_car.get_descriptive_name())

my_new_car.odometer_reading &lt;/span&gt;= 23&lt;span&gt;
my_new_car.read_odometer()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们使用句点表示法来直接访问并设置汽车的属性odometer_reading 。这行代码让Python在实例my_new_car 中找到属性odometer_reading ，并将该属性的值设置为23：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2016&lt;span&gt; Audi A4
This car has &lt;/span&gt;23 miles on it.
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;通过方法修改属性的值：&lt;/h4&gt;
&lt;p&gt;如果有替你更新属性的方法，将大有裨益。这样，你就无需直接访问属性，而可将值传递给一个方法，由它在内部进行更新&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;--snip--
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_odometer(self, mileage):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将里程表读数设置为指定的值&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.odometer_reading &lt;/span&gt;=&lt;span&gt; mileage

my_new_car &lt;/span&gt;= Car(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;audi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_new_car.get_descriptive_name())
my_new_car.update_odometer(&lt;/span&gt;23&lt;span&gt;)
my_new_car.read_odometer()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加了方法update_odometer() 。这个方法接受一个里程值，并将其存储到self.odometer_reading 中。&lt;/p&gt;
&lt;p&gt;我们调用了update_odometer() ，并向它提供了实参23（该实参对应于方法定义中的形参mileage）。它将里程表读数设置为23；而方法read_odometer() 打印该读数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2016&lt;span&gt; Audi A4
This car has &lt;/span&gt;23 miles on it.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 再看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;--snip--
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_odometer(self, mileage):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        将里程表读数设置为指定的值
        禁止将里程表读数往回调
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; mileage &amp;gt;=&lt;span&gt; self.odometer_reading:
            self.odometer_reading &lt;/span&gt;=&lt;span&gt; mileage
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You can't roll back an odometer!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;update_odometer() 在修改属性前检查指定的读数是否合理。如果新指定的里程（mileage ）大于或等于原来的里程（self.odometer_reading ），就将里程表读数改为新指定的里程&lt;/p&gt;
&lt;p&gt;否则就发出警告，指出不能将里程表往回拨&lt;/p&gt;
&lt;h4&gt;通过方法对属性的值进行递增：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;--snip--
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_odometer(self, mileage):
        &lt;/span&gt;--snip--
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; increment_odometer(self, miles):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将里程表读数增加指定的量&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.odometer_reading &lt;/span&gt;+=&lt;span&gt; miles

my_used_car &lt;/span&gt;= Car(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;subaru&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;outback&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2013&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_used_car.get_descriptive_name())

my_used_car.update_odometer(&lt;/span&gt;23500&lt;span&gt;)
my_used_car.read_odometer()

my_used_car.increment_odometer(&lt;/span&gt;100&lt;span&gt;)
my_used_car.read_odometer()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新增的方法increment_odometer() 接受一个单位为英里的数字，并将其加入到self.odometer_reading 中。&lt;/p&gt;
&lt;p&gt;我们创建了一辆二手车my_used_car，调用方法update_odometer() 并传入23500 ，将这辆二手车的里程表读数设置为23 500。&lt;/p&gt;
&lt;p&gt;我们调用increment_odometer()并传入100 ，以增加从购买到登记期间行驶的100英里：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2013&lt;span&gt; Subaru Outback
This car has &lt;/span&gt;23500&lt;span&gt; miles on it.
This car has &lt;/span&gt;23600 miles on it.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以轻松地修改这个方法，以禁止增量为负值，从而防止有人利用它来回拨里程表。&lt;/p&gt;
&lt;p&gt;注意：你可以使用类似于上面的方法来控制用户修改属性值（如里程表读数）的方式，但能够访问程序的人都可以通过直接访问属性来将里程表修改为任何值。要确保安全，除了进行类似于前面的基本检查外，还需特别注意细节。&lt;/p&gt;
&lt;h2&gt;四、继承&lt;/h2&gt;
&lt;p&gt;编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承 。一个类继承 另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类 ，而新类称为子类 。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。&lt;/p&gt;
&lt;h3&gt;子类的方法__init__()：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;一次模拟汽车的简单尝试&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, make, model, year):
        self.make &lt;/span&gt;=&lt;span&gt; make
        self.model &lt;/span&gt;=&lt;span&gt; model
        self.year &lt;/span&gt;=&lt;span&gt; year
        self.odometer_reading &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_descriptive_name(self):
        long_name &lt;/span&gt;= str(self.year) + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; + self.make + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; self.model
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; long_name.title()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_odometer(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car has &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(self.odometer_reading) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; miles on it.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_odometer(self, mileage):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; mileage &amp;gt;=&lt;span&gt; self.odometer_reading:
            self.odometer_reading &lt;/span&gt;=&lt;span&gt; mileage
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You can't roll back an odometer!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; increment_odometer(self, miles):
        self.odometer_reading &lt;/span&gt;+=&lt;span&gt; miles

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ElectricCar(Car):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;电动汽车的独特之处&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, make, model, year):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化父类的属性&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(make, model, year)

my_tesla &lt;/span&gt;= ElectricCar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tesla&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;model s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(my_tesla.get_descriptive_name())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先是Car 类的代码。创建子类时，父类必须包含在当前文件中，且位于子类前面&lt;/p&gt;
&lt;p&gt;定义了子类ElectricCar 。定义子类时，必须在括号内指定父类的名称。方法__init__() 接受创建Car 实例所需的信息&lt;/p&gt;
&lt;p&gt;super() 是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar 的父类的方法__init__() ，让ElectricCar 实例包含父类的所有属性。父类也称为超类 （superclass），名称super因此而得名&lt;/p&gt;
&lt;p&gt;为测试继承是否能够正确地发挥作用，我们尝试创建一辆电动汽车ElectricCar 类的一个实例，但提供的信息与创建普通汽车时相同，并将其存储在变量my_tesla 中。这行代码调用ElectricCar 类中定义的方法__init__() ，后者让Python调用父类Car 中定义的方法__init__() 。我们提供了实参'tesla' 、'models' 和2016 &lt;/p&gt;
&lt;p&gt;除方法__init__() 外，电动汽车没有其他特有的属性和方法。当前，我们只想确认电动汽车具备普通汽车的行为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
2016 Tesla Model S
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;给子类定义属性和方法：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;--snip--
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ElectricCar(Car):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Represent aspects of a car, specific to electric vehicles.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, make, model, year):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        电动汽车的独特之处
        初始化父类的属性，再初始化电动汽车特有的属性
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(make, model, year)
        self.battery_size &lt;/span&gt;= 70
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; describe_battery(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;打印一条描述电瓶容量的消息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car has a &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(self.battery_size) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-kWh battery.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

my_tesla &lt;/span&gt;= ElectricCar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tesla&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;model s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_tesla.get_descriptive_name())
my_tesla.describe_battery()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加了新属性self.battery_size ，并设置其初始值（如70 ）。根据ElectricCar 类创建的所有实例都将包含这个属性，但所有Car 实例都不包含它。&lt;/p&gt;
&lt;p&gt;添加了一个名为describe_battery() 的方法，它打印有关电瓶的信息。我们调用这个方法时，将看到一条电动汽车特有的描述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2016&lt;span&gt; Tesla Model S
This car has a &lt;/span&gt;70-kWh battery.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于ElectricCar 类的特殊化程度没有任何限制。模拟电动汽车时，你可以根据所需的准确程度添加任意数量的属性和方法。如果一个属性或方法是任何汽车都有的，而不是电动汽车特有的，就应将其加入到Car 类而不是ElectricCar 类中。这样，使用Car 类的人将获得相应的功能，而ElectricCar 类只包含处理电动汽车特有属性和行为的代码&lt;/p&gt;
&lt;h3&gt;重写父类的方法：&lt;/h3&gt;
&lt;p&gt;对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。假设Car 类有一个名为fill_gas_tank() 的方法，它对全电动汽车来说毫无意义，因此你可能想重写它。下面演示了一种重写方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ElectricCar(Car):
    &lt;/span&gt;--snip--
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fill_gas_tank():
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;电动汽车没有油箱&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car doesn't need a gas tank!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，如果有人对电动汽车调用方法fill_gas_tank() ，Python将忽略Car 类中的方法fill_gas_tank() ，转而运行上述代码。使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕。&lt;/p&gt;
&lt;h3&gt;将实例用作属性：&lt;/h3&gt;
&lt;p&gt;使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。&lt;/p&gt;
&lt;p&gt;例如，不断给ElectricCar 类添加细节时，我们可能会发现其中包含很多专门针对汽车电瓶的属性和方法。在这种情况下，我们可将这些属性和方法提取出来，放到另一个名为Battery 的类中，并将一个Battery 实例用作ElectricCar 类的一个属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;--snip--
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Battery():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;一次模拟电动汽车电瓶的简单尝试&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, battery_size=70&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化电瓶的属性&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.battery_size &lt;/span&gt;=&lt;span&gt; battery_size
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; describe_battery(self):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;打印一条描述电瓶容量的消息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car has a &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(self.battery_size) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-kWh battery.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ElectricCar(Car):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;电动汽车的独特之处&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, make, model, year):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        初始化父类的属性，再初始化电动汽车特有的属性
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(make, model, year)
        self.battery &lt;/span&gt;=&lt;span&gt; Battery()

my_tesla &lt;/span&gt;= ElectricCar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tesla&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;model s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义了一个名为Battery 的新类，它没有继承任何类，__init__() 除self 外，还有另一个形参battery_size 。这个形参是可选的：如果没有给它提供值，电瓶容量将被设置为70。方法describe_battery() 也移到了这个类中&lt;/p&gt;
&lt;p&gt;在ElectricCar 类中，我们添加了一个名为self.battery 的属性，这行代码让Python创建一个新的Battery 实例（由于没有指定尺寸，因此为默认值70 ），并将该实例存储在属性self.battery 中。每当方法__init__() 被调用时，都将执行该操作；因此现在每个ElectricCar 实例都包含一个自动创建的Battery 实例。&lt;/p&gt;
&lt;p&gt;我们创建一辆电动汽车，并将其存储在变量my_tesla 中。要描述电瓶时，需要使用电动汽车的属性battery ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
my_tesla.battery.describe_battery()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这行代码让Python在实例my_tesla 中查找属性battery ，并对存储在该属性中的Battery 实例调用方法describe_battery() &lt;/p&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2016&lt;/span&gt;&lt;span&gt; Tesla Model S
This car has a &lt;/span&gt;&lt;span&gt;70&lt;/span&gt;-kWh battery.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这看似做了很多额外的工作，但现在我们想多详细地描述电瓶都可以，且不会导致ElectricCar 类混乱不堪。下面再给Battery 类添加一个方法，它根据电瓶容量报告汽车的续航里程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Car():
    &lt;/span&gt;--snip--&lt;span&gt;
class Battery():
    &lt;/span&gt;--snip--&lt;span&gt;
    def get_range(self):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;打印一条消息，指出电瓶的续航里程&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self.battery_size == &lt;span&gt;70&lt;/span&gt;&lt;span&gt;:
            range &lt;/span&gt;= &lt;span&gt;240&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; self.battery_size == &lt;span&gt;85&lt;/span&gt;&lt;span&gt;:
            range &lt;/span&gt;= &lt;span&gt;270&lt;/span&gt;&lt;span&gt;
        message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car can go approximately &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str(range)
        message &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; miles on a full charge.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        print(message)
class ElectricCar(Car):
    &lt;/span&gt;--snip--&lt;span&gt;

my_tesla &lt;/span&gt;= ElectricCar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tesla&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;model s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2016&lt;/span&gt;&lt;span&gt;)
print(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新增的方法get_range() 做了一些简单的分析：如果电瓶的容量为70kWh，它就将续航里程设置为240英里；如果容量为85kWh，就将续航里程设置为270英里，然后报告这个值。为使用这个方法，我们也通过汽车的属性battery 来调用它&lt;/p&gt;
&lt;p&gt;输出指出了汽车的续航里程（这取决于电瓶的容量）：&lt;/p&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2016&lt;/span&gt;&lt;span&gt; Tesla Model S
This car has a &lt;/span&gt;&lt;span&gt;70&lt;/span&gt;-&lt;span&gt;kWh battery.
This car can go approximately &lt;/span&gt;&lt;span&gt;240&lt;/span&gt; miles on a full charge.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;模拟较复杂的物件（如电动汽车）时，需要解决一些有趣的问题。续航里程是电瓶的属性还是汽车的属性呢？如果我们只需描述一辆汽车，那么将方法get_range() 放在Battery 类中也许是合适的；但如果要描述一家汽车制造商的整个产品线，也许应该将方法get_range() 移到ElectricCar 类中。在这种情况下，get_range() 依然根据电瓶容量来确定续航里程，但报告的是一款汽车的续航里程。我们也可以这样做：将方法get_range() 还留在Battery 类中，但向它传递一个参数，如car_model ；在这种情况下，方法get_range() 将根据电瓶容量和汽车型号报告续航里程。这让你进入了程序员的另一个境界：解决上述问题时，你从较高的逻辑层面（而不是语法层面）考虑；你考虑的不是Python，而是如何使用代码来表示实物。到达这种境界后，你经常会发现，现实世界的建模方法并没有对错之分。有些方法的效率更高，但要找出效率最高的表示法，需要经过一定的实践。只要代码像你希望的那样运行，就说明你做得很好！即便你发现自己不得不多次尝试使用不同的方法来重写类，也不必气馁；要编写出高效、准确的代码，都得经过这样的过程。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;五、导入类&lt;/h2&gt;
&lt;p&gt;随着你不断地给类添加功能，文件可能变得很长，即便你妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。为在这方面提供帮助，Python允许你将类存储在模块中，然后在主程序中导入所需的模块。&lt;/p&gt;
&lt;p&gt;创建car.py文件，并写入如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;一个可用于表示汽车的类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;一次模拟汽车的简单尝试&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, make, model, year):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化描述汽车的属性&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.make &lt;/span&gt;=&lt;span&gt; make
        self.model &lt;/span&gt;=&lt;span&gt; model
        self.year &lt;/span&gt;=&lt;span&gt; year
        self.odometer_reading &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_descriptive_name(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;返回整洁的描述性名称&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        long_name &lt;/span&gt;= str(self.year) + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; + self.make + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; self.model
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; long_name.title()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_odometer(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;打印一条消息，指出汽车的里程&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car has &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(self.odometer_reading) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; miles on it.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_odometer(self, mileage):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        将里程表读数设置为指定的值
        拒绝将里程表往回拨
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; mileage &amp;gt;=&lt;span&gt; self.odometer_reading:
            self.odometer_reading &lt;/span&gt;=&lt;span&gt; mileage
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You can't roll back an odometer!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; increment_odometer(self, miles):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将里程表读数增加指定的量&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.odometer_reading &lt;/span&gt;+= miles
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件的开头，包含了一个模块级文档字符串，对该模块的内容做了简要的描述。你应为自己创建的每个模块都编写文档字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; car &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Car

my_new_car &lt;/span&gt;= Car(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;audi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_new_car.get_descriptive_name())
my_new_car.odometer_reading &lt;/span&gt;= 23&lt;span&gt;
my_new_car.read_odometer()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;import 语句让Python打开模块car ，并导入其中的Car 类。这样我们就可以使用Car 类了，就像它是在这个文件中定义的一样。输出与我们在前面看到的一样：&lt;/p&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2016&lt;/span&gt;&lt;span&gt; Audi A4
This car has &lt;/span&gt;&lt;span&gt;23&lt;/span&gt; miles on it.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然同一个模块中的类之间应存在某种相关性，但可根据需要在一个模块中存储任意数量的类。类Battery 和ElectricCar 都可帮助模拟汽车，因此下面将它们都加入模块car.py中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;一组用于表示燃油汽车和电动汽车的类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;--snip--

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Battery():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;一次模拟电动汽车电瓶的简单尝试&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, battery_size=60&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化电瓶的属性&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.battery_size &lt;/span&gt;=&lt;span&gt; battery_size

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; describe_battery(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;打印一条描述电瓶容量的消息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car has a &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(self.battery_size) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-kWh battery.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_range(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;打印一条描述电瓶续航里程的消息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self.battery_size == 70&lt;span&gt;:
            range &lt;/span&gt;= 240
        &lt;span&gt;elif&lt;/span&gt; self.battery_size == 85&lt;span&gt;:
            range &lt;/span&gt;= 270&lt;span&gt;
        message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car can go approximately &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str(range)
        message &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; miles on a full charge.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(message)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ElectricCar(Car):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;模拟电动汽车的独特之处&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, make, model, year):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        初始化父类的属性，再初始化电动汽车特有的属性
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(make, model, year)
        self.battery &lt;/span&gt;= Battery()    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们就可以import ElectricCar类了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; car &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ElectricCar

my_tesla &lt;/span&gt;= ElectricCar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tesla&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;model s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2016&lt;/span&gt;&lt;span&gt; Tesla Model S
This car has a &lt;/span&gt;&lt;span&gt;70&lt;/span&gt;-&lt;span&gt;kWh battery.
This car can go approximately &lt;/span&gt;&lt;span&gt;240&lt;/span&gt; miles on a full charge.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可根据需要在程序文件中导入任意数量的类。如果我们要在同一个程序中创建普通汽车和电动汽车，就需要将Car 和ElectricCar 类都导入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; car &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Car, ElectricCar

my_beetle &lt;/span&gt;= Car(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;volkswagen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;beetle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_beetle.get_descriptive_name())

my_tesla &lt;/span&gt;= ElectricCar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tesla&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;roadster&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(my_tesla.get_descriptive_name())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2016&lt;/span&gt;&lt;span&gt; Volkswagen Beetle
&lt;/span&gt;&lt;span&gt;2016&lt;/span&gt; Tesla Roadster
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;六、导入整个模块&lt;/h2&gt;
&lt;p&gt;你还可以导入整个模块，再使用句点表示法访问需要的类。这种导入方法很简单，代码也易于阅读。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; car

my_beetle &lt;/span&gt;= car.Car(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;volkswagen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;beetle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_beetle.get_descriptive_name())

my_tesla &lt;/span&gt;= car.ElectricCar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tesla&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;roadster&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2016&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(my_tesla.get_descriptive_name())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入了整个car 模块。接下来，使用语法 module_name.class_name 访问需要的类。&lt;/p&gt;
&lt;h3&gt;导入模块中的所有类：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; module_name &lt;span&gt;import&lt;/span&gt; *
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不推荐使用这种导入方式，其原因有二。首先，如果只要看一下文件开头的import 语句，就能清楚地知道程序使用了哪些类，将大有裨益；但这种导入方式没有明确地指出你使用了模块中的哪些类。这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其他东西同名的类，将引发难以诊断的错误。这里之所以介绍这种导入方式，是因为虽然不推荐使用这种方式，但你可能会在别人编写的代码中见到它。需要从一个模块中导入很多类时，最好导入整个模块，并使用 module_name.class_name 语法来访问类。这样做时，虽然文件开头并没有列出用到的所有类，但你清楚地知道在程序的哪些地方使用了导入的模块；你还避免了导入模块中的每个类可能引发的名称冲突。&lt;/p&gt;
&lt;h3&gt;在一个模块中导入另一个模块：&lt;/h3&gt;
&lt;p&gt;有时候，需要将类分散到多个模块中，以免模块太大，或在同一个模块中存储不相关的类。将类存储在多个模块中时，你可能会发现一个模块中的类依赖于另一个模块中的类。在这种情况下，可在前一个模块中导入必要的类。例如，下面将Car 类存储在一个模块中，并将ElectricCar 和Battery 类存储在另一个模块中。我们将第二个模块命名为electric_car.py &lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;car.py&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;A class that can be used to represent a car.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;A simple attempt to represent a car.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, manufacturer, model, year):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Initialize attributes to describe a car.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.manufacturer &lt;/span&gt;=&lt;span&gt; manufacturer
        self.model &lt;/span&gt;=&lt;span&gt; model
        self.year &lt;/span&gt;=&lt;span&gt; year
        self.odometer_reading &lt;/span&gt;=&lt;span&gt; 0
        
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_descriptive_name(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Return a neatly formatted descriptive name.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        long_name &lt;/span&gt;= str(self.year) + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; + self.manufacturer + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; self.model
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; long_name.title()
    
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_odometer(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Print a statement showing the car's mileage.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car has &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(self.odometer_reading) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; miles on it.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_odometer(self, mileage):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        Set the odometer reading to the given value.
        Reject the change if it attempts to roll the odometer back.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; mileage &amp;gt;=&lt;span&gt; self.odometer_reading:
            self.odometer_reading &lt;/span&gt;=&lt;span&gt; mileage
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You can't roll back an odometer!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; increment_odometer(self, miles):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Add the given amount to the odometer reading.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.odometer_reading &lt;/span&gt;+= miles
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;electric_car.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;A set of classes that can be used to represent electric cars.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; car &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Car

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Battery():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;A simple attempt to model a battery for an electric car.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, battery_size=60&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Initialize the batteery's attributes.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.battery_size &lt;/span&gt;=&lt;span&gt; battery_size

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; describe_battery(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Print a statement describing the battery size.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car has a &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(self.battery_size) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-kWh battery.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)  
        
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_range(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Print a statement about the range this battery provides.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self.battery_size == 60&lt;span&gt;:
            range &lt;/span&gt;= 140
        &lt;span&gt;elif&lt;/span&gt; self.battery_size == 85&lt;span&gt;:
            range &lt;/span&gt;= 185&lt;span&gt;
            
        message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This car can go approximately &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str(range)
        message &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; miles on a full charge.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(message)
    
        
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ElectricCar(Car):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Models aspects of a car, specific to electric vehicles.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, manufacturer, model, year):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        Initialize attributes of the parent class.
        Then initialize attributes specific to an electric car.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(manufacturer, model, year)
        self.battery &lt;/span&gt;= Battery()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ElectricCar 类需要访问其父类Car ，因此我们直接将Car 类导入该模块中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; car &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Car
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; electric_car &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ElectricCar

my_beetle &lt;/span&gt;= Car(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;volkswagen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;beetle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2015&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_beetle.get_descriptive_name())

my_tesla &lt;/span&gt;= ElectricCar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tesla&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;roadster&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2015&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(my_tesla.get_descriptive_name())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从模块car 中导入了Car 类，并从模块electric_car 中导入ElectricCar 类。接下来，我们创建了一辆普通汽车和一辆电动汽车。这两种汽车都得以正确地创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2016&lt;span&gt; Volkswagen Beetle
&lt;/span&gt;2016 Tesla Roadster
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如你看到的，在组织大型项目的代码方面，Python提供了很多选项。熟悉所有这些选项很重要，这样你才能确定哪种项目组织方式是最佳的，并能理解别人开发的项目。一开始应让代码结构尽可能简单。先尽可能在一个文件中完成所有的工作，确定一切都能正确运行后，再将类移到独立的模块中。如果你喜欢模块和文件的交互方式，可在项目开始时就尝试将类存储到模块中。先找出让你能够编写出可行代码的方式，再尝试让代码更为组织有序。&lt;/p&gt;
&lt;h2&gt;七、Python标准库&lt;/h2&gt;
&lt;p&gt;Python标准库 是一组模块，安装的Python都包含它。你现在对类的工作原理已有大致的了解，可以开始使用其他程序员编写好的模块了。可使用标准库中的任何函数和类，为此只需在程序开头包含一条简单的import 语句。下面来看模块collections 中的一个类——OrderedDict &lt;/p&gt;
&lt;p&gt;字典让你能够将信息关联起来，但它们不记录你添加键值对的顺序。要创建字典并记录其中的键—值对的添加顺序，可使用模块collections 中的OrderedDict类。OrderedDict 实例的行为几乎与字典相同，区别只在于记录了键值对的添加顺序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; OrderedDict

favorite_languages &lt;/span&gt;=&lt;span&gt; OrderedDict()

favorite_languages[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
favorite_languages[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sarah&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
favorite_languages[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;edward&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ruby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
favorite_languages[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phil&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; name, language &lt;span&gt;in&lt;/span&gt;&lt;span&gt; favorite_languages.items():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(name.title() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'s favorite language is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
        language.title() &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从模块collections 中导入了OrderedDict 类然后创建了OrderedDict 类的一个实例，并将其存储到favorite_languages 中。请注意，这里没有使用花括号，而是调用OrderedDict() 来创建一个空的有序字典，并将其存储在favorite_languages 中&lt;/p&gt;
&lt;p&gt;接下来，我们以每次一对的方式添加名字语言对，然后遍历favorite_languages ，将以添加的顺序获取调查结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Jen&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s favorite language is Python.&lt;/span&gt;
Sarah&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s favorite language is C.&lt;/span&gt;
Edward&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s favorite language is Ruby.&lt;/span&gt;
Phil&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s favorite language is Python.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个很不错的类，它兼具列表和字典的主要优点（在将信息关联起来的同时保留原来的顺序）。等你开始对关心的现实情形建模时，可能会发现有序字典正好能够满足需求。随着你对标准库的了解越来越深入，将熟悉大量可帮助你处理常见情形的模块。&lt;/p&gt;
&lt;h2&gt;八、编码规范&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;实例名和模块名都采用小写格式，并在单词之间加上下划线。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串，对其中的类可用于做什么进行描述。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;可使用空行来组织代码，但不要滥用。在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import 语句，再添加一个空行，然后编写导入你自己编写的模块的import 语句。在包含多条import 语句的程序中，这种做法让人更容易明白程序使用的各个模块都来自何方。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 10 Jan 2019 18:03:00 +0000</pubDate>
<dc:creator>davieyang</dc:creator>
<og:description>一、摘要 面向对象编程 是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。基于类创建对象 时，每个对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davieyang/p/10246481.html</dc:identifier>
</item>
<item>
<title>java 日志脱敏框架 sensitive-新版本0.0.2-深度拷贝，属性为对象和集合的支持 - 叶止水</title>
<link>http://www.cnblogs.com/houbbBlogs/p/10253271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/houbbBlogs/p/10253271.html</guid>
<description>&lt;p&gt;日志脱敏是常见的安全需求。普通的基于工具类方法的方式，对代码的入侵性太强。编写起来又特别麻烦。&lt;/p&gt;
&lt;p&gt;本项目提供基于注解的方式，并且内置了常见的脱敏方式，便于开发。&lt;/p&gt;
&lt;p&gt;用户也可以基于自己的实际需要，自定义注解。&lt;/p&gt;

&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;基于注解的日志脱敏&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以自定义策略实现，策略生效条件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;常见的脱敏内置方案&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;java 深拷贝，且原始对象不用实现任何接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;maven-导入&quot;&gt;maven 导入&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.houbb&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sensitive&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定义对象&quot;&gt;定义对象&lt;/h2&gt;
&lt;p&gt;我们对 password 使用脱敏，指定脱敏策略为 StrategyPassword。(直接返回 null)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User {

    @Sensitive(strategy = StrategyChineseName.class)
    private String username;
    
    @Sensitive(strategy = StrategyCardId.class)
    private String idCard;
    
    @Sensitive(strategy = StrategyPassword.class)
    private String password;
    
    @Sensitive(strategy = StrategyEmail.class)
    private String email;
    
    @Sensitive(strategy = StrategyPhone.class)
    private String phone;
    
    //Getter &amp;amp; Setter
    //toString()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;属性为集合或者对象&quot;&gt;属性为集合或者对象&lt;/h2&gt;
&lt;p&gt;如果某个属性是单个集合或者对象，则需要使用注解 &lt;code&gt;@SensitiveEntry&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;放在集合属性上，且属性为普通对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;会遍历每一个属性，执行上面的脱敏策略。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;放在对象属性上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;会处理对象中各个字段上的脱敏注解信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;放在集合属性上，且属性为对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;遍历每一个对象，处理对象中各个字段上的脱敏注解信息。&lt;/p&gt;
&lt;h3 id=&quot;放在集合属性上且属性为普通对象&quot;&gt;放在集合属性上，且属性为普通对象&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;UserEntryBaseType.java&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作为演示，集合中为普通的字符串。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserEntryBaseType {

    @SensitiveEntry
    @Sensitive(strategy = StrategyChineseName.class)
    private List&amp;lt;String&amp;gt; chineseNameList;

    @SensitiveEntry
    @Sensitive(strategy = StrategyChineseName.class)
    private String[] chineseNameArray;
    
    //Getter &amp;amp; Setter &amp;amp; toString()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;构建对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 构建用户-属性为列表，列表中为基础属性
 * @return 构建嵌套信息
 * @since 0.0.2
 */
public static UserEntryBaseType buildUserEntryBaseType() {
    UserEntryBaseType userEntryBaseType = new UserEntryBaseType();
    userEntryBaseType.setChineseNameList(Arrays.asList(&quot;盘古&quot;, &quot;女娲&quot;, &quot;伏羲&quot;));
    userEntryBaseType.setChineseNameArray(new String[]{&quot;盘古&quot;, &quot;女娲&quot;, &quot;伏羲&quot;});
    return userEntryBaseType;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试演示&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 用户属性中有集合或者map，集合中属性是基础类型-脱敏测试
 * @since 0.0.2
 */
@Test
public void sensitiveEntryBaseTypeTest() {
    UserEntryBaseType userEntryBaseType = DataPrepareTest.buildUserEntryBaseType();
    System.out.println(&quot;脱敏前原始： &quot; + userEntryBaseType);
    UserEntryBaseType sensitive = SensitiveUtil.desCopy(userEntryBaseType);
    System.out.println(&quot;脱敏对象： &quot; + sensitive);
    System.out.println(&quot;脱敏后原始： &quot; + userEntryBaseType);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;日志信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;脱敏前原始： UserEntryBaseType{chineseNameList=[盘古, 女娲, 伏羲], chineseNameArray=[盘古, 女娲, 伏羲]}
脱敏对象： UserEntryBaseType{chineseNameList=[*古, *娲, *羲], chineseNameArray=[*古, *娲, *羲]}
脱敏后原始： UserEntryBaseType{chineseNameList=[盘古, 女娲, 伏羲], chineseNameArray=[盘古, 女娲, 伏羲]}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;放在对象属性上&quot;&gt;放在对象属性上&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;演示对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的 User 和上面的 User 对象一致。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserEntryObject {

    @SensitiveEntry
    private User user;

    @SensitiveEntry
    private List&amp;lt;User&amp;gt; userList;

    @SensitiveEntry
    private User[] userArray;
    
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对象构建&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 构建用户-属性为列表，数组。列表中为对象。
 * @return 构建嵌套信息
 * @since 0.0.2
 */
public static UserEntryObject buildUserEntryObject() {
    UserEntryObject userEntryObject = new UserEntryObject();
    User user = buildUser();
    User user2 = buildUser();
    User user3 = buildUser();
    userEntryObject.setUser(user);
    userEntryObject.setUserList(Arrays.asList(user2));
    userEntryObject.setUserArray(new User[]{user3});
    return userEntryObject;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试演示&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 用户属性中有集合或者对象，集合中属性是对象-脱敏测试
 * @since 0.0.2
 */
@Test
public void sensitiveEntryObjectTest() {
    UserEntryObject userEntryObject = DataPrepareTest.buildUserEntryObject();
    System.out.println(&quot;脱敏前原始： &quot; + userEntryObject);
    UserEntryObject sensitiveUserEntryObject = SensitiveUtil.desCopy(userEntryObject);
    System.out.println(&quot;脱敏对象： &quot; + sensitiveUserEntryObject);
    System.out.println(&quot;脱敏后原始： &quot; + userEntryObject);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;脱敏前原始： UserEntryObject{user=User{username='脱敏君', idCard='123456190001011234', password='1234567', email='12345@qq.com', phone='18888888888'}, userList=[User{username='脱敏君', idCard='123456190001011234', password='1234567', email='12345@qq.com', phone='18888888888'}], userArray=[User{username='脱敏君', idCard='123456190001011234', password='1234567', email='12345@qq.com', phone='18888888888'}]}
脱敏对象： UserEntryObject{user=User{username='脱*君', idCard='123456**********34', password='null', email='123**@qq.com', phone='188****8888'}, userList=[User{username='脱*君', idCard='123456**********34', password='null', email='123**@qq.com', phone='188****8888'}], userArray=[User{username='脱*君', idCard='123456**********34', password='null', email='123**@qq.com', phone='188****8888'}]}
脱敏后原始： UserEntryObject{user=User{username='脱敏君', idCard='123456190001011234', password='1234567', email='12345@qq.com', phone='18888888888'}, userList=[User{username='脱敏君', idCard='123456190001011234', password='1234567', email='12345@qq.com', phone='18888888888'}], userArray=[User{username='脱敏君', idCard='123456190001011234', password='1234567', email='12345@qq.com', phone='18888888888'}]}&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/houbb/sensitive/issues&quot;&gt;issues&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你对本项目有兴趣，并且对代码有一定追求，可以申请加入本项目开发。&lt;/p&gt;
&lt;p&gt;如果你善于写文档，或者愿意补全测试案例，也非常欢迎加入。&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 16:41:00 +0000</pubDate>
<dc:creator>叶止水</dc:creator>
<og:description>项目介绍 日志脱敏是常见的安全需求。普通的基于工具类方法的方式，对代码的入侵性太强。编写起来又特别麻烦。 本项目提供基于注解的方式，并且内置了常见的脱敏方式，便于开发。 用户也可以基于自己的实际需要，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/houbbBlogs/p/10253271.html</dc:identifier>
</item>
<item>
<title>JAVA工程师-蚂蚁金服电话面试 - 不穿裤子的衣服</title>
<link>http://www.cnblogs.com/softjiang/p/10253268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/softjiang/p/10253268.html</guid>
<description>&lt;p&gt;　　　今天5点半接到一个杭州的电话，是蚂蚁金服打来的，当时心里一阵发慌，由于还在上班，就和面试官约定6点下班之后再来。挂完电话，心里忐忑的不行，感觉自己这也没准备好，那也没准备好。剩下半个小时完全没有心思再工作了，把常问的HashMap,concurrentHashMap底层看了一下，算是临时抱佛脚吧。一下班，就收拾出发在公司楼下找了个地方等面试电话。&lt;/p&gt;
&lt;p&gt;　　   没一会儿，电话如期而至。先是聊了下大概情况，然后聊了下工作经历。叫我挑选一个自己觉得掌握的最好的项目开始发问。&lt;/p&gt;
&lt;p&gt;　　　最开始问了你觉得项目中最难的地方，自己因为毕业了一直在小公司，也没有感觉遇到特别困难的地方，憋了半天憋不出来。面试官也放弃了，直接问，项目中用到Map集合吧，用到过哪些Map。自己就说了个最熟悉的HashMap。但是面试官好像不太想问这个，又问有没有用到过排好序的Map，当时自己脑子短路了，没想到TreeMap是排序的，当时竟然一时想不出有排好序的Map，就说了没有排好序的Map，但是可以实现Compareble接口来实现排序。肯定面试官也很无语，这送分题都不会啊！然后又问HashMap put方法的时间复杂度，我说因为HashMap底层是数组加链表实现的，如果没有hash碰撞时间复杂度就是O(1),有碰撞最坏情况就是O(n)。然后看到我建立上有写线程池，就问了下创建线程池的具体参数的含义，这个没啥难的，然后又问线程池的缓存队列，然后又问是否自己去实现过缓存队列。最后一问完全不知道咋回答，因为平时都是直接使用现成的。然后继续发问，问了下JDK bin目录下的工具除了java javac还有没有用过其他的。我心里想，面试官啊，你把我用过的工具都说完了。然后就只有说没有使用过。自然又是跳过。然后又问项目除了开发，有没有用到优化方面的。我想肯定是想问JVM方面的了。就说了下自己在测试环境服务老是启动没多久就挂了，自己调整了下堆内存的大小。其实当时只是试探性的加大了堆内存，根本没有怎么去分析过。然后面试官问，你是根据什么觉得要去调整堆内存大小的，自己当时就慌了，因为没有实际做过，所以就说自己在启动项目的时候加了输出GC日志的命令，看到有很多Full GC，所以就调整了。感觉面试官不是很满意。然后又问我你知道JVM垃圾回收机制吗？自己其实对JVM垃圾回收这一块还是挺熟悉的，但是这么一问自己一时不知道怎么回答，就把垃圾收集器说了一下，但是感觉不是很对。后来回来百度JVM垃圾回收机制，感觉都有说到JVM内存结构，对象可达性分析，垃圾回收算法，垃圾回收器都有讲到。其实自己这块挺熟悉的，但是一笼统的问JVM垃圾回收机制当时一直在想我该回答哪一块的内容。最后面试官问了如果你要让现在做的项目更好，你回添加一些什么功能。但是自己想了半天也不知道如何回答。面试官应该也很无语，但是不得不说面试官全程都是态度非常好，电话面试都能感受到面试官是一个又谦虚又有真才实学的人。给了我很多建议，说我们程序员一定要一直保持学习，要多学习底层方面的东西。其实自己也很想学习底层的东西，但是底层的确实要难很多，很多书看不动，还是要继续努力才行啊。面试官说，如果有下一步会发邮件，叫我注意关注下。&lt;/p&gt;
&lt;p&gt;　　　这次面试虽然表现很差，但是还是让我获益很多。我知道大的公司都喜欢面试底层，所以自己也对底层有过一些关注，在网上看到都会问HashMap , concurrentHashMap所以对这两个的底层是看了又看，特别是concurrentHashMap的实现1.8之前怎么实现，1.8之后怎么实现都做了很深的了解，然而今天并没有被问到。连简单的TreeMap都忘了，也是自己平时没怎么使用。平时的业务确实也没有涉及到。还有自己对自己做的项目完全没有一个总结，面试官问的关于自己项目的问题自己都回答的简直像坨翔一样。更深的感觉就是不管是什么东西，一定要自己动手去敲，去实现，这样面试官问你你才能完完全全的回答出来，而不是去背书，背书的话随便拐弯问两下你就现原形了。&lt;/p&gt;
&lt;p&gt;　　　接下来，总结项目，根据项目用到的技术复习吧。蚂蚁金服是真看中基础，面试了半个多小时，完全没有问一道框架方面的问题，我还以为会问Spring,Springboot相关的，然而一道题都没有，也不知道是不是因为自己前面基础知识回答得确实太差了，已经不想再问框架的了。面试了这一次也好，也知道该怎么准备了，接下来就是好好努力，努力看书，努力敲代码了。以后争取每一个知识点都自己去用代码敲出来，直到把键盘敲烂为止。😆😆　&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 16:37:00 +0000</pubDate>
<dc:creator>不穿裤子的衣服</dc:creator>
<og:description>今天5点半接到一个杭州的电话，是蚂蚁金服打来的，当时心里一阵发慌，由于还在上班，就和面试官约定6点下班之后再来。挂完电话，心里忐忑的不行，感觉自己这也没准备好，那也没准备好。剩下半个小时完全没有心思再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/softjiang/p/10253268.html</dc:identifier>
</item>
<item>
<title>使用 hashMap和treeMap开启多个摄像头的监控任务 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/10253247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/10253247.html</guid>
<description>&lt;p&gt;背景：今天有个需求，传人多个摄像头ID，然后调用接口，开启这些摄像头的监控任务。&lt;/p&gt;

&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;如果你的摄像头监控任务格式为：&lt;/p&gt;
&lt;p&gt;{camera_id_list=[{createBy=tjt, cameraId=camera01, startTime=2019-1-10 22:58:19}, {createBy=tjt, cameraId=camera02, startTime=2019-1-10 22:58:19}], callback=http://www.baidu.com}&lt;/p&gt;
&lt;p&gt;这种格式的话，那么可以用hashMap搞定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190111000810856-299094697.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;代码如下：&lt;br/&gt;import java.util.Date;&lt;br/&gt;import java.util.HashMap;&lt;br/&gt;import java.util.LinkedList;&lt;/p&gt;&lt;p&gt;import lombok.extern.slf4j.Slf4j;&lt;/p&gt;&lt;p&gt;@Slf4j&lt;br/&gt;public class HashMapUtil {&lt;br/&gt;    &lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        HashMapUtil.testHashMap(&quot;camera01,camera02,camera03&quot;);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    public static void testHashMap(String cameraStrList) {&lt;br/&gt;        String[] splitCameraList = cameraStrList.split(&quot;,&quot;);&lt;br/&gt;        HashMap&amp;lt;String, Object&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;        //add and delete faster than arrayList when using linkList&lt;br/&gt;        LinkedList&amp;lt;Object&amp;gt; linkedList = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        for(String splitCamera : splitCameraList) {&lt;br/&gt;            hashMap.put(&quot;cameraId&quot;, splitCamera);&lt;br/&gt;            hashMap.put(&quot;createBy&quot;,&quot;tjt&quot;);&lt;br/&gt;            hashMap.put(&quot;startTime&quot;, new Date().toLocaleString());&lt;br/&gt;            linkedList.add(hashMap);&lt;br/&gt;            hashMap = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;        }&lt;br/&gt;        HashMap&amp;lt;Object, Object&amp;gt; paramMap = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;        paramMap.put(&quot;camera_id_list&quot;, linkedList);&lt;br/&gt;        paramMap.put(&quot;callback&quot;, &quot;http://www.baidu.com&quot;);&lt;br/&gt;        log.info(&quot;linkedList: &quot;+linkedList);&lt;br/&gt;        log.info(&quot;paramMap: &quot;+paramMap);&lt;br/&gt;    }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;inkedList: [{createBy=tjt, cameraId=camera01, startTime=2019-1-10 22:58:19},{createBy=tjt, cameraId=camera02, startTime=2019-1-10 22:58:19}, {createBy=tjt, cameraId=camera03, startTime=2019-1-10 22:58:19}]&lt;br/&gt; paramMap: {camera_id_list=[{createBy=tjt, cameraId=camera01, startTime=2019-1-10 22:58:19}, {createBy=tjt, cameraId=camera02, startTime=2019-1-10 22:58:19}, {createBy=tjt, cameraId=camera03, startTime=2019-1-10 22:58:19}], callback=http://www.baidu.com}&lt;/p&gt;

&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;如果你的摄像头监控任务格式为：&lt;/p&gt;
&lt;p&gt;{camera_id_list=[{cameraId=camera01, cameraId=camera02, cameraId=camera03}], callback=http://www.baidu.com}&lt;/p&gt;
&lt;p&gt;二叉树treeMap，当传入的两个key值一样，会返回结果0，则会覆盖掉之前的cameraId，返回结果：{camera_id_list=[{cameraId=camera03}], callback=http://www.baidu.com}；&lt;/p&gt;
&lt;p&gt;重写了treeMap中的比较方法，当比较结果返回值小于0，则排在二叉树的左边即集合倒序，当比较结果返回值大于0，则排在二叉树的右边亦不会覆盖之前的key值；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190111000837340-330879076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;package com.xinyan.springcloud.controller;&lt;/p&gt;&lt;p&gt;import java.util.Comparator;&lt;br/&gt;import java.util.HashMap;&lt;br/&gt;import java.util.LinkedList;&lt;br/&gt;import java.util.TreeMap;&lt;/p&gt;&lt;p&gt;import lombok.extern.slf4j.Slf4j;&lt;/p&gt;&lt;p&gt;@Slf4j&lt;br/&gt;public class TreeMapUtil {&lt;br/&gt;    &lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        TreeMapUtil.testTreeMap(&quot;camera01,camera02,camera03&quot;);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    @SuppressWarnings({ &quot;unchecked&quot;, &quot;deprecation&quot; })&lt;br/&gt;    public static void testTreeMap(String cameraStrList) {&lt;br/&gt;        String[] splitCameraList = cameraStrList.split(&quot;,&quot;);&lt;br/&gt;        LinkedList&amp;lt;Object&amp;gt; linkedList = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        @SuppressWarnings({ &quot;unchecked&quot;, &quot;unused&quot;, &quot;rawtypes&quot; })&lt;br/&gt;        TreeMap treeMap = new TreeMap(new Comparator() {&lt;br/&gt;            @Override&lt;br/&gt;            public int compare(Object o1, Object o2) {&lt;br/&gt;                return 100;&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        for(String splitCamera : splitCameraList) {&lt;br/&gt;            treeMap.put(&quot;cameraId&quot;, splitCamera);&lt;br/&gt;        }&lt;br/&gt;        linkedList.add(treeMap);&lt;br/&gt;        HashMap&amp;lt;Object, Object&amp;gt; paramMap = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;        paramMap.put(&quot;camera_id_list&quot;, linkedList);&lt;br/&gt;        paramMap.put(&quot;callback&quot;, &quot;http://www.baidu.com&quot;);&lt;br/&gt;        log.info(&quot;linkedList: &quot;+linkedList);&lt;br/&gt;        log.info(&quot;paramMap: &quot;+paramMap);&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;linkedList: [{cameraId=camera01, cameraId=camera02, cameraId=camera03}]&lt;br/&gt;paramMap: {camera_id_list=[{cameraId=camera01, cameraId=camera02, cameraId=camera03}], callback=http://www.baidu.com}&lt;/p&gt;

</description>
<pubDate>Thu, 10 Jan 2019 16:11:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>背景：今天有个需求，传人多个摄像头ID，然后调用接口，开启这些摄像头的监控任务。 方法一： 如果你的摄像头监控任务格式为： {camera_id_list=[{createBy=tjt, camera</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taojietaoge/p/10253247.html</dc:identifier>
</item>
<item>
<title>时序数据库InfluxDB - 正版乔</title>
<link>http://www.cnblogs.com/qiaohaoforever/p/10252952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiaohaoforever/p/10252952.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在系统服务部署过后，线上运行服务的稳定性是系统好坏的重要体现，监控系统状态至关重要，经过调研了解，时序数据库influxDB在此方面表现优异。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;influxDB介绍&lt;/h3&gt;
&lt;p&gt;时间序列数据是以时间字段为每行数据的标示，比如股票市场的价格，环境中的温度，主机的CPU使用率等。但是又有什么数据是不包含timestamp的呢？几乎所有的数据都可以打上一个timestamp字段。时间序列数据更重要的一个属性是如何去查询它。在查询的时候，对于时间序列我们总是会带上一个时间范围去过滤数据。同时查询的结果里也总是会包含timestamp字段。&lt;br/&gt;InfluxDB 是一个开源分布式时序、事件和指标数据库。使用 Go 语言编写，无需外部依赖。其设计目标是实现分布式和水平伸缩扩展。&lt;br/&gt;它有三大特性：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Time Series （时间序列）：你可以使用与时间有关的相关函数（如最大，最小，求和等）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Metrics（度量）：你可以实时对大量数据进行计算&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Eevents（事件）：它支持任意的事件数据&lt;br/&gt;特点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;schemaless(无结构)，可以是任意数量的列&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;min, max, sum, count, mean, median 一系列函数，方便统计&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Native HTTP API, 内置http支持，使用http读写&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Powerful Query Language 类似&lt;code&gt;sql&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;操作介绍&lt;/h3&gt;
&lt;p&gt;远程连接&lt;/p&gt;
&lt;table width=&quot;NaN&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td height=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td height=&quot;35&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;influx -host xx.xx.xx.xx -port xxxx(默认8086) -username xx -password xx -database xx&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;创建及使用数据库&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;table width=&quot;NaN&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td height=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td height=&quot;35&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create database &quot;test&quot;; --创建数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;show databases;  --查看数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;use test; --选取数据库&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;增删改查&lt;/p&gt;
&lt;table width=&quot;NaN&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td height=&quot;35&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td height=&quot;35&quot; readability=&quot;11&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;SHOW MEASUREMENTS  --查询当前数据库中含有的表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW FIELD KEYS --查看当前数据库所有表的字段&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW series from pay --查看key数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW TAG KEYS FROM &quot;pay&quot; --查看key中tag key值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW TAG VALUES FROM &quot;pay&quot; WITH KEY = &quot;merId&quot; --查看key中tag 指定key值对应的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW TAG VALUES FROM cpu WITH KEY IN (&quot;region&quot;, &quot;host&quot;) WHERE service = 'redis'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP SERIES FROM &amp;lt;measurement_name[,measurement_name]&amp;gt; WHERE &amp;lt;tag_key&amp;gt;='&amp;lt;tag_value&amp;gt;' --删除key&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW CONTINUOUS QUERIES   --查看连续执行命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW QUERIES  --查看最后执行命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;KILL QUERY &amp;lt;qid&amp;gt; --结束命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW RETENTION POLICIES ON mydb  --查看保留数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;查询数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT * FROM /.*/ LIMIT 1  --查询当前数据库下所有表的第一行记录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from pay  order by time desc limit 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from  db_name.&quot;POLICIES name&quot;.measurement_name --指定查询数据库下数据保留中的表数据 POLICIES name数据保留&lt;/span&gt;&lt;br/&gt;&lt;span&gt;删除数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;delete from &quot;query&quot; --删除表所有数据，则表就不存在了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;drop MEASUREMENT &quot;query&quot;   --删除表（注意会把数据保留删除使用delete不会）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DELETE FROM cpu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DELETE FROM cpu WHERE time &amp;lt; '2000-01-01T00:00:00Z'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DELETE WHERE time &amp;lt; '2000-01-01T00:00:00Z'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP DATABASE “testDB” --删除数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP RETENTION POLICY &quot;dbbak&quot; ON mydb --删除保留数据为dbbak数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP SERIES from pay where tag_key='' --删除key中的tag&lt;/span&gt;&lt;p&gt;&lt;span&gt;SHOW SHARDS  --查看数据存储文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP SHARD 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW SHARD GROUPS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW SUBSCRIPTIONS&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;6、数据保留命令&lt;/p&gt;
&lt;p&gt;查看保留期 &lt;code&gt;SHOW RETENTION POLICIES ON mydb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改保留期 &lt;code&gt;ALTER RETENTION POLICY default ON online DEFAULT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除保留期 &lt;code&gt;DROP RETENTION POLICY &amp;lt;retentionpolicy&amp;gt; ON &amp;lt;database&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建保留期 &lt;code&gt;REATE RETENTION POLICY &quot;rp_name&quot; ON &quot;db_name&quot; DURATION 30d REPLICATION 1 DEFAULT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rp_name&lt;/code&gt;：策略名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;db_name&lt;/code&gt;：具体的数据库名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;30d&lt;/code&gt;：保存30天，30天之前的数据将被删除&lt;/p&gt;
&lt;p&gt;它具有各种时间参数，比如：h（小时），w（星期）m minutes h hours d days w weeks INF infinite&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REPLICATION 1&lt;/code&gt;：副本个数，这里填1就可以了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DEFAULT&lt;/code&gt;设为默认的策略&lt;/p&gt;

&lt;p&gt;目前，我们已经&lt;code&gt;influxdb&lt;/code&gt;+&lt;code&gt;grafana&lt;/code&gt;应用到数据库监控、Kafka数据流监控、服务页面数据统计监控等，炫酷的页面给你不一样的体验，试试吧！&lt;/p&gt;
关注微信公众号：&lt;strong&gt;正版乔&lt;/strong&gt;，和我一起探索日常的编程乐趣～
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;一个学统计的程序员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢Coding&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢硬件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢树莓派&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢深度学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢你&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 10 Jan 2019 15:25:00 +0000</pubDate>
<dc:creator>正版乔</dc:creator>
<og:description>在系统服务部署过后，线上运行服务的稳定性是系统好坏的重要体现，监控系统状态至关重要，经过调研了解，时序数据库influxDB在此方面表现优异。 influxDB介绍 时间序列数据是以时间字段为每行数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiaohaoforever/p/10252952.html</dc:identifier>
</item>
<item>
<title>前端常用技术概述--Less、typescript与webpack - 打伞的鱼l</title>
<link>http://www.cnblogs.com/hongxuquan/p/10252939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongxuquan/p/10252939.html</guid>
<description>&lt;blockquote readability=&quot;6.9241011984021&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;前言：讲起前端，我们就不能不讲CSS与Javascript，在这两种技术广泛应用的今天，他们的扩展也是层出不穷，css的扩展有Less、Sass、Stylus 等，js的超集有Typescript等。今天我们就简单来聊聊Less与Typescript以及静态模块打包器webpack。&lt;br/&gt;本节目标：本文为简单普及性知识，旨在让大家了解并初步学会怎么去用这三项技术，以及这三项技术在开发的过程中给我们带来的便利性与好处，挑起大家对这三项技术的兴趣，方便同学们课后去学习。&lt;br/&gt;本文借鉴了以下同学的文章，特此感谢。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 class=&quot;xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;一、Less&lt;/span&gt;&lt;/h2&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1、什么是Less？&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;Less是基于CSS的一种扩展技术，包含变量、混合、函数、运算，可以简化CSS代码，降低维护成本。必须通过解析器将less文件转换为css文件供页面使用。Less让 CSS 更易维护、方便制作主题、扩充。Less 可以运行在 Node 或浏览器端。&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;http://lesscss.cn/&quot; target=&quot;_blank&quot;&gt;Less中文网&lt;/a&gt;。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;2、为什么去用Less&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们在平常web开发过程中写css是否碰到如下的情形：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;.border{
        boder-radius:3px;
        -webkit-border-radius:3px;
        -moz-border-radius:3px;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;以上是设置boder的css，但是现在我们要将3px改成5px怎么办呢，我们就要一个个去改，如果多了我们就会很烦，还有可能漏掉一两个没改，在设置颜色中此类问题更为严重，优秀的程序员怎么可能容忍这样的情况呢，所以此时CSS的预编译技术就出现了。在Less中我们就可以把上述代码改写成如下：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;@borderSize:3px
.border{
        boder-radius:@borderSize;
        -webkit-border-radius:@borderSize;
        -moz-border-radius:@borderSize;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;上面就是Less的语法-变量的一种形式，如果我们此时要去改变border的大小我们只要改变borderSize的值即可。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;3、Less语法概要&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们在这里简单的说几点less的语法使用。&lt;br/&gt;&amp;lt;1&amp;gt;、变量&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//less写法
@color:#fff;
@classname: header;
.@classname{
        background-color:@color
}
//编译后的css
.header{
        background-color:#fff
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;从例子中我们就可以看到，变量不仅仅可以作为样式属性值：background-color: @color;，还可以作为类名：.@classname 表示的就是 .header，less编译时使用 @ 符号获取变量，仅仅将 @变量名 看成是一个字符串。这样我们就有很多应用场景了，可以让我们的代码减少了很多的重复性，也利于后期的修改与维护。&lt;br/&gt;&amp;lt;2&amp;gt;、混合&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//css语法
#menu a {
    color: #111;
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
#menu span {
    height: 16px;
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
//less语法
.bordered {
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}

#menu a {
    color: #111;
    .bordered;
}

#menu span {
    height: 16px;
    .bordered;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;混合也是减少代码书写量的一个方法；&lt;/li&gt;
&lt;li&gt;混合的类名在定义的时候加上小括弧 ()，那么在转译成 css 文件时就不会出现；&lt;/li&gt;
&lt;li&gt;混合的类名在被调用的时候加上小括弧 ()和不加上小括弧 ()是一样的效果，看个人习惯&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;3&amp;gt;、函数&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;// less语法
.border-radius(@radius) {
  -webkit-border-radius: @radius;
     -moz-border-radius: @radius;
          border-radius: @radius;
}
#header {
  .border-radius(4px);
}
.button {
  .border-radius(6px);
}
//编译成css
#header {
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
}
.button {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;可以看到，这里就用到了函数的概念，在 #header 和 .button 中分别传入不同的参数，结果也就生成不同的代码。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;4、怎么去用Less&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;1&amp;gt;、浏览器用法&lt;br/&gt;我们先来讲一下浏览器用法：&lt;br/&gt;首先我们要先写好页面所需要的less文件，然后引入less.js即可。如下：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779305779.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779305779.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;Tips：注意你的less样式文件一定要在引入less.js前先引入。&lt;br/&gt;请在服务器环境下使用！本地直接打开可能会报错！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;当浏览器加载后less.js后文件，会去解析rel为stylesheet/less文件，并将转译后的内容生成style元素内嵌在HTML的head节点中，如下图：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779602154.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779602154.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;此种方式缺点：耗性能，优点：简单开发时候无需一直预编译；&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;2&amp;gt;、服务端用法&lt;br/&gt;我们可以用nodejs将less文件编译成css，再引用css文件。&lt;br/&gt;上节课我们已经讲过了npm与nodejs的用法，接下来我们就演示一遍全局安装less：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;命令为 npm install -g less&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779910071.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779910071.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;br/&gt;这样我们就安装了less，我们也可以看less的编译器lessc的版本，那我们如何将一个less文件编译成一个css文件呢？&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546780584316.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546780584316.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;利用less编译器即可将指定的less文件编译成css到指定的目录底下。&lt;br/&gt;缺点：使用麻烦 优点：提高站点性能；

&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;本节旨在教会大家如何使用less以及less的基本语法，这里还有许多好用的语法没有讲到，比如内置函数、运算、神奇的import等等。less的语法与魅力请有兴趣的同学移步&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;http://lesscss.cn/&quot; target=&quot;_blank&quot;&gt;Less中文网&lt;/a&gt;或者本人将在未来写一篇有关Less的详细文章，敬请期待。&lt;/p&gt;

&lt;h2 class=&quot;xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;二、TypeScript&lt;/span&gt;&lt;/h2&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1、什么是Typescript？&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。截止目前，Typescript已经发布了最新的3.1版本。&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://www.tslang.cn/&quot; target=&quot;_blank&quot;&gt;Typescript中文网&lt;/a&gt;;下图为Typescript与ES6、ES5的关系。Typescript包含了ES6与ES5,简而言之，我们可以在Typescript写ES6与ES5的语法。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;enter description here&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546783020963.png&quot; alt=&quot;enter description here&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546783020963.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;2、为什么要去用Typescript？&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;1&amp;gt;、TypeScript的设计目的应该是解决JavaScript的“痛点”：弱类型和没有命名空间，导致很难模块化，不适合开发大型程序。另外它还提供了一些语法糖来帮助大家更方便地实践面向对象的编程。&lt;br/&gt;&amp;lt;2&amp;gt;、Typescript越来越在前端流行与广泛使用，在最新的TIOBE的编程语言排行榜中，成为最大的黑马，从第167名上升至49名，所以对于想要做好web的我们，了解并熟练掌握Typescript变得极为重要。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;3、Typescript常用语法概要&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们接下来稍微介绍一下Typescript的常用语法：&lt;br/&gt;&amp;lt;1&amp;gt;、数据类型&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;布尔类型:boolean
数字类型:number
字符串类型:string
数组类型:array
元组类型:tuple
枚举类型:enum(新)
任意类型:any(新)
null和undefined
void类型(新)
never类型(新)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;Typescript为了使代码更加规范与更容易维护，新增了数据类型校验：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//js代码,es5的正确写法
var flag=true;
flag=1;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;但是在Typescript这样写是错误的。写ts变量时必须指定数据类型。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//ts写法
var flag:boolean=true;
flag=1;//直接报错。
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;2&amp;gt;、类&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//ts语法
class person{
    name:string;
    constructor(name:string){
        this.name=name
    }
    getname():string{
        return this.name;
    };
    setname(name:string):void{
        this.name=name;
    }
}
var p= new person('张三');
alert( p.getname());
p.setname('李四');
alert(p.getname())
//编译后的js
var person = /** @class */ (function () {
    function person(name) {
        this.name = name;
    }
    person.prototype.getname = function () {
        return this.name;
    };
    ;
    person.prototype.setname = function (name) {
        this.name = name;
    };
    return person;
}());
var p = new person('张三');
alert(p.getname());
p.setname('李四');
alert(p.getname());
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们可以看到,其实Ts的类跟我们后端语言C#之类的非常相像。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;4、如何使用Typescript&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;1&amp;gt;、安装Typescript&lt;br/&gt;浏览器不能直接识别Typescript文件，必须由编译器编译成JS才可以，Visual Studio 2017和Visual Studio 2015 Update 3默认包含了TypeScript。 如果你的Visual Studio还没有安装TypeScript，你可以下载它。&lt;br/&gt;既然我们讲到了npm，我们也可以用npm去安装Typescript。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546782080526.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546782080526.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;如图，我们也可以去看Typescript的编译器的版本。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;2&amp;gt;、最简单的编译操作&lt;br/&gt;接下来我们来演示一下最简单的编译一个ts文件的操作。&lt;br/&gt;首先我们新建一个ts文件&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547042374061.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547042374061.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;然后使用 tsc tsdemo.ts命令编译成tsdemo.js文件，演示如下：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547042531228.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547042531228.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;3&amp;gt; 、配置配置文件&lt;br/&gt;我们如果要将一个Typescript文件（.ts文件）编译成一个js文件，那么每次都要去运行tsc命令是不是很烦呢，那如果要编译整个项目呢？有没有那种我们边写ts边生成js的方法呢？答案肯定是有的。接下来我们去配置配置文件。&lt;br/&gt;我们去运行tsc --init命令，在项目的根目录生成tsconfig.json的配置文件&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546783856530.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546783856530.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;如果一个目录下存在一个tsconfig.json文件，那么它意味着这个目录是TypeScript项目的根目录。 tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不带任何输入文件的情况下调用tsc，编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录。&lt;/li&gt;
&lt;li&gt;不带任何输入文件的情况下调用tsc，且使用命令行参数--project（或-p）指定一个包含tsconfig.json文件的目录。&lt;/li&gt;
&lt;li&gt;当命令行上指定了输入文件时，tsconfig.json文件会被忽略。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;接下来我们根据tsconfig.json文件与vscode来配置一个在编写ts文件时按保存可以时时编译成js文件的方法：&lt;br/&gt;首先，我们先在项目的根目录建一个ts文件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820712430.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820712430.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;然后，我们去tsconfig.json配置要生成的js目录：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546821074744.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546821074744.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;接下来点击vs上方菜单的终端，点击运行任务，选择tsc-监视：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820802687.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820802687.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;此时终端会显示成这样，证明监视成功：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820860038.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820860038.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;我们在ts文件中写ts代码，按ctrl+s保存时，会自动在我们设置好的目录下生成js文件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820992268.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820992268.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;配置项的具体含义请移步官网的&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://www.tslang.cn/docs/handbook/tsconfig-json.html&quot; target=&quot;_blank&quot;&gt;Typescript配置项说明&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;TS的使用方法及简要语法就先介绍到这里，有兴趣的同学可以移步&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://www.tslang.cn/&quot; target=&quot;_blank&quot;&gt;Typescript的中文官网&lt;/a&gt;或者本来在未来将会写一篇有关typescript的详细文章，敬请期待。&lt;/p&gt;

&lt;h2 class=&quot;xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;三、webpack&lt;/span&gt;&lt;/h2&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1、什么是webpack？&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;在当今的社会，作为 web 开发，会越来越意识到前端的重要性，随着 HTML5、 CSS3、 ES6 各种技术的发展，前端的开发越来越庞大。甚至有些应用就是单页面应用(SPA)，纯 JavaScript 开发，JavaScript 文件的管理也是一个问题。JavaScript 模块化编程，已经成为一个迫切的需求，这就出现了 JavaScript 的模块解决方案。webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。&lt;br/&gt;总的来说就是如下图：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546868168518.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546868168518.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;2、如何使用webpack&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;1&amp;gt; 、安装webpack&lt;br/&gt;安装webpack首先必须要有nodejs的环境，我们用npm工具去安装webpack，命令为：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;npm install -g webpack
/*在webpack 3中，webpack本身和它的CLI以前都是在同一个包中，但在第4版中，他们已经将两者分开来更好地管理它们*/
npm install -g webpack-cli
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;安装完毕后我们查看版本如下图：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546868064591.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546868064591.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;2&amp;gt; 、简单上手webpack&lt;br/&gt;接下来我们来做一个最简单的webpack的打包编译。&lt;br/&gt;我首先在vscode新建一个文件夹webpackDemo,新建一个hellowebpack.js的文件，写几句js代码&lt;br/&gt;接下来我们在这个目录下运行命令：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546869950896.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546869950896.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;从警告信息中我们就可以知道，我们没有设定mode，webpack分为开发模式和生产模式。我们看下这两种模式的编译&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546870319896.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546870319896.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546870366886.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546870366886.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;从图中我们也能看出来production编译出来的明显比较小。&lt;br/&gt;上面这种方法是全局去告诉webpack要编译哪个文件，那我们也可以用另外一种方法：&lt;br/&gt;我们先用 npm init -y 初始化项目，新建一个package.json文件。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546872088375.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546872088375.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们再用--save -dev安装局部本地依赖，此时package.json就会有安装依赖包的信息：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547043552619.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547043552619.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;这里面包含了项目的很多信息，记录项目的描述信息：项目作者、项目描述、项目依赖哪些包、插件配置信息等等。&lt;br/&gt;其中scripts对象是指定了运行脚本命令的npm命令行缩写&lt;br/&gt;我们将test改为build，用来简写webpack。注意此文件应放在src文件夹下，当webpack打包时会默认去此文件夹下找。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547047342757.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547047342757.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;此时我们去执行 npm run build命令，就能编译到dist文件夹下的main.js.&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547047540116.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547047540116.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;学会了这个简单的webpack打包，我们能不能让webpack自动帮我们创建html并将js引入进去呢？&lt;br/&gt;接下来我们来进行一下尝试。&lt;br/&gt;首先，我们先用npm init -y命令初始化项目。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547130489110.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547130489110.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;然后再局部引入webpack与webpack-cli&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547130726254.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547130726254.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;之后我们在根目录创建一个webpack.config.js的配置文件，写入入口文件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132297287.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132297287.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;那现在我们要让webpack帮我们创建html文件且引入js文件，就需要用到webpack的一个插件 【HtmlWebpackPlugin】，我们可以去官网查看此插件的用法，&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://www.webpackjs.com/plugins/html-webpack-plugin/&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547131253662.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547131253662.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们局部安装此插件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132378154.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132378154.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;并去webpack.config.js配置好此插件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132431818.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132431818.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;这里的HtmlWebpackPlugin()有一堆的参数，我们这里篇幅有限，只做简要的介绍，具体的更多功能请移步官网查看详解。&lt;br/&gt;此时我们再使用webpack --mode production 命令编译项目，webpack就会帮我们创建好html，并引入进去了。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132685265.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132685265.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;webpack简要的概述就讲到这里，还有兴趣的同学可以自行去官网学习，或者关注本博客，将会在未来推出更加详细的有关webpack的介绍。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;总结：本篇文章我们简要讲了Less、Typescript与模块打包器webpack，这三样技术在未来的web应用的开发绝对是一种不可阻挡的趋势。通过本篇文章的学习，我们已经能够初步的创建一个前端程序，并用webpack打包。这不管对于前端开发者还是全栈开发者，都是不可绕过的门槛，希望读者能继续深入学习，有疑问的可留言一起探讨学习。&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 15:23:00 +0000</pubDate>
<dc:creator>打伞的鱼l</dc:creator>
<og:description>前言：讲起前端，我们就不能不讲CSS与Javascript，在这两种技术广泛应用的今天，他们的扩展也是层出不穷，css的扩展有Less、Sass、Stylus 等，js的超集有Typescr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongxuquan/p/10252939.html</dc:identifier>
</item>
<item>
<title>Django视图层 - 伍萬磊</title>
<link>http://www.cnblogs.com/wanlei/p/10246952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanlei/p/10246952.html</guid>
<description>&lt;h2&gt;目录&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;一、HttpRequest对象&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。&lt;br/&gt;Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/1.11/ref/request-response/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;autoid-2-1-0&quot;&gt;请求相关的常用值&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;path_info&lt;/strong&gt;      返回用户访问url，不包括域名&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;method         &lt;/strong&gt;请求中使用的HTTP方法的字符串表示，全大写表示。&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;GET              &lt;/strong&gt;包含所有HTTP  GET参数的类字典对象&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;POST            &lt;/strong&gt;包含所有HTTP POST参数的类字典对象&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;body             &lt;/strong&gt;请求体，byte类型 request.POST的数据就是从body里面提取到的&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f2852a6d-6fd7-468e-9b25-3b0934882645')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_f2852a6d-6fd7-468e-9b25-3b0934882645&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f2852a6d-6fd7-468e-9b25-3b0934882645&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f2852a6d-6fd7-468e-9b25-3b0934882645',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f2852a6d-6fd7-468e-9b25-3b0934882645&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.HttpRequest.GET

　　一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。

&lt;/span&gt;2&lt;span&gt;.HttpRequest.POST

　　一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。

　　POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是表单中没有任何的数据，QueryDict 对象依然会被创建。
   因此，不应该使用 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.POST  来检查使用的是否是POST 方法；应该使用 &lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。
   
   注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用：
        request.POST.getlist(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hobby&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;3&lt;span&gt;.HttpRequest.body

　　一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML,Json等。
　　但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。


&lt;/span&gt;4&lt;span&gt;.HttpRequest.path

　　一个字符串，表示请求的路径组件（不含域名）。
　　例如：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/music/bands/the_beatles/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

5&lt;span&gt;.HttpRequest.method

　　一个字符串，表示请求使用的HTTP 方法。必须使用大写。
　　例如：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;、&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


6&lt;span&gt;.HttpRequest.encoding

　　一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;）。
   这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。
   接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。
   如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。


&lt;/span&gt;7&lt;span&gt;.HttpRequest.META

 　　一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例：
　　取值：

    CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。
    CONTENT_TYPE —— 请求的正文的MIME 类型。
    HTTP_ACCEPT —— 响应可接收的Content&lt;/span&gt;-&lt;span&gt;Type。
    HTTP_ACCEPT_ENCODING —— 响应可接收的编码。
    HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。
    HTTP_HOST —— 客服端发送的HTTP Host 头部。
    HTTP_REFERER —— Referring 页面。
    HTTP_USER_AGENT —— 客户端的user&lt;/span&gt;-&lt;span&gt;agent 字符串。
    QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。
    REMOTE_ADDR —— 客户端的IP 地址。
    REMOTE_HOST —— 客户端的主机名。
    REMOTE_USER —— 服务器认证后的用户。
    REQUEST_METHOD —— 一个字符串，例如&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 或&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。
    SERVER_NAME —— 服务器的主机名。
    SERVER_PORT —— 服务器的端口（是一个字符串）。
 　　从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，请求中的任何 HTTP 首部转换为 META 的键时，
    都会将所有字母大写并将连接符替换为下划线最后加上 HTTP_  前缀。
    所以，一个叫做 X&lt;/span&gt;-&lt;span&gt;Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。

&lt;/span&gt;8&lt;span&gt;.HttpRequest.FILES

　　一个类似于字典的对象，包含所有的上传文件信息。
   FILES 中的每个键为&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt; 中的name，值则为对应的数据。
　　注意，FILES 只有在请求的方法为POST 且提交的&lt;/span&gt;&amp;lt;form&amp;gt; 带有enctype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multipart/form-data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的情况下才会
   包含数据。否则，FILES 将为一个空的类似于字典的对象。


&lt;/span&gt;9&lt;span&gt;.HttpRequest.COOKIES

　　一个标准的Python 字典，包含所有的cookie。键和值都为字符串。



&lt;/span&gt;10&lt;span&gt;.HttpRequest.session

 　　一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。
    完整的细节参见会话的文档。


&lt;/span&gt;11&lt;span&gt;.HttpRequest.user(用户认证组件下使用)

　　一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。

　　如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。你可以通过 is_authenticated() 区分它们。

    例如：

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; request.user.is_authenticated():
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Do something for logged-in users.&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Do something for anonymous users.&lt;/span&gt;
&lt;span&gt;

     　　user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。

     &lt;/span&gt;-------------------------------------------------------------------------------------&lt;span&gt;

    匿名用户
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; models.AnonymousUser

    django.contrib.auth.models.AnonymousUser 类实现了django.contrib.auth.models.User 接口，但具有下面几个不同点：

    id 永远为None。
    username 永远为空字符串。
    get_username() 永远返回空字符串。
    is_staff 和 is_superuser 永远为False。
    is_active 永远为 False。
    groups 和 user_permissions 永远为空。
    is_anonymous() 返回True 而不是False。
    is_authenticated() 返回False 而不是True。
    set_password()、check_password()、save() 和delete() 引发 NotImplementedError。
    New &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; Django 1.8&lt;span&gt;:
    新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;request相关属性&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;method:请求方式
GET:get请求的参数(post请求,也可以携带参数)
POST:post请求的参数(本质是从bdoy中取出来,放到里面了)
COOKIES
META:字典(放着好多东西,前端传过来的,一定能从其中拿出来)
body:post提交的数据
path:请求的路径,不带参数
request.get_full_path() 请求路径,带参数
session
user
FILES
encoding:编码格式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c4ffa771-483b-41b4-ac30-82a27d045d2e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c4ffa771-483b-41b4-ac30-82a27d045d2e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c4ffa771-483b-41b4-ac30-82a27d045d2e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c4ffa771-483b-41b4-ac30-82a27d045d2e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c4ffa771-483b-41b4-ac30-82a27d045d2e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
1.HttpRequest.get_full_path()

　　返回 path，如果可以将加上查询字符串。

　　例如：&quot;/music/bands/the_beatles/?print=true&quot;
　　注意和path的区别：http://127.0.0.1:8001/order/?name=lqz&amp;amp;age=10

2.HttpRequest.is_ajax()

　　如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest'。

　　大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。

　　如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware，
   你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图以让响应能够正确地缓存。

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;二、HttpResponse对象&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;响应对象主要有三种形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;HttpResponse()&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;render()&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;redirect()&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HttpResponse()括号内直接跟一个具体的字符串作为响应体，比较直接很简单，所以这里主要介绍后面两种形式。&lt;/p&gt;
&lt;h3&gt;render()&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;render(request, template_name[, context]）
 
结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;6&quot;&gt;
参数：
     request： 用于生成响应的请求对象。

     template_name：要使用的模板的完整名称，可选的参数

     context：添加到模板上下文的一个字典。默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。&lt;p&gt;render方法就是将一个模板页面中的模板语法进行渲染，最终渲染成一个html页面作为响应体。
&lt;/p&gt;&lt;/pre&gt;
&lt;h3&gt;redirect()&lt;/h3&gt;
&lt;p&gt;传递要重定向的一个硬编码的URL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
def my_view(request):
    ...
    return redirect('/some/url/')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以是一个完整的URL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
def my_view(request):
    ...
    return redirect('http://www.baidu.com/')　
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_7d464ac1-4d95-4190-8cf9-a4a4372dad78&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt; &lt;span class=&quot;cnblogs_code_collapse&quot;&gt;重定向301和302的区别&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;三、JsonResponse&lt;/h2&gt;
&lt;p&gt;向前端返回一个&lt;span&gt;json格式字符串&lt;/span&gt;的两种方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_a92abf24-d80a-48fa-a4ab-73c226349f1d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt; &lt;span class=&quot;cnblogs_code_collapse&quot;&gt;两种方式&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;转列表格式:指定safe=False&lt;br/&gt;中文字符问题:json_dumps_params={'ensure_ascii':False}&lt;/p&gt;
&lt;h2&gt;四、CBV和FBV&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CBV基于类的视图(Class base view)和FBV基于函数的视图（Function base view）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; View
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AddPublish(View):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; dispatch(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以写类似装饰器的东西，在前后加代码&lt;/span&gt;
        obj=super().dispatch(request, *args, **&lt;span&gt;kwargs) 总的分发方法
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self,request):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self,request):
        request
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;在路由层:类名加as_view后一定要加括号&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
re_path(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^myclass/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,views.MyClass.as_view()),
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、简单文件上传&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;file_name&lt;/span&gt;=request.FILES.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).name
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.core.files.uploadedfile &lt;span&gt;import&lt;/span&gt;&lt;span&gt; InMemoryUploadedFile
with open(file_name,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)as f:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; request.FILES.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).chunks():
        f.write(i)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    -form表单默认提交的编码方式是enctype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        -前端:如果要form表单上传文件,必须指定编码方式为:multipart/form-&lt;span&gt;data
        &lt;/span&gt;-&lt;span&gt;后端:
            file&lt;/span&gt;=request.FILES.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myfile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            with open(file.name,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file:
                    f.write(line)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;注意&lt;/h3&gt;
&lt;p&gt;前端提交数据编码格式:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-multipart/form-&lt;span&gt;data(上传文件)
&lt;/span&gt;-application/x-www-form-urlencoded(默认编码)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 10 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>伍萬磊</dc:creator>
<og:description>目录 一 HttpRequest对象 二 HttpResponse对象 三 JsonResponse 四 CBV和FBV 五 简单文件上传 一、HttpRequest对象 当一个页面被请求时，Djan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanlei/p/10246952.html</dc:identifier>
</item>
<item>
<title>springboot配置druid连接池 - Brl</title>
<link>http://www.cnblogs.com/-brl/p/10252890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-brl/p/10252890.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Druid的简介&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Druid首先是一个数据库连接池。Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。Druid是阿里巴巴开发的号称为监控而生的数据库连接池！&lt;/p&gt;
&lt;p&gt;Druid的功能&lt;/p&gt;
&lt;p&gt;1、替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。&lt;/p&gt;
&lt;p&gt;2、可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。&lt;/p&gt;
&lt;p&gt;3、数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。&lt;/p&gt;
&lt;p&gt;4、SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。&lt;/p&gt;
&lt;p&gt;5、扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter机制，很方便编写JDBC层的扩展插件。&lt;/p&gt;
&lt;p&gt;所以Druid可以：&lt;br/&gt;1、充当数据库连接池。&lt;br/&gt;2、可以监控数据库访问性能&lt;br/&gt;3、获得SQL执行日志&lt;/p&gt;
&lt;p&gt;在spring boot基础上开始配置：&lt;/p&gt;
&lt;p&gt;1.引入当前最新的版本，这里我们使用的maven&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;druid&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.1.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.新建一个配置类，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
@Configuration&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在项目启动时可以初始化配置&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DruidConfiguration {
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletRegistrationBean staViewServlet(){
        ServletRegistrationBean servletRegistrationBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ServletRegistrationBean(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StatViewServlet(),
                &lt;/span&gt;&quot;/druid/*&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;白名单为空允许任何ip访问&lt;/span&gt;
        servletRegistrationBean.addInitParameter(&quot;allow&quot;,&quot;127.0.0.1&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ip黑名单(存在共同时，deny优先于allow)：如果满足deny的即提示：Sorry you are not permitted...&lt;/span&gt;
        servletRegistrationBean.addInitParameter(&quot;deny&quot;,&quot;127.0.0.2&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录查看信息的账号密码&lt;/span&gt;
        servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;,&quot;druid&quot;&lt;span&gt;);
        servletRegistrationBean.addInitParameter(&lt;/span&gt;&quot;loginPassword&quot;,&quot;druid&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否能够重置数据&lt;/span&gt;
        servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;,&quot;true&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; servletRegistrationBean;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FilterRegistrationBean statFilter(){
        FilterRegistrationBean filterRegistrationBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FilterRegistrationBean(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebStatFilter());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加过滤规则&lt;/span&gt;
        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加不需要忽略的格式信息&lt;/span&gt;
        filterRegistrationBean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpn,*.png,*.css,*.ico,/druid/*&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filterRegistrationBean;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置数据库的基本连接信息&lt;/span&gt;
&lt;span&gt;    @Bean
    @Primary
    @ConfigurationProperties(prefix &lt;/span&gt;= &quot;spring.datasource&quot;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在application.properties中读取配置信息注入到DruidDataSource里&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSource dataSource(){
        DruidDataSource druidDataSource &lt;/span&gt;=  DataSourceBuilder.create().type(DruidDataSource.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).build();
        druidDataSource.setInitialSize(&lt;/span&gt;3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化物理连接的数量&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            druidDataSource.addFilters(&lt;/span&gt;&quot;stat,wall&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;stat是sql监控，wall是防火墙(如果不添加则监控无效)，不能添加log4j不然会出错&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; druidDataSource;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在application.properties中添加如下配置信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/mrbshiro?characterEncoding=UTF-8
spring.datasource.username=root
spring.datasource.password=123456&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这些配置会自动注入到我们上面的&lt;span&gt;DruidDataSource实列里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样就可以访问projectUrl/druid进行登录了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210597/201901/1210597-20190110230447775-1471056137.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 10 Jan 2019 15:05:00 +0000</pubDate>
<dc:creator>Brl</dc:creator>
<og:description>Druid的简介Druid首先是一个数据库连接池。Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-brl/p/10252890.html</dc:identifier>
</item>
</channel>
</rss>