<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[译]Golang中的优雅重启 - MnCu</title>
<link>http://www.cnblogs.com/MnCu8261/p/10498849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MnCu8261/p/10498849.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原文 &lt;a href=&quot;https://grisha.org/blog/2014/06/03/graceful-restart-in-golang/&quot;&gt;Graceful Restart in Golang&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者 &lt;a href=&quot;https://grisha.org/&quot;&gt;grisha&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明：本文目的仅仅作为个人mark，所以在翻译的过程中参杂了自己的思想甚至改变了部分内容，其中有下划线的文字为译者添加。但由于译者水平有限，所写文字或者代码可能会误导读者，如发现文章有问题，请尽快告知，不胜感激。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Update (Apr 2015): &lt;a href=&quot;https://github.com/fvbock&quot;&gt;Florian von Bock&lt;/a&gt;已经根据本文实现了一个叫做&lt;a href=&quot;https://github.com/fvbock/endless&quot;&gt;endless&lt;/a&gt;的Go package&lt;/p&gt;
&lt;p&gt;大家知道，当我们用Go写的web服务器需要修改配置或者需要升级代码的时候我们需要重启服务器，如果你（像我一样）已经将优雅的重启视为理所当然，因为使用Golang你需要自己动手来做这些操作，所以你可能会发现这个方式非常方便。&lt;/p&gt;
&lt;h3 id=&quot;什么是优雅重启&quot;&gt;什么是优雅重启&lt;/h3&gt;
&lt;p&gt;本文中的优雅重启表现为两点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进程在不关闭其所监听的端口的情况下重启&lt;/li&gt;
&lt;li&gt;重启过程中保证所有请求能被正确的处理&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;进程在不关闭其所监听的端口的情况下重启&quot;&gt;1.进程在不关闭其所监听的端口的情况下重启&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;fork一个子进程，该子进程继承了父进程所监听的socket&lt;/li&gt;
&lt;li&gt;子进程执行初始化等操作，并最终开始接收该socket的请求&lt;/li&gt;
&lt;li&gt;父进程停止接收请求并等待当前处理的请求终止&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;fork一个子进程&quot;&gt;fork一个子进程&lt;/h5&gt;
&lt;p&gt;有不止一种方法fork一个子进程，但在这种情况下推荐&lt;a href=&quot;https://golang.org/pkg/os/exec/#Command&quot;&gt;exec.Command&lt;/a&gt;，因为&lt;a href=&quot;https://golang.org/pkg/os/exec/#Cmd&quot;&gt;Cmd&lt;/a&gt;结构提供了一个字段&lt;code&gt;ExtraFiles&lt;/code&gt;，该字段(注意不支持windows)为子进程额外地指定了需要继承的额外的文件描述符，不包含&lt;code&gt;std_in, std_out, std_err&lt;/code&gt;。&lt;br/&gt;需要注意的是，&lt;code&gt;ExtraFiles&lt;/code&gt;描述中有这样一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;If non-nil, entry i becomes file descriptor 3+i&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句是说，索引位置为i的文件描述符传过去，最终会变为值为i+3的文件描述符。ie: 索引为0的文件描述符565, 最终变为文件描述符3&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;file := netListener.File() // this returns a Dup()
path := &quot;/path/to/executable&quot;
args := []string{
    &quot;-graceful&quot;}

cmd := exec.Command(path, args...)
cmd.Stdout = os.Stdout
cmd.Stderr = os.Stderr
cmd.ExtraFiles = []*os.File{file}

err := cmd.Start()
if err != nil {
    log.Fatalf(&quot;gracefulRestart: Failed to launch, error: %v&quot;, err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，&lt;code&gt;netListener&lt;/code&gt;是一个&lt;a href=&quot;https://golang.org/pkg/net/#Listener&quot;&gt;net.Listener&lt;/a&gt;类型的指针，path变量则是我们要更新的新的可执行文件的路径。&lt;/p&gt;
&lt;p&gt;需要注意的是：上面&lt;code&gt;netListener.File()&lt;/code&gt;与&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/dup.html&quot;&gt;dup&lt;/a&gt;函数类似，返回的是一个拷贝的文件描述符。另外，该文件描述符不应该设置&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/fcntl.html&quot;&gt;FD_CLOEXEC&lt;/a&gt;标识，这将会导致出现我们不想要的结果：子进程的该文件描述符被关闭。&lt;/p&gt;
&lt;p&gt;你可能会想到可以使用命令行参数把该文件描述符的值传递给子进程，但相对来说，我使用的这种方式更为简单&lt;/p&gt;
&lt;p&gt;最终，&lt;code&gt;args&lt;/code&gt;数组包含了一个&lt;code&gt;-graceful&lt;/code&gt;选项，你的进程需要以某种方式通知子进程要复用父进程的描述符而不是新打开一个。&lt;/p&gt;
&lt;h5 id=&quot;子进程初始化&quot;&gt;子进程初始化&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;server := &amp;amp;http.Server{Addr: &quot;0.0.0.0:8888&quot;}

var gracefulChild bool
var l net.Listever
var err error

flag.BoolVar(&amp;amp;gracefulChild, &quot;graceful&quot;, false, &quot;listen on fd open 3 (internal use only)&quot;)

if gracefulChild {
    log.Print(&quot;main: Listening to existing file descriptor 3.&quot;)
    f := os.NewFile(3, &quot;&quot;)
    l, err = net.FileListener(f)
} else {
    log.Print(&quot;main: Listening on a new file descriptor.&quot;)
    l, err = net.Listen(&quot;tcp&quot;, server.Addr)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;通知父进程停止&quot;&gt;通知父进程停止&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;if gracefulChild {
    parent := syscall.Getppid()
    log.Printf(&quot;main: Killing parent pid: %v&quot;, parent)
    syscall.Kill(parent, syscall.SIGTERM)
}

server.Serve(l)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;父进程停止接收请求并等待当前所处理的所有请求结束&quot;&gt;父进程停止接收请求并等待当前所处理的所有请求结束&lt;/h5&gt;
&lt;p&gt;为了做到这一点我们需要使用&lt;a href=&quot;https://golang.org/pkg/sync/#WaitGroup&quot;&gt;sync.WaitGroup&lt;/a&gt;来保证对当前打开的连接的追踪，基本上就是：每当接收一个新的请求时，给wait group做原子性加法，当请求结束时给wait group做原子性减法。也就是说wait group存储了当前正在处理的请求的数量&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var httpWg sync.WaitGroup&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;匆匆一瞥，我发现go中的http标准库并没有为Accept()和Close()提供钩子函数，但这就到了&lt;code&gt;interface&lt;/code&gt;展现其魔力的时候了(非常感谢&lt;a href=&quot;http://nella.org/jra/&quot;&gt;Jeff R. Allen&lt;/a&gt;的这篇&lt;a href=&quot;http://blog.nella.org/zero-downtime-upgrades-of-tcp-servers-in-go/&quot;&gt;文章&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;下面是一个例子，该例子实现了每当执行Accept()的时候会原子性增加wait group。首先我们先继承&lt;code&gt;net.Listener&lt;/code&gt;实现一个结构体&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type gracefulListener struct {
    net.Listener
    stop    chan error
    stopped bool
}

func (gl *gracefulListener) File() *os.File {
    tl := gl.Listener.(*net.TCPListener)
    fl, _ := tl.File()
    return fl
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们覆盖Accept方法(暂时先忽略&lt;code&gt;gracefulConn&lt;/code&gt;)&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (gl *gracefulListener) Accept() (c net.Conn, err error) {
    c, err = gl.Listener.Accept()
    if err != nil {
        return
    }

    c = gracefulConn{Conn: c}

    httpWg.Add(1)
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还需要一个构造函数以及一个Close方法，构造函数中另起一个goroutine关闭，为什么要另起一个goroutine关闭，请看&lt;code&gt;refer^{[1]}&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func newGracefulListener(l net.Listener) (gl *gracefulListener) {
    gl = &amp;amp;gracefulListener{Listener: l, stop: make(chan error)}
    // 这里为什么使用go 另起一个goroutine关闭请看文章末尾
    go func() {
        _ = &amp;lt;-gl.stop
        gl.stopped = true
        gl.stop &amp;lt;- gl.Listener.Close()
    }()
    return
}

func (gl *gracefulListener) Close() error {
    if gl.stopped {
        return syscall.EINVAL
    }
    gl.stop &amp;lt;- nil
    return &amp;lt;-gl.stop
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的&lt;code&gt;Close&lt;/code&gt;方法简单的向stop chan中发送了一个nil，让构造函数中的goroutine解除阻塞状态并执行Close操作。最终，goroutine执行的函数释放了&lt;code&gt;net.TCPListener&lt;/code&gt;文件描述符。&lt;/p&gt;
&lt;p&gt;接下来，我们还需要一个&lt;code&gt;net.Conn&lt;/code&gt;的变种来原子性的对wait group做减法&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type gracefulConn struct {
    net.Conn
}

func (w gracefulConn) Close() error {
    httpWg.Done()
    return w.Conn.Close()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了让我们上面所写的优雅启动方案生效，我们需要替换&lt;code&gt;server.Serve(l)&lt;/code&gt;行为:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;netListener = newGracefulListener(l)
server.Serve(netListener)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后补充：我们还需要避免客户端长时间不关闭连接的情况，所以我们创建server的时候可以指定超时时间：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;server := &amp;amp;http.Server{
        Addr:           &quot;0.0.0.0:8888&quot;,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   10 * time.Second,
        MaxHeaderBytes: 1 &amp;lt;&amp;lt; 16}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;译者总结&quot;&gt;译者总结&lt;/h4&gt;
&lt;h4 id=&quot;译者注&quot;&gt;译者注:&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;refer^{[1]}&lt;/code&gt;&lt;br/&gt;&lt;span&gt;在上面的代码中使用goroutine的原因作者写了一部分，但我并没有读懂，但幸好在评论中，&lt;a href=&quot;https://disqus.com/by/disqus_uypMWCNAEC/&quot;&gt;jokingus&lt;/a&gt;问道：如果用下面的方式，是否就不需要在&lt;code&gt;newGracefulListener&lt;/code&gt;中使用那个goroutine函数了&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (gl *gracefulListener) Close() error { 
    // some code
    gl.Listener.Close()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;作者回复道：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Honestly, I cannot fathom why there would need to be a goroutine for this, and simply doing gl.Listener.Close() like you suggest wouldn't work.... May be there is some reason that is escaping me presently, or perhaps I just didn't know what I was doing? If you get to the bottom of it, would you post here, so I can correct the post if this goroutine business is wrong?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;作者自己也较为疑惑，但表示像&lt;a href=&quot;https://disqus.com/by/disqus_uypMWCNAEC/&quot;&gt;jokingus&lt;/a&gt;所提到的这种方式是行不通的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;译者的个人理解：在绝大多数情况下，需要一个goroutine(可以称之为主goroutine)来创建socket，监听该socket，并accept直到有请求到达，当请求到来之后再另起goroutine进行处理。首先因为accept一般处于主goroutine中，且其是一个阻塞操作，如果我们想在accept执行后关闭socket一般来说有两个方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;为accept设置一个超时时间，到达超时时间后，检测是否需要close socket，如果需要就关闭。但这样的话我们的超时时间可定不能设置太大，这样结束就不够灵敏，但设置的太小，就会对性能影响很大，总之来说不够优雅。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;accept方法可以一直阻塞，当我们需要close socket的时候，在另一个goroutine执行流中关闭socket，这样相对来说就比较优雅了，作者所使用的方法就是这种&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;另外，也可以参考：&lt;a href=&quot;http://blog.fatedier.com/2016/02/19/how-to-shutdown-go-net-dot-listeners-gracefully/&quot;&gt;Go中如何优雅地关闭net.Listener&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 15:43:00 +0000</pubDate>
<dc:creator>MnCu</dc:creator>
<og:description>原文 'Graceful Restart in Golang' 作者 'grisha' 声明：本文目的仅仅作为个人mark，所以在翻译的过程中参杂了自己的思想甚至改变了部分内容，其中有下划线的文字为译</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MnCu8261/p/10498849.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：18. 我对 Docker 的使用的学习心得 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop018.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;关于 Docker 的介绍，我这里就不废话了。Docker 是什么？Docker 和虚拟机有什么区别？Docker 适用的场景是什么？这些介绍早就烂大街了。大家可以去 Docker 的官网首页看介绍，也可以在博客园的首页随便搜一下，入门级的文章到处都是。如果想了解更深一点的技术细节，可以看 &lt;a href=&quot;https://www.cnblogs.com/sparkdev&quot;&gt;sparkdev&lt;/a&gt; 的博客，我这里先对 &lt;a href=&quot;https://www.cnblogs.com/sparkdev&quot;&gt;sparkdev&lt;/a&gt; 表示感谢，我这篇随笔中，引用了他的部分内容。而且，我这篇的标题是“我对 Docker 的使用的学习心得”，重点是学习它的使用，而不是它的原理。&lt;/p&gt;
&lt;h2 id=&quot;安装-docker&quot;&gt;安装 Docker&lt;/h2&gt;
&lt;p&gt;在 Ubuntu 中安装 Docker 真的是太方便了。完全不用访问 Docker 的官网，不需要自己去下载，&lt;code&gt;apt&lt;/code&gt;超级牛力瞬间搞定。稍微需要注意的是，不是安装&lt;code&gt;docker&lt;/code&gt;软件包，而是安装&lt;code&gt;docker.io&lt;/code&gt;软件包。首先，我先用&lt;code&gt;sudo aptitude search docker&lt;/code&gt;命令查看 Ubuntu 的软件源中有哪些和 Docker 有关的包，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308220307802-1364471466.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;docker&lt;/code&gt;被明确标记为 transitional package，所以我们安装下面的&lt;code&gt;docker.io&lt;/code&gt;包，使用&lt;code&gt;sudo aptitude install docker.io&lt;/code&gt;命令。安装完成后，使用&lt;code&gt;sudo docker --version&lt;/code&gt;查看一下，发现是最新的版本，而且是社区版，不是企业版，所以其版本号为 18.06.1-ce。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308220609285-2127873492.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;拉两个镜像测试一下&quot;&gt;拉两个镜像测试一下&lt;/h2&gt;
&lt;p&gt;只要稍微了解一点 Docker 的人都知道有一个 dockerhub，和我们常用的 github 一样，可以获得别人精心制作并分享的资源。在 github 中，我们可以找到我们感兴趣的项目，并把它 clone 到本地。而在 dockerhub 中，这些资源叫 Image，我们可以把我们感兴趣的 Image 拉到本地，并以该 Image 为基础，运行一些 Container。&lt;/p&gt;
&lt;p&gt;关于 Image 和 Container 的概念，我这里不再废话。我选择了一个 ubuntu，还有一个 spacevim。使用的命令分别为&lt;code&gt;sudo docker pull ubuntu&lt;/code&gt;和&lt;code&gt;sudo docker pull spacevim&lt;/code&gt;。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308221230807-622237421.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置-docker-使用中国的-image-仓库&quot;&gt;配置 Docker 使用中国的 Image 仓库&lt;/h2&gt;
&lt;p&gt;上面拉取 Image 的操作看似简单，其实经历过失败，主要原因就是国外的仓库被墙挡住了。解决这个问题的方法，就是设置 Docker 使用中国的 Image 仓库。其设置方法为修改&lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;配置文件，如果没有该文件，就新建一个。将其内容修改为：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;{
    &quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，使用如下命令重启 Docker 服务：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;systemctl daemon-reload
systemctl restart docker&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行一个容器&quot;&gt;运行一个容器&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;sudo docker image ls&lt;/code&gt;命令可以查看我们的机器上有哪些 Image，使用&lt;code&gt;sudo docker container ps -a&lt;/code&gt;命令，可以查看我们的机器上有哪些 Container。在上图中，在我们拉取镜像之前，它们的显示结果都是空的。&lt;code&gt;sudo docker container ps -a&lt;/code&gt;命令之所以要加上&lt;code&gt;-a&lt;/code&gt;参数，就是为了显示所有的 Container，包括运行的和停止的。&lt;/p&gt;
&lt;p&gt;拉取完了以后，再使用&lt;code&gt;sudo docker image ls&lt;/code&gt;命令，显示的就不再是空的了。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308222651050-1422478420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，使用&lt;code&gt;sudo docker run -it spacevim/spacevim nvim&lt;/code&gt;命令运行一个容器，启动 SpaceVim，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308222800465-1801142486.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，我分别写了一个 C 语言的文件和一个 Python 语言的文件，同时修改了一下 SpaceVim 自己的配置文件。&lt;/p&gt;
&lt;h2 id=&quot;介绍一下-spacevim&quot;&gt;介绍一下 SpaceVim&lt;/h2&gt;
&lt;p&gt;SpaceVim 是一个非常优秀的 Vim 整合项目，简单点说，就是通过各种插件把 Vim 打造成一个万能的 IDE，而且它对 NeoVim 支持非常好。确实很漂亮，功能也确实很强大。但是，我系统上用的 Vim 是我自己配的一个非常简洁的 Vim（请看我前面的随笔），如果再在系统上安装 SpaceVim 就不太方便。所以，使用 SpaceVim 官方提供的 Docker Image 就是一个非常方便的选择了。&lt;/p&gt;
&lt;h2 id=&quot;docker-的最常用命令和参数&quot;&gt;Docker 的最常用命令和参数&lt;/h2&gt;
&lt;p&gt;从上面的截图可以看出，我们最常用的命令就是&lt;code&gt;sudo docker run&lt;/code&gt;命令，它就是以某个 Image 为基础运行一个新的 Container，注意，是新的 Container 哦。也就是说，每执行一次&lt;code&gt;sudo docker run&lt;/code&gt;，就建立一个新的 Container，哪怕它们用的是同一个 Image。如果要启动一个已经存在的 Container 怎么办呢？别担心，有&lt;code&gt;sudo docker container start&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;最常用的参数是&lt;code&gt;-i&lt;/code&gt;和&lt;code&gt;-t&lt;/code&gt;，只有这样，我们才能够和 Container 中的程序进行交互。其次，就是&lt;code&gt;-p&lt;/code&gt;参数，可以把 Container 中的某个端口映射到主机的某个端口，这对网络服务非常重要。还有&lt;code&gt;-v&lt;/code&gt;参数，可以把主机的某个目录映射到 Container 中的某个目录，这样，共享文件就很方便了。&lt;/p&gt;
&lt;h2 id=&quot;使用-spacevim-时遇到的问题在一个-container-中可以运行多个程序吗&quot;&gt;使用 SpaceVim 时遇到的问题：在一个 Container 中可以运行多个程序吗？&lt;/h2&gt;
&lt;p&gt;使用 SpaceVim 的 Image 启动一个 Container 后，问题来了。每次启动这个 Container，就自动运行 nvim，进入 SpaceVim 的界面，编辑文件是不成问题，可是这个编辑器界面毕竟不是 Shell 不是吗？我们其它的管理工作怎么做？&lt;/p&gt;
&lt;p&gt;而我们使用 ubuntu 的 Image 启动 Container 后就很方便了，直接进入 Bash。所以问题来了，在一个 Container 中可以执行多个程序吗？&lt;/p&gt;
&lt;p&gt;答案是肯定的，那就是&lt;code&gt;sudo docker container exec&lt;/code&gt;命令，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308225416786-221819767.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，我们进入 Ubuntu 时，直接和 Shell 进行交互，所以可以非常方便地使用&lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;pwd&lt;/code&gt;等命令，甚至可以使用&lt;code&gt;cat /etc/os-release&lt;/code&gt;命令查看系统的版本信息。当然，还可以使用&lt;code&gt;apt&lt;/code&gt;安装软件。而要想进入 SpaceVim 所在的容器，就需要使用&lt;code&gt;sudo docker container exec -i spacevim-1.0 bash&lt;/code&gt;命令再启动一个 Shell，这样就可以使用&lt;code&gt;ls&lt;/code&gt;命令看到我们刚才编辑的&lt;code&gt;test.c&lt;/code&gt;和&lt;code&gt;test.py&lt;/code&gt;了。甚至可以使用&lt;code&gt;ps&lt;/code&gt;命令查看该容器中运行的进程。&lt;/p&gt;
&lt;h2 id=&quot;docker-的学习资源&quot;&gt;Docker 的学习资源&lt;/h2&gt;
&lt;p&gt;Docker 的官网就别看了，难受。买书呢？费钱！还不一定能找到优秀的。最好的办法就是查看 Docker 的手册页啦。使用&lt;code&gt;sudo dpkg -L docker.io&lt;/code&gt;命令，可以看到系统中安装了好多手册页，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308230336762-1050665506.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果输入&lt;code&gt;man docker&lt;/code&gt;，就是下面这样：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308230410062-641847169.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果输入&lt;code&gt;man docker run&lt;/code&gt;，就是下面这样：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308230445002-92823188.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想自己写 Dockfile，就输入&lt;code&gt;man Dockfile&lt;/code&gt;。我就不继续截图了。每一个手册页都可以从头读到尾，这种流畅的感觉是在 Docker 的官网上查看文档体会不到的。&lt;/p&gt;
&lt;h2 id=&quot;下一个问题我们可以把我们的-container-再打包带走吗&quot;&gt;下一个问题：我们可以把我们的 Container 再打包带走吗？&lt;/h2&gt;
&lt;p&gt;运行一个 Container 后，我们可以在上面编辑文件、更改配置，还可以按需安装软件。做了很多工作后，我们可以把这个 Container 打包带走吗？当然可以了，使用&lt;code&gt;sudo docker container commit&lt;/code&gt;命令可以基于一个 Container 再创建一个镜像。然后使用&lt;code&gt;sudo docker push&lt;/code&gt;命令就可以把这个镜像再上传到 dockerhub 上了。当然，这只是理想状态，毕竟有墙的存在，而且 dockerhub 要注册后才能上传镜像。所以上传这个事就不是那么好做啊。&lt;/p&gt;
&lt;p&gt;不过没关系，我们可以打包用 U 盘带走。&lt;code&gt;sudo docker image save&lt;/code&gt;命令可以把 Image 导出为本地文件。使用 U 盘带走后，使用&lt;code&gt;sudo docker image load&lt;/code&gt;命令可以从这个文件再导入镜像。&lt;/p&gt;
&lt;h2 id=&quot;下一个问题docker-中的程序可以访问我们主机上的所有硬件资源吗&quot;&gt;下一个问题：Docker 中的程序可以访问我们主机上的所有硬件资源吗？&lt;/h2&gt;
&lt;p&gt;其实我关心的是显卡。在我的上上篇随笔中，我写到了使用 CUDA 加速计算，而 CUDA 需要 Nvidia 的显卡支持。如果我要用 Docker 构建一个 CUDA 的开发环境，那就需要我 Docker 中的程序能够访问主机的显卡资源。从理论上讲，这是可以的。毕竟 Docker 不同于虚拟机，Docker 是和主机共享内核的，而 Nvidia 的驱动，只是一个内核模块。于是，我在使用 Ubuntu 镜像的 Container 中测试了一下。使用&lt;code&gt;lsmod&lt;/code&gt;命令查看内核模块，发现它确实是使用的 Nvidia 的驱动，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308232004015-351660252.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，使用&lt;code&gt;sudo aptitude install nvidia-cuda-toolkit&lt;/code&gt;安装 cuda-toolkit，也是可以安装的。因此，证明 Docker 中的程序可以访问主机上的所有硬件资源。使用 Docker 构建我们自己的开发环境不是梦。&lt;/p&gt;
&lt;h2 id=&quot;最后一个问题docker-中能运行-gui-程序吗&quot;&gt;最后一个问题：Docker 中能运行 GUI 程序吗？&lt;/h2&gt;
&lt;p&gt;答案是可以。&lt;/p&gt;
&lt;p&gt;先来分析一下思路。在 Docker 中运行控制台程序时，我们需要给程序一个标准输入输出，就可以和程序交互了。在 Docker 中运行 Web 服务时，我们需要给程序一个 IP 和端口，就可以和服务交互了。GUI 程序需要什么呢？它们需要一个 X Server 的 Display。我们给它就行了。&lt;/p&gt;
&lt;p&gt;DISPLAY的格式是&lt;code&gt;unix:端口&lt;/code&gt;或&lt;code&gt;主机名:端口&lt;/code&gt;，前一种格式表示使用本地的 unix 套接字，后一种表示使用 tcp 套接字。默认情况下，X11的服务端会监听本地的&lt;code&gt;unix:0&lt;/code&gt;端口，而 DISPLAY 的默认值为&lt;code&gt;:0&lt;/code&gt;，这实际上是&lt;code&gt;unit:0&lt;/code&gt;的简写。因此如果在 Linux 的控制台启动一个图形程序，它就会出现在当前主机的显示屏幕中。&lt;/p&gt;
&lt;p&gt;而 unix 套接字就是一个文件，所以，可以使用&lt;code&gt;-v&lt;/code&gt;参数，将主机的 unix 套接字共享到 Container 中，然后，运行在 Container 中的 GUI 程序，就会出现在主机的屏幕上。&lt;/p&gt;
&lt;p&gt;其实早在2015年的“Docker全球开发者大会”上，Docker 自家的美女程序员“杰西·弗莱泽尔（Jessie Frazelle）”就展示了一系列黑魔法一样的镜像。这些镜像中的大多数都使用了图形界面。比如，她使用这样的命令&lt;code&gt;docker run -d -v /tmp/.X11-unix:/tmp/.X11-unix jess/libreoffice&lt;/code&gt;在 Docker 中运行了 LibreOffice（这只是举例，真要运行成功还有很多细节需要完善），其中最重要的参数就是&lt;code&gt;-v /tmp/.X11-unix:/tmp/.X11-unix&lt;/code&gt;，也就是把主机的 unix 套接字映射到 Container 中。&lt;/p&gt;
&lt;p&gt;OK，关于 Docker，今天就写这么多。我感觉我又找到了新世界的大门。&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2019年03月08日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 15:38:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop018.html</dc:identifier>
</item>
<item>
<title>致2019年在软件工程师之路奋斗的你 - 代号六零一</title>
<link>http://www.cnblogs.com/daihaoliulingyi601/p/HLJ.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daihaoliulingyi601/p/HLJ.html</guid>
<description>[unable to retrieve full-text content]今天第一次上来博客园写写东西，之前在头条喜欢写一些杂七杂八的东西，但后来发现头条是一个鱼龙混杂的地方，什么新闻都有，要说发表技术的文章估计没有多少人看。毕竟在博客园大部分搜索的人都是一些有着相同梦想和需求的人，希望在这里可以认识更多大牛，也更希望我的分享可以给大家带来帮助，我今后会写一些关于自己学习</description>
<pubDate>Fri, 08 Mar 2019 15:14:00 +0000</pubDate>
<dc:creator>代号六零一</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop018.html</dc:identifier>
</item>
<item>
<title>没有基础也能写个小程序 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/10498779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/10498779.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文章记录了小程序的设计思路，介绍了使用的技术，描述了提交审核的故事，还提供了最终的完整源码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;微信小程序自从发布以来就占据着超高的话题热度，一直以来都想开发一款自己的小程序，但苦于不懂前端迟迟没有开始。偶然发现了ColorUI这个开源的小程序组件库，界面好看且提供Demo，心中狂喜马上动手&lt;/p&gt;
&lt;p&gt;做个什么小程序呢？想了一圈这半年多一直坚持在写技术文章，为此开通了微信公众号，因为公众号查看文章列表不友好，且不方便在微信以外的渠道传播，我又利用Github Pages搭建了&lt;a href=&quot;https://ops-coffee.cn&quot;&gt;运维咖啡吧&lt;/a&gt;网站主页，就想做个类似于网站主页的小程序吧，可以在微信体系内优化公众号文章列表页读取以及方便分类检索&lt;/p&gt;

&lt;p&gt;计划参考&lt;a href=&quot;https://ops-coffee.cn&quot;&gt;运维咖啡吧&lt;/a&gt;网站主页写个小程序页面来展示微信公众号内的所有文章，后边加上搜索、标签等方便检索，用户点击列表后跳转到微信公众号具体的文章查看，形成闭环&lt;/p&gt;
&lt;p&gt;首先写了个“列表”页，用来展示公众号内的所有文章，但写完列表后发现小程序并不支持跳转到公众号的文章，不能查看文章这个小程序的意义就失去了大半&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/8/1695dd77d461bb2b?w=637&amp;amp;h=1324&amp;amp;f=jpeg&amp;amp;s=134087&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后添加了一个“关于”页面，页面内介绍小程序是干嘛的顺便给个公众号入口，方便对文章感兴趣的朋友继续阅读&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/8/1695dd77d468936b?w=638&amp;amp;h=1325&amp;amp;f=jpeg&amp;amp;s=108188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码完成后提交给小程序审核，约半天时间反馈审核失败，原因是“实际运营内容与名称简介不符”，想着可能审核的伙伴不知道运维是干嘛的，看到名称里包含咖啡吧，以为是跟咖啡相关的，反馈解释了一下什么是运维，以及小程序跟公众号的关系，再次提交审核，又等了半天功夫，还是反馈审核失败，这次原因是“小程序进入点击页面内容无反应”，我就写了个列表页，列表内容并不能点，这不是BUG，又反馈了一次但很遗憾跟上次一样的原因依然审核失败，看来必须得能点&lt;/p&gt;
&lt;p&gt;决定添加一个“详情”页面，并不准备在详情内放文章的详细内容，因为这涉及到以往文章数据整理以及需要提供后端接口等问题，只想着能够审核通过，所以简单展示了文章的基本内容，给了个跳转到公众号的按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/8/1695dd77d447c5d9?w=638&amp;amp;h=1325&amp;amp;f=jpeg&amp;amp;s=60773&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编码完成再次提交审核，顺利通过&lt;/p&gt;

&lt;p&gt;下边介绍一下这个小程序中用到一些技术点&lt;/p&gt;
&lt;h2 id=&quot;for循环展示&quot;&gt;for循环展示&lt;/h2&gt;
&lt;p&gt;列表页面的展示采用了for循环读取JS数据&lt;/p&gt;
&lt;p&gt;JS里边用一个Blogs变量来记录文章列表页的数据，JS里边定义的变量可以直接在模板渲染时引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Page({
  data: {
    StatusBar: app.globalData.StatusBar,
    CustomBar: app.globalData.CustomBar,
    Blogs: [
        {
            &quot;title&quot;: &quot;Django内置权限扩展案例&quot;,
            &quot;image&quot;: &quot;https://ws1.sinaimg.cn/large/7164c73agy1g0vl4k4veej20zk0f841d.jpg&quot;,
            &quot;description&quot;: &quot;当Django的内置权限无法满足需求的时候&quot;,
            &quot;url&quot;: &quot;https://mp.weixin.qq.com/s/BZsJnWLtv8ZwwlBYbWSbZQ&quot;,
            &quot;tag&quot;: &quot;Django&quot;
        },
        {
            &quot;title&quot;: &quot;我们自研的那些Devops工具&quot;,
            &quot;image&quot;: &quot;https://ws1.sinaimg.cn/large/7164c73agy1g0vl4wtqdfj20zk0k00ve.jpg&quot;,
            &quot;description&quot;: &quot;随着云技术以及容器技术的崛起，人肉运维的时代结束了&quot;,
            &quot;url&quot;: &quot;https://mp.weixin.qq.com/s/HwOi-ARTvvNjGTWrDmZIkQ&quot;,
            &quot;tag&quot;: &quot;DevOps&quot;
        }
    ]
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模板渲染时用到了循环标签&lt;code&gt;wx:for&lt;/code&gt;，可以读取JS变量的列表值，然后通过&lt;code&gt;{{item}}&lt;/code&gt;拿到列表中的每个对象，再通过&lt;code&gt;{{item.key}}&lt;/code&gt;拿到对象的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;view bindtap=&quot;toChild&quot; data-blog=&quot;{{item}}&quot; class=&quot;cu-item shadow&quot; wx:for=&quot;{{Blogs}}&quot; wx:key&amp;gt;
&amp;lt;view class=&quot;title&quot;&amp;gt;{{item.title}}&amp;lt;/view&amp;gt;
&amp;lt;view class=&quot;content&quot;&amp;gt;
  &amp;lt;image src=&quot;{{item.image}}&quot; mode=&quot;aspectFill&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;view class=&quot;desc&quot;&amp;gt;
    &amp;lt;view class=&quot;text-content&quot;&amp;gt; {{item.description}}&amp;lt;/view&amp;gt;
    &amp;lt;view class=&quot;flex justify-between&quot;&amp;gt;
      &amp;lt;text class=&quot;text-xs text-gray&quot;&amp;gt;原创：37丫37&amp;lt;/text&amp;gt;
      &amp;lt;view class=&quot;bg-right cu-tag bg-green light sm round&quot;&amp;gt;{{item.tag}}&amp;lt;/view&amp;gt;
    &amp;lt;/view&amp;gt;
  &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;后端取数据&quot;&gt;后端取数据&lt;/h2&gt;
&lt;p&gt;考虑到文章可能会随时增加，将数据直接写在JS里边并不友好，每次变更还要重新发布审核，所以从后端接口读取数据才是最好的方式，但考虑到成本问题没必要专门写个后端程序来处理，直接将内容存json，提供https访问即可&lt;/p&gt;
&lt;p&gt;在页面加载的时候去后台请求数据，然后给设置成变量Blogs，页面渲染参考上边介绍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onLoad: function () {
    var that = this;
    wx.request({
      url: 'https://ops-coffee.cn/blog.json',
      header: {
        'content-type': 'application/json'
      },
      //请求后台数据成功
      success: function (res) {
        that.setData({
          Blogs: res.data.data
        })
      }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;页面跳转&quot;&gt;页面跳转&lt;/h2&gt;
&lt;p&gt;点击列表内容跳转到详情页该怎么实现呢？&lt;/p&gt;
&lt;p&gt;我们先来看看跳转，跳转可以直接通过&lt;code&gt;navigator&lt;/code&gt;标签实现，&lt;code&gt;open-type&lt;/code&gt;指定跳转方式，&lt;code&gt;url&lt;/code&gt;指定跳转的页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;navigator open-type=&quot;navigate&quot; url=&quot;/pages/index/detail/detail?data={{item}}&quot; class=&quot;cu-item shadow&quot; wx:for=&quot;{{Blog}}&quot; wx:key&amp;gt;
    &amp;lt;view class=&quot;title&quot;&amp;gt;{{item.title}}&amp;lt;/view&amp;gt;
    ...
&amp;lt;/navigator&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者通过&lt;code&gt;bindtap&lt;/code&gt;事件触发&lt;code&gt;wx.navigateTo&lt;/code&gt;实现跳转，&lt;code&gt;data-blog&lt;/code&gt;可以指定bindtap事件参数，从而在JS中获取&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;view bindtap=&quot;toChild&quot; data-blog=&quot;{{item}}&quot; class=&quot;cu-item shadow&quot; wx:for=&quot;{{Blogs}}&quot; wx:key&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;toChild(event) {
    var blog = event.currentTarget.dataset.blog;
    
    wx.navigateTo({
      url: '/pages/index/blog/blog'
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;本地存储&quot;&gt;本地存储&lt;/h2&gt;
&lt;p&gt;当点击列表内容跳转到详情页，正常的做法应该是去后台请求文章的详情以渲染详情页面，但这里我需要展示的内容列表页已经存在了，无需再次请求就找了个偷懒的做法，在用户点击列表内容时，把这篇文章的详细信息利用&lt;code&gt;wx.setStorageSync&lt;/code&gt;存储在本地&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;toChild(event) {
    var blog = event.currentTarget.dataset.blog;
    
    wx.setStorageSync(
      'blog',blog
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在详情页加载时利用&lt;code&gt;wx.getStorageSync&lt;/code&gt;取出来渲染到页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onLoad: function (option) {
    var blog = wx.getStorageSync('blog');
    
    this.setData({
      blog:blog
    })
},&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关联公众号&quot;&gt;关联公众号&lt;/h2&gt;
&lt;p&gt;小程序提供关联公众号的功能，需要先在小程序后台：设置-&amp;gt;关注公众号中开启公众号关注组件，然后在页面的相应地方添加上如下代码就可以像文章详情页最下边一样出来个关联公众号的组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;official-account&amp;gt;&amp;lt;/official-account&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但访问时可能会发现打开详情页并没有出现关联公众号的组件，这个主要是因为并非所有的情况下都会展示，只有用对了姿势才能看到，官方文档有更多介绍，目前还没有办法彻底解决看不到的问题&lt;/p&gt;
&lt;h2 id=&quot;页面分享&quot;&gt;页面分享&lt;/h2&gt;
&lt;p&gt;小程序上线后我想分享给朋友装逼，确发现没有方便的方式，查官方文档发现可以用&lt;code&gt;onShareAppMessage&lt;/code&gt;方法，只需简单的添加到想分享页面的JS中即可，然后在右上角的功能按钮中就会出现转发功能&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onShareAppMessage() {
    return {
      title: '运维咖啡吧',
      path: '/pages/index/list/list'
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;长按文末二维码关注微信公众号【运维咖啡吧】回复&quot;03&quot;可获取源码地址，期待你的到来&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;感谢ColorUI，如此优秀的项目才能让我没有基础的情况下快速开发一款小程序&lt;/li&gt;
&lt;li&gt;此项目从开发到完成大概只花了1天的时间，比较简陋，学习小程序的实验项目，各位轻喷&lt;/li&gt;
&lt;li&gt;对于框架的学习我的做法是先看一遍官方文档的介绍，了解基本的内容，能看得懂项目结构，然后再开始编码&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/8/1695dd77d456157d?w=430&amp;amp;h=475&amp;amp;f=jpeg&amp;amp;s=67696&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得文章不错，请点右下角【好看】。如果你觉得读的不尽兴，推荐阅读以下文章：&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 15:11:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>文章记录了小程序的设计思路，介绍了使用的技术，描述了提交审核的故事，还提供了最终的完整源码 背景说明 微信小程序自从发布以来就占据着超高的话题热度，一直以来都想开发一款自己的小程序，但苦于不懂前端迟迟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/37Y37/p/10498779.html</dc:identifier>
</item>
<item>
<title>CUBA 7 新特性（上篇） - CUBA-China</title>
<link>http://www.cnblogs.com/cubacn/p/cuba-newversion.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cubacn/p/cuba-newversion.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;  &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182113978-1294519029.png&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　三年前，我们宣布了&lt;/span&gt; CUBA 框架的第二个公开的主版本。&lt;a href=&quot;https://www.cuba-platform.com/blog/whats-new-in-cuba-platform-6-0-and-studio-2-0&quot;&gt;&lt;span&gt;CUBA 6&lt;/span&gt;&lt;/a&gt; &lt;span&gt;是改变游戏规则的版本&lt;/span&gt; - 框架的许可从私有化变成了公开的 Apache2.0。那些日子里，我们甚至猜不到这个变化会最终将框架带向何方。随之而来的是，CUBA社区开始呈指数级增长，从中我们学习到许多开发人员可能使用框架的方法（有时甚至是不可能的方法）。现在我们很高兴的宣布 &lt;a href=&quot;https://www.cuba-platform.com/blog/cuba-7-the-new-chapter&quot;&gt;&lt;span&gt;CUBA 7&lt;/span&gt;&lt;/a&gt; &lt;span&gt;的发布，通过这个版本，我们希望那些刚刚开始&lt;/span&gt;CUBA和Java之旅的社区成员能更加顺利和快乐的成长为熟练的企业级开发人员或者Java专家。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182148912-1311792502.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;开发工具&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　显然，&lt;/span&gt;CUBA 的成功很大一部分要依赖于 &lt;a href=&quot;https://www.cuba-platform.com/development-tools&quot;&gt;&lt;span&gt;CUBA Studio&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。它极大的简化了繁琐的&lt;/span&gt; Java 企业级开发任务，很多地方被简化成只需要在可视化编辑器进行简单的配置即可，不需要了解Persistence API 或者 Gradle，甚至不需要了解 Spring 就能开发出来完整的、功能丰富的CRUD 应用程序。这一切，Studio就能帮你完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182223277-1112118201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以前，&lt;/span&gt;Studio 是一个单独的 web 应用程序，这样会有一些明显的局限：&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;首先，&lt;/span&gt;Studio 并不是功能完备的 IDE，所以开发者需要经常在 Studio 和 IntelliJ IDEA 或者Eclipse 之间切换，以便在 IDE 中开发业务逻辑，也能更好的利用 IDE 方便的导航、代码完成功能和其他必要的功能。来回地切换有时候很烦人。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;其次，&lt;/span&gt;Studio 的简单性是建立在大量的源码解析和生成的基础上。所以，要提高代码生成的能力也就意味着要朝着开发功能完备的IDE方向努力 - 这个想法太过雄心勃勃了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后我们决定依靠另一位巨人的肩膀来解决这些局限。现在&lt;/span&gt; Studio 跟 JetBrains 开发的IntelliJ IDEA 合并了。现在可以将 Studio 作为 IntelliJ IDEA 的插件安装或者下载单独打包的版本。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182312522-1585450293.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　这个方法为我们开辟了新的视野：&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;能支持其它&lt;/span&gt;JVM的开发语言（首先就是Kotlin）&lt;/p&gt;
&lt;p&gt;　　l 提升了热部署的能力&lt;/p&gt;
&lt;p&gt;　　l 整个项目中能更直观的导航&lt;/p&gt;
&lt;p&gt;　　l 更聪明的代码生成和提醒&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在新的&lt;/span&gt;Studio正在积极的开发中：我们正在移植旧版本的功能。短期计划还包括使用原生IntelliJ UI重新实现基于 Web 的设计器，并改善项目导航体验。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;技术栈升级&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　跟以前主版本升级一样，这次底层的技术栈也做了升级，比如&lt;/span&gt; Java 8/11，Vaadin 8，Spring 5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182342189-1458114780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认情况下新项目会使用&lt;/span&gt;Java 8，但是也可以通过在build.gradle中添加下面的内容来指定需要的Java版本：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182402750-1540875340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　升级到&lt;/span&gt;Vaadin 8是个不小的挑战，因为Vaadin的数据绑定API发生了很大的破坏性变化。但使用CUBA的开发者很幸运，因为CUBA为开发者提供了统一封装的自有API层，屏蔽了底层Vaadin的内部结构。CUBA开发团队做了大量的工作，重新实现了很多内部逻辑以保持CUBA自有的API不变化。也就是说，这很好的保持了CUBA框架的兼容性，不需要做任何重构就可以直接移植到CUBA 7并享受Vaadin 8带来的好处。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　依赖库的完整升级列表可以在官方的&lt;/span&gt; &lt;a href=&quot;http://files.cuba-platform.com/cuba/release-notes/7.0/#upd_dep&quot;&gt;&lt;span&gt;release notes&lt;/span&gt;&lt;/a&gt; &lt;span&gt;中找到。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;新的界面&lt;/span&gt;API&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这一小节也可以称为&lt;/span&gt; “第一版界面API”，因为CUBA之前没有任何官方的声明在web客户端层有API存在。界面API基于框架的历史，也基于我们最初的一些假设：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以声明为中心的方法&lt;/span&gt; - 所有可以以声明式描述的，都应该在界面描述文件中声明，而不是在其控制器中编码。&lt;/p&gt;
&lt;p&gt;　　标准界面（浏览和编辑界面）提供具体的通用功能，一般不需要修改。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从最初的一千个成员加入了社区开始，我们就认识到对于&lt;/span&gt;“标准” CRUD 界面的需求是有多么广泛，已经超出了最开始我们设计的一组功能了。然而，很长一段时间，即使没有 API 层，我们也能够处理自定义行为的需求，这是因为有另一个第一阶段假设 - 开放继承。有效地进行开放继承意味着可以覆盖基础类的任何公共或保护方法，再根据需要定制其行为。这听起来似乎是所有顽疾的解药，但事实上可能短期都不一定能见效：如果被覆盖的方法被重命名、删除了或者将来版本的框架根本不同这个方法了，该怎么办？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182429358-1461271772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，为了响应社区日益增长的需求，我们决定引入新的界面&lt;/span&gt;API。API提供了清晰的长期的扩展点，而没有隐藏的声明式暗喻，灵活并且易于使用。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;界面声明&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt; CUBA 7 里，界面声明异常简单：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182454961-1573939596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从上面的例子我们可以看到，界面的标识符在控制器类上显式的进行定义。也就是说，现在界面&lt;/span&gt;id和控制器类能相互唯一的对应。由此带来的好消息就是，现在界面可以直接通过其控制类来安全访问了（注意下面例子用控制器类来创建确认窗口）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182503854-1192734549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　至此，界面描述文件不再是必须的，而成为了一个补充的部分。界面布局可以通过编程的方式创建或者通过&lt;/span&gt; XML 界面描述声明式创建，界面描述通过控制器类的 @UiDescriptor 注解定义。这样能使得控制器和布局更加容易读懂。这个方式跟Android开发中使用的模式非常类似。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之前，需要在&lt;/span&gt;web-screens.xml中注册一个界面描述并为其设置一个标识符。在 CUBA 7 中，这个文件只是因为兼容性的考虑被保留下来，用新方法创建界面不需要这种注册了。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;界面生命周期&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　新的&lt;/span&gt;API带来了清晰的自描述的界面生命周期事件：&lt;/p&gt;
&lt;p&gt;　　l Init&lt;/p&gt;
&lt;p&gt;　　l AfterInit&lt;/p&gt;
&lt;p&gt;　　l BeforeShow&lt;/p&gt;
&lt;p&gt;　　l AfterShow&lt;/p&gt;
&lt;p&gt;　　l BeforeClose&lt;/p&gt;
&lt;p&gt;　　l AfterClose&lt;/p&gt;
&lt;p&gt;　　CUBA 7 中所有的界面相关的事件都可以用下面的方式订阅：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182527423-563418869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将新&lt;/span&gt;API与旧方法进行比较，可以看到我们没有重写钩子方法，之前这些钩子方法在父类的层次结构中被模糊地调用。现在我们在界面生命周期的明确预定义的点中定义业务逻辑。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;事件处理和功能代理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　前一小节我们介绍了如何订阅生命周期事件，那么，其他组件呢？我们是否应该像在&lt;/span&gt;6.x版本中那样在界面初始化时分散所有必需的监听器？新API非常统一，因此订阅其他事件与生命周期事件完全相似。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们举一个带有两个&lt;/span&gt;UI元素的简单例子，一个按钮和一个货币字段控件，因此它的XML描述符如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182546718-1859839437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过单击按钮我们调用中间件服务返回一个数字，该数字将被写到货币控件中。货币控件需要根据价格的值更改其样式。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182648391-1628367278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在上面的例子中，我们看到有两个事件处理器：一个是按钮按下时调用的，另一个是当货币控件的值发生变化时执行的。就是这么简单。&lt;/p&gt;
&lt;p&gt;　　现在，我们设想一下，如果需要验证价格的值并确保其为一个正数。最直接的方法就是在界面初始化的时候为其添加一个验证器：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182705539-1711560311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在真实的应用程序中，界面的入口点经常会被这种界面元素的初始化方法填满。为了避免这个问题，&lt;/span&gt;CUBA提供了一个非常有用的注解 @Install。看看使用这个注解怎么避免这个情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182731147-1591504663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　事实上，这里是将货币控件验证的逻辑代理给了界面的&lt;/span&gt; currencyFieldValidator 方法来执行。虽然看上去稍微复杂一点，但是开发人员使用起这个功能来惊人的快速。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;界面&lt;/span&gt;Builders/通知消息/对话框&lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182817877-1188204209.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　CUBA 7 还引入了一些新的非常有用的带有流式 API 的组件：&lt;/p&gt;
&lt;p&gt;　　l ScreenBuilders 结合了流式工厂来生成标准的查找、编辑和自定义界面。下面的例子展示了如何从一个界面打开另一个界面。注意，build() 方法能返回正确类型的界面实例，不需要不安全的类型转换。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182837428-999038243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　l Screens 组件相对于 ScreenBuilders 来说提供了更底层的抽象，用来显示和创建界面。并且提供了访问 CUBA 应用程序中所有已打开界面信息的方法（Screens#getOpenedScreens），如果需要遍历这些界面，这个方法很有用。&lt;/p&gt;
&lt;p&gt;　　l Notifications和Dialogs 组件均提供了自描述的方便接口。这里有个例子创建对话框和消息通知：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182851908-2145613901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;数据绑定&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　CUBA 之所以可以做到后台UI的快速开发，不仅仅是因为提供了可以生成大部分代码的可视化工具，还因为提供了大量开箱即用的具有数据感知能力的组件。 这些组件只需要知道要使用哪些数据，其余事情会自动管理。例如， 查找列表、选择器字段、具有 CRUD 操作的各种网格等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在版本&lt;/span&gt; 7 之前，数据绑定是通过称为数据源的对象实现的，数据源包装单个实体或实体集合、与数据感知组件绑定，然后响应数据感知组件的数据变化。 这种方法非常有效，但是是以一个整块的方式实现的。 整块石头似的架构通常在可定制性方面会有问题。因此在 CUBA 7 中，这块坚固的巨石被分成 3 个数据组件：&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;Data Loader (数据加载器）&lt;/strong&gt; &lt;span&gt;是&lt;/span&gt;&lt;span&gt;数据容器的数据提供者。&lt;/span&gt; &lt;span&gt;数据加载器不保存数据，它们只是将所有必需的查询参数传递给数据存储，并将结果数据集提供给数据容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;Data container (数据容器)  &lt;/strong&gt;&lt;span&gt;保留加载的数据（单个实体或多个实体）并以响应式的方式将数据提供给数据感知组件：被包装实体的所有更改都会暴露给相应的&lt;/span&gt;UI组件，反之亦然，UI组件内的所有更改都会引起数据容器作出相应更改。&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;Data context&lt;/strong&gt;  &lt;span&gt;（数据上下文）&lt;/span&gt;是一个强大的数据更改管理器，可跟踪更改并提交所有已修改的&lt;span&gt;实体。&lt;/span&gt; &lt;span&gt;一个实体可以合并到一个数据上下文中，合并后会得到一个原始实体的副本，这个副本与原始实体有一个唯一但非常重要的区别：对副本实体及其引用的所有实体（包括集合）的所有修改都将被跟踪、存储和提交。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　数据组件可以在界面描述符中声明，也可以使用专门的工厂类&lt;/span&gt; - DataComponents 以编程的方式创建。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;其它&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　上面介绍了新的界面&lt;/span&gt;API中最重要的部分，所以剩下的部分我简要列出 Web客户端层中的其他重要功能：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　URL 历史记录和导航&lt;/strong&gt;&lt;span&gt;。此功能解决了在&lt;/span&gt; WEB 浏览器中具带有“后退”按钮的 SPA 应用程序存在的一个普遍问题，提供了一种简单地为应用程序界面分配路径的方法，同时使 API 能够在URL中反映界面的当前状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　使用&lt;/span&gt; Form 代替 FieldGroup&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt; FieldGroup 是一个数据感知组件，用于显示和修改单个实体的字段。它在运行时推断出用于显示字段的实际UI组件。也就是说，如果你的实体中有一个日期类型的字段，它将使用 DateField 组件来显示 。但是，如果你希望以编程方式使用此组件，则需要将此组件注入到界面控制器并手动将其转换为正确的类型（在我们的示例中为DateField）。过了一段时间，可能会字段类型更改为其他类型，这时应用程序就是崩溃。表单通过显式声明组件类型解决此问题。关于 Form 的更多信息请参阅&lt;a href=&quot;https://doc.cuba-platform.com/manual-7.0/gui_Form.html?_ga=2.116833092.339458145.1551663632-952816468.1486173136&quot;&gt;&lt;span&gt;&lt;span&gt;这里&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　显著地简化了第三方&lt;/span&gt; JavaScript 组件的集成&lt;/strong&gt;，可参考这个&lt;a href=&quot;https://doc.cuba-platform.com/manual-7.0/jsComponent.html?_ga=2.141916144.339458145.1551663632-952816468.1486173136&quot;&gt;&lt;span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;将自定义&lt;/span&gt; JavaScript 组件嵌入到CUBA 应用程序中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　现在可以在&lt;/span&gt; XML 界面描述中轻松定义 HTML/CSS属性&lt;/strong&gt;，也可以通过编程方式设置。详细信息请参阅&lt;a href=&quot;https://doc.cuba-platform.com/manual-7.0/gui_attributes.html?_ga=2.182882532.339458145.1551663632-952816468.1486173136#gui_attr_css&quot;&gt;&lt;span&gt;&lt;span&gt;这里&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　好了，以上只是关于&lt;/span&gt; Studio 和偏前端的新功能介绍，下篇会介绍偏后端的新功能。&lt;/p&gt;

</description>
<pubDate>Fri, 08 Mar 2019 14:17:00 +0000</pubDate>
<dc:creator>CUBA-China</dc:creator>
<og:description>三年前，我们宣布了 CUBA 框架的第二个公开的主版本。CUBA 6 是改变游戏规则的版本 - 框架的许可从私有化变成了公开的 Apache2.0。那些日子里，我们甚至猜不到这个变化会最终将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cubacn/p/cuba-newversion.html</dc:identifier>
</item>
<item>
<title>python垃圾回收机制 - 吃饭睡觉打逗逗</title>
<link>http://www.cnblogs.com/lurenjia1994/p/10498593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lurenjia1994/p/10498593.html</guid>
<description>&lt;p&gt;python中有自动内存回收机制，一般情况不需要程序员来处理，面试时被大佬问到了，记录一下。没有画图，推荐读参考的第一篇博文&lt;/p&gt;

&lt;h2&gt;gc方式1：引用计数&lt;/h2&gt;
&lt;p&gt;若此对象无其他对象引用，则立马回收掉&lt;/p&gt;
&lt;h4&gt;优点：简单、实时（将处理垃圾时间分摊到运行代码时，而不是等到一次回收）&lt;/h4&gt;
&lt;h4&gt;缺点：&lt;/h4&gt;
&lt;p&gt;1.保存对象引用数会占用一点点内存空间&lt;/p&gt;
&lt;p&gt;2.每次执行语句都可能更新引用数，不再使用大的数据结构时，会引起大量对象被回收&lt;/p&gt;
&lt;p&gt;3.不能处理循环引用的情况&lt;/p&gt;

&lt;h2&gt;gc方式2：标记-清除（Mark—Sweep）&lt;/h2&gt;
&lt;p&gt;此方式主要用来处理循环引用的情况，只有容器对象（list、dict、tuple，instance）才会出现循环引用的情况&lt;/p&gt;
&lt;h4&gt;循环引用示例：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1046062/201903/1046062-20190308212848414-1797660854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; 处理过程&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.将所有容器对象放到一个双向链表中（链表为了方便插入删除），这些对象为0代

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;.循环遍历链表，如果被本链表内的对象引入，自身的被引用数-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，如果被引用数为0，则触发引用计数回收条件，被回收掉

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;.未被回收的对象，升级为1代
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;触发条件：&lt;/h4&gt;
&lt;p&gt;因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代链表。&lt;/p&gt;
&lt;p&gt;随着时间的推移，一代链表越来越多，多到触发gc阈值，同样会对一代链表进行标记清除操作，然后将剩下活跃对象升为二代&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1046062/201903/1046062-20190308211852069-678917010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1046062/201903/1046062-20190308213942672-108078035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;何时触发&lt;/h2&gt;
&lt;p&gt;1.被引用为0时，立即回收当前对象&lt;/p&gt;
&lt;p&gt;2.达到了垃圾回收的阈值，触发标记-清除&lt;/p&gt;
&lt;p&gt;3.手动调用gc.collect()&lt;/p&gt;
&lt;p&gt;4.Python虚拟机退出的时候&lt;/p&gt;







&lt;h2&gt;参考：&lt;/h2&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinganzi/p/6646742.html&quot;&gt;Python垃圾回收机制--完美讲解!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://foofish.net/python-gc.html&quot; target=&quot;_blank&quot;&gt;Python 中的垃圾回收机制&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/xiongchengluo1129/article/details/80462651&quot; target=&quot;_blank&quot;&gt;python垃圾回收&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 14:13:00 +0000</pubDate>
<dc:creator>吃饭睡觉打逗逗</dc:creator>
<og:description>python中有自动内存回收机制，一般情况不需要程序员来处理，面试时被大佬问到了，记录一下。没有画图，推荐读参考的第一篇博文 gc方式1：引用计数 若此对象无其他对象引用，则立马回收掉 优点：简单、实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lurenjia1994/p/10498593.html</dc:identifier>
</item>
<item>
<title>SpringBoot 2 要不要升级 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10498344.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10498344.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在谈SpringBoot 2.x 之前，先来聊点别的：&lt;/p&gt;
&lt;p&gt;首先是Java 语言，这门长期占据编程语言排行榜首位的语言到底有什么魔力？&lt;br/&gt;大家的看法是多种多样的，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;面向对象设计，使用简单，可以很快速的入门；&lt;/li&gt;
&lt;li&gt;开源生态做得好，很多可重用的组件，拿来即用；&lt;/li&gt;
&lt;li&gt;跨平台，高性能，是做后台开发的首选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有一种观点很有意思：这是命好，每当人们觉得 Java 不行了的时候，总会有英雄横刀救美..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308211908029-1186505908.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，主要说的是：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&quot;:最初 Java 开发出来不知道有什么用的时候，发现可以用 Applet 在网页上做动画。&lt;br/&gt;后来企业级软件开发时代 JavaEE 大行其道，开源社区 Spring 桃李满天下。&lt;br/&gt;等到了移动时代，人们觉得 Java 要完蛋了，Google 拍马救市，收购并开放了 Android 平台，当家语言就是 Java。&lt;br/&gt;于是 Java 再次焕发勃勃生机。 目前在大数据领域，Java 同样是当仁不让的好手。&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文&lt;a href=&quot;http://www.10tiao.com/html/193/201802/2650713979/1.html&quot;&gt;出自这里&lt;/a&gt;，感兴趣的朋友可以去读一读。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&quot;命好&quot;&lt;/strong&gt;的确没错，但这里想说的是开放性(开源)是非常关键的。&lt;br/&gt;由于Java的开放性，其开源生态衍生出了非常多的优秀框架，其中最有代表性的就是SpringFramework。&lt;br/&gt;随着框架的受众越来越多，该项目也在持续演进以满足日益增长的能力需求，最终大家便越来越离不开它。&lt;br/&gt;到如今 SpringFramework 已经形成了一个庞大的生态圈，同时 Spring Web也已经成为Java开发的一种&quot;事实标准&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308211924462-1179083631.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果希望了解Spring 框架的一些历史，推荐读一读 &lt;a href=&quot;https://www.cnblogs.com/ityouknow/p/10213304.html&quot;&gt;是时候给大家介绍 Spring Boot/Cloud 背后豪华的研发团队了&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;一springboot-简史&quot;&gt;一、SpringBoot 简史&lt;/h2&gt;
&lt;p&gt;SpringBoot 的诞生不是没有道理的，可能大家都清楚，Spring Framework定义了一个核心的概念叫&lt;strong&gt;IoC&lt;/strong&gt;，即控制反转。 这是什么意思？&lt;br/&gt;控制反转，即对象的关系不再由对象本身决定，由容器来控制其依赖。简单说，就是由容器来帮你初始化对象，并完成自动化的关联。&lt;br/&gt;这样，又有了依赖注入(Dependency Injection)的概念...总之，IoC 和 DI是 理解Spring框架的关键，后面所有出现的东西，都是从这两个概念开始的。&lt;/p&gt;
&lt;p&gt;然后，因为要做自动化的对象初始化、关系装配，需要有个东西来描述这些关系，一般是用xml文件来描述，比如applicationContext.xml 会描述一个ApplicationContext上下文里面所拥有的对象实例，以及这些实例之间的关系。 于是乎，所有的 Spring 应用程序都使用了这样的配置方式。&lt;/p&gt;
&lt;p&gt;在 Web 开发方面，Spring Framework诞生了 Spring MVC，用来简化 Servlet的开发。 通过AOP实现的路由转换能力，可以快速的把URL映射到一个Bean方法去处理；通过内置常用的编解码转换器，可以避免每次都要写格式转换的代码.. 这些能力，也让 Spring MVC 称为了Java Web开发框架的不二之选。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308211951324-767429296.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是发展到了后来，随着 Web开发技术的逐步完善，一个框架集成的模块越来越多，而单一Web应用的功能特性也越来越多了。 此时大家逐渐发现，基于 xml的方式去定义Bean加载，工作量其实很大，而且配置文件逐渐变得臃肿、不好维护，有时候配置出现错误，经常是要排查个半天。 于是乎都用了@Bean、@Autowired注解，还有@ComponentScan 来实现自动化扫描，这些特性大大简化了开发工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308212004905-1460578456.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot 是基于&lt;strong&gt;免配置&lt;/strong&gt;的思路来设计的，也就是说让你不用在配置上花太多时间，所有的东西尽可能都用内置的、现成的。&lt;br/&gt;于是乎，就有了各种各样的 &lt;strong&gt;starter&lt;/strong&gt; 子项目，严格说，这些 starter 只能算是胶水项目(几乎没有代码)，但是它们能让你获得许多开发上的愉悦体验！&lt;br/&gt;下面的这些starter都具备不同的用途：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring-boot-starter&lt;br/&gt;　核心启动器，包含了自动配置、日志和YAML。&lt;/li&gt;
&lt;li&gt;spring-boot-starter-web&lt;br/&gt;　引入全栈式Web开发组件，包括Tomcat和spring-webmvc&lt;/li&gt;
&lt;li&gt;spring-boot-starter-thymeleaf&lt;br/&gt;　引入Thymeleaf模板引擎，包括与Spring的集成。&lt;/li&gt;
&lt;li&gt;spring-boot-starter-test&lt;br/&gt;　引入常规的测试依赖，包括JUnit、Hamcrest、Mockito以及spring-test模块。&lt;/li&gt;
&lt;li&gt;spring-boot-starter-websocket&lt;br/&gt;　引入WebSocket模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-redis&lt;br/&gt;　引入Redis模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-security&lt;br/&gt;　引入 spring-security安全模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-data-jpa&lt;br/&gt;　引入数据存储层JPA(Java Persistence API)&lt;/li&gt;
&lt;li&gt;spring-boot-starter-data-mongodb&lt;br/&gt;　引入MongoDB数据库模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-amqp&lt;br/&gt;　引入spring-rabbitmq客户端来支持AMQP协议&lt;/li&gt;
&lt;li&gt;spring-boot-starter-aop&lt;br/&gt;　引入AOP的编程模块，包括spring-aop和AspectJ&lt;/li&gt;
&lt;li&gt;spring-boot-starter-mail&lt;br/&gt;　引入javax.mail模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-log4j&lt;br/&gt;　引入Log4J日志框架&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时，这些模块化项目是随着SpringBoot版本一起演进的。&lt;br/&gt;2014年4月份，Spring Boot 刚发布了 1.0版本 便 &lt;strong&gt;迅速圈粉&lt;/strong&gt;，接下来1.x 版本经历了4年的演进；&lt;br/&gt;直到2018年3月份，Spring Boot 2.0版本发布，&lt;/p&gt;
&lt;p&gt;下面，是SpringBoot经历过的一些版本：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring boot 1.1（2014 年 6 月）&lt;/strong&gt;&lt;br/&gt;改进的模板支持，gemfire 支持，elasticsearch 和 apache solr 的自动配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 1.2（2015 年 3 月）&lt;/strong&gt;&lt;br/&gt;升级到 servlet 3.1 / tomcat 8 / jetty 9，spring 4.1 升级，&lt;br/&gt;支持 banner / jms / SpringBootApplication 注解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 1.3（2016 年 12 月）&lt;/strong&gt;&lt;br/&gt;升级到 Spring 4.2 ，新的 spring-boot-devtools，&lt;br/&gt;缓存模块实现自动化配置（ehcache，hazelcast，redis 和 infinispan）&lt;br/&gt;支持完全可执行的 jar 支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 1.4（2017年1月）&lt;/strong&gt;&lt;br/&gt;spring 4.3 升级，支持 couchbase/neo4j，分析启动失败和RestTemplateBuilder。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 1.5（2017年2月）&lt;/strong&gt;&lt;br/&gt;支持 kafka / ldap，第三方库升级，弃用 crash 支持和执行器记录器端点以动态修改应用程序日志级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 2.0（2018 年 03 月）&lt;/strong&gt;&lt;br/&gt;基于 Java 8，支持 Java 9，支持 Quartz ，调度程序大大简化了安全自动配置，支持嵌入式 Netty。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 2.1（2018 年 10 月）&lt;/strong&gt;&lt;br/&gt;支持 Java 11，升级Spring 5.1，应用性能提升，度量模块做了改进。&lt;/p&gt;
&lt;p&gt;其中 Spring Boot 2.0跨度较大，酝酿期也达到1年之多，整个 底层的SpringCore 核心都做了较大的升级(基于Spring 5.0)。&lt;br/&gt;随着 SpringBoot 2.1的发布，2.2即将面世，整个2.0 版本也会趋于稳定。&lt;/p&gt;
&lt;p&gt;其中，对于大多数人比较关心的，是Spring Boot 2都有哪些更新，要不要做升级？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308212023023-234978169.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;图-Spring之父 Rod Johnson&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二springboot-2-的变化&quot;&gt;二、SpringBoot 2 的变化&lt;/h2&gt;
&lt;p&gt;下面列举了Spring Boot 2.0这个重要版本的一些更新：&lt;/p&gt;
&lt;h4 id=&quot;配置的变更&quot;&gt;1.配置的变更&lt;/h4&gt;
&lt;p&gt;在 2.x 中废除了一些 1.x 中的配置，并增加了许多新配置，详细请查看以下链接中的变更表格。&lt;br/&gt;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Configuration-Changelog&lt;/p&gt;
&lt;p&gt;此外，关于配置的绑定方式也有些变化：&lt;/p&gt;
&lt;p&gt;在 1.x 中，配置绑定是通过注解 @ConfigurationProperties 来注入到 Spring 环境变量中的。&lt;br/&gt;在 2.x 中，配置绑定功能有了些的改造，在调整了 1.x 中许多不一致地方之外，还提供了独立于注解之外的 API 来装配配置属性。&lt;br/&gt;并增加了属性来源，这样你就能知道这些属性是从哪个配置文件中加载进来的。&lt;/p&gt;
&lt;h4 id=&quot;jdk-版本升级&quot;&gt;2.JDK 版本升级&lt;/h4&gt;
&lt;p&gt;2.x 至少需要 JDK 8 的支持，2.x 里面的许多方法应用了 JDK 8 的许多高级新特性，所以升级到 2.0 版本必须先确认你的应用必须兼容 JDK 8。&lt;br/&gt;另外是 2.x 开始了对 JDK 9 的支持。&lt;/p&gt;
&lt;h4 id=&quot;第三方类库升级&quot;&gt;3.第三方类库升级&lt;/h4&gt;
&lt;p&gt;2.x 对第三方类库升级了所有能升级的稳定版本，一些值得关注的类库：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) Spring Framework 5+&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2) Tomcat 8.5+&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3) Flyway 5+&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;4) Hibernate 5.2+&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;5) Thymeleaf 3+&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;响应式编程支持&quot;&gt;4.响应式编程支持&lt;/h4&gt;
&lt;p&gt;2.x 通过启动器和自动配置全面支持 Spring 的响应式编程，响应式编程是完全异步和非阻塞的，它是基于事件驱动模型，而不是传统的线程模型。&lt;br/&gt;就连 Spring Boot 内部也对一些功能点进行了有必要的响应式升级，最值得注意的是对内嵌式容器的支持。&lt;/p&gt;
&lt;p&gt;对响应式编程支持又包括以下几个技术模块。&lt;/p&gt;
&lt;p&gt;1) Spring WebFlux &amp;amp; WebFlux.fn 支持&lt;br/&gt;2) 响应式 Spring Data 支持&lt;br/&gt;3) 响应式 Spring Security 支持&lt;br/&gt;4) 内嵌式的 Netty 服务器支持&lt;/p&gt;
&lt;h4 id=&quot;data-支持&quot;&gt;5.Data 支持&lt;/h4&gt;
&lt;p&gt;上面有说到对响应式 Spring Data 的支持，除此之外，其他 Data 模块也做了许多更新和提升，具体体现在以下几个地方。&lt;/p&gt;
&lt;p&gt;1) 2.x 默认使用 HikariCP 连接池；&lt;br/&gt;2) 更加合理化的优化了数据库初始化逻辑；&lt;br/&gt;3) spring.jdbc.template 自动配置现在可以通过 spring.jdbc.template 属性定制；&lt;br/&gt;4) 提供了新配置 spring.jdbc.template 方便分页和排序；&lt;br/&gt;5) 对数据库 spring.jdbc.template 自动化配置支持；&lt;br/&gt;6) 可以高级定制 MongoDB 客户端；&lt;br/&gt;7) 可以通过 spring.cache.redis.* 来配置 Redis 缓存默认值。&lt;/p&gt;
&lt;h4 id=&quot;web加强&quot;&gt;6.Web加强&lt;/h4&gt;
&lt;p&gt;除了上面说了 2.x 对响应式框架的支持，还包括以下几个 web 开发改进。&lt;/p&gt;
&lt;p&gt;1) 使用内嵌式容器时，context path 会和端口一起记录并打印出来；&lt;br/&gt;2) 所有支持的容器都支持过滤器的初始化；&lt;br/&gt;3) Thymeleaf 开始支持 javax.time 类型；&lt;br/&gt;4) 提供了一个 spring-boot-starter-json 启动器对 JSON 读写的支持。&lt;/p&gt;
&lt;h4 id=&quot;http2-支持&quot;&gt;7.HTTP/2 支持&lt;/h4&gt;
&lt;p&gt;提供对HTTP/2 的支持，如：Tomcat, Undertow, Jetty，这个得依赖具体选择的应用服务器和应用环境。&lt;/p&gt;
&lt;h4 id=&quot;其他增强&quot;&gt;8.其他增强&lt;/h4&gt;
&lt;p&gt;出了前面的一些变化，还包括以下的一些增强：&lt;br/&gt;&lt;strong&gt;Actuator加强&lt;/strong&gt;&lt;br/&gt;在 2.x 中，对执行器端点进行了许多改进，所有的 HTTP 执行端点现在都暴露在 /actuator路径下，并对 JSON 结果集也做了改善。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gradle 插件&lt;/strong&gt;&lt;br/&gt;Spring Boot的 Gradle 插件全面重写了，并且最小支持 Gradle 4+ 以便提供一些重要的特性提升。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kotlin&lt;/strong&gt;&lt;br/&gt;2.x 开始提供对 Kotlin 1.2 的支持，并且提供了一个 runApplication 函数来运行 Spring Boot 应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quartz支持&lt;/strong&gt;&lt;br/&gt;2.x 提供了一个 spring-boot-starter-quartz 启动器对定时任务框架 Quartz 的支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试支持&lt;/strong&gt;&lt;br/&gt;在 2.x 中，对测试模块有了一些调整，如自动化的配置增强。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes&quot;&gt;在这里&lt;/a&gt;，可以看到更详细的的版本特性。&lt;/p&gt;
&lt;h2 id=&quot;三要不要升级&quot;&gt;三、要不要升级&lt;/h2&gt;
&lt;p&gt;Spring Boot 2.0 发布至今已经将近一年了，目前来看应该是比较稳定的，而市面上也出现不少基于 SpringBoot 2.0的教程书籍，在这个时间点开始使用是没有问题的。&lt;/p&gt;
&lt;p&gt;A. 如果所在的团队较小，或是对于新的项目，建议可以直接上手；&lt;br/&gt;B. 对于规模较大，或是已经上线一段时间的项目，则需要考虑如下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前的Spring Boot版本是否存在重大的缺陷？&lt;/li&gt;
&lt;li&gt;切换过程产生的人力成本是否可以接受？&lt;/li&gt;
&lt;li&gt;团队中对于新版本的掌握程度如何？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于后者，我更多建议持保守态度，Spring Boot 1.x 尽管目前已经停止更新，但其经历了4年多的迭代完善，目前是使用面最广且最为稳定的。&lt;/p&gt;
&lt;p&gt;如果确实想进行升级，也建议先做好的分析及测试，也可以看看&lt;a href=&quot;https://www.oschina.net/translate/spring-boot-2-0-migration-guide&quot;&gt;SpringBoot 2.0迁移指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为初学者来看，使用 Spring Boot 1.x 还是 2.x 的区别并不大，相比较之下，当下在使用 1.x过程中遇到的一些问题会更容易找到答案。&lt;br/&gt;或许，你可以从下面这篇文章开始学习 Spring Boot。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/littleatp/p/9278686.html&quot;&gt;springboot项目基础搭建课&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 13:21:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 前言 在谈SpringBoot 2.x 之前，先来聊点别的： 首先是Java 语言，这门长期占据编程语言排行榜首位的语言到底有什么魔力？ 大家的看法是多种多样的，比如： 面向对象设计，使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10498344.html</dc:identifier>
</item>
<item>
<title>读《构建之法》——感想 - Brad-Pitt</title>
<link>http://www.cnblogs.com/pittma/p/10467372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pittma/p/10467372.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Fri, 08 Mar 2019 12:51:00 +0000</pubDate>
<dc:creator>Brad-Pitt</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fpittma%2Fp%2F10467372.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>#5   Python面向对象（四） - MinuteSheep</title>
<link>http://www.cnblogs.com/minutesheep/p/10494463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minutesheep/p/10494463.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本节将是Python面向对象的最后一篇博文了，这节将记录类的特殊方法、特殊成员方法、旧类和新类的不同，以及一些其他知识。Go！&lt;/p&gt;
&lt;h3&gt;一、类的特殊方法&lt;/h3&gt;
&lt;p&gt;Python有三种特殊方法：实例方法、静态方法、类方法。如果你读过一些源代码，你一定疑惑过这些代码：&lt;strong&gt;@staticmethod、@classmethod&lt;/strong&gt;，前面见到的所有方法都是实例方法，实例方法的第一个参数为实例本身（self），由于实例方法经过前面几节已经掌握，所有本节将会熟悉剩下的两种特殊方法&lt;/p&gt;
&lt;h4&gt;1.1 静态方法&lt;/h4&gt;
&lt;p&gt;之前在类中编写的各种方法其实都是属于实例方法，每一个方法的第一个参数是实例本身（self），实例方法固然好用，但是在开发中，需要一些这样的方法：&lt;span&gt;与类有关，在使用时不需要引用类和实例，也就是不能访问类变量和实例变量。&lt;/span&gt;这些方法通常用来作全局的配置方法，使代码更加简洁和安全。&lt;/p&gt;
&lt;h4&gt;1.1.1 创建静态方法&lt;/h4&gt;
&lt;p&gt;在类中的方法的前面使用装饰器： &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;strong&gt;@staticmethod&lt;/strong&gt;&lt;/span&gt; 即可，静态方法已经和普通函数没有太大区别，唯一的区别就是静态方法要通过对象来访问，看例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, gender):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.name =&lt;span&gt; name
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.gender =&lt;span&gt; gender
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(self.name))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     @staticmethod    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建 is_man 静态方法&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_man(gender):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; gender == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上例可以看到静态方法的创建比较简单，基本上已经和类无关了，按照普通的函数创建即可&lt;/p&gt;
&lt;h4&gt;1.1.2 调用静态方法&lt;/h4&gt;
&lt;p&gt;静态方法与函数的区别就是调用方式不同，函数直接调用即可，但是静态方法多多少少和类还是有一些关系的，那就是调用时需要对象来调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
zhangsan = Teacher(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(zhangsan.is_man(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：静态方法无法调用类变量和实例变量，这里就不作演示了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;『防抄袭：读者请忽略这段文字，文章作者是博客园的&lt;a href=&quot;https://www.cnblogs.com/minutesheep/p/10494463.html&quot;&gt;MinuteSheep&lt;/a&gt;』&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是静态方法通常并不会在类外调用静态方法，而是直接在类内作为全局配置方法使用，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, gender):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.name =&lt;span&gt; name
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.gender =&lt;span&gt; gender
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(self.name))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_man(gender):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; gender == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         flag = self.is_man(self.gender)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 作为全局配置使用&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; flag:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am man, I will eat 2 buns&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am woman, I will eat 1 bun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; zhangsan = Teacher(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; zhangsan.eat()
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
I am man, I will eat 2 buns
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.1.3 继承静态方法&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果超类中有静态方法时，子类继承时会发生什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, gender):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.gender &lt;/span&gt;=&lt;span&gt; gender

    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_man(gender):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; gender == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        flag &lt;/span&gt;= self.is_man(self.gender)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 作为全局配置使用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; flag:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am {}, I will eat 2 buns&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(flag))
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am {}, I will eat 1 bun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.formar(flag))


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Chinese(Teacher):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    创建一个语文老师类，
    继承Teacher
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, gender):
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(name, gender)

    @staticmethod   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 改写超类的静态方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_man(gender):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; gender == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;man&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;woman&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;


zhangsan &lt;/span&gt;= Chinese(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

zhangsan.eat()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继承后将超类静态方法改写，运行结果j将按照子类的静态方法运行，结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
I am man, I will eat 2&lt;span&gt; buns

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 而不是按照超类的静态方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; I am 1,I will eat 2 buns&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.2 类方法&lt;/h4&gt;
&lt;p&gt; 类方法，顾名思义是一种直接作用于类的方法。类方法和实例方法的区别就在于：&lt;span&gt;类方法只能访问类变量，不能访问实例变量。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;1.2.1 创建类方法&lt;/h4&gt;
&lt;p&gt;在类中的方法前面使用装饰器： &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;strong&gt;@classmethod&lt;/strong&gt;&lt;/span&gt; 即可，类方法和实例方法格式相似，类方法第一个参数必须是类本身（cls），看例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher(object):
    food &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, gender):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.gender &lt;/span&gt;=&lt;span&gt; gender

    @classmethod   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建类方法 eat&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(cls.food)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面代码可以看到，类方法的第一个参数为类本身，习惯上用cls表示，当然也可以用其他单词表示（这一点与self类似）&lt;/p&gt;
&lt;h4&gt;1.2.2 调用类方法&lt;/h4&gt;
&lt;p&gt;类方法的调用与实例方法无异，看例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
zhangsan = Teacher(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
zhangsan.eat()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
bun
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：类方法只能调用类变量，不能调用实例变量，这里就不作演示了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;『防抄袭：读者请忽略这段文字，文章作者是博客园的&lt;a href=&quot;https://www.cnblogs.com/minutesheep/p/10494463.html&quot;&gt;MinuteSheep&lt;/a&gt;』&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;类方法经常出现在源代码中，通常用来为类传入新的参数。&lt;/p&gt;
&lt;h3&gt;二、类的特殊成员方法&lt;/h3&gt;
&lt;p&gt;什么事特殊成员方法呢？其实你已经见过了，那就是类似__init__这样 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;__方法__&lt;/span&gt;&lt;/span&gt; 形式的方法&lt;/p&gt;
&lt;h4&gt;2.1 常用的特殊成员方法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;__init__&lt;/strong&gt;   「构造函数，当实例化类对象时，会自动调用该方法」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;实例化类对象后就会运行我&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

Test()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
实例化类对象后就会运行我
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;__del__&lt;/strong&gt;   「析构函数，当类对象在内存中被释放时（也就是类对象运行完后），会自动调用该方法」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__del__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;类对象释放后就会运行我&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

Test()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
类对象释放后就会运行我
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;__call__&lt;/strong&gt;   「call方法，在类或者对象后加括号执行该方法」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是博客园MinuteSheep，神马文库抄袭我的博文,不要脸&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


Test()()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 或者&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; obj = Test()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; obj()&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
我是博客园MinuteSheep，神马文库抄袭我的博文,不要脸
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;__dict__&lt;/strong&gt;   「dict方法，查看类或者对象的所有成员信息」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
class Test:&lt;br/&gt;x = 1000&lt;span&gt;
    y &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;print&lt;/span&gt;(Test.&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__module__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__weakref__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__weakref__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; objects&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1000, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; objects&amp;gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;__doc__&lt;/strong&gt;   「doc方法，查看类的描述信息」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    这里是类的描述信息
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    x &lt;/span&gt;= 1000&lt;span&gt;
    y &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;print&lt;/span&gt;(Test.&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;
    这里是类的描述信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、旧类与新类&lt;/h3&gt;
&lt;p&gt;Python3中，只有新类，旧类以及被移除， &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;class&lt;/span&gt; 类名:&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;class&lt;/span&gt; 类名(object):&lt;/span&gt; 都是新类；Python2中， &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;class&lt;/span&gt; 类名:&lt;/span&gt; 是旧类， &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;class&lt;/span&gt; 类名(object):&lt;/span&gt; 是新类&lt;/p&gt;
&lt;p&gt;对旧类和新类了解一下即可&lt;/p&gt;
&lt;h4&gt;3.1 旧类与新类的区别&lt;/h4&gt;
&lt;p&gt;旧类：深度优先&lt;/p&gt;
&lt;p&gt;新类：广度优先&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在Python2中&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(B):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; D(A, B, C):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; D()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Python2中，上述代码的调用顺序为：&lt;strong&gt;D-&amp;gt;A-&amp;gt;B-&amp;gt;A-&amp;gt;C-&amp;gt;B-&amp;gt;A&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;明显是深度优先&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在Python2中&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A(object):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(B):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; D(A, B, C):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; D()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Python2中，上诉代码的调用顺序为：&lt;strong&gt;D-&amp;gt;A-&amp;gt;B-&amp;gt;C-&amp;gt;A-&amp;gt;B-&amp;gt;A-&amp;gt;object&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;明显是广度优先&lt;/p&gt;
&lt;h3&gt;四、其他知识&lt;/h3&gt;
&lt;h4&gt;4.1 私有成员和私有方法&lt;/h4&gt;
&lt;p&gt;接触类这么久了，你一定发现了又的方法和成员没有下划线，有的方法和成员只有一条下划线，有的方法和成员首尾各有两条下划线，这到底是什么含义呢？&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;无下划线 &lt;strong&gt;foo&lt;/strong&gt;：表示普通方法和成员&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一条下划线 &lt;strong&gt;_foo&lt;/strong&gt;：表示被保护方法和成员，不能被 from xxx import _foo 导入&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;两条下划线 &lt;strong&gt;__foo&lt;/strong&gt;：表示私有方法和成员，只运行类本身进行访问&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首尾各两条下划线 &lt;strong&gt;__foo__&lt;/strong&gt;：表示特殊方法，一般由系统自定义&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;Python面向对象的知识到此结束，多加理解和联系才能真正掌握面向对象的知识，拜拜～&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 12:41:00 +0000</pubDate>
<dc:creator>MinuteSheep</dc:creator>
<og:description>本篇博文主要记录Python面向对象中类的特殊方法和特殊成员方法，以及旧类和新类的对比，最后介绍了类中私有成员和方法的概念，Python面向对象结束</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minutesheep/p/10494463.html</dc:identifier>
</item>
<item>
<title>【Spring源码解读】bean标签中的属性（一）你可能还不够了解的 scope 属性 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/10498056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/10498056.html</guid>
<description>&lt;h2 id=&quot;scope-属性说明&quot;&gt;scope 属性说明&lt;/h2&gt;
&lt;p&gt;在spring中，在xml中定义&lt;code&gt;bean&lt;/code&gt;时，&lt;code&gt;scope&lt;/code&gt;属性是用来声明&lt;code&gt;bean&lt;/code&gt;的作用域的。对于这个属性，你也许已经很熟悉了，&lt;code&gt;singleton&lt;/code&gt;和&lt;code&gt;prototype&lt;/code&gt;信手捏来，甚至还能说出&lt;code&gt;request&lt;/code&gt;、&lt;code&gt;session&lt;/code&gt;、&lt;code&gt;global session&lt;/code&gt;，scope不就只有这么几个值吗。&lt;/p&gt;
&lt;p&gt;emmm，话不要说太满，容易打脸。常见的各类博客中，一般只会介绍上面说到的几种可能值，但翻一翻官方的说明，你就会发现，事情并没有这么简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/07/5c8073af8fd16.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是官方文档中的介绍，scope属性一共有六种可能值，惊不惊喜，意不意外。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/07/5c80742434d0e.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面，就让我们来一一看看各个值代表的意义。&lt;/p&gt;
&lt;h3 id=&quot;singleton&quot;&gt;singleton&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;singleton&lt;/code&gt;是scope属性的默认值，当我们把bean的scope属性设置为&lt;code&gt;singleton&lt;/code&gt;时，代表将对该bean使用单例模式，单例想必大家都熟悉，也就是说每次使用该bean的id从容器中获取该bean的时候，都将会返回同一个bean实例。但这里的单例跟设计模式里的单例还有一些小区别。&lt;/p&gt;
&lt;p&gt;设计模式中的单例是通过硬编码，给某个类仅创建一个静态对象，并且只暴露一个接口来获取这个对象实例，因此，设计模式中的单例是相对&lt;code&gt;ClassLoader&lt;/code&gt;而言的，同一个类加载器下只会有一个实例。&lt;/p&gt;
&lt;p&gt;下面就是经典的使用&lt;code&gt;double-check&lt;/code&gt;实现的懒加载代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Singleton{
    private static volatile Singleton FRANK;

    public static Singleton getInstance(){
        if (FRANK == null){
            synchronized(this){
                if (FRANK == null) FRANK = new Singleton();
            }
        }
        return FRANK;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是在Spring中，&lt;code&gt;singleton单例&lt;/code&gt;指的是每次从同一个IOC容器中返回同一个bean对象，单例的有效范围是IOC容器，而不是&lt;code&gt;ClassLoader&lt;/code&gt;。IOC容器会将这个bean实例缓存起来，以供后续使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/07/5c8079052f7de.png&quot; alt=&quot;20190307095059.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面做一个小实验验证一下：&lt;/p&gt;
&lt;p&gt;先写一个测试类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestScope {
    @Test
    public void testSingleton(){
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;test-bean.xml&quot;);
        TestBean bean = (TestBean) context.getBean(&quot;testBean&quot;);
        Assert.assertEquals(bean.getNum() , 0);
        bean.add();
        Assert.assertEquals(bean.getNum() , 1);

        TestBean bean1 = (TestBean) context.getBean(&quot;testBean&quot;);
        Assert.assertEquals(bean1.getNum() , 1);
        bean1.add();
        Assert.assertEquals(bean1.getNum() , 2);

        ApplicationContext context1 = new ClassPathXmlApplicationContext(&quot;test-bean.xml&quot;);
        TestBean bean2 = (TestBean) context1.getBean(&quot;testBean&quot;);
        Assert.assertEquals(bean2.getNum() , 0);
        bean2.add();
        Assert.assertEquals(bean2.getNum() , 1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestBean {
    private int num;

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public void add(){
        num++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是相应的配置文件&lt;code&gt;test-bean.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN 2.0//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans-2.0.dtd&quot;&amp;gt;

&amp;lt;beans&amp;gt;
    &amp;lt;bean id=&quot;testBean&quot; class=&quot;com.frank.spring.bean.scope.TestBean&quot; scope=&quot;singleton&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;testBean&lt;/code&gt;的&lt;code&gt;scope&lt;/code&gt;为&lt;code&gt;singleton&lt;/code&gt;，而变量&lt;code&gt;bean&lt;/code&gt;和&lt;code&gt;bean1&lt;/code&gt;所指向的实例都是从同一个IOC容器中获取的，所以获取的是同一个bean实例，因此分别对&lt;code&gt;bean&lt;/code&gt;和&lt;code&gt;bean1&lt;/code&gt;调用add方法后，num的值就会变成2。而&lt;code&gt;bean2&lt;/code&gt;是从另一个IOC容器中获取的，所以它是一个新的实例，&lt;code&gt;num&lt;/code&gt;的值便成了初始值0，调用&lt;code&gt;add&lt;/code&gt;方法后，num的值变成了1。这样也验证了上面所说的&lt;code&gt;singleton&lt;/code&gt;单例含义，指的是每一个IOC容器中仅存在一个实例。&lt;/p&gt;
&lt;h3 id=&quot;prototype&quot;&gt;prototype&lt;/h3&gt;
&lt;p&gt;接下来是另一个常用的scope：&lt;code&gt;prototype&lt;/code&gt;。与&lt;code&gt;singleton&lt;/code&gt;相反，设置为&lt;code&gt;prototype&lt;/code&gt;的bean，每次调用容器的&lt;code&gt;getBean&lt;/code&gt;方法或注入到另一个bean中时，都会返回一个新的实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/07/5c80fd2fc8df9.png&quot; alt=&quot;20190307191454.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与其他的&lt;code&gt;scope&lt;/code&gt;类型不同的是，Spring并不会管理设置为&lt;code&gt;prototype&lt;/code&gt;的bean的整个生命周期，获取相关bean时，容器会实例化，或者装配相关的&lt;code&gt;prototype-bean&lt;/code&gt;实例，然后返回给客户端，但不会保存&lt;code&gt;prototype-bean&lt;/code&gt;的实例。所以，尽管所有的bean对象都会调用配置的初始化方法，但是&lt;code&gt;prototype-bean&lt;/code&gt;并不会调用其配置的destroy方法。所以清理工作必须由客户端进行。所以，Spring容器对&lt;code&gt;prototype-bean&lt;/code&gt; 的管理在一定程度上类似于 &lt;code&gt;new&lt;/code&gt; 操作，对象创建后的事情将全部由客户端处理。&lt;/p&gt;
&lt;p&gt;仍旧用一个小栗子来进行测试：&lt;/p&gt;
&lt;p&gt;我们将上面的xml文件进行修改：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN 2.0//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans-2.0.dtd&quot;&amp;gt;

&amp;lt;beans&amp;gt;
    &amp;lt;bean id=&quot;testBean&quot; class=&quot;com.frank.spring.bean.scope.TestBean&quot; scope=&quot;prototype&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testPrototype(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;test-bean.xml&quot;);
    TestBean bean = (TestBean) context.getBean(&quot;testBean&quot;);
    Assert.assertEquals(bean.getNum() , 0);
    bean.add();
    Assert.assertEquals(bean.getNum() , 1);

    TestBean bean1 = (TestBean) context.getBean(&quot;testBean&quot;);
    Assert.assertEquals(bean1.getNum() , 0);
    bean1.add();
    Assert.assertEquals(bean1.getNum() , 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里两次从同一个IOC容器中获取&lt;code&gt;testBean&lt;/code&gt;，得到了两个不同的bean实例，这就是&lt;code&gt;prototype&lt;/code&gt;的作用。&lt;/p&gt;
&lt;p&gt;接着，我们配置一个初始化方法和销毁方法，来测试一下：&lt;/p&gt;
&lt;p&gt;给TestBean类加两个方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestBean {
    private int num;

    public void init(){
        System.out.println(&quot;init TestBean&quot;);
    }

    public void destroy(){
        System.out.println(&quot;destroy TestBean&quot;);
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public void add(){
        num++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在配置文件里设置它的初始化方法和销毁方法：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;beans&amp;gt;
    &amp;lt;bean id=&quot;testBean&quot; class=&quot;com.frank.spring.bean.scope.TestBean&quot; scope=&quot;prototype&quot;  init-method=&quot;init&quot;  destroy-method=&quot;destroy&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是用之前的测试方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testPrototype(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;test-bean.xml&quot;);
    TestBean bean = (TestBean) context.getBean(&quot;testBean&quot;);
    Assert.assertEquals(bean.getNum() , 0);
    bean.add();
    Assert.assertEquals(bean.getNum() , 1);

    TestBean bean1 = (TestBean) context.getBean(&quot;testBean&quot;);
    Assert.assertEquals(bean1.getNum() , 0);
    bean1.add();
    Assert.assertEquals(bean1.getNum() , 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;init TestBean
init TestBean&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，仅仅输出了初始化方法&lt;code&gt;init&lt;/code&gt;中的内容，而没有输出销毁方法&lt;code&gt;destroy&lt;/code&gt;中的内容，所以，对于&lt;code&gt;prototype-bean&lt;/code&gt;而言，在xml中配置&lt;code&gt;destroy-method&lt;/code&gt;属性是没有意义的，容器在创建这个bean实例后就抛弃它了，如果它持有的资源需要释放，则需要客户端进行手动释放才行。这大概就是亲生和领养的区别吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/07/5c81044d154bf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，如果将一个&lt;code&gt;prototype-bean&lt;/code&gt;注入到一个&lt;code&gt;singleton-bean&lt;/code&gt;中，那么每次从容器中获取的&lt;code&gt;singleton-bean&lt;/code&gt;对应&lt;code&gt;prototype-bean&lt;/code&gt;都是同一个，因为依赖注入仅会进行一次。&lt;/p&gt;
&lt;h2 id=&quot;request-session-application-websocket-scopes&quot;&gt;Request &amp;amp;&amp;amp; Session &amp;amp;&amp;amp; Application &amp;amp;&amp;amp; WebSocket Scopes&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/07/5c8106f6ae617.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;request&lt;/code&gt; 和 &lt;code&gt;session&lt;/code&gt; 这两个你也许有所耳闻，但是 &lt;code&gt;application&lt;/code&gt; 和 &lt;code&gt;websocket&lt;/code&gt; 是什么鬼？竟然还有这样的神仙scope？？莫方，让我们来一探究竟。&lt;/p&gt;
&lt;p&gt;这几个类型的scope都只能在web环境下使用，如果使用 &lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt; 来加载使用了该属性的bean，那么就会抛出异常。就像这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;java.lang.IllegalStateException: No Scope registered for scope name 'request'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面让我们依次来看看这几个值的作用。&lt;/p&gt;
&lt;h3 id=&quot;request&quot;&gt;request&lt;/h3&gt;
&lt;p&gt;如果将scope属性设置为 &lt;code&gt;request&lt;/code&gt; 代表该bean的作用域为单个请求，请求结束，则bean将被销毁，第二次请求将会创建一个新的bean实例，让我们来验证一下。方便起见，创建一个springboot应用，然后创建一个配置类并指定其扫描的xml：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@ImportResource(locations = {&quot;classpath:application-bean.xml&quot;})
public class WebConfiguration {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是xml中的内容：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;testBean&quot; class=&quot;com.frank.springboothello.model.TestBean&quot; scope=&quot;request&quot; &amp;gt;
        &amp;lt;aop:scoped-proxy/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是controller的内容：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class HelloController {

    @Autowired
    private TestBean testBean;

    @Autowired
    private TestBean testBean1;

    @GetMapping(&quot;/testBean&quot;)
    public void testBean(){
        System.out.println(&quot;==========request start==========&quot;);
        System.out.println(testBean.getNum());
        testBean.add();
        System.out.println(testBean.getNum());
        System.out.println(testBean1.getNum());
        testBean1.add();
        System.out.println(testBean1.getNum());
        System.out.println(&quot;==========request end==========&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里还是使用之前的TestBean，也许细心的你会发现，这里有一个乱入的家伙：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;aop:scoped-proxy/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/08/5c81c5cc0999a.png&quot; alt=&quot;20190308093050.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是个什么东西？？？&lt;/p&gt;
&lt;p&gt;这里其实是声明对该bean使用代理模式，这样做的话，容器在注入该bean的时候，将会使用&lt;code&gt;CGLib动态代理&lt;/code&gt;为它创建一个代理对象，该对象拥有与原Bean相同的public接口并暴露，代理对象每次调用时，会从相应作用域范围内（这里是&lt;code&gt;request&lt;/code&gt;）获取真正的&lt;code&gt;TestBean&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;那么，为什么要这样做呢？&lt;/p&gt;
&lt;p&gt;因为被注入的bean（&lt;code&gt;testBean&lt;/code&gt;）和目标bean（&lt;code&gt;HelloController&lt;/code&gt;）的生命周期不一样，而同一个容器内的bean注入只会发生一次，你想想，&lt;code&gt;HelloController&lt;/code&gt;是&lt;code&gt;singleton&lt;/code&gt;的，只会实例化一次，如果不使用代理对象，就意味着我们只能将同一个&lt;code&gt;request-bean&lt;/code&gt;注入到这个&lt;code&gt;singleton-bean&lt;/code&gt;中，那之后的每次访问，都将调用同一个&lt;code&gt;testBean&lt;/code&gt;实例，这不是我们想要的结果。我们希望&lt;code&gt;HelloController&lt;/code&gt;是容器范围内单例的，同时想要一个作用域为 &lt;code&gt;Http Request&lt;/code&gt; 的&lt;code&gt;testBean&lt;/code&gt;实例，这时候，代理对象就扮演着不可或缺的角色了。&lt;/p&gt;
&lt;p&gt;另外，值得一提的是，如果我们对一个&lt;code&gt;scope&lt;/code&gt;为&lt;code&gt;prototype&lt;/code&gt;的bean使用&lt;code&gt;&amp;lt;aop:scoped-proxy/&amp;gt;&lt;/code&gt;的话，那么每次调用该bean的方法都会创建一个新的实例，关于这一点，大家可以自行验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/08/5c8254687adf6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代理方式默认是&lt;code&gt;CGLib&lt;/code&gt;，并且只有&lt;code&gt;public&lt;/code&gt;方法会被代理，&lt;code&gt;private&lt;/code&gt;方法是不会被代理的。如果我们想要使用基于&lt;code&gt;JDK&lt;/code&gt;的代理来创建代理对象，那么只需要将aop标签中的&lt;code&gt;proxy-target-class&lt;/code&gt;属性设置为false即可，就像这样：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;aop:scoped-proxy proxy-target-class=&quot;false&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但有个条件，那就是这个bean必须要实现某个接口。&lt;/p&gt;
&lt;p&gt;我们再来跑一下代码验证一下，启动！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/08/5c81c5066975f.png&quot; alt=&quot;20190308092733.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来访问几次&lt;code&gt;http://127.0.0.1:8080/testBean&lt;/code&gt;，输出如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;==========request start==========
0
1
1
2
==========request end==========
==========request start==========
0
1
1
2
==========request end==========&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嗯，一切都在掌控范围之内。&lt;/p&gt;
&lt;h3 id=&quot;session&quot;&gt;session&lt;/h3&gt;
&lt;p&gt;跟&lt;code&gt;request&lt;/code&gt;类似，但它的生命周期更长一些，是在同一次会话范围内有效，也就是说如果不关闭浏览器，不管刷新多少次，都会访问同一个bean。&lt;/p&gt;
&lt;p&gt;我们将上面的xml稍作改动：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;testBean&quot; class=&quot;com.frank.springboothello.model.TestBean&quot; scope=&quot;session&quot; &amp;gt;
    &amp;lt;aop:scoped-proxy/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再也运行一下，然后在页面刷新几次：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;==========request start==========
0
1
1
2
==========request end==========
==========request start==========
2
3
3
4
==========request end==========
==========request start==========
4
5
5
6
==========request end==========&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，num的值一直的增加，可见我们访问的是同一个bean实例。&lt;/p&gt;
&lt;p&gt;然后，我们使用另一个浏览器继续访问该页面：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;==========request start==========
0
1
1
2
==========request end==========
==========request start==========
2
3
3
4
==========request end==========&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现num又从0开始计数了。这样就验证了我们对&lt;code&gt;session&lt;/code&gt;作用域的想法。&lt;/p&gt;
&lt;h3 id=&quot;application&quot;&gt;application&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;application&lt;/code&gt;的作用域比&lt;code&gt;session&lt;/code&gt;又要更广一些，&lt;code&gt;session&lt;/code&gt;作用域是针对一个 &lt;code&gt;Http Session&lt;/code&gt;，而a&lt;code&gt;pplication&lt;/code&gt;作用域，则是针对一个 &lt;code&gt;ServletContext&lt;/code&gt; ，有点类似 &lt;code&gt;singleton&lt;/code&gt;，但是&lt;code&gt;singleton&lt;/code&gt;代表的是每个IOC容器中仅有一个实例，而同一个web应用中，是可能会有多个IOC容器的，但一个Web应用只会有一个 &lt;code&gt;ServletContext&lt;/code&gt;，所以 &lt;code&gt;application&lt;/code&gt; 才是web应用中货真价实的单例模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/08/5c8215620925e.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来测试一下，继续修改上面的xml文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;testBean&quot; class=&quot;com.frank.springboothello.model.TestBean&quot; scope=&quot;application&quot; &amp;gt;
    &amp;lt;aop:scoped-proxy/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再次启动后，疯狂访问。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;==========request start==========
0
1
1
2
==========request end==========
==========request start==========
2
3
3
4
==========request end==========
==========request start==========
4
5
5
6
==========request end==========&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;换个浏览器继续访问：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;==========request start==========
6
7
7
8
==========request end==========
==========request start==========
8
9
9
10
==========request end==========&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嗯，验证完毕。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/08/5c82552a6af48.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;websocket&quot;&gt;websocket&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;websocket&lt;/code&gt; 的作用范围是 &lt;code&gt;WebSocket&lt;/code&gt; ，即在整个 &lt;code&gt;WebSocket&lt;/code&gt; 中有效。&lt;/p&gt;
&lt;p&gt;emmmm，说实话，这个验证起来有点麻烦，摸索了半天没有找到正确姿势，所以。。。。如果有知道如何验证这一点的小伙伴欢迎留言补充。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/08/5c824b40b64cd.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;global-session&quot;&gt;global session&lt;/h3&gt;
&lt;p&gt;也许你会发现，很多博客中说的 &lt;code&gt;global session&lt;/code&gt; 怎么不见了？？&lt;/p&gt;
&lt;p&gt;这你就不知道了吧，因为在最新版本（5.2.0.BUILD-SNAPSHOT）中&lt;code&gt;global session&lt;/code&gt;早就被移除了。&lt;/p&gt;
&lt;p&gt;所以以后再有人问你，scope属性有哪几种可能值，分别代表什么含义的时候，就可以理直气壮的把这篇文章甩他脸上了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/08/5c824e7fcae16.png&quot; alt=&quot;20190308191406.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;关于 scope 的介绍到此就告一段落了，来做一个小结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;singleton：单例模式，每次获取都返回同一个实例，相对于同一个IOC容器而言。&lt;/li&gt;
&lt;li&gt;prototype：原型模式，每次获取返回不同实例，创建后的生命周期不再由IOC容器管理。&lt;/li&gt;
&lt;li&gt;request：作用域为同一个 &lt;code&gt;Http Request&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;session：作用域为同一个 &lt;code&gt;Http Session&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;application：作用域为同一个WEB容器，可以看做Web应用中的单例模式。&lt;/li&gt;
&lt;li&gt;websocket：作用域为同一个&lt;code&gt;WebSocket&lt;/code&gt;应用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;希望这篇文章能对你有帮助，如果觉得还不错的话，记得分享给身边的小伙伴哦。&lt;/p&gt;
&lt;p&gt;让我们红尘作伴，活得潇潇洒洒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/08/5c8255c88946b.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 12:30:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>scope 属性说明 在spring中，在xml中定义 时， 属性是用来声明 的作用域的。对于这个属性，你也许已经很熟悉了， 和`prototype request session global se</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/10498056.html</dc:identifier>
</item>
</channel>
</rss>