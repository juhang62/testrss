<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring源码分析之AOP从解析到调用 - 雕爷的架构之路</title>
<link>http://www.cnblogs.com/tomakemyself/p/14131421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tomakemyself/p/14131421.html</guid>
<description>&lt;p&gt;正文：&lt;/p&gt;
&lt;p&gt;在上一篇，我们对IOC核心部分流程已经分析完毕，相信小伙伴们有所收获，从这一篇开始，我们将会踏上新的旅程，即Spring的另一核心：AOP!&lt;/p&gt;
&lt;p&gt;首先，为了让大家能更有效的理解AOP，先带大家过一下AOP中的术语：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;切面（Aspect)&lt;/strong&gt;：指关注点模块化，这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。在Spring AOP中，切面可以使用在普通类中以＠Aspect注解来实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接点（Join point)&lt;/strong&gt;：在Spring AOP中，一个连接点总是代表一个方法的执行，其实就代表增强的方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通知（Advice)&lt;/strong&gt;：在切面的某个特定的连接点上执行的动作。通知有多种类型，包括&lt;code&gt;around&lt;/code&gt;， &lt;code&gt;before&lt;/code&gt;和&lt;code&gt;after&lt;/code&gt;等等。许多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标对象（Target&lt;/strong&gt;)：目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切点（Pointcut)&lt;/strong&gt;：匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如，当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP的核心：Spring默认使用AspectJ切点语义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顾问（Advisor)&lt;/strong&gt;： 顾问是Advice的一种包装体现，Advisor是Pointcut以及Advice的一个结合，用来管理Advice和Pointcut。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;织入（Weaving)&lt;/strong&gt;：将通知切入连接点的过程叫织入&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引入（Introductions)&lt;/strong&gt;：可以将其他接口和实现动态引入到targetClass中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一个栗子&quot;&gt;一个栗子&lt;/h2&gt;
&lt;p&gt;术语看完了，我们先上个Demo回顾一下吧～&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;首先，使用&lt;code&gt;EnableAspectJAutoProxy&lt;/code&gt;注解开启我们的AOP&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ComponentScan(basePackages = {&quot;com.my.spring.test.aop&quot;})
@Configuration
@EnableAspectJAutoProxy
public class Main {

        public static void main(String[] args) {
                AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Main.class);
                IService service = context.getBean(&quot;service&quot;, IService.class);
                service.doService();
        }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;写一个接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface IService {

        void doService();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;写一个实现类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service(&quot;service&quot;)
public class ServiceImpl implements IService{

        @Override
        public void doService() {
                System.out.println(&quot;do service ...&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;写一个切面&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Aspect
@Component
public class ServiceAspect {

        @Pointcut(value = &quot;execution(* com.my.spring.test.aop.*.*(..))&quot;)
        public void pointCut() {
        }

        @Before(value = &quot;pointCut()&quot;)
        public void methodBefore(JoinPoint joinPoint) {
                String methodName = joinPoint.getSignature().getName();
                System.out.println(&quot;执行目标方法 【&quot; + methodName + &quot;】 的【前置通知】，入参：&quot; + Arrays.toString(joinPoint.getArgs()));
        }

        @After(value = &quot;pointCut()&quot;)
        public void methodAfter(JoinPoint joinPoint) {
                String methodName = joinPoint.getSignature().getName();
                System.out.println(&quot;执行目标方法 【&quot; + methodName + &quot;】 的【后置通知】，入参：&quot; + Arrays.toString(joinPoint.getArgs()));
        }

        @AfterReturning(value = &quot;pointCut()&quot;)
        public void methodReturn(JoinPoint joinPoint) {
                String methodName = joinPoint.getSignature().getName();
                System.out.println(&quot;执行目标方法 【&quot; + methodName + &quot;】 的【返回通知】，入参：&quot; + Arrays.toString(joinPoint.getArgs()));
        }

        @AfterThrowing(value = &quot;pointCut()&quot;)
        public void methodThrow(JoinPoint joinPoint) {
                String methodName = joinPoint.getSignature().getName();
                System.out.println(&quot;执行目标方法 【&quot; + methodName + &quot;】 的【异常通知】，入参：&quot; + Arrays.toString(joinPoint.getArgs()));
        }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;测试运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;执行目标方法 【doService】 的【前置通知】，入参：[]
do service ...
执行目标方法 【doService】 的【返回通知】，入参：[]
执行目标方法 【doService】 的【后置通知】，入参：[]
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;以上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo看完了，运行效果也出来了，AOP已生效，但如何生效的呢？相比于我们普通使用Bean的Demo，在这里，我们只不过加上了一个&lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;注解以及一个标识了&lt;code&gt;@Aspectj&lt;/code&gt;的类，那么我们先看看&lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;这个注解做了什么吧～&lt;/p&gt;
&lt;h2 id=&quot;开启aop&quot;&gt;开启AOP&lt;/h2&gt;
&lt;p&gt;以下是笔者所画的大致流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202012/1187061-20201214083728608-1653671399.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 其中&lt;code&gt;AspectJAutoProxyRegistrar&lt;/code&gt;实现了&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;，所以在处理&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;逻辑时将会调用&lt;code&gt;registerBeanDefinitions&lt;/code&gt;方法，此时就会把&lt;code&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/code&gt;注册到容器中，其中&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;的逻辑就不再说了，往期文章有过详细分析。而&lt;code&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/code&gt;的类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202012/1187061-20201214083729672-1502649614.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现&lt;code&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/code&gt;是实现了&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口的类，所以它其实是一个后置处理器，那么，还记得在创建Bean过程中的&lt;code&gt;BeanPostProcessor&lt;/code&gt;九次调用时机吗？不记得也没关系，&lt;code&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/code&gt;起作用的地方是在bean的实例化前以及初始化后，分别对应着解析切面和创建动态代理的过程，现在，就让我们先来看看解析切面的过程吧～&lt;/p&gt;
&lt;h2 id=&quot;解析切面&quot;&gt;解析切面&lt;/h2&gt;
&lt;p&gt;解析切面的流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202012/1187061-20201214083734567-465483733.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们已经了解到切面解析的过程是由&lt;code&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/code&gt;完成的，而&lt;code&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/code&gt;又继承了&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;，所以首先，我们先会来到&lt;code&gt;AbstractAutoProxyCreator#postProcessBeforeInstantiation&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) {
        // class类型是否为(Advice, Pointcut, Advisor, AopInfrastructureBean)
  // shouldSkip中将会解析切面
  if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
    this.advisedBeans.put(cacheKey, Boolean.FALSE);
    return null;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用到子类的&lt;code&gt;AspectJAwareAdvisorAutoProxyCreator#shouldSkip&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
protected boolean shouldSkip(Class&amp;lt;?&amp;gt; beanClass, String beanName) {
  // 寻找advisor
  List&amp;lt;Advisor&amp;gt; candidateAdvisors = findCandidateAdvisors();
  for (Advisor advisor : candidateAdvisors) {
    if (advisor instanceof AspectJPointcutAdvisor &amp;amp;&amp;amp;
        ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {
      return true;
    }
  }
  return super.shouldSkip(beanClass, beanName);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;findCandidateAdvisors&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected List&amp;lt;Advisor&amp;gt; findCandidateAdvisors() {
  // 寻找实现了Advisor接口的类, 由于我们一般不会以接口的方式实现切面，这里返回null
  List&amp;lt;Advisor&amp;gt; advisors = super.findCandidateAdvisors();
  if (this.aspectJAdvisorsBuilder != null) {
    // 这里将解析出所有的切面
    advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
  }
  return advisors;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;buildAspectJAdvisors&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public List&amp;lt;Advisor&amp;gt; buildAspectJAdvisors() {
  // aspectBeanNames有值则说明切面已解析完毕
  List&amp;lt;String&amp;gt; aspectNames = this.aspectBeanNames;
  // Double Check
  if (aspectNames == null) {
    synchronized (this) {
      aspectNames = this.aspectBeanNames;
      if (aspectNames == null) {
        List&amp;lt;Advisor&amp;gt; advisors = new ArrayList&amp;lt;&amp;gt;();
        aspectNames = new ArrayList&amp;lt;&amp;gt;();
        // 取出是Object子类的bean，其实就是所有的bean
        String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
          this.beanFactory, Object.class, true, false);
        for (String beanName : beanNames) {
          // 获得该bean的class
          Class&amp;lt;?&amp;gt; beanType = this.beanFactory.getType(beanName);
          // 判断是否有标识@AspectJ注解
          if (this.advisorFactory.isAspect(beanType)) {
            // 将beanName放入集合中
            aspectNames.add(beanName);
            // 将beanType和beanName封装到AspectMetadata中
            AspectMetadata amd = new AspectMetadata(beanType, beanName);
            // Kind默认为SINGLETON
            if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
              MetadataAwareAspectInstanceFactory factory =
                new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
              // 这里会通过@Before @After等标识的方法获取到所有的advisor
              List&amp;lt;Advisor&amp;gt; classAdvisors = this.advisorFactory.getAdvisors(factory);
              if (this.beanFactory.isSingleton(beanName)) {
                // 将获取到的所有advisor放入缓存
                this.advisorsCache.put(beanName, classAdvisors);
              }
              advisors.addAll(classAdvisors);
            }
          }
        }
        // 将所有解析过的beanName赋值
        this.aspectBeanNames = aspectNames;
        return advisors;
      }
    }
  }
  // aspectNames不为空，意味有advisor，取出之前解析好的所有advisor
  List&amp;lt;Advisor&amp;gt; advisors = new ArrayList&amp;lt;&amp;gt;();
  // 获取到所有解析好的advisor
  for (String aspectName : aspectNames) {
    List&amp;lt;Advisor&amp;gt; cachedAdvisors = this.advisorsCache.get(aspectName);
    if (cachedAdvisors != null) {
      advisors.addAll(cachedAdvisors);
    }
                return advisors;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;advisorFactory.getAdvisors&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public List&amp;lt;Advisor&amp;gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
        // 获取到标识了@AspectJ的class，其实就是刚刚封装的class
  Class&amp;lt;?&amp;gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
  // 获取className
  String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();
  
  List&amp;lt;Advisor&amp;gt; advisors = new ArrayList&amp;lt;&amp;gt;();
  
  // 拿出该类除了标识@PointCut的所有方法进行遍历 getAdvisorMethods时会对method进行一次排序
  // 排序顺序 Around, Before, After, AfterReturning, AfterThrowing
  for (Method method : getAdvisorMethods(aspectClass)) {
    // 获取到advisor
    Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, 0, aspectName);
    if (advisor != null) {
      // 加入到集合中
      advisors.add(advisor);
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看下&lt;code&gt;getAdvisorMethods&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private List&amp;lt;Method&amp;gt; getAdvisorMethods(Class&amp;lt;?&amp;gt; aspectClass) {
  final List&amp;lt;Method&amp;gt; methods = new ArrayList&amp;lt;&amp;gt;();
  // 循环遍历该类和父类的所有方法
  ReflectionUtils.doWithMethods(aspectClass, method -&amp;gt; {
    // 排除@PointCut标识的方法
    if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {
      methods.add(method);
    }
  }, ReflectionUtils.USER_DECLARED_METHODS);
  if (methods.size() &amp;gt; 1) {
    // 以Around, Before, After, AfterReturning, AfterThrowing的顺序自定义排序
    methods.sort(METHOD_COMPARATOR);
  }
  return methods;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不知道小伙伴们对ReflectionUtils.doWithMethods这个工具类熟不熟悉呢，这个工具类在之前分析Bean创建过程时可是出现了好多次呢，并且我们也是可以使用的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，已经获取到切面中的所有方法了，那么接下来就该对这些方法解析并进行封装成advisor了～&lt;/p&gt;
&lt;p&gt;getAdvisor&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
                        int declarationOrderInAspect, String aspectName) {
        // 获取方法上的切点表达式
  AspectJExpressionPointcut expressionPointcut = getPointcut(
    candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
  // 封装成对象返回，创建对象时将会解析方法创建advice
  return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,
                                                        this, aspectInstanceFactory, declarationOrderInAspect, aspectName);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取切点表达式的过程其实非常简单，即是解析方法上的注解，取出注解上的value即可&lt;/p&gt;
&lt;p&gt;getPointcut&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&amp;lt;?&amp;gt; candidateAspectClass) {
  // 查找方法上和AspectJ相关注解
  AspectJAnnotation&amp;lt;?&amp;gt; aspectJAnnotation =
    AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
  // 设置切点表达式
  AspectJExpressionPointcut ajexp =
    new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&amp;lt;?&amp;gt;[0]);
  // PointcutExpression 为注解上value属性的值
  ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
  if (this.beanFactory != null) {
    ajexp.setBeanFactory(this.beanFactory);
  }
  return ajexp;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;new InstantiationModelAwarePointcutAdvisorImpl，在这里，才会真正创建出advice&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public InstantiationModelAwarePointcutAdvisorImpl(){
  //...省略赋值过程...
  // 实例化出advice
  this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) {
  // 获取advice,aspectJAdviceMethod为方法，aspectName为切面类
  Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut,
                                                       this.aspectInstanceFactory, this.declarationOrder, this.aspectName);
  return (advice != null ? advice : EMPTY_ADVICE);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Advice getAdvice(){
  // 根据方法获取到注解信息
  AspectJAnnotation&amp;lt;?&amp;gt; aspectJAnnotation =
                                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
  AbstractAspectJAdvice springAdvice;
  // 根据注解类型返回对象，创建对象的过程都是一样的，都是调用父类的构造方法
  // candidateAdviceMethod为切面的方法，expressionPointcut是切点
  switch (aspectJAnnotation.getAnnotationType()) {
    case AtPointcut
      return null;
    case AtAround:
      springAdvice = new AspectJAroundAdvice(
        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
      break;
    case AtBefore:
      springAdvice = new AspectJMethodBeforeAdvice(
        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
      break;
    case AtAfter:
      springAdvice = new AspectJAfterAdvice(
        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
      break;
      //...省略其他的advice
    default:
      throw new UnsupportedOperationException(
        &quot;Unsupported advice type on method: &quot; + candidateAdviceMethod);
  }
  return springAdvice;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;springAdvice已创建完毕，意味着切面中的某个方法已经解析完毕了，其他的方法解析过程大致也是相似的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;其实解析切面本身并不复杂，只是Spring中将切面类封装来封装去容易使人混乱，如&lt;code&gt;buildAspectJAdvisors&lt;/code&gt;方法中，封装了一个&lt;code&gt;AspectMetadata amd = new AspectMetadata(beanType, beanName);&lt;/code&gt;，又立即发起判定&lt;code&gt;amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON&lt;/code&gt;，其实这里完全可以变为&lt;code&gt;AjTypeSystem.getAjType(currClass).getPerClause().getKind() == PerClauseKind.SINGLETON&lt;/code&gt;，&lt;code&gt;AjTypeSystem.getAjType(currClass)&lt;/code&gt;为&lt;code&gt;new AspectMetadata&lt;/code&gt;的一部分逻辑，笔者这里给大家总结一下吧。&lt;/p&gt;
&lt;p&gt;首先，循环所有的beanName，找到带有@Aspectj注解的class, 获取到class中的所有方法进行遍历解析，取出方法注解上的值（切点：pointcut），然后把方法，切点表达式，封装了BeanFactory,BeanName的factory封装成相应的SpringAdvice, 由SpringAdvice和pointcut组合成一个advisor。&lt;/p&gt;
&lt;h2 id=&quot;创建代理对象&quot;&gt;创建代理对象&lt;/h2&gt;
&lt;p&gt;切面已经解析完毕，接下来，我们就来看看如何把解析出的切面织入到目标方法中吧&lt;/p&gt;
&lt;p&gt;但，在这之前，还有必要给小伙伴们补充一点前置知识。&lt;/p&gt;
&lt;p&gt;我们知道，一个bean是否能够被aop代理，取决于它是否满足代理条件，即为是否能够被切点表达式所命中，而在Spring AOP中，bean与切点表达式进行匹配的是AspectJ实现的，并非Spring所完成的，所以我们先来看看AspectJ如何匹配出合适的bean的吧&lt;/p&gt;
&lt;h3 id=&quot;栗子&quot;&gt;栗子&lt;/h3&gt;
&lt;p&gt;首先需要引入&lt;code&gt;org.aspectj:aspectjweaver&lt;/code&gt;依赖&lt;/p&gt;
&lt;p&gt;一个Service，包名为&lt;code&gt;com.my.spring.test.aop&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.my.spring.test.aop;

/**
 * 切点表达式可以匹配的类
 *
 */
public class ServiceImpl{
        /**
         * 切点表达式可以匹配的方法
         */
  public void doService() {
    System.out.println(&quot;do service ...&quot;);
  }
        public void matchMethod() {
                System.out.println(&quot;ServiceImpl.notMatchMethod&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们自己封装一个用于匹配的工具类，具体功能大家看注释哈哈&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.my.spring.test.aspectj;

import org.aspectj.weaver.tools.PointcutExpression;
import org.aspectj.weaver.tools.PointcutParser;
import org.aspectj.weaver.tools.ShadowMatch;

import java.lang.reflect.Method;

/**
 * aop工具
 */
public class AOPUtils {
        // AspectJ的固定写法，获取一个切点解析器
        static PointcutParser parser = PointcutParser
                        .getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(
                                        PointcutParser.getAllSupportedPointcutPrimitives(), ClassLoader.getSystemClassLoader());
        // 切点表达式
        private static PointcutExpression pointcutExpression;

        /**
         * 初始化工具类，我们需要先获取一个切点表达式
         *
         * @param expression 表达式
         */
        public static void init(String expression){
                // 解析出一个切点表达式
                pointcutExpression =  parser.parsePointcutExpression(expression);
        }

        /**
         * 第一次筛选，根据类筛选，也叫做粗筛
         *
         * @param targetClass 目标类
         * @return 是否匹配
         */
        public static boolean firstMatch(Class&amp;lt;?&amp;gt; targetClass){
    // 根据类筛选
                return pointcutExpression.couldMatchJoinPointsInType(targetClass);
        }

        /**
         * 第二次筛选，根据方法筛选，也叫做精筛，精筛通过则说明完全匹配
         * ps: 也可以使用该方法进行精筛，粗筛的目的是提高性能，第一次直接过滤掉不合适的类再慢慢精筛
         * 
         * @param method 方法
         * @return 是否匹配
         */
        public static boolean lastMatch(Method method){
    // 根据方法筛选
                ShadowMatch shadowMatch = pointcutExpression.matchesMethodExecution(method);
                return shadowMatch.alwaysMatches();
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AOPUtilsTest {

        public static void main(String[] args) throws NoSuchMethodException {
                // 定义表达式
                String expression = &quot;execution(* com.my.spring.test.aop.*.*(..))&quot;;
                // 初始化工具类
                AOPUtils.init(expression);
                // 粗筛
                boolean firstMatch = AOPUtils.firstMatch(ServiceImpl.class);
                if(firstMatch){
                        System.out.println(&quot;第一次筛选通过&quot;);
                        // 正常情况应该是获取所有方法进行遍历，我这里偷懒了～
                        Method doService = ServiceImpl.class.getDeclaredMethod(&quot;doService&quot;);
                        // 精筛
                        boolean lastMatch = AOPUtils.lastMatch(doService);
                        if(lastMatch){
                                System.out.println(&quot;第二次筛选通过&quot;);
                        }
                        else{
                                System.out.println(&quot;第二次筛选未通过&quot;);
                        }
                }
                else {
                        System.out.println(&quot;第一次筛选未通过&quot;);
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果(就不截图了，怀疑的小伙伴可以自己试试～)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;第一次筛选通过
第二次筛选通过
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们新建一个类&lt;code&gt;Test&lt;/code&gt;,把切点表达式换成&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;execution(* com.my.spring.test.aop.Test.*(..))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一次筛选未通过
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再把切点表达式换成指定的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;execution(* com.my.spring.test.aop.*.matchMethod(..))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一次筛选通过
第二次筛选未通过
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;到这里，小伙伴们应该明白了AspectJ的使用方法吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;代理对象创建过程&quot;&gt;代理对象创建过程&lt;/h3&gt;
&lt;p&gt;接下来，我们就来看看Spring是如何使用AspectJ匹配出相应的advisor并创建代理对象的吧，以下为创建代理对象的大致路程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202012/1187061-20201214083740408-349963296.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建代理对象是在bean初始化后完成的，所以对应的&lt;code&gt;beanPostProcessor&lt;/code&gt;调用时机为&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;AbstractAutoProxyCreator#postProcessAfterInitialization&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
                if (bean != null) {
                        // 获取缓存key值，其实就是beanName
                        Object cacheKey = getCacheKey(bean.getClass(), beanName);
                        // 判断缓存中是否有该对象，有则说明该对象已被动态代理，跳过
                        if (this.earlyProxyReferences.remove(cacheKey) != bean) {
                                return wrapIfNecessary(bean, beanName, cacheKey);
                        }
                }
                return bean;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wrapIfNecessary&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
        // 根据bean获取到匹配的advisor
  Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
  if (specificInterceptors != DO_NOT_PROXY) {
    // 创建代理对象
    Object proxy = createProxy(
      bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
    return proxy;
  }
  return bean;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getAdvicesAndAdvisorsForBean&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object[] getAdvicesAndAdvisorsForBean(
                        Class&amp;lt;?&amp;gt; beanClass, String beanName, @Nullable TargetSource targetSource) {
  // 获取合适的advisor
  List&amp;lt;Advisor&amp;gt; advisors = findEligibleAdvisors(beanClass, beanName);
  return advisors.toArray();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;findEligibleAdvisors&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected List&amp;lt;Advisor&amp;gt; findEligibleAdvisors(Class&amp;lt;?&amp;gt; beanClass, String beanName) {
  // 先获取到所有的advisor, 这里和解析过程相同，由于已经解析好，所以会直接从缓存中取出
  List&amp;lt;Advisor&amp;gt; candidateAdvisors = findCandidateAdvisors();
  // 筛选出匹配的advisor
  List&amp;lt;Advisor&amp;gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
  // 增加一个默认的advisor
  extendAdvisors(eligibleAdvisors);
  if (!eligibleAdvisors.isEmpty()) {
    // 排序
    eligibleAdvisors = sortAdvisors(eligibleAdvisors);
  }
  return eligibleAdvisors;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;findAdvisorsThatCanApply&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected List&amp;lt;Advisor&amp;gt; findAdvisorsThatCanApply(
                        List&amp;lt;Advisor&amp;gt; candidateAdvisors, Class&amp;lt;?&amp;gt; beanClass, String beanName) {
  // 查找匹配的advisor
  return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;findAdvisorsThatCanApply&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static List&amp;lt;Advisor&amp;gt; findAdvisorsThatCanApply(List&amp;lt;Advisor&amp;gt; candidateAdvisors, Class&amp;lt;?&amp;gt; clazz){
  List&amp;lt;Advisor&amp;gt; eligibleAdvisors = new ArrayList&amp;lt;&amp;gt;();
  for (Advisor candidate : candidateAdvisors) {
    // 判断是否匹配
    if (canApply(candidate, clazz, hasIntroductions)) {
      // 加入到合适的advisors集合中
      eligibleAdvisors.add(candidate);
    }
  }
  return eligibleAdvisors;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;canApply&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static boolean canApply(Advisor advisor, Class&amp;lt;?&amp;gt; targetClass, boolean hasIntroductions) {
  if (advisor instanceof PointcutAdvisor) {
    PointcutAdvisor pca = (PointcutAdvisor) advisor;
    // 判断是否匹配
    return canApply(pca.getPointcut(), targetClass, hasIntroductions);
  }
  else {
    // It doesn't have a pointcut so we assume it applies.
    return true;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;canApply&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static boolean canApply(Pointcut pc, Class&amp;lt;?&amp;gt; targetClass, boolean hasIntroductions) {
        // 第一次筛选，对class筛选判断是否满足匹配条件
  // 这里将会初始化切点表达式
  if (!pc.getClassFilter().matches(targetClass)) {
    return false;
  }
  
  IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
  if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
    introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
  }
  
  for (Class&amp;lt;?&amp;gt; clazz : classes) {
    Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
    // 循环所有方法进行第二次筛选，判断是否有方法满足匹配条件
    for (Method method : methods) {
      if (introductionAwareMethodMatcher != null ?
          introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
          methodMatcher.matches(method, targetClass)) {
        return true;
      }
    }
  }
  return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pc.getClassFilter()&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ClassFilter getClassFilter() {
  obtainPointcutExpression();
  return this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;obtainPointcutExpression&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private PointcutExpression obtainPointcutExpression() {
  if (this.pointcutExpression == null) {
    // 确认类加载器
    this.pointcutClassLoader = determinePointcutClassLoader();
    // 创建切点表达式
    this.pointcutExpression = buildPointcutExpression(this.pointcutClassLoader);
  }
  return this.pointcutExpression;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;buildPointcutExpression&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private PointcutExpression buildPointcutExpression(@Nullable ClassLoader classLoader) {
  // 初始化切点解析器
  PointcutParser parser = initializePointcutParser(classLoader);
  PointcutParameter[] pointcutParameters = new PointcutParameter[this.pointcutParameterNames.length];
  for (int i = 0; i &amp;lt; pointcutParameters.length; i++) {
    pointcutParameters[i] = parser.createPointcutParameter(
      this.pointcutParameterNames[i], this.pointcutParameterTypes[i]);
  }
  // 使用切点解析器进行解析表达式获取切点表达式
  return parser.parsePointcutExpression(replaceBooleanOperators(resolveExpression()),
                                        this.pointcutDeclarationScope, pointcutParameters);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;initializePointcutParser&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private PointcutParser initializePointcutParser(@Nullable ClassLoader classLoader) {
  // 获得切点解析器
  PointcutParser parser = PointcutParser
    .getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(
    SUPPORTED_PRIMITIVES, classLoader);
  parser.registerPointcutDesignatorHandler(new BeanPointcutDesignatorHandler());
  return parser;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;pc.getClassFilter便是完成了以上事情，此时再进行调用matchs方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean matches(Class&amp;lt;?&amp;gt; targetClass) {
  PointcutExpression pointcutExpression = obtainPointcutExpression();
  // 使用切点表达式进行粗筛
  return pointcutExpression.couldMatchJoinPointsInType(targetClass);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;introductionAwareMethodMatcher.matches 同样如此&lt;/p&gt;
&lt;p&gt;以上便是寻找合适的advisor的过程，下面，就是通过这些advisor进行创建动态代理了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;createProxy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object createProxy(Class&amp;lt;?&amp;gt; beanClass, @Nullable String beanName,
                        @Nullable Object[] specificInterceptors, TargetSource targetSource) {
  ProxyFactory proxyFactory = new ProxyFactory();
  proxyFactory.copyFrom(this);
        // 将specificInterceptors（现在是Object）转化为Advisor返回
  Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
  // 赋值到proxyFactory的advisors属性中
  proxyFactory.addAdvisors(advisors);
  proxyFactory.setTargetSource(targetSource);
  customizeProxyFactory(proxyFactory);
  // 创建动态代理
  return proxyFactory.getProxy(getProxyClassLoader());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;proxyFactory.getProxy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object getProxy(@Nullable ClassLoader classLoader) {
  // 创建代理对象
  return createAopProxy().getProxy(classLoader);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;createAopProxy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected final synchronized AopProxy createAopProxy() {
  // 创建AOP代理对象
  return getAopProxyFactory().createAopProxy(this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
  // @EnableAspectJAutoProxy的proxyTargetClass是否配置为true
  if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
    Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
    if (targetClass == null) {
      throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                                   &quot;Either an interface or a target is required for proxy creation.&quot;);
    }
    // 如何是接口则创建jdk动态代理
    if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
      return new JdkDynamicAopProxy(config);
    }
    // cglib动态代理
    return new ObjenesisCglibAopProxy(config);
  }
  // 默认是jdk动态代理
  else {
    return new JdkDynamicAopProxy(config);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object getProxy(@Nullable ClassLoader classLoader) {
  // 获取到代理的接口
  Class&amp;lt;?&amp;gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
  findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
  // 创建jdk代理，传入的为JdkDynamicAopProxy对象，里面包含了被代理的bean以及匹配的advisor
  return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;动态代理创建完成～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;代理对象调用过程&quot;&gt;代理对象调用过程&lt;/h2&gt;
&lt;p&gt;对象都给你创建好了，接下当然是开..发起调用咯&lt;/p&gt;
&lt;p&gt;以下是调用的大致流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202012/1187061-20201214083743728-1185527259.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代理对象被调用的是invoke方法，我们所创建的代理对象为&lt;code&gt;JdkDynamicAopProxy&lt;/code&gt;，所以&lt;/p&gt;
&lt;p&gt;JdkDynamicAopProxy#invoke&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  Object oldProxy = null;
  boolean setProxyContext = false;
  // 取出包装了被代理bean的对象-&amp;gt;创建代理对象时的SingletonTargetSource, advised为ProxyFactory
  TargetSource targetSource = this.advised.targetSource;
  Object target = null;
  // 拿到bean
  target = targetSource.getTarget();
  Class&amp;lt;?&amp;gt; targetClass = (target != null ? target.getClass() : null);
  // 将所有advisor中的advice取出，并转化为对应的interceptor
  List&amp;lt;Object&amp;gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
  // 创建一个最外层的MethodInvocation用于发起调用
  MethodInvocation invocation =
    new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
  // 发起链式调用
  Object retVal = invocation.proceed();
  return retVal;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看获取interceptor的过程&lt;/p&gt;
&lt;p&gt;getInterceptorsAndDynamicInterceptionAdvice&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public List&amp;lt;Object&amp;gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class&amp;lt;?&amp;gt; targetClass) {
  // 将所有advisor中的advice取出并封装成intercept
  return this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public List&amp;lt;Object&amp;gt; getInterceptorsAndDynamicInterceptionAdvice(
  Advised config, Method method, @Nullable Class&amp;lt;?&amp;gt; targetClass) {
        // 创建一个advisor适配器的注册器用于转化advice，创建时将默认注册三个适配器
  AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();
  Advisor[] advisors = config.getAdvisors();
  // 循环遍历所有advisor
  for (Advisor advisor : advisors) {
        // 将advisor中的advice转化为interceptor
    MethodInterceptor[] interceptors = registry.getInterceptors(advisor);
    interceptorList.addAll(Arrays.asList(interceptors));
    return interceptorList;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GlobalAdvisorAdapterRegistry.getInstance() 类初始化时调用静态方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static AdvisorAdapterRegistry instance = new DefaultAdvisorAdapterRegistry()
public static AdvisorAdapterRegistry getInstance() {
                return instance;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public DefaultAdvisorAdapterRegistry() {
  // 注册三个适配器
  registerAdvisorAdapter(new MethodBeforeAdviceAdapter());
  registerAdvisorAdapter(new AfterReturningAdviceAdapter());
  registerAdvisorAdapter(new ThrowsAdviceAdapter());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void registerAdvisorAdapter(AdvisorAdapter adapter) {
  // 将适配器加入集合
  this.adapters.add(adapter);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;registry.getInterceptors 这里面包含了advice转化成interceptor的过程&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {
  List&amp;lt;MethodInterceptor&amp;gt; interceptors = new ArrayList&amp;lt;&amp;gt;(3);
  Advice advice = advisor.getAdvice();
  // advice本身是否就是MethodInterceptor
  if (advice instanceof MethodInterceptor) {
    interceptors.add((MethodInterceptor) advice);
  }
  for (AdvisorAdapter adapter : this.adapters) {
    // 判断advice是哪个advice 如：(advice instanceof MethodBeforeAdvice)
    if (adapter.supportsAdvice(advice)) {
      // 将advice封装到对应的interceptor
      interceptors.add(adapter.getInterceptor(advisor));
    }
  }
  return interceptors.toArray(new MethodInterceptor[0]);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若adapter为&lt;code&gt;MethodBeforeAdviceAdapter&lt;/code&gt;，则&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public MethodInterceptor getInterceptor(Advisor advisor) {
  MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
  return new MethodBeforeAdviceInterceptor(advice);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;其他advice转化过程相同&lt;/p&gt;
&lt;p&gt;以上，便将所有的advice转化成了interceptor，接下来，则是经典的链式递归调用过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下过程小伙伴们可以对照流程图阅读，毕竟递归还是有些复杂，需要一定的功底&lt;/p&gt;
&lt;p&gt;ReflectiveMethodInvocation#proceed&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object proceed() throws Throwable {
  // currentInterceptorIndex 初始值为-1
  // 当currentInterceptorIndex等于advice的数量减一时，则调用目标方法
  // 由于advice已排好序，所以调用顺序为before, after, afterReturn, afterThrowing
  // 注意，并非调用到相应的advice就会执行advice方法，这里是类似递归调用的方式，会存在一个归过程
  // 有些是递的时候发起调用，如beforeAdvice, 但有些则是归的时候发起调用，如afterAdvice
  // 递归的终止条件则是这下面这个return invokeJoinpoint();
  if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
    return invokeJoinpoint();
  }
        // currentInterceptorIndex自增并获取到interceptor
  Object interceptorOrInterceptionAdvice =
    this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
  // 将interceptro强转为MethodInterceptor发起调用
  return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时currentInterceptorIndex值为0，而我们的advice为4个(去除了默认的)，所以当currentInterceptorIndex为3时便会调用我们的实际方法&lt;/p&gt;
&lt;p&gt;首先调用的是MethodBeforeAdviceInterceptor&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object invoke(MethodInvocation mi) throws Throwable {
  // 调用前置通知
  this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
  return mi.proceed();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;mi为传入的this，所有mi.proceed()将会回到最开始的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再次循环，此时currentInterceptorIndex值为1&lt;/p&gt;
&lt;p&gt;调用的是AspectJAfterAdvice&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object invoke(MethodInvocation mi) throws Throwable {
  try {
    return mi.proceed();
  }
  finally {
    // finally意味着不管怎样都会被调用
    invokeAdviceMethod(getJoinPointMatch(), null, null);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续，此时currentInterceptorIndex值为2&lt;/p&gt;
&lt;p&gt;调用的是AfterReturningAdviceInterceptor&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object invoke(MethodInvocation mi) throws Throwable {
  Object retVal = mi.proceed();
  this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
  return retVal;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续，此时currentInterceptorIndex值为3&lt;/p&gt;
&lt;p&gt;调用的是AspectJAfterThrowingAdvice&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object invoke(MethodInvocation mi) throws Throwable {
  try {
    return mi.proceed();
  }
  catch (Throwable ex) {
    if (shouldInvokeOnThrowing(ex)) {
      // 调用异常通知
      invokeAdviceMethod(getJoinPointMatch(), null, ex);
    }
    // 往外抛出异常
    throw ex;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所以如果我们的业务方法发生了异常，会调用到异常通知，而这里又把异常往外抛，所以afterReturn就会被跳过直接到after的finally方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在currentInterceptorIndex值为3了，再回调最初的方法中时，就会调用到我们的业务方法了。调用完毕则进行归的过程，调用过程便结束了。&lt;/p&gt;
&lt;blockquote readability=&quot;3.9565217391304&quot;&gt;
&lt;p&gt;以上，便是整个AOP的过程了&lt;/p&gt;
&lt;p&gt;本篇文章中涉及到图片的矢量图地址为：&lt;a href=&quot;https://www.processon.com/view/link/5fa8afdae401fd45d109f257%EF%BC%8C%E6%9C%89%E9%9C%80%E8%A6%81%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%E5%8F%AF%E8%87%AA%E5%8F%96&quot; target=&quot;_blank&quot;&gt;https://www.processon.com/view/link/5fa8afdae401fd45d109f257，有需要的小伙伴可自取&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下文预告：Spring源码分析之事务管理(上)&lt;/p&gt;
&lt;h5 id=&quot;spring-源码系列&quot;&gt;Spring 源码系列&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;Spring源码分析之 IOC 容器预启动流程(已完结)&lt;/li&gt;
&lt;li&gt;Spring源码分析之BeanFactory体系结构(已完结)&lt;/li&gt;
&lt;li&gt;Spring源码分析之BeanFactoryPostProcessor调用过程(已完结)&lt;/li&gt;
&lt;li&gt;Spring源码分析之Bean的创建过程(已完结)&lt;/li&gt;
&lt;li&gt;Spring源码分析之什么是循环依赖及解决方案(已完结)&lt;/li&gt;
&lt;li&gt;Spring源码分析之AOP从解析到调用(已完结)&lt;/li&gt;
&lt;li&gt;Spring源码分析之事务管理(上)，事物管理是spring作为容器的一个特点，总结一下他的基本实现与原理吧&lt;/li&gt;
&lt;li&gt;Spring源码分析之事务管理(下) ，关于他的底层事物隔离与事物传播原理，重点分析一下&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;spring-mvc-源码系列&quot;&gt;Spring Mvc 源码系列&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;SpringMvc体系结构&lt;/li&gt;
&lt;li&gt;SpringMvc源码分析之Handler解析过程&lt;/li&gt;
&lt;li&gt;SpringMvc源码分析之请求链过程&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;另外笔者公众号：奇客时间，有更多精彩的文章，有兴趣的同学，可以关注&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 14 Dec 2020 00:38:00 +0000</pubDate>
<dc:creator>雕爷的架构之路</dc:creator>
<og:description>正文： 在上一篇，我们对IOC核心部分流程已经分析完毕，相信小伙伴们有所收获，从这一篇开始，我们将会踏上新的旅程，即Spring的另一核心：AOP! 首先，为了让大家能更有效的理解AOP，先带大家过一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tomakemyself/p/14131421.html</dc:identifier>
</item>
<item>
<title>你来说一下springboot的启动时的一个自动装配过程吧 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/14131406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/14131406.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;继续总结吧，没有面试就继续夯实自己的基础，前阵子的在面试过程中遇到的各种问题陆陆续续都会总结出来分享给大家，这次要说的也是面试中被问到的一个高频的问题，我当时其实没答好，因为很早之前是看到springboot的启动的一个过程的源码的，但是时间隔得有点久了（两年多没用过springboot），所以当时也没答好。这次好好总结这部分知识。&lt;/p&gt;
&lt;h2 id=&quot;springapplicationrun&quot;&gt;SpringApplication.run()&lt;/h2&gt;
&lt;p&gt;我看网上好多介绍springboot自动装配过的文章时，上来就直接说&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解是一个复合注解，从这个注解开始介绍springboot是如何将配置项进行加载的。其实我觉得难道不应该是先启动了spring的容器，然后才能扫到注解，然后才能解析注解吗？也可能是大家觉得创建容器刷新容器这些基础操作都默认知道的，所以就都没说。&lt;br/&gt;但我在分析springboot自动装配的时候，要先从&lt;code&gt;SpringApplication.run()&lt;/code&gt;方法开始。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201208221537783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们进入到&lt;code&gt;SpringApplication&lt;/code&gt;这个类中看一下&lt;code&gt;run()&lt;/code&gt;方法的核心实现，差不多每一行我都加上了注释了。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210001830991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;code&gt;SpringApplication.run()&lt;/code&gt;方法中，我把关键点用序号标识出来了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;第一个就是创建ApplicationContext容器。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二个是刷新ApplicationContext容器。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在创建ApplicationContext时，会根据用户是否明确设置了&lt;code&gt;ApplicationContextClass&lt;/code&gt;类型以及初始化阶段的推断结果，决定为当前SpringBoot应用创建什么类型的ApplicationContext。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213162927303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_50,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;创建完成ApplicationContext容器后，我们接着回到&lt;code&gt;SpringApplication.run()&lt;/code&gt;方法中。&lt;br/&gt;下面开始初始化各种插件在异常失败后给出的提示。&lt;br/&gt;然后执行准备刷新上下文的一些操作。其实&lt;code&gt;prepareContext()&lt;/code&gt;方法也是非常关键的，它起到了一个承上启下的作用。下面我们来看一下&lt;code&gt;prepareContext()&lt;/code&gt;方法里面具体执行了什么。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213173935942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;关键的地方我也标注出来了，主要就是&lt;code&gt;getAllSoures()&lt;/code&gt;方法，这个方法中，获取到的一个source就是启动类DemoApplication。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213165545364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这样就通过获取这个启动类就可以在后load()方法中取加载这个启动类到容器中。&lt;/p&gt;
&lt;p&gt;然后，后面再通过&lt;code&gt;listeners.contextLoaded(context)&lt;/code&gt;;&lt;br/&gt;将所有监听器加载到ApplicationContext容器中。&lt;/p&gt;
&lt;p&gt;最后就是我们上面说的核心的第二部刷新ApplicationContext容器操作，如果没有这一步操作上面的内容也都白做的，通过&lt;code&gt;SpringApplication的refreshContext(context)&lt;/code&gt;方法完成最后一道工序将启动类上的注解配置，刷新到当前运行的容器环境中。&lt;/p&gt;
&lt;h2 id=&quot;启动类上的注解&quot;&gt;启动类上的注解&lt;/h2&gt;
&lt;p&gt;上面我们说到在SpringApplication的&lt;code&gt;run()&lt;/code&gt;方法中，通过调用自己的&lt;code&gt;prepareContext()&lt;/code&gt;方法，在&lt;code&gt;prepareContext()&lt;/code&gt;方法中又调用&lt;code&gt;getAllSources()&lt;/code&gt;方法，然后去获取启动类，然后通过SpringApplication的&lt;code&gt;load()&lt;/code&gt;方法，去加载启动类，然后在刷新容器的时候就会去将启动类在容器中进行实例化。&lt;/p&gt;
&lt;p&gt;在刷新ApplicationContext容器时，就开始解析启动类上的注解了。&lt;/p&gt;
&lt;p&gt;启动类&lt;code&gt;DemoApplication&lt;/code&gt;就只有一个注解&lt;code&gt;@SpringBootApplication&lt;/code&gt;，那么下面来看一下这个注解：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213205024133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_50,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可以看到这个注解是一个复合注解，有三个关键注解需要说明一下。&lt;/p&gt;
&lt;h3 id=&quot;springbootconfiguration&quot;&gt;@SpringBootConfiguration&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@SpringBootConfiguration&lt;/code&gt;这个注解说明再点进去查看详情发现就是一个&lt;code&gt;@Configuration&lt;/code&gt;注解，这说明启动类就是一个配置类。支持Spring以JavaConfig的形式启动。&lt;/p&gt;
&lt;h3 id=&quot;componentscan&quot;&gt;@ComponentScan&lt;/h3&gt;
&lt;p&gt;这个注解，从字面的意思上也能看出来，就是组件扫描的意思，即默认扫描当前package以及其子包下面的spring的注解，例如：&lt;code&gt;@Controller&lt;/code&gt;、&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Component&lt;/code&gt;等等注解。&lt;/p&gt;
&lt;h3 id=&quot;enableautoconfiguration&quot;&gt;@EnableAutoConfiguration&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;这个注解也是一个复合注解：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213205927286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_20,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这个注解是比较核心的一个注解，springboot的主要自动配置原理基本上都来自@EnableAutoConfiguration这个注解的配置，那么我们通过看这个注解的源码可以发现有两个注解比较重要的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个是&lt;code&gt;@AutoConfigurationPackage&lt;/code&gt;，自动配置包。&lt;/li&gt;
&lt;li&gt;另一个是&lt;code&gt;@Import(AutoConfigurationImportSelector.class)&lt;/code&gt;，自动引入组件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;@AutoConfigurationPackage&lt;/code&gt;这个注解字面的意思是&lt;strong&gt;自动配置包&lt;/strong&gt;，那么我们点进去看看里面是什么样的。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213211229421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;还是一个复合注解，但是最终依赖的确实&lt;code&gt;@Import&lt;/code&gt;这个注解，这个注解后面我们会介绍，现在先明白它就是给Spring容器引入组件的功能的一个注解。&lt;br/&gt;那么我们接着来看看&lt;code&gt;AutoConfigurationPackages.Registrar.class&lt;/code&gt;这个类里面的代码。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213211732297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213212700970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这两张图就是这个&lt;code&gt;AutoConfigurationPackages.Registrar&lt;/code&gt;这个类的关键部分，说实话，我是没看出来什么东西。但是网上搜到的是这个register()方法的作用是，用来自动注册一些组件中的配置，例如JPA的&lt;code&gt;@Entity&lt;/code&gt;这个注解，这里就是会开启自动扫描这类注解的功能。&lt;/p&gt;
&lt;h4 id=&quot;importautoconfigurationimportselectorclass&quot;&gt;@Import(AutoConfigurationImportSelector.class)&lt;/h4&gt;
&lt;p&gt;我们接着回来看&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;下的&lt;code&gt;@Import(AutoConfigurationImportSelector.class)&lt;/code&gt;这个注解的功能。进入到&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;这个类里面后源码如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213213736281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后我们进入&lt;code&gt;getAutoConfigurationEntry()&lt;/code&gt;方法来看看：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213213847443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们继续进入&lt;code&gt;getCandidateConfigurations()&lt;/code&gt;方法：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213214040227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;看来最核心的方法是&lt;code&gt;SpringFactroiesLoader.loadFactoryNames()&lt;/code&gt;方法了，我们再进入看看：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213214451355.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;包的好深，居然还有一层，那么继续进入&lt;code&gt;loadSpringFactories()&lt;/code&gt;方法。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213214823867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;终于到最后一层了，算是“拨开云雾见天日,守得云开见月明”，下面就来梳理一下loadSpringFactories()方法。&lt;br/&gt;首先&lt;code&gt;FACTORIES_RESOURCE_LOCATION&lt;/code&gt;这个常量的值是：&lt;br/&gt;&lt;code&gt;&quot;META-INF/spring.factories&quot;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * The location to look for factories.
 * &amp;lt;p&amp;gt;Can be present in multiple JAR files.
 */
public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以第一个端核心代码的意思是：&lt;br/&gt;启动的时候会扫描所有jar包下&lt;code&gt;META-INF/spring.factories&lt;/code&gt;这个文件。第二段代码的意思是将这些扫描到的文件转成Properties对象，后面两个核心代码的意思就是说将加载到的Properties对象放入到缓存中。&lt;/p&gt;
&lt;p&gt;然后&lt;code&gt;getCandidateConfigurations()&lt;/code&gt;方法，是只获取了key是&lt;code&gt;EnableAutoConfiguration.class&lt;/code&gt;的配置。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020121322235276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们看到&lt;code&gt;getCandidateConfigurations()&lt;/code&gt;方法，通过S&lt;code&gt;pringFactoriesLoader.loadFactoryNames()&lt;/code&gt;获取到了118个配置。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213223115595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;那么我们来看一个&lt;code&gt;spring.factories&lt;/code&gt;文件中的内容是什么样子的呢？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020121322393196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;原来是这种形式的，看来这和上一篇文章中讲解的Java中的SPI机制加载接口实现很像啊，其实通过查阅资料发现，这就是一种自定义SPI的实现方式的功能。&lt;br/&gt;那么我们以第一个配置类：&lt;br/&gt;&lt;code&gt;org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration&lt;/code&gt;来看一下，这些类都是如果实现的。&lt;br/&gt;打开&lt;code&gt;org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration&lt;/code&gt;的源码：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213224336537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们看到这个类有三个注解&lt;code&gt;@Configuration&lt;/code&gt;、&lt;code&gt;@AutoConfigureAfter&lt;/code&gt;、&lt;code&gt;@ConditionalOnProperty&lt;/code&gt;、因为有&lt;code&gt;@Configuration&lt;/code&gt;注解所以它也是一个配置类，然后第二注解中的参数类&lt;code&gt;JmxAutoConfiguration.class&lt;/code&gt;进入之后是这样的：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213224743889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTY1MDAw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;也是存在&lt;code&gt;@ConditionalOnProperty&lt;/code&gt;注解的。那看来关键点就是&lt;code&gt;@ConditionalOnProperty&lt;/code&gt;这个注解了。&lt;br/&gt;这个注解其实是一个条件判断注解，这个条件注解后面的参数的意思是当存在系统属性前缀为&lt;code&gt;spring.application.admin&lt;/code&gt;，并且属性名称为&lt;code&gt;enabled&lt;/code&gt;，并且值为&lt;code&gt;true&lt;/code&gt;时，才加载当前这个Bean并进行实例化。&lt;/p&gt;
&lt;p&gt;这种spring4.0后面出现的的条件注解，可以极大的增加了框架的灵活性和扩展性，可以保证很多组件可以通过后期配置，而且阅读源码的人，通过这些注解就能明白在什么情况下才会实例化当前Bean。&lt;/p&gt;
&lt;p&gt;后面还有不少这种条件注解呢：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;@ConditionalOnBean：当容器里有指定Bean的条件下&lt;br/&gt;@ConditionalOnClass：当类路径下有指定的类的条件下&lt;br/&gt;@ConditionalOnExpression：基于SpEL表达式为true的时候作为判断条件才去实例化&lt;br/&gt;@ConditionalOnJava：基于JVM版本作为判断条件&lt;br/&gt;@ConditionalOnJndi：在JNDI存在的条件下查找指定的位置&lt;br/&gt;@ConditionalOnMissingBean：当容器里没有指定Bean的情况下&lt;br/&gt;@ConditionalOnMissingClass：当容器里没有指定类的情况下&lt;br/&gt;@ConditionalOnWebApplication：当前项目时Web项目的条件下&lt;br/&gt;@ConditionalOnNotWebApplication：当前项目不是Web项目的条件下&lt;br/&gt;@ConditionalOnProperty：指定的属性是否有指定的值&lt;br/&gt;@ConditionalOnResource：类路径是否有指定的值&lt;br/&gt;@ConditionalOnOnSingleCandidate：当指定Bean在容器中只有一个，或者有多个但是指定首选的Bean&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些注解其实都是通过@Conditional注解扩展而来的，只是使用了不同的组合条件来判断是否需要加载和初始化当前Bean。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好了，最后总结一下，当面试官问springboot的自动装配原理的时候，不能这么长篇大论的说吧，毕竟这么多内容也记不住啊。&lt;br/&gt;所以总结：&lt;br/&gt;&lt;mark&gt;springboot启动时，是依靠启动类的main方法来进行启动的，而main方法中执行的是&lt;code&gt;SpringApplication.run()&lt;/code&gt;方法，而&lt;code&gt;SpringApplication.run()&lt;/code&gt;方法中会创建spring的容器，并且刷新容器。而在刷新容器的时候就会去解析启动类，然后就会去解析启动类上的&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解，而这个注解是个复合注解，这个注解中有一个&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;注解，这个注解就是开启自动配置，这个注解中又有&lt;code&gt;@Import&lt;/code&gt;注解引入了一个&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;这个类，这个类会进过一些核心方法，然后去扫描我们所有jar包下的&lt;code&gt;META-INF&lt;/code&gt;下的&lt;code&gt;spring.factories&lt;/code&gt;文件，而从这个配置文件中取找key为&lt;code&gt;EnableAutoConfiguration&lt;/code&gt;类的全路径的值下面的所有配置都加载，这些配置里面都是有条件注解的，然后这些条件注解会根据你当前的项目依赖的jar包以及是否配置了符合这些条件注解的配置来进行装载的。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;这就是springboot自动配置的过程。&lt;/p&gt;
&lt;h4 id=&quot;其实上面这些内容还是有点多，而且还有好多注解的单词也不好记，那换成大白话，再精炼一下：&quot;&gt;其实上面这些内容还是有点多，而且还有好多注解的单词也不好记，那换成大白话，再精炼一下：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot在启动的时候会调用run()方法，run()方法会刷新容器，刷新容器的时候，会扫描classpath下面的的包中META-INF/spring.factories文件，在这个文件中记录了好多的自动配置类，在刷新容器的时候会将这些自动配置类加载到容器中，然后在根据这些配置类中的条件注解，来判断是否将这些配置类在容器中进行实例化，这些条件主要是判断项目是否有相关jar包或是否引入了相关的bean。这样springboot就帮助我们完成了自动装配。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Dec 2020 00:32:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 继续总结吧，没有面试就继续夯实自己的基础，前阵子的在面试过程中遇到的各种问题陆陆续续都会总结出来分享给大家，这次要说的也是面试中被问到的一个高频的问题，我当时其实没答好，因为很早之前是看到spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/14131406.html</dc:identifier>
</item>
<item>
<title>Anno 让微服务、混合编程更简单(Net love Java) - 杜燕明</title>
<link>http://www.cnblogs.com/duyanming/p/14101812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duyanming/p/14101812.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　在社区或者QQ群我们经常看到有人争辩编程语言的好坏，只要一提起这个话题常常就能引来很多人参与，往往最后就变成了一群人几个小时的骂战。今天我们要说的是如何让Java和.Net（甚至更多语言）相结合。充分发挥其优势扬长避短。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、Anno是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;a href=&quot;https://github.com/duyanming/Anno.Core&quot; target=&quot;_blank&quot;&gt;Anno&lt;/a&gt;&lt;/strong&gt;是一个微服务框架引擎。&lt;strong&gt;入门简单&lt;/strong&gt;、&lt;strong&gt;安全&lt;/strong&gt;、&lt;strong&gt;稳定&lt;/strong&gt;、&lt;strong&gt;高可用&lt;/strong&gt;、&lt;strong&gt;全平台可监控、依赖第三方框架少。&lt;/strong&gt;底层通讯RPC(Remote Procedure Call)采用稳定可靠经过无数成功项目验证过的跨语言的&lt;strong&gt;&lt;code&gt;&lt;a href=&quot;https://github.com/apache/thrift&quot; target=&quot;_blank&quot;&gt;thrift&lt;/a&gt;、&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;https://github.com/grpc/grpc-dotnet&quot; target=&quot;_blank&quot;&gt;grpc&lt;/a&gt;&lt;/code&gt;&lt;/strong&gt;。 自带服务注册发现健康检查（不依赖于Etcd、Consul、Zookeeper）、调用链追踪、Cron 调度、限流、事件总线等等。&lt;/p&gt;
&lt;p&gt; 2&lt;strong&gt;、Java和.Net 混合开发&lt;/strong&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Java的生态很强大，但是他的语法也常常让人诟病。提起.Net经常有人说他不能跨平台（其实早期.net 可以借助Mono跨平台,并且在多个领域取得了不可磨灭的成绩），国内生态不好。随着.net core 的出现和前段时间.Net5的发布，让.net 跨平台更容易。并且.net 有着超高的性能、优雅的语法等等很多方面被人称赞。在编程语言百花齐放的今天，我们需要扬长避短利用不同编程语言各自的优势为我们提供更好的服务。就在这种场景下我们推出了 &lt;span&gt;&lt;strong&gt;Anno微服务框架，让微服务、跨语言混合开发变的更简单更容易&lt;/strong&gt;&lt;/span&gt;。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在&lt;strong&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/duyanming/Anno.Core&quot; target=&quot;_blank&quot;&gt;Anno&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;中&lt;strong&gt;调用方&lt;/strong&gt;（Client）无需知道&lt;strong&gt;服务提供方&lt;/strong&gt;（Provider）的&lt;strong&gt;地址&lt;/strong&gt;、&lt;strong&gt;端口&lt;/strong&gt;、&lt;strong&gt;开发语言&lt;/strong&gt;等等信息&lt;strong&gt;，&lt;/strong&gt;因此我们在开发过程中对于我们需要的&lt;strong&gt;服务&lt;/strong&gt;我们只管通过Client SDK调用，无需关注细节。这样我们也避免了在多语言开发的微服务中带来的各种奇葩问题。&lt;/p&gt;
&lt;p&gt;　　下图是一个在线体验的环境：&lt;a href=&quot;http://140.143.207.244/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;http://140.143.207.244/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201208125905829-1223905973.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  　　Java服务的资源监控&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201209110524280-896002135.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   　　.Net服务的资源监控（运行时长、内存、CPU、硬盘、访问量）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201208131001412-299718107.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们来看一下从网关（.NET5.0实现）访问Java服务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201208131344537-1203342640.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201208131445903-1881191319.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;　　java端功能开发实例代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201208132657386-1967278546.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201208132909124-1342965003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_6a174b57-915a-4a54-a99f-6138293ceef8&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_6a174b57-915a-4a54-a99f-6138293ceef8&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6a174b57-915a-4a54-a99f-6138293ceef8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; anno.componentservice;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anno.componentservice.Models.UserInfo;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anno.componentservice.events.UserEvent;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anno.configuration.AnnoTheadPool;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anno.entities.SysMember;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anno.repository.SysMemberMapper;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anno.thrift.annotation.AnnoInfo;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anno.thrift.module.ActionResult;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anno.thrift.module.BaseModule;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationEventPublisher;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Scope(&quot;prototype&quot;)&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserInfoModule &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseModule {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ApplicationEventPublisher publisher;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;  SysMemberMapper sysMemberMapper;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     @AnnoInfo(desc = &quot;用户信息&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;Object&amp;gt;&lt;span&gt; GetUserInfo(GetUserInfoRequestDto queryInput){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         UserInfo userinfo=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserInfo();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         userinfo.setAge(18&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         userinfo.setName(&quot;Tom&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         HashMap&amp;lt;String,Object&amp;gt; output=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         output.put(&quot;key1&quot;,&quot;value1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         output.put(&quot;key2&quot;,&quot;value2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(HashMap.Entry&amp;lt;String,Object&amp;gt;&lt;span&gt; kv:output.entrySet()){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            output.put(kv.getKey(),kv.getValue());
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         HashMap&amp;lt;String,Object&amp;gt; outputData=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         outputData.put(&quot;queryInput&quot;&lt;span&gt;,queryInput);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         outputData.put(&quot;userinfo&quot;&lt;span&gt;,userinfo);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;        String msg= &quot;this message from Java Server UserInfoModule.&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ActionResult&amp;lt;Object&amp;gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, outputData, output, msg);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     @AnnoInfo(desc = &quot;你好世界&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;Object&amp;gt; HelloWorld(@AnnoInfo(desc = &quot;名称&quot;,name = &quot;name&quot;,required = &lt;span&gt;false&lt;/span&gt;,defaultValue = &quot;Anno Default Value&quot;&lt;span&gt;) String anno){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         String greetings=&quot;Hello &quot;+anno+&quot; I am Anno!&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; ActionResult&amp;lt;&amp;gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,greetings);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;   PublishMsg(String name){
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(name==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             name=&quot;Anno&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         UserEvent uv=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserEvent();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         uv.setId(10010&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        uv.setName(name);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;         * 线程池方式发布事件
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         AnnoTheadPool.getPool().execute(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            publisher.publishEvent(uv);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt; * 发布事件异步 创建线程
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        new Thread(()-&amp;gt;{
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;            publisher.publishEvent(uv);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }).start();&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;         * 直接发布事件 同步
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        publisher.publishEvent(uv);&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;     @AnnoInfo(desc = &quot;根据ID获取用户信息&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;SysMember&amp;gt; GetUserAutowired(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         SysMember member=&lt;span&gt;sysMemberMapper.selectById(id);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ActionResult&amp;lt;&amp;gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,member);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;更多关于Java和.NET的混合开发的详情，请移步到GitHub查看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习交流 &lt;/strong&gt;&lt;strong&gt;QQ群：478399354 &lt;/strong&gt;，到这里我们互为师长相互学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Anno&lt;/strong&gt;核心源码:&lt;a href=&quot;https://github.com/duyanming/Anno.Core&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Anno.Core&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java实现：&lt;a href=&quot;https://github.com/duyanming/anno.thrift-parent&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/anno.thrift-parent&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Viper&lt;/strong&gt;示例项目:&lt;a href=&quot;https://github.com/duyanming/Viper&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Viper&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;体验地址：&lt;a href=&quot;http://140.143.207.244/Home/Login&quot; target=&quot;_blank&quot;&gt;http://140.143.207.244/Home/Login&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档地址：&lt;a href=&quot;https://duyanming.github.io/&quot; target=&quot;_blank&quot;&gt;https://duyanming.github.io/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于Anno的更多内容，随后更新。敬请关注。开源不易，感谢Star。 &lt;/p&gt;
</description>
<pubDate>Mon, 14 Dec 2020 00:01:00 +0000</pubDate>
<dc:creator>杜燕明</dc:creator>
<og:description>在社区或者QQ群我们经常看到有人争辩编程语言的好坏，只要一提起这个话题常常就能引来很多人参与，往往最后就变成了一群人几个小时的骂战。今天我们要说的是如何让Java和.Net（甚至更多语言）相结合。充分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duyanming/p/14101812.html</dc:identifier>
</item>
<item>
<title>C#9.0新特性详解系列之六：增强的模式匹配 - 码客风云</title>
<link>http://www.cnblogs.com/markkang/p/14130867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/markkang/p/14130867.html</guid>
<description>&lt;p&gt;自C#7.0以来，模式匹配就作为C#的一项重要的新特性在不断地演化，这个借鉴于其小弟F#的函数式编程的概念，使得C#的本领越来越多，C#9.0就对模式匹配这一功能做了进一步的增强。&lt;/p&gt;
&lt;p&gt;为了更为深入和全面的了解模式匹配，在介绍C#9.0对模式匹配增强部分之前，我对模式匹配整体做一个回顾。&lt;/p&gt;
&lt;h2 id=&quot;1-模式匹配介绍&quot;&gt;1 模式匹配介绍&lt;/h2&gt;
&lt;h3 id=&quot;11-什么是模式匹配？&quot;&gt;1.1 什么是模式匹配？&lt;/h3&gt;
&lt;p&gt;在特定的上下文中，模式匹配是用于检查所给对象及属性是否满足所需模式（即是否符合一定标准）并从输入中提取信息的行为。它是一种新的代码流程控方式，它能使代码流可读性更强。这里说到的标准有“是不是指定类型的实例”、“是不是为空”、“是否与给定值相等”、“实例的属性的值是否在指定范围内”等。&lt;/p&gt;
&lt;p&gt;模式匹配常结合is表达式用在if语句中，也可用在switch语句在switch表达式中，并且可以用when语句来给模式指定附加的过滤条件。它非常善于用来探测复杂对象，例如：外部Api返回的对象在不同情况下返回的类型不一致，如何确定对象类型？&lt;/p&gt;
&lt;h3 id=&quot;12-模式匹配种类&quot;&gt;1.2 模式匹配种类&lt;/h3&gt;
&lt;p&gt;从C#的7.0版本到现在9.0版本，总共有如下十三种模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常量模式（C#7.0）&lt;/li&gt;
&lt;li&gt;Null模式（C#7.0）&lt;/li&gt;
&lt;li&gt;类型模式（C#7.0）&lt;/li&gt;
&lt;li&gt;属性模式（C#8.0）&lt;/li&gt;
&lt;li&gt;var模式（C#8.0）&lt;/li&gt;
&lt;li&gt;弃元模式 (C#8.0)&lt;/li&gt;
&lt;li&gt;元组模式（C#8.0）&lt;/li&gt;
&lt;li&gt;位置模式（C#8.0）&lt;/li&gt;
&lt;li&gt;关系模式（C#9.0）&lt;/li&gt;
&lt;li&gt;逻辑模式（C#9.0）
&lt;ul&gt;&lt;li&gt;否定模式（C#9.0）&lt;/li&gt;
&lt;li&gt;合取模式（C#9.0）&lt;/li&gt;
&lt;li&gt;析取模式（C#9.0）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;括号模式（C#9.0）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;后面内容，我们就以上这些模式以下面几个类型为基础进行写示例进行说明。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;public readonly struct Point
{
    public Point(int x, int y) =&amp;gt; (X, Y) = (x, y);
    public int X { get; }
    public int Y { get; }
    public void Deconstruct(out int x, out int y) =&amp;gt; (x, y) = (X, Y);
}

public abstract record Shape():IName
{
    public string Name =&amp;gt;this.GetType().Name;
}

public record Circle(int Radius) : Shape,ICenter
{
    public Point Center { get; init; }
}

public record Square(int Side) : Shape;

public record Rectangle(int Length, int Height) : Shape;

public record Triangle(int Base, int Height) : Shape
{
    public void Deconstruct(out int @base, out int height) =&amp;gt; (@base, height) = (Base, Height);
}

interface IName
{
    string Name { get; }
}

interface ICenter
{
    Point Center { get; init; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-各模式介绍与示例&quot;&gt;2 各模式介绍与示例&lt;/h2&gt;
&lt;h3 id=&quot;21-常量模式&quot;&gt;2.1 常量模式&lt;/h3&gt;
&lt;p&gt;常量模式是用来检查输入表达式的结果是否与指定的常量相等，这就像C#6.0之前switch语句支持的常量模式一样，自C#7.0开始，也支持is语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;expr is constant
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里expr是输入表达式，constant是字面常量、枚举常量或者const定义常量变量这三者之一。如果expr和constant都是整型类型，那么实质上是用expr == constant来决定两者是否相等；否则，表达式的值通过静态函数Object.Equals(expr, constant)来决定。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;var circle = new Circle(4);

if (circle.Radius is 0)
{
    Console.WriteLine(&quot;This is a dot not a circle.&quot;);
}
else
{
    Console.WriteLine($&quot;This is a circle which radius is {circle.Radius}.&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22-null模式&quot;&gt;2.2 null模式&lt;/h3&gt;
&lt;p&gt;null模式是个特殊的常量模式，它用于检查一个对象是否为空。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;expr is null
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，如果输入表达式expr是引用类型时，expr is null表达式使用(object)expr == null来决定其结果；如果是可空值类型时，使用Nullable.HasValue来决定其结果.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;Shape shape = null;

if (shape is null)
{
    Console.WriteLine(&quot;shape does not have a value&quot;);
}
else
{
    Console.WriteLine($&quot;shape is {shape}&quot;);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-类型模式&quot;&gt;2.3 类型模式&lt;/h3&gt;
&lt;p&gt;类型模式用于检测一个输入表达式能否转换成指定的类型，如果能，把转换好的值存放在指定类型定义的变量里。 在is表达式中形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;expr is type variable
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中expr表示输入表达式，type是类型或类型参数名字，variable是类型type定义的新本地变量。如果expr不为空，通过引用、装箱或者拆箱能转化为type或者满足下面任何一个条件，则整个表达式返回值为true，并且expr的转换结果被赋给变量variable。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;expr是和type一样类型的实例&lt;/li&gt;
&lt;li&gt;expr是从type派生的类型的实例&lt;/li&gt;
&lt;li&gt;expr的编译时类型是type的基类，并且expr有一个运行时类型，这个运行时类型是type或者type的派生类。编译时类型是指声明变量是使用的类型，也叫静态类型；运行时类型是定义的变量中具体实例的类型。&lt;/li&gt;
&lt;li&gt;expr是实现了type接口的类型的实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果expr是true并且is表达式被用在if语句中，那么variable本地变量仅在if语句内被分配空间进行赋值，本地变量的作用域是从is表达式到封闭包含if语句的块的结束位置。&lt;/p&gt;
&lt;p&gt;需要注意的是：声明本地变量的时候，type不能是可空值类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;Shape shape = new Square(5);
if (shape is Circle circle)
{
    Console.WriteLine($&quot;This shape is a {circle.Name} with radius equal to {circle.Radius}&quot;);
}
else
{
    Console.WriteLine(circle.Radius);//错误，使用了未赋值的本地变量
    circle = new Circle(6);
    Console.WriteLine($&quot;A new {circle.Name} with radius equal to {circle.Radius} is created now.&quot;);
}

//circle变量还处于其作用域内，除非到了封闭if语句的代码块结束的位置。
if (circle is not null &amp;amp;&amp;amp; circle.Radius is 0)
{
    Console.WriteLine(&quot;This is a dot not a circle.&quot;);
}
else
{
    Console.WriteLine($&quot;This is a circle which radius is {circle.Radius}.&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的包含类型模式的if语句块部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Circle circle)
{
    Console.WriteLine($&quot;This shape is a {circle.Name} with radius equal to {circle.Radius}&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与下面代码是等效的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;var circle = shape as Circle;

if (circle != null)
{
    Console.WriteLine($&quot;This shape is a {circle.Name} with radius equal to {circle.Radius}&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看出，应用类型模式匹配，使得程序代码更为紧凑简洁。&lt;/p&gt;
&lt;h3 id=&quot;24-属性模式&quot;&gt;2.4 属性模式&lt;/h3&gt;
&lt;p&gt;属性模式使你能访问对象实例的属性或者字段来检查输入表达式是否满足指定标准。与is表达式结合使用的基本形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;expr is type {prop1:value1,prop2：value2,...} variable
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该模式先检查expr的运行时类型是否能转化成类型type，如果不能，这个模式表达式返回false；如果能，则开始检查其中属性或字段的值匹配，如果有一个不相符，整个匹配结果就为false；如果都匹配，则将expr的对象实例赋给定义的类型为type的本地变量variable。&lt;br/&gt;其中，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type可以省略，如果省略，则type使用expr的静态类型；&lt;/li&gt;
&lt;li&gt;属性中的value可以为常量、var模式、关系模式或者组合模式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面例子用于检查shape是否是为高和宽相等的长方形，如果是，将其值赋给用Rectangle定义的本地变量rect中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Rectangle { Length: var l,Height:var w } rect &amp;amp;&amp;amp; l == w)
{
    Console.WriteLine($&quot;This is a square&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性模式是可以嵌套的，如下检查圆心坐标是否在原点位置，并且半径为100：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Circle {Radius:100, Center: {X:0,Y:0} c })
{
    Console.WriteLine(&quot;This is a circle which center is at (0,0)&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面示例与下面代码是等效的，但是采用模式匹配方式写的条件代码量更少，特别是有更多属性需要进行条件检查时，代码量节省更明显；而且上面代码还是原子操作，不像下面代码要对条件进行4次检查：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Circle circle &amp;amp;&amp;amp;
    circle.Radius == 100
    &amp;amp;&amp;amp; circle.Center.X == 0
    &amp;amp;&amp;amp; circle.Center.Y == 0)
{
    Console.WriteLine(&quot;This is a circle which center is at (0,0)&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;25-var模式&quot;&gt;2.5 var模式&lt;/h3&gt;
&lt;p&gt;将类型模式表达形式的type改为var关键字，就成了var模式的表达形式。var模式不管什么情况下，甚至是expr计算机结果为null，它都是返回true。其最大的作用就是捕获expr表达式的值，就是expr表达式的值会被赋给var后的局部变量名。局部变量的类型就是表达式的静态类型，这个变量可以在匹配的模式外部被访问使用。var模式没有null检查，因此在你使用局部变量之前必须手工对其进行null检查。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is var sh &amp;amp;&amp;amp; sh is not null)
{
    Console.WriteLine($&quot;This shape's name is {sh.Name}.&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将var模式和属性模式相结合，捕获属性的值。示例如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Square { Side: var side } &amp;amp;&amp;amp; side &amp;gt; 0 &amp;amp;&amp;amp; side &amp;lt; 100)
{
    Console.WriteLine($&quot;This is a square which side is {side} and between 0 and 100.&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;26-弃元模式&quot;&gt;2.6 弃元模式&lt;/h3&gt;
&lt;p&gt;弃元模式是任何表达式都可以匹配的模式。弃元不能当作常量或者类型直接用于is表达式，它一般用于元组、switch语句或表达式。例子参见2.7和4.3相关的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;var isShape = shape is _; //错误
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;27-元组模式&quot;&gt;2.7 元组模式&lt;/h3&gt;
&lt;p&gt;元组模式将多个值表示为一个元组，用来解决一些算法有多个输入组合这种情况。如下面的例子结合switch表达式，根据命令和参数值来创建指定图形：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;Shape Create(int cmd, int value1, int value2) =&amp;gt; (cmd,value1,value2) switch {
    (0,var v,_)=&amp;gt;new Circle(v),
    (1,var v,_)=&amp;gt;new Square(v),
    (2,var l,var h)=&amp;gt;new Rectangle(l,h),
    (3,var b,var h)=&amp;gt;new Triangle(b,h),
    (_,_,_)=&amp;gt;throw new NotSupportedException()
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是将元组模式用于is表达式的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;(Shape shape1, Shape shape2) shapeTuple = (new Circle(100),new Square(50));
if (shapeTuple is (Circle circle, _))
{
    Console.WriteLine($&quot;This shape is a {circle.Name} with radius equal to {circle.Radius}&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;28-位置模式&quot;&gt;2.8 位置模式&lt;/h3&gt;
&lt;p&gt;位置模式是指通过添加解构函数将类型对象的属性解构成以元组方式组织的离散型变量，以便你可以使用这些属性作为一个模式进行检查。&lt;/p&gt;
&lt;p&gt;例如我们给Point结构中添加解构函数Deconstruct，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;public readonly struct Point
{
    public Point(int x, int y) =&amp;gt; (X, Y) = (x, y);
    public int X { get; }
    public int Y { get; }
    public void Deconstruct(out int x, out int y) =&amp;gt; (x, y) = (X, Y);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我就可以将Point结构成不同的变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;var point = new Point(10,20);
var (x, y) = point;
Console.WriteLine($&quot;x = {x}, y = {y}&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解构函数使对象具有了位置模式的功能，使用的时候，看起来像元组模式。例如我用在is语句中例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (point is (10,_))
{
    Console.WriteLine($&quot;This point is (10,{point.Y})&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于位置型record类型，默认已经带有解构函数Deconstruct，因此可以直接使用位置模式。如果是class和struct类型，则需要自己添加解构函数Deconstruct。我们也可以用扩展方法给一些类型添加解构函数Deconstruct。&lt;/p&gt;
&lt;h3 id=&quot;29-关系模式&quot;&gt;2.9 关系模式&lt;/h3&gt;
&lt;p&gt;关系模式用于检查输入是否满足与常量进行比较的关系约束。形式如： op constant&lt;br/&gt;其中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;op表示操作符，关系模式支持二元操作符：&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt;=&lt;/li&gt;
&lt;li&gt;constant是常量，其类型只要是能支持上述二元关系操作符的内置类型都可以，包括sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, nint和 nuint。&lt;/li&gt;
&lt;li&gt;op的左操作数将做为输入，其类型与常量类型相同，或者能够通过拆箱或者显式可空类型转换为常量类型。如果不存在转换，则编译时会报错；如果存在转换，但是转换失败，则模式不匹配；如果相同或者能转换成功，则其值或转换的值与常量开始进行关系操作运算，该运算结果就是关系模式匹配的结果。由此可见，左操作数可以为dynamic,object，可空值类型，var类型及和constant相同的基本类型等。&lt;/li&gt;
&lt;li&gt;常量不能是null；&lt;/li&gt;
&lt;li&gt;double.NaN或float.NaN虽是常量，但不是数字，是不受支持的。&lt;/li&gt;
&lt;li&gt;该模式可用在is，which语句和which表达式中。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;int? num1 = null;
const int low = 0;
if (num1 is &amp;gt;low)
{
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关系模式与逻辑模式进行结合，功能就会更加强大，帮助我们处理更多的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;int? num1 = null;
const int low = 0;
double num2 = double.PositiveInfinity;
if (num1 is &amp;gt;low and &amp;lt;int.MaxValue &amp;amp;&amp;amp; num2 is &amp;lt;double.PositiveInfinity)
{
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;210-逻辑模式&quot;&gt;2.10 逻辑模式&lt;/h3&gt;
&lt;p&gt;逻辑模式用于处理多个模式间逻辑关系，就像逻辑运算符!、&amp;amp;&amp;amp;和||一样，优先级顺序也是相似的。为了避免与表达式逻辑操作符引起混淆，模式操作符采用单词来表示。他们分别为not、and和or。逻辑模式为多个基本模式进行组合提供了更多可能。&lt;/p&gt;
&lt;h4 id=&quot;2101-否定模式&quot;&gt;2.10.1 否定模式&lt;/h4&gt;
&lt;p&gt;否定模式类似于!操作符，用来检查与指定的模式不匹配的情况。它的关键字是not。例如null模式的否定模式就是检查输入表达式不为null.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is not null)
{
    // 当shape不为null时的代码逻辑
    Console.WriteLine($&quot;shape is {shape}.&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码我们将否定模式与null模式组合了起来，实现了与下面代码等效的功能，但是易读性更好。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (!(shape is null))
{
    // 当shape不为null时的代码逻辑
    Console.WriteLine($&quot;shape is {shape}.&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以将否定模式与类型模式、属性模式、常量模式等结合使用，用于更多的场景。例如下面例子就将类型模式、属性模式、否定模式和常量模式四种组合起来检查一个图形是否是一个半径不为零的圆。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Circle { Radius: not 0 })
{
    Console.WriteLine(&quot;shape is not a dot but a Circle&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面示例判断一个shape如果不是Circle时执行一段逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is not Circle circle)
{
    Console.WriteLine(&quot;shape is not a Circle&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：上面这段代码，如果if判断条件为true的话，那么circle的值为null，不能在if语句块中使用，但为false时，circle不为null，即使在if语句块中得到了使用，但也得不到执行，只能在if语句后面使用。&lt;/p&gt;
&lt;h4 id=&quot;2102-合取模式&quot;&gt;2.10.2 合取模式&lt;/h4&gt;
&lt;p&gt;类似于逻辑操作符&amp;amp;&amp;amp;，合取模式就是用and关键词连接两个模式，要求他们都同时匹配。&lt;br/&gt;以前，我们检查一个对象是否是边长位于（0，100）之间的正方形时，会有如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Square)
{
    var square = shape as Square;

    if (square.Side &amp;gt; 0 &amp;amp;&amp;amp; square.Side &amp;lt; 100)
    {
        Console.WriteLine($&quot;This shape is a square with a side {square.Side}&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，我们可以用模式匹配将上述逻辑描述为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Square { Side: &amp;gt; 0 and &amp;lt; 100 } square)
{
    Console.WriteLine($&quot;This shape is a square with a side {square.Side}&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们将一个类型模式、一个属性模式、一个合取模式、两个关系模式和两个常量模式进行组合。两段同样效果的代码，明显模式匹配代码量更少，没了square.Side的重复出现，更为简洁易懂。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;and要用于两个类型模式之间，则两个类型必须有一个是接口，或者都是接口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;shape is Square and Circle // 编译错误
shape is Square and IName // Ok
shape is IName and ICenter // OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;and不能用在一个没有关系模式的属性模式中，&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;shape is Circle { Radius: 0 and 10 } // 编译错误
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;and不能用在两个属性模式之间，因为这已经隐式实现了&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;shape is Triangle { Base: 10 and Height: 20 } // 编译错误
shape is Triangle { Base: 10 , Height: 20} // OK，是上一句要实现的效果
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2103-析取模式&quot;&gt;2.10.3 析取模式&lt;/h4&gt;
&lt;p&gt;类似于逻辑操作符||，析取模式就是用or关键词连接两个模式，要求两个模式中有一个能匹配就算匹配成功。&lt;/p&gt;
&lt;p&gt;例如下面代码用来检查一个图形是否是边长小于20或者大于60的有效的正方形：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Square { Side: &amp;gt;0 and &amp;lt; 20 or &amp;gt; 60 } square)
{
    Console.WriteLine($&quot;This shape is a square with a side {square.Side}&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们组合运用了类型模式、属性模式、合取模式、析取模式、关系模式和常量模式这六个模式来完成条件判断。看起来很简洁，这个如果用C#9.0之前的代码实现如下，繁琐很多，并且square.Side有重复出现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Square)
{
    var square = shape as Square;

    if (square.Side &amp;gt; 0 &amp;amp;&amp;amp; square.Side &amp;lt; 20 || square.Side&amp;gt;60)
    {
        Console.WriteLine($&quot;This shape is a square with a side {square.Side}&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;or 可以放在两个类型之间，但是不支持捕捉输入表达式的值存到定义的局部变量里；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;shape is Square or Circle // OK
shape is Square or Circle smt // 编译错误，不支持捕捉
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;or 可以放在一个没有关系模式的属性模式中，同时支持捕捉输入表达式的值存到定义的局部变量里&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;shape is Square { Side: 0 or 1 } sq // OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;or 不能用于同一对象的两个属性之间&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;shape is Rectangle { Height: 0 or Length: 0 } // 编译错误
shape is Rectangle { Height: 0 } or Rectangle { Length: 0 } // OK，实现了上一句想实现的目标
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;211-括号模式&quot;&gt;2.11 括号模式&lt;/h3&gt;
&lt;p&gt;有了以上各种模式及其组合后，就牵扯到一个模式执行优先级顺序的问题，括号模式就是用来改变模式优先级顺序的，这与我们表达式中括号的使用是一样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape is Square { Side: &amp;gt;0 and (&amp;lt; 20 or &amp;gt; 60) } square)
{
    Console.WriteLine($&quot;This shape is a square with a side {square.Side}&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-其他&quot;&gt;3 其他&lt;/h2&gt;
&lt;p&gt;有了模式匹配，对于是否为null的判断检查，就显得丰富多了。下面这些都可以用于判断不为null的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;if (shape != null)...
if (!(shape is null))...
if (shape is not null)...
if (shape is {})...
if (shape is {} s)...
if (shape is object)...
if (shape is object s)...
if (shape is Shape s)...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-switch语句与表达式中的模式匹配&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwNjcyNTU2Ng==&amp;amp;mid=2247483816&amp;amp;idx=1&amp;amp;sn=ee2e74ece4f5b69620ce50fae8b3072a&amp;amp;chksm=9b084b79ac7fc26f0d3ccf4440c23b531ff48fd97b9d0b24a5f8fd73db6e50382c3cb80f77fb&amp;amp;scene=178&amp;amp;cur_album_id=1612459507345899521#rd&quot; target=&quot;_blank&quot;&gt;4&lt;/a&gt; switch语句与表达式中的模式匹配&lt;/h2&gt;
&lt;p&gt;说到模式匹配，就不得不提与其紧密关联的switch语句、switch表达式和when关键字。&lt;/p&gt;
&lt;h3 id=&quot;41-when关键字&quot;&gt;4.1 when关键字&lt;/h3&gt;
&lt;p&gt;when关键字是在上下文中用来进一步指定过滤条件。只有当过滤条件为真时，后面语句才得以执行。&lt;/p&gt;
&lt;p&gt;被用到的上下文环境有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常用在try-catch或者try-catch-finally语句块的catch语句中&lt;/li&gt;
&lt;li&gt;用在switch语句的case标签中&lt;/li&gt;
&lt;li&gt;用在switch表达式中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里，我们重点介绍后面两者情况，有关在catch中的应用，如有不清楚的可以查阅相关资料。&lt;/p&gt;
&lt;p&gt;在switch语句的when的使用语法如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;case (expr) when (condition):&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里，expr是常量或者类型模式，condition是when的过滤条件，可以是任何的布尔表达式。具体示例见后面switch语句中的例子。&lt;/p&gt;
&lt;p&gt;在switch表达式中when的应用与switch类似，只不过case和冒号被用=&amp;gt;替代而已。具体示例见switch语句表达式。&lt;/p&gt;
&lt;h3 id=&quot;42-switch语句&quot;&gt;4.2 switch语句&lt;/h3&gt;
&lt;p&gt;自C#7.0之后，switch语句被改造且功能更为强大。变化有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持任何类型&lt;/li&gt;
&lt;li&gt;case可以用表达式，不再局限于常量&lt;/li&gt;
&lt;li&gt;支持匹配模式&lt;/li&gt;
&lt;li&gt;支持when关键字进一步限定case标签中的表达式&lt;/li&gt;
&lt;li&gt;case之间不再相互排斥，因而case的顺序很重要，执行匹配了第一个分支，后面分支都会被跳过。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面方法用于计算指定图形的面积。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;static int ComputeArea(Shape shape)
{
    switch (shape)
    {
        case null:
            throw new ArgumentNullException(nameof(shape));

        case Square { Side: 0 }:
        case Circle { Radius: 0 }:
        case Rectangle rect when rect is { Length: 0 } or { Height: 0 }:
        case Triangle { Base: 0 } or Triangle { Height: 0 }:
            return 0;

        case Square { Side:var side}:
            return side * side;
        case Circle c:
            return (int)(c.Radius * c.Radius * Math.PI);
        case Rectangle { Length:var l,Height:var h}:
            return l * h;
        case Triangle (var b,var h):
            return b * h / 2;

        default:
            throw new ArgumentException(&quot;shape is not a recognized shape&quot;,nameof(shape));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面该方法仅用于展示模式匹配多种不同可能的用法，其中计算面积为0的那一部分其实是没有必要的。&lt;/p&gt;
&lt;h3 id=&quot;43-switch表达式&quot;&gt;4.3 switch表达式&lt;/h3&gt;
&lt;p&gt;switch表达式是为在一个表达式的上下文中可以支持像switch语句那样的功能而添加的表达式。&lt;/p&gt;
&lt;p&gt;我们将4.1中的switch语句改为表达式，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;static int ComputeArea(Shape shape) =&amp;gt; shape switch 
{
    null=&amp;gt; throw new ArgumentNullException(nameof(shape)),
    Square { Side: 0 } =&amp;gt; 0,
    Rectangle rect when rect is { Length: 0 } or { Height: 0 } =&amp;gt; 0,
    Triangle { Base: 0 } or Triangle { Height: 0 } =&amp;gt; 0,
    Square { Side: var side } =&amp;gt; side*side,
    Circle c =&amp;gt; (int)(c.Radius * c.Radius * Math.PI),
    Rectangle { Length: var l, Height: var h } =&amp;gt; l * h,
    Triangle (var b, var h) =&amp;gt; b * h / 2,
    _=&amp;gt; throw new ArgumentException(&quot;shape is not a recognized shape&quot;,nameof(shape))
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上例子可以看出，switch表达式与switch语句有以下不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入参数位于switch关键字前面&lt;/li&gt;
&lt;li&gt;case和:被用=&amp;gt;替换，显得更加简练和直观&lt;/li&gt;
&lt;li&gt;default被弃元符号_替代&lt;/li&gt;
&lt;li&gt;语句体是表达式不是语句&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;switch表达式的每个分支=&amp;gt;标记后面的表达式们的最佳公共类型如果存在，并且每个分支的表达式都可以隐式转换为这个类型，那么这个类型就是switch表达式的类型。&lt;/p&gt;
&lt;p&gt;在运行情况下，switch表达式的结果是输入参数第一个匹配到的模式的分支中表达式的值。如果没有匹配到的情况，就会抛出SwitchExpressionException异常。&lt;/p&gt;
&lt;p&gt;switch表达式的各个分支情况要全面覆盖输入参数的各种值的情况，否则会报错。这也是弃元在switch表达式中用于代表不可知情况的原因。&lt;/p&gt;
&lt;p&gt;如果switch表达式中一些前面分支总是得到匹配，不能到达后面的分支话，就会出错。这就是弃元模式要放在最后分支的原因。&lt;/p&gt;
&lt;h2 id=&quot;5-为什么用模式匹配？&quot;&gt;5 为什么用模式匹配？&lt;/h2&gt;
&lt;p&gt;从前面很多例子可以看出，模式匹配的很多功能都可以用传统方法实现，那么为什么还要用模式匹配呢？&lt;/p&gt;
&lt;p&gt;首先，就是我们前面提到的模式匹配代码量少，简洁易懂，减少代码重复。&lt;/p&gt;
&lt;p&gt;再者，就是模式常量表达式在运算时是原子的，只有匹配或者不匹配两种相斥的情况。而多个连接起来的条件比较运算，要多次进行不同的比较检查。这样，模式匹配就避免了在多线程场景中的一些问题。&lt;/p&gt;
&lt;p&gt;总的来说，如果可能的话，请使用模式匹配，这才是最佳实践。&lt;/p&gt;
&lt;h2 id=&quot;6-总结&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwNjcyNTU2Ng==&amp;amp;mid=2247483816&amp;amp;idx=1&amp;amp;sn=ee2e74ece4f5b69620ce50fae8b3072a&amp;amp;chksm=9b084b79ac7fc26f0d3ccf4440c23b531ff48fd97b9d0b24a5f8fd73db6e50382c3cb80f77fb&amp;amp;scene=178&amp;amp;cur_album_id=1612459507345899521#rd&quot; target=&quot;_blank&quot;&gt;6&lt;/a&gt; 总结&lt;/h2&gt;
&lt;p&gt;这里我们回顾了所有的模式匹配，也介绍了模式匹配在switch语句和switch表达式中的使用情况，最后介绍了为什么使用模式匹配的原因。&lt;/p&gt;
&lt;h4 id=&quot;如对您有价值，请推荐，您的鼓励是我继续的动力，在此万分感谢。关注本人公众号码客风云，享第一时间阅读最新文章。&quot;&gt;如对您有价值，请推荐，您的鼓励是我继续的动力，在此万分感谢。关注本人公众号“码客风云”，享第一时间阅读最新文章。&lt;/h4&gt;
&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/markkang/1599593/o_191125074640qrcode_for_gh_ce8b314d60a0_430.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4OTA2NjY=,size_16,color_FFFFFF,t_70&quot; width=&quot;15%&quot; alt=&quot;码客风云&quot;/&gt;

</description>
<pubDate>Sun, 13 Dec 2020 23:29:00 +0000</pubDate>
<dc:creator>码客风云</dc:creator>
<og:description>自C#7.0以来，模式匹配就作为C#的一项重要的新特性在不断地演化，这个借鉴于其小弟F#的函数式编程的概念，使得C#的本领越来越多，C#9.0就对模式匹配这一功能做了进一步的增强。 为了更为深入和全面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/markkang/p/14130867.html</dc:identifier>
</item>
<item>
<title>2020年下半年总结与计划 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/14131363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/14131363.html</guid>
<description>&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;2020年到如今已经到了十二月中旬，下半年所学的东西还是挺多，我觉得学习的一个效率也是有着飞跃般的提升。主要的原因可能在于我和我的好朋友（基友）住在一个房间，互相督促学习。其次的原因是在这互相督促中基本都撸到4点左右进行学习一个新的东西。包括生活中的一些小想法或者是在安全中的一些想法。还有的一点原因是因为在后面一段时间中团队几个人一起为我们几个人学习的一个方向进行一个&lt;code&gt;头脑风暴&lt;/code&gt;，然后去定制化一些脑图。后面对应脑图疯狂学习，并且输出对应的文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202012/1993669-20201214071520729-25077522.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在学习内容中其实也会实时进行一个更新，目前也是完成大半了。&lt;/p&gt;
&lt;h2 id=&quot;0x01-絮絮叨叨&quot;&gt;0x01 絮絮叨叨&lt;/h2&gt;
&lt;p&gt;其实都知道今年并不好过，由于疫情的缘故有一个多月也是在家办公。而在这期间为我的Java学习的基础打下了一些基础。在这是将Java的一些基础其中包括JavaSE、Javaweb、以及SSM框架这些给刷了一遍。 而在疫情隔离以后，就是hvv。而在期间今年担任的是防守队，而在这期间也是学习了Java代码审计，成果是一个sql注入和两个xss。其实在这些类似于攻防演练蓝队都比较划水，大致是到4点左右没事件了，就直接打瞌睡。但是我觉得并&lt;code&gt;不能因为划水而划水&lt;/code&gt;,而我的做法是查看其他师傅们的代码审计文章，并且查询开发资料，了解一个漏洞在Java中的产生过程和关键产生漏洞的一些类。那么了解了这些后，有开发基础的情况下，就可以对一套源代码进行一个代码审计。而我后面因为条件比较苛刻，就算能审计代码，但是在审计完成后，需要对该审计出来的漏洞进行验证，需要使用到一些payload。但是在蓝队&lt;code&gt;划水&lt;/code&gt;工作中，连接的是客户的内网环境，里面会有很多监测设备，而且这些都是全内网环境，不出网。所以验证漏洞和查询资料都不能去进行一个操作，而我的解决方式是开虚拟机然后手机开启热点，虚拟机网络连接热点。&lt;/p&gt;
&lt;p&gt;我觉得这是一个很好的学习（划水）机会，得将该时间给利用起来。在这期间是将这些漏洞在Java中产生原理给理了一遍，在此为代码审计打下基础。&lt;/p&gt;
&lt;p&gt;后面发现网上很少会有Java的源代码，有一次在一次渗透中，利用信息泄露，打下的一个数据库，但是他的加密的是一个DES的加密（一开始不知道，一开始以为是AES）。查询到一些指纹信息发现他的CMS后，网上进行了一个下载，然后进行审计。开始兴致大起，下了500m的源码后才发现，这压根就不是源代码。而是编译后的class文件。当时想着既然是编译后的文件公布出来为啥不能直接打包成war包呢?但是还是得硬刚。放入JD-GUI进行反编译后，查看到伪代码，然后查询加密方式。后来是在一个他们开发中封装的jar包里面的一个工具类得到这个加密模式。因为在里面就定义了3DES的加密方式，这个方式会被插入一些数据的方法给调用，从而定位到该算法。然后拿到该密钥进行本地的解密，得到该数据结果。&lt;/p&gt;
&lt;p&gt;从中不得不说的是没有源代码，无法直接快捷的方式进行跳转，只能去进行全局搜索，然后查找调用。&lt;/p&gt;
&lt;p&gt;所以后面的重点放在了反序列化漏洞分析这块。在hvv的后面几天就在分析这个URLDNS利用链以及实际运用场景。&lt;/p&gt;
&lt;p&gt;其实在这段时间中，发现一般做这方面的分为两类人：一种是为了应付工作，一种是真正的喜欢这么一个东西，想去这方面做得更好。&lt;/p&gt;
&lt;p&gt;如果是应付工作的话，那么我觉得这是一个痛苦的。&lt;/p&gt;
&lt;p&gt;我觉得如果喜欢这么一个东西的话，就应该做得更好，再者如果喜欢的东西，变成一个工作后，难道不应该做到更好？&lt;/p&gt;
&lt;h2 id=&quot;0x02-下半年学习复盘&quot;&gt;0x02 下半年学习复盘&lt;/h2&gt;
&lt;p&gt;其实在我接触到Java是在7月份开始学习，在9月下旬左右开始进行代码审计。而我接触到Java安全领域是在10月份左右，接触的第一个知识点貌似是&lt;code&gt;ClassLoader&lt;/code&gt;类加载器。&lt;/p&gt;
&lt;p&gt;后面就是一些利用链的分析，在这里也是为我的一个漏洞调试分析奠定一个非常好的基础。由于第一个调试这些cc链，加上十月一假期，CC1这个链分析了10天，但是在后面摸清楚套路以后如鱼得水。后面就是学习了JNI、javaAgent等技术，在学习中途发现在安全中很多有意思的用途。在此先略过不讲。&lt;/p&gt;
&lt;p&gt;在期间也开发了一些小工具，如webshell管理工具，但是目前只实现了一个命令执行，传输双向加密，随机ua、gui界面功能。动态密钥AES+HEX加密&lt;/p&gt;
&lt;p&gt;最后面就是漏洞分析了，前天分析了Shiro 550 的漏洞，也是很有意思，该漏洞就是Cookie里面某字段的值，然后进行AES解密后base64解密，最后进行反序列化。而在Shiro 里面自带cc的组件。&lt;/p&gt;
&lt;p&gt;其实在Fastjson反序列化漏洞的分析也是写了一些，后面是因为各种原因，没继续去进行分析。想法是等分析完Weblogic漏洞后，在继续编写该文。&lt;/p&gt;
&lt;h2 id=&quot;0x03-计划&quot;&gt;0x03 计划&lt;/h2&gt;
&lt;h3 id=&quot;漏洞分析&quot;&gt;漏洞分析&lt;/h3&gt;
&lt;p&gt;关于明年的计划的话，其实我是想将weblogic和Fastjson反序列化漏洞和St2的表达式注入这些具有代表性的漏洞分析完成。&lt;/p&gt;
&lt;h3 id=&quot;代码审计&quot;&gt;代码审计&lt;/h3&gt;
&lt;p&gt;准备后面回去撸Java开发知识，比如SSH框架、Stringboot这些因为在之前就简单过了一遍，某些知识点可能不太了解。将代码审计的知识做一个更新。包括war包的审计这块，如果要做逆向如何更好的方式进行代码审计。&lt;/p&gt;
&lt;h3 id=&quot;工具开发&quot;&gt;工具开发&lt;/h3&gt;
&lt;p&gt;想着后面代码功底深了过后，去进行一个工具的开发，以前想实现或者是团队小伙伴提出的想法去做一个实现。具体想法在此不做赘述。比如burp的插件开发，比如一些反序列化漏洞的集合。&lt;/p&gt;
&lt;h2 id=&quot;0x04-总结&quot;&gt;0x04 总结&lt;/h2&gt;
&lt;p&gt;其实我在撸这个Java以来也是会前面有一段时间，非常非常的枯燥。但是学习中间一段时间后，发现很多有意思的点就没那么枯燥了，反而会更感兴趣。有一个不得不提的点是在学习中&lt;code&gt;不能为了学习而学习&lt;/code&gt;,因为这必然是枯燥的。比如学习到一个Java某一个类的时候，&lt;code&gt;需要思考&lt;/code&gt;该类有什么作用，实现一个什么功能，在安全领域能实现有一个什么功能。&lt;code&gt;如果不去思考，那必然也是枯燥的&lt;/code&gt;。&lt;/p&gt;
</description>
<pubDate>Sun, 13 Dec 2020 23:16:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>2020年下半年总结与计划 0x00 前言 2020年到如今已经到了十二月中旬，下半年所学的东西还是挺多，我觉得学习的一个效率也是有着飞跃般的提升。主要的原因可能在于我和我的好朋友（基友）住在一个房间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/14131363.html</dc:identifier>
</item>
<item>
<title>CentOS7搭建Hadoop-3.3.0集群手记 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/14131255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/14131255.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;这篇文章是基于&lt;code&gt;Linux&lt;/code&gt;系统&lt;code&gt;CentOS7&lt;/code&gt;搭建&lt;code&gt;Hadoop-3.3.0&lt;/code&gt;分布式集群的详细手记。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Hadoop&lt;/code&gt;中的&lt;code&gt;HDFS&lt;/code&gt;和&lt;code&gt;YARN&lt;/code&gt;都是主从架构，主从架构会有一主多从和多主多从两种架构，这里为了简化搭建集群的流程，这里使用一主多从的架构。&lt;code&gt;Hadoop&lt;/code&gt;集群中各个角色的名称如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务&lt;/th&gt;
&lt;th&gt;主节点&lt;/th&gt;
&lt;th&gt;从节点&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;HDFS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;NameNode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DataNode&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;YARN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ResourceManager&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;NodeManager&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;还有SecondaryNameNode，其实是NameNode的备用节点，定时合并和处理日志并且反馈到NameNode上。一般NameNode和SecondaryNameNode尽量不要放在同一个节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;HDFS&lt;/code&gt;服务和&lt;code&gt;YARN&lt;/code&gt;其实是分离的，一者是数据存储，另一者是资源调度，&lt;code&gt;Hadoop&lt;/code&gt;集群可以只启用&lt;code&gt;YARN&lt;/code&gt;集群做资源调度。&lt;/p&gt;
&lt;h2 id=&quot;测试集群服务器规划&quot;&gt;测试集群服务器规划&lt;/h2&gt;
&lt;p&gt;测试的&lt;code&gt;Hadoop&lt;/code&gt;集群使用了&lt;code&gt;3&lt;/code&gt;台基于&lt;code&gt;VirtualBox&lt;/code&gt;搭建的&lt;code&gt;CentOS7&lt;/code&gt;虚拟机：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;内网IP&lt;/th&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;用户&lt;/th&gt;
&lt;th&gt;虚拟磁盘空间&lt;/th&gt;
&lt;th&gt;HDFS角色&lt;/th&gt;
&lt;th&gt;YARN角色&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;192.168.56.200&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hadoop01&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hadoop&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;30GB&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;NameNode&lt;/code&gt;、&lt;code&gt;DataNode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;NodeManager&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;192.168.56.201&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hadoop02&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hadoop&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;30GB&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DataNode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;NodeManager&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;192.168.56.202&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hadoop03&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hadoop&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;30GB&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SecondaryNameNode&lt;/code&gt;、&lt;code&gt;DataNode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ResourceManager&lt;/code&gt;、&lt;code&gt;NodeManager&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;前置软件安装或者准备工作&quot;&gt;前置软件安装或者准备工作&lt;/h2&gt;
&lt;p&gt;主要包括必要的软件安装、用户创建和网络配置等等。&lt;/p&gt;
&lt;h3 id=&quot;关闭防火墙&quot;&gt;关闭防火墙&lt;/h3&gt;
&lt;p&gt;为了避免出现部分端口无法访问，内网环境下每台虚拟机都可以直接关闭防火墙：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 停止防火墙进程
systemctl stop firewalld.service

# 禁用防火墙开机启动
systemctl disable firewalld.service
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;jdk安装&quot;&gt;JDK安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;JDK&lt;/code&gt;的安装比较简单，这里过程略过。笔者使用的&lt;code&gt;JDK&lt;/code&gt;是&lt;code&gt;OpenJDK&lt;/code&gt;，版本是&lt;code&gt;1.8.0_252-b09&lt;/code&gt;，&lt;code&gt;JDK&lt;/code&gt;路径配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.252.b09-2.el7_8.x86_64
export PATH=$JAVA_HOME/bin:$PATH
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;确保集群所有机器的&lt;code&gt;JDK&lt;/code&gt;安装位置相同，并且&lt;code&gt;JDK&lt;/code&gt;版本尽可能大版本选择&lt;code&gt;8&lt;/code&gt;&lt;/strong&gt;，经过大量测试发现&lt;code&gt;Hadoop&lt;/code&gt;暂时不兼容&lt;code&gt;JDK9+&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost]# java -version
openjdk version &quot;1.8.0_252&quot;
OpenJDK Runtime Environment (build 1.8.0_252-b09)
OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这个JDK安装位置和安装包名称是不是看起来比较奇怪？没错，是笔者偷懒用yum直接安装的OpenJDK。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;修改主机名&quot;&gt;修改主机名&lt;/h3&gt;
&lt;p&gt;三个节点分别通过&lt;code&gt;hostnamectl set-hostname $hostname&lt;/code&gt;修改主机名：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 节点192.168.56.200
hostnamectl set-hostname hadoop01
reboot

# 节点192.168.56.201
hostnamectl set-hostname hadoop02
reboot

# 节点192.168.56.202
hostnamectl set-hostname hadoop03
reboot
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Connecting to 192.168.56.200:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

WARNING! The remote SSH server rejected X11 forwarding request.
Last login: Sun Dec 13 06:42:42 2020 from 192.168.56.1
[root@hadoop01 ~]# 

Connecting to 192.168.56.201:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

WARNING! The remote SSH server rejected X11 forwarding request.
Last login: Sun Dec 13 07:51:28 2020 from 192.168.56.1
[root@hadoop02 ~]#

Connecting to 192.168.56.202:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

WARNING! The remote SSH server rejected X11 forwarding request.
Last login: Sun Dec 13 07:52:01 2020
[root@hadoop03 ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改hosts文件&quot;&gt;修改hosts文件&lt;/h3&gt;
&lt;p&gt;在每个节点的&lt;code&gt;hosts&lt;/code&gt;文件具体是&lt;code&gt;/etc/hosts&lt;/code&gt;尾部添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;192.168.56.200 hadoop01
192.168.56.201 hadoop02
192.168.56.202 hadoop03
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方便后面可以直接通过主机名访问对应的机器。可以在任意一台机器用通过主机名&lt;code&gt;ping&lt;/code&gt;任意的主机名：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ping hadoop01
ping hadoop02
ping hadoop03
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加hadoop用户&quot;&gt;添加hadoop用户&lt;/h3&gt;
&lt;p&gt;添加用户的操作需要在&lt;code&gt;root&lt;/code&gt;用户下进行。添加一个用户分组、命名和密码都为&lt;code&gt;hadoop&lt;/code&gt;的用户：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;useradd hadoop
# 设置密码需要手动输入两次密码，笔者这里也暂时设定密码为hadoop
passwd hadoop
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;mkdir -p /data/hadoop&lt;/code&gt;创建一个新目录，后面的&lt;code&gt;hadoop&lt;/code&gt;相关的数据等文件都放在&lt;code&gt;/data/hadoop&lt;/code&gt;目录下。设置目录&lt;code&gt;/data/hadoop&lt;/code&gt;的拥有者为&lt;code&gt;hadoop&lt;/code&gt;用户：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;chown hadoop:hadoop /data/hadoop
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后设置&lt;code&gt;hadoop&lt;/code&gt;用户可以不输入密码直接通过&lt;code&gt;sudo su&lt;/code&gt;提升为&lt;code&gt;root&lt;/code&gt;用户：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;chmod u+w /etc/sudoers

vim /etc/sudoers

# 在sudoers文件的root用户一行后面添加下面内容并且保存
hadoop ALL=(ALL) NOPASSWD:ALL

chmod u-w /etc/sudoers
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202012/h-d-c-i-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证一下是否成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 在root用户下切换hadoop用户
su hadoop

# 在hadoop用户下无密码切换root用户
sudo su

# 效果
[root@localhost]# su hadoop
[hadoop@localhost]$ sudo su
[root@localhost]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创建hadoop用户需要在集群中每台机器操作一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;设置集群机器ssh免登&quot;&gt;设置集群机器SSH免登&lt;/h3&gt;
&lt;p&gt;设置集群机器&lt;code&gt;SSH&lt;/code&gt;免登这一步十分重要，无论是&lt;code&gt;scp&lt;/code&gt;命令去拷贝文件到各个机器，还是集群启动和通讯过程都依赖这一步。集群中每个机器都进行下面步骤操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;su hadoop&lt;/code&gt;切换到&lt;code&gt;hadoop&lt;/code&gt;用户&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ssh-keygen -t rsa&lt;/code&gt;命令，接着连按几次回车，生成公钥，执行完毕后&lt;code&gt;/home/hadoop/.ssh/&lt;/code&gt;目录下会多了一个&lt;code&gt;id_rsa.pub&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;收集集群中所有节点的&lt;code&gt;/home/hadoop/.ssh/id_rsa.pub&lt;/code&gt;内容，汇总合并成一个&lt;code&gt;authorized_keys&lt;/code&gt;文件，再拷贝该文件到所有集群节点的&lt;code&gt;/home/hadoop/.ssh/ssh&lt;/code&gt;目录下&lt;/li&gt;
&lt;li&gt;授权&lt;code&gt;chmod 700 /home/hadoop/.ssh/ &amp;amp;&amp;amp; chmod 700 /home/hadoop/ &amp;amp;&amp;amp; chmod 600 /home/hadoop/.ssh/authorized_keys&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终笔者的&lt;code&gt;/home/hadoop/.ssh/authorized_keys&lt;/code&gt;文件内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202012/h-d-c-i-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用下面的脚本替代手工操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 拷贝三个节点的RSA公钥到authorized_keys中，可以在第一个节点中执行即可
for a in {1..3}; do sudo ssh hadoop@hadoop0$a cat /home/hadoop/.ssh/id_rsa.pub &amp;gt;&amp;gt; /home/hadoop/.ssh/authorized_keys; done
# 拷贝authorized_keys到三个节点中，可以在第一个节点中执行即可
for a in {1..3}; do sudo scp /home/hadoop/.ssh/authorized_keys hadoop@hadoop0$a:/home/hadoop/.ssh/authorized_keys ; done
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202012/h-d-c-i-3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装hadoop&quot;&gt;安装Hadoop&lt;/h2&gt;
&lt;p&gt;主要在&lt;code&gt;hadoop01&lt;/code&gt;节点中安装即可，安装完毕可以通过&lt;code&gt;scp&lt;/code&gt;命令直接拷贝文件分发到不同的节点中。赋予用户&lt;code&gt;/data/hadoop&lt;/code&gt;目录的读写权限：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;su hadoop
sudo chmod -R a+w /data/hadoop
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这一步极其重要，否则容易导致运行集群的时候创建文件夹权限不足&lt;/strong&gt;。这里记住不要主动创建&lt;code&gt;Hadoop&lt;/code&gt;文件系统中的目录，否则容易导致&lt;code&gt;DataNode&lt;/code&gt;启动失败。&lt;/p&gt;
&lt;h3 id=&quot;1、解压安装&quot;&gt;1、解压安装&lt;/h3&gt;
&lt;p&gt;切换目录和用户：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;su hadoop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd /data/hadoop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下载和解压&lt;code&gt;hadoop-3.3.0&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;wget https://mirror.bit.edu.cn/apache/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz
tar -zxvf hadoop-3.3.0.tar.gz 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压完毕后，&lt;code&gt;/data/hadoop&lt;/code&gt;目录下会多了一个&lt;code&gt;hadoop-3.3.0&lt;/code&gt;文件夹。&lt;/p&gt;
&lt;h3 id=&quot;2、环境变量配置&quot;&gt;2、环境变量配置&lt;/h3&gt;
&lt;p&gt;重命名一下文件夹&lt;code&gt;mv hadoop-3.3.0 app&lt;/code&gt;，也就是最终的&lt;code&gt;HADOOP_HOME&lt;/code&gt;为&lt;code&gt;/data/hadoop/app&lt;/code&gt;，可以先提前修改一下用户配置&lt;code&gt;vim ~/.bashrc&lt;/code&gt;（&lt;strong&gt;所有节点都要添加&lt;/strong&gt;），添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.252.b09-2.el7_8.x86_64
export PATH=$JAVA_HOME/bin:$PATH
export HADOOP_HOME=/data/hadoop/app
export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刷新一下用户配置&lt;code&gt;source ~/.bashrc&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;3、查看版本&quot;&gt;3、查看版本&lt;/h3&gt;
&lt;p&gt;调用&lt;code&gt;hadoop version&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[hadoop@hadoop01 hadoop]$ hadoop version
Hadoop 3.3.0
Source code repository https://gitbox.apache.org/repos/asf/hadoop.git -r aa96f1871bfd858f9bac59cf2a81ec470da649af
Compiled by brahma on 2020-07-06T18:44Z
Compiled with protoc 3.7.1
From source with checksum 5dc29b802d6ccd77b262ef9d04d19c4
This command was run using /data/hadoop/app/share/hadoop/common/hadoop-common-3.3.0.jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就能确定&lt;code&gt;JDK&lt;/code&gt;和&lt;code&gt;Hadoop&lt;/code&gt;的位置配置没有问题，接着开始配置&lt;code&gt;Hadoop&lt;/code&gt;中的应用配置。&lt;/p&gt;
&lt;h3 id=&quot;4、hadoop配置&quot;&gt;4、Hadoop配置&lt;/h3&gt;
&lt;p&gt;配置&lt;code&gt;core-site.xml&lt;/code&gt;（具体是&lt;code&gt;/data/hadoop/app/etc/hadoop/core-site.xml&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
            &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
            &amp;lt;value&amp;gt;hdfs://hadoop01:9000&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
            &amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;
            &amp;lt;value&amp;gt;/data/hadoop/temp&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;fs.defaultFS&lt;/code&gt;：&lt;code&gt;nameNode&lt;/code&gt;的&lt;code&gt;HDFS&lt;/code&gt;协议的文件系统通信地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hadoop.tmp.dir&lt;/code&gt;：&lt;code&gt;Hadoop&lt;/code&gt;集群在工作的时候存储的一些临时文件的目录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置&lt;code&gt;hdfs-site.xml&lt;/code&gt;（具体是&lt;code&gt;/data/hadoop/app/etc/hadoop/hdfs-site.xml&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.namenode.name.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/data/hadoop/dfs/name&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/data/hadoop/dfs/data&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.secondary.http.address&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop03:50090&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;dfs.http.address&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;192.168.56.200:50070&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;dfs.namenode.name.dir&lt;/code&gt;：&lt;code&gt;NameNode&lt;/code&gt;的数据存放目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dfs.datanode.data.dir&lt;/code&gt;：&lt;code&gt;DataNode&lt;/code&gt;的数据存放目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dfs.replication&lt;/code&gt;：&lt;code&gt;HDFS&lt;/code&gt;的副本数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dfs.secondary.http.address&lt;/code&gt;：&lt;code&gt;SecondaryNameNode&lt;/code&gt;节点的&lt;code&gt;HTTP&lt;/code&gt;入口地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dfs.http.address&lt;/code&gt;：通过&lt;code&gt;HTTP&lt;/code&gt;访问&lt;code&gt;HDFS&lt;/code&gt;的&lt;code&gt;Web&lt;/code&gt;管理界面的地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置&lt;code&gt;mapred-site.xml&lt;/code&gt;（具体是&lt;code&gt;/data/hadoop/app/etc/hadoop/mapred-site.xml&lt;/code&gt;）:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.app.mapreduce.am.env&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;HADOOP_MAPRED_HOME=${HADOOP_HOME}&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;mapreduce.map.env&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;HADOOP_MAPRED_HOME=${HADOOP_HOME}&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;mapreduce.reduce.env&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;HADOOP_MAPRED_HOME=${HADOOP_HOME}&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;mapreduce.framework.name&lt;/code&gt;：选用&lt;code&gt;yarn&lt;/code&gt;，也就是&lt;code&gt;MR&lt;/code&gt;框架使用&lt;code&gt;YARN&lt;/code&gt;进行资源调度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置&lt;code&gt;yarn-site.xml&lt;/code&gt;（具体是&lt;code&gt;/data/hadoop/app/etc/hadoop/yarn-site.xml&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop03&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;yarn.resourcemanager.hostname&lt;/code&gt;：指定&lt;code&gt;ResourceManager&lt;/code&gt;所在的主机名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yarn.nodemanager.aux-services&lt;/code&gt;：指定&lt;code&gt;YARN&lt;/code&gt;集群为&lt;code&gt;MapReduce&lt;/code&gt;程序提供&lt;code&gt;Shuffle&lt;/code&gt;服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置&lt;code&gt;workers&lt;/code&gt;文件（这个文件在旧版本叫&lt;code&gt;slaves&lt;/code&gt;，因为技术政治化运动被改为&lt;code&gt;workers&lt;/code&gt;，具体是&lt;code&gt;/data/hadoop/app/etc/hadoop/workers&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;hadoop01
hadoop02
hadoop03
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，核心配置基本完成。&lt;/p&gt;
&lt;h3 id=&quot;5、分发hadoop安装包到其他节点&quot;&gt;5、分发Hadoop安装包到其他节点&lt;/h3&gt;
&lt;p&gt;重点提示三次：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有节点的&lt;code&gt;Hadoop&lt;/code&gt;安装包位置和配置信息必须一致&lt;/li&gt;
&lt;li&gt;所有节点的&lt;code&gt;Hadoop&lt;/code&gt;安装包位置和配置信息必须一致&lt;/li&gt;
&lt;li&gt;所有节点的&lt;code&gt;Hadoop&lt;/code&gt;安装包位置和配置信息必须一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在节点&lt;code&gt;hadoop01&lt;/code&gt;使用&lt;code&gt;scp&lt;/code&gt;命令进行分发：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;## 分发节点2
scp -r /data/hadoop/app hadoop@hadoop02:/data/hadoop

## 分发节点3
scp -r /data/hadoop/app hadoop@hadoop03:/data/hadoop
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6、格式化namenode&quot;&gt;6、格式化NameNode&lt;/h3&gt;
&lt;p&gt;规划中是&lt;code&gt;hadoop01&lt;/code&gt;作为&lt;code&gt;NameNode&lt;/code&gt;，在该机器下进行格式化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;hadoop namenode -format
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;格式化&lt;code&gt;NameNode&lt;/code&gt;成功的控制台日志如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202012/h-d-c-i-4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;7、启动和停止hdfs&quot;&gt;7、启动和停止HDFS&lt;/h3&gt;
&lt;p&gt;可以在任意一个节点中启动和停止&lt;code&gt;HDFS&lt;/code&gt;，为了简单起见还是在&lt;code&gt;hadoop01&lt;/code&gt;节点中操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动：&lt;code&gt;start-dfs.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;停止：&lt;code&gt;stop-dfs.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用启动命令后，控制台输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[hadoop@hadoop01 hadoop]$ start-dfs.sh 
Starting namenodes on [hadoop01]
Starting datanodes
Starting secondary namenodes [hadoop03]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;8、启动和停止yarn&quot;&gt;8、启动和停止YARN&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;YARN&lt;/code&gt;集群的启动命令必须在&lt;code&gt;ResourceManager&lt;/code&gt;节点中调用，规划中的对应角色的节点为&lt;code&gt;hadoop03&lt;/code&gt;，在该机器执行&lt;code&gt;YARN&lt;/code&gt;相关命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动：&lt;code&gt;start-yarn.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;停止：&lt;code&gt;stop-yarn.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行启动命令后，控制台输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[hadoop@hadoop03 data]$ start-yarn.sh 
Starting resourcemanager
Starting nodemanagers
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;9、查看所有节点的进程状态&quot;&gt;9、查看所有节点的进程状态&lt;/h3&gt;
&lt;p&gt;分别查看集群中所有节点的进程状态，可以直接使用&lt;code&gt;jps&lt;/code&gt;工具，具体结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[hadoop@hadoop01 hadoop]$ jps
8673 NameNode
8823 DataNode
9383 NodeManager
9498 Jps

[hadoop@hadoop02 hadoop]$ jps
4305 DataNode
4849 Jps
4734 NodeManager

[hadoop@hadoop03 data]$ jps
9888 Jps
9554 NodeManager
5011 DataNode
9427 ResourceManager
5125 SecondaryNameNode
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见进程是正常运行的。&lt;/p&gt;
&lt;h3 id=&quot;10、通过web管理界面查看集群状态&quot;&gt;10、通过WEB管理界面查看集群状态&lt;/h3&gt;
&lt;p&gt;访问入口如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;HDFS&lt;/code&gt;入口：&lt;code&gt;http://192.168.56.200:50070&lt;/code&gt;（来自于&lt;code&gt;hdfs-site.xml&lt;/code&gt;的&lt;code&gt;dfs.http.address&lt;/code&gt;配置项）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;YARN&lt;/code&gt;入口：&lt;code&gt;http://192.168.56.202:8088/cluster&lt;/code&gt;（&lt;code&gt;ResourceManager&lt;/code&gt;所在节点的&lt;code&gt;8088&lt;/code&gt;端口）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数据节点状态如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202012/h-d-c-i-5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YARN&lt;/code&gt;集群状态如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202012/h-d-c-i-6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用hadoop&quot;&gt;使用Hadoop&lt;/h2&gt;
&lt;p&gt;通过几个简单的例子尝试使用&lt;code&gt;Hadoop&lt;/code&gt;集群。&lt;/p&gt;
&lt;h3 id=&quot;创建目录和展示目录&quot;&gt;创建目录和展示目录&lt;/h3&gt;
&lt;p&gt;测试一下创建目录和展示目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[hadoop@hadoop01 hadoop]$ hadoop fs -mkdir -p /test
[hadoop@hadoop01 hadoop]$ hadoop fs -ls /
Found 1 items
drwxr-xr-x   - hadoop supergroup          0 2020-12-13 10:55 /test
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上传和下载文件&quot;&gt;上传和下载文件&lt;/h3&gt;
&lt;p&gt;创建一个&lt;code&gt;words.txt&lt;/code&gt;，写入内容并且上传到上一小节创建的&lt;code&gt;test&lt;/code&gt;文件夹中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cd /data/hadoop
touch words.txt
echo 'hello world' &amp;gt;&amp;gt; words.txt
hadoop fs -put words.txt /test
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;HDFS&lt;/code&gt;的&lt;code&gt;WEB&lt;/code&gt;界面中查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202012/h-d-c-i-7.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载该文件到&lt;code&gt;/data/hadoop/download.txt&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[hadoop@hadoop01 hadoop]$ hadoop fs -get /test/words.txt /data/hadoop/download.txt &amp;amp;&amp;amp; \
cat /data/hadoop/download.txt
hello world
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;执行wordcount程序&quot;&gt;执行WordCount程序&lt;/h3&gt;
&lt;p&gt;上传一个文件到&lt;code&gt;HDFS&lt;/code&gt;的&lt;code&gt;/test/input&lt;/code&gt;目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cd /data/hadoop &amp;amp;&amp;amp; \
hadoop fs -mkdir -p /test/input &amp;amp;&amp;amp; \
touch words-input.txt &amp;amp;&amp;amp; \
echo 'hello world' &amp;gt;&amp;gt; words-input.txt &amp;amp;&amp;amp; \
echo 'hello java' &amp;gt;&amp;gt; words-input.txt &amp;amp;&amp;amp; \
echo 'hello hadoop' &amp;gt;&amp;gt; words-input.txt &amp;amp;&amp;amp; \
hadoop fs -put words-input.txt /test/input
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自带的例子在目录&lt;code&gt;/data/hadoop/app/share/hadoop/mapreduce&lt;/code&gt;的&lt;code&gt;hadoop-mapreduce-examples-3.3.0.jar&lt;/code&gt;中，通过命令运行&lt;code&gt;WordCount&lt;/code&gt;程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;hadoop jar /data/hadoop/app/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.0.jar wordcount /test/input /test/output
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MR&lt;/code&gt;的执行过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202012/h-d-c-i-8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;code&gt;YARN&lt;/code&gt;管理界面对应的&lt;code&gt;Job&lt;/code&gt;状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202012/h-d-c-i-9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可知任务最终的执行状态为成功。最后可以通过&lt;code&gt;hadoop fs -cat&lt;/code&gt;命令查看结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[hadoop@hadoop01 hadoop]$ hadoop fs -ls /test/output
Found 2 items
-rw-r--r--   3 hadoop supergroup          0 2020-12-13 11:19 /test/output/_SUCCESS
-rw-r--r--   3 hadoop supergroup         32 2020-12-13 11:19 /test/output/part-r-00000
[hadoop@hadoop01 hadoop]$ hadoop fs -cat /test/output/part-r-00000
hadoop  1
hello   3
java    1
world   1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文花了大量时间详细记录了如何从零开始搭建一个&lt;code&gt;Hadoop&lt;/code&gt;集群，基于此才能进一步学习和使用&lt;code&gt;Hadoop&lt;/code&gt;生态中的组件如&lt;code&gt;Hive&lt;/code&gt;、&lt;code&gt;Sqoop&lt;/code&gt;和&lt;code&gt;Hbase&lt;/code&gt;等等，后续会逐个击破。&lt;/p&gt;
&lt;p&gt;（本文完 c-2-d e-a-20201213）&lt;/p&gt;
</description>
<pubDate>Sun, 13 Dec 2020 16:41:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 这篇文章是基于Linux系统CentOS7搭建Hadoop-3.3.0分布式集群的详细手记。 基本概念 Hadoop中的HDFS和YARN都是主从架构，主从架构会有一主多从和多主多从两种架构，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/14131255.html</dc:identifier>
</item>
<item>
<title>冬季里有温度的 3D 可视化智慧供热系统 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/14121743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/14121743.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202012/1496396-20201211174712406-190087532.gif&quot; class=&quot;desc_img&quot;/&gt;随着供暖季来临，我国北方大部分省市开始陆续供热。一年一度的供暖问题被提上了日程。在我们的印象里，供热的设施不论是锅炉、管道还是暖气片，都是坚硬的钢铁、铸铁。HT 通过自主研发的强大的基于 HTML5 的 2D、3D 渲染引擎，运用丰富的 2D/3D 组态，给它们装上了“触角”，接通了“血脉”，装上了“大脑”，数字孪生一个智慧供热全流程系统，助力城市供热信息化升级改造，深挖热力大数据价值。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;151.23529411765&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;随着供暖季来临，我国北方大部分省市开始陆续供热。一年一度的供暖问题被提上了日程。在我们的印象里，供热的设施不论是锅炉、管道还是暖气片，都是坚硬的钢铁、铸铁。&lt;strong&gt;HT&lt;/strong&gt; 通过自主研发的强大的基于 HTML5 的 2D、3D 渲染引擎，运用丰富的 2D/3D 组态，给它们装上了“触角”，接通了“血脉”，装上了“大脑”，数字孪生一个智慧供热全流程系统，助力城市供热信息化升级改造，深挖热力大数据价值。&lt;/p&gt;

&lt;p&gt;随着集中供热普及率的上升，北方地区供暖能耗逐年增大。我国单位住宅建设供暖能耗是相同维度的发达国家的3倍。而在传统供热模式下，机组自动化水平低、多依靠人工调控，导致供热量与热需求无法准确匹配，暴露出了能源浪费与环境污染的问题。面临多方压力的传统供热行业正积极寻求破局。近年来，以互联网、大数据、云计算、人工智能等为代表的新一代信息技术迅猛发展，正加速向各领域广泛渗透，推动着传统产业转型升级。作为传统行业的供热行业仍处于一种“春秋战国、群雄逐鹿”的格局，而在国家政策以及用户、企业的各方面的诉求下，智慧供暖已成为一种潮流。&lt;/p&gt;

&lt;p&gt;要开拓市场空间，降低供热成本，提高企业利润水平，技术和先进管理的提升必不可少。&lt;/p&gt;


&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;界面简介与效果预览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;界面分为数据面板（2D）和热网（3D）两个部分：&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202012/1496396-20201211174712406-190087532.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;随着画面初始化后，映入眼帘的是图扑可视化技术对整个城市进行的模拟仿真，整座城市被一条水路一分为二，主干道的车流汇聚成迷幻的霓虹。随后，火电厂大楼亮起自上而下的光环，象征着供热系统开始工作，热力通向城市各个角落的换热站，开始了对这个城市的供热服务。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据面板&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到界面右侧数据面板非常直观且详细地记录了坐标、天气情况、日期、供热详情及减排节约量的数据。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117171154667-327142820.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;系统分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;除了对整个城市的外观进行 3D 模拟仿真，我们对每一级的热网支线单位内部进行了细致的、高还原度的仿真展示。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;火电厂&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;火电厂是热力来源，我们可以称其为热源厂。我们可以观察到，这座建筑是在城市的边缘，有3条供热管道从这里出发，分别从左、中、右三个方向，每条管道上连接着加压站、隔压站、1级换热站、2级换热站，分布在城市的各个角落，供热覆盖的范围不重合。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117170245459-1544538796.gif&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;

&lt;p&gt;室内：分为两部分，由办公区域和设备区域组成。&lt;/p&gt;
&lt;p&gt;办公区域为整个供热系统的调度中心，HT的智慧供热全流程系统就将在这里进行工作。&lt;/p&gt;
&lt;p&gt;设备区域为汽轮机，其以蒸汽为动力，并以蒸汽的热能转化为机械功的旋转机械，它在火电厂中应用的最广泛的原动机。&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117170304064-1491094778.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;加压站&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在大型供热系统中,为了使热网既能满足末端用户的供热需求,同时还能最大限度地节约系统的运行能耗,在热网中增设加压站是常用的措施。加压站是供热系统的“心脏”，为热水在热源厂和热力站之间的流动提供动力。心脏让我们的血液在全身顺利循环输送养分，供热也是一样，需要在加压站的帮助下让热水循环输送热量。我们对加压站的外观进行了高亮处理，以显示其在整个热网的重要性。&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117170335323-1175383563.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;室内：加压站内部由水箱、软水装置、水泵等设备组成，热源厂来多少水，加压站就需要回送多少水，所以加压站的运作是否正常，直接决定热源站是否有足够的热送给用户，因此，加压站24小时必须确保正常运转。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117170400532-1394030267.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;隔压站&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;目前城市存在地势高差过大的情况，低处用户如果不经隔压换热站直接使用热力管网，管道压力过大，无法正常使用统一的热力管网，为解决低处用户的承压，需设置隔压站。&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117170426220-1999844150.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;室内：主要由换热器、循环水泵、集水罐、去污器和分水罐等设备组成，二次网回水时首先进去集水灌，经去污器去污后，有循环水泵进去换热器中，与二次网回水进行热交换，交换后的热水进去分水灌中进行二次网供水，换热后的一次网回水回到热电厂循环使用。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117170440837-1099094984.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;换热站&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;换热站是城市集中供热系统中热网与用户的连接站，其作用是根据热网工况和用户的不同条件，采用不同的连接方式，将热网输送的供热介质加以调节、转换，向用户系统分配，以满足用户需要，并集中计量、检测供热介质的数量和参数。为了将热力充分供应到每位用户的家中，这里的换热站设置了两个级别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1级换热站&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117170459931-736405420.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2级换热站&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们把鼠标移到2级换热站时，可以看到换热站所服务的辐射范围，这样我们就可以直观地看到热站的地理位置，同时也能对热站运行期间的工作运行情况进行实时监控，以及可以确保该区域的换热站运行故障可以得到及时的管控和检修，保障运行安全。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117170517697-255805443.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;室内：由换热器、热泵、水箱、分汽缸等设备组成，热水通过市政管道把蒸汽（热水）输送到换热站的分汽缸，在通过分汽缸输送到每套换热机组作为换热机组的一次热源，热水做为一次热源时需要回流到供热中心，形成一个闭式循环，持续供热。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201117170547716-1519849115.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;26&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;实现价值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;智慧供热系统的功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;HT 自主研发的智慧供热全流程系统以网络化、信息化、智能化的数字技术与供热设施的深度融合为基础，以节能、降耗、节费为出发，为供热企业量身定做三维可视化系统。可实现：&lt;/p&gt;
&lt;p&gt;1、可实现管网到热用户的整个供热系统的监控；&lt;/p&gt;
&lt;p&gt;2、可实现整个供热系统的过程管理和运行管理，提高了供热系统的管理效率，实现供热系统的整体节能；&lt;/p&gt;
&lt;p&gt;3、实现远程监控、无人值守，通过远程智慧控制，只需在调度中心就能实现均衡输送、精确调节，并能及时发现管网漏损情况，及时止损；&lt;/p&gt;
&lt;p&gt;4、实现自动反馈生产运行大数据，精准预测未来时段所需参数，形成生产分析报告，给网上各热源分配供给量及运行参数提供指导值，并实现在复杂工况下热源切换的无缝对接，大大降低热源切换给热用户带来的影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HT&lt;/strong&gt; 以最低成本、最高效率，最大限度满足热用户的需求，推动能源利用的高效化与节约化，最大程度实现了供热节能目标。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该系统以信息化、自动化、智能化为基础，可以完全取代粗放式、低效率的现场人工调节的传统运营模式；可以在供热期间，通过系统实时监视各热网支线的运行参数，及时对生产运行情况进行分析、管控。提高工人生产的精细化管理，实现快速响应、快速处理、业务全流程监管，提升了服务口碑，以达到良好的社会效益。三维可视化系统更接近于现实中的真实的楼宇、设备，用户易于接受；可以让用户看到系统整体的同时，还能观测局部细节数据，兼顾整体与细节。可以提供丰富的人机交互手段，便于操作。&lt;/p&gt;

&lt;p&gt;本项目所有效果均采用 HT 提供的 api 进行代码开发。感兴趣的小伙伴也可以上官网查询更多案例。&lt;/p&gt;



&lt;/div&gt;</description>
<pubDate>Sun, 13 Dec 2020 15:51:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 随着供暖季来临，我国北方大部分省市开始陆续供热。一年一度的供暖问题被提上了日程。在我们的印象里，供热的设施不论是锅炉、管道还是暖气片，都是坚硬的钢铁、铸铁。HT&amp;#160;通过自主研发的强大的基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/14121743.html</dc:identifier>
</item>
<item>
<title>【UV统计】海量数据统计的前世今生 - ERKE</title>
<link>http://www.cnblogs.com/ERKE/p/14131067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ERKE/p/14131067.html</guid>
<description>&lt;p&gt;在互联网公司中，每个项目都需要数据统计、分析，便于项目组利用详细数据研究项目的整体情况，进行下一步的调整。在数据统计中，UV统计是最常见的，也是最普遍的。有的场景要求实时性很高，有点场景要求准确性很高，有的场景比较在意计算过程中的内存。不同的场景使用不同的算法，下面我们从0到1简单介绍下UV统计领域。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;106.6956979191&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ERKELIU/article/details/111124848&quot; target=&quot;_blank&quot;&gt;转载请注明出处&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在互联网公司中，每个项目都需要数据统计、分析，便于项目组利用详细数据研究项目的整体情况，进行下一步的调整。在数据统计中，UV统计是最常见的，也是最普遍的。有的场景要求实时性很高，有点场景要求准确性很高，有的场景比较在意计算过程中的内存。不同的场景使用不同的算法，下面我们从0到1简单介绍下UV统计领域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假设我们的场景是商家这边上架一系列水果，然后需要统计出一共上架几种水果。具体如下所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020121317564896.png&quot; width=&quot;50%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对这个问题，我们想到的最简单的方式就是利用STL中的&lt;strong&gt;set&lt;/strong&gt;处理。&lt;/p&gt;

&lt;p&gt;上架一个水果的时候，也同时在set中插入。最后需要统计的时候，直接计算set中一共有几个水果即可。具体如下所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213175316421.png&quot; width=&quot;50%&quot;/&gt;&lt;br/&gt;这种方式准确率是绝对准确的，但是这种方式耗费的内存是很大的。&lt;br/&gt;假设每个水果需要 K 字节，那么如果有 M 个水果，一共需要 K * M 字节。那么我们能不能缩小这里的内存呢？&lt;br/&gt;稍微损失一点准确率换取内存？具体见下面&lt;strong&gt;HashMap&lt;/strong&gt;的方式&lt;/p&gt;

&lt;p&gt;这种算法在上架一个水果的时候，只需要在特定的位置置1即可，而不需要存储这个位置上究竟是何种水果。然后在统计的时候，只需要统计hashmap里面有多少个1即可。具体如下所示：&lt;br/&gt;具体如下所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020121317545090.png&quot; width=&quot;50%&quot;/&gt;&lt;br/&gt;那么如果有M个水果，这里其实只需要 M / 8 字节，相比set的方式内存直接缩小到1/8。当然Hash肯定会有冲突的，所以这里肯定有一定准确率的损失。&lt;br/&gt;但是如果涉及到海量数据的UV统计，这里的内存还是很大的。&lt;br/&gt;能否用上统计学进一步缩小内存呢？具体见下面的Linear Count的方式。&lt;/p&gt;

&lt;p&gt;这种算法在上架一个水果的时候，完全跟hashmap一致，在相应位置置1。&lt;br/&gt;然后在统计的时候，利用统计学的方式，根据hashmap中零的个数给出一个估算值。具体如下所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213190150362.png&quot; width=&quot;50%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设M为哈希桶长度，那么每次上架水果，每个桶被选中的概率为：&lt;br/&gt;$$\frac{1}{M}$$&lt;br/&gt;然后在上架N个元素后，某个桶为0的概率为：&lt;br/&gt;$$(1-\frac{1}{M}) ^N$$&lt;br/&gt;所以在上架n个元素后，哈希桶中零的个数期望为：&lt;br/&gt;$$ZeroNum=\sum_{i=1}^M (1-\frac{1}{M}) ^N = M (1-\frac{1}{M}) ^N= M ((1+\frac{1}{-M})&lt;sup&gt;{-M})&lt;/sup&gt;{-\frac{N}{M}}) \approx Me^{- \frac{N}{M}}$$&lt;br/&gt;所以最终：&lt;br/&gt;$$&lt;br/&gt;N = UV = -M ln(\frac{ZeroNum}{M})&lt;br/&gt;$$&lt;/p&gt;
&lt;p&gt;所以Linear Count算法中，只需统计下hashmap中零的个数，然后代入上式即可。&lt;br/&gt;这种算法在N很小的时候，准确率是很高的，但是N很大的时候，它的准确率急剧下降。&lt;br/&gt;针对海量数据的情况，LogLog Count的算法更加鲁棒&lt;/p&gt;

&lt;p&gt;这种算法跟上面几种都不同，上架水果的时候，在相应桶里面记录的是二进制数后面最长的连续零个数。然后统计的时候，利用统计学的方式，根据存储中最长连续后缀零个数，得出一个估计值。具体如下所示：&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213213228305.png&quot; width=&quot;50%&quot;/&gt;&lt;p&gt;它的原理如下：&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213231237260.png&quot; width=&quot;80%&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201213231344824.png&quot; width=&quot;70%&quot;/&gt;&lt;p&gt;这里如果只使用一个桶来估计的话，它的误差是很大，需要用分桶平均的方式来减少它的误差。&lt;/p&gt;
&lt;h2 id=&quot;分桶平均&quot;&gt;分桶平均&lt;/h2&gt;
&lt;p&gt;既然这里利用了分桶来减少误差，那么这里统计的时候就必须合起来，这里有4种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算术平均：$$UV=\frac{\sum_{j=1}^mUV_j} { m}$$&lt;/li&gt;
&lt;li&gt;几何平均：$$UV=\sqrt[m]{UV_1...UVm}$$&lt;/li&gt;
&lt;li&gt;调和平均：$$UV=\frac{m}{\sum_{j=1}&lt;sup&gt;mUV_j&lt;/sup&gt;{-1}}$$&lt;/li&gt;
&lt;li&gt;中位数：$$UV=mediam {UV_1,...,UV_m}$$&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;LogLog Count利用的是算术平均的方式，所以最终估计值为：&lt;br/&gt;$$UV=2&lt;sup&gt;{\frac{\sum_{j=1}&lt;/sup&gt;m{UV_j}}{m}}$$&lt;/p&gt;
&lt;p&gt;这种算法对于基数大的情况下准确率挺高的，但是基数小的情况下准确率很低。&lt;/p&gt;

&lt;p&gt;这种算法跟LogLog Count 类似，有个区别点就是它在求均值的时候利用了调和平均数，而不是算术平均数。这里最终估计值为：&lt;br/&gt;$$UV=mm(\sum_{j=1}&lt;sup&gt;m{2&lt;/sup&gt;{-M_j}})^{-1}$$&lt;br/&gt;然后它还引入了分段误差修正。&lt;/p&gt;
&lt;h2 id=&quot;误差修正&quot;&gt;误差修正&lt;/h2&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/2020121323240063.png&quot; width=&quot;80%&quot;/&gt;&lt;p&gt;具体可以看我github上的代码：&lt;a href=&quot;https://github.com/lockeliu/hyperloglog&quot; target=&quot;_blank&quot;&gt;HyperLogLog&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;准确率&lt;/th&gt;
&lt;th&gt;内存&lt;/th&gt;
&lt;th&gt;耗时&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;Set&lt;/td&gt;
&lt;td&gt;绝对准确&lt;/td&gt;
&lt;td&gt;K * M&lt;/td&gt;
&lt;td&gt;O(Mlog(M))&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;很高&lt;/td&gt;
&lt;td&gt;M/8&lt;/td&gt;
&lt;td&gt;O(M)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Linear Count&lt;/td&gt;
&lt;td&gt;基数小高，基数大低&lt;/td&gt;
&lt;td&gt;M/8&lt;/td&gt;
&lt;td&gt;O(M/8)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LogLog Count&lt;/td&gt;
&lt;td&gt;基数小低，基数大高&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;HyperLogLog Count&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;</description>
<pubDate>Sun, 13 Dec 2020 15:32:00 +0000</pubDate>
<dc:creator>ERKE</dc:creator>
<og:description>在互联网公司中，每个项目都需要数据统计、分析，便于项目组利用详细数据研究项目的整体情况，进行下一步的调整。在数据统计中，UV统计是最常见的，也是最普遍的。有的场景要求实时性很高，有点场景要求准确性很高</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ERKE/p/14131067.html</dc:identifier>
</item>
<item>
<title>.Net Core Excel导入导出神器Npoi.Mapper - yi念之间</title>
<link>http://www.cnblogs.com/wucy/p/14125392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wucy/p/14125392.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;    我们在日常开发中对Excel的操作可能会比较频繁，好多功能都会涉及到Excel的操作。在.Net Core中大家可能使用Npoi比较多，这款软件功能也十分强大，而且接近原始编程。但是直接使用Npoi大部分时候我们可能都会自己封装一下，毕竟根据二八原则，我们百分之八十的场景可能都是进行简单的导入导出操作，这里就引出我们的主角Npoi.Mapper了。&lt;/p&gt;
&lt;h4 id=&quot;简介&quot;&gt;简介&lt;/h4&gt;
&lt;p&gt;    关于Npoi.Mapper看名字我们就知道，它并不是一款创新型的软件，而是针对Npoi的二次封装增强了关于Mapper相关的操作。秉承着使用非常简单的原则，不过这样能够满足我们日常开发工作中很大一部分应用场景。它的GitHub地址为&lt;a href=&quot;https://github.com/donnytian/Npoi.Mapper&quot; target=&quot;_blank&quot;&gt;https://github.com/donnytian/Npoi.Mapper&lt;/a&gt;，目前Star并不多才240多，但是确实是非常好用，这里强烈推荐一波。接下来我们就大概演示一下的它的使用。&lt;/p&gt;
&lt;h4 id=&quot;常规操作&quot;&gt;常规操作&lt;/h4&gt;
&lt;p&gt;Npoi.Mapper的主题内容包括两大块，一个是针对导入，一个是针对导出。接下来我们先来简单演示一下最基础的导入导出。首先我们新建一个Student类作为数据承载的载体，简单定义大致如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Sex { get; set; }
    public DateTime BirthDay { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后引入Npoi.Mapper的nuget包&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;&amp;lt;PackageReference Include=&quot;Npoi.Mapper&quot; Version=&quot;3.5.1&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;导出操作&quot;&gt;导出操作&lt;/h5&gt;
&lt;p&gt;接下来我们构建一个Student集合，然后初始化一部分简单的数据，将这些数据导出到Excel，接下来做一个简单的演示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;static void Main(string[] args)
{
      List&amp;lt;Student&amp;gt; students = new List&amp;lt;Student&amp;gt;
      {
          new Student{ Id = 1,Name=&quot;夫子&quot;,Sex=&quot;男&quot;,BirthDay=new DateTime(1999,10,11) },
          new Student{ Id = 2,Name=&quot;余帘&quot;,Sex=&quot;女&quot;,BirthDay=new DateTime(1999,12,12) },
          new Student{ Id = 3,Name=&quot;李慢慢&quot;,Sex=&quot;男&quot;,BirthDay=new DateTime(1999,11,11) },
          new Student{ Id = 4,Name=&quot;叶红鱼&quot;,Sex=&quot;女&quot;,BirthDay=new DateTime(1999,10,10) }
      };
      //声明mapper操作对象
      var mapper = new Mapper();
      //第一个参数为导出Excel名称
      //第二个参数为Excel数据来源
      //第三个参数为导出的Sheet名称
      //overwrite参数如果是要覆盖已存在的Excel或者新建Excel则为true，如果在原有Excel上追加数据则为false
      //xlsx参数是用于区分导出的数据格式为xlsx还是xls
      mapper.Save(&quot;Students.xlsx&quot;, students, &quot;sheet1&quot;, overwrite: true, xlsx:true);
      Console.WriteLine(&quot;执行完成&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中overwrite参数如果是要覆盖已存在的Excel或者新建Excel则为true，如果在原有Excel上追加数据则为false，说白了就是控制是新建Excel文件还是在原有基础上直接追加。xlsx参数是用于区分导出的Excel格式为xlsx还是xls。通过上述简单代码便可以实现Excel的导出功能，真的是非常简单，如果你只是进行简单的导出操作，通过Npoi.Mapper操作真的是不二的选择。这样导出的Excel效果如下所示&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202012/2042116-20201212173558297-26608046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;但是这样导出的Excel头信息为属性的名称，而且我们Student类中包含了一个时间字段BirthDay为DateTime类型，这个表示格式好像也不太符合我们常规的阅读习惯，那该怎么办呢？Npoi.Mapper为我们提供了两种处理方式，一种是通过Fluent的方式指定映射关系如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var mapper = new Mapper();
//第一个参数表示导出的列名，第二个表示对应的属性字段
mapper.Map&amp;lt;Student&amp;gt;(&quot;姓名&quot;, s =&amp;gt; s.Name)
    .Map&amp;lt;Student&amp;gt;(&quot;学号&quot;, s =&amp;gt; s.Id)
    .Map&amp;lt;Student&amp;gt;(&quot;性别&quot;, s =&amp;gt; s.Sex)
    .Map&amp;lt;Student&amp;gt;(&quot;生日&quot;, s =&amp;gt; s.BirthDay)
     //格式化操作，第一个参数表示格式，第二表示对应字段
     //Format不仅仅只支持时间操作，还可以是数字或金额等
    .Format&amp;lt;Student&amp;gt;(&quot;yyyy-MM-dd&quot;, s =&amp;gt; s.BirthDay);
mapper.Save(&quot;Students.xlsx&quot;, students, &quot;sheet1&quot;, overwrite: true, xlsx:true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过上面相关操作之后导出后的效果如下所示&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202012/2042116-20201212174400748-1520873757.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;还有一种形式是通过ColumnAttribute的形式在导出的实体类的属性上进行声明导出列相关设置，具体操作如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class Student
{
    [Column(&quot;学号&quot;)]
    public int Id { get; set; }
    [Column(&quot;姓名&quot;)]
    public string Name { get; set; }
    [Column(&quot;性别&quot;)]
    public string Sex { get; set; }
    [Column(&quot;生日&quot;,CustomFormat = &quot;yyyy-MM-dd&quot;)]
    public DateTime BirthDay { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方式操作和通过Fluent的效果是完全一样的，至于使用哪一种完全看个人喜好，不过我个人更喜欢在属性上直接声明的方式，这样看起来显得一目了然。&lt;br/&gt;有时候我们可能需要将不同的数据源导入到同一个Excel的不同Sheet中，Npoi.Mapper也提供了这方面的支持，具体操作方式如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;static void Main(string[] args)
{
      //构建Student集合
      List&amp;lt;Student&amp;gt; students = new List&amp;lt;Student&amp;gt;
      {
          new Student{ Id = 1,Name=&quot;夫子&quot;,Sex=&quot;男&quot;,BirthDay=new DateTime(1999,10,11) },
          new Student{ Id = 2,Name=&quot;余帘&quot;,Sex=&quot;女&quot;,BirthDay=new DateTime(1999,12,12) }
      };
      //构建Person集合
      List&amp;lt;Person&amp;gt; persons = new List&amp;lt;Person&amp;gt;
      {
          new Person{ Id = 1,Name=&quot;陈某&quot;, Tel= 18833445566},
          new Person{ Id = 2,Name=&quot;柯浩然&quot;, Tel = 15588997766}
      };
      var mapper = new Mapper();
      //放入Mapper中
      //第一个参数是数据集合，第二个参数是Sheet名称，第三个参数表示是追加数据还是覆盖数据
      mapper.Put&amp;lt;Student&amp;gt;(students, &quot;student&quot;,true);
      mapper.Put&amp;lt;Person&amp;gt;(persons, &quot;person&quot;,true);
      mapper.Save(&quot;Human.xlsx&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过很多时候我们是通过Web程序直接将数据转换为文件流返回的，并不会生成Excel文件，Npoi.Mapper很贴心的为我们提供了将数据读取到Stream的操作，操作方式如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[HttpGet]
public ActionResult DownLoadFile()
{
    List&amp;lt;Student&amp;gt; students = new List&amp;lt;Student&amp;gt;
    {
        new Student{ Id = 1,Name=&quot;夫子&quot;,Sex=&quot;男&quot;,BirthDay=new DateTime(1999,10,11) },
        new Student{ Id = 2,Name=&quot;余帘&quot;,Sex=&quot;女&quot;,BirthDay=new DateTime(1999,12,12) },
        new Student{ Id = 3,Name=&quot;李慢慢&quot;,Sex=&quot;男&quot;,BirthDay=new DateTime(1999,11,11) },
        new Student{ Id = 4,Name=&quot;叶红鱼&quot;,Sex=&quot;女&quot;,BirthDay=new DateTime(1999,10,10) }
    };

    var mapper = new Mapper();
    MemoryStream stream = new MemoryStream();
    //将students集合生成的Excel直接放置到Stream中
    mapper.Save(stream, students, &quot;sheet1&quot;, overwrite: true, xlsx: true);
    return File(stream.ToArray(), &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;,&quot;Student.xlsx&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Save提供了几个重载方法，其中有一个就是将数据保存到Stream中，但是这里也踩到了一个坑，不过这个是Npoi的坑并不是Npoi.Mapper的坑，那就是Workbook.Write(stream)的时候会将stream关闭，如果继续操作这个Stream会报流已关闭的错误，而Npoi.Mapper的Save到Stream的方法恰恰是对这个方法的封装，这也是为何上面我没直接在File中直接返回Stream，而是将其转换为byte数组再返回的原因。&lt;/p&gt;
&lt;h5 id=&quot;导入操作&quot;&gt;导入操作&lt;/h5&gt;
&lt;p&gt;上面我们演示了使用Npoi.Mapper将数据导出的场景，接下来我们来演示通过Npoi.Mapper的读取Excel的相关操作，操作也是非常的简单，话不多说直接上代码，比如我读取上面导出的Excel&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;//Excel文件的路径
var mapper = new Mapper(&quot;Students.xlsx&quot;);
//读取的sheet信息
var studentRows = mapper.Take&amp;lt;Student&amp;gt;(&quot;sheet1&quot;);
foreach (var row in studentRows)
{
    //映射的数据保留在value中
    Student student = row.Value;
    Console.WriteLine($&quot;姓名:[{student.Name}],学号:[{student.Id}],性别:[{student.Sex}],生日:[{student.BirthDay:yyyy-MM-dd}]&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过Take方法直接读取出来的是RowInfo集合，RowInfo是用来包装读取数据的包装类。通过它可以获取读取的行号，或读取过程中可能会出现异常情况，比如某一列读取失败，它会将列信息和报错信息记录下来，如果你不需要这些信息或者觉得遍历的时候比较麻烦想直接拿到需要的集合，可以通过如下方式转换一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var studentRows = mapper.Take&amp;lt;Student&amp;gt;(&quot;sheet1&quot;);
//通过lambda获取到Student集合
var students = studentRows.Select(i =&amp;gt; i.Value);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有的时候你可能不想定义一个POCO去接收返回的结果，而是想直接拿到读取信息，转换成你需要的数据格式。比如你想读取Excel中的数据，将结果转换为实体类直接入库，但是你不想定义一个专门的映射类去接收读取结果，这时候你需要一个动态类型去接收，而Npoi.Mapper恰恰提供了这样的功能，可以将Excel中的数据直接读取到dynamic中去，具体操作和上面类似&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var mapper = new Mapper(&quot;Students.xlsx&quot;);
var studentRows = mapper.Take&amp;lt;dynamic&amp;gt;(&quot;sheet1&quot;);
foreach (var row in studentRows)
{
    var student = row.Value;
    Console.WriteLine($&quot;姓名:[{student.姓名}],学号:[{student.学号}],性别:[{student.性别}],生日:[{student.生日:yyyy-MM-dd}]&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中你要操作的字段名称和Excel的列名是一致的，比如我的Excel列名叫姓名，那么我读取的时候对应的属性名称也叫姓名。&lt;br/&gt;同样的情况也存在于导入操作，比如许多情况下我们是通过Web接口直接上传的文件，这种场景下，我们通常能拿到上传的流信息，Npoi.Mapper也支持读取Excel文件流的形式获取Excel数据，如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[HttpPost] 
public IEnumerable&amp;lt;Student&amp;gt; UploadFile(IFormFile formFile)
{
    //通过上传文件流初始化Mapper
    var mapper = new Mapper(formFile.OpenReadStream());
    //读取sheet1的数据
    return mapper.Take&amp;lt;Student&amp;gt;(&quot;sheet1&quot;).Select(i=&amp;gt;i.Value);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;其他功能&quot;&gt;其他功能&lt;/h4&gt;
&lt;p&gt;除了上面介绍的主要功能之外Npoi.Mapper还提供了一些其他的功能，简单介绍一下几个比较实用的点&lt;/p&gt;
&lt;h5 id=&quot;忽略操作&quot;&gt;忽略操作&lt;/h5&gt;
&lt;p&gt;有时候我们的导出或导入数据可能想忽略某些列不导出，Npoi.Mapper为了我们提供了类似EF的Ignore操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[Ignore]
public string IgnoredProperty { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话无论是导入还是导出都会忽略这个属性，即导出不会显示这个列，导入不会映射这一列的数据&lt;/p&gt;
&lt;h5 id=&quot;合并单元格&quot;&gt;合并单元格&lt;/h5&gt;
&lt;p&gt;如果我们导入的数据有一列数据的值是大家都拥有的，在Excel上可以通过合并单元格的操作来显示这一列，对于合并单元格的列，对于程序来讲就是等价于所有列都是同一个值，Npoi.Mapper为我们做了这种处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[UseLastNonBlankValue]
public string ClassName { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;自定义map规则&quot;&gt;自定义Map规则&lt;/h5&gt;
&lt;p&gt;虽然默认情况下Npoi.Mapper能帮我们满足大部分的类型映射关系，但是有时候我们需要根据我们自己的规则处理处理数据映射关系，这时候我们需要用到Map功能，他有许多重载的方法，我们就查看一个比较常用的方法做参数讲解&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;/// &amp;lt;param name=&quot;columnName&quot;&amp;gt;对应Excel列的名称&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;propertyName&quot;&amp;gt;对应实体的属性名称&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;tryTake&quot;&amp;gt;该函数用于处理从Excel读取时针对单元格数据的处理&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;tryPut&quot;&amp;gt;该函数用于处理将数据导出到Excel是针对源数据的处理&amp;lt;/param&amp;gt;
public static Mapper Map&amp;lt;T&amp;gt;(this Mapper mapper, string columnName, string propertyName,
            Func&amp;lt;IColumnInfo, object, bool&amp;gt; tryTake = null,
            Func&amp;lt;IColumnInfo, object, bool&amp;gt; tryPut = null)
{
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中tryTake用于处理从Excel导出时针对单元格数据的处理，IColumnInfo代表数据的来源，object代表对应将Row导入到某个实体中。tryPut恰恰相反，用于处理将数据导出到Excel是针对源数据的处理。其中IColumnInfo代表要导出到的列信息，object代表数据的源。简单演示一下，比如我想将上述示例中，读取到Excel里的性别数据映射到实体中的时候做一下中英文的处理，就可以使用以下操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var mapper = new Mapper(&quot;Students.xlsx&quot;);
mapper.Map&amp;lt;Student&amp;gt;(&quot;性别&quot;, &quot;Sex&quot;, (c, t) =&amp;gt; {
    Student student = t as Student;
    student.Sex = c.CurrentValue == &quot;男&quot; ? &quot;MAN&quot; : &quot;WOMAN&quot;;
    return true;
}, null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我是要读取Excel，所以使用tryTake函数，t代表target表示要映射到的实体，c代表读取到的单元格信息，我将读取到target里的数据做一下处理，如果在单元格中读取的是&quot;男&quot;那么对应到Student转换为&quot;MAN&quot;，反之则为&quot;WOMAN&quot;。总之你想处理一下，自定义映射逻辑都可以使用这个功能。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;以上是我们对Npoi.Mapper的大致讲解，我个人还是非常推荐的。它的使用足够简单而且功能非常完善，因为它既可以处理Excel导入操作，也可以处理Excel导出操作。它很强大，因为它可以满足我们日常开发中，大部分关于导入导出Excel的场景。但是它还不够强大，因为它还存在一定的缺陷，而且许多细节可能还没考虑到。不过庆幸的是，它的源码非常的简单一共不到20个类，而且逻辑非常清晰。如果有的情况它真的不能满足，我们完全可以下载它的源码自己扩展操作。最后再次贴上它的GitHub地址&lt;a href=&quot;https://github.com/donnytian/Npoi.Mapper&quot; target=&quot;_blank&quot;&gt;https://github.com/donnytian/Npoi.Mapper&lt;/a&gt;如果大家有类似的场景可以尝试使用一下。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;👇欢迎扫码关注我的公众号👇&lt;/span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202006/2042116-20200622133425514-1420050576.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 13 Dec 2020 15:31:00 +0000</pubDate>
<dc:creator>yi念之间</dc:creator>
<og:description>前言 我们在日常开发中对Excel的操作可能会比较频繁，好多功能都会涉及到Excel的操作。在.Net Core中大家可能使用Npoi比较多，这款软件功能也十分强大，而且接近原始编程。但是直接使用Np</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wucy/p/14125392.html</dc:identifier>
</item>
<item>
<title>动态规划算法 - 狼爷</title>
<link>http://www.cnblogs.com/powercto/p/14131017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powercto/p/14131017.html</guid>
<description>&lt;p&gt;动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。整体框架：状态转移方程、备忘录存储重复子问题、最小子问题、求最值。斐波那契数列不算动态规划，但是解决问题的思路与动态规划很像，再加上大家上学的时候基本都接触过斐波那契数列，通过它来理解动态规划就很不错了。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;123&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133883/202012/1133883-20201213222039424-782234376.jpg&quot; alt=&quot;动态规划-爬楼梯&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。&lt;/p&gt;
&lt;p&gt;我们把要解决的一个大问题转换成若干个规模较小的同类型问题，当我们求解出这些小问题的答案，大问题便不攻自破。这就是动态规划。&lt;/p&gt;
&lt;p&gt;看一个很经典的介绍 DP 的问题：&lt;br/&gt;“How should i explain Dynamic Programming to a 4-year-old?“&lt;br/&gt;&lt;em&gt;writes down &quot;1+1+1+1+1+1+1+1 =&quot; on a sheet of paper&lt;/em&gt;&lt;br/&gt;&quot;What's that equal to?&quot;&lt;br/&gt;&lt;em&gt;counting&lt;/em&gt; &quot;Eight!&quot;&lt;br/&gt;&lt;em&gt;writes down another &quot;1+&quot; on the left&lt;/em&gt;&lt;br/&gt;&quot;What about that?&quot;&lt;br/&gt;&lt;em&gt;quickly&lt;/em&gt; &quot;Nine!&quot;&lt;br/&gt;&quot;How'd you know it was nine so fast?&quot;&lt;br/&gt;&quot;You just added one more&quot;&lt;br/&gt;&quot;So you didn't need to recount because you remembered there were eight! Dynamic Programming is just a fancy way to say 'remembering stuff to save time later'&quot;&lt;/p&gt;
&lt;p&gt;这个估计大家都能看懂，就不解释了。动态规划其实就是把要解决的一个大问题转换成若干个规模较小的同类型问题。那这里的关键在于小问题的答案，可以进行重复使用，比如经典的爬楼梯问题。&lt;/p&gt;
&lt;p&gt;这种思想的本质是：一个规模较大的问题（可以用两三个参数表示），通过若干规模较小的问题的结果来得到的（通常会寻求到一些特殊的计算逻辑，如求最值等）&lt;/p&gt;
&lt;p&gt;我们一般看到的状态转移方程，基本类似下面的公式（注：i、j、k 都是在定义DP方程中用到的参数。opt 指代特殊的计算逻辑，大多数情况下为 max 或 min。func 指代逻辑函数）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dp[i] = opt(dp[i-1])+1&lt;/li&gt;
&lt;li&gt;dp[i][j] = func(i,j,k) + opt(dp[i-1][k])&lt;/li&gt;
&lt;li&gt;dp[i][j] = opt(dp[i-1][j-1],dp[i-1][j])+arr[i][j]&lt;/li&gt;
&lt;li&gt;dp[i][j] = opt(dp[i-1][j] + xi, dp[i][j-1] + yj, ...)&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态规划是一个求最值的过程，既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。&lt;/p&gt;
&lt;p&gt;首先，动态规划的穷举有点特别，因为这类问题存在“重叠子问题”，如果暴力穷举的话效率会极其低下，所以需要“备忘录”或者“DP table”来优化穷举过程，避免不必要的计算。&lt;br/&gt;而且，动态规划问题一定会具备“最优子结构”，才能通过子问题的最值得到原问题的最值。&lt;br/&gt;最后，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的“状态转移方程”才能正确地穷举。&lt;/p&gt;
&lt;p&gt;整体框架&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态转移方程&lt;/li&gt;
&lt;li&gt;备忘录存储重复子问题&lt;/li&gt;
&lt;li&gt;最小子问题&lt;/li&gt;
&lt;li&gt;求最值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;斐波那契数列不算动态规划，但是解决问题的思路与动态规划很像，再加上大家上学的时候基本都接触过斐波那契数列，通过它来理解动态规划就很不错了。&lt;/p&gt;
&lt;p&gt;斐波那契数列的数学形式就是递归的，写成代码就是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个递归，相信有不少人能看出问题，子问题被不断计算，以N=20为例&lt;br/&gt;fib(20) = fib(19) + fib(18) = fib(18) + fib(17) + fib(18)&lt;br/&gt;写到这里，已经发现，fib(18)已经被计算多次，效率很低下。&lt;/p&gt;
&lt;p&gt;所以引入带备忘录的递归算法，把每次计算的子结果的值进行存储，后面就不需要重复计算了。整改之后的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int fib(int N) {
    int[] dp = int int[N];
    // 最小子问题
    dp[1] = dp[2] = 1;
    for (int i = 3; i &amp;lt;= N; i++) {
        // 状态转移方程
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[N];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133883/202012/1133883-20201213232040302-1275576952.png&quot; alt=&quot;斐波那契数列&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;问题：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入: &quot;babad&quot;&lt;br/&gt;输出: &quot;bab&quot;&lt;br/&gt;注意: &quot;aba&quot; 也是一个有效答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：对于一个子串而言，如果它是回文串，并且长度大于2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串“ababa”，如果我们已经知道“bab” 是回文串，那么“ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”。&lt;br/&gt;于是得到我们的状态转移方程：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;dp[i][j] 表示i到j之间的字符串是否是回文串&lt;br/&gt;dp[i][j] = dp[i+1][j-1] and (s[i] eq s[j])&lt;br/&gt;最小子问题：当s[i] eq s[j]，子串长度是2或3，不需要检查子串是否回文串，即j-i&amp;lt;=2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;public String longestPalindrome(String s) {
    if (s == null || s.length() &amp;lt;= 1) {
        return s;
    }

    int len = s.length();
    int maxLen = 1;
    int left = 0;
    int right = 0;
    boolean[][] dp = new boolean[len][len];
    char[] chars = s.toCharArray();

    // 如果i从0开始，那么对应abba这样的字符串，bb这个子串在遍历过程中没法被当做子问题进行存储
    for (int i=len-2; i&amp;gt;=0; i--) {
        for (int j=i+1; j&amp;lt;len; j++) {
            if (chars[i] == chars[j]) {
                if (j-i &amp;lt;= 2) {     // 最小字问题
                    if (j-i+1 &amp;gt; maxLen) {
                        maxLen = j-i+1;
                        left = i;
                        right = j;
                    }
                    dp[i][j] = true;
                }else if (dp[i+1][j-1]) {   // 子问题
                    if (j-i+1 &amp;gt; maxLen) {
                        maxLen = j-i+1;
                        left = i;
                        right = j;
                    }
                    dp[i][j] = true;
                }
            }
        }
    }

    return s.substring(left, right + 1);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Sun, 13 Dec 2020 15:15:00 +0000</pubDate>
<dc:creator>狼爷</dc:creator>
<og:description>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。整体框架：状态转移方程、备忘录存储重复子问题、最小子问题、求最值。斐波那契数列不算动态规划，但是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/powercto/p/14131017.html</dc:identifier>
</item>
</channel>
</rss>