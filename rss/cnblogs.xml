<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Netty源码分析之NioEventLoop(二)—NioEventLoop的启动 - bigfan</title>
<link>http://www.cnblogs.com/dafanjoy/p/10507393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dafanjoy/p/10507393.html</guid>
<description>&lt;p&gt;上篇文章中我们对Netty中NioEventLoop创建流程与源码进行了跟踪分析。本篇文章中我们接着分析NioEventLoop的启动流程；&lt;/p&gt;
&lt;p&gt;Netty中会在服务端启动和新连接接入时通过chooser选择器，分别为NioServerSocketChannel与NioSocketChannel选择绑定一个NioEventLoop，接下来我们就分别从这两个方面梳理NioEventLoop的启动源码&lt;/p&gt;
&lt;p&gt;一、服务端启动&lt;/p&gt;
&lt;p&gt;首先我们结合下图看下Netty服务启动过程中，NioServerSocketChannel绑定的NioEventLoop启动流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780676/201903/780676-20190312212826820-2129904482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bind()部分源码我们在之前服务端启动过程中进行过说明，我们进一步跟踪进入doBind0()方法中可以看到channel.eventLoop().execute的执行，需要说明的是这里其实启动的NioServerSocketChannel绑定的 bossGroup，用来负责处理新连接接入的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * read by jsf
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; regFuture
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; channel
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; localAddress
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; promise
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doBind0(&lt;span&gt;final&lt;/span&gt; ChannelFuture regFuture, &lt;span&gt;final&lt;/span&gt; Channel channel, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SocketAddress localAddress,
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; ChannelPromise promise) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法向 NioServerSocketChannel 的 eventLoop 提交了一个任务，当 future(其实就是 promise) 成功后执行
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NioServerSocketChannel 的 bind 方法，并添加一个关闭监听器。我们主要关注 bind 方法。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method is invoked before channelRegistered() is triggered. Give user
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; handlers a chance to set up
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the pipeline in its channelRegistered() implementation.&lt;/span&gt;
        channel.eventLoop().execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (regFuture.isSuccess()) {
                    
                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    promise.setFailure(regFuture.cause());
                }
            }
        });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入NioEventLoop父类SingleThreadEventExecutor中的execute方法，改方法通过inEventLoop()会首先判断当前的线程是否是NioEventLoop本身绑定的线程，结合inEventLoop的代码可以看到NioEventLoop本身线程还未初始化为空，这里返回false，执行启动线程操作，同时会任务放入任务队列中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable task) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;task&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先判断当前线程是否是该EventLoop绑定的线程&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; inEventLoop =&lt;span&gt; inEventLoop();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把传入的任务加入任务对立&lt;/span&gt;
&lt;span&gt;        addTask(task);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!inEventLoop) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是同一条线程&lt;/span&gt;
&lt;span&gt;            startThread();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isShutdown() &amp;amp;&amp;amp;&lt;span&gt; removeTask(task)) {
                reject();
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!addTaskWakesUp &amp;amp;&amp;amp;&lt;span&gt; wakesUpForTask(task)) {
            wakeup(inEventLoop);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; inEventLoop(Thread thread) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; thread == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.thread;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 继续跟踪进入startThread()方法中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startThread() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state ==&lt;span&gt; ST_NOT_STARTED) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (STATE_UPDATER.compareAndSet(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, ST_NOT_STARTED, ST_STARTED)) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    doStartThread();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable cause) {
                    STATE_UPDATER.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, ST_NOT_STARTED);
                    PlatformDependent.throwException(cause);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在 doStartThread()中主要实现了以下功能：&lt;/p&gt;
&lt;p&gt;1、执行传入的ThreadPerTaskExecutor的execute方法，创建一个新的线程，并与这个NioEventLoop对象绑定；&lt;/p&gt;
&lt;p&gt;2、在开启的线程中执行SingleThreadEventExecutor.this.run()，也就是NioEventLoop的run方法，开始NioEventLoop的执行操作；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doStartThread() {
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; thread == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程执行器通过线程工厂创建线程&lt;/span&gt;
        executor.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启线程，并赋值&lt;/span&gt;
                thread =&lt;span&gt; Thread.currentThread();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (interrupted) {
                    thread.interrupt();
                }

                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; success = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                updateLastExecutionTime();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行NioEventLoop的run方法&lt;/span&gt;
                    SingleThreadEventExecutor.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.run();
                    success &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                    logger.warn(&lt;/span&gt;&quot;Unexpected exception from an event executor: &quot;&lt;span&gt;, t);
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldState =&lt;span&gt; state;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldState &amp;gt;= ST_SHUTTING_DOWN ||&lt;span&gt; STATE_UPDATER.compareAndSet(
                                SingleThreadEventExecutor.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, oldState, ST_SHUTTING_DOWN)) {
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if confirmShutdown() was called at the end of the loop.&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (success &amp;amp;&amp;amp; gracefulShutdownStartTime == 0&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isErrorEnabled()) {
                            logger.error(&lt;/span&gt;&quot;Buggy &quot; + EventExecutor.&lt;span&gt;class&lt;/span&gt;.getSimpleName() + &quot; implementation; &quot; +&lt;span&gt;
                                    SingleThreadEventExecutor.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.getSimpleName() + &quot;.confirmShutdown() must &quot; +
                                    &quot;be called before run() implementation terminates.&quot;&lt;span&gt;);
                        }
                    }

                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Run all remaining tasks and shutdown hooks.&lt;/span&gt;
                        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (confirmShutdown()) {
                                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            }
                        }
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            cleanup();
                        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                            STATE_UPDATER.set(SingleThreadEventExecutor.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, ST_TERMINATED);
                            threadLock.release();
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;taskQueue.isEmpty()) {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isWarnEnabled()) {
                                    logger.warn(&lt;/span&gt;&quot;An event executor terminated with &quot; +
                                            &quot;non-empty task queue (&quot; + taskQueue.size() + ')'&lt;span&gt;);
                                }
                            }

                            terminationFuture.setSuccess(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        }
                    }
                }
            }
        });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK到这一步，基于服务端启动绑定端口的NioServerSocketChannel，也就是服务端Channel绑定的NioEventLoop已经启动。&lt;/p&gt;
&lt;p&gt;二、新连接接入&lt;/p&gt;
&lt;p&gt;首先我们结合下图看下当有客户端接入时，创建NioSocketChannel，然后绑定NioEventLoop并启动的流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780676/201903/780676-20190323102914103-1658375837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务端启动时会在NioServerSocketChannel的任务链中添加ServerBootstrapAcceptor对象，这就是用来处理新新连接接入的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        p.addLast(&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;Channel&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initChannel(&lt;span&gt;final&lt;/span&gt; Channel ch) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline =&lt;span&gt; ch.pipeline();
                ChannelHandler handler &lt;/span&gt;=&lt;span&gt; config.handler();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    pipeline.addLast(handler);
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 服务端NioServerSocketChannel的pipeline中添加ServerBootstrapAcceptor&lt;/span&gt;
                ch.eventLoop().execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                        pipeline.addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerBootstrapAcceptor(
                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在新连接接入事件触发时，执行unsafe.read();&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe =&lt;span&gt; ch.unsafe();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;k.isValid()) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; EventLoop eventLoop;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                eventLoop &lt;/span&gt;=&lt;span&gt; ch.eventLoop();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ignored) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the channel implementation throws an exception because there is no event loop, we ignore this
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; because we are only trying to determine if ch is registered to this event loop and thus has authority
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to close ch.&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; still healthy and should not be closed.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/5125&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (eventLoop != &lt;span&gt;this&lt;/span&gt; || eventLoop == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; close the channel if the key is not valid anymore&lt;/span&gt;
&lt;span&gt;            unsafe.close(unsafe.voidPromise());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; readyOps =&lt;span&gt; k.readyOps();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the NIO JDK channel implementation may throw a NotYetConnectedException.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/924&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; ops =&lt;span&gt; k.interestOps();
                ops &lt;/span&gt;&amp;amp;= ~&lt;span&gt;SelectionKey.OP_CONNECT;
                k.interestOps(ops);

                unsafe.finishConnect();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process OP_WRITE first as we may be able to write some queued buffers and so free memory.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write&lt;/span&gt;
&lt;span&gt;                ch.unsafe().forceFlush();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to a spin loop
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新连接接入&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0&lt;span&gt;) {
                unsafe.read();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CancelledKeyException ignored) {
            unsafe.close(unsafe.voidPromise());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;unsafe.read()的具体实现为NioMessageUnsafe中的read()，在read()方法中主要实现了两个功能：&lt;/p&gt;
&lt;p&gt;1、创建客户端Channel，也就是NioSocketChannel；&lt;/p&gt;
&lt;p&gt;2、开始服务端NioServerSocketChannel的任务链传递，首先执行之前已经加入任务链的ServerBootstrapAcceptor中的channelRead&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read() {
            &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt;&lt;span&gt; eventLoop().inEventLoop();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ChannelConfig config =&lt;span&gt; config();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline =&lt;span&gt; pipeline();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle =&lt;span&gt; unsafe().recvBufAllocHandle();
            allocHandle.reset(config);

            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; closed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Throwable exception &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里创建客户端连接,也就是NioSocketChannelChannel&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt; localRead =&lt;span&gt; doReadMessages(readBuf);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localRead == 0&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; 0&lt;span&gt;) {
                            closed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }

                        allocHandle.incMessagesRead(localRead);
                    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (allocHandle.continueReading());
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                    exception &lt;/span&gt;=&lt;span&gt; t;
                }

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; readBuf.size();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i ++&lt;span&gt;) {
                    readPending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里开始NioServerSocketChannel的任务链传递，会首先执行ServerBootstrapAcceptor中的channelRead&lt;/span&gt;
&lt;span&gt;                    pipeline.fireChannelRead(readBuf.get(i));
                }
                readBuf.clear();
                allocHandle.readComplete();
                pipeline.fireChannelReadComplete();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exception != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    closed &lt;/span&gt;=&lt;span&gt; closeOnReadError(exception);

                    pipeline.fireExceptionCaught(exception);
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (closed) {
                    inputShutdown &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isOpen()) {
                        close(voidPromise());
                    }
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if there is a readPending which was not processed yet.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This could be for two reasons:
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2254&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!readPending &amp;amp;&amp;amp; !&lt;span&gt;config.isAutoRead()) {
                    removeReadOp();
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来在ServerBootstrapAcceptor中的channelRead中会获取到传入的NioSocketChannel，针对NioSocketChannel主要会执行以下操作：&lt;/p&gt;
&lt;p&gt;1、配置childHandler任务链；&lt;/p&gt;
&lt;p&gt;2、配置childOptions；&lt;/p&gt;
&lt;p&gt;3、为NioSocketChannel分配NioEventLoop&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        @Override
        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; channelRead(ChannelHandlerContext ctx, Object msg) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Channel child =&lt;span&gt; (Channel) msg;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置childHandler任务链&lt;/span&gt;
&lt;span&gt;            child.pipeline().addLast(childHandler);


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置childOptions&lt;/span&gt;
&lt;span&gt;            setChannelOptions(child, childOptions, logger);

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt;&lt;span&gt; e: childAttrs) {
                child.attr((AttributeKey&lt;/span&gt;&amp;lt;Object&amp;gt;&lt;span&gt;) e.getKey()).set(e.getValue());
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为新连接分配NioEventLoop，并启动执行&lt;/span&gt;
                childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChannelFutureListener() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; operationComplete(ChannelFuture future) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;future.isSuccess()) {
                            forceClose(child, future.cause());
                        }
                    }
                });
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                forceClose(child, t);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看以看到EventLoopGroup中register具体实实现：&lt;/p&gt;
&lt;p&gt;1、关于next()，我们之前讲过是专门用来分配NioEventLoop；&lt;/p&gt;
&lt;p&gt;2、register()主要负责了EventLoop的绑定和启动；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelFuture register(ChannelPromise promise) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next().register(promise);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; register(EventLoop eventLoop, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ChannelPromise promise) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (eventLoop == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;eventLoop&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRegistered()) {
                promise.setFailure(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;registered to an event loop already&quot;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isCompatible(eventLoop)) {
                promise.setFailure(
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;incompatible event loop type: &quot; +&lt;span&gt; eventLoop.getClass().getName()));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与NioEventLoop绑定&lt;/span&gt;
            AbstractChannel.&lt;span&gt;this&lt;/span&gt;.eventLoop =&lt;span&gt; eventLoop;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先判断线程是否一致,当前线程是NioServerSocketChannel的线程,与当前创建NioSocketChannel的eventLoop线程不一致&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (eventLoop.inEventLoop()) {
                register0(promise);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里NioEventLoop启动&lt;/span&gt;
                    eventLoop.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                        @Override
                        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                            register0(promise);
                        }
                    });
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                    logger.warn(
                            &lt;/span&gt;&quot;Force-closing a channel whose registration task was not accepted by an event loop: {}&quot;&lt;span&gt;,
                            AbstractChannel.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, t);
                    closeForcibly();
                    closeFuture.setClosed();
                    safeSetFailure(promise, t);
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中的 eventLoop.execute我们已经分析过，经过一系列的流程，最后会执行NioEventLoop的run方法开始轮询感兴趣的IO事件。&lt;/p&gt;
&lt;p&gt; 以上我们主要从服务启动与客户端连接两个方面分析了NioEventLoop的启动流程与源码，其实也就对应NioServerSocketChannel与NioSocketChannel分别绑定的NioEventLoop，其中有错误和不足之处还请指正与海涵。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 07:13:00 +0000</pubDate>
<dc:creator>bigfan</dc:creator>
<og:description>上篇文章中我们对Netty中NioEventLoop创建流程与源码进行了跟踪分析。本篇文章中我们接着分析NioEventLoop的启动流程； Netty中会在服务端启动和新连接接入时通过chooser</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dafanjoy/p/10507393.html</dc:identifier>
</item>
<item>
<title>C# 使用 Proxy 代理请求资源 - BUTTERAPPLE</title>
<link>http://www.cnblogs.com/xiyin/p/10583787.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyin/p/10583787.html</guid>
<description>&lt;h2 id=&quot;c-使用-proxy-请求资源基于-httpwebrequest-类&quot;&gt;C# 使用 Proxy 请求资源，基于 HttpWebRequest 类&lt;/h2&gt;
&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;这是上周在开发 C# 中使用 &lt;code&gt;Proxy&lt;/code&gt; 代理时开发的一些思考和实践。主要需求是这样的，用户可以配置每次请求是否需要代理，用户可以配置 &lt;code&gt;HTTP&lt;/code&gt;代理，&lt;code&gt;HTTPS&lt;/code&gt;代理和代理白名单。&lt;/p&gt;
&lt;h4 id=&quot;还是太年轻&quot;&gt;还是太年轻&lt;/h4&gt;
&lt;p&gt;因为一直用的C# 网络库中的&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.httpwebrequest?view=netframework-4.7.2&quot;&gt;HttpWebRequest&lt;/a&gt;，所以自然而然先去找找看这个网络库有没有封装好我所需要的代理呀。果不其然，被我找到了。自从上次发现某些类对老版本不兼容后，每次在微软官方文档上找到都会翻到最后，查看一下支持的最低框架。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/69a9dfdbgy1g1cjoouex9j20oj01fa9z.jpg&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我需要的就是这个 &lt;code&gt;Proxy&lt;/code&gt; 属性，也就是说我最终在发送请求前，设置好这个 &lt;code&gt;Proxy&lt;/code&gt; 属性就可以了。先去看看 &lt;code&gt;Proxy&lt;/code&gt; 类&lt;/p&gt;
&lt;blockquote readability=&quot;5.1509433962264&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.iwebproxy?view=netframework-4.7.2&quot;&gt;IWebProxy&lt;/a&gt; object to use to proxy the request. The default value is set by calling the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.globalproxyselection.select?view=netframework-4.7.2#System_Net_GlobalProxySelection_Select&quot;&gt;Select&lt;/a&gt; property.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的意思就是说我只要构造一个&lt;code&gt;WebProxy&lt;/code&gt;，然后赋值给 &lt;code&gt;HttpWebRequest.Proxy&lt;/code&gt;就可以了。&lt;/p&gt;
&lt;p&gt;看到了&lt;code&gt;WebProxy&lt;/code&gt; 的构造器，马上锁定了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/69a9dfdbgy1g1ckczx1v9j20om0jeq6l.jpg&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为我需要用户传的是 &lt;code&gt;string&lt;/code&gt; ，所以直接这样构造就可以了。然后就是测试了，主管大佬写的 &lt;code&gt;Node.js&lt;/code&gt;的&lt;code&gt;Proxy&lt;/code&gt;代理 &lt;a href=&quot;https://www.npmjs.com/package/o_o&quot;&gt;o_o&lt;/a&gt; 先来测试测试&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm install o_o -g

o_o&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就启动全局安装并启动了代理，在控制台上可以看到监听的是 8989 端口&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/69a9dfdbgy1g1ckirav4kj208v04e3yn.jpg&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; [Fact]
public void HttpProxy()
{
    var request = new DescribeAccessPointsRequest();
    client.SetHttpProxy(&quot;http://localhost:8989&quot;);

    var response = client.GetAcsResponse(request);
    Assert.NotNull(response.HttpResponse.Content);

    var expectValue = &quot;HTTP/1.1 o_o&quot;;
    string actualValue;
    response.HttpResponse.Headers.TryGetValue(&quot;Via&quot;, out actualValue);
    Assert.Equal(expectValue, actualValue);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果经过了代理，头部会出现 &lt;code&gt;&quot;HTTP/1.1 o_o&quot;&lt;/code&gt; 字段 ，经过&lt;code&gt;FT&lt;/code&gt;测试，是成功的。&lt;/p&gt;
&lt;p&gt;本来一切都没有问题的，除了我自己想的比较简单外，直到我 Code Review 了一下组里开发JAVA 的人实现这个功能的 Pull Request ，我才发现我还真的是想的太简单！！！&lt;/p&gt;
&lt;h4 id=&quot;开始重构&quot;&gt;开始重构&lt;/h4&gt;
&lt;p&gt;首先发现的一点是，我连&lt;code&gt;Constructor&lt;/code&gt;都用错了，用&lt;code&gt;ILSpy&lt;/code&gt;反编译了一下，发现&lt;code&gt;WebProxy(string,bool,string[])&lt;/code&gt;所作的事。&lt;img src=&quot;http://ww1.sinaimg.cn/large/69a9dfdbgy1g1cnpas4hrj20qx027wef.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// System.Net.WebProxy
private static Uri CreateProxyUri(string address)
{
    if (address == null)
    {
        return null;
    }
    if (address.IndexOf(&quot;://&quot;) == -1)
    {
        address = &quot;http://&quot; + address;
    }
    return new Uri(address);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即使传进去的是string，最后也是构造成 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.uri?view=netframework-4.7.2&quot;&gt;Uri&lt;/a&gt;， 为什么会关注的这个呢？因为我发现有些Proxy地址是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://username:password@localhost:8989&lt;/code&gt; 长这样的，那么我如果直接以这种形式传入到&lt;code&gt;CreateProxy&lt;/code&gt;里面，它会自动给我分解，然后分&lt;code&gt;Credential&lt;/code&gt;和 &lt;code&gt;proxy&lt;/code&gt; 传入到网络库中吗？接下来就是验证的过程。&lt;/p&gt;
&lt;p&gt;首先需要了解到的一个概念：&lt;strong&gt;Basic access authentication&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12.371364653244&quot;&gt;
&lt;p&gt;In the context of an &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP&quot;&gt;HTTP&lt;/a&gt; transaction, &lt;strong&gt;basic access authentication&lt;/strong&gt; is a method for an &lt;a href=&quot;https://en.wikipedia.org/wiki/User_agent&quot;&gt;HTTP user agent&lt;/a&gt; (e.g. a web browser) to provide a &lt;a href=&quot;https://en.wikipedia.org/wiki/User_name&quot;&gt;user name&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Password&quot;&gt;password&lt;/a&gt; when making a request. In basic HTTP authentication, a request contains a header field of the form &lt;code&gt;Authorization: Basic &amp;lt;credentials&amp;gt;&lt;/code&gt;, where credentials is the base64 encoding of id and password joined by a colon.&lt;/p&gt;
&lt;p&gt;It is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt; from 2015, which obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; from 1999.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于其不安全性，已在 RFC 中弃用了，转而代之的是 TLS SSL 那些协议。&lt;/p&gt;
&lt;p&gt;问题来了， &lt;code&gt;HttpWebRequest&lt;/code&gt; 中支持&lt;code&gt;Basic Authentication&lt;/code&gt;吗？我们可以看到&lt;code&gt;WebProxy&lt;/code&gt;中有一个构造方法最后一个参数是 ICredential 的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/69a9dfdbgy1g1co0t6go6j20qe03dgm7.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是的，就是它，知道前因后果和不足后，我继续去重构 &lt;code&gt;Http Proxy&lt;/code&gt; 的代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;originProxyUri = new Uri(proxy);
if (!String.IsNullOrEmpty(originProxyUri.UserInfo))
{
    authorization = Convert.ToBase64String(System.Text.Encoding.GetEncoding(&quot;ISO-8859-1&quot;).GetBytes(originProxyUri.UserInfo));
    finalProxyUri = new Uri(originProxyUri.Scheme + &quot;://&quot; + originProxyUri.Authority);
    var userInfoArray = originProxyUri.UserInfo.Split(':');
    credential = new NetworkCredential(userInfoArray[0], userInfoArray[1]);

    httpRequest.WebProxy = new WebProxy(finalProxyUri, false, noProxy, credential);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先拆分出 &lt;code&gt;UserInfo Credential&lt;/code&gt; 和 &lt;code&gt;Uri&lt;/code&gt;信息，然后分别重新构造相应的类型传入到 &lt;code&gt;WebProxy&lt;/code&gt; 中。上面也有一个坑，我之前还想用正则把&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt; 分别提取出去了，没想到 Uri 已经封装好了，直接取里面的&lt;code&gt;userinfo&lt;/code&gt; 信息。哈哈，省力了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StackOverFlow&lt;/code&gt;上也有挺多关于如何传入 &lt;code&gt;Credential&lt;/code&gt; 到&lt;code&gt;Proxy&lt;/code&gt;中，基本上用的也是这个方法，按理说这样就完事了，直到我做了测试，我发现微软这个&lt;code&gt;Credential&lt;/code&gt;根本没有起作用，如果是正确的话，会在 &lt;code&gt;HEADER&lt;/code&gt; 中添加&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Authorization: Basic &amp;lt;credentials&amp;gt;&lt;/code&gt; ，和上面那段测试代码一样，&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void HttpProxyWithCredential()
{
    DescribeAccessPointsRequest request = new DescribeAccessPointsRequest();
    client.SetHttpProxy(&quot;http://username:password@localhost:8989&quot;);
    var response = client.GetAcsResponse(request);

    var expectValue = &quot;HTTP/1.1 o_o&quot;;
    string actualValue;
    response.HttpResponse.Headers.TryGetValue(&quot;Via&quot;, out actualValue);

    Assert.Equal(expectValue, actualValue);
    Assert.NotNull(response.HttpResponse.Content);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我去测试了发现，这个头部里面根本没有加这个 &lt;code&gt;Authorization&lt;/code&gt; 属性啊，尴尬了，是官方文档坑还是我使用不正确呢，基于此，想到了之前 主管 开发的那个 &lt;code&gt;Proxy&lt;/code&gt; 代理 &lt;code&gt;o_o&lt;/code&gt; ，我又去找了一个验证 &lt;code&gt;basic-auth&lt;/code&gt; 的&lt;code&gt;node.js&lt;/code&gt; 代理服务器 &lt;a href=&quot;https://github.com/jshttp/basic-auth#readme&quot;&gt;basic-auth&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm install basic-auth&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var http = require('http')
var auth = require('basic-auth')
var compare = require('tsscmp')

// Create server
var server = http.createServer(function (req, res) {
  var credentials = auth(req)

  // Check credentials
  // The &quot;check&quot; function will typically be against your user store
  if (!credentials || !check(credentials.name, credentials.pass)) {
    res.statusCode = 401
    res.setHeader('WWW-Authenticate', 'Basic realm=&quot;example&quot;')
    res.end('Access denied')
  } else {
    res.end('Access granted')
  }
})

// Basic function to validate credentials for example
function check (name, pass) {
  var valid = true

  // Simple method to prevent short-circut and use timing-safe compare
  valid = compare(name, 'john') &amp;amp;&amp;amp; valid
  valid = compare(pass, 'secret') &amp;amp;&amp;amp; valid

  return valid
}

// Listen
server.listen(3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上面那段 Js代码打包成一个 js文件，然后执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node tets.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该代理服务器监听 3000端口，我使用刚才那段代码，果不其然，返回的是 401 ，这不是坑吗，官方文档上这样说可以，然而都不行。&lt;/p&gt;
&lt;p&gt;最后只能强制加上这个 &lt;code&gt;Authorization&lt;/code&gt; 代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;originProxyUri = new Uri(proxy);
if (!String.IsNullOrEmpty(originProxyUri.UserInfo))
{
    authorization = Convert.ToBase64String(System.Text.Encoding.GetEncoding(&quot;ISO-8859-1&quot;).GetBytes(originProxyUri.UserInfo));
    finalProxyUri = new Uri(originProxyUri.Scheme + &quot;://&quot; + originProxyUri.Authority);
    var userInfoArray = originProxyUri.UserInfo.Split(':');
    credential = new NetworkCredential(userInfoArray[0], userInfoArray[1]);

    httpRequest.WebProxy = new WebProxy(finalProxyUri, false, noProxy, credential);
    httpRequest.Headers.Add(&quot;Authorization&quot;, &quot;Basic &quot; + authorization);                    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在测试经过 3000 端口的代理服务器，确认是没问题的，把问题想得简单的结果就是发了一个新版本后，还没有下载，然而已经发了新版本说，用户您好，我们又有新版本了。尴尬。需要以此为鉴啊。&lt;/p&gt;
&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;姜还是老的辣，多看看别人的代码，来发现自己的不足。勤加练习！&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 06:10:00 +0000</pubDate>
<dc:creator>BUTTERAPPLE</dc:creator>
<og:description>C 使用 Proxy 请求资源，基于 HttpWebRequest 类 前言 这是上周在开发 C 中使用 代理时开发的一些思考和实践。主要需求是这样的，用户可以配置每次请求是否需要代理，用户可以配置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyin/p/10583787.html</dc:identifier>
</item>
<item>
<title>Easy Pipeline，一种轻量级的Python Pipeline库 - 喵耳朵</title>
<link>http://www.cnblogs.com/idiotgroup/p/10583779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idiotgroup/p/10583779.html</guid>
<description>&lt;p&gt;嗯，很久没有写博客了，最近的工作都是偏开发性质的，以至于没有时间对自己感兴趣的领域进行探索，感觉个人的成长停滞了一些。如何在枯燥的工作中，提取出有助于自己成长的养分，对于每个人来说都是不小的考验。&lt;/p&gt;
&lt;p&gt;这次，带来的是之前编写的一下挺简单的库，用来简化流水线作业的小框架。&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/miaoerduo/easy-pipeline&quot;&gt;https://github.com/miaoerduo/easy-pipeline&lt;/a&gt; 欢迎Star和提交MR。&lt;/p&gt;
&lt;p&gt;起因是这样的，组内有一个需求，需要挖掘视频中的检测难样本，这样可以极大地减少标注的量，从而降低成本。难样本挖掘的策略，简单来说就是如果视频的前几帧和后几帧都能检测到目标，而就只有当前帧没有检测到，就说明当前帧很可能存在漏检（没有检测本到该检测到的目标）；反之，如果前后都没有检测到目标，而当前帧检测到了，那就很可能是误检（检测到不是目标的东西）。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;wp-image-1148&quot; src=&quot;https://www.miaoerduo.com/wp-content/uploads/2019/03/image.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初步的方案是这样的，我们先把视频抽帧，直接用FFMpeg就可以方便的完成。然后调用现在的检测器，进行逐帧的检测，把检测结果存下来。最后写个脚本，分析检测的结果，然后输出可能有问题的帧，然后这些帧就会进行送标（发给标注员进行标注）。最终我们就只需要标注一些比较hard的样本就行了。&lt;/p&gt;
&lt;p&gt;但是这样会带来很多的问题，最显著的两个：1. 需要保存大量的中间结果（图片帧）；2. 必须依次完成每一步之后，才能得到最终的结果。&lt;/p&gt;
&lt;p&gt;这时候，相比大家都知道了该如何去解决。对的，我们应该用流水线作业的方式去进行。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;wp-image-1150&quot; src=&quot;https://www.miaoerduo.com/wp-content/uploads/2019/03/image-1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们可以将每部分任务并行的去处理。抽帧之后的结果送入队列；之后检测模块从队列取帧，检测之后将结果送入下一个队列；最后一个队列得到检测结果，再做最终的分析。相比于之前的方式，这样可以尽量的减少中间的结果。&lt;/p&gt;
&lt;p&gt;实现该方案，只需要使用最简单的生产者消费者队列即可以完成。所以说，相信大家都十分了解了。对于上面的逻辑，我们需要的队列的数目和我们的模块数是正相关的。如果单纯的进行实现的话，实在的太麻烦了，给队列命名都要我们绞尽脑汁了。所以，为了更优雅的编写代码，这里就推出本文标题中的Easy Pipeline框架。&lt;/p&gt;
&lt;p&gt;首先，我们举个最简单的例子来说明该框架的工作模式。输入一个数字的序列，按要求对他们进行加减乘除的操作（这里的每个操作，其实可以等价于前面的抽帧或是检测的更复杂的操作 ），并且支持每个操作的进程数。&lt;/p&gt;
&lt;pre class=&quot;wp-block-code&quot;&gt;
&lt;code&gt;from easy_pipeline import SimplePipeline, PipelineItem, Task, StopTask, EmptyTask
import multiprocessing as mp

# define our Task
class NumTask(Task):
    def __init__(self, x):
        super(NumTask, self).__init__()
        self.val = x

# init function, here we use closure to get different function
def get_init_fn(x):
    def init():
        return x
    return init

# operations
def plus(res, task):
    return NumTask(task.val + res)

def mul(res, task):
    return NumTask(task.val * res)

def minus(res, task):
    return NumTask(task.val - res)

def div(res, task):
    return NumTask(task.val / res)

if __name__ == '__main__':

    # job queue
    manager = mp.Manager()
    job_queue = manager.Queue(1000)

    # define pipeline and start

    # x = （(x + 1) * 2 - 3）/ 5
    pipeline_items = [
        PipelineItem(plus, get_init_fn(1), 1, 10),      # plus 1
        PipelineItem(mul, get_init_fn(2), 2, 10),       # mul 2
        PipelineItem(minus, get_init_fn(3), 3, 10),     # minus 3
        PipelineItem(div, get_init_fn(5.), 4, 10),      # div 5
    ]

    pipeline = SimplePipeline(pipeline_items, job_queue)
    pipeline.start()
    result_queue = pipeline.get_result_queue()

    # Feed jobs anytime (before StopTask)
    for i in range(10):
        job_queue.put(NumTask(i))

    # get partial output
    print('Get Output Start')
    for i in range(5):
        result = result_queue.get()
        if isinstance(result, StopTask):
            print(&quot;get stop task&quot;)
            break
        if isinstance(result, EmptyTask):
            continue
        print(result.val)
    print('Get Output End')
    
    # Feed jobs anytime (before StopTask)
    for i in range(10, 20):
        job_queue.put(NumTask(i))

    # Stop pipeline, means no more job will be added then.
    # Every process will exit when it has done all current jobs in job_queue
    pipeline.stop()

    # get all output
    print('Get Output Start')
    while True:
        result = result_queue.get()
        if isinstance(result, StopTask):
            print(&quot;Output Queue Empty&quot;)
            break
        if isinstance(result, EmptyTask):
            continue
        print(result.val)
    print('Get Output End')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面，我们来简单的说明一下工作逻辑。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;首先，我们需要定义自己的任务Task。&lt;/strong&gt;只需要继承Task这个类即可，内部可以存放自己喜欢的任何数据。这里只是为了计算，所以就只存放了一个数字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定义我们的初始化函数和工作函数。&lt;/strong&gt;初始化函数的作用是给每个进程初始化一些资源，如果不需要也可以不要。这里的初始化函数就是返回了一个值，表示操作数。工作函数是最重要的函数，他会处理接收到的Task，处理并返回新的Task（新的Task可以理解为处理的结果）。工作函数有两个输入，一个是资源，即初始化函数的返回值，另一个就是Task本身。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构建Pipeline。&lt;/strong&gt;每个工作模块都只需要用PipelineItem这个对象进行封装即可。器参数分别是：工作函数、初始化函数、进程数、结果队列的长度（-1表示不限长度）。结果队列的长度，通常设置为较大的值即可。因为不能的模块的处理速度可能不同，因此很容易出现结果堆积的现象，如果不支持队列长度，会导致内存的大量的占用。最后将PipelineItem的数组和输入的对垒传给SimplePipeline对象即可构建完我们的整套Pipeline程序了！&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动Pipeline程序，并输入数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;得到结果！&lt;/strong&gt;完事了，优秀。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面这是一个最简单的例子，可以比较直观的感受到这个框架的便捷之处。完全屏蔽掉对队列，并发等的操作。&lt;/p&gt;
&lt;p&gt;在我推荐给同事之后，确实一定程度地减小他的工作量，但同时，他也向我反馈了一些问题：这个框架在某些地方有些比较灵活的设计，应该给出足够多的实例，才能方便实用。关于该框架的设计思路和实例，将会在下一篇博客中进行详细介绍。&lt;/p&gt;
&lt;p&gt;最后，欢迎大家Star和提交MR。愿与你们一同进步。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 06:09:00 +0000</pubDate>
<dc:creator>喵耳朵</dc:creator>
<og:description>本文主要是分析遇到的项目中的问题，抽象成流水线的工作流程，最后安利一个自己开发的小框架。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/idiotgroup/p/10583779.html</dc:identifier>
</item>
<item>
<title>SpringBoot自动配置源码调试 - STM32STM32STM32</title>
<link>http://www.cnblogs.com/stm32stm32/p/10575145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stm32stm32/p/10575145.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;之前对SpringBoot的自动配置原理进行了较为详细的介绍（&lt;a href=&quot;https://www.cnblogs.com/stm32stm32/p/10560933.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/stm32stm32/p/10560933.html&lt;/a&gt;），接下来就对自动配置进行源码调试，探究下这个配置过程中各参数的情况。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;这里对AutoConfigurationImportSelector类的selectImports()方法打了4处断点，将着重对这4处进行调试。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190321221652148-900509833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一处断点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323092049435-398512848.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该方法的源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190321221930111-1894793121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;这一步就是将META-INF/spring-autoconfigure-metadata.properties文件中的键值对放入AutoConfigurationMetadataLoader的内部类PropertiesAutoConfigurationMetadata的Properties对象中，共有485个元素。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323092403182-586048121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二处断点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323092441222-967125976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个方法的源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323092631870-1966997301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的name就是org.springframework.boot.autoconfigure.EnableAutoConfiguration类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323092718746-317596358.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的方法中的metadata.getAnnotationAttributes(name, true)获取到的值如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323092819785-351745953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323092914327-1759807905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里还利用断言进行attributes是否为null判断，若为null，则提示No auto-configuration attributes found. Is com.SpringboothuifuApplication annotated with EnableAutoConfiguration ？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323093014420-907448733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终得到的attributes为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323093127524-1015212449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三处断点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323093219070-852412072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;getCandidateConfigurations方法定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323093333863-65258421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的getSpringFactoriesLoaderFactoryClass()返回的是EnableAutoConfiguration.class。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323093421770-233739253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入loadFacotryNames()方法进行调试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323093532929-912238932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;factoryClassName的值为org.springframework.boot.autoconfigure.EnableAutoConfiguration。&lt;/p&gt;
&lt;p&gt;常量FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;。&lt;/p&gt;
&lt;p&gt;下面的方法通过类加载器获取jar包中所有META-INF/spring.factories并获取其中的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323093839998-2097551674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后的urls包含扫描到3个jar包中有spring.factories文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323094336270-2124179820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来对urls进行3次遍历：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一次遍历的文件路径url=jar:file:/C:/Users/Alan/.m2/repository/org/springframework/boot/spring-boot/1.5.17.RELEASE&lt;strong&gt;/spring-boot-1.5.17.RELEASE.jar&lt;/strong&gt;!/META-INF/spring.factories&lt;/p&gt;
&lt;p&gt;通过Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));得到的properties对象的大小为7：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323094538336-798979726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为上述properties并不存在org.springframework.boot.autoconfigure.EnableAutoConfiguration的key，&lt;/p&gt;
&lt;p&gt; 所以String factoryClassNames = properties.getProperty(factoryClassName);得到的factoryClassNames为null&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323094633763-1455114495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时存放自动配置类的list集合result的大小仍然为0。&lt;/p&gt;
&lt;p&gt;第二次遍历的文件路径url=jar:file:/C:/Users/Alan/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/1.5.17.RELEASE&lt;strong&gt;/spring-boot-autoconfigure-1.5.17.RELEASE.jar&lt;/strong&gt;!/META-INF/spring.factories&lt;/p&gt;
&lt;p&gt;该文件也有7个键值对，新生成的properties大小为7：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323094914634-335587961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此时properties.getProperty(factoryClassName)将能找到key=org.springframework.boot.autoconfigure.EnableAutoConfiguration的属性键值对。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;factoryClassNames此时包含了org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的value值，最后全部添加到list集合里面，共有96个值（Arrays.asList转换得到）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323095012794-1589550906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三次遍历jar:file:/C:/Users/Alan/.m2/repository/org/springframework/spring-beans/4.3.20.RELEASE/&lt;strong&gt;spring-beans-4.3.20.RELEASE.jar&lt;/strong&gt;!/META-INF/spring.factories&lt;/p&gt;
&lt;p&gt;但是里面仍然没有org.springframework.boot.autoconfigure.EnableAutoConfiguration的key，所以result里面并没有添加新元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 总共进行了3次遍历，分别是下面3个jar包包含spring.factories文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、spring-boot-1.5.17.RELEASE.jar&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、spring-boot-autoconfigure-1.5.17.RELEASE.jar&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、spring-beans-4.3.20.RELEASE.jar&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而上述3个jar的spring.factories只有spring-boot-autoconfigure-1.5.17.RELEASE.jar中包含org.springframework.boot.autoconfigure.EnableAutoConfiguration的key，这样就把需要自动配置的候选类都找出并放入list集合中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接着还会用断言判断configurations是否有元素，否则提示：No auto configuration classes found in META-INF/spring.factories. If you  are using a custom packaging, make sure that file is correct.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323095239716-1590700558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后返回自动配置类的list集合对象configurations。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第四处断点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323095429872-1451440579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; filter方法传入了2个参数：&lt;/p&gt;
&lt;p&gt;1、configurations：读取MEAT-INF/spring.factories文件得到的经过排除得到的自动配置类名的list集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323095544889-481797446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、autoConfigurationMetadata：读取META-INF/spring-autoconfigure-metadata.properties文件得到的485个键值对。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323095600054-1617722672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;候选自动配置类数组candidates 由configurations转数组而来：String[] candidates = configurations.toArray(new String[configurations.size()]);其值如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323095713489-1270056946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;for循环中的getAutoConfigurationImportFilters定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323095856815-1106750986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面的SpringFactoriesLoader.loadFactories()方法定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323100006221-322001360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述方法主要目的是找寻spring.factories文件中key=org.springframework.boot.autoconfigure.AutoConfigurationImportFilter对应的值，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里依然进行了3次遍历，分别是下面3个jar包包含spring.factories文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、spring-boot-1.5.17.RELEASE.jar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、spring-boot-autoconfigure-1.5.17.RELEASE.jar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、spring-beans-4.3.20.RELEASE.jar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;而上述3个jar的spring.factories只有spring-boot-autoconfigure-1.5.17.RELEASE.jar中包含了org.springframework.boot.autoconfigure.AutoConfigurationImportFilter的key。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 通过loadFactoryNames(factoryClass, classLoaderToUse)得到的factoryNames为org.springframework.boot.autoconfigure.condition.OnClassCondition类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323100327009-1651374275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着遍历factoryNames，调用instantiateFactory方法，利用反射生成condition.OnClassCondition的实例添加到result集合中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323100403483-187333435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后对result进行排序并返回：AnnotationAwareOrderComparator.sort(result);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323100729961-1582629677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;getAutoConfigurationImportFilters()分析完了，我们继续看for循环：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323100951724-1278213364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的invokeAwareMethods(filter)方法根据filter是否实现了相关接口，对其进行了设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323101037298-118918524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;filter满足instance instanceof Aware、instance instanceof BeanClassLoaderAware、instance instanceof BeanFactoryAware。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来我们着重看下match方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323101306388-299787757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述方法调用了OnClassCondition类的match方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323101435101-630785586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 传入的参数是之前排除过自动配置类，目前还有96个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323101531342-2092244372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面的方法利用autoConfigurationMetadata对象对autoConfigurationClasses进行处理，autoConfigurationMetadata是加载META-INF/spring-autoconfigure-metadata.properties得到的485个元素，autoConfigurationClasses是读取META-INF/spring.factories文件key为org.springframework.boot.autoconfigure.EnableAutoConfiguration得到值进行排除、排序、去重等操作得到的候选自动配置类（由于没有添加排除项，目前仍然有96个）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323101601817-423954615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;getOutComes定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323102126738-1531869804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该方法将自动候选配置类分成2半进行条件判断处理，outcomes存入的是条件判断后的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323102338073-698661681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;匹配结束后的ConditionEvaluationReport对象report存放了不匹配的结果，从结果中看到候选的96个自动配置类，有72个不满足条件而被过滤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323102447803-768315245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随便点开一个outcomes元素：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;org.springframework.boot.autoconfigure.aop.AopAutoConfiguration&lt;/strong&gt; -&amp;gt; key=org.springframework.boot.autoconfigure.aop.AopAutoConfiguration；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;匹配失败原因&lt;/span&gt;&lt;/strong&gt;：&lt;strong&gt;&lt;span&gt;@ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice'&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;由于项目没有引入aop的相关依赖，导致类路径中没有Aspect和Advice类，导致AopAutoConfiguration这个自动配置类匹配失败。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) META-INF/spring-autoconfigure-metadata.properties文件中的Aop内容：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;org.springframework.boot.autoconfigure.aop.AopAutoConfiguration.Configuration=&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;org.springframework.boot.autoconfigure.aop.AopAutoConfiguration=&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;org.springframework.boot.autoconfigure.aop.AopAutoConfiguration.ConditionalOnClass=&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;org.springframework.context.annotation.EnableAspectJAutoProxy,org.aspectj.lang.annotation.Aspect,org.aspectj.lang.reflect.Advice&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) META-INF/spring.factories中的Aop内容：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\&lt;/span&gt;&lt;br/&gt;&lt;em&gt;&lt;span&gt;org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此spring.factories中的key=org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的值只是候选的自动配置类；&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;能否成功配置，关键还要看是否已经被排除以及是否满足spring-autoconfigure-metadata.properties中对对应配置类的加载条件。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;若不满足，则该类是会从自动配置类列表中排除，这样能加快springboot的启动速度。&lt;/strong&gt;&lt;/span&gt;spring官方文档（&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;&lt;span&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;）对该文件的作用描述如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;Spring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file (&lt;code class=&quot;literal&quot;&gt;META-INF/spring-autoconfigure-metadata.properties&lt;/code&gt;). If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time. &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;然后根据匹配结果，将真正满足配置条件的配置类放入list集合中  boolean[] skip记录了对应的候选自动配置类是否需要跳过，true-不满足条件，需要跳过，false-满足条件，不需要跳过。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323103425520-1375604426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;for循环结束，只有24个自动配置真正符合条件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323103444734-1468990290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323103511361-944734659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此第四处断点走完，真正符合自动配置条件类的自动配置类只有24个了（根据项目配置情况会有所不同）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323103612328-1500420730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;至此，SpringBoot自动配置源码调试告一段落，总结如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、读取META-INF/spring-autoconfigure-metadata.properties文件中的内容；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、获取需要排除的自动配置类；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、读取spring-boot-autoconfigure-1.5.17.RELEASE.jar中的META-INF/spring.factories文件内容，作为候选自动配置类；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、对候选自动配置类进行去重、排序、去除所有排除项；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、利用META-INF/spring-autoconfigure-metadata.properties文件的配置对META-INF/spring.factories经历第四步处理后的候选自动配置类进行过滤，去除不满足加载条件的类，得到最终的自动配置类供SpringBoot加载。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/864087/201903/864087-20190323105423627-1792337176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Mar 2019 03:14:00 +0000</pubDate>
<dc:creator>STM32STM32STM32</dc:creator>
<og:description>之前对SpringBoot的自动配置原理进行了较为详细的介绍（https://www.cnblogs.com/stm32stm32/p/10560933.html），接下来就对自动配置进行源码调试，探</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stm32stm32/p/10575145.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——61. 基本类型优于装箱的基本类型 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/10582913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/10582913.html</guid>
<description>&lt;blockquote readability=&quot;5.0845771144279&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;书中的源代码地址：&lt;a href=&quot;https://github.com/jbloch/effective-java-3e-source-code&quot; class=&quot;uri&quot;&gt;https://github.com/jbloch/effective-java-3e-source-code&lt;/a&gt;&lt;br/&gt;注意，书中的有些代码里方法是基于Java 9 API中的，所以JDK 最好下载 JDK 9以上的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4366140-8966e457a14bc8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Java是一个由两部分类型组成的系统，一部分由基本类型组成，如int，double和boolean，还有一部分是引用类型，如String和List。 每个基本类型都有一个相应的引用类型，称为装箱基本类型。 对应于int，double和boolean的盒装基元是Integer，Double和Boolean。&lt;/p&gt;
&lt;p&gt;正如条目6中提到的，自动装箱和自动拆箱模糊了基本类型和装箱基本类型之间的区别，但不会消除它们。这两者之间有真正的区别，重要的是要始终意识到你正在使用的是哪一种，并在它们之间仔细选择。&lt;/p&gt;
&lt;p&gt;基本类型和包装基本类型之间有三个主要区别。首先，基本类型只有它们的值，而包装基本类型具有与其值不同的标识。换句话说，两个包装基本类型实例可以具有相同的值但不同的引用标识。第二，基本类型只有功能的值（functional value），而每个包装基本类型类型除了对应的基本类型的功能值外，还有一个非功能值，即null。最后，基本类型比包装的基本类型更节省时间和空间。如果你不小心的话，这三种差异都会给你带来真正的麻烦。&lt;/p&gt;
&lt;p&gt;考虑下面的比较器，它的设计目的是表示Integer值的升序数字顺序。(回想一下，比较器的compare方法返回一个负数、零或正数，这取决于它的第一个参数是小于、等于还是大于第二个参数)。你不需要在实践中编写这个比较器，因为它实现了Integer的自然排序，但它提供了一个有趣的例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Broken comparator - can you spot the flaw?
Comparator&amp;lt;Integer&amp;gt; naturalOrder =
    (i, j) -&amp;gt; (i &amp;lt; j) ? -1 : (i == j ? 0 : 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个比较器看起来应该工作，也能通过很多测试。 例如，它可以与&lt;code&gt;Collections.sort&lt;/code&gt;方法一起使用，以正确排序百万个元素列表，无论列表是否包含重复元素。 但这个比较器存在严重缺陷。 为了说服自己，只需打印&lt;code&gt;naturalOrder.compare(new Integer(42)，new Integer(42))&lt;/code&gt;的值。 两个Integer实例都表示相同的值（42），因此该表达式的值应为0，但它为1，表示第一个Integer值大于第二个值！&lt;/p&gt;
&lt;p&gt;那么问题出在哪里呢？&lt;code&gt;naturalOrder&lt;/code&gt;中的第一个测试工作得很好。计算表达式&lt;code&gt;i &amp;lt; j&lt;/code&gt;会使i和j引用的整数实例自动拆箱；也就是说，它提取它们的基本类型值。计算的目的是检查得到的第一个int值是否小于第二个int值。但假设是否定的。然后，下一个测试计算表达式&lt;code&gt;i==j&lt;/code&gt;，该表达式对两个对象执行引用标识比较。如果i和j引用表示相同整型值的不同Integer实例，这个比较将返回false，比较器将错误地返回1，表明第一个整型值大于第二个整型值。&lt;strong&gt;将==操作符应用于装箱的基本类型几乎总是错误的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在实践中，如果你需要一个比较器来描述类型的自然顺序，应该简单地调用&lt;code&gt;comparator . naturalorder()&lt;/code&gt;方法，如果自己编写一个比较器，应该使用比较器构造方法，或者对基本类型使用静态compare方法(条目 14)。也就是说，可以通过添加两个局部变量来存储与装箱Integer参数对应的原始int值，并对这些变量执行所有的比较，从而修复了损坏的比较器中的问题。这样避免了错误的引用一致性比较:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Comparator&amp;lt;Integer&amp;gt; naturalOrder = (iBoxed, jBoxed) -&amp;gt; {
    int i = iBoxed, j = jBoxed; // Auto-unboxing
    return i &amp;lt; j ? -1 : (i == j ? 0 : 1);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，考虑一下这个有趣的小程序:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42)
            System.out.println(&quot;Unbelievable&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它不会打印出&lt;code&gt;Unbelievable&lt;/code&gt;字符串——但它所做的事情几乎同样奇怪。它在计算表达式&lt;code&gt;i==42时&lt;/code&gt;抛出&lt;code&gt;NullPointerException&lt;/code&gt;。问题是，i是Integer类型，而不是int类型，而且像所有非常量对象引用属性一样，它的初始值为null。当程序计算表达式&lt;code&gt;i==42&lt;/code&gt;时，它是在比较Integer和int之间的关系。 &lt;strong&gt;几乎在每种情况下，当在基本类型和包装基本类型进行混合操作时，包装基本类型会自动拆箱&lt;/strong&gt;。如果对一个null对象进行自动拆箱，那么会抛出NullPointerException。正如这个程序所演示的，它几乎可以在任何地方发生。修复这个问题非常简单，只需将i声明为int而不是Integer就可以了。&lt;/p&gt;
&lt;p&gt;最后，考虑第24页条目6中的程序:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Hideously slow program! Can you spot the object creation?
public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i &amp;lt; Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，什么时候应该使用装箱原语呢?它们有几个合法的用途。第一个是作为集合中的元素、键和值。不能将原语放在集合中，因此必须使用装箱的原语。这是一般情况下的特例。在参数化类型和方法(第5章)中，必须使用装箱原语作为类型参数，因为该语言不允许使用原语。例如，不能将变量声明为ThreadLocal类型，因此必须使用ThreadLocal。最后，在进行反射方法调用时，必须使用装箱原语(第65项)。&lt;/p&gt;
&lt;p&gt;这个程序比它原本的速度慢得多，因为它意外地声明了一个局部变量(sum)，它是装箱的基本类型Long，而不是基本类型long。程序在没有错误或警告的情况下编译，变量被反复装箱和拆箱，导致观察到的性能下降。&lt;/p&gt;
&lt;p&gt;在本条目中讨论的所有三个程序中，问题都是一样的:程序员忽略了基本类型和包装基本类型之间的区别，并承担了后果。在前两个项目中，结果是彻底的失败;第三，严重的性能问题。&lt;/p&gt;
&lt;p&gt;那么，什么时候应该使用装箱基本类型呢？它们有几个合法的用途。第一个是作为集合中的元素、键和值。不能将基本类型放在集合中，因此必须使用装箱的基本类型。这是一般情况下的特例。在参数化类型和方法(第5章)中，必须使用装箱基本类型作为类型参数，因为该语言不允许使用基本类型。例如，不能将变量声明为&lt;code&gt;ThreadLocal&amp;lt;int&amp;gt;&lt;/code&gt;类型，因此必须使用&lt;code&gt;ThreadLocal&amp;lt;Integer&amp;gt;&lt;/code&gt;。最后，在进行反射方法调用时，必须使用装箱基本类型(条目 65)。&lt;/p&gt;
&lt;p&gt;总之，只要有选择，就应该优先使用基本类型，而不是装箱基本类型。基本类型更简单、更快。如果必须使用装箱基本类型，则需要小心！&lt;strong&gt;自动装箱减少了使用装箱基本类型的冗长，但没有降低使用的危险&lt;/strong&gt;。当程序使用==操作符比较两个装箱的基本类型时，它会执行引用标识比较，这几乎肯定不是你想要的。当程序执行包含装箱和拆箱基本类型的混合类型计算时，它会执行拆箱，&lt;strong&gt;当程序执行拆箱时，会抛出NullPointerException&lt;/strong&gt;。最后，当程序装箱了基本类型，可能会导致代价高昂且创建了不必要的对象。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 02:54:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>Tips 书中的源代码地址：https://github.com/jbloch/effective java 3e source code 注意，书中的有些代码里方法是基于Java 9 API中的，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/10582913.html</dc:identifier>
</item>
<item>
<title>分布式事务？咱先弄明白本地事务再说 - ACID - 土豆的奥特之父</title>
<link>http://www.cnblogs.com/xguo/p/10582648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xguo/p/10582648.html</guid>
<description>&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;1433&quot; data-height=&quot;793&quot;&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190323094905327-79687081.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;过去一段时间面试的同学，对于数据库事务，可以按照配置正常使用，但很多都无法讲清楚和理解数据库事务这个东西真正的意义，以及互联网兴起以后，当今数据库在ACID面前面临怎样的问题和抉择。&lt;/p&gt;
&lt;p&gt;事务，是各大单机SQL数据库厂商包括Oracle、IBM DB2等，早在上世纪80年代提出的一个解决 数据并发操作处理的模型 ，旨在满足多用户（多线程、进程）对数据操作的场景下，依然能保证逻辑正确执行，状体持久，且各大厂商提出，并在事务实现上都遵循事务的 ACID 4个特性。&lt;/p&gt;
&lt;h2&gt;回顾ACID&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1720&quot; data-height=&quot;895&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190323094914736-1459866119.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;一个模块，是多个独立的功能逻辑的组合，每个功能包含多个操作步骤，包括IO、计算、数据库等操作，必须保证每一步都被执行，且执行正确，这个功能和模块才是可用，可交付的。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;494&quot; data-height=&quot;213&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190323094924183-1338282146.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;那么，如何保证这些操作的完整性，就是Atomic，定义为一个原子操作，全部执行且成功，或者全部失败都不执行（回滚），原子操作如果成功，那状态就必须持久，被称为数据库的Durability，持久性。&lt;/p&gt;
&lt;p&gt;原子性A、持久性D，这俩个都比较好理解，定义了事务的边界，行为的开始和行为的结束。&lt;/p&gt;
&lt;p&gt;A、D定义了事务的边界，那一致性C、隔离性I，就是对事务中间状态的管理，&lt;/p&gt;

&lt;p&gt;一致性，也可以理解为是数据的完整性，数据的有效性，我们举例来说明什么是一致性，以及事务是如何保证一致性的，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个账户减100，另一个账户加100的时候，程序异常crash了，这时候就出现数据的不一致情况，破坏了有效性，这个问题可以由Atomic来保证；&lt;/li&gt;
&lt;li&gt;一个原子操作在执行的过程中，涉及多个数据变更的中间状态的保护，例如把A账户减100，在加到B账户完成这个原子操作之前，此时，其他线程对A读的操作就有可能获取到A少100的这个中间状态，这种情况是否允许发生，由Isolation来保证；&lt;/li&gt;
&lt;li&gt;数据库延迟约束，例如数据字段的类型、空值、关系、数据范围、主键唯一性等这些合法性的检查都是由Durability来保证，在事务commit时，发现数据不合法，是无法提交成功的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，综上所述，一致性C，是数据状态的正确变换的保证，AID，是实现C的手段，也是我们真正要追求的目标。&lt;/p&gt;

&lt;p&gt;而，隔离性I的设定，就是对一致性C不同程度的破坏，事实上，如果我们顺序对数据进行读写，ACD是完全可用保证的，但这样效率会非常的低下，那，我们是要严格的一致性，还是更高的效率，数据库专家们把这个决定权交给了用户，所以，我们看到，ACID当中，只有隔离性I是用户可以选择的，可以自定义的。&lt;br/&gt;隔离性包括 &lt;code&gt;串行读、读已提交、重复读、读未提交&lt;/code&gt; 等几种策略，性能由低到高，让用户在不同的使用场景，选择合适的隔离策略，在一致性和性能之间平衡，取得最好的综合表现。&lt;/p&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;本文主要介绍了事务和事务的几个特性，解释了ACID的由来和之间的关系，&lt;/p&gt;
&lt;p&gt;总的来说，ACID的核心是C，大家其实都是为得到C而提出的不同纬度的限制和规范，A确定一个功能的完整性，D对状态负责，I可以说是C的等级系数，不同的I的策略，会出现不同的级别的C，AID是数据库本身的功能特性，C由业务层把控，要严格的C，就设置完整的数据库约束和串行隔离，反之，要宽松的C，就放开数据库的约束，使用读未提交的隔离策略，存在即合理，后者更适用于互联网高并发对一致性要求不高的场景，例如分布式的AP系统，可以保证服务整体的响应时间和服务的可用性。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Mar 2019 01:54:00 +0000</pubDate>
<dc:creator>土豆的奥特之父</dc:creator>
<og:description>过去一段时间面试的同学，对于数据库事务，可以按照配置正常使用，但很多都无法讲清楚和理解数据库事务这个东西真正的意义，以及互联网兴起以后，当今数据库在ACID面前面临怎样的问题和抉择。 事务，是各大单机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xguo/p/10582648.html</dc:identifier>
</item>
<item>
<title>大数据技术之_16_Scala学习_01_Scala 语言概述 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10582571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10582571.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#hscala&quot;&gt;第一章 Scala 语言概述&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h11whyisscala&quot;&gt;1.1 why is Scala 语言?&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h12scala&quot;&gt;1.2 Scala 语言诞生小故事&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h13scalajavajvm&quot;&gt;1.3 Scala 和 Java 以及 jvm 的关系分析图&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h14scala&quot;&gt;1.4 Scala 语言的特点&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h15windowsscala&quot;&gt;1.5 Windows 下搭建 Scala 开发环境&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h16linuxscala&quot;&gt;1.6 Linux 下搭建 Scala 开发环境&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h17scala&quot;&gt;1.7 Scala 的开发工具&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h171idea&quot;&gt;1.7.1 IDEA介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h172scala&quot;&gt;1.7.2 Scala 插件安装&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h18scala&quot;&gt;1.8 Scala 的开发快速入门&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h181windows&quot;&gt;1.8.1 windows 下开发步骤&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h182linux&quot;&gt;1.8.2 linux 下开发步骤&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h183idea&quot;&gt;1.8.3 IDEA 下开发步骤&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h184javascala&quot;&gt;1.8.4 使用 java 写一段模拟代码，来模拟 scala 的执行流程&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h185scala&quot;&gt;1.8.5 Scala 执行流程分析&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h186scala&quot;&gt;1.8.6 Scala 程序开发注意事项(重点)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h19scala&quot;&gt;1.9 Scala 语言转义字符&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h110scala&quot;&gt;1.10 Scala 语言输出的三种方式&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h111scala&quot;&gt;1.11 Scala 源码的查看的关联&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h112&quot;&gt;1.12 注释&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h1121&quot;&gt;1.12.1 介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h1122scala&quot;&gt;1.12.2 Scala 中的注释类型&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h1123&quot;&gt;1.12.3 文档注释案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h1124scala&quot;&gt;1.12.4 scala 的代码规范说明&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h1125&quot;&gt;1.12.5 正确的注释和注释风格&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h1126&quot;&gt;1.12.6 正确的缩进和空白&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h1127scala&quot;&gt;1.12.7 Scala 官方编程指南&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10582571.html#h113&quot;&gt;1.13 本章知识回顾&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;hscala&quot;&gt;&lt;span&gt;&lt;strong&gt;第一章 Scala 语言概述&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h11whyisscala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1 why is Scala 语言?&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1、Spark--新一代&lt;code&gt;内存级&lt;/code&gt;大数据计算框架，是大数据的重要内容。&lt;br/&gt;2、Spark 就是使用 Scala 编写的。因此为了更好的学习 Spark, 需要掌握 Scala 这门语言。&lt;br/&gt;3、Scala 是 Scalable Language 的简写，是一门多范式(范式=编程方式[面向对象/函数式编程])的编程语言。&lt;br/&gt;4、联邦理工学院洛桑（EPFL）的 Martin Odersky(马丁·奥德斯基) 于 2001 年开始设计 Scala(斯卡拉)。&lt;br/&gt;5、Spark 的兴起，带动 Scala 语言的发展！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h12scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2 Scala 语言诞生小故事&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;  创始人马丁·奥德斯基 (Martin Odersky) 是编译器及编程的狂热爱好者，长时间的编程之后，希望发明一种语言，能够让写程序这样的基础工作变得高效、简单。所以当接触到 JAVA 语言后，对 JAVA 这门便携式、运行在网络、且存在垃圾回收的语言产生了极大的兴趣，所以决定将函数式编程语言的特点融合到 JAVA 中，由此发明了两种语言（Pizza &amp;amp; Scala）。 （大量使用递归）&lt;br/&gt;  jdk5.0 的泛型、for 循环增强,、自动类型转换等，都是从 Pizza 引入的新特性。&lt;br/&gt;  jdk8.0 的类型推断、Lambda 表达式 就是从 scala 引入的特性。&lt;br/&gt;  Pizza 和 Scala 极大地推动了 Java 编程语言的发展。[如何理解?]&lt;br/&gt;  且现在主流 JVM 的 javac 编译器就是 马丁·奥德斯基 编写出来的。并被 JAVA 编程人员广泛的使用，所以 Scala 语言起源于 Java，却推动着 Java 的发展，它们是相辅相成的。Jdk5.0、Jdk8.0 的编译器就是 马丁·奥德斯基 写的，因此 马丁·奥德斯基 是一个人的战斗力抵得上一个 Java 开发团队。&lt;br/&gt;  &lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAQeO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  正是基于上面的原因，所以 Scala 源代码 (.scala) 会被编译成 Java 字节码 (.class)，然后运行于 JVM 之上，并可以调用现有的 Java 类库，实现两种语言的无缝对接，因此，对于已经掌握 JAVA 语言的我们来讲，学习起来一定会略显轻松。&lt;br/&gt;  Scala 是一门以 java 虚拟机(JVM) 为目标运行环境并将&lt;code&gt;面向对象&lt;/code&gt;和&lt;code&gt;函数式编程&lt;/code&gt;的最佳特性结合在一起的&lt;code&gt;静态类型编程语言&lt;/code&gt;。（运行之前一定知道类型是什么）

&lt;/blockquote&gt;
&lt;h3 id=&quot;h13scalajavajvm&quot;&gt;&lt;span&gt;&lt;strong&gt;1.3 Scala 和 Java 以及 jvm 的关系分析图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  一般来说，学 Scala 的人，都会 Java，而 Scala 是基于 Java 的，因此我们需要将 Scala 和 Java 以及 JVM 之间的关系搞清楚，否则学习 Scala 你会蒙圈。&lt;br/&gt;  建议：如果没有任何 Java 基础的同学，先学 Java，至少要学习 JavaSE，再学习 Scala。&lt;br/&gt;  我们分析一下：Scala 和 Java 以及 jvm 的关系 (重要！！！)&lt;br/&gt;  &lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAVY9.png&quot; alt=&quot;&quot;/&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h14scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.4 Scala 语言的特点&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;  Scala 是一门以 java 虚拟机(JVM) 为运行环境并将&lt;code&gt;面向对象&lt;/code&gt;和&lt;code&gt;函数式编程&lt;/code&gt;的最佳特性结合在一起的&lt;code&gt;静态类型编程语言(编译型语言)&lt;/code&gt;。（动态类型语言：javascript、python、php 解释型语言）&lt;br/&gt;  Scala 是一门多范式 (multi-paradigm) 的编程语言，Scala 支持面向对象和函数式编程。&lt;br/&gt;  Scala 源代码 (.scala) 会被编译成 Java 字节码 (.class)，然后运行于 JVM 之上，&lt;code&gt;并可以调用现有的 Java 类库，实现两种语言的无缝对接&lt;/code&gt;。[案例演示]&lt;br/&gt;  scala 单作为一门语言来看，非常的&lt;strong&gt;简洁高效&lt;/strong&gt;。[对 三元运算，++，-- 等进行简化]&lt;br/&gt;  Scala 在设计时，马丁·奥德斯基 是参考了 Java 的设计思想，可以说 Scala 是源于 java，同时 马丁·奥德斯基 也加入了自己的思想，将函数式编程语言的特点融合到 JAVA 中, 因此，对于学习过 Java 的同学，只要在学习 Scala 的过程中，搞清楚 Scala 和 java 相同点和不同点，就可以快速的掌握 Scala 这门语言。&lt;br/&gt;  快速有效掌握 Scala 的建议 [1、学习 scala 特有的语法。2、搞清楚 scala 和 java 区别。 3、如何规范的使用 scala。]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h15windowsscala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.5 Windows 下搭建 Scala 开发环境&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;安装&amp;amp;配置&lt;br/&gt;  1、Scala 需要 Java 运行时库，安装 Scala 需要首先安装 JVM 虚拟机并配置好，推荐安装 JDK1.8。&lt;br/&gt;  2、在 http://www.scala-lang.org/ 下载 Scala2.11.8 程序安装包&lt;br/&gt;  3、配置 Jdk 的环境变量&lt;br/&gt;  4、配置 SCALA_HOME，&lt;code&gt;SCALA_HOME= D:\program\scala-2.11.8&lt;/code&gt;&lt;br/&gt;  5、将 Scala 安装目录下的 bin 目录加入到 PATH 环境变量，在 PATH 变量中添加：&lt;code&gt;%SCALA_HOME%\bin&lt;/code&gt;&lt;br/&gt;  6、在终端中输入 “scala” 命令打开 scala 解释器&lt;br/&gt;1、&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAieU.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;2、&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGA9yV.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;3、&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGACLT.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h16linuxscala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.6 Linux 下搭建 Scala 开发环境&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  在实际开发中，我们的项目是部署到 linux 上，因此，我们需要在 Linux 下搭建 scala 的环境。Linux 下安装 Scala 的原理机制一样，操作的具体步骤：&lt;br/&gt;1、下载对应的 scala 的安装软件 scala-2.11.8.tgz&lt;br/&gt;2、通过远程登录工具，将安装软件上传到对应的 Linux 系统（xshell6 和 xftp6）&lt;br/&gt;3、mkdir /opt/module/scala 创建目录&lt;br/&gt;4、解压：&lt;code&gt;$ tar -zvxf /opt/software/scala-2.11.8.tgz -C /opt/module/scala/&lt;/code&gt;&lt;br/&gt;5、配置环境变量 vim /etc/profile&lt;br/&gt;在该文件中配置 scala 的 bin 目录 /opt/module/scala/scala-2.11.8/bin&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;export&lt;/span&gt; SCALA_HOME=/opt/module/scala/scala-2.11.8&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;export&lt;/span&gt; PATH=&lt;span class=&quot;hljs-variable&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;hljs-variable&quot;&gt;$SCALA_HOME&lt;/span&gt;/bin&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、使配置文件生效 source /etc/profile&lt;br/&gt;7、测试，命令：scala&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAFwF.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;Scala 的 REPL：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  上面打开的 scala 命令行窗口，我们称之为 REPL，是指：Read Evaluation Print Loop，也称之为交互式解释器。类似于 MySQL 的默认客户端工具。在命令行窗口中输入 scala 指令代码时，解释器会读取指令代码并计算（Evaluation）对应的值，然后将结果打印（Print）出来，接着循环等待用户输入指令（Loop）。&lt;br/&gt;  从技术上讲，这里其实并不是一个解释器，而是指令代码被快速的编译成 Java 字节码并被 JVM 加载执行。最终将执行结果输出到命令行中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h17scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.7 Scala 的开发工具&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h171idea&quot;&gt;&lt;span&gt;&lt;strong&gt;1.7.1 IDEA介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;  IDEA 全称 IntelliJ IDEA，是用于 java 语言开发的集成环境（也可用于其他语言），IntelliJ 在业界被公认为最好的 java 开发工具之一。IDEA 是 JetBrains 公司的产品，这家公司总部位于捷克共和国的首都布拉格。&lt;br/&gt;  java 开发工具很多，比如 netbean、eclipse 等等，单开发 Scala 可选的工具不多，主要使用 IDEA。&lt;br/&gt;  Idea 工具开发 Scala 的快捷键也不是很多，所以使用相对比较简单。&lt;br/&gt;  IDEA 不是专门用于开发 Scala 的 IDE，但是确是最适合开发 Scala 的工具，因为在我们实际工作中，大部分是开发项目，而大数据项目不可避免的会使用到 Java, 所以会进行 Java 和 Scala 两种语言的混合编程。 而 Idea 可以很好的支持 Java 和 Scala 的开发。&lt;br/&gt;  IDEA 的安装与配置详解：https://www.cnblogs.com/chenmingjun/p/10290183.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h172scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.7.2 Scala 插件安装&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  默认情况下 IDEA 不支持 Scala 的开发，需要安装 Scala 插件。&lt;br/&gt;操作的具体步骤：&lt;br/&gt;1、下载插件：scala-intellij-bin-2017.2.6.zip，下载地址：https://plugins.jetbrains.com/plugin/1347-scala，找到对应的版本&lt;br/&gt;2、建议该插件文件放到 scala 的安装目录，我们新建文件夹 /plugin，方便我们管理&lt;br/&gt;3、将插件安装到 idea&lt;br/&gt;4、打开 idea，先找到安装插件的位置 File -&amp;gt; Settings -&amp;gt; Plugins -&amp;gt; Installplugin from disk… -&amp;gt; 选择插件的路径 -&amp;gt; OK -&amp;gt; OK&lt;br/&gt;5、点击 OK，重启 idea&lt;/p&gt;
&lt;h3 id=&quot;h18scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.8 Scala 的开发快速入门&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  需求说明：要求开发一个 Hello.scala 程序，可以输出 “hello world!&quot; [对 scala 程序基本结构说明]。&lt;/p&gt;
&lt;h4 id=&quot;h181windows&quot;&gt;&lt;span&gt;&lt;strong&gt;1.8.1 windows 下开发步骤&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;步骤如下：&lt;br/&gt;  1、可以直接使用文本开发工具[Sublime Text 3]。&lt;br/&gt;  2、将 Scala 代码编写到扩展名为 HelloScala.scala 的文件中。[ 说明: 比如将源码在目录 D:\demo\ScalaDemo 下 ]&lt;br/&gt;  3、通过 scalac 命令对该 scala 文件进行编译，生成 .class 文件。[和javac类似]&lt;br/&gt;  4、命令行下执行 scala HelloScala 就可以看到运行效果。&lt;br/&gt;  5、&lt;code&gt;注意&lt;/code&gt;：scala HelloScala 命令可以直接运行 HelloScala.scala 程序。[内部会有编译和运行过程]&lt;br/&gt;效果截图：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAko4.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;对 scala 程序基本结构说明：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAZWR.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h182linux&quot;&gt;&lt;span&gt;&lt;strong&gt;1.8.2 linux 下开发步骤&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;步骤如下：&lt;br/&gt;  1、直接使用 vim 开发，一个遍历数组的案例。&lt;br/&gt;  2、将 Scala 代码编写到扩展名为 HelloScala.scala 的文件中。[代码说明]&lt;br/&gt;  3、通过 scala 命令对该 scala 文件进行编译，生成 .class 字节码文件。&lt;br/&gt;  4、在终端执行 scala HelloScala 就可以看到运行效果。&lt;br/&gt;  5、&lt;code&gt;注意&lt;/code&gt;：通过 scala HelloScala 命令可以直接运行 HelloScala.scala 程序。&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;scala language-scala&quot;&gt;/**&lt;br/&gt;* 只要以后看到 object HelloScala，我们就应该有如下认识：&lt;br/&gt;*     1、object HelloScala 对应的是一个 HelloScala$ 类型的静态对象 MODULE$。&lt;br/&gt;*     2、object HelloScala 在程序运行中是单例存在的。&lt;br/&gt;*/&lt;br/&gt;object HelloScala {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;hello scala&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h183idea&quot;&gt;&lt;span&gt;&lt;strong&gt;1.8.3 IDEA 下开发步骤&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  使用文本工具开发项目可以很好的理解运行原理，但是不利于开发综合项目，所以在实际开发中我们要使用 Idea 来开发。&lt;br/&gt;步骤如下：&lt;br/&gt;  1、新建一个 Maven 工程，在工程的 main 目录下新建一个 scala 文件夹，将该文件夹标记为【源码文件夹】，方便管理。右键 scala -&amp;gt; Mark Directory as -&amp;gt; Sources Root&lt;br/&gt;  2、默认情况下，不能写 scala 程序，需要我们引入 scala 框架(即将该工程关联上 scala)，选中该项目右键 -&amp;gt; Add Framework Support… -&amp;gt; 勾选左侧 Scala -&amp;gt; 指定 Scala 安装的主目录 -&amp;gt; OK。&lt;br/&gt;  3、在 scala 文件夹上右击，选择新建一个 Scala 类，勾选 Kind 为 Object，如下图所示：&lt;br/&gt;  &lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAuy6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  4、开发一个 HelloScala.scala 程序。&lt;br/&gt;  5、运行后，就可以看到输出。&lt;br/&gt;  &lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAnQx.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h184javascala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.8.4 使用 java 写一段模拟代码，来模拟 scala 的执行流程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;11&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter01.Test;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;HelloScala&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] paramArrayOfString)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;HelloScala$.MODULE$.main(paramArrayOfString);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;HelloScala&lt;/span&gt;$ &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; HelloScala$ MODULE$;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; {&lt;br/&gt;MODULE$ = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HelloScala$();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello scala&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h185scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.8.5 Scala 执行流程分析&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAmS1.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h186scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.8.6 Scala 程序开发注意事项(重点)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;注意事项：&lt;br/&gt;  1、Scala 源文件以 “.scala&quot; 为扩展名。&lt;br/&gt;  2、Scala 程序的执行入口是 main() 函数。&lt;br/&gt;  3、Scala 语言严格区分大小写。&lt;br/&gt;  4、Scala 方法由一条条语句构成，每个语句后不需要分号(&lt;code&gt;Scala 语言会在每行后自动加分号&lt;/code&gt;)，这也体现出 Scala 的简洁性。&lt;br/&gt;  5、如果在同一行有多条语句，除了最后一条语句不需要分号，其它语句需要分号。&lt;/p&gt;
&lt;h3 id=&quot;h19scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.9 Scala 语言转义字符&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;\t      ：一个制表位，实现对齐的功能&lt;br/&gt;\n      ：换行符&lt;br/&gt;\\      ：一个\&lt;br/&gt;\&quot;      ：一个&quot;&lt;br/&gt;\r      ：一个回车  println(&quot;hello\rk&quot;); &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h110scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.10 Scala 语言输出的三种方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  1、字符串通过+号连接（类似java）。&lt;br/&gt;  2、printf 用法（类似C语言）字符串通过 % 传值。&lt;br/&gt;  3、字符串通过 $ 引用（类似PHP）。&lt;br/&gt;示例代码：&lt;/p&gt;
&lt;pre readability=&quot;11&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;16&quot;&gt;package com.atguigu.chapter01&lt;p&gt;/**&lt;br/&gt;* @author chenmingjun&lt;br/&gt;*         2019-03-22 19:14&lt;br/&gt;*/&lt;br/&gt;object PrintDemo {&lt;/p&gt;&lt;p&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val str1: String = &quot;hello&quot;&lt;br/&gt;val str2: String = &quot;world&quot;&lt;br/&gt;// 连接打印&lt;br/&gt;println(str1 + str2)&lt;/p&gt;&lt;p&gt;val name: String = &quot;tom&quot;&lt;br/&gt;val age: Int = 10&lt;br/&gt;val sal: Float = 10.67f&lt;br/&gt;val height: Double = 180.75&lt;br/&gt;// 格式化输出&lt;br/&gt;printf(&quot;名字=%s 年龄=%d 薪水=%.2f 身高=%.3f&quot;, name, age, sal, height)&lt;/p&gt;&lt;p&gt;// scala 支持使用 $ 输出内容&lt;br/&gt;println(s&quot;个人信息如下1：\n 名字$name\n 年龄$age\n 薪水$sal\n&quot;)&lt;br/&gt;// 如果字符串中出现了类似 ${age + 10} ，则表示 {} 是一个表达式&lt;br/&gt;println(s&quot;个人信息如下2：\n 名字${name}\n 年龄${age + 10}\n 薪水${sal}\n&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs nginx&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;helloworld&lt;/span&gt;&lt;br/&gt;名字=tom 年龄=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; 薪水=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;67&lt;/span&gt; 身高=&lt;span class=&quot;hljs-number&quot;&gt;180&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;750&lt;/span&gt;&lt;br/&gt;个人信息如下&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;：&lt;br/&gt;名字tom&lt;br/&gt;年龄&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;&lt;br/&gt;薪水&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;67&lt;/span&gt;&lt;p&gt;个人信息如下&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;：&lt;br/&gt;名字tom&lt;br/&gt;年龄&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;br/&gt;薪水&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;67&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h111scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.11 Scala 源码的查看的关联&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  在使用 scala 过程中，为了搞清楚 scala 底层的机制，需要查看源码，下面看看如果关联和查看 scala 的源码包。&lt;br/&gt;1、查看源码, 选择要查看的方法或者类, 输入 Ctrl + B 或者 双击&lt;br/&gt;当我们没关联源码时，会看到如下图：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAlwD.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我么可以点击 &lt;strong&gt;Download…&lt;/strong&gt; 自动下载源码，也可以手动关联源码。
&lt;p&gt;2、手动关联源码&lt;br/&gt;源码包下载地址：https://www.scala-lang.org/download/2.11.8.html，修改我们下载的源码包 scala-2.11.8.tar.gz 包名为 scala-sources-2.11.8.tar.gz，为了方便识别&lt;br/&gt;步骤一：将我们的源码包拷贝至 scala/lib 文件夹下（scala-sources-2.11.8.tar.gz），这样为了方便管理，然后进行解压（因为 IDEA 不识别 xxx.tar.gz 这种格式的压缩包）&lt;br/&gt;步骤二：关联即可，点击 Attach Sources…，选中 scala-sources-2.11.8 这个文件夹，进行关联，最后，可以看到源码&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGAKOK.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h112&quot;&gt;&lt;span&gt;&lt;strong&gt;1.12 注释&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h1121&quot;&gt;&lt;span&gt;&lt;strong&gt;1.12.1 介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;  用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性。&lt;br/&gt;  注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h1122scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.12.2 Scala 中的注释类型&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、单行注释：格式：// 注释文字&lt;br/&gt;  2、多行注释：格式： /* 注释文字 */&lt;br/&gt;  3、文档注释：注释内容可以被工具 scaladoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。&lt;/p&gt;
&lt;h4 id=&quot;h1123&quot;&gt;&lt;span&gt;&lt;strong&gt;1.12.3 文档注释案例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、打开文件所在的目录，选中文件右键 -&amp;gt; Show in Explorer&lt;br/&gt;  2、在命令行窗口中输入 &lt;code&gt;scaladoc -d d:/mydoc Comment.scala&lt;/code&gt; 可以生成对应的文档说明。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;7&quot;&gt;package com.atguigu.chapter01&lt;p&gt;/**&lt;br/&gt;* 文档注释案例&lt;br/&gt;* @author chenmingjun&lt;br/&gt;*         2019-03-23 0:22&lt;br/&gt;*/&lt;br/&gt;object Comment {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;hello world&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* @deprecated 过期&lt;br/&gt;* @example&lt;br/&gt;*          输入 n1 = 10 n2 = 20 return 30&lt;br/&gt;* @param n2&lt;br/&gt;* @return 求和&lt;br/&gt;*/&lt;br/&gt;def sum(n1: Int, n2: Int): Int = {&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h1124scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.12.4 scala 的代码规范说明&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h4 id=&quot;h1125&quot;&gt;&lt;span&gt;&lt;strong&gt;1.12.5 正确的注释和注释风格&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  查看 Scala 源码。&lt;/p&gt;
&lt;h4 id=&quot;h1126&quot;&gt;&lt;span&gt;&lt;strong&gt;1.12.6 正确的缩进和空白&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、使用一次 tab 操作，实现缩进，默认整体向右边移动，使用 Shift + Tab 整体向左移。&lt;br/&gt;  2、或者使用 Ctrl + Alt + L 来进行格式化代码。&lt;br/&gt;  3、运算符两边习惯性各加一个空格。比如：2 + 4 * 5。&lt;br/&gt;  4、一行最长不超过 80 个字符，超过的请使用换行展示，尽量保持格式优雅。&lt;/p&gt;
&lt;h4 id=&quot;h1127scala&quot;&gt;&lt;span&gt;&lt;strong&gt;1.12.7 Scala 官方编程指南&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;API 下载地址：https://www.scala-lang.org/download/2.11.8.html&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/23/AGA1Te.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h113&quot;&gt;&lt;span&gt;&lt;strong&gt;1.13 本章知识回顾&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Scala 语言的 sdk 是什么？答：Scala 的类库。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Scala 环境变量配置及其作用。&lt;br/&gt;配置 &lt;code&gt;SCALA_HOME=D:\learn\Scala\scala-2.11.8&lt;/code&gt;&lt;br/&gt;配置 &lt;code&gt;Path=%SCALA_HOME%\bin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Scala 程序的编写、编译、运行步骤是什么？能否一步执行?？&lt;br/&gt;编写：就是使用工具，开发 scala 程序。&lt;br/&gt;编译：就是将 .scala 文件编译成 .class 【命令：scalac]】。&lt;br/&gt;运行：就是使用 scala 来将 .class 文件加载到 jvm 并运行，可以直接运行 .scala, 但是速度慢。【命令：scala xxx.scala】。&lt;/li&gt;
&lt;li&gt;Scala 程序编写的规则。&lt;br/&gt;// 规范基本上和 java 类似。但是语句后面不需要加上分号。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;简述：在配置环境、编译、运行各个步骤中常见的错误。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 23 Mar 2019 01:29:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>第一章 Scala 语言概述1.1 why is Scala 语言?1.2 Scala 语言诞生小故事1.3 Scala 和 Java 以及 jvm 的关系分析图1.4 Scala 语言的特点1.5</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10582571.html</dc:identifier>
</item>
<item>
<title>深入理解Git - 一切皆commit - J.晒太阳的猫</title>
<link>http://www.cnblogs.com/jasongrass/p/10582449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jasongrass/p/10582449.html</guid>
<description>&lt;p&gt;在对 git 有了基本理解和知道常规操作之后，如何对 git 的使用有进一步的理解？&lt;br/&gt;&lt;strong&gt;一切皆 commit&lt;/strong&gt; 或许是个不错的理解思路。&lt;/p&gt;
&lt;p&gt;本文将从『一切皆 commit 』的角度，通过 git 中常见的名词，如 commit, branch, tag, HEAD 和动词，如 cherry-pick, rebase, reset, revert, stash 来理解 git。通过这些理解，期望能够更好地处理使用 git 中遇到的问题。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 做了两个提交的修改，然后删掉分支了，过会发现刚才两个提交有价值，怎么找回来？&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;2 基于当前 release 分支开发功能，中途误合并了 dev 分支，&lt;br/&gt;然后又进行了几次提交，怎么取消合并dev的操作？&lt;/li&gt;
&lt;li&gt;3 rebase(变基)究竟是什么意思？&lt;br/&gt;等等。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5.2824074074074&quot;&gt;
&lt;p&gt;配合希沃白板课件食用，效果更佳：&lt;br/&gt;【希沃白板5】课件分享 : 《Git 进阶 - 从使用角度深入理解Git》&lt;br/&gt;&lt;a href=&quot;https://r302.cc/ke8XdO?platform=enpc&amp;amp;channel=copylink&quot; class=&quot;uri&quot;&gt;https://r302.cc/ke8XdO?platform=enpc&amp;amp;channel=copylink&lt;/a&gt;&lt;br/&gt;点击链接直接预览课件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;commit-的原子性&quot;&gt;1 commit 的原子性&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083138379-1587403102.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 git 中有工作区，暂存区和代码仓库三个概念，那为什么要有暂存区呢？为了保证提交的原子性，在 git 的应用层面上，提交（commit，名词）是 git 主要命令的操作的最小单位了。&lt;/p&gt;
&lt;p&gt;关于此，可以查看这篇知乎贴：&lt;a href=&quot;https://www.zhihu.com/question/19946553/answer/29033220&quot;&gt;为什么要先 git add 才能 git commit ？ - Ivony的回答 - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文中的内容很少涉及工作区和暂存区的操作，有了 commit 是 git 操作的基本单位这个概念，接下来将从『一切皆 commit』来理解 git。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一切皆-commit-名词部分&quot;&gt;2 一切皆 commit ：名词部分&lt;/h2&gt;
&lt;h3 id=&quot;本地仓库&quot;&gt;2.1 本地仓库&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083154056-201275795.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，其实比较好理解，我们知道 commit 有一个 commit id，另外还是 branch（分支），tag（标签），HEAD（当前分支头结点）这些概念。他们都是指向某个提交的引用（或者理解为指针）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;branch（分支）：指向你当前工作分支的最新的那个提交，当在当前分支有了新的提交，则 git 自动更新这个分支指针，以指向最新的提交。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;tag（标签）：对某个提交或者分支打 tag 之后，将固定指向那个提交，后续即使分支有更新甚至删除，tag 所指向的提交不变，且一直存在。&lt;/li&gt;
&lt;li&gt;HEAD（头结点）：指向当前工作的分支，即 HEAD 是当前分支的一个引用，如果切换了分支，HEAD 随之更新。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如此，便理解了，branch，tag，HEAD 这些，本质上都是指向某个提交的引用，即：一切都是 commit 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083201728-315630840.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083206523-305894676.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;远端仓库&quot;&gt;2.2 远端仓库&lt;/h3&gt;
&lt;p&gt;有一个引用，需要单独说明，就是 origin/branch ，通常称之为远程分支，那这个远程分支指向哪里呢？&lt;br/&gt;如何在 『一切皆commit』 这句咒语下理解远程仓库？&lt;/p&gt;
&lt;p&gt;以 master 分支为例，origin/master 指向的，就是当前远端 master 分支最新的那个提交。等等，其实这句话有点小问题，应该是最后一次更新本地仓库时，远端 master 分支最新的那个提交。那什么时候会更新远程仓库？在执行 pull push fetch 时更新。&lt;/p&gt;
&lt;p&gt;你或许听说过 git pull = git fetch + git merge 的说法。&lt;br/&gt;当执行 &lt;code&gt;git fetch&lt;/code&gt; 命令时，只更新 origin/master 分支（包括所有其它的 origin 远端分支），但并不会影响本地的任何分支。&lt;/p&gt;
&lt;p&gt;那要更新本地的 master 分支怎么办？ &lt;code&gt;git merge origin/master&lt;/code&gt; ，将远端的分支合并到本地分支，即完成了对本地 master 分支的更新。所以，实际上，git pull = git fetch + git merge 。&lt;br/&gt;&lt;code&gt;(@master)git pull = git fetch &amp;amp; git merge origin/master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;案例&lt;/p&gt;
&lt;p&gt;你在 f/table 分支开发功能，现在需要合并最新dev，可以怎么做？&lt;/p&gt;
&lt;p&gt;刚学 git 时，可能会这么做：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;(@f/table) git checkout dev
(@dev) git pull 
(@dev) git checkout f/table
(@f/table) git merge dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，不需要切到 dev 分支，先更新 dev，则合并。以下命令即可：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;(@f/table) git fetch
(@f/table) git merge origin/dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小结：origin/branch 是指向此分支云端最新提交的引用（最新=最后一次更新），在执行 fetch pull push 指令时自动更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083221507-1149417730.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用 git show 命令查看一个提交的详细信息，&lt;br/&gt;因为 commitId/HEAD/branch/tag/origin-branch 这些都是指向一个提交，所以 show 命令后面写任意一个都可以。&lt;br/&gt;另外，还可以使用其他参数控制显示内容，这里不展开。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git show commitId/HEAD/branch/tag/origin-branch --format=short &lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一切皆-commit-动词部分&quot;&gt;3 一切皆 commit ：动词部分&lt;/h2&gt;
&lt;h3 id=&quot;cherry-pick&quot;&gt;3.1 cherry-pick&lt;/h3&gt;
&lt;p&gt;cherry-pick 比较好理解，就是将一个指定提交的修改摘取过来，举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083234935-344620336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，6 提交是增加一个有用的 helper 类（间接说明，一个 commit 最好功能独立），但你不想将整个分支合并过来，就可以使用 cherry-pick 命令。使用任何一个指向 6 提交的引用都可以。&lt;br/&gt;需要说明的是，cherry-pick 过来的提交，只是内容与之前的提交一样，他们是两个不同的提交。&lt;/p&gt;
&lt;p&gt;案例&lt;/p&gt;
&lt;p&gt;做了两个提交的修改，然后删掉分支了，过会发现刚才两个提交有价值，怎么找回来？&lt;/p&gt;
&lt;p&gt;Step1 使用 &lt;code&gt;git reflog&lt;/code&gt; 查看之前的提交历史，找到需要找回的提交ID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083245929-1937252833.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step2 使用 cherry-pick 命令将需要的提交摘取出来即可。&lt;/p&gt;
&lt;p&gt;如何丢失的提交比较多，除了可以批量 cherry-pick 之外，根据实际情况，可以直接在那些提交的最新提交上，新建一个分支，那些提交在此之前的所有提交，都在新的分支上了。&lt;/p&gt;
&lt;p&gt;新建分支(03620f1 指提交号/commit id)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git branch newbranch 03620f1
git checkout -b newbranch 03620f1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rebase&quot;&gt;3.2 rebase&lt;/h3&gt;
&lt;p&gt;如果用一句话理解 rebase 的话，就是：rebase = 一连串自动的 cherry-pick 。&lt;/p&gt;
&lt;p&gt;关于 rebase ，需要回答三个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么推荐使用 rebase 而不是 merge？&lt;/li&gt;
&lt;li&gt;为什么听说过使用 rebase 会被打？&lt;/li&gt;
&lt;li&gt;使用 rebase 有什么问题(什么情况不用 rebase )？&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;rebase-究竟是什么意思&quot;&gt;rebase 究竟是什么意思？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083302963-712201043.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，假设 dev 上的提交是 1-2-3-4-5，f/table 分支上的提交是 1-2-3-6-7。现在我们需要合并 dev，通常，会使用 &lt;code&gt;(@f/table)git merge dev&lt;/code&gt; 的方式合并。这里，我们使用 rebase 来合并 dev 。&lt;/p&gt;
&lt;p&gt;首先，rebase 会找到 dev 和 f/table 共同的父提交，即 3 提交。然后以 dev 最新的提交为基础，把 f/table 分支上新的提交（这里就是 6 和 7），逐个 cherry-pick 过来。形成新的 f/table 分支。&lt;/p&gt;
&lt;p&gt;注意，整个过程中，对 dev 分支不会有任何影响，因为你是在 f/table 上进行的操作。所有，rebase 的中文翻译，变基，就可以理解为：变基：用 cherry-pick 的方式，给 f/table 上的新提交，换一个基，将基从之前的 3 换到了 dev 所指的提交 5 上。&lt;/p&gt;
&lt;h4 id=&quot;问题1-为什么推荐使用-rebase-而不是-merge&quot;&gt;问题1 为什么推荐使用 rebase 而不是 merge？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083314850-699492472.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当使用 merge 时，提交历史如右侧所示，使用 rebase 的提交历史如下侧所示。&lt;br/&gt;提交历史更清晰，当分支非常多时，回溯提交与查找问题更容易。&lt;/p&gt;
&lt;h4 id=&quot;问题2-为什么听说过使用-rebase-会被打&quot;&gt;问题2 为什么听说过使用 rebase 会被打&lt;/h4&gt;
&lt;p&gt;使用 rebase 会修改提交历史，上面的例子中，6和7提交将不在 f/table 分支上存在，取而代之的是8和9分支，在协作分支上，如果6和7已经存在于远端仓库（即别人可能已经基于此有了新的修改），再将6和7移除，将带来诸多冲突与合并的麻烦。（这是，你 push 时，也需要强推，在协作分支上强推，是很危险的行为。）&lt;br/&gt;所以：rebase只对本地未推送的commit上或自己的分支上进行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083321799-463379180.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;问题3-使用-rebase-有什么问题什么情况不用-rebase&quot;&gt;问题3 使用 rebase 有什么问题(什么情况不用 rebase )&lt;/h4&gt;
&lt;p&gt;使用 rebase 的收益：更简洁清晰易回溯的提交历史。&lt;/p&gt;
&lt;p&gt;使用 rebase 的代价：逐个 cherry-pick ，如果有冲突，需要逐个解冲突，使合并变复杂。&lt;/p&gt;
&lt;p&gt;以合并 dev 分支为例，当工作分支已经做了大量修改（有很多提交，预期有许多冲突），或者之前 merge 过 dev。则建议使用 merge 的方式合并 dev。&lt;/p&gt;
&lt;p&gt;rebase 小结：&lt;br/&gt;rebase : 一连串的 cherry-pick。（移花接木）&lt;/p&gt;
&lt;h3 id=&quot;reset&quot;&gt;3.3 reset&lt;/h3&gt;
&lt;p&gt;reset，重置，将当前分支的状态（这里指工作区，暂存区，代码仓库）重置到指定的状态。reset 的语法如下图，第一个参数是重置方式，后面是一个指向提交的引用（可以是提交ID，分支，tag，HEAD~1等等）。&lt;/p&gt;
&lt;p&gt;与 rebase 一样，reset 只对当前分支和工作区，暂存区的数据有影响，对参数中指定的引用没有影响。即 &lt;code&gt;(@f/table)git reset --hard dev&lt;/code&gt; 这句命令，影响的是 f/table 分支，对 dev 没有任何影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083330496-1978858975.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体来看：&lt;/p&gt;
&lt;h4 id=&quot;git-reset---hard&quot;&gt;git reset --hard&lt;/h4&gt;
&lt;p&gt;从参数名可以猜到，这个重置方式比较“强硬”，实际上就是，将当前分支，重置到与指定引用一样的状态，丢弃在这之后的提交，以及工作区和暂存区的提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083336218-33263985.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;未追踪的文件是不受影响的，PS：git clean 命令会清除掉未追踪的文件。&lt;/p&gt;
&lt;p&gt;案例1&lt;/p&gt;
&lt;p&gt;(@f/table)git reset --hard f/table~2 的含义？&lt;/p&gt;
&lt;p&gt;当前在 f/table 分支，将其重置到 f/table~2 ，结果就是：丢弃掉 f/table 最新的两个提交。&lt;/p&gt;
&lt;p&gt;案例2&lt;/p&gt;
&lt;p&gt;将当前分支重置到远端最新 dev 的状态，怎么做？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(@f/table)git fetch&lt;/code&gt;&lt;br/&gt;&lt;code&gt;(@f/table)git reset --hard origin/dev&lt;/code&gt;&lt;br/&gt;注意，这里需要先 fetch 一下远程仓库，更新 origin/dev 分支。&lt;/p&gt;
&lt;h4 id=&quot;git-reset---soft---mixed&quot;&gt;git reset --soft / --mixed&lt;/h4&gt;
&lt;p&gt;理解了 --hard 的含义，--soft 和 --mixed 就很好理解了，这两个参数，不会丢弃任何内容。&lt;/p&gt;
&lt;p&gt;--soft 会将指定提交之后的提交内容，都放到 暂存区，同理，--mixed 会将指定提交之后的提交内容，以及暂存区中的内容，放到工作区。&lt;/p&gt;
&lt;p&gt;所以，&lt;code&gt;git reset --mixed HEAD&lt;/code&gt; (可以简写为 &lt;code&gt;git reset&lt;/code&gt;)，实现的效果就是：将暂存区中的内容，回退到工作区。&lt;br/&gt;&lt;code&gt;git reset --hard HEAD&lt;/code&gt; (可以简写为 &lt;code&gt;git reset --hard&lt;/code&gt;)，实现的效果就是：将工作区和暂存区中的全部内容。&lt;/p&gt;
&lt;p&gt;案例1 将图中的 2 3 4合并为一个提交&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083344643-1824050497.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例2 移除误合并&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083351165-1102786425.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;revert&quot;&gt;3.4 revert&lt;/h3&gt;
&lt;p&gt;reset 用于修改错误，通常会修改提交历史，&lt;br/&gt;这在团队协作分支上是危险且不允许的（如很多仓库的 master 分支）。&lt;br/&gt;这时可以使用 revert 命令。&lt;/p&gt;
&lt;p&gt;revert 很好理解，就是新建一个提交，用于撤销之前的修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083403271-617385899.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有个问题，revert 一个 merge 提交会怎么样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083408272-580063825.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，如果执行 &lt;code&gt;(@f/table)git revert 6&lt;/code&gt;&lt;br/&gt;会得到类似这样的提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083420420-2084972935.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时，使用 -m 参数可以指定保留那边的提交，可选内容只有 1 和 2 （对于通常的两两合并的情况而言），&lt;br/&gt;1 指代当前分支的那些提交，如果不是很确定，可以使用 git show 命令查看那个合并提交，在前的那个父节点为 1 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662394/201903/662394-20190323083427946-1525346215.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;留两个思考题：&lt;br/&gt;1 如何在一切皆 commit 的语境下理解 git commit --amend&lt;br/&gt;2 如何在一切皆 commit 的语境下理解 git stash&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 00:36:00 +0000</pubDate>
<dc:creator>J.晒太阳的猫</dc:creator>
<og:description>在对 git 有了基本理解和知道常规操作之后，如何对 git 的使用有进一步的理解？ 一切皆 commit 或许是个不错的理解思路。 本文将从『一切皆 commit 』的角度，通过 g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jasongrass/p/10582449.html</dc:identifier>
</item>
<item>
<title>计算机启动过程 - AdamWong</title>
<link>http://www.cnblogs.com/adamwong/p/10582183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adamwong/p/10582183.html</guid>
<description>&lt;p&gt;操作系统老师说，平时面试学生或者毕业答辩的时候他都会问这个问题，可见这个问题对于计算机专业的学生来说是如此重要。那么，从打开计算机电源到计算机的屏幕显示，中间经历了哪些过程呢？&lt;/p&gt;
&lt;p&gt;启动的英文是&lt;code&gt;boot&lt;/code&gt;，来自于一个谚语&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pull oneself up by one's bootstraps
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过拉自己的鞋带把自己拽起&lt;/p&gt;
&lt;p&gt;这个很明显是矛盾的。工程师早期用这句谚语用来比喻早期的计算机开机，&lt;br/&gt;因为计算机启动需要运行程序，而运行程序又需要计算机启动。这个是一个很矛盾的过程。直到后来开机程序被刷入&lt;code&gt;ROM&lt;/code&gt;芯片后，这个开机的&lt;code&gt;boot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大概过程是这样的:&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;Turn on&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CPU jump to physical address of BIOS(In Intel it is 0xFFFF0)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BIOS runs POST(Power-On Self Test)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find bootable devices&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Loads boot sector from MBR&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BIOS yields control to OS BootLoader&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BIOS介绍:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BIOS（Basic Input/Output System）是基本输入输出系统的简称。BIOS 能为电脑提供最低级、最直接的硬件控制与支持，是联系最底层的硬件系统和软件系统的桥梁。为了在关机后使 BIOS 不会丢失，早期的 BIOS 存储在 ROM 中，并且其大小不会超过 64KB；而目前的 BIOS 大多有 1MB 到 2MB，所以会被存储在 闪存（Flash Memory）中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BIOS 设置程序是被固化到电脑主板上地 ROM 芯片中的一组程序，其主要功能是为电脑提供最底层的、最直接的硬件设置和控制。 BIOS 通常与&lt;br/&gt;&lt;strong&gt;硬件系统&lt;/strong&gt;集成在一起（在计算机主板的 ROM 或EEPROM 中），所以也被称为 &lt;strong&gt;固件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.lifewire.com/thmb/AeRVf2oW46AaeaFSwSGDxFHGF28=/768x0/filters:no_upscale():max_bytes(150000):strip_icc()/phoenix-bios-setup-utility-5a0b5e1cda271500370cf924.PNG&quot; alt=&quot;BIOS界面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BIOS存放在一个断电后不会丢失内容的ROM中，这保证了“拽着鞋带拉起自己”的这种情况不会发生。因为系统一上电或重置，处理器要执行第一条指令的地址会被定位到BIOS存储器，初始化开始运行。在X86系统中，CPU加电后跳转至BIOS的固定物理地址0xFFFF0。&lt;br/&gt;打开计算机电源，计算机会首先加载BIOS，包含&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CPU相关信息
设备启动顺序信息
硬盘信息
内存信息
时钟信息
PhP特性
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;硬件自检(Power-On Self Test,POST)&lt;/strong&gt;&lt;br/&gt;如果硬件出现问题，主板会发出不同含义的蜂鸣 ，启动中止。如果没有问题，屏幕就会显示出CPU 、内存、硬盘等信息。BIOS在执行完硬件自检和初始化后，会将自己复制到从 0xA0000 开始的物理内存中并继续执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BIOS 代码包含诊断功能，以保证某些重要硬件组件，像是
键盘、磁盘设备、输出输入端口等等，可以正常运作且正
确地初始化。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;BIOS产生的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开发效率低：大部分BIOS代码使用汇编开发，开发效率不言而喻。汇编开发的另一个缺点是使得代码与设备的耦合程度太高，代码受硬件变化的影响大。&lt;/li&gt;
&lt;li&gt;性能差：BIOS基本输入/输出服务需要通过中断来完成，开销大，并且BIOS没有提供异步工作模式，大量的时间消耗在等待上。&lt;/li&gt;
&lt;li&gt;功能扩展性差，升级缓慢：BIOS代码采用静态链接，增加硬件功能时，必须将16位代码放置在0x0C0000～0x0DFFFF区间，初始化时将其设置为约定的中断处理程序。而且BIOS没有提供动态加载设备驱动的方案。&lt;/li&gt;
&lt;li&gt;安全性：BIOS运行过程中对可执行代码没有安全方面的考虑。&lt;/li&gt;
&lt;li&gt;不支持从硬盘２TB以上的地址引导：受限于BIOS硬盘的寻址方式，BIOS硬盘采用32位地址，因而引导扇区的最大逻辑块地址是232(换算成字节地址，即232×512=2TB)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于这些问题的存在，&lt;code&gt;UEFI&lt;/code&gt;横空出世&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/8d/Efi_flowchart_extended.jpg?1553175603751&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UEFI中文名为&lt;strong&gt;统一可扩展固件界面&lt;/strong&gt;(英语：Unified Extensible Firmware Interface，缩写&lt;strong&gt;UEFI&lt;/strong&gt;)是一种个人电脑系统规格，用来定义操作系统与系统硬件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST），联系操作系统以及提供连接作业系统与硬体的介面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UEFI与BIOS的几个区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;EFI使用模块化、C语言风格的参数堆栈传递方式以及动态链接形式构建的系统，相对于BIOS而言跟容易实现，容错和纠错特性更强，减少系统研发的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;运行于32位或64位模式，面对未来增强的处理器模式下，能突破BIOS 16位代码的寻址能力，达到处理器最大寻址。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;UEFI有良好的鼠标操控图形化界面，在开机速度也比BIOS快不少&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;BIOS&lt;/strong&gt;过程&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575923/201903/1575923-20190322235352840-872134986.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UEFI&lt;/strong&gt;过程&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575923/201903/1575923-20190322235517497-707866623.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相对来说UEFI比BIOS少了一个硬件检测&lt;/p&gt;
&lt;p&gt;即使如此，本章启动过程还是着重于分析利用BIOS启动的过程。&lt;/p&gt;

&lt;p&gt;MBR-全称是Master Boot Record(主引导记录或主开机记录)，是一个512byte的扇区，位于磁盘的固定位置。之所以叫“主引导记录”，是因为其存在于驱动器开始部分的一个特殊扇区，个扇区包含已安装的操作系统启动记载器和驱动器的逻辑分区信息。BIOS完成POST和初始化之后，会根据CMOS中设定的顺序选择引导的设备，这个设备可以是U盘可以是硬盘。若设置为硬盘，则BIOS就会读取MBR。MBR里面包含了一段引导程序，一个分区表和Magic Number。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MBR的结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.maixj.net/pics/uploads/2017/06/MBR.jpg&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1-445字节&lt;/td&gt;
&lt;td&gt;调用操作系统的机器码(Call OS)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;447-510字节&lt;/td&gt;
&lt;td&gt;分区表(Partition table)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;511-512字节&lt;/td&gt;
&lt;td&gt;主引导记录签名(只有两个，0x55和0xAA，为Magic Number)，如果不是这两个幻数，就认为这是一个没有被分区的硬盘。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;分区表的长度只有64个字节，里面分为四项，每项为16个字节。所以一个硬盘只可以分四个一级分区，又叫做“主分区”。每个主分区的16个字节，结构如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;如果第一个为0x80，表示该主分区是激活分区(active)，控制权将转交给此分区。几个分区中只能有一个是激活分区，其他都是非激活分区(inactive)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;2-4&lt;/td&gt;
&lt;td&gt;主分区的第一个扇区物理位置(柱面、磁头、扇区号等)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;主分区的类型 分区类型符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;6-8&lt;/td&gt;
&lt;td&gt;主分区最后一个扇区的物理位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;9-12&lt;/td&gt;
&lt;td&gt;主分区第一个扇区的逻辑位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;13-16&lt;/td&gt;
&lt;td&gt;主分区的扇区总数，决定了主分区的长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中第5字节分区类型符，有如下特定符&lt;/p&gt;
&lt;p&gt;00H H —— 表示该分区未用 （ 即没有指定 ） ；&lt;/p&gt;
&lt;p&gt;06H H —— FAT 16 基本分区；&lt;/p&gt;
&lt;p&gt;0 0 BH —— FAT 32 基本分区；&lt;/p&gt;
&lt;p&gt;05H H —— 扩展分区；&lt;/p&gt;
&lt;p&gt;07H H —— NTFS 分区；&lt;/p&gt;
&lt;p&gt;0 0 FH —— （ LBA 模式 ） 扩展分区 (83H H 为 Linux)&lt;/p&gt;
&lt;p&gt;分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，也可以不全分，剩下的部分就浪费了。扩展分区不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一 部分 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;硬盘的容量 ＝ 主分区的容量 ＋ 扩展分区的容量

扩展分区的容量 ＝ 各个逻辑分区的容量之和&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://resources.infosecinstitute.com/wp-content/uploads/040213_2007_LinuxBootin1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Linux的Boot的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boot Loader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又叫做 操作系统内核加载器(OS kernel loader)，一个在&lt;code&gt;kernel&lt;/code&gt;运行前运行的一段小程序，通过这段程序可以初始化硬件设备，建立内存空间的映射，将系统软硬件环境带到一个合适的状态，便于未来调用操作系统内核。&lt;/p&gt;
&lt;p&gt;Linux下引导加载程序常见两种&lt;a href=&quot;https://www.wikiwand.com/zh-hk/LILO&quot;&gt;LILO&lt;/a&gt;和&lt;a href=&quot;https://www.wikiwand.com/zh/GNU_GRUB&quot;&gt;GNU GRUB&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;无交互命令界面&lt;/td&gt;
&lt;td&gt;有交互命令界面&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;不支持网络引导&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;错误配置MBR会让系统无法引导&lt;/td&gt;
&lt;td&gt;如果配置文件错误，则默认跳转到GRUB命令行界面&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;GRUB 磁盘引导的过程如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- stage1: grub 读取磁盘第一个 512 字节(硬盘的0道0 面1扇区，被称为 MBR (主引导记录)， 也称为bootsect )。 MBR 由一部分 bootloader 的引导代
码、分区表和魔数三部分组成。（ 启动的第二步 ）
- Stage1.5: 识别各种不同的文件系统格式。这使得 grub 识别到文件系统。
- stage2: 加载系统引导菜单 (/boot/grub/ menu.lst或 grub.lst) ) ，加载内核映像 (kernel image) 和 RAM磁盘 initrd （可选）。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行主引导程序的具体过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BIOS将硬盘主引导记录读入7C00处，并将控制权交给主引导程序:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查0x7dfe地址处是否等于0xaa55。不是则去其他介质；如果没有启动的介质，显示“No ROME BASIC”并死机。&lt;/li&gt;
&lt;li&gt;成功找到介质，跳转到0X7C00执行MBR的程序&lt;/li&gt;
&lt;li&gt;将自己复制到0x0600处且继续执行&lt;/li&gt;
&lt;li&gt;主分区表中搜索标志为激活的分区，如果发现没有激活分区或者不止一个激活分区则停止。&lt;/li&gt;
&lt;li&gt;将激活分区的第一个扇区读入内存地址0x7c00&lt;/li&gt;
&lt;li&gt;再次检查位于地址0x7dfe的内容是否等于0xaa55，若不等则停止并尝试软盘启动&lt;/li&gt;
&lt;li&gt;跳转到0x7c00继续执行特定系统的启动程序&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;补充：MBR和引导扇区的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575923/201903/1575923-20190322235548875-1362994985.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MBR存放的位置是整个硬盘的第一个扇区&lt;/li&gt;
&lt;li&gt;Boot Sector是硬盘上每一个分区的第一个扇区&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要有两个步骤:&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;根据 grub 设定的内核映像所在路径 ,系统读取内存映像 ,并进行解压缩操&lt;br/&gt;作 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;系统将解压后的内核放置在内存之中， 初始化函数并初始化各种设备 ， 完&lt;br/&gt;成 Linux 核心环境的建立 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以Linux系统为例，先载入/boot目录下面的kernel。&lt;/p&gt;
&lt;p&gt;内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。&lt;/p&gt;
&lt;p&gt;然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入username和password。&lt;/p&gt;
&lt;p&gt;至此，全部启动过程完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575923/201903/1575923-20190322235336116-1923591233.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 15:56:00 +0000</pubDate>
<dc:creator>AdamWong</dc:creator>
<og:description>介绍 操作系统老师说，平时面试学生或者毕业答辩的时候他都会问这个问题，可见这个问题对于计算机专业的学生来说是如此重要。那么，从打开计算机电源到计算机的屏幕显示，中间经历了哪些过程呢？ 启动的英文是 ，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adamwong/p/10582183.html</dc:identifier>
</item>
<item>
<title>关于asyncio知识（四） - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/10581972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/10581972.html</guid>
<description>&lt;h2 id=&quot;h2--asyncio-&quot;&gt;一、使用 asyncio 总结&lt;/h2&gt;
&lt;p&gt;最近在公司的一些项目中开始慢慢使用python 的asyncio, 使用的过程中也是各种踩坑，遇到的问题也不少，其中有一次是内存的问题，自己也整理了遇到的问题以及解决方法详细内容看：&lt;a href=&quot;https://www.syncd.cn/article/memory_trouble&quot;&gt;https://www.syncd.cn/article/memory_trouble&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在前面整理的三篇asyncio文章中，也都是使用asyncio的一些方法，但是在实际项目中使用还是避免不了碰到问题， 在这周的工作中遇到之前碰见过的问题，一个初学asyncio写代码中经常会碰到的问题，我的业务代码在运行一段时间后提示如下错误提示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Task was destroyed but it &lt;span&gt;is&lt;/span&gt; pending!task: &amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at ex10.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个错误我在前面几篇关于asyncio的系列文章中也反复说过这个问题，我也认为自己不会在出现这种问题，但是意外的是，我的程序还是出现了这个错误。&lt;/p&gt;
&lt;p&gt;我将我的业务代码通过一个demo代码进行模拟复现以及解决这个问题，下面整理的就是这个过程&lt;/p&gt;
&lt;h2 id=&quot;h2--task-was-destroyed-but-it-is-pending-&quot;&gt;二、“Task was destroyed but it is pending!”&lt;/h2&gt;
&lt;p&gt;我通过下面这张图先描述一下demo程序的逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997599/201903/997599-20190322225901944-77229557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Queue
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; uuid
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Lock
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CancelledError
queue &lt;/span&gt;=&lt;span&gt; Queue()
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HandleMsg(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, unid, coroutine_queue, handle_manager):
        self.unid &lt;/span&gt;=&lt;span&gt; unid
        self.coroutine_queue &lt;/span&gt;=&lt;span&gt; coroutine_queue
        self.handle_manager &lt;/span&gt;=&lt;span&gt; handle_manager
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_msg(self):
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            coroutine_msg &lt;/span&gt;=&lt;span&gt; await self.coroutine_queue.get()
            msg_type &lt;/span&gt;= coroutine_msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每个当一个unid收到end消息为结束&lt;/span&gt;
&lt;span&gt;                await self.handle_manager.del_unid(self.unid)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HandleManager(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    用于unid和queue的关系的处理
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
        self.lock &lt;/span&gt;= Lock(loop=&lt;span&gt;self.loop)
        self.handle_dict &lt;/span&gt;=&lt;span&gt; dict()
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; unid_bind(self, unid, coroutine_queue):
        async with self.lock:
            self.handle_dict[unid] &lt;/span&gt;=&lt;span&gt; coroutine_queue
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_queue(self, unid):
        async with self.lock:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; unid &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.handle_dict:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.handle_dict[unid]
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; del_unid(self, unid):
        async with self.lock:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; unid &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.handle_dict:
                self.handle_dict.pop(unid)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_uniqueid():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    生成unid
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    uniqueid &lt;/span&gt;=&lt;span&gt; str(uuid.uuid1())
    uniqueid &lt;/span&gt;= uniqueid.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    uniqueid.reverse()
    uniqueid &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;.join(uniqueid)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; uniqueid
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; product_msg():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    生产者
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        unid &lt;/span&gt;=&lt;span&gt; make_uniqueid()
        msg_start &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: unid, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
        await queue.put(msg_start)
        msg_end &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: unid, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
        await queue.put(msg_end)
        loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
        await asyncio.sleep(&lt;/span&gt;0.2, loop=&lt;span&gt;loop)
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; consumer_from_queue(handle_manager):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    消费者
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        msg &lt;/span&gt;=&lt;span&gt; await queue.get()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consumer recv %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; msg)
        msg_type &lt;/span&gt;= msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        unid &lt;/span&gt;= msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            coroutine_queue &lt;/span&gt;= Queue()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于和handle_msg协程进行数据传递&lt;/span&gt;
            handle_msg =&lt;span&gt; HandleMsg(unid, coroutine_queue, handle_manager)
            await handle_manager.unid_bind(unid, coroutine_queue)
            await coroutine_queue.put(msg)
            loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次的start消息创建一个task 去处理消息&lt;/span&gt;
&lt;span&gt;            loop.create_task(handle_msg.get_msg())
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            coroutine_queue &lt;/span&gt;=&lt;span&gt; await handle_manager.get_queue(unid)
            await coroutine_queue.put(msg)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
    handle_manager &lt;/span&gt;=&lt;span&gt; HandleManager()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  在最开始创建了两个task 分别是生产者和消费者&lt;/span&gt;
&lt;span&gt;    loop.create_task(product_msg())
    loop.create_task(consumer_from_queue(handle_manager))
    loop.run_forever()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码表面上看没啥问题，我们先看看运行效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
consumer recv {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;784f436cfaf388f611e94ca974e1ffbe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
consumer recv {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;784f436cfaf388f611e94ca974e1ffbe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
..........&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序没运行一段时间都会出现上面显示的错误提示，我先看看错误提示的信息：&lt;/p&gt;
&lt;blockquote&gt;

&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L2&quot;&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Task &lt;span class=&quot;pln&quot;&gt;was destroyed but it &lt;span class=&quot;kwd&quot;&gt;is &lt;span class=&quot;pln&quot;&gt;pending&lt;span class=&quot;pun&quot;&gt;!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;pln&quot;&gt;task&lt;span class=&quot;pun&quot;&gt;: &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;span class=&quot;typ&quot;&gt;Task &lt;span class=&quot;pln&quot;&gt;pending coro&lt;span class=&quot;pun&quot;&gt;=&amp;lt;&lt;span class=&quot;typ&quot;&gt;HandleMsg&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;get_msg&lt;span class=&quot;pun&quot;&gt;() &lt;span class=&quot;pln&quot;&gt;done&lt;span class=&quot;pun&quot;&gt;, &lt;span class=&quot;pln&quot;&gt;defined at demo&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;py&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;lit&quot;&gt;17&lt;span class=&quot;pun&quot;&gt;&amp;gt; &lt;span class=&quot;pln&quot;&gt;wait_for&lt;span class=&quot;pun&quot;&gt;=&amp;lt;&lt;span class=&quot;typ&quot;&gt;Future &lt;span class=&quot;pln&quot;&gt;cancelled&lt;span class=&quot;pun&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;p&gt;上面提示的其实就是我的task 是在pendding状态的时候被destroyed了，代码行数以及调用方法都告诉我们了是在：HandleMsg.get_msg() done, defined at demo.py:17&lt;/p&gt;
&lt;p&gt;其实问题也比较好找，我们为每个unid创建了一个task来处理消息，但是当我们收到每个unid消息的end消息之后其实这个task任务对于我们来说就已经完成了，同时我们删除了我的unid和queue的绑定，但是我们并没有手动去取消这个task。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;span&gt;注意：这里我其实也有一个不理解的地方：关于这个task为什么会会destroyed，这个协程里是一个死循环一直在收消息，当queue里面没有消息协程也应该一直在await 地方在等待才对，但是如果我们把收到end消息的那个地方的删除unid和queue的绑定关系不删除，那么这个任务是不会被descroyed。所以没有完全明白这里的机制，如果明白的同学欢迎留言讨论&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;但是即使上面的机制我们有点不是特别明白，我们其实也应该把这个task手动进行cancel的，我们们将上面的代码稍微进行改动如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_msg(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                coroutine_msg &lt;/span&gt;=&lt;span&gt; await self.coroutine_queue.get()
                msg_type &lt;/span&gt;= coroutine_msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每个当一个unid收到end消息为结束&lt;/span&gt;
&lt;span&gt;                    await self.handle_manager.del_unid(self.unid)
                    current_task &lt;/span&gt;=&lt;span&gt; asyncio.Task.current_task()
                    current_task.cancel()   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 手动cancel 当前的当前的task&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; CancelledError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid [%s] cancelled success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %self.unid)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有个问题需要注意就是当我们对task进行cancel的时候会抛出cancelledError异常，我们需要对异常进行处理。官网也对此进行专门说明：&lt;br/&gt;&lt;a href=&quot;https://docs.python.org/3.6/library/asyncio-task.html#coroutine&quot;&gt;https://docs.python.org/3.6/library/asyncio-task.html#coroutine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cancel()
Request that this task cancel itself.
This arranges &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; a CancelledError to be thrown into the wrapped coroutine on the next cycle through the event loop. The coroutine then has a chance to clean up &lt;span&gt;or&lt;/span&gt; even deny the request using &lt;span&gt;try&lt;/span&gt;/&lt;span&gt;except&lt;/span&gt;/&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;.
Unlike Future.cancel(), this does &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; guarantee that the task will be cancelled: the exception might be caught &lt;span&gt;and&lt;/span&gt; acted upon, delaying cancellation of the task &lt;span&gt;or&lt;/span&gt; preventing cancellation completely. The task may also &lt;span&gt;return&lt;/span&gt; a value &lt;span&gt;or&lt;/span&gt; &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; a different exception.
Immediately after this method &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; called, cancelled() will &lt;span&gt;not&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; True (unless the task was already cancelled). A task will be marked as cancelled when the wrapped coroutine terminates with a CancelledError exception (even &lt;span&gt;if&lt;/span&gt; cancel() was &lt;span&gt;not&lt;/span&gt; called).
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;h2--&quot;&gt;三、小结&lt;/h2&gt;
&lt;p&gt;虽然还有一些地方不太明白，但是随着用的越多，碰到的问题越多，一个一个解决，可能现在对某些知识还有点模糊，但是至少比刚开始使用asyncio的时候清晰了好多，之前整理的三篇文章的连接如下：&lt;br/&gt;&lt;a href=&quot;https://www.syncd.cn/article/asyncio_article_01&quot;&gt;https://www.syncd.cn/article/asyncio_article_01&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.syncd.cn/article/asyncio_article_02&quot;&gt;https://www.syncd.cn/article/asyncio_article_02&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.syncd.cn/article/asyncio_article_03&quot;&gt;https://www.syncd.cn/article/asyncio_article_03&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也欢迎加入交流群一起讨论相关内容：948510543&lt;/p&gt;


</description>
<pubDate>Fri, 22 Mar 2019 15:02:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<og:description>一、使用 asyncio 总结 最近在公司的一些项目中开始慢慢使用python 的asyncio, 使用的过程中也是各种踩坑，遇到的问题也不少，其中有一次是内存的问题，自己也整理了遇到的问题以及解决方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/10581972.html</dc:identifier>
</item>
</channel>
</rss>