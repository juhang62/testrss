<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>曹工杂谈：一例简单的Jar包冲突解决示例 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/11403444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/11403444.html</guid>
<description>&lt;p class=&quot;postTitle&quot;&gt;&lt;span&gt;Jar包冲突的相关文章：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/grey-wolf/p/11028975.html&quot;&gt;了不得，我可能发现了Jar 包冲突的秘密&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;jar包冲突分多种，简单理解来说，就是同package且同名的类在多个jar包内出现，如果两个jar包在同一个classloader下，那么最终的结果是，只会加载其中的一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时，这个错误一般在运行时出现，报的错可能是，找不到某方法，或者呢，更隐蔽的，不会报错，但是逻辑不对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对运行中的应用，可以考虑使用阿里出品的arthas来处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我今天呢，只是简单的找不到方法的情况，所以不需要用到那个。 我这里的场景是，在学习rocketMq的过程中，其依赖的jar包如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.apache.rocketmq&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;rocketmq-client&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;4.3.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;该jar包间接依赖如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201908/519126-20190824074216702-64229838.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图是截的idea插件，maven helper。但是一开始并没想起来去看这里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么会冲突呢，因为我把测试类写在了一个使用了netty 5 版本的工程里。（为了偷懒。。）&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;我这里报错如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; Exception in thread &quot;main&quot; &lt;span&gt;java.lang.NoSuchMethodError: io.netty.bootstrap.Bootstrap.channel&lt;/span&gt;(Ljava/lang/Class;)Lio/netty/bootstrap/&lt;span&gt;AbstractBootstrap;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     at org.apache.rocketmq.remoting.netty.NettyRemotingClient.start(NettyRemotingClient.java:165&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     at org.apache.rocketmq.client.impl.MQClientAPIImpl.start(MQClientAPIImpl.java:225&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     at org.apache.rocketmq.client.impl.factory.MQClientInstance.start(MQClientInstance.java:234&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.start(DefaultMQProducerImpl.java:171&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.start(DefaultMQProducerImpl.java:144&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     at org.apache.rocketmq.client.producer.DefaultMQProducer.start(DefaultMQProducer.java:172&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     at rocketmq.TestRocketMq$SyncProducer.main(TestRocketMq.java:21)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面意思就是，io/netty/bootstrap/AbstractBootstrap 不存在 channel(Ljava/lang/Class;) 这个方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我在ide里，打开了netty 5 jar包里的这个类，确实没找到这个方法，估计就是这个原因了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么验证程序加载了这个类呢？直接在启动参数里，加入 -verbose:class ，然后重新启动，过程中会打印出加载的class：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201908/519126-20190824074824928-1728326922.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201908/519126-20190824074847857-372604456.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图可以看到，果然是从5.0版本的netty里加载的。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;idea里安装maven helper插件，然后选择pom，下图即可看出冲突的jar包：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201908/519126-20190824075054699-833202897.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但是，说实话，这个一般事先并不会去看，很有可能都是事后出问题才去这里看。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;今天这个场景很简单，文章开头那个链接里的案例要复杂一点（windows上可以，linux不行）。大家也可以看下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jar包为什么冲突？这里再理解下，因为在jvm里，一个类是唯一的，说明类加载器相同 + 类的全路径名相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果同一个类加载器下出现了两个全路径相同的类，自然就冲突了。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 23:58:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>Jar包冲突的相关文章： 了不得，我可能发现了Jar 包冲突的秘密 一、前言 jar包冲突分多种，简单理解来说，就是同package且同名的类在多个jar包内出现，如果两个jar包在同一个classl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/11403444.html</dc:identifier>
</item>
<item>
<title>Nginx+Zuul集群实现高可用网关 - noneplus</title>
<link>http://www.cnblogs.com/noneplus/p/11403404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noneplus/p/11403404.html</guid>
<description>&lt;p&gt;代码参考：https://github.com/HCJ-shadow/Zuul-Gateway-Cluster-Nginx&lt;/p&gt;


&lt;p&gt;前期准备&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 7001
spring:
  application:
    name: zuul-gateway

eureka:
  client:
    service-url:
      defaultZone: http://eureka2001.com:2001/eureka/,http://eureka2002.com:2002/eureka/,http://eureka2003.com:2003/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;主类{注解@EnableZuulProxy}&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package zkrun.top;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;

@SpringBootApplication
@EnableEurekaClient
@EnableZuulProxy
public class App_gateway_7001 {
    public static void main(String[] args) {
        SpringApplication.run(App_gateway_7001.class,args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;依次运行Eureka，provider和gateway&lt;/p&gt;

&lt;p&gt;访问：http://localhost:2001/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042219838-1720672072.png&quot; alt=&quot;1566496950128&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问提供者的hello路径：http://localhost:5001/hello&lt;/p&gt;
&lt;p&gt;网关默认的映射路径：http://localhost:7001/msc-provider/hello&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认路由规则：http://zuulhost:zuulport/微服务在Eureka上的serviceId/路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;serviceId小写即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042213197-59263667.png&quot; alt=&quot;1566497384654&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义路由规则&quot;&gt;自定义路由规则&lt;/h2&gt;
&lt;p&gt;默认的路由规则是通过服务名称来路由的，也可以自定义路由的名称，增强服务的安全性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zuul:
  routes:
    api-a:
      path: /api-a/**
      serviceId: msc-provider
#    api-b:
#      path: /api-b/**
#      serviceId: service-feign&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户访问：&lt;br/&gt;http://localhost:7001/api-a/hello&lt;/p&gt;
&lt;p&gt;也可达到上述效果。本质上就是隐藏了微服务名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042206351-664800351.png&quot; alt=&quot;1566586070236&quot;/&gt;&lt;/p&gt;

&lt;p&gt;zuul的过滤器主要用在身份验证上。&lt;/p&gt;

&lt;p&gt;创建一个简单的过滤器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package zkrun.top.filter;


import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;

@Component
public class MyFilter extends ZuulFilter {

    private static Logger log = LoggerFactory.getLogger(MyFilter.class);

    /**
     * filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：
     * pre：路由之前
     * routing：路由之时
     * post： 路由之后
     * error：发送错误调用
     * @return
     */
    @Override
    public String filterType() {
        return &quot;pre&quot;;
    }

    /**
     * filterOrder：过滤的顺序
     * @return
     */
    @Override
    public int filterOrder() {
        return 0;
    }


    /**
     * shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。
     * @return
     */
    @Override
    public boolean shouldFilter() {
        return true;
    }

    /**
     * run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。
     * @return
     */
    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
        System.out.println(request);

        Object  token = request.getParameter(&quot;token&quot;);
        System.out.println(token);
        if(token == null) {
            log.info(&quot;fail&quot;);
            ctx.setSendZuulResponse(false);
            ctx.setResponseStatusCode(401);//401表示无权限
            try {
                ctx.getResponse().getWriter().write(&quot;token is empty&quot;);
            }catch (Exception e)
            {}
            return null;
        }
        log.info(&quot;pass&quot;);
        return null;

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不加token的话：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042200736-1927231623.png&quot; alt=&quot;1566587036580&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加了token：&lt;/p&gt;
&lt;p&gt;http://localhost:7001/api-a/hello?token=1234&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042153116-851544795.png&quot; alt=&quot;1566588398996&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际开发中，从数据库中取出用户信息和表单信息进行匹配，实现鉴权功能。&lt;/p&gt;

&lt;p&gt;两个作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Nginx通过轮询实现负载均衡&lt;/li&gt;
&lt;li&gt;Zuul通过集群实现高可用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大致是这样一个图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042147610-690862791.png&quot; alt=&quot;1566590072068&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现思路：&lt;/p&gt;
&lt;p&gt;zuul网关每个除了端口的差异之外，其他的过滤器，路由都相同。&lt;/p&gt;
&lt;p&gt;创建7001，7002，7003端口的网关。&lt;/p&gt;

&lt;p&gt;nginx配置：&lt;/p&gt;
&lt;p&gt;下载：&lt;/p&gt;
&lt;p&gt;http://nginx.org/en/download.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042141070-1459025852.png&quot; alt=&quot;1566590347942&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042133893-1566632369.png&quot; alt=&quot;1566590372213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042126543-1908497207.png&quot; alt=&quot;1566590616898&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  #配置上游服务器网关端口集群,默认轮询机制
    upstream  backServer{
        server 127.0.0.1:7001 weight=1;
        server 127.0.0.1:7002 weight=1;
        server 127.0.0.1:7003 weight=1;

    }

    server {
        listen       80;
        server_name  nginxtest.com;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            ### 指定上游服务器负载均衡服务器
            proxy_pass http://backServer/;
            index  index.html index.htm;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试-1&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;启动Eureka&lt;/p&gt;
&lt;p&gt;启动Provider&lt;/p&gt;
&lt;p&gt;启动Zuul网关集群&lt;/p&gt;
&lt;p&gt;启动Nginx&lt;/p&gt;

&lt;p&gt;Nginx启动：（双击）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042121214-637542652.png&quot; alt=&quot;1566590678943&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042115471-1788936386.png&quot; alt=&quot;1566591108823&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042109779-799922571.png&quot; alt=&quot;1566591154773&quot;/&gt;&lt;/p&gt;
&lt;p&gt;轮询到7002&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nginxtest.com/api-a/hello?token=2&quot; class=&quot;uri&quot;&gt;http://nginxtest.com/api-a/hello?token=2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;轮询到7001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190824042102768-756004610.png&quot; alt=&quot;1566591226465&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 20:30:00 +0000</pubDate>
<dc:creator>noneplus</dc:creator>
<og:description>﻿代码参考：https://github.com/HCJ shadow/Zuul Gateway Cluster Nginx Zuul的路由转发功能 前期准备 搭建Eureka服务注册中心 服务提供者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/noneplus/p/11403404.html</dc:identifier>
</item>
<item>
<title>go 学习笔记之详细说一说封装是怎么回事 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/11403292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/11403292.html</guid>
<description>&lt;blockquote readability=&quot;2.671875&quot;&gt;
&lt;p&gt;关注公众号[雪之梦技术驿站]查看上篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s/l-nqzYjcre2g__BrVptR9A&quot;&gt;猜猜看go是不是面向对象语言？能不能面向对象编程？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然在上篇文章中,我们通过尝试性学习探索了 &lt;code&gt;Go&lt;/code&gt; 语言中关于面向对象的相关概念,更确切的说是关于封装的基本概念以及相关实现.&lt;/p&gt;
&lt;p&gt;但那还远远不够,不能满足于一条路,而是应该尽可能地多走几条路,只有这样才能为以后可能遇到的问题积攒下来经验,所以这一节我们将继续探索封装.&lt;/p&gt;
&lt;h2 id=&quot;何为探索性学习&quot;&gt;何为探索性学习&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-bc84003e5d5c7ef1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-exploratory-learning.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过现有知识加上思想规则指导不断猜想假设逐步验证的学习过程是探索性学习,这样既有利于我们思考又能加深我们对新知识的理解,何乐而不为?&lt;/p&gt;
&lt;p&gt;学习 &lt;code&gt;Go&lt;/code&gt; 语言的过程越发觉得吃力,倒不是因为语法晦涩难懂而是因为语法习惯背后蕴藏的思维习惯差异性太大!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 语言相对于其他主流的编程语言来说是一种新语言,不仅体现在语法层面更重要的是实现思路的差异性.&lt;/p&gt;
&lt;p&gt;尤其是对于已有其他编程经验的开发者而言,这种体会更加深刻,原本可能觉得理所应当的事情到了 &lt;code&gt;Go&lt;/code&gt; 语言这里基本上都变了模样,很大程度上都换了一种思路去实现,这其实是一件好事,不同的思维碰撞才能促进思考进步,一成不变的话,谈何创新发展?&lt;/p&gt;
&lt;p&gt;在这里不得不感谢强大的 &lt;code&gt;IDE&lt;/code&gt; 开发工具,没有它我们就不能及时发现错误,正是这种快速试错的体验才给我们足够的反馈,运用已有的编程经验逐步接近 &lt;code&gt;Go&lt;/code&gt; 语言编程的真相.&lt;/p&gt;
&lt;p&gt;上篇文章中已经确定主线方向,基本上弄清楚了面向对象中的封装概念以及实现,为了不遗漏任何可能重要的知识点,本文将继续开放性探索,力争讲解清楚封装的知识点.&lt;/p&gt;
&lt;p&gt;如果这种学习的过程用走迷宫来比喻的话,一条道走到黑这种策略就是算法理论中的深度优先算法.如果边走边看,四处观望周围的风景就是广度优先算法.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-e80a934aba71467d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-exploratory-maze.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以,聪明的你肯定已经猜到了,上文采用的正是深度优先算法而本文则采用广度优先算法继续探索封装对象之旅!&lt;/p&gt;
&lt;h2 id=&quot;定义结构体&quot;&gt;定义结构体&lt;/h2&gt;
&lt;p&gt;结构体的定义方式只有一种,或者不存在简化形式吗?&lt;/p&gt;
&lt;p&gt;个人觉得不会不存在简化形式,当结构体存在多个字段,标准定义方式是合理使用的,但要是字段只有一个,仍然以标准形式定义结构体未免有种杀鸡焉用牛刀的感觉.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyDynamicArray struct {
    ptr *[10]int
    len int
    cap int
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所谓的结构体只不过是实现封装的一种手段,当封装的对象只有一个字段时,这个字段也就不存在字段名或者说这个唯一的字段名应该就可以由编译器自动定义,因此字段名可以省略.&lt;/p&gt;
&lt;p&gt;字段类型肯定是不可或缺的,这么想的话,对于封装只有一个字段的对象来说,只需要考虑的是这个唯一字段的类型.&lt;/p&gt;
&lt;p&gt;基于上述原因,个人觉得是这种猜想是合情合理的,但是按照已有的知识能否实现呢?&lt;/p&gt;
&lt;p&gt;简单起见,暂时先以上篇文章中关于动态数组的结构体声明为例作为测试案例.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyDynamicArray struct {
    ptr *[10]int
    len int
    cap int
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一定要从三个字段中选择一个字段,那只能是保留内部数组,排除其余字段了,同时最终结果上可能实现不了动态数组的功能,语义上会有所欠缺,那就不论语义,只谈技术!&lt;/p&gt;
&lt;p&gt;由于只保留内部数组,动态数组就变成下面这样.失去了动态数组的语义,命名上也做了改变,姑且称之为 &lt;code&gt;MyArray&lt;/code&gt; 吧!&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyArray struct {
    arr [10]int
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显,现在仍然是结构体的标准语法形式,请随我一起思考一下如何简化这种形式?&lt;/p&gt;
&lt;p&gt;因为这种简化形式的内部字段只有一个,所以字段名必须省略而字段类型可能不同,因此应该在简化形式中只保留声明内部字段类型的部分.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyArray struct {
    [10]int
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于多个字段时才需要换行分隔,一个字段自然是不需要换行的,因此大括号也是没必要存在的,这也是符合 &lt;code&gt;Go&lt;/code&gt; 设计中尽可能精简的情况下保证语义清晰的原则.&lt;/p&gt;
&lt;p&gt;当然如果你问我是否真的有这个原则的话,我的回答是可能有也可能没有.&lt;/p&gt;
&lt;p&gt;因为我也不知道,只是近期学习 &lt;code&gt;Go&lt;/code&gt; 语言的一种感觉,处处体现了这么一种哲学思想,也不用较真,只是个人看法.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyArray struct [10]int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在这种形式应该可以算是只有一种字段的结构体的简化形式,&lt;code&gt;struct&lt;/code&gt; 语义上指明了 &lt;code&gt;MyArray&lt;/code&gt; 是结构体,紧随后面的 &lt;code&gt;[10]int&lt;/code&gt; 语义上表示结构体的类型,整体上就是说 &lt;code&gt;MyArray&lt;/code&gt; 结构体的类型是 &lt;code&gt;[10]int&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;现在让我们在编辑器中测试一下,看一看 &lt;code&gt;Go&lt;/code&gt; 的编译会不会报错,能否验证我们的猜测呢?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-6ff72adb882ada1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-sole-error.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很遗憾,&lt;code&gt;IDE&lt;/code&gt; 编辑器告诉我们 &lt;code&gt;[10]int&lt;/code&gt; 不合法,必须是类型或类型指针!&lt;/p&gt;
&lt;p&gt;可 &lt;code&gt;[10]int&lt;/code&gt; 确实是我们需要的类型啊,既然报错也就是说&lt;code&gt;Go&lt;/code&gt; 编译器不支持这种简化形式!&lt;/p&gt;
&lt;p&gt;个人猜测可能是 &lt;code&gt;struct&lt;/code&gt; 关键字不支持这种简化形式,那就去掉这个关键字好了!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-691d216609bb0d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-sole-success.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没想到真的可以!&lt;/p&gt;
&lt;p&gt;至少现在看来 &lt;code&gt;Go&lt;/code&gt; 编译器是支持简化形式的,至于这种支持的形式和我们预期实现的语义是否一致,暂时还不好说,继续做实验探索吧!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-c35de9fd503af917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-sole-test.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过声明变量后直接打印,初步证明了我们这种简化形式是可以正常工作的,输出结果也是我们定义的内部数组!&lt;/p&gt;
&lt;p&gt;接下来看一看能不能对这个所谓的内部数组进行操作呢?&lt;/p&gt;
&lt;p&gt;这种简化形式只有一个字段,只指明了字段的类型,没有字段名,因而访问该字段应该直接通过结构体变量访问,不知道这种猜测是否正确,依旧做实验来证明.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyArray [10]int

func TestMyArray(t *testing.T) {
    var myArr MyArray

    // [0 0 0 0 0 0 0 0 0 0]
    t.Log(myArr)

    myArr[0] = 1
    myArr[9] = 9

    // [1 0 0 0 0 0 0 0 0 9]
    t.Log(myArr)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一次猜想也得到了验证,&lt;code&gt;Go&lt;/code&gt; 编译器就是通过结构体变量直接操作内部字段,看来我们离真相更进一步!&lt;/p&gt;
&lt;p&gt;先别急着高兴,将唯一的字段换成其他类型,多测试几遍看看是否依然正常?&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyBool bool

func TestMyBool(t *testing.T) {
    var myBool MyBool

    // false
    t.Log(myBool)

    myBool = true

    // true
    t.Log(myBool)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一番测试后并没有报错,很有可能这是 &lt;code&gt;Go&lt;/code&gt; 所支持的结构体简化形式,也和我们的预期一致.&lt;/p&gt;
&lt;p&gt;关于结构体属性的语法规则暂时没有其他探索的新角度,接下来开始探索结构体的方法.&lt;/p&gt;
&lt;p&gt;探索的过程中要尽可能的设身处地思考 &lt;code&gt;Go&lt;/code&gt; 语言应该如何设计才能方便使用者,尽可能地把自己想象成 &lt;code&gt;Go&lt;/code&gt; 语言的设计者!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-e202d0b65a5325b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-sole-method.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结构体的简化形式下可能并不支持方法,如果真的是这样的话,这样做也有一定道理.&lt;/p&gt;
&lt;p&gt;首先就语法层面分析,为什么单字段的结构体不支持方法?&lt;/p&gt;
&lt;p&gt;还记得我们想要简化单字段结构体遇到的报错提示吗?&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyArray struct [10]int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果直接将单字段类型放到 &lt;code&gt;struct&lt;/code&gt; 关键字后面,&lt;code&gt;Go&lt;/code&gt; 编译器就会报错,当我们省略 &lt;code&gt;struct&lt;/code&gt; 关键字时上述报错自然就消失了.&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;Go&lt;/code&gt; 编译器的角度上来讲,&lt;code&gt;struct&lt;/code&gt; 是系统关键字,告诉编译器只要遇到这个关键字就解析成结构体语法,现在没有遇到 &lt;code&gt;sruct&lt;/code&gt; 关键字也就意味着不是结构体语法.&lt;/p&gt;
&lt;p&gt;这里关键字和结构体是一一对应关系,也就是充分必要条件,由关键字可以推测到结构体,由结构体也可以推测到关键字.&lt;/p&gt;
&lt;p&gt;再回来看一看,我们的单字段结构体是怎么定义的呢?&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyArray [10]int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为没有关键字 &lt;code&gt;struct&lt;/code&gt; ,所以编译器推断 &lt;code&gt;MyArray&lt;/code&gt; 不是结构体,既然不是结构体,也不能用结构体的接收者函数去定义方法.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (myBool *MyBool) IsTrue() bool{
    return myBool
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这种方法就会报错,由此可见 ,&lt;code&gt;Go&lt;/code&gt; 语言如果真的不支持单字段结构体方法也有理可循.&lt;/p&gt;
&lt;p&gt;然后我们再从语义的角度上解释一下为什么不支持方法?&lt;/p&gt;
&lt;p&gt;回到探索的初衷,当正在定义的结构体有多个字段时,应该按照标准写法为每个字段指定字段的名称和类型.&lt;/p&gt;
&lt;p&gt;假如该字段有且只有一个时,再按照标准写法定义当然可以,但也应该提供更加简化的写法.&lt;/p&gt;
&lt;p&gt;只有一个字段的结构体,字段名称是没有意义的也是不应该出现的,因为完全可以用结构体变量所代替,此时这个结构体唯一有存在价值的就是字段的类型了!&lt;/p&gt;
&lt;p&gt;字段类型包括内建类型和用户自定义结构体类型,不论哪种类型,这种简化形式的结构体的语义上完全可以由该结构体的字段类型所决定,所以简化形式的结构体还需要方法吗?&lt;/p&gt;
&lt;p&gt;自然是不需要的!&lt;/p&gt;
&lt;p&gt;字段类型可以由字段类型自己定义的,也能确保职责清晰,彼此分离!&lt;/p&gt;
&lt;p&gt;综上,个人觉得即便 &lt;code&gt;Go&lt;/code&gt; 真的不支持单字段结构体的方法,背后的设计还是有章可循的,有理可依的!&lt;/p&gt;
&lt;p&gt;上文中定义动态数组时,内部使用的数组是静态数组,现在为了方便继续探索方法,应该提供重载方法使其支持动态数组.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func NewMyDynamicArray() *MyDynamicArray {
    var myDynamicArray MyDynamicArray

    myDynamicArray.len = 0
    myDynamicArray.cap = 10
    var arr [10]int
    myDynamicArray.ptr = &amp;amp;arr

    return &amp;amp;myDynamicArray
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内部数组 &lt;code&gt;arr&lt;/code&gt; 是静态数组,应该提供可以让外部调用者初始化指定数组的接口,按照已知的面向对象中关于方法的定义来重载方法.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-680c03c9c18ec76b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-method-overload.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初次尝试方法的重载就遇到了问题,报错提示该方法已声明,所以说 &lt;code&gt;Go&lt;/code&gt; 可能并不支持方法重载,这样就有点麻烦了.&lt;/p&gt;
&lt;p&gt;想要实现类似的功能要么通过定义不同的方法名,要么定义一个非常大的函数,接收最全的参数,再根据调用者参数进行对应的逻辑处理.&lt;/p&gt;
&lt;p&gt;用惯了方法的重载,突然发现这种特性在 &lt;code&gt;Go&lt;/code&gt; 语言中无法实现,顿时有点沮丧,和其他主流的面向对象语言差异性也太大了吧!&lt;/p&gt;
&lt;p&gt;不支持构造函数,不支持方法重载,原来以为理所应当的特性并不理所应当.&lt;/p&gt;
&lt;p&gt;还是先冷静下来想一想,&lt;code&gt;Go&lt;/code&gt; 为什么不支持方法重载呢?难不成和构造函数那样,怕是滥用干脆禁用的逻辑?&lt;/p&gt;
&lt;p&gt;因为我不是设计者,无法体会也不想猜测原因,但可以肯定的是,&lt;code&gt;Go&lt;/code&gt; 语言是一门全新的语言,有着独特的设计思路,不与众人同!&lt;/p&gt;
&lt;p&gt;吐槽时间结束,既然上了贼船就得一条道走到黑,不支持方法重载就换个函数名或者按参数名区分.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-f7c21f9110e5c876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-method-error.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;天啊撸,刚刚解决方法重载问题又冒出数组初始化不能是变量只能是常量表达式?&lt;/p&gt;
&lt;p&gt;简直不可思议!&lt;/p&gt;
&lt;p&gt;既然数组初始化长度只是常量表达式,也就无法接收外部传递的容量 &lt;code&gt;cap&lt;/code&gt;,没有了容量只能接收长度 &lt;code&gt;len&lt;/code&gt; ,而初始化内部数组长度又没办法确定了,两个变量都无法对外暴露!&lt;/p&gt;
&lt;p&gt;一切又回到原点,想要实现动态数组的功能只能靠具体的方法中去动态扩容和缩容,不能初始化指定长度了.&lt;/p&gt;
&lt;p&gt;这样的话,关于方法也是一条死路,停止探索.&lt;/p&gt;
&lt;h2 id=&quot;声明结构体&quot;&gt;声明结构体&lt;/h2&gt;
&lt;p&gt;结构体定义基本已经探索完毕,除了发现一种单字段结构体的简化形式外,暂时没有新的发现.&lt;/p&gt;
&lt;p&gt;再次回到使用者的角度上,声明结构体有没有其他方式呢?&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var myDynamicArray MyDynamicArray
    
t.Log(myDynamicArray)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是变量的声明方式,除了这种形式,还记得在学习 &lt;code&gt;Go&lt;/code&gt; 的变量时曾经介绍过声明并初始化变量方式,是否也适用于结构体变量呢?&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var myDynamicArray = MyDynamicArray{
        
}

t.Log(myDynamicArray)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器没有报错,证明这种字面量形式也是适用的,不过空数据结构没有太大的意义,怎么能初始化对应的结构呢?&lt;/p&gt;
&lt;p&gt;和多字段结构体最为相似的数据结构莫过于映射 &lt;code&gt;map&lt;/code&gt; 了!&lt;/p&gt;
&lt;p&gt;回忆一下 &lt;code&gt;map&lt;/code&gt; 如何进行字面量初始化的吧!&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var m = map[string]string{
    &quot;id&quot;:   &quot;1006&quot;,
    &quot;name&quot;: &quot;雪之梦技术驿站&quot;,
}

t.Log(m)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模仿这种结构看看能不能对结构体也这么初始化,果然就没有那么顺利!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-841ee789c4be7358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-init-field-error.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我还没定义,你就不行了?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IDE&lt;/code&gt; 编辑器提示字段名称无效,结构体明明就有 &lt;code&gt;len&lt;/code&gt; 字段啊,除非是没有正确识别!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&quot;len&quot;&lt;/code&gt; 与 &lt;code&gt;len&lt;/code&gt; 是不一样的吧?&lt;/p&gt;
&lt;p&gt;那就去掉双引号 &lt;code&gt;&quot;&quot;&lt;/code&gt; 直接使用字段名进行定义看看.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var myDynamicArray = MyDynamicArray{
    len: 10,
}

t.Log(myDynamicArray)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时报错消失了,成功解锁一种新的隐藏技能.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var myDynamicArray = MyDynamicArray{
    ptr: &amp;amp;[10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
    len: 10,
    cap: 10,
}

t.Log(myDynamicArray)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了这种指定字段名称注入方式,能不能不指定字段名称而是按照字段顺序依次初始化?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-0c72b074e50bdc22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-init-field-in-order.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;借助编辑器可以看到确实是按照顺序注入的,这样的话,其实有点意思了,明明不支持构造函数,采用字面量实例化时却看起来像构造函数的无参,有参数和全参形式?&lt;/p&gt;
&lt;p&gt;可以预想到的是,这种全参注入的方式一定是严格按照定义顺序相匹配的,当参数不全时可能按位插入也可能不支持,真相如何,一试便知!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-f8c97f86031c8e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-init-field-lack-order.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事实上并不支持这种参数不全的形式,因此个人觉得要么无参要么全参要么指定初始化字段这三种语义上还是比较清楚的.&lt;/p&gt;
&lt;p&gt;除了字面量的方式,&lt;code&gt;Go&lt;/code&gt; 是否支持创建 &lt;code&gt;slice&lt;/code&gt; 或 &lt;code&gt;map&lt;/code&gt; 时所使用的 &lt;code&gt;make&lt;/code&gt; 函数呢?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-6812a896ff965425.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-init-field-make-error.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看样子,&lt;code&gt;make&lt;/code&gt; 函数并不支持创建结构体,至于为什么不支持,原因就不清楚了,也是个人的一个疑惑点.&lt;/p&gt;
&lt;p&gt;既然 &lt;code&gt;make&lt;/code&gt; 可以创建 &lt;code&gt;slice&lt;/code&gt; ,&lt;code&gt;map&lt;/code&gt; 这种内建类型,语义上就是用来创建类型的变量,而结构体也是一种类型,唯一的差别可能就是结构体大多是自定义类型而不是内建类型.&lt;/p&gt;
&lt;p&gt;如果我来设计的话,可能会一统天下,因为语义上一致的功能只使用相同的关键字.&lt;/p&gt;
&lt;p&gt;回到面向对象的传统编程规范上,一般实例化对象用的是关键字 &lt;code&gt;new&lt;/code&gt;,而 &lt;code&gt;new&lt;/code&gt; 并不是 &lt;code&gt;Go&lt;/code&gt; 中的关键字.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 语言中的函数是一等公民,正如刚才说的 &lt;code&gt;make&lt;/code&gt; 也不是关键字,同样是函数.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-cea00bdc0b5e5770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-init-field-new-error.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即便对于同一个目标,&lt;code&gt;Go&lt;/code&gt; 也是有着自己的独到见解!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 不是以关键字形式出现而是以函数的身份登场,初步推测应该也具备实例化对象的能力吧?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-e18826a95292ab6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-init-field-new-assignment-error.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;难道 &lt;code&gt;new&lt;/code&gt; 函数不能实例化对象?为什么报错说赋值错误,难不成姿势不对?&lt;/p&gt;
&lt;p&gt;吓得我赶紧看一下 &lt;code&gt;new&lt;/code&gt; 的文档注释.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;
// The new built-in function allocates memory. The first argument is a type,
// not a value, and the value returned is a pointer to a newly
// allocated zero value of that type.
func new(Type) *Type&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据注释说明,果然是使用姿势不对,并不像其他的面向对象语言那样可以重复赋值,&lt;code&gt;Go&lt;/code&gt; 不支持这种形式,还是老老实实初始化声明吧!&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var myDynamicArray2 = new(MyDynamicArray)
    
t.Log(myDynamicArray2)  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然存在着两种方式来实例化对象,那么总要看一下有什么区别.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func TestNewMyDynamicArray(t *testing.T) {
    var myDynamicArray = MyDynamicArray{
        ptr: &amp;amp;[10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
        len: 10,
        cap: 10,
    }
    myDynamicArray = MyDynamicArray{
        &amp;amp;[10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
        10,
        10,
    }
    t.Log(myDynamicArray)
    t.Logf(&quot;%[1]T %[1]v&quot;, myDynamicArray)

    var myDynamicArray2 = new(MyDynamicArray)
    myDynamicArray2.ptr = &amp;amp;[10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    myDynamicArray2.len = 10
    myDynamicArray2.cap = 10

    t.Log(myDynamicArray2)

    t.Logf(&quot;%[1]T %[1]v&quot;, myDynamicArray2)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-5dfd68fd1213f607.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-init-field-diff.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里简单解释下 &lt;code&gt;t.Logf(&quot;%[1]T %[1]v&quot;, myDynamicArray)&lt;/code&gt; 语句是什么意思?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%[1]T&lt;/code&gt; 其实是 &lt;code&gt;%T&lt;/code&gt; 的变体,&lt;code&gt;%[1]v&lt;/code&gt; 也是 &lt;code&gt;%v&lt;/code&gt; 的变体,仔细观察的话就会发现占位符刚好都是同一个变量,这里也就是第一个参数,所以就用 &lt;code&gt;[1]&lt;/code&gt; 替代了,再次体现了 &lt;code&gt;Go&lt;/code&gt; 语言设计的简洁性.&lt;/p&gt;
&lt;p&gt;下面再举一个简单的例子加深印象,看仔细了哦!&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;test := &quot;snowdreams1006&quot;

// string snowdreams1006
t.Logf(&quot;%T %v&quot;, test, test)
t.Logf(&quot;%[1]T %[1]v&quot;, test)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;%T&lt;/code&gt; 是打印变量的类型,应该是类型 &lt;code&gt;type&lt;/code&gt; 的缩写,&lt;code&gt;v&lt;/code&gt; 应该是值 &lt;code&gt;value&lt;/code&gt; 的缩写.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释清楚了测试代码的含义,再回头看看测试结果,发现采用字面量方式得到的变量类型和 &lt;code&gt;new&lt;/code&gt; 函数得到的变量类型明显不同!&lt;/p&gt;
&lt;p&gt;具体表现为 &lt;code&gt;_struct.MyDynamicArray {0xc0000560f0 10 10}&lt;/code&gt; 是结构体类型,而 &lt;code&gt;*_struct.MyDynamicArray &amp;amp;{0xc000056190 10 10}&lt;/code&gt; 是结构体类型的指针类型.&lt;/p&gt;
&lt;p&gt;这种差异也是可以预期的差异,也是符合语义的差异.&lt;/p&gt;
&lt;p&gt;字面量实例化的对象是值对象,而 &lt;code&gt;new&lt;/code&gt; 实例化对象开辟了内存,返回的是实例对象到引用,正如其他编程语言的 &lt;code&gt;new&lt;/code&gt; 关键字一样,不是吗?&lt;/p&gt;
&lt;p&gt;既然说到了值对象和引用对象,再说一遍老生常谈的问题,函数或者说方法传递时应该传递哪一种类型?&lt;/p&gt;
&lt;h2 id=&quot;值传递还是引用传递&quot;&gt;值传递还是引用传递&lt;/h2&gt;
&lt;p&gt;接下来的示例和动态数组并没有什么关系,简单起见,新开一个结构体叫做 &lt;code&gt;Employee&lt;/code&gt;,顺便回顾一下目前学到的封装知识.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Employee struct {
    Id   string
    Name string
    Age  int
}

func TestCreateEmployee(t *testing.T) {
    e := Employee{
        &quot;0&quot;,
        &quot;Bob&quot;,
        20,
    }
    t.Logf(&quot;%[1]T %[1]v&quot;, e)

    e1 := Employee{
        Name: &quot;Mike&quot;,
        Age:  30,
    }
    t.Logf(&quot;%[1]T %[1]v&quot;, e1)

    e2 := new(Employee)
    e2.Id = &quot;2&quot;
    e2.Name = &quot;Rose&quot;
    e2.Age = 18
    t.Logf(&quot;%[1]T %[1]v&quot;, e2)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先测试引用传递,这也是结构体常用的传递方式,行为表现上和其他的主流编程语言表现一致,方法内的修改会影响调用者的参数.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (e *Employee) toStringPointer() string {
    fmt.Printf(&quot;Name address is %x\n&quot;, unsafe.Pointer(&amp;amp;e.Name))

    return fmt.Sprintf(&quot;ID:%s-Name:%s-Age:%d&quot;, e.Id, e.Name, e.Age)
}

func TestToStringPointer(t *testing.T) {
    e := &amp;amp;Employee{&quot;0&quot;, &quot;Bob&quot;, 20}

    fmt.Printf(&quot;Name address is %x\n&quot;, unsafe.Pointer(&amp;amp;e.Name))

    t.Log(e.toStringPointer())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-9638077710885527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-method-diff-pointer.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;unsafe.Pointer(&amp;amp;e.Name)&lt;/code&gt; 是查看变量的内存地址,可以看出来调用前后的地址是同一个.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (e Employee) toStringValue() string {
    fmt.Printf(&quot;Name address is %x\n&quot;, unsafe.Pointer(&amp;amp;e.Name))

    return fmt.Sprintf(&quot;ID:%s-Name:%s-Age:%d&quot;, e.Id, e.Name, e.Age)
}

func TestToStringValue(t *testing.T) {
    e := Employee{&quot;0&quot;, &quot;Bob&quot;, 20}

    fmt.Printf(&quot;Name address is %x\n&quot;, unsafe.Pointer(&amp;amp;e.Name))

    t.Log(e.toStringValue())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-b3ba5b3635fbc2e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-method-diff-value.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;调用者发送的内存地址和接收者接收的内存地址不一样,符合期望,值传递都是拷贝变量进行传递的嘛!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;值类型还是引用类型的区分无需赘述,接下来请关注一个神奇的事情,方法的接收者是值类型,方法的调用者是不是一定要传递值类型呢?&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (e Employee) toString() string {
    fmt.Printf(&quot;Name address is %x\n&quot;, unsafe.Pointer(&amp;amp;e.Name))

    return fmt.Sprintf(&quot;ID:%s-Name:%s-Age:%d&quot;, e.Id, e.Name, e.Age)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法的调用者分别传递值类型和引用类型,两者均能正常工作,是不是很神奇,好像和方法的定义没什么关系一样!&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func TestToString(t *testing.T) {
    e := Employee{&quot;0&quot;, &quot;Bob&quot;, 20}

    fmt.Printf(&quot;Name address is %x\n&quot;, unsafe.Pointer(&amp;amp;e.Name))

    t.Log(e.toString())
    t.Log((&amp;amp;e).toString())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-798e697c9473606c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-method-value-diff.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;虽然方法的接收者要求的是值类型,调用者传递的是值类型还是引用类型均可!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-5e99948ca61f5083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-struct-method-pointer-diff.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仅仅更改了方法接收者的类型,调用者不用做任何更改,依然可以正常运行!&lt;/p&gt;
&lt;p&gt;这样就很神奇了,方法的接受者不论是值类型还是指针类型,调用者既可以是值类型也可以是指针类型,为什么?&lt;/p&gt;
&lt;p&gt;同样的,基于语义进行分析,方法的设计者和调用者之间可以说是松耦合的,设计者的更改对于调用者来说没有太大影响,这也就意味着以后设计者觉得用值类型接收参数不好,完全可以直接更改为指针类型而不用通知调用者调整逻辑!&lt;/p&gt;
&lt;p&gt;这其实要归功于 &lt;code&gt;Go&lt;/code&gt; 语言到设计者很好的处理了值类型和指针类型的调用方式,不论是值类型还是引用类型,一律使用点操作符 &lt;code&gt;.&lt;/code&gt; 调用方法,并不像有的语言指针类型是 &lt;code&gt;-&amp;gt;&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; 前缀才能调用指针类型的方法.&lt;/p&gt;
&lt;p&gt;有所为有所不为,可能正是看到了这两种调用方式带来的差异性,&lt;code&gt;Go&lt;/code&gt; 全部统一成点操作符了!&lt;/p&gt;
&lt;p&gt;虽然形式上两种调用方式是一样的,但是设计方法或者函数时到底应该是值类型还是指针类型呢?&lt;/p&gt;
&lt;p&gt;这里有三点建议可供参考:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果接收者需要更改调用者的值,只能使用指针类型&lt;/li&gt;
&lt;li&gt;如果参数本身非常大,拷贝参数比较占用内存,只能用指针类型&lt;/li&gt;
&lt;li&gt;如果参数本身具有状态,拷贝参数可能会影响对象的状态,只能用指针类型&lt;/li&gt;
&lt;li&gt;如果是内建类型或者比较小的结构体,完全可以忽略拷贝问题,推荐用值类型.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然,实际情况可能还和业务相关,具体用什么类型还要自行判断,万一选用不当也不用担心,更改一下参数类型就好了也不会影响调用者的代码逻辑.&lt;/p&gt;
&lt;h2 id=&quot;封装后如何访问&quot;&gt;封装后如何访问&lt;/h2&gt;
&lt;p&gt;封装问题基本上讲解清楚了,一般来说,封装之后的结构体不仅是我们自己使用还有可能提供给外界使用,与此同时要保证外界不能随意修改我们的封装逻辑,这一部分就涉及到访问的控制权限了.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 语言的访问级别有两种,一种是公开的另一种就是私有的,由于没有继承特性,也不涉及子类和父类之间访问权限继承问题,顿时觉得没有继承也不是什么坏事嘛,少了很多易错的概念!&lt;/p&gt;
&lt;p&gt;虽然现在理解起来很简单,具体实际使用上是否便利还不好判断.&lt;/p&gt;
&lt;p&gt;关于可见性的命名规范如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;名称一般使用大驼峰命名法即 &lt;code&gt;CamelCase&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;首字母大写表示公开的 &lt;code&gt;public&lt;/code&gt; ,小写表示私有的 &lt;code&gt;private&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;上述规则不仅适用于方法,包括结构体,变量和常量等几乎是 &lt;code&gt;Go&lt;/code&gt; 语言的全部.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么问题了,这里的 &lt;code&gt;public&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; 是针对谁来说?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 语言中的基本结构是包 &lt;code&gt;package&lt;/code&gt;,这里的包和目录有区别,并不像 &lt;code&gt;Java&lt;/code&gt; 语言那样包和目录严格相关联的,这一点对于 &lt;code&gt;Java&lt;/code&gt; 小伙伴来说需要特别注意.&lt;/p&gt;
&lt;p&gt;包是相关代码的集合,这些代码可能存放于不同的目录文件中,就是通过包 &lt;code&gt;package&lt;/code&gt; 的声明告诉 &lt;code&gt;Go&lt;/code&gt;编译器说:我们是一个家族整体.&lt;/p&gt;
&lt;p&gt;如果不同的文件目录可以声明在同一个包中,这样相当于允许家族外迁,只保留姓氏就好.&lt;/p&gt;
&lt;p&gt;还是用代码说话吧,散落在各地的小伙伴能不能有共同的姓氏!&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;github.com/snowdreams1006/learn-go/oop/pack&quot;
)

func main() {
    var l = new(pack.Lang)
    l.SetName(&quot;Go&quot;)
    l.SetWebsite(&quot;https://golang.google.cn/&quot;)

    fmt.Println(l.ToString())
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-e16b539258c90a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-package-access-same-directory.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pack.go&lt;/code&gt; 源码文件和 &lt;code&gt;pack_test&lt;/code&gt; 测试文件都位于相同的目录 &lt;code&gt;pack&lt;/code&gt; 下且包的声明也相同都是 &lt;code&gt;pack&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这种情况相当于一家氏族位于一个村落中一起生活,和其他语言到表现一致.&lt;/p&gt;
&lt;p&gt;现在试一下这个氏族的一部分人能不能搬到其他村落居住呢?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-e0f9ee36c65cfc40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-package-access-other-directory-error.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;难不成跨域地域有点大,不支持定义方法吗?那移动一下使其离 &lt;code&gt;pack&lt;/code&gt; 目录近一点试试看!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-c0551a273627bde0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-package-access-same-directory-error.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是不行,不能新建子目录,那么和原来在一个目录下呢?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-90e0c02da54a097e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-package-access-same-directory-success.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有这样是可以被标识位结构体的方法的,如果不是方法,完全可以任意存放,这一点就不再演示了,小伙伴可自行测试一下哟!&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;github.com/snowdreams1006/learn-go/oop/pack&quot;
)

func main() {
    var l = new(pack.Lang)
    l.SetName(&quot;Go&quot;)
    l.SetWebsite(&quot;https://golang.google.cn/&quot;)

    fmt.Println(l.ToString())

    l.PrintLangName()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&quot;github.com/snowdreams1006/learn-go/oop/pack&quot;&lt;/code&gt; 是当前文件中导入依赖包路径,因此调用者能否正常访问到我们封装的结构体.&lt;/p&gt;
&lt;p&gt;在当前结构体中的属性被我们设置成了小写字母开头,所以不在同一包是无法访问该属性的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-0f5f4d386a41f4ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-package-access-private.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;封装后如何扩展&quot;&gt;封装后如何扩展&lt;/h2&gt;
&lt;p&gt;设计者封装好对象供其他人使用,难免会有疏忽不足之处,此时使用者就需要扩展已存在的结构体了.&lt;/p&gt;
&lt;p&gt;如果是面向对象的设计思路,最简单的实现方式可能就是继承了,重写扩展什么的都不在话下,可是 &lt;code&gt;Go&lt;/code&gt; 并不这么认为,不支持继承!&lt;/p&gt;
&lt;p&gt;所以剩下的方法就是组合了,这也是学习面向对象时的前人总结的一种经验: 多用组合少用继承!&lt;/p&gt;
&lt;p&gt;现在想一想,&lt;code&gt;Go&lt;/code&gt; 语言不但贯彻了这一思想,更是严格执行了,因为 &lt;code&gt;Go&lt;/code&gt; 直接取消了继承特性.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyLang struct {
    l *Lang
}

func (ml *MyLang) Print() {
    if ml == nil || ml.l == nil {
        return
    }

    fmt.Println(ml.l.ToString())
}

func TestMyLangPrint(t *testing.T) {
    var l = new(Lang)
    l.SetName(&quot;Go&quot;)
    l.SetWebsite(&quot;https://golang.google.cn/&quot;)

    var ml = MyLang{l}

    ml.Print()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-102e69c36e03733e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-combination-custom.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;通过自定义结构体内部属性是 &lt;code&gt;Lang&lt;/code&gt; 类型,进而扩展原来 &lt;code&gt;Lang&lt;/code&gt; 不具备的方法或者重写原来的方法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们的自定义结构体刚好只有这么一个属性,完全可以使用简化形式,说到这里其实有必要特别说明一下,专业叫法称之为别名.&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Lan Lang

func (l *Lan) PrintWebsite(){
    fmt.Println(l.website)
}

func TestLanPrintWebsite(t *testing.T) {
    var la = new(Lan)
    la.name = &quot;GoLang&quot;
    la.website = &quot;https://golang.google.cn/&quot;

    la.PrintWebsite()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为设计者和使用者都已经考虑到了,封装的基本知识也要告一段落了,由于 &lt;code&gt;Go&lt;/code&gt; 不支持继承,也没必要演示相关代码,唯一剩下的只有接口了.&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;Go&lt;/code&gt; 同样是不支持多态,但是 &lt;code&gt;Go&lt;/code&gt; 提供的接口确实与众不同,别有一番滋味在心头,下一节将开始探索接口.&lt;/p&gt;
&lt;h2 id=&quot;关于封装的复盘&quot;&gt;关于封装的复盘&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;定义结构体字段&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Lang struct {
    name    string
    website string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;结构体有多个字段时彼此直接换行,不用逗号也不用分号之类的,不要多此一举.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;定义结构体方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (l *Lang) GetName() string {
    return l.name
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;原本是普通的函数,函数名前面加入指向当前结构体的参数时,函数不再是函数而是方法,同时当前结构体参数叫做接收者,类似于其他面向对象语言中的 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;self&lt;/code&gt; 关键字实现的效果.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;字面量声明结构体&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func TestInitLang(t *testing.T) {
    l := Lang{
        name:    &quot;Go&quot;,
        website: &quot;https://golang.google.cn/&quot;,
    }

    t.Log(l.ToString())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;字面量声明结构体除了这种类似于有参构造函数使用方式,还有无参和全参构造函数使用方式,这里说的构造函数只是看起来像并不真的是构造函数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;new&lt;/code&gt; 声明结构体&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func TestPack(t *testing.T) {
    var l = new(Lang)
    l.SetName(&quot;Go&quot;)
    l.SetWebsite(&quot;https://golang.google.cn/&quot;)

    t.Log(l.ToString())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 函数和其他主流的编程语言 &lt;code&gt;new&lt;/code&gt; 关键字类似,用于声明结构体,不同于字面量声明方式,&lt;code&gt;new&lt;/code&gt; 函数的输出对象是指针类型.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;首字母大小写控制访问权限&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;不论是变量名还是方法名,名称首字母大写表示公开的,小写表示私有的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;代码的基本组织单元是包&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;访问控制权限也是针对代码包而言,一个目录下只有一个代码包,包名和目录名没有必然联系.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;复合扩展已有类型&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MyLang struct {
    l *Lang
}

func (ml *MyLang) Print() {
    if ml == nil || ml.l == nil {
        return
    }

    fmt.Println(ml.l.ToString())
}

func TestMyLangPrint(t *testing.T) {
    var l = new(Lang)
    l.SetName(&quot;Go&quot;)
    l.SetWebsite(&quot;https://golang.google.cn/&quot;)

    var ml = MyLang{l}

    ml.Print()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;自定义结构体内嵌其他结构体,通过复合而不是继承的方式实现对已有类型的增强控制,也是一种推荐的编程规范.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;别名扩展已有类型&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Lan Lang

func (l *Lan) PrintWebsite() {
    fmt.Println(l.website)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;别名可以看成单字段结构体的简化形式,可以用来扩展已存在的结构体类型,也支持方法等特性.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后,非常感谢你的阅读,鄙人知识浅薄,如有描述不当的地方,还请各位看官指出,你的每一次留言我都会认真回复,你的转发就是对我最大的鼓励!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-03ca806ca289734d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;go-oop-encapsulation-hi.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5294117647059&quot;&gt;
&lt;p&gt;如果需要查看相关源码,可以直接访问 &lt;a href=&quot;https://github.com/snowdreams1006/learn-go&quot; class=&quot;uri&quot;&gt;https://github.com/snowdreams1006/learn-go&lt;/a&gt;,同时也推荐关注公众号与我交流.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-613e34447dfaf269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;雪之梦技术驿站.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 16:20:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>关注公众号 '雪之梦技术驿站]查看上篇文章 [猜猜看go是不是面向对象语言？能不能面向对象编程？' 虽然在上篇文章中,我们通过尝试性学习探索了 语言中关于面向对象的相关概念,更确切的说是关于封装的基本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snowdreams1006/p/11403292.html</dc:identifier>
</item>
<item>
<title>教你用原生CSS写炫酷页面切换效果，跟第三方组件说拜拜 - Jacob98</title>
<link>http://www.cnblogs.com/Jacob98/p/11403240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jacob98/p/11403240.html</guid>
<description>&lt;blockquote readability=&quot;6.695652173913&quot;&gt;
&lt;p&gt;因为项目需要，别人想让我给他写一个个人博客，并且给了我一个其他人的网页，可以&lt;a href=&quot;http://www.martijnwieling.nl/&quot;&gt;&lt;strong&gt;点此查看&lt;/strong&gt;&lt;/a&gt;。有的同学可能说了，第三方博客框架这么多，为什么还要去手写的，你说这个有可能是没有看到打开这个博客。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;样式介绍&quot;&gt;样式介绍&lt;/h2&gt;
&lt;p&gt;给大家看一下这个网页的大体样式。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372160/201908/1372160-20190823235306162-1703978982.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个界面可以说是非常漂亮，整体也是一个响应式布局，总体来说还算不错。但是抛开页面设计，这个网站有一个致命的缺点，就是没有做&lt;strong&gt;懒加载&lt;/strong&gt;，这么多页面其实就是一个HTML文件，所有的资源图片以及文字信息等全部是一次性加载，所以你想打开这个界面还是比较困难的，需要等待一些时间。&lt;/p&gt;
&lt;p&gt;我们这次只看设计。其实用Vue的朋友们应该都听过&lt;code&gt;element-ui&lt;/code&gt;这个组件库，它里面有一个抽屉组件可以用。其实用这种现成的组件的局限性大家都很清楚，虽然说开发很快，但是定制化有很多限制，向上面GIF图中的效果他就不能很好的实现。于是本着学习的态度我们来实现一下这个样式。&lt;/p&gt;
&lt;h2 id=&quot;实现方法&quot;&gt;实现方法&lt;/h2&gt;
&lt;p&gt;话不多说，我们先来看一下实现效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372160/201908/1372160-20190823235306773-1952911954.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们大致实现了想要实现的效果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击不同标签页出现相应界面&lt;/li&gt;
&lt;li&gt;切换动画&lt;/li&gt;
&lt;li&gt;点击蒙版收回顶层标签页&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;切换动画&quot;&gt;切换动画&lt;/h3&gt;
&lt;p&gt;动画的实现方法有很多，在CSS里面写动画的话我比较常用keyframes，但是在这里我是用js来控制动画，没有使用css动画属性。js实现动画的话大家思考一下连环画的生成原理，其实就是在很短的事件里面对图片的频繁移动，只要移动速度合适，我们的眼睛就会认为我们看到了一个移动的物体。&lt;/p&gt;
&lt;p&gt;我js实现动画的原理和此类似，设定一个延时与起始位置，让他在规定时间内按照liner均匀移动，当然你也可以不使用liner，比如说X&lt;sup&gt;2&lt;/sup&gt;，这些也都是可以的。&lt;/p&gt;
&lt;p&gt;关于实现方法，我是写了一个animation类，这个类包括延时、函数（liner或者其他渐变函数）、completed等，可以很好地进行动画生成与控制。下面来看一下这段代码&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Animator {
  // 构造函数
  constructor() {
    this.durationTime = 0;
    this.easingFn = k =&amp;gt; k;
    this.eventHandlers = new Map();
  }
  // 动画移动速度所用的函数
  easing(fn) {
    if (typeof fn !== &quot;function&quot;) {
      throw new Error(&quot;Easing must be a function, such as k =&amp;gt; k&quot;);
    }
    this.easingFn = fn;
    return this;
  }
  // 动画时间
  duration(time) {
    if (typeof time !== &quot;number&quot;) {
      throw new Error(&quot;Duration must be a number&quot;);
    }
    this.durationTime = time;
    return this;
  }
  // 响应函数
  on(type, handler) {
    if (typeof handler !== &quot;function&quot;) {
      throw new Error(&quot;Handler must be a function&quot;);
    }
    this.eventHandlers.set(type, handler);
    return this;
  }
  // 动画生成
  animate() {
    const duration = this.durationTime;
    const easing = this.easingFn;
    const update = this.eventHandlers.get(&quot;update&quot;) || (t =&amp;gt; t);
    const complete = this.eventHandlers.get(&quot;complete&quot;) || (() =&amp;gt; {});
    let timer = null;
    const startTime = +new Date();
    function step() {
      const percent = Math.min(1, (+new Date() - startTime) / duration);
      if (percent &amp;lt; 1) {
        update(easing(percent));
        timer = requestAnimationFrame(step);
      } else {
        cancelAnimationFrame(timer);
        update(easing(1));
        complete();
      }
    }
    timer = requestAnimationFrame(step);
  }
}
/*
* 这里是专门写了一个产生动画的函数
* 传参: start:Number, step:Number, el:object(元素对象)
* 传入这些参数之后就可以产生相应的动画效果
*/
var move = function(start, step, el) {
  new Animator()
    .duration(200)
    .easing(k =&amp;gt; k)
    .on(&quot;update&quot;, t =&amp;gt; {
      el.style.right = String(start + t * step) + &quot;%&quot;;
    })
    .animate();
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;网页布局&quot;&gt;网页布局&lt;/h3&gt;
&lt;p&gt;其实像这种抽屉式的网页布局大家应该都不陌生，大概就是设置&lt;code&gt;position&lt;/code&gt;为&lt;code&gt;absolute&lt;/code&gt;，然后再使用&lt;code&gt;left&lt;/code&gt;或者&lt;code&gt;right&lt;/code&gt;属性进行布局，我在文章下面会给出全部代码的下载链接，大家如果感兴趣可以下载来看一下。&lt;/p&gt;
&lt;h3 id=&quot;点击逻辑&quot;&gt;点击逻辑&lt;/h3&gt;
&lt;p&gt;通过我前面的介绍，大家应该是可以知道这个demo是可以通过按钮点击触发，也是可以通过点击蒙版来触发的，当我的鼠标移到蒙版的时候鼠标会改变一个样式，这个只要设置一个属性就可以啦&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.overlay {
  cursor: url(&quot;你的图标url&quot;), pointer;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的逻辑大家可以参照这个思维导图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372160/201908/1372160-20190823235336213-565043045.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实当时这个逻辑搞了比较长时间，大家应该可以想到实现多个标签页的点击应该是使用栈来实现，始终把显示出来的抽屉页放在最顶层，这样也方便我们进行后续操作。&lt;/p&gt;
&lt;h3 id=&quot;网页源码&quot;&gt;网页源码&lt;/h3&gt;
&lt;p&gt;需要源码的朋友可以&lt;a href=&quot;https://pan.baidu.com/s/17PQEKXXD6rtI8Bos86VE8g&quot;&gt;点此下载&lt;/a&gt;😜&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;在刚开始学web前端开发的时候，看到一些特别的网站觉得很炫酷，当时的第一想法是看看GitHub上有没有现成的组件库可以给我用，所以也造就了我原生css学的不是很扎实。但是到现在来讲，随着工作的需要，为了有更好的突破还是得努力学习原生web。一些框架和组件都是基于原生的，只有这些学扎实了之后才能更好地认识和使用这些现成的轮子。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372160/201908/1372160-20190823235323976-1577601574.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 15:55:00 +0000</pubDate>
<dc:creator>Jacob98</dc:creator>
<og:description>因为项目需要，别人想让我给他写一个个人博客，并且给了我一个其他人的网页，可以 ' 点此查看 ' 。有的同学可能说了，第三方博客框架这么多，为什么还要去手写的，你说这个有可能是没有看到打开这个博客。 样</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jacob98/p/11403240.html</dc:identifier>
</item>
<item>
<title>集合系列（一）：集合框架概述 - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/java_collection_01_summary.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/java_collection_01_summary.html</guid>
<description>&lt;p&gt;Java 集合是 Java API 用得最频繁的一类，掌握 Java 集合的原理以及继承结构非常有必要。总的来说，Java 容器可以划分为 4 个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;List 集合&lt;/li&gt;
&lt;li&gt;Set 集合&lt;/li&gt;
&lt;li&gt;Queue 集合&lt;/li&gt;
&lt;li&gt;Map 集合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了上面 4 种集合之外，还有一个专门的工具类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具类（Iterator 迭代器、Enumeration 枚举类、Arrays 和 Collections）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在开始聊具体的集合体系之前，我想先介绍一下 Collection 框架的基本类结构。因为无论是 List 集合、Set 集合还是 Map 集合都以这个为基础。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，最顶层的是 Collection 接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到 Collection 接口定义了最最基本的集合操作，例如：判断集合大小、判断集合是否为空等。List、Set、Queue 都继承了该接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234825821-1006038125.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接着，AbstractCollection 也继承了 Collection 接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从这个类名可以看出，其是一个抽象类。AbstractCollection 对 Collection 接口中一些通用的方法做了实现。例如：判断是否为空的方法、判断是否包含某个元素的方法等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234826161-1891867586.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234826334-651785433.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过继承 AbstractCollection 接口，可以少写许多不必要的代码，这是代码抽象设计最常用的思想。AbstractCollection 是最为基础的类，其他所有集合的实现都继承了这个抽象类。&lt;/p&gt;
&lt;h2 id=&quot;list-集合&quot;&gt;List 集合&lt;/h2&gt;
&lt;p&gt;List 集合存储的是有序的数据集合，其数据结构特点是：读取快，修改慢，适合于读取多、写入修改少的场景。List 集合的类继承结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234827434-703183363.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到除了 Collection 和 AbstractCollection 之外，我们还有 List 接口和 AbstractList 抽象类。其中 List 接口是 List 集合的最上层抽象，其继承了 Collection 接口，表示其实一个集合。而 AbstractList 则是 List 集合的抽象实现，实现了许多公用的操作。&lt;/p&gt;
&lt;p&gt;整个 List 集合的实现可以分为红、黄、绿三大块。其中红色部分是 List 集合的列表实现，绿色部分是 List 结合的链表实现，而 黄色部分则是 List 集合列表实现的线程安全版本。&lt;/p&gt;
&lt;h3 id=&quot;列表实现&quot;&gt;列表实现&lt;/h3&gt;
&lt;p&gt;ArrayList 类是很常用的 List 实现，其底层是用数组实现的。其读取元素的时间复杂度是 O（1），修改写入元素的时间复杂度是 O（N）。我们将会在下面的章节中详细介绍，这里不做深入。&lt;/p&gt;
&lt;h3 id=&quot;列表安全实现&quot;&gt;列表安全实现&lt;/h3&gt;
&lt;p&gt;Vector 类也是很常用的 List 实现，其数据结构与 ArrayList 非常类似。但其与 ArrayList 的一个最大的不同是：Vector 是线程安全的，而 ArrayList 则不是线程安全的。&lt;/p&gt;
&lt;p&gt;Stack 类则是在 Vector 的基础上，又实现了一个双向队列。所以其除了是线程安全的之外，其还是一个先进后出的 List 实现。&lt;/p&gt;
&lt;p&gt;最后我们总结一下，List 集合最为关键的几个实现类是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ArrayList：列表集合经典实现。&lt;/li&gt;
&lt;li&gt;Vector：列表集合经典实现，线程安全，与 ArrayList 对应。&lt;/li&gt;
&lt;li&gt;Stack：栈结构的经典实现，先进后出的数据结构。继承了 Vector，线程安全。&lt;/li&gt;
&lt;li&gt;LinkedList：链表结构的经典实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;链表实现&quot;&gt;链表实现&lt;/h3&gt;
&lt;p&gt;LinkedList 是一个经典的链表实现。LinkedList 继承了 AbstractSequentialList 抽象类。AbstractSequentialList 抽象类从字面上理解是抽象连续列表。这里的重点是&lt;br/&gt;sequential 这个词，表示其数据结构是连续的（链表）。从其源码注释也可以看出这个意思。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;This class provides a skeletal implementation of the &lt;tt&gt;List&lt;/tt&gt; interface to minimize the effort required to implement this interface backed by a &quot;sequential access&quot; data store (such as a linked list).&lt;br/&gt;（意译）如果你想要实现一个连续存储（链表）的 List，那么这个抽象类可以让你减少不少工足量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实从命名就可以看出，AbstractSequentialList 其实是连续列表（链表）的一个抽象实现。AbstractSequentialList 抽象类做了许多工作，使得后续的链表实现更加简单。从 AbstractSequentialList 的注释可以看到，如果要实现一个链表，那么只需要实现 listIterator 方法和 size 方法就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234827766-383757492.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;set-集合&quot;&gt;Set 集合&lt;/h2&gt;
&lt;p&gt;Set 集合中存储的元素是不重复的，但是其存储顺序是无序的。下面是 Set 集合的类继承结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234830261-1908505236.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与 List 集合类似，都是一个 Set 接口继承了 Collection 接口。一个 AbstractSet 抽象类实现了 Set 接口、继承了 AbstractCollection 抽象类。这部分完全和 List 相同。&lt;/p&gt;
&lt;p&gt;Set 集合的实现可以分为两大块，一块是 Set 集合的有序实现（红色部分），另一块是 Set 集合的哈希实现（黄色部分）。&lt;/p&gt;
&lt;h3 id=&quot;有序实现treeset&quot;&gt;有序实现（TreeSet）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;SortedSet 接口继承了 Set 接口，TreeSet 实现了 SortedSet。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234830582-1688235594.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道 Set 集合中的元素是无序的，而 SortedSet 接口则是定义了有序 Set 集合的接口。而 TreeSet 则是 SortedSet 的具体实现。&lt;/p&gt;
&lt;h3 id=&quot;哈希实现hashsetlinkedhashset&quot;&gt;哈希实现（HashSet、LinkedHashSet）&lt;/h3&gt;
&lt;p&gt;HashSet 是 Set 接口的经典哈希实现。但 Set 集合中的元素是无序的，为了维护 Set 集合的插入顺序，人们创造出了 LinkedHashSet。LinkedHashSet 在 HashSet 的基础上是用链表维护元素的插入顺序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234830746-988653495.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里我们总结一下 Set 集合的所有实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TreeSet：Set 集合的有序实现。&lt;/li&gt;
&lt;li&gt;HashSet：Set 集合的哈希实现。&lt;/li&gt;
&lt;li&gt;LinkedHashSet：Set 集合的哈希实现，维护了元素插入顺序。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;queue-集合&quot;&gt;Queue 集合&lt;/h2&gt;
&lt;p&gt;队列是一个特殊的线性表，其数据结构特点是先进先出。Queue 类结构体系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234830914-1418819329.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，Queue 接口继承了 Collection 接口。Queue 接口在拥有基本集合操作的基础上，定义了队列这种数据结构的基本操作。可以看到 offer、poll 等方法都是队列独有的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234831117-1004947247.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，AbstractQueue 是对 Queue 接口的抽象实现。针对队列这种数据结构，其添加、删除元素的动作都不一样。在 AbstractQueue 抽象类里将队列的基本操作都实现了一遍。例如 AbstractQueue 中的 add 方法就和 AbstractList 中的 add 方法有着不同的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234831282-2009170779.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，Queue 的类结构整体可以分为黄色、红色两个部分。红色部分是 Queue 接口的有序实现，有 PriorityQueue 这个实现类。黄色部分是 Deque（双向队列）的实现，有 LinkedList 和 ArrayDeque 两个实现类。&lt;/p&gt;
&lt;h3 id=&quot;有序实现&quot;&gt;有序实现&lt;/h3&gt;
&lt;p&gt;PriorityQueue 是 AbstractQueue 抽象类的具体实现。&lt;/p&gt;
&lt;p&gt;PriorityQueue 表示优先级队列，其按照队列元素的大小进行重新排序。当调用 peek() 或 pool() 方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列的最小元素。&lt;/p&gt;
&lt;h3 id=&quot;双向实现&quot;&gt;双向实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先，我们会看到 Deque 接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Deque（double ended queue）是双向队列的意思，它能在头部或尾部进行元素操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最后，我们看到 LinkedList 和 ArrayDeque 都是 Deque 接口的具体实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;LinkedList 我们之前说过了，是一个链表，但它还是一个双向队列。因此 LinkedList 具有 List 和 Queue 的双重特性。ArrayDeque 则是一个双向循环队列，其底层是用数组实现。更多内容，我们将在队列章节讲解。&lt;/p&gt;
&lt;p&gt;最后我们总结 Queue 体系的几个常见实现类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PriorityQueue：优先级队列&lt;/li&gt;
&lt;li&gt;LinkedList：双向队列实现&lt;/li&gt;
&lt;li&gt;ArrayDeque：双向循环队列实现&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;map-集合&quot;&gt;Map 集合&lt;/h2&gt;
&lt;p&gt;Map 集合与 List、Set、Queue 有较大不同，其实类似于 key/value 的数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234832560-1707044445.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，Map 接口是最顶层的接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与 List、Set、Queue 类似，Map 接口定义的是哈希表数据结构的操作。例如我们常用的 put、get、keySet 等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接着，有 AbstractMap 抽象类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;和 List 等类似，AbstractMap 是 Map 接口的抽象实现。如上图所示，Map 集合的整个类结构可以分为红、黄、绿三块。&lt;/p&gt;
&lt;h3 id=&quot;哈希实现&quot;&gt;哈希实现&lt;/h3&gt;
&lt;p&gt;红色部分可以看成是 Map 的哈希实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234832937-298864807.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AbstractMap 有具体的实现类 HashMap。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HashMap 是 AbstractMap 基于哈希算法的具体实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接着，LinkedHashMap 和 WeakedHashMap 继承了 HashMap。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;LinkedHashMap 是 HashMap 的进一步实现，其用链表保存了插入 HashMap 中的元素顺序。WeakedHashMap 是 HashMap 的进一步实现，与 HashMap不同的是：WeakedHashMap 中的引用是弱引用，如果太久没用，则会被自动回收。&lt;/p&gt;
&lt;h3 id=&quot;有序实现-1&quot;&gt;有序实现&lt;/h3&gt;
&lt;p&gt;黄色部分可以看成是 Map 集合的有序实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，SortedMap 接口继承了 Map 接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与 Set 一样，Map 中的元素是没有顺序的，SortedMap 就是有序 Map 的接口定义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接着，NavigableMap 继承了 SortedMap 接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;NavigableMap 接口定义了一些查找逻辑，方便后续实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最后，TreeMap 则是 NavigableMap 接口的具体实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实 TreeMap 是基于红黑树的 Map 实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234833123-826572886.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到了这里，Map 整个类结构看完了一半。而另外一半则是以 Dictionary 为主的实现（绿色部分）。但实际上 Dictionary 是老旧的 Map 实现，现在已经废弃了。我们从源码的注释中可以看到相关的提示。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;NOTE: This class is obsolete（废弃的）.  New implementations should implement the Map interface, rather than extending this class.&lt;br/&gt;这个类已经被废弃，新的实现应该实现 Map 接口，而不是扩展这个类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以针对于 Dictionary 的实现，我们并不打算深入讲解。&lt;/p&gt;
&lt;p&gt;到这里我们总结一下 Map 集合的所有实现类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HashMap：Map 集合的经典哈希实现。&lt;/li&gt;
&lt;li&gt;LinkedHashMap：在 HashMap 的基础上，增加了对插入元素的链表维护。&lt;/li&gt;
&lt;li&gt;WeakedHashMap：在 HashMap 的基础上，使强引用变为弱引用。&lt;/li&gt;
&lt;li&gt;TreeMap：Map 集合的有序实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;工具类&quot;&gt;工具类&lt;/h2&gt;
&lt;p&gt;集合的工具类有：Iterator 迭代器、ListIterator 迭代器、Enumeration 枚举类、Arrays 和 Collections 类。&lt;/p&gt;
&lt;h3 id=&quot;iterator-迭代器&quot;&gt;Iterator 迭代器&lt;/h3&gt;
&lt;p&gt;Iterator 迭代器是一个用来遍历并选择序列中的对象。Java 的 Iterator 只能单向移动。可以看到在 ArrayList、WeakHashMap 等集合类都实现了该接口，从而实现不同类型集合的遍历。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234834013-1579308722.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234834940-577029236.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;listiterator-迭代器&quot;&gt;ListIterator 迭代器&lt;/h3&gt;
&lt;p&gt;ListIterator 继承了 Iterator 接口，所以其有更强大的功能，即它能够实现双向移动。但从其名字也可以看出，其只能适用于 List 集合的遍历。&lt;/p&gt;
&lt;h3 id=&quot;enumeration-枚举类&quot;&gt;Enumeration 枚举类&lt;/h3&gt;
&lt;p&gt;它是 JDK 1.0引入的接口。作用和Iterator一样，也是遍历集合。但是Enumeration的功能要比Iterator少。Enumeration只能在Hashtable, Vector, Stack中使用。这种传统接口已被迭代器取代，虽然 Enumeration 还未被遗弃，但在代码中已经被很少使用了。&lt;/p&gt;
&lt;p&gt;官方也在文档中推荐使用 Iterator 接口来替代 Enumeration 接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595137/201908/595137-20190823234835483-2007183639.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;arrays&quot;&gt;Arrays&lt;/h3&gt;
&lt;p&gt;Java.util.Arrays类能方便地操作数组，它提供的所有方法都是静态的。&lt;/p&gt;
&lt;h3 id=&quot;collections&quot;&gt;Collections&lt;/h3&gt;
&lt;p&gt;java.util.Collections 是一个包含各种有关集合操作的静态多态方法的工具类，服务于 Java 的 Collection 框架。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们花费了大量的篇幅讲解了 List 集合、Set 集合、Map 集合、Queue 集合以及 Iterator 等工具类。我们对这集合的类结构进行了详细的解析，从而更加了解他们之间的关系。&lt;/p&gt;
&lt;p&gt;有时候我们会想，了解这么多有啥用呢。我有个朋友只用了常见的 ArrayList、HashMap 就可以了啊。对于这个问题，我想分享几个收获。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一，让你更加熟悉类之间的差异。&lt;/strong&gt; 如果我们只会用一两个类，那么我们就不知道在什么时候用什么类。例如：什么时候用 HashMap，什么时候用 Hashtable？Iterator 接口有什么作用？JDK源码的命名有什么特点？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二，方便对源码进行扩展。&lt;/strong&gt; 当我们深入研究了集合的实现之后，我们知道了原来 List 接口就是 List 这种数据类型的定义，而 AbstractList 是 List 的抽象实现。那么如果我们要实现一个自定义的 List 结构，那么我们就可以直接继承 AbstractList 类，从而达到快速实现的目的。但如果你没有深入研究呢？你或许只能从头写起，这样得浪费多大的精力啊。你学会了这种方式，那么对于你扩展 Spring 源码也是有很好的帮助的。&lt;/p&gt;
&lt;p&gt;在接下来的文章里，我们将深入介绍每一个集合的具体实现。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 15:49:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<og:description>集合系列（一）：集合框架概述 Java 集合是 Java API 用得最频繁的一类，掌握 Java 集合的原理以及继承结构非常有必要。总的来说，Java 容器可以划分为 4 个部分： List 集合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chanshuyi/p/java_collection_01_summary.html</dc:identifier>
</item>
<item>
<title>学习Lowdb小型本地JSON数据库 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/11403202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/11403202.html</guid>
<description>&lt;p&gt;Lowdb是轻量化的基于Node的JSON文件数据库。对于构建不依赖服务器的小型项目，使用LowDB存储和管理数据是非常不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：lowdb 使用及安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目中的根目录安装 lowdb 命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save-dev lowdb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lowdb是基于&lt;a href=&quot;https://lodash.com/docs&quot; target=&quot;_blank&quot;&gt;lodash&lt;/a&gt;构建的，因此我们可以使用任何 lodash 强大的函数。并且我们可以串联使用。&lt;br/&gt;下面我们的目录结构比如是如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
|---&lt;span&gt; lowdb
&lt;/span&gt;| |---&lt;span&gt; node_modules
&lt;/span&gt;| |---&lt;span&gt; app.js
&lt;/span&gt;| |--- package.json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们在app.js 添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const low = require('lowdb'&lt;span&gt;);
const FileSync &lt;/span&gt;= require('lowdb/adapters/FileSync'&lt;span&gt;);

const adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSync('./db.json'&lt;span&gt;);
const db &lt;/span&gt;=&lt;span&gt; low(adapter);

db.defaults({posts: [], user: {}, count: &lt;/span&gt;0 }).write();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上保存后，我们在命令行中执行 node app.js 后，会在我们的项目中的根目录下新建一个叫 db.json 文件，该文件代码变成如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;posts&quot;&lt;span&gt;: [],
  &lt;/span&gt;&quot;user&quot;&lt;span&gt;: {},
  &lt;/span&gt;&quot;count&quot;: 0&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，引入 lowdb包，然后引入 lowdb 中的适配器 FileSync。&lt;br/&gt;lowdb自带的适配器有：FileSync、FileAsync 和 LocalBrowser。分别有以下可选参数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;defaultValue:&lt;/strong&gt; 文件不存在时的默认值。&lt;br/&gt;&lt;strong&gt;serialize/deserialize:&lt;/strong&gt; 文件被写之前和读之后的操作。&lt;/p&gt;
&lt;p&gt;比如如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const low = require('lowdb'&lt;span&gt;);
const FileSync &lt;/span&gt;= require('lowdb/adapters/FileSync'&lt;span&gt;);

const adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSync('./db.json'&lt;span&gt;, {
  serialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.stringify(data),
  deserialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.parse(data)
});
const db &lt;/span&gt;=&lt;span&gt; low(adapter);

db.defaults({posts: [], user: {}, count: &lt;/span&gt;0 }).write();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，如果我们的db.json 没有数据的时候 才会重新调用 db.defaults初始化数据，否则的话会使用本地存储的数据。我们可以更改 count 的值试试看，不管我们在node命令行中运行多少次，值都是一样的，但是当我们把 db.json内容删除掉后，我们再运行下，发现最新的内容被写入进去了。&lt;/p&gt;
&lt;p&gt;如上代码，如果我们把上面的代码改成这样的如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const low = require('lowdb'&lt;span&gt;);
const FileSync &lt;/span&gt;= require('lowdb/adapters/FileSync'&lt;span&gt;);

const adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSync('./db.json'&lt;span&gt;, {
  serialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; console.log(data),
  deserialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; console.log(data)
});
const db &lt;/span&gt;=&lt;span&gt; low(adapter);

db.defaults({posts: [], user: {}, count: &lt;/span&gt;30 }).write();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么在命令行中运行下，第一次被写入之前 serialize 打印 为 {} 空对象。然后就执行 db.defaults 操作就会把对应的数据写入到 db.json 文件中，然后我们就会执行 deserialize 操作对文件进行读取，然后在命令行中会打印 { posts: [], user: {}, count: 30 }。 打印完成后，我们没有做任何操作后，最后我们再来查看下 db.json文件的内容变成了 undefined. 因此我们可以判定 serialize 和 deserialize 这两个操作完成后，他们也会对文件进行写入操作。如果没有值被写入或操作的话，那么文件内容就变为undefined。当文件变为undefined后，我们再执行上面的代码，可以看到 db.defaults({posts: [], user: {}, count: 30 }).write(); 这句代码是不会被写入的。那么我们可以猜想的到，这句代码的含义是会判断该文件 有没有内容，如果没有内容的话文件数据才会被写入，否则的话就不会执行任何操作。我们可以再把 db.json 文件内容全部删除掉，我们再运行下 node app.js 命令后，可以看到这个时候 数据才会被写入进去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 设置数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以对 db.json 数据里面设置某个字段的数据，比如如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const low = require('lowdb'&lt;span&gt;);
const FileSync &lt;/span&gt;= require('lowdb/adapters/FileSync'&lt;span&gt;);

const adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSync('./db.json'&lt;span&gt;, {
  serialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.stringify(data),
  deserialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.parse(data)
});
const db &lt;/span&gt;=&lt;span&gt; low(adapter);

db.defaults({posts: [], user: {}, count: &lt;/span&gt;30&lt;span&gt; }).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置数据 &lt;/span&gt;
db.set(&quot;user.name&quot;, 'kongzhi').write();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们的 db.json 数据变成如下了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{&quot;posts&quot;:[],&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;},&quot;count&quot;:30}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 获取数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以对json文件获取某个字段后的值，然后进行添加数据操作，或者删除数据操作，总之我们可以操作数据，如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const low = require('lowdb'&lt;span&gt;);
const FileSync &lt;/span&gt;= require('lowdb/adapters/FileSync'&lt;span&gt;);

const adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSync('./db.json'&lt;span&gt;, {
  serialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.stringify(data),
  deserialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.parse(data)
});
const db &lt;/span&gt;=&lt;span&gt; low(adapter);

db.defaults({posts: [], user: {}, count: &lt;/span&gt;30&lt;span&gt; }).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置数据 &lt;/span&gt;
db.set(&quot;user.name&quot;, 'kongzhi'&lt;span&gt;).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get 数据, 然后添加一条数据进去，最后写入文档里面去。&lt;/span&gt;
db.get('posts').push({'id': 1, 'title': 'welcome to hangzhou' }).write();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的db.json 文件代码变成如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{&quot;posts&quot;:[{&quot;id&quot;:1,&quot;title&quot;:&quot;welcome to hangzhou&quot;}],&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;},&quot;count&quot;:30}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3. 更新数据，&lt;/strong&gt;我们可以对某条数据进行更新。如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
const low = require('lowdb'&lt;span&gt;);
const FileSync &lt;/span&gt;= require('lowdb/adapters/FileSync'&lt;span&gt;);

const adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSync('./db.json'&lt;span&gt;, {
  serialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.stringify(data),
  deserialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.parse(data)
});
const db &lt;/span&gt;=&lt;span&gt; low(adapter);

db.defaults({posts: [], user: {}, count: &lt;/span&gt;30&lt;span&gt; }).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置数据 &lt;/span&gt;
db.set(&quot;user.name&quot;, 'kongzhi'&lt;span&gt;).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get 数据, 然后添加一条数据进去，最后写入文档里面去。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; db.get('posts').push({'id': 1, 'title': 'welcome to hangzhou' }).write();&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 update 更新数据 这里的n 就是 count 的默认值，在db.json中的count默认值为30, 最后写入进去&lt;/span&gt;
db.update('count', n =&amp;gt; n + 1).write();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后 db.json 数据代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{&quot;posts&quot;:[{&quot;id&quot;:1,&quot;title&quot;:&quot;welcome to hangzhou&quot;}],&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;},&quot;count&quot;:31}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：由于我们的 lowdb 基于 lodash 的，因此我们可以使用 lodash 中的所有方法和属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. find 查找字段中数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以对 db.json 中的某个字段的数据进行查找。代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
const low = require('lowdb'&lt;span&gt;);
const FileSync &lt;/span&gt;= require('lowdb/adapters/FileSync'&lt;span&gt;);

const adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSync('./db.json'&lt;span&gt;, {
  serialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.stringify(data),
  deserialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.parse(data)
});
const db &lt;/span&gt;=&lt;span&gt; low(adapter);

db.defaults({posts: [], user: {}, count: &lt;/span&gt;30&lt;span&gt; }).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置数据 &lt;/span&gt;
db.set(&quot;user.name&quot;, 'kongzhi'&lt;span&gt;).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get 数据, 然后添加一条数据进去，最后写入文档里面去。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; db.get('posts').push({'id': 1, 'title': 'welcome to hangzhou' }).write();&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 update 更新数据 这里的n 就是 count 的默认值，在db.json中的count默认值为30, 最后写入进去&lt;/span&gt;
db.update('count', n =&amp;gt; n + 1&lt;span&gt;).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找数据&lt;/span&gt;
const value = db.get('posts').find({'id': 1&lt;span&gt;}).value();
console.log(value);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如我们的db.json 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{&quot;posts&quot;:[{&quot;id&quot;:1,&quot;title&quot;:&quot;welcome to hangzhou&quot;}],&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;},&quot;count&quot;:33}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此我们通过 db.get('posts').find({'id': 1}).value() 后就可以获取到值了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201908/561794-20190823232347291-1175057247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. lowdb 的API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. low(adapter): 它返回一个具有特定属性和功能的 lodash.&lt;br/&gt;2. db.[...].write()/.value(): write() 方法是写入数据，value()方法是读取数据。&lt;br/&gt;3. db.getState()/.setState(): 获取/设置数据库的状态。&lt;br/&gt;4. db._ 数据库的lodash的实列。我们可以使用这个来添加我们自己的函数或者第三方的mixins。比如 lodash-id(https://github.com/typicode/lodash-id)&lt;/p&gt;
&lt;p&gt;mixins 的使用列子如下：&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
const low = require('lowdb'&lt;span&gt;);
const FileSync &lt;/span&gt;= require('lowdb/adapters/FileSync'&lt;span&gt;);

const adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSync('./db.json'&lt;span&gt;, {
  serialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.stringify(data),
  deserialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.parse(data)
});
const db &lt;/span&gt;=&lt;span&gt; low(adapter);

db.defaults({posts: [], user: {}, count: &lt;/span&gt;30&lt;span&gt; }).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 mixin 混合模式来扩展我们自己的方法&lt;/span&gt;
&lt;span&gt;db._.mixin({
  getSecondData: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(arr) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; arr[1&lt;span&gt;];
  }
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 getSecondData 方法 获取到 posts 第二条数据&lt;/span&gt;
const xx = db.get('posts'&lt;span&gt;).getSecondData().value();
console.log(xx);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如我们的db.json 代码如下数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;posts&quot;&lt;span&gt;:[
    {&lt;/span&gt;&quot;id&quot;:1,&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;},
    {&lt;/span&gt;&quot;id&quot;:2,&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;}
  ],
  &lt;/span&gt;&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;&lt;span&gt;},
  &lt;/span&gt;&quot;count&quot;:33&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们运行 node app.js 命令后，可以看到，我们可以获取到数组里面的第二条数据了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201908/561794-20190823232452825-969188846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. db.getState/db.setState&lt;/strong&gt; 获取数据库状态/设置数据库的状态， 如下代码演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
const low = require('lowdb'&lt;span&gt;);
const FileSync &lt;/span&gt;= require('lowdb/adapters/FileSync'&lt;span&gt;);

const adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSync('./db.json'&lt;span&gt;, {
  serialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.stringify(data),
  deserialize: (data) &lt;/span&gt;=&amp;gt;&lt;span&gt; JSON.parse(data)
});
const db &lt;/span&gt;=&lt;span&gt; low(adapter);

db.defaults({posts: [], user: {}, count: &lt;/span&gt;30&lt;span&gt; }).write();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取数据库的状态&lt;/span&gt;
&lt;span&gt;console.log(db.getState());

const newState &lt;/span&gt;=&lt;span&gt; {}
db.setState(newState);

console.log(&lt;/span&gt;'-----------'&lt;span&gt;);
console.log(db.getState());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;db.json 假如数据如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;posts&quot;&lt;span&gt;:
    [
      {&lt;/span&gt;&quot;id&quot;:1,&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;},
      {&lt;/span&gt;&quot;id&quot;:2,&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;}
    ],
  &lt;/span&gt;&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;&lt;span&gt;},
  &lt;/span&gt;&quot;count&quot;:33&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201908/561794-20190823232550532-1905681992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 其他json数据操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如 db.json 数据如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;posts&quot;&lt;span&gt;:
    [
      {&lt;/span&gt;&quot;id&quot;:1,&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;},
      {&lt;/span&gt;&quot;id&quot;:2,&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;}
    ],
  &lt;/span&gt;&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;&lt;span&gt;},
  &lt;/span&gt;&quot;count&quot;:33&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1. 检查db.json中有没有 'posts' 这个字段是否存在。如下测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db.has('posts').value();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有该字段就会返回 true， 否则的话，返回false.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 设置值 set &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
db.set('posts', []).write(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运行完成后，就会对 posts 字段设置为 空数组了 [];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 获取特定字段的值 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
db.get('posts').map('id').value(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行完成后会返回 [1, 2]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 获取数量 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db.get('posts').size().value(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回该数组的长度为 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. 获取特定信息的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db.get('posts[0].id').value(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就会返回 1. &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6. 更新信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db.get('posts'&lt;span&gt;)
  .find({title: &lt;/span&gt;'welcome to hangzhou'&lt;span&gt;})
  .assign({name: &lt;/span&gt;'kongzhi'&lt;span&gt;})
  .write();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们可以看到，我们获取 posts这个字段，然后通过 find这个关键字去查找 {title: 'welcome to hangzhou'} 这样的，如果找到，就把 它改成 assign 里面的对象值。如果没有找到，就会在该对象里面添加该值，因此上面的结果返回如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;posts&quot;&lt;span&gt;:[
    {&lt;/span&gt;&quot;id&quot;:1,&quot;title&quot;:&quot;welcome to hangzhou&quot;,&quot;name&quot;:&quot;kongzhi&quot;&lt;span&gt;},
    {&lt;/span&gt;&quot;id&quot;:2,&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;}
  ],
  &lt;/span&gt;&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;&lt;span&gt;},
  &lt;/span&gt;&quot;count&quot;:33&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们把上面的语句改成如下语句，就会更改对应的值了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db.get('posts'&lt;span&gt;)
  .find({name: &lt;/span&gt;'kongzhi'&lt;span&gt;})
  .assign({name: &lt;/span&gt;'xxx'&lt;span&gt;})
  .write();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么结果就变成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;posts&quot;&lt;span&gt;:[
    {&lt;/span&gt;&quot;id&quot;:1,&quot;title&quot;:&quot;welcome to hangzhou&quot;,&quot;name&quot;:&quot;xxx&quot;&lt;span&gt;},
    {&lt;/span&gt;&quot;id&quot;:2,&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;}
  ],
  &lt;/span&gt;&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;&lt;span&gt;},
  &lt;/span&gt;&quot;count&quot;:33&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7. 删除信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db.get('posts'&lt;span&gt;)
  .remove({name: &lt;/span&gt;'xxx'&lt;span&gt;})
  .write();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么结果就变为如下了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;posts&quot;&lt;span&gt;:[
    {&lt;/span&gt;&quot;id&quot;:2,&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;}
  ],
  &lt;/span&gt;&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;&lt;span&gt;},
  &lt;/span&gt;&quot;count&quot;:33&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8. 移除属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db.unset('posts[0].id').write();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么结果变为如下了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{&quot;posts&quot;&lt;span&gt;:[
    {&lt;/span&gt;&quot;title&quot;:&quot;welcome to hangzhou&quot;&lt;span&gt;}
  ],
  &lt;/span&gt;&quot;user&quot;:{&quot;name&quot;:&quot;kongzhi&quot;&lt;span&gt;},
  &lt;/span&gt;&quot;count&quot;:33&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9. 深拷贝&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; xx = db.get('posts'&lt;span&gt;).cloneDeep().value();
console.log(xx); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印：[ { title: 'welcome to hangzhou' } ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;了解更多相关的知识，&lt;a href=&quot;https://ctolib.com/typicode-lowdb.html&quot; target=&quot;_blank&quot;&gt;请看这里&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 15:42:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>学习Lowdb小型本地JSON数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tugenhua0707/p/11403202.html</dc:identifier>
</item>
<item>
<title>我是如何学习写一个操作系统（一）：开篇 - dejavudwh</title>
<link>http://www.cnblogs.com/secoding/p/11402948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/secoding/p/11402948.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有人说程序员的三大浪漫分别是编译原理、操作系统和计算机网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在之前完成了一两个小软件和网站后遇见了编译原理，也不知道为什么就傻傻的学，还写了一个&lt;a href=&quot;https://www.cnblogs.com/secoding/p/11393720.html&quot;&gt;从零写编译器的系列学习笔记&lt;/a&gt;，不过都是小打小闹，只能算作摸到了一点点入门的门槛。再后来想深入学习的时候，因为暑假在家很多书买来的话再带去学校很麻烦，就索性找了一本操作系统的书，也不懂原理就撸了一个玩具型的操作系统&lt;/p&gt;
&lt;h3 id=&quot;几句感概&quot;&gt;几句感概&lt;/h3&gt;
&lt;p&gt;在身边同学都在埋头在各种Web方向，做出各种酷炫的东西，也深深觉得自己Web方向的技术栈太浅浅，之前利用React全家桶+Electron和node做后台的一个&lt;a href=&quot;https://github.com/dejavudwh/StackChat&quot;&gt;聊天软件&lt;/a&gt;，以现在来看略显幼稚，另外的Java虽然是我的第二门语言可是到现在也不算上得台面。下学期就大三了，越临近就业就越焦虑，下学期可能会更侧重应用方向吧。&lt;/p&gt;
&lt;h3 id=&quot;写这个系列的原因&quot;&gt;写这个系列的原因&lt;/h3&gt;
&lt;p&gt;因为跟着书上撸的操作系统属于小的玩具型的操作系统，所以很多涉及到操作系统比较深入的原理都没有进行学习，所以这个系列想作为自己学习操作系统的记录，也就是对原理性的学习和结合实现一个玩具型的操作系统&lt;/p&gt;
&lt;h3 id=&quot;fragileos&quot;&gt;FragileOS&lt;/h3&gt;
&lt;p&gt;FragileOS就是之前实现的一个玩具型操作系统，之前叫这个名字是因为它真的很Fragile，代码结构不好，功能不多，原型基本是来自别人的（后面会提到）&lt;/p&gt;
&lt;p&gt;代码在github上已经分享出来了：&lt;a href=&quot;https://github.com/dejavudwh/FragileOS&quot;&gt;FragileOS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/secoding/1532276/o_osjpg.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;主要界面&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;正式开始&quot;&gt;正式开始&lt;/h2&gt;
&lt;p&gt;这个学习笔记可能用到的有四本书：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《x86汇编语言：从实模式到保护模式》&lt;/li&gt;
&lt;li&gt;《操作系统：精髓与设计原理》&lt;/li&gt;
&lt;li&gt;《OrangeS：一个操作系统的实现》&lt;/li&gt;
&lt;li&gt;《30天自制操作系统》&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一本和第三本第四本在之前实现那个玩具型操作系统起了很大的作用，但是第三本只看了一点，第二本则是根据别人的推荐来的。所以战线很长很长，希望能坚持下来&lt;/p&gt;
&lt;h3 id=&quot;环境准备&quot;&gt;环境准备&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;VirtualBox 6.0&lt;/p&gt;
一个开源的虚拟机，开发的操作系统就运行在这之上&lt;/li&gt;
&lt;li&gt;GCC 8.1.0&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NASM 2.07&lt;/p&gt;
汇编器&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;objconv&lt;/p&gt;
&lt;p&gt;反汇编器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;希望能够坚持下去吧&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 14:17:00 +0000</pubDate>
<dc:creator>dejavudwh</dc:creator>
<og:description>前言 有人说程序员的三大浪漫分别是编译原理、操作系统和计算机网络 在之前完成了一两个小软件和网站后遇见了编译原理，也不知道为什么就傻傻的学，还写了一个 '从零写编译器的系列学习笔记' ，不过都是小打小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/secoding/p/11402948.html</dc:identifier>
</item>
<item>
<title>Glide3升级到Glide4碰到的问题汇总以及部分代码修改 - xing_star</title>
<link>http://www.cnblogs.com/xing-star/p/11402933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing-star/p/11402933.html</guid>
<description>&lt;p&gt;版权声明：本文为xing_star原创文章，转载请注明出处！&lt;/p&gt;
&lt;p&gt;本文同步自&lt;a href=&quot;http://javaexception.com/archives/188&quot; target=&quot;_blank&quot;&gt;http://javaexception.com/archives/188&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Glide.3x的版本是3.7.0，Glide4.x的版本是4.2.0&lt;/p&gt;
&lt;h2 id=&quot;title-0&quot;&gt;Glide3.x中最基础的用法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Glide.with(getActivity()).load(url).into(imageView)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么在Glide4.x中，其实还是一样的，最基本的用法不变&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Glide.with(context).load(url).into(imageView)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是稍微复杂一点的用法就有很大的差异了，接下来我们一一列举。&lt;/p&gt;

&lt;h2 id=&quot;title-1&quot;&gt;接下来看一个稍微常规点的复杂用法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Glide.with(BaseApplication.getAppContext())
.load(url)
.placeholder(R.drawable.xxx)
.crossFade()
.into(imageView);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;升级到Glide4后，更新为了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DrawableCrossFadeFactory drawableCrossFadeFactory = &lt;span&gt;new&lt;/span&gt; DrawableCrossFadeFactory.Builder().setCrossFadeEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).build();
Glide.with(BaseApplication.getAppContext())
.load(url)
.apply(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestOptions().placeholder(R.drawable.xxx))
.transition(DrawableTransitionOptions.with(drawableCrossFadeFactory))
.into(imageView);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Glide3.x的链式调用，Glide4.x的用法还是比较繁琐的&lt;/p&gt;
&lt;p&gt;接下来记录踩得第一个坑&lt;/p&gt;

&lt;h2 id=&quot;title-2&quot;&gt;Glide4.0后占位图和过渡动画冲突 &lt;/h2&gt;
&lt;p&gt;在实际使用过程中发现升级到Glide4之后，展位图跟过渡动画存在冲突，最后找到解决办法，Glide4加载url的代码调整为了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DrawableCrossFadeFactory drawableCrossFadeFactory = &lt;span&gt;new&lt;/span&gt; DrawableCrossFadeFactory.Builder().setCrossFadeEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).build();
Glide.with(BaseApplication.getAppContext())
.load(url)
.apply(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestOptions().placeholder(R.drawable.xxx))
.transition(DrawableTransitionOptions.with(drawableCrossFadeFactory))
.into(imageView);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键点在于&lt;br/&gt;setCrossFadeEnabled(true)&lt;/p&gt;

&lt;h2 id=&quot;title-3&quot;&gt;淡入淡出动画效果&lt;/h2&gt;
&lt;p&gt; 其实跟上面的一样，Glide3.x中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Glide.with(BaseApplication.getAppContext())
.load(url)
.crossFade()
.placeholder(R.drawable.xxx)
.into(imageView);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用法是这样的&lt;/p&gt;
&lt;p&gt;到Glide4.x中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DrawableCrossFadeFactory drawableCrossFadeFactory = &lt;span&gt;new&lt;/span&gt; DrawableCrossFadeFactory.Builder().setCrossFadeEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).build();
Glide.with(BaseApplication.getAppContext())
.load(url)
.transition(DrawableTransitionOptions.with(drawableCrossFadeFactory))
.apply(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestOptions().placeholder(R.drawable.post))
.into(imageView);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要使用的是transition方法以及apply方法。apply方法里面可以用来设置placeholder，errorr，centerCrop等方法。这个地方跟Glide3.x是不一样的，用起来可能会觉得别扭。&lt;/p&gt;

&lt;h2 id=&quot;title-4&quot;&gt;预加载问题&lt;/h2&gt;
&lt;p&gt;Glide3.x是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Glide.with(BaseApplication.getAppContext())
.load(url)
.diskCacheStrategy(DiskCacheStrategy.SOURCE);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;升级到Glide4.x之后，有所调整，用的是preload方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Glide.with(BaseApplication.getAppContext())
.load(url)
.preload();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;title-5&quot;&gt;自定义BitmapTransformation &lt;/h2&gt;
&lt;p&gt;升级后有几个方法发生了变更, 在我们自定义BitmapTransformation实现一些特定的圆角等需求中，Glide3.x中只需要实现getId方法, 而在Glide4.x中，需要重写equals方法，以及hashCode方法，还有updateDiskCacheKey。&lt;br/&gt;我们以GlideRoundTransform为例，看看两个版本的细微差异:&lt;/p&gt;
&lt;p&gt;Glide3.x的代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GlideRoundTransform &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BitmapTransformation {
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; radius =&lt;span&gt; 0f;
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GlideRoundTransform(Context context) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(context, 4&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GlideRoundTransform(Context context, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dp) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.radius =&lt;span&gt; DisplayUtils.dip2px(dp);
    }
 
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Bitmap transform(BitmapPool pool, Bitmap toTransform, &lt;span&gt;int&lt;/span&gt; outWidth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; outHeight) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roundCrop(pool, toTransform);
    }
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Bitmap roundCrop(BitmapPool pool, Bitmap source) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
 
        Bitmap result &lt;/span&gt;=&lt;span&gt; pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            result &lt;/span&gt;=&lt;span&gt; Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);
        }
 
        Canvas canvas &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Canvas(result);
        Paint paint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Paint();
        paint.setShader(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));
        paint.setAntiAlias(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        RectF rectF &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RectF(0f, 0f, source.getWidth(), source.getHeight());
        canvas.drawRoundRect(rectF, radius, radius, paint);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
 
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getClass().getName() +&lt;span&gt; Math.round(radius);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GlideRoundTransform &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BitmapTransformation {
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ID = &quot;com.star.wall.glide.GlideRoundTransform&quot;&lt;span&gt;;
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; radius =&lt;span&gt; 0f;
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GlideRoundTransform(Context context) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(context, 4&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GlideRoundTransform(Context context, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dp) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.radius =&lt;span&gt; DisplayUtils.dip2px(dp);
    }
 
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Bitmap transform(BitmapPool pool, Bitmap toTransform, &lt;span&gt;int&lt;/span&gt; outWidth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; outHeight) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roundCrop(pool, toTransform);
    }
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Bitmap roundCrop(BitmapPool pool, Bitmap source) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
 
        Bitmap result &lt;/span&gt;=&lt;span&gt; pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            result &lt;/span&gt;=&lt;span&gt; Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);
        }
 
        Canvas canvas &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Canvas(result);
        Paint paint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Paint();
        paint.setShader(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));
        paint.setAntiAlias(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        RectF rectF &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RectF(0f, 0f, source.getWidth(), source.getHeight());
        canvas.drawRoundRect(rectF, radius, radius, paint);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
 
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; GlideRoundTransform) {
            GlideRoundTransform other &lt;/span&gt;=&lt;span&gt; (GlideRoundTransform) o;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; radius ==&lt;span&gt; other.radius;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
 
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (ID + &quot;_&quot; +&lt;span&gt; radius).hashCode();
    }
 
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateDiskCacheKey(MessageDigest messageDigest) {
        messageDigest.update((ID &lt;/span&gt;+ &quot;_&quot; +&lt;span&gt; radius).getBytes());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果还有其他的自定义transform需求，可以参考上面的代码作为模板，进行调整。&lt;/p&gt;

&lt;h2 id=&quot;title-6&quot;&gt;对于只支持设置imageView.setImageDrawable方法的view&lt;/h2&gt;
&lt;p&gt;加载url的代码Glide3.x中是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Glide.with(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
.load(url)
.into(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SimpleTarget&amp;lt;GlideDrawable&amp;gt;&lt;span&gt;() {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onResourceReady(GlideDrawable resource, GlideAnimation&amp;lt;? &lt;span&gt;super&lt;/span&gt; GlideDrawable&amp;gt;&lt;span&gt; glideAnimation) {
stvInfo.setLeftIcon(resource);
}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Glide4.x中是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Glide.with(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
.load(url)
.into(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SimpleTarget&amp;lt;Drawable&amp;gt;&lt;span&gt;() {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onResourceReady(Drawable resource, Transition&amp;lt;? &lt;span&gt;super&lt;/span&gt; Drawable&amp;gt;&lt;span&gt; transition) {
stvInfo.setLeftIcon(resource);
}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一块的关键点是SimpleTarget,通过实现这个抽象类的特定方法，我们可以获取到drawable,拿到了drawable就可以给imageView设置图片源了，Glide3.x和Glide4.x的区别在于一个是GlideDrawable，一个是Drawable.&lt;/p&gt;

&lt;h2 id=&quot;title-7&quot;&gt;同步代码中，获取bitmap&lt;/h2&gt;
&lt;p&gt;在Glide3.x中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Bitmap bitmap =&lt;span&gt; Glide.with(BaseApplication.getAppContext())
.load(url).asBitmap()
.into(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)
.get();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;asBitmap后，调用get()方法，就能够获取到bitmap了，而在Glide4.x中，还得调整下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Bitmap bitmap =&lt;span&gt; Glide.with(BaseApplication.getAppContext()).asBitmap().load(url)
.apply(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RequestOptions().override(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)).submit().get();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以观察下，这两个差异还挺大的，Glide4.x里面是先asBitmap，再load(url),还有就是通过submit().get()的方式获取到bitmap&lt;/p&gt;

&lt;h2 id=&quot;title-8&quot;&gt;包含centerCrop,thumbnail,placeholder,error等常用方法的例子&lt;/h2&gt;
&lt;p&gt;Glide3中是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Glide.with(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
        .load(url)
        .centerCrop()
        .thumbnail(&lt;/span&gt;0.1f&lt;span&gt;)
        .placeholder(R.drawable.icon_pic_default)
        .error(R.drawable.icon_pic_default)
        .into(imageView);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而Glide4中是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Glide.with(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
        .load(url)
        .apply(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestOptions().centerCrop().placeholder(R.drawable.icon_pic_default).error(R.drawable.icon_pic_default))
        .thumbnail(&lt;/span&gt;0.1f&lt;span&gt;)
        .into(imageView);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未完待续。&lt;/p&gt;

&lt;h2 id=&quot;title-9&quot;&gt;补充资料:&lt;/h2&gt;
&lt;p&gt;Glide4.0后占位图和过渡动画冲突解决方案 &lt;a title=&quot;&quot; href=&quot;http://javaexception.com/go.html?url=https://www.jianshu.com/p/28f5bcee409f&quot; rel=&quot;nofollow&quot; data-original-title=&quot;&quot;&gt;https://www.jianshu.com/p/28f5bcee409f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于ImageView的几个常见问题 &lt;a title=&quot;&quot; href=&quot;http://javaexception.com/archives/173&quot; rel=&quot;nofollow&quot; data-original-title=&quot;&quot;&gt;http://javaexception.com/archives/173&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Glide处理圆形ImageView &lt;a title=&quot;&quot; href=&quot;http://javaexception.com/archives/182&quot; rel=&quot;nofollow&quot; data-original-title=&quot;&quot;&gt;http://javaexception.com/archives/182&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如何使用Glide加载通知栏头像url &lt;a title=&quot;&quot; href=&quot;http://javaexception.com/archives/19&quot; rel=&quot;nofollow&quot; data-original-title=&quot;&quot;&gt;http://javaexception.com/archives/19&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 23 Aug 2019 14:13:00 +0000</pubDate>
<dc:creator>xing_star</dc:creator>
<og:description>版权声明：本文为xing_star原创文章，转载请注明出处！ 本文同步自http://javaexception.com/archives/188 Glide.3x的版本是3.7.0，Glide4.x</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xing-star/p/11402933.html</dc:identifier>
</item>
<item>
<title>利用QGIS下载地图数据 - Dr.LYF</title>
<link>http://www.cnblogs.com/doctor-li/p/11402774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/doctor-li/p/11402774.html</guid>
<description>&lt;p&gt;这段时间做了一些利用地理信息进行定位导航的系列工作，其中很重要的一部分是如何获取到地图数据，比如道路的矢量图、某一区域的栅格图，我用到的主要工具是QGIS。QGIS是一个跨平台的免费应用，其中集成了对矢量图、栅格图处理的很多功能，同时也集成了很多开放地图数据网站的接口，比如OpenStreetMap等，因此，在获取数据，并处理成我们需要的格式方面非常便利。本篇博文主要介绍如何使用QGIS下载数据，并处理成特定的格式。&lt;/p&gt;
&lt;h2&gt;一、 指定区域指定地物矢量图获取&lt;/h2&gt;
&lt;p&gt;我们经常会遇到这样一种需求：获取某一区域的指定地物的地图，比如获取某一区域的道路图、河流图等。这一节的内容能够解决这一需求。通常我们从开放的地图平台OpenStreetMap中下载某一区域的矢量地图，而后通过后续的处理，来获取我们需要的地图信息。&lt;/p&gt;
&lt;h3&gt;1、数据下载&lt;/h3&gt;
&lt;p&gt;1) 在vector菜单栏中选择OpenStreetMap -&amp;gt;Download Data，即可打开数据的下载框：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823212817385-491474682.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）而后设定需要下载数据的区域，这里提供了三种区域设置方式：&lt;/p&gt;
&lt;p&gt;a) From map canvas：当前窗口显示的区域&lt;/p&gt;
&lt;p&gt;b) From layer：某一图层所代表的区域&lt;/p&gt;
&lt;p&gt;c) Manual：人为设定区域&lt;/p&gt;
&lt;p&gt;通常当我们已知我们需要下载的数据的区域，我们采用第三种方式。&lt;/p&gt;

&lt;p&gt;3）下载数据：设置好下载区域，并输入保存文件名后，点击确定，即开始下载数据。这里需要注意的一点是，在设定保存文件名时，需要把文件的扩展名带上，即.osm，这样在后续加载文件时，才不会出现找不到文件的情况。&lt;/p&gt;

&lt;h3&gt;2、提取指定地物及矢量图保持&lt;/h3&gt;
&lt;p&gt;上一步下载的数据是以xml的形式存储的，不是矢量图的格式，因此不能被直接处理。我们需要首先将该文件加载入QGIS中，并转换为矢量数据，才能进行下一步的处理。&lt;/p&gt;
&lt;p&gt;1） osm文件加载：选择vector-&amp;gt;Import Topology from XML，打开数据导入页面： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823212849286-1826538294.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择需要导入的文件（即刚才我们下载的osm文件），设置转换后文件名，点击确认。&lt;/p&gt;
&lt;p&gt;2） 导出矢量图：选择vector-&amp;gt;Export Topology to SpatiaLite，打开矢量图导出页面： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823212901876-1636182317.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于此处我们需要得到的是道路数据，因此我们在“export type”选择Polylines；而后设置导出文件名；最后需要导出标签。选择Load from DB，并选择感兴趣的标签。这里我们仅对道路感兴趣，因此我们仅选择highway。保留标签的目的是为了进一步筛选，虽然我们在“export type”中选择了Polylines，但是并不是所有的Polylines都是道路（也有可能是河流等），因此需要进行进一步的筛选。 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823212914241-1952015244.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3） 筛选感兴趣的地物： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823212925970-978489545.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述得到的矢量图，不仅仅包含道路图，还包含了其他地物特征，因此需要进一步筛选。&lt;/p&gt;
&lt;p&gt;在获得的图层上，右键打开菜单选项，选择Open Attribute Table：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823212958416-904374437.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;选择select by expression（图中红色圈），而后设置筛选的条件。这里我们需要选择的是道路，因此我们的筛选条件为：NOT (“highway”= ‘NULL’)。点集select按钮后，可以看见，道路部分被黄色高亮了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823213012316-361563310.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而后我们在图层窗口右键打开菜单，选择保存，打开保存页面：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823213027726-158079504.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;设置保存文件名，地理坐标系，注意勾选红色圈内选项，选择保存，即得到该区域的道路矢量图。&lt;/p&gt;
&lt;h2&gt;二、指定区域栅格图获取&lt;/h2&gt;
&lt;h3&gt;1、设置下载网址&lt;/h3&gt;
&lt;p&gt;在Browser Panel窗口中找到Tile Server(XYZ)，右键，New Connection：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823213105031-853023611.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823213111430-939198686.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入服务器的网址，例如：&lt;/p&gt;
&lt;p&gt;高德影像图：&lt;/p&gt;
&lt;p&gt;https://webst01.is.autonavi.com/appmaptile?style=6&amp;amp;x={x}&amp;amp;y={y}&amp;amp;z={z}&lt;/p&gt;
&lt;p&gt;高德路网：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wprd01.is.autonavi.com/appmaptile?x=%7bx%7d&amp;amp;y=%7by%7d&amp;amp;z=%7bz%7d&amp;amp;lang=zh_cn&amp;amp;size=1&amp;amp;scl=2&amp;amp;style=8&amp;amp;ltype=11&quot;&gt;https://wprd01.is.autonavi.com/appmaptile?x={x}&amp;amp;y={y}&amp;amp;z={z}&amp;amp;lang=zh_cn&amp;amp;size=1&amp;amp;scl=2&amp;amp;style=8&amp;amp;ltype=11&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此时会生成服务器地图的接口。&lt;/p&gt;
&lt;h3&gt;2、创建栅格地图图层&lt;/h3&gt;
&lt;p&gt;双击上述创建的服务器地图接口，即会在Layer Panel中生成一个响应的图层。此时，如果我们知道需要下载的区域的地理坐标，可直接进入第三步。如果不知道，可以打开参考地图，通过手动选取，来设定下载区域。具体做法为：&lt;/p&gt;
&lt;p&gt;打开web-&amp;gt;OpenLayers plugin，选择想要的地图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823213135668-350490286.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;而后通过缩放，拖动等操作，将地图设置到我们需要的区域：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823213148917-677868839.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;3、保存需要的栅格地图&lt;/h3&gt;
&lt;p&gt;在创建的栅格图层上，右键，选择保存，打开保存页面：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823213218014-1882595698.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548783/201908/1548783-20190823213225403-590486847.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;设置保存的路径，地理坐标系，范围（Extent），分辨率（Resolution），点击确定后，栅格地图数据就会被下载下来。如果保存的范围很大，通常地图会被分割为若干个小的区域进行保存。 &lt;/p&gt;
&lt;p&gt;相关操作，可以参考视频：&lt;a href=&quot;https://www.bilibili.com/video/av65061459/&quot;&gt;https://www.bilibili.com/video/av65061459/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 13:34:00 +0000</pubDate>
<dc:creator>Dr.LYF</dc:creator>
<og:description>利用QGIS下载矢量地图和栅格地图。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/doctor-li/p/11402774.html</dc:identifier>
</item>
<item>
<title>朴素贝叶斯python代码实现（西瓜书） - 知然</title>
<link>http://www.cnblogs.com/zhiranok/p/bys.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhiranok/p/bys.html</guid>
<description>&lt;h2 id=&quot;摘要&quot;&gt;摘要：&lt;/h2&gt;
&lt;p&gt;朴素贝叶斯也是机器学习中一种非常常见的分类方法，对于二分类问题，并且数据集特征为离散型属性的时候，&lt;br/&gt;使用起来非常的方便。原理简单，训练效率高，拟合效果好。&lt;/p&gt;
&lt;h2 id=&quot;朴素贝叶斯&quot;&gt;朴素贝叶斯&lt;/h2&gt;
&lt;p&gt;贝叶斯公式：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/282357/201908/282357-20190823200916848-103680275.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;朴素贝叶斯之所以称这为朴素，是因为假设了各个特征是相互独立的，因此假定下公式成立：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/282357/201908/282357-20190823200922536-18959263.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则朴素贝叶斯算法的计算公式如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/282357/201908/282357-20190823200927490-1435661781.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际计算中，上面的公式会做如下略微改动：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于某些特征属性的值P(Xi|Ci)可能很小，多个特征的p值连乘后可能被约等于0。可以公式两边取log然后变乘法为加法，避免类乘问题。&lt;/li&gt;
&lt;li&gt;P(Ci) 和P(Xi|Ci) 一般不直接使用样本的频率计算出来，一般会使用拉普拉斯平滑。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/282357/201908/282357-20190823200931990-1798054645.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面公式中，Dc为该类别的频数，N表示所有类别的可能数。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/282357/201908/282357-20190823200936414-715362009.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面公式中，Dc,xi为该特征对应属性的频数，Dc为该类别的频数，Ni表示该特征的可能的属性数。&lt;/p&gt;
&lt;h2 id=&quot;对应的西瓜书数据集为&quot;&gt;对应的西瓜书数据集为&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;色泽  根蒂  敲声  纹理  脐部  触感  好瓜
青绿  蜷缩  浊响  清晰  凹陷  硬滑  是
乌黑  蜷缩  沉闷  清晰  凹陷  硬滑  是
乌黑  蜷缩  浊响  清晰  凹陷  硬滑  是
青绿  蜷缩  沉闷  清晰  凹陷  硬滑  是
浅白  蜷缩  浊响  清晰  凹陷  硬滑  是
青绿  稍蜷  浊响  清晰  稍凹  软粘  是
乌黑  稍蜷  浊响  稍糊  稍凹  软粘  是
乌黑  稍蜷  浊响  清晰  稍凹  硬滑  是
乌黑  稍蜷  沉闷  稍糊  稍凹  硬滑  否
青绿  硬挺  清脆  清晰  平坦  软粘  否
浅白  硬挺  清脆  模糊  平坦  硬滑  否
浅白  蜷缩  浊响  模糊  平坦  软粘  否
青绿  稍蜷  浊响  稍糊  凹陷  硬滑  否
浅白  稍蜷  沉闷  稍糊  凹陷  硬滑  否
乌黑  稍蜷  浊响  清晰  稍凹  软粘  否
浅白  蜷缩  浊响  模糊  平坦  硬滑  否
青绿  蜷缩  沉闷  稍糊  稍凹  硬滑  否&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python实现&quot;&gt;python实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#encoding:utf-8

import pandas as pd
import numpy  as np

class NaiveBayes:
    def __init__(self):
        self.model = {}#key 为类别名 val 为字典PClass表示该类的该类，PFeature:{}对应对于各个特征的概率
    def calEntropy(self, y): # 计算熵
        valRate = y.value_counts().apply(lambda x : x / y.size) # 频次汇总 得到各个特征对应的概率
        valEntropy = np.inner(valRate, np.log2(valRate)) * -1
        return valEntropy

    def fit(self, xTrain, yTrain = pd.Series()):
        if not yTrain.empty:#如果不传，自动选择最后一列作为分类标签
            xTrain = pd.concat([xTrain, yTrain], axis=1)
        self.model = self.buildNaiveBayes(xTrain) 
        return self.model
    def buildNaiveBayes(self, xTrain):
        yTrain = xTrain.iloc[:,-1]
        
        yTrainCounts = yTrain.value_counts()# 频次汇总 得到各个特征对应的概率

        yTrainCounts = yTrainCounts.apply(lambda x : (x + 1) / (yTrain.size + yTrainCounts.size)) #使用了拉普拉斯平滑
        retModel = {}
        for nameClass, val in yTrainCounts.items():
            retModel[nameClass] = {'PClass': val, 'PFeature':{}}

        propNamesAll = xTrain.columns[:-1]
        allPropByFeature = {}
        for nameFeature in propNamesAll:
            allPropByFeature[nameFeature] = list(xTrain[nameFeature].value_counts().index)
        #print(allPropByFeature)
        for nameClass, group in xTrain.groupby(xTrain.columns[-1]):
            for nameFeature in propNamesAll:
                eachClassPFeature = {}
                propDatas = group[nameFeature]
                propClassSummary = propDatas.value_counts()# 频次汇总 得到各个特征对应的概率
                for propName in allPropByFeature[nameFeature]:
                    if not propClassSummary.get(propName):
                        propClassSummary[propName] = 0#如果有属性灭有，那么自动补0
                Ni = len(allPropByFeature[nameFeature])
                propClassSummary = propClassSummary.apply(lambda x : (x + 1) / (propDatas.size + Ni))#使用了拉普拉斯平滑
                for nameFeatureProp, valP in propClassSummary.items():
                    eachClassPFeature[nameFeatureProp] = valP
                retModel[nameClass]['PFeature'][nameFeature] = eachClassPFeature

        return retModel
    def predictBySeries(self, data):
        curMaxRate = None
        curClassSelect = None
        for nameClass, infoModel in self.model.items():
            rate = 0
            rate += np.log(infoModel['PClass'])
            PFeature = infoModel['PFeature']
            
            for nameFeature, val in data.items():
                propsRate = PFeature.get(nameFeature)
                if not propsRate:
                    continue
                rate += np.log(propsRate.get(val, 0))#使用log加法避免很小的小数连续乘，接近零
                #print(nameFeature, val, propsRate.get(val, 0))
            #print(nameClass, rate)
            if curMaxRate == None or rate &amp;gt; curMaxRate:
                curMaxRate = rate
                curClassSelect = nameClass
            
        return curClassSelect
    def predict(self, data):
        if isinstance(data, pd.Series):
            return self.predictBySeries(data)
        return data.apply(lambda d: self.predictBySeries(d), axis=1)

dataTrain = pd.read_csv(&quot;xiguadata.csv&quot;, encoding = &quot;gbk&quot;)

naiveBayes = NaiveBayes()
treeData = naiveBayes.fit(dataTrain)

import json
print(json.dumps(treeData, ensure_ascii=False))

pd = pd.DataFrame({'预测值':naiveBayes.predict(dataTrain), '正取值':dataTrain.iloc[:,-1]})
print(pd)
print('正确率:%f%%'%(pd[pd['预测值'] == pd['正取值']].shape[0] * 100.0 / pd.shape[0]))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;否&quot;: {&quot;PClass&quot;: 0.5263157894736842, &quot;PFeature&quot;: {&quot;色泽&quot;: {&quot;浅白&quot;: 0.4166666666666667, &quot;青绿&quot;: 0.3333333333333333, &quot;乌 黑&quot;: 0.25}, &quot;根蒂&quot;: {&quot;稍蜷&quot;: 0.4166666666666667, &quot;蜷缩&quot;: 0.3333333333333333, &quot;硬挺&quot;: 0.25}, &quot;敲声&quot;: {&quot;浊响&quot;: 0.4166666666666667, &quot;沉闷&quot;: 0.3333333333333333, &quot;清脆&quot;: 0.25}, &quot;纹理&quot;: {&quot;稍糊&quot;: 0.4166666666666667, &quot;模糊&quot;: 0.3333333333333333, &quot;清晰&quot;: 0.25}, &quot;脐部&quot;: {&quot;平坦&quot;: 0.4166666666666667, &quot;稍凹&quot;: 0.3333333333333333, &quot;凹陷&quot;: 0.25}, &quot;触感&quot;: {&quot;硬滑&quot;: 0.6363636363636364, &quot;软粘&quot;: 0.36363636363636365}}}, &quot;是&quot;: {&quot;PClass&quot;: 0.47368421052631576, &quot;PFeature&quot;: {&quot;色泽&quot;: {&quot;乌黑&quot;: 0.45454545454545453, &quot;青绿&quot;: 0.36363636363636365, &quot;浅白&quot;: 0.18181818181818182}, &quot;根蒂&quot;: {&quot;蜷缩&quot;: 0.5454545454545454, &quot;稍蜷&quot;: 0.36363636363636365, &quot;硬挺&quot;: 0.09090909090909091}, &quot;敲声&quot;: {&quot;浊响&quot;: 0.6363636363636364, &quot;沉闷&quot;: 0.2727272727272727, &quot;清脆&quot;: 0.09090909090909091}, &quot;纹理&quot;: {&quot;清晰&quot;: 0.7272727272727273, &quot;稍糊&quot;: 0.18181818181818182, &quot;模糊&quot;: 0.09090909090909091}, &quot;脐 部&quot;: {&quot;凹陷&quot;: 0.5454545454545454, &quot;稍凹&quot;: 0.36363636363636365, &quot;平坦&quot;: 0.09090909090909091}, &quot;触感&quot;: {&quot;硬滑&quot;: 0.7, &quot;软粘&quot;: 0.3}}}}
   预测值 正取值
0    是   是
1    是   是
2    是   是
3    是   是
4    是   是
5    是   是
6    否   是
7    是   是
8    否   否
9    否   否
10   否   否
11   否   否
12   是   否
13   否   否
14   是   否
15   否   否
16   否   否
正确率:82.352941%&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;贝叶斯分类器是一种生成式模型，不是直接拟合分类结果，而是拟合出后验概率公式计算对应分类的概率。&lt;/li&gt;
&lt;li&gt;本文只介绍了二分类，也可以用来处理多分类问题。&lt;/li&gt;
&lt;li&gt;对于小规模数据集，表现良好。&lt;/li&gt;
&lt;li&gt;建立在特征相互独立的假设上。&lt;/li&gt;
&lt;li&gt;这是我的github主页https://github.com/fanchy，有些有意思的分享。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 23 Aug 2019 12:12:00 +0000</pubDate>
<dc:creator>知然</dc:creator>
<og:description>朴素贝叶斯也是机器学习中一种非常常见的分类方法，对于二分类问题，并且数据集特征为离散型属性的时候， 使用起来非常的方便。原理简单，训练效率高，拟合效果好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhiranok/p/bys.html</dc:identifier>
</item>
</channel>
</rss>