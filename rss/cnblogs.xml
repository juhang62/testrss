<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Protocol Buffers（2）：编码与解码 - Mr-Lee</title>
<link>http://www.cnblogs.com/shine-lee/p/10717521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shine-lee/p/10717521.html</guid>
<description>&lt;p&gt;博客：&lt;a href=&quot;https://blog.shinelee.me/&quot;&gt;blog.shinelee.me&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/shine-lee/&quot;&gt;博客园&lt;/a&gt; | &lt;a href=&quot;https://blog.csdn.net/blogshinelee&quot;&gt;CSDN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上一篇文章中我们提到，对于序列化后字节流，需要回答的一个重要问题是“&lt;strong&gt;从哪里到哪里是哪个数据成员&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;message中每一个field的格式为：&lt;br/&gt;&lt;code&gt;required/optional/repeated FieldType FieldName = FieldNumber（a unique number in current message）&lt;/code&gt;&lt;br/&gt;在序列化时，一个field对应一个&lt;strong&gt;key-value&lt;/strong&gt;对，整个二进制文件就是一连串紧密排列的&lt;strong&gt;key-value&lt;/strong&gt;对，key也称为tag，先上图直观感受一下，图片来自&lt;a href=&quot;https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/ch04.html&quot;&gt;Encoding and Evolution&lt;/a&gt;：&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/04/15/Aj3lwV.png&quot; alt=&quot;Example record encoded using Protocol Buffers&quot;/&gt;&lt;/p&gt;
&lt;p&gt;key由wire type和FieldNumber两部分编码而成， 具体地&lt;code&gt;key = (field_number &amp;lt;&amp;lt; 3) | wire_type&lt;/code&gt;，&lt;strong&gt;field_number 部分指示了当前是哪个数据成员，通过它将cc和h文件中的数据成员与当前的key-value对应起来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;key的最低3个bit为wire type，&lt;strong&gt;什么是wire type？&lt;/strong&gt;如下表所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/04/15/Aj3zkT.png&quot; alt=&quot;wire types&quot;/&gt;&lt;br/&gt;wire type被如此设计，主要是为了解决一个问题，&lt;strong&gt;如何知道接下来value部分的长度（字节数）&lt;/strong&gt;，如果&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;wire type = 0、1、5，编码为 &lt;strong&gt;key + 数据&lt;/strong&gt;，只有一个数据，可能占数个字节，&lt;strong&gt;数据在编码时自带终止标记&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;wire type = 2，编码为 &lt;strong&gt;key + length + 数据&lt;/strong&gt;，length指示了数据长度，可能有多个数据，顺序排在length后&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，我们直接看一下example.pb.cc及相关的源码，看下key-value对是如何解析的。&lt;strong&gt;解码过程相对简单，理解了解码过程，编码也就比较显然了&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// example.proto
package example;

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// in example.pb.cc
bool Person::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:example.Person)
  for (;;) {
    ::std::pair&amp;lt;::google::protobuf::uint32, bool&amp;gt; p = input-&amp;gt;ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (static_cast&amp;lt; ::google::protobuf::uint8&amp;gt;(tag) == (10 &amp;amp; 0xFF)) { // 10 = (1 &amp;lt;&amp;lt; 3) + 2
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this-&amp;gt;mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this-&amp;gt;name().data(), static_cast&amp;lt;int&amp;gt;(this-&amp;gt;name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            &quot;example.Person.name&quot;);
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 id = 2;
      case 2: {
        if (static_cast&amp;lt; ::google::protobuf::uint8&amp;gt;(tag) == (16 &amp;amp; 0xFF)) { // 16 = (2 &amp;lt;&amp;lt; 8) + 0
          HasBitSetters::set_has_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive&amp;lt;
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32&amp;gt;(
                 input, &amp;amp;id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string email = 3;
      case 3: {
        if (static_cast&amp;lt; ::google::protobuf::uint8&amp;gt;(tag) == (26 &amp;amp; 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this-&amp;gt;mutable_email()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this-&amp;gt;email().data(), static_cast&amp;lt;int&amp;gt;(this-&amp;gt;email().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            &quot;example.Person.email&quot;);
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:example.Person)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:example.Person)
  return false;
#undef DO_
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整段代码在循环地解析&lt;code&gt;input&lt;/code&gt;流，遇到1个&lt;code&gt;tag&lt;/code&gt;（key），根据其wire type和数据类型调用相应的解析函数，如果是&lt;code&gt;string&lt;/code&gt;，则调用&lt;code&gt;ReadString&lt;/code&gt;，&lt;code&gt;ReadString&lt;/code&gt;会一直调用到&lt;code&gt;ReadBytesToString&lt;/code&gt;，如果是&lt;code&gt;int32&lt;/code&gt;，则调用&lt;code&gt;ReadPrimitive&lt;/code&gt;，&lt;code&gt;ReadPrimitive&lt;/code&gt;中会进一步调用&lt;code&gt;ReadVarint32&lt;/code&gt;。可以看到，生成的example.pb.cc决定了遇到哪个&lt;code&gt;tag&lt;/code&gt;调用哪个解析函数，从输入流中解析出值，赋给对应的成员变量，而真正进行解析的代码实际上是Protobuf的源码，如下所示：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// in wire_format_lit.cc
inline static bool ReadBytesToString(io::CodedInputStream* input,
                                     string* value) {
  uint32 length;
  return input-&amp;gt;ReadVarint32(&amp;amp;length) &amp;amp;&amp;amp;
      input-&amp;gt;InternalReadStringInline(value, length);
}

// in wire_format_lit.h
template &amp;lt;&amp;gt;
inline bool WireFormatLite::ReadPrimitive&amp;lt;int32, WireFormatLite::TYPE_INT32&amp;gt;(
    io::CodedInputStream* input,
    int32* value) {
  uint32 temp;
  if (!input-&amp;gt;ReadVarint32(&amp;amp;temp)) return false;
  *value = static_cast&amp;lt;int32&amp;gt;(temp);
  return true;
}

// in coded_stream.h
inline bool CodedInputStream::ReadVarint32(uint32* value) {
  uint32 v = 0;
  if (PROTOBUF_PREDICT_TRUE(buffer_ &amp;lt; buffer_end_)) {
    v = *buffer_;
    if (v &amp;lt; 0x80) {
      *value = v;
      Advance(1);
      return true;
    }
  }
  int64 result = ReadVarint32Fallback(v);
  *value = static_cast&amp;lt;uint32&amp;gt;(result);
  return result &amp;gt;= 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，如果遇到&lt;code&gt;int32&lt;/code&gt;的&lt;code&gt;tag&lt;/code&gt;，直接读取接下来的数据，如果遇到&lt;code&gt;string&lt;/code&gt;的&lt;code&gt;tag&lt;/code&gt;，会先读一个Varint32的&lt;code&gt;length&lt;/code&gt;，然后再读&lt;code&gt;length&lt;/code&gt;个字节的数据。&lt;/p&gt;
&lt;p&gt;这里频繁出现了varint，&lt;code&gt;length&lt;/code&gt;是varint，存储的&lt;code&gt;int32&lt;/code&gt;数据也是varint，那varint是什么？&lt;/p&gt;

&lt;p&gt;varint是一种&lt;strong&gt;可变长编码&lt;/strong&gt;，使用1个或多个字节对整数进行编码，可编码任意大的整数，&lt;strong&gt;小整数占用的字节少，大整数占用的字节多&lt;/strong&gt;，如果小整数更频繁出现，则通过varint可实现压缩存储。&lt;/p&gt;
&lt;p&gt;varint中每个字节的最高位bit称之为&lt;strong&gt;most significant bit (MSB)&lt;/strong&gt;，如果该bit为0意味着这个字节为表示当前整数的最后一个字节，如果为1则表示后面还有至少1个字节，可见，&lt;strong&gt;varint的终止位置其实是自解释的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Protobuf中，tag和length都是使用varint编码的&lt;/strong&gt;。&lt;code&gt;length&lt;/code&gt;和&lt;code&gt;tag&lt;/code&gt;中的field_number都是正整数&lt;code&gt;int32&lt;/code&gt;，这里提一下&lt;code&gt;tag&lt;/code&gt;，它的低3位bit为wire type，如果只用1个字节表示的话，最高位bit为0，则留给field_number只有4个bit位，1到15，如果field_number大于等于16，就需要用2个字节，所以对于频繁使用的field其field_number应设置为1到15。&lt;/p&gt;
&lt;p&gt;比如正整数150，其使用varint编码如下（小端存储）：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// proto file
message Test1 {
  optional int32 a = 1;
}

// c++ file
// set a = 150

// binary file, in hex
// 08 96 01&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;08&lt;/code&gt;为key， &lt;code&gt;96 01&lt;/code&gt;为150的varint编码，解释如下&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/04/15/AjtFPK.png&quot; alt=&quot;varint 150&quot;/&gt;&lt;br/&gt;有关varint的更多内容，可以参见&lt;a href=&quot;https://wiki2.org/en/Variable-length_quantity&quot;&gt;wiki Variable-length quantity&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;至此，key-value的编码方式我们已经解决了一半，还剩value部分没有解决，接下来看看Protobuf数据部分是如何编码的。&lt;/p&gt;

&lt;p&gt;Protobuf中整数也是通过varint进行编码，移除每个字节的MSB，然后拼接在一起，可以得到一个含有数个字节的buffer，这个buffer该怎么解释还需要&lt;strong&gt;参考具体的数据类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;int32&lt;/code&gt;或&lt;code&gt;int64&lt;/code&gt;，正数直接按varint编码，数据类型为&lt;code&gt;int32&lt;/code&gt;或&lt;code&gt;int64&lt;/code&gt;的负数统一被编码为10个字节长的varint（补码）。&lt;/p&gt;
&lt;p&gt;如果是&lt;code&gt;sint32&lt;/code&gt;或&lt;code&gt;sint64&lt;/code&gt;，则采用ZigZag方式进行编码，如下表所示：&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/04/15/AjaWon.png&quot; alt=&quot;Varint ZigZag encoding&quot;/&gt;&lt;br/&gt;&lt;code&gt;sint32 n&lt;/code&gt;被编码为 &lt;code&gt;(n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 31)&lt;/code&gt;对应的varint，&lt;code&gt;sint64 n&lt;/code&gt;被编码为 &lt;code&gt;(n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 63)&lt;/code&gt;对应的varint，这样，&lt;strong&gt;绝对值较小的整数只需要较少的字节就可以表示&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;至于浮点数，对应的wire type为1或5，直接按小端存储。&lt;/p&gt;

&lt;p&gt;主要有3类：string、嵌套message以及packed repeated fields。它们的编码方式统一为 &lt;code&gt;tag + length + 数据&lt;/code&gt;，只是数据部分有所差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string&lt;/strong&gt;的编码为 &lt;strong&gt;key + length + 字符&lt;/strong&gt;，参看开篇的图片已经很清晰了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;嵌套message&lt;/strong&gt;也很简单，直接将嵌套message部分的编码接在&lt;code&gt;length&lt;/code&gt;后即可，如下所示：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// proto file
message Test1 {
  optional int32 a = 1;
}
message Test3 {
  optional Test1 c = 3;
}

// cpp file
// set a = 150

// message Test3 binary file, in hex
// 1a 03 08 96 01&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;1a&lt;/code&gt;为&lt;code&gt;c&lt;/code&gt;的key，&lt;code&gt;03&lt;/code&gt;为&lt;code&gt;c&lt;/code&gt;的长度，接下来的&lt;code&gt;08 96 01&lt;/code&gt;为&lt;code&gt;a&lt;/code&gt;的key+value。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;packed repeated fields&lt;/strong&gt;，指的是proto2中声明了&lt;code&gt;[packed=true]&lt;/code&gt;的repeated varint、32bit or 64bit数据，proto3中repeated默认packed，如下所示&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// in proto2
message Test4 {
  repeated int32 d = 4 [packed=true];
}

// in proto3
message Test4 {
  repeated int32 d = 4;
}

// 3, 270, 86942压缩存储如下，in hex
22        // key (field number 4, wire type 2), 0x22 = 34 = (4 &amp;lt;&amp;lt; 3) + 2
06        // payload size (6 bytes), length
03        // first element (varint 3)
8E 02     // second element (varint 270)
9E A7 05  // third element (varint 86942)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6个字节根据varint的MSB可自动分割成3个数据。对这种packed repeated fields，在Protobuf中会以&lt;code&gt;RepeatedField&lt;/code&gt;对象承载，支持get-by-index、set-by-index和add（添加元素）操作。&lt;/p&gt;

&lt;p&gt;至此，二进制文件中key-value对的编码方式已基本介绍完毕，后面将通过一个相对复杂的例子，将这些琐碎的编码方式串起来，以加深理解。&lt;/p&gt;

</description>
<pubDate>Tue, 16 Apr 2019 07:35:00 +0000</pubDate>
<dc:creator>Mr-Lee</dc:creator>
<og:description>博客： 'blog.shinelee.me' | '博客园' | 'CSDN' [toc] Message Structure 在上一篇文章中我们提到，对于序列化后字节流，需要回答的一个重要问题是“</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shine-lee/p/10717521.html</dc:identifier>
</item>
<item>
<title>Golang websocket推送 - bener</title>
<link>http://www.cnblogs.com/bener/p/10717466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bener/p/10717466.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在工作用主要使用的是Java，也做过IM（后端用的netty websocket）。最近想通过Golang重写下，于是通过websocket撸了一个聊天室。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuanbo/pusher&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;依赖&quot;&gt;依赖&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;golang.org/x/net&lt;/code&gt;下的websocket。&lt;/p&gt;
&lt;p&gt;由于我使用的是golang版本是1.12，在国内访问&lt;code&gt;golang.org/x&lt;/code&gt;需要借助代理，或者通过replace替换为github下的镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module github.com/xuanbo/pusher

require golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3

replace (
        golang.org/x/crypto =&amp;gt; github.com/golang/crypto v0.0.0-20190308221718-c2843e01d9a2
        golang.org/x/net =&amp;gt; github.com/golang/net v0.0.0-20190404232315-eb5bcb51f2a3
        golang.org/x/sys =&amp;gt; github.com/golang/sys v0.0.0-20190215142949-d0b11bdaac8a
        golang.org/x/text =&amp;gt; github.com/golang/text v0.3.0
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即工程下的&lt;code&gt;go.mod.cn&lt;/code&gt;文件。&lt;/p&gt;
&lt;h2 id=&quot;websocket用法&quot;&gt;websocket用法&lt;/h2&gt;
&lt;p&gt;核心就是for循环下的处理收到的消息逻辑，然后对消息进行处理（转发、广播等）。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// websocket Handler
// usage: http.Handle(&quot;/websocket&quot;, websocket.Handler(pusher.Handler))
func Handler(conn *websocket.Conn) {
    // handle connected
    var userId string
    var err error
    if userId, err = doConnected(conn); err != nil {
        fmt.Println(&quot;Client connect error: &quot;, err)
        return
    }

    fmt.Println(&quot;Client connected, userId: &quot;, userId)

    for {
        msg := new(Message)

        if err := websocket.JSON.Receive(conn, msg); err != nil {
            fmt.Println(&quot;Can't receive, error: &quot;, err)
            break
        }

        msg.UpdateAt = Timestamp()

        fmt.Println(&quot;Received from client: &quot;, msg)

        // handle received message
        if err := doReceived(conn, msg); err != nil {
            fmt.Println(&quot;Received message error: &quot;, err)
            break
        }
    }

    // handle disConnected
    if err := doDisConnected(userId, conn); err != nil {
        fmt.Println(&quot;Client disconnected error: &quot;, err)
        return
    }

    fmt.Println(&quot;Client disconnected, userId: &quot;, userId)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;连接管理&quot;&gt;连接管理&lt;/h2&gt;
&lt;p&gt;在IM中比较重要的点就是管理客户端连接，这样我们才能通过服务端转发消息给对应的用户。注意，下面没有考虑集群，只在单机中考虑。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// websocket connection manager
type ConnManager struct {
    // websocket connection number
    Online *int32
    // websocket connection
    connections *sync.Map
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义了一个连接管理结构体，&lt;code&gt;Online&lt;/code&gt;为在线的人数，&lt;code&gt;connections&lt;/code&gt;为客户端的连接管理（key为userId，value为websocket connection）。&lt;/p&gt;
&lt;p&gt;下面为ConnManager添加一些方法来处理连接、断开连接、发送消息、广播等操作。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// add websocket connection
// online number + 1
func (m *ConnManager) Connected(k, v interface{}) {
    m.connections.Store(k, v)

    atomic.AddInt32(m.Online, 1)
}

// remove websocket connection by key
// online number - 1
func (m *ConnManager) DisConnected(k interface{}) {
    m.connections.Delete(k)

    atomic.AddInt32(m.Online, -1)
}

// get websocket connection by key
func (m *ConnManager) Get(k interface{}) (v interface{}, ok bool) {
    return m.connections.Load(k)
}

// iter websocket connections
func (m *ConnManager) Foreach(f func(k, v interface{})) {
    m.connections.Range(func(k, v interface{}) bool {
        f(k, v)
        return true
    })
}

// send message to one websocket connection
func (m *ConnManager) Send(k, msg *Message) {
    v, ok := m.Get(k)
    if ok {
        if conn, ok := v.(*websocket.Conn); ok {
            if err := websocket.JSON.Send(conn, msg); err != nil {
                fmt.Println(&quot;Send msg error: &quot;, err)
            }
        } else {
            fmt.Println(&quot;invalid type, expect *websocket.Conn&quot;)
        }
    } else {
        fmt.Println(&quot;connection not exist&quot;)
    }
}

// send message to multi websocket connections
func (m *ConnManager) SendMulti(keys []*Message, msg interface{}) {
    for _, k := range keys {
        v, ok := m.Get(k)
        if ok {
            if conn, ok := v.(*websocket.Conn); ok {
                if err := websocket.JSON.Send(conn, msg); err != nil {
                    fmt.Println(&quot;Send msg error: &quot;, err)
                }
            } else {
                fmt.Println(&quot;invalid type, expect *websocket.Conn&quot;)
            }
        } else {
            fmt.Println(&quot;connection not exist&quot;)
        }
    }
}

// broadcast message to all websocket connections otherwise own connection
func (m *ConnManager) Broadcast(conn *websocket.Conn, msg *Message) {
    m.Foreach(func(k, v interface{}) {
        if c, ok := v.(*websocket.Conn); ok &amp;amp;&amp;amp; c != conn {
            if err := websocket.JSON.Send(c, msg); err != nil {
                fmt.Println(&quot;Send msg error: &quot;, err)
            }
        }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;消息类型格式&quot;&gt;消息类型、格式&lt;/h2&gt;
&lt;p&gt;消息类型（MessageType）主要有单聊、群聊、系统通知等。&lt;/p&gt;
&lt;p&gt;消息格式（MediaType）主要有文本格式、图片、文件等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type MessageType int
type MediaType int

const (
    Single MessageType = iota
    Group
    SysNotify
    OnlineNotify
    OfflineNotify
)

const (
    Text MediaType = iota
    Image
    File
)

// websocket message
type Message struct {
    MessageType MessageType `json:&quot;messageType&quot;`
    MediaType   MediaType   `json:&quot;mediaType&quot;`
    From        string      `json:&quot;from&quot;`
    To          string      `json:&quot;to&quot;`
    Content     string      `json:&quot;content,omitempty&quot;`
    FileId      string      `json:&quot;fileId,omitempty&quot;`
    Url         string      `json:&quot;url,omitempty&quot;`
    CreateAt    int64       `json:&quot;createAt,omitempty&quot;`
    UpdateAt    int64       `json:&quot;updateAt,omitempty&quot;`
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义了一个统一的消息（Message）。&lt;/p&gt;
&lt;h2 id=&quot;效果&quot;&gt;效果&lt;/h2&gt;
&lt;p&gt;前端的代码就不展示了，最终实现的聊天室效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/xuanbo/pusher/raw/master/doc/ui.png&quot; alt=&quot;UI&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;补充&quot;&gt;补充&lt;/h2&gt;
&lt;p&gt;本例子没有涉及到用户认证、消息加密、idle、单聊、消息格式、消息持久化等等，只做了一个简单的群聊。&lt;/p&gt;
&lt;p&gt;欢迎感兴趣的道友，基于此扩展出自己的推送系统、IM等。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;Just for fun！&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 07:29:00 +0000</pubDate>
<dc:creator>bener</dc:creator>
<og:description>Golang websocket推送 在工作用主要使用的是Java，也做过IM（后端用的netty websocket）。最近想通过Golang重写下，于是通过websocket撸了一个聊天室。 项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bener/p/10717466.html</dc:identifier>
</item>
<item>
<title>C# 设置Excel数据自适应行高、列宽的2种情况 - E-iceblue</title>
<link>http://www.cnblogs.com/Yesi/p/10716963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yesi/p/10716963.html</guid>
<description>&lt;p&gt;Excel表格中，由于各种数据的复杂性，可能存在单元格中的数据字号大小、数据内容长度不一而出现，列宽过宽、过窄或者行高过大、过小的问题。常见的解决方法是调整行高、列宽。在Microsoft Excel中，在单元格格式设置中可手动设置自适应行高或自适应列宽，但通过代码，我们可以通过方法AutoFitColumns()或者AutoFitRows()来设置指定数据范围或整个工作表的自适应行高、列宽。这里设置自适应分以下2种情况来进行：&lt;/p&gt;
&lt;p&gt;1. 固定数据，设置行高、列宽自适应数据&lt;/p&gt;
&lt;p&gt;2. 固定行高、列宽，设置数据自适应行高、列宽（即缩小单元格数据字体大小适应单元格）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用工具&lt;/strong&gt;：&lt;a href=&quot;https://www.e-iceblue.cn/Introduce/Free-Spire-XLS-NET.html&quot;&gt;Free Spire.XLS for .NET（免费版）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/strong&gt;注意在下载安装后，添加引用Spire.Xls.dll文件，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190416142222606-843519081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;【示例1】固定数据，设置行高、列宽自适应数据&lt;/h2&gt;
&lt;p&gt; Step 1: 加载工作簿&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Workbook类的对象，并加载测试文档&lt;/span&gt;
Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 2: 获取指定工作表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Worksheet worksheet = workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 3:设置自适应&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置列宽、行高为自适应（应用于指定数据范围）&lt;/span&gt;
worksheet.AllocatedRange[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:F15&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].AutoFitColumns();
worksheet.AllocatedRange[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:F15&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].AutoFitRows();

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/设置列宽、行高为自适应（应用于整个工作表）&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;worksheet.AllocatedRange.AutoFitColumns();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;worksheet.AllocatedRange.AutoFitRows();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 4:保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, FileFormat.Version2010);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190416142211212-555114811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;全部代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4f8af432-0b88-423a-bc57-9ab8f9cc0237')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_4f8af432-0b88-423a-bc57-9ab8f9cc0237&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4f8af432-0b88-423a-bc57-9ab8f9cc0237&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4f8af432-0b88-423a-bc57-9ab8f9cc0237',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4f8af432-0b88-423a-bc57-9ab8f9cc0237&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AutoFit_XLS
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Workbook类的对象，并加载测试文档&lt;/span&gt;
            Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
            workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取工作表&lt;/span&gt;
            Worksheet worksheet = workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置列宽、行高为自适应（应用于指定数据范围）&lt;/span&gt;
            worksheet.AllocatedRange[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:F15&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].AutoFitColumns();
            worksheet.AllocatedRange[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:F15&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].AutoFitRows();

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/设置列宽、行高为自适应（应用于整个工作表）&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;worksheet.AllocatedRange.AutoFitColumns();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;worksheet.AllocatedRange.AutoFitRows();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档&lt;/span&gt;
            workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Version2010);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;【示例2】固定行高、列宽，设置数据自适应行高、列宽&lt;/h2&gt;
&lt;p&gt;Step 1:加载工作簿&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化Workbook类的对象，并加载测试文档&lt;/span&gt;
Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 2:获取指定工作表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Worksheet sheet = workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 3: 获取指定数据范围&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CellRange cell = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:C1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 4: 缩小单元格字体以适应列宽&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CellStyle style =&lt;span&gt; cell.Style;
style.ShrinkToFit &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 5: 保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ExcelVersion.Version2013);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;设置结果：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190416142930941-1070465655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;全部代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1ef443e4-94d7-4332-a43e-3869a8445d4f')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_1ef443e4-94d7-4332-a43e-3869a8445d4f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1ef443e4-94d7-4332-a43e-3869a8445d4f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1ef443e4-94d7-4332-a43e-3869a8445d4f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1ef443e4-94d7-4332-a43e-3869a8445d4f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ShrinkTextToFitCell_XLS
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化Workbook类的对象，并加载测试文档&lt;/span&gt;
            Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
            workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个工作表&lt;/span&gt;
            Worksheet sheet = workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定数据范围&lt;/span&gt;
            CellRange cell = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:C1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置单元格样式（数据缩小以适应单元格）&lt;/span&gt;
            CellStyle style =&lt;span&gt; cell.Style;
            style.ShrinkToFit &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档&lt;/span&gt;
            workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ExcelVersion.Version2013);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;（本文完）&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 06:39:00 +0000</pubDate>
<dc:creator>E-iceblue</dc:creator>
<og:description>Excel表格中，由于各种数据的复杂性，可能存在单元格中的数据字号大小、数据内容长度不一而出现，列宽过宽、过窄或者行高过大、过小的问题。常见的解决方法是调整行高、列宽。在Microsoft Excel</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yesi/p/10716963.html</dc:identifier>
</item>
<item>
<title>缓存的应用场景以及要注意的问题 - 保军Baojun</title>
<link>http://www.cnblogs.com/wangbaojun/p/10716607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangbaojun/p/10716607.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是缓存(cache)：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;在项目中没有必要每次请求都查询数据库的情况就可以使用缓存，让每次请求先查询缓存，如果命中，就直接返回缓存结果，如果没有命中，就查询数据库， 并将查询结果放入缓存，下次请求时查询缓存命中，直接返回结果，就不用再次查询数据库。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;缓存的作用？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;缓和较慢存储的高频请求&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;/span&gt;缓解数据库压力，提升响应速率。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么缓存可以提高响应速度？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　因为缓存时基于内存的存储的，内存的读写速率时普通SSD硬盘的至少十倍，更何况机械硬盘了：看对比图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317274/201904/1317274-20190416123832214-798329379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;缓存介质？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;web项目中常用的缓存是&lt;strong&gt;memcached和redis&lt;/strong&gt;，它们都支持分布式存储&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存一定能给项目响应速率带来较大提升吗?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　答案是不见得，要根据项目实际情况分析，有没有使用缓存的不要。在考虑使用缓存前，不妨先问问自己：&lt;/p&gt;
&lt;p&gt;　　1.　项目的读写操作比例为多少，如果是写多读少，那缓存真的比一定能帮助你，此时不妨考虑数据库分库分表，然后做MySQL的分布式集群，或者简单直接，将硬盘全部替换为SSD(如果你的公司财大气粗)，反之，以读为主的项目就比较适合加缓存了&lt;/p&gt;
&lt;p&gt;　　2. 项目的访问频率高不高（用户多不多）？如果用户区区几千人或几万人，全然没有必要使用缓存，这点访问量经过网络后几乎不会造成并发，即使偶出现几万的并发，MySQL也是扛得住的，强行使用缓存反而会增加代码复杂度，甚至不容易维护，得不偿失。&lt;/p&gt;
&lt;p&gt;　　3. 数据是否要求强一致性？如果项目涉及到金钱或者重要数据，且数据频繁发生变化，不允许存在一点差异，那是否使用缓存就要&lt;strong&gt;慎重慎重再慎重！因为缓存适用的是对数据一致性不是特别高的项目，如果使用，需要对缓存的设计有很好的方案，非常考验技术功底&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说了这么多，进入正题吧，我们通过代码来模拟一下缓存的使用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　redis版本：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: UTF-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;使用redis做缓存，这里模拟一个web接口缓存的例子
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里使用redis连接池，管理redisservice的所有连接，避免每次创建关闭连接的开销&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; pool = redis.ConnectionPool(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=6379&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; redis_cli = redis.Redis(connection_pool=&lt;span&gt;pool)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; redis_cache(func):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     @functools.wraps(func)        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为了保留原函数的属性，因为被装饰的函数对外暴露的是装饰器的属性&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; wrapper(*args,**&lt;span&gt;kargs):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         _key = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;function-name:{},args:{},kargs:{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(func.&lt;span&gt;__name__&lt;/span&gt;,args,kargs)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义key的形式&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         result =&lt;span&gt; redis_cli.get(_key)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; result:      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis查找到对应的key，直接返回结果&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             result =&lt;span&gt; json.loads(result)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(result))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis find:{},result:{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(_key,result))
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;:            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis没有查找到对应key，查询执行函数，查询mysql&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis not find:{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(_key))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             result = func(*args,**&lt;span&gt;kargs)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             redis_cli.setex(_key,json.dumps(result),5)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将mysql结果写入redis,并设置过期时间 单位s&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;final result:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(result))
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         end_time = time.time()-&lt;span&gt;start_time
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Total time of this query:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(end_time))
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;@redis_cache
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; mysql_dispose(name,age):
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     result = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:name,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:age}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql-result:{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(result))
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     mysql_dispose(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zz3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,45&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; out-put&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;第一次执行：
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 　　　　redis &lt;span&gt;not&lt;/span&gt; find:function-name:mysql_dispose,args:(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zz3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 45&lt;span&gt;),kargs:{}
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 　　　　mysql-result:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zz3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 45&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 　　　　final result:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zz3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 45&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;      Total time of this query:2.0049448013305664
&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;第二次执行（距第一次5秒内执行）：
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 　　　　&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;span&gt;57&lt;/span&gt; 　　　　redis find:function-name:mysql_dispose,args:(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zz3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 45),kargs:{},result:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zz3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 45&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 　　　　Total time of this query:0.005013942718505859
&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;  第三次执行（5秒后）：　
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 　　　　redis &lt;span&gt;not&lt;/span&gt; find:function-name:mysql_dispose,args:(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zz3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 45&lt;span&gt;),kargs:{}
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 　　　　mysql-result:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zz3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 45&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 　　　　final result:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zz3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 45&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;      Total time of this query:2.0038458017378002
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    不难看出，原本需要2秒才能完成的数据库查询动作，再有了redis缓存后可以直接返回结果，提高了响应速率&lt;/p&gt;

</description>
<pubDate>Tue, 16 Apr 2019 05:56:00 +0000</pubDate>
<dc:creator>保军Baojun</dc:creator>
<og:description>什么是缓存(cache)： 在项目中没有必要每次请求都查询数据库的情况就可以使用缓存，让每次请求先查询缓存，如果命中，就直接返回缓存结果，如果没有命中，就查询数据库， 并将查询结果放入缓存，下次请求时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangbaojun/p/10716607.html</dc:identifier>
</item>
<item>
<title>python接口自动化（十六）--参数关联接口后传（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10715555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10715555.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　大家对前边的自动化新建任务之后，接着对这个新建任务操作了解之后，希望带小伙伴进一步巩固胜利的果实，夯实基础。因此再在沙场实例演练一下博客园的相关接口。我们用自动化发随笔之后，要想接着对这篇随笔操作，不用说就需&lt;/p&gt;
&lt;p&gt;要用参数关联了，发随笔之后会有一个随笔的 id，获取到这个 id，继续操作传这个随笔 id 就可以了（博客园的登录机制已经变了，不能用账号和密码登录了，这里用 cookie 登录）&lt;/p&gt;
&lt;p&gt;大致流程步骤：web界面操作登录抓包查看cookie—&amp;gt;代码模拟cookie登录—&amp;gt;web界面操作新建随笔和保存随笔—&amp;gt;抓包查看新建随笔和保存随笔的url和参数等—&amp;gt;代码模拟新建随笔并保存编辑内容—&amp;gt;web界面操作删除随笔—&amp;gt;抓取删除操作请求—&amp;gt;提取参数—&amp;gt;传参—&amp;gt;代码实现。&lt;/p&gt;
&lt;h2&gt;一、删除随笔&lt;/h2&gt;
&lt;p&gt;1、我们前面讲过登录后新建随笔和保存随笔后，不记得可以点击&lt;a href=&quot;https://www.cnblogs.com/du-hong/p/10636893.html&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;那可以继续接着操作：删除刚才新建的随笔&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190416112854202-1863970122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、用fiddler抓包，抓到删除新建随笔的请求，从抓包结果可以看出，传的json参数是postId&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190416114809493-773371217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.这个postId哪里来的呢？可以看上个请求的url地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190416114627706-1999908725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、也就是说保存草稿箱成功之后，重定向一个 url 地址，里面带有 postId 这个参数。那我们想办法将这个参数提取出来就可以了&lt;/p&gt;
&lt;h2&gt;二、提取参数&lt;/h2&gt;
&lt;p&gt;1、我们需要的参数 postId 是在保存成功后 url 地址，这时候从 url 地址提出对应的参数值就行了，先获取保存成功后 url&lt;/p&gt;
&lt;p&gt;2、通过正则表达式从保存的url提取需要的字符串，这个参数值前面（postid=）和后面（&amp;amp;）字符串都是固定的&lt;/p&gt;
&lt;p&gt;3、这里正则提出来的是 list 类型，取第一个值就可以是字符串了（注意：每次保存需要修改内容，不能重复）&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190416132226901-2016326895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、传参&lt;/h2&gt;
&lt;p&gt;1、删除草稿箱的 json 参数传上面取到的参数：{&quot;postId&quot;: postid[0]}&lt;/p&gt;
&lt;p&gt;2、json 数据类型 post 里面填 json 就行，会自动转 json&lt;/p&gt;
&lt;p&gt;3、接着前面的保存随笔的操作，就可以删除成功了&lt;/p&gt;
&lt;p&gt;注意：同理和jenkins一样，如果想看清楚，可以在删除新建随笔出打断点，看到新建的随笔后，再次执行下边的代码 看看是不是可以删掉新建随笔&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190416132335249-1213273111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、参考代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding:utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import requests
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;# 先打开登录首页，获取部分cookie
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://passport.cnblogs.com/user/signin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;            }  # get方法其它加个ser-&lt;span&gt;Agent就可以了
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; s =&lt;span&gt; requests.session()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; r = s.&lt;span&gt;get&lt;/span&gt;(url, headers=headers,verify=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print (s.cookies)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;# 添加登录需要的两个cookie
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; c =&lt;span&gt; requests.cookies.RequestsCookieJar()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; c.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.CNBlogsCookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  # 填上面抓包内容
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; c.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.Cnblogs.AspNetCore.Cookies&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  # 填上面抓包内容
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; c.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;AlwaysCreateItemsAsActive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; c.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;AdminCookieAlwaysExpandAdvanced&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;s.cookies.update(c)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;print (s.cookies)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;# 登录成功后保存编辑内容
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; url2= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://i.cnblogs.com/EditPosts.aspx?opt=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; body = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__VIEWSTATE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__VIEWSTATEGENERATOR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FE27D343&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Editor$Edit$txbTitle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是绕过登录的标题：北京-宏哥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Editor$Edit$EditorBody&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;这里是中文内容：http://www.cnblogs.com/duhong/&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Editor$Edit$Advanced$ckbPublished&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Editor$Edit$Advanced$chkDisplayHomePage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Editor$Edit$Advanced$chkComments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Editor$Edit$Advanced$chkMainSyndication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Editor$Edit$lkbDraft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;存为草稿&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; r2 = s.post(url2, data=body, verify=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; #print (r.content.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;# 第三步：正则提取需要的参数值
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;import re
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; postid = re.findall(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;postid=(.+?)&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, r2.url)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;print(type(postid))
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;print (postid) # 这里是 list
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;# 提取为字符串
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; print (postid[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;# 第四步：删除草稿箱
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; url3 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://i.cnblogs.com/post/delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; json3 = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;postId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: postid[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; r3 = s.post(url3, json=json3, verify=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; print (r3.json())
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、小结&lt;/h2&gt;
&lt;p&gt;1、好了，参数关联接口就是这么简单，相信各位小伙伴下回遇到此种类似的问题，不会慌了，应该是十拿九稳的把它KO掉。&lt;/p&gt;
&lt;p&gt;2、有兴趣的自己可以向上一篇一样，自己练习一下打断点，自己可以体验一下其中的乐趣和神奇。&lt;/p&gt;
&lt;p&gt;最后欢迎各位小伙伴探讨和留言！！！&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 05:36:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 大家对前边的自动化新建任务之后，接着对这个新建任务操作了解之后，希望带小伙伴进一步巩固胜利的果实，夯实基础。因此再在沙场实例演练一下博客园的相关接口。我们用自动化发随笔之后，要想接着对这篇随笔操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10715555.html</dc:identifier>
</item>
<item>
<title>大数据技术 - MapReduce的Shuffle及调优 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/10704544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/10704544.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章内容我们学习一下 MapReduce 中的 Shuffle 过程，Shuffle 发生在 map 输出到 reduce 输入的过程，它的中文解释是 “洗牌”，顾名思义该过程涉及数据的重新分配，主要分为两部分：&lt;em&gt;1.&lt;/em&gt; map 任务输出的数据分组、排序，写入本地磁盘 &lt;em&gt;2.&lt;/em&gt; reduce 任务拉取排序。由于该过程涉及排序、磁盘IO、以及网络IO 等消耗资源和 CPU 比较大的操作，因此该过程向来是“兵家必争”之地，即大家会重点优化的一个地方，因此也是大数据面试中经常会被重点考察的地方。本文力求通俗、简单地将 Shuffle 过程描述清楚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;包含 Shuffle 过程的 MapReduce 任务处理流程如下图，图片来自《Hadoop权威指南（第四版）》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201904/1129006-20190414134222300-2125548172.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，分别介绍 Shuffle 所涉及的主要操作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;map 端输出时，先将数据写入内存中的&lt;strong&gt;环形缓冲区&lt;/strong&gt;，默认大小为 100M，可以通过 mapreduce.task.io.sort.mb 来设置。map 端输出过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当缓冲区的内容大小达到阈值（默认 0.8，即缓冲区大小的 80%，可通过 mapreduce.map.sort.spill.percent 设置），便有一个后台线程会将写入缓冲区的内容&lt;strong&gt;溢写&lt;/strong&gt;到磁盘。溢写的过程中 map 任务仍然可以写缓冲区，一旦缓冲区写满，map 任务阻塞，直到后台线程写磁盘结束&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;后台线程写磁盘之前会计算输出的 key 的分区（一个分区对应一个 reduce 任务），同一个分区的 key 分在一组并按照 key 排序。最后写到本地磁盘。如果设置 combiner 函数，会在写磁盘之前调用 combaner 函数。我们之前没有介绍 combiner，不理解的同学可以先忽略，只需知道它是先将数据聚合为了减少网络IO，且不会影响 reduce 计算结果的一个操作即可&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每一次溢写都会产生一个&lt;strong&gt;溢出文件&lt;/strong&gt;，map 输出结束后会产生多个溢出文件。最终会被合并成&lt;strong&gt;一个&lt;/strong&gt;分区的且有序的文件。这里为什么要合并成 1 个，因为如果 map 输出的数据比较多，产生本地的小文件会太多，影响系统性能。因此需要进行合并，通过 mapreduce.task.io.sort.factor 设置一次可以合并的文件个数，默认为 10 &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;输出到磁盘的过程中可以设置压缩， 默认不压缩。通过设置 mapreduce.map.output.compress 为 true 开启压缩&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;以上便是 map 任务输出过程的主要操作，输出到磁盘后，reducer 会通过 http 服务拉取输出文件中属于自己分区的数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;reduce 端在 Shuffle 阶段主要涉及&lt;strong&gt;复制&lt;/strong&gt;和&lt;strong&gt;排序&lt;/strong&gt;两个过程。 reduce 端拉取 map 输出数据的过程是&lt;strong&gt;复制阶段&lt;/strong&gt;，对应上图中的 fetch。一个 reduce 任务需要从多个 map 输出复制。因此只要有 map 任务完成，reduce 任务就可以进行复制。复制的过程可以是多线程并发进行，并发的线程个数由 mapreduce.reduce.shuffle.parallelcopies 设置，默认是 5 。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;map 任务完成后通过心跳通知 application master，reduce 端会有一个线程定期查询 application master，以获取完成的 map 任务的位置，从而去对应的机器复制数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;reduce 复制的数据先写到 reduce 任务的 JVM 内存，通过 mapreduce.reduce.shuffle.input.buffer.percent 控制可以用的内存比例&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果复制的数据大小达到内存阈值（通过 mapreduce.reduce.shuffle.merge.percent 控制）或者复制的文件数达到阈值（通过 mapreduce.reduce.merge.inmem.threshold 控制，默认 1000）则将内存的数据合并溢写到磁盘，如果设置了 combine 函数，写磁盘前会调用 combine 函数以减少写入磁盘的数据量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;复制阶段结束后，reduce 将进入排序阶段。如果发生了上面第三步，即产生溢写，那么磁盘可能会有多个溢写文件，此时需要将磁盘文件合并并&lt;strong&gt;排序&lt;/strong&gt;。如果溢写的文件较多，需要多次合并，每次合并的文件数由 mapreduce.task.io.sort.factor 控制。最后一次合并排序的时候不会将数据写到磁盘而直接作为 reduce 任务的输入&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;以上便是 reduce 任务前的&lt;strong&gt;复制、排序&lt;/strong&gt;阶段。至此，整个 Shuffle 过程就介绍完毕。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们在上面介绍 Shuffle 过程时已经提到了一些参数，这里统一整理并说明一下&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;map 端调优参数&lt;/span&gt;&lt;/h2&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td&gt;参数名&lt;/td&gt;
&lt;td&gt;默认值&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;mapreduce.task.io.sort.mb&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;map 输出是所使用的内存缓冲区大小，单位：MB&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;mapreduce.map.sort.spill.percent&lt;/td&gt;
&lt;td&gt;0.80&lt;/td&gt;
&lt;td&gt;map 输出溢写到磁盘的内存阈值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;mapreduce.task.io.sort.factor&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;排序文件是一次可以合并的流数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mapreduce.map.output.compress&lt;/td&gt;
&lt;td&gt;false　&lt;/td&gt;
&lt;td&gt;map 输出是否压缩&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;mapreduce.map.output.compress.codec&lt;/td&gt;
&lt;td&gt;org.apache.hadoop.io.compress.DefaultCodec&lt;/td&gt;
&lt;td&gt;map 输出压缩的编解码器&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;我们希望在 map 输出阶段能够提供更多的内存空间，以提升性能。因此 map 函数应该尽量少占用内存，以便留出内存用于输出。我们也可以评估 map 输出，通过增大 mapreduce.task.io.sort.mb 值来减少溢写的文件数。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;reduce 端调优参数&lt;/h2&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr&gt;&lt;td&gt;参数名&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;默认值&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mapreduce.reduce.shuffle.parallelcopies&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;并发复制的线程数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mapreduce.task.io.sort.factor&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;同 map 端&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;mapreduce.reduce.shuffle.input.buffer.percent&lt;/td&gt;
&lt;td&gt;0.70&lt;/td&gt;
&lt;td&gt;Shuffle 的复制阶段，用来存放 map 输出缓冲区占reduce 堆内存的百分比&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;mapreduce.reduce.shuffle.merge.percent&lt;/td&gt;
&lt;td&gt;0.66&lt;/td&gt;
&lt;td&gt;map 输出缓冲区的阈值，超过该比例将进行合并和溢写磁盘&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;mapreduce.reduce.merge.inmem.threshold&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;阈值，当累积的 map 输出文件数超过该值，进行合并和溢写磁盘，0或者负值意味着改参数无效，合并和溢写只由 mapreduce.reduce.shuffle.merge.percent 控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;mapreduce.reduce.input.buffer.percent&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;在 reduce 过程（开始运行 reduce 函数时），内存中保存 map 输出的空间站整个堆空间的比例。&lt;/p&gt;
&lt;p&gt;默认情况下，reduce 任务开始前所有的 map 输出合并到磁盘，以便为 reducer 提供尽可能多的内存。&lt;/p&gt;
&lt;p&gt;如果 reducer 需要的内存较少，可以增加此值以最小化磁盘访问次数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;在 reduce 端，进行 reduce 函数前，如果中间数据全部驻留内存可以获得最佳性能，默认情况是不能实现的。如果 reduce 函数内存需求不大，把 mapreduce.reduce.input.buffer.percent 参数设置大一些可以提升性能。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;今天这章，我们详细介绍了 Shuffle 过程，关注 Shuffle 过程的性能对整个 MR 作业的性能调优至关重要。经过这章的介绍，我们能够掌握 Shuffle 过程的关键技术点，虽然还不算深入。同时，我们介绍了常见的参数以及调优方法，希望能够在实际应用中不断的尝试、总结，写出性能最佳的任务。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 05:33:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>本章内容我们学习一下 MapReduce 中的 Shuffle 过程，Shuffle 发生在 map 输出到 reduce 输入的过程，它的中文解释是 “洗牌”，顾名思义该过程涉及数据的重新分配，主要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duma/p/10704544.html</dc:identifier>
</item>
<item>
<title>微信公众号开发C#系列-8、自定义菜单及菜单响应事件的处理 - yonghu86</title>
<link>http://www.cnblogs.com/huyong/p/10700758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huyong/p/10700758.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;1、概述&lt;/h2&gt;
&lt;p&gt;自定义菜单能够帮助公众号丰富界面，让用户更好更快地理解公众号的功能。菜单分为默认菜单与个性化菜单。个性化菜单接口是为了帮助公众号实现灵活的业务运营，开发者可以通过该接口，让公众号的不同用户群体看到不一样的自定义菜单。该接口开放给已认证订阅号和已认证服务号。本文主要介绍微信自定义菜单的创建、查询、删除、各菜单类型事件的响应方法，以及菜单应用的界面整合参考。由于篇幅有限不可能面面俱到，只能抛砖迎玉，大家就可以据此扩展做深入的应用。&lt;/p&gt;
&lt;h2 id=&quot;自定义菜单的规则&quot;&gt;2、自定义菜单的规则&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;自定义菜单分为一级菜单和二级菜单。&lt;/li&gt;
&lt;li&gt;一级菜单数量为1-3个，即打开公众账号直接可以看到排列在最下方的最多3个按钮。一级菜单的文字最多不能4个汉字，多出来的部分将会以“...”代替。&lt;/li&gt;
&lt;li&gt;二级菜单从属于一级菜单，数量为1-5个。二级菜单的文字不最多不能超过8个汉字，多出来的部分将会以“...”代替。&lt;/li&gt;
&lt;li&gt;无论一级菜单还是二级菜单，都有两个触发事件可以选择，分别是：点击（click，值不能超过128字节）和打开网址（view，url不能超过256个字节）。&lt;/li&gt;
&lt;li&gt;当一个一级菜单下有二级菜单存在的时候，这个一级菜单按钮被点击不会有任何事件发生。&lt;/li&gt;
&lt;li&gt;创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;自定义菜单接口可实现按钮类型的种类&quot;&gt;3、自定义菜单接口可实现按钮类型的种类&lt;/h2&gt;
&lt;p&gt;自定义菜单接口可实现多种类型按钮，如下：&lt;/p&gt;
&lt;p&gt;1、click：点击推事件用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；&lt;/p&gt;
&lt;p&gt;2、view：跳转URL用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。&lt;/p&gt;
&lt;p&gt;3、scancode_push：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。&lt;/p&gt;
&lt;p&gt;4、scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。&lt;/p&gt;
&lt;p&gt;5、pic_sysphoto：弹出系统拍照发图用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。&lt;/p&gt;
&lt;p&gt;6、pic_photo_or_album：弹出拍照或者相册发图用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。&lt;/p&gt;
&lt;p&gt;7、pic_weixin：弹出微信相册发图器用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。&lt;/p&gt;
&lt;p&gt;8、location_select：弹出地理位置选择器用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。&lt;/p&gt;
&lt;p&gt;9、media_id：下发消息（除文本消息）用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。&lt;/p&gt;
&lt;p&gt;10、view_limited：跳转图文消息URL用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意，3到8的所有事件，仅支持微信iPhone5.4.1以上版本，和Android5.4以上版本的微信用户，旧版本微信用户点击后将没有回应，开发者也不能正常接收到事件推送。9和10，是专门给第三方平台旗下未微信认证（具体而言，是资质认证未通过）的订阅号准备的事件类型，它们是没有事件推送的，能力相对受限，其他类型的公众号不必使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建菜单&quot;&gt;4、创建菜单&lt;/h2&gt;
&lt;h3 id=&quot;创建菜单的接口&quot;&gt;4.1、创建菜单的接口&lt;/h3&gt;
&lt;p&gt;微信提供了接口API可以创建自定义菜单，接口相关说明如下。&lt;/p&gt;
&lt;p&gt;http请求方式：POST（请使用https协议）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;click和view的请求示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
     &quot;button&quot;:[
     {    
          &quot;type&quot;:&quot;click&quot;,
          &quot;name&quot;:&quot;今日歌曲&quot;,
          &quot;key&quot;:&quot;V1001_TODAY_MUSIC&quot;
      },
      {
           &quot;name&quot;:&quot;菜单&quot;,
           &quot;sub_button&quot;:[
           {    
               &quot;type&quot;:&quot;view&quot;,
               &quot;name&quot;:&quot;搜索&quot;,
               &quot;url&quot;:&quot;http://www.soso.com/&quot;
            },
            {
                 &quot;type&quot;:&quot;miniprogram&quot;,
                 &quot;name&quot;:&quot;wxa&quot;,
                 &quot;url&quot;:&quot;http://mp.weixin.qq.com&quot;,
                 &quot;appid&quot;:&quot;wx286b93c14bbf93aa&quot;,
                 &quot;pagepath&quot;:&quot;pages/lunar/index&quot;
             },
            {
               &quot;type&quot;:&quot;click&quot;,
               &quot;name&quot;:&quot;赞一下我们&quot;,
               &quot;key&quot;:&quot;V1001_GOOD&quot;
            }]
       }]
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他新增按钮类型的请求示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;button&quot;: [
        {
            &quot;name&quot;: &quot;扫码&quot;, 
            &quot;sub_button&quot;: [
                {
                    &quot;type&quot;: &quot;scancode_waitmsg&quot;, 
                    &quot;name&quot;: &quot;扫码带提示&quot;, 
                    &quot;key&quot;: &quot;rselfmenu_0_0&quot;, 
                    &quot;sub_button&quot;: [ ]
                }, 
                {
                    &quot;type&quot;: &quot;scancode_push&quot;, 
                    &quot;name&quot;: &quot;扫码推事件&quot;, 
                    &quot;key&quot;: &quot;rselfmenu_0_1&quot;, 
                    &quot;sub_button&quot;: [ ]
                }
            ]
        }, 
        {
            &quot;name&quot;: &quot;发图&quot;, 
            &quot;sub_button&quot;: [
                {
                    &quot;type&quot;: &quot;pic_sysphoto&quot;, 
                    &quot;name&quot;: &quot;系统拍照发图&quot;, 
                    &quot;key&quot;: &quot;rselfmenu_1_0&quot;, 
                   &quot;sub_button&quot;: [ ]
                 }, 
                {
                    &quot;type&quot;: &quot;pic_photo_or_album&quot;, 
                    &quot;name&quot;: &quot;拍照或者相册发图&quot;, 
                    &quot;key&quot;: &quot;rselfmenu_1_1&quot;, 
                    &quot;sub_button&quot;: [ ]
                }, 
                {
                    &quot;type&quot;: &quot;pic_weixin&quot;, 
                    &quot;name&quot;: &quot;微信相册发图&quot;, 
                    &quot;key&quot;: &quot;rselfmenu_1_2&quot;, 
                    &quot;sub_button&quot;: [ ]
                }
            ]
        }, 
        {
            &quot;name&quot;: &quot;发送位置&quot;, 
            &quot;type&quot;: &quot;location_select&quot;, 
            &quot;key&quot;: &quot;rselfmenu_2_0&quot;
        },
        {
           &quot;type&quot;: &quot;media_id&quot;, 
           &quot;name&quot;: &quot;图片&quot;, 
           &quot;media_id&quot;: &quot;MEDIA_ID1&quot;
        }, 
        {
           &quot;type&quot;: &quot;view_limited&quot;, 
           &quot;name&quot;: &quot;图文消息&quot;, 
           &quot;media_id&quot;: &quot;MEDIA_ID2&quot;
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;参数           是否必须                   说明
button         是                        一级菜单数组，个数应为1~3个
sub_button  否                       二级菜单数组，个数应为1~5个
type            是                       菜单的响应动作类型，view表示网页类型，click表示点击类型，miniprogram表示小程序类型
name        是       菜单标题，       不超过16个字节，子菜单不超过60个字节
key         click等点击类型必须        菜单KEY值，用于消息接口推送，不超过128字节
url         view、miniprogram类型必须    网页 链接，用户点击菜单可打开链接，不超过1024字节。 type为miniprogram时，不支持小程序的老版本客户端将打开本url。
media_id    media_id类型和view_limited类型必须 调用新增永久素材接口返回的合法media_id
appid       miniprogram类型必须     小程序的appid（仅认证公众号可配置）
pagepath    miniprogram类型必须     小程序的页面路径&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用senparc.weixin.mp-sdk创建自定义菜单&quot;&gt;4.2、使用Senparc.Weixin.MP SDK创建自定义菜单&lt;/h3&gt;
&lt;p&gt;使用微信提供的接口创建菜单编码量还是非常大，在此我们借助Senparc.Weixin.MP SDK来快速的创建自定义菜单。非常简单，只需三步：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：获取AccessToken&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var accessToken = AccessTokenContainer.TryGetToken(appId, appSecret).access_token;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：如果第三步中使用AppId取代AccessToken，则这一步可以省略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：组织菜单内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ButtonGroup bg = new ButtonGroup();
        
//菜单1
var subButton = new SubButton()
{
    name = &quot;菜单1&quot;
};

bg.button.Add(subButton);
subButton.sub_button.Add(new SingleClickButton()
{
    key = &quot;SubClickRoot_Text&quot;,
    name = &quot;返回文本&quot;
});
subButton.sub_button.Add(new SingleClickButton()
{
    key = &quot;SubClickRoot_News&quot;,
    name = &quot;返回图文&quot;
});
subButton.sub_button.Add(new SingleClickButton()
{
    key = &quot;SubClickRoot_Music&quot;,
    name = &quot;返回音乐&quot;
});
subButton.sub_button.Add(new SingleViewButton()
{
    url = &quot;http://www.rdiframework.net/&quot;,
    name = &quot;Url跳转&quot;
});

//菜单2
var subButton2 = new SubButton()
{
    name = &quot;菜单2&quot;
};

bg.button.Add(subButton2);
subButton2.sub_button.Add(new SingleClickButton()
{
    key = &quot;SubClickRoot_Text&quot;,
    name = &quot;返回文本&quot;
});
subButton2.sub_button.Add(new SingleClickButton()
{
    key = &quot;SubClickRoot_News&quot;,
    name = &quot;返回图文&quot;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步：提交到微信服务器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var result = CommonApi.CreateMenu(accessToken, bg);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面SingleClickButton和SingleViewButton分别对应了微信API中的click和view两种菜单响应方式。&lt;/p&gt;
&lt;p&gt;通过执行上述代码我们可以看到创建的菜单如下所示，可以看到上面我们通过代码创建的自定义菜单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190413130432474-1231929006.png&quot; alt=&quot;自定义的菜单效果&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查询已创建的菜单&quot;&gt;4.3、查询已创建的菜单&lt;/h3&gt;
&lt;p&gt;使用接口创建自定义菜单后，开发者还可使用接口查询自定义菜单的结构。另外请注意，在设置了个性化菜单后，使用本自定义菜单查询接口可以获取默认菜单和全部个性化菜单信息。&lt;br/&gt;请求说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http请求方式：GET
https://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的时返回的Json数据分两种类型，默认菜单与个性化的菜单。&lt;br/&gt;menu为默认菜单，conditionalmenu为个性化菜单列表。字段说明请见&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1455782296&quot;&gt;个性化菜单接口页的说明&lt;/a&gt;。&lt;br/&gt;使用Senparc.Weixin.MP SDK查询已创建的菜单接口只需一行代码，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var result = CommonApi.GetMenu(accessToken);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除已创建的菜单&quot;&gt;4.4、删除已创建的菜单&lt;/h3&gt;
&lt;p&gt;使用接口创建自定义菜单后，开发者还可使用接口删除当前使用的自定义菜单。另请注意，在个性化菜单时，调用此接口会删除默认菜单及全部个性化菜单。&lt;/p&gt;
&lt;p&gt;请求说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http请求方式：GET
https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Senparc.Weixin.MP SDK删除已创建的菜单接口只需一行代码，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var result = CommonApi.DeleteMenu(accessToken);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;菜单响应事件的处理&quot;&gt;5、菜单响应事件的处理&lt;/h2&gt;
&lt;p&gt;无论是click还是view，服务器都会收到不同的事件响应。不同的是，click之后客户端可以得到返回信息，而view在收到请求后，无论返回什么信息，客户端都无法收到（直接打开URL了）。用户点击自定义菜单后，微信会把点击事件推送给开发者，请注意，点击菜单弹出子菜单，不会产生上报。另外第3个到第8个类型的所有事件，仅支持微信iPhone5.4.1以上版本，和Android5.4以上版本的微信用户，旧版本微信用户点击后将没有回应，开发者也不能正常接收到事件推送。&lt;/p&gt;
&lt;p&gt;要对菜单响应事件的处理，我们只需要重写Senparc.Weixin.MP SDK中的对应事件，具体详情如下。下面给出了各类型事件处理的参考代码，具体业务应用可以就此扩展开来做深入的应用即可。&lt;/p&gt;
&lt;h3 id=&quot;点击菜单拉取消息时的事件推送&quot;&gt;5.1、点击菜单拉取消息时的事件推送&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public override IResponseMessageBase OnTextOrEventRequest(RequestMessageText requestMessage)
{
    // 预处理文字或事件类型请求。
    // 这个请求是一个比较特殊的请求，通常用于统一处理来自文字或菜单按钮的同一个执行逻辑，
    // 会在执行OnTextRequest或OnEventRequest之前触发，具有以下一些特征：
    // 1、如果返回null，则继续执行OnTextRequest或OnEventRequest
    // 2、如果返回不为null，则终止执行OnTextRequest或OnEventRequest，返回最终ResponseMessage
    // 3、如果是事件，则会将RequestMessageEvent自动转为RequestMessageText类型，其中RequestMessageText.Content就是RequestMessageEvent.EventKey

    if (requestMessage.Content == &quot;OneClick&quot;)
    {
        var strongResponseMessage = CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
        strongResponseMessage.Content = &quot;您点击了底部按钮。\r\n为了测试微信软件换行bug的应对措施，这里做了一个——\r\n换行&quot;;
        return strongResponseMessage;
    }
    return null;//返回null，则继续执行OnTextRequest或OnEventRequest
}


public override IResponseMessageBase OnEvent_ClickRequest(RequestMessageEvent_Click requestMessage)
{
    //获得当前公众号
    WeixinOfficialAccountEntity account = RDIFrameworkService.Instance.WeixinBasicService.GetOfficialAccountEntity(Id);

    IResponseMessageBase reponseMessage = null;
    //菜单点击，需要跟创建菜单时的Key匹配
    switch (requestMessage.EventKey)
    {
        case &quot;OneClick&quot;:
            {
                //这个过程实际已经在OnTextOrEventRequest中完成，这里不会执行到。
                var strongResponseMessage = CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
                reponseMessage = strongResponseMessage;
                strongResponseMessage.Content = &quot;您点击了底部按钮。\r\n为了测试微信软件换行bug的应对措施，这里做了一个——\r\n换行&quot;;
            }
            break;
        case &quot;SubClickRoot_Text&quot;:
            {
                var strongResponseMessage = CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
                reponseMessage = strongResponseMessage;
                strongResponseMessage.Content = &quot;您点击了子菜单按钮。&quot;;
            }
            break;
        case &quot;SubClickRoot_News&quot;:
            {
                var strongResponseMessage = CreateResponseMessage&amp;lt;ResponseMessageNews&amp;gt;();
                reponseMessage = strongResponseMessage;
                strongResponseMessage.Articles.Add(new Article()
                {
                    Title = &quot;您点击了子菜单图文按钮&quot;,
                    Description = &quot;您点击了子菜单图文按钮，这是一条图文信息。&quot;,
                    PicUrl = &quot;http://www.rdiframework.net/img/weixing-ma.png&quot;,
                    Url = &quot;http://www.rdiframework.net/&quot;
                });
            }
            break;
        case &quot;SubClickRoot_Music&quot;:
            {
                //上传缩略图
                var uploadResult = MediaApi.UploadTemporaryMedia(account.AccessToken, UploadMediaFileType.image,Server.GetMapPath(&quot;~/Content/Images/weixing-ma.png&quot;));
                //设置音乐信息
                var strongResponseMessage = CreateResponseMessage&amp;lt;ResponseMessageMusic&amp;gt;();
                reponseMessage = strongResponseMessage;
                strongResponseMessage.Music.Title = &quot;天籁之音&quot;;
                strongResponseMessage.Music.Description = &quot;真的是天籁之音&quot;;
                strongResponseMessage.Music.MusicUrl = &quot;http://www.rdiframework.net/resource/music/music1.mp3&quot;;
                strongResponseMessage.Music.HQMusicUrl = &quot;http://www.rdiframework.net/resource/music/music1.mp3&quot;;
                strongResponseMessage.Music.ThumbMediaId = uploadResult.media_id;
            }
            break;
        case &quot;SubClickRoot_Image&quot;:
            {
                //上传图片
                var uploadResult = MediaApi.UploadTemporaryMedia(account.AccessToken, UploadMediaFileType.image, Server.GetMapPath(&quot;~/Content/Images/weixing-ma.png&quot;));
                //设置图片信息
                var strongResponseMessage = CreateResponseMessage&amp;lt;ResponseMessageImage&amp;gt;();
                reponseMessage = strongResponseMessage;
                strongResponseMessage.Image.MediaId = uploadResult.media_id;
            }
            break;         
        default:
            {
                var strongResponseMessage = CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
                strongResponseMessage.Content = &quot;您点击了按钮，EventKey：&quot; + requestMessage.EventKey;
                reponseMessage = strongResponseMessage;
            }
            break;
    }

    return reponseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在4.2小节我们创建的菜单中，我们单击“返回图文”二级菜单项，由于我们为这个菜单项定义的KEY为“SubClickRoot_News”，如下图的调试状态所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190413130512971-2054947634.png&quot; alt=&quot;返回图文事件调试状态&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们返回到微信查看一下运行效果，可以看到我们自己的服务器根据定义已经正确的返回了图文信息给我们，其他的菜单事件操作类似。&lt;/p&gt;
&lt;p&gt;[返回图文事件运行效果]](&lt;a href=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190413130528327-1661526058.png&quot; class=&quot;uri&quot;&gt;https://img2018.cnblogs.com/blog/157572/201904/157572-20190413130528327-1661526058.png&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;又如我们返回一首音乐，还可以直接播放返回的音乐，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190413130542325-2071841917.png&quot; alt=&quot;返回音乐事件运行效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190413130549166-1484462136.png&quot; alt=&quot;音乐事件播放效果&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;击菜单跳转链接时的事件推送&quot;&gt;5.2、击菜单跳转链接时的事件推送&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public override IResponseMessageBase OnEvent_ViewRequest(RequestMessageEvent_View requestMessage)
{
   //说明：这条消息只作为接收，下面的responseMessage到达不了客户端，类似OnEvent_UnsubscribeRequest
   var responseMessage = CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
   responseMessage.Content = &quot;您点击了view按钮，将打开网页：&quot; + requestMessage.EventKey;
   return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;扫码推事件的事件推送&quot;&gt;5.3、扫码推事件的事件推送&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 事件之扫码推事件(scancode_push)
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnEvent_ScancodePushRequest(RequestMessageEvent_Scancode_Push requestMessage)
{
    var responseMessage = base.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
    responseMessage.Content = &quot;事件之扫码推事件&quot;;
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;扫码推事件且弹出消息接收中提示框的事件推送&quot;&gt;5.4、扫码推事件且弹出“消息接收中”提示框的事件推送&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 事件之扫码推事件且弹出“消息接收中”提示框(scancode_waitmsg)
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnEvent_ScancodeWaitmsgRequest(RequestMessageEvent_Scancode_Waitmsg requestMessage)
{
    var responseMessage = base.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
    responseMessage.Content = &quot;事件之扫码推事件且弹出“消息接收中”提示框&quot;;
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;弹出系统拍照发图的事件推送&quot;&gt;5.5、弹出系统拍照发图的事件推送&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 事件之弹出系统拍照发图(pic_sysphoto)
/// 实际测试时发现微信并没有推送RequestMessageEvent_Pic_Sysphoto消息，只能接收到用户在微信中发送的图片消息。
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnEvent_PicSysphotoRequest(RequestMessageEvent_Pic_Sysphoto requestMessage)
{
    var responseMessage = base.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
    responseMessage.Content = &quot;事件之弹出系统拍照发图&quot;;
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;弹出拍照或者相册发图的事件推送&quot;&gt;5.6、弹出拍照或者相册发图的事件推送&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 事件之弹出拍照或者相册发图（pic_photo_or_album）
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnEvent_PicPhotoOrAlbumRequest(RequestMessageEvent_Pic_Photo_Or_Album requestMessage)
{
   var responseMessage = base.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
   responseMessage.Content = &quot;事件之弹出拍照或者相册发图&quot;;
   return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;弹出微信相册发图器的事件推送&quot;&gt;5.7、弹出微信相册发图器的事件推送&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 事件之弹出微信相册发图器(pic_weixin)
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnEvent_PicWeixinRequest(RequestMessageEvent_Pic_Weixin requestMessage)
{
    var responseMessage = base.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
    responseMessage.Content = &quot;事件之弹出微信相册发图器&quot;;
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;弹出地理位置选择器的事件推送&quot;&gt;5.8、弹出地理位置选择器的事件推送&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 事件之弹出地理位置选择器（location_select）
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnEvent_LocationSelectRequest(RequestMessageEvent_Location_Select requestMessage)
{
    var responseMessage = base.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
    responseMessage.Content = &quot;事件之弹出地理位置选择器&quot;;
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对菜单应用的整合界面参考&quot;&gt;6、对菜单应用的整合界面参考&lt;/h2&gt;
&lt;p&gt;实际应用中菜单随时都可能在变化，我们的最终使用者是不可能用编码的方式去对菜单进行处理的。这时就需要一个集中的界面可对菜单的集中配置。我们开发了菜单的应用参考界面，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190413130618630-2091640661.png&quot; alt=&quot;微信菜单定义界面整合&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，我们通过“获取菜单”按钮可以得到当前已经定义好的菜单及菜单的事件响应的处理，我们对微信常规菜单以及个性化菜单的定义都进行了处理。各菜单的定义完全按照微信的要求标准进行了处理。对于界面右侧的“按钮其他参数”的的设置，针对不同的类型分别进行了处理。对于菜单的修改，直接单击“更新到服务器”即可完成同步，非常的方便。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1445241432&quot;&gt;微信公众平台技术文档-官方&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JeffreySu/WeiXinMPSDK&quot;&gt;Senparc.Weixin SDK + 官网示例源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.rdiframework.net/article/190&quot;&gt;RDIFramework.NET — 基于.NET的快速信息化系统开发框架 — 系列目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.rdiframework.net/article/169&quot;&gt;RDIFramework.NET ━ .NET快速信息化系统开发框架 ━ 工作流程组件介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.rdiframework.net/article/189&quot;&gt;RDIFramework.NET框架SOA解决方案（集Windows服务、WinForm形式与IIS形式发布）-分布式应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.rdiframework.net/article/199&quot;&gt;RDIFramework.NET代码生成器全新V3.5版本发布-重大升级&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;一路走来数个年头，感谢RDIFramework.NET框架的支持者与使用者，大家可以通过下面的地址了解详情。&lt;/p&gt;
&lt;p&gt;RDIFramework.NET官方网站：&lt;a href=&quot;http://www.rdiframework.net/&quot; class=&quot;uri&quot;&gt;http://www.rdiframework.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RDIFramework.NET官方博客：&lt;a href=&quot;http://blog.rdiframework.net/&quot; class=&quot;uri&quot;&gt;http://blog.rdiframework.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时需要说明的，以后的所有技术文章以官方网站为准，欢迎大家收藏！&lt;/p&gt;
&lt;p&gt;RDIFramework.NET框架由专业团队长期打造、一直在更新、一直在升级，请放心使用！&lt;/p&gt;
&lt;p&gt;欢迎关注RDIFramework.net框架官方公众微信（微信号：guosisoft），及时了解最新动态。&lt;/p&gt;
&lt;p&gt;扫描二维码立即关注&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190413130345648-600309676.png&quot; alt=&quot;微信号：guosisoft&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 05:20:00 +0000</pubDate>
<dc:creator>yonghu86</dc:creator>
<og:description>1、概述 自定义菜单能够帮助公众号丰富界面，让用户更好更快地理解公众号的功能。菜单分为默认菜单与个性化菜单。个性化菜单接口是为了帮助公众号实现灵活的业务运营，开发者可以通过该接口，让公众号的不同用户群</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huyong/p/10700758.html</dc:identifier>
</item>
<item>
<title>在Heroku上免费部署ASP.NET Core（使用Docker和CircleCI） - luzemin</title>
<link>http://www.cnblogs.com/talentzemin/p/10716312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/talentzemin/p/10716312.html</guid>
<description>&lt;p&gt;使用命令行即可创建一个模板项目&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet new webapi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码 &lt;a href=&quot;https://github.com/Ibro/AspNetCoreHerokuDocker&quot; class=&quot;uri&quot;&gt;https://github.com/Ibro/AspNetCoreHerokuDocker&lt;/a&gt;&lt;br/&gt;可以直接fork&lt;/p&gt;

&lt;p&gt;参考Docker官方文档&lt;a href=&quot;https://docs.docker.com/engine/examples/dotnetcore/&quot; class=&quot;uri&quot;&gt;https://docs.docker.com/engine/examples/dotnetcore/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于Heroku不能很好的运行&lt;code&gt;ENTRYPOINT&lt;/code&gt;命令&lt;br/&gt;所以我们修改&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ENTRYPOINT [&quot;dotnet&quot;, &quot;aspnetapp.dll&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CMD dotnet aspnetapp.dll&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的&lt;code&gt;Dockerfile&lt;/code&gt; 大概是这个样子的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM microsoft/dotnet:2.2-sdk AS build-env
WORKDIR /app

# Copy csproj and restore as distinct layers
COPY *.csproj ./
RUN dotnet restore

# Copy everything else and build
COPY . ./
RUN dotnet publish -c Release -o out

# Build runtime image
FROM microsoft/dotnet:2.2-aspnetcore-runtime
WORKDIR /app
COPY --from=build-env /app/out .
CMD dotnet AspNetCoreHerokuDocker.dll&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;注册账号&quot;&gt;注册账号&lt;/h2&gt;
&lt;p&gt;Heroku官方地址&lt;a href=&quot;https://www.heroku.com/&quot; class=&quot;uri&quot;&gt;https://www.heroku.com/&lt;/a&gt;&lt;br/&gt;没有账号的注册一个，我在注册的时候发现qq邮箱是不允许的。&lt;br/&gt;注册完毕会在注册邮箱收到确认地址，打开输入密码，即完成注册。&lt;/p&gt;
&lt;h2 id=&quot;创建应用&quot;&gt;创建应用&lt;/h2&gt;
&lt;p&gt;登录账号会跳转到个人控制台，创建一个app&lt;br/&gt;输入app名称、选择地区，即可完成创建&lt;br/&gt;此处，我创建的app名称为&lt;code&gt;netcoreapp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/474029/201904/474029-20190416124841128-1903776802.jpg&quot; alt=&quot;https://img2018.cnblogs.com/blog/474029/201904/474029-20190416124841128-1903776802.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;0.在项目根目录下创建&lt;code&gt;circleci&lt;/code&gt;文件夹，在文件夹中创建&lt;code&gt;config.yml&lt;/code&gt;文件，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: 2
jobs:
 build:
   machine: true
   steps:
     - checkout 

     # build image
     - run: |         
         docker info
         docker build -t aspnetapp -f Dockerfile .
     # deploy the image
     - run: |         
         docker login --username=$HEROKU_USERNAME --password=$HEROKU_API_KEY registry.heroku.com
         docker tag aspnetapp registry.heroku.com/$HEROKU_APP_NAME/web
         docker push registry.heroku.com/$HEROKU_APP_NAME/web                
         curl https://cli-assets.heroku.com/install.sh | sh
         heroku container:release web -a $HEROKU_APP_NAME&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.CircleCI官方网址 &lt;a href=&quot;https://circleci.com&quot; class=&quot;uri&quot;&gt;https://circleci.com&lt;/a&gt; ,使用Github登录&lt;/p&gt;
&lt;p&gt;2.左侧菜单选择&lt;code&gt;Add Projects&lt;/code&gt;，CircleCI会扫描Github的仓库，我们可以看到fork的&lt;code&gt;AspNetCoreHerokuDocker&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/474029/201904/474029-20190416124702733-514445383.png&quot; alt=&quot;https://img2018.cnblogs.com/blog/474029/201904/474029-20190416124702733-514445383.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.点击该项目后面的&lt;code&gt;Set Up Project&lt;/code&gt;按钮进入下一步&lt;/p&gt;
&lt;p&gt;4.选择&lt;code&gt;linux&lt;/code&gt;系统，再选择下方 &lt;code&gt;Start building&lt;/code&gt;按钮，开始builing&lt;/p&gt;
&lt;p&gt;5.开始前为CircleCI项目设置环境变量&lt;br/&gt;&lt;code&gt;HEROKU_USERNAME&lt;/code&gt; Heroku注册邮箱&lt;br/&gt;&lt;code&gt;HEROKU_API_KEY&lt;/code&gt; 在Heroku个人信息中可以找到&lt;br/&gt;&lt;code&gt;HEROKU_APP_NAME&lt;/code&gt; 我们在Heroku中创建的app名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/474029/201904/474029-20190416124809345-1940074567.png&quot; alt=&quot;https://img2018.cnblogs.com/blog/474029/201904/474029-20190416124809345-1940074567.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.开始build,大约1-2分钟完成&lt;/p&gt;

&lt;p&gt;在Heroku中，打开创建的app，在右上角点击&lt;code&gt;open app&lt;/code&gt;即可在线访问&lt;br/&gt;或者直接输入&lt;code&gt;https://app名称.herokuapp.com/&lt;/code&gt;访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/474029/201904/474029-20190416124906805-1673550607.jpg&quot; alt=&quot;https://img2018.cnblogs.com/blog/474029/201904/474029-20190416124906805-1673550607.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codingblast.com/hosting-asp-net-core-on-heroku-with-dockercircleci-for-free/&quot; class=&quot;uri&quot;&gt;https://codingblast.com/hosting-asp-net-core-on-heroku-with-dockercircleci-for-free/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 04:52:00 +0000</pubDate>
<dc:creator>luzemin</dc:creator>
<og:description>创建 ASP.NET Core应用 使用命令行即可创建一个模板项目 完整代码 'https://github.com/Ibro/AspNetCoreHerokuDocker' 可以直接fork 配置D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/talentzemin/p/10716312.html</dc:identifier>
</item>
<item>
<title>设计模式之工厂模式（一） - 小酒窝</title>
<link>http://www.cnblogs.com/dimple91/p/10716288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dimple91/p/10716288.html</guid>
<description>&lt;p&gt;工厂模式的学习篇幅比较长，小编第一次看书的时候，就一口气花了一个多小时，还是通读。后面又断断续续地继续了解了下，力争做到清晰的认知，给大家一个简单的学习方式。所以，这次模块分的可能会比之前的多，涉及到多个工厂模式。好的，我们继续冲鸭！！！&lt;/p&gt;
&lt;p&gt;除了使用new操作符之外，还有更多制造对象的方法。我们将了解到实例化这个活动不应该总是公开地进行，也会认识到初始化经常会造成“耦合”问题。所以，这肯定不是我们希望的这样对吧？继续学习下去，我们将了解工厂模式如何从复杂的依赖中帮你脱困。&lt;/p&gt;
&lt;h4 id=&quot;当看到new就会想到具体&quot;&gt;当看到“new”，就会想到“具体”&lt;/h4&gt;
&lt;p&gt;很多朋友应该有一个疑惑，之前说的原则，不应该针对实现编程，但是当我们每次使用new的时候，其实就是在针对实现编程呀。使用了“new”，就是在实例化一个具体类，所以用的的确是实现，而不是接口。遇到一个类的情况，还好说，但是遇到多个类，就必须等到运行时，才知道该实例化哪一个。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Duck duck;
if(picnic) {
    duck = new MallardDuck();
} else if (hunting) {
    duck = new DecoyDuck();
} else if (inBathTub) {
    duck = new RubberDuck();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码如果一旦有变化扩展，就必须重新打开这段代码进行检查和修改，势必会造成部分系统更难维护和更新，也更容易犯错。&lt;/p&gt;
&lt;h3 id=&quot;new有什么不对劲&quot;&gt;“new”有什么不对劲&lt;/h3&gt;
&lt;p&gt;针对Java程序来说，new是最最基础的部分了，所以从技术上来说，new丝毫没有问题，问题的关键在于经常要进行的改变。&lt;/p&gt;
&lt;p&gt;针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。为啥呢？如果代码是针对接口编程，那么通过&lt;strong&gt;多态&lt;/strong&gt;可以与任何新类实现该接口。但是，当代码使用大量的具体类时，这就很麻烦了，就必须对代码进行改变。也就是说，你的代码并非“对修改关闭”。想用新的具体类型来扩展代码，就必须重新 打开它。&lt;/p&gt;
&lt;p&gt;所以，有没有解决办法呢？还记得我们的第一个原则不，就是用来改变，并帮我们“找出会变化的方面，把它们从不变的部分分离出来”。&lt;/p&gt;
&lt;p&gt;之前的装饰者模式，我们喝了可口的咖啡，那么在工厂模式里，就让我们给咖啡加点搭配，来尝尝披萨的口味吧。&lt;/p&gt;
&lt;h3 id=&quot;识别变化的方面以及你的初步判断&quot;&gt;识别变化的方面，以及你的初步判断&lt;/h3&gt;
&lt;p&gt;假设你有一个披萨店，为了让系统有弹性，很是希望这是一个抽象类或接口。但如果这样，这些类或接口就无法直接实例化了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Pizza orderPizza() {
    Pizza pizza = new Pizza();
    
    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，我们还是需要增加一些代码，来“决定”适合披萨的类型，然后再“制造”披萨：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Pizza orderPizza(String type) {
        Pizza pizza;
        
        // 根据披萨的类型，我们实例化正确的具体类，然后将其赋值给pizza实例化变量。
        // 请注意，这里的任何披萨都必须实现Pizza接口
        if (&quot;cheese&quot;.equals(type)) {
            pizza = new CheesePizza();
        } else if (&quot;greek&quot;.equals(type)) {
            pizza = new GreekPizza();
        } else if (&quot;pepperoni&quot;.equals(type)) {
            pizza = new PepperoniPizza();
        }
        
        // 一旦我们有了披萨，需要做一些必要的工作。每个Pizza的子类型都知道如何准备自己
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;但是压力来自增加更多的披萨类型&quot;&gt;但是压力来自增加更多的披萨类型&lt;/h3&gt;
&lt;p&gt;但是，每个产业都会存在竞争对手的，是吧。当其他的披萨店开发出了新产品，你怎么办呢。比如人家有了Clam Pizza、Veggie Pizza。还能怎么办，必须与时俱进，与对手一同进步，把这些披萨加入到你的店里，顺带淘汰一些过时了的披萨。&lt;/p&gt;
&lt;p&gt;完蛋了，如果要增加披萨，又要去淘汰过时的披萨，在程序的世界里就是实例化某些类，删除某些实例化的类。orderPizza()出问题了，我们无法让orderPizza()对修改关闭；所以，我们用到了第一节学到的封装，我们要封装这些增删改的东西。&lt;/p&gt;
&lt;h3 id=&quot;封装创建对象的代码&quot;&gt;封装创建对象的代码&lt;/h3&gt;
&lt;p&gt;那么封装什么才是符合我们预期的呢，显而易见，现在最好将创建对象移到orderPizza()之外。但怎么做呢？我们要把创建披萨的代码移到另一个对象中，由这个对象专职创建披萨。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (&quot;cheese&quot;.equals(type)) {
    pizza = new CheesePizza();
} else if (&quot;greek&quot;.equals(type)) {
    pizza = new GreekPizza();
} else if (&quot;pepperoni&quot;.equals(type)) {
    pizza = new PepperoniPizza();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是把这个移走，新建一个对象，这个新对象只管如何创建披萨。如果任何对象想要创建披萨，直接就找这个即可。&lt;/p&gt;
&lt;h3 id=&quot;我们称这个新对象为工厂并建造工厂&quot;&gt;我们称这个新对象为“工厂”，并建造工厂&lt;/h3&gt;
&lt;p&gt;工厂（factory）处理创建对象的细节，一旦有了SimplePizzaFactory，orderPizza()就变成此对象的客户。现在，我们方式很简单了，当你想要一个披萨的时候，你就叫披萨工厂去做一个就好了。orderPizza()方法只关心从工厂得到了一个披萨，而这个披萨实现了Pizza接口，所以他可以调用prepare()、bake()、cut()、box()来分别进行准备、烘烤、切片、盒装。&lt;/p&gt;
&lt;p&gt;那我们把这个工厂建造起来吧，还不赶紧的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 这个工厂只做一件事，帮他的客户创建披萨
public class SimplePizzaFactory {

    // 在工厂内定义一个方法createPizza()方法，所有客户用这个方法来实例化新对象
    public Pizza createPizza(String type) {
        Pizza pizza = null;

        if (type.equals(&quot;cheese&quot;)) {
            pizza = new CheesePizza();
        } else if (type.equals(&quot;pepperoni&quot;)) {
            pizza = new PepperoniPizza();
        } else if (type.equals(&quot;clam&quot;)) {
            pizza = new ClamPizza();
        } else if (type.equals(&quot;veggie&quot;)) {
            pizza = new VeggiePizza();
        }
        return pizza;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这个类还是需要进行频繁的增删改的，还是有点麻烦，但是相比之前呢。为什么这么说，因为这个类，还可以有很多行为，这会儿是创建披萨，那也许是创建菜单呢，又或者是创建饿了么外卖呢，都可以在这个工厂类里创建出来，其他类，只需要调用即可。所以，也就是说，当以后有任何改变，只需要修改这个类即可，省去你在其他地方操作的烦恼。&lt;/p&gt;
&lt;p&gt;有了工厂类，其他类的操作就要随之更改了。PizzaStore类需要把这个工厂加进来，毕竟我们什么事情都交给工厂去完成了。修改如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 你需要更多的披萨类型传入orderPizza()
    public Pizza orderPizza(String type) {
        Pizza pizza;
        pizza = factory.createPizza(type);
                
        // 一旦我们有了披萨，需要做一些必要的工作。每个Pizza的子类型都知道如何准备自己
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义简单工厂&quot;&gt;定义简单工厂&lt;/h3&gt;
&lt;p&gt;简单工厂其实不是一个设计模式，反而比较像是一种变成习惯。但由于经常被使用，所以在书中，给他一个“Head First Pattern荣誉奖”。有些开发人员的确是把这个编程习惯误认为是“工厂模式”(Factory Pattern)。但是不要因为简单工厂不是一个设计模式，就忽略了他。让我们来看看新的披萨店的类图：&lt;br/&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/mw690/62b02411ly1g1ylvytksej20mi0drte8.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好啦，工厂模式的热身结束啦。谢谢简单工厂模式给我们暖身，之后我们会进入两个重量级的模式，他们都是工厂。所以，别担心你吃不到披萨，后面还会有更多的披萨呢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再提醒一次&lt;/strong&gt;，在设计模式中，所谓的“实现一个接口”并“不一定”表示“写一个类，并利用implement关键词来实现某个Java接口”。“实现一个接口”泛指“实现某个超类型（可以使类或接口）的某个方法”。&lt;/p&gt;
&lt;p&gt;简单工厂你get了吗？&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;GitHub地址 &lt;a href=&quot;https://github.com/dimplexu/HeadFirstDesign&quot;&gt;HeadFirstDesign&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;爱生活，爱学习，爱感悟，爱挨踢&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/mw690/62b02411ly1g1h6i45avyj207607674r.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 04:46:00 +0000</pubDate>
<dc:creator>小酒窝</dc:creator>
<og:description>工厂模式的学习篇幅比较长，小编第一次看书的时候，就一口气花了一个多小时，还是通读。后面又断断续续地继续了解了下，力争做到清晰的认知，给大家一个简单的学习方式。所以，这次模块分的可能会比之前的多，涉及到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dimple91/p/10716288.html</dc:identifier>
</item>
<item>
<title>一次分表踩坑实践的探讨 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/10716139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/10716139.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1g23egdv1f8j30m80chq6e.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;之前不少人问我“能否分享一些分库分表相关的实践”，其实不是我不分享，而是真的经验不多🤣；和大部分人一样都是停留在理论阶段。&lt;/p&gt;
&lt;p&gt;不过这次多少有些可以说道了。&lt;/p&gt;
&lt;p&gt;先谈谈背景，我们生产数据库随着业务发展量也逐渐起来；好几张单表已经突破&lt;strong&gt;亿级&lt;/strong&gt;数据，并且保持每天 200+W 的数据量增加。&lt;/p&gt;
&lt;p&gt;而我们有些业务需要进行关联查询、或者是报表统计；在这样的背景下大表的问题更加突出（比如一个查询功能需要跑好几分钟）。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;可能很多人会说：为啥单表都过亿了才想方案解决？其实不是不想，而是由于历史原因加上错误预估了数据增长才导致这个局面。总之原因比较复杂，也不是本次讨论的重点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于需求紧、人手缺的情况下，整个处理的过程分为几个阶段。&lt;/p&gt;
&lt;p&gt;第一阶段应该是去年底，当时运维反应 &lt;code&gt;MySQL&lt;/code&gt; 所在的主机内存占用很高，整体负载也居高不下，导致整个 MySQL 的吞吐量明显降低（写入、查询数据都明显减慢）。&lt;/p&gt;
&lt;p&gt;为此我们找出了数据量最大的几张表，发现大部分数据量在7/8000W 左右，少数的已经突破一亿。&lt;/p&gt;
&lt;p&gt;通过业务层面进行分析发现，这些数据多数都是用户产生的一些&lt;strong&gt;日志型数据&lt;/strong&gt;，而且这些数据在业务上并不是强相关的，甚至两三个月前的数据其实已经不需要实时查询了。&lt;/p&gt;
&lt;p&gt;因为接近年底，尽可能的不想去动应用，考虑是否可以在运维层面缓解压力；主要的目的就是把单表的数据量降低。&lt;/p&gt;
&lt;p&gt;原本是想把两个月之前的数据直接迁移出来放到备份表中，但在准备实施的过程中发现一个大坑。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;表中没有一个可以排序的索引，导致我们无法快速的筛选出一部分数据！这真是一个深坑，为后面的一些优化埋了个地雷；即便是加索引也需要花几个小时（具体多久没敢在生产测试）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们强行按照时间进行筛选，可能查询出 4000W 的数据就得花上好几个小时；这显然是行不通的。&lt;/p&gt;
&lt;p&gt;于是我们便想到了一个大胆的想法：这部分数据是否可以直接不要了？&lt;/p&gt;
&lt;p&gt;这可能是最有效及最快的方式了，和产品沟通后得知这部分数据真的只是日志型的数据，即便是报表出不来今后补上也是可以的。&lt;/p&gt;
&lt;p&gt;于是我们就简单粗暴的做了以下事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改原有表的表名，比如加上(&lt;code&gt;_190416bak&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;再新建一张和原有表名称相同的表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样新的数据就写到了新表，同时业务上也是使用的这个数据量较小的新表。&lt;/p&gt;
&lt;p&gt;虽说过程不太优雅，但至少是解决了问题同时也给我们做技术改造预留了时间。&lt;/p&gt;

&lt;p&gt;之前的方案虽说可以缓解压力，但不能根本解决问题。&lt;/p&gt;
&lt;p&gt;有些业务必须得查询之前的数据，导致之前那招行不通了，所以正好我们就借助这个机会把表分了。&lt;/p&gt;
&lt;p&gt;我相信大部分人虽说没有做过实际做过分表，但也见过猪跑；网上一搜各种方案层出不穷。&lt;/p&gt;
&lt;p&gt;我认为最重要的一点是要结合实际业务找出需要 sharding 的字段，同时还有上线阶段的数据迁移也非常重要。&lt;/p&gt;
&lt;h2 id=&quot;时间&quot;&gt;时间&lt;/h2&gt;
&lt;p&gt;可能大家都会说用 hash 的方式分配得最均匀，但我认为这还是需要使用历史数据的场景才用哈希分表。&lt;/p&gt;
&lt;p&gt;而对于不需要历史数据的场景，比如业务上只查询近三个月的数据。&lt;/p&gt;
&lt;p&gt;这类需求完成可以采取时间分表，按照月份进行划分，这样改动简单，同时对历史数据也比较好迁移。&lt;/p&gt;
&lt;p&gt;于是我们首先将这类需求的表筛选出来，按照月份进行拆分，只是在查询的时候拼接好表名即可；也比较好理解。&lt;/p&gt;
&lt;h2 id=&quot;哈希&quot;&gt;哈希&lt;/h2&gt;
&lt;p&gt;刚才也提到了：需要根据业务需求进行分表策略。&lt;/p&gt;
&lt;p&gt;而一旦所有的数据都有可能查询时，按照时间分表也就行不通了。（也能做，只是如果不是按照时间进行查询时需要遍历所有的表）&lt;/p&gt;
&lt;p&gt;因此我们计划采用 &lt;code&gt;hash&lt;/code&gt; 的方式分表，这算是业界比较主流的方式就不再赘述。&lt;/p&gt;
&lt;p&gt;采用哈希时需要将 &lt;code&gt;sharding&lt;/code&gt; 字段选好，由于我们的业务比较单纯；是一个物联网应用，所有的数据都包含有物联网设备的唯一标识（IMEI），并且这个字段天然的就保持了唯一性；大多数的业务也都是根据这个字段来的，所以它非常适合来做这个 &lt;code&gt;sharding&lt;/code&gt; 字段。&lt;/p&gt;
&lt;p&gt;在做分表之前也调研过 &lt;code&gt;MyCAT&lt;/code&gt; 及 &lt;code&gt;sharding-jdbc&lt;/code&gt;(现已升级为 &lt;code&gt;shardingsphere&lt;/code&gt;)，最终考虑到对开发的友好性及不增加运维复杂度还是决定在 jdbc 层 sharding 的方式。&lt;/p&gt;
&lt;p&gt;但由于历史原因我们并不太好集成 &lt;code&gt;sharding-jdbc&lt;/code&gt;，但基于 &lt;code&gt;sharding&lt;/code&gt; 的特点自己实现了一个分表策略。&lt;/p&gt;
&lt;p&gt;这个简单也好理解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int index = hash(sharding字段) % 分表数量 ;

select xx from 'busy_'+index where sharding字段 = xxx;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实就是算出了表名，然后路由过去查询即可。&lt;/p&gt;
&lt;p&gt;只是我们实现的非常简单：修改了所有的底层查询方法，每个方法都里都做了这样的一个判断。&lt;/p&gt;
&lt;p&gt;并没有像 &lt;code&gt;sharding-jdbc&lt;/code&gt; 一样，代理了数据库的查询方法；其中还要做 &lt;code&gt;SQL解析--&amp;gt;SQL路由--&amp;gt;执行SQL--&amp;gt;合并结果&lt;/code&gt; 这一系列的流程。&lt;/p&gt;
&lt;p&gt;如果自己再做一遍无异于重新造了一个轮子，并且并不专业，只是在现有的技术条件下选择了一个快速实现达成效果的方法。&lt;/p&gt;
&lt;p&gt;不过这个过程中我们节省了将 sharding 字段哈希的过程，因为每一个 IMEI 号其实都是一个唯一的整型，直接用它做 mod 运算即可。&lt;/p&gt;
&lt;p&gt;还有一个是需要一个统一的组件生成规则，分表后不能再依赖于单表的字段自增了；方法还是挺多的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;比如时间戳+随机数可满足大部分业务。&lt;/li&gt;
&lt;li&gt;UUID，生成简单，但没法做排序。&lt;/li&gt;
&lt;li&gt;雪花算法统一生成主键ID。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大家可以根据自己的实际情况做选择。&lt;/p&gt;

&lt;p&gt;因为我们并没有使用第三方的 sharding-jdbc 组件，所有没有办法做到对代码的低侵入性；每个涉及到分表的业务代码都需要做底层方法的改造（也就是路由到正确的表）。&lt;/p&gt;
&lt;p&gt;考虑到后续业务的发展，我们决定将拆分的表分为 64 张；加上后续引入大数据平台足以应对几年的数据增长。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里还有个小细节需要注意：分表的数量需要为 2∧N 次方，因为在取模的这种分表方式下，即便是今后再需要分表影响的数据也会尽量的小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再修改时只能将表名称进行全局搜索，然后加以修改，同时根据修改的方法倒推到表现的业务并记录下来，方便后续回归测试。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当然无法避免查询时利用非 sharding 字段导致的全表扫描，这是所有分片后都会遇到的问题。&lt;/p&gt;
&lt;p&gt;因此我们在修改分表方法的底层查询时同时也会查看是否有走分片字段，如果不是，那是否可以调整业务。&lt;/p&gt;
&lt;p&gt;比如对于一个上亿的数据是否还有必要存在按照分页查询、日期查询？这样的业务是否真的具有意义？&lt;/p&gt;
&lt;p&gt;我们尽可能的引导产品按照这样的方式来设计产品或者做出调整。&lt;/p&gt;
&lt;p&gt;但对于报表这类的需求确实也没办法，比如统计表中某种类型的数据；这种我们也可以利用多线程的方式去并行查询然后汇总统计来提高查询效率。&lt;/p&gt;
&lt;p&gt;有时也有一些另类场景：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;比如一个千万表中有某一特殊类型的数据只占了很小一部分，比如说几千上万条。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时页面上需要对它进行分页查询是比较正常的（比如某种投诉消息，客户需要一条一条的单独处理），但如果我们按照 IMEI 号或者是主键进行分片后再分页查询那就比较蛋疼了。&lt;/p&gt;
&lt;p&gt;所以这类型的数据建议单独新建一张表来维护，不要和其他数据混合在一起，这样不管是做分页还是 like 都比较简单和独立。&lt;/p&gt;
&lt;h2 id=&quot;验证&quot;&gt;验证&lt;/h2&gt;
&lt;p&gt;代码改完，开发也单测完成后怎么来验证分表的业务是否正常也比较麻烦。&lt;/p&gt;
&lt;p&gt;一个是测试麻烦，再一个是万一哪里改漏了还是查询的原表，但这样在测试环境并不会有异常，一旦上线产生了生产数据到新的 64 张表后想要再修复就比较麻烦了。&lt;/p&gt;
&lt;p&gt;所以我们取了个巧，直接将原表的表名修改，比如加一个后缀；这样在测试过程中观察前后台有无报错就比较容易提前发现这个问题。&lt;/p&gt;

&lt;p&gt;测试验收通过后只是分表这个需求的80%，剩下如何上线也是比较头疼。&lt;/p&gt;
&lt;p&gt;一旦应用上线后所有的查询、写入、删除都会先走路由然后到达新表；而老数据在原表里是不会发生改变的。&lt;/p&gt;
&lt;h2 id=&quot;数据迁移&quot;&gt;数据迁移&lt;/h2&gt;
&lt;p&gt;所以我们上线前的第一步自然是需要将原有的数据进行迁移，迁移的目的是要分片到新的 64 张表中，这样才会对原有的业务无影响。&lt;/p&gt;
&lt;p&gt;因此我们需要额外准备一个程序，它需要将老表里的数据按照分片规则复制到新表中；&lt;/p&gt;
&lt;p&gt;在我们这个场景下，生产数据有些已经上亿了，这个迁移过程我们在测试环境模拟发现耗时是非常久的。而且我们老表中对于 &lt;code&gt;create_time&lt;/code&gt; 这样用于筛选数据的字段没有索引（以前的技术债），所以查询起来就更加慢了。&lt;/p&gt;
&lt;p&gt;最后没办法，我们只能和产品协商告知用户对于之前产生的数据短期可能会查询不到，这个时间最坏可能会持续几天（我们只能在凌晨迁移，白天会影响到数据库负载）。&lt;/p&gt;

&lt;p&gt;这便是我们这次的分表实践，虽说不少过程都不优雅，但受限于条件也只能折中处理。&lt;/p&gt;
&lt;p&gt;但我们后续的计划是，修改我们底层的数据连接（目前是自己封装的一个 jar 包，导致集成 sharding-jdbc 比较麻烦）最终逐渐迁移到 &lt;code&gt;sharding-jdbc&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;最后得出了几个结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个好的产品规划非常有必要，可以在合理的时间对数据处理（不管是分表还是切入归档）。&lt;/li&gt;
&lt;li&gt;每张表都需要一个可以用于排序查询的字段（自增ID、创建时间），整个过程由于没有这个字段导致耽搁了很长时间。&lt;/li&gt;
&lt;li&gt;分表字段需要谨慎，要全盘的考虑业务情况，尽量避免出现查询扫表的情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后欢迎留言讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 04:03:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>之前不少人问我“能否分享一些分库分表相关的实践”，其实不是我不分享，而是真的经验不多🤣；和大部分人一样都是停留在理论阶段。 不过这次多少有些可以说道了。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crossoverJie/p/10716139.html</dc:identifier>
</item>
</channel>
</rss>