<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从壹开始学习NetCore 45 ║ 终于解决了事务问题 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/11605436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/11605436.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;哈喽，又来写文章了，原来放假可以这么爽，可以学习和分享，🤫嘘，大家要好好的工作哟。昨天发表的问题，嗯，给我留下了一点点冲击，夜里辗转反侧，想了很多，从好到坏再到好再到坏，从希望到失望再到希望再到失望，想起来当年高四了，不想解释什么了，四年后再见❤，不说废话，直接说说今天的内容吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;今天这个内容，还是来源于两个多月前，我的项目的一个 issue ，当时说到了如何使用事务，（&lt;span&gt;&lt;span&gt;为啥要使用事务，我就不多说了，相信肯定都知道，还有那个每次面试都问的题，事务四大特性。不知道还有没有小伙伴记得，不，是都记得！）&lt;/span&gt;​&lt;/span&gt;我一直也是各种尝试，直到前几天也尝试了几个办法，还是无果，然后又和 sqlsugar 的作者凯旋讨论这个问题。他说只要能保证每次http 的scope 会话中的 sugar client 是同一个就行了，而且又不能把 client 设置为单例，天天看着这个 issue，心里难免波澜，终于哟，昨天群管 @大黄瓜 小伙伴研究出来了，我很开心，表扬下他，下边就正式说说在我的项目中，如果使用事务的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201909/1468246-20190929123618079-423116429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;项目介绍： netcore 2.2 + Sqlsugar 5.0 + UnitOfWork + async Repository + Service 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;投稿作者：QQ群：大黄瓜（博客园地址不详） &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;项目已经修改，不仅仅实现了单一仓储服务的事务提交，而且也可以跨类跨仓储服务来实现事务，欢迎大家下载与公测，没问题，我会merge 到 master。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了防止大家不必要的更新错误，我新建了一个分支，大家自己去看分支即可——&lt;a href=&quot;https://github.com/anjoy8/Blog.Core/tree/Trans1.0&quot;&gt;https://github.com/anjoy8/Blog.Core/tree/Trans1.0&lt;/a&gt;&lt;a href=&quot;https://github.com/anjoy8/Blog.Core/tree/Trans1.0&quot; target=&quot;_blank&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;Tips：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我认为 sqlsugar 还是很不错，很好用，当然，不能用万能来形容客观事物，这本身就不是一个成年人该有的思维，在我推广 sqlsugar 这一年来，我也一直给凯旋提一些需求和Bug，他都特别及时的解决了，而且使用上也很顺手，目前已经实现了跨服务事务操作了，下一步就是在blog.core 中，使用主从数据库，分离了，加油。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h3&gt;1、创建工作单元接口&lt;/h3&gt;
&lt;p&gt;首先我们需要在 Blog.Core.IRepository 层，创建一个文件夹 UnitOfWork ，然后创建接口 IUnitOfWork.cs ，用来对工作单元进行定义&lt;span&gt;相应的行为操作&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUnitOfWork
 {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 sqlsugar client 实例&lt;/span&gt;
&lt;span&gt;     ISqlSugarClient GetDbClient();
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始事务&lt;/span&gt;
     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BeginTran();
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交事务&lt;/span&gt;
     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CommitTran();
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回滚事务&lt;/span&gt;
     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RollbackTran();
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、对 UnitOfWork 接口进行实现&lt;/h3&gt;
&lt;p&gt;在 Blog.Core.Repository 层，创建一个文件夹 UnitOfWork，然后创建事务接口实现类 UnitOfWork.cs ，来&lt;span&gt;对事务行为做实现&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnitOfWork : IUnitOfWork
    {

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ISqlSugarClient _sqlSugarClient;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注入 sugar client 实例&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UnitOfWork(ISqlSugarClient sqlSugarClient)
        {
            _sqlSugarClient &lt;/span&gt;=&lt;span&gt; sqlSugarClient;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保证每次 scope 访问，多个仓储类，都用一个 client 实例
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意，不是单例模型！！！&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ISqlSugarClient GetDbClient()
        {

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _sqlSugarClient;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BeginTran()
        {
            GetDbClient().Ado.BeginTran(); 
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CommitTran()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                GetDbClient().Ado.CommitTran(); &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                GetDbClient().Ado.RollbackTran();
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RollbackTran()
        {
            GetDbClient().Ado.RollbackTran();
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的内容，很简单，这里不过多解释。&lt;/p&gt;

&lt;h3&gt;3、用 UnitOfWork 接管 SqlguarClient&lt;/h3&gt;
&lt;p&gt;在基类泛型仓储类  BaseRepository&amp;lt;TEntity&amp;gt; 中，我们修改构造函数，注入工作单元接口，用来将 sqlsugar 实例统一起来，不是每次都 new，而且通过工作单元来控制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  ISqlSugarClient _db;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IUnitOfWork _unitOfWork;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数，通过 unitofwork，来控制sqlsugar 实例&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseRepository(IUnitOfWork unitOfWork)
{
    _unitOfWork &lt;/span&gt;=&lt;span&gt; unitOfWork;
    _db &lt;/span&gt;=&lt;span&gt; unitOfWork.GetDbClient();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 好像这个可以去掉，先保留&lt;/span&gt;
&lt;span&gt;    DbContext.Init(BaseDBConfig.ConnectionString, (DbType)BaseDBConfig.DbType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以对比下以前的代码，就知道了，这么做的目的，就是把 sugar client 统一起来，这样就能保证每次一个scope ，都能是同一个实例。&lt;/p&gt;

&lt;h3&gt;4、修改每一个仓储的构造函数&lt;/h3&gt;
&lt;p&gt;上边我们为了实现对 sugar client的控制，在&lt;span&gt;基类仓储的构造函数&lt;/span&gt;中，注入了IUnitOfWork，但是这样会导致子类的仓储报错，毕竟父类构造函数修改了嘛，所以目前有两个方案：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1、去掉子仓储，只使用泛型基类仓储，在service层中，使用  private readonly IRepository&amp;lt;实体类&amp;gt; _repository; 这种方法。&lt;/p&gt;
&lt;p&gt;2、去一一的修改子仓储，增加构造函数，将 IUnitOfWork 传给父类，具体的看我的代码即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201909/1468246-20190929173816653-1729920699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;5、依赖注入 ISqlSugarClient&lt;/h3&gt;
&lt;p&gt;这个是肯定的，大家还记得上边说的呢，我们要在 BaseRepository 中，注入 ISqlSugarClient ，所以就必须依赖注入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里我不是引用了命名空间，因为如果引用命名空间的话，会和Microsoft的一个GetTypeInfo存在二义性，所以就直接这么使用了。&lt;/span&gt;
 services.AddScoped&amp;lt;SqlSugar.ISqlSugarClient&amp;gt;(o =&amp;gt;&lt;span&gt;
 {
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SqlSugar.SqlSugarClient(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSugar.ConnectionConfig()
     {
         ConnectionString &lt;/span&gt;= BaseDBConfig.ConnectionString,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填, 数据库连接字符串&lt;/span&gt;
         DbType = (SqlSugar.DbType)BaseDBConfig.DbType,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填, 数据库类型&lt;/span&gt;
         IsAutoCloseConnection = &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认false, 时候知道关闭数据库连接, 设置为true无需使用using或者Close操作&lt;/span&gt;
         IsShardSameThread=&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;共享线程&lt;/span&gt;
         InitKeyType = SqlSugar.InitKeyType.SystemTable&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认SystemTable, 字段信息读取, 如：该属性是不是主键，标识列等等信息&lt;/span&gt;
&lt;span&gt;     });
 });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里有一个小知识点，就是我们的 IUnitOfWork 已经随着 仓储层 依赖注入了，就不许单独注入了，是不是这个时候感觉使用 Autofac 很方便？&lt;/p&gt;
&lt;p&gt;到了这里，修改就完成了，下边就是如何使用了。&lt;/p&gt;



&lt;h3&gt;1、直接操作跨 Service  事务&lt;/h3&gt;
&lt;p&gt;现在我们就可以使用如何使用事务了，第一个简单粗暴的，就是全部写到 controller 里，我已经写好了一个demo，大家来看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依赖注入&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TransactionController(IUnitOfWork unitOfWork, IPasswordLibServices passwordLibServices, IGuestbookServices guestbookServices)
{
    _unitOfWork &lt;/span&gt;=&lt;span&gt; unitOfWork;
    _passwordLibServices &lt;/span&gt;=&lt;span&gt; passwordLibServices;
    _guestbookServices &lt;/span&gt;=&lt;span&gt; guestbookServices;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
{
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始事务&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Begin Transaction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                _unitOfWork.BeginTran();
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; passwords = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _passwordLibServices.Query();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次密码表的数据条数&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first time : the count of passwords is :{passwords.Count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
               
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向密码表添加一条数据&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insert a data into the table PasswordLib now.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; insertPassword = &lt;span&gt;await&lt;/span&gt; _passwordLibServices.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PasswordLib()
                {
                    IsDeleted &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    plAccountName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    plCreateTime &lt;/span&gt;=&lt;span&gt; DateTime.Now
                });

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二次查看密码表有多少条数据，判断是否添加成功&lt;/span&gt;
                passwords = &lt;span&gt;await&lt;/span&gt; _passwordLibServices.Query(d =&amp;gt; d.IsDeleted == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;second time : the count of passwords is :{passwords.Count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;......&lt;/span&gt;
&lt;span&gt;
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; guestbooks = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _guestbookServices.Query();
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first time : the count of guestbooks is :{guestbooks.Count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出现了一个异常！&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nThere's an exception!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; throwEx = &lt;span&gt;1&lt;/span&gt; /&lt;span&gt; ex;

                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insert a data into the table Guestbook now.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; insertGuestbook = &lt;span&gt;await&lt;/span&gt; _guestbookServices.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Guestbook()
                {
                    username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    blogId &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                    createdate &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                    isshow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                });

                guestbooks &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _guestbookServices.Query();
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;second time : the count of guestbooks is :{guestbooks.Count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事务提交&lt;/span&gt;
&lt;span&gt;                _unitOfWork.CommitTran();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
            {
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事务回滚&lt;/span&gt;
&lt;span&gt;                _unitOfWork.RollbackTran();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; passwords = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _passwordLibServices.Query();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三次查看密码表有几条数据，判断是否回滚成功&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;third time : the count of passwords is :{passwords.Count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

               &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; guestbooks = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _guestbookServices.Query();
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;third time : the count of guestbooks is :{guestbooks.Count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;项目的过程，在上边注释已经说明了，大家可以看一下，很简单，就是查询，添加，再查询，判断是否操作成功，那现在我们就测试一下，数据库表是空的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201909/1468246-20190929175950831-1575262568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 然后我们执行方法，动图如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201909/1468246-20190929182511861-1598537061.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;可以看到，我们是密码表已经添加了一条数据的前提下，后来回滚后，数据都被删掉了，数据库也没有对应的值，达到的目的。&lt;/p&gt;
&lt;p&gt;但是这里有两个小问题：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、我们控制的是 Service 类，那我们能不能控制仓储 Repository 类呢？&lt;/p&gt;
&lt;p&gt;2、我们每次都这么写，会不会很麻烦呢，能不能用统一AOP呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案都是肯定的！&lt;/p&gt;

&lt;h3&gt;2、建立事务AOP，解决多仓储内的事务操作&lt;/h3&gt;
&lt;p&gt;在 Blog.Core api 层的 AOP 文件夹下，创建 BlogTranAOP.cs 文件，用来实现事务AOP操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlogTranAOP : IInterceptor
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依赖注入工作单元接口&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IUnitOfWork _unitOfWork;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BlogTranAOP(IUnitOfWork unitOfWork)
        {
            _unitOfWork &lt;/span&gt;=&lt;span&gt; unitOfWork;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实例化IInterceptor唯一方法 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;invocation&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;包含被拦截方法的信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Intercept(IInvocation invocation)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method = invocation.MethodInvocationTarget ??&lt;span&gt; invocation.Method;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对当前方法的特性验证
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要验证&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (method.GetCustomAttributes(&lt;span&gt;true&lt;/span&gt;).FirstOrDefault(x =&amp;gt; x.GetType() == &lt;span&gt;typeof&lt;/span&gt;(UseTranAttribute)) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; UseTranAttribute) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Begin Transaction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    _unitOfWork.BeginTran();

                    invocation.Proceed();


                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步获取异常，普通的 try catch 外层不能达到目的，毕竟是&lt;span&gt;异步&lt;/span&gt;的&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IsAsyncMethod(invocation.Method))
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (invocation.Method.ReturnType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Task))
                        {
                            invocation.ReturnValue &lt;/span&gt;=&lt;span&gt; InternalAsyncHelper.AwaitTaskWithPostActionAndFinally(
                                (Task)invocation.ReturnValue,
                                &lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; TestActionAsync(invocation),
                                ex &lt;/span&gt;=&amp;gt;&lt;span&gt;
                                {
                                    _unitOfWork.RollbackTran();&lt;span&gt;//事务回滚&lt;/span&gt;
                                });
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Task&amp;lt;TResult&amp;gt;&lt;/span&gt;
&lt;span&gt;                        {
                            invocation.ReturnValue &lt;/span&gt;=&lt;span&gt; InternalAsyncHelper.CallAwaitTaskWithPostActionAndFinallyAndGetResult(
                             invocation.Method.ReturnType.GenericTypeArguments[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],
                             invocation.ReturnValue,
                             &lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; TestActionAsync(invocation),
                             ex &lt;/span&gt;=&amp;gt;&lt;span&gt;
                             {
                                 _unitOfWork.RollbackTran();&lt;span&gt;//事务回滚&lt;/span&gt;
                             });
                        }
                    }
                    _unitOfWork.CommitTran();

                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
                {
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Rollback Transaction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    _unitOfWork.RollbackTran();
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                invocation.Proceed();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接执行被拦截方法&lt;/span&gt;
&lt;span&gt;            }

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsAsyncMethod(MethodInfo method)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
                method.ReturnType &lt;/span&gt;== &lt;span&gt;typeof&lt;/span&gt;(Task) ||&lt;span&gt;
                (method.ReturnType.IsGenericType &lt;/span&gt;&amp;amp;&amp;amp; method.ReturnType.GetGenericTypeDefinition() == &lt;span&gt;typeof&lt;/span&gt;(Task&amp;lt;&amp;gt;&lt;span&gt;))
                );
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task TestActionAsync(IInvocation invocation)
        {
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上边具体的操作很简单，如果你看过我的缓存AOP和日志AOP以后，肯定就能看懂这个事务AOP的内容，这里只是有一点，需要增加一个特性，public class UseTranAttribute : Attribute，这个和当时的缓存AOP是一样的，只有配置了才会实现事务提交，具体的请查看 &lt;span&gt;UseTranAttribute&lt;/span&gt;.cs 类。&lt;/p&gt;
&lt;p&gt;然后我们测试一个子仓储项目，具体的代码如下：&lt;/p&gt;
&lt;p&gt;在 Blog.Core.Services 层下的 GuestbookServices.cs 内，增加一个 Task&amp;lt;bool&amp;gt; TestTranInRepositoryAOP() 方法，内容和上边 controller 中的控制 service 类似，只不过是用 Repository 操作类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201909/1468246-20190929190323756-1300213067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;增加事务特性 [&lt;span&gt;UseTran&lt;/span&gt;] ，然后在控制器正常的调用，具体的操作和结果就不展示了，已经测试过了，没问题。&lt;/p&gt;
&lt;p&gt;到这里，就终于解决了事务的相关操作，当然这里还是有很多的问题需要考究，我也在考虑有没有更好的点子和方案，期待后续报道。 &lt;/p&gt;




&lt;p&gt;注意情况分支：&lt;span&gt;Trans1.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/Blog.Core&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/Blog.Core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/laozhangIsPhi/Blog.Core&quot; target=&quot;_blank&quot;&gt;https://gitee.com/laozhangIsPhi/Blog.Core&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 30 Sep 2019 00:37:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>一、项目说明 哈喽，又来写文章了，原来放假可以这么爽，可以学习和分享，&amp;#129323;嘘，大家要好好的工作哟。昨天发表的问题，嗯，给我留下了一点点冲击，夜里辗转反侧，想了很多，从好到坏再到好再到坏，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/laozhang-is-phi/p/11605436.html</dc:identifier>
</item>
<item>
<title>面试并发volatile关键字时，我们应该具备哪些谈资？ - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/11610855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/11610855.html</guid>
<description>&lt;p&gt;&lt;strong&gt;提前发现更多精彩内容，请访问 &lt;a href=&quot;https://dayarch.top/&quot;&gt;个人博客&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;提前发现更多精彩内容，请访问 &lt;a href=&quot;https://dayarch.top/&quot;&gt;个人博客&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;提前发现更多精彩内容，请访问 &lt;a href=&quot;https://dayarch.top/&quot;&gt;个人博客&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&quot;https://dayarch.top/2019/09/12/you-xu-xing-ke-jian-xing-happens-before-lai-gao-ding/&quot;&gt;可见性有序性，Happens-before来搞定&lt;/a&gt; 文章中，happens-before 的原则之一: volatile变量规则&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按理说了解了这个规则，对 volatile 的使用就已经足够了，但是面试官可是喜欢刨根问到底的，为了更透彻的了解 volatile 的内存语义与读写语义，为了面试多一些谈资进而获得一些加分项，同时尽早填补前序文章留下的坑，于是乎这篇文章就这样尴尬的诞生了&lt;/p&gt;
&lt;h2 id=&quot;happens-before-之-volatile-变量规则&quot;&gt;happens-before 之 volatile 变量规则&lt;/h2&gt;
&lt;p&gt;下面的表格你还记得吗？(是的，你记得😂)&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;第一个操作&lt;/td&gt;
&lt;td&gt;普通读/写&lt;/td&gt;
&lt;td&gt;volatile 读&lt;/td&gt;
&lt;td&gt;volatile 写&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;普通读/写&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;volatile 读&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;volatile 写&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面的表格是 JMM 针对编译器定制的 volatile 重排序的规则，那 JMM 是怎样禁止重排序的呢？答案是&lt;strong&gt;内存屏障&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;内存屏障-memory-barriers-fences&quot;&gt;内存屏障 (Memory Barriers / Fences)&lt;/h2&gt;
&lt;p&gt;无论你听过这个名词与否都没关系，很简单，且看&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话有点抽象，试着想象内存屏障是一面高墙，如果两个变量之间有这个屏障，那么他们就不能互换位置(重排序)了，变量有读(Load)有写(Store)，操作有前有后，JMM 就将内存屏障插入策略分为 4 种:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在每个 volatile 写操作的前面插入一个 StoreStore 屏障&lt;/li&gt;
&lt;li&gt;在每个 volatile 写操作的后面插入一个 StoreLoad 屏障&lt;/li&gt;
&lt;li&gt;在每个 volatile 读操作的后面插入一个 LoadLoad 屏障&lt;/li&gt;
&lt;li&gt;在每个 volatile 读操作的后面插入一个 LoadStore 屏障&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;1 和 2 用图形描述以及对应表格规则就是下面这个样子了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190930082902457-681497965.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3 和 4 用图形描述以及对应表格规则就是下面这个样子了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190930082903800-760097773.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其实图形也是表格内容的体现，只不过告诉大家内存屏障是如何禁止指令重排序的，所以大家只要牢记表格内容即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一段程序的读写通常不会像上面两种情况这样简单，这些屏障组合起来如何使用呢？其实一点都不难，我们只需要将这些指令带入到文章开头的表格中，然后再按照程序顺序拼接指令就好了&lt;/p&gt;
&lt;p&gt;来看一小段程序:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class VolatileBarrierExample {

    private int a;
    private volatile int v1 = 1;
    private volatile int v2 = 2;

    void readAndWrite(){
        int i = v1; //第一个volatile读
        int j = v2; //第二个volatile读
        a = i + j;  //普通写
        v1 = i + 1; //第一个volatile写
        v2 = j * 2; //第二个volatile写
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将屏障指令带入到程序就是这个样子:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190930082905867-738431879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将上图分几个角度来看:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;彩色是将屏障指令带入到程序中生成的全部内容，也就是编译器生成的&lt;strong&gt;「最稳妥」&lt;/strong&gt;的方案&lt;/li&gt;
&lt;li&gt;显然有很多屏障是重复多余的，右侧虚线框指向的屏障是可以被&lt;strong&gt;「优化」&lt;/strong&gt;删除掉的屏障&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到这里你应该了解了 volatile 是如何通过内存屏障保证程序不被&quot;擅自&quot;排序的，那 volatile 是如何保证可见性的呢？&lt;/p&gt;
&lt;h2 id=&quot;volatile-写-读的内存语义&quot;&gt;volatile 写-读的内存语义&lt;/h2&gt;
&lt;p&gt;回顾一下之前文章内容中的程序，假定线程 A 先执行 writer 方法，随后线程 B 执行 reader 方法，:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ReorderExample {

    private int x = 0;
    private int y = 1;
    private volatile boolean flag = false;

    public void writer(){
        x = 42; //1
        y = 50; //2
        flag = true;    //3
    }

    public void reader(){
        if (flag){  //4
            System.out.println(&quot;x:&quot; + x);   //5
            System.out.println(&quot;y:&quot; + y);   //6
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里你是否还记得之前说过的 JMM，是的，你还记得😂，当线程 A 执行 writer 方法时，且看下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190930082906449-849548855.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程 A 将本地内存更改的变量写回到主内存中&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;h3 id=&quot;volatile-读的内存语义&quot;&gt;volatile 读的内存语义:&lt;/h3&gt;
&lt;p&gt;当读一个 volatile 变量时, JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以当线程 B 执行 reader 方法时，图形结构就变成了这个样子:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190930082907159-1356957098.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程 B 本地内存变量无效，从主内存中读取变量到本地内存中，也就得到了线程 A 更改后的结果，这就是 volatile 是如何保证可见性的&lt;/p&gt;
&lt;p&gt;如果你看过前面的文章你就不难理解上面的两张图了，综合起来说:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程 A 写一个volatile变量, 实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了(其对共享变量所做修改的)消息&lt;/li&gt;
&lt;li&gt;线程 B 读一个 volatile 变量,实质上是线程 B 接收了之前某个线程发出的(在写这个 volatile 变量之前对共享变量所做修改的)消息。&lt;/li&gt;
&lt;li&gt;线程 A 写一个 volatile 变量, 随后线程 B 读这个 volatile 变量, 这个过程实质上是线程 A 通过主内存向线程B 发送消息。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到这里，面试 volatile 时，你应该有一些谈资了，同时也对 volatile 的语义有了更深层次的了解&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;之前的文章提到过这样一句话:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;从内存语义的角度来说, volatile 的&lt;code&gt;写-读&lt;/code&gt;与锁的&lt;code&gt;释放-获取&lt;/code&gt;有相同的内存效果；volatile 写和锁的释放有相同的内存语义; volatile 读与锁的获取有相同的内存语义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记住文中最后两张图， 当我们说到 synchronized 的时候，你就会猛的理解这句话的含义了, 感兴趣的可以自己先了解 synchronized 的写-读语义&lt;/p&gt;
&lt;p&gt;接下来我们就聊一聊锁相关的内容了，敬请期待...&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;如果 volatile 写之后直接 return，那还会生成 StoreLoad 指令吗？&lt;/li&gt;
&lt;li&gt;synchronized 是怎样逐步被优化的？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;提高效率工具&quot;&gt;提高效率工具&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190930082907383-221945708.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tool.lu&quot;&gt;tool.lu&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://tool.lu&quot; class=&quot;uri&quot;&gt;https://tool.lu&lt;/a&gt; 是一款集成了非常多功能的在线工具，基本满足日常开发所需&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190930082914498-1015843942.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;欢迎持续关注公众号日拱一兵&quot;&gt;欢迎持续关注公众号：「日拱一兵」&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;前沿 Java 技术干货分享&lt;/li&gt;
&lt;li&gt;高效工具汇总 | 回复「工具」&lt;/li&gt;
&lt;li&gt;面试问题分析与解答&lt;/li&gt;
&lt;li&gt;技术资料领取 | 回复「资料」&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190930082915462-420578354.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Sep 2019 00:29:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>提前发现更多精彩内容，请访问 '个人博客' 提前发现更多精彩内容，请访问 '个人博客' 提前发现更多精彩内容，请访问 '个人博客' 写在前面 在 '可见性有序性，Happens before来搞定'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/11610855.html</dc:identifier>
</item>
<item>
<title>11.Django基础九之中间件 - changxin7</title>
<link>http://www.cnblogs.com/changxin7/p/11610813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/changxin7/p/11610813.html</guid>
<description>&lt;h2 id=&quot;一-前戏&quot;&gt;一 前戏&lt;/h2&gt;

&lt;p&gt;　　我们在前面的课程中已经学会了给视图函数加装饰器来判断是用户是否登录，把没有登录的用户请求跳转到登录页面。我们通过给几个特定视图函数加装饰器实现了这个需求。但是以后添加的视图函数可能也需要加上装饰器，这样是不是稍微有点繁琐。&lt;/p&gt;
&lt;p&gt;　　学完今天的内容之后呢，我们就可以用更适宜的方式来实现类似给所有请求都做相同操作的功能了&lt;/p&gt;

&lt;h2 id=&quot;二-中间件介绍&quot;&gt;二 中间件介绍&lt;/h2&gt;

&lt;p&gt;　　中间件顾名思义，是介于request与response处理之间的一道处理过程，相对比较轻量级，并且在全局上改变django的输入与输出。因为改变的是全局，所以需要谨慎实用，用不好会影响到性能。&lt;/p&gt;
&lt;p&gt;　　Django的中间件的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Middleware is a framework of hooks into Django’s request/response processing. &amp;lt;br&amp;gt;It’s a light, low-level “plugin” system for globally altering Django’s input or output.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　如果你想修改请求，例如被传送到view中的&lt;strong&gt;HttpRequest&lt;/strong&gt;对象。 或者你想修改view返回的&lt;strong&gt;HttpResponse&lt;/strong&gt;对象，这些都可以通过中间件来实现。&lt;/p&gt;
&lt;p&gt;　　可能你还想在view执行之前做一些操作，这种情况就可以用 middleware来实现。&lt;/p&gt;
&lt;p&gt;　　说的直白一点中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个方法，Django框架会在请求的特定的时间去执行这些方法。&lt;/p&gt;
&lt;p&gt;　　我们一直都在使用中间件，只是没有注意到而已，打开Django项目的Settings.py文件，看到下面的MIDDLEWARE配置项，django默认自带的一些中间件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　MIDDLEWARE配置项是一个列表，列表中是一个个字符串，这些字符串其实是一个个类，也就是一个个中间件。&lt;/p&gt;
&lt;p&gt;　　我们之前已经接触过一个csrf相关的中间件了？我们一开始让大家把他注释掉，再提交post请求的时候，就不会被forbidden了，后来学会使用csrf_token之后就不再注释这个中间件了。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201903/988061-20190307152249812-1922952163.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那接下来就学习中间件中的方法以及这些方法什么时候被执行。&lt;/p&gt;
&lt;h2 id=&quot;三-自定义中间件&quot;&gt;三 自定义中间件&lt;/h2&gt;
&lt;p&gt;想多了解中间，在&lt;a href=&quot;https://my.oschina.net/zfschool/blog/789541&quot;&gt;开源中国&lt;/a&gt;中有很多关于中间件的&lt;a href=&quot;https://my.oschina.net/liuyuantao/blog/756778&quot;&gt;详细解释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　中间件可以定义五个方法，分别是：（主要的是process_request和process_response）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;process_request(self,request)&lt;/li&gt;
&lt;li&gt;process_view(self, request, view_func, view_args, view_kwargs)&lt;/li&gt;
&lt;li&gt;process_template_response(self,request,response)&lt;/li&gt;
&lt;li&gt;process_exception(self, request, exception)&lt;/li&gt;
&lt;li&gt;process_response(self, request, response)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象，则直接将该对象返回给用户。&lt;/p&gt;
&lt;p&gt;　　当用户发起请求的时候会依次经过所有的的中间件，这个时候的请求时process_request,最后到达views的函数中，views函数处理后，在依次穿过中间件，这个时候是process_response,最后返回给请求者。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/877318/201710/877318-20171012212952512-1143032176.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上述截图中的中间件都是django中的，我们也可以自己定义一个中间件，我们可以自己写一个类，但是必须继承MiddlewareMixin&lt;/p&gt;
&lt;h3 id=&quot;自定义一个中间件示例&quot;&gt;自定义一个中间件示例&lt;/h3&gt;
&lt;p&gt;　　　　目录：&lt;/p&gt;
&lt;p&gt;　　　　　　在项目中创建一个包，随便起名字，一般都放在一个叫做utils的包里面，表示一个公用的组件，创建一个py文件，随便起名字，例如叫做：middlewares.py，内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.utils.deprecation import MiddlewareMixin

class MD1(MiddlewareMixin):
    #自定义中间件，不是必须要有下面这两个方法，有request方法说明请求来了要处理，有response方法说明响应出去时需要处理，不是非要写这两个方法，如果你没写process_response方法，那么会一层一层的往上找，哪个中间件有process_response方法就将返回对象给哪个中间件
    def process_request(self, request):
        print(&quot;MD1里面的 process_request&quot;)

    def process_response(self, request, response):
        print(&quot;MD1里面的 process_response&quot;)
        return response&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;process_request&quot;&gt;process_request&lt;/h3&gt;
&lt;p&gt;　　　　　　process_request有一个参数，就是request，这个request和视图函数中的request是一样的。&lt;/p&gt;
&lt;p&gt;　　　　　　它的返回值可以是None也可以是HttpResponse对象。返回值是None的话，按正常流程继续走，交给下一个中间件处理，如果是HttpResponse对象，Django将不执行视图函数，而将相应对象返回给浏览器。&lt;/p&gt;
&lt;p&gt;　　　　　　我们来看看多个中间件时，Django是如何执行其中的process_request方法的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.utils.deprecation import MiddlewareMixin


class MD1(MiddlewareMixin):

    def process_request(self, request):
        print(&quot;MD1里面的 process_request&quot;)


class MD2(MiddlewareMixin):
    def process_request(self, request):
        print(&quot;MD2里面的 process_request&quot;)
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　在settings.py的MIDDLEWARE配置项中注册上述两个自定义中间件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'middlewares.MD1',  # 自定义中间件MD1，这个写的是你项目路径下的一个路径，例如，如果你放在项目下，文件夹名成为utils，那么这里应该写utils.middlewares.MD1
    'middlewares.MD2'  # 自定义中间件MD2
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　此时，我们访问一个视图，会发现终端中打印如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MD1里面的 process_request
MD2里面的 process_requestapp01 中的 index视图&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　把MD1和MD2的位置调换一下，再访问一个视图，会发现终端中打印的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MD2里面的 process_request
MD1里面的 process_requestapp01 中的 index视图&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　看结果我们知道：视图函数还是最后执行的，MD2比MD1先执行自己的process_request方法。&lt;/p&gt;
&lt;p&gt;　　　　　　在打印一下两个自定义中间件中process_request方法中的request参数，会发现它们是同一个对象。&lt;/p&gt;
&lt;p&gt;　　　　　　由此总结一下：&lt;/p&gt;
&lt;p&gt;　　　　　　　　中间件的process_request方法是在执行视图函数之前执行的。&lt;/p&gt;
&lt;p&gt;　　　　　　　　当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。&lt;/p&gt;
&lt;p&gt;　　　　　　　　不同中间件之间传递的request都是同一个对象&lt;/p&gt;
&lt;p&gt;　　　　　　多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序&lt;strong&gt;倒序&lt;/strong&gt;执行的，也就是说第一个中间件的process_request方法首先执行，而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。&lt;/p&gt;
&lt;h3 id=&quot;process_response&quot;&gt;process_response&lt;/h3&gt;
&lt;p&gt;　　　　　　它有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。该方法的返回值也必须是HttpResponse对象。&lt;/p&gt;
&lt;p&gt;　　　　　　给上述的M1和M2加上process_response方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.utils.deprecation import MiddlewareMixin


class MD1(MiddlewareMixin):

    def process_request(self, request):
        print(&quot;MD1里面的 process_request&quot;)
        #不必须写return值
    def process_response(self, request, response):#request和response两个参数必须有，名字随便取
        print(&quot;MD1里面的 process_response&quot;)        #print(response.__dict__['_container'][0].decode('utf-8')) #查看响应体里面的内容的方法，或者直接使用response.content也可以看到响应体里面的内容，由于response是个变量，直接点击看源码是看不到的，你打印type(response)发现是HttpResponse对象，查看这个对象的源码就知道有什么方法可以用了。
　　　　 return response  #必须有返回值，写return response  ，这个response就像一个接力棒一样
        #return HttpResponse('瞎搞') ,如果你写了这个，那么你视图返回过来的内容就被它给替代了

class MD2(MiddlewareMixin):
    def process_request(self, request):
        print(&quot;MD2里面的 process_request&quot;)
        pass

    def process_response(self, request, response): #request和response两个参数必须要有，名字随便取
        print(&quot;MD2里面的 process_response&quot;) 
        return response  #必须返回response，不然你上层的中间件就没有拿到httpresponse对象，就会报错&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　访问一个视图，看一下终端的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MD2里面的 process_request
MD1里面的 process_request
app01 中的 index视图
MD1里面的 process_response
MD2里面的 process_response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　看结果可知：&lt;/p&gt;
&lt;p&gt;　　　　　　process_response方法是在视图函数之后执行的，并且顺序是MD1比MD2先执行。(此时settings.py中 MD2比MD1先注册)&lt;/p&gt;
&lt;p&gt;　　　　　　多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序&lt;strong&gt;倒序&lt;/strong&gt;执行的，也就是说第一个中间件的process_request方法首先执行，而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。&lt;/p&gt;
&lt;p&gt;　　　　　　再看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.utils.deprecation import MiddlewareMixin
from django.shortcuts import HttpResponse

class Md1(MiddlewareMixin):

    def process_request(self,request):
        print(&quot;Md1请求&quot;)　　　　 #process_request方法里面不写返回值，默认也是返回None，如果你自己写了return None，也是一样的效果，不会中断你的请求，但是如果你return 的一个httpresponse对象，那么就会在这个方法中断你的请求，直接返回给用户，这就成了非正常的流程了        #并且，如果你在这里return了httpresponse对象，那么会从你这个中间件类中的process_response方法开始执行返回操作，所以这个类里面只要有process_response方法，肯定会执行
 
    def process_response(self,request,response):
        print(&quot;Md1返回&quot;)
        return response

class Md2(MiddlewareMixin):

    def process_request(self,request):
        print(&quot;Md2请求&quot;)
        #return HttpResponse(&quot;Md2中断&quot;)
    def process_response(self,request,response):
        print(&quot;Md2返回&quot;)
        return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Md1请求
Md2请求
view函数...
Md2返回
Md1返回&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　&lt;strong&gt;注意：&lt;/strong&gt;如果当请求到达请求2的时候直接不符合条件返回，即&lt;strong&gt;return HttpResponse(&quot;Md2中断&quot;)&lt;/strong&gt;，程序将把请求直接发给中间件2返回，然后依次返回到请求者，结果如下：&lt;/p&gt;
&lt;p&gt;　　　　返回Md2中断的页面，后台打印如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Md1请求
Md2请求
Md2返回
Md1返回&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　&lt;strong&gt;流程图如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201805/877318-20180523153139864-2049371026.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　之前我们做的cookie认证，都是通过在函数上面加装饰器搞的，比较麻烦，看看中间件怎么搞，如果写的是session认证的，你必须放在django自带的session中间件的下面，所以自定义中间之后，你需要注意你的中间件的摆放顺序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class M1(MiddlewareMixin):

    def process_request(self,request):

        #设置路径白名单，只要访问的是login登陆路径，就不做这个cookie认证
        if request.path not in [reverse('login'),]:
            print('我是M1中间件') #客户端IP地址
            # return HttpResponse('sorry,没有通过我的M1中间件')
            is_login = request.COOKIES.get('is_login', False)

            if is_login:
                pass
            else:
                # return render(request,'login.html')
                return redirect(reverse('login'))
        else:
            return None #别忘了return None，或者直接写个pass

    def process_response(self,request,response):

        print('M1响应部分')
        # print(response.__dict__['_container'][0].decode('utf-8'))
        return response
        # return HttpResponse('瞎搞')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　练习：尝试一下通过中间件来控制用户的访问次数，让用户在一分钟之内不能访问我的网站超过20次。&lt;/p&gt;
&lt;p&gt;　　　　后面要学的方法不常用，但是大家最好也要知道。&lt;/p&gt;
&lt;h3 id=&quot;process_view&quot;&gt;process_view&lt;/h3&gt;
&lt;p&gt;　　　　　　process_view(self, request, view_func, view_args, view_kwargs)&lt;/p&gt;
&lt;p&gt;　　　　　　该方法有四个参数&lt;/p&gt;
&lt;p&gt;　　　　　　request是HttpRequest对象。&lt;/p&gt;
&lt;p&gt;　　　　　　view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）&lt;/p&gt;
&lt;p&gt;　　　　　　view_args是将传递给视图的位置参数的列表.&lt;/p&gt;
&lt;p&gt;　　　　　　view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。&lt;/p&gt;
&lt;p&gt;　　　　　　Django会在调用视图函数之前调用process_view方法。&lt;/p&gt;
&lt;p&gt;　　　　　　它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用对应的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201805/877318-20180523150722556-373788290.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　给MD1和MD2添加process_view方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.utils.deprecation import MiddlewareMixin


class MD1(MiddlewareMixin):

    def process_request(self, request):
        print(&quot;MD1里面的 process_request&quot;)

    def process_response(self, request, response):
        print(&quot;MD1里面的 process_response&quot;)
        return response

    def process_view(self, request, view_func, view_args, view_kwargs):
        print(&quot;-&quot; * 80)
        print(&quot;MD1 中的process_view&quot;)
        print(view_func, view_func.__name__) #就是url映射到的那个视图函数，也就是说每个中间件的这个process_view已经提前拿到了要执行的那个视图函数        #ret = view_func(request) #提前执行视图函数，不用到了上图的试图函数的位置再执行，如果你视图函数有参数的话，可以这么写 view_func(request,view_args,view_kwargs) 
        #return ret  #直接就在MD1中间件这里这个类的process_response给返回了，就不会去找到视图函数里面的这个函数去执行了。

class MD2(MiddlewareMixin):
    def process_request(self, request):
        print(&quot;MD2里面的 process_request&quot;)
        pass

    def process_response(self, request, response):
        print(&quot;MD2里面的 process_response&quot;)
        return response

    def process_view(self, request, view_func, view_args, view_kwargs):
        print(&quot;-&quot; * 80)
        print(&quot;MD2 中的process_view&quot;)
        print(view_func, view_func.__name__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　访问index视图函数，看一下输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MD2里面的 process_request
MD1里面的 process_request
--------------------------------------------------------------------------------
MD2 中的process_view
&amp;lt;function index at 0x000001DE68317488&amp;gt; index
--------------------------------------------------------------------------------
MD1 中的process_view
&amp;lt;function index at 0x000001DE68317488&amp;gt; index
app01 中的 index视图
MD1里面的 process_response
MD2里面的 process_response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　process_view方法是在process_request之后，reprocess_response之前，视图函数之前执行的，执行顺序按照MIDDLEWARE中的注册顺序&lt;strong&gt;从前到后顺序&lt;/strong&gt;执行的&lt;/p&gt;
&lt;p&gt;　　　　　 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201903/988061-20190307175159136-388101846.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;process_exception&quot;&gt;process_exception&lt;/h3&gt;
&lt;p&gt;　　　　　　process_exception(self, request, exception)&lt;/p&gt;
&lt;p&gt;　　　　　　该方法两个参数:&lt;/p&gt;
&lt;p&gt;　　　　　　一个HttpRequest对象&lt;/p&gt;
&lt;p&gt;　　　　　　一个exception是视图函数异常产生的Exception对象。&lt;/p&gt;
&lt;p&gt;　　　　　　这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的倒序执行。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201805/877318-20180523152523125-1475347796.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　给MD1和MD2添加上这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.utils.deprecation import MiddlewareMixin


class MD1(MiddlewareMixin):

    def process_request(self, request):
        print(&quot;MD1里面的 process_request&quot;)

    def process_response(self, request, response):
        print(&quot;MD1里面的 process_response&quot;)
        return response

    def process_view(self, request, view_func, view_args, view_kwargs):
        print(&quot;-&quot; * 80)
        print(&quot;MD1 中的process_view&quot;)
        print(view_func, view_func.__name__)

    def process_exception(self, request, exception):
        print(exception)
        print(&quot;MD1 中的process_exception&quot;)


class MD2(MiddlewareMixin):
    def process_request(self, request):
        print(&quot;MD2里面的 process_request&quot;)
        pass

    def process_response(self, request, response):
        print(&quot;MD2里面的 process_response&quot;)
        return response

    def process_view(self, request, view_func, view_args, view_kwargs):
        print(&quot;-&quot; * 80)
        print(&quot;MD2 中的process_view&quot;)
        print(view_func, view_func.__name__)

    def process_exception(self, request, exception):
        print(exception)
        print(&quot;MD2 中的process_exception&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　如果视图函数中无异常，process_exception方法不执行。&lt;/p&gt;
&lt;p&gt;　　　　　　想办法，在视图函数中抛出一个异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def index(request):
    print(&quot;app01 中的 index视图&quot;)
    raise ValueError(&quot;呵呵&quot;)
    return HttpResponse(&quot;O98K&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　在MD1的process_exception中返回一个响应对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MD1(MiddlewareMixin):

    def process_request(self, request):
        print(&quot;MD1里面的 process_request&quot;)

    def process_response(self, request, response):
        print(&quot;MD1里面的 process_response&quot;)
        return response

    def process_view(self, request, view_func, view_args, view_kwargs):
        print(&quot;-&quot; * 80)
        print(&quot;MD1 中的process_view&quot;)
        print(view_func, view_func.__name__)

    def process_exception(self, request, exception):
        print(exception)
        print(&quot;MD1 中的process_exception&quot;)
        return HttpResponse(str(exception))  # 返回一个响应对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　看输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MD2里面的 process_request
MD1里面的 process_request
--------------------------------------------------------------------------------
MD2 中的process_view
&amp;lt;function index at 0x0000022C09727488&amp;gt; index
--------------------------------------------------------------------------------
MD1 中的process_view
&amp;lt;function index at 0x0000022C09727488&amp;gt; index
app01 中的 index视图
呵呵
MD1 中的process_exception
MD1里面的 process_response
MD2里面的 process_response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201903/988061-20190307234702348-264207907.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　注意，这里并没有执行MD2的process_exception方法，因为MD1中的process_exception方法直接返回了一个响应对象。&lt;/p&gt;
&lt;h3 id=&quot;process_template_response用的比较少&quot;&gt;&lt;strong&gt;process_template_response（用的比较少）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　process_template_response(self, request, response)&lt;/p&gt;
&lt;p&gt;　　　　　　它的参数，一个HttpRequest对象，response是TemplateResponse对象（由视图函数或者中间件产生）。&lt;/p&gt;
&lt;p&gt;　　　　　　process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法（或者表明该对象是一个TemplateResponse对象或等价方法）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MD1(MiddlewareMixin):

    def process_request(self, request):
        print(&quot;MD1里面的 process_request&quot;)

    def process_response(self, request, response):
        print(&quot;MD1里面的 process_response&quot;)
        return response

    def process_view(self, request, view_func, view_args, view_kwargs):
        print(&quot;-&quot; * 80)
        print(&quot;MD1 中的process_view&quot;)
        print(view_func, view_func.__name__)

    def process_exception(self, request, exception):
        print(exception)
        print(&quot;MD1 中的process_exception&quot;)
        return HttpResponse(str(exception))

    def process_template_response(self, request, response):
        print(&quot;MD1 中的process_template_response&quot;)
        return response


class MD2(MiddlewareMixin):
    def process_request(self, request):
        print(&quot;MD2里面的 process_request&quot;)
        pass

    def process_response(self, request, response):
        print(&quot;MD2里面的 process_response&quot;)
        return response

    def process_view(self, request, view_func, view_args, view_kwargs):
        print(&quot;-&quot; * 80)
        print(&quot;MD2 中的process_view&quot;)
        print(view_func, view_func.__name__)

    def process_exception(self, request, exception):
        print(exception)
        print(&quot;MD2 中的process_exception&quot;)

    def process_template_response(self, request, response):
        print(&quot;MD2 中的process_template_response&quot;)
        return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　views.py中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def index(request):
    print(&quot;app01 中的 index视图&quot;)
　　#raise ValueError('出错啦') 
    def render():
        print(&quot;in index/render&quot;)          #raise ValueError('出错啦') #至于render函数中报错了，那么会先执行process_template_response方法，然后执行process_exception方法，如果是在render方法外面报错了，那么就不会执行这个process_template_response方法了。
        return HttpResponse(&quot;O98K&quot;) #返回的将是这个新的对象
    rep = HttpResponse(&quot;OK&quot;)
    rep.render = render
    return rep&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　访问index视图，终端输出的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MD2里面的 process_request
MD1里面的 process_request
--------------------------------------------------------------------------------
MD2 中的process_view
&amp;lt;function index at 0x000001C111B97488&amp;gt; index
--------------------------------------------------------------------------------
MD1 中的process_view
&amp;lt;function index at 0x000001C111B97488&amp;gt; index
app01 中的 index视图
MD2 中的process_template_response
MD1 中的process_template_response
in index/render
MD1里面的 process_response
MD2里面的 process_response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　从结果看出：&lt;/p&gt;
&lt;p&gt;　　　　　　视图函数执行完之后，立即执行了中间件的process_template_response方法，顺序是倒序，先执行MD2的，在执行MD1的，接着执行了视图函数返回的HttpResponse对象的render方法，返回了一个新的HttpResponse对象，接着执行中间件的process_response方法。&lt;/p&gt;
&lt;h2 id=&quot;四-中间件执行流程&quot;&gt;四 中间件执行流程&lt;/h2&gt;
&lt;p&gt;　　上一部分，我们了解了中间件中的5个方法，它们的参数、返回值以及什么时候执行，现在总结一下中间件的执行流程。&lt;/p&gt;
&lt;p&gt;　　请求到达中间件之后，先按照正序执行每个注册中间件的process_reques方法，process_request方法返回的值是None，就依次执行，如果返回的值是HttpResponse对象，不再执行后面的process_request方法，而是执行当前对应中间件的process_response方法，将HttpResponse对象返回给浏览器。也就是说：如果MIDDLEWARE中注册了6个中间件，执行过程中，第3个中间件返回了一个HttpResponse对象，那么第4,5,6中间件的process_request和process_response方法都不执行，顺序执行3,2,1中间件的process_response方法。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409214209079-1725524152.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　process_request方法都执行完后，匹配路由，找到要执行的视图函数，先不执行视图函数，先执行中间件中的process_view方法，process_view方法返回None，继续按顺序执行，所有process_view方法执行完后执行视图函数。加入中间件3 的process_view方法返回了HttpResponse对象，则4,5,6的process_view以及视图函数都不执行，直接从最后一个中间件，也就是中间件6的process_response方法开始倒序执行。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409214307195-1684061444.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　process_template_response和process_exception两个方法的触发是有条件的，执行顺序也是倒序。总结所有的执行流程如下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409214356226-286908304.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409214433968-2137571775.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五-中间件版登陆认证&quot;&gt;五 中间件版登陆认证&lt;/h2&gt;
&lt;p&gt;中间件版的登录验证需要依靠session，所以数据库中要有django_session表。&lt;/p&gt;
&lt;p&gt;　　　　urls.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url
from app01 import views

urlpatterns = [
    url(r'^index/$', views.index),
    url(r'^login/$', views.login, name='login'),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　views.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.shortcuts import render, HttpResponse, redirect


def index(request):
    return HttpResponse('this is index')


def home(request):
    return HttpResponse('this is home')


def login(request):
    if request.method == &quot;POST&quot;:
        user = request.POST.get(&quot;user&quot;)
        pwd = request.POST.get(&quot;pwd&quot;)

        if user == &quot;Q1mi&quot; and pwd == &quot;123456&quot;:
            # 设置session
            request.session[&quot;user&quot;] = user
            # 获取跳到登陆页面之前的URL
            next_url = request.GET.get(&quot;next&quot;)
            # 如果有，就跳转回登陆之前的URL
            if next_url:
                return redirect(next_url)
            # 否则默认跳转到index页面
            else:
                return redirect(&quot;/index/&quot;)
    return render(request, &quot;login.html&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　login.html&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
    &amp;lt;title&amp;gt;登录页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form action=&quot;{% url 'login' %}&quot;&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label for=&quot;user&quot;&amp;gt;用户名：&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;text&quot; name=&quot;user&quot; id=&quot;user&quot;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label for=&quot;pwd&quot;&amp;gt;密 码：&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;text&quot; name=&quot;pwd&quot; id=&quot;pwd&quot;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;登录&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　middlewares.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class AuthMD(MiddlewareMixin):
    white_list = ['/login/', ]  # 白名单
    balck_list = ['/black/', ]  # 黑名单

    def process_request(self, request):
        from django.shortcuts import redirect, HttpResponse

        next_url = request.path_info
        print(request.path_info, request.get_full_path())

        if next_url in self.white_list or request.session.get(&quot;user&quot;):
            return
        elif next_url in self.balck_list:
            return HttpResponse('This is an illegal URL')
        else:
            return redirect(&quot;/login/?next={}&quot;.format(next_url))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　在settings.py中注册&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'middlewares.AuthMD',
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　AuthMD中间件注册后，所有的请求都要走AuthMD的process_request方法。&lt;/p&gt;
&lt;p&gt;　　　　访问的URL在白名单内或者session中有user用户名，则不做阻拦走正常流程；&lt;/p&gt;
&lt;p&gt;　　　　如果URL在黑名单中，则返回This is an illegal URL的字符串；&lt;/p&gt;
&lt;p&gt;　　　　正常的URL但是需要登录后访问，让浏览器跳转到登录页面。&lt;/p&gt;
&lt;p&gt;　　　　注：AuthMD中间件中需要session，所以AuthMD注册的位置要在session中间的下方。&lt;/p&gt;
&lt;p&gt;　　　　附：Django请求流程图&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409234112982-196913305.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六-中间件案例&quot;&gt;六 中间件案例&lt;/h2&gt;
&lt;h3 id=&quot;应用案例&quot;&gt;应用案例&lt;/h3&gt;
&lt;h4 id=&quot;做ip访问频率限制&quot;&gt;&lt;strong&gt;1、做IP访问频率限制&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　　　　　某些IP访问服务器的频率过高，进行拦截，比如限制每分钟不能超过20次。&lt;/p&gt;
&lt;h4 id=&quot;url访问过滤&quot;&gt;&lt;strong&gt;2、URL访问过滤&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　　　　　如果用户访问的是login视图（放过）&lt;/p&gt;
&lt;p&gt;　　　　　　如果访问其他视图，需要检测是不是有session认证，已经有了放行，没有返回login，这样就省得在多个视图函数上写装饰器了！&lt;/p&gt;
&lt;h3 id=&quot;源码试读&quot;&gt;源码试读&lt;/h3&gt;
&lt;p&gt;　　　　作为延伸扩展内容，有余力的同学可以尝试着读一下以下两个自带的中间件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'django.contrib.sessions.middleware.SessionMiddleware',
'django.contrib.auth.middleware.AuthenticationMiddleware',&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Sun, 29 Sep 2019 23:55:00 +0000</pubDate>
<dc:creator>changxin7</dc:creator>
<og:description>一 前戏 我们在前面的课程中已经学会了给视图函数加装饰器来判断是用户是否登录，把没有登录的用户请求跳转到登录页面。我们通过给几个特定视图函数加装饰器实现了这个需求。但是以后添加的视图函数可能也需要加上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/changxin7/p/11610813.html</dc:identifier>
</item>
<item>
<title>[ 测试思考 ] 效率提升测试工具开发的思考 - BengDou_Do&amp;Think</title>
<link>http://www.cnblogs.com/linyfeng/p/11610780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linyfeng/p/11610780.html</guid>
<description>&lt;p&gt;&lt;span&gt;  本文针对测试部效率提升测试工具开发、管理、维护暴露出来的问题的一些思考以及一些个人改进观点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  本文提到的效率提升测试工具不是指的部门中固有的自动化测试工具，这里提到的测试工具统一指&lt;strong&gt;测试人员在工作之余&lt;/strong&gt;自主开发用于期望替代重复、繁琐、耗时的手工操作的测试工具，开发的目的是希望提升测试工作效率。不是针对专业工具开发部门团队的测试工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;测试工具管理暴露的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  总体来说，测试内部发布的用于效率提升的测试工具整体质量不高，工具功能、性能、易用性、可维护性质量都不高。大部分测试工具通常都是谁开发的谁用的比较顺手，&lt;span&gt;工具推广度不高。&lt;/span&gt;并没有真正让部门其他测试人员效率得到提升。针对这些问题简单调研了一下身边的同事原因，主要以下几个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  1、工具不知道从哪里可以获取。这是测试部&lt;strong&gt;工具管理的问题。&lt;/strong&gt;没有统一的发布路径、测试人员不知道当前测试部都有哪些测试工具可以用，不知道从哪里可以获取到&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2、工具不会用。测试人员拿到工具不知道怎么使用。对一些相对复杂功能的测试工具没有使用指导书、没有联机帮助。甚至有一些工具开发的菜单、标签、工具名称起的都很含糊。不知道这个工具是要干嘛的。这些通常都是测试人员在开发工具时不考虑工具的易用性问题导致其他测试人员很难上手使用。举个例子，测试工具开发人员用 Python开发了一个windows平台工具但是并没有编译成可执行的.exe程序发布，其他人很难用，首先可能要下载python程序、其他要下载程序依赖的各种类库。用个工具这么麻烦很多人就不想用了。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3、工具不好用、经常出现问题。测试工具开发在实现工具时可能只针对某一个具体的场景、某一个具体的业务版本进行开发导致工具并不具备推广性。另外，一些工具交互太多&lt;span&gt;甚至使用时有一些依赖外部条件需要设置程序才能正常执行等等都是导致不好用、没人用的原因。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4、工具很难维护（可维护性问题）。工具开发人员技能不一、能力高低有区别、对编码规范的遵循程度也不一样。实现工具开发的语言多样化，主流的开发语言Python、Java等还好，如果是AutoIt、vbs等这些比较少用的语言开发的工具后期维护就很麻烦甚至就没人维护了。另外，测试人员毕竟没有对编码规范有很好的理解，代码怎么写的都有、几千行代码注释几乎为0，也没有开发文档说明，维护起来特别困难。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  5、工具需求开发随意、发布路径不统一、工具发布格式不规范。这也是管理的问题。工具没有统一的管理就会衍生出很多额外的问题。比如前文提到的不知道从哪里获取工具、工具没有指导书，我没有编码能力但是我识别出了工作中的短板需要开发工具可以把需求提交给谁。。等等。。这里，不是一定要强制某些工具不能开发，某些工具可以开发。从测试部整体角度来说，将工作量聚焦测试部topN效率短板提升的工具开发肯定是必要的。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  上面暴露的问题在我呆过的很多产品都遇到过，并不是个例。针对这些问题的解决方法，谈一下个人观点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  1、工具统一管理。测试部内部发布工具开发规范、统一工具发布路径、工具发布格式（工具名称+版本号、工具主要功能、工具作者、工具维护历史、工具开发IDE等）。建议使用主流编程语言开发（Python、Java等），内部强调编程规范等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2、工具开发提高易用性。一是减少交互而是方便交互。减少交互主要是指没有必要的输入或者可以固化的输入就集成到软件中，需要依赖的步骤也可以直接在工具中实现。方便交互主要是指在windows系统使用时尽量提供界面化形式的交互窗口。windows上使用的程序培养的习惯是这样。对于linux下，命令行交互没有问题，但是每一步的输入提示描述尽量简单清晰。尽量可以达到傻瓜式的使用。实现的时候就从这个角度考虑。你不期望你给别人工具还要教他怎么用吧。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3、提高工具可用性。这是功能的问题。通常这些效率提升工具都是个人在工作之余花时间实现的，要求面面俱到也是很困难，但是尽量还是要保证主场景在绝大多数情况下运行正常，可以正常输出预期结果。不能换一个测试版本工具就出问题就好了，别人可能就不想用了。对于工具的完善可以在下一次迭代优化。这是每一个工具开发人员都是应该思考的问题。。你也不期望自己发布的工具别人一用就出问题。。对自己的形象也不好。。是吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4、提高工具可维护性。要求不高，就是多加一些注释，代码自己觉得可读性还可以。函数/类尽量划分的合理。至少保证自己过半年一年再回来看自己的代码还能快速读懂修改就差不多了。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 5、工具定期宣传。定期挑选一些好用的、具有一定普遍性的工具进行推广。酒香也怕巷子深，每个工具开发作者也希望自己的劳动成果可以真正的让其他人受益，让自己的付出得到别人的认可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  6、编码技能交流。测试人员整体编码技能还是相对较弱，工具的开发主要还是集中在一小部分人身上。可以将这部分人员统一集中起来多交流、探讨。也可以在测试内部推一些编码基础培训课程或者是一些基础文章，可以帮助有兴趣提升编码能力的测试人员。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;   工具开发管理维护使用暴露出的问题挺多的，其实没有啥。毕竟都是测试人员在业余时间开发的。做出来了总比没做出来好，做出来的东西只要稍加引导就可以不断迭代优化改进。不可取的是没有改进意识，容忍低效、重复、繁琐的手工执行工作，这样对自己没有什么好处。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   限于时间，匆匆写完，有些观点可能表达不到位，针对这些问题，有兴趣可以交流。。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Sep 2019 23:40:00 +0000</pubDate>
<dc:creator>BengDou_Do&amp;amp;Think</dc:creator>
<og:description>本文针对测试部效率提升测试工具开发、管理、维护暴露出来的问题的一些思考以及一些个人改进观点。 写在前面 本文提到的效率提升测试工具不是指的部门中固有的自动化测试工具，这里提到的测试工具统一指测试人员在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linyfeng/p/11610780.html</dc:identifier>
</item>
<item>
<title>分库分表(1) --- 理论 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11608222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11608222.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;当一张表的数据达到几千万时，查询一次所花的时间会变长。业界公认MySQL单表容量在 &lt;strong&gt;1千万&lt;/strong&gt; 以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。&lt;/p&gt;
&lt;p&gt;数据切分可以分为：&lt;code&gt;垂直切分&lt;/code&gt;和&lt;code&gt;水平切分&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一垂直切分&quot;&gt;&lt;span&gt;一、垂直切分&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;垂直切分又可以分为: &lt;code&gt;垂直分库&lt;/code&gt;和&lt;code&gt;垂直分表&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;垂直分库&quot;&gt;1、垂直分库&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; 就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与&quot;微服务治理&quot;的做法相似，&lt;/p&gt;
&lt;p&gt;每个微服务使用单独的一个数据库。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153840439-1816032834.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一开始我们是单体服务，所以只有一个数据库，所有的表都在这个库里。&lt;/p&gt;
&lt;p&gt;后来因为业务需求,单体服务变成微服务治理。所以将之前的一个商品库，拆分成多个数据库。每个微服务对于一个数据库。&lt;/p&gt;
&lt;h4 id=&quot;垂直分表&quot;&gt;2、垂直分表&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; 把一个表的多个字段分别拆成多个表，一般按字段的冷热拆分，热字段一个表，冷字段一个表。从而提升了数据库性能。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153851001-806440217.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一开始商品表中包含商品的所有字段，但是我们发现:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.商品详情和商品属性字段较长&lt;/code&gt;。&lt;code&gt;2.商品列表的时候我们是不需要显示商品详情和商品属性信息，只有在点进商品商品的时候才会展示商品详情信息&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以可以考虑把商品详情和商品属性单独切分一张表，提高查询效率。&lt;/p&gt;
&lt;h4 id=&quot;垂直切分优缺点&quot;&gt;3、垂直切分优缺点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 解决业务系统层面的耦合，业务清晰
- 与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等
- 高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 分库后无法Join，只能通过接口聚合方式解决，提升了开发的复杂度
- 分库后分布式事务处理复杂
- 依然存在单表数据量过大的问题（需要水平切分）&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;二水平切分&quot;&gt;&lt;span&gt;二、水平切分&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当一个应用难以再细粒度的垂直切分或切分后数据量行数巨大,存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。&lt;/p&gt;
&lt;p&gt;水平切分也可以分为：&lt;code&gt;水平分库&lt;/code&gt;和&lt;code&gt;水平分表&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;水平分库&quot;&gt;1、水平分库&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;水平分库的原因&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面虽然已经把商品库分成3个库，但是随着业务的增加一个订单库也出现QPS过高，数据库响应速度来不及,一般mysql单机也就1000左右的QPS，如果超过1000就要考虑分库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153903240-431948355.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;水平分表&quot;&gt;2、水平分表&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; 一般我们一张表的数据不要超过1千万,如果表数据超过1千万，并且还在不断增加数据，那就可以考虑分表。&lt;/p&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153912863-301123895.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;垂直切分优缺点-1&quot;&gt;3、垂直切分优缺点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力
- 应用端改造较小，不需要拆分业务模块&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 跨分片的事务一致性难以保证
- 跨库的Join关联查询性能较差
- 数据多次扩展难度和维护量极大&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三数据分片规则&quot;&gt;&lt;span&gt;三、数据分片规则&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们我们考虑去水平切分表，将一张表水平切分成多张表，这就涉及到数据分片的规则，比较常见的有：&lt;code&gt;Hash取模分表&lt;/code&gt;、&lt;code&gt;数值Range分表&lt;/code&gt;、&lt;code&gt;一致性Hash算法分表&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;hash取模分表&quot;&gt;1、Hash取模分表&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; 一般采用Hash取模的切分方式，例如：假设按goods_id分4张表。（goods_id%4 取整确定表）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153922347-942099001.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; - 数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 后期分片集群扩容时，需要迁移旧的数据很难。
- 容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带goods_id时,将会导致无法定位数据库,从而需要同时向4个库发起查询，
再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数值range分表&quot;&gt;2、数值Range分表&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; 按照时间区间或ID区间来切分。例如：将goods_id为1~1000的记录分到第一个表，1001~2000的分到第二个表，以此类推。&lt;/p&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153932064-1649836918.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 单表大小可控
- 天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移
- 使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 热点数据成为性能瓶颈。
例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一致性hash算法&quot;&gt;3、一致性Hash算法&lt;/h4&gt;
&lt;p&gt;一致性Hash算法能很好的&lt;code&gt;解决因为Hash取模而产生的分片集群扩容时，需要迁移旧的数据的难题&lt;/code&gt;。至于具体原理这里就不详细说，&lt;/p&gt;
&lt;p&gt;可以参考一篇博客：&lt;a href=&quot;https://www.cnblogs.com/duhuo/p/4996105.html&quot;&gt;一致性哈希算法(分库分表，负载均衡等)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四分库分表带来的问题&quot;&gt;&lt;span&gt;四、分库分表带来的问题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;任何事情都有两面性，分库分表也不例外，如果采用分库分表，会引入新的的问题&lt;/p&gt;
&lt;h4 id=&quot;分布式事务问题&quot;&gt;1、分布式事务问题&lt;/h4&gt;
&lt;p&gt;使用分布式事务中间件解决，具体是通过最终一致性还是强一致性分布式事务，看业务需求，这里就不多说。&lt;/p&gt;
&lt;h4 id=&quot;跨节点关联查询-join-问题&quot;&gt;2、跨节点关联查询 Join 问题&lt;/h4&gt;
&lt;p&gt;切分之前，我们可以通过Join来完成。而切分之后，数据可能分布在不同的节点上，此时Join带来的问题就比较麻烦了，考虑到性能，尽量避免使用Join查询。&lt;/p&gt;
&lt;p&gt;解决这个问题的一些方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;全局表&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;全局表，也可看做是 &quot;&lt;strong&gt;数据字典表&lt;/strong&gt;&quot;，就是系统中所有模块都可能依赖的一些表，为了避免跨库Join查询，可以将 &lt;strong&gt;这类表在每个数据库中都保存一份&lt;/strong&gt;。这些数据通常&lt;/p&gt;
&lt;p&gt;很少会进行修改，所以也不担心一致性的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;字段冗余&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用空间换时间，为了性能而避免join查询&lt;/strong&gt;。例：订单表保存userId时候,也将userName冗余保存一份，这样查询订单详情时就不需要再去查询&quot;买家user表&quot;了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;数据组装&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在系统层面，分两次查询&lt;/strong&gt;。第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。&lt;/p&gt;
&lt;h4 id=&quot;跨节点分页排序函数问题&quot;&gt;3、跨节点分页、排序、函数问题&lt;/h4&gt;
&lt;p&gt;跨节点多库进行查询时，会出现Limit分页、Order by排序等问题。分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；&lt;/p&gt;
&lt;p&gt;当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。&lt;/p&gt;
&lt;h4 id=&quot;全局主键避重问题&quot;&gt;4、全局主键避重问题&lt;/h4&gt;
&lt;p&gt;如果都用&lt;code&gt;主键自增&lt;/code&gt;肯定不合理，如果用&lt;code&gt;UUID&lt;/code&gt;那么无法做到根据主键排序，所以我们可以考虑通过&lt;code&gt;雪花ID&lt;/code&gt;来作为数据库的主键，&lt;/p&gt;
&lt;p&gt;有关雪花ID可以参考我之前写的博客：&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11372658.html&quot;&gt;静态内部类单例模式实现雪花算法&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;数据迁移问题&quot;&gt;5、数据迁移问题&lt;/h4&gt;
&lt;p&gt;采用&lt;code&gt;双写的方式&lt;/code&gt;，修改代码，所有涉及到分库分表的表的增、删、改的代码，都要对新库进行增删改。同时，再有一个数据抽取服务，不断地从老库抽数据，往新库写，&lt;/p&gt;
&lt;p&gt;边写边按时间比较数据是不是最新的。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.jianshu.com/p/89fa2f873afe&quot;&gt;分库分表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1622441635115622194&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;谈谈分库分表吧？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/butterfly100/p/9034281.html&quot;&gt;数据库分库分表思路&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt; 我相信，无论今后的道路多么坎坷，只要抓住今天，迟早会在奋斗中尝到人生的甘甜。抓住人生中的一分一秒，胜过虚度中的一月一年！(16）&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Sun, 29 Sep 2019 23:17:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>分库分表 理论 当一张表的数据达到几千万时，查询一次所花的时间会变长。业界公认MySQL单表容量在 1千万 以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。 数据切分可以分为： 和`水平切</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11608222.html</dc:identifier>
</item>
<item>
<title>.NET之Hangfire快速入门和使用 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/11610747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/11610747.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　定时任务调度问题，是一个老生常谈的问题。网上有许多定时任务调度的解决方案，对于我而言很早以前主要是使用Window计划和Window服务来做任务定时执行，然后就开始使用定时任务调度框架Quartz.Net。但是却一直没有上手过Hangfire这个自带后台任务调度面板，可以在后台手动执行任务的神奇的任务调度框架。前段时间终于开始对他下手了，通过在网上查阅了一些资料和查看了Hangfire在Github中的demo，终于在我自己的项目中用上了Hangfire。在该篇文章中主要简单介绍一下什么是Hangfire，Hangfire的基本特征与优点和分别使用MySQL，MS SQL Server作为存储使用。&lt;/p&gt;
&lt;h2&gt;一、Hangfire是什么：&lt;/h2&gt;
&lt;p&gt;　　Hangfire是一个开源的.NET任务调度框架，提供了内置集成化的控制台，可以直观明了的查看作业调度情况，并且Hangfire不需要依赖于单独的应用程序执行（如：windows服务，window计划）。并且支持持久性存储。&lt;/p&gt;
&lt;h2&gt;二、Hangfire使用条件：&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Hangfire与特定的.NET应用程序类型无关。您可以在ASP.NET Web应用程序，非ASP.NET Web应用程序，控制台应用程序或Windows服务中使用它。以下是要求：&lt;/p&gt;
&lt;p&gt;1.NET Framework 4.5&lt;/p&gt;
&lt;p&gt;2.永久存储（Hangfire将后台作业和其他与处理有关的信息保留在永久性存储器中，所以需要存储库来存储如：MS SQL Server，Redis，MySQL，PostgreSql等）&lt;/p&gt;
&lt;p&gt;3.Newtonsoft.Json库≥5.0.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;三、Hangfire的基本特征与优点：&lt;/h2&gt;
&lt;p&gt;通过官网中的一张图片便可知道它是一个多么优秀的任务调度框架,如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201909/1336199-20190930003952822-502302129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;四、Hangfire安装和使用：&lt;/h2&gt;
&lt;h3&gt;在NuGet上有关于Hangfire的 一系列软件包:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;详情地址：&lt;/strong&gt; &lt;a href=&quot;https://www.nuget.org/packages?q=Hangfire&quot;&gt;https://www.nuget.org/packages?q=Hangfire&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;通过在程序包管理控制台中输入安装命令安装Hangfire所需NuGet包：&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;使用MS SQL Server作为存储时我们需要安装的NuGet：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt; 在ASP.NET 应用程序下使用Hangfire安装： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Install-Package Hangfire
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在控制台应用程序或者window server中处理作业：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Install-Package Hangfire.Core
Install-Package Hangfire.SqlServer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意，在控制台应用程序或者window server中不推荐直接安装：Install-Package Hangfire ，因为它只是一个快速启动软件包，并包含您可能不需要的依赖项（例如，Microsoft.Owin.Host.SystemWeb等无关依赖项）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;使用MySQL作为存储时我们需要安装的NuGet：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt; 在ASP.NET 应用程序下使用Hangfire安装： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 Install-Package Hangfire.Core 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还需要安装一个MySql存储（Hangfire.MySqlStorage）的拓展，注意因为Hangfire本身是不支持MySQL存储的，这是名为：&lt;span&gt;Arnoldas Gudas作者拓展的&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;Nuget地址：&lt;a href=&quot;https://www.nuget.org/packages/Hangfire.MySqlStorage/&quot;&gt;https://www.nuget.org/packages/Hangfire.MySqlStorage/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装命令：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：因为我的项目是.NET Framework,Version=v4.5.1版本的，所以只能安装1.0.7版本的，大家看需求而定&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Install-Package Hangfire.MySqlStorage -Version 1.0.7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们要使用(宿主)IIS托管ASP.NET应用程序时，我们还需要安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Install-Package Microsoft.Owin.Host.SystemWeb -Version 4.0.1
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;添加和配置OWIN Startup.cs，及其连接对应的存储数据库：&lt;/h3&gt;
&lt;h4&gt;添加OWIN Startup.cs&lt;/h4&gt;
&lt;p&gt;　　这里是当你的项目中不存在Startup.cs时才需要执行添加的操作！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201909/1336199-20190930012558086-1777119302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;什么是OWIN Startup.cs：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;简单概述：是.NET 平台开放的web接口，Startup则是.Net与web通讯管道，起到转发，沟通的作用。&lt;/p&gt;
&lt;p&gt;详情介绍：&lt;a href=&quot;https://www.cnblogs.com/wj033/p/6065145.html&quot;&gt;https://www.cnblogs.com/wj033/p/6065145.html&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;在Startup.cs中连接需要使用的存储库：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        public void Configuration(IAppBuilder app)
        {
            //运用SqlServer存储，对应web.config中的connectionStrings中的name
            GlobalConfiguration.Configuration.UseSqlServerStorage(&quot;sqlserver_connection&quot;);&lt;br/&gt;//注意，当你使用的是MySql作为存储时，需要如下配置
            //运用MySql存储，对应web.config中的connectionStrings中的name
            GlobalConfiguration.Configuration.UseStorage(new MySqlStorage(&quot;mysql_connection&quot;));

            app.UseHangfireDashboard();//配置后台仪表盘
            app.UseHangfireServer();//开始使用Hangfire服务

        }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Web.config数据库配置:&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.MS SQL Server中：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;connectionStrings&amp;gt;
    &amp;lt;add name=&quot;sqlserver_connection&quot; connectionString=&quot;Data Source=.;Initial Catalog=MyFirstDb;Integrated Security=True&quot; providerName=&quot;System.Data.SqlClient&quot; /&amp;gt;&lt;br/&gt;&amp;lt;/connectionStrings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.MySQL中：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 &amp;lt;connectionStrings&amp;gt;
    &amp;lt;add name=&quot;mysql_connection&quot; providerName=&quot;System.Data.MySqlClient&quot; connectionString=&quot;Server=123.xxx.xxx.xx;Port=3306;Database=MyFirstDb;Uid=root;&lt;br/&gt;Pwd=youpassword;charset=utf8;SslMode=none;Allow User Variables=True&quot; /&amp;gt;&lt;br/&gt;&amp;lt;/connectionStrings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;运行程序，访问调度控制面板：&lt;/h3&gt;
&lt;p&gt;　　当我们已经完成了上面的相关配置后，且程序能够正常无bug的运行时，我们的Hangfire Dashboard(仪表盘)在我们的本地就可以正常访问了（Hangfire仪表盘默认只支持本地访问），假如需要远程可访问的话我们还需要做对应的配置授权操作！　　&lt;/p&gt;
&lt;h4&gt;运行成功，查看数据库中是否生成了与Hangfire相关的表：&lt;/h4&gt;
&lt;p&gt;　　首次运行成功后，打开数据库可以看到Hangfire已经自动为我们创建了定时任务的一些定时任务列表，定时队列，服务，状态等相关的数据表（展现了Hangfire作用的持久化特性），如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.MS SQL Server中生成的表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201909/1336199-20190930015159406-225896067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; b.MySQL中生成的表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201909/1336199-20190930015239389-1347380917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; 访问调度控制面板：&lt;/h4&gt;
&lt;p&gt;本地访问方式：https://localhost:端口号/hangfire/&lt;/p&gt;
&lt;p&gt;调度控制面板效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201909/1336199-20190930015547922-1145741350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 后台常用任务调度创建和使用：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持基于队列的任务处理：任务执行不是同步的，而是放到一个持久化队列中，以便马上把请求控制权返回给调用者。&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; jobId = BackgroundJob.Enqueue(() =&amp;gt; WriteLog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列任务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延迟任务执行：不是马上调用方法，而是设定一个未来时间点再来执行，延迟作业仅执行一次&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; jobId = BackgroundJob .Schedule（()=&amp;gt; Console .WriteLine（&lt;span&gt;&quot;&quot;&lt;/span&gt;),TimeSpan .FromDays(&lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一天后执行该任务

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环任务执行：一行代码添加重复执行的任务，其内置了常见的时间循环模式，也可基于CRON表达式来设定复杂的模式。【用的比较的多】&lt;/span&gt;
RecurringJob.AddOrUpdate(() =&amp;gt; WriteLog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;每分钟执行任务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Cron.Minutely); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意最小单位是分钟

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延续性任务执行：类似于.NET中的Task,可以在第一个任务执行完之后紧接着再次执行另外的任务&lt;/span&gt;
BackgroundJob.ContinueWith(jobId, () =&amp;gt; WriteLog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连续任务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结:&lt;/h2&gt;
&lt;p&gt;　　通过本次项目实践的确让我感受到了Hangfire的魅力所在，真的可以说是上手简单，开箱即用的一个任务调度框架。并且该框架做的最好的是，官方文档详细，并且还提供了完整的demo示例。最后要为Hangfire的作者点赞！&lt;/p&gt;
&lt;h2&gt;Hangfire相关使用学习资料：&lt;/h2&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://www.hangfire.io/&quot;&gt;https://www.hangfire.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub源码：&lt;a href=&quot;https://github.com/HangfireIO/Hangfire&quot;&gt;https://github.com/HangfireIO/Hangfire&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文文档：&lt;a href=&quot;https://www.bookstack.cn/read/Hangfire-zh-official/README.md&quot;&gt;https://www.bookstack.cn/read/Hangfire-zh-official/README.md&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;GitHub使用示例源码：&lt;a href=&quot;https://github.com/HangfireIO/Hangfire.Samples&quot;&gt;https://github.com/HangfireIO/Hangfire.Samples&lt;/a&gt;（包括控制台应用程序，window服务，ASP.NET MVC，WebForm）&lt;/p&gt;
&lt;p&gt;Hangfire使用文章汇总：&lt;a href=&quot;https://www.bbsmax.com/R/xl56E0nrJr/&quot;&gt;https://www.bbsmax.com/R/xl56E0nrJr/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 29 Sep 2019 18:31:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 定时任务调度问题，是一个老生常谈的问题。网上有许多定时任务调度的解决方案，对于我而言很早以前主要是使用Window计划和Window服务来做任务定时执行，然后就开始使用定时任务调度框架Quar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/11610747.html</dc:identifier>
</item>
<item>
<title>FreeSql 导航属性的联级保存功能 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/11610724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/11610724.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;FreeSql 一个款 .net 平台下支持 .net framework 4.5+、.net core 2.1+ 的开源 ORM。单元测试超过3100+，正在不断吸引新的开发者，生命不息开发不止。&lt;/p&gt;
&lt;p&gt;和 EFCore 一样，我们也有导航对象，支持【OneToOne】(一对一)、【ManyToOne】(多对一)、【OneToMany】(一对多)、【ParentChild】(父子)、【ManyToMany】(多对多)，可以约定配置或手工配置实体间的关联，也可以使用 fluent api 设置关联。&lt;/p&gt;
&lt;p&gt;联级保存功能可实现保存对象的时候，将其【OneToMany】、【ManyToMany】导航属性集合也一并保存，本文档说明实现的机制防止误用。&lt;/p&gt;
&lt;h2 id=&quot;机制规则&quot;&gt;机制规则&lt;/h2&gt;
&lt;p&gt;【一对多】模型下， 保存时可联级保存实体的属性集合。出于使用安全考虑我们没做完整对比，只实现实体属性集合的添加或更新操作，所以不会删除实体属性集合的数据。&lt;/p&gt;
&lt;p&gt;完整对比的功能使用起来太危险，试想下面的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保存的时候，实体的属性集合是空的，如何操作？记录全部删除？&lt;/li&gt;
&lt;li&gt;保存的时候，由于数据库中记录非常之多，那么只想保存子表的部分数据，或者只需要添加，如何操作？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【多对多】模型下，我们对中间表的保存是完整对比操作，对外部实体的操作只作新增（注意不会更新）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;属性集合为空时，删除他们的所有关联数据（中间表）&lt;/li&gt;
&lt;li&gt;属性集合不为空时，与数据库存在的关联数据（中间表）完整对比，计算出应该删除和添加的记录&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;功能开启和关闭&quot;&gt;功能开启和关闭&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;IFreeSql fsql = new FreeSql.FreeSqlBuilder()

    .UseConnectionString(FreeSql.DataType.Sqlite, &quot;Data Source=|DataDirectory|/document22.db;Pooling=true;Max Pool Size=10&quot;)

    .UseAutoSyncStructure(true) //自动同步结构到数据库
    .UseMonitorCommand(cmd =&amp;gt; Trace.WriteLine(cmd.CommandText)) //监听SQL命令对象，在执行后
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 FreeSqlBuilder 创建好的 IFreeSql 对象，联级保存功能，默认是打开的。&lt;/p&gt;
&lt;p&gt;全局关闭：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;fsql.SetDbContextOptions(opt =&amp;gt; opt.EnableAddOrUpdateNavigateList = false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;局部关闭：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var repo = fsql.GetRepository&amp;lt;T&amp;gt;();
repo.DbContextOptions.EnableAddOrUpdateNavigateList = false;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一对多onetomany代码测试&quot;&gt;一对多（OneToMany）代码测试&lt;/h2&gt;
&lt;p&gt;为了方便展示，以下是一个 ParentChild 关系，其实他也是 OneToMany，只不过是自己指向自己。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Table(Name = &quot;EAUNL_OTMP_CT&quot;)]
class CagetoryParent
{
    public Guid Id { get; set; }
    public string Name { get; set; }

    public Guid ParentId { get; set; }
    [Navigate(&quot;ParentId&quot;)]
    public List&amp;lt;CagetoryParent&amp;gt; Childs { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化测试数据：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var cts = new[] {
    new CagetoryParent
    {
        Name = &quot;分类1&quot;,
        Childs = new List&amp;lt;CagetoryParent&amp;gt;(new[]
        {
            new CagetoryParent { Name = &quot;分类1_1&quot; },
            new CagetoryParent { Name = &quot;分类1_2&quot; },
            new CagetoryParent { Name = &quot;分类1_3&quot; }
        })
    },
    new CagetoryParent
    {
        Name = &quot;分类2&quot;,
        Childs = new List&amp;lt;CagetoryParent&amp;gt;(new[]
        {
            new CagetoryParent { Name = &quot;分类2_1&quot; },
            new CagetoryParent { Name = &quot;分类2_2&quot; }
        })
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1、执行批量插入：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var repo = g.sqlite.GetRepository&amp;lt;CagetoryParent&amp;gt;();
repo.Insert(cts);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始执行该方法时，会执行自动创建数据库表操作。如果表已存在，则执行对比，若无变化则不执行操作。&lt;/p&gt;
&lt;p&gt;经过断点调试，在控制台可以看到输出 SQL 内容为：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;INSERT INTO &quot;EAUNL_OTMP_CT&quot;(&quot;Id&quot;, &quot;Name&quot;, &quot;ParentId&quot;) VALUES('5d90afcb-ed57-f6f4-0082-cb6b78eaaf9f', '分类1', '00000000-0000-0000-0000-000000000000'), ('5d90afcb-ed57-f6f4-0082-cb6c5b531b3e', '分类2', '00000000-0000-0000-0000-000000000000')

INSERT INTO &quot;EAUNL_OTMP_CT&quot;(&quot;Id&quot;, &quot;Name&quot;, &quot;ParentId&quot;) VALUES('5d90afcb-ed57-f6f4-0082-cb6d0c1c5f1a', '分类1_1', '5d90afcb-ed57-f6f4-0082-cb6b78eaaf9f'), ('5d90afcb-ed57-f6f4-0082-cb6e74bd8eef', '分类1_2', '5d90afcb-ed57-f6f4-0082-cb6b78eaaf9f'), ('5d90afcb-ed57-f6f4-0082-cb6f6267cc5f', '分类1_3', '5d90afcb-ed57-f6f4-0082-cb6b78eaaf9f'), ('5d90afcb-ed57-f6f4-0082-cb7057c41d46', '分类2_1', '5d90afcb-ed57-f6f4-0082-cb6c5b531b3e'), ('5d90afcb-ed57-f6f4-0082-cb7156e0375e', '分类2_2', '5d90afcb-ed57-f6f4-0082-cb6c5b531b3e')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、测试批量修改：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;cts[0].Name = &quot;分类11&quot;;
cts[0].Childs.Clear();
cts[1].Name = &quot;分类22&quot;;
cts[1].Childs.Clear();
repo.Update(cts);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台看到输出 SQL 内容为：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;UPDATE &quot;EAUNL_OTMP_CT&quot; SET &quot;Name&quot; = CASE &quot;Id&quot; 
WHEN '5d90afcb-ed57-f6f4-0082-cb6b78eaaf9f' THEN '分类11' 
WHEN '5d90afcb-ed57-f6f4-0082-cb6c5b531b3e' THEN '分类22' END 
WHERE (&quot;Id&quot; IN ('5d90afcb-ed57-f6f4-0082-cb6b78eaaf9f','5d90afcb-ed57-f6f4-0082-cb6c5b531b3e'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Childs.Clear 执行了，但是控制台没有输出执行删除子集合语句，说明没有做完整的对比&lt;/p&gt;
&lt;p&gt;3、子集合表已存在数据，继续添加数据&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;cts[0].Name = &quot;分类111&quot;;
cts[0].Childs.Clear();
cts[0].Childs.Add(new CagetoryParent { Name = &quot;分类1_33&quot; });
cts[1].Name = &quot;分类222&quot;;
cts[1].Childs.Clear();
cts[1].Childs.Add(new CagetoryParent { Name = &quot;分类2_22&quot; });
repo.Update(cts);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台看到输出 SQL 内容为：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;UPDATE &quot;EAUNL_OTMP_CT&quot; SET &quot;Name&quot; = CASE &quot;Id&quot; 
WHEN '5d90afcb-ed57-f6f4-0082-cb6b78eaaf9f' THEN '分类111' 
WHEN '5d90afcb-ed57-f6f4-0082-cb6c5b531b3e' THEN '分类222' END 
WHERE (&quot;Id&quot; IN ('5d90afcb-ed57-f6f4-0082-cb6b78eaaf9f','5d90afcb-ed57-f6f4-0082-cb6c5b531b3e'))

INSERT INTO &quot;EAUNL_OTMP_CT&quot;(&quot;Id&quot;, &quot;Name&quot;, &quot;ParentId&quot;) VALUES('5d90afe8-ed57-f6f4-0082-cb725df546ea', '分类1_33', '5d90afcb-ed57-f6f4-0082-cb6b78eaaf9f'), ('5d90afe8-ed57-f6f4-0082-cb7338a6214c', '分类2_22', '5d90afcb-ed57-f6f4-0082-cb6c5b531b3e')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再一次验证了【一对多】(OneToMany) 不会作完整对比，只会添加或更新，添加测试数据的时候用它能简化好多代码。&lt;/p&gt;
&lt;h2 id=&quot;多对多manytomany代码测试&quot;&gt;多对多（ManyToMany）代码测试&lt;/h2&gt;
&lt;p&gt;以下我们创建了三个类，Song 为本体类，Tag 为外部类，SongTag 为 中间关联数据类，采用命名约定的方式进行了导航关系设置。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Table(Name = &quot;EAUNL_MTM_SONG&quot;)]
class Song
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public List&amp;lt;Tag&amp;gt; Tags { get; set; }
}
[Table(Name = &quot;EAUNL_MTM_TAG&quot;)]
class Tag
{
    public Guid Id { get; set; }
    public string TagName { get; set; }
    public List&amp;lt;Song&amp;gt; Songs { get; set; }
}
[Table(Name = &quot;EAUNL_MTM_SONGTAG&quot;)]
class SongTag
{
    public Guid SongId { get; set; }
    public Song Song { get; set; }
    public Guid TagId { get; set; }
    public Tag Tag { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化测试数据：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var tags = new[] {
    new Tag { TagName = &quot;流行&quot; },
    new Tag { TagName = &quot;80后&quot; },
    new Tag { TagName = &quot;00后&quot; },
    new Tag { TagName = &quot;摇滚&quot; }
};
var ss = new[]
{
    new Song
    {
        Name = &quot;爱你一万年.mp3&quot;,
        Tags = new List&amp;lt;Tag&amp;gt;(new[]
        {
            tags[0], tags[1]
        })
    },
    new Song
    {
        Name = &quot;李白.mp3&quot;,
        Tags = new List&amp;lt;Tag&amp;gt;(new[]
        {
            tags[0], tags[2]
        })
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1、执行批量插入：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var repo = g.sqlite.GetRepository&amp;lt;Song&amp;gt;();
repo.Insert(ss);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始执行该方法时，会执行自动创建数据库表操作。如果表已存在，则执行对比，若无变化则不执行操作。&lt;/p&gt;
&lt;p&gt;经过断点调试，在控制台可以看到输出 SQL 内容为：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;INSERT INTO &quot;EAUNL_MTM_SONG&quot;(&quot;Id&quot;, &quot;Name&quot;) VALUES('5d90fdb3-6a6b-2c58-00c8-37974177440d', '爱你一万年.mp3'), ('5d90fdb3-6a6b-2c58-00c8-37987f29b197', '李白.mp3')

INSERT INTO &quot;EAUNL_MTM_TAG&quot;(&quot;Id&quot;, &quot;TagName&quot;) VALUES('5d90fdb7-6a6b-2c58-00c8-37991ead4f05', '流行'), ('5d90fdbd-6a6b-2c58-00c8-379a0432a09c', '80后')

INSERT INTO &quot;EAUNL_MTM_SONGTAG&quot;(&quot;SongId&quot;, &quot;TagId&quot;) VALUES('5d90fdb3-6a6b-2c58-00c8-37974177440d', '5d90fdb7-6a6b-2c58-00c8-37991ead4f05'), ('5d90fdb3-6a6b-2c58-00c8-37974177440d', '5d90fdbd-6a6b-2c58-00c8-379a0432a09c')

INSERT INTO &quot;EAUNL_MTM_TAG&quot;(&quot;Id&quot;, &quot;TagName&quot;) VALUES('5d90fdcc-6a6b-2c58-00c8-379b5af59d25', '00后')

INSERT INTO &quot;EAUNL_MTM_SONGTAG&quot;(&quot;SongId&quot;, &quot;TagId&quot;) VALUES('5d90fdb3-6a6b-2c58-00c8-37987f29b197', '5d90fdb7-6a6b-2c58-00c8-37991ead4f05'), ('5d90fdb3-6a6b-2c58-00c8-37987f29b197', '5d90fdcc-6a6b-2c58-00c8-379b5af59d25')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、测试批量更新，并且中间表数据有了变化&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;ss[0].Name = &quot;爱你一万年.mp5&quot;;
ss[0].Tags.Clear();
ss[0].Tags.Add(tags[0]);
ss[1].Name = &quot;李白.mp5&quot;;
ss[1].Tags.Clear();
ss[1].Tags.Add(tags[3]);
repo.Update(ss);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台看到输出 SQL 内容为：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;UPDATE &quot;EAUNL_MTM_SONG&quot; SET &quot;Name&quot; = CASE &quot;Id&quot; 
WHEN '5d90fdb3-6a6b-2c58-00c8-37974177440d' THEN '爱你一万年.mp5' 
WHEN '5d90fdb3-6a6b-2c58-00c8-37987f29b197' THEN '李白.mp5' END 
WHERE (&quot;Id&quot; IN ('5d90fdb3-6a6b-2c58-00c8-37974177440d','5d90fdb3-6a6b-2c58-00c8-37987f29b197'))

SELECT a.&quot;SongId&quot;, a.&quot;TagId&quot; 
FROM &quot;EAUNL_MTM_SONGTAG&quot; a 
WHERE (a.&quot;SongId&quot; = '5d90fdb3-6a6b-2c58-00c8-37974177440d')

DELETE FROM &quot;EAUNL_MTM_SONGTAG&quot; WHERE (&quot;SongId&quot; = '5d90fdb3-6a6b-2c58-00c8-37974177440d' AND &quot;TagId&quot; = '5d90fdbd-6a6b-2c58-00c8-379a0432a09c')

INSERT INTO &quot;EAUNL_MTM_TAG&quot;(&quot;Id&quot;, &quot;TagName&quot;) VALUES('5d90febd-6a6b-2c58-00c8-379c21acfc72', '摇滚')

SELECT a.&quot;SongId&quot;, a.&quot;TagId&quot; 
FROM &quot;EAUNL_MTM_SONGTAG&quot; a 
WHERE (a.&quot;SongId&quot; = '5d90fdb3-6a6b-2c58-00c8-37987f29b197')

DELETE FROM &quot;EAUNL_MTM_SONGTAG&quot; WHERE (&quot;SongId&quot; = '5d90fdb3-6a6b-2c58-00c8-37987f29b197' AND &quot;TagId&quot; = '5d90fdb7-6a6b-2c58-00c8-37991ead4f05' OR &quot;SongId&quot; = '5d90fdb3-6a6b-2c58-00c8-37987f29b197' AND &quot;TagId&quot; = '5d90fdcc-6a6b-2c58-00c8-379b5af59d25')

INSERT INTO &quot;EAUNL_MTM_SONGTAG&quot;(&quot;SongId&quot;, &quot;TagId&quot;) VALUES('5d90fdb3-6a6b-2c58-00c8-37987f29b197', '5d90febd-6a6b-2c58-00c8-379c21acfc72')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行的过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，批量更新 song 数据&lt;/li&gt;
&lt;li&gt;第二步，由于是 song 是更新操作，所以需要先查出 song 的关联数据&lt;/li&gt;
&lt;li&gt;第三步，删除 song 的关联数据（tags[0] 除外），因为 tags[0] 是本次保存有的数据，直白的说就是删除非本次保存的所有关联数据&lt;/li&gt;
&lt;li&gt;第四步，添加 tags[3] 摇滚外部数据，因为它还不存在外部表&lt;/li&gt;
&lt;li&gt;第五步，与第二步相同&lt;/li&gt;
&lt;li&gt;第六步，与第三步相同&lt;/li&gt;
&lt;li&gt;第七步，插入中间表数据，李白.mp5 与 摇滚 关联&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么会有这么多步呢？原因是 song 测试数据是两条，double 了，如果单条记录大概是 4-5 条，取决于是否有新增的关联数据需要添加。&lt;/p&gt;
&lt;p&gt;3、测试清空关联数据&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;ss[0].Name = &quot;爱你一万年.mp4&quot;;
ss[0].Tags.Clear();
ss[1].Name = &quot;李白.mp4&quot;;
ss[1].Tags.Clear();
repo.Update(ss);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台看到输出 SQL 内容为：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DELETE FROM &quot;EAUNL_MTM_SONGTAG&quot; WHERE (&quot;SongId&quot; = '5d90fdb3-6a6b-2c58-00c8-37974177440d')

DELETE FROM &quot;EAUNL_MTM_SONGTAG&quot; WHERE (&quot;SongId&quot; = '5d90fdb3-6a6b-2c58-00c8-37987f29b197')

UPDATE &quot;EAUNL_MTM_SONG&quot; SET &quot;Name&quot; = CASE &quot;Id&quot; 
WHEN '5d90fdb3-6a6b-2c58-00c8-37974177440d' THEN '爱你一万年.mp4' 
WHEN '5d90fdb3-6a6b-2c58-00c8-37987f29b197' THEN '李白.mp4' END 
WHERE (&quot;Id&quot; IN ('5d90fdb3-6a6b-2c58-00c8-37974177440d','5d90fdb3-6a6b-2c58-00c8-37987f29b197'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再一次证明【ManyToMany】(多对多) 模型下，中间表是完整的对比操作，外部表只会插入，不更新。&lt;/p&gt;
&lt;h2 id=&quot;导航对象&quot;&gt;导航对象&lt;/h2&gt;
&lt;p&gt;除了联级保存功能外，导航对象的主要设计目的为快速在实体间点点点穿插，以便执行 lambda 表达式的查询操作。&lt;/p&gt;
&lt;p&gt;如何自定义导航关系？&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//导航属性，OneToMany
[Navigate(&quot;song_id&quot;)]
public virtual List&amp;lt;song_tag&amp;gt; Obj_song_tag { get; set; }

//导航属性，ManyToOne/OneToOne
[Navigate(&quot;song_id&quot;)]
public virtual Song Obj_song { get; set; }

//导航属性，ManyToMany
[Navigate(ManyToMany = typeof(tag_song))]
public virtual List&amp;lt;tag&amp;gt; tags { get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可约定，可不约定；&lt;/li&gt;
&lt;li&gt;不约定的，需指定 Navigate 特性关联；&lt;/li&gt;
&lt;li&gt;无关联的，查询时可以指明 On 条件，LeftJoin(a =&amp;gt; a.Parent.Id == a.ParentId)；&lt;/li&gt;
&lt;li&gt;已关联的，直接使用导航对象就行，On 条件会自动附上；&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;也可以使用 FluentApi 在外部设置导航关系：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;fsql.CodeFirst.ConfigEntity&amp;lt;实体类&amp;gt;(a =&amp;gt; a
    .Navigate(b =&amp;gt; b.roles, null, typeof(多对多中间实体类))
    .Navigate(b =&amp;gt; b.users, &quot;uid&quot;)
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优先级，特性 &amp;gt; FluentApi&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;FreeSql 发布已经10个月了，元旦将发布 1.0 正式版，希望将来可以成为 .net 社区下给力的轮子，也算是我不枉十几年对 .net 不离不弃的一点贡献吧。&lt;/p&gt;
&lt;p&gt;希望 FreeSql 越来越好，&lt;/p&gt;
&lt;p&gt;原 .net core 越来越好！（虽然 3.0 升级很多人翻了车，有心中那些情怀在，翻了车最多是骂几句而已，骂完还得接着用它）&lt;/p&gt;
&lt;p&gt;教程地址：&lt;a href=&quot;https://www.cnblogs.com/kellynic/p/11531945.html&quot;&gt;《FreeSql 新手上路系列教程已发布在 cnblogs》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/2881099&quot; class=&quot;uri&quot;&gt;https://github.com/2881099&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Sep 2019 17:35:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>写在前面 FreeSql 一个款 .net 平台下支持 .net framework 4.5+、.net core 2.1+ 的开源 ORM。单元测试超过3100+，正在不断吸引新的开发者，生命不息开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kellynic/p/11610724.html</dc:identifier>
</item>
<item>
<title>Micronaut 微服务中使用 Kafka - SpringForAll</title>
<link>http://www.cnblogs.com/springforall/p/11610643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/springforall/p/11610643.html</guid>
<description>&lt;p&gt;今天，我们将通过&lt;code&gt;Apache Kafka&lt;/code&gt;topic构建一些彼此异步通信的微服务。我们使用&lt;code&gt;Micronaut&lt;/code&gt;框架，它为与&lt;code&gt;Kafka&lt;/code&gt;集成提供专门的库。让我们简要介绍一下示例系统的架构。我们有四个微型服务：&lt;code&gt;订单服务&lt;/code&gt;，&lt;code&gt;行程服务&lt;/code&gt;，&lt;code&gt;司机服务&lt;/code&gt;和&lt;code&gt;乘客服务&lt;/code&gt;。这些应用程序的实现非常简单。它们都有内存存储，并连接到同一个&lt;code&gt;Kafka&lt;/code&gt;实例。&lt;/p&gt;
&lt;p&gt;我们系统的主要目标是为客户安排行程。订单服务应用程序还充当网关。它接收来自客户的请求，保存历史记录并将事件发送到&lt;code&gt;orders&lt;/code&gt;topic。所有其他微服务都在监听&lt;code&gt;orders&lt;/code&gt;这个topic，并处理&lt;code&gt;order-service&lt;/code&gt;发送的订单。每个微服务都有自己的专用topic，其中发送包含更改信息的事件。此类事件由其他一些微服务接收。架构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1234351/201909/1234351-20190930002631589-1816432052.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在阅读本文之前，有必要熟悉一下&lt;code&gt;Micronaut&lt;/code&gt;框架。您可以阅读之前的一篇文章，该文章描述了通过&lt;code&gt;REST API构建微服务通信的过程&lt;/code&gt;:&lt;a href=&quot;https://piotrminkowski.wordpress.com/2019/01/25/quick-guide-to-microservices-with-micronaut-framework/&quot;&gt;使用microaut框架构建微服务的快速指南&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;运行kafka&quot;&gt;1. 运行Kafka&lt;/h2&gt;
&lt;p&gt;要在本地机器上运行&lt;code&gt;Apache Kafka&lt;/code&gt;，我们可以使用它的Docker映像。最新的镜像是由https://hub.docker.com/u/wurstmeister共享的。在启动&lt;code&gt;Kafka&lt;/code&gt;容器之前，我们必须启动&lt;code&gt;kafka&lt;/code&gt;所用使用的&lt;code&gt;ZooKeeper&lt;/code&gt;服务器。如果在&lt;code&gt;Windows&lt;/code&gt;上运行&lt;code&gt;Docker&lt;/code&gt;，其虚拟机的默认地址是&lt;code&gt;192.168.99.100&lt;/code&gt;。它还必须设置为&lt;code&gt;Kafka&lt;/code&gt;容器的环境。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Zookeeper&lt;/code&gt;和&lt;code&gt;Kafka&lt;/code&gt;容器都将在同一个网络中启动。在docker中运行Zookeeper以&lt;code&gt;zookeeper&lt;/code&gt;的名称提供服务，并在暴露&lt;code&gt;2181&lt;/code&gt;端口。&lt;code&gt;Kafka&lt;/code&gt;容器需要在环境变量使用&lt;code&gt;KAFKA_ZOOKEEPER_CONNECT&lt;/code&gt;的地址。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ docker network create kafka
$ docker run -d --name zookeeper --network kafka -p 2181:2181 wurstmeister/zookeeper
$ docker run -d --name kafka -p 9092:9092 --network kafka --env KAFKA_ADVERTISED_HOST_NAME=192.168.99.100 --env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 wurstmeister/kafka&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;引入micronaut-kafka依赖&quot;&gt;2. 引入Micronaut Kafka依赖&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;Kafka&lt;/code&gt;构建的&lt;code&gt;microaut&lt;/code&gt;应用程序可以在HTTP服务器存在的情况下启动，也可以在不存在HTTP服务器的情况下启动。要启用&lt;code&gt;Micronaut Kafka&lt;/code&gt;，需要添加&lt;code&gt;micronaut-kafka&lt;/code&gt;库到依赖项。如果您想暴露&lt;code&gt;HTTP API&lt;/code&gt;，您还应该添加&lt;code&gt;micronaut-http-server-netty&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.micronaut.configuration&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;micronaut-kafka&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.micronaut&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;micronaut-http-server-netty&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构建订单微服务&quot;&gt;3. 构建订单微服务&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;订单微服务&lt;/code&gt;是唯一一个启动嵌入式HTTP服务器并暴露&lt;code&gt;REST API&lt;/code&gt;的应用程序。这就是为什么我们可以为&lt;code&gt;Kafka&lt;/code&gt;提供内置&lt;code&gt;Micronaut&lt;/code&gt;健康检查。要做到这一点，我们首先应该添加&lt;code&gt;micronaut-management&lt;/code&gt;依赖:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.micronaut&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;micronaut-management&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便起见，我们将通过在&lt;code&gt;application.yml&lt;/code&gt;中定义以下配置来启用所有管理端点并禁用它们的HTTP身份验证。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;endpoints:
  all:
    enabled: true
    sensitive: false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，可以在地址http://localhost:8080/health下使用&lt;code&gt;health check&lt;/code&gt;。我们的示例应用程序还将暴露&lt;code&gt;添加新订单&lt;/code&gt;和&lt;code&gt;列出所有以前创建的订单&lt;/code&gt;的简单&lt;code&gt;REST API&lt;/code&gt;。下面是暴露这些端点的&lt;code&gt;Micronaut&lt;/code&gt;控制器实现:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller(&quot;orders&quot;)
public class OrderController {

    @Inject
    OrderInMemoryRepository repository;
    @Inject
    OrderClient client;

    @Post
    public Order add(@Body Order order) {
        order = repository.add(order);
        client.send(order);
        return order;
    }

    @Get
    public Set&amp;lt;Order&amp;gt; findAll() {
        return repository.findAll();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个微服务都使用内存存储库实现。以下是&lt;code&gt;订单微服务（Order-Service）&lt;/code&gt;中的存储库实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Singleton
public class OrderInMemoryRepository {

    private Set&amp;lt;Order&amp;gt; orders = new HashSet&amp;lt;&amp;gt;();

    public Order add(Order order) {
        order.setId((long) (orders.size() + 1));
        orders.add(order);
        return order;
    }

    public void update(Order order) {
        orders.remove(order);
        orders.add(order);
    }

    public Optional&amp;lt;Order&amp;gt; findByTripIdAndType(Long tripId, OrderType type) {
        return orders.stream().filter(order -&amp;gt; order.getTripId().equals(tripId) &amp;amp;&amp;amp; order.getType() == type).findAny();
    }

    public Optional&amp;lt;Order&amp;gt; findNewestByUserIdAndType(Long userId, OrderType type) {
        return orders.stream().filter(order -&amp;gt; order.getUserId().equals(userId) &amp;amp;&amp;amp; order.getType() == type)
                .max(Comparator.comparing(Order::getId));
    }

    public Set&amp;lt;Order&amp;gt; findAll() {
        return orders;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内存存储库存储&lt;code&gt;Order&lt;/code&gt;对象实例。&lt;code&gt;Order&lt;/code&gt;对象还被发送到名为&lt;code&gt;orders&lt;/code&gt;的Kafkatopic。下面是&lt;code&gt;Order&lt;/code&gt;类的实现:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Order {

    private Long id;
    private LocalDateTime createdAt;
    private OrderType type;
    private Long userId;
    private Long tripId;
    private float currentLocationX;
    private float currentLocationY;
    private OrderStatus status;

    // ... GETTERS AND SETTERS
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用kafka异步通信&quot;&gt;4. 使用Kafka异步通信&lt;/h2&gt;
&lt;p&gt;现在，让我们想一个可以通过示例系统实现的用例——&lt;code&gt;添加新的行程&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们创建了&lt;code&gt;OrderType.NEW_TRIP&lt;/code&gt;类型的新订单。在此之后，(1)&lt;code&gt;订单服务&lt;/code&gt;创建一个订单并将其发送到&lt;code&gt;orders&lt;/code&gt;topic。订单由三个微服务接收:&lt;code&gt;司机服务&lt;/code&gt;、&lt;code&gt;乘客服务&lt;/code&gt;和&lt;code&gt;行程服务&lt;/code&gt;。&lt;br/&gt;(2)所有这些应用程序都处理这个新订单。&lt;code&gt;乘客服务&lt;/code&gt;应用程序检查乘客帐户上是否有足够的资金。如果没有，它就取消了行程，否则什么也做不了。&lt;code&gt;司机服务&lt;/code&gt;正在寻找最近可用的司机，(3)&lt;code&gt;行程服务&lt;/code&gt;创建和存储新的行程。&lt;code&gt;司机服务&lt;/code&gt;和&lt;code&gt;行程服务&lt;/code&gt;都将事件发送到它们的topic(&lt;code&gt;drivers&lt;/code&gt;, &lt;code&gt;trips&lt;/code&gt;),其中包含相关更改的信息。&lt;/p&gt;
&lt;p&gt;每一个事件可以被其他&lt;code&gt;microservices&lt;/code&gt;访问,例如，(4)&lt;code&gt;行程服务&lt;/code&gt;侦听来自&lt;code&gt;司机服务&lt;/code&gt;的事件，以便为行程分配一个新的司机&lt;/p&gt;
&lt;p&gt;下图说明了在添加新的行程时，我们的微服务之间的通信过程。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1234351/201909/1234351-20190930002633017-1440201269.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;现在，让我们继续讨论实现细节。&lt;/p&gt;
&lt;h3 id=&quot;发送订单&quot;&gt;4.1. 发送订单&lt;/h3&gt;
&lt;p&gt;首先，我们需要创建Kafka 客户端，负责向topic发送消息。我们创建的一个接口，命名为&lt;code&gt;OrderClient&lt;/code&gt;，为它添加&lt;code&gt;@KafkaClient&lt;/code&gt;并声明用于发送消息的一个或多个方法。每个方法都应该通过&lt;code&gt;@Topic&lt;/code&gt;注解设置目标topic名称。对于方法参数，我们可以使用三个注解&lt;code&gt;@KafkaKey&lt;/code&gt;、&lt;code&gt;@Body&lt;/code&gt;或&lt;code&gt;@Header&lt;/code&gt;。&lt;code&gt;@KafkaKey&lt;/code&gt;用于分区，这是我们的示例应用程序所需要的。在下面可用的客户端实现中，我们只使用&lt;code&gt;@Body&lt;/code&gt;注解。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@KafkaClient
public interface OrderClient {

    @Topic(&quot;orders&quot;)
    void send(@Body Order order);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;接收订单&quot;&gt;4.2. 接收订单&lt;/h3&gt;
&lt;p&gt;一旦客户端发送了一个订单，它就会被监听&lt;code&gt;orders&lt;/code&gt;topic的所有其他微服务接收。下面是&lt;code&gt;司机服务&lt;/code&gt;中的监听器实现。监听器类&lt;code&gt;OrderListener&lt;/code&gt;应该添加&lt;code&gt;@KafkaListener&lt;/code&gt;注解。我们可以声明&lt;code&gt;groupId&lt;/code&gt;作为一个注解参数，以防止单个应用程序的多个实例接收相同的消息。然后，我们声明用于处理传入消息的方法。与客户端方法相同，应该通过&lt;code&gt;@Topic&lt;/code&gt;注解设置目标topic名称，因为我们正在监听&lt;code&gt;Order&lt;/code&gt;对象，所以应该使用&lt;code&gt;@Body&lt;/code&gt;注解——与对应的客户端方法相同。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@KafkaListener(groupId = &quot;driver&quot;)
public class OrderListener {

    private static final Logger LOGGER = LoggerFactory.getLogger(OrderListener.class);

    private DriverService service;

    public OrderListener(DriverService service) {
        this.service = service;
    }

    @Topic(&quot;orders&quot;)
    public void receive(@Body Order order) {
        LOGGER.info(&quot;Received: {}&quot;, order);
        switch (order.getType()) {
            case NEW_TRIP -&amp;gt; service.processNewTripOrder(order);
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发送到其他topic&quot;&gt;4.3. 发送到其他topic&lt;/h3&gt;
&lt;p&gt;现在，让我们看一下&lt;code&gt;司机服务&lt;/code&gt;中的&lt;code&gt;processNewTripOrder&lt;/code&gt;方法。&lt;code&gt;DriverService&lt;/code&gt;注入两个不同的&lt;code&gt;Kafka Client&lt;/code&gt;&lt;br/&gt;bean: &lt;code&gt;OrderClient&lt;/code&gt;和&lt;code&gt;DriverClient&lt;/code&gt;。当处理新订单时，它将试图寻找与发送订单的乘客最近的司机。找到他之后，将该司机的状态更改为&lt;code&gt;UNAVAILABLE&lt;/code&gt;，并将带有&lt;code&gt;Driver&lt;/code&gt;对象的事件发送到&lt;code&gt;drivers&lt;/code&gt;topic。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Singleton
public class DriverService {

    private static final Logger LOGGER = LoggerFactory.getLogger(DriverService.class);

    private DriverClient client;
    private OrderClient orderClient;
    private DriverInMemoryRepository repository;

    public DriverService(DriverClient client, OrderClient orderClient, DriverInMemoryRepository repository) {
        this.client = client;
        this.orderClient = orderClient;
        this.repository = repository;
    }

    public void processNewTripOrder(Order order) {
        LOGGER.info(&quot;Processing: {}&quot;, order);
        Optional&amp;lt;Driver&amp;gt; driver = repository.findNearestDriver(order.getCurrentLocationX(), order.getCurrentLocationY());
        driver.ifPresent(driverLocal -&amp;gt; {
            driverLocal.setStatus(DriverStatus.UNAVAILABLE);
            repository.updateDriver(driverLocal);
            client.send(driverLocal, String.valueOf(order.getId()));
            LOGGER.info(&quot;Message sent: {}&quot;, driverLocal);
        });
    }

    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是&lt;code&gt;Kafka Client&lt;/code&gt;在&lt;code&gt;司机服务&lt;/code&gt;中的实现，用于向&lt;code&gt;driver&lt;/code&gt;topic发送消息。因为我们需要将&lt;code&gt;Driver&lt;/code&gt;与&lt;code&gt;Order&lt;/code&gt; 关联起来，所以我们使用&lt;code&gt;@Header&lt;/code&gt;注解 的&lt;code&gt;orderId&lt;/code&gt;参数。没有必要把它包括到&lt;code&gt;Driver&lt;/code&gt;类中，将其分配给监听器端的正确行程。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@KafkaClient
public interface DriverClient {

    @Topic(&quot;drivers&quot;)
    void send(@Body Driver driver, @Header(&quot;Order-Id&quot;) String orderId);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务间通信&quot;&gt;4.4. 服务间通信&lt;/h3&gt;
&lt;p&gt;由&lt;code&gt;DriverListener&lt;/code&gt;收到&lt;code&gt;@KafkaListener&lt;/code&gt;在&lt;code&gt;行程服务&lt;/code&gt;中声明。它监听传入到&lt;code&gt;trip&lt;/code&gt;topic。接收方法的参数和客户端发送方法的类似，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@KafkaListener(groupId = &quot;trip&quot;)
public class DriverListener {

    private static final Logger LOGGER = LoggerFactory.getLogger(OrderListener.class);

    private TripService service;

    public DriverListener(TripService service) {
        this.service = service;
    }

    @Topic(&quot;drivers&quot;)
    public void receive(@Body Driver driver, @Header(&quot;Order-Id&quot;) String orderId) {
        LOGGER.info(&quot;Received: driver-&amp;gt;{}, header-&amp;gt;{}&quot;, driver, orderId);
        service.processNewDriver(driver);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一步，将&lt;code&gt;orderId&lt;/code&gt;查询到的行程&lt;code&gt;Trip&lt;/code&gt;与&lt;code&gt;driverId&lt;/code&gt;关联，这样整个流程就结束。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Singleton
public class TripService {

    private static final Logger LOGGER = LoggerFactory.getLogger(TripService.class);

    private TripInMemoryRepository repository;
    private TripClient client;

    public TripService(TripInMemoryRepository repository, TripClient client) {
        this.repository = repository;
        this.client = client;
    }


    public void processNewDriver(Driver driver, String orderId) {
        LOGGER.info(&quot;Processing: {}&quot;, driver);
        Optional&amp;lt;Trip&amp;gt; trip = repository.findByOrderId(Long.valueOf(orderId));
        trip.ifPresent(tripLocal -&amp;gt; {
            tripLocal.setDriverId(driver.getId());
            repository.update(tripLocal);
        });
    }

    // ... OTHER METHODS

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;跟踪&quot;&gt;5. 跟踪&lt;/h2&gt;
&lt;p&gt;我们可以使用&lt;code&gt;Micronaut Kafka&lt;/code&gt;轻松地启用分布式跟踪。首先，我们需要启用和配置&lt;code&gt;Micronaut&lt;/code&gt;跟踪。要做到这一点，首先应该添加一些依赖项：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.micronaut&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;micronaut-tracing&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.zipkin.brave&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;brave-instrumentation-http&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.zipkin.reporter2&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;zipkin-reporter&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.opentracing.brave&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;brave-opentracing&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.opentracing.contrib&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;opentracing-kafka-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.16&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还需要在&lt;code&gt;application.yml&lt;/code&gt;配置文件中，配置Zipkin 的追踪的地址等。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;tracing:
  zipkin:
    enabled: true
    http:
      url: http://192.168.99.100:9411
    sampler:
      probability: 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在启动应用程序之前，我们必须运行&lt;code&gt;Zipkin&lt;/code&gt;容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run -d --name zipkin -p 9411:9411 openzipkin/zipkin&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;6. 总结&lt;/h2&gt;
&lt;p&gt;在本文中，您将了解通过&lt;code&gt;Apache Kafka&lt;/code&gt;使用异步通信构建微服务架构的过程。我已经向大家展示了&lt;code&gt;Microaut Kafka&lt;/code&gt;库最重要的特性，它允许您轻松地声明&lt;code&gt;Kafka&lt;/code&gt;topic的生产者和消费者，为您的微服务启用&lt;code&gt;健康检查&lt;/code&gt;和&lt;code&gt;分布式跟踪&lt;/code&gt;。我已经为我们的系统描述了一个简单的场景的实现，包括根据客户的请求添加一个新的行程。本示例系统的整体实现，请查看GitHub上的&lt;a href=&quot;https://github.com/piomin/sample-kafka-micronaut-microservices.git.&quot;&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.4179104477612&quot;&gt;
&lt;p&gt;原文链接：https://piotrminkowski.wordpress.com/2019/08/06/kafka-in-microservices-with-micronaut/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://piotrminkowski.wordpress.com/&quot;&gt;Piotr's&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;https://blog.csdn.net/u010046908&quot;&gt;李东&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 29 Sep 2019 16:27:00 +0000</pubDate>
<dc:creator>SpringForAll</dc:creator>
<og:description>今天，我们将通过 topic构建一些彼此异步通信的微服务。我们使用 框架，它为与 集成提供专门的库。让我们简要介绍一下示例系统的架构。我们有四个微型服务： ，`行程服务 司机服务 乘客服务 Kafka</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/springforall/p/11610643.html</dc:identifier>
</item>
<item>
<title>分库分表之后，id 主键如何处理？ - 米兜Java</title>
<link>http://www.cnblogs.com/midoujava/p/11610492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/midoujava/p/11610492.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/c1864375cefe4961a2c87434d1a0ed5e&quot; title=&quot;关注米兜Java&quot; alt=&quot;关注米兜Java.md&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;面试题&quot;&gt;面试题&lt;/h2&gt;
&lt;p&gt;分库分表之后，id 主键如何处理？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;面试官心理分析&lt;/h2&gt;
&lt;p&gt;其实这是分库分表之后你必然要面对的一个问题，就是 id 咋生成？因为要是分成多个表之后，每个表都是从 1 开始累加，那肯定不对啊，需要一个&lt;strong&gt;全局唯一&lt;/strong&gt;的 id 来支持。所以这都是你实际生产环境中必须考虑的问题。&lt;/p&gt;
&lt;h2 id=&quot;面试题剖析&quot;&gt;面试题剖析&lt;/h2&gt;
&lt;h3 id=&quot;基于数据库的实现方案&quot;&gt;基于数据库的实现方案&lt;/h3&gt;
&lt;h4 id=&quot;数据库自增-id&quot;&gt;数据库自增 id&lt;/h4&gt;
&lt;p&gt;这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。&lt;/p&gt;
&lt;p&gt;这个方案的好处就是方便简单，谁都会用；&lt;strong&gt;缺点就是单库生成&lt;/strong&gt;自增 id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增几个 id，一次性返回一批 id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是&lt;strong&gt;无论如何都是基于单个数据库&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适合的场景&lt;/strong&gt;：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你&lt;strong&gt;并发不高，但是数据量太大&lt;/strong&gt;导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。&lt;/p&gt;
&lt;h4 id=&quot;设置数据库-sequence-或者表自增字段步长&quot;&gt;设置数据库 sequence 或者表自增字段步长&lt;/h4&gt;
&lt;p&gt;可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。&lt;/p&gt;
&lt;p&gt;比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1756639/201909/1756639-20190929231341180-1764461227.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适合的场景&lt;/strong&gt;：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。&lt;/p&gt;
&lt;h3 id=&quot;uuid&quot;&gt;UUID&lt;/h3&gt;
&lt;p&gt;好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，&lt;strong&gt;作为主键性能太差&lt;/strong&gt;了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。&lt;/p&gt;
&lt;p&gt;适合的场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;UUID.randomUUID().toString().replace(“-”, “”) -&amp;gt; sfsdf23423rr234sfdaf&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取系统当前时间&quot;&gt;获取系统当前时间&lt;/h3&gt;
&lt;p&gt;这个就是获取当前时间即可，但是问题是，&lt;strong&gt;并发很高的时候&lt;/strong&gt;，比如一秒并发几千，&lt;strong&gt;会有重复的情况&lt;/strong&gt;，这个是肯定不合适的。基本就不用考虑了。&lt;/p&gt;
&lt;p&gt;适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。&lt;/p&gt;
&lt;h3 id=&quot;snowflake-算法&quot;&gt;snowflake 算法&lt;/h3&gt;
&lt;p&gt;snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。&lt;/li&gt;
&lt;li&gt;41 bit：表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 &lt;code&gt;2^41 - 1&lt;/code&gt;，也就是可以标识 &lt;code&gt;2^41 - 1&lt;/code&gt; 个毫秒值，换算成年就是表示69年的时间。&lt;/li&gt;
&lt;li&gt;10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10台机器上哪，也就是1024台机器。但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 &lt;code&gt;2^5&lt;/code&gt;个机房（32个机房），每个机房里可以代表 &lt;code&gt;2^5&lt;/code&gt; 个机器（32台机器）。&lt;/li&gt;
&lt;li&gt;12 bit：这个是用来记录同一个毫秒内产生的不同 id，12 bit 可以代表的最大正整数是 &lt;code&gt;2^12 - 1 = 4096&lt;/code&gt;，也就是说可以用这个 12 bit 代表的数字来区分&lt;strong&gt;同一个毫秒内&lt;/strong&gt;的 4096 个不同的 id。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class IdWorker {

    private long workerId;
    private long datacenterId;
    private long sequence;

    public IdWorker(long workerId, long datacenterId, long sequence) {
        // sanity check for workerId
        // 这儿不就检查了一下，要求就是你传递进来的机房id和机器id不能超过32，不能小于0
        if (workerId &amp;gt; maxWorkerId || workerId &amp;lt; 0) {
            throw new IllegalArgumentException(
                    String.format(&quot;worker Id can't be greater than %d or less than 0&quot;, maxWorkerId));
        }
        if (datacenterId &amp;gt; maxDatacenterId || datacenterId &amp;lt; 0) {
            throw new IllegalArgumentException(
                    String.format(&quot;datacenter Id can't be greater than %d or less than 0&quot;, maxDatacenterId));
        }
        System.out.printf(
                &quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;,
                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);

        this.workerId = workerId;
        this.datacenterId = datacenterId;
        this.sequence = sequence;
    }

    private long twepoch = 1288834974657L;

    private long workerIdBits = 5L;
    private long datacenterIdBits = 5L;

    // 这个是二进制运算，就是 5 bit最多只能有31个数字，也就是说机器id最多只能是32以内
    private long maxWorkerId = -1L ^ (-1L &amp;lt;&amp;lt; workerIdBits);

    // 这个是一个意思，就是 5 bit最多只能有31个数字，机房id最多只能是32以内
    private long maxDatacenterId = -1L ^ (-1L &amp;lt;&amp;lt; datacenterIdBits);
    private long sequenceBits = 12L;

    private long workerIdShift = sequenceBits;
    private long datacenterIdShift = sequenceBits + workerIdBits;
    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;
    private long sequenceMask = -1L ^ (-1L &amp;lt;&amp;lt; sequenceBits);

    private long lastTimestamp = -1L;

    public long getWorkerId() {
        return workerId;
    }

    public long getDatacenterId() {
        return datacenterId;
    }

    public long getTimestamp() {
        return System.currentTimeMillis();
    }

    public synchronized long nextId() {
        // 这儿就是获取当前时间戳，单位是毫秒
        long timestamp = timeGen();

        if (timestamp &amp;lt; lastTimestamp) {
            System.err.printf(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp);
            throw new RuntimeException(String.format(
                    &quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));
        }

        if (lastTimestamp == timestamp) {
            // 这个意思是说一个毫秒内最多只能有4096个数字
            // 无论你传递多少进来，这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围
            sequence = (sequence + 1) &amp;amp; sequenceMask;
            if (sequence == 0) {
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0;
        }

        // 这儿记录一下最近一次生成id的时间戳，单位是毫秒
        lastTimestamp = timestamp;

        // 这儿就是将时间戳左移，放到 41 bit那儿；
        // 将机房 id左移放到 5 bit那儿；
        // 将机器id左移放到5 bit那儿；将序号放最后12 bit；
        // 最后拼接起来成一个 64 bit的二进制数字，转换成 10 进制就是个 long 型
        return ((timestamp - twepoch) &amp;lt;&amp;lt; timestampLeftShift) | (datacenterId &amp;lt;&amp;lt; datacenterIdShift)
                | (workerId &amp;lt;&amp;lt; workerIdShift) | sequence;
    }

    private long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp &amp;lt;= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }

    private long timeGen() {
        return System.currentTimeMillis();
    }

    // ---------------测试---------------
    public static void main(String[] args) {
        IdWorker worker = new IdWorker(1, 1, 1);
        for (int i = 0; i &amp;lt; 30; i++) {
            System.out.println(worker.nextId());
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么说呢，大概这个意思吧，就是说 41 bit 是当前毫秒单位的一个时间戳，就这意思；然后 5 bit 是你传递进来的一个&lt;strong&gt;机房&lt;/strong&gt; id（但是最大只能是 32 以内），另外 5 bit 是你传递进来的&lt;strong&gt;机器&lt;/strong&gt; id（但是最大只能是 32 以内），剩下的那个 12 bit序列号，就是如果跟你上次生成 id 的时间还在一个毫秒内，那么会把顺序给你累加，最多在 4096 个序号以内。&lt;/p&gt;
&lt;p&gt;所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是 0。然后每次接收到一个请求，说这个机房的这个机器要生成一个 id，你就找到对应的 Worker 生成。&lt;/p&gt;
&lt;p&gt;利用这个 snowflake 算法，你可以开发自己公司的服务，甚至对于机房 id 和机器 id，反正给你预留了 5 bit + 5 bit，你换成别的有业务含义的东西也可以的。&lt;/p&gt;
&lt;p&gt;这个 snowflake 算法相对来说还是比较靠谱的，所以你要真是搞分布式 id 生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。&lt;/p&gt;
&lt;p&gt;本文在米兜公众号链接:&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/mt8bVpM57SsI-nvTRKxSKg&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s/mt8bVpM57SsI-nvTRKxSKg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎关注米兜Java，一个注在共享、交流的Java学习平台。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://graph.baidu.com/resource/2127b62307ecaf0bac70201566400691.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Sep 2019 15:14:00 +0000</pubDate>
<dc:creator>米兜Java</dc:creator>
<og:description>面试题 分库分表之后，id 主键如何处理？ 面试官心理分析 其实这是分库分表之后你必然要面对的一个问题，就是 id 咋生成？因为要是分成多个表之后，每个表都是从 1 开始累加，那肯定不对啊，需要一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/midoujava/p/11610492.html</dc:identifier>
</item>
<item>
<title>Python 编译器与解释器 - 挽手说梦话！</title>
<link>http://www.cnblogs.com/jqc6/p/11610435.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jqc6/p/11610435.html</guid>
<description>&lt;p&gt;Python 编译器与解释器&lt;/p&gt;
&lt;p&gt;Python的环境我们已经搭建好了，可以开始学习基础知识了。但是，在此之前，还要先说说编译器与解释器相关的内容。&lt;/p&gt;
&lt;p&gt;如果这部分内容，让你觉得难以理解或不能完全明白，可以暂时跳过，等以后再回过头来重新读一遍。&lt;/p&gt;
&lt;h2 id=&quot;_1&quot;&gt;一、数据的表示方式&lt;/h2&gt;
&lt;p&gt;我们都知道，现实生活中，数字的表示方式有很多种，常见的有二进制、八进制、十进制和十六进制。十进制我们都很熟悉，加法口诀表我们都背过，主要是使用0~9，这10个阿拉伯数字来构建整个十进制的体系，其中最核心的法则是“逢十进一”，借位则是“借一当十”。那么为什么全世界不管什么国家，什么历史，什么文化水平基本都是用十进制作为基本进制呢？是因为我们人有10个手指头，掰起来最方便！我们对十进制有着天然的友好度。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/p8cfuwot4k8ixzxs5s5iy6fh/image.png&quot; alt=&quot;image.png-139.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么对于计算机呢？计算机不是人，没有10个手指头可以掰，所以它用不了十进制。那么它用几进制？二进制！二进制是用0和1两个数码来表示的数，也就是形如010101010的样子。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/gi6qsw8crf1z7mo43ohhwssx/image.png&quot; alt=&quot;image.png-246.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么计算机要使用二进制作为自己的机器语言也就是数据的表示方式呢？因为计算机最小的计算单元是根据开关状态高低电平来确定的，它只有开和关，高和低的概念，换成数学就是0和1的两种。同样的，在物理存储方面，硬盘的磁道只能区分打孔和未打孔的状态，也是0和1两种。同时二进制便于进行加、减运算和计数编码。二进制与十进制数易于互相转换。二进制便于逻辑判断（是或非），逻辑判断通常也是两种状态，这和二进制很搭配。二进制表示数据还具有抗干扰能力强，可靠性高的特点，因为当受到一定程度的电磁干扰时，只要可以分辨出它是高电平还是低电平，至于高多少或低多少并不重要，就能区分0和1，这在网络信号中，就是天生自带抗干扰能力。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/n2jka1wktqd3tl2rj8o8j9r5/image.png&quot; alt=&quot;image.png-46.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，在人机交流上，&lt;strong&gt;二进位制有致命的弱点，数字的书写特别冗长，并且没有人类可读性&lt;/strong&gt;！例如，十进位制的100000写成二进制就是11000011010100000，长了好几倍，而且你能从一个这么长的二进制数里读出它的十进制数是多少吗？&lt;/p&gt;
&lt;p&gt;计算机不能独立存在，目前也无法自我创造，不管是输入还是输出，它的一切都必须和人交流。那么问题来了，人类只能读10进制和英语、汉语等，可计算机只会010101，至于英语、汉语对它而言更是天书。那么我们是怎么和计算机交流的呢？怎么将我们的英语或者汉语编码成计算机能够识别的1010101呢？&lt;/p&gt;
&lt;h2 id=&quot;_2&quot;&gt;二、 编程语言发展历程&lt;/h2&gt;
&lt;h3 id=&quot;1&quot;&gt;1. 打孔纸条&lt;/h3&gt;
&lt;p&gt;我们已经知道了计算机只懂机器语言，也就是二进制的数据表示方式，任何对它的操作和编码，最终都要统一到这上面来，然而这是一个悲伤的故事。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/evkduns8qfxwszewg8x4hwam/image.png&quot; alt=&quot;image.png-146.2kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;起初，为了让计算机按我们的想法工作，程序员不得不编写计算机可以读懂看明白直接执行的机器码，也就是01010101的样子，打孔字条就是这么干的。用打没打孔来代表0和1。OK，计算机没问题，它能无障碍阅读，可程序员就难受了。拍脑袋也能想得到这里面的问题。&lt;strong&gt;容易出错，效率低，编写困难，维护困难&lt;/strong&gt;。可能就是个简单的打印“hello world”，也许就需要好几米长的字条。这简直就是原始社会，生产效率低下的令人发指。发生个火灾什么的，直接Over。唯一的好处就是无需转换，可直接执行，但相对缺点来讲，这点好处完全可以被忽略。&lt;/p&gt;
&lt;h3 id=&quot;2&quot;&gt;2. 汇编语言&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/nyr7vigh76oghbis1strcee0/image.png&quot; alt=&quot;image.png-357.6kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;汇编语言是一种可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。也就是说不同平台之间不可直接移植，它是平台相关的，你在这个硬件平台写的汇编程序，换到另外一套硬件上去是运行不了的。 因此，汇编语言通常被应用在底层，硬件操作和高要求的程序优化的场合。驱动程序、嵌入式操作系统和实时运行程序较多使用汇编语言。相比于机器码，它更偏向人类的语言习惯，更易于编写和阅读，也就是有一点抽象符号概念化了，这大大提高了编程效率。但是，这依然是一种低级语言，还有改善和提高的空间。&lt;/p&gt;
&lt;p&gt;上面一段看得晕没关系，简单地说就是汇编语言相比打孔纸条，对人类更友好一点了，至少能用几个类似ADD\CALL\MOV的英文缩写了。但是，它牺牲了一定的性能，并且依然不够友好。&lt;/p&gt;
&lt;h3 id=&quot;3-c&quot;&gt;3. C语言&lt;/h3&gt;
&lt;p&gt;在C语言之前其实还有很多低级语言，我们不关心它们。为了让编程更简单，更高效，聪明的计算机程序员，一步步发明了FORTRAN、BASIC、B等许多语言，然后在1972年诞生了无人不知，应用最广，影响最深，至今仍然地位不可动摇的C语言。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/4ep969o5viseafa2qxlcwz4j/image.png&quot; alt=&quot;image.png-125.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C语言为什么这么厉害？归根结底是一句话：直接操作硬件！同样的算法，用C语言，其执行效率超过JAVA等语言很多。那可能有人会问，C和汇编和机器码比呢？肯定是C慢，但是写个汇编程序和写个C程序的效率差别那就更大了。C语言在人类友好性和底层相关性上达到了一个高度的平衡。这两者是互相矛盾的，不可同时兼得。&lt;/p&gt;
&lt;p&gt;C干了些什么？其实它就是在人类友好性方面相比以前跨出了更大一步。人类是方便了，可机器就迷糊了！你给我这么多字符都是啥意思？机器它只懂二进制啊！那么C的代码是如何被执行的呢？这就得请出编译器了！&lt;/p&gt;
&lt;p&gt;编译器将编程语言写的代码翻译成机器能够执行或者说“看懂”的二进制机器码。&lt;/p&gt;
&lt;p&gt;其实我们安装JAVA也好，C也好，Python也罢，主要就是安装的这个编程语言的“编译器”。&lt;/p&gt;
&lt;h3 id=&quot;4-python&quot;&gt;4. Python语言&lt;/h3&gt;
&lt;p&gt;在几十年前，C语言是当之无愧的高级语言代表，现在也依然是语言排行榜第二的霸主。然而，在很多领域，它已经不太适用了，现今更主流的语言是那些上手快、简单易懂，说白了就是门槛低的语言，让更多的人能进入程序员行业，让编程能更容易、更快是未来的发展趋势。也就是说，需要进一步让编程语言更贴近人类语言，更远离机器语言。&lt;/p&gt;
&lt;p&gt;Python就是这么一种语言。它的语法简单明了，更贴近人类的使用习惯。作为一种动态解释性语言，让人们在写代码的时候可以更多的关注业务逻辑细节，而不需要花太多精力去关注数据类型定义、程序运行效率等！&lt;/p&gt;
&lt;p&gt;既然都说的是机器不懂的“人话”，那必然也需要一个Python“编译器”。对于Python语言，广义上的“编译器”，叫做解释器。&lt;/p&gt;
&lt;h2 id=&quot;_3&quot;&gt;三、 编译器与解释器&lt;/h2&gt;
&lt;p&gt;编译器/解释器：&lt;strong&gt;高级语言与机器之间的翻译官&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程有不同而已。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/u522zy10qfeykmvqpufjhgdk/image.png&quot; alt=&quot;image.png-515.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么两者有什么区别呢？&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/x6c0pdl90q1129rgfne1p5gy/image.png&quot; alt=&quot;image.png-182.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用一个通俗的例子进行比喻：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/lh7jc5xsx7e38yudllmn40e5/image.png&quot; alt=&quot;image.png-125.7kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于更深入的编译器和解释器是如何工作的，请参考史诗巨著《编译原理》，这本书有个外号，叫做“龙书”。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/w83xu9wpxr1ybp9b47zu47l6/image.png&quot; alt=&quot;image.png-305.4kB&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;python&quot;&gt;四、 Python解释器种类&lt;/h2&gt;
&lt;p&gt;Python有好几种版本的解释器：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPython&lt;/strong&gt;：官方版本的解释器。这个解释器是用C语言开发的，所以叫CPython。CPython是使用最广的Python解释器。我们通常说的、下载的、讨论的、使用的都是这个解释器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ipython&lt;/strong&gt;：基于CPython之上的一个交互式解释器，在交互方式上有所增强，执行Python代码的功能和CPython是完全一样的。CPython用&amp;gt;&amp;gt;&amp;gt;作为提示符，而IPython用In [序号]:作为提示符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PyPy&lt;/strong&gt;：一个追求执行速度的Python解释器。采用JIT技术，对Python代码进行动态编译（注意，不是解释），可以显著提高Python代码的执行速度。绝大部分CPython代码都可以在PyPy下运行，但还是有一些不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jython&lt;/strong&gt;：运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IronPython&lt;/strong&gt;：和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。&lt;/p&gt;
&lt;h2 id=&quot;python_1&quot;&gt;五、 Python的运行机制&lt;/h2&gt;
&lt;p&gt;Python作为动态解释性语言，其运行机制可参考下图（图片来自网络，其中的“编译器”是对解释器的广义称呼）：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/b8rpg9on1ms629hl0ldmpcne/image.png&quot; alt=&quot;image.png-157.1kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;都说解释器慢，Python也有想办法提高一下运行速度的，那就是使用pyc文件。这点参考了JAVA的字节码做法，但并不完全类同。&lt;/p&gt;
&lt;p&gt;我们编写的代码一般都会保存在以.py为后缀的文件中。在执行程序时，解释器逐行读取源代码并逐行解释运行。每执行一次，就重复一次这个过程，这其中耗费了大量的重复性的解释工作。为了减少这一重复性的解释工作，Python引入了pyc文件，pyc文件是将py文件的解释结果保存下来的文件，这样，下次再运行的时候就不用再解释了，直接使用pyc文件就可以了，这无疑大大提高了程序运行速度。&lt;/p&gt;
&lt;p&gt;对于pyc文件，你必须知道以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对于当前调用的主程序不会生成pyc文件&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以import xxx或from xxx import xxx等方式导入主程序的模块才会生成pyc文件&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;每次使用pyc文件时，都会根据pyc文件的创建时间和源模块进行对比，如果源模块有修改，则重新创建pyc文件，并覆盖先前的pyc文件，如果没有修改，直接使用pyc文件代替模块；&lt;/li&gt;
&lt;li&gt;pyc文件统一保存在模块所在目录的__pycache__文件夹内。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下图所示，modula_a被module_main导入后会生成对应的pyc文件，但是module_main不会生成pyc文件！！&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;http://static.zybuluo.com/feixuelove1009/unsuig1675ezmwqpqd1dptvv/image.png&quot; alt=&quot;image.png-68.9kB&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Sep 2019 14:58:00 +0000</pubDate>
<dc:creator>挽手说梦话！</dc:creator>
<og:description>Python 编译器与解释器 Python的环境我们已经搭建好了，可以开始学习基础知识了。但是，在此之前，还要先说说编译器与解释器相关的内容。 如果这部分内容，让你觉得难以理解或不能完全明白，可以暂时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jqc6/p/11610435.html</dc:identifier>
</item>
</channel>
</rss>