<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>编译基础理论 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12666772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12666772.html</guid>
<description>&lt;p&gt;　　最近在读一本编译相关的书《&lt;span&gt;&lt;a href=&quot;https://book.douban.com/subject/25908672/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;两周自制脚本语言&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》，书中用Java来设计一种名为Stone的脚本语言。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202004/211606-20200409142502648-702811258.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在下图中，源代码首先将进行词法分析，由一长串字符串细分为多个更小的字符串单元。分割后的字符串称为单词（token）。之后处理器将执行语法分析处理，把单词的排列转换为抽象语法树。至此为止，解释器与编译器的处理方式相同。之后，编译器将会把抽象语法树转换为其他语言，而解释器将会一边分析抽象语法树一边执行运算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202004/211606-20200409142602367-1112913334.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　语言处理器的第一个组成部分是词法分析器（lexical analyzer、lexer或scanner）。程序的源代码最初只是一长串字符串。从内部来看，源代码中的换行也能用专门的（不可见）换行符表示，因此整个源代码是一种相连的长字符串。这样的长字符串很难处理，语言处理器通常会首先将字符串中的字符以单词为单位分组，切割成多个子字符串。这就是词法分析。&lt;span&gt;&lt;a href=&quot;https://jflex.de/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;JFlex&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;工具可定义单词并自动生成词法分析器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）通过正则表达式定义单词&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　要设计词法分析器，首先要考虑每一种类型的单词定义，规定怎样的字符串才能构成一个单词。&lt;/p&gt;
&lt;p&gt;　　Stone语言支持三种类型的单词，即标识符、整型字面量及字符串字面量。&lt;/p&gt;
&lt;p&gt;　　（1）标识符（identifier）指的是变量名、函数名或类名等名称。此外，+或-等运算符及括号等标点符号也属于标识符。还有保留字也作为标识符处理。&lt;/p&gt;
&lt;p&gt;　　（2）整型字面量（integer literal）指的是127或2014等字符序列。&lt;/p&gt;
&lt;p&gt;　　（3）字符串字面量（string literal）是一串用于表示字符串的字符序列。双引号之间可以使用\n、\&quot;与\\这三种类型的转义字符。它们分别表示换行符、双引号和反斜杠。&lt;/p&gt;
&lt;p&gt;　　正则表达式（regular expression）是一种用于字符串模式匹配的书写记号。接下来，我们借助正则表达式来定义Stone语言的单词。&lt;/p&gt;
&lt;p&gt;　　（1）首先来定义整型字面量，它比较简单。&lt;/p&gt;

&lt;p&gt;　　（2）然后定义标识符，最后的\p{Punct}表示与任意一个标点符号字符匹配，这是Java的正则语法。模式\|\|将会匹配||。由于|是正则表达式的元字符，因此在使用时必须在前面添加\来转义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[A-Z_a-z][A-Z_a-z0-9]*|==|&amp;lt;=|&amp;gt;=|&amp;amp;&amp;amp;|\|\||\p{Punct}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）最后需要定义的是字符串字面量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&quot;(\\&quot;|\\\\|\\n|[^&quot;])*&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）设计词法分析器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　要利用这一功能设计词法分析器，首先要准备一个下面这样的正则表达式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;\s*((//.*)|(pat1)|(pat2)|pat3)?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，pat1是与整型字面量匹配的正则表达式，pat2与字符串字面量匹配，pat3则与标识符匹配。起始的\s与空字符匹配，\s*与0个及0个以上的空字符匹配。模式//.*匹配由//开始的任意长度的字符串，用于匹配代码注释。于是，上述正则表达式能匹配任意个空白符以及连在其后的注释、整型字面量、字符串字面量或标识符。又因为它最后以?结尾，所以仅由任意多个空白符组成的字符串也能与该模式匹配。&lt;/p&gt;
&lt;p&gt;　　执行词法分析时，语言处理器将逐行读取源代码，从各行开头起检查内容是否与该正则表达式匹配，并在检查完成后获取与正则表达式括号内的模式相匹配的字符串。&lt;/p&gt;
&lt;p&gt;　　只要像这样检查一下哪一个括号对应的不是null，就能知道行首出现的是哪种类型的单词。之后再继续用正则表达式匹配剩余部分，就能得到下一个单词。不断重复该过程，词法分析器就能获得由源代码分割而得的所有单词。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）自动机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　自动机（automaton）类似于一种极为简单的计算机。它的内部包含了一个仅能记录有限类型的值的内存，在接收新的输入后，新值将由输入值与当前值共同决定，并更新至内存中。自动机不支持包括四则运算或分支运算等在内的任何其他类型的运算。自动机程序实质是一张对应关系表，根据该表，我们能由输入值及当前内存值的组合，得到需要保存至内存中的新值。&lt;/p&gt;
&lt;p&gt;　　图中的自动机与正则表达式[0-9][0-9]*等价。圆圈内的数字表示自动机内存记录的当前值。圆圈（或其中的数字）称为状态。图中的箭头表示自动机在某一状态下，如果收到箭头旁标识的输入，将转换至箭头指向的状态（这一过程称为转换）。也就是说，如果圆圈内的数字是内存的当前值，且箭头旁的数字是自动机接受的输入，那么内存的值将被更新为箭头指向的圆圈内的数字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202004/211606-20200409143427137-1992866602.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　任何正则表达式都能转化为与之等价的有限状态机，也就是说自动机定能仅包含有限个圆圈。事实上，圆圈内的数字并没有特殊的含义。它们仅仅用于区分不同的圈圈。因此，有些图中的圆圈内不写数字。该图最为根本的一点在于，圆圈的数量有限（因此称为有限状态自动机）。&lt;/p&gt;
&lt;p&gt;　　字符串匹配的执行将从起始状态，即图中的状态1开始。自动机将从字符串头部开始逐一输入字符，并据此改变状态，最终抵达停止状态，即图中的状态2。执行途中如果找不到符合要求的箭头就会出现错误，字符串匹配失败。&lt;/p&gt;
&lt;p&gt;　　状态2是一个停止状态，其中，我们应当关注的是状态2上标有的箭头。可以看到，该自动机的状态2依然能够接受数字输入并继续执行。由于箭头从状态2出发又回到该状态，因此无论输入几次，自动机将始终处于状态2。只要输入内容是数字，自动机的执行将不断循环。&lt;/p&gt;
&lt;p&gt;　　要判断正则表达式是否与整个字符串匹配，程序需要检查字符串的最后一个字符输入后，自动机是否处于停止状态。如果没有到达停止状态，或中途出错，则表示字符串与正则表达式不匹配。&lt;/p&gt;
&lt;p&gt;　　下面我们再来看一个自动机的例子。这次我们尝试将一条更加复杂的正则表达式改写为自动机。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
\s*([0-9][0-9]*|[A-Za-z][A-Za-z0-9]*|=|==)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下图是与该正则表达式等价的自动机，它含有5种状态。其中，状态1是开始状态，其余都是停止状态。当自动机处于状态1时，它能根据输入的内容在4种模式中选择，并转换至相应的状态。如果输入的是空白符，自动机将保持状态1，直至接受到与某种模式匹配的字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202004/211606-20200409143851219-698111357.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由于模式=与==的首字符相同，因此对于这两种模式，自动机都将转换至状态4。如果下一个字符不是=，匹配将就此结束。如果自动机继续接受了一个字符=，就将转换至状态5并结束。状态5没有转换至其他状态的箭头，因此无论之后的输入是什么，匹配过程都会直接结束，不会进行判断。&lt;/p&gt;

&lt;p&gt;　　语言处理器在词法分析阶段将程序分割为单词后，将开始构造抽象语法树。抽象语法树（AST，Abstract Syntax Tree）是一种用于表示程序结构的树形结构。构造抽象语法树的过程称为语法分析，依然属于语言处理器的前半阶段。经过词法分析后，程序已经被分解为一个个单词。语法分析的主要任务是分析单词之间的关系，如判断哪些单词属于同一个表达式或语句，以及处理左右括号（单词）的配对等问题。语法分析的结果能够通过抽象语法树来表示。这一阶段还会检查程序中是否含有语法错误。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）抽象语法树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用树形结构来表现语法分析的结果，即通过对象来表示程序中的语句与表达式。接下来我们试着用抽象语法树来表示下面的Stone语言程序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
13 + x * 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只要将这个程序理解为算式13+x*2，即13与(x*2)的和即可。图下是它的对象形式表示，是一棵抽象语法树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202004/211606-20200409144148078-2100191153.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图上方的单词序列是词法分析阶段得到的结果。通过语法分析，就能得到如图所示的由对象形式表现的树形结构。图中的矩形表示对象。矩形上半部分显示的是类名。箭头表示的是字段，箭头旁边显示的文字是字段名。矩形下半部分列出的也是字段。&lt;/p&gt;
&lt;p&gt;　　BinaryExpr对象用于表示双目运算表达式。双目运算指的是四则运算等一些通过左值和右值计算新值的运算。&lt;/p&gt;
&lt;p&gt;　　图中含有两个BinaryExpr对象，其中一个用于表示乘法运算x*2，另一个用于表示加法运算13加x*2。加法运算的左侧是整型字面量13，它是一个NumberLiteral对象。右侧是x*2，它是另一个BinaryExpr对象。这样通过对象来表示运算符的左值与右值的方式能一目了然地显示各自表示的内容。&lt;/p&gt;
&lt;p&gt;　　表达式x*2左侧的x是一个变量名，因此能用Name对象来表示。右侧的2是一个整型字面量，因此以NumberLiteral对象表示。&lt;/p&gt;
&lt;p&gt;　　上图形如一棵上下颠倒的树，因此这种数据结构通常被称为树形结构。图中的矩形（对象）称为节点（node），箭头称为树枝或边。图的上方的BinaryExpr对象称为根节点。NumberLiteral对象及Name对象这类不含树枝的节点被称为叶节点。如果一个节点含有若干树枝，树枝连接的节点就是该节点的子节点，它们与该节点组成的整体称为子树。&lt;/p&gt;
&lt;p&gt;　　在很多教材中，抽象语法树会用更加简洁的形式表示，如下图所示，树形结构通过箭头呈现。这种表示树形结构的方式没有限定具体的实现方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202004/211606-20200409144552455-1349702462.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　抽象语法树仅用于表示语法分析的结果，因此通过词法分析得到的单词并不一定要与抽象语法树的节点一一对应。抽象语法树是一种去除了多余信息的抽象树形结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
(13 + x) * 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对这样一个表达式来说，它与之前的例子不同，包含了括号。乘法运算的左值不再是x而是13+x。一般来讲，这段程序的抽象语法树如下图所示。叶节点和中间的节点都不含括号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202004/211606-20200409144700905-1823570518.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）BNF&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　要构造抽象语法树，语言处理器首先要知道将会接收哪些单词序列（即需要处理怎样的程序），并确定希望构造出怎样的抽象语法树。通常，这些设定由程序设计语言的语法决定。&lt;/p&gt;
&lt;p&gt;　　语法规定了单词的组合规则，例如，双目运算表达式应该由哪些单词组成，或是if语句应该具有怎样的结构等。而程序设计语言的语法通常会包含诸如if语句的执行方式，或通过extends继承类时将执行哪些处理等规则。&lt;/p&gt;
&lt;p&gt;　　下面的代码清单采用了一种名为BNF（Backus-NaurForm，巴科斯范式）的书写方式，这是一种用于表示上下文无关文法的语言。准确来讲，这里使用的书写方式更接近BNF的扩展版本EBNF（Extended BNF，扩展巴科斯范式）。一般都会用&lt;span&gt;&lt;a href=&quot;http://dinosaur.compilertools.net/#yacc&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Yacc&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;这类工具来生成基于BNF的语法分析器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
factor:         NUMBER|&quot;(&quot;expression&quot;)&quot;&lt;span&gt;
term:        　 factor{(&lt;/span&gt;&quot;*&quot;|&quot;/&quot;&lt;span&gt;)factor}
expression:     term{(&lt;/span&gt;&quot;+&quot;|&quot;-&quot;)term}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　BNF中用到的元符号如下表所示。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;{pat}&lt;/td&gt;
&lt;td&gt;模式pat至少重复0次&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;[pat]&lt;/td&gt;
&lt;td&gt;与重复出现0次或1次的模式pat匹配&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pat1|pat2&lt;/td&gt;
&lt;td&gt;与pat1或pat2匹配&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;将括号内视为一个完整的模式&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　乍一看，BNF与正则表达式区别很大，但两者的思维方式类似。BNF与正则表达式都用于表述某种模式，以检查序列的内容。&lt;/p&gt;
&lt;p&gt;　　在BNF的表达规则中，冒号（:）左侧所写的内容能够用于表示与在冒号右侧所写的模式相匹配的单词序列。例如，第1行的规则中，factor（因子）意指与右侧模式匹配的单词序列。冒号左侧出现的诸如factor这样的符号称为非终结符或元变量。&lt;/p&gt;
&lt;p&gt;　　与非终结符相对的是终结符，它们是一些事先规定好的符号，表示各种单词。在代码清单中，NUMBER这种由大写字母组成的名称，以及由双引号&quot;括起的诸如&quot;(&quot;的符号就是终结符。NUMBER表示任意一个整型字面量单词，&quot;(&quot;表示一个内容为左括号的单词。&lt;/p&gt;
&lt;p&gt;　　冒号右侧的模式中也包含了若干个终结符或非终结符。与正则表达式一样，模式中也能使用上表列出的那些特殊符号。&lt;/p&gt;
&lt;p&gt;　　例如，在代码清单第1行的规则中，factor能表示NUMBER（1个整型字面量单词），或由左括号、expression（表达式）及右括号依次排列而成的单词序列。expression是一个非终结符，第3行对其下了定义。因此，由左括号、与expression匹配的单词序列，及右括号这些单词组成的单词序列能与factor模式匹配。&lt;/p&gt;
&lt;p&gt;　　如果冒号右侧的模式中仅含有终结符，BNF与正则表达式没有什么区别。此时，两者唯一的不同仅在于具体是以单词为单位检查匹配还是以字符为单位检查。&lt;/p&gt;
&lt;p&gt;　　另一方面，如果右侧含有类似于expression这样的非终结符，与该部分匹配的单词序列必须与另外定义的expression模式匹配。非终结符可以理解为常用模式的别称，在定义其他模式时能够引用这些非终结符。模式中包含非终结符是BNF的特征之一。&lt;/p&gt;
&lt;p&gt;　　代码清单第2行中的term（项）表示一种由factor与运算符“*”或“/”构成的序列，其中factor至少出现一次，运算符则必须夹在两个factor之间。由于“{}”括起来的模式将至少重复出现0次，因此，第2行的规则直译过来就是：与模式term匹配的内容，或是一个与factor相匹配的单词序列，或是在一个与factor相匹配的单词序列之后，由运算符“*”或“/”以及factor构成的组合再重复若干次得到的序列。&lt;/p&gt;
&lt;p&gt;　　第3行的规则也是类似。expression表示一种由term（对term对应的单词序列）与运算符“+”或“-”构成的序列，其中term至少出现一次，运算符则必须夹在两个term之间。结合所有这些规则，可以发现与模式expression匹配的就是通常的四则运算表达式，只不过单词的排列顺序做了修改。也就是说，与该模式匹配的单词序列就是一个expression。反之，如果单词序列与模式expression不匹配，则会发生语法错误（syntax error）。&lt;/p&gt;
&lt;p&gt;　　那么，接下来让我们来看一个具体的例子。表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
13 + 4 * 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　经过词法分析后将得到如下的单词序列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
NUMBER &quot;+&quot; NUMBER &quot;*&quot; NUMBER
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　整个单词序列与代码清单中的模式expression匹配。如下图所示，该单词序列的局部与非终结符factor及term的模式匹配，整个序列则明显与模式expression匹配。整型字面量13与factor匹配的同时也与term匹配。根据语法规则，单独的整型字面量单词能与factor匹配，单个factor又能与term匹配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202004/211606-20200409151708155-2112752282.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在代码清单中，expression、term与factor是范围逐层缩小的组成单位，不过需要注意的是，factor能够重新回到（由括号括起的）expression。这种具有循环结构的递归定义也是BNF的一个特征。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）语法分析与抽象语法树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在使用BNF来表示语法之后，就能借助它们进行语法分析，并构造抽象语法树。语法分析用于查找与模式匹配的单词序列。查找得到的单词序列是一个具有特定含义的单词组。分组后的单词能继续与其他单词组一起做模式匹配，组成更大的分组。&lt;/p&gt;
&lt;p&gt;　　通常，抽象语法树用于表示语法分析的结果，因此需要表现出这些分组之间的包含关系。下图是根据代码清单中的四则运算规则，对13+4*2进行语法分析后得到的结果，以及根据该结果构造的抽象语法树。图的左上方是语法分析的结果，右下方是构造的抽象语法树，正好上下颠倒。抽象语法树中的13或+等节点表示与相应单词对应的叶节点。可以看到，语法规则中出现的终结符都是抽象语法树的叶节点。非终结符term与factor也是抽象语法树的节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202004/211606-20200409152042230-1699345377.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　抽象语法树的子树表示的是语法分析中得到的单词组。子树是更大的树中的一部分。例如，与非终结符term模式匹配的分组能够构成一棵子树，它的根节点是表示非终结符term，与相应单词匹配的叶节点都是其子节点。右侧的term与4、*及2匹配，它们是以term为根节点的子树的叶节点。4与2同时也与模式factor匹配，因此term与4、2之间插入了一个表示factor的节点。至于13，它和term、factor通过一条直线相连，也是一棵以term为根节点、13为叶节点的符合语法规则的子树。&lt;/p&gt;

</description>
<pubDate>Wed, 13 May 2020 00:31:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>最近在读一本编译相关的书《两周自制脚本语言》，书中用Java来设计一种名为Stone的脚本语言。 一、语言处理器的结构 在下图中，源代码首先将进行词法分析，由一长串字符串细分为多个更小的字符串单元。分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12666772.html</dc:identifier>
</item>
<item>
<title>手把手教你学Numpy，从此处理数据不再慌「一」 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12880160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12880160.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当当当，我又开新坑了，这次的专题是Python机器学习中一个非常重要的工具包，也就是大名鼎鼎的&lt;strong&gt;numpy&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以今天的文章是&lt;strong&gt;Numpy专题的第一篇&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;俗话说得好，机器学习要想玩的溜，你可以不会写Python，但一定不能不会调库（大雾）。Numpy可以说是Python中最基础也是最重要的工具库了，要用Python做机器学习，玩转各种框架，Numpy是必须要会的。像是TensorFlow、pytorch这些知名框架都是基于Numpy进行计算的，可想而知它的重要性。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Numpy存在的必要性&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上关于Numpy的介绍非常多，但说来说去无非是一个Python中数值计算的非常重要的基础包，可以用来很方便地做一些矩阵和大数据的运算。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Numpy是做什么的我们很好理解，但是我们可能更加好奇它&lt;strong&gt;更深层次的意义&lt;/strong&gt;究竟是什么？关于这个问题我们从浅到深不停地追问，可以得到许多不同的答案。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最浅层的回答很简单，Numpy很方便，&lt;strong&gt;计算速度快&lt;/strong&gt;，可以很方便地进行矩阵运算。在Andrew的课程当中，他曾经演示过，同样的矩阵运算，如果我们通过Python中的循环实现速度会比调用Numpy慢上至少上百倍。这个差异显然是非常可怕的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但为什么Numpy会更快呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们追问下去，又会得到一个新的答案。因为Numpy包&lt;strong&gt;底层是通过C++实现的&lt;/strong&gt;，显然C++运算比Python快得多，所以Numpy自然就更快了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难道Numpy就只是因为C++更快这么简单吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题已经超越了Numpy本身，我们需要从Python的特性来回答了。Python是一门解释型语言，也就是说当我们执行Python的时候，其实是执行了一个Python的解释器。由Python的解释器来解释执行Python的每一行代码。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们把解释器理解成虚拟机，把Python执行的代码理解成虚拟机当中的程序。如果我们虚拟机多开的话，是很难保证线程安全的。为了解决这个问题，Python设计了&lt;strong&gt;GIL机制&lt;/strong&gt;，也就是全局解释器锁，它保证了同一时刻最多只有一个解释器线程在执行。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个机制保证了线程安全，但是也限制了Python多线程的使用。Python的多线程本质上是伪多线程，因为解释器只有一个线程在跑。所以如果我们想要通过多线程并发来加速计算的话，这是不可能的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而矩阵和向量的一些操作是可以通过多线程并发来加速计算的，而Python本身的特性导致了Python不能执行这样的操作。那么通过Python调用C++实现的计算库也就是唯一的选择了。实际上不仅是Numpy，几乎所有Python的计算库，都是通过Python调用其他语言实现的。Python本身只是最上层的调用方。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了这点除了对于Python可以有更加清晰的认识之外，也有助于之后学习TensorFlow等其他框架。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Numpy中的n维数组&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Numpy之所以好用，是因为我们可以通过Numpy&lt;strong&gt;很方便地创建高维的数组和矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，比如在原生Python当中，当我们需要创建一个二维数组的时候，往往需要些很长的定义。比如我们想要一个10 * 10的数组：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;arr = [[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)] &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在Numpy当中就会很方便，只需要一行。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; np
arr = np.zeros((&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一行当中我们引入了numpy，为了编码方便，我们将它重新命名成了np。这个是业内惯用做法，几乎所有使用numpy的程序员都会这么重命名。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在numpy当中，存储高维数组的对象叫做ndarray，与之对应的是存储矩阵的mat。其实这两者区别不大，支持矩阵的运算，ndarray基本上也都支持。我们有这么一个印象即可，关于mat内容我们会在之后介绍。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建除了ndarray之后，关于获取ndarray基本信息的api大概有下面四个。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个是&lt;strong&gt;通过.ndim&lt;/strong&gt;查看ndarray的维度，也就是查看这是一个几维的数组：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/13/1720b6d8a56a3413?w=1180&amp;amp;h=140&amp;amp;f=jpeg&amp;amp;s=6006&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个是&lt;strong&gt;通过.shape&lt;/strong&gt;获取这个ndarray在各个维度的大小：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/13/1720b6d87ce20ae1?w=996&amp;amp;h=128&amp;amp;f=jpeg&amp;amp;s=6186&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三个是&lt;strong&gt;通过.dtype&lt;/strong&gt;获取这个ndarray中元素的类型：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/13/1720b6d8ad50fc43?w=1056&amp;amp;h=126&amp;amp;f=jpeg&amp;amp;s=7407&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一个是&lt;strong&gt;tolist()方法&lt;/strong&gt;，可以将一个ndarray转化成Python原生的list进行返回。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/13/1720b6d8b26187ce?w=1214&amp;amp;h=398&amp;amp;f=jpeg&amp;amp;s=83474&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;ndarray&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们怎么创建numpy中的ndarray呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概也有几种办法，首先，既然numpy中的ndarray可以转换成Python原生的list，同样Python中原生的list也可以转换成numpy中的ndarray。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和转换变量类型的语法很像，我们通过np.array()转换即可。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;nums = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]
arr = np.array(nums)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了通过Python中原生的list转换，我们还可以根据自己的需要创建新的ndarray。numpy创建array的方法有很多，我们先来介绍一下其中比较基础的几种。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;创建出一个range&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;np.arange可以&lt;strong&gt;生成一个序列&lt;/strong&gt;，有些类似于Python中原生的range。不过它更加灵活，我们可以之传入一个整数，它会返回一个从0开始的序列：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;np.arange(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)
array([&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以&lt;strong&gt;指定首尾元素和间隔&lt;/strong&gt;，numpy会自动帮我们生成一个等差序列：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;np.arange(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt;)
array([&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;1.5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;2.5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3.&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;3.5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4.&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;4.5&lt;/span&gt;])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，numpy中还提供了&lt;strong&gt;ones和zeros&lt;/strong&gt;两个api，可以生成全为0和全为1的元素。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;np.zeros((&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;))
array([[&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;],
       [&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;],
       [&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;np.ones((&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;))
array([[&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;],
       [&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以使用&lt;strong&gt;eye或者是identity&lt;/strong&gt;生成一个N*N的单位矩阵：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;np.eye(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)
array([[&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;],
       [&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;],
       [&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还有一个full的api可以&lt;strong&gt;指定shape和数值&lt;/strong&gt;，用我们指定的数值填充出一个指定大小的数组来：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;np.full((&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;), &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)
array([[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;],
       [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;],
       [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个api我们用的不多，因为我们可以用ones生成一个全为1的数组，然后乘上一个我们想要的值，就等价于full。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，ones, zeros, full这几个api还有一个对应的like方法。所谓的like方法就是我们传入另外一个ndarray代替shape，numpy会根据这个ndarray的形状生成一个对应形状的新array。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看个例子吧，首先我们生成一个顺序的序列：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;ex1 = np.arange(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们通过zeros_like方法生成一个同样大小的全为0的矩阵：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;ex2 = np.zeros_like(ex1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它其实等价于：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;np.zeros(ex1.shape)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他几个like方法也大同小异，因为可替代性很强，所以我也用的不多。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;numpy支持的类型&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;numpy支持的数据类型很多，除了常用的int和float之外，还支持&lt;strong&gt;复数类型的complex&lt;/strong&gt;，某种程度上来说和golang支持的类型比较接近。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中int类型一共分为int8，int32，int64和int128，其中每一种又分为带符号的和不带符号的。例如int8就是带符号的8位二进制表示的int，而uint8则是不带符号位的。浮点数没有无符号浮点数，一共分为float16，float32，float64和flaot128。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复数也有三种，分别是complex64，complex128和complex256。除此之外还有string_和object以及unicode_这三种类型。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过调用astype方法更改ndarray中所有变量的类型：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;ex1 = np.arange(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)
ex1.astype(np.float64)
array([&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8.&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9.&lt;/span&gt;])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了人为转换之外，我们还可以在创建的时候通过dtype这个参数来表示我们想要创建的数据的类型，这样可以避免之后转换的麻烦。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;ex1 = np.arange(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, dtype=np.float32)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;结尾&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章当中我们不仅介绍了Numpy的创建的方法，还聊了Python这门语言的一些特性。正是因为Python本身多线程的限制，导致它在需要高并发计算的场景下性能很差。才会需要通过Python去调用C++或者是其他语言的底层实现。这也是为什么Python经常被称为&lt;strong&gt;胶水语言&lt;/strong&gt;的原因。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Numpy可以认为是Python进行机器学习的基础，当然除了Numpy之外，像是pandas、matplot以及scikit-learn等库也是必不可少的。我们会从Numpy开始，一点一点把这些常用的库都给大家分享一遍。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各位看官大人，喜欢的话，点个关注吧~&lt;/p&gt;
</description>
<pubDate>Wed, 13 May 2020 00:29:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>当当当，我又开新坑了，这次的专题是Python机器学习中一个非常重要的工具包，也就是大名鼎鼎的numpy。 所以今天的文章是Numpy专题的第一篇。 俗话说得好，机器学习要想玩的溜，你可以不会写Pyt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12880160.html</dc:identifier>
</item>
<item>
<title>企业网站建设 - 小杨姐姐</title>
<link>http://www.cnblogs.com/yyy15365206/p/12874064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyy15365206/p/12874064.html</guid>
<description>&lt;p&gt;企业网站建设方案适合中小型企业，它有自己独特的风格设计。风格设计主要体现在企业个性特点的凸显，结合企业经营行业市场分析，了解客户群体活动习性以及活动规律，分析、策划并制定出一套适合企业自身的网站建设的设计风格方案。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;299&quot;&gt;
&lt;p&gt;企业网站建设方案适合中小型企业，它有自己独特的风格设计。风格设计主要体现在企业个性特点的凸显，结合企业经营行业市场分析，了解客户群体活动习性以及活动规律，分析、策划并制定出一套适合企业自身的网站建设的设计风格方案。设计首页要求列出最吸引客户的产品信息以及服务信息，用最精炼的语言表达出客户想了解的信息，一般网站首页由企业简介，企业新闻，企业资质，产品展示，在线留言，联系方式等。&lt;/p&gt;
&lt;h2 id=&quot;一、web-技术编辑&quot;&gt;一、Web 技术编辑&lt;/h2&gt;
&lt;p&gt;　　Web 技术一直在发展，因为Http协议最初只是为了表现简单的超文本，当人们赋予Web越来越多的使命的时候，Web的局限性就表现出来了，为了解决这些问题，人们在Web上面附加了很多新技术以增强Web的表现能力，Cookie, Javscript, DHTML, ActiveX, Applet, CSS一直到现在炙手可热的AJAX技术，然而这些新技术很快带来了兼容性问题，因为Web内容要靠浏览器解释，不同的浏览器加不同的安全配置，导致这些新技术并不能被如期地渲染出来。&lt;/p&gt;
&lt;h2 id=&quot;二、不使用任何网页特效编辑&quot;&gt;二、不使用任何网页特效编辑&lt;/h2&gt;
&lt;p&gt;　　虽然网页特效并不一定涉及不兼容技术，但网页特效对绝大多数人来说是非常厌烦的，企业网站绝对不应该使用那些仅仅为了好玩的网页特效。最令人厌烦的网页特效包括，要求设为主页，接连弹出的窗口，全屏窗口，改变鼠标光标，在状态条上滚动的废话，页面内容禁选，禁止查看源代码，闪烁的文字，离开时的弹窗，颜色古怪的窗口滚动条，声音背景。需要记住一条，访问者永远都不会因为您使用了一种自认为很 Cool 的特效而觉得您了不起。&lt;/p&gt;
&lt;h2 id=&quot;三、清晰，统一的导航编辑&quot;&gt;三、清晰，统一的导航编辑&lt;/h2&gt;
&lt;p&gt;　　用户在您的企业网站找到有用内容的唯一途径是通过站点的导航系统，您需要花大力气来组织您的内容，保证让用户以最快的速度找到它们。导航系统必须清晰，他们应该和站点的其它内容用不同的颜色搭配以便在网页上突出出来，同时，每个页的导航系统应该完全一致，从一个页面进入另一个页面看到完全陌生的导航系统是非常令人沮丧的。　&lt;/p&gt;
&lt;h2 id=&quot;四、导航深度不超过三级编辑&quot;&gt;四、导航深度不超过三级编辑&lt;/h2&gt;
&lt;p&gt;　　虽然很多人觉得这太绝对，事实上，用户需要点三次才能找到自己想要的内容仍然太多，那种一级一级下潜的导航菜单是令人生畏的，很多人会产生进去以后便找不到路回来的恐惧，如果您能够很好地组织自己的内容，结合分页机制，Tag机制，对绝大多数网站，三级导航深度已经足够使用了。&lt;/p&gt;
&lt;h2 id=&quot;五、导航链接中必须包含文字编辑&quot;&gt;五、导航链接中必须包含文字编辑&lt;/h2&gt;
&lt;p&gt;　　为了美观，许多人喜欢图片按纽式的导航链接，如果您坚持这样做，也无可厚非，但一定在图片上同时加上文字，让文字体现该链接的含义，因为除了设计者，外人往往很难猜测您的图片按纽的含义，文字是最直接，最精确的。&lt;/p&gt;
&lt;h2 id=&quot;六、必须有纯文本版本的站点地图编辑&quot;&gt;六、必须有纯文本版本的站点地图编辑&lt;/h2&gt;
&lt;p&gt;　　当用户在您的令人眼花缭乱的站点导航中彻底迷失的时候，纯文字版的，简单直接的站点地图还可以救急，站点地图可以帮助用户快速找到他们想要的内容，这是对导航系统的补充，甚至对有些站点来说，比导航系统更有效。另外，纯文本版的站点地图非常容易被搜索引擎抓取并以此遍历您的整个站点。&lt;/p&gt;
&lt;h2 id=&quot;七、必须有面包屑导航条编辑&quot;&gt;七、必须有面包屑导航条编辑&lt;/h2&gt;
&lt;p&gt;　　面包屑导航(Breadcrumb Navigation)这个概念来自童话故事&quot;汉泽尔和格雷特尔&quot;，当汉泽尔和格雷特尔穿过森林时，他们在沿途走过的地方都撒下了面包屑，让这些面包屑来帮助他们找到回家的路，所以，面包屑导航的作用是告诉访问者他们目前在网站中的位置以及如何返回。&lt;/p&gt;
&lt;h2 id=&quot;八、每页都有自己的标题编辑&quot;&gt;八、每页都有自己的标题编辑&lt;/h2&gt;
&lt;p&gt;　　许多企业网站的所有页的标题都是企业的名字或者一句口号，这会让用户不知道他们访问的当前页是说什么的，每页都应有一个和本页内容匹配的标题，这样，即使用户打开了很多窗口，仍然可以通过标题知道哪一页是说什么的。从SEO的角度看，在标题中使用本页内容中某些关键词是非常好的习惯，而且，当您的页面出现在搜索引擎的搜索结果中时，您的页面标题应当明确地告诉搜索者他们搜到的页面是关于什么的。&lt;/p&gt;
&lt;h2 id=&quot;九、任何页都有一个链接指向首页编辑&quot;&gt;九、任何页都有一个链接指向首页编辑&lt;/h2&gt;
&lt;p&gt;　　人们进入一个陌生的地方，当感到迷失或不安的时候，会立刻想到返回入口位置，访问者进入您的网站也是这样，每页都有一个指向首页的链接可以帮助用户在感到迷失的时候，迅速返回入口重新开始。&lt;/p&gt;
&lt;h2 id=&quot;十、企业网站的功能编辑&quot;&gt;十、企业网站的功能编辑&lt;/h2&gt;
&lt;p&gt;　　企业网上的功能，可以从技术功能和网络营销功能两个方面来考虑。网站的技术功能是整个网站得以正常运行的技术基础；网站的网络营销功能，则是网站以网络营销策略的角度来看，一个企业网站具有哪些可以发挥网络营销作用的功能。显然，网站的技术功能是为网站的网络营销功能提供支持的网站的网络营销功能是技术功能的体现。&lt;/p&gt;
&lt;p&gt;　　众多的企业网站中，无论网站规模多大，也不论具有哪些技术功能，网站的网络营销功能主要包括八个方面：品牌形象、产品/服务展示、信息发布、顾客服务、顾客关系、网上调查、资源合作、网上销售。即使最简单的企业网站也具有其中至少一项以上的功能。&lt;/p&gt;
&lt;h2 id=&quot;十一、必要性编辑&quot;&gt;十一、必要性编辑&lt;/h2&gt;
&lt;p&gt;　　网站是您抢占网络市场，把握网络商机的必备武器，互联网，作为一种新型媒体，从上世纪九十年代中期登陆中国以来便以其“及时性、海量性、互动性和低成本”等特点迅速得到了中国老百姓特别是年轻群体的喜爱，到现在随着中国经济的发展和家庭电脑的普及，这条连接世界的电线正以另人难以想象的速度在中国延伸铺盖，到现在“网络”对于使用它的网民来讲，它已经不是一个单纯的获得信息和知识的介体。在潜移默化之间，它已经深入到我们生活的各个方面，成为我们生活的一部分！您大概已经意识到了，在这个庞大的互联网用户群体中间，潜藏着多大的市场和商机？而且，这个市场比我们想象的还要大，因为互联网不仅链接中国，它是一条链接世界的网线。但是，大多数的中国企业并没有意识到网络市场的巨大，或者虽然有了意识，但不知道如何进行网络推广和网络营销，并且对网络交易的可操作性持怀疑态度。&lt;/p&gt;
&lt;p&gt;　　在这种情况下，谁的意识有了突破，谁先掌握了网络推广和电子商务的相关知识并建立自己的网站，谁就能最先占领网络市场这块营销高地，在未来的市场竟争中胜人一筹。因此，网站是您抢占网络市场，把握网络商机的必备武器！&lt;/p&gt;
&lt;p&gt;　　网站是您展示企业形象，竖立企业品牌的广告手段，随着中国经济与世界经济的接轨，“企业品牌”和“企业文化”的意识已经深到到中国企业管理者的经营策略之中，但遗憾的是，他们可能更加重视&quot;电视、报纸&quot;等传统媒体的宣传和广告投入，却往往忽视了一个宣传企业品牌和展示企业形象的经济又实用的平台，这就是企业网站。打个比方说，有一个初次与贵公司接触的异地客户，在他决定与贵公司合作之前，他们往往会先打开贵公司的网站浏览一下贵公司的企业介绍和产品等信息，这时，他们对贵公司的第一印象就是来于自您的网站。假如说贵公司规模很大，产品质量也很高，但网站却建得很粗糙，甚至有很多死链接，这时，贵公司的形象在客户心中但会大打折扣，甚至会对贵公司的实力产生怀疑。相反，如果您的企业刚刚起步，各方面硬件设施都不是很完善，实力相对较弱，但贵公司的网站却清新大气、专业实用，这时您的企业形象在客户心里就会大大加分，从而对您的公司实力产生信心！一个经过专业设计和科学推广的网站，不仅可以帮您宣传产品，占领市场，更可以为您的产品和公司竖立良好的企业形象和产品品牌，形象点儿说，您的网站不仅是您的业务员，也是您的形象代言人！&lt;/p&gt;
&lt;p&gt;　　网站是您方便联系客户，加强在线交流的有效平台，众所周知，网络通讯已经成为一种仅次于电话通讯的现代化通讯方式，而相对于电话交流，网络更加廉价和轻松，因此越来越多的人喜欢上了在网上进行交流。作为企业来讲，网络已经成为我们与客户交流的重要平台，而企业网站就是我们的一个产品地图，也是我们与客户交流的一个直接的参照物，客户可以通过企业网站方便快捷的了解我们的产品，并通过网站的相关功能，把对我们的产品或服务的意见和建议即时反馈给我们，我们也可以通过网站让客户在最快最短的时间内，对我们的产品和企业有一个全面的认识！因此网站是您方便联系客户，加强在线交流的有效平台，方便了人们的商务办公，因互联网可以滋生更多品牌 网站建设公司。&lt;/p&gt;
&lt;h2 id=&quot;十二、方案的目的编辑&quot;&gt;十二、方案的目的编辑&lt;/h2&gt;
&lt;p&gt;　　1、企业网站建设方案的策划主要目的在于，能够通过网站首页，公司简介，产品服务信息，让客户清楚了解公司产品以及服务信息情况。&lt;/p&gt;
&lt;p&gt;　　2、网站栏目清晰明了，网站本身就是服务企业，为企业带来宣传。栏目之间的设定都是在服务于如何让网站更吸引客户，更能抓住客户心理，方便用户浏览网站而设定制作。&lt;/p&gt;
&lt;p&gt;　　3、策划方案还可以反应出网站框架设计是否合理，预计能够达到什么效果，以及后期网站推广工作安排。&lt;/p&gt;
&lt;h2 id=&quot;十三、后台管理系统设计框架编辑&quot;&gt;十三、后台管理系统设计框架编辑&lt;/h2&gt;
&lt;p&gt;　　1、网站后台需要进行初步设计，为了方便使用者更新网站产品信息或者服务信息，因为企业的产品或者服务在不断的增加和完善，所以为了方便用户使用，后台需要为客户搭建一个管理平台，产品以及产品分类增加，删除，修改等功能。&lt;/p&gt;
&lt;p&gt;　　2、在线留言以及网站公告：通过在线留言可以方便建立与客户之间沟通的媒介，很多企业网站忽略这点。网站公告可以在第一时间内告诉客户企业新品的发布以及企业近期动态，这样，当自己有新产品推出的时候，总是会第一时间通知到这些客户，也是提高客户服务质量的一种手段。&lt;/p&gt;
&lt;h2 id=&quot;十四、方案的内容编辑&quot;&gt;十四、方案的内容编辑&lt;/h2&gt;
&lt;h4 id=&quot;（一）建设网站前的市场分析&quot;&gt;（一）建设网站前的市场分析&lt;/h4&gt;
&lt;p&gt;　　1、相关行业的市场是怎样的,市场有什么样的特点，是否能够在互联网上开展公司业务。&lt;/p&gt;
&lt;p&gt;　　2、市场主要竞争者分析，竞争对手上网情况及其网站策划、功能作用。&lt;/p&gt;
&lt;p&gt;　　3、公司自身条件分析、公司概况、市场优势，可以利用网站提升哪些竞争力，建设网站的能力（费用、技术、人力等）。&lt;/p&gt;
&lt;h4 id=&quot;（二）建设网站目的及功能定位&quot;&gt;（二）建设网站目的及功能定位&lt;/h4&gt;
&lt;p&gt;　　1、为什么要建立网站，是为了树立企业形象，宣传产品，进行电子商务，还是建立行业性网站？是企业的基本需要还是市场开拓的延伸？&lt;/p&gt;
&lt;p&gt;　　2、整合公司资源，确定网站功能。根据公司的需要和计划，确定网站的功能。&lt;/p&gt;
&lt;p&gt;　　　　类型：企业型网站、应用型网站、商业型网站（行业型网站）、电子商务型网站；企业网站又分为企业形象型、产品宣传型、网上营销型、客户服务型、电子商务型等。&lt;/p&gt;
&lt;p&gt;　　3、根据网站功能，确定网站应达到的目的作用。&lt;/p&gt;
&lt;p&gt;　　4、企业内部网（intranet）的建设情况和网站的可扩展性。&lt;/p&gt;
&lt;h4 id=&quot;（三）网站技术解决方案&quot;&gt;（三）网站技术解决方案&lt;/h4&gt;
&lt;p&gt;　　1、采用自建服务器，还是租用虚拟主机。&lt;/p&gt;
&lt;p&gt;　　2、选择操作系统，用window2000/nt还是unix,linux。分析投入成本、功能、开发、稳定性和安全性等。&lt;/p&gt;
&lt;p&gt;　　3、采用模板自助建站、建站套餐还是个性化开发。&lt;/p&gt;
&lt;p&gt;　　4、网站安全性措施，防黑、防病毒方案（如果采用虚拟主机，则该项由专业公司代劳）。&lt;/p&gt;
&lt;p&gt;　　5、选择什么样的动态程序及相应数据库。如程序asp、jsp、php；数据库sql、access、oracle等。&lt;/p&gt;
&lt;h4 id=&quot;（四）网站内容及实现方式&quot;&gt;（四）网站内容及实现方式&lt;/h4&gt;
&lt;p&gt;　　1、根据网站的目的确定网站的结构导航。&lt;/p&gt;
&lt;p&gt;　　　　一般企业型网站应包括：公司简介、企业动态、产品介绍、客户服务、联系方式、在线留言等基本内容。更多内容如：常见问题、营销网络、招贤纳士、在线论坛、英文版等等。&lt;/p&gt;
&lt;p&gt;　　2、根据网站的目的及内容确定网站整合功能。&lt;/p&gt;
&lt;p&gt;　　　　如flash引导页、会员系统、网上购物系统、在线支付、问卷调查系统、在线支付、信息搜索查询系统、流量统计系统等。&lt;/p&gt;
&lt;p&gt;　　3、确定网站的结构导航中的每个频道的子栏目。&lt;/p&gt;
&lt;p&gt;　　　　如公司简介中可以包括：总裁致词、发展历程、企业文化、核心优势、生产基地、科技研发、合作伙伴、主要客户、客户评价等；客户服务可以包括：服务热线、服务宗旨、服务项目等。&lt;/p&gt;
&lt;p&gt;　　4、确定网站内容的实现方式。&lt;/p&gt;
&lt;p&gt;　　　　如产品中心使用动态程序数据库还是静态页面；营销网络是采用列表方式还是地图展示。&lt;/p&gt;
&lt;h4 id=&quot;（五）网页设计&quot;&gt;（五）网页设计&lt;/h4&gt;
&lt;p&gt;　　1、网页设计美术设计要求，网页美术设计一般要与企业整体形象一致，要符合企业ci规范。要注意网页色彩、图片的应用及版面策划，保持网页的整体一致性。&lt;/p&gt;
&lt;p&gt;　　2、在新技术的采用上要考虑主要目标访问群体的分布地域、年龄阶层、网络速度、阅读习惯等。&lt;/p&gt;
&lt;p&gt;　　3、制定网页改版计划，如半年到一年时间进行较大规模改版等。&lt;/p&gt;
&lt;h4 id=&quot;（六）费用预算&quot;&gt;（六）费用预算&lt;/h4&gt;
&lt;p&gt;　　1、 企业建站费用的初步预算。一般根据企业的规模、建站的目的、上级的批准而定。&lt;/p&gt;
&lt;p&gt;　　2、 专业建站公司提供详细的功能描述及报价，企业进行性价比研究。&lt;/p&gt;
&lt;p&gt;　　3、 网站的价格从几千元到十几万元不等。如果排除模板式自助建站（通常认为企业的网站无论大小，必须有排他性，如果千篇一律对企业形象的影响极大）和牟取暴利的因素，网站建设的费用一般与功能要求是成正比的。&lt;/p&gt;
&lt;h4 id=&quot;（七）网站维护&quot;&gt;（七）网站维护&lt;/h4&gt;
&lt;p&gt;　　1、服务器及相关软硬件的维护，对可能出现的问题进行评估，制定响应时间。&lt;/p&gt;
&lt;p&gt;　　2、数据库维护，有效地利用数据是网站维护的重要内容，因此数据库的维护要受到重视。&lt;/p&gt;
&lt;p&gt;　　3、内容的更新、调整等。&lt;/p&gt;
&lt;p&gt;　　4、制定相关网站维护的规定，将网站维护制度化、规范化。&lt;/p&gt;
&lt;p&gt;　　5、说明：动态信息的维护通常由企业安排相应人员进行在线的更新管理；静态信息（即没用动态程序数据库支持）可由专业公司进行维护。&lt;/p&gt;
&lt;h4 id=&quot;（八）网站测试&quot;&gt;（八）网站测试​&lt;/h4&gt;
&lt;p&gt;　　网站发布前要进行细致周密的测试，以保证正常浏览和使用。主要测试内容：&lt;/p&gt;
&lt;p&gt;　　1、文字、图片是否有错误。&lt;/p&gt;
&lt;p&gt;　　2、程序及数据库测试。&lt;/p&gt;
&lt;p&gt;　　3、链接是否有错误。&lt;/p&gt;
&lt;p&gt;　　4、服务器稳定性、安全性。&lt;/p&gt;
&lt;p&gt;　　5、网页兼容性测试，如浏览器、显示器。&lt;/p&gt;
&lt;h4 id=&quot;（九）网站发布与推广&quot;&gt;（九）网站发布与推广&lt;/h4&gt;
&lt;p&gt;　　1、网站测试后进行发布的公关，广告活动。&lt;/p&gt;
&lt;p&gt;　　2、搜索引掣登录等。&lt;/p&gt;
&lt;h2 id=&quot;十五、国内知名的企业网站建设公司编辑&quot;&gt;十五、国内知名的企业网站建设公司编辑&lt;/h2&gt;
&lt;p&gt;　　东莞市普林网络科技有限公司是一家集网站建设、品牌策划、网站设计制作、网站优化、网站推广、网站维护、网站改版、400电话、域名空间注册为一体的专业化设计公司。普林拥有一批丰富经验的业内顶尖资深设计精英，企业网站建设是一支经验丰富、创意独到、充满活力、自信尽职、团结协作的创意执行一流正规军。一直以来，普林企业网站建设紧贴网络时代的发展潮流，对中国网络应用的现状和趋势有很深的认识，因此不论您是需要简洁实用的小型展示性网站，还是大型网站,我们都有相应解决的方法。我们的优势在于我们重视于每一份业务的设计质量，而不在意业务的数量多少，提升客户网站形象是我们致力追求的业务目标。东莞做网站公司的设计师把网站设计推向一个更高的艺术层次。&lt;/p&gt;
&lt;p&gt;　 　普林企业网站建设将一如既往的秉承“一流美工、顶尖技术、超值服务”的服务理理念，以出色、专业、诚信的服务姿态服务所有的新老客户，一如既往的坚持“以人为本、与时俱进，持续改革，技术创新，精益求精”的发展理念以保持东莞做企业网站公司的高速稳步发展。企业网站建设的理念——专业、专注、用心、服务。&lt;/p&gt;
&lt;h2 id=&quot;十六、企业网站建设注意事项编辑&quot;&gt;十六、企业网站建设注意事项编辑&lt;/h2&gt;
&lt;h4 id=&quot;（一）站点结构设计选择&quot;&gt;（一）站点结构设计选择&lt;/h4&gt;
&lt;p&gt;　　导航是网站的重要的组成部分之一。在这里我特别提醒站长朋友们的是，千万别忘了面包屑导航。它不仅能有效的提高用户的体验，更能让搜索引擎觉得网站具有一定的专业性。还有一点就是网站的导航记住一定要用文本形式的来做链接。然后是ＵＲＬ结构的选择，相信站长朋友们都知道ＵＲＬ层次要尽量的简短，路径一定是静态路径，然而在这之后的对于文件名的选择我们最是要好考虑好的。比如照片的文件我们可以用ｐｉｃｔｕｒｅｓ来命名，这样就不仅可以让用户看更得明白，也相对来说比较简短。&lt;/p&gt;
&lt;h4 id=&quot;（二）关键词的选择&quot;&gt;（二）关键词的选择&lt;/h4&gt;
&lt;p&gt;　　关键词的选择，就像是在给网站定位一个方向。所以我们在建站之前必须要对一些关键词进行一番研究，不要随意凭借自己的想象来进行决定。而关键词的选择也是有很多办法的，可以通过关键词工具，这这种工具是非常多的。也可以通过百度相关的搜索以及下拉框，还有通过客户的搜索习惯进行搜索。这些都是能对关键词进行研究选择的。&lt;/p&gt;
&lt;h4 id=&quot;（三）服务器空间的选择&quot;&gt;（三）服务器空间的选择&lt;/h4&gt;
&lt;p&gt;　　一般大型的网站都是独立的服务器或者是服务器集群。然而个人站长大部分则都是租用虚拟空间的。那么选择服务器空间我们要注意几点呢？&lt;/p&gt;
&lt;p&gt;　　１、服务区的ＩＰ是否被惩罚过或者是服务器运营是否稳定，速度怎样。&lt;/p&gt;
&lt;p&gt;　　２、服务器的所在区的选择。服务器所在的区也会影响到网站的排名，曾经有做过这方面实验的，就选择所在的服务区不同，其他的优化手段都是一样的情况下，排名的情况也是不一样的。这就提醒大家，做站点，特别是做地方站点时，要选择好服务器所在的区。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 13 May 2020 00:23:00 +0000</pubDate>
<dc:creator>小杨姐姐</dc:creator>
<og:description>企业网站建设方案适合中小型企业，它有自己独特的风格设计。风格设计主要体现在企业个性特点的凸显，结合企业经营行业市场分析，了解客户群体活动习性以及活动规律，分析、策划并制定出一套适合企业自身的网站建设的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyy15365206/p/12874064.html</dc:identifier>
</item>
<item>
<title>HMM-前向后向算法与实现 - 周若梣</title>
<link>http://www.cnblogs.com/gongyanzh/p/12880147.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gongyanzh/p/12880147.html</guid>
<description>&lt;h3 id=&quot;基本要素&quot;&gt;基本要素&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;状态 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;状态序列 &lt;span class=&quot;math inline&quot;&gt;\(S = s_1,s_2,...\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;观测序列 &lt;span class=&quot;math inline&quot;&gt;\(O=O_1,O_2,...\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\lambda(A,B,\pi)\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态转移概率 &lt;span class=&quot;math inline&quot;&gt;\(A = \{a_{ij}\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;发射概率 &lt;span class=&quot;math inline&quot;&gt;\(B = \{b_{ik}\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;初始概率分布 &lt;span class=&quot;math inline&quot;&gt;\(\pi = \{\pi_i\}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观测序列生成过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始状态&lt;/li&gt;
&lt;li&gt;选择观测&lt;/li&gt;
&lt;li&gt;状态转移&lt;/li&gt;
&lt;li&gt;返回step2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hmm三大问题&quot;&gt;HMM三大问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;概率计算问题（评估问题）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;给定观测序列 &lt;span class=&quot;math inline&quot;&gt;\(O=O_1O_2...O_T\)&lt;/span&gt;，模型 &lt;span class=&quot;math inline&quot;&gt;\(\lambda (A,B,\pi)\)&lt;/span&gt;，计算 &lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda)\)&lt;/span&gt;，即计算观测序列的概率&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解码问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;给定观测序列 &lt;span class=&quot;math inline&quot;&gt;\(O=O_1O_2...O_T\)&lt;/span&gt;，模型 &lt;span class=&quot;math inline&quot;&gt;\(\lambda (A,B,\pi)\)&lt;/span&gt;，找到对应的状态序列 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学习问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;给定观测序列 &lt;span class=&quot;math inline&quot;&gt;\(O=O_1O_2...O_T\)&lt;/span&gt;，找到模型参数 &lt;span class=&quot;math inline&quot;&gt;\(\lambda (A,B,\pi)\)&lt;/span&gt;，以最大化 &lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda)\)&lt;/span&gt;，&lt;/p&gt;
&lt;h3 id=&quot;概率计算问题&quot;&gt;概率计算问题&lt;/h3&gt;
&lt;p&gt;给定模型 &lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt; 和观测序列 &lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;，如何计算&lt;span class=&quot;math inline&quot;&gt;\(P(O| \lambda)\)&lt;/span&gt;？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暴力枚举&lt;/strong&gt;每一个可能的状态序列 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;对每一个给定的状态序列&lt;/p&gt;
&lt;p&gt;\[P(O|S,\lambda) = \prod^T_{t=1} P(O_t|s_t,\lambda) =\prod^T_{t=1} b_{s_tO_t} \]&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一个状态序列的产生概率&lt;/p&gt;
&lt;p&gt;\[P(S|\lambda) = P(s_1)\prod^T_{t=2}P(s_t|s_{t-1})=\pi_1\prod^T_{t=2}a_{s_{t-1}s_t} \]&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;联合概率&lt;/p&gt;
&lt;p&gt;\[P(O,S|\lambda) = P(S|\lambda)P(O|S,\lambda) =\pi_1\prod^T_{t=2}a_{s_{t-1}s_t}\prod^T_{t=1} b_{s_tO_t} \]&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;考虑所有的状态序列&lt;/p&gt;
&lt;p&gt;\[P(O|\lambda)=\sum_S\pi_1b_{s_1O_1}\prod^T_{t=2}a_{s_{t-1}s_t}b_{s_tO_t} \]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt; 可能由任意一个状态得到，所以需要将每个状态的可能性相加。&lt;/p&gt;
&lt;p&gt;这样做什么问题？时间复杂度高达 &lt;span class=&quot;math inline&quot;&gt;\(O(2TN^T)\)&lt;/span&gt;。每个序列需要计算 &lt;span class=&quot;math inline&quot;&gt;\(2T\)&lt;/span&gt; 次，一共 &lt;span class=&quot;math inline&quot;&gt;\(N^T\)&lt;/span&gt; 个序列。&lt;/p&gt;
&lt;h4 id=&quot;前向算法&quot;&gt;前向算法&lt;/h4&gt;
&lt;p&gt;在时刻 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，状态为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 时，前面的时刻观测到 &lt;span class=&quot;math inline&quot;&gt;\(O_1,O_2, ..., O_t\)&lt;/span&gt; 的概率，记为 &lt;span class=&quot;math inline&quot;&gt;\(\alpha _i(t)\)&lt;/span&gt; ：&lt;/p&gt;
&lt;p&gt;\[\alpha_{i}(t)=P\left(O_{1}, O_{2}, \ldots O_{t}, s_{t}=i | \lambda\right) \]&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(t=1\)&lt;/span&gt; 时，输出为 &lt;span class=&quot;math inline&quot;&gt;\(O_1\)&lt;/span&gt;，假设有三个状态，&lt;span class=&quot;math inline&quot;&gt;\(O_1\)&lt;/span&gt; 可能是任意一个状态发出，即&lt;/p&gt;
&lt;p&gt;\[P(O_1|\lambda) = \pi_1b_1(O_1)+\pi_2b_2(O_1)+\pi_2b_3(O_1) = \alpha_1(1)+\alpha_2(1)+\alpha_3(1) \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/gongyanzh/blogpic/raw/master/pictures/image-20200511202908264.png&quot; alt=&quot;image-20200511202908264&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(t=2\)&lt;/span&gt; 时，输出为 &lt;span class=&quot;math inline&quot;&gt;\(O_1O_2\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(O_2\)&lt;/span&gt; 可能由任一个状态发出，同时产生 &lt;span class=&quot;math inline&quot;&gt;\(O_2\)&lt;/span&gt; 对应的状态可以由 &lt;span class=&quot;math inline&quot;&gt;\(t=1\)&lt;/span&gt; 时刻任意一个状态转移得到。假设 &lt;span class=&quot;math inline&quot;&gt;\(O_2\)&lt;/span&gt; 由状态 &lt;code&gt;1&lt;/code&gt; 发出，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/gongyanzh/blogpic/raw/master/pictures/image-20200511203749699.png&quot; alt=&quot;image-20200511203749699&quot;/&gt;&lt;/p&gt;
&lt;p&gt;\[P(O_1O_2,s_2=q_1|\lambda) = \pi_1b_1(O_1)a_{11}b_1(O_2)+\pi_2b_2(O_1)a_{21}b_1(O_2)+\pi_2b_3(O_1)a_{31}b_1(O_2) \\ =\bold{\alpha_1(1)}a_{11}b_1(O_2)+\bold{\alpha_2(1)}a_{21}b_1(O_2)+\bold{\alpha_3(1)}a_{31}b_1(O_2) = \bold{\alpha_1(2)} \]&lt;/p&gt;
&lt;p&gt;同理可得 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_2(2),\alpha_3(2)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;\[\bold{\alpha_2(2)} = P(O_1O_2,s_2=q_2|\lambda) =\bold{\alpha_1(1)}a_{12}b_2(O_2)+\bold{\alpha_2(1)}a_{22}b_2(O_2)+\bold{\alpha_3(1)}a_{32}b_2(O_2) \\ \bold{\alpha_3(2)} = P(O_1O_2,s_2=q_3|\lambda) =\bold{\alpha_1(1)}a_{13}b_3(O_2)+\bold{\alpha_2(1)}a_{23}b_3(O_2)+\bold{\alpha_3(1)}a_{33}b_3(O_2) \]&lt;/p&gt;
&lt;p&gt;所以&lt;/p&gt;
&lt;p&gt;\[P(O_1O_2|\lambda) =P(O_1O_2,s_2=q_1|\lambda)+ P(O_1O_2,s_2=q_2|\lambda) +P(O_1O_2,s_2=q_3|\lambda)\\ = \alpha_1(2)+\alpha_2(2)+\alpha_3(2) \]&lt;/p&gt;
&lt;p&gt;所以&lt;strong&gt;前向算法&lt;/strong&gt;过程如下：&lt;/p&gt;
&lt;p&gt;​ step1：初始化 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i(1)= \pi_i*b_i(O_1)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ step2：计算 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i(t) = (\sum^{N}_{j=1} \alpha_j(t-1)a_{ji})b_i(O_{t})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ step3：&lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda) = \sum^N_{i=1}\alpha_i(T)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相比暴力法，时间复杂度降低了吗？&lt;/p&gt;
&lt;p&gt;当前时刻有 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 个状态，每个状态可能由前一时刻 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 个状态中的任意一个转移得到，所以单个时刻的时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(N^2)\)&lt;/span&gt;,总&lt;strong&gt;时间复杂度&lt;/strong&gt;为 &lt;span class=&quot;math inline&quot;&gt;\(O(TN^2)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;假设从三个 袋子 &lt;code&gt;{1,2,3}&lt;/code&gt;中 取出 4 个球 &lt;code&gt;O={red,white,red,white}&lt;/code&gt;，模型参数&lt;span class=&quot;math inline&quot;&gt;\(\lambda = (A,B,\pi)\)&lt;/span&gt; 如下，计算序列&lt;code&gt;O&lt;/code&gt;出现的概率&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#状态 1 2 3
A = [[0.5,0.2,0.3],
         [0.3,0.5,0.2],
         [0.2,0.3,0.5]]

pi = [0.2,0.4,0.4]

# red white
B = [[0.5,0.5],
         [0.4,0.6],
         [0.7,0.3]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ step1：初始化 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i(1)= \pi_i*b_i(O_1)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ step2：计算 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i(t) = (\sum^{N}_{j=1} \alpha_j(t-1)a_{ji})b_i(O_{t})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ step3：&lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda) = \sum^N_{i=1}\alpha_i( T)\)&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#前向算法
def hmm_forward(A,B,pi,O):
    T = len(O)
    N = len(A[0])
    #step1 初始化
    alpha = [[0]*T for _ in range(N)]
    for i in range(N):
        alpha[i][0] = pi[i]*B[i][O[0]]

    #step2 计算alpha(t)
    for t in range(1,T):
        for i in range(N):
            temp = 0
            for j in range(N):
                temp += alpha[j][t-1]*A[j][i]
            alpha[i][t] = temp*B[i][O[t]]
            
    #step3
    proba = 0
    for i in range(N):
        proba += alpha[i][-1]
    return proba,alpha

A = [[0.5,0.2,0.3],[0.3,0.5,0.2],[0.2,0.3,0.5]]
B = [[0.5,0.5],[0.4,0.6],[0.7,0.3]]
pi = [0.2,0.4,0.4]
O = [0,1,0,1]
hmm_forward(A,B,pi,O)  #结果为 0.06009
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/gongyanzh/blogpic/raw/master/pictures/image-20200512195503450.png&quot; alt=&quot;image-20200512195503450&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;后向算法&quot;&gt;后向算法&lt;/h4&gt;
&lt;p&gt;在时刻 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，状态为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 时，观测到 &lt;span class=&quot;math inline&quot;&gt;\(O_{t+1},O_{t+2}, ..., O_T\)&lt;/span&gt; 的概率，记为 &lt;span class=&quot;math inline&quot;&gt;\(\beta _i(t)\)&lt;/span&gt; ：&lt;/p&gt;
&lt;p&gt;\[\beta_{i}(t)=P\left(O_{t+1},O_{t+2}, ..., O_T | s_{t}=i, \lambda\right) \]&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(t=T\)&lt;/span&gt; 时，由于 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 时刻之后为空，没有观测，所以 &lt;span class=&quot;math inline&quot;&gt;\(\beta_i(t)=1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(t = T-1\)&lt;/span&gt; 时，观测 &lt;span class=&quot;math inline&quot;&gt;\(O_T\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(O_T\)&lt;/span&gt; 可能由任意一个状态产生&lt;/p&gt;
&lt;p&gt;\[\beta_i(T-1) = P(O_T|s_{t}=i,\lambda) = a_{i1}b_1(O_T)\beta_1(T)+a_{i2}b_2(O_T)\beta_2(T)+a_{i3}b_3(O_T)\beta_3(T) \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/gongyanzh/blogpic/raw/master/pictures/image-20200511214910979.png&quot; alt=&quot;image-20200511214910979&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(t=1\)&lt;/span&gt; 时，观测为 &lt;span class=&quot;math inline&quot;&gt;\(O_{2},O_{3}, ..., O_T\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \beta_1(1) &amp;amp;= P(O_{2},O_{3}, ..., O_T|s_1=1,\lambda)\\ &amp;amp;=a_{11}b_1(O_2)\beta_1(2)+a_{12}b_2(O_2)\beta_2(2)+a_{13}b_3(O_2)\beta_3(2) \\ \quad \\ \beta_2(1) &amp;amp;= P(O_{2},O_{3}, ..., O_T|s_1=2,\lambda)\\ &amp;amp;=a_{21}b_1(O_2)\beta_1(2)+a_{22}b_2(O_2)\beta_2(2)+a_{23}b_3(O_2)\beta_3(2) \\ \quad \\ \beta_3(1) &amp;amp;=P(O_{2},O_{3}, ..., O_T|s_1=3,\lambda)\\ &amp;amp;=a_{31}b_1(O_2)\beta_1(2)+a_{32}b_2(O_2)\beta_2(2)+a_{33}b_3(O_2)\beta_3(2) \end{aligned} \]&lt;/p&gt;
&lt;p&gt;所以&lt;/p&gt;
&lt;p&gt;\[P(O_{2},O_{3}, ..., O_T|\lambda) = \beta_1(1)+\beta_2(1)+\beta_3(1) \]&lt;/p&gt;
&lt;p&gt;后向算法过程如下：&lt;/p&gt;
&lt;p&gt;​ step1：初始化 &lt;span class=&quot;math inline&quot;&gt;\(\beta_i(T)=1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ step2：计算 &lt;span class=&quot;math inline&quot;&gt;\(\beta_i(t) = \sum^N_{j=1}a_{ij}b_j(O_{t+1})\beta_j(t+1)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ step3：&lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda) = \sum^N_{i=1}\pi_ib_i(O_1)\beta_i(1)\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度 &lt;span class=&quot;math inline&quot;&gt;\(O(N^2T)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是上面的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#后向算法
def hmm_backward(A,B,pi,O):
    T = len(O)
    N = len(A[0])
    #step1 初始化
    beta = [[0]*T for _ in range(N)]
    for i in range(N):
        beta[i][-1] = 1
        
    #step2 计算beta(t)
    for t in reversed(range(T-1)):
        for i in range(N):
            for j in range(N):
                beta[i][t]  += A[i][j]*B[j][O[t+1]]*beta[j][t+1]
            
    #step3
    proba = 0
    for i in range(N):
        proba += pi[i]*B[i][O[0]]*beta[i][0]
    return proba,beta

A = [[0.5,0.2,0.3],[0.3,0.5,0.2],[0.2,0.3,0.5]]
B = [[0.5,0.5],[0.4,0.6],[0.7,0.3]]
pi = [0.2,0.4,0.4]
O = [0,1,0,1]
hmm_backward(A,B,pi,O)  #结果为 0.06009
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/gongyanzh/blogpic/raw/master/pictures/image-20200512195526215.png&quot; alt=&quot;image-20200512195526215&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;前向-后向算法&quot;&gt;前向-后向算法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/gongyanzh/blogpic/raw/master/pictures/image-20200511201506794.png&quot; alt=&quot;image-20200511201506794&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回顾前向、后向变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(a_i(t)\)&lt;/span&gt; 时刻 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，状态为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; ，观测序列为 &lt;span class=&quot;math inline&quot;&gt;\(O_1,O_2, ..., O_t\)&lt;/span&gt; 的概率&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\beta_i(t)\)&lt;/span&gt; 时刻 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，状态为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; ，观测序列为 &lt;span class=&quot;math inline&quot;&gt;\(O_{t+1},O_{t+2}, ..., O_T\)&lt;/span&gt; 的概率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[\begin{aligned} P(O,s_t=i|\lambda) &amp;amp;= P(O_1,O_2, ..., O_T,s_t=i|\lambda)\\ &amp;amp;= P(O_1,O_2, ..., O_t,s_t=i,O_{t+1},O_{t+2}, ..., O_T|\lambda)\\ &amp;amp;= P(O_1,O_2, ..., O_t,s_t=i|\lambda)*P(O_{t+1},O_{t+2}, ..., O_T|O_1,O_2, ..., O_t,s_t=i,\lambda) \\ &amp;amp;= P(O_1,O_2, ..., O_t,s_t=i|\lambda)*P(O_{t+1},O_{t+2}, ..., O_T,s_t=i|\lambda)\\ &amp;amp;= a_i(t)*\beta_i(t) \end{aligned} \]&lt;/p&gt;
&lt;p&gt;即在给定的状态序列中，&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 时刻状态为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 的概率。&lt;/p&gt;
&lt;p&gt;使用前后向算法可以计算隐状态，记 &lt;span class=&quot;math inline&quot;&gt;\(\gamma_i(t) = P(s_t=i|O,\lambda)\)&lt;/span&gt; 表示时刻 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 位于隐状态 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 的概率&lt;/p&gt;
&lt;p&gt;\[P\left(s_{t}=i, O | \lambda\right)=\alpha_{i}(t) \beta_{i}(t) \]&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \gamma_{i}(t) &amp;amp;=P\left(s_{t}={i} | O, \lambda\right)=\frac{P\left(s_{t}={i}, O | \lambda\right)}{P(O | \lambda)} \\ &amp;amp;=\frac{\alpha_{i}(t) \beta_{i}(t)}{P(O | \lambda)}=\frac{\alpha_{i}(t) \beta_{i}(t)}{\sum_{i=1}^{N} \alpha_{i}(t) \beta_{i}(t)} \end{aligned} \]&lt;/p&gt;
&lt;p&gt;references：&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://www.cs.sjsu.edu/~stamp/RUA/HMM.pdf&quot;&gt;https://www.cs.sjsu.edu/~stamp/RUA/HMM.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]&lt;a href=&quot;https://www.cnblogs.com/fulcra/p/11065474.html&quot;&gt;https://www.cnblogs.com/fulcra/p/11065474.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://www.cnblogs.com/sjjsxl/p/6285629.html&quot;&gt;https://www.cnblogs.com/sjjsxl/p/6285629.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] &lt;a href=&quot;https://blog.csdn.net/xueyingxue001/article/details/52396494&quot;&gt;https://blog.csdn.net/xueyingxue001/article/details/52396494&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 May 2020 00:22:00 +0000</pubDate>
<dc:creator>周若梣</dc:creator>
<og:description>[TOC] 基本要素 状态 $N$个 状态序列 $S = s_1,s_2,...$ 观测序列 $O=O_1,O_2,...$ $\lambda(A,B,\pi)$ 状态转移概率 $A = \{a_{i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gongyanzh/p/12880147.html</dc:identifier>
</item>
<item>
<title>.net core HttpClient 使用之掉坑解析（一） - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12813692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12813692.html</guid>
<description>&lt;p&gt;在我们开发当中经常需要向特定URL地址发送Http请求操作，在.net core 中对httpClient使用不当会造成灾难性的问题，这篇文章主要来分享.net core中通过HttpFactory 工厂来使用HttpClient的正确打开方式。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;141&quot;&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;在我们开发当中经常需要向特定URL地址发送Http请求操作，在.net core 中对httpClient使用不当会造成灾难性的问题，这篇文章主要来分享.net core中通过IHttpClientFactory 工厂来使用HttpClient的正确打开方式。&lt;/p&gt;
&lt;h2 id=&quot;二、httpclient使用中的那些坑&quot;&gt;二、HttpClient使用中的那些坑&lt;/h2&gt;
&lt;h3 id=&quot;21-错误使用&quot;&gt;2.1 错误使用&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;using(var client = new HttpClient())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以先来做一个简单的测试，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public async Task&amp;lt;string&amp;gt; GetBaiduListAsync(string url)
 {
     var html = &quot;&quot;;
     for (var i = 0; i &amp;lt; 10; i++)
     {
          using (var client = new System.Net.Http.HttpClient())
          {
             var result=await client.GetStringAsync(url);
             html += result;
           }
     }
     return html;
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行项目输出结果后，通过netstate查看下TCP连接情况：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202005/824291-20200503114621000-310046717.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;虽然项目已经运行结束，但是连接依然存在，状态为&quot; TIME_WAIT&quot;（继续等待看是否还有延迟的包会传输过来；默认在windows下，&lt;code&gt;TIME_WAIT&lt;/code&gt;状态将会使系统将会保持该连接 240s。&lt;br/&gt;在高并发的情况下，连接来不及释放，socket被耗尽，耗尽之后就会出现喜闻乐见的一个错误：&lt;/p&gt;
&lt;h4 id=&quot;错误原因&quot;&gt;错误原因:&lt;/h4&gt;
&lt;p&gt;对象所占用资源应该确保及时被释放掉，但是，对于网络连接而言，这是错误的,原因有如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络连接是需要耗费一定时间的，频繁开启与关闭连接，性能会受影响；&lt;/li&gt;
&lt;li&gt;开启网络连接时会占用底层socket资源，但在HttpClient调用其本身的Dispose方法时，并不能立刻释放该资源，这意味着你的程序可能会因为耗尽连接资源而产生灾难性的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于上面的错误原因，大家可能会想到使用静态单例模式的HttpClient，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static HttpClient Client = new HttpClient();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;静态单例模式虽然可以解决上面问题，但是会带来另外一个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DNS变更会导致不能解析，DNS不会重新加载，需要重启才能变更（有兴趣的大佬可以去尝试一下）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、正确使用及源码分析&quot;&gt;三、正确使用及源码分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202005/824291-20200501154248841-1287450278.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HttpClientFactory 以模块化、可命名、可配置、弹性方式重建了 HttpClient 的使用方式： 由 DI 框架注入 IHttpClientFactory 工厂；由工厂创建 HttpClient 并从内部的 Handler 池分配请求 Handler。&lt;/p&gt;
&lt;p&gt;.net core 2.1 开始引入了IHttpClientFactory 工厂类来自动管理IHttpClientFactory 类的创建和资源释放，可以通过Ioc 注入方式进行使用，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddControllers();
services.AddHttpClient();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
private readonly IHttpClientFactory _clientFactory;

public FirstController(IHttpClientFactory clientFactory)
{
    _clientFactory = clientFactory;
}


/// &amp;lt;summary&amp;gt;
/// 
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;url&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public async Task&amp;lt;string&amp;gt; GetBaiduAsync(string url)
{
    var client = _clientFactory.CreateClient();
    var result = await client.GetStringAsync(url);
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中通过&lt;code&gt;IHttpClientFactory&lt;/code&gt; 中的&lt;code&gt;CreateClient()&lt;/code&gt;方法进行创建一个HttpClient 对象,但是没有看到有释放资源的动作，那它是怎么释放的呢？&lt;br/&gt;我们来看看它的主要源代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Creates a new &amp;lt;see cref=&quot;HttpClient&quot;/&amp;gt; using the default configuration.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;factory&quot;&amp;gt;The &amp;lt;see cref=&quot;IHttpClientFactory&quot;/&amp;gt;.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;An &amp;lt;see cref=&quot;HttpClient&quot;/&amp;gt; configured using the default configuration.&amp;lt;/returns&amp;gt;
public static HttpClient CreateClient(this IHttpClientFactory factory)
{
     if (factory == null)
     {
        throw new ArgumentNullException(nameof(factory));
     }

     return factory.CreateClient(Options.DefaultName);
}

public HttpClient CreateClient(string name)
{
     if (name == null)
     {
          throw new ArgumentNullException(nameof(name));
     }

     var handler = CreateHandler(name);
     var client = new HttpClient(handler, disposeHandler: false);

     var options = _optionsMonitor.Get(name);
     for (var i = 0; i &amp;lt; options.HttpClientActions.Count; i++)
     {
         options.HttpClientActions[i](client);
     }

     return client;
}

public HttpMessageHandler CreateHandler(string name)
{
     if (name == null)
     {
         throw new ArgumentNullException(nameof(name));
     }

     var entry = _activeHandlers.GetOrAdd(name, _entryFactory).Value;

     StartHandlerEntryTimer(entry);

     return entry.Handler;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中可以看到创建&lt;code&gt;HttpClent&lt;/code&gt; 时会先创建&lt;code&gt;HttpMessageHandler&lt;/code&gt;对象,而CreateHandler 方法中调用了&lt;code&gt;StartHandlerEntryTimer&lt;/code&gt;方法，该方法主要时启动清理释放定时器方法，核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public DefaultHttpClientFactory(
            IServiceProvider services,
            IServiceScopeFactory scopeFactory,
            ILoggerFactory loggerFactory,
            IOptionsMonitor&amp;lt;HttpClientFactoryOptions&amp;gt; optionsMonitor,
            IEnumerable&amp;lt;IHttpMessageHandlerBuilderFilter&amp;gt; filters)
        {
            if (services == null)
            {
                throw new ArgumentNullException(nameof(services));
            }

            if (scopeFactory == null)
            {
                throw new ArgumentNullException(nameof(scopeFactory));
            }

            if (loggerFactory == null)
            {
                throw new ArgumentNullException(nameof(loggerFactory));
            }

            if (optionsMonitor == null)
            {
                throw new ArgumentNullException(nameof(optionsMonitor));
            }

            if (filters == null)
            {
                throw new ArgumentNullException(nameof(filters));
            }

            _services = services;
            _scopeFactory = scopeFactory;
            _optionsMonitor = optionsMonitor;
            _filters = filters.ToArray();

            _logger = loggerFactory.CreateLogger&amp;lt;DefaultHttpClientFactory&amp;gt;();

            // case-sensitive because named options is.
            _activeHandlers = new ConcurrentDictionary&amp;lt;string, Lazy&amp;lt;ActiveHandlerTrackingEntry&amp;gt;&amp;gt;(StringComparer.Ordinal);
            _entryFactory = (name) =&amp;gt;
            {
                return new Lazy&amp;lt;ActiveHandlerTrackingEntry&amp;gt;(() =&amp;gt;
                {
                    return CreateHandlerEntry(name);
                }, LazyThreadSafetyMode.ExecutionAndPublication);
            };

            _expiredHandlers = new ConcurrentQueue&amp;lt;ExpiredHandlerTrackingEntry&amp;gt;();
            _expiryCallback = ExpiryTimer_Tick;

            _cleanupTimerLock = new object();
            _cleanupActiveLock = new object();
        }

        // Internal for tests
        internal void ExpiryTimer_Tick(object state)
        {
            var active = (ActiveHandlerTrackingEntry)state;

            // The timer callback should be the only one removing from the active collection. If we can't find
            // our entry in the collection, then this is a bug.
            var removed = _activeHandlers.TryRemove(active.Name, out var found);
            Debug.Assert(removed, &quot;Entry not found. We should always be able to remove the entry&quot;);
            Debug.Assert(object.ReferenceEquals(active, found.Value), &quot;Different entry found. The entry should not have been replaced&quot;);

            // At this point the handler is no longer 'active' and will not be handed out to any new clients.
            // However we haven't dropped our strong reference to the handler, so we can't yet determine if
            // there are still any other outstanding references (we know there is at least one).
            //
            // We use a different state object to track expired handlers. This allows any other thread that acquired
            // the 'active' entry to use it without safety problems.
            var expired = new ExpiredHandlerTrackingEntry(active);
            _expiredHandlers.Enqueue(expired);

            Log.HandlerExpired(_logger, active.Name, active.Lifetime);

            StartCleanupTimer();
        }

        // Internal so it can be overridden in tests
        internal virtual void StartHandlerEntryTimer(ActiveHandlerTrackingEntry entry)
        {
            entry.StartExpiryTimer(_expiryCallback);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从微软源码分析，HttpClient继承自HttpMessageInvoker，而HttpMessageInvoker实质就是HttpClientHandler。&lt;/p&gt;
&lt;p&gt;HttpClientFactory 创建的HttpClient，也即是HttpClientHandler，只是这些个HttpClient被放到了“池子”中，工厂每次在create的时候会自动判断是新建还是复用。(默认生命周期为2min)。&lt;br/&gt;希望这篇文章对你有帮助，如果对你有帮助请点个推荐，感谢!&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 12 May 2020 23:47:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>在我们开发当中经常需要向特定URL地址发送Http请求操作，在.net core 中对httpClient使用不当会造成灾难性的问题，这篇文章主要来分享.net core中通过HttpFactory</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12813692.html</dc:identifier>
</item>
<item>
<title>spring-boot如何去获取前端传递的参数 - 测试轩</title>
<link>http://www.cnblogs.com/zyjimmortalp/p/12879814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyjimmortalp/p/12879814.html</guid>
<description>&lt;p&gt;本文主要讨论spring-boot如何获取前端传过来的参数，这些参数主要有两大类，一类是URL里的参数，一个是请求body里的参数&lt;/p&gt;
&lt;h3 id=&quot;url里的参数&quot;&gt;url里的参数&lt;/h3&gt;
&lt;p&gt;通过url里传过来的参数一般有三种方式，下面我们来看一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;路径参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;路径参数就是说在请求路径里携带了几个参数，比如有一个查询banner详情的接口，/v2/banner/123,这里的123就是参数，可以表示banner的ID。&lt;/p&gt;
&lt;p&gt;下面我们设计了一个简陋的接口，来演示路径参数的获取&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@RequestMapping(value = &quot;/v2/banner&quot;)
public class BannerController {

    @GetMapping(&quot;/{id}&quot;)
    public Integer getBannerDetail(@PathVariable Integer id){
        return id;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取banner详情完整接口路径是/v2/banner/{id},这里的id就是路径参数，在方法的传参里，用@PathVariable注解标明那个参数用来接收请求路径传递过来的值,通过postman发个请求看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200513001019460-1409193887.png&quot; alt=&quot;image-20200512231356185&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里要注意，接口路由里定义的参数名要和方法参数里的定义名字要一样，如果不一样需要通过@PathVariable来指定**&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/{id}&quot;)
public Integer getBannerDetail(@PathVariable(name = &quot;id&quot;) Integer id12){
    return id12;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查询参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;查询参数就是请求的url里？号后面跟的键值对,比如/v2/banner?id=123,下面我们重新定义一个借口，采用查询参数的形式获取banner详情&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200513001019727-573574337.png&quot; alt=&quot;image-20200512231905390&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求url里的查询参数通过@RequestParam注解可以和方法里的参数进行一一对应，比如现在有这么个&lt;code&gt;url：/v2/banner?id=123&amp;amp;pos=3&lt;/code&gt;，那么接口的参数定义就得是&lt;code&gt;@RequestParam Integer id, @RequestParam Integer pos&lt;/code&gt;,请求上面定义的接口看看返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200513001020004-1322682369.png&quot; alt=&quot;image-20200512232224434&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;路径参数和查询参数结合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;路径参数和查询时可以同时使用的，那在定义接口的时候，同时使用这两种注解就行，比如下面的接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/{id}&quot;)
public Map&amp;lt;String, Object&amp;gt; getBannerDetail(@PathVariable Integer id, @RequestParam Integer pos){
    Map&amp;lt;String, Object&amp;gt; body = new HashMap&amp;lt;&amp;gt;();
    body.put(&quot;id&quot;, id);
    body.put(&quot;pos&quot;, pos);
    return body;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求一下接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200513001020263-1874871279.png&quot; alt=&quot;image-20200512232535782&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;请求body里的参数&quot;&gt;请求body里的参数&lt;/h3&gt;
&lt;p&gt;先来思考一个问题，当前端传递过来一个json的数据，我们的方法通过什么样的形式能够接受到参数呢？&lt;/p&gt;
&lt;p&gt;一般来说有两种形式，Map和自定义对象，下面我们分别来介绍一下。&lt;/p&gt;
&lt;p&gt;设计简单的banner创建接口，参数通过Map来接收，创建成功后，添加一个id，然后将传递的数据和id一起返回&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PostMapping(value = &quot;/create&quot;)
public Map&amp;lt;String, Object&amp;gt; createBanner(@RequestBody Map&amp;lt;String, Object&amp;gt; banner){
    banner.put(&quot;id&quot;, 1243);
    return banner;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里@RequestBody的这个注解来将body里的参数，转化成一个map，请求一下接口看看正常不：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200513001020528-774195684.png&quot; alt=&quot;image-20200512233539544&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面我们使用的Map,它是一个接口,在具体接收数据的时候,肯定会用一个Map的实现类，这就会设计到装箱拆箱的过程，那么频繁的装箱拆箱会有一定到的性能损耗，所以这种方式一般并不推荐使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自定义对象Dto&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们将接收请求参数的对象称作为数据传输对象，一般定义为XXXDto,这里我们定义一个创建banner时用来接收参数的对象BannerCreateDto.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BannerCreateDto {
    private String name;
    private Integer pos;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getPos() {
        return pos;
    }

    public void setPos(Integer pos) {
        this.pos = pos;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Controller具体使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PostMapping(value = &quot;/create&quot;)
public Map&amp;lt;String, Object&amp;gt; createBanner(@RequestBody BannerCreateDto dto){
    Map&amp;lt;String, Object&amp;gt; res = new HashMap&amp;lt;&amp;gt;();
    res.put(&quot;id&quot;, 10000);
    res.put(&quot;name&quot;, dto.getName());
    res.put(&quot;pos&quot;, dto.getPos());
    return res;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用@RequestBody标记BannerCreateDto对象，spring-boot会自动调用对象的getter和setter给他赋值。我们请求一下看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200513001020791-1822620542.png&quot; alt=&quot;image-20200512234718559&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;以上就是我们对spring-boot进行参数接收时处理方式的讨论，包括路径参数以及查询参数，还有body参数的接收，下篇文章我们将讨论一下参数的校验，敬请关注！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;gt; 本文链接：&lt;a href=&quot;https://www.immortalp.com/articles/2020/05/13/1589299551179.html&quot;&gt;https://www.immortalp.com/articles/2020/05/13/1589299551179.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.3258426966292&quot;&gt;
&lt;p&gt;欢迎大家去 &lt;a href=&quot;https://www.immortalp.com&quot;&gt;我的博客&lt;/a&gt; 瞅瞅，里面有更多关于测试实战的内容哦！！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 12 May 2020 16:10:00 +0000</pubDate>
<dc:creator>测试轩</dc:creator>
<og:description>本文主要讨论spring boot如何获取前端传过来的参数，这些参数主要有两大类，一类是URL里的参数，一个是请求body里的参数 url里的参数 通过url里传过来的参数一般有三种方式，下面我们来看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zyjimmortalp/p/12879814.html</dc:identifier>
</item>
<item>
<title>读写分离很难吗？SpringBoot结合aop简单就实现了 - Java知音号</title>
<link>http://www.cnblogs.com/javazhiyin/p/12879751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javazhiyin/p/12879751.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;入职新公司到现在也有一个月了，完成了手头的工作，前几天终于有时间研究下公司旧项目的代码。在研究代码的过程中，发现项目里用到了Spring Aop来实现数据库的读写分离，本着自己爱学习(我自己都不信…)的性格，决定写个实例工程来实现spring aop读写分离的效果。&lt;/p&gt;
&lt;h2&gt;环境部署&lt;/h2&gt;
&lt;p&gt;关于mysql的主从环境部署，可以参考：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://juejin.im/post/5dd13778e51d453da86c0e6f&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;开始项目&lt;/h2&gt;
&lt;p&gt;首先，毫无疑问，先开始搭建一个SpringBoot工程，然后在pom文件中引入如下依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;druid-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.1.10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;tk.mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mapper-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8.0.16&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 动态数据源 所需依赖 ### start&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-jdbc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;provided&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-aop&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;provided&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 动态数据源 所需依赖 ### end&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.projectlombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;lombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;fastjson&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-jpa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;目录结构&lt;/h2&gt;
&lt;p&gt;引入基本的依赖后，整理一下目录结构，完成后的项目骨架大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;读写分离很难吗？SpringBoot结合aop简单就实现了&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/05/java5-1588903367.jpeg&quot; alt=&quot;读写分离很难吗？SpringBoot结合aop简单就实现了&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/05/java5-1588903367.jpeg&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;建表&lt;/h3&gt;
&lt;p&gt;创建一张表user，在主库执行sql语句同时在从库生成对应的表数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;`;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;` (
  `&lt;/span&gt;&lt;span&gt;user_id&lt;/span&gt;` &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `&lt;/span&gt;&lt;span&gt;user_name&lt;/span&gt;` &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `user_phone` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户手机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `address` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;住址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `weight` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;权重，大者优先&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `created_at` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `updated_at` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;更新时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (`&lt;span&gt;user_id&lt;/span&gt;&lt;span&gt;`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1196978513958141952&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18826334748&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;广州市海珠区&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-11-20 10:28:51&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-11-22 14:28:26&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1196978513958141953&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18826274230&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;广州市天河区&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-11-20 10:29:37&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-11-22 14:28:14&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1196978513958141954&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18826273900&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;广州市天河区&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-11-20 10:30:19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-11-22 14:28:30&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;主从数据源配置&lt;/h3&gt;
&lt;p&gt;application.yml，主要信息是主从库的数据源配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;8001&lt;span&gt;
spring:
  jackson:
      date&lt;/span&gt;-format: yyyy-MM-&lt;span&gt;dd HH:mm:ss
      time&lt;/span&gt;-zone: GMT+8&lt;span&gt;
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver&lt;/span&gt;-&lt;span&gt;class&lt;/span&gt;-&lt;span&gt;name: com.mysql.cj.jdbc.Driver
    master:
      url: jdbc:mysql:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3307/user?serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;autoReconnect=true&amp;amp;failOverReadOnly=false&amp;amp;useSSL=false&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;allowMultiQueries=true&lt;/span&gt;
&lt;span&gt;      username: root
      password:
    slave:
      url: jdbc:mysql:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3308/user?serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;autoReconnect=true&amp;amp;failOverReadOnly=false&amp;amp;useSSL=false&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;allowMultiQueries=true&lt;/span&gt;
&lt;span&gt;      username: root
      password:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为有一主一从两个数据源，我们用枚举类来代替，方便我们使用时能对应&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Getter
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; DynamicDataSourceEnum {
    MASTER(&lt;/span&gt;&quot;master&quot;&lt;span&gt;),
    SLAVE(&lt;/span&gt;&quot;slave&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String dataSourceName;
    DynamicDataSourceEnum(String dataSourceName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dataSourceName =&lt;span&gt; dataSourceName;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;数据源配置信息类 DataSourceConfig，这里配置了两个数据源，masterDb和slaveDb&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@MapperScan(basePackages &lt;/span&gt;= &quot;com.xjt.proxy.mapper&quot;, sqlSessionTemplateRef = &quot;sqlTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataSourceConfig {

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主库&lt;/span&gt;
&lt;span&gt;      @Bean
      @ConfigurationProperties(prefix &lt;/span&gt;= &quot;spring.datasource.master&quot;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSource masterDb() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DruidDataSourceBuilder.create().build();
      }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 从库
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    @ConditionalOnProperty(prefix &lt;/span&gt;= &quot;spring.datasource&quot;, name = &quot;slave&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    @ConfigurationProperties(prefix &lt;/span&gt;= &quot;spring.datasource.slave&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSource slaveDb() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DruidDataSourceBuilder.create().build();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 主从动态配置
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DynamicDataSource dynamicDb(@Qualifier(&quot;masterDb&quot;&lt;span&gt;) DataSource masterDataSource,
        @Autowired(required &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;) @Qualifier(&quot;slaveDb&quot;&lt;span&gt;) DataSource slaveDataSource) {
        DynamicDataSource dynamicDataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DynamicDataSource();
        Map&lt;/span&gt;&amp;lt;Object, Object&amp;gt; targetDataSources = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        targetDataSources.put(DynamicDataSourceEnum.MASTER.getDataSourceName(), masterDataSource);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slaveDataSource != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            targetDataSources.put(DynamicDataSourceEnum.SLAVE.getDataSourceName(), slaveDataSource);
        }
        dynamicDataSource.setTargetDataSources(targetDataSources);
        dynamicDataSource.setDefaultTargetDataSource(masterDataSource);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dynamicDataSource;
    }
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SqlSessionFactory sessionFactory(@Qualifier(&quot;dynamicDb&quot;) DataSource dynamicDataSource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        SqlSessionFactoryBean bean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBean();
        bean.setMapperLocations(
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/*Mapper.xml&quot;&lt;span&gt;));
        bean.setDataSource(dynamicDataSource);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean.getObject();
    }
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SqlSessionTemplate sqlTemplate(@Qualifier(&quot;sessionFactory&quot;&lt;span&gt;) SqlSessionFactory sqlSessionFactory) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionTemplate(sqlSessionFactory);
    }
    @Bean(name &lt;/span&gt;= &quot;dataSourceTx&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataSourceTransactionManager dataSourceTx(@Qualifier(&quot;dynamicDb&quot;&lt;span&gt;) DataSource dynamicDataSource) {
        DataSourceTransactionManager dataSourceTransactionManager &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dynamicDataSource);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSourceTransactionManager;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;设置路由&lt;/h3&gt;
&lt;p&gt;设置路由的目的为了方便查找对应的数据源，我们可以用ThreadLocal保存数据源的信息到每个线程中，方便我们需要时获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataSourceContextHolder {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; DYNAMIC_DATASOURCE_CONTEXT = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(String datasourceType) {
        DYNAMIC_DATASOURCE_CONTEXT.set(datasourceType);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String get() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DYNAMIC_DATASOURCE_CONTEXT.get();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        DYNAMIC_DATASOURCE_CONTEXT.remove();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;获取路由&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DynamicDataSource &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractRoutingDataSource {
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object determineCurrentLookupKey() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DataSourceContextHolder.get();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;AbstractRoutingDataSource的作用是基于查找key路由到对应的数据源，它内部维护了一组目标数据源，并且做了路由key与目标数据源之间的映射，提供基于key查找数据源的方法。更多springboot文章，查看往期：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;amp;mid=2247488811&amp;amp;idx=2&amp;amp;sn=0d054027651bef114ae6bec5a8f62359&amp;amp;chksm=ebd62a07dca1a3111269692dd9b0a5ab8af7d2038b8ec6600a057573364e76db1332adc5fd46&amp;amp;scene=21#wechat_redirect&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;SpringBoot内容聚合&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;数据源的注解&lt;/h3&gt;
&lt;p&gt;为了可以方便切换数据源，我们可以写一个注解，注解中包含数据源对应的枚举值，默认是主库，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DataSourceSelector {

    DynamicDataSourceEnum value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; DynamicDataSourceEnum.MASTER;
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; clear() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;aop切换数据源&lt;/h3&gt;
&lt;p&gt;到这里，aop终于可以现身出场了，这里我们定义一个aop类，对有注解的方法做切换数据源的操作，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Slf4j
@Aspect
@Order(value &lt;/span&gt;= 1&lt;span&gt;)
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataSourceContextAop {

 @Around(&lt;/span&gt;&quot;@annotation(com.xjt.proxy.dynamicdatasource.DataSourceSelector)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object setDynamicDataSource(ProceedingJoinPoint pjp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; clear = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Method method &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getMethod(pjp);
            DataSourceSelector dataSourceImport &lt;/span&gt;= method.getAnnotation(DataSourceSelector.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            clear &lt;/span&gt;=&lt;span&gt; dataSourceImport.clear();
            DataSourceContextHolder.set(dataSourceImport.value().getDataSourceName());
            log.info(&lt;/span&gt;&quot;========数据源切换至：{}&quot;&lt;span&gt;, dataSourceImport.value().getDataSourceName());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pjp.proceed();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clear) {
                DataSourceContextHolder.clear();
            }

        }
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Method getMethod(JoinPoint pjp) {
        MethodSignature signature &lt;/span&gt;=&lt;span&gt; (MethodSignature)pjp.getSignature();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; signature.getMethod();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到这一步，我们的准备配置工作就完成了，下面开始测试效果。更多springboot文章，查看往期：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;amp;mid=2247488811&amp;amp;idx=2&amp;amp;sn=0d054027651bef114ae6bec5a8f62359&amp;amp;chksm=ebd62a07dca1a3111269692dd9b0a5ab8af7d2038b8ec6600a057573364e76db1332adc5fd46&amp;amp;scene=21#wechat_redirect&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;SpringBoot内容聚合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先写好Service文件，包含读取和更新两个方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserMapper userMapper;

    @DataSourceSelector(value &lt;/span&gt;=&lt;span&gt; DynamicDataSourceEnum.SLAVE)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; listUser() {
        List&lt;/span&gt;&amp;lt;User&amp;gt; users =&lt;span&gt; userMapper.selectAll();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; users;
    }

    @DataSourceSelector(value &lt;/span&gt;=&lt;span&gt; DynamicDataSourceEnum.MASTER)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; update() {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setUserId(Long.parseLong(&lt;/span&gt;&quot;1196978513958141952&quot;&lt;span&gt;));
        user.setUserName(&lt;/span&gt;&quot;修改后的名字2&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userMapper.updateByPrimaryKeySelective(user);
    }

    @DataSourceSelector(value &lt;/span&gt;=&lt;span&gt; DynamicDataSourceEnum.SLAVE)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User find() {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setUserId(Long.parseLong(&lt;/span&gt;&quot;1196978513958141952&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userMapper.selectByPrimaryKey(user);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据方法上的注解可以看出，读的方法走从库，更新的方法走主库，更新的对象是userId为1196978513958141953 的数据，&lt;/p&gt;
&lt;p&gt;然后我们写个测试类测试下是否能达到效果，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserServiceTest {

    @Autowired
    UserService userService;

    @Test
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; listUser() {
        List&lt;/span&gt;&amp;lt;User&amp;gt; users =&lt;span&gt; userService.listUser();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (User user : users) {
            System.out.println(user.getUserId());
            System.out.println(user.getUserName());
            System.out.println(user.getUserPhone());
        }
    }
    @Test
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
        userService.update();
        User user &lt;/span&gt;=&lt;span&gt; userService.find();
        System.out.println(user.getUserName());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;测试结果：&lt;/h3&gt;
&lt;p&gt;1、读取方法&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;读写分离很难吗？SpringBoot结合aop简单就实现了&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/05/java2-1588903367.jpeg&quot; alt=&quot;读写分离很难吗？SpringBoot结合aop简单就实现了&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/05/java2-1588903367.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、更新方法&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;读写分离很难吗？SpringBoot结合aop简单就实现了&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/05/java10-1588903367-1.jpeg&quot; alt=&quot;读写分离很难吗？SpringBoot结合aop简单就实现了&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/05/java10-1588903367-1.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行之后，比对数据库就可以发现主从库都修改了数据，说明我们的读写分离是成功的。当然，更新方法可以指向从库，这样一来就只会修改到从库的数据，而不会涉及到主库。&lt;/p&gt;
&lt;h2&gt;注意&lt;/h2&gt;
&lt;p&gt;上面测试的例子虽然比较简单，但也符合常规的读写分离配置。值得说明的是，读写分离的作用是为了缓解写库，也就是主库的压力，但一定要基于数据一致性的原则，就是保证主从库之间的数据一定要一致。如果一个方法涉及到写的逻辑，那么该方法里所有的数据库操作都要走主库。&lt;/p&gt;
&lt;p&gt;假设写的操作执行完后数据有可能还没同步到从库，然后读的操作也开始执行了，如果这个读取的程序走的依然是从库的话，那么就会出现数据不一致的现象了，这是我们不允许的。&lt;br/&gt;最后发一下项目的github地址，有兴趣的同学可以看下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://github.com/Taoxj/mysql-proxy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;參考：&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://www.cnblogs.com/cjsblog/p/9712457.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：鄙人薛某&lt;/p&gt;
&lt;p&gt;链接：juejin.im/post/5ddcd93af265da7dce3271de&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 12 May 2020 15:52:00 +0000</pubDate>
<dc:creator>Java知音号</dc:creator>
<og:description>前言 入职新公司到现在也有一个月了，完成了手头的工作，前几天终于有时间研究下公司旧项目的代码。在研究代码的过程中，发现项目里用到了Spring Aop来实现数据库的读写分离，本着自己爱学习(我自己都不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javazhiyin/p/12879751.html</dc:identifier>
</item>
<item>
<title>.NET Attribute在数据校验上的应用 - hexuwsbg</title>
<link>http://www.cnblogs.com/hexu0512/p/12879671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hexu0512/p/12879671.html</guid>
<description>&lt;p&gt;Attribute（特性）的概念不在此赘述了，相信有点.NET基础的开发人员都明白，用过Attribute的人也不在少数，毕竟很多框架都提供自定义的属性，类似于Newtonsoft.JSON中JsonProperty、JsonIgnore等&lt;/p&gt;
&lt;h2 id=&quot;自定义特性&quot;&gt;自定义特性&lt;/h2&gt;
&lt;p&gt;.NET 框架允许创建自定义特性，用于存储声明性的信息，且可在运行时被检索。该信息根据设计标准和应用程序需要，可与任何目标元素相关。&lt;/p&gt;
&lt;p&gt;创建并使用自定义特性包含四个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;声明自定义特性&lt;/li&gt;
&lt;li&gt;构建自定义特性&lt;/li&gt;
&lt;li&gt;在目标程序元素上应用自定义特性&lt;/li&gt;
&lt;li&gt;通过反射访问特性&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;声明自定义特性&quot;&gt;声明自定义特性&lt;/h3&gt;
&lt;p&gt;一个新的自定义特性必须派生自System.Attribute类，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FieldDescriptionAttribute : Attribute
{
    public string Description { get; private set; }

    public FieldDescriptionAttribute(string description)
    {
        Description = description;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class UserEntity
{
    [FieldDescription(&quot;用户名称&quot;)]
    public string Name { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该如何拿到我们标注的信息呢？这时候需要使用反射获取&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      var type = typeof(UserEntity);
      var properties = type.GetProperties();
      foreach (var item in properties)
      {
          if(item.IsDefined(typeof(FieldDescriptionAttribute), true))
          {
              var attribute = item.GetCustomAttribute(typeof(FieldDescriptionAttribute)) as FieldDescriptionAttribute;
              Console.WriteLine(attribute.Description);
          }
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1171637/202005/1171637-20200512225950643-1151892047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从执行结果上看，我们拿到了我们想要的数据，那么这个特性在实际使用过程中，到底有什么用途呢？&lt;/p&gt;
&lt;h3 id=&quot;attribute特性妙用&quot;&gt;Attribute特性妙用&lt;/h3&gt;
&lt;p&gt;在实际开发过程中，我们的系统总会提供各种各样的对外接口，其中参数的校验是必不可少的一个环节。然而没有特性时，校验的代码是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public class UserEntity
  {
      /// &amp;lt;summary&amp;gt;
      /// 姓名
      /// &amp;lt;/summary&amp;gt;
      [FieldDescription(&quot;用户名称&quot;)]
      public string Name { get; set; }

      /// &amp;lt;summary&amp;gt;
      /// 年龄
      /// &amp;lt;/summary&amp;gt;
      public int Age { get; set; }

      /// &amp;lt;summary&amp;gt;
      /// 地址
      /// &amp;lt;/summary&amp;gt;
      public string Address { get; set; }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;      UserEntity user = new UserEntity();

      if (string.IsNullOrWhiteSpace(user.Name))
      {
          throw new Exception(&quot;姓名不能为空&quot;);
      }
      if (user.Age &amp;lt;= 0)
      {
          throw new Exception(&quot;年龄不合法&quot;);
      }
      if (string.IsNullOrWhiteSpace(user.Address))
      {
          throw new Exception(&quot;地址不能为空&quot;);
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字段多了之后这种代码就看着非常繁琐，并且看上去不直观。对于这种繁琐又恶心的代码，有什么方法可以优化呢？&lt;br/&gt;使用特性后的验证写法如下：&lt;/p&gt;
&lt;p&gt;首先定义一个基础的校验属性，提供基础的校验方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public abstract class AbstractCustomAttribute : Attribute
    {
        /// &amp;lt;summary&amp;gt;
        /// 校验后的错误信息
        /// &amp;lt;/summary&amp;gt;
        public string ErrorMessage { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 数据校验
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public abstract void Validate(object value);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后可以定义常用的一些对应的校验Attribute，例如RequiredAttribute、StringLengthAttribute&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 非空校验
        /// &amp;lt;/summary&amp;gt;
        [AttributeUsage(AttributeTargets.Property)]
        public class RequiredAttribute : AbstractCustomAttribute
        {
            public override void Validate(object value)
            {
                if (value == null || string.IsNullOrWhiteSpace(value.ToString()))
                {
                    throw new Exception(string.IsNullOrWhiteSpace(ErrorMessage) ? &quot;字段不能为空&quot; : ErrorMessage);
                }
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 自定义验证，验证字符长度
        /// &amp;lt;/summary&amp;gt;
        [AttributeUsage(AttributeTargets.Property)]
        public class StringLengthAttribute : AbstractCustomAttribute
        {
            private int _maxLength;
            private int _minLength;

            public StringLengthAttribute(int minLength, int maxLength)
            {
                this._maxLength = maxLength;
                this._minLength = minLength;
            }

            public override void Validate(object value)
            {
                if (value != null &amp;amp;&amp;amp; value.ToString().Length &amp;gt;= _minLength &amp;amp;&amp;amp; value.ToString().Length &amp;lt;= _maxLength)
                {
                    return;
                }

                throw new Exception(string.IsNullOrWhiteSpace(ErrorMessage) ? $&quot;字段长度必须在{_minLength}与{_maxLength}之间&quot; : ErrorMessage);
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加一个用于校验的ValidateExtensions&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class ValidateExtensions
  {
      /// &amp;lt;summary&amp;gt;
      /// 校验
      /// &amp;lt;/summary&amp;gt;
      /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
      /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
      public static void Validate&amp;lt;T&amp;gt;(this T entity) where T : class
      {
          Type type = entity.GetType();

          foreach (var item in type.GetProperties())
          {
              //需要对Property的字段类型做区分处理针对Object List 数组需要做区分处理
              if (item.PropertyType.IsPrimitive || item.PropertyType.IsEnum || item.PropertyType.IsValueType || item.PropertyType == typeof(string))
              {
                  //如果是基元类型、枚举类型、值类型或者字符串 直接进行校验
                  CheckProperty(entity, item);
              }
              else
              {
                  //如果是引用类型
                  var value = item.GetValue(entity, null);
                  CheckProperty(entity, item);
                  if (value != null)
                  {
                      if ((item.PropertyType.IsGenericType &amp;amp;&amp;amp; Array.Exists(item.PropertyType.GetInterfaces(), t =&amp;gt; t.GetGenericTypeDefinition() == typeof(IList&amp;lt;&amp;gt;))) || item.PropertyType.IsArray)
                      {
                          //判断IEnumerable
                          var enumeratorMI = item.PropertyType.GetMethod(&quot;GetEnumerator&quot;);
                          var enumerator = enumeratorMI.Invoke(value, null);
                          var moveNextMI = enumerator.GetType().GetMethod(&quot;MoveNext&quot;);
                          var currentMI = enumerator.GetType().GetProperty(&quot;Current&quot;);
                          int index = 0;
                          while (Convert.ToBoolean(moveNextMI.Invoke(enumerator, null)))
                          {
                              var currentElement = currentMI.GetValue(enumerator, null);
                              if (currentElement != null)
                              {
                                  currentElement.Validate();
                              }
                              index++;
                          }
                      }
                      else
                      {
                          value.Validate();
                      }
                  }
              }
          }
      }

      private static void CheckProperty(object entity, PropertyInfo property)
      {
          if (property.IsDefined(typeof(AbstractCustomAttribute), true))//此处是重点
          {
              //此处是重点
              foreach (AbstractCustomAttribute attribute in property.GetCustomAttributes(typeof(AbstractCustomAttribute), true))
              {
                  if (attribute == null)
                  {
                      throw new Exception(&quot;AbstractCustomAttribute not instantiate&quot;);
                  }

                  attribute.Validate(property.GetValue(entity, null));
              }
          }
      }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新的实体类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public class UserEntity
  {
      /// &amp;lt;summary&amp;gt;
      /// 姓名
      /// &amp;lt;/summary&amp;gt;
      [Required]
      public string Name { get; set; }

      /// &amp;lt;summary&amp;gt;
      /// 年龄
      /// &amp;lt;/summary&amp;gt;
      public int Age { get; set; }

      /// &amp;lt;summary&amp;gt;
      /// 地址
      /// &amp;lt;/summary&amp;gt;
      [Required]
      public string Address { get; set; }

      [StringLength(11, 11)]
      public string PhoneNum { get; set; }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UserEntity user = new UserEntity();
user.Validate();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的校验逻辑写的比较复杂，主要是考虑到对象中包含复杂对象的情况，如果都是简单对象，可以不用考虑，只需针对单个属性做字段校验&lt;br/&gt;现有的方式是在校验不通过的时候抛出异常，此处大家也可以自定义异常来表示校验的问题，也可以返回自定义的校验结果实体来记录当前是哪个字段出的问题，留待大家自己实现&lt;br/&gt;如果您有更好的建议和想法欢迎提出，共同进步&lt;/p&gt;
&lt;p&gt;以上代码均为原创分享，若大家认为有不妥的地方，烦请留言指出，在下感激不尽&lt;/p&gt;
&lt;h4 id=&quot;本文作者：hexuwsbg&quot;&gt;本文作者：hexuwsbg&lt;/h4&gt;
&lt;h4 id=&quot;出处：httpswwwcnblogscomhexu0512p12879671html&quot;&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/hexu0512/p/12879671.html&quot;&gt;https://www.cnblogs.com/hexu0512/p/12879671.html&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;版权：本文采用「可附带出处转载」知识共享许可协议进行许可&quot;&gt;版权：本文采用「可附带出处转载」知识共享许可协议进行许可&lt;/h4&gt;
</description>
<pubDate>Tue, 12 May 2020 15:39:00 +0000</pubDate>
<dc:creator>hexuwsbg</dc:creator>
<og:description>Attribute（特性）的概念不在此赘述了，相信有点.NET基础的开发人员都明白，用过Attribute的人也不在少数，毕竟很多框架都提供自定义的属性，类似于Newtonsoft.JSON中Json</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hexu0512/p/12879671.html</dc:identifier>
</item>
<item>
<title>C# 9.0 新特性预览 - 空参数校验 - Rwing</title>
<link>http://www.cnblogs.com/Rwing/p/csharp-9-0-preview-null-arg-checking.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rwing/p/csharp-9-0-preview-null-arg-checking.html</guid>
<description>&lt;p&gt;随着 .NET 5 发布日期的日益临近，其对应的 C# 新版本已确定为 C# 9.0，其中新增加的特性（或语法糖）也已基本锁定，本系列文章将向大家展示它们。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;110.31256674973&quot;&gt;


&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;随着 .NET 5 发布日期的日益临近，其对应的 C# 新版本已确定为 C# 9.0，其中新增加的特性（或语法糖）也已基本锁定，本系列文章将向大家展示它们。&lt;/p&gt;
&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;p&gt;[&lt;a href=&quot;https://www.cnblogs.com/Rwing/p/csharp-9-0-preview-target-typed-new.html&quot;&gt;C# 9.0 新特性预览 - 类型推导的 new&lt;/a&gt;]&lt;br/&gt;[&lt;a href=&quot;https://www.cnblogs.com/Rwing/p/csharp-9-0-preview-null-arg-checking.html&quot;&gt;C# 9.0 新特性预览 - 空参数校验&lt;/a&gt;]&lt;br/&gt;[C# 9.0 新特性预览 - Lambda 中的弃元]&lt;br/&gt;[C# 9.0 新特性预览 - Record 类型]&lt;br/&gt;[C# 9.0 新特性预览 - 模式匹配的改善]&lt;br/&gt;[C# 9.0 新特性预览 - 其他小的变化]&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&quot;简便的空参数校验-simplified-null-argument-checking&quot;&gt;简便的空参数校验 (Simplified Null Argument Checking)&lt;/h3&gt;

&lt;h4 id=&quot;目的&quot;&gt;目的&lt;/h4&gt;
&lt;p&gt;这个特性主要是为了更简便的检查方法的参数是否为 null 并抛出 ArgumentNullExceptiony 异常。&lt;br/&gt;&lt;/p&gt;
&lt;h4 id=&quot;语法&quot;&gt;语法&lt;/h4&gt;
&lt;p&gt;语法很简单，在参数名后加个叹号即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;void M(string name!) {
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码会被翻译为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;void M(string name) {
    if (name is null) {
        throw new ArgumentNullException(nameof(name));
    }
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想必有些同学已经从上面代码看出来了，这个生成的空校验，只是校验参数是否为 null，这也就意味着它无法在值类型上使用，以下代码将报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// Error: 无法在值类型参数上使用!操作符
void G&amp;lt;T&amp;gt;(T arg!) where T : struct {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，可空的值类型是可以的，但是编译器会提示一条警告，提示你在可空类型上进行了空检查：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// Warning: 将显式null检查与可为null的类型结合使用
void M(int? x!) { 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似的，在参数拥有默认值的情况下，也会提示警告&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// Warning: 参数 'x' 进行了空检查但是它默认为空
void M(string x! = null) { 
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;构造方法的场景&quot;&gt;构造方法的场景&lt;/h4&gt;
&lt;p&gt;在构造方法的场景下，空参数校验将发生在任何其他代码的前面，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对其他构造方法的链式调用，即 this() 或 base()&lt;/li&gt;
&lt;li&gt;在构造方法内的隐式字段初始化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class C {
    string field = GetString();
    C(string name!): this(name) {
        ...
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码会大致翻译为以下伪代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class C {
    C(string name)
        if (name is null) {
            throw new ArgumentNullException(nameof(name));
        }
        field = GetString();
        :this(name);
        ...
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;lambda-的场景&quot;&gt;Lambda 的场景&lt;/h4&gt;
&lt;p&gt;这个特性在 lambda 中也可以使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;void G() {
    Func&amp;lt;string, string&amp;gt; s = x! =&amp;gt; x;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;不可以使用的场景&quot;&gt;不可以使用的场景&lt;/h4&gt;
&lt;p&gt;这个特性只能用于有方法体的方法中，也就意味着它不能用于抽象方法、接口、委托和部分方法。&lt;br/&gt;以下代码编译器会报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;interface C
{
    public int M(string x!);// ERROR
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不能用于属性。因为属性 setter 中的 value 是隐式的，不会出现在参数列表中，所以此特性不适用于属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;string FirstName! { get; set; } // ERROR
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不能用于 out / ref / in 的参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void M(out string x!) {} // ERROR
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;[&lt;a href=&quot;https://github.com/dotnet/csharplang/blob/master/proposals/null-arg-checking.md&quot;&gt;Proposal: Simplified Null Argument Checking&lt;/a&gt;]&lt;br/&gt;[&lt;a href=&quot;https://github.com/dotnet/roslyn/blob/features%2Fparam-nullchecking/src/Compilers/CSharp/Test/Semantic/Semantics/NullCheckedParameterTests.cs&quot;&gt;Unit test: NullCheckedParameterTests.cs&lt;/a&gt;]&lt;br/&gt;[&lt;a href=&quot;https://github.com/dotnet/csharplang/blob/master/meetings/2019/LDM-2019-07-10.md#param&quot;&gt;LDM-2019-07-10.md&lt;/a&gt;]&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 12 May 2020 15:21:00 +0000</pubDate>
<dc:creator>Rwing</dc:creator>
<og:description>随着 .NET 5 发布日期的日益临近，其对应的 C# 新版本已确定为 C# 9.0，其中新增加的特性（或语法糖）也已基本锁定，本系列文章将向大家展示它们。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Rwing/p/csharp-9-0-preview-null-arg-checking.html</dc:identifier>
</item>
<item>
<title>[工具]微软的学习平台Microsoft Learn很好用，推荐一下 - dino.c</title>
<link>http://www.cnblogs.com/dino623/p/get_started_using_Microsoft_Learn.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dino623/p/get_started_using_Microsoft_Learn.html</guid>
<description>&lt;h2 id=&quot;1-什么是microsoft-learn&quot;&gt;1. 什么是Microsoft Learn&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223501111-470141043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/learn/&quot;&gt;Microsoft Learn&lt;/a&gt;是微软这两年大力推广的全新学习平台，可提供 Microsoft 产品交互式学习体验。基本上无需登录即可使用，但登录后可以使用更多功能，包括：&lt;/p&gt;
&lt;h2 id=&quot;2-选择课程&quot;&gt;2. 选择课程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223548732-1636668932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223553458-395749339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Microsoft Learn的网站首页会提供“你可能喜欢的内容”，也可以浏览所有学习选项找到自己想学习的内容。学习内容有两种类型，分别是学习路径和模块：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;学习路径&lt;/strong&gt;是围绕特定角色（如开发人员、架构师或系统管理员）或技术（如 Azure Web 应用、Power BI 或 Xamarin.Forms）组织的模块集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;模块&lt;/strong&gt;是 Microsoft Learn 体验的构建基块。 可以将模块看成是包含一系列相关单元（如视频、实验室和文章）的课程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如上图中的“Azure基础学习”就是一个学习路径，从它下面的进度条可以看到我已经完成了这个学习路径的40%。点击还能看到如下图的详细内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223615878-428630323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在标题下显示此路径的剩余学习时间、我已完成了多少个模块、这个学习路径的简介。右上角是这个学习路径总的XP（用于升级）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223637952-362231042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简介下面就是此路径中需要学习的模块，每个模块又由多个单元组成，每个单元分别给出了大概的学习时间，学习后可以获得的XP。对于感兴趣的模块还可以点击右下角的添加按钮将它添加到一个由自己管理的集合，方便以后回顾。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223656082-1331225347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-学习azure&quot;&gt;3. 学习Azure&lt;/h2&gt;
&lt;p&gt;我在一月份参考了深圳的的Microsoft Ignite，获得了一次免费的&lt;a href=&quot;https://docs.microsoft.com/zh-cn/learn/certifications/microsoft-ignite-free-certification-exam-offer&quot;&gt;考试机会&lt;/a&gt;（不知道下次Ignite还会不会送考试机会）。机会难得我就开始了使用Microsoft Azure进行Azure的学习。当然，大家要明白学习、考试和工作的内容并不是一回事，要通过认证考试只学习了Microsoft Learn的学习路径可能不够，还需自己多多努力。对于Azure，Microsoft Learn提供了无与伦比的交互式学习体验。它的学习有三种形式：文档、知识检查和实践练习。&lt;/p&gt;
&lt;p&gt;微软的文档一向优秀，Microsoft Learn中相当一部分学习内容都是文档阅读，而且提供了40多种语言，这些文档本身就是知识的宝库。可惜缺点还是有，首先是知识可能没有及时更新，有些实践步骤根据Visual Studio 2017编写，和Visual Studio 2019有出入，例如一些需要安装扩展才能实现的功能在2019已成为内置功能；或者是文档里的Azure网站截图已经过时。其次是翻译和实际环境有出入，例如“Azure Functions”有时翻译成“Azure 函数”，但实际环境可能还是显示“Azure Functions”。这些都是小问题，最大的问题是有的翻译过于生硬，例如这句“通过应用服务进行纵向扩展和横向扩展来缩放应用服务 Web 应用以有效满足需求”，原文“Scale an App Service web app to efficiently meet demand with App Service scale up and scale out”还比较容易理解。&lt;/p&gt;
&lt;p&gt;在一些模块的中间或最后，Microsoft Learn会穿插一个知识检查单元，以检查学员是否已经正确理解文档的知识点。无论选择的答案正确与否，答案后面都会给出一个详细解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223714781-1998918835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实践练习是Microsoft Learn最有价值的部分。学习Azure最大的困难在于申请资源、配置环境、各个模块间配置的污染，这些困难都让人对学习Azure望而却步。Microsoft Learn每天为学员提供10个免费的&lt;a href=&quot;https://docs.microsoft.com/zh-cn/learn/support/faq?pivots=sandbox&quot;&gt;沙盒&lt;/a&gt;，每个沙盒都是独立的Azure环境可供学员在练习中使用。通常每个模块使用一个沙盒，一天10个沙盒绰绰有余。部分模块可以直接在文档右侧启动Azure Cloud Shell，更加方便实践操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223727842-34582911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-成就&quot;&gt;4. 成就&lt;/h2&gt;
&lt;p&gt;为了保持学习的动力，每次完成一个单元都可以获得XP，积累到一定数量会提升等级，这和游戏很像（只是为学习稍微添加了一点点点点点点点点的乐趣）。在网站的右上角能看到自己的等级，点击可以进到“我的个人资料”页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223743319-1923947409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个页面能看到自己在Microsoft Learn的大部分资料，例如书签、集合、关注等。“从上次离开的位置继续”这个功能很重要，可以帮助学员顺畅地继续上一次的学习。点击“成就”链接，可以看到收集的徽章和奖杯（这点也和游戏很像），每个徽章和奖杯都有具体的完成时间和完成的内容，这样就能方便地回顾自己的学习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223804455-2011561803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223810566-1667312777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-认证&quot;&gt;5. 认证&lt;/h2&gt;
&lt;p&gt;自 2020 年 6 月 30 日起，微软将不再提供 MCSA，MCSD 和 MCSE 的所有考试，转向基于角色的认证（后来因为疫情延期后到明年）。具体可以看下面的新闻：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/learning/community-blog-post.aspx?BlogId=8&amp;amp;Id=375282&quot;&gt;Microsoft Learning Blog post - MCSA, MCSD, MCSE certifications retire; with continued investment to role-based certifications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223829594-426282166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Microsoft Learn网站上点击“认证”链接以浏览微软提供的认证。选中需要的认证可以看到具体的学习内容，考试大纲，学习路径以及各种学习资源。例如&lt;a href=&quot;https://docs.microsoft.com/zh-cn/learn/certifications/azure-developer&quot;&gt;Microsoft Certified: Azure Developer Associate&lt;/a&gt;这个认证，学习完后可以参加AZ-204考试。每次考试115USD，还是挺有压力的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223855243-1558302179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;考试通过后会在&lt;a href=&quot;https://certification.microsoft.com/badge&quot;&gt;badge&lt;/a&gt;页面看到自己通过的考试，有个酷酷的徽章。（大概吧，我还没考过新的认证考试。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202005/38937-20200512223936863-344531477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-总结&quot;&gt;6. 总结&lt;/h2&gt;
&lt;p&gt;在使用了几十个小时后，我对Microsoft Learn这个学习平台十分满意，毕竟对学习Azure来说真的太方便了。还有其它各式各样的课程，包括AI、.NET Core、Python等，有兴趣的话可以尝试，正如首页上说的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;按照自己的速度和安排掌握核心概念。 无论你有 15 分钟还是 1 小时的时间，都可通过交互式模块和路径拓展实践技能。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 12 May 2020 15:14:00 +0000</pubDate>
<dc:creator>dino.c</dc:creator>
<og:description>1. 什么是Microsoft Learn &amp;quot;Microsoft Learn&amp;quot; 是微软这两年大力推广的全新学习平台，可提供 Microsoft 产品交互式学习体验。基本上无需登录即</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dino623/p/get_started_using_Microsoft_Learn.html</dc:identifier>
</item>
</channel>
</rss>