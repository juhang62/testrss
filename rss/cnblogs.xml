<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>容器信号使用 - sealyun</title>
<link>http://www.cnblogs.com/sealyun/p/11286477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sealyun/p/11286477.html</guid>
<description>&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://sealyun.com&quot;&gt;kubernetes各版本离线安装包&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;容器信号使用&quot;&gt;容器信号使用&lt;/h2&gt;
&lt;p&gt;我们跑在容器中的程序通常想在容器退出之前做一些清理操作，比较常用的方式是监听一个信号，延迟关闭容器。&lt;/p&gt;
&lt;p&gt;docker提供了这样的功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;╰─➤  docker stop --help

Usage:  docker stop [OPTIONS] CONTAINER [CONTAINER...]

Stop one or more running containers

Options:
      --help       Print usage
  -t, --time int   Seconds to wait for stop before killing it (default 10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker 1.13以上版本在创建容器时可直接指定STOP_TIMEOUT 和STOP_SIGNAL参数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run --help
...
--stop-signal string                    Signal to stop a container, SIGTERM by default (default &quot;SIGTERM&quot;)
--stop-timeout int                      Timeout (in seconds) to stop a container
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是。。。&lt;/p&gt;
&lt;p&gt;我们测试一个：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
    &quot;time&quot;
)

func main() {
    fmt.Println(&quot;signal test&quot;)
    go func() {
        for {
            c := make(chan os.Signal, 1)
            signal.Notify(c, syscall.SIGTERM)
            s := &amp;lt;-c
            fmt.Println(&quot;Got signal:&quot;, s)
        }
    }()
    time.Sleep(time.Second * 100)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dockerfile:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM dev.reg.iflytek.com/base/golang:1.8.0
COPY main.go .
RUN go build -o signal &amp;amp;&amp;amp; cp signal $GOPATH/bin
CMD signal  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker build -t dev.reg.iflytek.com/test/signal:latest .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run --name signal dev.reg.iflytek.com/test/signal:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再开一终端，运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker stop -t 10 signal&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现并没有打印出Got signal:... 监听信号失败。&lt;/p&gt;
&lt;p&gt;问题再于：我们docker inspect signal看一下&lt;br/&gt;可以看到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path:/bin/sh
Args:[
  -c,
  signal
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者docker exec signal ps 看一下可以看到pid为1的进程并不是signal, 而是shell.&lt;/p&gt;
&lt;p&gt;所以原因找到了，是因为docker engine只给pid为1的进程发送信号，sh收到了信号而我们想要的signal进程没有收到信号&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM dev.reg.iflytek.com/base/golang:1.8.0
COPY main.go .
RUN go build -o signal &amp;amp;&amp;amp; cp signal $GOPATH/bin
CMD [&quot;signal&quot;]  # 不能写成 CMD signal, 这会直接exec，否则会以shell的方式派生子进程。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扫码关注sealyun&lt;br/&gt;&lt;img src=&quot;https://sealyun.com/img/qrcode1.jpg&quot;/&gt;&lt;br/&gt;探讨可加QQ群：98488045&lt;/p&gt;
</description>
<pubDate>Fri, 02 Aug 2019 00:34:00 +0000</pubDate>
<dc:creator>sealyun</dc:creator>
<og:description>'kubernetes各版本离线安装包' 容器信号使用 我们跑在容器中的程序通常想在容器退出之前做一些清理操作，比较常用的方式是监听一个信号，延迟关闭容器。 docker提供了这样的功能： &lt;! mo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sealyun/p/11286477.html</dc:identifier>
</item>
<item>
<title>在Docker中部署Spring Boot项目 - 代码无止境</title>
<link>http://www.cnblogs.com/endless-code/p/11285839.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endless-code/p/11285839.html</guid>
<description>&lt;blockquote readability=&quot;3.943661971831&quot;&gt;
&lt;p&gt;想要获取更多文章可以访问我的博客 - &lt;a href=&quot;https://itweknow.cn&quot;&gt;代码无止境&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微服务现在在互联网公司可谓非常流行了，之前找工作的的时候很多HR电话约面试的时候都会问对微服务是否有过接触。而微服务和Docker可以非常完美的结合，更加方便的实现微服务架构的落地。作为微服务中的代表SpringBoot框架，今天我们就来了解一下如何在Docker容器中运行一个SpringBoot应用。&lt;/p&gt;
&lt;h3 id=&quot;创建spring-boot程序&quot;&gt;创建Spring Boot程序&lt;/h3&gt;
&lt;p&gt;在这篇文章中我们将在Docker容器中运行一个简单的SpringBoot的Web应用，下面是初始时刻的&lt;code&gt;pom.xml&lt;/code&gt;中的内容。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;cn.itweknow&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springboot-docker&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;springboot-docker&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.0.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加一个&lt;code&gt;HelloController.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class HelloController {

    @RequestMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;Hello Docker.&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，到现在为止我们一个简单的web应用就已经建好了，可以在本地运行起来并看下效果，确保程序正确。&lt;/p&gt;
&lt;h3 id=&quot;配置docker&quot;&gt;配置Docker&lt;/h3&gt;
&lt;p&gt;docker提供了maven构建的插件&lt;code&gt;docker-maven-plugin&lt;/code&gt;,我们只需要在我们的&lt;code&gt;pom.xml&lt;/code&gt;中添加这个插件，然后做相关的一些简单的配置就OK了。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;com.spotify&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;docker-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.0&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;!-- 这里是最终生成的docker镜像名称 --&amp;gt;
        &amp;lt;imageName&amp;gt;itweknow/${project.artifactId}&amp;lt;/imageName&amp;gt;
        &amp;lt;!-- 基础镜像，运行一个springboot应用只需要基础的java环境就行 --&amp;gt;
        &amp;lt;baseImage&amp;gt;java:8&amp;lt;/baseImage&amp;gt;
        &amp;lt;!-- docker启动的时候执行的命令 --&amp;gt;
        &amp;lt;entryPoint&amp;gt;[&quot;java&quot;, &quot;-jar&quot;, &quot;/${project.build.finalName}.jar&quot;]&amp;lt;/entryPoint&amp;gt;
        &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;targetPath&amp;gt;/&amp;lt;/targetPath&amp;gt;
            &amp;lt;directory&amp;gt;${project.build.directory}&amp;lt;/directory&amp;gt;
            &amp;lt;include&amp;gt;${project.build.finalName}.jar&amp;lt;/include&amp;gt;
            &amp;lt;/resource&amp;gt;
        &amp;lt;/resources&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错就这么简单，到目前我们整个项目已经搭建好了，剩下的工作就是讲项目copy到我们linux环境下生成docker镜像然后运行起来了。&lt;/p&gt;
&lt;h3 id=&quot;构建镜像&quot;&gt;构建镜像&lt;/h3&gt;
&lt;p&gt;copy项目到linux下后，进入到项目目录下，顺序执行下面的命令，就可以生成一个docker镜像了。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn clean
# -Dmaven.test.skip=true 是跳过测试代码
mvn package -Dmaven.test.skip=true
mvn docker:build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然你也可以三条命令一起执行&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn clean package docker:build -Dmaven.test.skip=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在执行&lt;code&gt;docker images&lt;/code&gt;查看系统中的docker镜像，看是否生成成功。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;REPOSITORY                                           TAG                 IMAGE ID            CREATED             SIZE
itweknow/springboot-docker                           latest              f03b689cfc33        10 seconds ago      660MB&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行docker容器&quot;&gt;运行Docker容器&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# -d 是指定后台运行
# --name是指定容器名称
# -p 8080:8080 是指将容器的8080端口映射给宿主机的8080端口 格式为：主机(宿主)端口:容器端口
docker run -d --name test -p 8080:8080 itweknow/springboot-docker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;docker ps&lt;/code&gt;查看一下正在运行的容器&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS              PORTS                    NAMES
652fd3ccac89        itweknow/springboot-docker   &quot;java -jar /springbo…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8080-&amp;gt;8080/tcp   test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的项目已经成功运行在了docker容器中了，我们可以访问一下&lt;code&gt;http://虚拟机IP:8080/hello&lt;/code&gt;测试一下了。&lt;/p&gt;
&lt;h3 id=&quot;总结语&quot;&gt;总结语&lt;/h3&gt;
&lt;p&gt;本文只是简单的介绍了一下如何利用Docker部署我们的Spring Boot项目，有关Docker的内容，后面的文章我们会慢慢和大家一起了解。本文的&lt;a href=&quot;https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-docker&quot;&gt;完整实现&lt;/a&gt;你可以在Github上找到。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS:学习不止，码不停蹄！如果您喜欢我的文章，就关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://g-blog.oss-cn-beijing.aliyuncs.com/image/qrcode_for_gh_526c6f450b21_258.jpg&quot; alt=&quot;扫码关注“代码无止境”&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 02 Aug 2019 00:15:00 +0000</pubDate>
<dc:creator>代码无止境</dc:creator>
<og:description>想要获取更多文章可以访问我的博客 '代码无止境' 。 微服务现在在互联网公司可谓非常流行了，之前找工作的的时候很多HR电话约面试的时候都会问对微服务是否有过接触。而微服务和Docker可以非常完美的结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/endless-code/p/11285839.html</dc:identifier>
</item>
<item>
<title>.net持续集成测试篇之Nunit常见断言 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11286438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11286438.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;nunit测试基础之简单断言&quot;&gt;Nunit测试基础之简单断言&lt;/h2&gt;
&lt;p&gt;在开始本篇之前需要补充一些内容,通过前面搭建Nunit测试环境我们知道要使一个方法成为单元测试方法首先要在此方法所在类加上TestFixture注解,并且在该方法上添加上Test注解.&lt;br/&gt;然而还有一点需要注意:所有进行单元测试的方法必须标识为public访问级别,否则无法识别为单元测试方法&lt;/p&gt;
&lt;p&gt;此外,单元测试方法还有以下特征&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li&gt;单元测试方法不带返回参数,也即都是Void类型&lt;br/&gt;由于单元测试方法都是用来断言特定状态的,因此返回值是没有意义的.此外也不要尝试在一个单元测试方法中调用另一个,这样做违反的单元测试的初衷(一旦出现错误不知道是哪个方法出出现的,还需要借助单元调用去发现是哪个方法出现的)&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;单元测试方法不能带有参数&lt;br/&gt;这里说的不能是指不能像普通方法一样带有普通的参数(可以带基于注解的特殊参数)&lt;br/&gt;如果像普通方法一样带参数,虽然编译能通过,但是运行时会抛出异常.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;单元测试方法不能重载&lt;br/&gt;这里说的不能是不应该,实践中是可以的,但是重载方法会带来无尽的麻烦,读者可以自己实践一下.&lt;br/&gt;进行单元测试无非就是对不同参数引起方法出现不同结果的断言(一般情况下所有的单元测试方法都有断言)下面我们来看Nunit中最基本最常用的断言&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基本断言&quot;&gt;基本断言&lt;/h2&gt;
&lt;h3 id=&quot;assert.true&quot;&gt;Assert.True()&lt;/h3&gt;
&lt;p&gt;Assert.True用于断言布尔参数是否为true&lt;br/&gt;Assert.True的重载方法还支持可空布尔参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190802080000022-171110221.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Assert.True还支持自定义错误提示&lt;br/&gt;上面代码改为如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190802075952699-165461378.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果返回错误的时候,我们自定义的错误信息就会显示出来.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其它的断言方法也大都有此重载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.istrue&quot;&gt;Assert.IsTrue&lt;/h3&gt;
&lt;p&gt;此断言方法为Assert.True的亲兄弟,二者功能一模一样.&lt;/p&gt;
&lt;h3 id=&quot;ssert.false&quot;&gt;ssert.False&lt;/h3&gt;
&lt;p&gt;与Assert.True断言状态相反,断言某一参数的结果为false&lt;br/&gt;这里需要特别说明的是,单元测试应该力求简单,明了,断言尤其如此.&lt;br/&gt;上面的断言还也可以写成&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;Assert.False(!firstCondition);&lt;br/&gt;这和断言变量firstCondition为true最终功能一样,但是看上去很不直接明了,通常情况下我见到Assert.False第一反应就是断言一个变量为False,这里则反其道行之,实际上是断言一个变量为true,这种情况应当避免.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.isfalse&quot;&gt;Assert.IsFalse&lt;/h3&gt;
&lt;p&gt;Assert.False的亲兄弟,二者表现一模一样&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Nunit Assert类还有还多其它的前面带有Is的方法,它们都和不带Is的一模一样,其中带Is的是为了兼容老版本写法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.null&quot;&gt;Assert.Null&lt;/h3&gt;
&lt;p&gt;用于断言一个变量是否为null,这里不再举例,但是实际中用的却比较多.&lt;/p&gt;
&lt;h3 id=&quot;assert.notnull&quot;&gt;Assert.NotNull&lt;/h3&gt;
&lt;p&gt;用于断言一个变量不是null,它和Assert.Null()功能相同,只是断言的状态相反.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Nunit里还有其它的前缀有Not的方法,它和不带Not的方法用法一样,只是断言的状态相反&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Assert.Throws&lt;br/&gt;用于断言特定方法在运行的时候会抛出异常.此方法有泛型版本,异步版本,这里仅对异步版本进行说明&lt;br/&gt;由于示例越来越复制,我们不能只在测试方法内写一些简单代码进行测试了,这里我们新建一个Person类如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190802075944046-75744432.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个类里面包含一个WhetherNameContainsB方法,用于判断实例的Name是否包含字母B,&lt;br/&gt;这个方法里面有三个逻辑分支,单元测试的时候每一个都要覆盖到,这里我们断言如果name为null则抛出ArgumentNullException&lt;br/&gt;我们编写如下单元测试方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190802075934967-608910521.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行这个测试,则会返回成功状态,因为预期的异常出现了.&lt;/p&gt;
&lt;h3 id=&quot;assert.isempty&quot;&gt;Assert.IsEmpty&lt;/h3&gt;
&lt;p&gt;用于断言字段串是否为空字符串.&lt;/p&gt;
&lt;h3 id=&quot;assert.positive&quot;&gt;Assert.Positive&lt;/h3&gt;
&lt;p&gt;用于断言数字类型(int,long,float,double,decimal等)为正数(大于零的数)&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;其实很多断言都可以断言都可以用Assert.True来完成,比如断言一个数是否为正数,可以用Assert.True(a&amp;gt;0),这里由于a只是一个普通变量,使用a&amp;gt;0作为条件主义仍然十分清析,然而到了后面有我们不仅要判断一个变通变量,还要判断lambda表达式,如果条件过于复杂,则语义会变得不是特别清析了,使用Assert自带的静态方法主义会更加清析,可读性更高.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.negative&quot;&gt;Assert.Negative&lt;/h3&gt;
&lt;p&gt;用于断言数字类型为负数(小于零,不包括零)&lt;/p&gt;
&lt;h3 id=&quot;assert.zero&quot;&gt;Assert.Zero&lt;/h3&gt;
&lt;p&gt;用于断言数字类型为数字零&lt;/p&gt;
&lt;h3 id=&quot;assert.notzero&quot;&gt;Assert.NotZero&lt;/h3&gt;
&lt;p&gt;用于断言数字类型不是零.&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;很多时候,Not包含的范围非常广,进行单元测试是为了在开发阶段找出问题,解决问题,因此断言的范围越窄越好,我们不能仅仅让单元测试通过了事.&lt;br/&gt;比如一个方法返回的结果是数字类型,我们要断定它是正数?大于某一个数的正数?在一定范围的正数?是一个具体的正数?而不能简单的是零,不是零.当然这还要根据业务本身来确实,有些时候范围可能确实很大,但是一定要注意单元测试原则.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;assert.greaterorequal&quot;&gt;Assert.Greater(OrEqual)&lt;/h3&gt;
&lt;p&gt;用于断言数字类型的变量大于(或者等于)某一个值&lt;/p&gt;
&lt;h3 id=&quot;assert.lessorequal&quot;&gt;Assert.Less(OrEqual)&lt;/h3&gt;
&lt;p&gt;用于断言数字类型小于(或者等于)某一值&lt;/p&gt;
&lt;h3 id=&quot;assert.contains&quot;&gt;Assert.Contains&lt;/h3&gt;
&lt;p&gt;用于断言集合中是否包含某一元素.&lt;br/&gt;比如以下方法,用于断言字符串数组中是否包含特定字符串&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190802075927427-1369200248.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;assert.aresame&quot;&gt;Assert.AreSame&lt;/h3&gt;
&lt;p&gt;用于断言两个对象是否相等&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;这个静态方法并没有提供重载参数用于指定一个比较器来比较引用对象的相等性,需要实现equals和gethashcode方法才能得到预期结果,但在实际中我们往往把比较器放在类外边,如何在比较引用对象的时候加载一个比较器在后面章节会有介绍,这里先略过.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;nunit测试基础之复杂断言-1&quot;&gt;Nunit测试基础之复杂断言&lt;/h2&gt;
&lt;p&gt;上面一篇我们讲解了一些基本断言,利用这些断言我们就可以进行单元测试了,然而仅仅使用简单断言还是不够的,如果逻辑复杂度较高,使用简单的断言会导致单元测试代码量增加,最终导致单元测试本身过于复杂和难以维护.需要说明的是这里所说的复杂断言仍然在Assert的静态方法里面,本身也不是特别复杂,只是比前面讲的秒复杂一些,只是如果没有了这些方法,一些特殊功能实现起来比较费劲基本无法实现.&lt;/p&gt;
&lt;p&gt;下面就介绍一下这些方法.&lt;/p&gt;
&lt;h2 id=&quot;assert.catch&quot;&gt;Assert.Catch&lt;/h2&gt;
&lt;p&gt;Assert.Catch有泛型和异步方法,这里只介绍其泛型方法.很多即使经常使用单元测试功能的人也未必用过这个方法.&lt;br/&gt;其实这个方法和Assert.Throw用法上类似,只是有一点不同的是要测试的方法里的异常可以是catch到的异常的子类,实际开发中,如果我们能确立异常的类型,则最好捕获具体类型异常,然而不能排除有一些不够规范的代码整段代码被一个try catch包围,这时候不一定能够捕获到想要的特定异常,这时候可以使用Assert.Catch&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190802080050397-1267300618.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上代码类似上一节中讲throw时使用的代码,只是这里泛型参数里是Exception而不是具体的异常信息,我们运行这段代码,依然能够测试通过.&lt;br/&gt;在单元测试中,期待的状态越具体越好,然而由于种种原因(比如立项时候没有对代码规范做过多要求,开发者水平不高,要测试的代码是别人写的,写单元测试的人对其中逻辑并不是特别清楚等)我们无法做到非常具体,这个时候可以把要获得的状态放宽以后,待条件完备了再修改单元测试以进一步收窄状态.&lt;/p&gt;
&lt;h2 id=&quot;assert.ignore&quot;&gt;Assert.Ignore&lt;/h2&gt;
&lt;p&gt;Assert.Ignore和Ignore注解功能类似,可以在测试的时候忽略一个单元测试.有些情况下我们需要暂时忽略一个测试,比如说要进行测试的内容有一个外部依赖,现在外部依赖暂时不可用,如果我们不忽略的话测试将会失败,在自动化环境下,失败将导致无法进行下一步动作,此时我们可以暂时忽略这个测试.&lt;br/&gt;忽略的测试前面有一个 黄色叹号标志,警示我们需要注意.&lt;/p&gt;
&lt;h2 id=&quot;assert.-fail&quot;&gt;Assert. Fail&lt;/h2&gt;
&lt;p&gt;我们先看一下面一段代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190802080042022-2042680923.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个单元测试本身使用到了try catch,我们知道WhetherNameContainsB方法在Person类的Name没有提供值的情况下会抛出异常,然而我们的代码并没有断言这个异常存在,此时由于catch代码块存在,会把异常吞掉,因此最终我们断言person的Age为正数的时候将会通过(我们在构造类的时候设置了Age为32)&lt;br/&gt;这显然不行的,这时候我把们Assert.Fail(e.Message)取消注释,测试便会变成失败状态.&lt;/p&gt;
&lt;h2 id=&quot;assert.isnan&quot;&gt;Assert.IsNaN&lt;/h2&gt;
&lt;p&gt;用于断言一个Double类型数字是否是NaN&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190802080034808-1670126693.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然实际业务中我们并不会写以上代码,但是如果除数和被除数是通过复杂计算得来的则有可能除数和被除数都是零.&lt;/p&gt;
&lt;h2 id=&quot;assert.isinstanceof&quot;&gt;Assert.IsInstanceOf&lt;/h2&gt;
&lt;p&gt;用于断言一个对象是否是指定类型的实例,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190802080027672-1234528885.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上psn是Person类的一个实例,而Person继承自Object,因此psn也是Object类的实例&lt;/p&gt;
&lt;h2 id=&quot;assert.isassignablefrom&quot;&gt;Assert.IsAssignableFrom&lt;/h2&gt;
&lt;p&gt;此方法和以上方法作用相反,它用来断言指定类型是当前对象类型的子类.(Assert.IsInstanceOf判断的是当前对象是指定类型的子类)&lt;br/&gt;这个方法语义不是很明确,很容易搞晕,使用的时候需要特别注意&lt;/p&gt;
&lt;h2 id=&quot;assert.warn&quot;&gt;Assert.Warn&lt;/h2&gt;
&lt;p&gt;用于使一个测试通过,但是出现警示信息.&lt;/p&gt;
</description>
<pubDate>Fri, 02 Aug 2019 00:07:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' Nunit测试基础之简单断言 在开始本篇之前需要补充一些内容,通过前面搭建Nunit测试环境我们知道要使一个方法成为单元测试方法首先要在此方法所在类加上TestFixture注解,并且在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11286438.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Web Api之JWT刷新Token(三) - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/11273732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/11273732.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;如题，本节我们进入JWT最后一节内容，JWT本质上就是从身份认证服务器获取访问令牌，继而对于用户后续可访问受保护资源，但是关键问题是：访问令牌的生命周期到底设置成多久呢？见过一些使用JWT的童鞋会将JWT过期时间设置成很长，有的几个小时，有的一天，有的甚至一个月，这么做当然存在问题，如果被恶意获得访问令牌，那么可在整个生命周期中使用访问令牌，也就是说存在冒充用户身份，此时身份认证服务器当然也就是始终信任该冒牌访问令牌，若要使得冒牌访问令牌无效，唯一的方案则是修改密钥，但是如果我们这么做了，则将使得已授予的访问令牌都将无效，所以更改密钥不是最佳方案，我们应该从源头尽量控制这个问题，而不是等到问题呈现再来想解决之道，刷新令牌闪亮登场。&lt;/p&gt;

&lt;h2&gt;RefreshToken&lt;/h2&gt;
&lt;p&gt;什么是刷新令牌呢？刷新访问令牌是用来从身份认证服务器交换获得新的访问令牌，有了刷新令牌可以在访问令牌过期后通过刷新令牌重新获取新的访问令牌而无需客户端通过凭据重新登录，如此一来，既保证了用户访问令牌过期后的良好体验，也保证了更高的系统安全性，同时，若通过刷新令牌获取新的访问令牌验证其无效可将受访者纳入黑名单限制其访问，那么访问令牌和刷新令牌的生命周期设置成多久合适呢？这取决于系统要求的安全性，一般来讲访问令牌的生命周期不会太长，比如5分钟，又比如获取微信的AccessToken的过期时间为2个小时。接下来我将用两张表来演示实现刷新令牌的整个过程，可能有更好的方案，欢迎在评论中提出，学习，学习。我们新建一个http://localhost:5000的WebApi用于身份认证，再新建一个http://localhost:5001的客户端，首先点击【模拟登录获取Toen】获取访问令牌和刷新令牌，然后点击【调用客户端获取当前时间】，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190801215825701-1265169389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们新建一张用户表（User）和用户刷新令牌表（UserRefreshToken），结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt; _userRefreshTokens = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;UserRefreshToken&amp;gt; UserRefreshTokens =&amp;gt;&lt;span&gt; _userRefreshTokens;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证刷新token是否存在或过期
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;refreshToken&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsValidRefreshToken(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; refreshToken)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _userRefreshTokens.Any(d =&amp;gt; d.Token.Equals(refreshToken) &amp;amp;&amp;amp;&lt;span&gt; d.Active);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建刷新Token
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;token&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;userId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;minutes&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CreateRefreshToken(&lt;span&gt;string&lt;/span&gt; token, &lt;span&gt;string&lt;/span&gt; userId, &lt;span&gt;double&lt;/span&gt; minutes = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            _userRefreshTokens.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; UserRefreshToken() { Token = token, UserId = userId, Expires =&lt;span&gt; DateTime.Now.AddMinutes(minutes) });
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 移除刷新token
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;refreshToken&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RemoveRefreshToken(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; refreshToken)
        {
            _userRefreshTokens.Remove(_userRefreshTokens.FirstOrDefault(t &lt;/span&gt;=&amp;gt; t.Token ==&lt;span&gt; refreshToken));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserRefreshToken
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;; } =&lt;span&gt; Guid.NewGuid().ToString();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Token { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime Expires { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Active =&amp;gt; DateTime.Now &amp;lt;=&lt;span&gt; Expires;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上可以看到对于刷新令牌的操作我们将其放在用户实体中，也就是使用EF Core中的Back Fields而不对外暴露。接下来我们将生成的访问令牌、刷新令牌、验证访问令牌、获取用户身份封装成对应方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成访问令牌
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;claims&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GenerateAccessToken(Claim[] claims)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(signingKey));

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityToken(
                issuer: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                audience: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                claims: claims,
                notBefore: DateTime.Now,
                expires: DateTime.Now.AddMinutes(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
                signingCredentials: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256)
            );

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler().WriteToken(token);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成刷新Token
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GenerateRefreshToken()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; randomNumber = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;32&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; rng =&lt;span&gt; RandomNumberGenerator.Create())
            {
                rng.GetBytes(randomNumber);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToBase64String(randomNumber);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从Token中获取用户身份
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;token&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ClaimsPrincipal GetPrincipalFromAccessToken(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; token)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler();

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; handler.ValidateToken(token, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
                {
                    ValidateAudience &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    ValidateIssuer &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    ValidateIssuerSigningKey &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    IssuerSigningKey &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(signingKey)),
                    ValidateLifetime &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                }, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; SecurityToken validatedToken);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当用户点击登录，访问身份认证服务器，登录成功后我们创建访问令牌和刷新令牌并返回，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
        [HttpPost(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Login()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()
            {
                Id &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D21D099B-B49B-4604-A247-71B0518A0B1C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };

            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.Users.AddAsync(user);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; refreshToken =&lt;span&gt; GenerateRefreshToken();

            user.CreateRefreshToken(refreshToken, user.Id);

            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.SaveChangesAsync();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(ClaimTypes.Name, user.UserName),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(JwtRegisteredClaimNames.Email, user.Email),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(JwtRegisteredClaimNames.Sub, user.Id),
            };

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt; Response() { AccessToken = GenerateAccessToken(claims), RefreshToken =&lt;span&gt; refreshToken });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们回到如上给出的图，我们点击【模拟登录获取Token】，此时发出Ajax请求，然后将返回的访问令牌和刷新令牌存储到本地localStorage中，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;模拟登录获取Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-currentTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用客户端获取当前时间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟登陆&lt;/span&gt;
        $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#btn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(function () {
            GetTokenAndRefreshToken();
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Token&lt;/span&gt;
&lt;span&gt;        function GetTokenAndRefreshToken() {    
         $.post(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:5000/api/account/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).done(function (data) {
                saveAccessToken(data.accessToken);
                saveRefreshToken(data.refreshToken);
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从localStorage获取AccessToken&lt;/span&gt;
&lt;span&gt;        function getAccessToken() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; localStorage.getItem(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accessToken&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从localStorage获取RefreshToken&lt;/span&gt;
&lt;span&gt;        function getRefreshToken() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; localStorage.getItem(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;refreshToken&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存AccessToken到localStorage&lt;/span&gt;
&lt;span&gt;        function saveAccessToken(token) {
            localStorage.setItem(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accessToken&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, token);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存RefreshToken到localStorage&lt;/span&gt;
&lt;span&gt;        function saveRefreshToken(refreshToken) {
            localStorage.setItem(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;refreshToken&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, refreshToken);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们再来点击【调用客户端获取当前时间】，同时将登录返回的访问令牌设置到请求头中，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
       $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#btn-currentTime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(function () {
            GetCurrentTime();
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用客户端获取当前时间&lt;/span&gt;
&lt;span&gt;        function GetCurrentTime() {
            $.ajax({
                type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                contentType: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:5001/api/home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                beforeSend: function (xhr) {
                    &lt;span&gt;xhr.setRequestHeader(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;'Authorization', 'Bearer ' +&lt;/span&gt;&lt;span&gt;&lt;span&gt; getAccessToken())&lt;/span&gt;;
                },
                success: function (data) {
                    alert(data);
                },
                error: function (xhr) {
                   
                }
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端请求接口很简单，为了让大家一步步看明白，我也给出来，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Authorize]
        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetCurrentTime()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了到了这里我们已经实现模拟登录获取访问令牌，并能够调用客户端接口获取到当前时间，同时我们也只是返回了刷新令牌并存储到了本地localStorage中，并未用到。当访问令牌过期后我们需要通过访问令牌和刷新令牌去获取新的访问令牌，对吧。那么问题来了。我们怎么知道访问令牌已经过期了呢？这是其一，其二是为何要发送旧的访问令牌去获取新的访问令牌呢？直接通过刷新令牌去换取不行吗？有问题是好的，就怕没有任何思考，我们一一来解答。我们在客户端添加JWT中间件时，里面有一个事件可以捕捉到访问令牌已过期（关于客户端配置JWT中间件第一节已讲过，这里不再啰嗦），如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                  options.Events = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtBearerEvents
                  {
                      OnAuthenticationFailed &lt;/span&gt;= context =&amp;gt;&lt;span&gt;
                      {
                          &lt;/span&gt;&lt;span&gt;if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))
                          {
                              context.Response.Headers.Add(&quot;act&quot;, &quot;expired&quot;);
                          }
                          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
                      }
                  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过如上事件并捕捉访问令牌过期异常，这里我们在响应头添加了一个自定义键act，值为expired，因为一个401只能反映未授权，并不能代表访问令牌已过期。当我们在第一张图中点击【调用客户端获取当前时间】发出Ajax请求时，如果访问令牌过期，此时在Ajax请求中的error方法中捕捉到，我们在如上已给出发出Ajax请求的error方法中继续进行如下补充：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;                error: function (xhr) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xhr.status === &lt;span&gt;401&lt;/span&gt; &amp;amp;&amp;amp; xhr.getResponseHeader(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;act&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;expired&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问令牌肯定已过期&lt;/span&gt;
&lt;span&gt;                    }
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到了这里我们已经解决如何捕捉到访问令牌已过期的问题，接下来我们需要做的则是获取刷新令牌，直接通过刷新令牌换取新的访问令牌也并非不可，只不过还是为了安全性考虑，我们加上旧的访问令牌。接下来我们发出Ajax请求获取刷新令牌，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取刷新Token&lt;/span&gt;
&lt;span&gt;        function GetRefreshToken(func) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; model =&lt;span&gt; {
                accessToken: getAccessToken(),
                refreshToken: getRefreshToken()
            };
            $.ajax({
                type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                contentType: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:5000/api/account/refresh-token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                dataType: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: JSON.stringify(model),
                success: function (data) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!data.accessToken &amp;amp;&amp;amp; !&lt;span&gt;data.refreshToken) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转至登录&lt;/span&gt;
                    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        saveAccessToken(data.accessToken);
                        saveRefreshToken(data.refreshToken);
                        func();
                    }
                }
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发出Ajax请求获取刷新令牌的方法我们传入了一个函数，这个函数则是上一次调用接口访问令牌过期的请求，点击【调用客户端获取当前时间】按钮的Ajax请求error方法中，最终演变成如下这般：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;              error: function (xhr) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xhr.status === &lt;span&gt;401&lt;/span&gt; &amp;amp;&amp;amp; xhr.getResponseHeader(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;act&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;expired&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {

                        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 访问令牌肯定已过期，将当前请求传入获取刷新令牌方法，
                         * 以便获取刷新令牌换取新的令牌后继续当前请求
                        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                        GetRefreshToken(GetCurrentTime);
                    }
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来则是通过传入旧的访问令牌和刷新令牌调用接口换取新的访问令牌，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 刷新Token
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        [HttpPost(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refresh-token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; RefreshToken([FromBody] Request request)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO 参数校验&lt;/span&gt;

            &lt;span&gt;var&lt;/span&gt; principal =&lt;span&gt; GetPrincipalFromAccessToken(request.AccessToken);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (principal &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id = principal.Claims.First(c =&amp;gt; c.Type == JwtRegisteredClaimNames.Sub)?&lt;span&gt;.Value;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(id))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;await&lt;/span&gt; context.Users.Include(d =&amp;gt;&lt;span&gt; d.UserRefreshTokens)
                .FirstOrDefaultAsync(d &lt;/span&gt;=&amp;gt; d.Id ==&lt;span&gt; id);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; || user.UserRefreshTokens?.Count() &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;user.IsValidRefreshToken(request.RefreshToken))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }

            user.RemoveRefreshToken(request.RefreshToken);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; refreshToken =&lt;span&gt; GenerateRefreshToken();

            user.CreateRefreshToken(refreshToken, id);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.SaveChangesAsync();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(ClaimTypes.Name, user.UserName),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(JwtRegisteredClaimNames.Email, user.Email),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(JwtRegisteredClaimNames.Sub, user.Id),
            };

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Response()
            {
                AccessToken &lt;/span&gt;=&lt;span&gt; GenerateAccessToken(claims),
                RefreshToken &lt;/span&gt;=&lt;span&gt; refreshToken
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上通过传入旧的访问令牌验证并获取用户身份，然后验证刷新令牌是否已经过期，如果未过期则创建新的访问令牌，同时更新刷新令牌。最终客户端访问令牌过期的那一刻，通过刷新令牌获取新的访问令牌继续调用上一请求，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190801230024564-1027413648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里关于JWT实现刷新Token就已结束，自我感觉此种实现刷新令牌将其存储到数据库的方案还算可取，将刷新令牌存储到Redis也可行，看个人选择吧。上述若刷新令牌验证无效，可将访问者添加至黑名单，不过是添加一个属性罢了。别着急，本节内容结束前，还留有彩蛋。&lt;/p&gt;
&lt;h2&gt;EntityFramework Core Back Fields深入探讨&lt;/h2&gt;
&lt;p&gt;无论是看视频还是看技术博客也好，一定要动手验证，看到这里觉得上述我所演示是不是毫无问题，如果阅读本文的你直接拷贝上述代码你会发现有问题，且听我娓娓道来，让我们来复习下Back Fields。Back Fields命名是有约定dei，上述我是根据约定而命名，所以千万别一意孤行，别乱来，比如如下命名将抛出如下异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt; _refreshTokens = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt;&lt;span&gt;();

 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;UserRefreshToken&amp;gt; UserRefreshTokens =&amp;gt; _refreshTokens;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190802001646386-1170834742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述我们配置刷新令牌的Back Fields，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt; _userRefreshTokens = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt;&lt;span&gt;();
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;UserRefreshToken&amp;gt; UserRefreshTokens =&amp;gt; _userRefreshTokens;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190802002120402-1137888617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要是我们配置成如下形式，结果又会怎样呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt; _userRefreshTokens = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt;&lt;span&gt;();
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;UserRefreshToken&amp;gt; UserRefreshTokens =&amp;gt; _userRefreshTokens.AsReadOnly();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190802002303208-179103071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时为了解决这个问题，我们必须将其显式配置成Back Fields，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity&lt;/span&gt;&amp;lt;User&amp;gt;(u =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; navigation =&lt;span&gt; u.Metadata.FindNavigation(nameof(User.UserRefreshTokens));
                navigation.SetPropertyAccessMode(PropertyAccessMode.Field);
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我个人著作中也讲解到为了性能问题，可将字段进行ToList()，若进行了ToList()，必须显式配置成Back Fields，否则获取不到刷新令牌导航属性，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt; _userRefreshTokens = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;UserRefreshToken&amp;gt; UserRefreshTokens =&amp;gt; _userRefreshTokens.&lt;span&gt;ToList()&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者进行如下配置，我想应该也可取，不会存在性能问题，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt; _userRefreshTokens = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UserRefreshToken&amp;gt;&lt;span&gt;();
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IReadOnlyCollection&amp;lt;UserRefreshToken&amp;gt; UserRefreshTokens =&amp;gt; _userRefreshTokens.AsReadOnly();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是关于Back Fields问题之一，问题之二则是上述我们请求获取刷新令牌中，我们先在刷新令牌的Back Fields中移除掉旧的刷新令牌，而后再创建新的刷新令牌，但是会抛出如下异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190802003349134-1039267209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190802003405517-723820150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到在添加刷新令牌时，用户Id是有值的，对不对，这是为何呢？究其根本问题出在我们移除刷新令牌方法中，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 移除刷新token
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;refreshToken&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RemoveRefreshToken(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; refreshToken)
        {
            _userRefreshTokens.Remove(_userRefreshTokens.FirstOrDefault(t &lt;/span&gt;=&amp;gt; t.Token ==&lt;span&gt; refreshToken));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将查询出来的导航属性并将其映射到_userRefreshTokens字段中，此时是被上下文所追踪，上述我们查询出存在的刷新令牌并在跟踪的刷新令牌中进行移除，没毛病，没找到原因，于是乎，我将上述方法修改成如下看看是否必须需要主键才能删除旧的刷新令牌：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 移除刷新token
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;refreshToken&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RemoveRefreshToken(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; refreshToken)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id = _userRefreshTokens.FirstOrDefault(t =&amp;gt; t.Token ==&lt;span&gt; refreshToken).Id;
            _userRefreshTokens.Remove(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; UserRefreshToken() { Id =&lt;span&gt; id });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;倒没抛出异常，创建了一个新的刷新令牌，但是旧的刷新令牌却没删除，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190802004923053-2092111571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此未找到问题出在哪里，当前版本为2.2，难道不能通过Back Fields移除对象？这个问题待解决。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我们重点讲解了如何实现JWT刷新令牌，并也略带讨论了EF Core中Back Fields以及尚未解决的问题，至此关于JWT已结束，下节开始正式进入Docker小白系列，感谢阅读。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Aug 2019 23:46:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 如题，本节我们进入JWT最后一节内容，JWT本质上就是从身份认证服务器获取访问令牌，继而对于用户后续可访问受保护资源，但是关键问题是：访问令牌的生命周期到底设置成多久呢？见过一些使用JWT的童鞋</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/11273732.html</dc:identifier>
</item>
<item>
<title>css3系列之详解perspective - 杨耿</title>
<link>http://www.cnblogs.com/yanggeng/p/11285856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanggeng/p/11285856.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;perspective&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单来说，就是设置这个属性后，那么，就可以模拟出像我们人看电脑上的显示的元素一样。比如说， perspective：800px   意思就是，我在离屏幕800px 的地方观看这个元素。(这个属性，要设置在父元素上面)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(这个属性呢，有着很冷门的知识请认真看完呢)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801220139575-2128845822.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;先来看看， 加了perspective  和 没有加是什么区别， 第一个小方块，是有加的效果，能明显的看到空间感了有没有， 感觉他是真的像在旋转， 而第二个呢，像是在伸缩。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801221411621-350515949.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本章需要知道translateZ 是干嘛的，如果不懂什么是 translate Z请点击→ &lt;/span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yanggeng/p/11286250.html&quot;&gt;css3系列之transform详解translate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么思考一个问题，transform：translateZ  呢，可以增加  Z轴的距离， 那么Z轴越大，是不是也就代表着，这个元素，离我们的距离越近？  那么，你把一张图片，贴到你脸上，有什么效果？ 是不是非常大？有人可能会问，这两者之间有什么关系吗？  肯定是有的，这个 perspective  配合 transform：translateZ  就有这种效果， 我们来看看。(先记着，我们设置了perspective：800px，那么来看看 Z到800px 有什么效果)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801222956571-567878966.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有没有发现，&lt;span&gt;临近 800px&lt;/span&gt; 的时候， 图片突然变黑了， 然后到&lt;span&gt;800px&lt;/span&gt;的时候， 图片消失了。  这又是为啥呢？   其实很像我们现实中的例子一样，一张远处的图片，慢慢的移动到你脸上， 你会看见图片越来越大，贴到你脸上的时候，是不是 你就看不见了？  到800px 的时候，你人都和图片 融合在一体了， 如果&lt;span&gt;801px&lt;/span&gt; 是不是你都穿过这张图片了？道理是一样的啦。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那么transform：translateZ， 到负数的时候， 是不是值越小，图片离我们越远，同理的 图片也就越小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801224057610-1784556030.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但是！如果你真的认为 perspective 这个属性这么简单的话，那么你就太天真了。按照我们的思路继续，如果 perspective： 这个值，越小，是不是我们就离屏幕越近， 那么 图片也会越大，(translateZ 是移动图片， perspective是移动 人 和屏幕的距离，这么想也是没问题的哈。对吧，那么把translateZ(0px)。然后增加 perspective 试试看。  )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801225520468-1941953896.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，你会惊奇的发现，咦？  好像无论是增加，还是减少，图片都没有任何变化。 这个时候，先卖个关子，接着看下个案例，把 translateZ(-100px) 设置成 负值。(正常，按照我们的想法，是不是 Z的值是正数，说明这个图片，离我们越近，那么反之，负值，离我们越远对吧)  那么这次我们不移动 translateZ 了， 设置好Z 值为-100px 之后，移动perspective的值，把他的值变小，(正常来说，值越小，是不是就代表 我们离屏幕越近， 看的东西也就越大对吧)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801230607960-2031990058.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，你又会惊奇的发现， 怎么图片不是越来越大呢? 我们离屏幕越大，图片应该越大才对啊， 怎么变小了呢？  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实把。这里我们一直误导一个情况，我们看到的，并不是图片本身，而是图片的投影。 是不是有点晕了，投影是什么鬼， 没事，看下面的图解。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第一个情况，translateZ 的值越大，图片越大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801234131287-970705813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二个情况，translateZ 的值越小，图片越小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801234818111-1640872733.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三个情况，translateZ 为0的时候，为什么移动我们perspective 的值，图片的大小没有改变呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801232932435-607269886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第四个情况，为什么translateZ 为负数之后，增加 perspective 的值后，图片不是变大， 反而变小呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801233508948-1693095665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好了，最后补充一点，这个perspective 属性呢，要放在父级身上。然后还有一个属性perspective-origin，这个属性也是设置在父级身上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个属性呢，默认值是 center  center，也就是 居中。这两个参数呢，是根据自身来定位的， 0px 0px 代表着元素的左上角，center center代表着元素的中间点。可以设置像素 50px  也可设置百分比 50%，还可以设置 top right left bottom center 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个属性有什么用呢？ 这个属性是相当于人 的眼睛看哪里。你没有设置，也就是默认看父元素 中间的地方。看下面两张图的例子，就知道什么意思啦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801235429754-139196392.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609428/201908/1609428-20190801235955684-2042643681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;没有了呢，不用再翻了，谢谢你的阅读。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Aug 2019 16:41:00 +0000</pubDate>
<dc:creator>杨耿</dc:creator>
<og:description>perspective 简单来说，就是设置这个属性后，那么，就可以模拟出像我们人看电脑上的显示的元素一样。比如说， perspective：800px 意思就是，我在离屏幕800px 的地方观看这个元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanggeng/p/11285856.html</dc:identifier>
</item>
<item>
<title>JAVA-Spring AOP五大通知类型 - Mr丶L</title>
<link>http://www.cnblogs.com/xiaoluohao/p/11286242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoluohao/p/11286242.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、前置通知&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在目标方法执行之前执行的通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在前置通知方法，可以没有参数，也可以额外接收一个JoinPoint，Spring会自动将该对象传入，代表当前的连接点，通过该对象可以获取目标对象和目标方法相关的信息。&lt;span&gt;注意，如果接收JoinPoint，必须保证其为方法的第一个参数，否则报错！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;span&gt;配置方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190801235438573-754088208.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、环绕通知&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在目标方法执行&lt;strong&gt;&lt;span&gt;之前&lt;/span&gt;&lt;/strong&gt;和&lt;span&gt;&lt;strong&gt;之后&lt;/strong&gt;&lt;/span&gt;都可以执行额外代码的通知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在环绕通知中必须显式的调用目标方法，否则目标方法不会执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这个显式调用时通过ProceedingJoinPoint来实现，可以在环绕通知中接收一个此类型的形参，spring容器会自动将该对象传入，这个参数必须处在环绕通知的第一个形参位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;　**要注意，只有环绕通知可以接收ProceedingJoinPoint，而其他通知只能接收JoinPoint。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　配置方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802000018246-1910815998.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　环绕通知需要返回返回值，否则真正调用之将拿不到返回值，只能得到一个null。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　环绕通知有控制目标方法是否执行、目标方法执行之前或之后执行额外代码、有控制是否返回值、甚至改变返回值的能力&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　环绕通知虽然有这样的能力，但一定要慎用，要小心不要破坏了软件分层的“高内聚   低耦合”的目标。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、后置通知&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在目标方法执行之后的通知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在后置通知中也可以选择性的接收一个JoinPoint来获取连接点的额外信息，但是这个参数必须处在参数列表的第一位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802000445137-1525232588.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802000452118-1222911562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　　　&lt;span&gt;在后置通知中，还可以通过配置获取返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802000525353-447828812.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;一定要保证JoinPoint处在参数列表的第一位，否则抛异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802000630307-573071867.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、异常通知&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;在目标方法抛出异常时执行的通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　配置方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802000736477-1661348575.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;可以配置传入JoinPoint获取目标对象和目标方法相关信息，&lt;span&gt;但必须处在参数列表第一位&lt;/span&gt;，另外，还可以配置参数，让异常通知可以接收到目标方法抛出来的异常对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802001032648-1617493266.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、最终通知&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是在目标方法执行之后执行的通知。和后置通知不同的是，后置通知是在方法正常返回后执行的通知，如果方法没有正常返回，比如说抛出异常，则后置通知不会执行。而最终通知无论如何都会在目标方法调用过后执行，即使目标方法没有正常的执行完成。另外，后置通知可以通过配置得到返回值，而最终通知无法得到。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　配置方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802001422803-1318983713.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;最终通知也可以额外接受一个JoinPoint参数，来获取目标对象和目标方法相关信息，但一定要保证&lt;span&gt;必须是第一个参数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802001526233-313016563.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; -------------------------------------------------------------LK------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt;五种通知执行的顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.在目标方法没有抛出异常的情况下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　前置通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　环绕通知的调用目标方法之前的代码 　　//--取决于配置顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　目标方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　环绕通知的调用目标方法之后的代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　后置通知　　　　　　　　　　　　　　//--取决于配置顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　最终通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.在目标方法抛出异常的情况下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　前置通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　环绕通知的调用目标方法之前的代码　　&lt;/span&gt;&lt;span&gt;//--取决于配置顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　目标方法  　　//抛出异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　异常通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　最终通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.如果存在多个切面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　多切面执行时，采用了责任链设计模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　切面的配置顺序决定了切面的执行过程，类似于方法调用的过程，在环绕通知的proceed()执行时，去执行下一个切面或如果没有下一个切面执行目标方法，从而达成了如下的执行过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802002805804-975533326.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　如果目标方法抛出异常：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802002842082-1032538090.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;五种通知的常见使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236612/201908/1236612-20190802002930491-2042972153.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 01 Aug 2019 16:32:00 +0000</pubDate>
<dc:creator>Mr丶L</dc:creator>
<og:description>一、前置通知 在目标方法执行之前执行的通知 在前置通知方法，可以没有参数，也可以额外接收一个JoinPoint，Spring会自动将该对象传入，代表当前的连接点，通过该对象可以获取目标对象和目标方法相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoluohao/p/11286242.html</dc:identifier>
</item>
<item>
<title>真千兆路由的极限之OPENWRT MAKE, 某品牌白菜价QCA9558/QCA9880/QCA8337N纯种组合OS搭建时记 - A.Z</title>
<link>http://www.cnblogs.com/A-Z/p/ath79_nand_flash_qca9558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/A-Z/p/ath79_nand_flash_qca9558.html</guid>
<description>&lt;p&gt;自从上次仙人梦里放了一张无字天书，解惑了WPR003N的秘诀后，渐渐的，就忘了这件这事情，连想好的评测都拖延了好多月了，毕竟路由是拿来用的，不是用来写什么陈词滥调的评测的，无意间，热爱白菜的我发现了一个沦为几十元的千兆路由器在售，本着鄙视图吧大佬的心态，立刻这个路由就到了手上&lt;/p&gt;
&lt;p&gt;插上试一试吧？NO&amp;gt;&amp;lt;, 一个搞机搞到这样境界的机友会做的第一件事情肯定不是插上电源，而是用迅雷不及掩耳之势把它的外壳脱个精光，露出PCB, 小家碧玉，排列规整，无异味，无外科痕迹，是一个原生态的路由，心里有了谱&lt;/p&gt;
&lt;p&gt;很熟练的捏出16M sdcard,扔进可回收垃圾桶，买椟还珠，四字诀念一遍。没有了天线的束缚，没有了钢板的压重，PCB上的reset就像飞行器上的摇杆，操控自如&lt;/p&gt;
&lt;p&gt;5分钟后，它变了&lt;/p&gt;
&lt;p&gt;是的，只用了5分钟，搞机的境界里没有什么编程器这么LOW的事情，放在眼前的已经是一个主频超到1G,74kc CPU的Qualcomm Atheros Scorpion AP135平台，硕大的CPU摸在上面非常的烫，上面竟然刻着Made in China. 时代在变&lt;/p&gt;
&lt;p&gt;虽然&lt;span data-mce-=&quot;&quot;&gt;Scorpion已经是13年前诞生的淘汰产物，但是放在今天仍旧可以藐视一切伪千兆，断流路由，这是Atheros的自信，即使被Qualcomm买走合体了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;很自然的放弃了原版bootloader，继而让小Han太太这个缺乏i18n精神，却有着独树一帜超频能力，不怎么好看但很实用的WEB GUI的NDA混合体继承了原来的引导位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;然后我很认真地在ATH79下面做了一个只缺乏NAND支持的LINUX 4.19 16M factory.bin, 配合小Han太太提供的GUI，非常的便捷，作为第一次MAKE ATH10K，出乎意料的顺利，请看下图（忽略invalid mac,那并不重要:P）：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/A-Z/117549/o_dw33d.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;请圣地为数不多的能写driver的看官帮忙看看， 我分别在DTS binding和module里都成功加载了ar934x_nfc，在sys log里可以看到自己加的probe info, 两种方式都执行到了requast_irq failed, 对于ath79的底层，实在是第一次没有任何想法，也不想去触碰研读别人当作饭碗的sequence.这点非常有谱，请有经验或者了解这位原作者Gabor Juhos的同学指点一二，不胜感激&lt;/strong&gt;，&lt;/span&gt;我就是那个传说中用Visual Studio 2019看linux 4.19源码的人，大家不许笑&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;有一句话让我顿悟了一下，&lt;span&gt;退一步，海阔天空&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;退而求其次，我在ar71xx里找到了人所众知的profile，小改了一下，现在也能在小Han太太的GUI里输入factory.bin啦，呵呵&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;在4.14下，ar934x_nfc很正常，表现非常的好，GOOD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/A-Z/117549/o_dw33d-nand-ro.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;128M的NAND载入没有问题，分区自然是忘记了原来的，把无用的分区全部抛弃了，建立崭新的开始&lt;/p&gt;
&lt;p&gt;让我最后DISS一下分别维护两个nand profile下的那些提交者，非常的粗糙，比如当前的parallel nand flash,很显然spi-nand framework并不适用，却毫无进展，一些小小的细节略微滑稽&lt;/p&gt;
&lt;p&gt;当然最开心的还是小Han太太的GUI可以派上用场了&lt;/p&gt;
&lt;p&gt;上次梦见仙人，隐约听到what you want to know?  I don't understand what you are talking about... 泪目，感叹学识太浅，只能读仙人的无字天书，这一开口，听不懂啊啊啊&lt;/p&gt;

&lt;p&gt;&lt;span&gt;劝小编善良，放首页看看有没有人可以指点遇到的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;时记&lt;/p&gt;

</description>
<pubDate>Thu, 01 Aug 2019 16:06:00 +0000</pubDate>
<dc:creator>A.Z</dc:creator>
<og:description>自从上次仙人梦里放了一张无字天书，解惑了WPR003N的秘诀后，渐渐的，就忘了这件这事情，连想好的评测都拖延了好多月了，毕竟路由是拿来用的，不是用来写什么陈词滥调的评测的，无意间，热爱白菜的我发现了一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/A-Z/p/ath79_nand_flash_qca9558.html</dc:identifier>
</item>
<item>
<title>第三章、Go-内建容器 - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/11285729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/11285729.html</guid>
<description>&lt;h3&gt;&lt;span&gt;3.1.数组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）数组的定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import (
        &quot;fmt&quot;
)

func main() {
        //用var定义数组可以不用赋初值
        var arr1 [5]int                  //[0 0 0 0 0]
        //用冒号必须指定初值
        arr2 := [3]int{1,3,5}            //[1 3 5]
        //用“...”表示任意个数
        arr3 := [...]int{2,4,6,8,10}     //[2 4 6 8 10]
        fmt.Println(arr1,arr2,arr3)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）数组的遍历&lt;/p&gt;
&lt;p&gt;用range关键字&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import (
        &quot;fmt&quot;
)

func main() {
        arr3 := [...]int{2,4,6,8,10}     //[2 4 6 8 10]
        fmt.Println(arr3)

        //数组的遍历
        for i := range arr3{
                fmt.Println(arr3[i])
        }
}


//结果
2
4
6
8
10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取下标和值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import (
        &quot;fmt&quot;
)

func main() {
        arr3 := [...]int{2,4,6,8,10}     //[2 4 6 8 10]
        fmt.Println(arr3)

        //数组的遍历
        for i ,v:= range arr3{
                fmt.Println(i,v)
        }
}

//结果
0 2
1 4
2 6
3 8
4 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）数组是值类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[10]int和[20]int是不同类型&lt;/li&gt;
&lt;li&gt;调用func f(arr [10]int) 会拷贝数组&lt;/li&gt;
&lt;li&gt;在go语言中一般不使用数组，而使用切片&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import (
        &quot;fmt&quot;
)

func printArray(arr [5]int){
        for i ,v:= range arr{
                fmt.Println(i,v)
        }
}

func main() {
        //arr2 := [3]int{1,3,5}
        arr3 := [...]int{2,4,6,8,10}    
        printArray(arr3)
}


//结果
0 2
1 4
2 6
3 8
4 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　如果传arr2则报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import (
        &quot;fmt&quot;
)

func printArray(arr [5]int){
        for i ,v:= range arr{
                fmt.Println(i,v)
        }
}

func main() {
        arr2 := [3]int{1,3,5}
        //arr3 := [...]int{2,4,6,8,10}
        printArray(arr2)     //cannot use arr2 (type [3]int) as type [5]int in argument to printArray
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;3.2.切片&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）切片&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import &quot;fmt&quot;

func main() {
        arr := [...]int{0,1,2,3,4,5,6,7}
        fmt.Println(arr[2:6])   //[2 3 4 5]
        fmt.Println(arr[:6])    //[0 1 2 3 4 5]
        fmt.Println(arr[2:])    //[2 3 4 5 6 7]
        fmt.Println(arr[:])         //[0 1 2 3 4 5 6 7]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）slice的扩展&lt;/p&gt;
&lt;p&gt;slice可以向后扩展，不可以向前扩展&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import &quot;fmt&quot;

func main() {
        arr := [...]int{0,1,2,3,4,5,6,7}
        s1 := arr[2:6]
        s2 := s1[3:5]
        fmt.Println(s1)     //[2 3 4 5]
        fmt.Println(s2)    //[5 6]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　s2是如何取到[5,6]的&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1299879/201908/1299879-20190801230544082-1166414996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （3）slice的实现&lt;/p&gt;
&lt;p&gt; slice底层隐藏了三个值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1299879/201908/1299879-20190801230807005-371640086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;s[i]不可以超越len(s)，向后扩展不可以超越底层数组cap(s)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;57&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import &quot;fmt&quot;

func main() {
        arr := [...]int{0,1,2,3,4,5,6,7}
        s1 := arr[2:6]
        s2 := s1[3:5]
        fmt.Println(&quot;arr = &quot;,arr)                                         //arr =  [0 1 2 3 4 5 6 7]
        fmt.Printf(&quot;s1=%v,len(s1)=%d,cap(s1)=%d\n&quot;,s1,len(s1),cap(s1))   //s1=[2 3 4 5],len(s1)=4,cap(s1)=6
        fmt.Printf(&quot;s2=%v,len(s2)=%d,cap(s2)=%d\n&quot;,s2,len(s2),cap(s2))   //s2=[5 6],len(s2)=2,cap(s2)=3
        fmt.Println(s1[3:6])                                             //[5 6 7]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;3.3.切片的操作&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）向slice添加元素&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加元素时，如果超出了cap，系统会重新分配更大的底层数组&lt;/li&gt;
&lt;li&gt;由于值传递的关系，必须接收append的返回值。s = append(s,val)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import &quot;fmt&quot;

func main() {
        arr := [...]int{0,1,2,3,4,5,6,7}
        s1 := arr[2:6]         //[2 3 4 5]
        s2 := s1[3:5]          //[5 6]
        s3 := append(s2,10)
        s4 := append(s3,11)
        s5 := append(s4,12)
        fmt.Println(s3,s4,s5)    //[5 6 10] [5 6 10 11] [5 6 10 11 12]
        //因为s2的cap是[5,6,7],s3 append把7替换成10，s4后超出了cap
        fmt.Println(arr)         //[0 1 2 3 4 5 6 10]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）slice的创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import &quot;fmt&quot;

func main() {
        //第一种
        //Zero value for slice is nil
        var s1 []int
        fmt.Println(s1)    //[]

        for i := 0; i &amp;lt; 5 ; i++{
                s1 = append(s1,i)
        }
        fmt.Println(s1)    //[0 1 2 3 4]

        //第二种
        s2 := []int{2,4,6,8}
        fmt.Printf(&quot;len(s2)=%d,cap(s2)=%d\n&quot;,len(s2),cap(s2))    //len(s2)=4,cap(s2)=4

        //第三种
        s3 := make([]int,16)
        fmt.Printf(&quot;len(s3)=%d,cap(s3)=%d\n&quot;,len(s3),cap(s3))    //len(s3)=16,cap(s3)=16

        //第四种
        s4 := make([]int,16,32)
        fmt.Printf(&quot;len(s4)=%d,cap(s4)=%d\n&quot;,len(s4),cap(s4))    //len(s4)=16,cap(s4)=32
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）slice的删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import &quot;fmt&quot;

func main() {
        s1 := []int{0,1,2,3,4,5,6}
        fmt.Println(s1)                   //[0 1 2 3 4 5 6]
        //删除index为3的值
        s1 = append(s1[:3],s1[4:]...)
        fmt.Println(s1)                   //[0 1 2 4 5 6]
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 01 Aug 2019 16:02:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<og:description>3.1.数组 （1）数组的定义 （2）数组的遍历 用range关键字 获取下标和值 （3）数组是值类型 [10]int和[20]int是不同类型 调用func f(arr [10]int) 会拷贝数组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/derek1184405959/p/11285729.html</dc:identifier>
</item>
<item>
<title>Linux Qt使用POSIX多线程条件变量、互斥锁(量) - 真的好多巧合</title>
<link>http://www.cnblogs.com/d-h-/p/11286171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/d-h-/p/11286171.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天团建，但是文章也要写。酒要喝好，文要写美，方为我辈程序员的全才之路。嘎嘎&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;之前一直在看&lt;/span&gt;POSIX&lt;span&gt;的多线程编程，上个周末结合自己的理解，写了一个基于&lt;/span&gt;&lt;span&gt;Qt&lt;/span&gt;&lt;span&gt;的用条件变量同步线程的例子。故此来和大家一起分享，希望和大家一起交流。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;提到线程，如果在&lt;/span&gt;UI&lt;span&gt;编程中，总会和一些耗时操作联系在一起。&lt;/span&gt;&lt;span&gt;Qt&lt;/span&gt;&lt;span&gt;中处理耗时操作通常有两种方式，一种是将耗时操作放在线程中；另一种则是使用&lt;/span&gt;&lt;span&gt;QApplication::processEvents()&lt;/span&gt;&lt;span&gt;，防止阻塞&lt;/span&gt;&lt;span&gt;UI&lt;/span&gt;&lt;span&gt;。从更加通用的角度来讲，我是更倾向于线程的，但对于很多初学者来讲，线程还是有一定难度的。比如说需要对线程间共享的数据提供保护，使用互斥量同步、使用条件变量、使用读写锁同步等；各种同步方式用在什么情况下，开始编程时多线程使用的并不多，无法切身体会到这些问题，后来程序写的多了一点儿，慢慢接触到一些多线程的东西，并且自己也可以学习了相关知识，并用到实际程序中。好了，下面以一个实际的例子为背景，来说明&lt;/span&gt;&lt;span&gt;Linux POSIX&lt;/span&gt;&lt;span&gt;多线程的一些特性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;程序环境：&lt;/span&gt;ubuntu 14.04&lt;span&gt;、&lt;/span&gt; &lt;span&gt;Qt 5.5.1&lt;/span&gt;&lt;span&gt;、&lt;/span&gt; &lt;span&gt;Posix&lt;/span&gt;&lt;span&gt;多线程&lt;/span&gt;&lt;span&gt;(C&lt;/span&gt;&lt;span&gt;的用法&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里简单说下我为什么用&lt;/span&gt;Linux C&lt;span&gt;的多线程，因为&lt;/span&gt;&lt;span&gt;Qt&lt;/span&gt;&lt;span&gt;的多编程对于一些线程的终止时含糊不清楚的，并且一个线程被终止后的资源是无法被清理的，所以我选择是相对底层的一些用法，以后有机会我还会添加线程取消和线程退出的操作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我自己设定的场景是这样的，在&lt;/span&gt;UI&lt;span&gt;主线程中通过界面手动向一个线程间共享的队列中&lt;/span&gt;&lt;span&gt;push&lt;/span&gt;&lt;span&gt;数据，而另外开启的一个线程则一直在&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;pop&lt;/span&gt;&lt;span&gt;数据，这算是一个变种的生产者和消费者模式吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至于条件变量、互斥量&lt;/span&gt;(&lt;span&gt;也就是互斥锁&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;的初始化在这里不再详细说明，只说明一些相对重要的地方。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1. UI&lt;span&gt;中向队列&lt;/span&gt;&lt;span&gt;push&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;生产者生产数&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个槽函数，当在&lt;/span&gt;lineEdit&lt;span&gt;中回车后，则会触发该槽函数，由于该队列是线程间的&lt;/span&gt; &lt;span&gt;共享数据，所以使用了互斥锁进行保护，即该槽操作数据的过程中如果有其他线程想要操作数据，则其他线程则会被阻塞，即访问一个已经被加锁的互斥量的线程会被阻塞。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void Widget::on_le_writeNum_returnPressed()
{
    int status;

    status = pthread_mutex_lock (&amp;amp;mp_processThread-&amp;gt;m_structCondition.mutex);
    if (status != 0)
        err_abort (status, &quot;Lock mutex&quot;);

    QString num = ui-&amp;gt;le_writeNum-&amp;gt;text();
    mp_processThread-&amp;gt;queuePushData(num.toInt());

    status = pthread_cond_signal (&amp;amp;mp_processThread-&amp;gt;m_structCondition.cond);
//    status = pthread_cond_broadcast( &amp;amp;mp_processThread-&amp;gt;m_structCondition.cond);
    if (status != 0)
        err_abort (status, &quot;Signal condition&quot;);

    status = pthread_mutex_unlock (&amp;amp;mp_processThread-&amp;gt;m_structCondition.mutex);
    if (status != 0)
        err_abort (status, &quot;Unlock mutex&quot;);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2. &lt;span&gt;消费者线程&lt;/span&gt;pop&lt;span&gt;数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该线程使用的是&lt;/span&gt;Qt&lt;span&gt;的&lt;/span&gt;&lt;span&gt;moveToThread&lt;/span&gt;&lt;span&gt;方法创建的线程，这里注意的是，整个类都运行在新的线程中。该槽函数随着线程的启动信号&lt;/span&gt;&lt;span&gt;(start())&lt;/span&gt;&lt;span&gt;发射后而一直进行&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;循环。首先对互斥量上锁，之后判断谓词状态，如果队列为空，则等待条件变量。等待条件变量时&lt;/span&gt;pthread_cond_wait()&lt;span&gt;会自动释放互斥锁，这样其他线程才能够操作共享数据。从条件变量等待中醒来后，会再次获得互斥锁，以操作共享数据。共享数据被操作完成后，再次释放互斥锁。这是我们使用条件变量等待的一个操作流程，如果我们不使用条件变量等待会是怎样的呢？&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void ProcessThread::slot_processData()
{
    int status;

    while(!mb_stopThread)
    {
        status = pthread_mutex_lock (&amp;amp;m_structCondition.mutex);
        if (status != 0)
            err_abort (status, &quot;Lock mutex&quot;);

        while(m_queue.empty())   //if queue is empty, wait contion
        {
//使用条件变量等待
            status = pthread_cond_wait(&amp;amp;m_structCondition.cond,
                                       &amp;amp;m_structCondition.mutex); 
//            qDebug() &amp;lt;&amp;lt; &quot;pthread_cond_wait is block func!&quot;;

            if (status != 0)
            {
                err_abort (status, &quot;Wait on cond faild&quot;);
            }
        }

        while(!m_queue.empty())
        {
            qDebug() &amp;lt;&amp;lt; &quot;queue mem is&quot; &amp;lt;&amp;lt; m_queue.back();

            m_queue.pop();
        }

        status = pthread_mutex_unlock (&amp;amp;m_structCondition.mutex);
        if (status != 0)
            err_abort (status, &quot;Unlock mutex&quot;);

    }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3. &lt;span&gt;不使用条件变量等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;①不使用条件变量等待&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不使用条件变量等待，则消费者线程在很大一部时间内几乎都是在执行&lt;/span&gt; while(1)&lt;span&gt;无限循环，这是很占用&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;资源的，在&lt;/span&gt;&lt;span&gt;ubuntu&lt;/span&gt;&lt;span&gt;下，使用&lt;/span&gt;&lt;span&gt;htop&lt;/span&gt;&lt;span&gt;查看的效果&lt;/span&gt; &lt;span&gt;如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;屏蔽&lt;/span&gt;status = pthread_cond_wait(&amp;amp;m_structCondition.cond,&lt;/p&gt;
&lt;p&gt;&amp;amp;m_structCondition.mutex);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686124/201908/686124-20190801235439315-1020668240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看到，此时&lt;/span&gt;CPU&lt;span&gt;是满负荷在运行的，这当然不是一个程序所应有的正常状态。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;②使用条件变量的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686124/201908/686124-20190801235502775-1535206830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此时我们看到&lt;/span&gt;CPU&lt;span&gt;的占用率是很低的，这也是为什么使用条件变量的原因之一，让不满足的条件的线程挂起，而不是在浪费&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;资源。条件变量是 允许使用队列的线程之间交换队列状态信息的机制。那么当我们还没有掌握线程条件变量的用法时，又遇到这种情况时，该怎么做呢？简单，加个&lt;/span&gt;&lt;span&gt;5ms&lt;/span&gt;&lt;span&gt;的延时即可，&lt;/span&gt;&lt;span&gt;5ms&lt;/span&gt;&lt;span&gt;对我们来讲时间极短极短，但对计算机来讲，已经挺长时间了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后，当我们关掉&lt;/span&gt;UI&lt;span&gt;窗口时，会有这样一句消息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;QThread: Destroyed while thread is still running&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程正在运行时就被破坏了，这个我们接下来会说，那就是如何退出线程、终止线程以及取消线程等操作了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎大家一起交流！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果转载，请注明出处，禁止商业用途，感谢合作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686124/201908/686124-20190801235631104-413625206.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 01 Aug 2019 15:58:00 +0000</pubDate>
<dc:creator>真的好多巧合</dc:creator>
<og:description>今天团建，但是文章也要写。酒要喝好，文要写美，方为我辈程序员的全才之路。嘎嘎 之前一直在看POSIX的多线程编程，上个周末结合自己的理解，写了一个基于Qt的用条件变量同步线程的例子。故此来和大家一起分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/d-h-/p/11286171.html</dc:identifier>
</item>
<item>
<title>Linux-Windows 端口转发 - 自由早晚乱余生</title>
<link>http://www.cnblogs.com/operationhome/p/11284559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/operationhome/p/11284559.html</guid>
<description>&lt;p&gt;在实际的生产环境中，我们为了安全性，会将一些重要的服务(数据库服务)不开放外网访问，但是当我们某个时刻由于一些特殊需求，需要进行外网访问的时候，我们可以通过端口转发来实现。通过一台和与服务可以互相访问的主机，通过该主机进行端口转发。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Windows 端口转发&lt;/li&gt;
&lt;li&gt;Linux 端口转发&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一windows-端口转发&quot;&gt;一、Windows 端口转发&lt;/h2&gt;
&lt;p&gt;windows 主要是通过 &lt;code&gt;netsh&lt;/code&gt; 进行端口转发。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;listenaddress  # 本地监听的ip
listenport # 本地监听的端口

connectaddress # 转发请求接收的主机ip
connectport # 转发请求接收的主机的端口
# 执行命令
netsh  interface  portproxy    add  v4tov4  listenaddress=localip  listenport=localport connectaddress=remoteip  connectport=remoteport
# 查看现有的配置
netsh  interface  portproxy show all
# 删除原有的端口转发
 netsh  interface  portproxy    delete   v4tov4  listenaddress=localip listenport=localport&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;示例&quot;&gt;示例&lt;/h4&gt;
&lt;p&gt;设置将请求到 本地 IP &lt;code&gt;192.168.15.89&lt;/code&gt; 的端口请求 &lt;code&gt;2222&lt;/code&gt; 转发到 &lt;code&gt;192.168.15.35&lt;/code&gt; 端口 &lt;code&gt;22&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意： 下面的命令需要用管理员执行。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;netsh  interface  portproxy    add  v4tov4  listenaddress=192.168.15.89  listenport=2222  connectaddress=192.168.15.35  connectport=22&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\WINDOWS\system32&amp;gt; netsh  interface  portproxy show all

侦听 ipv4:                 连接到 ipv4:

地址            端口        地址            端口
--------------- ----------  --------------- ----------
192.168.15.89   2222        192.168.15.35   22&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二linux-端口转发&quot;&gt;二、Linux 端口转发&lt;/h2&gt;
&lt;h3 id=&quot;rinetd&quot;&gt;1、rinetd&lt;/h3&gt;
&lt;h4 id=&quot;简介&quot;&gt;简介&lt;/h4&gt;
&lt;p&gt;官方文档 ：&lt;a href=&quot;https://boutell.com/rinetd/&quot; class=&quot;uri&quot;&gt;https://boutell.com/rinetd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载 &lt;a href=&quot;https://boutell.com/rinetd/http/rinetd.tar.gz&quot; class=&quot;uri&quot;&gt;https://boutell.com/rinetd/http/rinetd.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rinetd&lt;/code&gt; 可以将 &lt;code&gt;TCP&lt;/code&gt; 连接从一个 IP 地址和端口重定向到另外一个 IP 地址和端口。&lt;code&gt;rinetd&lt;/code&gt; 是一个单进程服务(非阻塞IO进程)，它可以处理配置文件&lt;code&gt;/etc/rinetd.conf&lt;/code&gt;中指定的地址和端口中任意数量的连接。&lt;code&gt;rinetd&lt;/code&gt; 不能重定向 FTP，因为 FTP 需要多个 &lt;code&gt;socket&lt;/code&gt;。 &lt;code&gt;rinetd&lt;/code&gt; 可以在 Linux 平台上运行，也可以在 &lt;code&gt;Windows 95/98/NT&lt;/code&gt; 平台上运行。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装：&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;wget https://boutell.com/rinetd/http/rinetd.tar.gz
tar -xzf  rinetd.tar.gz
yum  install gcc -y
cd  rinetd
# (修改端口范围)
sed -i 's/65536/65535/g' rinetd.c 
# 创建目录
mkdir /usr/man
# 解压安装
make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置文件&quot;&gt;配置文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;配置转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置文件的转发书写规则，可以配置多个转发。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bindaddress bindport connectaddress connectport&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0.0.0.0 2222  192.168.15.89 22
0.0.0.0 3333  192.168.15.89 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置过滤规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rinetd&lt;/code&gt; 可以使用过滤规则，来设定可以访问的主机。(只能使用ip，不能使用主机名)&lt;/p&gt;
&lt;p&gt;注意： 填写的位置应该&lt;code&gt;位于文件的开头&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;allow  #设置允许访问的主机
deny   #设置拒绝访问的主机&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：拒绝 &lt;code&gt;192.168.15&lt;/code&gt; 整个网段的请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;deny 192.168.15.*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置日志文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下， &lt;code&gt;rinetd&lt;/code&gt; 不会生成日志文件。要激活日志记录，请将以下行添加到配置文件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;logfile log-file-location&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：注意 logfile 与后面路径只有一个空格哦。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;logfile /var/log/rinetd.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;deny 192.168.15.*
0.0.0.0 2222  192.168.15.89 22
0.0.0.0 3333  192.168.15.89 80
logfile /var/log/rinetd.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写入配置文件&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;echo  &amp;lt;&amp;lt;EOF  &amp;gt;/etc/rinetd.conf
deny 192.168.15.*
0.0.0.0 2222  192.168.15.89 22
0.0.0.0 3333  192.168.15.89 80
logfile /var/log/rinetd.log
EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;运行和管理&quot;&gt;运行和管理&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 启动 rinetd
rinetd

# 设置开机自启
echo rinetd &amp;gt;&amp;gt;/etc/rc.local

# 暂停 ，通过kill pid
kill `cat   /var/run/rinetd.pid`

# 使用其他配置文件
rinetd -c  /opt/rinetd.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在上面使用的端口，记得在防火墙添加放行规则。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iptables&lt;/code&gt; 和 &lt;code&gt;Firewalld&lt;/code&gt; 进行端口转发的话我们后面进行补充。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Aug 2019 15:46:00 +0000</pubDate>
<dc:creator>自由早晚乱余生</dc:creator>
<og:description>在实际的生产环境中，我们为了安全性，会将一些重要的服务(数据库服务)不开放外网访问，但是当我们某个时刻由于一些特殊需求，需要进行外网访问的时候，我们可以通过端口转发来实现。通过一台和与服务可以互相访问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/operationhome/p/11284559.html</dc:identifier>
</item>
</channel>
</rss>