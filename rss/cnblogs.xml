<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【asp.net core 系列】14 .net core 中的IOC - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/13201056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/13201056.html</guid>
<description>&lt;p&gt;通过前面几篇，我们了解到了如何实现项目的基本架构：数据源、路由设置、加密以及身份验证。那么在实现的时候，我们还会遇到这样的一个问题：当我们业务类和数据源越来越多的时候，我们无法通过普通的构造对象的方法为每个实例进行赋值。同时，传统意义上的赋值遇到底层切换或者其他修改的时候，就需要修改大量的代码，对改变不友好。为了改变这种现状，我们基于面向接口编程，然后使用一些DI功能和IOC框架。&lt;/p&gt;

&lt;p&gt;先来给大家解释几个概念，IOC全称Inversion of Control，翻译过来就是控制反转，是面向对象编程的一种设计原则，用来降低代码之间的耦合度。所谓的控制反转简单来讲就是将类中属性或者其他参数的初始化交给其他方处理，而不是直接使用构造函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class Demo1
{
}

public class Demo2
{
        public Demo1 demo;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于以上简单示例代码中，在Demo2类中持有了一个Demo1的实例。如果按照之前的情况来讲，我们会通过以下方法为demo赋值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;// 方法一
public Demo1 demo = new Demo1();
// 方法二
public Demo2()
{
    demo = new Demo1();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候，如果Demo1变成下面的样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class Demo1
{
    public Demo1(Demo3 demo3)
    {
        // 隐藏
    }
}
public class Demo3
{
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，如果Demo2 没有持有一个Demo3的实例对象，这时候创建Demo1的时候就需要额外构造一个Demo3。如果Demo3需要持有另外一个类的对象，那么Demo2中就需要多创建一个对象。最后就会发现这样就陷入了一个构造“地狱”（我发明的词，指这种为了一个对象却得构造一大堆其他类型的对象）。&lt;/p&gt;
&lt;p&gt;实际上，对于Demo2并不关心Demo1的实例对象是如何获取的，甚至都不关心它是不是Demo1的子类或者接口实现类。我在示例中使用了类，但这里可以同步替换成Interface，替换之后，Demo2在调用Demo1的时候，还需要知道Demo1有实现类，以及实现类的信息。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，一些高明的程序员们提出了将对象的创建这一过程交给第三方去操作，而不是调用类来创建。于是乎，上述代码就变成了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class Demo2
{
    public Demo1 Demo {get;set;}
    public Demo2(Demo1 demo)
    {
        Demo = demo;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;似乎并没有什么变化？对于Demo2来说，Demo2从此不再负责Demo1的创建，这个步骤交由Demo2的调用方去创建，Demo2从此从负责维护Demo1这个对象的大麻烦中解脱了。&lt;/p&gt;
&lt;p&gt;但实际上构造地狱的问题还是没有解决，只不过是通过IOC的设计将这一步后移了。这时候，那些大神们想了想，不如开发一个框架这些实体对象吧。所以就出现了很多IOC框架：AutoFac、Sping.net、Unity等。&lt;/p&gt;
&lt;p&gt;说到IOC就不得不提一下DI（Dependency Injection)依赖注入。所谓的依赖注入就是属性对应实例通过构造函数或者使用属性由第三方进行赋值。也就是最后Demo2的示例代码中的写法。&lt;/p&gt;
&lt;p&gt;早期IOC和DI是指一种技术，后来开始确定这是不同的描述。IOC描述的是一种设计模式，而DI是一种行为。&lt;/p&gt;

&lt;p&gt;在之前的ASP.NET 框架中，微软并没有提供默认的IOC支持。在最新的asp.net core中微软提供了一套IOC支持，该支持在命名空间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Microsoft.Extensions.DependencyInjection
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;里，在代码中引用即可。&lt;/p&gt;
&lt;p&gt;主要通过以下几组方法实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static IServiceCollection AddScoped&amp;lt;TService&amp;gt;(this IServiceCollection services) where TService : class;
public static IServiceCollection AddSingleton&amp;lt;TService&amp;gt;(this IServiceCollection services) where TService : class;
public static IServiceCollection AddTransient&amp;lt;TService&amp;gt;(this IServiceCollection services) where TService : class;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只列出了这三组方法的一种重载版本。&lt;/p&gt;
&lt;p&gt;这三组方法分别代表三种生命周期：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AddScored 表示对象的生命周期为整个Request请求&lt;/li&gt;
&lt;li&gt;AddTransient 表示每次从服务容器进行请求时创建的，适合轻量级、 无状态的服务&lt;/li&gt;
&lt;li&gt;AddSingleton 表示该对象在第一次从服务容器请求后获取，之后就不会再次初始化了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里每组方法只介绍了一个版本，但实际上每个方法都有以下几个版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static IServiceCollection AddXXX&amp;lt;TService&amp;gt;(this IServiceCollection services) where TService : class;
public static IServiceCollection AddXXX(this IServiceCollection services, Type serviceType, Type implementationType);
public static IServiceCollection AddXXX(this IServiceCollection services, Type serviceType, Func&amp;lt;IServiceProvider, object&amp;gt; implementationFactory);
public static IServiceCollection AddXXX&amp;lt;TService, TImplementation&amp;gt;(this IServiceCollection services)
            where TService : class
            where TImplementation : class, TService;
public static IServiceCollection AddXXX(this IServiceCollection services, Type serviceType);
public static IServiceCollection AddXXX&amp;lt;TService&amp;gt;(this IServiceCollection services, Func&amp;lt;IServiceProvider, TService&amp;gt; implementationFactory) where TService : class;
public static IServiceCollection AddXXX&amp;lt;TService, TImplementation&amp;gt;(this IServiceCollection services, Func&amp;lt;IServiceProvider, TImplementation&amp;gt; implementationFactory)
            where TService : class
            where TImplementation : class, TService;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：implementationFactory 表示通过一个Provider实现TService/TImplementation 的工厂方法。当方法指定了泛型的时候，会自动依据泛型参数获取要注入的类型信息，如果没有使用泛型则必须手动传入参数类型。&lt;/p&gt;
&lt;p&gt;asp.net core如果使用依赖注入的话，需要在Startup方法中设置，具体内容可以参照以下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
    //省略其他代码
    services.AddScoped&amp;lt;ISysUserAuthRepository,SysUserAuthRepository&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;asp.net core 为DbContext提供了不同的IOC支持，AddDbContext：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static IServiceCollection AddDbContext&amp;lt;TContext&amp;gt;(
      this IServiceCollection serviceCollection,
      Action&amp;lt;DbContextOptionsBuilder&amp;gt; optionsAction = null,
      ServiceLifetime contextLifetime = ServiceLifetime.Scoped,
      ServiceLifetime optionsLifetime = ServiceLifetime.Scoped)
      where TContext : DbContext;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;services.AddDbContext&amp;lt;DefaultContext&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;理论上，asp.net core的IOC已经足够好了，但是依旧原谅我的贪婪。如果有二三百个业务类需要我来设置的话，我宁愿不使用IOC。因为那配置起来就是一场极其痛苦的过程。不过，可喜可贺的是AutoFac可以让我免收这部分的困扰。&lt;/p&gt;
&lt;p&gt;这里简单介绍一下如何使用AutoFac作为IOC管理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd Web  # 切换目录到Web项目
dotnet package add Autofac.Extensions.DependencyInjection # 添加 AutoFac的引用
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为asp.net core 版本3更改了一些逻辑，AutoFac的引用方式发生了改变，现在不介绍之前版本的内容，以3为主。使用AutoFac需要先在 Program类里设置以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
                Host.CreateDefaultBuilder(args)
                .UseServiceProviderFactory(new AutofacServiceProviderFactory()) // 添加这行代码
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                        {
                webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Program类里启用AutoFac的一个Service提供工厂类。然后在Startup类里添加如下方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public void ConfigureContainer(ContainerBuilder builder)
{
    builder.RegisterType&amp;lt;DefaultContext&amp;gt;().As&amp;lt;DbContext&amp;gt;()
                .WithParameter(&quot;connectStr&quot;,&quot;Data Source=./demo.db&quot;)
                .InstancePerLifetimeScope();
            

    builder.RegisterAssemblyTypes(Assembly.Load(&quot;Web&quot;))
        .Where(t =&amp;gt; t.BaseType.FullName.Contains(&quot;Filter&quot;))
        .AsSelf();

    builder.RegisterAssemblyTypes(Assembly.Load(&quot;Domain&quot;),
                    Assembly.Load(&quot;Domain.Implements&quot;), Assembly.Load(&quot;Service&quot;), Assembly.Load(&quot;Service.Implements&quot;))
                .AsSelf()
                .AsImplementedInterfaces()
                .InstancePerLifetimeScope()
                .PropertiesAutowired();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews(options =&amp;gt;
            {
                options.Filters.Add&amp;lt;UnitOfWorkFilterAttribute&amp;gt;();
            }).AddControllersAsServices();// 这行新增
    // 省略其他
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这一篇简单介绍了如何在Asp.net Core中启用IOC支持，并提供了两种方式，可以说是各有优劣。小伙伴们根据自己需要选择。后续会为大家详细深入AutoFac之类IOC框架的核心秘密。&lt;/p&gt;
&lt;blockquote readability=&quot;2.1052631578947&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://www.attachie.club&quot;&gt;我的博客《高先生小屋》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202006/1266612-20200628085151421-1704781331.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jun 2020 00:52:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0.前言 通过前面几篇，我们了解到了如何实现项目的基本架构：数据源、路由设置、加密以及身份验证。那么在实现的时候，我们还会遇到这样的一个问题：当我们业务类和数据源越来越多的时候，我们无法通过普通的构造</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/13201056.html</dc:identifier>
</item>
<item>
<title>推荐一种通过刷leetcode来增强技术功底的方法 - 编程一生</title>
<link>http://www.cnblogs.com/xiexj/p/13200128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/13200128.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果前人认为这个一种学习提高或者检验能力的成功实践。而自己目前又没有更好的方法，那就不妨试一试。&lt;/p&gt;
&lt;p&gt;而不管作为面试官还是被面试者，编码题最近越来越流行。而两种角色都需要思考的问题是希望考察什么能力，通过什么题目，需要达到怎样的程度可以说明面试者具有了这样的能力。&lt;/p&gt;
&lt;p&gt;而要找到上面这些问题的答案，比较好的方式除了看一些理论性文章和接受培训之外，自己动手刷一刷leetcode切身实践一下不失为一个不错的方式。而既然要花精力去做这件事情，那就需要解决一个问题：我从中可以获得什么提高。以下是个人的一些经验和感受。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;收益&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对底层有了更深入的了解和思考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leetcode一些常见题也是平时工作中常用的一些底层数据结构的实现方法。 &lt;/p&gt;
&lt;p&gt;先举个大家使用比较多的算法：LRU(最近最少使用)，在Java的实现中实现特别简单。只是使用了LinkedHashMap这种数据结构。而如果看一些开源包里LRU的实现，发现也是这样实现的。实际上动手实现一遍，LRU就再也不会忘了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202006/1112728-20200627215212017-848496056.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再举个数据结构的例子：字典树又叫前缀树。它是搜索和推荐的基础。标准点的定义是：&lt;/p&gt;
&lt;p&gt;字典树又称单词查找树，Tire树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。&lt;/p&gt;
&lt;p&gt;因为之前做过搜索引擎，一直也对这块很有兴趣，所以对它底层知识的补充对个人而言，感觉深度有增加。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202006/1112728-20200627215239569-450703132.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;养成评估时空开销的习惯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我刷leetcode必看官方解答里估算的时间和空间复杂度。这也是作为一个架构师的必备基本能力。&lt;/p&gt;
&lt;p&gt;数组、哈希这些因为数据的位置不需要进行查找，只需要算数计算就可以得到，所以它们的时间复杂度是O(1)。&lt;/p&gt;
&lt;p&gt;链表如果直接在头部或者尾部插入，因为不需要查找，所以时间复杂度也是O(1)，但是定位的话因为涉及查找，按遍历查找来算是log(n)。所以对于jdk1.7之前，hashmap底层采用的是数组+链表的数据结构。所以如果不算哈希冲突和扩容的话，获取和插入数据的时间复杂度是O(1)；如果出现了哈希冲突，则插入因为是头部插入，时间复杂度还是O(1)；获取时间复杂度因为涉及先查找，所以是O(n)，这个n代表冲突的数量。&lt;/p&gt;
&lt;p&gt;对于在有序数据中进行查找，因为可采用二分查找等优化，时间复杂度可降到log(n).&lt;/p&gt;
&lt;p&gt;对于递归调用，如果递归方法内进行2次调用。对于层数n来说，时间复杂度是2的n次方。举个例子就是一个数等于前面两个数之和。当然，如果是前面3个数之和，不进行优化的情况下时间复杂度就是3的n次方。&lt;/p&gt;
&lt;p&gt;对于一个n*m的二维数组等需要进行嵌套循环遍历的，时间复杂度是O(n*m)，有个特殊情况是n*m，这时候时间复杂度是n的平方。&lt;/p&gt;
&lt;p&gt;对于全排列的情况，时间复杂度是O(n!)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码简化的方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我习惯的一种学习方法是先做题，有了一定自己的总结和思考之后，再看书学习别人的总结思考方法。对于刷leetcode相关性高，也比较受认可的书是《Cracking the Coding interview(6th)》，中文版翻译是《程序员面试金典》。这本书对于面试官和面试者来说读了都会有一定的收获。&lt;/p&gt;

&lt;p&gt;我读了这本书，对我印象最深的是介绍了两种代码优化的方法：BUD和BCR。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BUD&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;BUD是瓶颈、不必要工作、重复工作 三个词组首字母的缩写。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202006/1112728-20200627215346007-967780408.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者提出拿到一道编程题，可先尝试用暴力解法将题目写出来，之后找到解法的性能瓶颈，针对瓶颈进行优化，之后在去掉不必要的工作，最后去掉重复的工作。&lt;/p&gt;
&lt;p&gt;这个经典的编程优化方法不只可应用于编程，还可应用于整个程序的优化，也是最常规的优化方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BCR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BCR是Best Conceivable Runtime的缩写，意思是想知道自己可以优化到什么程度，先估算可达到的最优情况。&lt;/p&gt;
&lt;p&gt;比如：在一个无序数组中，查找两个两个相同的数。直觉来说如果找到这两个数，最起码需要将每个数都遍历一遍，所以可达到的最优情况是O(n)，无论怎么优化，都不可能比这个更好。所以这就是优化的上限。&lt;/p&gt;
&lt;p&gt;这本书里还介绍了其他的优化方法如：使用额外数据结构、通过构建测试用例、根据题目的限制和提示来寻找线索，大家看这本书的时候可以了解下。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jun 2020 00:44:00 +0000</pubDate>
<dc:creator>编程一生</dc:creator>
<og:description>背景 如果前人认为这个一种学习提高或者检验能力的成功实践。而自己目前又没有更好的方法，那就不妨试一试。 而不管作为面试官还是被面试者，编码题最近越来越流行。而两种角色都需要思考的问题是希望考察什么能力</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiexj/p/13200128.html</dc:identifier>
</item>
<item>
<title>《HelloGitHub》第 51 期 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13200452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13200452.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 就是帮你找到兴趣！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230758673-1962207916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;分享 GitHub 上有趣、入门级的开源项目。&lt;/p&gt;
&lt;p&gt;这是一个面向&lt;strong&gt;编程新手&lt;/strong&gt;、&lt;strong&gt;热爱编程&lt;/strong&gt;、&lt;strong&gt;对开源社区感兴趣&lt;/strong&gt; 人群的月刊，月刊的内容包括：&lt;strong&gt;各种编程语言的项目&lt;/strong&gt;、&lt;strong&gt;让生活变得更美好的工具&lt;/strong&gt;、&lt;strong&gt;书籍、学习笔记、教程等&lt;/strong&gt;，这些开源项目大多都是非常容易上手，而且非常 Cool。主要是希望大家能动手用起来，加入到&lt;strong&gt;开源社区&lt;/strong&gt;中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会编程的可以贡献代码&lt;/li&gt;
&lt;li&gt;不会编程的可以反馈使用这些工具中的 Bug&lt;/li&gt;
&lt;li&gt;帮着宣传你觉得优秀的项目&lt;/li&gt;
&lt;li&gt;Star 项目⭐️&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在浏览、参与这些项目的过程中，你将学习到&lt;strong&gt;更多编程知识&lt;/strong&gt;、&lt;strong&gt;提高编程技巧&lt;/strong&gt;、&lt;strong&gt;找到编程的乐趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;🎉 最后 &lt;a href=&quot;https://hellogithub.com&quot;&gt;HelloGitHub&lt;/a&gt; 这个项目就诞生了 🎉&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.5882352941176&quot;&gt;
&lt;p&gt;&lt;strong&gt;以下为本期内容&lt;/strong&gt;｜每个月 &lt;strong&gt;28&lt;/strong&gt; 号发布最新一期｜&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%86%85%E5%AE%B9&quot;&gt;点击查看往期内容&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;c-项目&quot;&gt;C 项目&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/allinurl/goaccess&quot;&gt;goaccess&lt;/a&gt;：实时 Web 日志分析工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225326764-1681857054.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/esolangs/u6a&quot;&gt;u6a&lt;/a&gt;：函数式编程语言 &lt;a href=&quot;http://www.madore.org/~david/programs/unlambda/&quot;&gt;Unlambda&lt;/a&gt; 的一个朴素实现，包含字节码编译器和解释器。此项目可以帮助初学者理解函数式编程的思想，并提供了实现函数式编程语言解释器的一些朴素思路。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;性能优异：运行性能远高于官方实现，且优于多数现有的开源实现&lt;/li&gt;
&lt;li&gt;稳定可靠：有丰富的测试样例支撑，可靠性高&lt;/li&gt;
&lt;li&gt;简单朴素：代码简单易读，且提供了实现思路&lt;a href=&quot;https://github.com/esolangs/u6a/wiki/Developer's-Notes-on-Implementing-Unlambda&quot;&gt;文档&lt;/a&gt;，对初学或者完全没有学过编译原理的新手非常友好&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;c-项目-2&quot;&gt;C# 项目&lt;/h3&gt;
&lt;p&gt;3、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/NetchX/Netch&quot;&gt;Netch&lt;/a&gt;：一款 Windows 平台的开源游戏加速工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225420570-922173668.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/hey-hoho/ScheduleMasterCore&quot;&gt;ScheduleMasterCore&lt;/a&gt;：一款基于 .NET Core 开发的分布式任务调度系统。支持丰富的调度类型、灵活可控的系统参数、简易的 UI 操作、支持多节点高可用、业务 API 集成等等特性。同时支持多样化的部署方式，容易上手&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225454864-374651438.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/HandyOrg/HandyControl&quot;&gt;HandyControl&lt;/a&gt;：一套 WPF 控件库。它几乎重写了所有原生样式，同时包含 70 余款自定义控件。支持跨平台、国际化，适用于 MVVM 架构开发，扁平化设计、支持动态更换主题和背景色。丰富的自定义控件解决了 View 设计的痛点，让程序员更加专注于业务逻辑的开发&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225520081-2109383018.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;c-项目-3&quot;&gt;C++ 项目&lt;/h3&gt;
&lt;p&gt;6、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/electronicarts/CnC_Remastered_Collection&quot;&gt;CnC_Remastered_Collection&lt;/a&gt;：EA 发布的《红警》和《泰伯利亚黎明》游戏源代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225541936-1838716731.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/xmuli/chinessChess&quot;&gt;chinessChess&lt;/a&gt;：基于 Qt5 开发的中国象棋网络对战平台，支持单机和网络对战&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225556638-1362545310.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;go-项目&quot;&gt;Go 项目&lt;/h3&gt;
&lt;p&gt;8、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/bcicen/grmon&quot;&gt;grmon&lt;/a&gt;：Goroutine 的命令行监控工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225619178-114426277.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/cckuailong/HackChrome&quot;&gt;HackChrome&lt;/a&gt;：Go 语言实现的从 Chrome 中获取自动保存的用户名密码工具。目前仅支持 Windows Chrome 中存储的密码，但是很有意思还可以学习怎么用 Go 调用 DLL 动态链接库的姿势&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225636004-1047127527.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/chrislusf/seaweedfs&quot;&gt;seaweedfs&lt;/a&gt;：一款基于 Go 开发的部署方便、使用简单且强大的分布式文件系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225658004-840470331.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/godcong/fate&quot;&gt;fate&lt;/a&gt;：起中文名工具，去吧！算名先生&lt;/p&gt;
&lt;h3 id=&quot;java-项目&quot;&gt;Java 项目&lt;/h3&gt;
&lt;p&gt;12、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/YeDaxia/JApiDocs&quot;&gt;JApiDocs&lt;/a&gt;：一个无需额外注解、开箱即用的 SpringBoot 接口文档生成工具。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码即文档&lt;/li&gt;
&lt;li&gt;支持导出 HTML&lt;/li&gt;
&lt;li&gt;同步导出客户端 Model 代码&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;13、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/KFCFans/PowerJob&quot;&gt;PowerJob&lt;/a&gt;：基于 Akka 架构的新一代分布式任务调度与计算框架。支持 CRON、API、固定频率、固定延迟等调度策略，支持单机、广播、MapReduce 等多种执行模式，支持在线任务治理与运维，提供 Shell、Python、Java 等功能丰富的任务处理器，提供工作流来编排任务解决依赖关系，使用简单，功能强大，文档齐全。同类产品对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225718554-972129652.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;javascript-项目&quot;&gt;JavaScript 项目&lt;/h3&gt;
&lt;p&gt;14、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/rcdexta/react-trello&quot;&gt;react-trello&lt;/a&gt;：任务状态管理面板组件。实现了拖拽方式管理任务状态，点击即可编辑任务内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225742432-431578744.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;15、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Zizzamia/perfume.js&quot;&gt;perfume.js&lt;/a&gt;：用于测量第一个 dom 生成的时间、用户最早可操作时间和组件的生命周期性能的库。示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;perfume.start('fibonacci');
fibonacci(400);
perfume.end('fibonacci');
// Perfume.js: fibonacci 0.14 ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225813894-100297455.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/RenzHoly/Mongood&quot;&gt;Mongood&lt;/a&gt;：MongoDB 图形化的管理工具。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于微软 Fluent UI，支持自动黑暗模式&lt;/li&gt;
&lt;li&gt;支持完整的 Mongo-shell 数据类型和查询语法，利用索引实现的自动查询和排序&lt;/li&gt;
&lt;li&gt;支持 Json 数据库模式，既可用于 Server 也可用于 Client&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225837745-1853509595.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;17、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/oct16/TimeCat&quot;&gt;TimeCat&lt;/a&gt;：一款 JS 的网页录屏工具。参考了游戏录像的原理而实现的渲染引擎，生成的录像文件只有传统视频的百分之一！还可以在录制语音的同时自动生成字幕，导出的视频文件可以跨端播放。目前已经开发一段时间，后续还将实现更多有意思的功能，欢迎持续关注。&lt;a href=&quot;https://oct16.gitee.io/static/timeCatReplay/antd.html&quot;&gt;在线预览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;18、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/brick-design/react-visual-editor&quot;&gt;react-visual-editor&lt;/a&gt;：基于 React 组件的可视化拖拽、搭建页面的代码生成工具。所见即所得，可以完美还原 UI 设计搞，并支持多款型号手机（可配置）和 PC 效果展示，模板功能可以使你分享你的页面或者页面中局部任何部分组件组合，减少相似页面的重复操作。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225900180-768628934.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;19、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/tholman/elevator.js&quot;&gt;elevator.js&lt;/a&gt;：一个 back to top 返回顶部的插件。如他的名字一样，网页在返回顶部过程中像电梯向上运行，当页面返回到顶部时，会有电梯“到达”的提示音。叮~页面已到达顶部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225920151-1437701981.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;php-项目&quot;&gt;PHP 项目&lt;/h3&gt;
&lt;p&gt;20、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/4x99/code6&quot;&gt;code6&lt;/a&gt;：一款 GitHub 代码泄露监控系统，通过定期扫描 GitHub 发现代码泄露行为。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全可视化界面，操作部署简单&lt;/li&gt;
&lt;li&gt;支持 GitHub 令牌管理及智能调度&lt;/li&gt;
&lt;li&gt;扫描结果信息丰富，支持批量操作&lt;/li&gt;
&lt;li&gt;任务配置灵活，可单独配置任务扫描参数&lt;/li&gt;
&lt;li&gt;支持白名单模式，主动忽略白名单仓库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225938480-1687933394.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;python-项目&quot;&gt;Python 项目&lt;/h3&gt;
&lt;p&gt;21、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/willmcgugan/rich&quot;&gt;rich&lt;/a&gt;：一个让你的终端输出变得“花里胡哨”的三方库。我的一位前辈告诉我，不要整那些花里胡哨的主题和样式，这是在自寻烦恼。可是臣妾做不到啊，这么好看的终端输出，让我的心情都愉悦起来了。瞧那性感的语法高亮、整齐的表格、舒服的颜色、进度条等，一切都是值得的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627225953545-1369955406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;22、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/python-poetry/poetry&quot;&gt;poetry&lt;/a&gt;：Python 虚拟环境、依赖管理工具。依赖管理工具有很多，我相上了它有三点：通过单文件 pyproject.toml 便可轻松的区别安装、管理开发和正式环境、有版本锁定可方便回滚、输出界面简单清爽。当然它还是个“新生儿”，尝鲜的风险还是有的，选择须谨慎&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230011100-816216712.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;23、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/grantjenks/free-python-games&quot;&gt;free-python-games&lt;/a&gt;：真入门级的 Python 游戏集合库。都是简单的小游戏：贪吃蛇、迷宫、Pong、猜字等，运行方便、代码简单易懂。用游戏开启的你 Python 学习之旅，玩完再学源码，其乐无穷啊。安装运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install freegames
python -m freegames.snake # freegames.游戏名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230031790-1113330918.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/cckuailong/py2sec&quot;&gt;py2sec&lt;/a&gt;：一款轻量级跨平台 Python “加密”、加速的脚本工具。原理是基于 Cython 将 .py 编译成 run-time libraries 文件：.so（Linux &amp;amp;&amp;amp; Mac）或 .pyd（Win），一定程度上实现了“加密”保护源代码的功能。参数详解如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-v,  --version    显示 py2sec 版本
-h,  --help       显示帮助菜单
-p,  --pyth       Python 的版本，默认为你的 Python 命令绑定的 Python 版本
-d,  --directory  Python 项目路径（如果使用 -d 参数，将编译整个 Python 项目）
-f,  --file       Python文件（如果使用 -f，将编译单个 Python 文件）
-m,  --maintain   标记你不想编译的文件或文件夹路径
-x  --nthread     编译启用的线程数
-q  --quiet       静默模式，默认 False
-r  --release     Release 模式，清除所有中间文件，只保留加密结果文件，默认 False
python py2sec.py -f test.py
python py2sec.py -f example/test1.py -r
python py2sec.py -d example/ -m test1.py,bbb/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230055439-560070633.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;25、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/RainMark/oxfs&quot;&gt;oxfs&lt;/a&gt;：一个基于 sftp 协议的 fuse 网络文件系统，功能上类似于 sshfs。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引入了异步并发读远端文件机制，提高了文件首次读速度。&lt;/li&gt;
&lt;li&gt;缓存持久化到本地磁盘，下次挂载时访问更加快速。&lt;/li&gt;
&lt;li&gt;异步任务负责同步文件，避免低速的网络读写阻塞上层应用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230118555-734443723.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;swift-项目&quot;&gt;Swift 项目&lt;/h3&gt;
&lt;p&gt;26、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/JohnCoates/Aerial&quot;&gt;Aerial&lt;/a&gt;：炫酷的苹果系统屏保项目。该屏保视频取材自苹果零售店 Apple TV 的专用屏保，航拍质量超棒，快换上试试吧。直接下载 &lt;a href=&quot;https://github.com/JohnCoates/Aerial/releases&quot;&gt;Aerial.saver.zip 文件&lt;/a&gt;，解压后双击文件“即可食用”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230140406-418731341.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;其它&quot;&gt;其它&lt;/h3&gt;
&lt;p&gt;27、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/LingDong-/shan-shui-inf&quot;&gt;shan-shui-inf&lt;/a&gt;：自动生成一副山水画&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230211827-1608803195.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;28、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/eip-work/kuboard-press&quot;&gt;kuboard-press&lt;/a&gt;：一款基于 Kubernetes 的微服务管理界面。包含文档、教程、管理界面和实战分享&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230234860-605181076.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;29、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/SaekiRaku/vscode-rainbow-fart&quot;&gt;vscode-rainbow-fart&lt;/a&gt;：一款在你编程时花式夸你的 VSCode 扩展插件。可以根据代码关键字，播放贴近代码意义的真人语音，并且有一个醒目的项目名字“彩虹屁”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230300168-236815279.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;30、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/flink-china/flink-training-course&quot;&gt;flink-training-course&lt;/a&gt;：Flink 视频直播教程回放集合&lt;/p&gt;
&lt;p&gt;31、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/maemual/raft-zh_cn&quot;&gt;raft-zh_cn&lt;/a&gt;：《分布式 Raft 一致性算法论文》中文翻译&lt;/p&gt;
&lt;p&gt;32、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts&quot;&gt;GitHub-Chinese-Top-Charts&lt;/a&gt;：每周更新一次的 GitHub 中文项目排行榜&lt;/p&gt;
&lt;h3 id=&quot;开源书籍&quot;&gt;开源书籍&lt;/h3&gt;
&lt;p&gt;33、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/chai2010/go-ast-book&quot;&gt;go-ast-book&lt;/a&gt;：《Go语法树入门：开启自制编程语言和编译器之旅》&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230331398-1573621375.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;机器学习&quot;&gt;机器学习&lt;/h3&gt;
&lt;p&gt;34、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/NicolasHug/Surprise&quot;&gt;Surprise&lt;/a&gt;：一款简单易用基于 Python scikit 的推荐系统。如果你想用 Python 上手做一套推荐系统，那你可以试试它&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230400316-960982833.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;35、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/awslabs/djl&quot;&gt;djl&lt;/a&gt;：亚马逊开源的一款基于 Java 语言的深度学习框架。对于 Java 开发者而言，可以在 Java 中开发及应用原生的机器学习和深度学习模型，同时简化了深度学习开发的难度。通过 DJL 提供直观的、高级的 API，Java 开发人员可以训练自己的模型，或者利用数据科学家用 Python 预先训练好的模型来进行推理。如果您恰好是对学习深度学习感兴趣的 Java 开发者，那么这个项目完全对口。运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230416273-551957437.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;36、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/donnemartin/data-science-ipython-notebooks&quot;&gt;data-science-ipython-notebooks&lt;/a&gt;：数据科学的 IPython 集合。包含：TensorFlow、Theano、Caffe、scikit-learn、Spark、Hadoop、MapReduce、matplotlib、pandas、SciPy 等方方面面&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果你发现了 GitHub 上有趣的项目，欢迎在 HelloGitHub 项目提 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub/issues/new&quot;&gt;issues&lt;/a&gt; 告诉我们。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200627230845217-844711602.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;关注 HelloGitHub 公众号获取第一手的更新&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jun 2020 00:43:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>兴趣是最好的老师，HelloGitHub 就是帮你找到兴趣！ 简介 分享 GitHub 上有趣、入门级的开源项目。 这是一个面向编程新手、热爱编程、对开源社区感兴趣 人群的月刊，月刊的内容包括：各种编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13200452.html</dc:identifier>
</item>
<item>
<title>认证授权方案之授权初识 - 艾三元</title>
<link>http://www.cnblogs.com/i3yuan/p/13198355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/i3yuan/p/13198355.html</guid>
<description>&lt;p&gt;&lt;strong&gt;回顾&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/i3yuan/p/13160022.html&quot;&gt;认证授权方案之JwtBearer认证&lt;/a&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202006/1576550-20200627170555877-1275585821.gif&quot; alt=&quot;授权&quot;/&gt;&lt;/div&gt;
&lt;p&gt;在上一篇中，我们通过JwtBearer的方式认证，了解在认证时，都是基于Claim的，因此我们可以通过用户令牌获取到用户的Claims，在授权过程中对这些Claims进行验证，从而来判断是否具有获取或执行目标资源操作的权限。本章就来介绍一下 ASP.NET Core 的授权系统的简单使用。&lt;/p&gt;

&lt;p&gt;授权与身份认证是相互独立，但是，授权却需要一种身份验证机制，因此，身份验证可以为当前用户创建一个或多个标识，是确定用户真实身份的过程。而授权是根据标识确定用户可执行的操作的过程，其本质就是具有某种特性的用户会有权限访问某个资源或者执行某个操作。例如：一个拥有管理员身份的用户有创建人员、删除人员、编辑人员和删除人员的操作权限，而一个非管理身份的用户仅有读取自己信息的权限。&lt;/p&gt;
&lt;p&gt;这时候，你可能会问，究竟怎样特性的用户可以被授权访问某个资源或执行某个操作。由此我们引出了授权策略的方式，可以根据用户拥有的角色，也可以根据用户的职位，部门甚至是性别，年龄等等特性进行授权。&lt;/p&gt;
&lt;p&gt;通过建立授权策略方式，检验认证的用户所携带的身份声明（ClaimsPrincipal对象）与授权策略是否一致，从而确定用户可否执行操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202006/1576550-20200627202216875-2059410399.png&quot; alt=&quot;授权&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;31--基于角色&quot;&gt;3.1. 基于角色&lt;/h2&gt;
&lt;h4 id=&quot;311-添加角色&quot;&gt;&lt;strong&gt;3.1.1 添加角色&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;将角色赋予某个控制器或控制器内的操作，指定当前用户必须是其角色才能访问请求资源。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;Authorize&lt;/code&gt;属性的Roles特性指定所请求资源的角色。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分配了“admin”角色用户进行访问操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Authorize(Roles =&quot;admin&quot;)]
public class WeatherForecastController : ControllerBase
{

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;以逗号分隔角色名来允行多个角色访问操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Authorize(Roles =&quot;admin,user&quot;)]
public class WeatherForecastController : ControllerBase
{ 


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中只要满足&lt;code&gt;admmin&lt;/code&gt;或者&lt;code&gt;user&lt;/code&gt;其一就可以进行访问。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同时满足指定的多个角色进行的访问操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Authorize(Roles = &quot;admin&quot;)]
[Authorize(Roles = &quot;user&quot;)]
public class WeatherForecastController : ControllerBase
{ 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;312-添加策略的角色&quot;&gt;&lt;strong&gt;3.1.2 添加策略的角色&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;可以创建策略的方式进行访问控制，在配置授权服务中添加注册授权服务策略。&lt;/p&gt;
&lt;p&gt;在Startup.cs文件中，通过&lt;code&gt;ConfigureServices()&lt;/code&gt;配置服务,创建一个允许具有&lt;code&gt;admin&lt;/code&gt;角色的用户才能进行访问的策略&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        //添加授权角色策略
        services.AddAuthorization(options =&amp;gt;
        {
            options.AddPolicy(&quot;BaseRole&quot;, options =&amp;gt; options.RequireRole(&quot;admin&quot;));
        });
        //或者指定多个允许的角色
        //services.AddAuthorization(options =&amp;gt;
        // {
        //    options.AddPolicy(&quot;MoreBaseRole&quot;, options =&amp;gt; options.RequireRole(&quot;admin&quot;,&quot;user&quot;));
        // });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在控制器方法使用特性&lt;code&gt;Policy&lt;/code&gt;的属性进行策略应用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    [Authorize(Policy = &quot;BaseRole&quot;)]
    public class WeatherForecastController : ControllerBase
    {
    
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32-基于声明&quot;&gt;3.2. 基于声明&lt;/h2&gt;
&lt;h4 id=&quot;321添加声明&quot;&gt;&lt;strong&gt;3.2.1添加声明&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;对当前用户必须拥有的声明，并将声明赋予某个控制器或控制器内的操作，因此，指定声明必须持有对应的值才能访问请求资源。&lt;/p&gt;
&lt;p&gt;声明要求基于策略，所以必须进行构建一个表示声明要求的策略，才能进行授权。&lt;/p&gt;
&lt;p&gt;最简单的类型声明是将判断声明是否存在，而不检查值。&lt;/p&gt;
&lt;p&gt;可以创建策略的方式进行访问控制，在配置授权服务中添加注册授权服务策略。&lt;/p&gt;
&lt;p&gt;在Startup.cs文件中，通过&lt;code&gt;ConfigureServices()&lt;/code&gt;配置服务,创建一个允许具有声明的用户才能进行访问的策略&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        //添加基于声明的授权
        services.AddAuthorization(options =&amp;gt;
        {
            options.AddPolicy(&quot;BaseClaims&quot;, options =&amp;gt; options.RequireClaim(&quot;name&quot;));
        });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BaseClaims&lt;/code&gt;声明策略会检查&lt;code&gt;name&lt;/code&gt;当前标识是否存在声明。&lt;/p&gt;
&lt;p&gt;在控制器方法使用特性&lt;code&gt;Policy&lt;/code&gt;的属性进行策略应用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    [Authorize(Policy = &quot;BaseClaims&quot;)]
    public class WeatherForecastController : ControllerBase
    {
    
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，大多时候，我们需要声明包含值，只有指定允许值的列表，才能授权成功。所以，可以添加指定值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        //添加基于声明的授权,指定允许值列表。
        services.AddAuthorization(options =&amp;gt;
        {
            options.AddPolicy(&quot;BaseClaims&quot;, options =&amp;gt; options.RequireClaim(&quot;name&quot;,&quot;i3yuan&quot;));
        });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;33-基于策略&quot;&gt;3.3 基于策略&lt;/h2&gt;
&lt;p&gt;上面介绍的基于角色和基于声明的授权，都使用了要求、要求处理程序和预配置的策略。这些在构建上提供了便捷，但是最终都是生成授权策略。ASP.NET Core，设计了另一种灵活的授权方式，一种更丰富的可重复使用的授权结构，基于策略的授权，同时这也是授权的核心。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;code&gt;这节会先讲一下授权策略的应用，在下一节中，会对授权策略的核心进行一步步的详解。
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;在上面我们简单的介绍了基于策略的角色授权，但是这种方式无非基于角色或者声明多一些。&lt;/p&gt;
&lt;p&gt;因此，这里我们基于自定义策略授权的方式，实现授权。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;自定义授权，就要我们自己写策略提供器，自己根据不同的参数来生成不同的策略，重新实现策略的方式。策略要求由以下两种元素组成：仅保留数据的要求类，以及对用户验证数据的授权处理程序。创建自定义要求，还可以进一步表达特定策略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;331-定义权限策略permissionrequirement&quot;&gt;&lt;strong&gt;3.3.1. 定义权限策略&lt;code&gt;PermissionRequirement&lt;/code&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;定义一个权限策略，这个策略并包含一些属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class PermissionRequirement: IAuthorizationRequirement
{
    public string _permissionName { get; }

    public PermissionRequirement(string PermissionName)
    {
        _permissionName = PermissionName;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;332-再定义一个策略处理类&quot;&gt;&lt;strong&gt;3.3.2. 再定义一个策略处理类&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class PermissionRequirementHandler : AuthorizationHandler&amp;lt;PermissionRequirement&amp;gt;
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, PermissionRequirement requirement)
    {
        var role = context.User.FindFirst(c =&amp;gt; c.Type == ClaimTypes.Role);
        if (role != null)
        {
            var roleValue = role.Value;
            if (roleValue==requirement._permissionName)
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;授权处理程序读取与角色用户关联的声明，并检查自定义的角色，如果角色匹则成功，否则无法返回成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这里的自定义声明是写固定了，但是也可以通过数据库或外部服务的方式进行运行查询获取用户相关角色信息相对应的判断条件，从而在处理程序中进行判断处理。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;授权处理程序调用方法 &lt;code&gt;Succeed&lt;/code&gt;，同时传递当前要求，以通知此要求已成功得到验证。如果没有传递要求，处理程序无需执行任何操作，可以直接返回内容。不过，如果处理程序要确定是否不符合要求（无论其他处理程序是否已成功验证同一要求），将会对授权上下文对象调用方法 &lt;code&gt;Fail&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;333-下面展示了如何将自定义要求添加到策略&quot;&gt;&lt;strong&gt;3.3.3. 下面展示了如何将自定义要求添加到策略&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;（请注意，由于这是自定义要求，因此没有扩展方法，而必须继续处理策略对象的整个 &lt;code&gt;Requirements&lt;/code&gt; 集合）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        //基于自定义策略授权
        services.AddAuthorization(options =&amp;gt;
        {
            options.AddPolicy(&quot;customizePermisson&quot;,
              policy =&amp;gt; policy
                .Requirements
                .Add(new PermissionRequirement(&quot;admin&quot;)));
        });
        //此外，还需要在 IAuthorizationHandler 类型的范围内向 DI 系统注册新的处理程序：
        services.AddScoped&amp;lt;IAuthorizationHandler, PermissionRequirementHandler&amp;gt;();
        // 如前所述，要求可包含多个处理程序。如果为授权层的同一要求向 DI 系统注册多个处理程序，有一个成功就足够了。

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;334-应用自定义的策略的特性&quot;&gt;&lt;strong&gt;3.3.4. 应用自定义的策略的特性&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;指定当前用户必须是应用对控制器或控制器内的操作，如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;   [Authorize(Policy = &quot;customizePermisson&quot;)]
    public class WeatherForecastController : ControllerBase
    { 
    }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在上一篇&lt;a href=&quot;https://www.cnblogs.com/i3yuan/p/13160022.html&quot;&gt;认证授权方案之JwtBearer认证&lt;/a&gt;中，我们已经实现了获取token的方式，这一次，我们实现一个以基于角色场景为例的认证授权。&lt;/p&gt;
&lt;p&gt;在原来生成token的方式中，添加多一个声明角色的Claim，如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;new Claim(JwtClaimTypes.Role,&quot;admin&quot;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    [HttpGet]
    public IActionResult GetToken()
    {
        try
        {
            //定义发行人issuer
            string iss = &quot;JWTBearer.Auth&quot;;
            //定义受众人audience
            string aud = &quot;api.auth&quot;;
            //定义许多种的声明Claim,信息存储部分,Claims的实体一般包含用户和一些元数据
            IEnumerable&amp;lt;Claim&amp;gt; claims = new Claim[]
            {
                new Claim(JwtClaimTypes.Id,&quot;1&quot;),
                new Claim(JwtClaimTypes.Name,&quot;i3yuan&quot;),
                new Claim(JwtClaimTypes.Role,&quot;admin&quot;),
            };
            //notBefore  生效时间
            // long nbf =new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds();
            var nbf = DateTime.UtcNow;
            //expires   //过期时间
            // long Exp = new DateTimeOffset(DateTime.Now.AddSeconds(1000)).ToUnixTimeSeconds();
            var Exp = DateTime.UtcNow.AddSeconds(1000);
            //signingCredentials  签名凭证
            string sign = &quot;q2xiARx$4x3TKqBJ&quot;; //SecurityKey 的长度必须 大于等于 16个字符
            var secret = Encoding.UTF8.GetBytes(sign);
            var key = new SymmetricSecurityKey(secret);
            var signcreds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            //String issuer = default(String), String audience = default(String), IEnumerable&amp;lt;Claim&amp;gt; claims = null, Nullable&amp;lt;DateTime&amp;gt; notBefore = default(Nullable&amp;lt;DateTime&amp;gt;), Nullable&amp;lt;DateTime&amp;gt; expires = default(Nullable&amp;lt;DateTime&amp;gt;), SigningCredentials signingCredentials = null
            var jwt = new JwtSecurityToken(issuer: iss, audience: aud, claims:claims,notBefore:nbf,expires:Exp, signingCredentials: signcreds);
            var JwtHander = new JwtSecurityTokenHandler();
            var token = JwtHander.WriteToken(jwt);
            return Ok(new
            {
                access_token = token,
                token_type = &quot;Bearer&quot;,
            });
        }
        catch (Exception ex)
        {
            throw;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对控制器或控制器内的操作，指定当前用户必须是其角色才能访问请求资源，如&lt;code&gt;WeatherForecastController.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[ApiController]
[Route(&quot;[controller]&quot;)]
[Authorize(Roles =&quot;admin&quot;)]
public class WeatherForecastController : ControllerBase
{ 
    private static readonly string[] Summaries = new[]
    {
        &quot;Freezing&quot;, &quot;Bracing&quot;, &quot;Chilly&quot;, &quot;Cool&quot;, &quot;Mild&quot;, &quot;Warm&quot;, &quot;Balmy&quot;, &quot;Hot&quot;, &quot;Sweltering&quot;, &quot;Scorching&quot;
    };

    private readonly ILogger&amp;lt;WeatherForecastController&amp;gt; _logger;

    public WeatherForecastController(ILogger&amp;lt;WeatherForecastController&amp;gt; logger)
    {
        _logger = logger;
    }

    [HttpGet]
    public IEnumerable&amp;lt;WeatherForecast&amp;gt; Get()
    {
        var rng = new Random();
        return Enumerable.Range(1, 5).Select(index =&amp;gt; new WeatherForecast
        {
            Date = DateTime.Now.AddDays(index),
            TemperatureC = rng.Next(-20, 55),
            Summary = Summaries[rng.Next(Summaries.Length)]
        })
        .ToArray();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;51-获取token&quot;&gt;5.1. 获取token&lt;/h3&gt;
&lt;p&gt;分别获取role为admin和role为user的情况下颁发的token，只有在角色为admin的情况下才能授权通过。&lt;/p&gt;
&lt;h3 id=&quot;52-授权资源接口访问&quot;&gt;5.2. 授权资源接口访问&lt;/h3&gt;
&lt;h4 id=&quot;在role为admin的情况下&quot;&gt;&lt;strong&gt;在role为admin的情况下&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202006/1576550-20200627145702959-125614839.png&quot; alt=&quot;授权&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202006/1576550-20200627145729993-1283137083.png&quot; alt=&quot;授权&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;在role为user的情况下&quot;&gt;&lt;strong&gt;在role为user的情况下&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202006/1576550-20200627145753549-1407374501.png&quot; alt=&quot;授权&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202006/1576550-20200627145803254-935058113.png&quot; alt=&quot;授权&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上可知，只有在角色为admin的情况下，才能访问目标资源进行操作。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;从上一篇的认证到这一篇的授权阶段，简单的介绍了Asp.net Core的认证授权系统，对授权有了初步的认识以及使用，对授权进行划分为两种，一种是基于角色的授权，但随着角色的增加会对处理授权产生限制，不适合表达复杂的授权逻辑。另一种是基于策略的身份验证，策略包含一系列基于声明的要求，以及基于可从 &lt;code&gt;HTTP&lt;/code&gt; 上下文或外部源注入的其他任何信息的自定义逻辑。这些要求各自与一个或多个处理程序相关联，这些处理程序负责要求的实际计算。&lt;/li&gt;
&lt;li&gt;可以发现，asp.net core提供的授权策略是一个非常强大丰富且灵活的认证授权方案，能够满足大部分的授权场景。&lt;/li&gt;
&lt;li&gt;如果有不对的或不理解的地方，希望大家可以多多指正，提出问题，一起讨论,不断学习,共同进步。&lt;/li&gt;
&lt;li&gt;因此，在后续的篇章中，会继续探索授权系统，对授权策略的核心进行一步步的详解。&lt;/li&gt;
&lt;li&gt;本示例&lt;a href=&quot;https://files-cdn.cnblogs.com/files/i3yuan/Auth.Token%E6%8E%88%E6%9D%83.rar&quot;&gt;源码地址&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/security/?view=aspnetcore-3.1&quot;&gt;文献文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jun 2020 00:35:00 +0000</pubDate>
<dc:creator>艾三元</dc:creator>
<og:description>1.前言 回顾：认证授权方案之JwtBearer认证 在上一篇中，我们通过JwtBearer的方式认证，了解在认证时，都是基于Claim的，因此我们可以通过用户令牌获取到用户的Claims，在授权过程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/i3yuan/p/13198355.html</dc:identifier>
</item>
<item>
<title>ABP(ASP.NET Boilerplate Project)快速入门 - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13197706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13197706.html</guid>
<description>&lt;p&gt;这两天看了一下ABP，做个简单的学习记录。记录主要有以下内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从官网创建并下载项目(.net core 3.x + vue)&lt;/li&gt;
&lt;li&gt;项目在本地成功运行&lt;/li&gt;
&lt;li&gt;新增实体并映射到数据库&lt;/li&gt;
&lt;li&gt;完成对新增实体的基本增删改查&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ABP官网：&lt;a href=&quot;https://aspnetboilerplate.com/&quot;&gt;https://aspnetboilerplate.com/&lt;/a&gt;&lt;br/&gt;Github：&lt;a href=&quot;https://github.com/aspnetboilerplate&quot;&gt;https://github.com/aspnetboilerplate&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;进入官网&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627100457868-170119983.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Get started，选择前后端技术栈，我这里就选.net core 3.x和vue。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627100647685-2090498988.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写自己的项目名称，邮箱，然后点create my project就可以下载项目了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627100918563-2094721135.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解压文件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627102510273-1984153044.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;后端项目&quot;&gt;后端项目&lt;/h2&gt;
&lt;p&gt;首先运行后端项目，打开/aspnet-core/MyProject.sln&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627102114156-216837578.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;改一下MyProject.Web.Host项目下appsettings.json的数据库连接字符串，如果本地安装了mssql，用windows身份认证，不改也行&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627103950359-1210972586.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据库默认是使用mssql的，当然也可以改其他数据库。&lt;/p&gt;
&lt;p&gt;将MyProject.Web.Host项目设置为启动项，打开程序包管理器控制台，默认项目选择DbContext所在的项目，也就是MyProject.EntityFrameworkCore。执行&lt;code&gt;update-database&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627104427236-1141298040.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据库已成功创建：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627104650285-1366503271.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ctrl+F5，不出意外，浏览器就会看到这个界面：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627104847414-338522314.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前端项目&quot;&gt;前端项目&lt;/h2&gt;
&lt;p&gt;后端项目成功运行了，下面运行一下前端项目，先要确保本机有nodejs环境并安装了vue cli，这个就不介绍了。&lt;/p&gt;
&lt;p&gt;/vue目录下打开cmd执行：&lt;code&gt;npm install&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627105827060-1630520275.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;install完成后执行：&lt;code&gt;npm run serve&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627110024817-53125415.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器访问http://localhost:8080/，不出意外的话，会看到这个界面：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627110339033-46455551.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用默认用户 admin/123qwe 登录系统：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627110508174-741570768.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，前后端项目都已成功运行。&lt;br/&gt;那么基于abp的二次开发该从何下手呢，最简单的，比如要增加一个数据表，并且完成最基本CRUD该怎么做？&lt;/p&gt;

&lt;p&gt;实体类需要放在MyProject.Core项目下，我新建一个MyTest文件夹，并新增一个Simple类，随意给2个属性。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627113800717-635021028.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我这里继承了abp的Entity类，Entity类有主键ID属性，这个泛型int是指主键的类型，不写默认就是int。abp还有一个比较复杂的FullAuditedEntity类型，继承FullAuditedEntity的话就有创建时间，修改时间，创建人，修改人，软删除等字段。这个看实际情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Simple : Entity&amp;lt;int&amp;gt;
{
    public string Name { get; set; }

    public string Details { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改MyProject.EntityFrameworkCore项目的/EntityFrameworkCore/MyProjectDbContext：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyProjectDbContext : AbpZeroDbContext&amp;lt;Tenant, Role, User, MyProjectDbContext&amp;gt;
{
    /* Define a DbSet for each entity of the application */

    public DbSet&amp;lt;Simple&amp;gt; Simples { get; set; }

    public MyProjectDbContext(DbContextOptions&amp;lt;MyProjectDbContext&amp;gt; options)
        : base(options)
    {
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity&amp;lt;Simple&amp;gt;(p =&amp;gt;
        {
            p.ToTable(&quot;Simples&quot;, &quot;test&quot;);
            p.Property(x =&amp;gt; x.Name).IsRequired(true).HasMaxLength(20);
            p.Property(x =&amp;gt; x.Details).HasMaxLength(100);
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以迁移数据库了，程序包管理器控制台执行：&lt;code&gt;add-migration mytest1&lt;/code&gt;，&lt;code&gt;update-database&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627115048131-2123033570.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;刷新数据库，Simples表已生成：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627115950665-1424626700.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进入MyProject.Application项目，新建一个MyTest文件夹&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627124056350-400123291.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;dto&quot;&gt;Dto&lt;/h2&gt;
&lt;p&gt;CreateSimpleDto，新增Simple数据的传输对象，比如ID，创建时间，创建人等字段，就可以省略&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CreateSimpleDto
{
    public string Name { get; set; }

    public string Details { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PagedSimpleResultRequestDto，分页查询对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PagedSimpleResultRequestDto : PagedResultRequestDto
{
    /// &amp;lt;summary&amp;gt;
    /// 查询关键字
    /// &amp;lt;/summary&amp;gt;
    public string Keyword { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SimpleDto，这里跟CreateSimpleDto的区别就是继承了EntityDto，多了个ID属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SimpleDto : EntityDto&amp;lt;int&amp;gt;
{
    public string Name { get; set; }

    public string Details { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SimpleProfile，用来定义AutoMapper的映射关系清单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SimpleProfile : Profile
{
    public SimpleProfile()
    {
        CreateMap&amp;lt;Simple, SimpleDto&amp;gt;();
        CreateMap&amp;lt;SimpleDto, Simple&amp;gt;();
        CreateMap&amp;lt;CreateSimpleDto, Simple&amp;gt;();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;service&quot;&gt;Service&lt;/h2&gt;
&lt;p&gt;注意，类名参考abp的规范去命名。&lt;/p&gt;
&lt;p&gt;ISimpleAppService，Simple服务接口。我这里继承IAsyncCrudAppService，这个接口中包含了增删改查的基本定义，非常方便。如果不需要的话，也可以继承IApplicationService自己定义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface ISimpleAppService : IAsyncCrudAppService&amp;lt;SimpleDto, int, PagedSimpleResultRequestDto, CreateSimpleDto, SimpleDto&amp;gt;
{

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SimpleAppService，Simple服务，继承包含了增删改查的AsyncCrudAppService类，如果有需要的话可以override这些增删改查方法。也可以继承MyProjectAppServiceBase，自己定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SimpleAppService : AsyncCrudAppService&amp;lt;Simple, SimpleDto, int, PagedSimpleResultRequestDto, CreateSimpleDto, SimpleDto&amp;gt;, ISimpleAppService
{
    public SimpleAppService(IRepository&amp;lt;Simple, int&amp;gt; repository) : base(repository)
    {

    }

    /// &amp;lt;summary&amp;gt;
    /// 条件过滤
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;input&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    protected override IQueryable&amp;lt;Simple&amp;gt; CreateFilteredQuery(PagedSimpleResultRequestDto input)
    {
        return Repository.GetAll()
            .WhereIf(!input.Keyword.IsNullOrWhiteSpace(), a =&amp;gt; a.Name.Contains(input.Keyword));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接口测试&quot;&gt;接口测试&lt;/h2&gt;
&lt;p&gt;重新运行项目，不出意外的话，Swagger中就会多出Simple相关的接口。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627130744917-1655287996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131029796-1315680981.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131120431-831899305.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131349678-286797860.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131413832-513887384.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131547775-48419930.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131608590-91559163.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131706912-822599511.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131729470-463138682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131801785-1425833934.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200627131820860-673778571.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ABP是一个优秀的框架，基于ABP的二次开发肯定会非常高效，但前提是需要熟练掌握ABP，弄清楚他的设计理念以及他的一些实现原理。&lt;/p&gt;
&lt;p&gt;以后有时间的话再深入学习一下。文中如果有不妥之处欢迎指正。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jun 2020 00:19:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>前言 这两天看了一下ABP，做个简单的学习记录。记录主要有以下内容： 从官网创建并下载项目(.net core 3.x + vue) 项目在本地成功运行 新增实体并映射到数据库 完成对新增实体的基本增</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13197706.html</dc:identifier>
</item>
<item>
<title>恕我直言你可能真的不会java第7篇：像使用SQL一样排序集合 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13200981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13200981.html</guid>
<description>&lt;p&gt;在开始之前，我先卖个关子提一个问题：我们现在有一个Employee员工类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@AllArgsConstructor
public class Employee {

   private Integer id;
   private Integer age;   //年龄
   private String gender;  //性别
   private String firstName;  
   private String lastName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你知道怎么对一个Employee对象组成的List集合，&lt;strong&gt;先按照性别字段倒序排序，再按照年龄的倒序&lt;/strong&gt;进行排序么？如果您不知道4行代码以内的解决方案（其实是1行代码就可以实现，但笔者格式化为4行），我觉得您有必要一步步的看下去。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202006/1815316-20200628080545312-2102015558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、字符串list排序&quot;&gt;一、字符串List排序&lt;/h2&gt;
&lt;p&gt;cities是一个字符串数组。&lt;strong&gt;注意london的首字母是小写的。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; cities = Arrays.asList(
        &quot;Milan&quot;,
        &quot;london&quot;,
        &quot;San Francisco&quot;,
        &quot;Tokyo&quot;,
        &quot;New Delhi&quot;
);
System.out.println(cities);
//[Milan, london, San Francisco, Tokyo, New Delhi]

cities.sort(String.CASE_INSENSITIVE_ORDER);
System.out.println(cities);
//[london, Milan, New Delhi, San Francisco, Tokyo]

cities.sort(Comparator.naturalOrder());
System.out.println(cities);
//[Milan, New Delhi, San Francisco, Tokyo, london]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当使用sort方法，按照String.CASE_INSENSITIVE_ORDER（字母大小写不敏感）的规则排序，结果是：[london, Milan, New Delhi, San Francisco, Tokyo]&lt;/li&gt;
&lt;li&gt;如果使用Comparator.naturalOrder()字母自然顺序排序，结果是：[Milan, New Delhi, San Francisco, Tokyo, london]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同样我们可以把排序器Comparator用在Stream管道流中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cities.stream().sorted(Comparator.naturalOrder()).forEach(System.out::println);

//Milan
//New Delhi
//San Francisco
//Tokyo
//london
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在java 7我们是使用Collections.sort()接受一个数组参数，对数组进行排序。&lt;strong&gt;在java 8之后可以直接调用集合类的sort()方法进行排序&lt;/strong&gt;。sort()方法的参数是一个比较器Comparator接口的实现类，Comparator接口的我们下一节再给大家介绍一下。&lt;/p&gt;
&lt;h2 id=&quot;二、整数类型list排序&quot;&gt;二、整数类型List排序&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(6, 2, 1, 4, 9);
System.out.println(numbers); //[6, 2, 1, 4, 9]

numbers.sort(Comparator.naturalOrder());  //自然排序
System.out.println(numbers); //[1, 2, 4, 6, 9]

numbers.sort(Comparator.reverseOrder()); //倒序排序
System.out.println(numbers);  //[9, 6, 4, 2, 1]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、按对象字段对listobject排序&quot;&gt;三、按对象字段对&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;排序&lt;/h2&gt;
&lt;p&gt;这个功能就比较有意思了，举个例子大家理解一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Employee e1 = new Employee(1,23,&quot;M&quot;,&quot;Rick&quot;,&quot;Beethovan&quot;);
Employee e2 = new Employee(2,13,&quot;F&quot;,&quot;Martina&quot;,&quot;Hengis&quot;);
Employee e3 = new Employee(3,43,&quot;M&quot;,&quot;Ricky&quot;,&quot;Martin&quot;);
Employee e4 = new Employee(4,26,&quot;M&quot;,&quot;Jon&quot;,&quot;Lowman&quot;);
Employee e5 = new Employee(5,19,&quot;F&quot;,&quot;Cristine&quot;,&quot;Maria&quot;);
Employee e6 = new Employee(6,15,&quot;M&quot;,&quot;David&quot;,&quot;Feezor&quot;);
Employee e7 = new Employee(7,68,&quot;F&quot;,&quot;Melissa&quot;,&quot;Roy&quot;);
Employee e8 = new Employee(8,79,&quot;M&quot;,&quot;Alex&quot;,&quot;Gussin&quot;);
Employee e9 = new Employee(9,15,&quot;F&quot;,&quot;Neetu&quot;,&quot;Singh&quot;);
Employee e10 = new Employee(10,45,&quot;M&quot;,&quot;Naveen&quot;,&quot;Jain&quot;);


List&amp;lt;Employee&amp;gt; employees = Arrays.asList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);

employees.sort(Comparator.comparing(Employee::getAge));
employees.forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先，我们创建了10个Employee对象，然后将它们转换为List&lt;/li&gt;
&lt;li&gt;然后重点的的代码:使用了函数应用Employee::getAge作为对象的排序字段，即使用员工的年龄作为排序字段&lt;/li&gt;
&lt;li&gt;然后调用List的forEach方法将List排序结果打印出来，如下(当然我们重写了Employee的toString方法，不然打印结果没有意义)：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Employee(id=2, age=13, gender=F, firstName=Martina, lastName=Hengis)
Employee(id=6, age=15, gender=M, firstName=David, lastName=Feezor)
Employee(id=9, age=15, gender=F, firstName=Neetu, lastName=Singh)
Employee(id=5, age=19, gender=F, firstName=Cristine, lastName=Maria)
Employee(id=1, age=23, gender=M, firstName=Rick, lastName=Beethovan)
Employee(id=4, age=26, gender=M, firstName=Jon, lastName=Lowman)
Employee(id=3, age=43, gender=M, firstName=Ricky, lastName=Martin)
Employee(id=10, age=45, gender=M, firstName=Naveen, lastName=Jain)
Employee(id=7, age=68, gender=F, firstName=Melissa, lastName=Roy)
Employee(id=8, age=79, gender=M, firstName=Alex, lastName=Gussin)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果我们希望List按照年龄age的倒序排序，就使用reversed()方法。如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;employees.sort(Comparator.comparing(Employee::getAge).reversed());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、comparator链对listobject排序&quot;&gt;四、Comparator链对&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;排序&lt;/h2&gt;
&lt;p&gt;下面这段代码先是按性别的倒序排序，再按照年龄的倒序排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;employees.sort(
        Comparator.comparing(Employee::getGender)
        .thenComparing(Employee::getAge)
        .reversed()
);
employees.forEach(System.out::println);

//都是正序 ，不加reversed
//都是倒序，最后面加一个reserved
//先是倒序（加reserved），然后正序
//先是正序（加reserved），然后倒序（加reserved）
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6.2932692307692&quot;&gt;
&lt;p&gt;细心的朋友可能注意到：我们只用了一个reversed()倒序方法，这个和SQL的表述方式不太一样。这个问题不太好用语言描述，建议大家去看一下&lt;a href=&quot;https://www.bilibili.com/video/BV1sE411P7C1/&quot;&gt;本文对应的视频&lt;/a&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;排序结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Employee(id=8, age=79, gender=M, firstName=Alex, lastName=Gussin)
Employee(id=10, age=45, gender=M, firstName=Naveen, lastName=Jain)
Employee(id=3, age=43, gender=M, firstName=Ricky, lastName=Martin)
Employee(id=4, age=26, gender=M, firstName=Jon, lastName=Lowman)
Employee(id=1, age=23, gender=M, firstName=Rick, lastName=Beethovan)
Employee(id=6, age=15, gender=M, firstName=David, lastName=Feezor)
Employee(id=7, age=68, gender=F, firstName=Melissa, lastName=Roy)
Employee(id=5, age=19, gender=F, firstName=Cristine, lastName=Maria)
Employee(id=9, age=15, gender=F, firstName=Neetu, lastName=Singh)
Employee(id=2, age=13, gender=F, firstName=Martina, lastName=Hengis)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jun 2020 00:06:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在开始之前，我先卖个关子提一个问题：我们现在有一个Employee员工类。 @Data @AllArgsConstructor public class Employee { private Inte</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13200981.html</dc:identifier>
</item>
<item>
<title>GitLab Runner部署(kubernetes环境) - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13200977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13200977.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;br/&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于gitlab-ci&quot;&gt;关于GitLab CI&lt;/h3&gt;
&lt;p&gt;如下图所示，开发者将代码提交到GitLab后，可以触发CI脚本在GitLab Runner上执行，通过编写CI脚本我们可以完成很多使用的功能：编译、构建、生成docker镜像、推送到私有仓库等：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628073056617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;本次实战内容&quot;&gt;本次实战内容&lt;/h3&gt;
&lt;p&gt;今天咱们会一起完成以下操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;部署minio，pipeline脚本中的cache功能由minio来实现；&lt;/li&gt;
&lt;li&gt;配置和部署GitLab Runner；&lt;/li&gt;
&lt;li&gt;编写和运行pipeline脚本；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;环境和版本信息&quot;&gt;环境和版本信息&lt;/h3&gt;
&lt;p&gt;本次实战涉及到多个服务，下面给出它们的版本信息供您参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GitLab：Community Edition 13.0.6&lt;/li&gt;
&lt;li&gt;GilLab Runner：13.1.0&lt;/li&gt;
&lt;li&gt;kubernetes：1.15.3&lt;/li&gt;
&lt;li&gt;Harbor：1.1.3&lt;/li&gt;
&lt;li&gt;Minio：2020-06-18T02:23:35Z&lt;/li&gt;
&lt;li&gt;Helm：2.16.1&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;需要提前准备好的服务&quot;&gt;需要提前准备好的服务&lt;/h3&gt;
&lt;p&gt;以下服务需要您在实战前提前准备好：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;部署好GitLab，参考&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/106973743&quot;&gt;《群晖DS218+部署GitLab》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部署好Harbor，参考&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/106962214&quot;&gt;《群晖DS218+部署Harbor(1.10.3)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部署好Helm，参考&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/103667500&quot;&gt;《部署和体验Helm(2.16.1版本)》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;准备完毕后开始实战；&lt;/p&gt;
&lt;h3 id=&quot;部署minio&quot;&gt;部署minio&lt;/h3&gt;
&lt;p&gt;minio作为一个独立的服务部署，我将用docker部署在服务器：&lt;span&gt;192.168.50.43&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在宿主机准备两个目录，分别存储minio的配置和文件，执行以下命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir -p /var/services/homes/zq2599/minio/gitlab_runner \
&amp;amp;&amp;amp; chmod -R 777 /var/services/homes/zq2599/minio/gitlab_runner \
&amp;amp;&amp;amp; mkdir -p /var/services/homes/zq2599/minio/config \
&amp;amp;&amp;amp; chmod -R 777 /var/services/homes/zq2599/minio/config
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;执行docker命令创建minio服务，指定服务端口是9000，并且指定了access key(最短三位)和secret key(最短八位)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo docker run -p 9000:9000 --name minio \
-d --restart=always \
-e &quot;MINIO_ACCESS_KEY=access&quot; \
-e &quot;MINIO_SECRET_KEY=secret123456&quot; \
-v /var/services/homes/zq2599/minio/gitlab_runner:/gitlab_runner \
-v /var/services/homes/zq2599/minio/config:/root/.minio \
minio/minio server /gitlab_runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;浏览器访问，输入access key和secret key后登录成功：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020062807412844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图，点击红框中的图标，创建一个bucket，名为&lt;span&gt;runner&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628074153636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;至此，minio已备好，接下来在kubernetes环境部署GitLab Runner；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;gitlab-runner的类型&quot;&gt;GitLab Runner的类型&lt;/h3&gt;
&lt;p&gt;从使用者的维度来看，GitLab Runner的类型分为&lt;span&gt;shared&lt;/span&gt;和&lt;span&gt;specific&lt;/span&gt;两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果您想创建的GitLab Runner给所有GitLab仓库使用，就要创建&lt;span&gt;shared&lt;/span&gt;类型；&lt;/li&gt;
&lt;li&gt;如果您的GitLab Runner只用于给某个固定的Gitlab仓库，就要创建&lt;span&gt;specific&lt;/span&gt;类型；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天的实战，我们创建的是&lt;span&gt;specific&lt;/span&gt;类型，即先有GitLab代码仓库，然后创建该仓库专用的runner，所以请您提前准备好GitLab仓库；&lt;/p&gt;
&lt;h3 id=&quot;准备gitlab配置信息specific&quot;&gt;准备GitLab配置信息(specific)&lt;/h3&gt;
&lt;p&gt;在部署GitLab Runner之前，要准备两个关键的配置信息，以便GitLab Runner启动后可以顺利连接上GitLab：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览器访问GitLab，打开用来做CI的代码仓库，点击Settings -&amp;gt; CI/CD -&amp;gt; Runners -&amp;gt; Expand：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628074415275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图，红框1中是&lt;span&gt;gitlab url&lt;/span&gt;，红框2中是&lt;span&gt;registration token&lt;/span&gt;，记好这两个参数，稍后会用到：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628074430670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;准备gitlab配置信息shared&quot;&gt;准备GitLab配置信息(shared)&lt;/h3&gt;
&lt;p&gt;本次实战不会创建shared类型的runner，如果您要创建该类型runner，只需按照以下方法准备信息即可，创建出来的runner就是所有仓库都能使用的了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;以管理员身份登录GitLab；&lt;/li&gt;
&lt;li&gt;按照下图红框的顺序取得&lt;span&gt;gitlab url&lt;/span&gt;和&lt;span&gt;registration token&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628074523336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;部署ritlab-runner&quot;&gt;部署RitLab Runner&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;请确保当前可以通过&lt;span&gt;kubectl&lt;/span&gt;命令在kubernetes进行常规操作；&lt;/li&gt;
&lt;li&gt;创建名为&lt;span&gt;gitlab-runner&lt;/span&gt;的namespace：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl create namespace gitlab-runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;创建一个secret，把minio的access key和secret key存进去，在后面配置cache的时候会用到：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl create secret generic s3access \
--from-literal=accesskey=&quot;access&quot; \
--from-literal=secretkey=&quot;secret123456&quot; -n gitlab-runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;用helm部署GitLab Runner之前，先把chart的仓库添加到helm的仓库列表中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;helm repo add gitlab https://charts.gitlab.io
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;下载GitLab Runner的chart：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;helm fetch gitlab/gitlab-runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;当前目录会多出一个文件gitlab-runner-0.18.0.tgz，解压：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;tar -zxvf gitlab-runner-0.18.0.tgz
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;解压后是名为gitlab-runner的文件夹，内容如下图所示，接下来要修改里面的三个文件：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628074715321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;打开values.yaml，里面有四处需要修改：&lt;/li&gt;
&lt;li&gt;第一处，找到已被注释掉的&lt;span&gt;gitlabUrl&lt;/span&gt;参数位置，添加gitlabUrl的配置，其值就是前面在GitLab网页取得的&lt;span&gt;gitlab url&lt;/span&gt;参数，如下图红框：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628074750153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;第二处，找到已被注释掉的&lt;span&gt;runnerRegistrationToken&lt;/span&gt;参数位置，添加&lt;span&gt;runnerRegistrationToken&lt;/span&gt;的配置，其值就是前面在GitLab网页取得的&lt;span&gt;registration token&lt;/span&gt;参数，如下图红框：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628074820219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;找到&lt;span&gt;rbac&lt;/span&gt;的配置，将&lt;span&gt;create&lt;/span&gt;和&lt;span&gt;clusterWideAccess&lt;/span&gt;的值都改成&lt;span&gt;true&lt;/span&gt;(创建RBAC、创建容器gitlab-bastion用于管理job的容器)：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020062807490137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;设置此GitLab Runner的&lt;span&gt;tag&lt;/span&gt;为&lt;span&gt;k8s&lt;/span&gt;，在pipeline脚本中可以通过指定tag为&lt;span&gt;k8s&lt;/span&gt;，这样pipeline就会在这个Gitlab Runner上允许：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628074932783.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;找到&lt;span&gt;cache&lt;/span&gt;的配置，在修改之前，cache的配置如下图，可见值为空内容的大括号，其余信息全部被注释了：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628074949927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;修改后的&lt;span&gt;cache&lt;/span&gt;配置如下图，红框1中原先的大括号已去掉，红框2中的是去掉了注释符号，内容不变，红框3中填写的是&lt;span&gt;minio&lt;/span&gt;的访问地址，红框4中的是去掉了注释符号，内容不变：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628075020123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上图红框4中的&lt;span&gt;s3CacheInsecure&lt;/span&gt;参数等于&lt;span&gt;false&lt;/span&gt;表示对minio的请求为http(如果是true就是https)，但实际证明，&lt;span&gt;当前版本的chart中该配置是无效的&lt;/span&gt;，等到运行时还是会以https协议访问，解决此问题的方法是修改templates目录下的&lt;span&gt;_cache.tpl&lt;/span&gt;文件，打开此文件，找到下图红框中的内容：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628075119646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;将上图红框中的内容替换成下面红框中的样子，即删除原先的&lt;span&gt;if判断和对应的end&lt;/span&gt;这两行，直接给&lt;span&gt;CACHE_S3_INSECURE&lt;/span&gt;赋值：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020062807515897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;接下来要修改的是&lt;span&gt;templates/configmap.yaml&lt;/span&gt;文件，在这里面将宿主机的docker的sock映射给runner executor，这样job中的docker命令就会发到宿主机的docker daemon上，由宿主机来执行，打开&lt;span&gt;templates/configmap.yaml&lt;/span&gt;，找到下图位置，我们要在红框1和红框2之间添加一段内容：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628075235857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;要在上图红框1和红框2之间添加的内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cat &amp;gt;&amp;gt;/home/gitlab-runner/.gitlab-runner/config.toml &amp;lt;&amp;lt;EOF
            [[runners.kubernetes.volumes.host_path]]
              name = &quot;docker&quot;
              mount_path = &quot;/var/run/docker.sock&quot;
              read_only = true
              host_path = &quot;/var/run/docker.sock&quot;
    EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;19&quot;&gt;&lt;li&gt;添加上述内容后，整体效果如下，红框中就是新增内容：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628075611623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;修改完毕，回到&lt;span&gt;values.yam&lt;/span&gt;所在目录，执行以下命令即可创建GitLab Runner：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;helm install \
--name-template gitlab-runner \
-f values.yaml . \
--namespace gitlab-runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;21&quot;&gt;&lt;li&gt;检查pod是否正常：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628075649333.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;看pod日志也并未发现异常：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020062807570438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;回到GitLab的runner页面，可见新增一个runner：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628075714511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，整个GitLab CI环境已部署完毕，接下来简单的验证环境是否OK；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在GitLab仓库中，增加名为&lt;span&gt;.gitlab-ci.yml&lt;/span&gt;的文件，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;# 设置执行镜像
image: busybox:latest

# 整个pipeline有两个stage
stages:
- build
- test

# 定义全局缓存，缓存的key来自分支信息，缓存位置是vendor文件夹
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
  - vendor/

before_script:
  - echo &quot;Before script section&quot;

after_script:
  - echo &quot;After script section&quot;

build1:
  stage: build
    tags:
  - k8s
  script:
    - echo &quot;将内容写入缓存&quot;
    - echo &quot;build&quot; &amp;gt; vendor/hello.txt

test1:
  stage: test
  script:
    - echo &quot;从缓存读取内容&quot;
    - cat vendor/hello.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;提交上述脚本到GitLab，如下图，可见pipeline会被触发，状态为pending是因为正在等待runner创建executor pod：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020062807583134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;稍后就会执行成功，点开看结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628075848441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;点开&lt;span&gt;build1&lt;/span&gt;的图标，可见此job的输出信息：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200628075858913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;点开&lt;span&gt;test1&lt;/span&gt;的图标，可见对应的控制台输出，上一个job写入的数据被成功读取：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020062807592726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbGluZ19jYXZhbHJ5,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，GitLab Runner已经成功在kubernetes环境部署和运行，接下来的文章，我们会一起实战将SpringBoot应用构建成docker镜像并推送到Harbor；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注我的公众号：程序员欣宸&quot;&gt;欢迎关注我的公众号：程序员欣宸&lt;/h3&gt;
</description>
<pubDate>Sun, 28 Jun 2020 00:03:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>记录K8S环境部署GitLab Runner的详细步骤</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13200977.html</dc:identifier>
</item>
<item>
<title>前端开发神器Charles从入门到卸载 - 胡哥有话说</title>
<link>http://www.cnblogs.com/justbecoder/p/13200946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justbecoder/p/13200946.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文将带大家学习使用前端开发神器-&lt;code&gt;charles&lt;/code&gt;，从基本的下载安装到常见配置使用，为大家一一讲解。&lt;/p&gt;
&lt;h2 id=&quot;一、花式夸奖charles&quot;&gt;一、花式夸奖Charles&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;截取 Http 和 Https 网络封包。&lt;/li&gt;
&lt;li&gt;支持重发网络请求，方便后端调试。&lt;/li&gt;
&lt;li&gt;支持修改网络请求参数。&lt;/li&gt;
&lt;li&gt;支持网络请求的截获并动态修改。&lt;/li&gt;
&lt;li&gt;支持模拟慢速网络。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;好，骑上我心爱的小摩托，准备上路...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二、下载与安装&quot;&gt;二、下载与安装&lt;/h2&gt;
&lt;p&gt;官网下载&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文所使用的的版本为 mac V4.5.6版本，不同版本间的具体化差异，大家可留言交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Charles破解工具可通过关注公众号「胡哥有话说」，回复关键字&lt;code&gt;charles&lt;/code&gt;获得。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三、简单入门-抓包所有请求&quot;&gt;三、简单入门-抓包所有请求&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;打开&lt;code&gt;Charles&lt;/code&gt;，勾选&lt;code&gt;Proxy&lt;/code&gt;下的&lt;code&gt;macOS Proxy&lt;/code&gt;（如果是windows，此处为Windows Proxy）&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;Proxy&lt;/code&gt;-&amp;gt;&lt;code&gt;Start Recording&lt;/code&gt;，打开浏览器访问任意页面，可以在&lt;code&gt;Charles&lt;/code&gt;中看到请求了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065200493-96323728.jpg&quot; alt=&quot;Recording&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;很好，现在已经上路了，学习的路上永不堵车...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四、设置过滤请求&quot;&gt;四、设置过滤请求&lt;/h2&gt;
&lt;p&gt;通过上面的操作，我们已经抓包了所有的请求，实际开发中可能是专门针对某些接口（如百度域名下的接口），我们可以专门配置过滤接口。&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;临时性过滤配置&lt;/p&gt;
&lt;p&gt;在展示界面的&lt;code&gt;Filter&lt;/code&gt;中可进行条件过滤&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065200836-2145652095.jpg&quot; alt=&quot;Filter&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;同时可在右侧的&lt;code&gt;settings&lt;/code&gt;中配置使用正则来进行过滤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;永久性过滤配置&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;Proxy&lt;/code&gt;-&amp;gt;&lt;code&gt;Recording Settings&lt;/code&gt;-&amp;gt;&lt;code&gt;include&lt;/code&gt;中配置过滤条件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065201258-1579602663.jpg&quot; alt=&quot;Recording Settings&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Ok，我们又前进了一大步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;五、代理转发请求&quot;&gt;五、代理转发请求&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;Charles&lt;/code&gt;的&lt;code&gt;Map Remote&lt;/code&gt;和&lt;code&gt;Map Local&lt;/code&gt;我们也可以配置代理转发请求。&lt;/p&gt;
&lt;h3 id=&quot;map-remote&quot;&gt;Map Remote&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Map Remote 远程映射，是将指定的网络请求重定向到另一个网址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;业务场景：&lt;/strong&gt;&lt;br/&gt;某些服务端的文件请求时限制某些特定域名(*.baidu.com)，我们使用localhost启动项目时,会导致没有权限访问。通过配置&lt;code&gt;Map Remote&lt;/code&gt;远程映射解决问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置路径：&lt;/strong&gt;&lt;br/&gt;设置&lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Map Remote&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065201545-1847158413.jpg&quot; alt=&quot;Remote列表&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065201746-746642626.jpg&quot; alt=&quot;单一Remote设置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图上的配置，本地启动的项目地址为：&lt;code&gt;http://localhost:8080&lt;/code&gt;（或 &lt;code&gt;http://127.0.0.1:8080&lt;/code&gt;），现在再访问，可以使用路径 &lt;code&gt;http://test.baidu.com&lt;/code&gt;访问即可。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意&lt;code&gt;Enable Map Remote&lt;/code&gt;一定要勾选，以及相应规则也要勾选，否则不会生效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;map-local&quot;&gt;Map Local&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Map Local 本地映射，是指将指定的网络请求重定向到本地的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;业务场景：&lt;/strong&gt;&lt;br/&gt;在本地化的开发中，接口数据Mock；或者是线上环境问题排查时，将请求重定向到本地文件以方便排查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置路径：&lt;/strong&gt;&lt;br/&gt;设置&lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Map Local&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065202053-1932582399.jpg&quot; alt=&quot;Local映射列表&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065202275-604405120.jpg&quot; alt=&quot;单一Local映射设置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过如上图的配置，请求 &lt;code&gt;aa.baidu.com:443/index&lt;/code&gt;时，会被映射到本地 &lt;code&gt;/xx/index.json&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意&lt;code&gt;Enable Map Local&lt;/code&gt;一定要勾选，以及相关规则也要勾选，否则不会生效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;六、手机抓包&quot;&gt;六、手机抓包&lt;/h2&gt;
&lt;p&gt;手机抓包请求也是我们日常开发中需要用到的，那如何利用&lt;code&gt;Charles&lt;/code&gt;抓包手机请求呢。&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设置&lt;code&gt;Charles&lt;/code&gt;的代理端口号&lt;br/&gt;通过设置&lt;code&gt;Proxy&lt;/code&gt;-&amp;gt;&lt;code&gt;Proxy Settings&lt;/code&gt;-&amp;gt;&lt;code&gt;Proxies&lt;/code&gt;-&amp;gt;&lt;code&gt;HTTP Proxy&lt;/code&gt;下的&lt;code&gt;Port&lt;/code&gt;端口号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065202568-283686823.jpg&quot; alt=&quot;Port设置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查看本地IP地址&lt;br/&gt;通过&lt;code&gt;Charles&lt;/code&gt;的&lt;code&gt;Help&lt;/code&gt;-&amp;gt;&lt;code&gt;Local IP Address&lt;/code&gt;查看，本机IP为xx.xx.xx.xx&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065202791-1491770081.jpg&quot; alt=&quot;本机IP&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;手机和电脑需要处于同于wifi网络内&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;手机wifi网络配置&lt;/p&gt;
&lt;p&gt;以华为mate 30为例，选择对应的wifi，选择&lt;code&gt;显示高级选项&lt;/code&gt;，设置代理为&lt;code&gt;手动&lt;/code&gt;。&lt;br/&gt;设置&lt;code&gt;服务器主机名&lt;/code&gt;为：xx.xx.xx.xx（刚才查看的电脑IP）&lt;br/&gt;设置&lt;code&gt;服务器端口&lt;/code&gt;为：8888（刚才设置的port）&lt;br/&gt;点击保存后，手机的请求就可以在&lt;code&gt;Charles&lt;/code&gt;中查看啦...&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065203013-61759766.jpg&quot; alt=&quot;手机wifi设置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意链接时，&lt;code&gt;Charles&lt;/code&gt;会弹出授权窗口，要选择&lt;code&gt;Allow&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065203208-1999072868.jpg&quot; alt=&quot;Auth&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;七、限速设置&quot;&gt;七、限速设置&lt;/h2&gt;
&lt;p&gt;通过设置&lt;code&gt;Proxy&lt;/code&gt;-&amp;gt;&lt;code&gt;Throttle Settings&lt;/code&gt;来进行速度限制&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1103694/202006/1103694-20200628065203432-905561486.jpg&quot; alt=&quot;Throttle Settings&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：一定要勾选 &lt;code&gt;Enable Throttling&lt;/code&gt;选项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;以上是给大家分享的&lt;code&gt;Charles&lt;/code&gt;的常见使用配置，如有相关问题可留言交流。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得&lt;code&gt;点赞&lt;/code&gt;、&lt;code&gt;收藏&lt;/code&gt;呦，关注胡哥有话说，学习前端不迷路，欢迎多多留言交流...&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;胡哥有话说，专注于大前端技术领域，分享前端系统架构，框架实现原理，最新最高效的技术实践！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 27 Jun 2020 22:52:00 +0000</pubDate>
<dc:creator>胡哥有话说</dc:creator>
<og:description>前言 本文将带大家学习使用前端开发神器-charles，从基本的下载安装到常见配置使用，为大家一一讲解。 一、花式夸奖Charles 截取 Http 和 Https 网络封包。 支持重发网络请求，方便</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justbecoder/p/13200946.html</dc:identifier>
</item>
<item>
<title>FreeSql 使用 ToTreeList/AsTreeCte 查询无限级分类表 - FreeSql</title>
<link>http://www.cnblogs.com/FreeSql/p/13200935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FreeSql/p/13200935.html</guid>
<description>&lt;h2 id=&quot;关于无限级分类&quot;&gt;关于无限级分类&lt;/h2&gt;
&lt;p&gt;第一种方案：&lt;br/&gt;使用递归算法，也是使用频率最多的，大部分开源程序也是这么处理，不过一般都只用到四级分类。 这种算法的数据库结构设计最为简单。category表中一个字段id，一个字段fid(父id)。这样可以根据WHERE id = fid来判断上一级内容，运用递归至最顶层。&lt;br/&gt;分析：通过这种数据库设计出的无限级，可以说读取的时候相当费劲，所以大部分的程序最多3-4级分类，这就足以满足需求，从而一次性读出所有的数据，再对得到数组或者对象进行递归。本身负荷还是没太大问题。但是如果分类到更多级，那是不可取的办法。&lt;br/&gt;这样看来这种分类有个好处，就是增删改的时候轻松了…然而就二级分类而言，采用这种算法就应该算最优先了。&lt;/p&gt;
&lt;p&gt;第二种方案：&lt;br/&gt;设置fid字段类型为varchar，将父类id都集中在这个字段里，用符号隔开，比如：1,3,6&lt;br/&gt;这样可以比较容易得到各上级分类的ID，而且在查询分类下的信息的时候，&lt;br/&gt;可以使用：SELECT * FROM category WHERE pid LIKE “1,3%”。&lt;/p&gt;
&lt;p&gt;分 析：相比于递归算法，在读取数据方面优势非常大，但是若查找该分类的所有 父分类 或者 子分类 查询的效率也不是很高，至少也要二次query，从某种意义看上，个人觉得不太符合数据库范式的设计。倘若递增到无限级，还需考虑字段是否达到要求，而且 在修改分类和转移分类的时候操作将非常麻烦。&lt;br/&gt;暂时，在自己项目中用的就是类似第二种方案的解决办法。就该方案在我的项目中存在这样的问题， 如果当所有数据记录达到上万甚至10W以上后，一次性将所以分类，有序分级的现实出来，效率很低。极有可能是项目处理数据代码效率低带来的。现在正在改良。&lt;/p&gt;
&lt;p&gt;第三种方案：&lt;br/&gt;　　无限级分类----改进前序遍历树&lt;br/&gt;那 么理想中的树型结构应具备哪些特点呢？数据存储冗余小、直观性强；方便返回整个树型结构数据；可以很轻松的返回某一子树（方便分层加载）；快整获以某节点 的祖谱路径；插入、删除、移动节点效率高等等。带着这些需求我查找了很多资料，发现了一种理想的树型结构数据存储及操作算法，改进的前序遍历树模型 （The Nested Set Model）。&lt;br/&gt;原理：&lt;br/&gt;我们先把树按照水平方式摆开。从根节点开始（“Food”），然后他的左边写 上1。然后按照树的顺序（从上到下）给“Fruit”的左边写上2。这样，你沿着树的边界走啊走（这就是“遍历”），然后同时在每个节点的左边和右边写上 数字。最后，我们回到了根节点“Food”在右边写上18。下面是标上了数字的树，同时把遍历的顺序用箭头标出来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1694977/202006/1694977-20200628061920348-1579067206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我 们称这些数字为左值和右值（如，“Food”的左值是1，右值是18）。正如你所见，这些数字按时了每个节点之间的关系。因为“Red”有3和6两个值， 所以，它是有拥有1-18值的“Food”节点的后续。同样的，我们可以推断所有左值大于2并且右值小于11的节点，都是有2-11的“Fruit” 节点的后续。这样，树的结构就通过左值和右值储存下来了。这种数遍整棵树算节点的方法叫做“改进前序遍历树”算法。&lt;/p&gt;
&lt;p&gt;表结构设计：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1694977/202006/1694977-20200628061937964-106255953.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那 么我们怎样才能通过一个SQL语句把所有的分类都查询出来呢，而且要求如果是子类的话前面要打几个空格以表现是子分类。要想查询出所有分类很好 办：SELECT * FROM category WHERE lft&amp;gt;1 AND lft&amp;lt;18 ORDER BY lft这样的话所有的分类都出来了，但是谁是谁的子类却分不清，那么怎么办呢?我们仔细看图不难发现如果相邻的两条记录的右值第一条的右值比第二条的大那 么就是他的父类，比如food的右值是18而fruit的右值是11 那么food是fruit的父类，但是又要考虑到多级目录。于是有了这样的设计，我们用一个数组来存储上一条记录的右值，再把它和本条记录的右值比较，如 果前者比后者小，说明不是父子关系，就用array_pop弹出数组，否则就保留，之后根据数组的大小来打印空格。&lt;/p&gt;
&lt;blockquote readability=&quot;1.8493150684932&quot;&gt;
&lt;p&gt;以上内容引用出处：&lt;a href=&quot;https://www.cnblogs.com/badboys/p/9945296.html&quot;&gt;https://www.cnblogs.com/badboys/p/9945296.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于第三种设计的更多资料请点击查看原文，因为过于复杂（过重）被使用的频率不高。&lt;/p&gt;
&lt;h2 id=&quot;引出痛点&quot;&gt;引出痛点&lt;/h2&gt;
&lt;p&gt;无限级分类（父子）是一种比较常用的表设计，每种设计方式突出优势的同时也带来缺陷，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种方案：表设计中只有 parent_id 字段，写入数据方便，困扰：查询麻烦，许多使用了 ORM 的项目被迫使用 SQL 解决该场景；&lt;/li&gt;
&lt;li&gt;第二种方案：表设计中冗余子级id便于查询，困扰：添加/更新/删除的时候需要重新计算；&lt;/li&gt;
&lt;li&gt;第三种方案：表设计中存储左右值编码，困扰：同上；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一种方案的设计最简单，本文后面的内容是在该基础上，使用 FreeSql 实现 ToTreeList(内存加工树型)、AsTreeCte(实现递归向下/向上查询)，满足大众日常使用。&lt;/p&gt;
&lt;h2 id=&quot;关于-freesql&quot;&gt;关于 FreeSql&lt;/h2&gt;
&lt;p&gt;FreeSql 是功能强大的对象关系映射技术(O/RM)，支持 .NETCore 2.1+ 或 .NETFramework 4.0+ 或 Xamarin，以 MIT 开源协议托管于 github，单元测试数量 4528个，nuget 下载量 151K，支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite/达梦/人大金仓/神州通用/Access；&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1694977/202006/1694977-20200628062451646-2038596813.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者说过：每一个功能代表他的一撮头发！&lt;/p&gt;
&lt;h2 id=&quot;第一步：定义导航属性&quot;&gt;第一步：定义导航属性&lt;/h2&gt;
&lt;p&gt;FreeSql 导航属性之中，有针对父子关系的设置方式，ToTreeList/AsTreeCte 依赖该设置，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Area
{
  [Column(IsPrimary = true)]
  public string Code { get; set; }

  public string Name { get; set; }
  public string ParentCode { get; set; }

  [Navigate(nameof(ParentCode)), JsonIgnore] //JsonIgnore 是 json.net 的特性
  public Area Parent { get; set; }
  [Navigate(nameof(ParentCode))]
  public List&amp;lt;Area&amp;gt; Childs { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关于导航属性&quot;&gt;关于导航属性&lt;/h3&gt;
&lt;p&gt;定义 Parent 属性，在表达式中可以这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Parent.Parent.Parent.Name == &quot;中国&quot;)
  .First();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义 Childs 属性，在表达式中可以这样（子查询）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Childs.AsSelect().Any(c =&amp;gt; c.Name == &quot;北京&quot;))
  .First();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义 Childs 属性，还可以使用&lt;a href=&quot;https://github.com/dotnetcore/FreeSql/wiki/%E8%81%94%E7%BA%A7%E4%BF%9D%E5%AD%98&quot;&gt;【级联保存】&lt;/a&gt;、&lt;a href=&quot;https://github.com/2881099/FreeSql/wiki/%e8%b4%aa%e5%a9%aa%e5%8a%a0%e8%bd%bd&quot;&gt;【贪婪加载】&lt;/a&gt; 等等操作。&lt;/p&gt;
&lt;h3 id=&quot;添加测试数据&quot;&gt;添加测试数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Delete&amp;lt;Area&amp;gt;().Where(&quot;1=1&quot;).ExecuteAffrows();
var repo = fsql.GetRepository&amp;lt;Area&amp;gt;();
repo.DbContextOptions.EnableAddOrUpdateNavigateList = true;
repo.DbContextOptions.NoneParameter = true;
repo.Insert(new Area
{
  Code = &quot;100000&quot;,
  Name = &quot;中国&quot;,
  Childs = new List&amp;lt;Area&amp;gt;(new[] {
    new Area
    {
      Code = &quot;110000&quot;,
      Name = &quot;北京&quot;,
      Childs = new List&amp;lt;Area&amp;gt;(new[] {
        new Area{ Code=&quot;110100&quot;, Name = &quot;北京市&quot; },
        new Area{ Code=&quot;110101&quot;, Name = &quot;东城区&quot; },
      })
    }
  })
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第二步：使用-totreelist-返回树型数据&quot;&gt;第二步：使用 ToTreeList 返回树型数据&lt;/h2&gt;
&lt;p&gt;配置好父子属性之后，就可以这样用了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t1 = fsql.Select&amp;lt;Area&amp;gt;().ToTreeList();
Assert.Single(t1);
Assert.Equal(&quot;100000&quot;, t1[0].Code);
Assert.Single(t1[0].Childs);
Assert.Equal(&quot;110000&quot;, t1[0].Childs[0].Code);
Assert.Equal(2, t1[0].Childs[0].Childs.Count);
Assert.Equal(&quot;110100&quot;, t1[0].Childs[0].Childs[0].Code);
Assert.Equal(&quot;110101&quot;, t1[0].Childs[0].Childs[1].Code);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询数据本来是平面的，ToTreeList 方法将返回的平面数据在内存中加工为树型 List 返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;[
  {
    &quot;ParentCode&quot;: null,
    &quot;Childs&quot;: [
      {
        &quot;ParentCode&quot;: &quot;100000&quot;,
        &quot;Childs&quot;: [
          {
            &quot;ParentCode&quot;: &quot;110000&quot;,
            &quot;Childs&quot;: [],
            &quot;Code&quot;: &quot;110100&quot;,
            &quot;Name&quot;: &quot;北京市&quot;
          },
          {
            &quot;ParentCode&quot;: &quot;110000&quot;,
            &quot;Childs&quot;: [],
            &quot;Code&quot;: &quot;110101&quot;,
            &quot;Name&quot;: &quot;东城区&quot;
          }
        ],
        &quot;Code&quot;: &quot;110000&quot;,
        &quot;Name&quot;: &quot;北京&quot;
      }
    ],
    &quot;Code&quot;: &quot;100000&quot;,
    &quot;Name&quot;: &quot;中国&quot;
  }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第三步：使用-astreecte-递归查询&quot;&gt;第三步：使用 AsTreeCte 递归查询&lt;/h2&gt;
&lt;p&gt;若不做数据冗余的无限级分类表设计，递归查询少不了，AsTreeCte 正是解决递归查询的封装，方法参数说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) pathSelector&lt;/td&gt;
&lt;td&gt;路径内容选择，可以设置查询返回：中国 -&amp;gt; 北京 -&amp;gt; 东城区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) up&lt;/td&gt;
&lt;td&gt;false(默认)：由父级向子级的递归查询，true：由子级向父级的递归查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) pathSeparator&lt;/td&gt;
&lt;td&gt;设置 pathSelector 的连接符，默认：-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;(可选) level&lt;/td&gt;
&lt;td&gt;设置递归层级&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过测试的数据库：MySql8.0、SqlServer、PostgreSQL、Oracle、Sqlite、达梦、人大金仓&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;姿势一：AsTreeCte() + ToTreeList&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t2 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte() //查询 中国 下的所有记录
  .OrderBy(a =&amp;gt; a.Code)
  .ToTreeList(); //非必须，也可以使用 ToList（见姿势二）
Assert.Single(t2);
Assert.Equal(&quot;100000&quot;, t2[0].Code);
Assert.Single(t2[0].Childs);
Assert.Equal(&quot;110000&quot;, t2[0].Childs[0].Code);
Assert.Equal(2, t2[0].Childs[0].Childs.Count);
Assert.Equal(&quot;110100&quot;, t2[0].Childs[0].Childs[0].Code);
Assert.Equal(&quot;110101&quot;, t2[0].Childs[0].Childs[1].Code);
// WITH &quot;as_tree_cte&quot;
// as
// (
// SELECT 0 as cte_level, a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;Area&quot; a 
// WHERE (a.&quot;Name&quot; = '中国')

// union all

// SELECT wct1.cte_level + 1 as cte_level, wct2.&quot;Code&quot;, wct2.&quot;Name&quot;, wct2.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; wct1 
// INNER JOIN &quot;Area&quot; wct2 ON wct2.&quot;ParentCode&quot; = wct1.&quot;Code&quot;
// )
// SELECT a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; a 
// ORDER BY a.&quot;Code&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;姿势二：AsTreeCte() + ToList&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t3 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .OrderBy(a =&amp;gt; a.Code)
  .ToList();
Assert.Equal(4, t3.Count);
Assert.Equal(&quot;100000&quot;, t3[0].Code);
Assert.Equal(&quot;110000&quot;, t3[1].Code);
Assert.Equal(&quot;110100&quot;, t3[2].Code);
Assert.Equal(&quot;110101&quot;, t3[3].Code);
//执行的 SQL 与姿势一相同
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;姿势三：AsTreeCte(pathSelector) + ToList&lt;/p&gt;
&lt;p&gt;设置 pathSelector 参数后，如何返回隐藏字段？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t4 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte(a =&amp;gt; a.Name + &quot;[&quot; + a.Code + &quot;]&quot;)
  .OrderBy(a =&amp;gt; a.Code)
  .ToList(a =&amp;gt; new { 
    item = a, 
    level = Convert.ToInt32(&quot;a.cte_level&quot;), 
    path = &quot;a.cte_path&quot; 
  });
Assert.Equal(4, t4.Count);
Assert.Equal(&quot;100000&quot;, t4[0].item.Code);
Assert.Equal(&quot;110000&quot;, t4[1].item.Code);
Assert.Equal(&quot;110100&quot;, t4[2].item.Code);
Assert.Equal(&quot;110101&quot;, t4[3].item.Code);
Assert.Equal(&quot;中国[100000]&quot;, t4[0].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000]&quot;, t4[1].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000] -&amp;gt; 北京市[110100]&quot;, t4[2].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000] -&amp;gt; 东城区[110101]&quot;, t4[3].path);
// WITH &quot;as_tree_cte&quot;
// as
// (
// SELECT 0 as cte_level, a.&quot;Name&quot; || '[' || a.&quot;Code&quot; || ']' as cte_path, a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;Area&quot; a 
// WHERE (a.&quot;Name&quot; = '中国')

// union all

// SELECT wct1.cte_level + 1 as cte_level, wct1.cte_path || ' -&amp;gt; ' || wct2.&quot;Name&quot; || '[' || wct2.&quot;Code&quot; || ']' as cte_path, wct2.&quot;Code&quot;, wct2.&quot;Name&quot;, wct2.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; wct1 
// INNER JOIN &quot;Area&quot; wct2 ON wct2.&quot;ParentCode&quot; = wct1.&quot;Code&quot;
// )
// SELECT a.&quot;Code&quot; as1, a.&quot;Name&quot; as2, a.&quot;ParentCode&quot; as5, a.cte_level as6, a.cte_path as7 
// FROM &quot;as_tree_cte&quot; a 
// ORDER BY a.&quot;Code&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;更多姿势...请根据代码注释进行尝试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jun 2020 22:41:00 +0000</pubDate>
<dc:creator>FreeSql</dc:creator>
<og:description>关于无限级分类 第一种方案： 使用递归算法，也是使用频率最多的，大部分开源程序也是这么处理，不过一般都只用到四级分类。 这种算法的数据库结构设计最为简单。category表中一个字段id，一个字段fi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FreeSql/p/13200935.html</dc:identifier>
</item>
<item>
<title>HTML5实现DTMF（电话拨号按键信号）解码、编码，代码简单易于移植 - xiangyuecn</title>
<link>http://www.cnblogs.com/xiangyuecn/p/13200894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiangyuecn/p/13200894.html</guid>
<description>&lt;blockquote readability=&quot;14.718309859155&quot;&gt;
&lt;p&gt;DTMF(Dual Tone Multi Frequency) 双音多频，由高频群和低频群组成，高低频群各包含4个频率；两个频率波形合成按键信号(0-9 * # A B C D)。&lt;/p&gt;
&lt;p&gt;SIP中检测DTMF信号的方法：SIPINFO、RFC2833、INBAND；至于这些是什么我这个外行纯属热闹；拿两个手机互打电话，中途按下的按键嘟嘟的声音就是直接通过话音来传输DTMF信号，属于INBAND（带内检测）吧。&lt;/p&gt;
&lt;p&gt;拿Adobe Audition打开手机上的电话录音文件，可以直观的肉眼看到整齐的DTMF信号，分析一下就能很快GET到此信号的解码、编码原理。&lt;/p&gt;
&lt;p&gt;在线测试地址：&lt;a href=&quot;https://xiangyuecn.github.io/Recorder/assets/%E5%B7%A5%E5%85%B7-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E5%8F%91Runtime.html?jsname=teach.dtmf.decode_and_encode&quot;&gt;在线测试&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMTUyNjY5LWM4MWNiYmM1MTE1MzZkY2IucG5n?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;sup&gt;【图1】简单粗暴合成的PCM信号杂波较多，但和华为手机打出来的录音信号差不多（他们杂波少点）&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-html5实现dtmf的一些动机&quot;&gt;1.1 HTML5实现DTMF的一些动机&lt;/h2&gt;
&lt;p&gt;我的GitHub开源库 &lt;a href=&quot;https://github.com/xiangyuecn/Recorder&quot;&gt;Recorder&lt;/a&gt; 功能日渐丰富，最近又有项目可能会用到DTMF的解码功能，所以就用js实现了一下，本着易于移植的目的，相关代码都是简单的纯js代码，移植到别的语言非常方便。&lt;/p&gt;
&lt;p&gt;涉及到三个源码，个个小巧：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;FFT：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/lib.fft.js&quot;&gt;lib.fft.js&lt;/a&gt; 111行（代码+空行+注释）&lt;/li&gt;
&lt;li&gt;DTMF解码：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/dtmf.decode.js&quot;&gt;dtmf.decode.js&lt;/a&gt; 192行（代码+空行+注释）&lt;/li&gt;
&lt;li&gt;DTMF编码：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/dtmf.encode.js&quot;&gt;dtmf.encode.js&lt;/a&gt; 191行（代码+空行+注释）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;自评：&lt;strong&gt;高性能💪、准确度高💪、误识别率低💪&lt;/strong&gt;；欢迎到 &lt;a href=&quot;https://xiangyuecn.github.io/Recorder/assets/%E5%B7%A5%E5%85%B7-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E5%8F%91Runtime.html?jsname=teach.dtmf.decode_and_encode&quot;&gt;在线测试&lt;/a&gt;，下载别的一个软件 &lt;a href=&quot;http://aluigi.altervista.org/mytoolz.htm#dtmf2num&quot;&gt;dtmf2num(命令行)&lt;/a&gt; 来对比伤害一下。&lt;/p&gt;
&lt;h2 id=&quot;12-一些有效场景&quot;&gt;1.2 一些有效场景&lt;/h2&gt;
&lt;h3 id=&quot;1-10086&quot;&gt;(1) 10086&lt;/h3&gt;
&lt;p&gt;查话费请按1，嘟（你按了一个1），您的话费余额为9亿9千万……不能否认，这些能力的实现是建立在DTMF信号的编解码之上。&lt;/p&gt;
&lt;h3 id=&quot;2-软电话&quot;&gt;(2) 软电话&lt;/h3&gt;
&lt;p&gt;透过某些渠道，比如在你服务器上的程序拥有了自动拨打电话的能力，你希望通过用户按下某些按键后实现一些功能，比如输入密码，这样你的服务器端程序就需要带上DTMF解码功能。&lt;/p&gt;
&lt;h3 id=&quot;3-小玩具&quot;&gt;(3) 小玩具&lt;/h3&gt;
&lt;p&gt;写一些小玩具把玩。嘿哈🙃。&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;低频群\高频群 (hz)&lt;/th&gt;
&lt;th&gt;1209&lt;/th&gt;
&lt;th&gt;1336&lt;/th&gt;
&lt;th&gt;1477&lt;/th&gt;
&lt;th&gt;1633&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;697&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;770&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;852&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;941&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;#&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;31-先学会手工解码&quot;&gt;3.1 先学会手工解码&lt;/h2&gt;
&lt;p&gt;观察上面【图1】，一个长的PCM音频中，每个按键信号频谱中都能清晰的看到两条非常亮的横线（对应此频率的信号能量非常强），Adobe Audition中定位到需要分析的时间位置，然后点击菜单：窗口-&amp;gt;频率分析(Alt+Z)，显示频率信息得到两个最高的频率；这两个最高频率就是上面频率对照表中的频率值（取最接近的值）：低频703hz约等于697，高频1203hz约等于1209，查表可知此信号对应的按键为“1”。&lt;/p&gt;
&lt;h2 id=&quot;32-了解一些原理&quot;&gt;3.2 了解一些原理&lt;/h2&gt;
&lt;p&gt;并非专业，看看就好。&lt;/p&gt;
&lt;h3 id=&quot;1-调整pcm采样率基本不会干扰到dtmf信号&quot;&gt;(1) 调整PCM采样率基本不会干扰到DTMF信号&lt;/h3&gt;
&lt;p&gt;我说的。因为DTMF信号的最高频率是1633hz，远低于常见的&lt;code&gt;8000&lt;/code&gt;（频率最高4000hz）、&lt;code&gt;44100&lt;/code&gt;（频率最高22050hz）采样率对应的最高识别频率。&lt;/p&gt;
&lt;h3 id=&quot;2-降低采样率有利于识别dtmf信号&quot;&gt;(2) 降低采样率有利于识别DTMF信号&lt;/h3&gt;
&lt;p&gt;我说的。比如：&lt;code&gt;8000&lt;/code&gt;采样率就包含了0-4000hz的频率信号，&lt;code&gt;44100&lt;/code&gt;采样率包含了 0 - 22050hz 的频率信号，相当于&lt;code&gt;44100&lt;/code&gt;比&lt;code&gt;8000&lt;/code&gt;多了 4000 - 22050hz 的和DTMF信号无关的频率，而且是占大头。多出来的这些频率最直观的提现就是增大了计算量（指数级吧）。&lt;/p&gt;
&lt;p&gt;以此类推，如果我们将PCM的最高频率控制在比1633高点，那么将会大幅减少计算量，比如限制最高2000hz频率，对应的采样率就是&lt;code&gt;4000&lt;/code&gt;，比&lt;code&gt;8000&lt;/code&gt;还小了一倍，把高频信号全部切掉，参考下面【图2】。&lt;/p&gt;
&lt;h3 id=&quot;3-普通话音很难刚好凑成dtmf信号&quot;&gt;(3) 普通话音很难刚好凑成DTMF信号&lt;/h3&gt;
&lt;p&gt;至少人家是这么说的。刚好有那么一个声音持续了一段时间，并且这个声音的最高两个频率刚好在DTMF对照表里面，概率不会太高吧。&lt;/p&gt;
&lt;p&gt;取决于解码算法的好坏，同一段音频，可能有的解码器会错误识别出20个按键信号，有的可能只错误识别出2个按键信号&lt;sup&gt;（比如我写的解码器，哈😆）&lt;/sup&gt;。&lt;/p&gt;
&lt;h2 id=&quot;33-实现软件解码&quot;&gt;3.3 实现软件解码&lt;/h2&gt;
&lt;p&gt;软解码最直观的实现就是将【2.1 手工解码】按顺序用程序实现就行了，简单粗暴，不需要更多的原理和基础知识。软解js源码：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/dtmf.decode.js&quot;&gt;dtmf.decode.js&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-降低pcm的采样率&quot;&gt;(1) 降低PCM的采样率&lt;/h3&gt;
&lt;p&gt;为了减少计算量，和突出DTMF信号的频率，我们将任何PCM数据的采样率降低到4000，此时的PCM中包含了 0 - 2000hz 的频率。可以采用最简单的重采样办法：隔几个数据抽取一个数据；比如16000采样率降到4000，每4个采样取一个即可。此处理性能消耗忽略不计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMTUyNjY5LTQxYjUwYWYzYTk4YTczM2QucG5n?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;sup&gt;【图2】4000采样率下两个频率就非常突出了（Audition频谱里面要到右侧刻度右键降低分辨率，不然4000的采样率是一坨一坨的频谱）&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-如何找到那两条横线&quot;&gt;(2) 如何找到那两条横线&lt;/h3&gt;
&lt;p&gt;如上面【图2】中，一个按键信号的频谱中有两个能量非常强的频率（很亮的两条横线），对应的就是DTMF的低频和高频，这两频率是会持续一段时间的；因此我们只要发现PCM内存在两个最强的频率，并且这两个频率在DTMF频率表中，那么我们就可以假设此时间位置可能有一个DTMF按键信号（注意是可能有，并非一定是一个按键信号）。&lt;/p&gt;
&lt;p&gt;那我们现在只需要计算一下某个时间段内是否有2个最大频率信号在DTMF频率表内即可实现判断；计算方法除了用FFT（快速傅里叶变换）外，更常用的是Goertzel算法，本着入门到放弃的原则，我们采用更通用的FFT来计算频率，Goertzel就放弃学习了。&lt;/p&gt;
&lt;p&gt;似乎FFT运算会带来性能问题，不过对于短的PCM计算来说，也是可以忽略不计的，并且我们已经降低了采样率（计算量指数级下降）；这里给一个数据：一个4分30秒的mp3进行一次DTMF解码总消耗的时间300ms不到，共进行了约&lt;code&gt;( 4.5*60 * 1000ms ) / 16ms = 16875&lt;/code&gt; 次FFT计算 (其中16ms是下面滑动窗口一次滑动时长距离)，fftSize=256。&lt;/p&gt;
&lt;h3 id=&quot;3-用fft将时域信号转成频率信号&quot;&gt;(3) 用FFT将时域信号转成频率信号&lt;/h3&gt;
&lt;p&gt;FFT又是一个复杂的东西，还好有很多代码可以借(copy)鉴。参考js代码：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/lib.fft.js&quot;&gt;lib.fft.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FFT需要提供一个fftSize，越大对频率的分辨率越高，比如&lt;code&gt;fftSize=1024&lt;/code&gt;，分辨率为：&lt;code&gt;4000/1024 = 3.90625hz&lt;/code&gt;（4000是PCM的采样率）。FFT计算一次后会输出&lt;code&gt;Int[512]&lt;/code&gt;的数组，数组内第一个点的频率就是 &lt;code&gt;1 * 3.90625 = 3.90625 hz&lt;/code&gt;，最后一个点的频率就是 &lt;code&gt;512 * 3.90625 = 2000 hz&lt;/code&gt;；数组内的每个值就是对应频率的信号强度值（可转换成分贝），越大信号越强。&lt;/p&gt;
&lt;p&gt;但这个分辨率并非越大越好，因为你提供的fftSize越大，每次计算就需要提供同等数量的PCM采样数据，&lt;code&gt;fftSize=1024&lt;/code&gt;就要提供&lt;code&gt;1024/4000*1000 = 256ms&lt;/code&gt;的PCM数据；这样问题就产生了：我们单个DTMF信号音的持续时间可能就是 40 - 100 ms，256ms覆盖的数据区间就太长了甚至可能被覆盖了两个按键信号也不一定；因此我们要调低分辨率。&lt;/p&gt;
&lt;p&gt;调低后的折中结果就是：&lt;code&gt;fftSize=256&lt;/code&gt;，分辨率为&lt;code&gt;4000/256 = 15.625 hz&lt;/code&gt;（相对于 3.90625hz 分辨率降低了4倍），不能再低了，再低分辨率就识别不出信号到底是DTMF频率表中的哪个值了。此时每次计算需要的PCM数据时长为&lt;code&gt;256/4000*1000 = 64ms&lt;/code&gt;，能够很好的保证区间内只有一个按键信号。&lt;/p&gt;
&lt;h3 id=&quot;4-粗暴的fft扫荡模式：滑动窗口，不放过任何可能的信号&quot;&gt;(4) 粗暴的FFT扫荡模式：滑动窗口，不放过任何可能的信号&lt;/h3&gt;
&lt;p&gt;我们不能简单的把PCM切分N段（256个采样为一段），然后每段进行一次FFT计算，这样会大概率将一个信号拆分到两段数据中，导致检测不到这个信号。因此我们计算FFT时应当采用滑动窗口模式，每次将计算窗口往前滑动一点点，这样就能保证所有的数据都能被至少完整的计算一次。&lt;/p&gt;
&lt;p&gt;可以将每次滑动大小设为窗口大小的1/4，即256个采样为窗口大小，每次FFT计算时往前滑动&lt;code&gt;256 / 4 = 64&lt;/code&gt;个采样（&lt;code&gt;64/4000*1000 = 16 ms&lt;/code&gt; ），这样就能完美的覆盖到所有信号，看下面【图3】。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMTUyNjY5LTRhMjVkZTIyNzBmM2VlNjEucG5n?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;sup&gt;【图3】下面这种不停滑动的窗口，能很好覆盖所有信号区域，缺点就是1次计算要变成4次计算；上面这种虽然只要一次计算，但覆盖能力太差&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-连续出现的相同信号即为有效按键&quot;&gt;(5) 连续出现的相同信号即为有效按键&lt;/h3&gt;
&lt;p&gt;只出现一次的信号不能代表这是一个有效的DTMF按键信号，我们累计连续出现3次的相同信号才判定为有效信号。因此我们能够识别到的最小按键音时长为：&lt;code&gt;256/4000*1000 = 64ms&lt;/code&gt; , &lt;code&gt;64 / 4 = 16 ms&lt;/code&gt; , &lt;code&gt;16 * (3-0.999999🤔) ≈ 32 ms&lt;/code&gt;。更长的按键音时长无限制，因为连续相同的只会算一个按键信号。&lt;/p&gt;
&lt;p&gt;另外还需要区分两个按键之间的间隙，我们定义累计出现3个以上没有信号的区域，下一个信号才算新的按键信号，这样就能区分多次按同一个键，因此两个信号理论上最小的间隔时长为：&lt;code&gt;16 * 3 + 16 * 3 = 96 ms&lt;/code&gt;，但实际计结果3次是最小的边界，按3+1次以上才容错性更好，最佳间隔应当是&lt;code&gt;16 * 4 + 16 * 4 = 128 ms&lt;/code&gt;以上，意思就是按下一个键后，下一个键要128ms以后再按（生成信号）。&lt;/p&gt;
&lt;p&gt;不停的向后计算，直到PCM结尾，我们就能把所有DTMF信号找出来了，并且我们还能比较准确的转换出这些信号的位置。然后测试一下：准确度高，误识别率低，性能还可以，效果很不错（升职加薪😆）。&lt;/p&gt;

&lt;p&gt;并非专业，看看就好。有了解码的基础后，来编写信号生成代码就简单的了。我们只要将两个频率的波形生成出来，然后合并到一起，再按一定的间隔将多个信号摆放到PCM中即可；实际的代码也就是按这套逻辑写的，信号编码js源码：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/dtmf.encode.js&quot;&gt;dtmf.encode.js&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;41-mix：两个音频信号的混合&quot;&gt;4.1 Mix：两个音频信号的混合&lt;/h2&gt;
&lt;p&gt;不管是生成单个按键信号，还是将按键信号混合到语音PCM流中，都涉及到信号的混合这种操作，似乎又是一个高深的东西；要 IFFT 计算么？先不管如何复杂，先来一个简单的混音算法来用的试试看：&lt;code&gt;c = (a+b)/2&lt;/code&gt; 就这么简单粗暴，不过这个线性求平均值合成的声音杂音颇大。&lt;/p&gt;
&lt;p&gt;最后采用 &lt;code&gt;c = a + b - (a * b / ±0x7FFF)&lt;/code&gt;，混音后的音质非常好，来自&lt;a href=&quot;https://blog.csdn.net/dancing_night/article/details/53080819&quot;&gt;这篇&lt;/a&gt;文章，最终源码阅读上面 dtmf.encode.js 中的&lt;code&gt;Mix&lt;/code&gt;函数。&lt;/p&gt;
&lt;h2 id=&quot;42-生成单个按键信号&quot;&gt;4.2 生成单个按键信号&lt;/h2&gt;
&lt;p&gt;源码阅读上面 dtmf.encode.js 中的&lt;code&gt;Recorder.DTMF_Encode&lt;/code&gt;函数。比如要生成“1”键的信号，查表得到低频&lt;code&gt;697 hz&lt;/code&gt;、高频&lt;code&gt;1209 hz&lt;/code&gt;，然后分别生成两个频率的正弦波PCM信号，将两个PCM用&lt;code&gt;Mix&lt;/code&gt;函数混合到一起即可得到“1”键的信号。&lt;/p&gt;
&lt;p&gt;这个生成代码也是出奇的简单，不过受限于&lt;code&gt;Mix&lt;/code&gt;函数采用的简单混音算法，两个频率正弦波叠加后的杂波有点多，看上面【图1】两个最大的频率两边的杂波信号也非常强，不过还好并不影响识别。&lt;/p&gt;
&lt;h2 id=&quot;43-连续多个按键信号混合到语音pcm流中&quot;&gt;4.3 连续多个按键信号混合到语音PCM流中&lt;/h2&gt;
&lt;p&gt;这个才是实际实用的函数：上面 dtmf.encode.js 中的&lt;code&gt;EncodeMix.prototype.mix(pcms,sampleRate,index)&lt;/code&gt;，不管你一次性按下多少个按键，混音函数会按部就班的一个一个的混合到语音流中，并且保证按键之间的间隔能被解码程序正确识别。&lt;/p&gt;
&lt;p&gt;这个代码也算简单，总共做了两件事：延迟 + 调用&lt;code&gt;Mix&lt;/code&gt;函数，其中Mix调用实际是替换PCM并不是两个PCM混音。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;最后来个动图收尾吧：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMTUyNjY5LWZmMzczNGMwNWMzZmFiNjAuZ2lm&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;= 完 =&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jun 2020 18:54:00 +0000</pubDate>
<dc:creator>xiangyuecn</dc:creator>
<og:description>DTMF(Dual Tone Multi Frequency) 双音多频，由高频群和低频群组成，高低频群各包含4个频率；两个频率波形合成按键信号(0-9 * # A B C D)。 SIP中检测DTM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiangyuecn/p/13200894.html</dc:identifier>
</item>
</channel>
</rss>