<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【nodejs原理&amp;源码赏析（9）】用node-ssh实现轻量级自动化部署 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/11293667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/11293667.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201908/1354575-20190803082144716-2045753711.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2041884816754&quot;&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;http://www.github.com/dashnowords/blogs&quot; class=&quot;uri&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为云社区地址：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/8ae7e6420a4611e9bd5a7ca23e93a891&quot;&gt;【你要的前端打怪升级指南】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一.-需求描述&quot;&gt;一. 需求描述&lt;/h2&gt;
&lt;p&gt;前端工程出包后实现简易的自动化部署。&lt;/p&gt;
&lt;h2 id=&quot;二.-预备知识&quot;&gt;二. 预备知识&lt;/h2&gt;
&lt;p&gt;网站的建设可以使用任何自己熟悉的框架，三大框架都有自己的官方&lt;code&gt;Cli&lt;/code&gt;工具，从代码编写到生成可用于生产环境部署的包基本都有自动化命令，各个打包工具也在&lt;strong&gt;零配置&lt;/strong&gt;的追求上做了很多工作。本篇中从得到一个生产环境的包以后开始，对站点部署的相关知识进行一些介绍。&lt;/p&gt;
&lt;p&gt;首先你需要一个Web服务器，常见的有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Nginx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Apache&lt;/code&gt;或相关集成环境
&lt;ul&gt;&lt;li&gt;&lt;code&gt;XAMMP&lt;/code&gt;【&lt;code&gt;Apache&lt;/code&gt;+&lt;code&gt;MySQL&lt;/code&gt;+&lt;code&gt;PHP&lt;/code&gt;+&lt;code&gt;PERL&lt;/code&gt; 】&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LAMP&lt;/code&gt;【&lt;code&gt;Linux&lt;/code&gt;+&lt;code&gt;Apache&lt;/code&gt;+&lt;code&gt;MySQL&lt;/code&gt;+&lt;code&gt;PHP&lt;/code&gt;】&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nodejs&lt;/code&gt;或相关框架+守护进程
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Express&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Koa2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上任何一种在服务器上运行起来后都可以担任&lt;strong&gt;Web服务器&lt;/strong&gt;的角色，只是具备的扩展功能和应用场景有区别，&lt;code&gt;Nginx&lt;/code&gt;基本上是正式环境部署的首选方案。常见的基本部署方案如下：&lt;/p&gt;
&lt;h3 id=&quot;ip端口访问&quot;&gt;IP+端口访问&lt;/h3&gt;
&lt;p&gt;使用访问，可直接访问对应端口的服务，部署方式相对简单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201908/1354575-20190803082211675-691736354.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;域名访问&quot;&gt;域名访问&lt;/h3&gt;
&lt;p&gt;使用域名访问时，通常会使用A记录进行解析，它只能映射到80端口（https时映射到443），这时就需要使用反向代理将&lt;code&gt;80&lt;/code&gt;端口的请求分发到本地不同的内部端口来访问对应服务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201908/1354575-20190803082225163-1233988823.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本例中使用&lt;code&gt;域名+IP&lt;/code&gt;的方式进行部署。&lt;/p&gt;
&lt;h2 id=&quot;三.-nodejs应用的手动部署&quot;&gt;三. Nodejs应用的手动部署&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201908/1354575-20190803082238173-833981596.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;Express&lt;/code&gt;为例，步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先通过&lt;code&gt;yarn global add express-generator&lt;/code&gt;或&lt;code&gt;npm install express-generator -g&lt;/code&gt;全局安装脚手架&lt;/li&gt;
&lt;li&gt;完成后在工作目录通过命令行&lt;code&gt;express mydemo --ejs&lt;/code&gt;生成一个使用&lt;code&gt;ejs&lt;/code&gt;作为模板渲染引擎的&lt;code&gt;express&lt;/code&gt;工程&lt;/li&gt;
&lt;li&gt;命令行输入&lt;code&gt;cd mydemo &amp;amp;&amp;amp; yarn&lt;/code&gt;或&lt;code&gt;cd mydemo &amp;amp;&amp;amp; npm install&lt;/code&gt;安装依赖&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;/bin/www&lt;/code&gt;文件中修改端口号为期望的端口号（自动生成的是80端口），例如&lt;code&gt;3001&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将前端工程build出的包整体复制粘贴到&lt;code&gt;/public&lt;/code&gt;目录中&lt;/li&gt;
&lt;li&gt;此时在本地工程根目录下输入&lt;code&gt;npm start&lt;/code&gt;后，在浏览器中&lt;code&gt;http://localhost:3001&lt;/code&gt;就可以访问到网站了&lt;/li&gt;
&lt;li&gt;使用FTP工具(如&lt;code&gt;FlashFxp&lt;/code&gt;或&lt;code&gt;FileZilla Client&lt;/code&gt;等)连接到部署机器，将&lt;code&gt;mydemo&lt;/code&gt;目录压缩为&lt;code&gt;zip&lt;/code&gt;包后上传到服务器指定目录。&lt;/li&gt;
&lt;li&gt;使用SSH工具(如&lt;code&gt;Xshell&lt;/code&gt;或&lt;code&gt;MobaXter&lt;/code&gt;)登录远程机器，假设为&lt;code&gt;linux&lt;/code&gt;系统，输入&lt;code&gt;unzip mydemo.zip&lt;/code&gt;解压压缩包，然后&lt;code&gt;cd mydemo&lt;/code&gt;进入服务端工程，输入&lt;code&gt;npm start&lt;/code&gt;即可在服务器上开启Web服务，通过&lt;code&gt;ip地址:3001&lt;/code&gt;就可以访问到网站。&lt;/li&gt;
&lt;li&gt;但是如果此时&lt;code&gt;SSH&lt;/code&gt;工具断开连接，就会发现&lt;code&gt;express&lt;/code&gt;应用无法继续访问了，所以还需要一个守护进程来维持应用的启动状态，在服务端通过&lt;code&gt;npm install pm2 -g&lt;/code&gt;来安装&lt;code&gt;nodejs&lt;/code&gt;应用的部署管理模块，它可以实现多应用管理、Hook更新、自动重启等等许多常用功能，详细信息可以访问 &lt;a href=&quot;http://pm2.keymetrics.io/&quot;&gt;【PM2官方网站】&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;最后，在工程根目录输入&lt;code&gt;pm2 start ./bin/www&lt;/code&gt;即可以后台模式运行应用。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四.-基于nodejs的自动部署&quot;&gt;四. 基于nodejs的自动部署&lt;/h2&gt;
&lt;h3 id=&quot;package.json中的scripts&quot;&gt;4.1 package.json中的scripts&lt;/h3&gt;
&lt;p&gt;了解了手动部署的过程后，就可以通过自动化脚本来实现后续的更新和部署。&lt;code&gt;nodejs&lt;/code&gt;工程的自动化是依赖于&lt;code&gt;package.json&lt;/code&gt;文件中的&lt;code&gt;scripts&lt;/code&gt;配置项来实现的，例如使用&lt;code&gt;vue-cli&lt;/code&gt;搭建的工程中就会带有：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    ...
    &quot;scripts&quot;: {
        &quot;serve&quot;: &quot;vue-cli-service serve&quot;,
        &quot;build&quot;: &quot;vue-cli-service build&quot;,
        &quot;lint&quot;: &quot;vue-cli-service lint&quot;
      },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在项目根目录下打开命令行，输入&lt;code&gt;npm run [script-key]&lt;/code&gt;或者&lt;code&gt;yarn [script-key]&lt;/code&gt;（&lt;code&gt;[script-key]&lt;/code&gt;指上面示例中的serve,build,lint这些键名），就会执行对应的&lt;code&gt;scripts[key]&lt;/code&gt;对应的命令。我们先添加一条用于自动部署的脚本指令:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    ...
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;vue-cli-service build&quot;,
        &quot;deploy&quot; &quot;node ./scripts/deploy/deploy.js&quot;
      },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当输入&lt;code&gt;npm run deploy&lt;/code&gt;或&lt;code&gt;yarn deploy&lt;/code&gt;时，实际上就相当于用node去执行&lt;code&gt;./scripts/deploy/deploy.js&lt;/code&gt;这个脚本，其中就编写了自动化发布的指令。&lt;code&gt;scripts&lt;/code&gt;还提供了生命周期钩子，比如你对接的是一个测试环境，希望每次build后自动发布，就可以使用&lt;strong&gt;post&lt;/strong&gt;钩子来实现：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    ...
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;vue-cli-service build&quot;,
        &quot;postbuild&quot;:&quot;npm run deploy&quot;,
        &quot;deploy&quot; &quot;node ./scripts/deploy/deploy.js&quot;
      },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样每次build执行完毕后，就会自动执行&lt;code&gt;npm run deploy&lt;/code&gt;，也就是运行发布的脚本。&lt;/p&gt;
&lt;h3 id=&quot;自动化发布脚本deploy.js&quot;&gt;4.2 自动化发布脚本deploy.js&lt;/h3&gt;
&lt;p&gt;自动化发布脚本需要完成这样几个任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将打包出的&lt;code&gt;dist&lt;/code&gt;压缩为&lt;code&gt;zip&lt;/code&gt;包&lt;/li&gt;
&lt;li&gt;使用SSH连接部署服务器，将&lt;code&gt;zip&lt;/code&gt;包发上去&lt;/li&gt;
&lt;li&gt;上传完毕后，启动事先写好后续任务并放在服务器上的&lt;code&gt;shell&lt;/code&gt;脚本来完成剩余的工作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;涉及的几个模块包括实现SSH连接的&lt;code&gt;node-ssh&lt;/code&gt;模块（底层是&lt;code&gt;ssh2&lt;/code&gt;模块，这个模块是一个Promise封装），用于制作&lt;code&gt;zip&lt;/code&gt;压缩包的&lt;code&gt;archiver&lt;/code&gt;模块。&lt;code&gt;node-ssh&lt;/code&gt;提供了上传本地目录的方法，但实际使用过程中发现并不稳定，从告警信息来看是&lt;code&gt;node-stream&lt;/code&gt;模块在传送时将不同格式的文件转换为流时可能会出现异常，实测大约有一半概率触发，尝试修改了一些配置参数并未解决，所以采用&lt;code&gt;archiver&lt;/code&gt;模块先压缩为单个文件后再进行上传。&lt;/p&gt;
&lt;p&gt;参考代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const path = require('path');
const archiver =require('archiver');
const fs = require('fs');
const node_ssh = require('node-ssh');
const ssh = new node_ssh();
const srcPath = path.resolve(__dirname,'../../dist');
const configs = require('./config');

console.log('开始压缩dist目录...');
startZip();

//压缩dist目录为public.zip
function startZip() {
    var archive = archiver('zip', {
        zlib: { level: 5 } //递归扫描最多5层
    }).on('error', function(err) {
        throw err;//压缩过程中如果有错误则抛出
    });
    
    var output = fs.createWriteStream(__dirname + '/public.zip')
     .on('close', function(err) {
         /*压缩结束时会触发close事件，然后才能开始上传，
           否则会上传一个内容不全且无法使用的zip包*/
         if (err) {
            console.log('关闭archiver异常:',err);
            return;
         }
         console.log('已生成zip包');
         console.log('开始上传public.zip至远程机器...');
         uploadFile();
     });

    archive.pipe(output);//典型的node流用法
    archive.directory(srcPath,'/public');//将srcPach路径对应的内容添加到zip包中/public路径
    archive.finalize();
}

//将dist目录上传至正式环境
function uploadFile() {
    ssh.connect({ //configs存放的是连接远程机器的信息
        host: configs.host,
        username: configs.user,
        password: configs.password,
        port:22 //SSH连接默认在22端口
    }).then(function () {
        //上传网站的发布包至configs中配置的远程服务器的指定地址
        ssh.putFile(__dirname + '/public.zip', configs.path).then(function(status) {
                console.log('上传文件成功');
                console.log('开始执行远端脚本');
                startRemoteShell();//上传成功后触发远端脚本
          }).catch(err=&amp;gt;{
             console.log('文件传输异常:',err);
             process.exit(0);
          });
    }).catch(err=&amp;gt;{
        console.log('ssh连接失败:',err);
        process.exit(0);
    });
}

//执行远端部署脚本
function startRemoteShell() {
    //在服务器上cwd配置的路径下执行sh deploy.sh脚本来实现发布
    ssh.execCommand('sh deploy.sh', { cwd:'/usr/bin/XXXXX' }).then(function(result) {
        console.log('远程STDOUT输出: ' + result.stdout)
        console.log('远程STDERR输出: ' + result.stderr)
        if (!result.stderr){
            console.log('发布成功!');
            process.exit(0);
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;远端脚本deploy.sh&quot;&gt;4.3 远端脚本deploy.sh&lt;/h3&gt;
&lt;p&gt;当发布包上传至远程服务器后，剩余的工作在远端来完成就可以了，你只需要将后续的工作写进&lt;code&gt;shell&lt;/code&gt;脚本并放在对应的目录里就可以了，本例中&lt;code&gt;deploy.sh&lt;/code&gt;放在了服务端项目目录&lt;code&gt;/mydemo&lt;/code&gt;中。示例如下（由于是自用系统，不考虑灰度发布等，直接暴力删除静态目录public,然后替换为新的包）：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;#!/bin/bash
cd /usr1/AAA/mydemo
#删除原静态资源目录
rm -rf public
cd /usr1/AAA
#解压新的包
unzip public.zip
#将解压出的public目录移动到服务端程序目录BBB中
mv public ./mydemo&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;如果脚本文件是在windows下编写的，请注意将编辑器中的回车换行改为&lt;code&gt;LF&lt;/code&gt;，windows下通常默认是&lt;code&gt;CRLF&lt;/code&gt;，这可能会导致脚本在linux机器上无法正常执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至此，一个简易的自动化部署就做完了。你只需要在本地输入&lt;code&gt;npm run deploy&lt;/code&gt;，后续的工作就会自动执行。&lt;/p&gt;
&lt;h2 id=&quot;五.-小结&quot;&gt;五. 小结&lt;/h2&gt;
&lt;p&gt;本篇只是一个简易的自动化部署流程，由于部署环境没有外网所以暂时无法借助通用的自动化流水线实现全自动的&lt;code&gt;DevOps&lt;/code&gt;流程。&lt;code&gt;PM2&lt;/code&gt;实际上还有非常多实用的功能，可以管理多个不同的应用实例，以集群模式运行实例，或者预设发布流程，可以直接响应&lt;code&gt;Web Hook&lt;/code&gt;并对接指定的代码仓，在根目录下建立&lt;code&gt;ecosystem.config.js&lt;/code&gt;配置文件就可以添加更多配置来指定&lt;code&gt;pm2&lt;/code&gt;的表现，感兴趣的读者可以研究一下。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Aug 2019 00:24:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>示例代码托管在： 'http://www.github.com/dashnowords/blogs' 博客园地址： '《大史住在大前端》原创博文目录' 华为云社区地址： '【你要的前端打怪升级指南】'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dashnowords/p/11293667.html</dc:identifier>
</item>
<item>
<title>spark shuffle写操作之BypassMergeSortShuffleWriter - 匠心源码</title>
<link>http://www.cnblogs.com/johnny666888/p/11291592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/johnny666888/p/11291592.html</guid>
<description>[unable to retrieve full-text content]前言 再上一篇文章 spark shuffle的写操作之准备工作 中，主要介绍了 spark shuffle的准备工作，本篇文章主要介绍spark shuffle使用BypassMergeSortShuffleWriter写数据详细细节。 在本篇文章中如果有不了解的术语，也可以参照 spark sh</description>
<pubDate>Fri, 02 Aug 2019 23:00:00 +0000</pubDate>
<dc:creator>匠心源码</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com/signin?ReturnUrl=https%3a%2f%2fwww.cnblogs.com%2fjohnny666888%2fp%2f11291592.html</dc:identifier>
</item>
<item>
<title>RocketMQ中NameServer的启动 - 松饼人</title>
<link>http://www.cnblogs.com/a526583280/p/11291564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/a526583280/p/11291564.html</guid>
<description>&lt;p&gt;在RocketMQ中，使用NamesrvStartup作为启动类&lt;/p&gt;

&lt;p&gt;主函数作为其启动的入口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    main0(args);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;main0方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; NamesrvController main0(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         NamesrvController controller =&lt;span&gt; createNamesrvController(args);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        start(controller);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         String tip = &quot;The Name Server boot success. serializeType=&quot; +&lt;span&gt; RemotingCommand.getSerializeTypeConfigInThisServer();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        log.info(tip);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.printf(&quot;%s%n&quot;&lt;span&gt;, tip);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; controller;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.exit(-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;首先通过createNamesrvController方法生成NameServer的控制器NamesrvController&lt;/p&gt;
&lt;p&gt;createNamesrvController方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; NamesrvController createNamesrvController(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, JoranException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PackageConflictDetect.detectFastjson();&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     Options options = ServerUtil.buildCommandlineOptions(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Options());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     commandLine = ServerUtil.parseCmdLine(&quot;mqnamesrv&quot;, args, buildCommandlineOptions(options), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PosixParser());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; commandLine) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.exit(-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; NamesrvConfig namesrvConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NamesrvConfig();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; NettyServerConfig nettyServerConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyServerConfig();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     nettyServerConfig.setListenPort(9876&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (commandLine.hasOption('c'&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         String file = commandLine.getOptionValue('c'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (file != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             InputStream in = &lt;span&gt;new&lt;/span&gt; BufferedInputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(file));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             properties = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            properties.load(in);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            MixAll.properties2Object(properties, namesrvConfig);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            MixAll.properties2Object(properties, nettyServerConfig);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            namesrvConfig.setConfigStorePath(file);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             System.out.printf(&quot;load config properties file OK, %s%n&quot;&lt;span&gt;, file);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            in.close();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (commandLine.hasOption('p'&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         InternalLogger console =&lt;span&gt; InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        MixAll.printObjectProperties(console, namesrvConfig);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        MixAll.printObjectProperties(console, nettyServerConfig);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         System.exit(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; namesrvConfig.getRocketmqHome()) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         System.out.printf(&quot;Please set the %s variable in your environment to match the location of the RocketMQ installation%n&quot;&lt;span&gt;, MixAll.ROCKETMQ_HOME_ENV);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         System.exit(-2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     LoggerContext lc =&lt;span&gt; (LoggerContext) LoggerFactory.getILoggerFactory();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     JoranConfigurator configurator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JoranConfigurator();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    configurator.setContext(lc);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    lc.reset();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     configurator.doConfigure(namesrvConfig.getRocketmqHome() + &quot;/conf/logback_namesrv.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     log =&lt;span&gt; InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    MixAll.printObjectProperties(log, namesrvConfig);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    MixAll.printObjectProperties(log, nettyServerConfig);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; NamesrvController controller = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NamesrvController(namesrvConfig, nettyServerConfig);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; remember all configs to prevent discard&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    controller.getConfiguration().registerConfig(properties);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; controller;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里创建了两个实体类NamesrvConfig和NettyServerConfig&lt;br/&gt;这两个实体类对应了其配置文件中的配置&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;NamesrvConfig：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String rocketmqHome =&lt;span&gt; System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String kvConfigPath = System.getProperty(&quot;user.home&quot;) + File.separator + &quot;namesrv&quot; + File.separator + &quot;kvConfig.json&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String configStorePath = System.getProperty(&quot;user.home&quot;) + File.separator + &quot;namesrv&quot; + File.separator + &quot;namesrv.properties&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String productEnvName = &quot;center&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; clusterTest = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; orderMessageEnable = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;NettyServerConfig：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; listenPort = 8888&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; serverWorkerThreads = 8&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; serverCallbackExecutorThreads = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; serverSelectorThreads = 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; serverOnewaySemaphoreValue = 256&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; serverAsyncSemaphoreValue = 64&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; serverChannelMaxIdleTimeSeconds = 120&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; serverSocketSndBufSize = NettySystemConfig.socketSndbufSize &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 65535;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 65535;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; serverPooledByteBufAllocatorEnable = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;对应如下配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;##
# 名称：NamesrvConfig.rocketmqHome &amp;lt;String&amp;gt;
# 默认值：(通过 sh mqnamesrv 设置 ROCKETMQ_HOME 环境变量，在源程序中获取环境变量得
#        到的目录)
# 描述：RocketMQ 主目录 
# 建议：不主动配置
##
rocketmqHome = /usr/rocketmq

##
# 名称：NamesrvConfig.kvConfigPath &amp;lt;String&amp;gt;
# 默认值：$user.home/namesrv/kvConfig.json &amp;lt;在源程序中获取用户环境变量后生成&amp;gt;
# 描述：kv 配置文件路径，包含顺序消息主题的配置信息 
# 建议：启用顺序消息时配置
##
kvConfigPath = /root/namesrv/kvConfig.json

##
# 名称：NamesrvConfig.configStorePath &amp;lt;String&amp;gt;
# 默认值：$user.home/namesrv/namesrv.properties &amp;lt;在源程序中获取用户环境变量后生成&amp;gt;
# 描述：NameServer 配置文件路径
# 建议：启动时通过 -c 指定
##
configStorePath = /root/namesrv/namesrv.properties

##
# 名称：NamesrvConfig.clusterTest &amp;lt;boolean&amp;gt;
# 默认值：false &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：是否开启集群测试
# 建议：不主动配置
##
clusterTest = false

##
# 名称：NamesrvConfig.orderMessageEnable &amp;lt;boolean&amp;gt;
# 默认值：false &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：是否支持顺序消息
# 建议：启用顺序消息时配置
##
orderMessageEnable = false

##
# 名称：NettyServerConfig.listenPort &amp;lt;int&amp;gt;
# 默认值：&lt;/span&gt;9876&lt;span&gt; &amp;lt;在源程序中初始化后单独设置&amp;gt;
# 描述：服务端监听端口
# 建议：不主动配置
##
listenPort = &lt;/span&gt;9876&lt;span&gt;

##
# 名称：NettyServerConfig.serverWorkerThreads &amp;lt;int&amp;gt;
# 默认值：&lt;/span&gt;8&lt;span&gt; &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：Netty 业务线程池线程个数
# 建议：不主动配置
##
serverWorkerThreads = &lt;/span&gt;8&lt;span&gt;

##
# 名称：NettyServerConfig.serverCallbackExecutorThreads &amp;lt;int&amp;gt;
# 默认值：&lt;/span&gt;0&lt;span&gt; &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：Netty public 任务线程池线程个数，Netty 网络设计，根据业务类型会创建不同的线程池，比如处理发送消息、消息消费、心跳检测等。如果该业务类型(RequestCode)未注册线程池，则由 public 线程池执行
# 建议：
##
serverCallbackExecutorThreads = &lt;/span&gt;0&lt;span&gt;

##
# 名称：NettyServerConfig.serverSelectorThreads &amp;lt;int&amp;gt;
# 默认值：&lt;/span&gt;3&lt;span&gt; &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：IO 线程池线程个数，主要是 NameServer、Broker 端解析请求、返回响应的线程个数，这类线程池主要是处理网络请求的，解析请求包，然后转发到各个业务线程池完成具体的业务操作，然后将结果再返回调用方
# 建议：不主动配置
##
serverSelectorThreads = &lt;/span&gt;3&lt;span&gt;

##
# 名称：NettyServerConfig.serverOnewaySemaphoreValue &amp;lt;int&amp;gt;
# 默认值：&lt;/span&gt;256&lt;span&gt; &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：send oneway 消息请求并发度
# 建议：不主动配置
##
serverOnewaySemaphoreValue = &lt;/span&gt;256&lt;span&gt;

##
# 名称：NettyServerConfig.serverAsyncSemaphoreValue &amp;lt;int&amp;gt;
# 默认值：&lt;/span&gt;64&lt;span&gt; &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：异步消息发送最大并发度
# 建议：不主动配置
##
serverAsyncSemaphoreValue = &lt;/span&gt;64&lt;span&gt;

##
# 名称：NettyServerConfig.serverChannelMaxIdleTimeSeconds &amp;lt;int&amp;gt;
# 默认值：&lt;/span&gt;120&lt;span&gt; &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：网络连接最大空闲时间，单位秒，如果连接空闲时间超过该参数设置的值，连接将被关闭
# 建议：不主动配置
##
serverChannelMaxIdleTimeSeconds = &lt;/span&gt;120&lt;span&gt;

##
# 名称：NettyServerConfig.serverSocketSndBufSize &amp;lt;int&amp;gt;
# 默认值：&lt;/span&gt;65535&lt;span&gt; &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：网络 socket 发送缓存区大小，单位 B，即默认为 64KB
# 建议：不主动配置
##
serverSocketSndBufSize = &lt;/span&gt;65535&lt;span&gt;

##
# 名称：NettyServerConfig.serverSocketRcvBufSize &amp;lt;int&amp;gt;
# 默认值：&lt;/span&gt;65535&lt;span&gt; &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：网络 socket 接收缓存区大小，单位 B，即默认为 64KB
# 建议：不主动配置
##
serverSocketRcvBufSize = &lt;/span&gt;65535&lt;span&gt;

##
# 名称：NettyServerConfig.serverPooledByteBufAllocatorEnable &amp;lt;int&amp;gt;
# 默认值：true &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：ByteBuffer 是否开启缓存，建议开启
# 建议：不主动配置
##
serverPooledByteBufAllocatorEnable = true

##
# 名称：NettyServerConfig.useEpollNativeSelector &amp;lt;int&amp;gt;
# 默认值：false &amp;lt;在源程序中初始化字段时指定&amp;gt;
# 描述：是否启用 Epoll IO 模型
# 建议：Linux 环境开启
##
useEpollNativeSelector = true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;接下来是对‘-c’命令下配置文件的加载，以及‘-p’命令下namesrvConfig和nettyServerConfig属性的打印&lt;br/&gt;后续是对日志的一系列配置&lt;/p&gt;
&lt;p&gt;在完成这些后，会根据namesrvConfig和nettyServerConfig创建NamesrvController实例&lt;/p&gt;
&lt;p&gt;NamesrvController：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; NamesrvController(NamesrvConfig namesrvConfig, NettyServerConfig nettyServerConfig) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.namesrvConfig =&lt;span&gt; namesrvConfig;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.nettyServerConfig =&lt;span&gt; nettyServerConfig;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.kvConfigManager = &lt;span&gt;new&lt;/span&gt; KVConfigManager(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.routeInfoManager = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RouteInfoManager();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerHousekeepingService = &lt;span&gt;new&lt;/span&gt; BrokerHousekeepingService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.configuration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        log,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.namesrvConfig, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nettyServerConfig
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.configuration.setStorePathFromConfig(&lt;span&gt;this&lt;/span&gt;.namesrvConfig, &quot;configStorePath&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到这里创建了一个KVConfigManager和一个RouteInfoManager&lt;/p&gt;

&lt;p&gt;KVConfigManager：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KVConfigManager {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; NamesrvController namesrvController;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Namespace &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, HashMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Key &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Value &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&amp;gt;&amp;gt; configTable =
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, HashMap&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; KVConfigManager(NamesrvController namesrvController) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.namesrvController =&lt;span&gt; namesrvController;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;KVConfigManager通过建立configTable管理KV&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;RouteInfoManager：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouteInfoManager {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; topic &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, List&amp;lt;QueueData&amp;gt;&amp;gt;&lt;span&gt; topicQueueTable;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; brokerName &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, BrokerData&amp;gt;&lt;span&gt; brokerAddrTable;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; clusterName &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, Set&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; brokerName &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; clusterAddrTable;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; brokerAddr &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, BrokerLiveInfo&amp;gt;&lt;span&gt; brokerLiveTable;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; brokerAddr &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, List&amp;lt;String&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Filter Server &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&amp;gt;&lt;span&gt; filterServerTable;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; BROKER_CHANNEL_EXPIRED_TIME = 1000 * 60 * 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RouteInfoManager() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.topicQueueTable = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, List&amp;lt;QueueData&amp;gt;&amp;gt;(1024&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerAddrTable = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, BrokerData&amp;gt;(128&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.clusterAddrTable = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt;(32&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.brokerLiveTable = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, BrokerLiveInfo&amp;gt;(256&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.filterServerTable = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;(256&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RouteInfoManager则记录了这些路由信息，其中BROKER_CHANNEL_EXPIRED_TIME 表示允许的不活跃的Broker存活时间&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在NamesrvController中还创建了一个BrokerHousekeepingService：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BrokerHousekeepingService &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ChannelEventListener {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; InternalLogger log =&lt;span&gt; InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; NamesrvController namesrvController;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BrokerHousekeepingService(NamesrvController namesrvController) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.namesrvController =&lt;span&gt; namesrvController;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChannelConnect(String remoteAddr, Channel channel) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChannelClose(String remoteAddr, Channel channel) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChannelException(String remoteAddr, Channel channel) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChannelIdle(String remoteAddr, Channel channel) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到这是一个ChannelEventListener，用来处理Netty的中的异步事件监听&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在创建完NamesrvController后，回到main0，调用start方法，真正开启NameServer服务&lt;/p&gt;
&lt;p&gt;start方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; NamesrvController start(&lt;span&gt;final&lt;/span&gt; NamesrvController controller) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; controller) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;NamesrvController is null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; initResult =&lt;span&gt; controller.initialize();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;initResult) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        controller.shutdown();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.exit(-3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     Runtime.getRuntime().addShutdownHook(&lt;span&gt;new&lt;/span&gt; ShutdownHookThread(log, &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Void&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Void call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            controller.shutdown();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    controller.start();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; controller;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先调用NamesrvController的initialize方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; initialize() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.kvConfigManager.load();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingServer = &lt;span&gt;new&lt;/span&gt; NettyRemotingServer(&lt;span&gt;this&lt;/span&gt;.nettyServerConfig, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerHousekeepingService);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.remotingExecutor =
&lt;span&gt; 7&lt;/span&gt;         Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), &lt;span&gt;new&lt;/span&gt; ThreadFactoryImpl(&quot;RemotingExecutorThread_&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registerProcessor();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             NamesrvController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.routeInfoManager.scanNotActiveBroker();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }, 5, 10&lt;span&gt;, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.scheduledExecutorService.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             NamesrvController.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.kvConfigManager.printAllPeriodically();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }, 1, 10&lt;span&gt;, TimeUnit.MINUTES);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (TlsSystemConfig.tlsMode !=&lt;span&gt; TlsMode.DISABLED) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register a listener to reload SslContext&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             fileWatchService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileWatchService(
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[] {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    TlsSystemConfig.tlsServerCertPath,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    TlsSystemConfig.tlsServerKeyPath,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    TlsSystemConfig.tlsServerTrustCertPath
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                },
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileWatchService.Listener() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;boolean&lt;/span&gt; certChanged, keyChanged = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChanged(String path) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                             log.info(&quot;The trust certificate changed, reload the ssl context&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                            reloadServerSslContext();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (path.equals(TlsSystemConfig.tlsServerCertPath)) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                             certChanged = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (path.equals(TlsSystemConfig.tlsServerKeyPath)) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                             keyChanged = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (certChanged &amp;amp;&amp;amp;&lt;span&gt; keyChanged) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                             log.info(&quot;The certificate and private key changed, reload the ssl context&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                             certChanged = keyChanged = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                            reloadServerSslContext();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reloadServerSslContext() {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                        ((NettyRemotingServer) remotingServer).loadSslContext();
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             log.warn(&quot;FileWatchService created error, can't load the certificate dynamically&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先通过kvConfigManager的load方法，向KVConfigManager中的map加载之前配置好的KV文件路径下的键值对&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; load() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     String content = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         content = MixAll.file2String(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.namesrvController.getNamesrvConfig().getKvConfigPath());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         log.warn(&quot;Load KV config table exception&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (content != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         KVConfigSerializeWrapper kvConfigSerializeWrapper =
&lt;span&gt;10&lt;/span&gt;             KVConfigSerializeWrapper.fromJson(content, KVConfigSerializeWrapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; kvConfigSerializeWrapper) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.configTable.putAll(kvConfigSerializeWrapper.getConfigTable());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             log.info(&quot;load KV config table OK&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法比较简单，将JSON形式的KV文件包装成KVConfigSerializeWrapper，通过getConfigTable方法转换成map放在configTable中&lt;/p&gt;

&lt;p&gt;完成KV加载后，建立了一个NettyRemotingServer，即Netty服务器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; NettyRemotingServer(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; NettyServerConfig nettyServerConfig,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ChannelEventListener channelEventListener) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(nettyServerConfig.getServerOnewaySemaphoreValue(), nettyServerConfig.getServerAsyncSemaphoreValue());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.serverBootstrap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerBootstrap();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.nettyServerConfig =&lt;span&gt; nettyServerConfig;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.channelEventListener =&lt;span&gt; channelEventListener;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; publicThreadNums =&lt;span&gt; nettyServerConfig.getServerCallbackExecutorThreads();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (publicThreadNums &amp;lt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         publicThreadNums = 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.publicExecutor = Executors.newFixedThreadPool(publicThreadNums, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; AtomicInteger threadIndex = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Thread(r, &quot;NettyServerPublicExecutor_&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.threadIndex.incrementAndGet());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (useEpoll()) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.eventLoopGroupBoss = &lt;span&gt;new&lt;/span&gt; EpollEventLoopGroup(1, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; AtomicInteger threadIndex = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Thread(r, String.format(&quot;NettyEPOLLBoss_%d&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.threadIndex.incrementAndGet()));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.eventLoopGroupSelector = &lt;span&gt;new&lt;/span&gt; EpollEventLoopGroup(nettyServerConfig.getServerSelectorThreads(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory() {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; AtomicInteger threadIndex = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadTotal =&lt;span&gt; nettyServerConfig.getServerSelectorThreads();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Thread(r, String.format(&quot;NettyServerEPOLLSelector_%d_%d&quot;, threadTotal, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.threadIndex.incrementAndGet()));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.eventLoopGroupBoss = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(1, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory() {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; AtomicInteger threadIndex = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Thread(r, String.format(&quot;NettyNIOBoss_%d&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.threadIndex.incrementAndGet()));
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.eventLoopGroupSelector = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(nettyServerConfig.getServerSelectorThreads(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory() {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; AtomicInteger threadIndex = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadTotal =&lt;span&gt; nettyServerConfig.getServerSelectorThreads();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Thread(r, String.format(&quot;NettyServerNIOSelector_%d_%d&quot;, threadTotal, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.threadIndex.incrementAndGet()));
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    loadSslContext();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里创建了ServerBootstrap&lt;br/&gt;channelEventListener就是刚才创建的BrokerHousekeepingService&lt;/p&gt;
&lt;p&gt;然后根据是否使用epoll，选择创建两个合适的EventLoopGroup&lt;/p&gt;
&lt;p&gt;创建完成后，通过loadSslContext完成对SSL和TLS的设置&lt;/p&gt;

&lt;p&gt;回到initialize方法，在创建完Netty的服务端后，调用registerProcessor方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerProcessor() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (namesrvConfig.isClusterTest()) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.remotingServer.registerDefaultProcessor(&lt;span&gt;new&lt;/span&gt; ClusterTestRequestProcessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, namesrvConfig.getProductEnvName()),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remotingExecutor);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.remotingServer.registerDefaultProcessor(&lt;span&gt;new&lt;/span&gt; DefaultRequestProcessor(&lt;span&gt;this&lt;/span&gt;), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remotingExecutor);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里和是否设置了clusterTest集群测试有关，默认关闭&lt;/p&gt;

&lt;p&gt;在默认情况下创建了DefaultRequestProcessor，这个类很重要，后面会详细说明，然后通过remotingServer的registerDefaultProcessor方法，将DefaultRequestProcessor注册给Netty服务器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerDefaultProcessor(NettyRequestProcessor processor, ExecutorService executor) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.defaultRequestProcessor = &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;NettyRequestProcessor, ExecutorService&amp;gt;&lt;span&gt;(processor, executor);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在做完这些后，提交了两个定时任务&lt;br/&gt;①定时清除不活跃的Broker&lt;br/&gt;RouteInfoManager的scanNotActiveBroker方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; scanNotActiveBroker() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Iterator&amp;lt;Entry&amp;lt;String, BrokerLiveInfo&amp;gt;&amp;gt; it = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerLiveTable.entrySet().iterator();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Entry&amp;lt;String, BrokerLiveInfo&amp;gt; next =&lt;span&gt; it.next();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; last =&lt;span&gt; next.getValue().getLastUpdateTimestamp();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((last + BROKER_CHANNEL_EXPIRED_TIME) &amp;lt;&lt;span&gt; System.currentTimeMillis()) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            RemotingUtil.closeChannel(next.getValue().getChannel());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            it.remove();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             log.warn(&quot;The broker channel expired, {} {}ms&quot;&lt;span&gt;, next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onChannelDestroy(next.getKey(), next.getValue().getChannel());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里比较简单，在之前RouteInfoManager中创建的brokerLiveTable表中遍历所有BrokerLiveInfo，找到超出规定时间BROKER_CHANNEL_EXPIRED_TIME的BrokerLiveInfo信息进行删除，同时关闭Channel&lt;br/&gt;而onChannelDestroy方法，会对其他几张表进行相关联的删除工作，代码重复量大就不细说了&lt;/p&gt;

&lt;p&gt;BrokerLiveInfo记录了Broker的活跃度信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; lastUpdateTimestamp;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; DataVersion dataVersion;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Channel channel;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String haServerAddr;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lastUpdateTimestamp记录上一次更新时间戳，是其活跃性的关键&lt;/p&gt;

&lt;p&gt;②定时完成configTable的日志记录&lt;br/&gt;KVConfigManager的printAllPeriodically方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printAllPeriodically() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lock.readLock().lockInterruptibly();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             log.info(&quot;--------------------------------------------------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 log.info(&quot;configTable SIZE: {}&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.configTable.size());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 Iterator&amp;lt;Entry&amp;lt;String, HashMap&amp;lt;String, String&amp;gt;&amp;gt;&amp;gt; it =
&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.configTable.entrySet().iterator();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     Entry&amp;lt;String, HashMap&amp;lt;String, String&amp;gt;&amp;gt; next =&lt;span&gt; it.next();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     Iterator&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; itSub =&lt;span&gt; next.getValue().entrySet().iterator();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (itSub.hasNext()) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                         Entry&amp;lt;String, String&amp;gt; nextSub =&lt;span&gt; itSub.next();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         log.info(&quot;configTable NS: {} Key: {} Value: {}&quot;&lt;span&gt;, next.getKey(), nextSub.getKey(),
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                            nextSub.getValue());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lock.readLock().unlock();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         log.error(&quot;printAllPeriodically InterruptedException&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单，根据configTable表的内容，完成KV的日志记录&lt;/p&gt;

&lt;p&gt;在创建完这两个定时任务后会注册一个侦听器，以便完成SslContext的重新加载&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;initialize随之结束，之后是对关闭事件的处理&lt;/p&gt;

&lt;p&gt;最后调用NamesrvController的start，此时才是真正的开启物理上的服务&lt;br/&gt;NamesrvController的start方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remotingServer.start();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.fileWatchService != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fileWatchService.start();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里实际上就是开启的Netty服务端&lt;/p&gt;

&lt;p&gt;NettyRemotingServer的start方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.defaultEventExecutorGroup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultEventExecutorGroup(
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        nettyServerConfig.getServerWorkerThreads(),
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; AtomicInteger threadIndex = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Thread(r, &quot;NettyServerCodecThread_&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.threadIndex.incrementAndGet());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     ServerBootstrap childHandler =
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.serverBootstrap.group(&lt;span&gt;this&lt;/span&gt;.eventLoopGroupBoss, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventLoopGroupSelector)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             .channel(useEpoll() ? EpollServerSocketChannel.&lt;span&gt;class&lt;/span&gt; : NioServerSocketChannel.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             .option(ChannelOption.SO_BACKLOG, 1024&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             .option(ChannelOption.SO_REUSEADDR, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             .option(ChannelOption.SO_KEEPALIVE, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             .childOption(ChannelOption.TCP_NODELAY, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            .childOption(ChannelOption.SO_SNDBUF, nettyServerConfig.getServerSocketSndBufSize())
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            .childOption(ChannelOption.SO_RCVBUF, nettyServerConfig.getServerSocketRcvBufSize())
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             .localAddress(&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nettyServerConfig.getListenPort()))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             .childHandler(&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initChannel(SocketChannel ch) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    ch.pipeline()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                        .addLast(defaultEventExecutorGroup, HANDSHAKE_HANDLER_NAME,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HandshakeHandler(TlsSystemConfig.tlsMode))
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                        .addLast(defaultEventExecutorGroup,
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyEncoder(),
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyDecoder(),
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                             &lt;span&gt;new&lt;/span&gt; IdleStateHandler(0, 0&lt;span&gt;, nettyServerConfig.getServerChannelMaxIdleTimeSeconds()),
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyConnectManageHandler(),
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyServerHandler()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                        );
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (nettyServerConfig.isServerPooledByteBufAllocatorEnable()) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        childHandler.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         ChannelFuture sync = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serverBootstrap.bind().sync();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         InetSocketAddress addr =&lt;span&gt; (InetSocketAddress) sync.channel().localAddress();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.port =&lt;span&gt; addr.getPort();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e1) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;this.serverBootstrap.bind().sync() InterruptedException&quot;&lt;span&gt;, e1);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.channelEventListener != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nettyEventExecutor.start();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.timer.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 NettyRemotingServer.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.scanResponseTable();
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 log.error(&quot;scanResponseTable exception&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     }, 1000 * 3, 1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到也就是正常的Netty服务端启动流程&lt;/p&gt;

&lt;p&gt;关键在于在childHandler的绑定中，可以看到向pipeline绑定了一个NettyServerHandler：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NettyServerHandler &lt;span&gt;extends&lt;/span&gt; SimpleChannelInboundHandler&amp;lt;RemotingCommand&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        processMessageReceived(ctx, msg);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么当客户端和NameServre端建立连接后，之间传输的消息会通过processMessageReceived方法进行处理&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;processMessageReceived方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; processMessageReceived(ChannelHandlerContext ctx, RemotingCommand msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;        &lt;span&gt;final&lt;/span&gt; RemotingCommand cmd =&lt;span&gt; msg;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (cmd != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (cmd.getType()) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt;&lt;span&gt; REQUEST_COMMAND:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                processRequestCommand(ctx, cmd);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RESPONSE_COMMAND:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                processResponseCommand(ctx, cmd);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据消息类型（请求消息、响应消息），使用不同的处理&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;processRequestCommand方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; processRequestCommand(&lt;span&gt;final&lt;/span&gt; ChannelHandlerContext ctx, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; RemotingCommand cmd) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Pair&amp;lt;NettyRequestProcessor, ExecutorService&amp;gt; matched = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.processorTable.get(cmd.getCode());
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Pair&amp;lt;NettyRequestProcessor, ExecutorService&amp;gt; pair = &lt;span&gt;null&lt;/span&gt; == matched ? &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultRequestProcessor : matched;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; opaque =&lt;span&gt; cmd.getOpaque();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (pair != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Runnable run = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    doBeforeRpcHooks(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), cmd);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;final&lt;/span&gt; RemotingCommand response =&lt;span&gt; pair.getObject1().processRequest(ctx, cmd);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), cmd, response);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cmd.isOnewayRPC()) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (response != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                            response.setOpaque(opaque);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                            response.markResponseType();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                                ctx.writeAndFlush(response);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                                 log.error(&quot;process request over, but response failed&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                                log.error(cmd.toString());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                                log.error(response.toString());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     log.error(&quot;process request exception&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    log.error(cmd.toString());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cmd.isOnewayRPC()) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         &lt;span&gt;final&lt;/span&gt; RemotingCommand response =&lt;span&gt; RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_ERROR,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                            RemotingHelper.exceptionSimpleDesc(e));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                        response.setOpaque(opaque);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                        ctx.writeAndFlush(response);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pair.getObject1().rejectRequest()) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; RemotingCommand response =&lt;span&gt; RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_BUSY,
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &quot;[REJECTREQUEST]system busy, start flow control for a while&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            response.setOpaque(opaque);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            ctx.writeAndFlush(response);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; RequestTask requestTask = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestTask(run, ctx.channel(), cmd);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            pair.getObject2().submit(requestTask);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RejectedExecutionException e) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((System.currentTimeMillis() % 10000) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                log.warn(RemotingHelper.parseChannelRemoteAddr(ctx.channel())
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     + &quot;, too many requests and system thread pool busy, RejectedExecutionException &quot;
&lt;span&gt;59&lt;/span&gt;                     +&lt;span&gt; pair.getObject2().toString()
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                     + &quot; request code: &quot; +&lt;span&gt; cmd.getCode());
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cmd.isOnewayRPC()) {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 &lt;span&gt;final&lt;/span&gt; RemotingCommand response =&lt;span&gt; RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_BUSY,
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                     &quot;[OVERLOAD]system busy, start flow control for a while&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;                response.setOpaque(opaque);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                ctx.writeAndFlush(response);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         String error = &quot; request type &quot; + cmd.getCode() + &quot; not supported&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; RemotingCommand response =
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;            RemotingCommand.createResponseCommand(RemotingSysResponseCode.REQUEST_CODE_NOT_SUPPORTED, error);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        response.setOpaque(opaque);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        ctx.writeAndFlush(response);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         log.error(RemotingHelper.parseChannelRemoteAddr(ctx.channel()) +&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里创建了一个Runnable提交给线程池，这个Runnable的核心是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RemotingCommand response = pair.getObject1().processRequest(ctx, cmd);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;实际上调用的就是前面说过的DefaultRequestProcessor的processRequest方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RemotingCommand processRequest(ChannelHandlerContext ctx,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    RemotingCommand request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingCommandException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ctx != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         log.debug(&quot;receive request, {} {} {}&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            request.getCode(),
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            RemotingHelper.parseChannelRemoteAddr(ctx.channel()),
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            request);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (request.getCode()) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.PUT_KV_CONFIG:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.putKVConfig(ctx, request);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_KV_CONFIG:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getKVConfig(ctx, request);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.DELETE_KV_CONFIG:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.deleteKVConfig(ctx, request);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.QUERY_DATA_VERSION:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; queryBrokerTopicConfig(ctx, request);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.REGISTER_BROKER:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             Version brokerVersion =&lt;span&gt; MQVersion.value2Version(request.getVersion());
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (brokerVersion.ordinal() &amp;gt;=&lt;span&gt; MQVersion.Version.V3_0_11.ordinal()) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registerBrokerWithFilterServer(ctx, request);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registerBroker(ctx, request);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.UNREGISTER_BROKER:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.unregisterBroker(ctx, request);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_ROUTEINTO_BY_TOPIC:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRouteInfoByTopic(ctx, request);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_BROKER_CLUSTER_INFO:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getBrokerClusterInfo(ctx, request);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.WIPE_WRITE_PERM_OF_BROKER:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wipeWritePermOfBroker(ctx, request);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getAllTopicListFromNameserver(ctx, request);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.DELETE_TOPIC_IN_NAMESRV:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; deleteTopicInNamesrv(ctx, request);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_KVLIST_BY_NAMESPACE:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getKVListByNamespace(ctx, request);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_TOPICS_BY_CLUSTER:
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getTopicsByCluster(ctx, request);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_SYSTEM_TOPIC_LIST_FROM_NS:
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getSystemTopicListFromNs(ctx, request);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_UNIT_TOPIC_LIST:
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getUnitTopicList(ctx, request);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_HAS_UNIT_SUB_TOPIC_LIST:
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHasUnitSubTopicList(ctx, request);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST:
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHasUnitSubUnUnitTopicList(ctx, request);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.UPDATE_NAMESRV_CONFIG:
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateConfig(ctx, request);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestCode.GET_NAMESRV_CONFIG:
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getConfig(ctx, request);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法很直观，根据不同的RequestCode，执行不同的方法，其中有熟悉的&lt;br/&gt;REGISTER_BROKER 注册Broker&lt;br/&gt;GET_ROUTEINTO_BY_TOPIC 获取Topic路由信息&lt;br/&gt;而其相对性的方法执行就是通过查阅或者修改之前创建的表来完成&lt;br/&gt;最后将相应的数据包装，在Runnable中通过Netty的writeAndFlush完成发送&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;至此NameServer的启动结束&lt;/p&gt;
</description>
<pubDate>Fri, 02 Aug 2019 17:15:00 +0000</pubDate>
<dc:creator>松饼人</dc:creator>
<og:description>在RocketMQ中，使用NamesrvStartup作为启动类 主函数作为其启动的入口： main0方法： 首先通过createNamesrvController方法生成NameServer的控制器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/a526583280/p/11291564.html</dc:identifier>
</item>
<item>
<title>HashMap、Hash Table、ConcurrentHashMap - wudidamowang666</title>
<link>http://www.cnblogs.com/wudidamowang666/p/11286279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wudidamowang666/p/11286279.html</guid>
<description>&lt;p&gt;这个这个。。。本王最近由于开始找实习工作了，所以就在牛客网上刷一些公司的面试题，大多都是一些java，前端HTML，js，jquery，以及一些好久没有碰的算法题，说实话，有点难受，其实在我不知道的很多是地方还有很多很多的知识漏洞，就像这一次写的这个，也是我在刷题的时候感觉到真的是我空缺的地方，为什么呢？因为，做多了，错多了。然而很尴尬的又是因为这个只是也是很多公司的面试题，所以索性直接写下来整理一遍。&lt;/p&gt;
&lt;p&gt;在这里我也建议各位，牛客网不仅仅是一个找工作的station也是一个可以锻炼我们的地方，没事刷刷题啊，逛逛论坛啊，说不定就能找到很多你意想不到的东西。&lt;/p&gt;
&lt;p&gt;在面试的过程中，有几个问题是比较常见的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;HashTable、HashMap、ConcurrentHashMap的区别？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HashMap线程不安全的出现场景？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HashMap put方法存放数据时是怎么判断是否重复的？ &lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JDK7和JDK8&lt;/strong&gt;&lt;strong&gt; 中HashMap的实现有什么区别？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HashMap的长度为什么是2的幂次方？&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;只要把这几个问题过一遍之后，大致了解了他们各自的作用与互相之间的区别再！！去敲一遍其实就可以掌握了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HashTable&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;底层数组+链表实现，无论key还是value都&lt;strong&gt;不能为null&lt;/strong&gt;，线程&lt;strong&gt;安全&lt;/strong&gt;，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化&lt;/li&gt;
&lt;li&gt;初始size为&lt;strong&gt;11&lt;/strong&gt;，扩容：newsize = oldsize*2+1&lt;/li&gt;
&lt;li&gt;计算index的方法：index = (hash &amp;amp; 0x7FFFFFFF) % tab.length&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;HashMap&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在底层数组+链表中实现，&lt;strong&gt;线程不安全，可存储null键和null值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;初始size为16，可扩容：newsize = oldsize*2，size一定为2的n次幂&lt;/li&gt;
&lt;li&gt;扩容针对整个Map，每次扩容的时候，原来数组中的元素依次重新计算存放的位置，并重新插入&lt;/li&gt;
&lt;li&gt;插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）&lt;/li&gt;
&lt;li&gt;当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀&lt;/li&gt;
&lt;li&gt;计算index方法：index = hash &amp;amp; (tab.length – 1)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;*HashMap的初始值还要考虑加载因子:&lt;/span&gt;&lt;br/&gt;哈希冲突：若干Key的哈希值按数组大小取模后，如果落在同一个数组下标上，将组成一条Entry链，对Key的查找需要遍历Entry链上的每个元素执行equals()比较。&lt;br/&gt;加载因子：为了降低哈希冲突的概率，默认当HashMap中的键值对达到数组大小的75%时，即会触发扩容。因此，如果预估容量是100，即需要设定100/0.75＝134的数组大小。&lt;br/&gt;空间换时间：如果希望加快Key查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突的概率。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;HashMap与&lt;/strong&gt;HashTable的区别&lt;/strong&gt;&lt;/span&gt;（面试题常考~）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.两者所继承的父类不同&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在这里原本是截取了JDK API1.6 中文版里面的，但实在是太丑了，就在别人的博客，呵呵，悄咪咪的拿了过来借鉴了一下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201908/1113047-20190802011233819-1549379106.png&quot; alt=&quot;&quot; width=&quot;536&quot; height=&quot;273&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201908/1113047-20190802011241508-721594602.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;152&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;2.两者对外接口是不同的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashTable比HashMap多提供了elements()和contains()两个方法。&lt;/p&gt;
&lt;p&gt;elements()方法继承自HashTable的父类Doctionnary。elements()方法用于返回此时HashTable中的值的枚举。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201908/1113047-20190802232850357-1667246016.png&quot; alt=&quot;&quot; width=&quot;482&quot; height=&quot;379&quot;/&gt;&lt;/p&gt;
&lt;p&gt;contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法，是判断哈希表中是否包含指定的值。如图是contains的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public virtual bool Contains(object key)
{
    return this.ContainsKey(key);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.对Null key 和Null value的支持不同&lt;/strong&gt;&lt;br/&gt;Hashtable既不支持Null key也不支持Null value。&lt;/p&gt;
&lt;p&gt;HashMap中，key-value都是存在Entry中的。null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，用过HashCode()方法和equal()方法来保证键的唯一性。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。&lt;br/&gt;&lt;span&gt;&lt;strong&gt;4.线程安全的不同性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。所以使用HashMap时就必须要自己增加同步处理，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。&lt;br/&gt;&lt;span&gt;&lt;strong&gt;5.Hash值的计算方法不同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了求得元素的位置，需要根据元素的Key计算出一个哈希值，然后再用这个哈希值来计算出崔忠的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201908/1113047-20190802235559198-986581724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。&lt;/p&gt;
&lt;p&gt;Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。&lt;/p&gt;
&lt;p&gt;HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。&lt;/p&gt;
&lt;p&gt;HashMap的效率虽然提高了，但是hash冲突却也增加了。因为它得出的hash值的低位相同的概率比较高，而计算位运算&lt;/p&gt;
&lt;p&gt;为了解决这个问题，HashMap重新根据hashcode计算hash值后，又对hash值做了一些运算来打散数据。使得取得的位置更加分散，从而减少了hash冲突。当然了，为了高效，HashMap只做了一些简单的位处理。从而不至于把使用2 的幂次方带来的效率提升给抵消掉。&lt;/p&gt;
&lt;h3 id=&quot;ConcurrentHashMap&quot;&gt;&lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;底层采用分段的数组+链表实现，线程&lt;strong&gt;安全。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;key和value都不能为null。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过把整个Map分为N个Segment，可以提供相同的线程安全&lt;/strong&gt;，但是效率提升N倍，默认提升16倍。&lt;/li&gt;
&lt;li&gt;Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术&lt;/li&gt;
&lt;li&gt;有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁&lt;/li&gt;
&lt;li&gt;扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，&lt;strong&gt;不会对整个Map进行扩容&lt;/strong&gt;），插入前检测需不需要扩容，有效避免无效扩容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个就很棒了，上面总结的源于某猿大神，Java5提供的ConcurrentHashMap就像是HashTable的升级版，扩容性更强。&lt;/p&gt;
&lt;p&gt;在HashMap中，通过get()返回的null值，既可以表示返回该Key所对应过的Value是null值，也可以表示为没有该Key，在这种情况下就应该采用ConcurrentHashMap。&lt;/p&gt;
&lt;p&gt;来看一张简单的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201908/1113047-20190803001104869-974780989.png&quot; alt=&quot;&quot; width=&quot;815&quot; height=&quot;678&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一个可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素。当对HashEntry数组的数据进行修改时，必须首先获得与它对应的segment锁。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; Hashtable中采用的锁机制是一次锁住整个hash表，从而在同一时刻只能由一个线程对其进行操作；而ConcurrentHashMap中则是一次锁住一个桶。&lt;/p&gt;
&lt;p&gt;简单理解就是，ConcurrentHashMap是一个Segment数组，Segment通过继承ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个Segment，只要保证每个Segment是线程安全的，也就实现了全局的线程安全。&lt;strong&gt;重申一下，Segment数组不能扩容，扩容是Segment数组某个位置内部的数组HashEntry&amp;lt;K,V&amp;gt;[]进行扩容，扩容后，容量为原来的2倍。&lt;/strong&gt;可以回顾下出发扩容的地方，put的时候，如果判断该值的插入会导致该Segment的元素个数超过阈值，那么先进行扩容，再插值。&lt;/p&gt;
</description>
<pubDate>Fri, 02 Aug 2019 16:16:00 +0000</pubDate>
<dc:creator>wudidamowang666</dc:creator>
<og:description>这个这个。。。本王最近由于开始找实习工作了，所以就在牛客网上刷一些公司的面试题，大多都是一些java，前端HTML，js，jquery，以及一些好久没有碰的算法题，说实话，有点难受，其实在我不知道的很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wudidamowang666/p/11286279.html</dc:identifier>
</item>
<item>
<title>Thinkphp5.0快速入门笔记（1） - 嘘，小点声</title>
<link>http://www.cnblogs.com/bai2018/p/11291674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bai2018/p/11291674.html</guid>
<description>
&lt;h2&gt;学习来源与说明&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kancloud.cn/thinkphp/thinkphp5_quickstart&quot; target=&quot;_blank&quot;&gt;https://www.kancloud.cn/thinkphp/thinkphp5_quickstart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试与部署均在windows10下进行学习。&lt;/p&gt;
&lt;h2&gt;Composer安装和更新&lt;/h2&gt;
&lt;p class=&quot;slogan&quot;&gt;Composer 是 PHP 用来管理依赖（dependency）关系的工具。可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。&lt;/p&gt;
&lt;p class=&quot;slogan&quot;&gt;网址：&lt;a href=&quot;https://www.phpcomposer.com/&quot; target=&quot;_blank&quot;&gt;https://www.phpcomposer.com/&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;slogan&quot;&gt;下载：&lt;a href=&quot;https://getcomposer.org/Composer-Setup.exe&quot; target=&quot;_blank&quot;&gt;https://getcomposer.org/Composer-Setup.exe&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;slogan&quot;&gt;ThinkPHP框架下载地址&lt;/h2&gt;
&lt;p&gt;[ Github ]&lt;br/&gt;应用项目： https://github.com/top-think/think&lt;br/&gt;核心框架： https://github.com/top-think/framework&lt;br/&gt;[ 码云 ]&lt;br/&gt;应用项目： https://git.oschina.net/liu21st/thinkphp5.git&lt;br/&gt;核心框架： https://git.oschina.net/liu21st/framework.git&lt;br/&gt;[ Coding ]&lt;br/&gt;应用项目： https://git.coding.net/liu21st/thinkphp5.git&lt;br/&gt;核心框架： https://git.coding.net/liu21st/framework.git&lt;/p&gt;
&lt;h2&gt;部署与测试&lt;/h2&gt;
&lt;p&gt;部署过程采用xampp搭建。&lt;/p&gt;
&lt;p&gt;XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。&lt;/p&gt;
&lt;p&gt;下载完以后默认安装。安装完毕后打开xampp-control，如下界面。点击Apache的start和MySQL的start，&lt;strong&gt;允许网络&lt;/strong&gt;，输入127.0.0.1测试。&lt;/p&gt;
&lt;p&gt;Apache如果无法启动考虑端口占用问题，使用端口80,443。在cmd窗口下命令：netstat -ano查看端口占用情况，然后在任务管理器中找到占用端口的对应进程PID，结束掉，重新启动Apache试试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802213413109-864268990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试完毕后，在Apache的Config下的httpd.conf文件打开，在文本最后（568行最后左右）编辑输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;VirtualHost *:80&amp;gt;
    DocumentRoot &quot;C:\xampp\htdocs\server\public&quot;
    ServerName www.server.com
&amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后在C:\xampp\htdocs下建立文件夹server，将php框架解压到该文件夹下，检查对应出的public文件夹。&lt;/p&gt;
&lt;p&gt; 然后在C:\Windows\System32\drivers\etc中，找到host文件，修改属性，使可以编辑，然后在最后端添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
192.168.0.103  www.matlabserver.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使可以通过域名对应到网络ip。其中的192.168.0.103为本机对应在局域网的ip地址，用户应该在cmd窗口中使用ipconfig，自行查找对应的局域网ip地址。&lt;/p&gt;
&lt;p&gt;最后测试，浏览器中输入ip，测试完毕后的效果如下：（当然啦，现在thinkPHP都出到6.0版本了，如果使用了5.1版本或者6.0，应该效果略有差异，但是不影响吧）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802215547537-374498254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;demo、控制器、视图、调试开关&lt;/h2&gt;
&lt;h3&gt;demo&lt;/h3&gt;
&lt;p&gt;在ThinkPHP框架根路径打开cmd窗口，输入&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
php think build --module demo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会在application/下生成demo代码作为示例。&lt;/p&gt;
&lt;h3&gt;控制器&lt;/h3&gt;
&lt;p&gt;控制器位于路径application/index/controller/Index.php。编辑该文件即对主页编辑。控制器的路径和public/index.php配置有关。&lt;/p&gt;
&lt;p&gt;修改application/index/controller/Index.php文件，则修改了主界面，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php
namespace app\index\controller;
class Index
{
    public function index()
    {
        return 'Hello,World！';
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802221423523-675521887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;视图&lt;/h3&gt;
&lt;p&gt;和demo一样，在application/index/下创建view文件夹，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802221953464-847739135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在之下创立hello.html，有如下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
     &amp;lt;title&amp;gt;hello {$name}&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
     hello, {$name}!
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 修改application/index/controller/Index.php控制器为以下，则通过hello相互关联，控制器添加视图文件功能。（使用use声明继承方便，不适用use则需要class Index extends \think\Controller声明继承。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php
namespace app\index\controller;
use think\Controller;
class Index extends Controller
{
    public function hello($name = 'thinkphp')
    {
        $this-&amp;gt;assign('name', $name);
        return $this-&amp;gt;fetch();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 效果如下：（&lt;strong&gt;注意url访问&lt;/strong&gt; http://serverName/index.php/模块/控制器/操作）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802222757275-1653997921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;调试开关&lt;/h3&gt;
&lt;p&gt;调试开关位于application/config.php，第20行左右修改为以下，则关闭了调试开关：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
    'app_debug'              =&amp;gt; false,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802223145686-927290508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关闭状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802223517864-18574055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;与数据库连接&lt;/h2&gt;
&lt;p&gt; 数据库在xampp下的打开方式，可以通过MySQL的admin打开，也可以在cmd窗口中操作。下图为在xampp下的打开mysql方式。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802223746739-978040098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在cmd中操作，首先将环境变量添加到path中，然后再打开cmd窗口。下图为添加环境变量示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802224219917-1592029126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后输入如下，进入mysql。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802224326256-1400622071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入以下，创建id，data的数据库，插入三条数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot; readability=&quot;5&quot;&gt;
show databases;

create database demo;&lt;br/&gt;use demo&lt;br/&gt;CREATE TABLE IF NOT EXISTS `think_data`(
`id` int(8) unsigned NOT NULL AUTO_INCREMENT,
`data` varchar(255) NOT NULL,
PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 ;

INSERT INTO `think_data`(`id`,`data`) VALUES
(1,'thinkphp'),
(2,'php'),
(3,'framework');&lt;p&gt;select * from think_data;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一点效果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802224954975-654716139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在application/database.php中修改文件内容为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php

return [
    // 数据库类型
    'type' =&amp;gt; 'mysql',
    // 服务器地址
    'hostname' =&amp;gt; '127.0.0.1',
    // 数据库名
    'database' =&amp;gt; 'demo',
    // 数据库用户名
    'username' =&amp;gt; 'root',
    // 数据库密码
    'password' =&amp;gt; '',
    // 数据库连接端口
    'hostport' =&amp;gt; '',
    // 数据库连接参数
    'params' =&amp;gt; [],
    // 数据库编码默认采用utf8
    'charset' =&amp;gt; 'utf8',
    // 数据库表前缀
    'prefix' =&amp;gt; 'think_',
    // 数据库调试模式
    'debug' =&amp;gt; true,
    ];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 修改控制器代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php
namespace app\index\controller;
use think\Controller;
use think\Db;
class Index extends Controller
{
    public function index()
    {
        $data = Db::name('data')-&amp;gt;find();
        $this-&amp;gt;assign('result', $data);
        return $this-&amp;gt;fetch();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 添加模板文件view/index.html，设立内容为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        {$result.id}--{$result.data}
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 保存，最终效果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1325410/201908/1325410-20190802225647170-2105805098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 成功连接上了数据库，然后输出第一条数据。&lt;/p&gt;
&lt;p&gt; 也可以尝试更改控制器代码第九行为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
        $data = Db::name('data')-&amp;gt;where('id',2)-&amp;gt;find();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 输出数据库第二条数据。&lt;/p&gt;
&lt;p&gt;参阅地址：&lt;a href=&quot;https://www.kancloud.cn/manual/thinkphp5/135176&quot; target=&quot;_blank&quot;&gt;https://www.kancloud.cn/manual/thinkphp5/135176&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 02 Aug 2019 15:13:00 +0000</pubDate>
<dc:creator>嘘，小点声</dc:creator>
<og:description>学习来源与说明 https://www.kancloud.cn/thinkphp/thinkphp5_quickstart 测试与部署均在windows10下进行学习。 Composer安装和更新 C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bai2018/p/11291674.html</dc:identifier>
</item>
<item>
<title>spark shuffle的写操作之准备工作 - 匠心源码</title>
<link>http://www.cnblogs.com/johnny666888/p/11265502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/johnny666888/p/11265502.html</guid>
<description>[unable to retrieve full-text content]前言 在前三篇文章中，spark 源码分析之十九 -- DAG的生成和Stage的划分 剖析了DAG的构建和Stage的划分，spark 源码分析之二十 -- Stage的提交 剖析了TaskSet任务的提交，以及spark 源码分析之二十一 -- Task的执行细节剖析了Task执行的整个流程。在</description>
<pubDate>Fri, 02 Aug 2019 14:59:00 +0000</pubDate>
<dc:creator>匠心源码</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com/signin?ReturnUrl=https%3a%2f%2fwww.cnblogs.com%2fjohnny666888%2fp%2f11265502.html</dc:identifier>
</item>
<item>
<title>续集：白菜的内涵，更新nand分区为ubifs，替换overlay - A.Z</title>
<link>http://www.cnblogs.com/A-Z/p/openwrt-with-ubifs.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/A-Z/p/openwrt-with-ubifs.html</guid>
<description>&lt;p&gt;在上一篇&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/A-Z/p/ath79_nand_flash_qca9558.html&quot;&gt;真千兆路由的极限之OPENWRT MAKE, 某品牌白菜价QCA9558/QCA9880/QCA8337N纯种组合OS搭建时记&lt;/a&gt;中附带了128M nand的空间图示，在ar71xx profile里，默认以jffs2的分区存在, jffs2有一些弊端，砖家们认为更适合空间小的spi-nor flash，无附议，对于增倍的nand flash, ubifs有着后天设计上的优势&lt;/p&gt;
&lt;p&gt;为此，稍作修改，即可更新为ubifs, 而我始终坚持在spi-nor的混合存储中把kernel和rootfs放在前者，因为相比nand,spi-nor并没有ecc带来的失速，也可以提高读写频率来提高载入速度，况且，作为系统安全性的重要一环nand的数据丢失和断电缓存是一个必须面对的问题，所以并不是适宜把OS放在其上split, 这应该是系统硬件配置和支持的初衷&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/A-Z/117549/o_dw33d-ubifs.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更新后的mount list&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/A-Z/117549/o_dw33d-ubifs_space.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/p&gt;
&lt;p&gt;free space比原先减少了不少，但是聊胜于无，有了space，那某位18年已经放弃更新c实现的pkg，也少不了为它更新其他依赖lib的patch, 就可以更新下一位作者go的作品啦，go本身也是一个大问题，cve少不了它，还是聊胜于无，据说多个instance空间节约不少，能用就好&lt;/p&gt;

&lt;p&gt;续篇over.&lt;/p&gt;
</description>
<pubDate>Fri, 02 Aug 2019 14:59:00 +0000</pubDate>
<dc:creator>A.Z</dc:creator>
<og:description>在上一篇真千兆路由的极限之OPENWRT MAKE, 某品牌白菜价QCA9558/QCA9880/QCA8337N纯种组合OS搭建时记中附带了128M nand的空间图示，在ar71xx profil</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/A-Z/p/openwrt-with-ubifs.html</dc:identifier>
</item>
<item>
<title>传输层的TCP和UDP协议 - herryLo</title>
<link>http://www.cnblogs.com/liuheng/p/11291593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuheng/p/11291593.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://image-static.segmentfault.com/127/292/127292712-5d444ab736b8b_articlex&quot; alt=&quot;img1&quot; width=&quot;800&quot; height=&quot;533&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者：&lt;a href=&quot;https://github.com/HerryLo&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;HerryLo&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原文永久链接： &lt;a href=&quot;https://github.com/AttemptWeb/Record...&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;https://github.com/AttemptWeb...&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP/IP协议&lt;/strong&gt;， 你一定常常听到，其中&lt;strong&gt;TCP（Transmission Control Protocol）称为 传输控制协议，IP（Internet Protocol） 称为网际协议&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AttemptWeb/Record/master/Img/tcp%3Aip.png&quot; alt=&quot;img&quot; width=&quot;618&quot; height=&quot;507&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上TCP/IP协议，是一个协议族，是一个协议的集合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP/IP协议，定义了一整套规则。它定义整个互联网如何连接，如何通信，如何协商的最基础规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP/IP协议分为五层，分别是应用层、传输层、网络层、数据链路层、物理层。每层都有对应的相关协议，其中TCP和UDP是传输层的两个协议。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;articleHeader0&quot;&gt;&lt;span&gt;理解TCP和UDP&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img title=&quot;TCP/UDP&quot; src=&quot;https://raw.githubusercontent.com/AttemptWeb/Record/master/Img/udp%3Atcp.png&quot; alt=&quot;TCP/UDP&quot; width=&quot;1156&quot; height=&quot;448&quot; data-src=&quot;/img/bVbvUo2?w=1156&amp;amp;h=448&quot;/&gt;&lt;br/&gt;既然他们是传输层的协议，那么他们的作用当然就是用来负责传输数据了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们想象一个场景，网络中随意的两端要通信，会采取什么传输方式呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以先想象一下人类之间的通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种是打电。我拨通电话你的电话，直到你回答“你好”，我听到声音之后，我们之间才继续进行交谈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一个是发短信。我给你的手机号发送一条短信，无法知道你是否收到，然后我就只能等待你的回复了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中第一种方式对应TCP，而第二种对应UDP。TCP是需要对方确认的，也就是传输之前需要进行三次握手（传输的两端需要经过三次握手，才开始通信）。UDP着比较粗暴，不论对方什么情况，直接发送，不需要确认过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而上图中的看到的，TCP是可靠的，UDP是不可靠的，就是这个意思。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可靠的连接带来的是效率的下降。比如一次网络请求，很大一部分时间其实都是浪费在互相确认的过程当中，资源消耗比较多，保证了数据传输是可靠的，而且传输数据是有序的。不可靠的连接带来的是效率的提升，但可能服务质量有下降。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要摆脱一种人为的误区，不要以为UDP不可靠，就没有应用场景。据说QQ发送数据就是靠UDP发送的，尽管是不可靠的连接，可是还是用了非常多的校验算法保证了数据质量稳定，同也保证了效率。TCP尽管耗时，可是对于稳定性优先的场景，还是应该有限选用TCP，比方浏览器中访问网页用的就是TCP。此外在一些长连接系统里面，比方微信，连接通道应该也是用TCP建立的，由于要维持一条稳定的信息传输通道。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;协议是怎么控制，数据包是怎么传输，怎么校验数据的正确性，还有重传特性。这些都是协议中重要的控制过程，在这里不做详解，因为对于实际的产品并没有太大的用。至于如何选定传输数据方式，应该依据场景而定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安全的东西往往不快，反之亦然。而TCP和UCD之间也是这样：&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;articleHeader1&quot;&gt;&lt;span&gt;TCP(传输控制协议)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP(传输控制协议)是基于连接的&lt;/strong&gt;。在正式收发数据之前，必须要与对方建立连接。这之间需要经过'三次握手':&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步. 首先A主机需要和B主机之间建立数据收发，A需要发送一个请求询问B：'我要建立连接'；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步. B收到消息后，会给A发送一个回应：'可以连接'；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步. A收到B的回应后，A向B再次回应：'我要开始发送了'，他们之间就可以建立连接了；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第一次握手的结论是：A的发送能力、B的接收能力正常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二次握手的结论是：B的发送能力、A的接收能力正常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三次握手的结论是：A的接收、发送能力，B的接收、发送能力都是正常的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;'3次握手'的作用就是 双方都能明确自己和对方的收、发能力是正常的.&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;articleHeader2&quot;&gt;&lt;span&gt;UDP(用户数据报协议)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP(用户数据报协议)是面向非连接的，不与对方建立连接&lt;/strong&gt;，而直接把数据报=包发送出去。UDP适用于一次传输少量的数据，对于可靠性要求不高的应用环境。日常生活中使用的ping命令测试主机是否通信正常，事实上'ping'命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，假设数据包是否到达的消息及时反馈回来了，那么网络传输就是正常的。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;articleHeader3&quot;&gt;&lt;span&gt;适用场景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP&lt;/strong&gt;：是全双工、面向连接、可靠的，而且精确控制的协议。主要用于实时性不强，但传输要求高的应用。比方说：网页浏览、文件下载(不是BT、电脑下载)、邮件的发送等场合，这些场景需要TCP协议进行传输。当然，它在网络方面的开销是昂贵的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP&lt;/strong&gt;：这是一个不可靠的传输协议。由于它不排序所要发送的数据段，不负责这些数据段到达目标的顺序（说一它才不可靠）。它在网络的开销要比TCP小很多，因此UDP适合用在那些实时性强、允许出错的场合。比如说：即时通讯(MSN、QQ)，视频、语言等方面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ps: 顺便推一下自己的个人公众号：Yopai，有兴趣的可以关注，每周不定期更新，分享可以增加世界的快乐&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Aug 2019 14:47:00 +0000</pubDate>
<dc:creator>herryLo</dc:creator>
<og:description>作者：HerryLo 原文永久链接： https://github.com/AttemptWeb... TCP/IP协议， 你一定常常听到，其中TCP（Transmission Contro</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuheng/p/11291593.html</dc:identifier>
</item>
<item>
<title>从动态代理到Spring AOP（中） - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/11267836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/11267836.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一.前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　上一章节主要介绍了JDK动态代理和CGLIB动态代理：&lt;a href=&quot;https://www.cnblogs.com/GrimMjx/p/11194283.html&quot;&gt;https://www.cnblogs.com/GrimMjx/p/11194283.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这一章主要结合我们之前学习的动态代理的基础来学习Sring AOP，本章学习需要Spring IOC的基础。首先会有一个Spring AOP的例子，后面逐渐深入会把一些关键的源码贴出来供大家学习。&lt;/p&gt;
&lt;h2&gt;二.一个栗子&lt;/h2&gt;
&lt;h3&gt;2.1 创建Spring配置文件&lt;/h3&gt;
&lt;p&gt;　　本例子使用xml的方式来配置Spring，如果你用Springboot可以用@EnableAspectJAutoProxy来开启AOP功能。xml配置Spring是否使用注解AOP的方式是&amp;lt;aop:aspectj-autoproxy/&amp;gt;，配置文件中有这句话Spring就会支持注解的AOP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190730083629107-488730106.png&quot; alt=&quot;&quot; width=&quot;717&quot; height=&quot;419&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2 创建要被代理的bean&lt;/h3&gt;
&lt;p&gt;　　这个bean的某个方法可能封装着核心逻辑，如果我们想对这个方法的前后加入日志或者其他逻辑进行增强，直接修改这个bean不符合面向对象的设计，还好Spring AOP帮我们做到这一点。那我们先创建一个简单的bean：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190730082651058-1808383072.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3 创建Advisor&lt;/h3&gt;
&lt;p&gt;　　Spring2.0可以采用@AspectJ注解对POJO进行标记，从而定义一个包含切点信息和增强横切逻辑的切面然后织入匹配的目标Bean中&lt;/p&gt;
&lt;p&gt;　　在AspectJConfig中，我们简单的对test方法前后记录日志。&lt;span&gt;记住光用@AspectJ注解是不够的。要么再添加@Component注解要么在xml添加这个bean&lt;/span&gt;，官方解释如下：&lt;/p&gt;
&lt;p&gt;　　You may register aspect classes as regular beans in your Spring XML configuration, or autodetect them through classpath scanning - just like any other Spring-managed bean. However, note that the @Aspect annotation is not sufficient for autodetection in the classpath: For that purpose, you need to add a separate @Component annotation (or alternatively a custom stereotype annotation that qualifies, as per the rules of Spring’s component scanner).&lt;/p&gt;
&lt;p&gt;　　再来看一下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190730083601010-988418566.png&quot; alt=&quot;&quot; width=&quot;633&quot; height=&quot;476&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.4 测试&lt;/h3&gt;
&lt;p&gt;　　我们可以写一个简单的测试类，通过容器拿到TestBean这个bean，然后调用test方法，看一下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190730084017854-1443312039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三.源码赏析&lt;/h2&gt;
&lt;p&gt;　　最好带着问题去看源码，要不然自己也是跟着走一遍，&lt;span&gt;源码是无尽，开发思想是有尽的。比如今天看了ConcurrentHashMap的size方法对cas的优化，再看看LongAdder是咋玩的，学到了分散思想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　-谁来创建AOP的？&lt;/p&gt;
&lt;p&gt;　　-谁来解析@Aspect注解的类？&lt;/p&gt;
&lt;p&gt;　　-JDK动态代理怎么创建的？&lt;/p&gt;
&lt;p&gt;　　-CGlib动态代理怎么创建的？&lt;/p&gt;
&lt;p&gt;　　-有什么好的设计方式吗？&lt;/p&gt;
&lt;p&gt;　　-等等&lt;/p&gt;
&lt;h3&gt;3.1 谁来创建？&lt;/h3&gt;
&lt;p&gt;　　是AnnotationAwareAspectJAutoProxyCreator。（名字就很通俗易懂）&lt;/p&gt;
&lt;p&gt;　　Spring扫到&amp;lt;aop:aspectj-autoproxy/&amp;gt;后，&lt;span&gt;AspectJAutoProxyBeanDefinitionParser会注册这位创建者。对于Spring AOP的实现，AnnotationAwareAspectJAutoProxyCreator是负责代理的创建者&lt;/span&gt;，也是我们赏析的开始。先来看下这个创建者的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190730210548776-491990550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当Spring加载每个Bean的时候会在实例化前调用postProcessorAfterInitialization方法，对于AOP的逻辑也由此开始：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190730210747101-1881894031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2 获取所有增强器&lt;/h3&gt;
&lt;p&gt;　　还记得之前的栗子吗？有个类是有@AspectJ注解的AspectJConfig类，这个类里面有@PointCut注解，这个注解的意思是对哪些方法进行增强，这里@Pointcut(&quot;execution(* *.test(..))&quot;)表示要对所有test方法进行增强。通过不同的切点表达函数可以实现对某些你想要类或者方法进行增强。&lt;/p&gt;
&lt;p&gt;　　那么，什么叫增强器？Spring AOP在JoinPoint“周围”维护一系列的拦截器。有哪些Advice呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;@Before - 在JoinPoint方法之前执行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@AfterReturning - 在JoinPoint方法正常执行后执行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@AfterThrowing - 在JoinPoint方法抛出异常退出并执行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@After - 无论JoinPoint方法正常返回还是异常返回都会执行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@Around - 在JoinPoint方法前后执行&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　例子中，有2个增强器。那我们看下源码是如何拿到所有的增强器的，看这个方法：org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Look for AspectJ-annotated aspect beans in the current bean factory,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * and return to a list of Spring AOP Advisors representing them.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;Creates a Spring Advisor for each AspectJ advice method.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the list of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.aop.Advisor} beans
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #isEligibleBean
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; List&amp;lt;Advisor&amp;gt;&lt;span&gt; buildAspectJAdvisors() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     List&amp;lt;String&amp;gt; aspectNames = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         aspectNames = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectBeanNames;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (aspectNames == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             List&amp;lt;Advisor&amp;gt; advisors = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Advisor&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             aspectNames = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取容器内所有的beanName&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             String[] beanNames =
&lt;span&gt;17&lt;/span&gt;                     BeanFactoryUtils.beanNamesForTypeIncludingAncestors(&lt;span&gt;this&lt;/span&gt;.beanFactory, Object.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for循环，找出增强方法        &lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String beanName : beanNames) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤不合法的bean，子类实现&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isEligibleBean(beanName)) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We must be careful not to instantiate beans eagerly as in this
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; case they would be cached by the Spring container but would not
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; have been weaved
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取到bean类型&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                 Class beanType = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.getType(beanName);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (beanType == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果存在@AspectJ注解&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisorFactory.isAspect(beanType)) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入list&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    aspectNames.add(beanName);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     AspectMetadata amd = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AspectMetadata(beanType, beanName);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (amd.getAjType().getPerClause().getKind() ==&lt;span&gt; PerClauseKind.SINGLETON) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                         MetadataAwareAspectInstanceFactory factory =
&lt;span&gt;39&lt;/span&gt;                                 &lt;span&gt;new&lt;/span&gt; BeanFactoryAspectInstanceFactory(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory, beanName);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析获取增强方法&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;                         &lt;span&gt;List&amp;lt;Advisor&amp;gt; classAdvisors = this.advisorFactory.getAdvisors(factory);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.isSingleton(beanName)) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放入缓存&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisorsCache.put(beanName, classAdvisors);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectFactoryCache.put(beanName, factory);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                        advisors.addAll(classAdvisors);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Per target or per this.&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.isSingleton(beanName)) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Bean with name '&quot; + beanName +
&lt;span&gt;56&lt;/span&gt;                                     &quot;' is a singleton, but aspect instantiation model is not singleton&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                         MetadataAwareAspectInstanceFactory factory =
&lt;span&gt;59&lt;/span&gt;                                 &lt;span&gt;new&lt;/span&gt; PrototypeAspectInstanceFactory(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory, beanName);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectFactoryCache.put(beanName, factory);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                         advisors.addAll(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisorFactory.getAdvisors(factory));
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.aspectBeanNames =&lt;span&gt; aspectNames;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; advisors;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (aspectNames.isEmpty()) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.EMPTY_LIST;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;     List&amp;lt;Advisor&amp;gt; advisors = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Advisor&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String aspectName : aspectNames) {
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从缓冲拿出增强器&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; cachedAdvisors = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisorsCache.get(aspectName);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (cachedAdvisors != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;            advisors.addAll(cachedAdvisors);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;             MetadataAwareAspectInstanceFactory factory = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectFactoryCache.get(aspectName);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;             advisors.addAll(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisorFactory.getAdvisors(factory));
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; advisors;
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到此我们找到了所有声明@AspectJ注解的类，接下来是不是该找用@Before，@After等等那些注解的方法了？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190731085833090-1813666558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　等等，我们要的是Advisor，所有增强由Advisor的实现类InstantiationModelAwarePointcutAdvisorImpl封装，不同的注解会封装成不同的增强器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut ajexp,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         MetadataAwareAspectInstanceFactory aif, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; declarationOrderInAspect, String aspectName) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 检查开始 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     Class&amp;lt;?&amp;gt; candidateAspectClass =&lt;span&gt; aif.getAspectMetadata().getAspectClass();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    validate(candidateAspectClass);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 之前讲过，获取到方法上的注解信息&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     AspectJAnnotation&amp;lt;?&amp;gt; aspectJAnnotation =
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (aspectJAnnotation == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we get here, we know we have an AspectJ method. 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check that it's an AspectJ-annotated class&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isAspect(candidateAspectClass)) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AopConfigException(&quot;Advice must be declared inside an aspect type: &quot; +
&lt;span&gt;16&lt;/span&gt;                 &quot;Offending method '&quot; + candidateAdviceMethod + &quot;' in class [&quot; +
&lt;span&gt;17&lt;/span&gt;                 candidateAspectClass.getName() + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         logger.debug(&quot;Found AspectJ method: &quot; +&lt;span&gt; candidateAdviceMethod);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 检查结束 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据不同的注解生成不同的增强器&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    AbstractAspectJAdvice springAdvice;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (aspectJAnnotation.getAnnotationType()) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt;&lt;span&gt; AtBefore&lt;/span&gt;:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             springAdvice = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; AspectJMethodBeforeAdvice&lt;/span&gt;(candidateAdviceMethod, ajexp, aif);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt;&lt;span&gt; AtAfter&lt;/span&gt;:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             springAdvice = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; AspectJAfterAdvice&lt;/span&gt;(candidateAdviceMethod, ajexp, aif);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt;&lt;span&gt; AtAfterReturning&lt;/span&gt;:
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             springAdvice = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; AspectJAfterReturningAdvice&lt;/span&gt;(candidateAdviceMethod, ajexp, aif);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             AfterReturning afterReturningAnnotation =&lt;span&gt; (AfterReturning) aspectJAnnotation.getAnnotation();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasText(afterReturningAnnotation.returning())) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                springAdvice.setReturningName(afterReturningAnnotation.returning());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt;&lt;span&gt; AtAfterThrowing&lt;/span&gt;:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             springAdvice = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; AspectJAfterThrowingAdvice&lt;/span&gt;(candidateAdviceMethod, ajexp, aif);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             AfterThrowing afterThrowingAnnotation =&lt;span&gt; (AfterThrowing) aspectJAnnotation.getAnnotation();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasText(afterThrowingAnnotation.throwing())) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt;&lt;span&gt; AtAround&lt;/span&gt;:
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             springAdvice = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; AspectJAroundAdvice&lt;/span&gt;(candidateAdviceMethod, ajexp, aif);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; AtPointcut:
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 logger.debug(&quot;Processing pointcut '&quot; + candidateAdviceMethod.getName() + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException(
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                     &quot;Unsupported advice type on method &quot; +&lt;span&gt; candidateAdviceMethod);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Now to configure the advice...&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    springAdvice.setAspectName(aspectName);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    springAdvice.setDeclarationOrder(declarationOrderInAspect);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     String[] argNames = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (argNames != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        springAdvice.setArgumentNamesFromStringArray(argNames);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    springAdvice.calculateArgumentBindings();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; springAdvice;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3 获取匹配的增强器&lt;/h3&gt;
&lt;p&gt;　　前面讲了获取所有的增强器，不一定都适用于现在的bean，我们要选出合适的增强器，也就是满足配置的增强器，具体方法在：org.springframework.aop.support.AopUtils#findAdvisorsThatCanApply：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190731212134969-1022131177.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;3.4 创建代理&lt;/h3&gt;
&lt;p&gt;　　首先看这个方法：org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190731214336442-47915016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么接下来就是代理的创建与获取了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201907/1465200-20190731215032114-1159314851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们先看下如何创建代理的，注释如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201908/1465200-20190802104510304-1543059917.png&quot; alt=&quot;&quot; width=&quot;911&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以我们可以得出以下结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果目标类实现了接口，默认使用JDK动态代理实现AOP，但是也可以强制使用CGLIB实现AOP&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果目标类没有实现接口，那么必须采用CGLIB库&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.5 调用过程　　&lt;/h3&gt;
&lt;p&gt;　　最后就是方法调用的关键方法了，可以说&lt;span&gt;最核心的方法就是这个了&lt;/span&gt;，org.springframework.aop.framework.ReflectiveMethodInvocation#proceed：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Spring aop的精华都在于此，核心就是&lt;strong&gt;递归思想&lt;/strong&gt;，调用完了拦截链（所有增强器）中的所有拦截器方法后，再调用目标对象的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201908/1465200-20190802215628739-1271609521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到底invoke方法是啥呢？见下图，我们可以看到是一个接口的方法，不同增强器有不同的实现，我们这里就看Before和After的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201908/1465200-20190802220006340-1707089085.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201908/1465200-20190802220111638-1130937577.png&quot; alt=&quot;&quot; width=&quot;913&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201908/1465200-20190802220151728-1649059540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后画一张图吧，这样比较好理解一点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201908/1465200-20190802221152975-1711438733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四.总结&lt;/h2&gt;
&lt;p&gt;　　过程就是先拿出所有适用的Adivsors，然后构造拦截链（chain），最后进行串行调用（递归）。&lt;/p&gt;
&lt;p&gt;　　最后还是希望多写几个demo来实践一下，打打断点。还是那句话，源码是看不完的，最重要的是思想。这是我第一家公司技术总监老羊说的。我觉得还是挺收益的。本文还有很多不足之处，如果有写的不对的地方还请指点一下，感谢。&lt;/p&gt;
</description>
<pubDate>Fri, 02 Aug 2019 14:24:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>一.前言 上一章节主要介绍了JDK动态代理和CGLIB动态代理：https://www.cnblogs.com/GrimMjx/p/11194283.html 这一章主要结合我们之前学习的动态代理的基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GrimMjx/p/11267836.html</dc:identifier>
</item>
<item>
<title>曹工杂谈：Linux服务器上，Spring Boot 原地修改 jar 包配置文件/替换class文件，免去重复上传的麻烦 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/11291379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/11291379.html</guid>
<description>&lt;p&gt;相信很多同学有这样的需求，现在很多公司都有多地的研发中心，经常需要跨地区部署，比如，博主人在成都，但是服务器是北京的。一般城市间网络都不怎么好，上传一个几十兆的jar包那是真的慢，别说现在微服务架构下，动辄两位数的fat jar。这里说的jar，就是spring boot项目打出来的fat jar类型，一般也有个几十兆吧。&lt;/p&gt;
&lt;p&gt;博主之前还遇到部署北美亚马逊环境，好不容易传个包过去，后来发现有bug，需要改class，如果重新打包再传，真的要死的心都有了。&lt;/p&gt;
&lt;p&gt;如果要改什么配置，或者发现某个class文件有bug，那怎么办呢？不要急，今天就是教你怎么解决这种简单问题。&lt;/p&gt;


&lt;p&gt;这个非常简单，只要使用vim即可，真正的屠龙工具。&lt;/p&gt;
&lt;p&gt;比如当前目录下有个spring boot 的jar包，我们可以按如下步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201908/519126-20190802210203178-221042123.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，我们直接vim xxx.jar包后，可以通过 /关键字 来查找文件，查找到以后，通过方向键进行控制，enter 进入文件，修改文件、保存等操作和vim的操作一样。&lt;/p&gt;


&lt;h2&gt;1、方式1，jar命令替换&lt;/h2&gt;
&lt;p&gt;如果只是简单地替换文件，可以直接使用 以下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
jar uvf pas-server.jar com/ceiec/pas/server/service/impl/IncidentServiceImpl
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我是不推荐该命令的，因为很麻烦，要自己去新建一级一级的目录，而且一般class文件的包名都是以 . 来分隔的，还要手动修改为文件分隔符。其次，如果输错了路径，再想删掉这个class就麻烦了。&lt;/p&gt;

&lt;h2&gt;2、方式2，解压后再压缩的方式（极力推荐）&lt;/h2&gt;
&lt;p&gt;细分为以下几个步骤：&lt;/p&gt;
&lt;h3&gt;1、拷贝jar包为一个zip文件&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;span&gt;cp&lt;/span&gt; pas-server.jar pas-server.&lt;span&gt;zip&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201908/519126-20190802211602465-338028986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、解压zip到指定文件夹&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;unzip&lt;/span&gt; pas-server.&lt;span&gt;zip&lt;/span&gt; -d pas-server-&lt;span&gt;unzip&lt;/span&gt;/
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3、进入解压后的文件夹，修改文件&lt;/h3&gt;
&lt;p&gt;解压后的spring boot包的结构如下，class自行修改即可（在BOOT-INF下面），我一般rz上传后，直接覆盖:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201908/519126-20190802211943686-243360497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4、重新打为spring boot 的fat包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
jar -cvfM0 pas-server.jar BOOT-INF/ META-INF/ org/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201908/519126-20190802214314536-1108653900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到，在pas-server.jar后，我们指定了多个目录，这几个目录即是spring boot 的那几个目录。&lt;/p&gt;

&lt;p&gt;上述 jar 命令中相关的参数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201908/519126-20190802212847920-1029573258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;postTitle&quot;&gt;博主前几天随便记录的，和这个主题有点关系，比较适用于netty工程：&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/grey-wolf/p/11265298.html&quot;&gt;普通的maven项目，如何打成一个fat jar（包括了全部依赖jar包）？&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;今天这篇个人感觉不算丰满，但感觉没太多好写的，不像理论知识那些。不过这个还是蛮重要的，能解决开发中的实际问题，提升大家的效率吧。&lt;/p&gt;

</description>
<pubDate>Fri, 02 Aug 2019 13:47:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>一、前言 相信很多同学有这样的需求，现在很多公司都有多地的研发中心，经常需要跨地区部署，比如，博主人在成都，但是服务器是北京的。一般城市间网络都不怎么好，上传一个几十兆的jar包那是真的慢，别说现在微</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/11291379.html</dc:identifier>
</item>
</channel>
</rss>