<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Curl命令大全 - 男子汉i</title>
<link>http://www.cnblogs.com/dai-zhe/p/11509904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dai-zhe/p/11509904.html</guid>
<description>&lt;p&gt;1.命令介绍：curl&lt;br/&gt;在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。&lt;/p&gt;
&lt;p&gt;2.语法：# curl [option] [url]&lt;/p&gt;
&lt;p&gt;3.常见参数：&lt;br/&gt;-A/--user-agent &amp;lt;string&amp;gt; 设置用户代理发送给服务器&lt;br/&gt;-b/--cookie &amp;lt;name=string/file&amp;gt; *cookie字符串或文件读取位置&lt;br/&gt;-c/--cookie-jar &amp;lt;file&amp;gt; *操作结束后把cookie写入到这个文件中&lt;br/&gt;-C/--continue-at &amp;lt;offset&amp;gt; *断点续转&lt;br/&gt;-D/--dump-header &amp;lt;file&amp;gt; *把header信息写入到该文件中&lt;br/&gt;-e/--referer *来源网址&lt;br/&gt;-f/--fail *连接失败时不显示http错误&lt;br/&gt;-o/--output *把输出写到该文件中&lt;br/&gt;-O/--remote-name *把输出写到该文件中，保留远程文件的文件名&lt;br/&gt;-r/--range &amp;lt;range&amp;gt; 检索来自HTTP/1.1或FTP服务器字节范围&lt;br/&gt;-s/--silent *静音模式。不输出任何东西&lt;br/&gt;-T/--upload-file &amp;lt;file&amp;gt; 上传文件&lt;br/&gt;-u/--user &amp;lt;user[:password]&amp;gt; 设置服务器的用户和密码&lt;br/&gt;-w/--write-out [format] 什么输出完成后&lt;br/&gt;-x/--proxy &amp;lt;host[:port]&amp;gt; 在给定的端口上使用HTTP代理&lt;br/&gt;-#/--progress-bar *进度条显示当前的传送状态&lt;/p&gt;
&lt;p&gt;4.基本用法：&lt;br/&gt;curl http://www.linux.com&lt;/p&gt;
&lt;p&gt;5.保存访问的网页&lt;br/&gt;5.1:使用linux的重定向功能保存 #追加重定向&lt;br/&gt;# curl http://www.linux.com &amp;gt;&amp;gt; linux.html&lt;/p&gt;
&lt;p&gt;5.2:可以使用curl的内置option:-o(小写)保存网页&lt;br/&gt;$ curl -o linux.html http://www.linux.com&lt;br/&gt;执行完成后会显示如下界面，显示100%则表示保存成功&lt;br/&gt;% Total % Received % Xferd Average Speed Time Time Time Current&lt;br/&gt;Dload Upload Total Spent Left Speed&lt;br/&gt;100 79684 0 79684 0 0 3437k 0 --:--:-- --:--:-- --:--:-- 7781k&lt;/p&gt;&lt;p&gt;5.3:可以使用curl的内置option:-O(大写)保存网页中的文件&lt;br/&gt;要注意这里后面的url要具体到某个文件，不然抓不下来&lt;br/&gt;# curl -O http://www.linux.com/hello.sh&lt;/p&gt;&lt;p&gt;6.测试网页返回值&lt;br/&gt;# curl -o /dev/null -s -w %{http_code} www.linux.com&lt;br/&gt;Ps:在脚本中，这是很常见的测试网站是否正常的用法&lt;/p&gt;
&lt;p&gt;7.指定proxy服务器以及其端口&lt;br/&gt;很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理&lt;br/&gt;# curl -x 192.168.100.100:1080 http://www.linux.com&lt;br/&gt;8.cookie&lt;br/&gt;有些网站是使用cookie来记录session信息。对于chrome这样的浏览器，可以轻易处理cookie信息，但在curl中只要增加相关参数也是可以很容易的处理cookie&lt;br/&gt;8.1:保存http的response里面的cookie信息。内置option:-c（小写）&lt;br/&gt;# curl -c cookiec.txt http://www.linux.com&lt;br/&gt;执行后cookie信息就被存到了cookiec.txt里面了&lt;/p&gt;
&lt;p&gt;8.2:保存http的response里面的header信息。内置option: -D&lt;br/&gt;# curl -D cookied.txt http://www.linux.com&lt;br/&gt;执行后cookie信息就被存到了cookied.txt里面了&lt;br/&gt;注意：-c(小写)产生的cookie和-D里面的cookie是不一样的。&lt;/p&gt;
&lt;p&gt;8.3:使用cookie&lt;br/&gt;很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b&lt;br/&gt;# curl -b cookiec.txt http://www.linux.com&lt;/p&gt;
&lt;p&gt;9.模仿浏览器&lt;br/&gt;有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站&lt;br/&gt;# curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com&lt;br/&gt;这样服务器端就会认为是使用IE8.0去访问的&lt;/p&gt;
&lt;p&gt;10.伪造referer（盗链）&lt;br/&gt;很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了&lt;br/&gt;curl中内置option：-e可以让我们设定referer&lt;br/&gt;# curl -e &quot;www.linux.com&quot; http://mail.linux.com&lt;br/&gt;这样就会让服务器其以为你是从www.linux.com点击某个链接过来的&lt;/p&gt;
&lt;p&gt;11.下载文件&lt;br/&gt;11.1：利用curl下载文件。&lt;br/&gt;#使用内置option：-o(小写)&lt;br/&gt;# curl -o dodo1.jpg http:www.linux.com/dodo1.JPG&lt;br/&gt;#使用内置option：-O（大写)&lt;br/&gt;# curl -O http://www.linux.com/dodo1.JPG&lt;br/&gt;这样就会以服务器上的名称保存文件到本地&lt;/p&gt;
&lt;p&gt;11.2：循环下载&lt;br/&gt;有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样&lt;br/&gt;# curl -O http://www.linux.com/dodo[1-5].JPG&lt;br/&gt;这样就会把dodo1，dodo2，dodo3，dodo4，dodo5全部保存下来&lt;/p&gt;
&lt;p&gt;11.3：下载重命名&lt;br/&gt;# curl -O http://www.linux.com/{hello,bb}/dodo[1-5].JPG&lt;br/&gt;由于下载的hello与bb中的文件名都是dodo1，dodo2，dodo3，dodo4，dodo5。因此第二次下载的会把第一次下载的覆盖，这样就需要对文件进行重命名。&lt;/p&gt;&lt;p&gt;# curl -o #1_#2.JPG http://www.linux.com/{hello,bb}/dodo[1-5].JPG&lt;br/&gt;这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖&lt;/p&gt;
&lt;p&gt;11.4：分块下载&lt;br/&gt;有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r&lt;br/&gt;# curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG&lt;br/&gt;# curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG&lt;br/&gt;# curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG&lt;br/&gt;# cat dodo1_part* &amp;gt; dodo1.JPG&lt;br/&gt;这样就可以查看dodo1.JPG的内容了&lt;/p&gt;
&lt;p&gt;11.5：通过ftp下载文件&lt;br/&gt;curl可以通过ftp下载文件，curl提供两种从ftp中下载的语法&lt;br/&gt;# curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG&lt;br/&gt;# curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG&lt;/p&gt;
&lt;p&gt;11.6：显示下载进度条&lt;br/&gt;# curl -# -O http://www.linux.com/dodo1.JPG&lt;/p&gt;&lt;p&gt;12.7：不会显示下载进度信息&lt;br/&gt;# curl -s -O http://www.linux.com/dodo1.JPG&lt;/p&gt;
&lt;p&gt;12.断点续传&lt;br/&gt;在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果&lt;br/&gt;如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传&lt;br/&gt;# curl -C -O http://www.linux.com/dodo1.JPG&lt;/p&gt;
&lt;p&gt;13.上传文件&lt;br/&gt;curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现&lt;br/&gt;# curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/&lt;br/&gt;这样就向ftp服务器上传了文件dodo1.JPG&lt;/p&gt;
&lt;p&gt;14.显示抓取错误&lt;br/&gt;# curl -f http://www.linux.com/error&lt;br/&gt;其他参数(此处翻译为转载)：&lt;br/&gt;复制代码&lt;br/&gt;-a/--append 上传文件时，附加到目标文件&lt;br/&gt;--anyauth 可以使用“任何”身份验证方法&lt;br/&gt;--basic 使用HTTP基本验证&lt;br/&gt;-B/--use-ascii 使用ASCII文本传输&lt;br/&gt;-d/--data &amp;lt;data&amp;gt; HTTP POST方式传送数据&lt;br/&gt;--data-ascii &amp;lt;data&amp;gt; 以ascii的方式post数据&lt;br/&gt;--data-binary &amp;lt;data&amp;gt; 以二进制的方式post数据&lt;br/&gt;--negotiate 使用HTTP身份验证&lt;br/&gt;--digest 使用数字身份验证&lt;br/&gt;--disable-eprt 禁止使用EPRT或LPRT&lt;br/&gt;--disable-epsv 禁止使用EPSV&lt;br/&gt;--egd-file &amp;lt;file&amp;gt; 为随机数据(SSL)设置EGD socket路径&lt;br/&gt;--tcp-nodelay 使用TCP_NODELAY选项&lt;br/&gt;-E/--cert &amp;lt;cert[:passwd]&amp;gt; 客户端证书文件和密码 (SSL)&lt;br/&gt;--cert-type &amp;lt;type&amp;gt; 证书文件类型 (DER/PEM/ENG) (SSL)&lt;br/&gt;--key &amp;lt;key&amp;gt; 私钥文件名 (SSL)&lt;br/&gt;--key-type &amp;lt;type&amp;gt; 私钥文件类型 (DER/PEM/ENG) (SSL)&lt;br/&gt;--pass &amp;lt;pass&amp;gt; 私钥密码 (SSL)&lt;br/&gt;--engine &amp;lt;eng&amp;gt; 加密引擎使用 (SSL). &quot;--engine list&quot; for list&lt;br/&gt;--cacert &amp;lt;file&amp;gt; CA证书 (SSL)&lt;br/&gt;--capath &amp;lt;directory&amp;gt; CA目 (made using c_rehash) to verify peer against (SSL)&lt;br/&gt;--ciphers &amp;lt;list&amp;gt; SSL密码&lt;br/&gt;--compressed 要求返回是压缩的形势 (using deflate or gzip)&lt;br/&gt;--connect-timeout &amp;lt;seconds&amp;gt; 设置最大请求时间&lt;br/&gt;--create-dirs 建立本地目录的目录层次结构&lt;br/&gt;--crlf 上传是把LF转变成CRLF&lt;br/&gt;--ftp-create-dirs 如果远程目录不存在，创建远程目录&lt;br/&gt;--ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用&lt;br/&gt;--ftp-pasv 使用 PASV/EPSV 代替端口&lt;br/&gt;--ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址&lt;br/&gt;--ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输&lt;br/&gt;--ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输&lt;br/&gt;-F/--form &amp;lt;name=content&amp;gt; 模拟http表单提交数据&lt;br/&gt;-form-string &amp;lt;name=string&amp;gt; 模拟http表单提交数据&lt;br/&gt;-g/--globoff 禁用网址序列和范围使用{}和[]&lt;br/&gt;-G/--get 以get的方式来发送数据&lt;br/&gt;-h/--help 帮助&lt;br/&gt;-H/--header &amp;lt;line&amp;gt; 自定义头信息传递给服务器&lt;br/&gt;--ignore-content-length 忽略的HTTP头信息的长度&lt;br/&gt;-i/--include 输出时包括protocol头信息&lt;br/&gt;-I/--head 只显示文档信息&lt;br/&gt;-j/--junk-session-cookies 读取文件时忽略session cookie&lt;br/&gt;--interface &amp;lt;interface&amp;gt; 使用指定网络接口/地址&lt;br/&gt;--krb4 &amp;lt;level&amp;gt; 使用指定安全级别的krb4&lt;br/&gt;-k/--insecure 允许不使用证书到SSL站点&lt;br/&gt;-K/--config 指定的配置文件读取&lt;br/&gt;-l/--list-only 列出ftp目录下的文件名称&lt;br/&gt;--limit-rate &amp;lt;rate&amp;gt; 设置传输速度&lt;br/&gt;--local-port&amp;lt;NUM&amp;gt; 强制使用本地端口号&lt;br/&gt;-m/--max-time &amp;lt;seconds&amp;gt; 设置最大传输时间&lt;br/&gt;--max-redirs &amp;lt;num&amp;gt; 设置最大读取的目录数&lt;br/&gt;--max-filesize &amp;lt;bytes&amp;gt; 设置最大下载的文件总量&lt;br/&gt;-M/--manual 显示全手动&lt;br/&gt;-n/--netrc 从netrc文件中读取用户名和密码&lt;br/&gt;--netrc-optional 使用 .netrc 或者 URL来覆盖-n&lt;br/&gt;--ntlm 使用 HTTP NTLM 身份验证&lt;br/&gt;-N/--no-buffer 禁用缓冲输出&lt;br/&gt;-p/--proxytunnel 使用HTTP代理&lt;br/&gt;--proxy-anyauth 选择任一代理身份验证方法&lt;br/&gt;--proxy-basic 在代理上使用基本身份验证&lt;br/&gt;--proxy-digest 在代理上使用数字身份验证&lt;br/&gt;--proxy-ntlm 在代理上使用ntlm身份验证&lt;br/&gt;-P/--ftp-port &amp;lt;address&amp;gt; 使用端口地址，而不是使用PASV&lt;br/&gt;-Q/--quote &amp;lt;cmd&amp;gt; 文件传输前，发送命令到服务器&lt;br/&gt;--range-file 读取（SSL）的随机文件&lt;br/&gt;-R/--remote-time 在本地生成文件时，保留远程文件时间&lt;br/&gt;--retry &amp;lt;num&amp;gt; 传输出现问题时，重试的次数&lt;br/&gt;--retry-delay &amp;lt;seconds&amp;gt; 传输出现问题时，设置重试间隔时间&lt;br/&gt;--retry-max-time &amp;lt;seconds&amp;gt; 传输出现问题时，设置最大重试时间&lt;br/&gt;-S/--show-error 显示错误&lt;br/&gt;--socks4 &amp;lt;host[:port]&amp;gt; 用socks4代理给定主机和端口&lt;br/&gt;--socks5 &amp;lt;host[:port]&amp;gt; 用socks5代理给定主机和端口&lt;br/&gt;-t/--telnet-option &amp;lt;OPT=val&amp;gt; Telnet选项设置&lt;br/&gt;--trace &amp;lt;file&amp;gt; 对指定文件进行debug&lt;br/&gt;--trace-ascii &amp;lt;file&amp;gt; Like --跟踪但没有hex输出&lt;br/&gt;--trace-time 跟踪/详细输出时，添加时间戳&lt;br/&gt;--url &amp;lt;URL&amp;gt; Spet URL to work with&lt;br/&gt;-U/--proxy-user &amp;lt;user[:password]&amp;gt; 设置代理用户名和密码&lt;br/&gt;-V/--version 显示版本信息&lt;br/&gt;-X/--request &amp;lt;command&amp;gt; 指定什么命令&lt;br/&gt;-y/--speed-time 放弃限速所要的时间。默认为30&lt;br/&gt;-Y/--speed-limit 停止传输速度的限制，速度时间'秒&lt;br/&gt;-z/--time-cond 传送时间设置&lt;br/&gt;-0/--http1.0 使用HTTP 1.0&lt;br/&gt;-1/--tlsv1 使用TLSv1（SSL）&lt;br/&gt;-2/--sslv2 使用SSLv2的（SSL）&lt;br/&gt;-3/--sslv3 使用的SSLv3（SSL）&lt;br/&gt;--3p-quote like -Q for the source URL for 3rd party transfer&lt;br/&gt;--3p-url 使用url，进行第三方传送&lt;br/&gt;--3p-user 使用用户名和密码，进行第三方传送&lt;br/&gt;-4/--ipv4 使用IP4&lt;br/&gt;-6/--ipv6 使用IP6&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 00:38:00 +0000</pubDate>
<dc:creator>男子汉i</dc:creator>
<og:description>1.命令介绍：curl	在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dai-zhe/p/11509904.html</dc:identifier>
</item>
<item>
<title>.NET 分布式自增Id组件（解决自动分配机器Id、时间回拨问题） - 寒空飞箭</title>
<link>http://www.cnblogs.com/coldairarrow/p/11509881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coldairarrow/p/11509881.html</guid>
<description>&lt;p&gt;IdHelper是一个.NET（支持.NET45+或.NET Standard2+）生成分布式趋势自增Id组件，有两个版本：&lt;strong&gt;原始版&lt;/strong&gt;为基于雪花Id（不了解请自行百度）方案，需要手动管理设置WorkerId；&lt;strong&gt;完美版&lt;/strong&gt;在原始版的基础上使用Zookeeper来解决原始版中的WorkerId的分配问题和时间回拨问题。&lt;/p&gt;
&lt;p&gt;原始版安装方式：Nuget安装&lt;strong&gt;IdHelper&lt;/strong&gt;即可&lt;/p&gt;
&lt;p&gt;完美版安装方式：Nuget安装&lt;strong&gt;IdHelper.Zookeeper&lt;/strong&gt;即可&lt;/p&gt;
&lt;p&gt;请按需选择，强烈推荐&lt;strong&gt;完美版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Coldairarrow/IdHelper&quot; class=&quot;uri&quot;&gt;https://github.com/Coldairarrow/IdHelper&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;分布式趋势自增Id的生成方案比较多，其中雪花Id是比较常用的，但是雪花Id及其依赖WorkerId的分配和机器时钟。WorkerId分配问题：传统雪花Id是需要分配数据中心Id和机器Id（即WorkerId），我为了使用方便（项目比较小），用不到数据中心Id，就把数据中心Id去掉并补充到机器Id，使机器Id可分配范围为1~1023，每个服务机器Id不能重复，若手工去为每个服务设置无疑十分麻烦还容易搞错（其实是&lt;strong&gt;懒&lt;/strong&gt;）。时钟回拨问题：由于强依赖机器时钟，因此当时间回拨时将发生灾难性问题，虽然这种概率很小，但是实际存在。为了解决上述两个问题，本组件应运而生。&lt;/p&gt;

&lt;h2 id=&quot;原始版&quot;&gt;原始版&lt;/h2&gt;
&lt;p&gt;Nuget安装包：IdHelper&lt;/p&gt;
&lt;p&gt;刚出炉的包，排名比较靠后，请认准作者：Coldairarrow&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Coldairarrow.Util;
using System;

namespace Demo
{
    class Program
    {
        static void Main(string[] args)
        {
            new IdHelperBootstrapper()
                //设置WorkerId
                .SetWorkderId(1)
                .Boot();

            Console.WriteLine($&quot;WorkerId:{IdHelper.WorkerId},Id:{IdHelper.GetId()}&quot;);

            Console.ReadLine();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;完美版&quot;&gt;完美版&lt;/h2&gt;
&lt;p&gt;1：安装并配置JAVA环境（Zookeeper需要用JAVA） 教程：&lt;a href=&quot;https://blog.csdn.net/qq_42040731/article/details/82598034&quot;&gt;连接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2：安装并启动Zookeeper，教程：&lt;a href=&quot;https://blog.csdn.net/ring300/article/details/80446918&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3：Nuget安装包：IdHelper.Zookeeper&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Coldairarrow.Util;
using System;

namespace Demo.Zookeeper
{
    class Program
    {
        static void Main(string[] args)
        {
            new IdHelperBootstrapper()
                //使用Zookeeper自动分配管理WorkerId,解决时间回退问题和自动分配问题
                .UseZookeeper(&quot;127.0.0.1:2181&quot;, 200, &quot;Test&quot;)
                .Boot();

            Console.WriteLine($&quot;WorkerId:{IdHelper.WorkerId},Id:{IdHelper.GetId()}&quot;);

            Console.ReadLine();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Coldairarrow.Util;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;

namespace Demo.Test
{
    class Program
    {
        static void Main(string[] args)
        {
            string conString = &quot;127.0.0.1:2181&quot;;
            new IdHelperBootstrapper()
                .UseZookeeper(conString, 200, &quot;Test&quot;)
                .Boot();

            Console.WriteLine($&quot;WorkerId:{IdHelper.WorkerId}&quot;);

            Stopwatch watch = new Stopwatch();
            watch.Start();
            List&amp;lt;Task&amp;gt; tasks = new List&amp;lt;Task&amp;gt;();
            BlockingCollection&amp;lt;string&amp;gt; ids = new BlockingCollection&amp;lt;string&amp;gt;();
            for (int i = 0; i &amp;lt; 4; i++)
            {
                tasks.Add(Task.Run(() =&amp;gt;
                {
                    for (int j = 0; j &amp;lt; 1000000; j++)
                    {
                        ids.Add(IdHelper.GetId());
                    }
                }));
            }
            Task.WaitAll(tasks.ToArray());
            watch.Stop();
            Console.WriteLine($&quot;耗时:{watch.ElapsedMilliseconds}ms,是否有重复:{ids.Count != ids.Distinct().Count()}&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;以上所有示例在源码中都有，若觉得不错请点赞加星星，希望能够帮助到大家。&lt;/p&gt;
&lt;p&gt;有任何问题请及时反馈或加群交流&lt;/p&gt;
&lt;p&gt;QQ群1:（已满）&lt;/p&gt;
&lt;p&gt;QQ群2:579202910&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 00:22:00 +0000</pubDate>
<dc:creator>寒空飞箭</dc:creator>
<og:description>.NET 分布式自增Id生成组件，基于雪花Id改进版，简洁易用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coldairarrow/p/11509881.html</dc:identifier>
</item>
<item>
<title>关于三次握手与四次挥手你要知道这些 - 全菜工程师小辉</title>
<link>http://www.cnblogs.com/mseddl/p/11509867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mseddl/p/11509867.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190912080933324-633796525.png&quot; alt=&quot;TCP的有限状态机&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果没有基础的话，直接看这张图或者网络上各种文字描述，十分生涩，所以先看懂接下来的握手挥手的图，理解之后，再看这个有限状态机就感觉原来如此简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190912080933610-1414124714.png&quot; alt=&quot;TCP三次握手&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;握手过程&quot;&gt;握手过程&lt;/h2&gt;
&lt;p&gt;第一次握手：主机A发送位码为syn＝1，随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道A要求建立连接。&lt;/p&gt;
&lt;p&gt;第二次握手：主机B收到请求后要确认连接信息，向A发送ack number(主机A的seq+1)、syn=1、ack=1，随机产生seq=y的包，此时服务器进入SYN_RECV状态。&lt;/p&gt;
&lt;p&gt;第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1)、ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入ESTABLISHED状态。&lt;/p&gt;
&lt;h2 id=&quot;三次握手的必要性&quot;&gt;三次握手的必要性&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收能力，服务器自己的发送能力也正常。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此，客户端和服务端可以确定双方的接收和发送能力均正常。&lt;/p&gt;
&lt;h2 id=&quot;第三次握手的必要性&quot;&gt;第三次握手的必要性&lt;/h2&gt;
&lt;p&gt;这主要是为了防止已失效的连接请求报文段突然又传送到了服务器端，从而减少服务端的开销。&lt;br/&gt;如果只有两次握手就建立连接会出现这种情况：客户端发出的连接请求报文段在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才能到达服务端。本来这是一个早已失效的报文段，但服务端收到此失效的连接请求报文段后，就误认为客户端又发出了一次新的连接请求。于是向客户端发出确认报文段，同意建立连接。由于现在客户端并没有发出建立连接的请求，因此不会处理服务端的确认，也不会向服务端发送数据。但服务端却以为新的连接已经建立了，并一直等待客户端发来数据。 服务端会因此浪费很多了。&lt;/p&gt;
&lt;h2 id=&quot;如果第三次握手丢失了客户端服务端会如何处理&quot;&gt;如果第三次握手丢失了，客户端服务端会如何处理？&lt;/h2&gt;
&lt;p&gt;服务端：&lt;br/&gt;该TCP连接的状态为SYN_RECV,并且会根据TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。如果重发指定次数之后，仍然未收到客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。&lt;br/&gt;客户端：&lt;br/&gt;客户端在接收到SYN+ACK包，它的TCP连接状态就为ESTABLISHED（已连接），表示该连接已经建立。那么如果第三次握手中的ACK包丢失的情况下，客户端向服务端发送数据，服务端将以RST包(reset重置)响应，才能感知到服务端的错误。&lt;/p&gt;
&lt;h2 id=&quot;什么是syn-flood攻击&quot;&gt;什么是syn flood攻击&lt;/h2&gt;
&lt;p&gt;syn flood是一种经典的ddos攻击手段，这里面用到了TCP三次握手存在的漏洞。当服务端接收到SYN后进入SYN-RECV状态，此时的连接称为半连接，同时会被服务端写入一个半连接队列。如果攻击者在短时间内不断的向服务端发送大量的SYN包而不响应，那么服务器的半连接队列很快会被写满，从而导致无法工作。 实现syn flood 的手段，可以通过伪造源IP的方式，这样服务器的响应就永远到达不了客户端(握手无法完成)；当然，通过设定客户端防火墙规则也可以达到同样的目的。对syn flood实现拦截是比较困难的，可以通过启用 syn_cookies 的方式实现缓解，但这通常不是最佳方案。最好的办法是通过专业的防火墙来解决，基本上所有的云计算大 都具备这个能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190912080933785-789682461.png&quot; alt=&quot;TCP四次挥手&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;挥手过程&quot;&gt;挥手过程&lt;/h2&gt;
&lt;p&gt;第一次挥手：主机A（可以是客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机B发送一个FIN报文段；此时，主机A进入FIN_WAIT_1状态；这表示主机A没有数据要发送给主机B了。&lt;br/&gt;第二次挥手：主机B收到了主机A发送的FIN报文段，向主机A回一个ACK报文段，Acknowledgment Number为Sequence Number加1，主机A进入FIN_WAIT_2状态；主机B告诉主机A，我也没有数据要发送了，可以进行关闭连接了。&lt;br/&gt;第三次挥手：主机B向主机A发送FIN报文段，请求关闭连接，同时主机B进入CLOSE_WAIT状态。&lt;br/&gt;第四次挥手：主机A收到主机B发送的FIN报文段，向主机B发送ACK报文段，然后主机A进入TIME_WAIT状态；主机B收到主机A的ACK报文段以后，就关闭连接；此时，主机A等待2MSL后依然没有收到回复，则证明主机B已正常关闭，那好，主机A也可以关闭连接了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;主机B发送了FIN-ACK之后，会立即启动超时重传计时器&lt;br/&gt;主机A在发送最后一个ACK之后，会立即启动时间等待计时器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;挥手为什么需要四次&quot;&gt;挥手为什么需要四次？&lt;/h2&gt;
&lt;p&gt;因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，&quot;你发的FIN报文我收到了&quot;。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。&lt;/p&gt;
&lt;h2 id=&quot;rst是什么为什么会出现&quot;&gt;RST是什么，为什么会出现&lt;/h2&gt;
&lt;p&gt;RST 是一个特殊的标记，用来表示当前应该立即终止连接。以下这些情况都会产生RST：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;向一个未被监听的端口发送数据&lt;/li&gt;
&lt;li&gt;对方已经调用 close 关闭连接&lt;/li&gt;
&lt;li&gt;存在一些数据未处理(接收缓冲区)，请求关闭连接时，会发送RST强制关闭&lt;/li&gt;
&lt;li&gt;某些请求发生了超时&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;为什么服务器会有大量closewait&quot;&gt;为什么服务器会有大量closewait&lt;/h2&gt;
&lt;p&gt;半关闭的状态下的服务器连接会处于closewait状态，直到服务器发送了FIN。 那么在应用层则是调用socket.close()会执行FIN的发送，如果服务器出现大量CLOSE_WAIT状态的连接，那么有可能的原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务器压力过大，根本来不及调用close&lt;/li&gt;
&lt;li&gt;存在连接泄露问题(Bug)，服务器未及时关闭连接&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四次挥手释放连接时等待2msl的意义&quot;&gt;四次挥手释放连接时，等待2MSL的意义&lt;/h2&gt;
&lt;p&gt;为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。我们都知道IP头部中有个TTL字段，TTL是time to live的缩写，可译为“生存时间”，这个生存时间是由源主机设置初始值代表一个IP数据包可以经过的最大路由数，每经过一个路由器，它的值就减1，当此值为0则数据报被丢弃，同时发送ICMP报文通知源主机。RFC793中规定MSL为2分钟，但这完全是从工程上来考虑，对于现在的网络，常用值30秒或1分钟。因此TCP允许不同的实现可根据具体情况使用更小的MSL值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，限于笔者经验水平有限，欢迎读者就文中的观点提出宝贵的建议和意见。如果想获得更多的学习资源或者想和更多的是技术爱好者一起交流，可以关注我的公众号『全菜工程师小辉』后台回复关键词领取学习资料、进入前后端技术交流群和程序员副业群。同时也可以加入程序员副业群Q群：735764906 一起交流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190912080934160-543157291.gif&quot; alt=&quot;哎呀，如果我的名片丢了。微信搜索“全菜工程师小辉”，依然可以找到我&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 00:10:00 +0000</pubDate>
<dc:creator>全菜工程师小辉</dc:creator>
<og:description>TCP的整个连接过程 如果没有基础的话，直接看这张图或者网络上各种文字描述，十分生涩，所以先看懂接下来的握手挥手的图，理解之后，再看这个有限状态机就感觉原来如此简单。 三次握手 握手过程 第一次握手：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mseddl/p/11509867.html</dc:identifier>
</item>
<item>
<title>杂谈：面向微服务的体系结构评审中需要问的三个问题 - 锅外的大佬</title>
<link>http://www.cnblogs.com/liululee/p/11509836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liululee/p/11509836.html</guid>
<description>&lt;p&gt;面向微服务的体系结构如今风靡全球。这是因为更快的部署节奏和更低的成本是面向微服务的体系结构的基本承诺。&lt;/p&gt;
&lt;p&gt;然而，对于大多数试水的公司来说，开发活动更多的是将现有的单块应用程序转换为面向微服务的体系结构，这可能是许多层面上阻碍和冲突的根源。&lt;/p&gt;
&lt;p&gt;虽然&lt;a href=&quot;https://searchunifiedcommunications.techtarget.com/definition/greenfield-deployment&quot;&gt;Greenfield&lt;/a&gt; (未开发的)面向微服务的体系结构实现可以坚持对当前微服务的严格解释-设计原则。但在面向微服务的体系结构中，分解的遗留应用程序存在灰色阴影，如果没有其他原因，只能满足预算和时间限制。&lt;/p&gt;
&lt;p&gt;在企业管理链的某个地方，有一位业务主管在一个面向微服务的体系结构中查看与这些遗留应用程序相关的分解成本，并将其与遗留代码已经提供的价值进行比较。一旦开发成本超过了预期的收益，业务主管很可能会退出并取消该项目。&lt;/p&gt;
&lt;p&gt;这种事经常会发生。&lt;/p&gt;
&lt;p&gt;因此，开发经理面临着巨大的压力，要求他们尽快将代码输出。“足够好”地成为转型的理想目标。&lt;/p&gt;
&lt;p&gt;现在，这不一定是一件坏事。与等待梦想到来相比，输出工作代码的能力总是更好。但是，“灰色的阴影”是很难管理的，问题就在于如何界定“足够好”的界限。&lt;/p&gt;
&lt;p&gt;因此，冲突开始了。一方想要输出他们想要的东西，而另一方则希望做更多的改进。&lt;/p&gt;
&lt;p&gt;对你来说，挑战是不要让这些&lt;a href=&quot;https://searchmicroservices.techtarget.com/tip/5-basic-SOA-principles-that-still-apply-to-microservices&quot;&gt;不同学派&lt;/a&gt;在本质上是信仰支持的观点上制造一场没完没了的争吵。如果您这样做了，它将造成一种情况，即根本不提供任何代码。现在，冲突可以从许多相互竞争的想法中综合出最好的想法。但是，当话语退化为永无止境的冲突时，它可能是致命的。&lt;/p&gt;
&lt;p&gt;我通过集中讨论以下三个问题来处理这类情况，以避免这种冲突：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设计的理由是什么？&lt;/li&gt;
&lt;li&gt;风险有多大？&lt;/li&gt;
&lt;li&gt;减少风险的计划是什么？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请允许我详细说明。&lt;/p&gt;
&lt;h2 id=&quot;设计的理由是什么&quot;&gt;1. 设计的理由是什么？&lt;/h2&gt;
&lt;p&gt;当您评估面向微服务的体系结构的设计时，所面临的挑战是将过去的观点转移到理论基础分析上。它的创建主要来自于单个应用程序的分解。任何设计都可能“足够好”，只要你能证明它的好处和价值。&lt;/p&gt;
&lt;p&gt;例如，面向微服务的体系结构设计的首选样式之一是采用事件驱动的方法进行服务间通信。具体来说，这意味着您使用消息节点&lt;a href=&quot;https://searchmicroservices.techtarget.com/tip/Synchronous-vs-asynchronous-communication-The-differences&quot;&gt;以异步方式&lt;/a&gt;在微服务之间传递消息。然而，从长远来看，虽然异步通信更加灵活和可扩展，但消息系统实现比在“面向”微服务的API之间使用同步HTTP调用的设计要复杂得多。因此，当市场时间被关注时，完全有理由将单块应用程序中的特性重构为以HTTP API方式表示的独立的微服务。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190912065637610-480732563.png;%20charset=binary&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;与异步服务相比，同步微服务的实现通常不那么复杂。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从长远来看，同步通信不一定是最佳选择，但考虑到从单块应用程序中提取独立的微服务所需的所有其他工作，同步对于第一个版本来说是“足够好”的。因此，这是一个合理的理由。&lt;/p&gt;
&lt;p&gt;然而，这并不是说同步方法没有风险。事实上，风险有很多。当涉及到审查面向微服务的体系结构设计时，仅仅说明理由并不是唯一的因素。风险也必须加以阐述。&lt;/p&gt;
&lt;h2 id=&quot;风险有多大&quot;&gt;2. 风险有多大？&lt;/h2&gt;
&lt;p&gt;所有的设计都有内在的风险。在上面描述的同步设计示例中，这种服务间通信方法可能会导致服务之间类型耦合的风险，由于同步HTTP通信和其他通信的性质而&lt;a href=&quot;https://searchmicroservices.techtarget.com/tip/Microservices-challenges-include-latency-but-it-can-be-beat&quot;&gt;增加延迟&lt;/a&gt;增加延迟。&lt;/p&gt;
&lt;p&gt;重要的是要让人们知道这些风险，这样就可以根据预期设计的合理性来权衡它们。如果风险是巨大的，再多的理由也是不够的。另一方面，考虑到目前的需求，某些风险可能是可以接受的。诀窍是确保风险在审查过程中得到明确的传达。讨论中已知的风险总是比隐藏的风险更可取，而这种风险可能会在路上造成冲击。此外，如果您以前知道风险，那么随着面向微服务的体系结构的成熟，您可以计划如何在未来的版本中更好地向前迈进。这就是减少风险的原因。&lt;/p&gt;
&lt;h2 id=&quot;减少风险的计划是什么&quot;&gt;3. 减少风险的计划是什么？&lt;/h2&gt;
&lt;p&gt;一个明智的应用程序设计人员的一个标志是能够识别他们的设计风险，一旦确定下来他会有远见地阐明一种方法，以减轻这些风险。没有适当的缓解技术的风险识别是思维不完整的标志。&lt;/p&gt;
&lt;p&gt;如果面向微服务的体系结构设计有很大的风险和解决这些问题的边际计划，那么设计团队需要认真考虑其可行性。此外，如果缓解计划不切实际-超出&lt;a href=&quot;https://searchmicroservices.techtarget.com/tip/Understand-business-logic-to-fortify-microservices-design&quot;&gt;项目的专门知识和预算&lt;/a&gt;-设计的可行性也需要质疑。这都是平衡的问题。&lt;/p&gt;
&lt;p&gt;一个平衡良好的面向微服务的体系结构设计是合理的，因为它想要满足的条件与其固有的设计风险和旨在解决这些风险的缓解计划相权衡。&lt;/p&gt;
&lt;h2 id=&quot;把它们放在一起&quot;&gt;4. 把它们放在一起&lt;/h2&gt;
&lt;p&gt;冲突是创造性进程的重要组成部分。有创造力的人往往对自己的想法坚韧不拔。所以，当你把它们放在一个房间里，让他们为面向微服务的建筑设计一个单一的设计时，紧张关系肯定会加剧。事情就是这样的。但要振作起来！冲突是好事。&lt;/p&gt;
&lt;p&gt;幸运的是，有了一种理性的方法，用我前面描述的三个问题来审查面向微服务的体系结构设计，您就可以促进客观的讨论，从而产生软件以及时满足您的需求。没有任何设计是完美的，特别是那些分解单个应用程序的设计。但是，交付面向微服务的体系结构有一个很大的好处，这个体系结构足够好&lt;a href=&quot;https://microservices.io/patterns/microservices.html&quot;&gt;有效运作&lt;/a&gt;在短期和灵活性足够持续不断改善长期。&lt;/p&gt;
&lt;blockquote readability=&quot;1.68&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/3-questions-to-ask-in-a-microservices-oriented-architecture-review&quot; class=&quot;uri&quot;&gt;https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/3-questions-to-ask-in-a-microservices-oriented-architecture-review&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：Bob Reselman&lt;/p&gt;
&lt;h2 id=&quot;译者遗失的拂晓&quot;&gt;译者：遗失的拂晓&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;9月福利，关注公众号&lt;br/&gt;​&lt;br/&gt;后台回复：004，领取8月翻译集锦!&lt;br/&gt;​&lt;br/&gt;往期福利回复：001，002, 003即可领取！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190912065641709-1370437382.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Sep 2019 22:57:00 +0000</pubDate>
<dc:creator>锅外的大佬</dc:creator>
<og:description>面向微服务的体系结构如今风靡全球。这是因为更快的部署节奏和更低的成本是面向微服务的体系结构的基本承诺。 然而，对于大多数试水的公司来说，开发活动更多的是将现有的单块应用程序转换为面向微服务的体系结构，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liululee/p/11509836.html</dc:identifier>
</item>
<item>
<title>编译原理之理解文法和语言 - Rakers</title>
<link>http://www.cnblogs.com/Rakers1024/p/11509796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rakers1024/p/11509796.html</guid>
<description>&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　一个程序设计语言是一个记号系统，如同自然语言一样，它的完整定义应包括语法和语义两个方面。所谓一个语言的语法是指一组规则，用它可以形成和产生一个合适的程序。目前广泛使用的手段是上下文无关文法，即用上下文无关文法作为程序设计语言语法的描述工具。语法只是定义什么样的符号序列是合法的，与这些符号的含义毫无关系，比如对于一个Pascal程序来说，一个上下文无关文法可以定义符号串A：=B+C是一个合乎语法的赋值语句，而A：=B+就不是。但是，如果B是实型的，而C是布尔型的，或者B、C中任何一个变量没有事先说明，则A：=B+C仍不是正确的程序，也就是说程序结构上的这种特点——类型匹配、变量作用域等是无法用上下文无关手段检查的，这些工作属于语义分析工作。程序设计语言的语义常常分为两类：静态语义和动态语义。静态语义是一系列限定规则，并确定哪些合乎语法的程序是合适的；动态语义也称作运行语义或执行语义，表明程序要做些什么，要计算什么。&lt;br/&gt;　　阐明语法的一个工具是文法，这是形式语言理论的基本概念之一。本章将介绍文法和语言的概念，重点讨论上下文无关文法及其句型分析中的有关问题。&lt;br/&gt;阐明语义要比阐明语法困难得多，尽管形式语义学的研究已取得重大进展，但是仍没有哪一种公认的形式系统可用来自动构造出正确的编译系统。本书不对形式语义学进行介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;1.理解符号串与集合运算。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;L={A,B, … ,Z,a,b, … ,z}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;D={0,1, … ,9}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;说明下表示的含义：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;LUD L和D都是集合，那么LUD&lt;span&gt;即为&lt;/span&gt;L的D的并集合，即L={A,B, … ,Z,a,b, … ,z,0,1, … ,9}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;LD =&amp;gt;&amp;gt; {xy | x∈L且y∈D}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;L4 L集合的4位组合即{AAAA, AAAB, ..., zzzz}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;L* &lt;span&gt;集合&lt;/span&gt;L的闭包&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;D+ &lt;span&gt;表示&lt;/span&gt;D的正闭包&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;L(LUD)* L并D的正闭包与L的乘积，即{xy | x∈L且y∈(LUD)*}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;2.文法G(Z):Z-&amp;gt;aZb|ab定义的是什么样的语言？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;span&gt;定义的是&lt;span&gt;规则，也称作重写规则，产生式或生成式&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;Z-&amp;gt;aZb|ab&lt;span&gt;，&lt;/span&gt;&lt;span&gt;即&lt;/span&gt;Z-&amp;gt;aZb-&amp;gt;aaZbb-&amp;gt;aaabbb&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;则：&lt;/span&gt;L(G) = {a&lt;sup&gt;n&lt;/sup&gt;b&lt;sup&gt;n&lt;/sup&gt; | n &amp;gt; 1}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;3.写出教材22页例2.2中标识符的文法四元组形式(VN,NT,P,S)。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;例&lt;/span&gt;2.2&lt;/strong&gt;有文法G=（V&lt;sub&gt;N&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;V&lt;sub&gt;T&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;P，S）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V&lt;sub&gt;N&lt;/sub&gt;={标识符，字母，数字}，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V&lt;sub&gt;T&lt;/sub&gt;={a，b，c&lt;span&gt;，&lt;/span&gt;... &lt;span&gt;，&lt;/span&gt;x，y，z，0，1&lt;span&gt;，&lt;/span&gt;... &lt;span&gt;，&lt;/span&gt;9}，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;P={&amp;lt;&lt;span&gt;标识符&lt;/span&gt;&amp;gt;→&amp;lt;&lt;span&gt;字母&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;span&gt;标识符&lt;/span&gt;&amp;gt;→&amp;lt;&lt;span&gt;标识符&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;字母&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;span&gt;标识符&lt;/span&gt;&amp;gt;→&amp;lt;&lt;span&gt;标识符&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;数字&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;span&gt;字母&lt;/span&gt;&amp;gt;→a&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;span&gt;字母&lt;/span&gt;&amp;gt;→b&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       ...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;span&gt;字母&lt;/span&gt;&amp;gt;→z&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;span&gt;数字&lt;/span&gt;&amp;gt;→0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;span&gt;数字&lt;/span&gt;&amp;gt;→1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       ...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;span&gt;数字&lt;/span&gt;&amp;gt;→9}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S=&amp;lt;&lt;span&gt;标识符&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;解：由此例题可设&lt;/span&gt;&amp;lt;&lt;span&gt;标识符&lt;/span&gt;&amp;gt;为I，&amp;lt;&lt;span&gt;字母&lt;/span&gt;&amp;gt;为L，&amp;lt;&lt;span&gt;数字&lt;/span&gt;&amp;gt;为D则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;P={I→L&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;I→IL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;I→ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;L→a&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;L→b&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  ...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;L→z&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D→0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D→1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  ...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D→9}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;S = I&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;则&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;I-&amp;gt; L|IL|ID&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;L-&amp;gt; a|b|c|...|x|y|z&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;D-&amp;gt; 0|1|2|...|8|9&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;4.写出下列表达式的最左推导、最右推导。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;G(E):&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;E=&amp;gt; E + T | T&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;T=&amp;gt;T * F | F&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;F=&amp;gt;（E）| i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最左推导：&lt;/span&gt;E =&amp;gt; E + T =&amp;gt; T+T =&amp;gt; T*F+T =&amp;gt; F*F+T =&amp;gt; i*F+T =&amp;gt; i*i+T =&amp;gt; i*i+F =&amp;gt; i*i+i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最&lt;/span&gt;&lt;span&gt;右&lt;/span&gt;&lt;span&gt;推导：&lt;/span&gt;E =&amp;gt; E + T =&amp;gt; E+F =&amp;gt; E+i =&amp;gt; T+i =&amp;gt; T*F+i =&amp;gt; T*i+i =&amp;gt; F*i+i =&amp;gt; i*i+i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最左推导：&lt;/span&gt;E =&amp;gt; E + T =&amp;gt; T+T =&amp;gt; F + T =&amp;gt; i + T*F =&amp;gt; i + F*F =&amp;gt; i + i*F =&amp;gt; i+i*i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最&lt;/span&gt;&lt;span&gt;右&lt;/span&gt;&lt;span&gt;推导：&lt;/span&gt;E =&amp;gt; E + T =&amp;gt; E + T*F =&amp;gt; E + T*i =&amp;gt; E + F*i =&amp;gt; E + i*i =&amp;gt; T +i*i =&amp;gt; F+i*i =&amp;gt; i+i*i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最左推导：&lt;/span&gt;E =&amp;gt; E + T =&amp;gt; T+T =&amp;gt; F + T =&amp;gt; i + F =&amp;gt; i+(E)=&amp;gt; i+(E+T) =&amp;gt; i+(T+T) =&amp;gt; i+(F+T) =&amp;gt; i+(i+T) =&amp;gt; i+(i+F) =&amp;gt; i+(i+i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最&lt;/span&gt;&lt;span&gt;右&lt;/span&gt;&lt;span&gt;推导：&lt;/span&gt;E =&amp;gt; E + T =&amp;gt; E + (E) =&amp;gt; E + (E) =&amp;gt; E + (E+T) =&amp;gt; E+(E+F)=&amp;gt; E+(E+i) =&amp;gt; E+(T+i) =&amp;gt; E+(F+i) =&amp;gt; E+(i+i) =&amp;gt; T+(i+i) =&amp;gt; F+(i+i) =&amp;gt; i+(i+i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; 注意观察最左和最右推导过程的不同。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 11 Sep 2019 18:25:00 +0000</pubDate>
<dc:creator>Rakers</dc:creator>
<og:description>简介 一个程序设计语言是一个记号系统，如同自然语言一样，它的完整定义应包括语法和语义两个方面。所谓一个语言的语法是指一组规则，用它可以形成和产生一个合适的程序。目前广泛使用的手段是上下文无关文法，即用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Rakers1024/p/11509796.html</dc:identifier>
</item>
<item>
<title>从原理层面掌握@InitBinder的使用【享学Spring MVC】 - _YourBatman</title>
<link>http://www.cnblogs.com/fangshixiang/p/11509660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fangshixiang/p/11509660.html</guid>
<description>&lt;h4 id=&quot;每篇一句&quot;&gt;每篇一句&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大魔王张怡宁：女儿，这堆金牌你拿去玩吧，但我的银牌不能给你玩。你要想玩银牌就去找你王浩叔叔吧，他那银牌多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;为了讲述好&lt;code&gt;Spring MVC&lt;/code&gt;最为复杂的数据绑定这块，我前面可谓是做足了功课，对此部分知识此处给小伙伴留一个学习入口，有兴趣可以点开看看：&lt;a href=&quot;https://blog.csdn.net/f641385712/article/details/96450469&quot;&gt;聊聊Spring中的数据绑定 --- WebDataBinder、ServletRequestDataBinder、WebBindingInitializer...【享学Spring】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@InitBinder&lt;/code&gt;这个注解是&lt;code&gt;Spring 2.5&lt;/code&gt;后推出来，用于数据绑定、设置数据转换器等，字面意思是“初始化绑定器”。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关于数据绑定器的概念，前面的功课中有重点详细讲解，此处默认小伙伴是熟悉了的~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;Spring MVC&lt;/code&gt;的web项目中，相信小伙伴们经常会遇到一些前端给后端传值比较棘手的问题：比如最经典的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Date&lt;/code&gt;类型（&lt;code&gt;或者LocalDate类型&lt;/code&gt;）前端如何传？后端可以用&lt;code&gt;Date&lt;/code&gt;类型接收吗？&lt;/li&gt;
&lt;li&gt;字符串类型，如何保证前段传入的值两端没有空格呢？（99.99%的情况下多余的空格都是木有用的）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这些看似不太好弄的问题，看了这篇文章你就可以&lt;strong&gt;优雅的&lt;/strong&gt;搞定了~&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;---&lt;/h2&gt;
&lt;p&gt;说明：关于&lt;code&gt;Date&lt;/code&gt;类型的传递，业界也有两个&lt;strong&gt;通用的解决方案&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用时间戳&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;String&lt;/code&gt;字符串（传值的万能方案）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用者两种方式总感觉不优雅，且不够面向对象。那么本文就介绍一个黑科技：使用&lt;code&gt;@InitBinder&lt;/code&gt;来便捷的实现&lt;strong&gt;各种数据类型&lt;/strong&gt;的数据绑定（咱们Java是强类型语言且面向对象的，如果啥都用字符串，是不是也太low了~）&lt;/p&gt;
&lt;h2 id=&quot;一般的string-int-long会自动绑定到参数但是自定义的格式spring就不知道如何绑定了-.所以要继承propertyeditorsupport实现自己的属性编辑器propertyeditor绑定到webdatabinder-binder.registercustomeditor覆盖方法setastext&quot;&gt;&amp;gt; 一般的string, int, long会自动绑定到参数，但是自定义的格式spring就不知道如何绑定了 .所以要继承&lt;code&gt;PropertyEditorSupport&lt;/code&gt;，实现自己的属性编辑器&lt;code&gt;PropertyEditor&lt;/code&gt;,绑定到&lt;code&gt;WebDataBinder ( binder.registerCustomEditor)&lt;/code&gt;，覆盖方法&lt;code&gt;setAsText&lt;/code&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;h2 id=&quot;initbinder原理&quot;&gt;&lt;code&gt;@InitBinder&lt;/code&gt;原理&lt;/h2&gt;
&lt;p&gt;本文先原理，再案例的方式，让你能够彻头彻尾的掌握到该注解的使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;code&gt;@InitBinder&lt;/code&gt;是什么时候生效的？&lt;/strong&gt;&lt;br/&gt;这就是前面文章埋下的伏笔：&lt;code&gt;Spring&lt;/code&gt;在绑定请求参数到&lt;code&gt;HandlerMethod&lt;/code&gt;的时候（此处以&lt;code&gt;RequestParamMethodArgumentResolver&lt;/code&gt;为例），会借助&lt;code&gt;WebDataBinder&lt;/code&gt;进行数据转换：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// RequestParamMethodArgumentResolver的父类就是它，resolveArgument方法在父类上
// 子类仅仅只需要实现抽象方法resolveName，即：从request里根据name拿值
AbstractNamedValueMethodArgumentResolver：

    @Override
    @Nullable
    public final Object resolveArgument( ... ) {
        ...
        Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);
        ...
        if (binderFactory != null) {
            // 创建出一个WebDataBinder
            WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);
            // 完成数据转换（比如String转Date、String转...等等）
            arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);
            ...
        }
        ...
        return arg;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它从请求request拿值得方法便是：&lt;code&gt;request.getParameterValues(name)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、web环境使用的数据绑定工厂是：&lt;code&gt;ServletRequestDataBinderFactory&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;虽然在前面功课中有讲到，但此处为了连贯性还是有必要再简单过一遍：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// @since 3.1 org.springframework.web.bind.support.DefaultDataBinderFactory 
public class DefaultDataBinderFactory implements WebDataBinderFactory {

    @Override
    @SuppressWarnings(&quot;deprecation&quot;)
    public final WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName) throws Exception {
        WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);
        
        // WebBindingInitializer initializer在此处解析完成了 全局生效
        if (this.initializer != null) {
            this.initializer.initBinder(dataBinder, webRequest);
        }
        // 解析@InitBinder注解，它是个protected空方法，交给子类复写实现
        // InitBinderDataBinderFactory对它有复写
        initBinder(dataBinder, webRequest);
        return dataBinder;
    }
}

public class InitBinderDataBinderFactory extends DefaultDataBinderFactory {
    // 保存所有的，
    private final List&amp;lt;InvocableHandlerMethod&amp;gt; binderMethods;
    ...
    @Override
    public void initBinder(WebDataBinder dataBinder, NativeWebRequest request) throws Exception {
        for (InvocableHandlerMethod binderMethod : this.binderMethods) {
            if (isBinderMethodApplicable(binderMethod, dataBinder)) {
                // invokeForRequest这个方法不用多说了，和调用普通控制器方法一样
                // 方法入参上也可以写格式各样的参数~~~~
                Object returnValue = binderMethod.invokeForRequest(request, null, dataBinder);
            
                // 标注有@InitBinder注解方法必须返回void
                if (returnValue != null) {
                    throw new IllegalStateException(&quot;@InitBinder methods must not return a value (should be void): &quot; + binderMethod);
                }
            }
        }
    }

    // dataBinder.getObjectName()在此处终于起效果了  通过这个名称来匹配
    // 也就是说可以做到让@InitBinder注解只作用在指定的入参名字的数据绑定上~~~~~
    // 而dataBinder的这个ObjectName，一般就是入参的名字（注解指定的value值~~）

    // 形参名字的在dataBinder，所以此处有个简单的过滤~~~~~~~
    protected boolean isBinderMethodApplicable(HandlerMethod initBinderMethod, WebDataBinder dataBinder) {
        InitBinder ann = initBinderMethod.getMethodAnnotation(InitBinder.class);
        Assert.state(ann != null, &quot;No InitBinder annotation&quot;);
        String[] names = ann.value();
        return (ObjectUtils.isEmpty(names) || ObjectUtils.containsElement(names, dataBinder.getObjectName()));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;WebBindingInitializer&lt;/code&gt;接口方式是优先于&lt;code&gt;@InitBinder&lt;/code&gt;注解方式执行的（API方式是去全局的，注解方式可不一定，所以更加的灵活些）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;子类&lt;code&gt;ServletRequestDataBinderFactory&lt;/code&gt;就做了一件事：&lt;code&gt;new ExtendedServletRequestDataBinder(target, objectName)&lt;/code&gt;&lt;br/&gt;&lt;code&gt;ExtendedServletRequestDataBinder&lt;/code&gt;只做了一件事：处理&lt;code&gt;path&lt;/code&gt;变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;binderMethods&lt;/code&gt;是通过构造函数进来的，它表示和本次请求有关的所有的标注有&lt;code&gt;@InitBinder&lt;/code&gt;的方法，所以需要了解它的实例是如何被创建的，那就是接下来这步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;code&gt;ServletRequestDataBinderFactory&lt;/code&gt;的创建&lt;/strong&gt;&lt;br/&gt;任何一个请求进来，最终交给了&lt;code&gt;HandlerAdapter.handle()&lt;/code&gt;方法去处理，它的创建流程如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean {
    ...
    @Override
    protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
        ...
        // 处理请求，最终其实就是执行控制器的方法，得到一个ModelAndView
        mav = invokeHandlerMethod(request, response, handlerMethod);
        ...
    }
    
    // 执行控制器的方法，挺复杂的。但本文我只关心WebDataBinderFactory的创建，方法第一句便是
    @Nullable
    protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        ...
    }

    // 创建一个WebDataBinderFactory 
    // Global methods first（放在前面最先执行） 然后再执行本类自己的
    private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception {
        // handlerType：方法所在的类（控制器方法所在的类，也就是xxxController）
        // 由此可见，此注解的作用范围是类级别的。会用此作为key来缓存
        Class&amp;lt;?&amp;gt; handlerType = handlerMethod.getBeanType();
        Set&amp;lt;Method&amp;gt; methods = this.initBinderCache.get(handlerType);
        if (methods == null) { // 缓存没命中，就去selectMethods找到所有标注有@InitBinder的方法们~~~~
            methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);
            this.initBinderCache.put(handlerType, methods); // 缓存起来
        }
        
        // 此处注意：Method最终都被包装成了InvocableHandlerMethod，从而具有执行的能力
        List&amp;lt;InvocableHandlerMethod&amp;gt; initBinderMethods = new ArrayList&amp;lt;&amp;gt;();
        
        // 上面找了本类的，现在开始看看全局里有木有@InitBinder
        // Global methods first（先把全局的放进去，再放个性化的~~~~ 所以小细节：有覆盖的效果哟~~~）
        // initBinderAdviceCache它是一个缓存LinkedHashMap(有序哦~~~)，缓存着作用于全局的类。
        // 如@ControllerAdvice，注意和`RequestBodyAdvice`、`ResponseBodyAdvice`区分开来

        // methodSet：说明一个类里面是可以定义N多个标注有@InitBinder的方法~~~~~
        this.initBinderAdviceCache.forEach((clazz, methodSet) -&amp;gt; {
            
            // 简单的说就是`RestControllerAdvice`它可以指定：basePackages之类的属性，看本类是否能被扫描到吧~~~~
            if (clazz.isApplicableToBeanType(handlerType)) {
            
                // 这个resolveBean() 有点意思：它持有的Bean若是个BeanName的话，会getBean()一下的
                // 大多数情况下都是BeanName，这在@ControllerAdvice的初始化时会讲~~~
                Object bean = clazz.resolveBean();
                for (Method method : methodSet) {
                    // createInitBinderMethod：把Method适配为可执行的InvocableHandlerMethod
                    
                    // 特点是把本类的HandlerMethodArgumentResolverComposite传进去了
                    // 当然还有DataBinderFactory和ParameterNameDiscoverer等
                    initBinderMethods.add(createInitBinderMethod(bean, method));
                }
            }
        });
        // 后一步：再条件标注有@InitBinder的方法
        for (Method method : methods) {
            Object bean = handlerMethod.getBean();
            initBinderMethods.add(createInitBinderMethod(bean, method));
        }

        // protected方法，就一句代码：new ServletRequestDataBinderFactory(binderMethods, getWebBindingInitializer())
        return createDataBinderFactory(initBinderMethods);
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，整个&lt;code&gt;@InitBinder&lt;/code&gt;的解析过程就算可以全部理解了。关于这个过程，我有如下几点想说：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;有了这些基础理论的支撑，接下来当然就是它的使用&lt;code&gt;Demo Show&lt;/code&gt;了&lt;/p&gt;
&lt;h2 id=&quot;initbinder的使用案例&quot;&gt;&lt;code&gt;@InitBinder&lt;/code&gt;的使用案例&lt;/h2&gt;
&lt;p&gt;我抛出两个需求，借助&lt;code&gt;@InitBinder&lt;/code&gt;来实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;请求进来的所有&lt;strong&gt;字符串&lt;/strong&gt;都&lt;code&gt;trim&lt;/code&gt;一下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yyyy-MM-dd&lt;/code&gt;这种格式的字符串能直接用&lt;code&gt;Date&lt;/code&gt;类型接收（不用先用&lt;code&gt;String&lt;/code&gt;接收再自己转换，不优雅）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了实现如上两个需求，我需要先自定义两个属性编辑器：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;code&gt;StringTrimmerEditor&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StringTrimmerEditor extends PropertyEditorSupport {

    // 将属性对象用一个字符串表示，以便外部的属性编辑器能以可视化的方式显示。缺省返回null，表示该属性不能以字符串表示
    //@Override
    //public String getAsText() {
    //    Object value = getValue();
    //    return (value != null ? value.toString() : null);
    //}

    // 用一个字符串去更新属性的内部值，这个字符串一般从外部属性编辑器传入
    // 处理请求的入参：test就是你传进来的值（并不是super.getValue()哦~）
    @Override
    public void setAsText(String text) throws IllegalArgumentException {
        text = text == null ? text : text.trim();
        setValue(text);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;说明：Spring内置有&lt;code&gt;org.springframework.beans.propertyeditors.StringTrimmerEditor&lt;/code&gt;，默认情况下它并没有装配进来，若你有需要可以直接使用它的（此处为了演示，我就用自己的）。Spring内置注册了哪些？参照&lt;code&gt;PropertyEditorRegistrySupport#createDefaultEditors&lt;/code&gt;方法&lt;br/&gt;Spring的属性编辑器和传统的用于IDE开发时的属性编辑器不同，它们没有UI界面，&lt;strong&gt;仅负责将配置文件中的文本配置值转换为Bean属性的对应值，所以Spring的属性编辑器并非传统意义上的JavaBean属性编辑器&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;code&gt;CustomDateEditor&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;关于这个属性编辑器，你也可以像我一样自己实现。本文就直接使用Spring提供了的，参见：&lt;code&gt;org.springframework.beans.propertyeditors.CustomDateEditor&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// @since 28.04.2003
// @see java.util.Date
public class CustomDateEditor extends PropertyEditorSupport {
    ...
    @Override
    public void setAsText(@Nullable String text) throws IllegalArgumentException {
        ...
        setValue(this.dateFormat.parse(text));
        ...
    }
    ...
    @Override
    public String getAsText() {
        Date value = (Date) getValue();
        return (value != null ? this.dateFormat.format(value) : &quot;&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义好后，如何使用呢？有两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;API方式&lt;code&gt;WebBindingInitializer&lt;/code&gt; ，关于它的使用，请参阅&lt;a href=&quot;https://fangshixiang.blog.csdn.net/article/details/96450469&quot;&gt;这里&lt;/a&gt;，本文略。&lt;br/&gt;1. 重写&lt;code&gt;initBinder&lt;/code&gt;注册的属性编辑器是全局的属性编辑器，对&lt;strong&gt;所有的&lt;code&gt;Controller&lt;/code&gt;都有效&lt;/strong&gt;（全局的）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@InitBinder&lt;/code&gt;注解方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在&lt;code&gt;Controller&lt;/code&gt;本类上使用&lt;code&gt;@InitBinder&lt;/code&gt;，形如这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
@RequestMapping
public class HelloController {

    @InitBinder
    public void initBinder(WebDataBinder binder) {
        //binder.setDisallowedFields(&quot;name&quot;); // 不绑定name属性
        binder.registerCustomEditor(String.class, new StringTrimmerEditor());

        // 此处使用Spring内置的CustomDateEditor
        DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));
    }

    @ResponseBody
    @GetMapping(&quot;/test/initbinder&quot;)
    public String testInitBinder(String param, Date date) {
        return param + &quot;:&quot; + date;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求：&lt;code&gt;/test/initbinder?param= ds&amp;amp;date=2019-12-12&lt;/code&gt;。结果为：&lt;code&gt;ds:Thu Dec 12 00: 00: 00 CST 2019&lt;/code&gt;，符合预期。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，若date为null返回值为&lt;code&gt;ds: null&lt;/code&gt;（因为我设置了允许为null）&lt;br/&gt;但若你不是&lt;code&gt;yyyy-MM-dd&lt;/code&gt;格式，那就抛错喽（格式化异常）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本例的&lt;code&gt;@InitBinder&lt;/code&gt;方法只对当前&lt;code&gt;Controller&lt;/code&gt;生效。&lt;strong&gt;要想全局生效，可以使用&lt;code&gt;@ControllerAdvice/WebBindingInitializer&lt;/code&gt;&lt;/strong&gt;。&lt;br/&gt;通过&lt;code&gt;@ControllerAdvice&lt;/code&gt;可以将对于控制器的&lt;strong&gt;全局配置放置在同一个位置&lt;/strong&gt;，注解了&lt;code&gt;@ControllerAdvice&lt;/code&gt;的类的方法可以使用&lt;code&gt;@ExceptionHandler&lt;/code&gt;，&lt;code&gt;@InitBinder&lt;/code&gt;，&lt;code&gt;@ModelAttribute&lt;/code&gt;等注解到方法上，这对所有注解了&lt;code&gt;@RequestMapping&lt;/code&gt;的控制器内的方法有效（关于全局的方式本文略，建议各位自己实践~）。&lt;/p&gt;
&lt;h5 id=&quot;initbinder的value属性的作用&quot;&gt;@InitBinder的value属性的作用&lt;/h5&gt;
&lt;p&gt;获取你可能还不知道，它还有个&lt;code&gt;value&lt;/code&gt;属性呢，并且还是数组&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public @interface InitBinder {
    // 用于限定次注解标注的方法作用于哪个模型key上
    String[] value() default {};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说人话：&lt;strong&gt;若指定了value值，那么只有方法参数名（或者模型名）匹配上了此注解方法才会执行&lt;/strong&gt;（若不指定，都执行）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
@RequestMapping
public class HelloController {

    @InitBinder({&quot;param&quot;, &quot;user&quot;})
    public void initBinder(WebDataBinder binder, HttpServletRequest request) {
        System.out.println(&quot;当前key：&quot; + binder.getObjectName());
    }

    @ResponseBody
    @GetMapping(&quot;/test/initbinder&quot;)
    public String testInitBinder(String param, String date,
                                 @ModelAttribute(&quot;user&quot;) User user, @ModelAttribute(&quot;person&quot;) Person person) {
        return param + &quot;:&quot; + date;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求：&lt;code&gt;/test/initbinder?param=fsx&amp;amp;date=2019&amp;amp;user.name=demoUser&lt;/code&gt;，控制台打印：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;当前key：param
当前key：user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从打印结果中很清楚的看出了&lt;code&gt;value&lt;/code&gt;属性的作用~&lt;/p&gt;
&lt;blockquote readability=&quot;6.8073394495413&quot;&gt;
&lt;p&gt;需要说明一点：虽然此处有key是&lt;code&gt;user.name&lt;/code&gt;，但是User对象可是不会封装到此值的(因为&lt;code&gt;request.getParameter('user')&lt;/code&gt;没这个key嘛~)。如何解决？？？需要绑定前缀，原理可参考&lt;a href=&quot;https://fangshixiang.blog.csdn.net/article/details/98260361&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;其它应用场景&quot;&gt;其它应用场景&lt;/h5&gt;
&lt;p&gt;上面例举的场景是此注解最为常用的场景，大家务必掌握。它还有一些奇淫技巧的使用，心有余力的小伙伴不妨也可以消化消化：&lt;/p&gt;
&lt;p&gt;若你一次提交需要提交两个&quot;模型&quot;数据，并且它们有重名的属性。形如下面例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
@RequestMapping
public class HelloController {

    @Getter
    @Setter
    @ToString
    public static class User {
        private String id;
        private String name;
    }

    @Getter
    @Setter
    @ToString
    public static class Addr {
        private String id;
        private String name;
    }

    @InitBinder(&quot;user&quot;)
    public void initBinderUser(WebDataBinder binder) {
        binder.setFieldDefaultPrefix(&quot;user.&quot;);
    }

    @InitBinder(&quot;addr&quot;)
    public void initBinderAddr(WebDataBinder binder) {
        binder.setFieldDefaultPrefix(&quot;addr.&quot;);
    }

    @ResponseBody
    @GetMapping(&quot;/test/initbinder&quot;)
    public String testInitBinder(@ModelAttribute(&quot;user&quot;) User user, @ModelAttribute(&quot;addr&quot;) Addr addr) {
        return user + &quot;:&quot; + addr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求：&lt;code&gt;/test/initbinder?user.id=1&amp;amp;user.name=demoUser&amp;amp;addr.id=10&amp;amp;addr.name=北京市海淀区&lt;/code&gt;，结果为：&lt;code&gt;HelloController.User(id=1, name=demoUser):HelloController.Addr(id=10, name=北京市海淀区)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;至于加了前缀为何能绑定上，这里简要说说：&lt;br/&gt;1、&lt;code&gt;ModelAttributeMethodProcessor#resolveArgument&lt;/code&gt;里依赖&lt;code&gt;attribute = createAttribute(name, parameter, binderFactory, webRequest)&lt;/code&gt;方法完成数据的封装、转换&lt;br/&gt;2、&lt;code&gt;createAttribute&lt;/code&gt;先&lt;code&gt;request.getParameter(attributeName)&lt;/code&gt;看请求域里是否有值（此处为null），若木有就&lt;strong&gt;反射创建一个空实例&lt;/strong&gt;，回到&lt;code&gt;resolveArgument&lt;/code&gt;方法。&lt;br/&gt;3、继续利用&lt;code&gt;WebDataBinder&lt;/code&gt;来完成对这个空对象的数据值绑定，这个时候这些&lt;code&gt;FieldDefaultPrefix&lt;/code&gt;就起作用了。执行方法是：&lt;code&gt;bindRequestParameters(binder, webRequest)&lt;/code&gt;，实际上是&lt;code&gt;((WebRequestDataBinder) binder).bind(request);&lt;/code&gt;。对于bind方法的原理，就不陌生了~&lt;br/&gt;4、完成Model数据的封装后，再进行&lt;code&gt;@Valid&lt;/code&gt;校验...&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考解析类：&lt;code&gt;ModelAttributeMethodProcessor&lt;/code&gt;对参数部分的处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文花大篇幅从原理层面总结了&lt;code&gt;@InitBinder&lt;/code&gt;这个注解的使用，虽然此注解在当下的环境中出镜率并不是太高，但我还是期望小伙伴能理解它，特别是我本文举例说明的例子的场景一定能做到运用自如。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，此注解的使用的注意事项我把它总结如下，供各位使用过程中参考：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;@InitBinder&lt;/code&gt;标注的方法执行是多次的，一次请求来就执行一次（第一次惩罚）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Controller&lt;/code&gt;实例中的所有&lt;code&gt;@InitBinder&lt;/code&gt;只对当前所在的&lt;code&gt;Controller&lt;/code&gt;有效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@InitBinder&lt;/code&gt;的value属性控制的是模型Model里的key，而不是方法名（不写代表对所有的生效）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@InitBinder&lt;/code&gt;标注的方法不能有返回值（只能是&lt;code&gt;void&lt;/code&gt;或者&lt;code&gt;returnValue=null&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@InitBinder&lt;/code&gt;对&lt;code&gt;@RequestBody&lt;/code&gt;这种基于消息转换器的请求参数无效&lt;br/&gt;1. 因为&lt;code&gt;@InitBinder&lt;/code&gt;它用于初始化&lt;code&gt;DataBinder&lt;/code&gt;数据绑定、类型转换等功能，而&lt;code&gt;@RequestBody&lt;/code&gt;它的数据解析、转换时消息转换器来完成的，所以即使你自定义了属性编辑器，对它是不生效的（&lt;strong&gt;它的&lt;code&gt;WebDataBinder&lt;/code&gt;只用于数据校验，不用于数据绑定和数据转换。它的数据绑定转换若是json，一般都是交给了&lt;code&gt;jackson&lt;/code&gt;来完成的&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;只有&lt;code&gt;AbstractNamedValueMethodArgumentResolver&lt;/code&gt;才会调用&lt;code&gt;binder.convertIfNecessary&lt;/code&gt;进行数据转换，从而属性编辑器才会生效&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;== &lt;strong&gt;若对Spring、SpringBoot、MyBatis等源码分析感兴趣，可加我wx：fsx641385712，手动邀请你入群一起飞&lt;/strong&gt; ==&lt;br/&gt;== &lt;strong&gt;若对Spring、SpringBoot、MyBatis等源码分析感兴趣，可加我wx：fsx641385712，手动邀请你入群一起飞&lt;/strong&gt; ==&lt;/p&gt;
</description>
<pubDate>Wed, 11 Sep 2019 16:23:00 +0000</pubDate>
<dc:creator>_YourBatman</dc:creator>
<og:description>一个可以沉迷于技术的程序猿，wx加入加入技术群：fsx641385712</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fangshixiang/p/11509660.html</dc:identifier>
</item>
<item>
<title>从零开始搭建前后端分离的NetCore2.2（EF Core CodeFirst+Autofac）+Vue的项目框架之八MemoryCache与redis缓存的使用 - Levy-伟</title>
<link>http://www.cnblogs.com/levywang/p/coreframe_8.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/levywang/p/coreframe_8.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;1.什么是缓存&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　这里要讲到的缓存是服务端缓存，简单的说，缓存就是将一些实时性不高，但访问又十分频繁，或者说要很长时间才能取到的数据给存在内存当中，当有请求时直接返回，不用经过数据库或接口获取。这样就可以减轻数据库的负担。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;2.为什么要用缓存&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　总的来说就是为了提高响应速度（用户体验度），减少数据库访问频率。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　在一个用户看来，软件使用的体验度才是关键，在对实时性要求不高的情况下，用户肯定会觉得打开界面的响应速度快，能保证平常工作的应用才是好的。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;因此为了满足这个需求，通过使用缓存，就可以保证满足在正常工作的前提下响应时间尽可能短。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　例如：当客户端向服务器请求某个数据时，服务器先在缓存中找，如果在缓存中，就直接返回，无需查询数据库；如果请求的数据不在缓存中，这时再去数据库中找，找到后返回给客户端，并将这个资源加入缓存中。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;这样下次请求相同资源时，就不需&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　   要连接&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;数据库了。而且如果把缓存放在内存中，因为对内存的操作要比对数据库操作快得多，这样请求时间也会缩短。每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;strong&gt;如果没有使用缓存&lt;/strong&gt;，用户去请求某个数据，当用户量和数据逐渐增加的时候，就会发现每次用户请求的时间越来越长，且数据库无时不刻都在工作。这样用户和数据库都很痛苦，时间一长，就有可能发生下以下事情：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　1.用户常抱怨应用打开速度太慢，页面经常无响应，偶尔还会出现崩溃的情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　2.数据库连接数满或者说数据库响应慢（处理不过来）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　3.当并发量上来的时候，可能会导致数据库崩溃，使得应用无法正常使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　简单说下这两者的区别，两者都是通过key-value的方式进行存储的，Memcached只有简单的字符串格式，而Redis还支持更多的格式（list、 set、sorted set、hash table ），缓存时使用到的数据都是在内存当中，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　不同的在于Redis支持持久化，集群、简单事务、发布/订阅、主从同步等功能，当断电或软件重启时，Memcached中的数据就已经不存在了，而Redis可以通过读取磁盘中的数据再次使用。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这里提高Windows版的安装包：&lt;a title=&quot;Redis安装包&quot; href=&quot;https://files.cnblogs.com/files/levywang/Redis-x64-3.2.100.rar&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;          可视化工具：因文件太大无法上传到博客园。代码仓库中有，需要的私信哦~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　Memcached的使用还是相当简单的，首先在 Startup 类中做以下更改，添加缓存参数  赋值给外部类来方便使用&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, IMemoryCache memoryCache)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....  省略部分代码&lt;/span&gt;
            DemoWeb.MemoryCache =&lt;span&gt; memoryCache;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....  省略部分代码&lt;/span&gt;
        }    
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
DemoWeb中的代码：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoWeb
    {
      
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....省略部分代码&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; MemoryCache
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IMemoryCache MemoryCache { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取当前请求客户端IP
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetClientIp()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ip = HttpContext.Request.Headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-Forwarded-For&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].FirstOrDefault()?.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Trim();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(ip))
            {
                ip &lt;/span&gt;=&lt;span&gt; HttpContext.Connection.RemoteIpAddress.ToString();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ip;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后创建 MemoryCache 来封装些缓存的简单方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9f210381-7b64-46c3-9143-b88a3d27d4cc')&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_9f210381-7b64-46c3-9143-b88a3d27d4cc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9f210381-7b64-46c3-9143-b88a3d27d4cc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9f210381-7b64-46c3-9143-b88a3d27d4cc',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9f210381-7b64-46c3-9143-b88a3d27d4cc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; MemoryCache缓存
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MemoryCache
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; HashSet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Keys = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 缓存前缀
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Prefix { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造函数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;prefix&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; MemoryCache(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; prefix)
        {
            Prefix &lt;/span&gt;= prefix + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DemoWeb.MemoryCache.Get&amp;lt;T&amp;gt;(Prefix +&lt;span&gt; key);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置 无过期时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; data)
        {
            key &lt;/span&gt;= Prefix +&lt;span&gt; key;
            DemoWeb.MemoryCache.Set(key, data);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Keys.Contains(key))
            {
                Keys.Add(key);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;absoluteExpiration&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; data, DateTimeOffset absoluteExpiration)
        {
            key &lt;/span&gt;= Prefix +&lt;span&gt; key;
            DemoWeb.MemoryCache.Set(key, data, absoluteExpiration);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Keys.Contains(key))
            {
                Keys.Add(key);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;absoluteExpirationRelativeToNow&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; data, TimeSpan absoluteExpirationRelativeToNow)
        {
            key &lt;/span&gt;= Prefix +&lt;span&gt; key;
            DemoWeb.MemoryCache.Set(key, data, absoluteExpirationRelativeToNow);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Keys.Contains(key))
            {
                Keys.Add(key);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expirationToken&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; data, IChangeToken expirationToken)
        {
            key &lt;/span&gt;= Prefix +&lt;span&gt; key;
            DemoWeb.MemoryCache.Set(key, data, expirationToken);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Keys.Contains(key))
            {
                Keys.Add(key);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;options&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; data, MemoryCacheEntryOptions options)
        {
            key &lt;/span&gt;= Prefix +&lt;span&gt; key;
            DemoWeb.MemoryCache.Set(key, data, options);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Keys.Contains(key))
            {
                Keys.Add(key);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 移除某个
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Remove(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            key &lt;/span&gt;= Prefix +&lt;span&gt; key;
            DemoWeb.MemoryCache.Remove(key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Keys.Contains(key))
            {
                Keys.Remove(key);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 清空所有
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClearAll()
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Keys)
            {
                DemoWeb.MemoryCache.Remove(key);
            }
            Keys.Clear();
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　其实接下来就可以直接使用缓存了，但为了方便使用，再建一个缓存类别的中间类来管理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('974f84a7-17ee-4cf4-8961-20807e7e45e0')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_974f84a7-17ee-4cf4-8961-20807e7e45e0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_974f84a7-17ee-4cf4-8961-20807e7e45e0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('974f84a7-17ee-4cf4-8961-20807e7e45e0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_974f84a7-17ee-4cf4-8961-20807e7e45e0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserCache
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; MemoryCache Cache = &lt;span&gt;new&lt;/span&gt; MemoryCache(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TimeSpan _timeout =&lt;span&gt; TimeSpan.Zero;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; TimeSpan Timeout
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_timeout !=&lt;span&gt; TimeSpan.Zero)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _timeout;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    _timeout &lt;/span&gt;= TimeSpan.FromMinutes(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _timeout;
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; TimeSpan.FromMinutes(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; cache)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(cache))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            Cache.Set(key, cache, Timeout);
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Cache.Get&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(key);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;UserCache&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　测试是否可以正常使用：代码与截图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mecache&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ValidToken()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            UserCache.Set(key, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试数据&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Succeed(UserCache.Get(key));
        }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1750888/201909/1750888-20190911213655583-2042302230.png&quot; alt=&quot;&quot; width=&quot;971&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以清楚的看到 MemoryCache 可以正常使用。  &lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;那么接下来将讲到如何使用 Redis 缓存。先在需要封装基础类的项目 Nuget 包中添加  &lt;span class=&quot;cnblogs_code&quot;&gt;StackExchange.Redis&lt;/span&gt;  依赖。然后添加Redis 连接类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4680af4e-b749-4d6a-8201-8897f8c23373')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_4680af4e-b749-4d6a-8201-8897f8c23373&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4680af4e-b749-4d6a-8201-8897f8c23373&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4680af4e-b749-4d6a-8201-8897f8c23373',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4680af4e-b749-4d6a-8201-8897f8c23373&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisConnectionFactory
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ConnectionString { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Password { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConnectionMultiplexer CurrentConnectionMultiplexer { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置连接字符串
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetConnectionString(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; connectionString)
        {
            ConnectionString &lt;/span&gt;=&lt;span&gt; connectionString;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置连接字符串
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetPassword(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; password)
        {
            Password &lt;/span&gt;=&lt;span&gt; password;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConnectionMultiplexer GetConnectionMultiplexer()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CurrentConnectionMultiplexer == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;CurrentConnectionMultiplexer.IsConnected)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CurrentConnectionMultiplexer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    CurrentConnectionMultiplexer.Dispose();
                }

                CurrentConnectionMultiplexer &lt;/span&gt;=&lt;span&gt; GetConnectionMultiplexer(ConnectionString);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CurrentConnectionMultiplexer;
        }


        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConnectionMultiplexer GetConnectionMultiplexer(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; connectionString)
        {
            ConnectionMultiplexer connectionMultiplexer;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(Password) &amp;amp;&amp;amp; !connectionString.ToLower().Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                connectionString &lt;/span&gt;+= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,password={Password}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisConfiguration =&lt;span&gt; ConfigurationOptions.Parse(connectionString);
            redisConfiguration.AbortOnConnectFail &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            redisConfiguration.AllowAdmin &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            redisConfiguration.ConnectRetry &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
            redisConfiguration.ConnectTimeout &lt;/span&gt;= &lt;span&gt;3000&lt;/span&gt;&lt;span&gt;;
            redisConfiguration.DefaultDatabase &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            redisConfiguration.KeepAlive &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
            redisConfiguration.SyncTimeout &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
            redisConfiguration.Ssl &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            connectionMultiplexer &lt;/span&gt;=&lt;span&gt; ConnectionMultiplexer.Connect(redisConfiguration);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connectionMultiplexer;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;RedisConnectionFactory&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　再添加Redis客户端类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('67242964-96a1-4fb9-bee1-9865f8c2bc5d')&quot; readability=&quot;42.5&quot;&gt;&lt;img id=&quot;code_img_closed_67242964-96a1-4fb9-bee1-9865f8c2bc5d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_67242964-96a1-4fb9-bee1-9865f8c2bc5d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('67242964-96a1-4fb9-bee1-9865f8c2bc5d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_67242964-96a1-4fb9-bee1-9865f8c2bc5d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Redis Client
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisClient : IDisposable
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DefaultDatabase { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ConnectionMultiplexer _client;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IDatabase _db;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RedisClient(ConnectionMultiplexer client)
        {
            _client &lt;/span&gt;=&lt;span&gt; client;
            UseDatabase();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; UseDatabase(&lt;span&gt;int&lt;/span&gt; db = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (db == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                db &lt;/span&gt;=&lt;span&gt; DefaultDatabase;
            _db &lt;/span&gt;=&lt;span&gt; _client.GetDatabase(db);
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; StringGet(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _db.StringGet(key).ToString();
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StringSet(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; data)
        {
            _db.StringSet(key, data);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StringSet(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; data, TimeSpan timeout)
        {
            _db.StringSet(key, data, timeout);
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; StringGet(key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(json))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; json.ToNetType&amp;lt;T&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; data)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; data.ToJson();
            _db.StringSet(key, json);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; data, TimeSpan timeout)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; data.ToJson();
            _db.StringSet(key, json, timeout);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Exist
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Exist(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _db.KeyExists(key);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Delete
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Delete(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _db.KeyDelete(key);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Set Expire to Key
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expiry&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Expire(&lt;span&gt;string&lt;/span&gt; key, TimeSpan?&lt;span&gt; expiry)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _db.KeyExpire(key, expiry);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 计数器  如果不存在则设置值，如果存在则添加值  如果key存在且类型不为long  则会异常
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expiry&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;只有第一次设置有效期生效&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; SetStringIncr(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;long&lt;/span&gt; value = &lt;span&gt;1&lt;/span&gt;, TimeSpan? expiry = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nubmer =&lt;span&gt; _db.StringIncrement(key, value);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nubmer == &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; expiry != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有第一次设置有效期（防止覆盖）&lt;/span&gt;
                _db.KeyExpireAsync(key, expiry);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置有效期&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nubmer;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 读取计数器
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; GetStringIncr(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; StringGet(key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(value) ? &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;long&lt;/span&gt;&lt;span&gt;.Parse(value);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 计数器-减少 如果不存在则设置值，如果存在则减少值  如果key存在且类型不为long  则会异常
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; StringDecrement(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;long&lt;/span&gt; value = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nubmer =&lt;span&gt; _db.StringDecrement(key, value);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nubmer;
        }



        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            _client&lt;/span&gt;?&lt;span&gt;.Dispose();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;RedisClient&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　然后再添加Redis连接生成工具类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2bd2cfea-0b59-40e8-bb4b-07bd39877097')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_2bd2cfea-0b59-40e8-bb4b-07bd39877097&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2bd2cfea-0b59-40e8-bb4b-07bd39877097&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2bd2cfea-0b59-40e8-bb4b-07bd39877097',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2bd2cfea-0b59-40e8-bb4b-07bd39877097&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisFactory
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Locker = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RedisConnectionFactory factory;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitRedisConnection()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisConnectionFactory();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; connectionString = DemoWeb.Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis:ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; DEBUG&lt;span&gt;
                connectionString &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
                factory.ConnectionString &lt;/span&gt;=&lt;span&gt; connectionString;
                factory.Password &lt;/span&gt;= DemoWeb.Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis:Pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                LogHelper.Logger.Fatal(e, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis连接创建失败。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RedisClient GetClient()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先判断一轮,减少锁,提高效率&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (factory == &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(factory.ConnectionString))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止并发创建&lt;/span&gt;
                &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (Locker)
                {
                    InitRedisConnection();
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisClient(factory.GetConnectionMultiplexer())
            {
                DefaultDatabase &lt;/span&gt;= DemoWeb.Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis:DefaultDatabase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToInt()
            };

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;RedisFactory&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　这里要使用到前面的静态扩展方法。请自行添加  &lt;span&gt;&lt;a title=&quot;C#之项目常用方法之静态扩展&quot; href=&quot;https://www.cnblogs.com/levywang/p/ObjStrExtension.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;传送门&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; ，&lt;span&gt;还需要将 Startup 类中的 Configuration 给赋值到 DemoWeb中的 Configuration 字段值来使用&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　在配置文件 &lt;span class=&quot;cnblogs_code&quot;&gt;appsettings.json&lt;/span&gt; 中添加&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultDatabase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　再添加Redis缓存使用类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('431dbf56-4c1b-4e58-8f53-4c291c067cf8')&quot; readability=&quot;48.5&quot;&gt;&lt;img id=&quot;code_img_closed_431dbf56-4c1b-4e58-8f53-4c291c067cf8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_431dbf56-4c1b-4e58-8f53-4c291c067cf8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('431dbf56-4c1b-4e58-8f53-4c291c067cf8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_431dbf56-4c1b-4e58-8f53-4c291c067cf8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;92&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Redis缓存
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisCache
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RedisClient _client;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RedisClient Client =&amp;gt; _client ?? (_client =&lt;span&gt; RedisFactory.GetClient());

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ToKey(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cache_redis_{key}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Client.Get&amp;lt;T&amp;gt;&lt;span&gt;(redisKey);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                LogHelper.Logger.Fatal(e, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RedisCache.Get \n key:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, key);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 尝试获取
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T TryGet&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; result)
        {
            result &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Client.Get&amp;lt;T&amp;gt;&lt;span&gt;(redisKey);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                LogHelper.Logger.Fatal(e, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RedisCache.TryGet \n key:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, key);
                result &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;setFunc&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expiry&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;resolver&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; key, Func&amp;lt;T&amp;gt; setFunc, TimeSpan? expiry = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = TryGet&amp;lt;T&amp;gt;(redisKey, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; success);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (success &amp;amp;&amp;amp; result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                result &lt;/span&gt;=&lt;span&gt; setFunc();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    Set(redisKey, result, expiry);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
                {
                    LogHelper.Logger.Fatal(e, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RedisCache.Get&amp;lt;T&amp;gt; \n key:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, key);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expiry&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Set&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; key, T value, TimeSpan? expiry = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; allRedisKey = ToKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;||Keys||&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; allkeyRedisValue =&lt;span&gt; Client.StringGet(allRedisKey);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys = allkeyRedisValue.ToNetType&amp;lt;List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;() ?? &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;keys.Contains(redisKey))
            {
                keys.Add(redisKey);
                Client.Set(allRedisKey, keys);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (expiry.HasValue)
            {
                Client.StringSet(redisKey, value.ToJson(), expiry.Value);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Client.StringSet(redisKey, value.ToJson());
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重新设置过期时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expiry&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ResetItemTimeout(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, TimeSpan expiry)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);
            Client.Expire(redisKey, expiry);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Exist
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;原始key&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Exist(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Client.Exist(redisKey);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 计数器 增加  能设置过期时间的都设置过期时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expiry&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; SetStringIncr(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;long&lt;/span&gt; value = &lt;span&gt;1&lt;/span&gt;, TimeSpan? expiry = &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt; needRest0 = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (expiry.HasValue)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Exist(key) &amp;amp;&amp;amp;&lt;span&gt; needRest0)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exitValue =&lt;span&gt; GetStringIncr(key);
                        Client.SetStringIncr(redisKey, value &lt;/span&gt;-&lt;span&gt; exitValue, expiry.Value);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Client.SetStringIncr(redisKey, value, expiry.Value);
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Exist(key) &amp;amp;&amp;amp;&lt;span&gt; needRest0)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exitValue =&lt;span&gt; GetStringIncr(key);
                        Client.SetStringIncr(redisKey, value &lt;/span&gt;-&lt;span&gt; exitValue);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Client.SetStringIncr(redisKey, value);
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                LogHelper.Logger.Fatal($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;计数器-增加错误，原因：{e.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 读取计数器
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; GetStringIncr(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Client.GetStringIncr(redisKey);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 计数器 - 减少
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; StringDecrement(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;long&lt;/span&gt; value = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Client.StringDecrement(redisKey, value);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                LogHelper.Logger.Fatal($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;计数器-减少错误，原因：{e.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Delete(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisKey =&lt;span&gt; ToKey(key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Client.Delete(redisKey);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 清空
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Clear()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为codis不支持keys之类的命令，所以只能自己记录下来，然后通过这个来清理。&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; redisKey = ToKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;||Keys||&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys = Client.Get&amp;lt;List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;(redisKey);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; notExists = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; keys)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Client.Exist(key))
                    Client.Delete(key);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    notExists.Add(key);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (notExists.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                keys.RemoveAll(s &lt;/span&gt;=&amp;gt;&lt;span&gt; notExists.Contains(s));
                Client.Set(redisKey, keys);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;RedisCache&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　到这来基本就快可以拿来测试是否可以用了。但是前提是得把 Redis 给运行起来。&lt;/p&gt;
&lt;p&gt;　　将上面的 Redis安装包安装，并启动所安装文件夹中的 &lt;span class=&quot;cnblogs_code&quot;&gt;redis-server.exe&lt;/span&gt; 程序，若出现闪退情况，就运行 &lt;span class=&quot;cnblogs_code&quot;&gt;redis-cli.exe&lt;/span&gt; 程序，然后输入 &lt;span class=&quot;cnblogs_code&quot;&gt;shutdown&lt;/span&gt; 按下回车，重新运行 &lt;span class=&quot;cnblogs_code&quot;&gt;redis-server.exe&lt;/span&gt; 程序，就会出现这个界面。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1750888/201909/1750888-20190911232125759-1646796330.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到这来，添加一个测试方法来看看效果。借助Redis可视化工具查看结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1750888/201909/1750888-20190911234851006-1049568926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　测试完美成功，由于时间问题，上面 RedisCache只有字符串的方法，没有加其它类型的方法。有需要的自己加咯~&lt;/p&gt;

&lt;p&gt;　　在下一篇中将介绍如何在NetCore中如何使用 过滤器来进行权限验证&lt;/p&gt;

&lt;p&gt;　　有需要源码的在下方评论或私信~给我的SVN访客账户密码下载，代码未放在GitHub上。svn中新加上了Redis安装包及可视化工具。&lt;/p&gt;
</description>
<pubDate>Wed, 11 Sep 2019 15:54:00 +0000</pubDate>
<dc:creator>Levy-伟</dc:creator>
<og:description>1.缓存概念 1.什么是缓存 这里要讲到的缓存是服务端缓存，简单的说，缓存就是将一些实时性不高，但访问又十分频繁，或者说要很长时间才能取到的数据给存在内存当中，当有请求时直接返回，不用经过数据库或接口</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/levywang/p/coreframe_8.html</dc:identifier>
</item>
<item>
<title>如何从 if-else 的参数校验中解放出来？ - 风尘博客</title>
<link>http://www.cnblogs.com/vandusty/p/11509569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vandusty/p/11509569.html</guid>
<description>&lt;h4 id=&quot;背景&quot;&gt;背景&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在开发中经常需要写一些字段校验的代码，比如非空，长度限制，邮箱格式验证等等，导致充满了&lt;code&gt;if-else&lt;/code&gt; 的代码,不仅相当冗长,而且很让人抓狂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;hibernate validator&lt;/code&gt;（&lt;a href=&quot;http://hibernate.org/validator/documentation/&quot;&gt;官方文档&lt;/a&gt;）提供了一套比较完善、便捷的验证实现方式。它定义了很多常用的校验注解，我们可以直接将这些注解加在我们&lt;code&gt;JavaBean&lt;/code&gt;的属性上面，就可以在需要校验的时候进行校验了。在&lt;code&gt;Spring Boot&lt;/code&gt; 火热的现在，该工具已经包含在&lt;code&gt;spring-boot-starter-web&lt;/code&gt;中，不需额外引入其他包。&lt;/p&gt;
&lt;h3 id=&quot;一快速入门&quot;&gt;一、快速入门&lt;/h3&gt;
&lt;h4 id=&quot;在userdto中声明要检查的参数&quot;&gt;1.1 在&lt;code&gt;UserDTO&lt;/code&gt;中声明要检查的参数&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;校验说明见代码中注释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class UserDTO {

    /**
     性别（不校验）
     */
    private String sex;

    /** 
     用户名（校验：不能为空，不能超过20个字符串）
     */
    @NotBlank(message = &quot;用户名不能为空&quot;)
    @Length(max = 20, message = &quot;用户名不能超过20个字符&quot;)
    private String userName;

    /** 
     * 手机号（校验：不能为空且按照正则校验格式）
     */
    @NotBlank(message = &quot;手机号不能为空&quot;)
    @Pattern(regexp = &quot;^[1][3,4,5,6,7,8,9][0-9]{9}$&quot;, message = &quot;手机号格式有误&quot;)
    private String mobile;

    /** 
     邮箱（校验：不能唯恐且校验邮箱格式）
     */
    @NotBlank(message = &quot;联系邮箱不能为空&quot;)
    @Email(message = &quot;邮箱格式不对&quot;)
    private String email;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;接口处声明要检查的参数&quot;&gt;1.2 接口处声明要检查的参数&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要在&lt;code&gt;Controller&lt;/code&gt;层的入参位置用&lt;code&gt;@Validated&lt;/code&gt; 注解声明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/demo&quot;)
public class ValidatorDemoController {

    /**
     * 注解参数校验案例
     * @param userDTO
     * @return
     */
    @PostMapping(&quot;/test&quot;)
    public HttpResult test(@Validated UserDTO userDTO) {
        return HttpResult.success(userDTO);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里的&lt;code&gt;HttpResult&lt;/code&gt; 是Van 自己封装的一个结果集，详见文末Github地址的源码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;web全局异常捕获&quot;&gt;1.3 Web全局异常捕获&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;@Valid&lt;/code&gt; 在 &lt;code&gt;Spring Boot&lt;/code&gt;中进行绑定参数校验时会抛出异常,需要在&lt;code&gt;Spring Boot&lt;/code&gt;中处理。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestControllerAdvice
@Slf4j
public class WebExceptionHandler {


    /**
     * 方法参数校验
     * @param e
     * @return
     */
    @ExceptionHandler(BindException.class)
    public HttpResult handleMethodArgumentNotValidException(BindException e) {
        log.error(e.getMessage(), e);
        return HttpResult.failure(400,e.getBindingResult().getFieldError().getDefaultMessage());
    }

    @ExceptionHandler(Exception.class)
    public HttpResult handleException(Exception e) {
        log.error(e.getMessage(), e);
        return HttpResult.failure(400, &quot;系统繁忙,请稍后再试&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试&quot;&gt;1.4 测试&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;测试工具采用的&lt;code&gt;postman&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;请求方式：POST&lt;/li&gt;
&lt;li&gt;请求地址：localhost:8080/demo/test&lt;/li&gt;
&lt;li&gt;请求参数：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;userName:Van
mobile:17098705205
email:123&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回结果：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;{
    &quot;success&quot;: false,
    &quot;code&quot;: 400,
    &quot;data&quot;: null,
    &quot;message&quot;: &quot;邮箱格式不对&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;更多注解，请各位自行尝试；&lt;/li&gt;
&lt;li&gt;测试结果证明：参数校验生效，且按照我们设定的结果集返回异常信息。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;常见的校验注解&quot;&gt;1.5 常见的校验注解&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;@Null&lt;/code&gt;：被注释的元素必须为 &lt;code&gt;null&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@NotNull&lt;/code&gt;：被注释的元素必须不为 &lt;code&gt;null&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AssertTrue&lt;/code&gt;：被注释的元素必须为 &lt;code&gt;true&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AssertFalse&lt;/code&gt;：被注释的元素必须为 &lt;code&gt;false&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Min(value)&lt;/code&gt;：被注释的元素必须是一个数字，其值必须大于等于指定的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Max(value)&lt;/code&gt;：被注释的元素必须是一个数字，其值必须小于等于指定的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DecimalMin(value)&lt;/code&gt;：被注释的元素必须是一个数字，其值必须大于等于指定的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DecimalMax(value)&lt;/code&gt;：被注释的元素必须是一个数字，其值必须小于等于指定的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Size(max=, min=)&lt;/code&gt;：被注释的元素的大小必须在指定的范围内&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Digits (integer, fraction)&lt;/code&gt;：被注释的元素必须是一个数字，其值必须在可接受的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Past&lt;/code&gt;：被注释的元素必须是一个过去的日期&lt;br/&gt;&lt;code&gt;@Future&lt;/code&gt;：被注释的元素必须是一个将来的日期&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pattern(regex=,flag=)&lt;/code&gt;：被注释的元素必须符合指定的正则表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@NotBlank(message =)&lt;/code&gt;：验证字符串非&lt;code&gt;null&lt;/code&gt;，且长度必须大于0&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Email&lt;/code&gt;：被注释的元素必须是电子邮箱地址&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Length(min=,max=)&lt;/code&gt;：被注释的字符串的大小必须在指定的范围内&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@NotEmpty&lt;/code&gt;：被注释的字符串的必须非空&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Range(min=,max=,message=)&lt;/code&gt;：被注释的元素必须在合适的范围内&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;二自定义注解校验&quot;&gt;二、自定义注解校验&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hibernate validator&lt;/code&gt; 自带的注解可以搞定简单的参数校验，加上正则的写法，能解决绝大多数参数校验情况。但是，有些情况，比如：校验是否登录，就需要我们自定义注解校验了。为了方便测试，我这里以身份证校验为例完成自定义校验的过程。&lt;/p&gt;
&lt;h4 id=&quot;身份证校验工具类&quot;&gt;2.1 身份证校验工具类&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class IdCardValidatorUtils {

    protected String codeAndCity[][] = {{&quot;11&quot;, &quot;北京&quot;}, {&quot;12&quot;, &quot;天津&quot;},
            {&quot;13&quot;, &quot;河北&quot;}, {&quot;14&quot;, &quot;山西&quot;}, {&quot;15&quot;, &quot;内蒙古&quot;}, {&quot;21&quot;, &quot;辽宁&quot;},
            {&quot;22&quot;, &quot;吉林&quot;}, {&quot;23&quot;, &quot;黑龙江&quot;}, {&quot;31&quot;, &quot;上海&quot;}, {&quot;32&quot;, &quot;江苏&quot;},
            {&quot;33&quot;, &quot;浙江&quot;}, {&quot;34&quot;, &quot;安徽&quot;}, {&quot;35&quot;, &quot;福建&quot;}, {&quot;36&quot;, &quot;江西&quot;},
            {&quot;37&quot;, &quot;山东&quot;}, {&quot;41&quot;, &quot;河南&quot;}, {&quot;42&quot;, &quot;湖北&quot;}, {&quot;43&quot;, &quot;湖南&quot;},
            {&quot;44&quot;, &quot;广东&quot;}, {&quot;45&quot;, &quot;广西&quot;}, {&quot;46&quot;, &quot;海南&quot;}, {&quot;50&quot;, &quot;重庆&quot;},
            {&quot;51&quot;, &quot;四川&quot;}, {&quot;52&quot;, &quot;贵州&quot;}, {&quot;53&quot;, &quot;云南&quot;}, {&quot;54&quot;, &quot;西藏&quot;},
            {&quot;61&quot;, &quot;陕西&quot;}, {&quot;62&quot;, &quot;甘肃&quot;}, {&quot;63&quot;, &quot;青海&quot;}, {&quot;64&quot;, &quot;宁夏&quot;},
            {&quot;65&quot;, &quot;新疆&quot;}, {&quot;71&quot;, &quot;台湾&quot;}, {&quot;81&quot;, &quot;香港&quot;}, {&quot;82&quot;, &quot;澳门&quot;},
            {&quot;91&quot;, &quot;国外&quot;}};

    private String cityCode[] = {&quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;21&quot;, &quot;22&quot;,
            &quot;23&quot;, &quot;31&quot;, &quot;32&quot;, &quot;33&quot;, &quot;34&quot;, &quot;35&quot;, &quot;36&quot;, &quot;37&quot;, &quot;41&quot;, &quot;42&quot;, &quot;43&quot;,
            &quot;44&quot;, &quot;45&quot;, &quot;46&quot;, &quot;50&quot;, &quot;51&quot;, &quot;52&quot;, &quot;53&quot;, &quot;54&quot;, &quot;61&quot;, &quot;62&quot;, &quot;63&quot;,
            &quot;64&quot;, &quot;65&quot;, &quot;71&quot;, &quot;81&quot;, &quot;82&quot;, &quot;91&quot;};


    // 每位加权因子
    private static int power[] = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2};

    // 第18位校检码
    private String verifyCode[] = {&quot;1&quot;, &quot;0&quot;, &quot;X&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;,
            &quot;4&quot;, &quot;3&quot;, &quot;2&quot;};

    /**
     * 验证所有的身份证的合法性
     *
     * @param idcard
     * @return
     */
    public static boolean isValidatedAllIdcard(String idcard) {
        if (idcard.length() == 15) {
            idcard = convertIdcarBy15bit(idcard);
        }
        return isValidate18Idcard(idcard);
    }

    /**
     * 将15位的身份证转成18位身份证
     *
     * @param idcard
     * @return
     */
    public static String convertIdcarBy15bit(String idcard) {
        String idcard17 = null;
        // 非15位身份证
        if (idcard.length() != 15) {
            return null;
        }

        if (isDigital(idcard)) {
            // 获取出生年月日
            String birthday = idcard.substring(6, 12);
            Date birthdate = null;
            try {
                birthdate = new SimpleDateFormat(&quot;yyMMdd&quot;).parse(birthday);
            } catch (ParseException e) {
                e.printStackTrace();
            }
            Calendar cday = Calendar.getInstance();
            cday.setTime(birthdate);
            String year = String.valueOf(cday.get(Calendar.YEAR));

            idcard17 = idcard.substring(0, 6) + year + idcard.substring(8);

            char c[] = idcard17.toCharArray();
            String checkCode = &quot;&quot;;

            if (null != c) {
                int bit[] = new int[idcard17.length()];

                // 将字符数组转为整型数组
                bit = converCharToInt(c);
                int sum17 = 0;
                sum17 = getPowerSum(bit);

                // 获取和值与11取模得到余数进行校验码
                checkCode = getCheckCodeBySum(sum17);
                // 获取不到校验位
                if (null == checkCode) {
                    return null;
                }

                // 将前17位与第18位校验码拼接
                idcard17 += checkCode;
            }
        } else { // 身份证包含数字
            return null;
        }
        return idcard17;
    }

    /**
     * @param idCard
     * @return
     */
    public static boolean isValidate18Idcard(String idCard) {
        // 非18位为假
        if (idCard.length() != 18) {
            return false;
        }
        // 获取前17位
        String idcard17 = idCard.substring(0, 17);
        // 获取第18位
        String idcard18Code = idCard.substring(17, 18);
        char c[] = null;
        String checkCode = &quot;&quot;;
        // 是否都为数字
        if (isDigital(idcard17)) {
            c = idcard17.toCharArray();
        } else {
            return false;
        }

        if (null != c) {
            int bit[] = new int[idcard17.length()];
            bit = converCharToInt(c);
            int sum17 = 0;
            sum17 = getPowerSum(bit);

            // 将和值与11取模得到余数进行校验码判断
            checkCode = getCheckCodeBySum(sum17);
            if (null == checkCode) {
                return false;
            }
            // 将身份证的第18位与算出来的校码进行匹配，不相等就为假
            if (!idcard18Code.equalsIgnoreCase(checkCode)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 18位身份证号码的基本数字和位数验校
     *
     * @param idCard
     * @return
     */
    public boolean is18Idcard(String idCard) {
        return Pattern.matches(&quot;^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([\\d|x|X]{1})$&quot;, idCard);
    }

    /**
     * 数字验证
     *
     * @param str
     * @return
     */
    public static boolean isDigital(String str) {
        return str == null || &quot;&quot;.equals(str) ? false : str.matches(&quot;^[0-9]*$&quot;);
    }

    /**
     * 将身份证的每位和对应位的加权因子相乘之后，再得到和值
     *
     * @param bit
     * @return
     */
    public static int getPowerSum(int[] bit) {

        int sum = 0;

        if (power.length != bit.length) {
            return sum;
        }

        for (int i = 0; i &amp;lt; bit.length; i++) {
            for (int j = 0; j &amp;lt; power.length; j++) {
                if (i == j) {
                    sum = sum + bit[i] * power[j];
                }
            }
        }
        return sum;
    }

    /**
     * 将和值与11取模得到余数进行校验码判断
     *
     * @param sum17
     * @return 校验位
     */
    public static String getCheckCodeBySum(int sum17) {
        String checkCode = null;
        switch (sum17 % 11) {
            case 10:
                checkCode = &quot;2&quot;;
                break;
            case 9:
                checkCode = &quot;3&quot;;
                break;
            case 8:
                checkCode = &quot;4&quot;;
                break;
            case 7:
                checkCode = &quot;5&quot;;
                break;
            case 6:
                checkCode = &quot;6&quot;;
                break;
            case 5:
                checkCode = &quot;7&quot;;
                break;
            case 4:
                checkCode = &quot;8&quot;;
                break;
            case 3:
                checkCode = &quot;9&quot;;
                break;
            case 2:
                checkCode = &quot;x&quot;;
                break;
            case 1:
                checkCode = &quot;0&quot;;
                break;
            case 0:
                checkCode = &quot;1&quot;;
                break;
        }
        return checkCode;
    }

    /**
     * 将字符数组转为整型数组
     *
     * @param c
     * @return
     * @throws NumberFormatException
     */
    public static int[] converCharToInt(char[] c) throws NumberFormatException {
        int[] a = new int[c.length];
        int k = 0;
        for (char temp : c) {
            a[k++] = Integer.parseInt(String.valueOf(temp));
        }
        return a;
    }


    public static void main(String[] args) {
        String idCardForFalse = &quot;350583199108290106&quot;;
        String idCardForTrue = &quot;350583197106150219&quot;;
        if (IdCardValidatorUtils.isValidatedAllIdcard(idCardForTrue)) {
            System.out.println(&quot;身份证校验正确&quot;);
        } else {
            System.out.println(&quot;身份证校验错误！&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;自定义注解&quot;&gt;2.2 自定义注解&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Documented
@Target({ElementType.PARAMETER, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = IdentityCardNumberValidator.class)
public @interface IdentityCardNumber {

    String message() default &quot;身份证号码格式不正确&quot;;

    Class&amp;lt;?&amp;gt;[] groups() default {};

    Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;仔细的你会发现，相对于一般的自定义注解，该注解：&lt;br/&gt;&lt;code&gt;@Constraint(validatedBy = IdentityCardNumberValidator.class)&lt;/code&gt;,该注解的作用就是调用身份证校验的工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;在userdto-需要校验的字段添加声明&quot;&gt;2.3 在&lt;code&gt;UserDTO&lt;/code&gt; 需要校验的字段添加声明&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 身份证号（校验：自定义注解校验）
 */
@IdentityCardNumber
private String idNumber;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;控制层接口&quot;&gt;2.4 控制层接口&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/custom&quot;)
public class ValidatorCustomController {

    /**
     * 自定义注解参数校验案例
     * @param userDTO
     * @return
     */
    @PostMapping(&quot;/test&quot;)
    public HttpResult test(@Validated UserDTO userDTO) {
        return HttpResult.success(userDTO);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;自定义注解的测试&quot;&gt;2.5 自定义注解的测试&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;请求方式：POST&lt;/li&gt;
&lt;li&gt;请求地址：localhost:8080/private/test&lt;/li&gt;
&lt;li&gt;请求参数：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;userName:Van
mobile:17098705205
email:110@qq.com
idNumber:350583199108290106&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回结果：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
    &quot;success&quot;: false,
    &quot;code&quot;: 400,
    &quot;data&quot;: null,
    &quot;message&quot;: &quot;身份证号码格式不正确&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三分组校验&quot;&gt;三、分组校验&lt;/h3&gt;
&lt;p&gt;除了上述的校验外，可能还有这种需求：&lt;/p&gt;
&lt;p&gt;在创建用户信息时，不需要校验&lt;code&gt;userId&lt;/code&gt;;但在更新用户信息时，需要校验&lt;code&gt;userId&lt;/code&gt;,而用户名，邮箱等两种情况都得校验。这种情况，就可以&lt;strong&gt;分组校验&lt;/strong&gt;来解决了。&lt;/p&gt;
&lt;h4 id=&quot;定义分组接口&quot;&gt;3.1 定义分组接口&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Create.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import javax.validation.groups.Default;

public interface Create extends Default {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Update.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import javax.validation.groups.Default;

public interface Update extends Default {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在userdto-需要校验的字段添加声明-1&quot;&gt;3.2 在&lt;code&gt;UserDTO&lt;/code&gt; 需要校验的字段添加声明&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
     * 用户id(只有在有Update分组中校验非空)
     */
    @NotNull(message = &quot;id 不能为空&quot;, groups = Update.class)
    private Long userId;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;控制层入参位置进行声明&quot;&gt;3.3 控制层入参位置进行声明&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/groups&quot;)
public class ValidatorGroupsController {

    /**
     * 更新数据，需要传入userID
     * @param userDTO
     * @return
     */
    @PostMapping(&quot;/update&quot;)
    public HttpResult updateData(@Validated(Update.class)UserDTO userDTO) {
        return HttpResult.success(userDTO);
    }
    /**
     * 新增数据，不需要传入userID
     * @param userDTO
     * @return
     */
    @PostMapping(&quot;/create&quot;)
    public HttpResult createData(@Validated(Create.class)UserDTO userDTO) {
        return HttpResult.success(userDTO);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分组校验的测试-新增测试&quot;&gt;3.4 分组校验的测试-新增测试&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;请求方式：POST&lt;/li&gt;
&lt;li&gt;请求地址：localhost:8080/groups/create&lt;/li&gt;
&lt;li&gt;请求参数：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;userName:Van
mobile:17098705205
email:110@qq.com
idNumber:350583197106150219
userId:&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回结果：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
    &quot;success&quot;: true,
    &quot;code&quot;: 200,
    &quot;data&quot;: {
        &quot;userId&quot;: null,
        &quot;sex&quot;: null,
        &quot;userName&quot;: &quot;Van&quot;,
        &quot;mobile&quot;: &quot;17098705205&quot;,
        &quot;email&quot;: &quot;110@qq.com&quot;,
        &quot;idNumber&quot;: &quot;350583197106150219&quot;,
        &quot;passWord&quot;: null
    },
    &quot;message&quot;: null
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求成功，说明新增请求，不检验&lt;code&gt;userId&lt;/code&gt;，即&lt;code&gt;userId&lt;/code&gt;可以为空。&lt;/p&gt;
&lt;h4 id=&quot;分组校验的测试-更新测试&quot;&gt;3.5 分组校验的测试-更新测试&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;请求方式：POST&lt;/li&gt;
&lt;li&gt;请求地址：localhost:8080/groups/update&lt;/li&gt;
&lt;li&gt;请求参数：同上（3.4）&lt;/li&gt;
&lt;li&gt;返回结果：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
    &quot;success&quot;: false,
    &quot;code&quot;: 400,
    &quot;data&quot;: null,
    &quot;message&quot;: &quot;id 不能为空&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求失败，说明更新请求，检验&lt;code&gt;userId&lt;/code&gt;，即&lt;code&gt;userId&lt;/code&gt;不能为空。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;结合 3.4 与 3.5 的测试结果，说明分组校验成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;四总结&quot;&gt;四、总结&lt;/h3&gt;
&lt;p&gt;希望大家写的每一行代码都是业务需要，而不是无聊且无穷无尽的参数校验。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vanDusty/SpringBoot-Home/tree/master/springboot-demo-parameter/validator-demo&quot;&gt;Github 示例代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Sep 2019 15:47:00 +0000</pubDate>
<dc:creator>风尘博客</dc:creator>
<og:description>如何逃离令人抓狂的 if-else 参数校验的代码，Van 带你用validator快速搞定，节省更多的时间勾搭小姐姐。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vandusty/p/11509569.html</dc:identifier>
</item>
<item>
<title>python每日经典算法题5(基础题)+1(中难题) - 一只帅气的IT小昂</title>
<link>http://www.cnblogs.com/ITXiaoAng/p/11507516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ITXiaoAng/p/11507516.html</guid>
<description>&lt;p&gt;　　现在，越来越多的公司面试以及考验面试对算法要求都提高了一个层次，从现在，我讲每日抽出时间进行5+1算法题讲解，5是指基础题，1是指1道中等偏难。希望能够让大家熟练掌握python的语法结构已经一些高级函数的应用。这些题目是在某些刷题的网站上登记的有水平的题目。这里如果有需要input的简单题，就略去了输出结果。如果时间充裕，则就会增加每日更多习题。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一：基础算法题10道&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.判断用户输入的年份是否为闰年&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目解析:&lt;/p&gt;
&lt;p&gt;(1)问题分析：&lt;span&gt;能被4整除但不能被100整除的年份为普通闰年，能被400整除的年份为世纪闰年，判断是否满足上述情况&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;(2)算法分析：输入一个数，先判断如果是400的倍数，则满足；如果不是400的倍数，再判断如果该数能够被4整除，却不能被100整除，则满足。&lt;/p&gt;
&lt;p&gt;(3)用到的python语法：input()标准输入函数，if判断语句，or，and逻辑运算符。&lt;/p&gt;
&lt;p&gt;(4)博主答题代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
n = int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入年份:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n % 400 == 0 &lt;span&gt;or&lt;/span&gt; n % 4 == 0 &lt;span&gt;and&lt;/span&gt; n % 100 !=&lt;span&gt; 0:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{0}是闰年&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{0}不是闰年&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(n))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(5)高效方法：&lt;br/&gt;python 的 calendar 库中已经封装好了一个方法 isleap() 来实现这个判断是否为闰年：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; calendar

n &lt;/span&gt;= int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入年份：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
year &lt;/span&gt;=&lt;span&gt; calendar.isleap(n)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; year ==&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}是闰年&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(n))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}不是闰年&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(n))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.判断一个数是否是质数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目解析:&lt;/p&gt;
&lt;p&gt;(1)问题分析：&lt;span&gt;除了1和它本身以外不再有其他的因数的数就是质数&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2)算法分析：输入一个数，如果该数大于1，则从2开始循环到该数并一一整除该数，如果余数为0，则该数不是质数；否则该数是质数。&lt;/p&gt;
&lt;p&gt;(3)用到的python语法：input()标准输入函数，for循环，if判断语句。&lt;/p&gt;
&lt;p&gt;(4)博主答题代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
n = int(input(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2&lt;span&gt;,n):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n % i ==&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{0}不是质数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{n}={a}*{b}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(n=n,a=i,b=int(n/i)))    &lt;span&gt;# &lt;/span&gt;&lt;span&gt;这里也可为b=n//i&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{0}是质数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时如果想把非质数的所有非1与自己的因数输出，则可以改为如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
n = int(input(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;gt; 1&lt;span&gt;:
    m1 &lt;/span&gt;= 0;m2 =&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2&lt;span&gt;,n):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n % i ==&lt;span&gt; 0:
            str &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{0}不是质数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{n}={a}*{b}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(n=n,a=i,b=int(n/i)))    &lt;span&gt;# &lt;/span&gt;&lt;span&gt;这里也可为b=n//i&lt;/span&gt;
            m1 = 1;m2 = 1
        &lt;span&gt;elif&lt;/span&gt; m1==&lt;span&gt;0:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{0}是质数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; [m1,m2].count(1) == 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{0}不是质数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(n))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(5)高效方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
num = int(input(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;))
i &lt;/span&gt;= 2
&lt;span&gt;while&lt;/span&gt; i &amp;lt;&lt;span&gt; num:
    s &lt;/span&gt;= num %&lt;span&gt; i
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; s ==&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        i &lt;/span&gt;+= 1
&lt;span&gt;if&lt;/span&gt; num ==&lt;span&gt; i:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}是质数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(num))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}不是质数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(num))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.输出指定范围内的素数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)题目分析：&lt;span&gt;素数就是质，上一题已经介绍了如何求质数，这里我们需要加一个范围&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;(2)算法分析：把上一题判断的内容放在一个for循环选择范围里进行分析。&lt;/p&gt;
&lt;p&gt;(3)用到的python语法：input()标准输入函数，map函数，for循环，if判断语句。&lt;br/&gt;(4)博主答题代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
my_index1,my_index2 = map(int,input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择一个范围:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
result &lt;/span&gt;=&lt;span&gt; []

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt; range(my_index1,my_index2+1&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num &amp;gt; 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2&lt;span&gt;,num):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num % i) ==&lt;span&gt; 0:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            result.append(num)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{a}到{b}所有的质数有:{c}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(a = my_index1,b = my_index2,c = result))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的if和else是就近匹配，和上面的不同，这就避免了重复，这是要注意的一点。&lt;/p&gt;
&lt;p&gt;展示这是最简单的方法，如果大家有好的方法，请评论。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.约瑟夫生者死者小游戏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;30 个人在一条船上，超载，需要 15 人下船。&lt;/p&gt;
&lt;p&gt;于是人们排成一队，排队的位置即为他们的编号。&lt;/p&gt;
&lt;p&gt;报数，从 1 开始，数到 9 的人下船。&lt;/p&gt;
&lt;p&gt;如此循环，直到船上仅剩 15 人为止，问都有哪些编号的人下船了呢？&lt;/p&gt;
&lt;p&gt;这一题可以扩展为：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;m个人在一条船上，超载，需要n人下船。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是人们排成一队，排队的位置即为他们的编号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;报数，从 1 开始，数到 k 的人下船。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如此循环，直到船上仅剩 m - n人为止，问都有哪些编号的人下船了呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1)题目分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1735560/201909/1735560-20190911211040211-451360783.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2)算法分析：这里设置编号从1开始，先给出从1到m的所有编号，用一个列表表示，需要n个人下船，则船上就生了m-n个人。以此循环递归，其实也可以转化为递归问题。但这里每次递归，当找到数到编号k，就把编号k所在的序号，就是编号删除。这里可以设置一个外部变量，从第一个编号index开始，当index=k时，把编号重新置为1，每次都这样，直到循环完毕，直到所有最后剩余元素个数为m-n。&lt;/p&gt;
&lt;p&gt;(3)用到的python语法：for循环，函数，列表操作，列表切片。&lt;/p&gt;
&lt;p&gt;(4)博主答题代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; yueSeFu(m,n,k):
    serial_num &lt;/span&gt;= list(range(1,m +1))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建从1到m的序号&lt;/span&gt;
    index = 0                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置外部变量index&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; len(serial_num) &amp;gt; m - n:        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当最后剩余人数为m - n之前，一直进行下面的程序&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; serial_num:            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历每个编号&lt;/span&gt;
            index += 1                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把外部变量index进行真实遍历&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; index == k:                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当外部变量index找到k时，进行下面代码块的操作&lt;/span&gt;
                serial_num.remove(i)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 移除需要下船的人的编号&lt;/span&gt;
                index = 1                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这时候index已经找到序号k了，就要重新遍历&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{0}号人下船了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(i))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传入起始人数m，需要下船的人数n，数到多少下船的序号k,这里可自行设置&lt;/span&gt;
    yueSeFu(30,15,9)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(5)高效方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; yueSeFu(m,n,k):
    people &lt;/span&gt;= list(range(1, m+1&lt;span&gt;))
    i &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; len(people) &amp;gt; m -&lt;span&gt; n:
        i &lt;/span&gt;+= (k - 1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i &amp;gt;=&lt;span&gt; len(people):
            i &lt;/span&gt;-=&lt;span&gt; len(people)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}号下船了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(people[i]))
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; people[i]

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传入起始人数m，需要下船的人数n，数到多少下船的序号k&lt;/span&gt;
    yueSeFu(30,15,9)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5.二分查找，返回某个值在数组中的索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)题目分析：二分搜索是一种在有序数组中查找某一特定元素的搜索算法。从数组的中间元素开始，正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。&lt;/p&gt;
&lt;p&gt;(2)算法分析：这里重复查找需要用到递归，用到一个一维数组，先判断数组查找的元素末尾下标是否大于等于1。如果是的话，就要先找到中间位置，如果大于中间位置，就只比较左边的元素重新递归；如果小于中间位置，则比较右边的元素重新递归。找不到就返回-1。&lt;br/&gt;(3)用到的python语法：if判断语句，函数，递归算法。&lt;/p&gt;
&lt;p&gt;(4)博主答题代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; twoSearch(x,arr,begin,end):    &lt;span&gt;# &lt;/span&gt;&lt;span&gt;x为要查询的元素,arr为数组,begin和and是每次查找的范围&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; end &amp;gt;= 1&lt;span&gt;:
        mid &lt;/span&gt;= int(begin + (end-1)/2)    &lt;span&gt;# &lt;/span&gt;&lt;span&gt;每次范围的元素中间位置&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; int(arr[mid]) ==&lt;span&gt; x:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; int(arr[mid]) &amp;gt; x:        &lt;span&gt;# &lt;/span&gt;&lt;span&gt;元素小于中间的元素，需要比较左边的元素&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; twoSearch(x,arr,begin,end - 1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;:                    &lt;span&gt;# &lt;/span&gt;&lt;span&gt;元素大于中间的元素，需要比较右边的元素&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; twoSearch(x,arr,begin + 1&lt;span&gt;,end)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    my_arr &lt;/span&gt;= list(map(int,input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入数组:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)))    &lt;span&gt;# &lt;/span&gt;&lt;span&gt;返回可迭代对象&lt;/span&gt;
    my_x = int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入要查找的元素:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    result &lt;/span&gt;= twoSearch(my_x, my_arr, 0, len(my_arr) - 1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; result != -1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;元素在数组中的索引为:{0}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(result))
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;元素不在数组中&lt;/span&gt;&lt;span&gt;')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：中等算法题2道&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.两数之和&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;给定 nums = [2, 7, 11, 15], target = 9&lt;/p&gt;
&lt;p&gt;因为 nums[0] + nums[1] = 2 + 7 = 9&lt;br/&gt;所以返回 [0, 1]&lt;/p&gt;
&lt;p&gt;(1)算法解析：&lt;span&gt;我们给出一个列表，进行两次循环，就可以得到结果&lt;/span&gt;。&lt;br/&gt;(2)博主代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; twoSum(nums, target):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; index1,i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(nums):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; index2,j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(nums):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i+j == target &lt;span&gt;and&lt;/span&gt; i !=&lt;span&gt; j:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index1,index2


a &lt;/span&gt;= list(map(int,input().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))
b &lt;/span&gt;=&lt;span&gt; int(input())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(list(twoSum(a,b)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; index1,i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(nums):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; index2,j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(nums):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i+j == target &lt;span&gt;and&lt;/span&gt; i !=&lt;span&gt; j:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; index1,index2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)代码问题&lt;/p&gt;
&lt;p&gt;　　但是在运行很多个数字的列表中，需要两次循环遍历列表，如果列表的长度为n，则时间复杂度为O(n)，时间执行效率太差，最差为O(n^2)，故上面的代码实际上是不太可取的。&lt;/p&gt;
&lt;p&gt;(4)高级算法&lt;/p&gt;
&lt;p&gt;下面有一些改进的高级一点的算法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表生成式三行代码搞定：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(nums)):    &lt;span&gt;# &lt;/span&gt;&lt;span&gt;循环遍历列表&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里是用和减去列表中的某一元素，并且两个元素下标不同，就返回两个下标&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(target-nums[i] &lt;span&gt;in&lt;/span&gt; nums &lt;span&gt;and&lt;/span&gt; i != nums.index(target-&lt;span&gt;nums[i])):
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [i,nums.index(target-nums[i])]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行用时 :1284ms，内存消耗 :14.7MB左右，比上面的代码节省了一层循环遍历的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典查找，利用哈希表，不用遍历：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
my_dict = {}                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个字典&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; index, num1 &lt;span&gt;in&lt;/span&gt; enumerate(nums):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用函数enumerate输出列表或数组的下标和元素&lt;/span&gt;
        num2 = target - num1            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 另一个元素&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里是判断，如果字典中有另一个元素值的话，返回下标，以及该元素下标&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里由于字典是键值对，就避免了两个元素和符合，单元素是同一个元素的情况&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; num2 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; my_dict:                
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [my_dict[num2], index]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把字典中的元素对应于键&lt;/span&gt;
        my_dict[num1] =&lt;span&gt; index
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行用时 :68ms，内存消耗 :15 MB左右，时间效率更高。&lt;/p&gt;
&lt;p&gt;利用集合进行操作，效率和字典差不多：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
my_set =&lt;span&gt; set(nums)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(nums):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (target - v) &lt;span&gt;in&lt;/span&gt; my_set &lt;span&gt;and&lt;/span&gt; i != nums.index(target -&lt;span&gt; v):
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [i, nums.index(target - v)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行用时 :80ms，内存消耗 :15 .2MB左右。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.用python字典或集合的效率要高很多，不建议常用列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.生成一个整数序列可以先生成一个可迭代对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　比如生成一个只有整数的可迭代对象：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;map(int,input('请选择一个范围:').split(','))&lt;/p&gt;
&lt;p&gt;　　3.calendar.isleap(n可以判断是否为闰年。&lt;/p&gt;
&lt;p&gt;　　4.列表生成式常用可以减少代码量，当然是有必要用列表的时候。&lt;/p&gt;
&lt;p&gt;　　5.enumerate对既需要元素和下标值的序列很有用。&lt;/p&gt;
</description>
<pubDate>Wed, 11 Sep 2019 15:24:00 +0000</pubDate>
<dc:creator>一只帅气的IT小昂</dc:creator>
<og:description>现在，越来越多的公司面试以及考验面试对算法要求都提高了一个层次，从现在，我讲每日抽出时间进行5+1算法题讲解，5是指基础题，1是指1道中等偏难。希望能够让大家熟练掌握python的语法结构已经一些高级</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ITXiaoAng/p/11507516.html</dc:identifier>
</item>
<item>
<title>解开Batch Normalization的神秘面纱 - JieLongZ</title>
<link>http://www.cnblogs.com/jielongAI/p/11497223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jielongAI/p/11497223.html</guid>
<description>&lt;p&gt;停更博客好长一段时间了，其实并不是没写了，而是转而做笔记了，但是发现做笔记其实印象无法更深刻，因此决定继续以写博客来记录或者复习巩固所学的知识，与此同时跟大家分享下自己对深度学习或者机器学习相关的知识点，当然浅薄之见如有说错表达错误的，欢迎大家指出来。废话不多说，进入今天的主题：&lt;span&gt;&lt;strong&gt;&lt;span&gt;Batch Normalization&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1502.03167&quot; target=&quot;_blank&quot;&gt;Batch Normalization&lt;/a&gt;（BN）是由&lt;strong&gt;Sergey Ioffe&lt;/strong&gt;和&lt;strong&gt;Christian Szegedy&lt;/strong&gt;在&lt;strong&gt;&lt;span&gt;2015年&lt;/span&gt;&lt;/strong&gt;的时候提出的，后者同时是Inception的提出者（深度学习领域的大牛），截止至动手写这篇博客的时候Batch Normalization的论文被引用了12304次，这也足以说明BN被使用地有多广泛。在正式介绍BN之前，有必要了解下&lt;span&gt;feature scaling（特征归一化），这是不论做传统机器学习也好或者现在深度学习也好，预处理阶段可以说是必不可少的一步也是确保模型能够正常学习非常重要的一步&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、为什么需要使用feature scaling？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Feature scaling指的是对输入的数据特征进行归一化操作（一般有&lt;a href=&quot;https://www.cnblogs.com/jielongAI/p/11509536.html&quot; target=&quot;_blank&quot;&gt;min-max normalization或者min-max standardization两种&lt;/a&gt;）以确保所有特征的值处于同一维度。假设现在有x&lt;sub&gt;1&lt;/sub&gt;和x&lt;sub&gt;2&lt;/sub&gt;是两个特征，从公式a = Sigmoid(W&lt;sup&gt;T&lt;/sup&gt;X + b)计算loss可以知道，如果x&lt;sub&gt;1&lt;/sub&gt;和x&lt;sub&gt;2&lt;/sub&gt;的特征值差别很大的话但是假设他们对结果的影响力一致的话（如下图所示），那么意味着w&lt;sub&gt;1&lt;/sub&gt;的数值维度会比较大, w&lt;sub&gt;2&lt;/sub&gt;的数值维度则会比较小，而如果要使w&lt;sub&gt;1&lt;/sub&gt;和w&lt;sub&gt;2&lt;/sub&gt;有一个同等的变化（&lt;span&gt;如果这样子需要设置不同的learning rate进行更新，针对w&lt;/span&gt;&lt;span&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/span&gt;&lt;span&gt;的步长要设置编辑哦大而w&lt;/span&gt;&lt;span&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/span&gt;&lt;span&gt;比较小来更新，以此来使模型的loss达到收敛&lt;/span&gt;，参照图2来理解，这里要稍微想象一下，我最开始也比较困惑为什么使如此），那么意味着x&lt;sub&gt;1&lt;/sub&gt;w&lt;sub&gt;1&lt;/sub&gt;的结果就比较小，而x&lt;sub&gt;2&lt;/sub&gt;w&lt;sub&gt;2&lt;/sub&gt;的结果会比较大（&lt;span&gt;根据个人建模的经验来说，如果特征数值维度差别很大的话，一般模型很难训练，直白点说就是loss几乎不收敛，可能刚开始收敛，后面就乱串了，有其他经历的朋友可以留言告知下&lt;/span&gt;）。由此可以影响训练速度和精度，因为针对不同的特征，需要不同的学习率来调整，由此拖慢了训练速度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1441504/201909/1441504-20190911212924650-658240853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图1 简单的神经元计算流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1441504/201909/1441504-20190911214914287-1259841179.png&quot; alt=&quot;&quot;/&gt;                           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1441504/201909/1441504-20190911215121658-1679044393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  图2 特征值差异较大时的训练过程（左）和特征值大小处于同一维度的训练过程（右）&lt;/p&gt;
&lt;p&gt;一般的feature scaling是如何做呢？计算每个dimension的mean和每个dimension的std（feature scaling之后的每一维的值的均值为0，方差为1），做feature scaling之后梯度下降收敛会快点。当对输入的特征做完feature scaling之后，不免会引起一定困惑，那就是在神经网络中由于网络结构含有多层隐藏层，每一层隐藏层的输入时下一层的输入，那么这些&lt;strong&gt;&lt;span&gt;隐藏层的输入&lt;/span&gt;&lt;/strong&gt;（下面统一用这种说辞，避免混淆）是否需要也进行feature scaling呢？经过&lt;strong&gt;Sergey Ioffe&lt;/strong&gt;和&lt;strong&gt;Christian Szegedy&lt;/strong&gt;的验证答案是肯定的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、神经网络中隐藏层为什么要做feature scaling?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 2.1 Internal Covariate Shift&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在正式进入正题之前，同样十分有必要解释下Internal Covariate shift（ICS）是什么以及对深度学习训练模型的影响？在此之前，又得再先确认一个概念，那就是：深度学习和机器学习在进行模型训练的时候都是基于数据IID（Independently identically distribution，独立同分布）的情况。那什么是独立同分布呢？独立（两个事件没有关联）意味着数据之间（一般指训练数据和测试数据，测试数据一般又指未见过的数据）是相互独立的，同分布则指明数据具有相同分布形状并且具有相同分布的参数（&lt;span&gt;这里可以想象下为为什么针对采样自统一分布的数据进行模型训练和学习，例如想象下参数的变化，数据集拆分符合分布规律等等，也就能明白IID是如何影响深度学习模型和机器学习模型的&lt;/span&gt;），更直观点说就是选取用于训练的数据要具有全局代表性，以便可以对未知的数据进行预测。&lt;/p&gt;
&lt;p&gt;那什么又是ICS呢？&lt;strong&gt;&lt;span&gt;在神经网络的设计往往都是含有多个隐藏层，而像之前说的当前隐藏层的输出是下一个隐藏层的输入，把这个输入当作一个分布来看的话，而由于为了使训练收敛参数不断处于更新之中，当前隐藏层的参数更新之后会影响下一个隐藏层的输入，也就是说由于参数的改变，输入改变了（也就是分布改变了），这个跟基于IID的假设是相违背的，&lt;/span&gt;&lt;/strong&gt;出现这种现象则称之为ICS（&lt;span&gt;可通过设置小一点的学习率可以改善，但是小的学习率影响训练速度因为步长变短了&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 Batch Normalization&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为了降低ICS所带来的影响，BN就被提出来了&lt;/strong&gt;&lt;/span&gt;。这里我们来看下通常神经网络结构是如何设计的: x with feature scaling -&amp;gt; layer1 -&amp;gt; a1(feature scaling?) -&amp;gt; layer2 -&amp;gt; a2(feature scaling?) 。那既然是叫Batch Normalization，那么就意味着这个normalization是针对一个Batch一个batch的。这里再复习下Batch训练的一些基本原理，batch的意思是训练网络的时候一次性拿几个样本并行的做计算，比如batch=4，那么就是四个样本作为输入一起乘上同一个参数（如下图3所示）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1441504/201909/1441504-20190911225516301-1456172280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图3 Batch Training&lt;/p&gt;
&lt;p&gt;实际运算中，batch=4的四个样本会被拼成一整个matrix，这里从编程的角度想想会更好理解，例如要对1万张图片进行训练，&lt;strong&gt;&lt;span&gt;选取batch=4，假设每个图片的高和宽为224和224，通道数为3，那么他们的shape就是（4，224，224，3）&lt;/span&gt;&lt;/strong&gt;，这个用numpy或者PyTorch或者TensorFlow来在电脑上展示出来都是一个矩阵。Batch normalization是如何作用在batch上的呢？一般是先BN后activation，如果先做activation再做BN的话，input就有可能落在saturation值域上（tanh和sigmoid都容易存在这个问题），那么就会产生gradient vanishing（梯度消失）的问题。接下来看看Batch Normalization的计算，一般是基于batch计算μ和σ的（均值和标准差），由于整个数据集量很大，如果是针对整个数据集计算μ和σ的话，那么计算开销很大，所以BN是作用在batch上的数据，这也由此引申出一个问题，那就是在使用BN的时候，batch应该尽量设置比较大（batch &amp;lt; n where n is the number of samples），BN的计算演示图如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1441504/201909/1441504-20190911231344531-1710531031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4 引入BN的神经网络结构图&lt;/p&gt;
&lt;p&gt;那么使用BN的话怎么进行训练呢？&lt;strong&gt;&lt;span&gt;使用BN的时候，在做BP的时候也同样需要去更新计算出来的batch的μ和σ，因为μ和σ也会影像training loss。&lt;/span&gt;&lt;/strong&gt;在经过BN之后，数据的值的分布是服从mean为0，方差为1的。但是有时候并不是服从这样子的分布才是网络更robust，所以此时希望对做了BN之后的数值做一个scale和偏移。这也就是论文中的β和γ存在的因素。但是仔细的人应该可以看出来，最后一个公式是计算μ和σ的来normalize输入的逆过程，如果当μ、σ（calculated from batch）和γ、β一样的话，就等于BN没有任何作用。但是此时需要注意的是，&lt;span&gt;μ和σ是受到每一层的输入的影响的，但是γ和β是独立的，不受输入的影响&lt;/span&gt;，并且γ和β是整个网络的参数。通过上面的讲述，可以清楚看到BN在训练神经网络模型的过程中引入了&lt;span&gt;&lt;strong&gt;&lt;span&gt;四个新的需要被训练的参数：μ、σ、γ和β&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。下图是来自论文的上述参数的每个计算公示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1441504/201909/1441504-20190910145446571-1237326850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5 原论文中的计算公式 &lt;/p&gt;
&lt;p&gt;使用BN在测试阶段同样会遇到一个问题，因为我们知道在training的时候是一个Batch一个Batch进行训练的，但是测试的时候（做预测时）是没有所谓的batch之说的。这个时候一个比较实用的操作就是计算在训练过程μ和σ的moving average，并且让在靠近训练结束的位置占比较大的权重，而刚开始训练的时候占比较小的权重。&lt;/p&gt;
&lt;p&gt;最后，来看看使用BN所带来的好处都有哪些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少训练时间，这是因为ICS所带来的的影响减小了，由此可以使用较大的学习率；&lt;/li&gt;
&lt;li&gt;避免梯度爆炸或者梯度消失（尤其在使用sigmoid和tanh这类激活函数的时候）；&lt;/li&gt;
&lt;li&gt;学习率受参数初始化的影响减小；&lt;/li&gt;
&lt;li&gt;让训练的模型不那么容易过拟合（overfitting）；&lt;/li&gt;
&lt;li&gt;减少对正则化的依赖（如减少使用dropout）；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 11 Sep 2019 15:23:00 +0000</pubDate>
<dc:creator>JieLongZ</dc:creator>
<og:description>停更博客好长一段时间了，其实并不是没写了，而是转而做笔记了，但是发现做笔记其实印象无法更深刻，因此决定继续以写博客来记录或者复习巩固所学的知识，与此同时跟大家分享下自己对深度学习或者机器学习相关的知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jielongAI/p/11497223.html</dc:identifier>
</item>
</channel>
</rss>