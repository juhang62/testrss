<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Nacos系列：基于Nacos的注册中心 - 知行旅人</title>
<link>http://www.cnblogs.com/javagoboy/p/10426477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javagoboy/p/10426477.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;所谓&lt;code&gt;注册中心&lt;/code&gt;，其实是分布式架构演进过程中的产物，在系统中充当一个协调者的角色。但是，为什么需要这样一个协调者的角色呢？我们先来看一个例子，以便理解为什么分布式架构中需要有注册中心。&lt;/p&gt;
&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;小明和小新住在同一家沃尔玛超市附近，他俩都办了会员，经常关注超市的一些优惠活动，元宵节快到了，沃尔玛准备搞一个元宵节特惠活动，需要通知到附近的住户。对于沃尔玛来说，可以安排工作人员电话通知到小明和小新；而对于小明和小新来说，可以去超市咨询相关信息。&lt;/p&gt;
&lt;p&gt;那么问题来了，住在超市附近的，不只有小明和小新两个消费者，如果每个人都打电话去通知就显得太麻烦了，小明和小新提前在超市了解了相关信息，可是不巧的是，由于各种原因，沃尔玛元宵特惠活动要从上午改到下午才开始，他们又该从何得知呢？&lt;/p&gt;
&lt;p&gt;其实，沃尔玛关心的是通知能不能传达到附近的住户，小明和小新关心的是沃尔玛优惠活动的详情动态。沃尔玛不必给每个住户挨个电话通知，它只需要在它的微信公众号上推送一条消息即可，小明和小新也不用去超市咨询，只要随时关注沃尔玛公众号的推送消息即可。&lt;/p&gt;
&lt;p&gt;在上面这个例子中，沃尔玛就是服务提供者，小明和小新是服务消费者，微信公众号类似于注册中心，沃尔玛将“服务”发布到注册中心，小明和小新作为消费者，订阅注册中心上沃尔玛提供的“服务”，通过微信公众号，沃尔玛（服务方）和小明、小新（消费方）就“解耦”了。&lt;/p&gt;
&lt;p&gt;用这个例子来解释注册中心未必恰当，毕竟系统中的服务既可以是服务提供者(Provider)，也可以是服务消费者(Consumer)，但我想的是以一种更加通俗的方式来解释它，技术日新月异，各种技术、术语层出不穷，容易让人头晕眼花，但万变不离其宗，技术源于现实世界，亦服务于现实世界，在现实世界中，我们思考如何解决问题，技术也必然以同样的思路去解决问题。&lt;/p&gt;
&lt;p&gt;关于注册中心，更技术层面的解释，大家可以看一下这篇文章:&lt;a href=&quot;https://www.jianshu.com/p/5014bb302c7d&quot;&gt;《服务注册中心架构演进》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在现有的技术方案中，注册中心主要分为两类，一类是&lt;code&gt;CP&lt;/code&gt;类注册中心，另一类是&lt;code&gt;AP&lt;/code&gt;类注册中心，&lt;code&gt;Nacos&lt;/code&gt;属于后者，为什么会有 &lt;code&gt;CP&lt;/code&gt; 和 &lt;code&gt;AP&lt;/code&gt; 两种不同类型的注册中心呢？这就不得不提到分布式的一个理论：&lt;code&gt;CAP理论&lt;/code&gt;。它是由加州大学的计算机科学家 &lt;code&gt;Eric Brewer&lt;/code&gt; 提出，在一个分布式系统中，&lt;code&gt;Consistency&lt;/code&gt;（一致性）、&lt;code&gt;Availability&lt;/code&gt;（可用性）、&lt;code&gt;Partition tolerance&lt;/code&gt;（分区容错性）无法同时满足，正所谓“鱼和熊掌与虾不可兼得也”。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CP&lt;/code&gt;类注册中心更强调一致性，而&lt;code&gt;AP&lt;/code&gt;类注册中心更强调可用性，它们之间的区别，推荐阅读阿里中间件博客的文章：&lt;a href=&quot;http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/&quot;&gt;《阿里巴巴为什么不用 ZooKeeper 做服务发现？》&lt;/a&gt;, 这篇文章我看了好几遍，虽然不能完全理解，但也能明白十之八九。如果你看完文章后，得到的结论是以后再也不把 Dubbo 和 Zookeeper 结合起来使用了，那么你便错了。因为，对于绝大多数公司的绝大多数系统，无论是 Dubbo + Zookeeper,还是 Dubbo + Nacos，都能够满足需求，有的公司甚至都不需要使用Dubbo，所以，一定要结合实际的业务场景来分析判断。&lt;/p&gt;
&lt;p&gt;不过，我们作为技术开发人员，了解技术原理是很重要的，唯有了解其底层逻辑，才知道如何做技术选型以及解决疑难杂症。&lt;/p&gt;
&lt;p&gt;好了，让我们回到&lt;code&gt;Nacos&lt;/code&gt;本身，下面将从代码层面分别介绍 Nacos + Spring 和 Nacos + Spring Boot 的使用，我的案例都是基于 Nacos 官网的示例（毕竟官网是最好的学习资料嘛）。&lt;/p&gt;
&lt;h2 id=&quot;nacos-结合-spring&quot;&gt;Nacos 结合 Spring&lt;/h2&gt;
&lt;p&gt;先来看 Nacos + Spring 的使用：&lt;/p&gt;
&lt;p&gt;添加 maven 依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.nacos&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;nacos-spring-context&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.2.2-RC1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;@EnableNacosDiscovery&lt;/code&gt; 开启 Nacos Spring 的服务发现功能&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableNacosDiscovery(globalProperties = @NacosProperties(serverAddr = &quot;127.0.0.1:8848&quot;))
public class NacosDiscovery {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;@NacosInjected&lt;/code&gt; 注入 Nacos 的&lt;code&gt;NamingService&lt;/code&gt;实例，通过&lt;code&gt;NamingService&lt;/code&gt;的&lt;code&gt;registerInstance()&lt;/code&gt; 向 Nacos Server 注册一个名称为applicationName的服务，当然，你也可以通过 &lt;code&gt;Nacos Open API&lt;/code&gt; 方式注册：&lt;br/&gt;&lt;code&gt;curl -X PUT 'http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=XXX&amp;amp;ip=XXX&amp;amp;port=XXX'&lt;/code&gt;，这里我们介绍使用代码的方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableNacosDiscovery(globalProperties = @NacosProperties(serverAddr = &quot;127.0.0.1:8848&quot;))
public class NacosDiscovery {

    @NacosInjected
    private NamingService namingService;

    @Value(&quot;${server.port}&quot;)
    private int serverPort;

    @Value(&quot;${spring.application.name}&quot;)
    private String applicationName;

    @PostConstruct
    public void registerInstance() throws NacosException {
        namingService.registerInstance(applicationName, &quot;127.0.0.1&quot;, serverPort);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再写一个Controller来验证服务是否再 Nacos Server 上注册了，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
@RequestMapping(value = &quot;discovery&quot;)
public class NacosDiscoveryController {

    @NacosInjected
    private NamingService namingService;

    @RequestMapping(value = &quot;/get&quot;, method = GET)
    @ResponseBody
    public List&amp;lt;Instance&amp;gt; getInstance(@RequestParam String serviceName) throws NacosException {
        return namingService.getAllInstances(serviceName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动 Nacos Server，安装及启动方式请参考：&lt;a href=&quot;https://www.cnblogs.com/javagoboy/p/10423678.html&quot;&gt;《Nacos系列：欢迎来到Nacos的世界！》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后启动Tomcat，我们先来看看Nacos控制台有什么变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/ccf0e1c080d7ef8963fd39a958e958b6c4a.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在控制台上，我们可以看到名为nacos-spring-discovery服务实例，点击详情按钮查看实例的详细信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/5130ca3d716a31ea32192c25912ece0eab0.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在浏览器上访问：&lt;code&gt;http://127.0.0.1:8080/discovery/get?serviceName=nacos-spring-discovery&lt;/code&gt;，返回结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[{
    &quot;instanceId&quot;: &quot;127.0.0.1#8080#{\&quot;defaultCheckPort\&quot;:80,\&quot;defaultPort\&quot;:80,\&quot;healthChecker\&quot;:{\&quot;type\&quot;:\&quot;TCP\&quot;},\&quot;metadata\&quot;:{},\&quot;name\&quot;:\&quot;\&quot;,\&quot;useIPPort4Check\&quot;:true}#nacos-spring-discovery&quot;,
    &quot;ip&quot;: &quot;127.0.0.1&quot;,
    &quot;port&quot;: 8080,
    &quot;weight&quot;: 1.0,
    &quot;healthy&quot;: true,
    &quot;cluster&quot;: {
        &quot;serviceName&quot;: null,
        &quot;name&quot;: &quot;&quot;,
        &quot;healthChecker&quot;: {
            &quot;type&quot;: &quot;TCP&quot;
        },
        &quot;defaultPort&quot;: 80,
        &quot;defaultCheckPort&quot;: 80,
        &quot;useIPPort4Check&quot;: true,
        &quot;metadata&quot;: {}
    },
    &quot;service&quot;: null,
    &quot;metadata&quot;: {}
}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和我们刚才在控制台看到的数据是一致的。&lt;/p&gt;
&lt;p&gt;以上就是 Nacos 结合 Spring 的实现方式，那么 Nacos 结合 Spring Boot 呢？其实没什么太大区别。&lt;/p&gt;
&lt;h2 id=&quot;nacos-结合-spring-boot&quot;&gt;Nacos 结合 Spring Boot&lt;/h2&gt;
&lt;p&gt;添加 Starter 依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;nacos-discovery-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.2.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;application.properties&lt;/code&gt;中添加如下配置信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server.port=8080
spring.application.name=nacos-springboot-discovery
nacos.discovery.server-addr=127.0.0.1:8848&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加NacosDiscoveryApplication启动类，使用&lt;code&gt;@NacosInjected&lt;/code&gt;注入 Nacos 的 &lt;code&gt;NamingService&lt;/code&gt;实例，通过&lt;code&gt;NamingService&lt;/code&gt;的&lt;code&gt;registerInstance()&lt;/code&gt;向 Nacos Server 注册一个名称为applicationName的服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
public class NacosDiscoveryApplication {

    @NacosInjected
    private NamingService namingService;

    @Value(&quot;${server.port}&quot;)
    private int serverPort;

    @Value(&quot;${spring.application.name}&quot;)
    private String applicationName;

    @PostConstruct
    public void registerInstance() throws NacosException {
        namingService.registerInstance(applicationName, &quot;127.0.0.1&quot;, serverPort);
    }

    public static void main(String[] args) {
        SpringApplication.run(NacosDiscoveryApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加NacosDiscoveryController类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
@RequestMapping(value = &quot;discovery&quot;)
public class NacosDiscoveryController {

    @NacosInjected
    private NamingService namingService;

    @RequestMapping(value = &quot;/get&quot;, method = GET)
    @ResponseBody
    public List&amp;lt;Instance&amp;gt; getInstance(@RequestParam String serviceName) throws NacosException {
        return namingService.getAllInstances(serviceName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动NacosDiscoveryApplication，观察Nacos控制台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/49b061ef89d962296c9aec28e121e51bd23.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在浏览器上访问：&lt;code&gt;http://127.0.0.1:8080/discovery/get?serviceName=nacos-springboot-discovery&lt;/code&gt;，返回结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[{
    &quot;instanceId&quot;: &quot;127.0.0.1#8080#{\&quot;defaultCheckPort\&quot;:80,\&quot;defaultPort\&quot;:80,\&quot;healthChecker\&quot;:{\&quot;type\&quot;:\&quot;TCP\&quot;},\&quot;metadata\&quot;:{},\&quot;name\&quot;:\&quot;\&quot;,\&quot;useIPPort4Check\&quot;:true}#nacos-springboot-discovery&quot;,
    &quot;ip&quot;: &quot;127.0.0.1&quot;,
    &quot;port&quot;: 8080,
    &quot;weight&quot;: 1.0,
    &quot;healthy&quot;: true,
    &quot;cluster&quot;: {
        &quot;serviceName&quot;: null,
        &quot;name&quot;: &quot;&quot;,
        &quot;healthChecker&quot;: {
            &quot;type&quot;: &quot;TCP&quot;
        },
        &quot;defaultPort&quot;: 80,
        &quot;defaultCheckPort&quot;: 80,
        &quot;useIPPort4Check&quot;: true,
        &quot;metadata&quot;: {}
    },
    &quot;service&quot;: null,
    &quot;metadata&quot;: {}
}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，关于 Nacos 作为注册中心的话题先聊到这里，下一期将介绍 Nacos 作为配置中心的使用，敬请期待！&lt;/p&gt;
&lt;h2 id=&quot;示例源码&quot;&gt;示例源码&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Nacos + Spring&lt;/strong&gt; ：&lt;code&gt;learn-nacos-spring-discovery&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nacos + Spring Boot&lt;/strong&gt; ： &lt;code&gt;learn-nacos-springboot-discovery&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码已上传至&lt;code&gt;码云&lt;/code&gt;和&lt;code&gt;Github&lt;/code&gt;上，欢迎下载学习&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Sun, 24 Feb 2019 07:51:00 +0000</pubDate>
<dc:creator>知行旅人</dc:creator>
<og:description>注册中心主要分为两类，一类是`CP`类注册中心，另一类是`AP`类注册中心，`Nacos`属于后者，为什么会有 `CP` 和 `AP` 两种不同类型的注册中心呢？这就不得不提到分布式的一个理论：`CA</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/javagoboy/p/10426477.html</dc:identifier>
</item>
<item>
<title>理解Java的NIO - 小徐同学是个coder</title>
<link>http://www.cnblogs.com/zjxu97/p/10426429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjxu97/p/10426429.html</guid>
<description>

&lt;p&gt;同步和异步是针对应用程序和内核的交互而言的。&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;同步：执行一个操作之后，进程触发IO操作并等待(阻塞)或者轮询的去查看IO的操作(非阻塞)是否完成，等待结果，然后才继续执行后续的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作。&lt;/p&gt;
&lt;p&gt;非阻塞是针对于进程在访问数据的时候，根据IO口的状态返回不同的状态值。阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;非阻塞：进程给CPU传达任我后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。(轮询)&lt;/p&gt;
&lt;p&gt;同步异步是结果，阻塞非阻塞是手段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java IO的各种流是&lt;strong&gt;同步阻塞&lt;/strong&gt;的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 当然，他还有一个更加重要的特性是，多路复用IO。&lt;/p&gt;
&lt;p&gt;Java NIO的&lt;strong&gt;同步非阻塞&lt;/strong&gt;模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。&lt;/p&gt;
&lt;p&gt;之前使用futrueModel的就是类似异步IO模型。&lt;strong&gt;异步一定是非阻塞的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java的NIO有三个核心部分：Channels、Buffers、Selectors&lt;/p&gt;
&lt;h2&gt;Channel 和 Buffer&lt;/h2&gt;
&lt;p&gt;Channel有四个类型：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;文件&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;th&gt;TCP-client&lt;/th&gt;
&lt;th&gt;TCP-server&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;FileChannel&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;DatagramChannel&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;SocketChannel&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;ServerSocketChannel&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Buffer有八个实现类型，对应八种基本数据类型除了布尔型的七种，以及一个映射类型：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ByteBuffer&lt;/th&gt;
&lt;th&gt;IntBuffer&lt;/th&gt;
&lt;th&gt;CharIntBuffer&lt;/th&gt;
&lt;th&gt;FloatIntBuffer&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ShortBuffer&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;LongIntBuffer&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;DoubleIntBuffer&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;MappedByteBuffer&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;可以将一个Channel看作一个流，而buffer和channel联合起来就是一个带有缓冲区域的流。和stream不同的是，stream的方向是单向的，但是buffer和channel之间的数据传输是双向的，数据既可以从channel到buffer，也可以从buffer到channel。&lt;/p&gt;
&lt;h2&gt;Selector&lt;/h2&gt;
&lt;p&gt;Selector是一个管理器，可以管理多个channel。在线程中使用Selector，将Channel注册到Selector中，在channel中有事件就绪，就会将调用select方法，获取事件，响应事件。&lt;/p&gt;


&lt;p&gt;Channel 是一个接口，其常用的实现类有下面四个：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;文件&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;th&gt;TCP-client&lt;/th&gt;
&lt;th&gt;TCP-server&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;FileChannel&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;DatagramChannel&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;SocketChannel&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;ServerSocketChannel&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;一个Channel的使用实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;package com.xzj;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

//   @ author :zjxu     time:2019/1/8
public class Main {
    final static String PATH = &quot;/Users/thisxzj/IDEAProject/Revise/NIO/src/index.txt&quot;;

    public static void main(String[] args) throws IOException {
        RandomAccessFile file = new RandomAccessFile(PATH, &quot;rw&quot;);
        FileChannel fileChannel = file.getChannel();
        ByteBuffer byteBuffer = ByteBuffer.allocate(64);

        int length = fileChannel.read(byteBuffer);
        if (length != -1) {
            System.out.println(&quot;length = &quot; + length );
            byteBuffer.flip();          //反转buffer

            while (byteBuffer.hasRemaining()) {
                System.out.print((char) byteBuffer.get());
            }
                //byteBuffer.rewind();
            //while (byteBuffer.hasRemaining()) {
            //    System.out.print((char) byteBuffer.get());
            //}
            byteBuffer.clear();
        }
        fileChannel.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;length = 12
Hello World!
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Buffer是一个抽象类，他有有八个实现类型，对应八种基本数据类型除了布尔型的七种，以及一个映射类型：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ByteBuffer&lt;/th&gt;
&lt;th&gt;IntBuffer&lt;/th&gt;
&lt;th&gt;CharIntBuffer&lt;/th&gt;
&lt;th&gt;FloatIntBuffer&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ShortBuffer&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;LongIntBuffer&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;DoubleIntBuffer&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;MappedByteBuffer&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;buffer的基本用法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;写入数据到Buffer&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;flip()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;从Buffer中读取数据&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;clear()&lt;/code&gt;方法或者&lt;code&gt;compact()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;buffer的内部&lt;/h2&gt;
&lt;p&gt;buffer内部是一个对应类型的数组，这个数字有四个index，这四个index在数据的存取过程中有自己作用。属性解释：&lt;/p&gt;
&lt;ol start=&quot;&quot;&gt;&lt;li&gt;capacity：缓冲区数字的总长度。&lt;/li&gt;
&lt;li&gt;pasition：下一个要操作的数据元素的位置。&lt;/li&gt;
&lt;li&gt;limit：缓冲区不可操作的下一个位置的位置。&lt;/li&gt;
&lt;li&gt;mark：记录position前一个位置，default：-1(也就是不存在)。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用方法：&lt;/p&gt;
&lt;ol start=&quot;&quot;&gt;&lt;li&gt;创建方法：ByteBuffer.allocate(n) //创建一个长度为n的Byte的缓冲区。这个时候的 capacity 和 limit的大小都是数组的长度；position的大小是0，数组的首端。&lt;/li&gt;
&lt;li&gt;在写入了数据之后，position会变为数组没有存储数据的位置的一个位置。&lt;/li&gt;
&lt;li&gt;使用byteBuffer.flip方法，limit = position，position = 0，然后就可以正确的读取这鞋数据，并且将数据发送出去。&lt;/li&gt;
&lt;li&gt;然后使用 byteBuffer.clear方法，将会到刚刚创建的状态。&lt;/li&gt;
&lt;li&gt;关于 mark 方法 ，使用mark方法的时候，mark会记录position - 1 的数据大小。当再次使用reset的时候，position将不会还原，会回到mark的值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;几个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;public Buffer flip() {
        limit = position;
        position = 0;
        mark = -1;
        return this;
}
                ······
public Buffer clear() {
        position = 0;
        limit = capacity;
        mark = -1;
        return this;
}
                ······
public Buffer rewind() {
        position = 0;
        mark = -1;
        return this;
}
        ······
public final Buffer mark() {
        mark = position;
        return this;
}
                ······
public Buffer reset() {
        int m = mark;
        if (m &amp;lt; 0)
            throw new InvalidMarkException();
        position = m;
        return this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;flip方法&lt;/h3&gt;
&lt;p&gt;反转buffer，反转缓冲区。首先将限制设置为当前位置，然后将位置设置为 0。通常情况下，在从写入状态转向读取状态的时候调用flip方法。&lt;/p&gt;
&lt;h3&gt;clear、compact方法&lt;/h3&gt;
&lt;p&gt;清除方法，清除整个缓冲区，相当于是再次初始化。和这个类似的还有一个compact方法。clear的作用是将全部缓冲区域清除，如果缓冲区中的数据全部使用结束，那么使用clear是没有问题的。&lt;/p&gt;
&lt;p&gt;如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么就使用compact()方法。compact()方法将所有未读的数据拷贝搬移Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。也就是将没有使用过的数据搬移到初始端，然后，在原先数据的后面接着写入新的数据。&lt;/p&gt;
&lt;h3&gt;rewind 方法&lt;/h3&gt;
&lt;p&gt;无论是在读还是写的模式下，都从头开始。如果是读的模式，使用这个方法，写入新的数据将会覆盖原来数据的。如果是读取的话，将会重复的将原先读过的数据在读一遍。&lt;/p&gt;
&lt;p&gt;如将channel中的注释打开，那么执行的结果就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;length = 12
Hello World!Hello World!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就体现了在读取的时候rewind的作用。&lt;/p&gt;
&lt;h3&gt;mark()与reset()方法&lt;/h3&gt;
&lt;p&gt;通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。&lt;/p&gt;
&lt;p&gt;例如，先mark一下，然后经过读或者是写，之后，使用reset可以将position返回到使用mark的时候的那个mark值。但是flip、clear、compact、rewind、reset都会将mark标记回归负一，也就是取消掉。在使用reset的时候，必须要有一个mark，否则会exception。&lt;/p&gt;
&lt;h2&gt;buffer的使用&lt;/h2&gt;
&lt;h3&gt;创建&lt;/h3&gt;
&lt;p&gt;使用Buffer抽象类的实现类的静态方法来创建，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//创建一个对应的Buffer的对象，其最大容量为128。
XXXBuffer xxxBuffer = XXXBuffer.allocate(128);
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3&gt;写数据&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;从channel中：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;int readLength = inChannel.read(xxxBuffer); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用channel的read方法，将channel中的数据传入xxxBuffer中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用put方法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;xxxBuffer.put(new byte[]{' ', 'x', ' ', 'z', ' ', 'j', ' ', '!'});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用buffer对象的put方法，将put方法的参数，传入的到buffer中。这个参数可以是这个buffer的类型的值、数组。还可以是另一个同类型的buffer，这个参数的本质也是一个数组。&lt;/p&gt;
&lt;h3&gt;读取数据&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;从Buffer读取数据到Channel：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;int writeLength = inChannel.write(xxxBuffer); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用get方法获取buffer中的数据：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;xxxBuffer.get();                   //获取的是一个xxx类型的数据
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;p&gt;可以使用equare 和 compareTo来比较两个buffer。&lt;/p&gt;

&lt;p&gt;使用多个buffer，对应一个channel。&lt;/p&gt;
&lt;h3&gt;scatter&lt;/h3&gt;
&lt;p&gt;使用buffer的数组从channel中获取信息的时候，将会按照数组中buffer的顺序，将channel中的信息，保存在buffer中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;package com.xzj;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

//   @ author :zjxu     time:2019/1/8
public class Main {
    final static String PATH = &quot;/Users/thisxzj/IDEAProject/Revise/NIO/src/index.txt&quot;;

    public static void main(String[] args) throws IOException {
        RandomAccessFile file = new RandomAccessFile(PATH, &quot;rw&quot;);
        FileChannel fileChannel = file.getChannel();
        ByteBuffer byteBuffer1 = ByteBuffer.allocate(10);
        ByteBuffer byteBuffer2 = ByteBuffer.allocate(100);
        ByteBuffer[] byteBuffer = new ByteBuffer[]{byteBuffer1, byteBuffer2};
        long length = fileChannel.read(byteBuffer);

        if (length != -1) {
            System.out.println(&quot;length = &quot; + length);
            byteBuffer2.flip();          //反转buffer
            while (byteBuffer2.hasRemaining()) {
                System.out.print((char) byteBuffer2.get() );
            }
            byteBuffer2.clear();
        }
        fileChannel.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index.txt中保存的文本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello World!Hello World!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;length = 24
d!Hello World!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，第一个长度为10的数组中，保存了前面十个字符。后面长度为100的保存了后面的十四位。在移动下一个buffer前，必须填满当前的buffer。&lt;/p&gt;
&lt;h3&gt;gather&lt;/h3&gt;
&lt;p&gt;同样的，channel在获取数字的时候，可以有这样的数组的机制。但是需要注意的是，只有position和limit之间的数字会被填充进去。所以和前面的一样，需要使用filp更改来将数据刷新进去。在满的时候，或者是将队尾的空格输入进去的时候，使用rewind。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;package com.xzj;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

//   @ author :zjxu     time:2019/1/8
public class Main {
    final static String PATH = &quot;/Users/thisxzj/IDEAProject/Revise/NIO/src/index.txt&quot;;

    public static void main(String[] args) throws IOException {
        RandomAccessFile file = new RandomAccessFile(PATH, &quot;rw&quot;);
        FileChannel fileChannel = file.getChannel();
        ByteBuffer byteBuffer1 = ByteBuffer.allocate(10);
        ByteBuffer byteBuffer2 = ByteBuffer.allocate(10);

        byteBuffer1.put(&quot;0123456789&quot;.getBytes());
        byteBuffer1.rewind();
        byteBuffer2.put(&quot;ABCDEFGHIJ&quot;.getBytes());
        byteBuffer2.rewind();

        ByteBuffer[] byteBuffer = new ByteBuffer[]{byteBuffer1, byteBuffer2};

        long length = fileChannel.write(byteBuffer);
        System.out.println(length);
        fileChannel.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index.txt中的文本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;0123456789ABCDEFGHIJ
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;20
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;transferFrom&lt;/h2&gt;
&lt;p&gt;将from中文本信息复制到to中，如果to中文本信息长度比from长，多余的一部分保留。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;package com.xzj;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;

//   @ author :zjxu     time:2019/1/8
public class Main {
    final static String FROM = &quot;/Users/thisxzj/IDEAProject/Revise/NIO/src/fromIndex.txt&quot;;
    final static String TO = &quot;/Users/thisxzj/IDEAProject/Revise/NIO/src/toIndex.txt&quot;;

    public static void main(String[] args) throws IOException {
        RandomAccessFile fromFile = new RandomAccessFile(FROM, &quot;rw&quot;);
        RandomAccessFile toFile = new RandomAccessFile(TO, &quot;rw&quot;);
        FileChannel fromChannel = fromFile.getChannel();
        FileChannel toChannel = toFile.getChannel();

        long position = 0;
        long count = fromChannel.size();

        toChannel.transferFrom(fromChannel, position, count);
        fromChannel.close();
        toChannel.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fromIndex：abcdbfghijkrmnopqrstuvwxyz
toIndex：1234567890123456789012345678901234567890

运行之后，from中文本不变，to中的文本变化如下：
toIndex：abcdbfghijkrmnopqrstuvwxyz78901234567890
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;transferTo&lt;/h2&gt;
&lt;p&gt;将上面的程序的第21行改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;       fromChannel.transferTo(position, count, toChannel);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其余的逻辑，方法都不变。&lt;/p&gt;


&lt;p&gt;和selector配套使用的是selectable接口的实现类，通常是网络接口。所以，NIO是和网络紧密相关的一个IO机制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有关UDP协议的：DatagramChannel。&lt;/li&gt;
&lt;li&gt;有关SCTP协议的：SctpChannel、SctpMultiChannel、SctpServerChannel。&lt;/li&gt;
&lt;li&gt;有关TCP协议的：ServerSocketChannel、SocketChannel。&lt;/li&gt;
&lt;li&gt;有关管道的：SinkChannel、SourceChannel这两个抽象类定义在java.nio.channels.Pipe类中。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;Socket和ServerSocket是位于java.net下的两个类。&lt;/li&gt;
&lt;li&gt;SocketChannel和ServerSocketChannel是位于java.nio.channels下的两个类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;连接关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务器必须先建立ServerSocket或者ServerSocketChannel 来等待客户端的连接。&lt;/li&gt;
&lt;li&gt;客户端必须建立相对应的Socket或者SocketChannel来与服务器建立连接。&lt;/li&gt;
&lt;li&gt;服务器接受到客户端的连接，再生成一个Socket或者SocketChannel与此客户端通信。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;SocketChannel&lt;/h2&gt;
&lt;h4&gt;打开方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//客户端
SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 8000));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;连接方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//客户端
socketChannel.configureBlocking(false);  //非阻塞模式
socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 8000));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;写入方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//客户端
ByteBuffer writeBuffer = ByteBuffer.allocate(64);
writeBuffer.clear();
writeBuffer.put((new Date().toString()).getBytes());
writeBuffer = writeBuffer.flip();
socketChannel.write(writeBuffer);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;读取方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//客户端
readBuff.clear();
int length = socketChannel.read(readBuff);
readBuff.flip();
System.out.println(&quot;received: &quot; +
              new String(readBuff.array()).substring(0, length));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;关闭方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//客户端
socketChannel.close();
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;ServerSocketChannel&lt;/h2&gt;
&lt;h4&gt;打开方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//服务端
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
ssc.socket().bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 8000));
ssc.configureBlocking(false);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;连接方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//服务端
ssc.configureBlocking(false);                           //非阻塞模式
ssc.socket().bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 8000));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;监听连接&lt;/h4&gt;
&lt;p&gt;通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。&lt;/p&gt;
&lt;p&gt;通常不会仅仅只监听一个连接,在while循环中调用 accept()方法。如下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;while(true){
    SocketChannel socketChannel = serverSocketChannel.accept();
    //do something with socketChannel...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然,也可以在while循环中使用除了true以外的其它退出准则。&lt;/p&gt;
&lt;h4&gt;读取方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//使用一个新建的Socket连接，在这个连接上使用read和write
readBuff.clear();
int length = socketChannel.read(readBuff);
readBuff.flip();
System.out.println(&quot;received: &quot; +
              new String(readBuff.array()).substring(0, length));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;关闭方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//服务端
serverSocketChannel.close();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;TCP的使用示例&lt;/h2&gt;
&lt;h4&gt;WebServer&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;package com.xzj;

//   @ author :zjxu     time:2019/1/9

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class WebServer {
    public static void main(String[] args) throws IOException {

        //创建一个channel并且设定为非阻塞模式
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.socket().bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 8000));
        serverSocketChannel.configureBlocking(false);

        //创建selector
        Selector selector = Selector.open();

        //将channel和selector关联起来，并且指定感兴趣的事件是 Accept
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        //创建读写buffer
        ByteBuffer readBuff = ByteBuffer.allocate(1024);
        ByteBuffer writeBuff = ByteBuffer.allocate(128);

        writeBuff.put(&quot;enter:&quot;.getBytes());
        writeBuff.flip();

        while (true) {
            int nReady = selector.select();
            Set&amp;lt;SelectionKey&amp;gt; keys = selector.selectedKeys();
            Iterator&amp;lt;SelectionKey&amp;gt; it = keys.iterator();

            while (it.hasNext()) {
               //轮询
                SelectionKey key = it.next();
                it.remove();

                if (key.isAcceptable()) {
                    // 创建新的连接，并且把连接注册到selector上，而且
                    // 声明这个channel只对读操作感兴趣
                    SocketChannel socketChannel = serverSocketChannel.accept();
                    socketChannel.configureBlocking(false);
                    socketChannel.register(selector, SelectionKey.OP_READ);

                } else if (key.isReadable()) {
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    readBuff.clear();
                    int length = socketChannel.read(readBuff);

                    readBuff.flip();
                    System.out.println(&quot;received: &quot; + new String(readBuff.array()).substring(0, length-1));
                    key.interestOps(SelectionKey.OP_WRITE);
                } else if (key.isWritable()) {
                    writeBuff.rewind();
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    socketChannel.write(writeBuff);
                    key.interestOps(SelectionKey.OP_READ);
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;WebClient&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;package com.xzj;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.Date;

//   @ author :zjxu     time:2019/1/9
public class WebClient {
    public static void main(String[] args) throws IOException {
        try {
            SocketChannel socketChannel = SocketChannel.open();
            socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 8000));

                //创建读写buffer
            ByteBuffer writeBuffer = ByteBuffer.allocate(64);
            ByteBuffer readBuffer = ByteBuffer.allocate(32);

            while (true) {
                writeBuffer.clear();
                writeBuffer.put((new Date().toString()).getBytes());
                writeBuffer.flip();
                socketChannel.write(writeBuffer);
                readBuffer.clear();
                socketChannel.read(readBuffer);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;DatagramChannel&lt;/h2&gt;
&lt;h4&gt;打开方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;DatagramChannel channel = DatagramChannel.open();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;连接方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;channel.socket().bind(new InetSocketAddress(8000));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;收发方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;ByteBuffer sendBuffer = ByteBuffer.allocate(64);
ByteBuffer receiveBuffer = ByteBuffer.allocate(64);

//接收方法
receiveBuffer.clear();
channel.receive(receiveBuffer);

String string =
        new SimpleDateFormat(&quot;yyyyMMdd HH:mm:ss&quot;).format(new Date());
//发送方法
sendBuffer.clear();
sendBuffer.put(string.getBytes());
sendBuffer.flip();
channel.send(sendBuffer,new InetSocketAddress(8001));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以将DatagramChannel“连接”到网络中的特定地址的。由于UDP是无连接的，连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ，让其只能从特定地址收发数据。&lt;/p&gt;
&lt;p&gt;这里有个例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;`channel.connect(``new` `InetSocketAddress(``&quot;jenkov.com&quot;``, ``80``));`
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当连接后，也可以使用read()和write()方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;int bytesRead = channel.read(buf);
int bytesWrite = channel.write(buf);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;UDP的使用示例&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;package com.xzj;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Date;
import java.util.Iterator;
import java.util.Scanner;

//   @ author :zjxu     time:2019/1/9
public class DatagramTest {
    public void send() throws IOException {
        DatagramChannel dChannel = DatagramChannel.open();
        dChannel.configureBlocking(false);
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String string = scanner.next();
            buffer.put((new Date().toString()+&quot;&amp;gt;&amp;gt;&quot;+string).getBytes());
            buffer.flip();
            dChannel.send(buffer, new InetSocketAddress(&quot;127.0.0.1&quot;, 8989));
            buffer.clear();

        }
        dChannel.close();
    }
    public void receive() throws IOException {
        DatagramChannel datagramChannel = DatagramChannel.open();
        datagramChannel.configureBlocking(false);
        datagramChannel.bind(new InetSocketAddress(8989));
        Selector selector = Selector.open();
        datagramChannel.register(selector, SelectionKey.OP_READ);
        while(selector.select()&amp;gt;0){
            Iterator&amp;lt;SelectionKey&amp;gt; iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                SelectionKey selectionKey = (SelectionKey) iterator.next();
                if (selectionKey.isReadable()) {
                    ByteBuffer buffer = ByteBuffer.allocate(1024);
                    datagramChannel.receive(buffer);
                    buffer.flip();
                    System.out.println(new String(buffer.array(),0,buffer.limit()));
                    buffer.clear();
                }
            }
            iterator.remove();
        }


    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Pipe&lt;/h2&gt;
&lt;p&gt;JavaNIO中的pipe是两个&lt;strong&gt;线程之间&lt;/strong&gt;的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。&lt;/p&gt;
&lt;h3&gt;创建管道&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;Pipe pipe = Pipe.open();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;写入&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;SinkChannel sinkChannel = pipe.sink();
ByteBuffer byteBuffer = ByteBuffer.allocate(64);

String string =
        new SimpleDateFormat(&quot;yyyyMMdd HH:mm:ss&quot;).format(new Date());

byteBuffer.clear();
byteBuffer.put(string.getBytes());
byteBuffer.flip();

sinkChannel.write(byteBuffer);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;读取&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;SourceChannel sourceChannel = pipe.source();
ByteBuffer readBuffer = ByteBuffer.allocate(64);

readBuffer.clear();
int length = sourceChannel.read(readBuffer);
System.out.println(new String(readBuffer.array()).substring(0, length - 1));
sourceChannel.close();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Pipe使用示例&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;package com.xzj;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.Pipe;
import java.nio.channels.Pipe.SinkChannel;
import java.nio.channels.Pipe.SourceChannel;
import java.text.SimpleDateFormat;
import java.util.Date;


//   @ author :zjxu     time:2019/1/9
public class Test {
    public static void main(String[] args) throws IOException {
        Pipe pipe = Pipe.open();
        SinkChannel sinkChannel = pipe.sink();
        ByteBuffer writeBuffer = ByteBuffer.allocate(64);

        String string =
                new SimpleDateFormat(&quot;yyyyMMdd HH:mm:ss&quot;).format(new Date()) + &quot;\n&quot;;

        writeBuffer.clear();
        writeBuffer.put(string.getBytes());
        writeBuffer.flip();

        sinkChannel.write(writeBuffer);
        sinkChannel.close();

        SourceChannel sourceChannel = pipe.source();
        ByteBuffer readBuffer = ByteBuffer.allocate(64);

        readBuffer.clear();
        int length = sourceChannel.read(readBuffer);
        System.out.println(new String(readBuffer.array()).substring(0, length - 1));
        sourceChannel.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;20190109 12:34:14
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;使用scelector的好处是，只需要更少的线程来维护通道。，可以使用以恶搞线程处理所有的通道。&lt;/p&gt;
&lt;h3&gt;创建方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;Selector selector = Selector.open();
 //selector.isOpen();判断是否打开
 //selector.close();关闭
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;注册通道&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;channel.configureBlocking(false);
SelectionKey readKey = channel.register(selector,SelectionKey.OP_READ);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个参数，表示监听的动作：&lt;/p&gt;
&lt;p&gt;有四个类型：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;事件&lt;/th&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;key常量&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;连接就绪&lt;/td&gt;
&lt;td&gt;Connect&lt;/td&gt;
&lt;td&gt;SelectionKey.OP_CONNECT&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;接收就绪&lt;/td&gt;
&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;SelectionKey.OP_ACCEPT&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;读就绪&lt;/td&gt;
&lt;td&gt;Read&lt;/td&gt;
&lt;td&gt;SelectionKey.OP_READ&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;写就绪&lt;/td&gt;
&lt;td&gt;Write&lt;/td&gt;
&lt;td&gt;SelectionKey.OP_WRITE&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;Key&lt;/h3&gt;
&lt;p&gt;使用key常量将selector和channel中的动作关联起来，并返回一个SelectionKey对象。只要是channel向selector中注册了事件，selector就会跟踪检测这个事件是否发生。这些的key对象就是检测这些事件的句柄。&lt;/p&gt;
&lt;h4&gt;获取keys&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;//所有注册到selector的key
Set&amp;lt;SelectionKey&amp;gt; keys = selector.keys();
//相关事件被捕获的key
Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果关闭了与SelectionKey对象关联的Channel对象，或者调用了SelectionKey对象的cancel方法，这个SelectionKey对象就会被加入到cancelled-keys集合中，表示这个SelectionKey对象已经被取消。&lt;/p&gt;
&lt;p&gt;cancelled-keys没有对应的方法被获取。&lt;/p&gt;
&lt;h4&gt;interest集合&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;int interestSet = key.interestOps();
boolean isInterestedInAccept = (interestSet &amp;amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = (interestSet &amp;amp; SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT;
boolean isInterestedInRead = (interestSet &amp;amp; SelectionKey.OP_READ) == SelectionKey.OP_READ;
boolean isInterestedInWrite = (interestSet &amp;amp; SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用来检测对那些事件感兴趣。其中：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作类型&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;OP_READ&lt;/td&gt;
&lt;td&gt;1 &amp;lt;&amp;lt; 0&lt;/td&gt;
&lt;td&gt;读操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OP_WRITE&lt;/td&gt;
&lt;td&gt;1 &amp;lt;&amp;lt; 2&lt;/td&gt;
&lt;td&gt;写操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OP_CONNECT&lt;/td&gt;
&lt;td&gt;1 &amp;lt;&amp;lt; 3&lt;/td&gt;
&lt;td&gt;连接socket操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OP_ACCEPT&lt;/td&gt;
&lt;td&gt;1 &amp;lt;&amp;lt; 4&lt;/td&gt;
&lt;td&gt;接受socket操作&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用interestOps();方法获取的是一个多位二进制数，通过逻辑操作，可以判断是不是在key上有对应的操作。&lt;/p&gt;
&lt;h4&gt;ready集合&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;int readySet = key.readyOps();
boolean isAcceptable = (readySet &amp;amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;
boolean isConnectable = (readySet &amp;amp; SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT;
boolean isReadable = (readySet  &amp;amp; SelectionKey.OP_READ) == SelectionKey.OP_READ;
boolean isWritable =  (readySet &amp;amp; SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和上面的获取机制一模一样。此外还可以使用直接获取的方式，获取ready状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;key.isAcceptable();
key.isConnectable();
key.isReadable();
key.isWritable();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;附加对象&lt;/h4&gt;
&lt;p&gt;通过key生成的channel和seletor：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;Channel keyChannel = key.channel();
Selector keySelector = key.selector();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将一个对象添加到key上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;StringBuilder stringBuilder = new StringBuilder(&quot;xzj&quot;);
//添加上去
key.attach(stringBuilder);
//从key获取
StringBuilder getter = (StringBuilder) key.attachment();
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;select()&lt;/h2&gt;
&lt;p&gt;向一个selector中注册多个channel之后，可以使用selector的select方法，该方法的返回值是一个int型，表示的是通道就绪的数量。使用的select()方法是阻塞等待至少一个通道准备就绪，其中可以向其中添加一个最长等待时间，也可以使用selectNow()来表示立即返回。&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;selector.select();
selector.select(1000);
selector.selectNow();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;遍历&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot; lang=&quot;java&quot;&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();
Iterator selectedKeysIterator = selectedKeys.iterator();

while (selectedKeysIterator.hasNext()) {
    SelectionKey key = (SelectionKey) selectedKeysIterator.next();
    if (key.isAcceptable()) {      // a connection was accepted by a ServerSocketChannel

    } else if (key.isConnectable()) {     // a connection was established with a remote server

    } else if (key.isReadable()) {        // a channel is ready for reading

    } else if (key.isWritable()) {        // a channel is ready for writing

    }

    //将刚刚访问过的元素删除
    selectedKeysIterator.remove();
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;weakUp方法&lt;/h2&gt;
&lt;p&gt;在某一个线程在使用select()方法被阻塞，而无法返回的时候，在同一个select对象上使用weakUp()方法，会使阻塞的select方法返回。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Feb 2019 07:40:00 +0000</pubDate>
<dc:creator>小徐同学是个coder</dc:creator>
<og:description>同步与阻塞 同步和异步是针对应用程序和内核的交互而言的。 同步：执行一个操作之后，进程触发IO操作并等待(阻塞)或者轮询的去查看IO的操作(非阻塞)是否完成，等待结果，然后才继续执行后续的操作。 异步</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjxu97/p/10426429.html</dc:identifier>
</item>
<item>
<title>SQL优化 MySQL版 -分析explain SQL执行计划与Type级别详解【全干货】 - StanleyBlogs</title>
<link>http://www.cnblogs.com/StanleyBlogs/p/10426385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StanleyBlogs/p/10426385.html</guid>
<description>&lt;p&gt;作者 ： Stanley 罗昊&lt;/p&gt;
&lt;h2&gt;【&lt;strong&gt;转载请注明出处和署名，谢谢！&lt;/strong&gt;】&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：看此文章前，需要有一定的Mysql基础或观看上一篇文章，该文章传送门：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/StanleyBlogs/p/10416865.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;索引类型type&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201902/1545884-20190224151823265-460873894.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以清楚的看到type那一栏有index ALL eq_ref，他们都代表什么意思呢？&lt;/p&gt;
&lt;p&gt;首先类型有许多，这里我只给大家介绍企业里面用的最多的类型：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;system&amp;gt;const&amp;gt;eq_ref&amp;gt;ref&amp;gt;range&amp;gt;inex&amp;gt;ALL&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;越往左边，性能越高&lt;/span&gt;，&lt;strong&gt;&lt;span&gt;比如system就比ALL类型性能要高出许多&lt;/span&gt;&lt;/strong&gt;，其中system、const只是理想类型，基本达不到；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们自己实际能优化到ref&amp;gt;range这两个类型，就是你自己写SQL，如果你没优化基本上就是ALL，如果你优化了，那就尽量达到&lt;strong&gt;&lt;span&gt;ref&amp;gt;range&lt;/span&gt;&lt;/strong&gt;这两个级别；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里我强调一下，左边基本达不到！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以，要对type优化的前提是，&lt;strong&gt;&lt;span&gt;你需要有索引，如果你连索引都没有创建，那你就不用优化了，肯定是ALL.....&lt;/span&gt;&lt;/strong&gt;；&lt;/p&gt;
&lt;h2&gt;Type级别详解&lt;/h2&gt;
&lt;h3&gt;一.system级别&lt;/h3&gt;
&lt;p&gt;索引类型能是system的只有两种情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.只有一条数据的系统表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只有一条数据的系统表，就是系统里自带一张表，并且这个表就一条数据，这个基本上就达不到，这个是系统自带的表，而且就一条数据，所以基本达不到；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.或衍生表只能有一条数据的主查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是可以实现的，但是在实际开发当中，你不可能去写一个这么个玩意儿，不可能公司的业务去让你把SQL索引类型写实system...&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SQL语句:&lt;span&gt;select&lt;/span&gt; * From (&lt;span&gt;select&lt;/span&gt; * From test01) t &lt;span&gt;where&lt;/span&gt; tid = &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面需要加explain&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201902/1545884-20190224090139937-774409413.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是把它凑出来即可；&lt;/p&gt;
&lt;p&gt;我之所以能达到system，是因为我满足了它的第二个条件；&lt;/p&gt;
&lt;h3&gt;二.const级别&lt;/h3&gt;
&lt;p&gt;const条件稍微低一点，&lt;strong&gt;&lt;span&gt;但是基本上也达不到；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.仅仅能查出一条的SQL语句并且用于Primary key 或 unique索引；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个我就不说了把，都知道，所以在企业里根本不可能实现，能查出来一条SQL语句，你的索引还必须是Primary key或unique；&lt;/p&gt;
&lt;p&gt;但是我们可以把它凑出来，我再强调一点，在公司，你们的业务不可能去让你凑type级别！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SQL语句：&lt;span&gt;select&lt;/span&gt; * tid From test01 &lt;span&gt;where&lt;/span&gt; tid = &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面需要加explain&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201902/1545884-20190224091052030-782213229.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;根据tid找，因为tid是我设置的主键，主键就是Primary key，并且只能有一条数据，我表里面本来就一条，所以我满足了；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;三.eq_ref级别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多，不能0）;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解说：比如你select ...from 一张表 where 比方说有一个字段 name = 一个东西，也就是我们以name作为索引，假设我之前给name加了一个索引值，我现在根据name去查，查完后有20条数据，我就必须保证这二十条数据每行都是唯一的，不能重复不能为空！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;只要满足以上条件，你就能达到eq_ref，当然前提是你要给name建索引，如果name连索引都没，那你肯定达不到eq_ref;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此种情况常见于唯一索引和主键索引；&lt;/p&gt;
&lt;p&gt;比如我根据name去查，但是一个公司里面或一个学校里面叫name的可能不止一个，一般你想用这个的时候，就要确保你这个字段是唯一的，id就可以，你可以重复两个张三，但是你身份证肯定不会重复；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;添加唯一键语法：alter table 表名 add constraint 索引名 unique index(列名)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;检查字段是否唯一键：&lt;span&gt;show index form 表名；被展示出来的皆是有唯一约束的；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;以上级别，均是可遇不可求！！！！&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;四 .ref级别&lt;/h3&gt;
&lt;p&gt;到ref还是问题不大的，&lt;strong&gt;&lt;span&gt;只要你上点心，就可以达到&lt;/span&gt;&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;非唯一性索引：对于每个索引键的查询，返回匹配的所有行（可以是0，或多个）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我现在要根据name查询，首先name可能有多个，因为一个公司或学校叫小明的不止一个人，但是你要用name去查，你必须name是索引，我们先给它加个索引，因为要达到ref级别，所以这里我给它加一个&lt;strong&gt;&lt;span&gt;单值索引&lt;/span&gt;&lt;/strong&gt;，关于单值索引的介绍我在前几篇文章讲过：&lt;/p&gt;
&lt;p&gt;传送门：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/StanleyBlogs/p/10416865.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;单值索引语法：&lt;/strong&gt;alter table 表名 索引类型 索引名（字段）&lt;/p&gt;
&lt;p&gt;现在我们根据索引来查数据，这里我假设我写的单值索引；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
alter table student add index index_name (name);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我们再去编写sql语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
alter table student add index index_name (name);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;因为name是索引列，这里假设有两个叫张三的，ref级别规则就是能查出多个或0个，很显然能查出来多个，那这条SQL语句，必然是ref级别！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201902/1545884-20190224142555721-2088313894.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201902/1545884-20190224142653429-1617380224.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;五.range级别&lt;/h3&gt;
&lt;p&gt;检索指定范围的行，查找一个范围内的数据，where后面是一个范围查询 （between,in,&amp;gt; &amp;lt; &amp;gt;=);&lt;/p&gt;
&lt;p&gt;注：in 有时会失效，导致为ALL；&lt;/p&gt;
&lt;p&gt;现在我们写一个查询语句，前提是，tid一定是一个索引列，如果是id的话，就用主键索引，也就是唯一索引，值不可以重复，这个时候我们范围查询的时候要用它来做条件：&lt;/p&gt;
&lt;p&gt; EXPLAIN SELECT t.* FROM student t WHERE t.tid BETWEEN 1 AND 2; ;//查询tid是1到2；&lt;/p&gt;
&lt;p&gt;查看执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201902/1545884-20190224145658802-1272499849.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我表示，我在这试了好几次都是index级别，我也不知道为什么，我即便满足条件仍是index级别，可能是数据库版本？如果你知道的话，请务必在下发留言与我交流！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;六.index级别&lt;/h3&gt;
&lt;p&gt;查询全部索引中的数据&lt;/p&gt;
&lt;p&gt;讲解：假设我有一张表，里面有id name age，这个时候name是一个单值索引，一旦name被设定成索引，&lt;strong&gt;&lt;span&gt;它就会成为B树一样，经过各种算法将name里面的值像树一样进行分类，这个时候我where name = **，就相当于把这颗B树查了一个遍，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;也就是说，你把name这一列给查了一遍；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL语句：select id From student;//&lt;span&gt;我只查被索引声明的列，必然就是index了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201902/1545884-20190224150915301-791088739.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;七.ALL级别&lt;/h3&gt;
&lt;p&gt;查询全部表数据，就是select name From student;&lt;/p&gt;
&lt;p&gt;其中 name 不是索引；&lt;/p&gt;
&lt;p&gt;如果你查的这一列不是索引，就会导致全表扫描，&lt;strong&gt;&lt;span&gt;所以要避免全表扫描&lt;/span&gt;&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201902/1545884-20190224151322007-1429823933.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;今日感悟：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;靠自己得到的，是荣誉，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   乞求父母得到的，是虚荣&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Feb 2019 07:33:00 +0000</pubDate>
<dc:creator>StanleyBlogs</dc:creator>
<og:description>type索引类型、类型 作者 ： Stanley 罗昊 【转载请注明出处和署名，谢谢！】 注：看此文章前，需要有一定的Mysql基础或观看上一篇文章，该文章传送门： 索引类型type 我们可以清楚的看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StanleyBlogs/p/10426385.html</dc:identifier>
</item>
<item>
<title>python之类的继承及方法讲解分析 - Teacher涛</title>
<link>http://www.cnblogs.com/Teachertao/p/10426386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Teachertao/p/10426386.html</guid>
<description>&lt;pre readability=&quot;206&quot;&gt;
#!/usr/bin/env python&lt;br/&gt;#-*- conding:utf-8 -*-&lt;p&gt;# class Person(object):&lt;br/&gt;#     def __init__(self,name,age):&lt;br/&gt;#         self.name = name&lt;br/&gt;#         self.age = age&lt;br/&gt;#&lt;br/&gt;#     def getName(self):&lt;br/&gt;#         return self.name&lt;br/&gt;#&lt;br/&gt;#     def getAge(self):&lt;br/&gt;#         return self.age&lt;br/&gt;#&lt;br/&gt;#     def setName(self, name):&lt;br/&gt;#         self.name=name&lt;br/&gt;#&lt;br/&gt;#     def setAge(self,age):&lt;br/&gt;#         self.age=age&lt;br/&gt;#&lt;br/&gt;#     def info(self):&lt;br/&gt;#          return &quot;name{0},age{1}&quot;.format(self.name,self.age)&lt;br/&gt;# per = Person(&quot;Teacher&quot;,24)&lt;br/&gt;# per.info()&lt;br/&gt;# print(per.info())&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;首先一个类，不管是否写了构造函数，它都是有构造函数的&lt;br/&gt;一个类，可以有多个构造函数,建议一个类只有一个构造函数&lt;br/&gt;构造函数&lt;br/&gt;1.初始化属性&lt;br/&gt;&quot;&quot;&quot;&lt;br/&gt;# class Person1(object):&lt;br/&gt;# #动态方法&lt;br/&gt;#     def __init__(self,*args,**kwargs):&lt;br/&gt;#         self.args = args&lt;br/&gt;#         self.kwargs = kwargs&lt;br/&gt;#&lt;br/&gt;#     def info(self):&lt;br/&gt;#         # print(&quot;信息:&quot;,self.kwargs)&lt;br/&gt;#         print(&quot;信息:&quot;,self.args)&lt;br/&gt;#&lt;br/&gt;# per1 = Person1(name=&quot;Teacher&quot;,age=24)&lt;br/&gt;# per1 = Person1(&quot;Teacher&quot;,26)&lt;br/&gt;# per1.info()&lt;br/&gt;# per1.info()&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;析构函数&lt;br/&gt;对象实例化--&amp;gt;构造函数--&amp;gt;对象调用方法--&amp;gt;代码跳转到具体的方法&lt;br/&gt;--&amp;gt;执行方法的代码块--&amp;gt;最后执行析构函数&lt;br/&gt;&quot;&quot;&quot;&lt;br/&gt;# class Person(object):&lt;br/&gt;#     def __init__(self):&lt;br/&gt;#         print(&quot;我是构造方法&quot;)&lt;br/&gt;#&lt;br/&gt;#     def __del__(self):&lt;br/&gt;#         print(&quot;我是析构方法&quot;)&lt;br/&gt;#&lt;br/&gt;#     def info(self):&lt;br/&gt;#         print(&quot;我是方法&quot;)&lt;br/&gt;#&lt;br/&gt;# per = Person()&lt;br/&gt;# per.info()&lt;br/&gt;#&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;普通方法&lt;br/&gt;&quot;&quot;&quot;&lt;br/&gt;# class Person2(object):&lt;br/&gt;#     def conn(self,user,passwd,host,port):&lt;br/&gt;#         pass&lt;br/&gt;#&lt;br/&gt;#     def f1(self,*args,**kwargs):&lt;br/&gt;#         # self.kwargs = kwargs&lt;br/&gt;#         # self.args = args&lt;br/&gt;#         pass&lt;br/&gt;#&lt;br/&gt;#     def info(self):&lt;br/&gt;#         print(&quot;我是普通方法&quot;)&lt;br/&gt;#&lt;br/&gt;# per = Person2()&lt;br/&gt;# per.conn(&quot;root&quot;,123456,&quot;localhost&quot;,3306)&lt;br/&gt;# per.info()&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;特性方法：不能有形式参数&lt;br/&gt;&quot;&quot;&quot;&lt;br/&gt;# class Person(object):&lt;br/&gt;#&lt;br/&gt;#     @property #装饰器&lt;br/&gt;#     def getUserID(self):&lt;br/&gt;#         pass&lt;br/&gt;#&lt;br/&gt;# per = Person()&lt;br/&gt;# per.getUserID   #不加(),加()报错&lt;/p&gt;&lt;p&gt;# from selenium import webdriver&lt;br/&gt;# driver = webdriver.Firefox()&lt;br/&gt;# driver.find_element_by_id(&quot;kw&quot;).text&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;静态方法:&lt;br/&gt;可以直接使用类名来调用方法，属于类&lt;br/&gt;实例对象也可以调用方法，但不建议使用，多此一举！&lt;br/&gt;&quot;&quot;&quot;&lt;br/&gt;# class MySQL(object):&lt;br/&gt;#     @staticmethod&lt;br/&gt;#     # 方法参数不用加self&lt;br/&gt;#     def conn(user):&lt;br/&gt;#         pass&lt;br/&gt;#&lt;br/&gt;# # MySQL.conn(&quot;Teacher&quot;)&lt;br/&gt;# sql = MySQL()&lt;br/&gt;# sql.conn(&quot;Teacher&quot;)&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;类的方法：直接使用类名来调用&lt;br/&gt;&quot;&quot;&quot;&lt;br/&gt;# class MySQL(object):&lt;br/&gt;#     @classmethod&lt;br/&gt;#     # 方法参数不用加self&lt;br/&gt;#     def conn(cls):&lt;br/&gt;#         pass&lt;br/&gt;#&lt;br/&gt;# # MySQL.conn(&quot;Teacher&quot;)&lt;br/&gt;# MySQL.conn()&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;属于类：&lt;br/&gt;类属性&lt;br/&gt;静态方法&lt;br/&gt;类方法&lt;br/&gt;属于对象：&lt;br/&gt;实例属性&lt;br/&gt;普通方法&lt;br/&gt;特性方法&lt;br/&gt;&quot;&quot;&quot;&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;类的继承：重复使用已经存在的数据和行为，减少重复编写代码，&lt;br/&gt;子类继承父类的实例属性和方法&lt;br/&gt;&quot;&quot;&quot;&lt;br/&gt;&quot;&quot;&quot;类属性的继承&quot;&quot;&quot;&lt;br/&gt;# class Person(object):&lt;br/&gt;#     China = &quot;中国&quot;&lt;br/&gt;# class UsaPerson(Person):&lt;br/&gt;#     pass&lt;br/&gt;# Usa = UsaPerson()&lt;br/&gt;# Usa.China&lt;br/&gt;# print(Usa.China)&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;实例属性的继承与继承的两种写法&quot;&quot;&quot;&lt;br/&gt;# class Fruit(object):&lt;br/&gt;#     def __init__(self,name):&lt;br/&gt;#         self.name = name&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;子类由于业务的需求，需要继承父类的实例属性&quot;&quot;&quot;&lt;/p&gt;&lt;p&gt;# class Apple(Fruit):&lt;br/&gt;#     def __init__(self,name,brand,color):&lt;br/&gt;# #        super(Apple,self).__init__(name)&lt;br/&gt;#         Fruit.__init__(self,name)&lt;br/&gt;#         self.brand = brand&lt;br/&gt;#         self.color = color&lt;br/&gt;#&lt;br/&gt;#     def info(self):&lt;br/&gt;#         return &quot;名称{0},品牌{1},颜色{2}&quot;.format(self.name,self.brand,self.color)&lt;br/&gt;#&lt;br/&gt;# app = Apple(&quot;苹果&quot;,&quot;富士&quot;,&quot;红色&quot;)&lt;br/&gt;# app.info()&lt;br/&gt;# print(app.info())&lt;/p&gt;&lt;p&gt;# class Fruit(object):&lt;br/&gt;#     def __init__(self,name):&lt;br/&gt;#         self.name = name&lt;br/&gt;&quot;&quot;&quot;子类由于业务的需求，不需要继承父类的实例属性&quot;&quot;&quot;&lt;/p&gt;&lt;p&gt;# class Apple(Fruit):&lt;br/&gt;#     def __init__(self,brand,color):&lt;br/&gt;#         self.brand = brand&lt;br/&gt;#         self.color = color&lt;br/&gt;#&lt;br/&gt;#     def info(self):&lt;br/&gt;#         return &quot;品牌{0},颜色{1}&quot;.format(self.brand,self.color)&lt;br/&gt;#&lt;br/&gt;# app = Apple(&quot;富士#&quot;,&quot;红色&quot;)&lt;br/&gt;# app.info()&lt;br/&gt;# print(app.info())&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;格式化字符&quot;&quot;&quot;&lt;br/&gt;#&quot;{a} Love {b}.{0}&quot;.format(a = &quot;I&quot;,b = &quot;You&quot;,&quot;com&quot;)&lt;br/&gt;&quot;{0} Love {a}.{b}&quot;.format(&quot;I&quot;,a = &quot;You&quot;,b = &quot;com&quot;)&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;方法的继承：&lt;br/&gt;子类为什么要重写父类的方法？子类有自己的特性&lt;br/&gt;当子类重写了父类的方法，对子类进行实例化对象后，&lt;br/&gt;子类调用的(父类，子类方法都存在)方法，执行的方法是子类的方法&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;# class Person(object):&lt;br/&gt;#     def eat(self):&lt;br/&gt;#         print(&quot;人需要吃饭的&quot;)&lt;br/&gt;#&lt;br/&gt;# class Son(Person):&lt;br/&gt;#     def __init__(self,name):&lt;br/&gt;#         self.name = name&lt;br/&gt;#&lt;br/&gt;#     def eat(self):&lt;br/&gt;#         print(&quot;名字是{0},为什么？&quot;.format(self.name))&lt;br/&gt;#&lt;br/&gt;# son = Son(&quot;Teacher&quot;)&lt;br/&gt;# son.eat()&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;单个类继承的原则：&lt;br/&gt;1.从上到下，子类继承父类，但没有重写父类的方法，&lt;br/&gt;对子类进行实例化对象后，执行调用是直接父类中的方法&lt;br/&gt;2.从下到上，子类继承父类，但子类重写父类的方法，&lt;br/&gt;对子类进行实例化对象后，执行调用是直接子类中的方法(优先调用自己方法)&lt;br/&gt;&quot;&quot;&quot;&lt;/p&gt;&lt;p&gt;# class Fruit(object):&lt;br/&gt;#     def eat(self):&lt;br/&gt;#         print(&quot;水果是用来吃的&quot;)&lt;br/&gt;#&lt;br/&gt;# class Apple(Fruit):&lt;br/&gt;#     def __init__(self,color):&lt;br/&gt;#         self.color = color&lt;br/&gt;#&lt;br/&gt;#     def eat(self):&lt;br/&gt;#         print(&quot;苹果的颜色{0},该吃掉了！&quot;.format(self.color))&lt;br/&gt;#&lt;br/&gt;# class Band(Apple):&lt;br/&gt;#     def eat(self):&lt;br/&gt;#         print(&quot;我是Apple的子类&quot;)&lt;br/&gt;#&lt;br/&gt;# band = Band(&quot;红色&quot;)&lt;br/&gt;# band.eat()&lt;/p&gt;&lt;p&gt;# class Person(object):&lt;br/&gt;#     def __init__(self,name):&lt;br/&gt;#         self.name=name&lt;br/&gt;#&lt;br/&gt;#     def info(self):&lt;br/&gt;#         print (self.name)&lt;br/&gt;#&lt;br/&gt;# class Son(Person):&lt;br/&gt;#     def info(self):&lt;br/&gt;#         print (self.name)&lt;br/&gt;#&lt;br/&gt;# s=Son('name')&lt;br/&gt;# s.info()&lt;br/&gt;#&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;多个继承：执行的顺序，从左到右执行;并且是同一级别的！同一级别指的是共同的类&quot;&quot;&quot;&lt;/p&gt;&lt;p&gt;# class Person(object):&lt;br/&gt;#     def eat(self):&lt;br/&gt;#         print(&quot;人是吃饭的&quot;)&lt;br/&gt;#&lt;br/&gt;# class Monther(Person):&lt;br/&gt;# #   def eat(self):&lt;br/&gt;# #        print(&quot;妈妈不吃饭，要减肥&quot;)&lt;br/&gt;#         pass&lt;br/&gt;#&lt;br/&gt;# class Father(Person):&lt;br/&gt;#     def eat(self):&lt;br/&gt;#         print(&quot;爸爸吃饭！&quot;)&lt;br/&gt;#&lt;br/&gt;# class Son(Monther,Father):&lt;br/&gt;#     pass&lt;br/&gt;#&lt;br/&gt;# son = Son()&lt;br/&gt;# son.eat()&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;__doc__ 打印出类的注释&quot;&quot;&quot;&lt;/p&gt;&lt;p&gt;# class Person(object):&lt;br/&gt;#     &quot;&quot;&quot;人的属性&amp;amp;特性&quot;&quot;&quot;&lt;br/&gt;#     def info(self,username,password):&lt;br/&gt;#         &quot;&quot;&quot;&lt;br/&gt;#         :param username: 参数用户名&lt;br/&gt;#         :param password: 参数密码&lt;br/&gt;#         :return:&lt;br/&gt;#         &quot;&quot;&quot;&lt;br/&gt;#         pass&lt;br/&gt;#&lt;br/&gt;# per = Person()&lt;br/&gt;# print(per.__doc__)&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;__call__:对象创建时直接返回__call__的内容,使用该方法可以模拟静态方法&quot;&quot;&quot;&lt;/p&gt;&lt;p&gt;# class Per(object):&lt;br/&gt;#     def __new__(cls, *args, **kwargs):&lt;br/&gt;#         print(&quot;打印出call方法&quot;)&lt;br/&gt;#&lt;br/&gt;# per = Per()&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;&lt;br/&gt;__str__:对象代表的含义，返回一个字符串，通过他可以把字符串和对象关联起来，方便某些程序的实现&lt;br/&gt;该字符串表示某个类，实现__str__后，可以直接使用print语句打印出对象，也可以通过str来触发__str__来执行&lt;br/&gt;__str__:&lt;br/&gt;1.对象的意思&lt;br/&gt;2.返回一个字符串，对象和字符串关联起来 --&amp;gt;该字符串可表示一个类&lt;br/&gt;&quot;&quot;&quot;&lt;br/&gt;# class Per(object):&lt;br/&gt;#     &quot;&quot;&quot;我是一个字符串类&quot;&quot;&quot;&lt;br/&gt;#     def __str__(self):&lt;br/&gt;#         return self.__doc__&lt;br/&gt;#&lt;br/&gt;# per = Per()&lt;br/&gt;# print(str(per))&lt;/p&gt;&lt;p&gt;class Factory(object):&lt;br/&gt;def createFruit(self,fruit):&lt;br/&gt;if fruit == &quot;apple&quot;:&lt;br/&gt;return Apple()&lt;br/&gt;elif fruit == &quot;banana&quot;:&lt;br/&gt;return Banana()&lt;/p&gt;&lt;p&gt;class Fruit(object):&lt;br/&gt;def __str__(self):&lt;br/&gt;return &quot;fruit&quot;&lt;/p&gt;&lt;p&gt;class Apple(object):&lt;br/&gt;def __str__(self):&lt;br/&gt;return &quot;apple&quot;&lt;/p&gt;&lt;p&gt;class Banana(object):&lt;br/&gt;def __str__(self):&lt;br/&gt;return &quot;banana&quot;&lt;/p&gt;&lt;p&gt;if __name__ == '__main__':&lt;br/&gt;factory = Factory()&lt;br/&gt;print(factory.createFruit(&quot;apple&quot;))&lt;br/&gt;print(factory.createFruit(&quot;banana&quot;))&lt;/p&gt;&lt;p&gt;&quot;&quot;&quot;工厂设计模式在UI中的应用&quot;&quot;&quot;&lt;br/&gt;from selenium import webdriver&lt;br/&gt;from appium import webdriver&lt;br/&gt;from selenuim.webdriver.support.expected_conditions import NoSuchElementException&lt;br/&gt;from selenium.webdriver.common.by import By&lt;/p&gt;&lt;p&gt;class Factory(object):&lt;br/&gt;def createWebDriver(self,WebDriver):&lt;br/&gt;if WebDriver == &quot;web&quot;:&lt;br/&gt;return WebUI(self.driver)&lt;br/&gt;elif WebDriver == &quot;app&quot;:&lt;br/&gt;return AppUI(self.driver)&lt;/p&gt;&lt;p&gt;class WebDriver(object):&lt;br/&gt;def __init__(self,webdriver):&lt;br/&gt;self.webdriver = webdriver&lt;/p&gt;&lt;p&gt;def __str__(self):&lt;br/&gt;return &quot;WebDriver&quot;&lt;/p&gt;&lt;p&gt;def findElement(self,*loc):&lt;br/&gt;try:&lt;br/&gt;return self.driver_find_element_By(*loc)&lt;br/&gt;except NoSuchElementException as e:&lt;br/&gt;print(&quot;Error details:%s&quot;,e.args[0])&lt;/p&gt;&lt;p&gt;def findElements(self,*loc):&lt;br/&gt;try:&lt;br/&gt;return self.driver_find_element_By(*loc)&lt;br/&gt;except NoSuchElementException as e:&lt;br/&gt;print(&quot;Error details:%s&quot;,e.args[0])&lt;/p&gt;&lt;p&gt;class WebUI(WebDriver):&lt;br/&gt;def __str__(self):&lt;br/&gt;return &quot;web&quot;&lt;/p&gt;&lt;p&gt;class AppUI(WebDriver):&lt;br/&gt;def __str__(self):&lt;br/&gt;return &quot;app&quot;&lt;/p&gt;&lt;p&gt;if __name__ == '__main__':&lt;br/&gt;factory = Factory()&lt;br/&gt;print(factory.createFruit(&quot;web&quot;))&lt;br/&gt;print(factory.createFruit(&quot;app&quot;))
&lt;/p&gt;&lt;/pre&gt;</description>
<pubDate>Sun, 24 Feb 2019 07:33:00 +0000</pubDate>
<dc:creator>Teacher涛</dc:creator>
<og:description>#!/usr/bin/env python#-*- conding:utf-8 -*-# class Person(object):# def __init__(self,name,age):# se</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Teachertao/p/10426386.html</dc:identifier>
</item>
<item>
<title>Android利用RecyclerView实现列表倒计时效果 - 冬季穿短裤</title>
<link>http://www.cnblogs.com/qq714081644/p/6547192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq714081644/p/6547192.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最近面试时，面试官问了一个列表倒计时效果如何实现，然后脑袋突然懵的了O(∩_∩)O，现在记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;运行效果图&quot;&gt;运行效果图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190223155458142.gif&quot; alt=&quot;Alt&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现思路&quot;&gt;实现思路&lt;/h2&gt;
&lt;p&gt;实现方法主要有两个：&lt;br/&gt;1.为每个开始倒计时的item启动一个定时器，再做更新item处理；&lt;br/&gt;2.只启动一个定时器，然后遍历数据，再做再做更新item处理。&lt;br/&gt;经过思考，包括性能、实现等方面，决定使用第2种方式实现。&lt;/p&gt;
&lt;h2 id=&quot;实现过程&quot;&gt;实现过程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据实体&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** 
  * 总共的倒计时的时间(结束时间-开始时间),单位：毫秒 
  * 例: 2019-02-23 11:00:30 与 2019-02-23 11:00:00 之间的相差的毫秒数 
  */  
 private long totalTime;  
 /** 
  * 倒计时是否在暂停状态 
  */  
 private boolean isPause = true;  &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;倒计时&lt;/strong&gt;&lt;br/&gt;Timer&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;mTimer.schedule(mTask, 0, 1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TimerTask&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; class MyTask extends TimerTask {
        @Override
        public void run() {
            if (mList.isEmpty()) {
                return;
            }
            int size = mList.size();
            CountDownTimerBean bean;
            long totalTime;
            for (int i = 0; i &amp;lt; size; i++) {
                bean = mList.get(i);
                if (!bean.isPause()) {//不处于暂停状态
                    totalTime = bean.getTotalTime() - 1000;
                    if (totalTime &amp;lt;= 0) {
                        bean.setPause(true);
                        bean.setTotalTime(0);
                    }
                    bean.setTotalTime(totalTime);
                    Message message = mHandler.obtainMessage(1);
                    message.arg1 = i;
                    mHandler.sendMessage(message);
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;线程交互更新item&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; mHandler = new Handler(Looper.getMainLooper()) {
            @Override
            public void handleMessage(Message msg) {
                switch (msg.what) {
                    case 1:
                        notifyItemChanged(msg.arg1, &quot;update-time&quot;);
                        break;
                }
            }
        };&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;性能优化方面&lt;/strong&gt;&lt;br/&gt;1.调用notifyItemChanged()方法后，不要更新整个item(比如说item包含图片，不需要变的)，所以要重写onBindViewHolder( Holder , int , List&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
    public void onBindViewHolder(@NonNull Holder holder, int position, @NonNull List&amp;lt;Object&amp;gt; payloads) {
        if (payloads.isEmpty()) {
            onBindViewHolder(holder, position);
            return;
        }
        //更新某个控件,比如说只需要更新时间信息，其他不用动
        CountDownTimerBean bean = mList.get(position);
        long day = bean.getTotalTime() / (1000 * 60 * 60 * 24);
        long hour = (bean.getTotalTime() / (1000 * 60 * 60) - day * 24);
        long min = ((bean.getTotalTime() / (60 * 1000)) - day * 24 * 60 - hour * 60);
        long s = (bean.getTotalTime() / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);
        holder.tvTime.setText(&quot;剩余时间: &quot; + day + &quot;天&quot; + hour + &quot;小时&quot; + min + &quot;分&quot; + s + &quot;秒&quot;);
        holder.btnAction.setText(bean.isPause() ? &quot;开始&quot; : &quot;暂停&quot;);
        holder.btnAction.setEnabled(bean.getTotalTime() != 0);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.销毁资源操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   /**
     * 销毁资源
     */
    public void destroy() {
        mHandler.removeMessages(1);
        if (mTimer != null) {
            mTimer.cancel();
            mTimer.purge();
            mTimer = null;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;RecyclerView.Adapter部分源码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CountDownTimerAdapter extends RecyclerView.Adapter&amp;lt;CountDownTimerAdapter.Holder&amp;gt; {
    private static final String TAG = &quot;CountDownTimerAdapter-&amp;gt;&quot;;
    private List&amp;lt;CountDownTimerBean&amp;gt; mList;//数据
    private Handler mHandler;//线程调度，用来更新列表

    private Timer mTimer;
    private MyTask mTask;

    public CountDownTimerAdapter() {
        mList = new ArrayList&amp;lt;&amp;gt;();
        mHandler = new Handler(Looper.getMainLooper()) {
            @Override
            public void handleMessage(Message msg) {
                switch (msg.what) {
                    case 1:
                        notifyItemChanged(msg.arg1, &quot;update-time&quot;);
                        break;
                }
            }
        };
        mTask = new MyTask();
    }

    public void bindAdapterToRecyclerView(@NonNull RecyclerView view) {
        view.setAdapter(this);
    }

    /**
     * 设置新的数据源
     *
     * @param list 数据
     */
    public void setNewData(@NonNull List&amp;lt;CountDownTimerBean&amp;gt; list) {
        destroy();
        mList.clear();
        mList.addAll(list);
        notifyDataSetChanged();
        if (mTimer == null) {
            mTimer = new Timer();
        }
        mTimer.schedule(mTask, 0, 1000);
    }

    /**
     * 销毁资源
     */
    public void destroy() {
        mHandler.removeMessages(1);
        if (mTimer != null) {
            mTimer.cancel();
            mTimer.purge();
            mTimer = null;
        }
    }

    @NonNull
    @Override
    public Holder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) {
        View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item_count_down_timer, viewGroup, false);
        return new Holder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull Holder holder, int position, @NonNull List&amp;lt;Object&amp;gt; payloads) {
        if (payloads.isEmpty()) {
            onBindViewHolder(holder, position);
            return;
        }
        //更新某个控件,比如说只需要更新时间信息，其他不用动
        CountDownTimerBean bean = mList.get(position);
        long day = bean.getTotalTime() / (1000 * 60 * 60 * 24);
        long hour = (bean.getTotalTime() / (1000 * 60 * 60) - day * 24);
        long min = ((bean.getTotalTime() / (60 * 1000)) - day * 24 * 60 - hour * 60);
        long s = (bean.getTotalTime() / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);
        holder.tvTime.setText(&quot;剩余时间: &quot; + day + &quot;天&quot; + hour + &quot;小时&quot; + min + &quot;分&quot; + s + &quot;秒&quot;);
        holder.btnAction.setText(bean.isPause() ? &quot;开始&quot; : &quot;暂停&quot;);
        holder.btnAction.setEnabled(bean.getTotalTime() != 0);
    }

    @Override
    public void onBindViewHolder(@NonNull final Holder holder, int position) {
        holder.ivIcon.setImageResource(R.mipmap.ic_launcher_round);
        final CountDownTimerBean bean = mList.get(position);
        long day = bean.getTotalTime() / (1000 * 60 * 60 * 24);
        long hour = (bean.getTotalTime() / (1000 * 60 * 60) - day * 24);
        long min = ((bean.getTotalTime() / (60 * 1000)) - day * 24 * 60 - hour * 60);
        long s = (bean.getTotalTime() / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);
        holder.tvTime.setText(&quot;剩余时间: &quot; + day + &quot;天&quot; + hour + &quot;小时&quot; + min + &quot;分&quot; + s + &quot;秒&quot;);
        holder.btnAction.setText(bean.isPause() ? &quot;开始&quot; : &quot;暂停&quot;);
        holder.btnAction.setEnabled(bean.getTotalTime() != 0);
        holder.btnAction.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (bean.isPause()) {
                    bean.setPause(false);
                    holder.btnAction.setText(&quot;暂停&quot;);
                } else {
                    bean.setPause(true);
                    holder.btnAction.setText(&quot;开始&quot;);
                }
            }
        });
    }

    @Override
    public int getItemCount() {
        return mList.size();
    }

    class Holder extends RecyclerView.ViewHolder {
        private ImageView ivIcon;
        private TextView tvTime;
        private Button btnAction;

        Holder(@NonNull View itemView) {
            super(itemView);
            ivIcon = itemView.findViewById(R.id.iv_icon);
            tvTime = itemView.findViewById(R.id.tv_time);
            btnAction = itemView.findViewById(R.id.btn_action);
        }
    }

    class MyTask extends TimerTask {
        @Override
        public void run() {
            if (mList.isEmpty()) {
                return;
            }
            int size = mList.size();
            CountDownTimerBean bean;
            long totalTime;
            for (int i = 0; i &amp;lt; size; i++) {
                bean = mList.get(i);
                if (!bean.isPause()) {//不处于暂停状态
                    totalTime = bean.getTotalTime() - 1000;
                    if (totalTime &amp;lt;= 0) {
                        bean.setPause(true);
                        bean.setTotalTime(0);
                    }
                    bean.setTotalTime(totalTime);
                    Message message = mHandler.obtainMessage(1);
                    message.arg1 = i;
                    mHandler.sendMessage(message);
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://download.csdn.net/download/csdn_shen0221/10973034&quot;&gt;源码&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;br/&gt;如有问题，欢迎及时沟通。</description>
<pubDate>Sun, 24 Feb 2019 07:30:00 +0000</pubDate>
<dc:creator>冬季穿短裤</dc:creator>
<og:description>最近面试时，面试官问了一个列表倒计时效果如何实现，然后脑袋突然懵的了O(∩_∩)O，现在记录一下。 运行效果图 实现思路 实现方法主要有两个： 1.为每个开始倒计时的item启动一个定时器，再做更新i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq714081644/p/6547192.html</dc:identifier>
</item>
<item>
<title>设计模式之外观模式(结构型) - smileNicky</title>
<link>http://www.cnblogs.com/mzq123/p/10426290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10426290.html</guid>
<description>&lt;h3 id=&quot;一模式定义&quot;&gt;一、模式定义&lt;/h3&gt;
&lt;p&gt;外观模式：外观模式就是提供一个统一的接口，用来访问子系统的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。，外观模式也称门面模式，是一种对象结构型设计模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190224144010651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjczOTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二模式角色&quot;&gt;二、模式角色&lt;/h3&gt;
&lt;p&gt;从模式定义可以知道，外观模式应该包含如下角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Frcade：外观角色&lt;/li&gt;
&lt;li&gt;SubSystem：子系统角色&lt;/li&gt;
&lt;li&gt;Client：客户端角色&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经典例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Facade
{
    private SubSystemA obj1 = new SubSystemA();
    private SubSystemB obj2 = new SubSystemB();
    private SubSystemC obj3 = new SubSystemC();
    public void method()
    {
        obj1.method();
        obj2.method();
        obj3.method();
    }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三模式简单分析&quot;&gt;三、模式简单分析&lt;/h3&gt;
&lt;p&gt;外观模式为客户端类提供了便捷，客户端类不需要关注子系统的设计，直接提供外观类访问就好&lt;/p&gt;
&lt;p&gt;外观模式符合“迪米特法则”，引入一个单一简单的接口，给客户端调用，从而降低了客户端和子系统的耦合度&lt;/p&gt;
&lt;p&gt;不过外观模式也有一些缺点，每一种设计模式都是有缺点和优点的，需要根据复杂的业务场景进行选用。加入没引用一个抽象的外观类的话，一旦业务改变就需要进行外观类和客户端类代码的调整了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190224151134675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjczOTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于一些很复杂的业务系统来说，有时候可以设计多个外观类进行系统解耦&lt;/p&gt;
&lt;h3 id=&quot;四简单例子实践&quot;&gt;四、简单例子实践&lt;/h3&gt;
&lt;p&gt;JDBC数据库操作的例子，本例子来自&lt;a href=&quot;https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19696449&quot;&gt;《设计模式》&lt;/a&gt;一书&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.sql.*;

public class JDBCFacade {
    
    private Connection conn=null;
    private Statement statement=null;

    public void open(String driver,String jdbcUrl,String userName,String userPwd) {
        try {
            Class.forName(driver).newInstance();
            conn = DriverManager.getConnection(jdbcUrl,userName,userPwd);
            statement = conn.createStatement();
        } 
        catch (Exception e) {
            e.printStackTrace();
        }
    }

    public int executeUpdate(String sql) {
        try {
            return statement.executeUpdate(sql);
        } 
        catch (SQLException e) {
            e.printStackTrace();
            return -1;
        }
    }

    public ResultSet executeQuery(String sql) {
        try {
            return statement.executeQuery(sql);
        } catch (SQLException e) {
            e.printStackTrace();
            return null;
        }
    }

    public void close() {
        try {
            conn.close();
            statement.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五模式应用&quot;&gt;五、模式应用&lt;/h3&gt;
&lt;p&gt;外观模式适用于复杂的系统，可以用于系统解耦。下面简单列举一下外观模式的一些应用场景&lt;/p&gt;
</description>
<pubDate>Sun, 24 Feb 2019 07:15:00 +0000</pubDate>
<dc:creator>smileNicky</dc:creator>
<og:description>[TOC] 一、模式定义 外观模式：外观模式就是提供一个统一的接口，用来访问子系统的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。，外观模式也称门面模式，是一种对象结构型设计模式。 二、模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10426290.html</dc:identifier>
</item>
<item>
<title>go:Hello world与变量声明 - kakawith</title>
<link>http://www.cnblogs.com/kakawith/p/10426281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kakawith/p/10426281.html</guid>
<description>
&lt;p&gt;一、go语言版hello world&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main # 指明文件属于main包 main包使用后来定义一个独立的可执行程序，而不是库main包中的main函数是特殊的，不管在什么程序中，main做什么事情，它总是程序开始的执行的地方。
import &quot;fmt&quot; # 导入fmt包，fmt中的函数是用来处理格式化输入输出
func main()  {
        fmt.Println(&quot;Hello,world!&quot;)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　go语言不需要在语句或者声明后面是用分号结尾，除非有多个语句或者声明出现在同一行。&lt;/p&gt;
&lt;p&gt;　　注意：&lt;/p&gt;
&lt;p&gt;　　1.&quot; { &quot;符号必须和关键字func在同一行，不能独立成行&lt;/p&gt;
&lt;p&gt;二、变量声明&lt;/p&gt;
&lt;p&gt;　　以下变量声明的方式是等价的：&lt;/p&gt;
&lt;p&gt;　　1.s := &quot;&quot; // 短变量声明更加简洁，通常在一个函数内部使用&lt;/p&gt;
&lt;p&gt;　　2.var s string //第二种形式依赖默认初始化为空字符串&quot;&quot;&lt;/p&gt;
&lt;p&gt;　　3.var s = &quot;&quot; //第三种形式很少用，除非我们声明多个变量&lt;/p&gt;
&lt;p&gt;　　4.var s string = &quot;&quot; //第四种形式是显式的变量类型，在类型一致的情况下是冗余的信息在类型不一致的情况下是必须的。&lt;/p&gt;
&lt;p&gt;　　实际生产中我们使用前两种形式，使用显式初始化来说明初始化变量的重要性，使用隐式的初始化来表明初始化变量不重要&lt;/p&gt;
</description>
<pubDate>Sun, 24 Feb 2019 07:13:00 +0000</pubDate>
<dc:creator>kakawith</dc:creator>
<og:description>一、go语言版hello world go语言不需要在语句或者声明后面是用分号结尾，除非有多个语句或者声明出现在同一行。 注意： 1.&quot; { &quot;符号必须和关键字func在同一行，不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kakawith/p/10426281.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 基于JWT的认证(一) - WarrenRyan</title>
<link>http://www.cnblogs.com/WarrenRyan/p/10426204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WarrenRyan/p/10426204.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Json web token&lt;/em&gt;&lt;/strong&gt; (&lt;em&gt;JWT&lt;/em&gt;), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(&lt;em&gt;RFC 7519&lt;/em&gt;).该&lt;em&gt;token&lt;/em&gt;被设计为紧凑且安全的，特别适用于分布式站点的单点登录（&lt;em&gt;SSO&lt;/em&gt;）场景。&lt;em&gt;JWT&lt;/em&gt;的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该&lt;em&gt;token&lt;/em&gt;也可直接被用于认证，也可被加密。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道，&lt;em&gt;http&lt;/em&gt;协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据&lt;em&gt;http&lt;/em&gt;协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为&lt;em&gt;cookie&lt;/em&gt;,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了。&lt;/p&gt;
&lt;h2 id=&quot;几种常见的传统认证机制&quot;&gt;&lt;strong&gt;几种常见的传统认证机制&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;http-basic-auth&quot;&gt;&lt;strong&gt;&lt;em&gt;HTTP Basic Auth&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;HTTP Basic Auth&lt;/em&gt;简单点说明就是每次请求API时都提供用户的&lt;em&gt;username&lt;/em&gt;和&lt;em&gt;password&lt;/em&gt;，简言之，&lt;em&gt;Basic Auth&lt;/em&gt;是配合&lt;em&gt;RESTful API&lt;/em&gt; 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的&lt;em&gt;RESTful API&lt;/em&gt;时，尽量避免采用&lt;em&gt;HTTP Basic Auth&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id=&quot;oauth&quot;&gt;&lt;strong&gt;&lt;em&gt;OAuth&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;OAuth&lt;/em&gt;（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;OAuth&lt;/em&gt;允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，&lt;em&gt;OAuth&lt;/em&gt;让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容&lt;br/&gt;下面是&lt;em&gt;OAuth2.0&lt;/em&gt;的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.tity.xyz/Article/jwt/oauth2.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cookie-auth&quot;&gt;&lt;strong&gt;&lt;em&gt;Cookie Auth&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Cookie&lt;/em&gt;认证机制就是为一次请求认证在服务端创建一个&lt;em&gt;Session&lt;/em&gt;对象，同时在客户端的浏览器端创建了一个&lt;em&gt;Cookie&lt;/em&gt;对象；通过客户端带上来&lt;em&gt;Cookie&lt;/em&gt;对象来与服务器端的&lt;em&gt;session&lt;/em&gt;对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，&lt;em&gt;cookie&lt;/em&gt;会被删除。但可以通过修改&lt;em&gt;Cookie&lt;/em&gt; 的&lt;em&gt;expire time&lt;/em&gt;使&lt;em&gt;cookie&lt;/em&gt;在一定时间内有效；&lt;br/&gt;&lt;img src=&quot;https://pic.tity.xyz/Article/jwt/token.png&quot; alt=&quot;两种对比&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;token-简介&quot;&gt;&lt;strong&gt;&lt;em&gt;Token&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;JWT&lt;/em&gt;&lt;/strong&gt; (&lt;em&gt;Json Web Token&lt;/em&gt;)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;JWT&lt;/em&gt;的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。&lt;/p&gt;
&lt;p&gt;有些朋友可能会认为，我登录只需要用缓存或者数据库记录下一个特征码或者是&lt;em&gt;Cookies&lt;/em&gt;就可以了，为什么要使用&lt;em&gt;JWT&lt;/em&gt;呢？我们知道一个数据库或者是一个软件，损耗时间最大的地方就是我们的 &lt;strong&gt;&lt;em&gt;I/O&lt;/em&gt;&lt;/strong&gt;(输入输出，通常指的就是硬盘的读写)，因此我们选择解码一次HS256，对于现在的计算能力强大的计算机而言，解一次HS256比访问一次磁盘要快得多。&lt;/p&gt;
&lt;p&gt;基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。&lt;br/&gt;流程上是这样的：&lt;br/&gt;&lt;img src=&quot;https://pic.tity.xyz/Article/jwt/token02.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户使用用户名密码来请求服务器&lt;/li&gt;
&lt;li&gt;服务器进行验证用户的信息&lt;/li&gt;
&lt;li&gt;服务器通过验证发送给用户一个token&lt;/li&gt;
&lt;li&gt;客户端存储token，并在每次请求时附送上这个token值&lt;/li&gt;
&lt;li&gt;服务端验证token值，并返回数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。&lt;br/&gt;那么我们现在回到JWT的主题上。&lt;/p&gt;
&lt;h3 id=&quot;jwt-的组成&quot;&gt;&lt;strong&gt;&lt;em&gt;JWT&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;的组成&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们先来看一段&lt;em&gt;jwt&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仔细观察我们可以发现这一段字符串中含有两个 &lt;strong&gt;&quot; . &quot;&lt;/strong&gt;,这两个 &lt;strong&gt;&quot; . &quot;&lt;/strong&gt;把&lt;em&gt;jwt&lt;/em&gt;分成了三份，我们分别成为头部、荷载信息、签证信息。那么这三部分的分工是什么呢？&lt;/p&gt;

&lt;p&gt;&lt;em&gt;JWT&lt;/em&gt;的头部承载了两个信息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;声明类型,对于Jwt来说就是jwt&lt;/li&gt;
&lt;li&gt;加密算法，通常使用SHA256,HS256&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完整的头部应该是像这样的一个Json&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  'typ': 'JWT',
  'alg': 'HS256'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将头部Json进行base64加密就得到了我们的第一部分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;payload&quot;&gt;&lt;strong&gt;&lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;第二部分是荷载信息，Payload,你可以理解为我们的&lt;em&gt;JWT&lt;/em&gt;是一辆大仓库，第一部分头部就是仓库的名称编号等基础信息，而荷载信息就是仓库的本身，包含了仓库里面的所有货物。这些信息又包含了三个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标准中注册的声明&lt;/li&gt;
&lt;li&gt;公共的声明&lt;/li&gt;
&lt;li&gt;私有的声明&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;标准中注册的声明-建议但不强制使用&quot;&gt;&lt;strong&gt;标准中注册的声明 (建议但不强制使用)&lt;/strong&gt; ：&lt;/h4&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;
&lt;p&gt;iss: jwt签发者&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;sub: jwt所面向的用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;aud: 接收jwt的一方&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;exp: jwt的过期时间，这个过期时间必须要大于签发时间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;nbf: 定义在什么时间之前，该jwt都是不可用的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iat: jwt的签发时间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;公共的声明&quot;&gt;&lt;strong&gt;公共的声明 ：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要息。但不建议添加敏感信息，因为该部分在客户端可解密。&lt;/p&gt;
&lt;h4 id=&quot;私有的声明&quot;&gt;&lt;strong&gt;私有的声明 ：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。&lt;/p&gt;
&lt;p&gt;事实上我们的Header和Payload都是基于base64加密的，这种密文都是可以对称解密的，因此请不要存放敏感信息。&lt;/p&gt;
&lt;p&gt;定义一个payload:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;admin&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进行base64加密后，得到了我们的第二部分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;signature&quot;&gt;&lt;strong&gt;&lt;em&gt;Signature&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Jwt&lt;/em&gt;的第三部分是一个签证信息，这个签证信息由三部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;header (base64后的)&lt;/li&gt;
&lt;li&gt;payload (base64后的)&lt;/li&gt;
&lt;li&gt;secret&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这一部分可以理解为对前部分的一个校验，将前两部分加密后的密文通过在&lt;em&gt;Header&lt;/em&gt;中定义的加密方式，与服务端所传入的密钥进行一次加密，假如前两部分的信息被篡改的话，必然通不过最后一部分签证的校验。因此通过这样保证了&lt;em&gt;Jwt&lt;/em&gt;的安全性。&lt;/p&gt;
&lt;p&gt;因此，保存并隐藏好我们的加密密钥是非常重要的，假设泄露了，就意味着任何知道密钥的人都可以轻松的对&lt;em&gt;jwt&lt;/em&gt;进行自我签发和验证。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Feb 2019 06:56:00 +0000</pubDate>
<dc:creator>WarrenRyan</dc:creator>
<og:description>ASP.NET Core 基于 JWT 的认证(一) Json web token ( JWT ), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（( RFC 7519 ).该 t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WarrenRyan/p/10426204.html</dc:identifier>
</item>
<item>
<title>Java8之Optional类 - wenbochang</title>
<link>http://www.cnblogs.com/wenbochang/p/10426171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenbochang/p/10426171.html</guid>
<description>&lt;h2&gt;写在前头&lt;/h2&gt;
&lt;p&gt;今天再看阿里的Java开发手册，里面&lt;strong&gt;异常处理第10条&lt;/strong&gt;提到这样一个建议。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;【推荐】&lt;strong&gt;防止 NPE ，是程序员的基本修养，注意 NPE 产生的场景：&lt;/strong&gt;&lt;br/&gt;1 ） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。&lt;br/&gt;反例： public int f() { return Integer 对象}， 如果为 null ，自动解箱抛 NPE 。&lt;br/&gt;2 ） 数据库的查询结果可能为 null 。&lt;br/&gt;3 ） 集合里的元素即使 isNotEmpty ，取出的数据元素也可能为 null 。&lt;br/&gt;4 ） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE 。&lt;br/&gt;5 ） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。&lt;br/&gt;6 ） 级联调用 obj . getA() . getB() . getC()； 一连串调用，易产生 NPE 。&lt;br/&gt;&lt;strong&gt;正例：使用 JDK8 的 Optional 类来防止 NPE 问题。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里面的正确示例提示我们用Java8的Optional类来防止NPE的问题。&lt;/p&gt;
&lt;p&gt;那我们今天就看看这个Optional类吧&lt;/p&gt;

&lt;h2&gt;Optional类&lt;/h2&gt;
&lt;table class=&quot;reference&quot;&gt;&lt;tbody readability=&quot;21&quot;&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;方法 &amp;amp; 描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;&lt;strong&gt;static &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; empty()&lt;/strong&gt;
&lt;p&gt;返回空的 Optional 实例。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;boolean equals(Object obj)
&lt;p&gt;判断其他对象是否等于 Optional。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;Optional&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super &amp;lt;T&amp;gt; predicate)
&lt;p&gt;如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.5&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;&amp;lt;U&amp;gt; Optional&amp;lt;U&amp;gt; flatMap(Function&amp;lt;? super T,Optional&amp;lt;U&amp;gt;&amp;gt; mapper)
&lt;p&gt;如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;T get()
&lt;p&gt;如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;int hashCode()
&lt;p&gt;返回存在值的哈希码，如果值不存在 返回 0。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.5&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;void ifPresent(Consumer&amp;lt;? super T&amp;gt; consumer)
&lt;p&gt;如果值存在则使用该值调用 consumer , 否则不做任何事情。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;boolean isPresent()
&lt;p&gt;如果值存在则方法会返回true，否则返回 false。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;&amp;lt;U&amp;gt;Optional&amp;lt;U&amp;gt; map(Function&amp;lt;? super T,? extends U&amp;gt; mapper)
&lt;p&gt;如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;&lt;strong&gt;static &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; of(T value)&lt;/strong&gt;
&lt;p&gt;返回一个指定非null值的Optional。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;&lt;strong&gt;static &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; ofNullable(T value)&lt;/strong&gt;
&lt;p&gt;如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;T orElse(T other)
&lt;p&gt;如果存在该值，返回值， 否则返回 other。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;T orElseGet(Supplier&amp;lt;? extends T&amp;gt; other)
&lt;p&gt;如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;&amp;lt;X extends Throwable&amp;gt; T orElseThrow(Supplier&amp;lt;? extends X&amp;gt; exceptionSupplier)

&lt;p&gt;如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;String toString()
&lt;p&gt;返回一个Optional的非空字符串，用来调试&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;我们可以看到Optional总共也就10+个方法，其中有三个&lt;strong&gt;static&lt;/strong&gt;方法。并且Optional的构造方法是private，不能new出来。&lt;/p&gt;
&lt;p&gt;所以我们一般用这三个static来获取Optional的对象。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h3&gt; of &amp;amp;&amp;amp; ofNullable&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt;&lt;span&gt; of(T value) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Optional&amp;lt;&amp;gt;&lt;span&gt;(value);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt;&lt;span&gt; ofNullable(T value) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; value == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; empty() : of(value);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显 of 对null对象没有做任何处理，ofNullable才做了处理。所以当我们&lt;strong&gt;不知道传入的对象是否为null的时候&lt;/strong&gt;，我们应该选择用 ofNullable来做处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&amp;lt;U&amp;gt; Optional&amp;lt;U&amp;gt; map(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? &lt;span&gt;extends&lt;/span&gt; U&amp;gt;&lt;span&gt; mapper) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    Objects.requireNonNull(mapper);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isPresent())
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; empty();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Optional.ofNullable(mapper.apply(value));
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们想获取Object里面的值的话，我们就需要用到这个map。&lt;/p&gt;

&lt;h2&gt;例子&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionalTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Person person = &lt;span&gt;new&lt;/span&gt; Person(&quot;zhangsan&quot;, 18&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String name =&lt;span&gt; getName(person);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        System.out.println(name);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getName(Person person) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Objects.isNull(person)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;unKnown&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; person.getName();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看上面的这个例子。&lt;/p&gt;
&lt;p&gt;我们有一个函数 &lt;strong&gt;getName&lt;/strong&gt; 作用是获取Person对象的名字。但我并不知道这个Person是否为Null。&lt;/p&gt;
&lt;p&gt;所以我要进行一个判断，判断Person是否为空，在做决定。&lt;/p&gt;
&lt;p&gt;但如果我们使用Optional类的话，我们可以这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionalTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Person person = &lt;span&gt;new&lt;/span&gt; Person(&quot;zhangsan&quot;, 18&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String name =&lt;span&gt; getName(person);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        System.out.println(name);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getName(Person person) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         String name = Optional.ofNullable(person).map(x -&amp;gt;&lt;span&gt; x.getName())
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 .orElse(&quot;unKnown&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果传入的为空，它会自动new一个  &lt;strong&gt;Optional&amp;lt;T&amp;gt; t = (Optional&amp;lt;T&amp;gt;) EMPTY; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有效的处理到了null的问题，而且还非常的简洁。&lt;/p&gt;

</description>
<pubDate>Sun, 24 Feb 2019 06:49:00 +0000</pubDate>
<dc:creator>wenbochang</dc:creator>
<og:description>写在前头 今天再看阿里的Java开发手册，里面异常处理第10条提到这样一个建议。 【推荐】防止 NPE ，是程序员的基本修养，注意 NPE 产生的场景：1 ） 返回类型为基本数据类型，return 包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenbochang/p/10426171.html</dc:identifier>
</item>
<item>
<title>Ansible 入门指南 - 安装及 Ad-Hoc 命令使用 - Michael翔</title>
<link>http://www.cnblogs.com/michael-xiang/p/10426159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/michael-xiang/p/10426159.html</guid>
<description>&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;Ansilbe管理员节点和远程主机节点通过ssh协议进行通信。所以Ansible配置的时候只需要保证从Ansible管理节点通过SSH能够连接到被管理的远程的远程节点&lt;/p&gt;
&lt;p&gt;每一台被ansible远程管理的主机，都需要配置基于key的ssh连接&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用Ansilbe命令行管理主机（Ad-hoc command）&lt;/li&gt;
&lt;li&gt;使用Ansilbe脚本语言管理主机（脚本语言Playbook）&lt;/li&gt;
&lt;li&gt;Ansible的“命令”Module&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;安装-ansible&quot;&gt;安装 ansible&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# Readhat/CentOS Linux, Ansible 目前放在 epel 源中
yum install -y epel-release
yum install -y ansible
# Mac
brew install ansible&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装 ansible 在管理节点，那么，需要配置管理节点-&amp;gt;远程主机之间基于 key 的免密访问：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 生成 ssh key，如果你之前配置过 Git，那么已经生成过一个了
ssh-keygen -t rsa -C &quot;649168982@qq.com&quot;
# 拷贝 ssh key 至远程主机，下次管理节点就可以免密访问远程主机了
ssh-copy-id remote_user@remote_server
# ssh 的时候不会提示是否保存 key
ssh-keyscan remote_servers &amp;gt;&amp;gt; ~/.ssh/known_hosts&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候在管理节点登录远程节点时，就不会输入密码也不会提醒你存储key，之前写过一篇文章，记录设置免密登录的文章&lt;a href=&quot;https://blog.csdn.net/michael_728/article/details/84944807&quot;&gt;Linux 双向 SSH 免密登录&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh remote_user@remote_server&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;host-inventory-主机清单&quot;&gt;Host Inventory 主机清单&lt;/h3&gt;
&lt;p&gt;Host Inventory 是配置文件，用来告诉Ansible需要管理哪些主机。并且把这些主机根据按需分类。&lt;/p&gt;
&lt;p&gt;可以根据用途分类：数据库节点，服务节点，nginx 节点、构建机器节点&lt;/p&gt;
&lt;p&gt;默认的配置文件在：&lt;code&gt;/etc/ansible/hosts&lt;/code&gt;，可以通过 &lt;code&gt;-i&lt;/code&gt; 参数指定配置文件的，参考问题：&lt;/p&gt;
&lt;h3 id=&quot;ansible-配置文件&quot;&gt;ansible 配置文件&lt;/h3&gt;
&lt;p&gt;ansible 的配置文件有多个位置，查找顺序如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;环境变量 &lt;code&gt;ANSIBLE_CONFIG&lt;/code&gt; 所指向的位置&lt;/li&gt;
&lt;li&gt;当前目录下的 &lt;code&gt;ansible.cfg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HOME 目录下的配置文件 &lt;code&gt;~/.ansible.cfg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/ansible/ansible.cfg&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文 ansible.cfg：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[defaults]
# 这个参数表示主机清单 inventory 文件的位置
inventory = ./inventory
 # 并发连接数，默认为5
forks = 5
remote_user = root
# 设置默认执行命令的用户，~~sudo_user~~ 参数在 ansbile 2.8 版本将会作废的
become_user = root
#指定一个存储ansible日志的文件（默认不记录日志）
log_path = ./ansible.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定用户名除了在 &lt;code&gt;ansible.cfg&lt;/code&gt; 中指定 &lt;code&gt;remote_user&lt;/code&gt; 之外，还可以：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;inventory 文件中指定 &lt;code&gt;ansible_user&lt;/code&gt; 或 &lt;code&gt;ansible_ssh_user&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;-u&lt;/code&gt; 参数指定用户名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多 &lt;code&gt;ansbile.cfg&lt;/code&gt; 的配置&lt;a href=&quot;https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;inventory-文件&quot;&gt;inventory 文件&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;inventory: 英  ['ɪnv(ə)nt(ə)rɪ]   美  ['ɪnvəntɔri]
n. 存货，存货清单；详细目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ansible 可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置。&lt;/p&gt;
&lt;p&gt;inventory:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[centos]
192.168.3.43
[centos:vars]
ansible_ssh_user=root&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;方括号&lt;code&gt;[]&lt;/code&gt;中是组名,用于对主机进行分类,便于对不同主机进行个别的管理&lt;/li&gt;
&lt;li&gt;一个主机可以属于不同的组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[组名:vars]&lt;/code&gt; 定义了「组的变量」&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;拓展：&lt;br/&gt;可以把一个组作为另一个组的子成员,以及分配变量给整个组使用. 这些变量可以给 &lt;code&gt;/usr/bin/ansible-playbook&lt;/code&gt; 使用,但不能给 &lt;code&gt;/usr/bin/ansible&lt;/code&gt; 使用&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[atlanta]
host1
host2

[raleigh]
host2
host3

[southeast:children]
atlanta
raleigh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Inventory 参数可以控制 ansible 与远程主机的交互方式：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ansible_ssh_host
      将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.

ansible_ssh_port
      ssh端口号.如果不是默认的端口号,通过此变量设置.

ansible_ssh_user
      默认的 ssh 用户名

ansible_ssh_pass
      ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)

ansible_sudo_pass
      sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)

ansible_sudo_exe (new in version 1.8)
      sudo 命令路径(适用于1.8及以上版本)

ansible_connection
      与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 'smart','smart' 方式会根据是否支持 ControlPersist, 来判断'ssh' 方式是否可行.

ansible_ssh_private_key_file
      ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.

ansible_shell_type
      目标系统的shell类型.默认情况下,命令的执行使用 'sh' 语法,可设置为 'csh' 或 'fish'.

ansible_python_interpreter
      目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \*BSD, 或者 /usr/bin/python
      不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26).

      与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;h2 id=&quot;用命令管理主机&quot;&gt;用命令管理主机&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ansible -h&lt;/code&gt; 中将命令行工具叫做 &lt;code&gt;Ad-Hoc Commands&lt;/code&gt;，格式是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Usage: ansible &amp;lt;host-pattern&amp;gt; [options]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ad hoc——临时的，在ansible中是指需要快速执行，并且不需要保存的命令。说白了就是执行简单的命令——一条命令。对于复杂的命令后面会说playbook。关于命令中使用的模块，之后专门详细再做功课，这里先简单意会入门吧。&lt;/p&gt;
&lt;p&gt;我的目录初始化时的组成：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;.
├── ansible.cfg
└── inventory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;host-pattern&lt;/code&gt; 既可以是一个具体的主机 IP，也可以是 inventory 中的组名。&lt;/p&gt;
&lt;p&gt;常用的命令选项示例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ansible all --list-hosts&lt;/code&gt; 列出所有主机的 IP，这里的 &lt;code&gt;all&lt;/code&gt; 不是组名，而是只 inventory 中所有的主机&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在进入下面的小节学习相关模块简单用法之前，咱们先学习一个命令，这对于今后的使用很有帮助：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ansible-doc &amp;lt;module_name&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;批量执行-ssh-授信---authorizedkey-模块&quot;&gt;批量执行 ssh 授信 - authorized——key 模块&lt;/h3&gt;
&lt;p&gt;在未进行批量授信之前，可以使用 &lt;code&gt;--ask-pass&lt;/code&gt; 参数来进行认证，例如：&lt;code&gt;ansible all -m ping --ask-pass&lt;/code&gt;。但是这样并不方便，可以通过将 ansible server 机器上的公钥复制到远程主机 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; 文件中，实现免密登录。机器很多时，这样做就比较麻烦了，可以用如下模块实现：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ansible centos -m authorized_key -a &quot;user=root key='{{ lookup('file', '/Users/michael/.ssh/id_rsa.pub') }}' path=/root/.ssh/authorized_keys manage_dir=yes&quot; --ask-pass&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;检查-ansbile-安装环境---ping-模块&quot;&gt;检查 ansbile 安装环境 - ping 模块&lt;/h3&gt;
&lt;p&gt;ping 模块用于测试 ansible server 到 inventory 主机的连通性，这是官网的介绍&lt;a href=&quot;https://docs.ansible.com/ansible/latest/modules/ping_module.html#ping-module&quot;&gt;ping – Try to connect to host, verify a usable python and return pong on success&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ansible -i inventory centos -m ping -u root
192.168.3.43 | SUCCESS =&amp;gt; {
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; 指定了 &lt;code&gt;inventory&lt;/code&gt; 文件，后面要接着目标主机名，不然会报错&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m&lt;/code&gt; 后面接使用的 &lt;code&gt;module&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt; 只以什么用户登录到目标主机&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面实例中，没有加目标主机名，就报错了：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ansible -i inventory centos -m ping -u root&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ERROR! Missing target hosts&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面错误示例，指定的用户名 &lt;code&gt;hh&lt;/code&gt; 无法免密登录到目标主机：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ansible -i inventory centos -m ping -u hh
192.168.3.43 | UNREACHABLE! =&amp;gt; {
    &quot;changed&quot;: false,
    &quot;msg&quot;: &quot;Failed to connect to the host via ssh: hh@192.168.3.43: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).\r\n&quot;,
    &quot;unreachable&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39972445&quot;&gt;这篇文章中&lt;/a&gt;看到了这样的用法也可以指定登录远程主机的用户名，并且，优先级比 &lt;code&gt;-u&lt;/code&gt; 或者在 &lt;code&gt;ansible.cfg&lt;/code&gt; 中指定都高：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[centos]
192.168.3.43
[centos:vars]
ansible_ssh_user=michael&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在远程主机执行命令&quot;&gt;在远程主机执行命令&lt;/h3&gt;
&lt;h4 id=&quot;command-模块&quot;&gt;command 模块&lt;/h4&gt;
&lt;p&gt;command模块为ansible默认模块，不指定-m参数时，使用的就是command模块；comand模块比较简单，常见的命令都可以使用，但其命令的执行不是通过shell执行的，所以，像这些 &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;|&quot;, and &quot;&amp;amp;&quot;操作都不可以，当然，也就不支持管道；&lt;/p&gt;
&lt;p&gt;在远程主机上执行命令 &lt;code&gt;pwd&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ansible centos -a 'pwd'
192.168.3.43 | CHANGED | rc=0 &amp;gt;&amp;gt;
/home/michael&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缺点：不支持管道，就没法批量执行命令&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里没有再用 &lt;code&gt;-i&lt;/code&gt; 参数指定 inventory 文件，因为我运行 &lt;code&gt;ansible --version&lt;/code&gt; 时，看到了它识别到了我当前目录下的 &lt;code&gt;ansible.cfg&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;centos&lt;/code&gt; 就是必不可少的参数 &lt;code&gt;host-pattern&lt;/code&gt;，让我们复习一下用法 &lt;code&gt;ansible &amp;lt;host-pattern&amp;gt; [options]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt;/&lt;code&gt;--args&lt;/code&gt; 模块参数&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;shell模块&quot;&gt;shell模块&lt;/h4&gt;
&lt;p&gt;使用shell模块，在远程命令通过&lt;code&gt;/bin/sh&lt;/code&gt;来执行；所以，我们在终端输入的各种命令方式，都可以使用； 但是我们自己定义在&lt;code&gt;.bashrc/.bash_profile&lt;/code&gt;中的环境变量shell模块由于没有加载，所以无法识别；&lt;/p&gt;
&lt;p&gt;如果需要使用自定义的环境变量，就需要在最开始，执行加载自定义脚本的语句；&lt;/p&gt;
&lt;p&gt;对shell模块的使用可以分成两块：&lt;br/&gt;1.如果待执行的语句少，可以直接写在一句话中：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ansible all -m shell -a &quot;. ~/.bashrc;ps -fe |grep sa_q&quot;
192.168.3.43 | CHANGED | rc=0 &amp;gt;&amp;gt;
root      2849  2844  2 14:58 pts/0    00:00:00 /bin/sh -c . ~/.bashrc;ps -fe |grep sa_q
root      2866  2849  0 14:58 pts/0    00:00:00 grep sa_q&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.如果在远程待执行的语句比较多，可写成一个脚本，通过 &lt;code&gt;copy&lt;/code&gt; 模块传到远端，然后再执行；但这样就又涉及到两次ansible调用；对于这种需求，ansible已经为我们考虑到了，script模块就是干这事的。&lt;/p&gt;
&lt;h4 id=&quot;script模块&quot;&gt;script模块&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;scripts&lt;/code&gt; 模块可以在本地写一个脚本，在远程服务器上执行（远程服务器不需要python环境）：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ansible all -m script -a &quot;./test-20190224.sh&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;test-20190224.sh&lt;/code&gt; 位于当前目录下，表示在所有的远程主机上执行 &lt;code&gt;test.sh&lt;/code&gt; 脚本，省略了先把文件复制过去的步骤&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考&lt;/p&gt;
&lt;h3 id=&quot;文件传输---copy-模块&quot;&gt;文件传输 - copy 模块&lt;/h3&gt;
&lt;p&gt;拷贝本地文件 &lt;code&gt;/Users/michael/Code/05-Github-Own/ansible-learn/file_mbp.txt&lt;/code&gt; 至远程主机的 &lt;code&gt;/tmp&lt;/code&gt; 目录下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ansible centos -m copy -a &quot;src=//Users/michael/Code/05-Github-Own/ansible-learn/file_mbp.txt dest=/tmp/ [owner=root group=root mode=0755]&quot;`
ansible centos -m copy -a &quot;src=//Users/michael/Code/05-Github-Own/ansible-learn/file_mbp.txt dest=/tmp/centos.txt [owner=root group=root mode=0755]&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面 &lt;code&gt;[]&lt;/code&gt;中的内容表示非必须。这个 &lt;code&gt;copy&lt;/code&gt; 模块挺智能，如果目标没有写文件名，那么传过去的文件就同名，如果自定义了文件名，就进行了重命名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/mw690/6d9475f6ly1g0hcx1tclij20y4064aaz.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装包---yum-模块&quot;&gt;安装包 - yum 模块&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ansible centos -m yum -a &quot;name=lrzsz state=latest&quot;
192.168.3.43 | SUCCESS =&amp;gt; {
    &quot;ansible_facts&quot;: {
        &quot;pkg_mgr&quot;: &quot;yum&quot;
    },
    &quot;changed&quot;: false,
    &quot;msg&quot;: &quot;&quot;,
    &quot;rc&quot;: 0,
    &quot;results&quot;: [
        &quot;All packages providing lrzsz are up to date&quot;,
        &quot;&quot;
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;yum&lt;/code&gt; 模块来安装软件包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; 指定安装的软件包的名字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt; 指定安装软件包时的行为，它有几个选项值，
&lt;ul&gt;&lt;li&gt;&lt;code&gt;installed&lt;/code&gt;/&lt;code&gt;present&lt;/code&gt; 它俩是等价的，表示如果远程主机上有这个包了，则不重新安装了；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;latest&lt;/code&gt; 顾名思义，会去安装最新版的，这个对于生产是比较危险的，有可能因此破坏了生产的环境&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Yum 模块&lt;/p&gt;
&lt;p&gt;&lt;code&gt;state&lt;/code&gt; 值得具体区别，参考了这个问题:&lt;/p&gt;
&lt;h3 id=&quot;添加用户---user-模块&quot;&gt;添加用户 - user 模块&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ansible centos -m user -a &quot;name=foo password=&amp;lt;crypted password here&amp;gt;&quot;
//移除用户
ansible all -m user -a 'name=foo state=absent'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;下载-git-仓库---git-模块&quot;&gt;下载 Git 仓库 - git 模块&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ansible centos -m git -a &quot;repo=https://github.com/Michael728/my-config-files.git dest=/tmp/my-config-files version=HEAD&quot;
192.168.3.43 | CHANGED =&amp;gt; {
    &quot;after&quot;: &quot;6faf55b17a1d7c25dfda6f6197839deaa2aa2bd5&quot;,
    &quot;before&quot;: null,
    &quot;changed&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用 git 模块下载了代码库默认分支的最新版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repo&lt;/code&gt; 是必选参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dest&lt;/code&gt; 也是必选参数，指定代码库的下载路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码库地址除了选择用 &lt;code&gt;https&lt;/code&gt; 链接之外，还可以用 &lt;code&gt;ssh&lt;/code&gt; 地址，事实上，公司中大多使用 &lt;code&gt;ssh&lt;/code&gt; 地址会更方便：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ansible centos -m git -a &quot;repo=git@github.com:Michael728/my-config-files.git dest=/tmp/my-config-files version=HEAD accept_hostkey=yes&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;远程主机首次使用 &lt;code&gt;git clone&lt;/code&gt; 命令时，是需要手动接受 knows_hosts 的，这时候加上 &lt;code&gt;accept_hostkey=yes&lt;/code&gt; 可以避免出错&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h3 id=&quot;启动服务---service-模块&quot;&gt;启动服务 - service 模块&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 启动服务
ansible centos -m service -a &quot;name=httpd state=started&quot;
# 重启服务，前提是该服务已经启动了
ansible centos -m service -a &quot;name=httpd state=restarted&quot;
# 重载服务，不会中断服务，如果服务之前未启动，那么会启动服务
ansible centos -m service -a &quot;name=httpd state=reloaded&quot;
# 停止服务
ansible centos -m service -a &quot;name=httpd state=stopped&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;state 有几个可选值&lt;code&gt;(Choices: reloaded, restarted, started, stopped)[Default: (null)]&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;started'/&lt;/code&gt;stopped' are idempotent[幂等] actions that will not run commands unless necessary.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;restarted&lt;/code&gt; will always bounce the service.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reloaded&lt;/code&gt; will always reload. &lt;em&gt;At least one of state and enabled are required.&lt;/em&gt; Note that reloaded will start the service if it is not already started, even if your chosen init system wouldn't normally.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;并行执行重启&quot;&gt;并行执行重启&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ansible centos -a &quot;/sbin/reboot&quot; -f 10&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 参数会 fork 出 10 个子进程，以并行的方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个命令虽然显示是出现问题了，但是我发现虚拟机确实重启了：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ansible all -a &quot;reboot&quot; -f 6
192.168.3.43 | UNREACHABLE! =&amp;gt; {
    &quot;changed&quot;: false,
    &quot;msg&quot;: &quot;Failed to connect to the host via ssh: Shared connection to 192.168.3.43 closed.\r\n&quot;,
    &quot;unreachable&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看远程主机的全部系统信息---setup-模块&quot;&gt;查看远程主机的全部系统信息 - setup 模块&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ansible all -m setup

# 通过 filter 获取某一个 fact 变量
ansible all -m setup -a 'filter=ansible_*mb'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可以发现，ansible Ad-Hoc 的命令使用比较简单，适用于不复杂的场景，如果需要实现复杂的任务，那么就需要通过 ansible-playbook 的方式执行了，下一篇文章中学习它。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Sun, 24 Feb 2019 06:44:00 +0000</pubDate>
<dc:creator>Michael翔</dc:creator>
<og:description>运维 后端 人员对机器初始化等操作的利器 ansible</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/michael-xiang/p/10426159.html</dc:identifier>
</item>
</channel>
</rss>