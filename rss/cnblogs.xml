<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>靠这些秋招秘笈，齐姐的学妹今年已经拿到了 8 个offer！ - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13747935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13747935.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小齐说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在秋招进行时，正在找工作的小伙伴进度都怎么样了呀？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章是我武大的学妹今年秋招的经验分享，庆妹去年才决定转行，现在已手握 N+ 个 offer ～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章干货满满，庆妹对每一块面试考察点都给出非常具体、详细的资料和书籍推荐，我看了都很有启发，希望对你也能有所帮助呀。&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2020 年秋招过了一半了，我目前收到了百度，快手，Shopee，作业帮，TpLlink 的意向书，腾讯，华为和微博面试也已经通过，等待录用。岗位都与后台开发、C++开发有关。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我本身并不是计算机专业，比不上收割 SSP offer 的大佬。这篇文章我就跟大家谈谈&lt;strong&gt;非科班的后台开发求职路线&lt;/strong&gt;吧。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;背景介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;去年这个时候我的编程水平也就是能用 C 语言写 HelloWord 的水平，我的学习路线就是一个真实的纯小白的进化史了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍一下我的编程背景，我研究生就读的武汉大学 xx 学院的二年制专业硕士，研究方向与深度学习有关。本科时上过 C 语言、数据结构、计算机网络这些课程，不过都忘的差不多了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我是专硕，在研究生第一学年结束就要马上开始找工作，所以我在刚入学就有了就业意识。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那时候和 2019 年秋招的一位学长交流了许多，学长拿了武汉字节，上海拼多多的 offer，字节年薪&lt;strong&gt;30 万&lt;/strong&gt;，拼多多年薪&lt;strong&gt;50 万&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从来没有见过这么多钱的我瞬间惊呆了！原来在互联网开发可以赚这么多钱。我对开发工作产生了一些心动。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且学长鼓励我在一年之内是完全能够达到他这样的水平，于是我就初步将后台开发方向作为我的就业方向。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;C++ vs Java?&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择哪一门编程语言？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前秋招后台开发求职主要有两种语言，C++和 java。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 的就业方向更广，阿里美团，银行和一些中小厂技术栈 80% 以上是 Java，生态圈更加完善，比较好提升背景项目。正因为这样，学 Java 的人很多，竞争非常激烈。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选 C++也有优点，腾讯的技术栈主要是 C++，学习 C++可以走算法优化方向，这是算法落地的一个热门方向。而且， C++比 Java 学习的知识点要少。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过去的我确实也在语言的选择上纠结了好久，但是当我走过秋招，发现其实语言并没有想象的那么重要。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做笔试的时候两种编程方式都可以选择。在面试的时候，面试官会针对我们熟悉的语言针对考察。所以无论是 C++还是 Java，甚至是 python 或是 C#都是没问题的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于当时实验室的师兄都用的 C++，如果学习遇到了困难我有人可以问，于是最后我选择了 C++。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;资料分享&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来谈谈学习后台开发需要看的资料，主要分为&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;C++语言&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;数据结构与算法&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;计算机网络&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;操作系统&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;项目经历&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Linux 使用&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;数据库&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;设计模式&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这 8 大部分。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中前五个部分是需要重点准备的，后面三个部分学有余力可以充分准备，没有时间的话了解常考面试题也是可以的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想准备其他语言，除了语言部分，其他部分都是适用的。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;C++ 语言&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看 &lt;em&gt;C++ primer&lt;/em&gt; 前三大部分——C++基础、C++标准库和类设计者的工具，学习 C++基本语法，容器的常用用法，了解 C++11 新特性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进阶阶段推荐看《STL 源码剖析》和 &lt;em&gt;Effective C++&lt;/em&gt;，前者了解 C++容器的底层数据结构，后者涉及了很多 C++面试的内容。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;数据结构与算法&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解数据结构看“如果天空不死”的数据结构部分博客，这个博客利用画图的方式把数据结构用浅显易懂的方式表示出来。看博客时除了排序算法部分要看程序以外，其余部分熟悉概念即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习算法我是上了牛客网左程云老师的算法视频课，我非常推荐这门课程，因为这门课讲解了面试中最常见的数据结构考点和面试算法题考点，还讲解了一些看起来高大上的内容可供面试装逼。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gj63vw6yuhj307705eq2v.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，算法部分还需要通过刷算法题，不断巩固熟练度。《剑指 offer》和 Leetcode 前 hot100 争取刷三遍。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做到以上，面试 90%能遇到原题。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;计算机网络&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看《图解 TCP/IP》，对 TCP/IP 协议有些初步印象&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来看《计算机基础》，只要看有关 TCP 和 IP 协议的部分。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过博客学习 HTTP 协议，例如 CS2018.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进阶阶段需要学习计算机网络编程，看《UNIX 网络编程卷 1》&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;操作系统&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐《深入理解计算机基础》，从第五章虚拟内存开始看。这本书非常经典，能够熟知这本的知识，面试中的操作系统问题绝对没问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;清华大学操作系统课程，学堂在线可看。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些大佬推荐看现代操作系统，Linux 内核这些书，这些书面试中考察的不多，可以以后工作了看。&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;下次一定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;项目准备&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了陈硕《Linux 高性能服务器编程》这本书，基于这本书在 github 上学习了一位大佬写的 web 服务器。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学 C++方向的很多同学都准备了 web 服务器，导致我后期面试跟别人撞车。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目经历可以说是我的弱项了。有精力想要冲大厂的同学，可以看看陈硕的 Module 库，了解下一些开源库的源码，比如 libevent nginx 等。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Linux 使用&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我看了 B 站尚学堂的 Linux 视频教程，课程内容涵盖了大多数面试内容。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;数据库&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基础入门看《MySql 必知必会》，进阶看《高性能服务器》前四章。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;设计模式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学会单例模式和工厂模式这两种模式即可。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;什么时候投简历最好？提前批！&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2020 年疫情期间，我花了三个月把之前提到的学习资料看了一遍，还花了些零零散散的时间看了牛客网上的面试经典问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;六月份，我的秋招之旅便开始了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;七月初很顺利的斩获了我的第一个 offer——Tplink 后端开发。七月份很多互联网知名公司提前批都开始了，于是我开始了疯狂海投、笔试和面试的过程，最忙的时候一天有 5 场面试。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家一定要在提前批抓住机会，不要等到完全做好准备了再投简历。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一是你准备好了，别人也就准备好了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二是很多公司提前批免除了笔试的过程，面试难度也比正式批要小。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三是到了正式批，很多人会学会搞骚操作。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我了解到居然有一个实验室的人同时帮一个同学做笔试的情况，我就说怎么到了正式批我的笔试通过率变低了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;面试是一个查漏补缺的过程，面试完之后做好总结，“以战养战”才是进步最快的方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;七月中旬牛客做了一个 SP 提前批专场的活动，每个公司都有投，虽然说多数毫无音信，甚至一些不太知名的游戏公司直接通知我简历不过，把我气的半死，不过我最想去的 Shoppe 通过了简历筛选，免除了笔试环节，要知道笔试就要挂很多人。最后我的 offer 基本上都是在提前批拿到的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然找工作免不了焦虑的时候。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;八月上旬字节提前批三面挂，网易互娱一面挂，快手 HR 面之后也没有准信，那段时间真的有些低气压。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我不是一个心态很好的人，失败的时候就会生气焦虑。我也不喜欢给自己灌鸡汤，找不到工作我就是烦。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得这很正常啊，是个人找不到心仪的工作都会很崩溃，那段时间经常我还经常跟我妈吵架。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可生活不能老这样，我得调节自己，烦躁的时候我就啥也不干，玩玩手机，放空自己。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在找工作期间我还养了两只小乌龟，他们太可爱了，看着他们就特别解压。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，找工作别看牛客，一堆大佬 show 自己收到大佬 offer，越看越烦。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gj642rn5wzj3069069dfp.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;八月中旬心态崩溃，去长沙玩了一圈，回到家隔天收到了 Shopee 意向书，心里放松了大半。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后的过程也慢慢的越来越顺利，继续笔试面试的过程，在九月初赶在开学前收获了百度，快手的意向书。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到学校以后，由于导师盯得紧，能面试的时间很少。所以接下来的阶段，主要是利用有限的时间冲冲大厂，再准备一些心仪的国企银行。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，互联网也许不是人生的最优解，毕竟容易出现中年危机不是？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是无论是去国企还是银行，都需要提前准备的意识。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果大家有准备前端算法或者其他方向的，可以参考这下面这个牛客网址：&lt;code&gt;https://www.nowcoder.com/discuss/351700&lt;/code&gt;&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢庆妹的无私分享，也祝庆妹在接下来的面试中一切顺利，好好享受最后一年学生时光，齐姐真是羡慕你们呀～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是小齐，纽约程序媛，终生学习者，每天晚上 9 点，云自习室里不见不散！&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;更多干货文章见我的 Github: https://github.com/xiaoqi6666/NYCSDE&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 29 Sep 2020 00:39:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>小齐说： 现在秋招进行时，正在找工作的小伙伴进度都怎么样了呀？ 今天这篇文章是我武大的学妹今年秋招的经验分享，庆妹去年才决定转行，现在已手握 N+ 个 offer ～ 这篇文章干货满满，庆妹对每一块面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13747935.html</dc:identifier>
</item>
<item>
<title>和低效 IO 说再见，回头补一波 Java 7 的 NIO.2 特性 - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/13742641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/13742641.html</guid>
<description>&lt;p&gt;朋友，你知道Java 里一行代码读取、写入、复制文件的写法吗？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;195.68395390071&quot;&gt;
&lt;p&gt;其实在这之前已经写过一篇关于 Java 7 的新特性文章了，那篇文章主要介绍了 Java 7 的资源自动关闭、Switch String 实现原理、异常捕获 try-catch、新的二进制书写方式等，具体的内容也可以看下当初的这篇文章（&lt;a href=&quot;https://mp.weixin.qq.com/s/fdW1wwcYgg0INixN4BtgbQ&quot;&gt;补一波 Java 7 语法特性&lt;/a&gt;）。而在那篇文章里唯独没有介绍到 Java 7 中对于 IO 操作的更新，而这部分恰好又是非常重要的一部分，该还的总是要还的，现在补上。&lt;/p&gt;
&lt;p&gt;看完这篇文章你会了解到：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;抽象文件路径&lt;/strong&gt;操作方式，直观方便少 BUG。&lt;/li&gt;
&lt;li&gt;高效的文件操作方式，&lt;strong&gt;写入读取复制文件仅需一行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;快速获取不同系统下的&lt;strong&gt;文件属性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;遍历目录下文件和目录的&lt;strong&gt;多种方式&lt;/strong&gt;，且十分高效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反应式&lt;/strong&gt;事件通知，监测文件变化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 Java 7 中，加强了文件操作相关功能，也就是新的 java.nio.file 包里的内容，它提供了诸如文件路径抽象、文件目录流、目录树、文件属性和变化监视服务等功能，可以大幅度提高我们对于文件的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200920215435075.png&quot; alt=&quot;NIO.2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;文件路径&quot;&gt;文件路径&lt;/h2&gt;
&lt;p&gt;在 Java 7 之前对&lt;strong&gt;文件路径&lt;/strong&gt;的操作都是以&lt;strong&gt;字符串&lt;/strong&gt;的操作，使用时你需要把一个字符串直接扔进去，直接使用字符串操作是低效的，比如你要拼接父路径和子目录，你只能进行字符串的拼接。而且拼接这个本身操作就丢失了它作为文件路径的含义。另外使用字符串进行各种路径操作很有可能由于拼写错误而出现各种问题。&lt;/p&gt;
&lt;p&gt;Java 7 的到来让这一切变的不一样了，它提供了 Path 接口用来表示路径的抽象，然后提供了一系列对于路径的操作方法，让这一切变得如此简单。&lt;/p&gt;
&lt;p&gt;为了方便的创建 Path 对象，又提供了Paths 工具类，如何使用让我们先睹为快。&lt;/p&gt;
&lt;p&gt;一切都从 &lt;code&gt;Path path = Paths.get(&quot;/Users/darcy/java/&quot;);&lt;/code&gt; 获取一个 Path 对象开始。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Path path = Paths.get(&quot;/Users/darcy/java/&quot;);
System.out.println(&quot;完整路径：&quot; + path.toString());

Path pathParent = path.getParent();
System.out.println(&quot;父级路径：&quot; + pathParent.toString());

Path pathRoot = path.getRoot();
System.out.println(&quot;根目录：&quot; + pathRoot.toString());

int pathNameCount = path.getNameCount();
System.out.println(&quot;目录深度：&quot; + pathNameCount);

Path pathIndex3 = path.getName(2);
System.out.println(&quot;第三级目录：&quot; + pathIndex3);

Path subPath = path.subpath(1, 3);
System.out.println(&quot;第1级目录到第三级目录（包左不包右）：&quot; + subPath.toString());

// resolveSibling 从当前目录父目录开始拼接目录
Path pathResolveSibling = path.resolveSibling(&quot;PathDemo.java&quot;);
System.out.println(&quot;父目录开始拼接参数：&quot; + pathResolveSibling.toString());

// resolve 把当前路径当作父路径，参数作为子目录或者文件
Path pathResolve = Paths.get(&quot;/Users/darcy/java/&quot;).resolve(&quot;PathDem.java&quot;);
System.out.println(&quot;当前目录拼接后的目录：&quot; + pathResolve.toString());

// 参数路径相对于主体路径的相对路径
Path path1 = Paths.get(&quot;/Users/darcy/&quot;);
Path path2 = Paths.get(&quot;/Users/darcy/java/PathDemo.java&quot;);
Path path3 = path1.relativize(path2);
System.out.println(&quot;相对路径：&quot; + path3.toString());

/* 输出结果
完整路径：/Users/darcy/java
父级路径：/Users/darcy
根目录：/
目录深度：3
第三级目录：java
第1级目录到第三级目录（包左不包右）：darcy/java
父目录开始拼接参数：/Users/darcy/PathDemo.java
当前目录拼接后的目录：/Users/darcy/java/PathDem.java
相对路径：java/PathDemo.java
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到上面代码里除了创建 Path 对象时输入了一次路径，后续的操作都是使用 Path 中的方法进行操作的，在此之前你可能需要各种字符串截取拼接，十分繁琐。&lt;/p&gt;
&lt;h2 id=&quot;文件操作&quot;&gt;文件操作&lt;/h2&gt;
&lt;p&gt;还记得初学 Java IO 时，文件复制有多种写法，但是不管是哪一种，写起来都需要不少的代码，而且还需要考虑复制时的性能。读取文件那就更不用说了，定义各种读取和接收变量，各种验证。现在不一样了，不仅文件操作非常方便，而且像文件&lt;strong&gt;复制和读取&lt;/strong&gt;等常用操作都可以&lt;strong&gt;一行搞定&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用过于简单，直接代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 如果文件不存在，则创建一个文件
Path path = Paths.get(&quot;test.txt&quot;);
Path pathBackup = Paths.get(&quot;test_bak.txt&quot;);
Path pathLink = Paths.get(&quot;test.txt.link&quot;);
Path pathDir = Paths.get(&quot;dir&quot;);

// 已存在则删除
Files.deleteIfExists(path);
Files.deleteIfExists(pathBackup);
Files.deleteIfExists(pathLink);
Files.deleteIfExists(pathDir);

// 创建文件写入内容
Path file = Files.createFile(path);
Files.write(path, &quot;关注公众号：未读代码&quot;.getBytes());
Files.write(path, System.lineSeparator().getBytes(), StandardOpenOption.APPEND);
Files.write(path, &quot;欢迎加我微信：wn8398&quot;.getBytes(), StandardOpenOption.APPEND);
System.out.println(&quot;创建文件：&quot; + file.toString());

// 创建文件链接
pathLink = Files.createLink(pathLink, path);
System.out.println(&quot;创建文件：&quot; + pathLink.toString());

// 创建目录
Path directory = Files.createDirectory(pathDir);
System.out.println(&quot;创建目录：&quot; + directory.toString());

// 文件复制
Files.copy(path, pathBackup);
System.out.println(&quot;复制文件: &quot; + path + &quot; --&amp;gt; &quot; + pathBackup);

// 读取文件
List&amp;lt;String&amp;gt; lines = Files.readAllLines(pathBackup);
for (String line : lines) {
    System.out.println(&quot;文件读取：&quot; + line);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面展示了 Files 类的文件创建、删除、写入、拷贝、读取的写法，都是只有一行代码。&lt;/p&gt;
&lt;h2 id=&quot;文件属性&quot;&gt;文件属性&lt;/h2&gt;
&lt;p&gt;和路径操作类似，Java 7 也提供了文件属性的抽象，增加了一系列文件属性的操作工具类。这部分代码在 &lt;code&gt;java.nio.file.attribute&lt;/code&gt; 包内。它抽象出了一个 AttributeView 作为所有属性视图的父接口，然后用它的子类 Fi leAttributeView 表示文件视图，用子类 FileOwnerAttributeView 表示文件所有者的属性视图。前者属性如文件的创建时间、修改时间、是否目录等信息，后者则包含文件的相关信息。为了兼容不同的操作系统，Java 7 还提供了不同实现，如 DosFileAttributeView 视图，很明显他是为 Windows 操作系统准备的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200921115536094.png&quot; alt=&quot;Java7 文件属性&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用起来过于简单，直接代码奉上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Path path = Paths.get(&quot;/Users/darcy/git/jdk-feature/README.md&quot;);
BasicFileAttributeView fileAttributeView = Files.getFileAttributeView(path, BasicFileAttributeView.class);
BasicFileAttributes basicFileAttributes = fileAttributeView.readAttributes();
FileTime creationTime = basicFileAttributes.creationTime();
FileTime lastModifiedTime = basicFileAttributes.lastModifiedTime();
FileTime lastAccessTime = basicFileAttributes.lastAccessTime();
System.out.println(&quot;创建时间：&quot; + creationTime);
System.out.println(&quot;上次修改时间：&quot; + lastModifiedTime);
System.out.println(&quot;上次访问时间：&quot; + lastAccessTime);

boolean directory = basicFileAttributes.isDirectory();
boolean regularFile = basicFileAttributes.isRegularFile();
boolean symbolicLink = basicFileAttributes.isSymbolicLink();
System.out.println(&quot;是否目录：&quot; + directory);
System.out.println(&quot;是否普通文件：&quot; + regularFile);
System.out.println(&quot;是否符号链接：&quot; + symbolicLink);

long size = basicFileAttributes.size();
System.out.println(&quot;文件大小：&quot; + size);

PosixFileAttributeView linuxFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class);
UserPrincipal owner = linuxFileAttributeView.getOwner();
System.out.println(&quot;文件归属用户:&quot; + owner.getName());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码运行后得到如下输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;创建时间：2020-09-06T13:35:14Z
上次修改时间：2020-09-06T13:35:14.649261371Z
上次访问时间：2020-09-06T13:35:14.680968254Z
是否目录：false
是否普通文件：true
是否符号链接：false
文件大小：3636
文件归属用户:darcy
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件列表流&quot;&gt;文件列表流&lt;/h2&gt;
&lt;p&gt;在 Java 7 之前遍历文件目录和文件，你应该会选择 File 类的 listFiles 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 文件直接遍历，不会遍历子目录
String pathString = &quot;/Users/darcy/project/mylab/src/main/java/com/wdbyte/java&quot;;
File file = new File(pathString);
File[] listFiles = file.listFiles();
for (File tempFile : listFiles) {
    System.out.println(&quot;file list: &quot; + tempFile.getAbsolutePath());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种遍历方式看起来也是十分优雅的，可是这种方式在面对大量文件时，&lt;strong&gt;效率会变的很低&lt;/strong&gt;。所以 Java 7 也对此进行了改进，引入了 &lt;strong&gt;DirectoryStream&lt;/strong&gt; 文件列表流。它可以进行&lt;strong&gt;渐进式&lt;/strong&gt;的文件遍历，每次读取一定数量，降低遍历时的性能开销，但是 DirectoryStream 遍历时只会遍历它的直接目录和文件，不会递归的遍历子目录。下面是它的遍历写法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String pathString = &quot;/Users/darcy/project/mylab/src/main/java/com/wdbyte/java&quot;;
// Path 直接遍历方式，不会遍历子目录
try (DirectoryStream&amp;lt;Path&amp;gt; directoryStream = Files.newDirectoryStream(Paths.get(pathString))) {
    for (Path pathTemp : directoryStream) {
        System.out.println(&quot;DirectoryStream: &quot; + pathTemp);
    }
}

// Path 直接遍历方式 - 筛选 .class 文件
try (DirectoryStream&amp;lt;Path&amp;gt; directoryStream = Files.newDirectoryStream(Paths.get(pathString), &quot;*.java&quot;)) {
    for (Path pathTemp : directoryStream) {
        System.out.println(&quot;DirectoryStream file type is class : &quot; + pathTemp);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里扩展一下，在 Java 8 中对 Files 类进行了增强，引入了 Java 8 的 Lambda 表达式，增加了 walk 方法，遍历文件也有异曲同工之妙（下面的例子中用到了 Lambda 表达式）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 遍历所有目录和子目录
Stream&amp;lt;Path&amp;gt; pathStream = Files.walk(Paths.get(&quot;/Users/darcy/project/mylab/src/main/java/com/wdbyte&quot;));
pathStream.forEach(pathTemp -&amp;gt; {
    System.out.println(&quot;Stream: &quot; + pathTemp.toString());
});

// 遍历所有目录和子目录 - 筛选 java 文件
pathStream = Files.walk(Paths.get(&quot;/Users/darcy/project/mylab/src/main/java/com/wdbyte&quot;));
pathStream
    .filter(pathTemp -&amp;gt; pathTemp.toString().endsWith(&quot;.java&quot;))
    .forEach(pathTemp -&amp;gt; {
        System.out.println(&quot;Stream filter java: &quot; + pathTemp.toString());
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件监视&quot;&gt;文件监视&lt;/h2&gt;
&lt;p&gt;文件监视，也就是可以动态的监测指定目录的文件或者内容的变化，应用场景很多，比如热部署时检查 class 文件是否更新，或者每当有文件进来时就进行操作。在这之前你只能通过循环调用 listFiles 并与上次的调用结果对比才可以找到文件的变化，而现在可以通过通知的方式进行反应式的逻辑处理，一切变的简单了。&lt;/p&gt;
&lt;p&gt;被监视的对象要实现 Watchable 接口，然后通过 register 方法注册到监视服务 WatchService 接口的实现，同时指定要监视的事件类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 创建
StandardWatchEventKinds.ENTRY_CREATE,
// 删除
StandardWatchEventKinds.ENTRY_DELETE,
// 更新
StandardWatchEventKinds.ENTRY_MODIFY
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体怎么使用呢？通过下面这个例子看下代码如何实现，下面的代码对文件夹 &lt;code&gt;/Users/darcy/test&lt;/code&gt; 进行监测，注册的感兴趣事件是创建、删除、更新操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;WatchService watchService = FileSystems.getDefault().newWatchService();
Path path = Paths.get(&quot;/Users/darcy/test&quot;);
path.register(watchService,
    StandardWatchEventKinds.ENTRY_CREATE,
    StandardWatchEventKinds.ENTRY_DELETE,
    StandardWatchEventKinds.ENTRY_MODIFY);

while (true) {
    WatchKey watchKey = watchService.take();
    // 获取事件类型
    for (WatchEvent&amp;lt;?&amp;gt; pollEvent : watchKey.pollEvents()) {
        // 具体的事件上下文信息
        Path tempPath = (Path)pollEvent.context();
        Kind&amp;lt;?&amp;gt; kind = pollEvent.kind();
        if (kind.name().equals(StandardWatchEventKinds.ENTRY_CREATE.name())) {
            System.out.println(&quot;创建了一个文件：&quot; + tempPath.toString());
        }
        if (kind.name().equals(StandardWatchEventKinds.ENTRY_DELETE.name())) {
            System.out.println(&quot;删除了一个文件：&quot; + tempPath.toString());
        }
        if (kind.name().equals(StandardWatchEventKinds.ENTRY_MODIFY.name())) {
            System.out.println(&quot;修改了一个文件：&quot; + tempPath.toString());
        }
    }
    // 事件处理完毕后要进行 reset 才能继续监听事件
    watchKey.reset();
    // 取消监视
    // watchKey.cancel();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册事件监听后，通过一个循环，调用 take() 方法获取事件结果，得到事件后再判断事件类型进行日志输出。我启动后进行了简单测试，下面是日志输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 下面是我的操作
➜  test pwd 
/Users/darcy/test
➜  test touch test.txt # 创建文件
➜  test vim test.txt # 修改文件
➜  test rm test.txt # 删除文件
# 得到的日志输出
创建了一个文件：test.txt
创建了一个文件：.test.txt.swp
修改了一个文件：test.txt
删除了一个文件：.test.txt.swp
删除了一个文件：test.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为使用 vim 编辑，所以有临时的 swp 文件生成和自动删除，也被监测到了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;往期 Java 新特性系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后的话&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.2348178137652&quot;&gt;
&lt;p&gt;文章已经收录在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，欢迎Star和指教。更有一线大厂面试点，Java程序员需要掌握的核心知识等文章，也整理了很多我的文字，欢迎 &lt;strong&gt;Star&lt;/strong&gt; 和完善，希望我们一起变得优秀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章有帮助可以点个「&lt;strong&gt;赞&lt;/strong&gt;」或「&lt;strong&gt;分享&lt;/strong&gt;」，都是支持，我都喜欢！&lt;br/&gt;文章每周持续更新，要实时关注我更新的文章以及分享的干货，可以关注「 &lt;strong&gt;未读代码&lt;/strong&gt; 」公众号或者&lt;a href=&quot;https://www.wdbyte.com/&quot;&gt;我的博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets@439f6a5f6bd130e2aec56f3527656d6edb487b91/webinfo/weixin-public.jpg&quot; alt=&quot;公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 29 Sep 2020 00:34:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>朋友，你知道Java 里一行代码读取、写入、复制文件的写法吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/13742641.html</dc:identifier>
</item>
<item>
<title>树莓派3B+安装64位ubuntu系统和docker工具 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13747866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13747866.html</guid>
<description>&lt;p&gt;想在树莓派3B上安装一些64位应用(例如64位JDK)，因此首先要安装64位的操作系统，今天咱们就一起来实战；&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/80716098&quot;&gt;https://blog.csdn.net/boling_cavalry/article/details/80716098&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;环境要求&quot;&gt;环境要求&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一台树莓派3B设备；&lt;/li&gt;
&lt;li&gt;网络环境是内网，&lt;span&gt;需要有线网络和网线一根&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;当树莓派通过网线连接到内网后，能够在路由器管理软件上查到树莓派的IP，例如我用的是小米路由器，通过路由器管理页面或者小米路由器的APP就能看到树莓派的接入情况；&lt;/li&gt;
&lt;li&gt;读卡器；&lt;/li&gt;
&lt;li&gt;电脑一台，系统是windows10；&lt;/li&gt;
&lt;li&gt;电脑上安装了SecureCRT、SDFormatter、Win32DiskImager这三个软件；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;操作步骤列表&quot;&gt;操作步骤列表&lt;/h3&gt;
&lt;p&gt;先把所有操作步骤梳理一遍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载64位操作系统镜像；&lt;/li&gt;
&lt;li&gt;格式化存储卡；&lt;/li&gt;
&lt;li&gt;烧录镜像到存储卡；&lt;/li&gt;
&lt;li&gt;启动树莓派；&lt;/li&gt;
&lt;li&gt;远程连接；&lt;/li&gt;
&lt;li&gt;基本设置；&lt;/li&gt;
&lt;li&gt;安装64位应用，验证；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;准备完毕就开始实战吧；&lt;/p&gt;
&lt;h3 id=&quot;下载64位操作系统镜像&quot;&gt;下载64位操作系统镜像&lt;/h3&gt;
&lt;p&gt;有大神将64位镜像做好了放到GitHub上，地址：&lt;a href=&quot;https://github.com/bamarni/pi64/releases%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%8C%E6%9C%89%E6%A1%8C%E9%9D%A2%E7%89%88%E5%92%8C%E9%9D%9E%E6%A1%8C%E9%9D%A2%E7%89%88%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AF%E9%9D%9E%E6%A1%8C%E9%9D%A2%E7%89%88%E6%9C%AC%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E7%BA%A2%E6%A1%86%E6%89%80%E7%A4%BA%EF%BC%9A&quot;&gt;https://github.com/bamarni/pi64/releases，如下图所示，有桌面版和非桌面版，我选择的是非桌面版本，如下图红框所示：&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200929073045094-1046251617.png&quot; alt=&quot;这里写图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载完成后解压，得到文件&lt;span&gt;pi64-lite.img&lt;/span&gt;，500M不到；&lt;/p&gt;
&lt;h3 id=&quot;格式化存储卡&quot;&gt;格式化存储卡&lt;/h3&gt;
&lt;p&gt;将存储卡插入读卡器，将读卡器插入电脑，然后启动SDFormatter软件，点击右下角的&lt;span&gt;格式化&lt;/span&gt;按钮即可开始格式化，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200929073045633-243129257.png&quot; alt=&quot;这里写图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在格式化过程中可能提示格式化失败，如下图，这时候再格式化一次就会成功：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200929073045944-50549673.png&quot; alt=&quot;这里写图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;烧录镜像到存储卡&quot;&gt;烧录镜像到存储卡&lt;/h3&gt;
&lt;p&gt;打开Win32DiskImager，选择刚刚下载的pi64-lite.img文件，点击&lt;span&gt;Write&lt;/span&gt;按钮开始烧录，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200929073046385-511468487.png&quot; alt=&quot;这里写图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;烧录完毕后，将存储卡插入树莓派的卡槽；&lt;/p&gt;
&lt;h3 id=&quot;启动树莓派&quot;&gt;启动树莓派&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;将接入内网的网线插入树莓派的网口；&lt;/li&gt;
&lt;li&gt;接电，启动树莓派；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;远程连接&quot;&gt;远程连接&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;通过路由器的管理系统查到树莓派的IP地址，例如我用的是小米路由器的安卓APP，如下图所示，红框中就是树莓派设备，点进去就能看到IP，假设这里IP地址是&lt;span&gt;192.168.31.86&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200929073048638-1290819667.png&quot; alt=&quot;这里写图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;打开SecureCRT，新建一个和树莓派的SSH连接，用户名&lt;span&gt;pi&lt;/span&gt;，密码&lt;span&gt;raspberry&lt;/span&gt;，连接成功，显示如下信息：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Linux raspberrypi 4.11.12-pi64+ #1 SMP PREEMPT Sun Jul 30 20:18:20 CEST 2017 aarch64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sat Jun 16 15:40:41 2018 from 192.168.31.180
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;3. 用&lt;span&gt;uname -a&lt;/span&gt;和&lt;span&gt;getconf LONG_BIT&lt;/span&gt;这两个命令来验证是否是64位系统，如下： ```shell root@raspberrypi:/home/pi# uname -a Linux raspberrypi 4.11.12-pi64+ #1 SMP PREEMPT Sun Jul 30 20:18:20 CEST 2017 aarch64 GNU/Linux root@raspberrypi:/home/pi# getconf LONG_BIT 64 ``` 确实是64位系统；
&lt;h3 id=&quot;基本设置&quot;&gt;基本设置&lt;/h3&gt;
&lt;p&gt;接下来做一些基本设置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先是修改root密码，然后我们就可以用root账号进行各种操作了，命令是&lt;span&gt;sudo passwd root&lt;/span&gt;，按照提示输入两遍新的root密码，然后就可以su到root身份了；&lt;/li&gt;
&lt;li&gt;以root身份执行命令&lt;span&gt;apt-get update&lt;/span&gt;，做一次更新；&lt;/li&gt;
&lt;li&gt;接下来我们来做一些基本设置，例如时区、hostname、无限网络等，以root身份输入命令&lt;span&gt;pi64-config&lt;/span&gt;，会出现如下界面，请按照自己所需去逐个设置：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200929073049424-1792202379.png&quot; alt=&quot;这里写图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;WIFI设置完毕后，在路由器管理页面上就能看见最新以无线方式接入的树莓派设备了，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200929073052353-1059420838.png&quot; alt=&quot;这里写图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;这时候可以拔掉网线了，记下无线接入的树莓派的IP，然后在SecureCRT新建一个和树莓派的SSH连接；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;安装64位应用，验证&quot;&gt;安装64位应用，验证&lt;/h3&gt;
&lt;p&gt;本次验证用的是64位JDK：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装vi工具，执行命令&lt;span&gt;apt-get install vim -y&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;先在树莓派上安装上传下载的工具，执行命令&lt;span&gt;apt-get install lrzsz -y&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;在电脑上进入JDK下载网页，地址：&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%8C%E9%A6%96%E5%85%88%E8%A6%81%E7%82%B9%E5%87%BB%E7%BB%BF%E6%A1%86%E4%B8%AD%E7%9A%84%E9%80%89%E9%A1%B9%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E7%BA%A2%E6%A1%86%E4%B8%AD%E7%9A%84&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html，如下图，首先要点击绿框中的选项，然后点击红框中的&lt;/a&gt;&lt;span&gt;jdk-8u172-linux-arm64-vfp-hflt.tar.gz&lt;/span&gt;，这才是树莓派可用的版本：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200929073054044-1947914920.png&quot; alt=&quot;这里写图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;文件下载完毕后，在SecureCRT上执行rz命令，将文件下载到树莓派；&lt;/li&gt;
&lt;li&gt;在SecureCTR上执行命令&lt;span&gt;tar -zxvf jdk-8u172-linux-arm64-vfp-hflt.tar.gz&lt;/span&gt;，解压文件；&lt;/li&gt;
&lt;li&gt;将解压后的文件夹移动到/usr/local目录下：&lt;span&gt;mv jdk1.8.0_172 /usr/local/&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;打开文件/etc/profile，添加以下内容：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export JAVA_HOME=/usr/local/jdk1.8.0_172
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib/dt.JAVA_HOME/lib/tools.jar:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:${PATH}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;8. 使配置立即生效：&lt;span&gt;source /etc/profile&lt;/span&gt;； 9. 查看当前java版本信息：&lt;span&gt;java -version&lt;/span&gt;，可以看到如下基本内容： ```shell root@raspberrypi:/usr/local/jdk1.8.0_172# java -version java version &quot;1.8.0_172&quot; Java(TM) SE Runtime Environment (build 1.8.0_172-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.172-b11, mixed mode) ```
&lt;p&gt;至此，树莓派上安装64位系统成功，并且验证成功；&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Sep 2020 23:31:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>想在树莓派3B上安装一些64位应用(例如64位JDK)，因此首先要安装64位的操作系统，今天咱们就一起来实战； 原文地址：https://blog.csdn.net/boling_cavalry/ar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13747866.html</dc:identifier>
</item>
<item>
<title>详细分析 Java 中启动线程的正确和错误方式 - 踏雪彡寻梅</title>
<link>http://www.cnblogs.com/txxunmei/p/13747631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/txxunmei/p/13747631.html</guid>
<description>&lt;h2 id=&quot;前文回顾&quot;&gt;前文回顾&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/txxunmei/p/13733332.html&quot;&gt;详细分析 Java 中实现多线程的方法有几种?(从本质上出发)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;start-方法和-run-方法的比较&quot;&gt;start 方法和 run 方法的比较&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码演示:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * &amp;lt;p&amp;gt;
 * start() 和 run() 的比较
 * &amp;lt;/p&amp;gt;
 *
 * @author 踏雪彡寻梅
 * @version 1.0
 * @date 2020/9/20 - 16:15
 * @since JDK1.8
 */
public class StartAndRunMethod {
    public static void main(String[] args) {
        // run 方法演示
        // 输出: name: main
        // 说明由主线程去执行的, 不符合新建一个线程的本意
        Runnable runnable = () -&amp;gt; {
            System.out.println(&quot;name: &quot; + Thread.currentThread().getName());
        };
        runnable.run();

        // start 方法演示
        // 输出: name: Thread-0
        // 说明新建了一个线程, 符合本意
        new Thread(runnable).start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上示例可以分析出以下两点:&lt;/p&gt;
&lt;h2 id=&quot;start-方法分析&quot;&gt;start 方法分析&lt;/h2&gt;
&lt;h3 id=&quot;start-方法的含义以及注意事项&quot;&gt;start 方法的含义以及注意事项&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt; 方法可以启动一个新线程。&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;线程对象在初始化之后调用了 &lt;code&gt;start&lt;/code&gt; 方法之后, 当前线程(通常是主线程)会请求 JVM 虚拟机如果有空闲的话来启动一下这边的这个新线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;也就是说, 启动一个新线程的本质就是请求 JVM 来运行这个线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;至于这个线程何时能够运行，并不是简单的由我们能够决定的，而是由线程调度器去决定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果它很忙，即使我们运行了 &lt;code&gt;start&lt;/code&gt; 方法，也不一定能够立刻的启动线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所以说 &lt;code&gt;srtart&lt;/code&gt; 方法调用之后，并不意味这个方法已经开始运行了。它可能稍后才会运行，也很有可能很长时间都不会运行，比如说遇到了饥饿的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这也就印证了有些情况下，线程 1 先掉用了 &lt;code&gt;start&lt;/code&gt; 方法，而线程 2 后调用了 &lt;code&gt;start&lt;/code&gt; 方法，却发现线程 2 先执行线程 1 后执行的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;总结: 调用 &lt;code&gt;start&lt;/code&gt; 方法的顺序并不能决定真正线程执行的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt; 方法会牵扯到两个线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第一个就是主线程，因为我们必须要有一个主线程或者是其他的线程(哪怕不是主线程)来执行这个 &lt;code&gt;start&lt;/code&gt; 方法，第二个才是新的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;很多情况下会忽略掉为我们创建线程的这个主线程，不要误以为调用了 &lt;code&gt;start&lt;/code&gt; 就已经是子线程去执行了，这个语句其实是主线程或者说是父线程来执行的，被执行之后才去创建新线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt; 方法创建新线程的准备工作&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先，它会让自己处于就绪状态。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就绪状态指已经获取到除了 CPU 以外的其他资源, 如已经设置了上下文、栈、线程状态以及 PC(PC 是一个寄存器，PC 指向程序运行的位置) 等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;做完这些准备工作之后，就万事俱备只欠东风了，东风就是 CPU 资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;做完准备工作之后，线程才能被 JVM 或操作系统进一步去调度到执行状态等待获取 CPU 资源，然后才会真正地进入到运行状态执行 &lt;code&gt;run&lt;/code&gt; 方法中的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;需要注意: 不能重复的执行 start 方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* &amp;lt;p&amp;gt;
* 演示不能重复的执行 start 方法(两次及以上), 否则会报错
* &amp;lt;/p&amp;gt;
*
* @author 踏雪彡寻梅
* @version 1.0
* @date 2020/9/20 - 16:47
* @since JDK1.8
*/
public class CantStartTwice {
    public static void main(String[] args) {
        Runnable runnable = () -&amp;gt; {
            System.out.println(&quot;name: &quot; + Thread.currentThread().getName());
        };
        Thread thread = new Thread(runnable);
        // 输出: name: Thread-0
        thread.start();
        // 输出: 抛出 java.lang.IllegalThreadStateException
        // 即非法线程状态异常(线程状态不符合规定)
        thread.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;报错的原因&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;start&lt;/code&gt; 一旦开始执行，线程状态就从最开始的 New 状态进入到后续的状态，比如说 Runnable，然后一旦线程执行完毕，线程就会变成终止状态，而终止状态永远不可能再返回回去，所以会抛出以上异常，也就是说不能回到初始状态了。这里描述的还不够清晰，让我们来看看源码能了解的更透彻。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;start-方法源码分析&quot;&gt;start 方法源码分析&lt;/h3&gt;
&lt;h4 id=&quot;源码&quot;&gt;源码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public synchronized void start() {
    /**
     * This method is not invoked for the main method thread or &quot;system&quot;
     * group threads created/set up by the VM. Any new functionality added
     * to this method in the future may have to also be added to the VM.
     *
     * A zero status value corresponds to state &quot;NEW&quot;.
     */
    // 第一步, 检查线程状态是否为初始状态, 这里也就是上面抛出异常的原因
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    /* Notify the group that this thread is about to be started
     * so that it can be added to the group's list of threads
     * and the group's unstarted count can be decremented. */
    // 第二步, 加入线程组
    group.add(this);

    boolean started = false;
    try {
        // 第三步, 调用 start0 方法
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
              it will be passed up the call stack */
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;源码中的流程&quot;&gt;源码中的流程&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;&lt;br/&gt;启动新线程时会首先检查线程状态是否为初始状态, 这也是以上抛出异常的原因。即以下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (threadStatus != 0)
        throw new IllegalThreadStateException();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;threadStatus&lt;/code&gt; 这个变量的注释如下，也就是说 Java 的线程状态最初始(还没有启动)的时候表示为 0:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/* Java thread status for tools,
 * initialized to indicate thread 'not yet started'
 */
private volatile int threadStatus = 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步:&lt;/strong&gt;&lt;br/&gt;将其加入线程组。即以下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;group.add(this);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步:&lt;/strong&gt;&lt;br/&gt;最后调用 &lt;code&gt;start0()&lt;/code&gt; 这个 native 方法(native 代表它的代码不是由 Java 实现的，而是由 C/C++ 实现的，具体实现可以在 JDK 里面看到，了解即可), 即以下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean started = false;
try {
    // 第三步, 调用 start0 方法
    start0();
    started = true;
} finally {
    try {
        if (!started) {
            group.threadStartFailed(this);
        }
    } catch (Throwable ignore) {
        /* do nothing. If start0 threw a Throwable then
          it will be passed up the call stack */
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;run-方法分析&quot;&gt;run 方法分析&lt;/h2&gt;
&lt;h3 id=&quot;run-方法源码分析&quot;&gt;run 方法源码分析&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void run() {
    // 传入了 target 对象(即 Runnable 接口的实现), 执行传入的 target 对象的 run 方法
    if (target != null) {
        target.run();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对于-run-方法的两种情况&quot;&gt;对于 run 方法的两种情况&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第一种: 重写了 &lt;code&gt;Thread&lt;/code&gt; 类的 &lt;code&gt;run&lt;/code&gt; 方法，&lt;code&gt;Thread&lt;/code&gt; 的 &lt;code&gt;run&lt;/code&gt; 方法会失效, 将会执行重写的 &lt;code&gt;run&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第二种: 传入了 &lt;code&gt;target&lt;/code&gt; 对象(即 &lt;code&gt;Runnable&lt;/code&gt; 接口的实现)，执行 &lt;code&gt;Thread&lt;/code&gt; 的原有 &lt;code&gt;run&lt;/code&gt; 方法然后接着执行 &lt;code&gt;target&lt;/code&gt; 对象的 &lt;code&gt;run&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 方法就是一个普通的方法, 上文中直接去执行 &lt;code&gt;run&lt;/code&gt; 方法也就是相当于我们执行自己写的普通方法一样，所以它的执行线程就是我们的主线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所以要想真正的启动线程，不能直接调用 &lt;code&gt;run&lt;/code&gt; 方法，而是要调用 &lt;code&gt;start&lt;/code&gt; 方法，其中可以间接的调用 &lt;code&gt;run&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;如有写的不足的，请见谅，请大家多多指教。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Sep 2020 16:11:00 +0000</pubDate>
<dc:creator>踏雪彡寻梅</dc:creator>
<og:description>启动线程的正确和错误方式 前文回顾 详细分析 Java 中实现多线程的方法有几种?(从本质上出发) start 方法和 run 方法的比较 代码演示: /** * &amp;amp;lt;p&amp;amp;gt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/txxunmei/p/13747631.html</dc:identifier>
</item>
<item>
<title>【译】使用 WebView2 将最好的 Web 带到 .NET 桌面应用程序中 - MeteorSeed</title>
<link>http://www.cnblogs.com/MeteorSeed/p/13690556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeteorSeed/p/13690556.html</guid>
<description>&lt;p&gt;今天，我们很高兴地宣布 .NET 应用程序的 WebView2 预览版发布了！它可以在 WPF、Windows Form和 WinUI 3.0 应用程序中使用，一直到 Windows 7。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;88.5277116627&quot;&gt;
&lt;p&gt;　　在去年的 Build 大会上，我们引入了 WebView2，这是一个浏览器控件，可以用新的基于 Chrome 的 Microsoft Edge 来呈现 Web 内容（HTML / CSS / JavaScript）。它最初的范围仅限于 C/C++ 应用程序。今天，我们很高兴地宣布 .NET 应用程序的 WebView2 预览版发布了！WebView2 对 .NET Core 和 .NET Framework 都支持。它可以在 WPF、Windows Form 和 WinUI 3.0 应用程序中使用，一直到 Windows 7。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202009/270073-20200918121952611-1327009472.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　重要提示：当安装 NuGet 包时，确保选中“Include prerelease”复选框，并选择带有 -prerelease 后缀的版本。否则你将得不到 .NET 的支持。&lt;/p&gt;
&lt;p&gt;　　以后，我们会根据路线图每6周更新一次 SDK，并会得到大家的反馈。您可以在发布说明中了解最新的更新。&lt;/p&gt;

&lt;p&gt;    在 WebView2 控件家族的帮助下，您可以在桌面 .NET 应用程序中托管 Web 内容，并使用 Web 提供的所有好处来增强它们，例如动态内容、现代用户界面和工具。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;过去&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;    最初，我们从基于 Internet Explorer 的 WebBrowser 控件开始，因此不再适合现代 Web 内容。然后我们创建了一个基于 Edge 的控件，叫做 WebView。这个控制只能在 Windows 10 上运行，而且不能被包括在你的 app 里。我们听到您的反馈响亮而清楚，你想要一个现代和一致的控件，支持从 Windows 7 开始的所有 Windows 版本。这就是 WebView2 的诞生。它是基于 Microsoft Edge Chromium 平台，一致地支持从 Windows 7 开始的所有 Windows 版本。它每6周一次更新，使您能够使用最新的功能。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;现在&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;    WebView2 支持许多特性，如导航、Web 消息传递（应用程序和 WebView2 控件之间的通信）、本地对象注入（直接从 JavaScript 访问应用程序对象）等等。查看我们的文档以了解更多细节。在微软，我们在很多应用程序中使用 WebView2。一个例子是 Outlook 桌面版的 Room Finder 面板。通过使用 WebView2，我们能够重用来自 Outlook Web UI 的代码，并使其可以直接访问桌面版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202009/270073-20200918122101219-1618143121.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;未来&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　目前 WebView2 处于预览状态，我们正在开发 GA 版本。作为这一努力的一部分，我们将支持 Windows Form 和 WPF 的设计器支持，所以你可以喜欢的熟悉的拖放和所见即所得的方式使用。有关更多信息，请参阅我们的路线图。今天已支持 WindowsForm 的 .NET 框架设计器体验，其他的即将来临。&lt;/p&gt;

&lt;p&gt;　　预览版目前支持以下平台：&lt;/p&gt;
&lt;p&gt;　　和以下windows版本：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;Windows 10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows 8.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows 8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows 7&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows Server 2016&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows Server 2012&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows Server 2012 R2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows Server 2008 R2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/bring-the-best-of-the-web-to-your-net-desktop-applications-with-webview2/&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://devblogs.microsoft.com/dotnet/bring-the-best-of-the-web-to-your-net-desktop-applications-with-webview2/&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202009/270073-20200918122354421-1393963505.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 28 Sep 2020 15:52:00 +0000</pubDate>
<dc:creator>MeteorSeed</dc:creator>
<og:description>今天，我们很高兴地宣布 .NET 应用程序的 WebView2 预览版发布了！它可以在 WPF、Windows Form和 WinUI 3.0 应用程序中使用，一直到 Windows 7。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MeteorSeed/p/13690556.html</dc:identifier>
</item>
<item>
<title>Maven依赖管理之BOM - 西北偏北UP</title>
<link>http://www.cnblogs.com/niceshot/p/13747547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niceshot/p/13747547.html</guid>
<description>&lt;h3 id=&quot;什么是bom&quot;&gt;什么是BOM&lt;/h3&gt;
&lt;p&gt;BOM全称是Bill Of Materials，译作材料清单。BOM本身并不是一种特殊的文件格式，而是一个普通的POM文件，只是在这个POM中，我们罗列的是一个工程的所有依赖和其对应的版本。该文件一般被其它工程使用，当其它工程引用BOM中罗列的jar包时，不用显示指定具体的版本，会自动使用BOM对应的jar版本。&lt;/p&gt;
&lt;p&gt;所以BOM的好处是用来管理一个工程的所有依赖版本信息。&lt;/p&gt;
&lt;h3 id=&quot;一个bom的格式&quot;&gt;一个BOM的格式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.niceshot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;test-BOM&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
    &amp;lt;name&amp;gt;Test-BOM&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;parent pom&amp;lt;/description&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;test&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;a&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;test&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;b&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;test&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;c&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中定义的关键信息是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;&lt;/code&gt;打包方式是pom文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&amp;lt;dependencies&amp;gt;&lt;/code&gt;下定义的各种依赖的版本&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;怎么使用bom&quot;&gt;怎么使用BOM&lt;/h3&gt;
&lt;h4 id=&quot;通过parent引用&quot;&gt;通过parent引用&lt;/h4&gt;
&lt;p&gt;比如我有一个spring boot工程名叫&lt;code&gt;spring-cloud-learn&lt;/code&gt;。由于其本身是一个spring boot工程，所以我可以直接引用Spring boot的BOM，通过&lt;code&gt;&amp;lt;parent&amp;gt;&lt;/code&gt;配置，即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.niceshot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-learn&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;spring-cloud-learn&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通过dependencymanagement引用&quot;&gt;通过dependencyManagement引用&lt;/h4&gt;
&lt;p&gt;parent只能指定一个BOM。如果我还想引入一个或多个BOM，这个时候，就可以使用&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt;配置。也即&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt; 不光可以用来定义BOM本身的依赖清单，也可以用作BOM的引入。因为dependencyManagement本身是做依赖管理的，Jar是一种依赖，BOM当然也是一种依赖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200928234252655-2111778534.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;怎么查看依赖的某个bom的具体清单&quot;&gt;怎么查看依赖的某个BOM的具体清单&lt;/h3&gt;
&lt;p&gt;由于BOM不是一个jar包，所以你没办法在idea的依赖libary中看看到该文件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200928234306131-1806089199.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在idea中的查看方式是通过ctrl + 鼠标点击BOM的artifactId即可看到对应的材料清单&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2007268/202009/2007268-20200928234319144-731920621.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;版本冲突时的一些规则&quot;&gt;版本冲突时的一些规则&lt;/h3&gt;
&lt;p&gt;当出现版本冲突时，具体使用哪一个版本的优先顺序是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接在当前工程中显示指定的版本&lt;/li&gt;
&lt;li&gt;parent中配置的父工程使用的版本&lt;/li&gt;
&lt;li&gt;在当前工程中通过dependencyManagement引入的BOM清单中的版本，当引入的多个BOM都有对应jar包时，先引入的BOM生效&lt;/li&gt;
&lt;li&gt;上述三个地方都没配置，则启用依赖调解dependency mediation&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;何为依赖调节&quot;&gt;何为依赖调节&lt;/h4&gt;
&lt;p&gt;当有两个依赖路径，依赖到同一个jar的不同版本时，最短路径的版本生效，比如&lt;code&gt;A -&amp;gt; B -&amp;gt; C -&amp;gt; D 1.4 and A -&amp;gt; E -&amp;gt; D 1.0&lt;/code&gt;最终将会使用D的1.0版本&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/spring-maven-bom&quot;&gt;https://www.baeldung.com/spring-maven-bom&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://howtodoinjava.com/maven/maven-bom-bill-of-materials-dependency/&quot;&gt;https://howtodoinjava.com/maven/maven-bom-bill-of-materials-dependency/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/38496022/maven-bom-bill-of-materials-dependency&quot;&gt;https://stackoverflow.com/questions/38496022/maven-bom-bill-of-materials-dependency&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Sep 2020 15:44:00 +0000</pubDate>
<dc:creator>西北偏北UP</dc:creator>
<og:description>什么是BOM BOM全称是Bill Of Materials，译作材料清单。BOM本身并不是一种特殊的文件格式，而是一个普通的POM文件，只是在这个POM中，我们罗列的是一个工程的所有依赖和其对应的版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niceshot/p/13747547.html</dc:identifier>
</item>
<item>
<title>我没学过计算机，是怎么接了四个私活还挣了两个 iPad 的？ - 悟空聊架构</title>
<link>http://www.cnblogs.com/jackson0714/p/sihuo1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/sihuo1.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6bf8f2c0b544cca24663bdbe755b11~tplv-k3u1fbpfcp-zoom-1.image&quot; class=&quot;desc_img&quot;/&gt; 大家看到这篇文章的时候，我和一枝花、Guide哥、Guide哥的妹纸一起恰饭去啦！&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;113.66598053892&quot;&gt;
&lt;div readability=&quot;105.93441270496&quot;&gt;
&lt;blockquote readability=&quot;6.8073394495413&quot;&gt;
&lt;p&gt;你好，我是&lt;code class=&quot;juejin-editor-code&quot;&gt;悟空哥&lt;/code&gt;，&lt;span class=&quot;juejin-editor-bold&quot;&gt;「7年项目开发经验，全栈工程师，开发组长，超喜欢图解编程底层原理」。我还&lt;code class=&quot;juejin-editor-code&quot;&gt;手写了2个小程序&lt;/code&gt;，Java刷题小程序，PMP刷题小程序。我的 &lt;a href=&quot;https://github.com/Jackson0714&quot;&gt;GitHub&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;大家看到这篇文章的时候，我和&lt;span class=&quot;juejin-editor-bold&quot;&gt;一枝花、Guide哥、Guide哥的妹纸一起恰饭去啦！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;离国庆还有几天，无心写技术干货，那就来点珍藏的私活（货）吧。&lt;span class=&quot;juejin-editor-bold&quot;&gt;谐音梗有没有发现？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大家可能不知道，我并不是&lt;span class=&quot;juejin-editor-bold&quot;&gt;「计算机专业的，在大学都是自学编程、单片机、嵌入式的」，和计算机专业的学生还是有些差距。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要是说单片机、嵌入式我还能给您倒腾倒腾，毕竟大学期间还获得过全国研究生嵌入式电子设计&lt;span class=&quot;juejin-editor-bold&quot;&gt;二等奖（以本科身份破格参加）、全国大学生电子设计比赛&lt;span class=&quot;juejin-editor-bold&quot;&gt;三等奖。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是&lt;code class=&quot;juejin-editor-code&quot;&gt;编译原理&lt;/code&gt;、&lt;code class=&quot;juejin-editor-code&quot;&gt;Linux 内核&lt;/code&gt; 我真心不会。&lt;/p&gt;
&lt;p&gt;能接到这四个私活实属意外，很魔幻了。&lt;/p&gt;
&lt;h2&gt;魔幻一、小白做网站-小亏&lt;/h2&gt;
&lt;ol&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;那个时候刚毕业几个月，通过公司培训 + 自学，学了点编程技术。从公司小伙伴中结识了一个计算机专业的大学同学，想找我一起帮他亲戚做个小网站，说是几百块钱。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;第一次接私活，所以带着一颗激动的心就开始做了，功能就是做一个静态网站，有顶部导航栏，可以切换菜单，每个菜单下有不同内容，支持跳转等，总共有 7 个主页面，最复杂的是首页功能。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;下面这张图就是当时做的网站，做的首页还是有模有样的~&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89aeede62ddc49abad0e284acaa969e2~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;打完收工&lt;/h3&gt;
&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;做完了提的需求后，我就将网站效果图发给他们，他们觉得还行，然后我问了是否还需要做其他的，后面就没有回应了，是的，没有回应了。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;之前说的几百块钱并没有兑现。就这样结束了，花了两周空闲时间做完了。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;亏了还是赚了？&lt;/h3&gt;
&lt;p&gt;看似好像是亏了，但其实真的是对我自己技术的一种积累，毕竟我也没学过计算机~&lt;/p&gt;
&lt;h2&gt;魔幻二、帮妹纸做毕设-赚了&lt;/h2&gt;
&lt;p&gt;对于第二个小私活，接到这个活的过程是这样的：大概是n年前吧，一个亲戚电话问我，说她一个朋友的女儿在新加坡上学，不会做课题作业（类似实物毕设），技术用的是 php+mysql。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;我含蓄地问：这个是私活还是就是指导下？&lt;/p&gt;
&lt;p&gt;亲戚：就是指导下。&lt;/p&gt;
&lt;p&gt;我谨慎的问：关系是不是跟你很好？&lt;/p&gt;
&lt;p&gt;亲戚：很好，一定要帮她。&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p&gt;然后我就答应了。想着既然亲戚都知道我很厉害（其实我连 mysql 都没用过，php 看过几集视频教程。我之前是做.net的，也就几年 .net 开发经验），我就接受了。强调下，这里只是帮忙而已。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;那就有个问题了？我都不会 php 和 mysql，怎么能帮忙做呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为我秉持着一个理念：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;语言都是相通的，你学会了 A 语言，B 语言你也就会了。天下语言是一家，但是核心不变的是数据结构和算法。就跟练武一样，天下武功出少林，各门各派都有自己的招式，把内功修炼好了，无招胜有招。&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;h3&gt;需求功能&lt;/h3&gt;
&lt;p&gt;这个需求就是做一个在线网站，可以帮助护士监测老人的活动状态和异常状况。实现的功能如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SfAHMuUxqJ2EsR4EiaSW3ob1dpKZrsxHJRWI1uuOCVN6Iiagn2mGHpuCISiaQo9EhmvypIgS4s0M1Sz8439GbswcQ/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SfAHMuUxqJ2EsR4EiaSW3ob1dpKZrsxHJ5LZicMibwibThLIDTX147XrfThwnI6icXL5bjc2ZiauvxwyIS7OYcYOs5Tg/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;留学生是个妹纸，长得还挺漂亮的。我准备两周时间搞定这个项目。&lt;/p&gt;
&lt;p&gt;端午节在家休息的时候，我就开始学习 php 的知识，为了就是补好功课，加快开发进度。在家用微信聊天帮她解决了她一直没解决的问题，她觉得我是大神，咳咳咳，我就是改了两段 mysql 语句。&lt;/p&gt;
&lt;h3&gt;插曲&lt;/h3&gt;
&lt;p&gt;星期一过来的时候，妹纸的一家人请我和亲戚吃饭，我起码吃了20只虾，最后妹纸的家人给我烟和新加坡带回来的巧克力和咖啡。因为事先亲戚跟我打好了招呼，给的东西都不能收，所以在亲戚和妹纸家人的博弈下，最后让我把巧克力和咖啡收下了。&lt;/p&gt;
&lt;h3&gt;打完收工&lt;/h3&gt;
&lt;p&gt;最后妹纸的课题成功交付，她们一家人为了感谢我，给我买了一个iPad mini4，太意外了，居然还有钱赚！&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;在这个项目中，大赚啊！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;魔幻三、正式的私活 - 赚了&lt;/h2&gt;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;ol&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;第二个私活也为我带来了另外一单生意，通过这个妹纸的朋友的介绍，我又认识了一个新加坡的项目经理，想让我帮他做一个官网，具有内容发布、留言的功能。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;这个比第一个私活难度要大些，毕竟是一个动态网站，而且还需要部署上线，这些对于我这个新手小白都是没做过的。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;调研&lt;/h3&gt;
&lt;p&gt;这个官网需要的内容还挺丰富，而且还要美观，自己造轮子肯定不合适，于是在网上开始搜索了一些现成的框架，比较好看的都是收费的。我用免费的模板框架试了下，可以实现一个内容发布分享平台，但功能就比较简单，而且样式比较龊。&lt;/p&gt;
&lt;h3&gt;签署合同&lt;/h3&gt;
&lt;p&gt;经过前期技术调研，可以一个月搞定后，我就和他们签署合作合同了（第一次签私活合同）。&lt;/p&gt;
&lt;p&gt;主要分成三批款，第一批 1000 元、第二批 3000 元、第三批 1000 元。第一批是签署完合同后直接给的。&lt;/p&gt;
&lt;h3&gt;开工&lt;/h3&gt;
&lt;p&gt;我买了一份官网的源代码，花了大概 800 块，技术栈是 php + JQuery + mysql。&lt;/p&gt;
&lt;p&gt;但是功能、风格和甲方提的需求还是差得比较远，所以只能自己拿过来改了。&lt;/p&gt;
&lt;p&gt;下班后，我就窝在家里改代码，以及研究如何发布上线，花了一个月时间搞定，收到了第二批款 3000元。当时感觉好爽。&lt;/p&gt;
&lt;h3&gt;失误&lt;/h3&gt;
&lt;p&gt;我也不知道那根筋不对，问了下手机上要不要适配官网显示，结果甲方当然说肯定要了。但最开始的需求并没有说要做这个呀，&lt;span class=&quot;juejin-editor-bold&quot;&gt;哎我人傻了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了第三笔款我还是做吧，其实也不难，做完之后，甲方各种挑刺，哎，我也不想纠结了，那就索性不要第三笔款了吧。&lt;/p&gt;
&lt;h3&gt;亏了还是赚了？&lt;/h3&gt;
&lt;h2&gt;魔幻四、做个小游戏-亏了&lt;/h2&gt;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;经朋友搭线介绍，一家公司需要做个微信小游戏，问我有没有时间和兴趣，我说可以做。我做过小程序，但&lt;span class=&quot;juejin-editor-bold&quot;&gt;「并没有做过小游戏」 ，所以又是一个 &lt;code class=&quot;juejin-editor-code&quot;&gt;现学现用&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该公司的对接人给了一个这样的小游戏，需要迁移到微信小游戏上，这个游戏的名称叫做Root Beer Tapper。玩法就是一个酒保不断的倒酒，传递给顾客。顾客到达桌子边沿或者酒杯传多了游戏就结束了。另外他们也没有提供什么UI，素材。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SfAHMuUxqJ2EsR4EiaSW3ob1dpKZrsxHJpKy3kaLqTICOrtaicjfsrYdg3tT9yrwH8icAoETyqKztMc7ohYH1f1iaA/640?wx_fmt=gif&quot;/&gt;&lt;/div&gt;
&lt;h3&gt;如何收费&lt;/h3&gt;
&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;小游戏我没有做过，也没有把握做好，所以跟甲方说是&lt;span class=&quot;juejin-editor-bold&quot;&gt;两周内出一个 Demo。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;等Demo出来后再看如何合作。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;所以接下来就是没有给钱的干活啦。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;开工&lt;/h3&gt;
&lt;h4&gt;头疼的图片素材&lt;/h4&gt;
&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;找了些类似的小游戏，发现都是 swf 格式的文件（用 Flash 开发的），然后想用反编译工具拿到游戏的源代码。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;于是找了一个反编译 swf 文件的工具（硕思闪客精灵），想要将里面的图片导出来，发现试用版只能导出前两张图。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;买了个正版软件，花了 &lt;span class=&quot;juejin-editor-bold&quot;&gt;298 大洋。利用工具后，图是能全部导出了，发现格式不是自己想要的，哎，买了并没有什么卵用，感觉亏了 &lt;code class=&quot;juejin-editor-code&quot;&gt;298 元&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;另外反编译之后发现里面的代码太乱了，要转成 Javacript 不那么容易，干脆自己写吧。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;这个反编译工具的正版功能在后期也没有用到。截取图片素材用试用版都能搞定。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;截图出来的图片没有去掉背景色，找 UX 大神教我怎么使用PS工具去掉了背景，变成了透明的，这样就达到了图片要求。自己找素材切图可把我累坏了。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;实战小游戏&lt;/h4&gt;
&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;先研究了下微信小游戏的开发步骤。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;看了下小游戏的引擎怎么玩，找到了Egret白鹭引擎，真的是非常赞，提供的开发工具也是一流，可以无缝对接微信小游戏！&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;Egret开发工具虽好，但不知道怎么使用，看了下官网的视频教程，发现这个视频非常好啊，视频里面的 demo 和我要做的功能有点类似，可以借鉴借鉴。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;看了一部分教程后，就开始动手做了，一个星期后，甲方问了进度，我只画了页面和顾客的向右移动功能。甲方反馈有进度就好。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;两个星期后，甲方又问了进度，这次&lt;span class=&quot;juejin-editor-bold&quot;&gt;基本上都做完了。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc4ee0dc4a640e78d235a8c72076e5d~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;过了一个星期后，再问甲方：“demo已经做完了，是否后面还需要做什么？”（意思就是可不可以合作啦，聊下需求，签下合同，汇下第一笔款....）&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;甲方没有做任何回复~是的，没有回复了。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;算了哦，就当花了298元学了一把游戏开发。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;亏了还是赚了？&lt;/h3&gt;
&lt;h2&gt;感言&lt;/h2&gt;
&lt;h3&gt;接私活的好处&lt;/h3&gt;
&lt;p&gt;这四个私活，给我的人生带来了不一样的精彩，也带来了很多欢乐，赚的钱虽然不多，但是都是凭借自己的技术挣的 2个 iPad，真的会开心很久。而且挣的 iPad 我已经用了4年了，每次用的时候我都会想起当时做私活的经历，确实非常有意思。而且学习了一些新的技能，功不唐捐，以后指不定会用上！&lt;/p&gt;
&lt;h3&gt;接私活的坏处&lt;/h3&gt;
&lt;p&gt;如果把接私活的时间和精力用来做更有意义的事情，比如沉淀技术博客，写付费专栏，说不定能赚到更多钱，而且技术提升更快。&lt;/p&gt;
&lt;h3&gt;以后还会接私活吗？&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我接的私活全靠运气，如果真的能接到和自己技术相关，也可以考虑下。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;时间上真心不够，写公众号产出干货非常花时间，一周一篇干货也是累成狗。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;加上最近要写付费专栏，真的是牛仔很忙。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;- END -&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;你好，我是&lt;code class=&quot;juejin-editor-code&quot;&gt;悟空哥&lt;/code&gt;，&lt;span class=&quot;juejin-editor-bold&quot;&gt;「7年项目开发经验，全栈工程师，开发组长，超喜欢图解编程底层原理」。我还&lt;code class=&quot;juejin-editor-code&quot;&gt;手写了2个小程序&lt;/code&gt;，Java刷题小程序，PMP刷题小程序，点击我的公众号菜单打开！另外有111本架构师资料以及1000道Java面试题，都整理成了PDF，可以关注公众号 &lt;span class=&quot;juejin-editor-bold&quot;&gt;「&lt;span class=&quot;juejin-editor-bold&quot;&gt;悟空聊架构&lt;span class=&quot;juejin-editor-bold&quot;&gt;」 回复 &lt;code class=&quot;juejin-editor-code&quot;&gt;悟空&lt;/code&gt; 领取优质资料。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gArwz96NEq6dAxAUwibh0JyybcXEcpWjwJhXYLCrE9icqHXv0OJqbK2RFA/640?wx_fmt=png&quot; width=&quot;414&quot; height=&quot;609&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的资料&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;「转发-&amp;gt;在看-&amp;gt;点赞-&amp;gt;收藏-&amp;gt;评论！！！」 是对我最大的支持！&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;《Java并发必知必会》系列：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6861885337568804871&quot;&gt;1.反制面试官 | 14张原理图 | 再也不怕被问 volatile!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6863799243182702599&quot;&gt;2.程序员深夜惨遭老婆鄙视，原因竟是CAS原理太简单？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6864945088721027079&quot;&gt;3.用积木讲解ABA原理 | 老婆居然又听懂了！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6866444584688451591&quot;&gt;4.全网最细 | 21张图带你领略集合的线程不安全&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6867922895536914446&quot;&gt;5.5000字 | 24张图带你彻底理解Java中的21种锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6870298844425371655&quot;&gt;6.干货 | 一口气说出18种队列(Queue)，面试稳了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6872367966512644103&quot;&gt;🏆 技术专题第五期 | 聊聊分布式的那些事......&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/414640/202009/414640-20200928233709757-1048672098.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;299&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 28 Sep 2020 14:59:00 +0000</pubDate>
<dc:creator>悟空聊架构</dc:creator>
<og:description>你好，我是悟空哥，「7年项目开发经验，全栈工程师，开发组长，超喜欢图解编程底层原理」。我还手写了2个小程序，Java刷题小程序，PMP刷题小程序。我的&amp;#160;GitHub。 前言 大家看到这篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackson0714/p/sihuo1.html</dc:identifier>
</item>
<item>
<title>基础篇：深入解析JAVA反射机制 - cscw</title>
<link>http://www.cnblogs.com/cscw/p/13747357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cscw/p/13747357.html</guid>
<description>&lt;ul&gt;&lt;li&gt;java的放射机制：在程序运行时，程序有能力获取一个类的所有方法和属性；并且对于任意一个对象，可以调用它的任意方法或者获取其属性&lt;/li&gt;
&lt;li&gt;通俗解析：java文件需要编译成.class文件才能被jvm加载使用,对象的.class数据在jvm里就是Class&amp;lt;T&amp;gt;；我们如果能拿到这个Class&amp;lt;T&amp;gt;对象，&lt;br/&gt;就能获取该Class&amp;lt;T&amp;gt;对应的对象类型，及在该类型声明的方法和属性值；还可以根据Class&amp;lt;T&amp;gt;创建相应的类型对象，通过Field,Method反过来操作对象&lt;/li&gt;
&lt;li&gt;java相关类介绍&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Class&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;代表类的实体，在运行的Java应用程序中表示类或者接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Field&lt;/td&gt;
&lt;td&gt;类的成员变量（成员变量也称为类的属性）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Method&lt;/td&gt;
&lt;td&gt;类的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Constructor&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;类的构造方法&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;&lt;li&gt;1通过已知的类型获取class&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 根据Example 获取Class =》Example.class
public Class&amp;lt;Example&amp;gt; getExample(){
    Class&amp;lt;Example&amp;gt; clazz = Example.class;
    return clazz;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2通过实例对象获取class&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Class&amp;lt;Example&amp;gt; getExampleByInstance(){
    Example example = new Example();
    // getClass是Object类里面的方法；《?》 是通配符
    Class&amp;lt;?&amp;gt; clazz = example.getClass();
    return (Class&amp;lt;Example&amp;gt;)clazz;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3通过Class.forName获取全路径指定类名的class&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/** forName0 本地方法，C++实现，jvm调用
 *      1 className 是个类名  2 initialize 是否延迟加载  3 loader 加载器
 */
private static native Class&amp;lt;?&amp;gt; forName0(String className, boolean initialize,
                                ClassLoader loader, Class&amp;lt;?&amp;gt; caller) throws ClassNotFoundException;

public static Class&amp;lt;?&amp;gt; forName(String className) throws ClassNotFoundException {
        Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();
        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
    }
// 两个forName方法最终都会调用forName0方法去加载class   
public static Class&amp;lt;?&amp;gt; forName(String name,
                boolean initialize, ClassLoader loader) throws ClassNotFoundException {
        ....
        return forName0(name, initialize, loader, caller);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 示例:通过java.lang.Integer 
public Class&amp;lt;Integer&amp;gt; getInteger()throws ClassNotFoundException{
    Class&amp;lt;?&amp;gt; clazz = Class.forName(&quot;java.lang.Integer&quot;);
    return (Class&amp;lt;Integer&amp;gt;)clazz;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;Class常用操作方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//获取所有的构造方法 / private public
public Constructor&amp;lt;?&amp;gt;[] getDeclaredConstructors()
//获取特定的构造方法 / private public
public Constructor&amp;lt;T&amp;gt; getDeclaredConstructor(Class&amp;lt;?&amp;gt;... parameterTypes)    
//获取类的父类
public native Class&amp;lt;? super T&amp;gt; getSuperclass()    
//获取类实现的接口
private Class&amp;lt;?&amp;gt;[] getInterfaces(boolean cloneArray)  
//获取在类内定义的内部类或接口
public Class&amp;lt;?&amp;gt;[] getDeclaredClasses()
//获取所有的方法
public Method[] getDeclaredMethods() throws SecurityException
//根据方法名和参数获得特定的方法
public Method getDeclaredMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes)  
//获取类型的定义的所有属性
public Field[] getFields() throws SecurityException
// 根据属性命名获得特定的Field
public Field getField(String name) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Method常用的操作方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//获得方法的放回类型
public Class&amp;lt;?&amp;gt; getReturnType()   
//获得方法的传入参数类型
public Class&amp;lt;?&amp;gt;[] getParameterTypes()   
//obj是实例对象，args是方法，反过来由Method控制对象的方法调用
public Object invoke(Object obj, Object... args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Field常用的操作方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//属性与obj相等则返回true
public boolean equals(Object obj)
//获得obj中对应的属性值
public Object get(Object obj)
//设置obj中对应属性值
public void set(Object obj, Object value) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Constructor&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//根据传递的参数创建类的对象:initargs 构造方法参数
public T newInstance(Object... initargs) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1根据class创建对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//方式一 clazz.newInstance()
Class&amp;lt;Example&amp;gt; clazz = Example.class;
Example example = clazz.newInstance();
//方式二 先获取再由Constructor：clazz.getConstructors()/getConstructor(...) 
//再由Constructor.newInstance 方法构造对象
-----------------------------------------
public class Example {
    private int value;
    public Example(){ } // 如果只声明有参构造函数，clazz.newInstance()会报错
    public Example(Integer value){  this.value  = value;  }
    static public void main(String[] args) throws Exception{
        Class&amp;lt;Example&amp;gt; clazz = Example.class;
        //根据指定构造函数参数获取Constructor
        Constructor&amp;lt;Example&amp;gt; constructor = clazz.getConstructor(Integer.class);
        Example example = constructor.newInstance(100);
        System.out.println(example.value);
    }
}    
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2由class获取Field，并操作实例的属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Example {
    private int value , count;
    static public void main(String[] args) throws Exception{
        Class&amp;lt;Example&amp;gt; clazz = Example.class;
        //获取所有的属性，getField只能获取public的属性
                Field[] fs = clazz.getDeclaredFields();
        //根据名称获取指定 Field
        Field value = clazz.getDeclaredField(&quot;value&quot;);
        Example example = clazz.newInstance();
        //使用反射机制可以打破封装性，导致了java对象的属性不安全  
        value.setAccessible(true); //setAccessible(true)让private的参数可赋值操作
        //由Field反过去设置example的值
        value.set(example,100);
        System.out.println(example.value);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3由class获取Method，并反射调用实例方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Example {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;Example&amp;gt; clazz = Example.class;
        Example example = clazz.newInstance();
        Method[] methods = clazz.getDeclaredMethods();
        //getDeclaredMethod和getMethod是：getMethod只能返回public的方法
        Method method = clazz.getDeclaredMethod(&quot;hello&quot;, String.class);
        method.setAccessible(true);
        method.invoke(example, &quot;cscw&quot;);
    }
    private void hello(String name) { System.out.println(name + &quot; Hello!&quot;); }
}
－－－－－
cscw Hello!
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;1 动态拓展：假设有同一组类是实现相同的接口，并且类的加载方式不限制。当我们需要那种具体类实现的功能时，只需加载.class文件，并获取对应的Class&amp;lt;T&amp;gt;对象。可以由Class或者Constructor实例化对象instance；根据接口定义，可以获取Class&amp;lt;T&amp;gt;里的某一方法Method，并配合instance调用功能方法&lt;/li&gt;
&lt;li&gt;2 Spring的IOC就是基于反射机制实现&lt;/li&gt;
&lt;li&gt;3 JDK的动态代理&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;在Java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口。通过这个类和接口可以生成JDK动态代理类或动态代理对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface InvocationHandler {
        //所有方法都会调用此代理方法
    Object invoke(Object var1, Method var2, Object[] var3) throws Throwable;
}       　
public class Proxy implements Serializable｛
        ...
    //根据interfaces和InvocationHandler生成代理对象
    public static Object newProxyInstance(ClassLoader loader,
                Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h) 
    ...    
｝
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;JDK的动态代理由Proxy和InvocationHandler实现；而被代理对象必须实现一个接口。代理对象由Proxy生成，可转为接口interface的实现类对象OBJ。当调用OBJ的方法时，则会触发InvocationHandler.invoke，参数依次为&lt;strong&gt;代理对象&lt;/strong&gt;，&lt;strong&gt;Method对象&lt;/strong&gt;,和&lt;strong&gt;方法Method所需的参数&lt;/strong&gt;。在invoke方法可以加入拓展的逻辑，如日志记录操作；&lt;strong&gt;并可以在invoke里利用反射的技术调用 被代理对象方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;示例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ExampleFactory&amp;lt;T&amp;gt; implements InvocationHandler{
    private T target;
    public T bind(T obj){
        target = obj;
        return (T)Proxy.newProxyInstance(obj.getClass().getClassLoader(),
                                obj.getClass().getInterfaces(),this);
    }
    @Override
    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
        //增强逻辑
        System.out.println(&quot;log start&quot;);
        //反射调用被代理对象方法
        Object result = method.invoke(target,objects);
        System.out.println(&quot;log end&quot;);
        return result;
    }
}
-----------
public interface Face {
    void hello(String name);
}
---------
//被代理对象必须实现一个接口，并由接口方法对方提供功能
public class Example implements Face {
        public void hello(String name) {
        System.out.println(name + &quot; Hello!&quot;);
    }
    public static void main(String[] args)  {
        //ExampleFactory&amp;lt;Face&amp;gt; 相当于一个中介人
        ExampleFactory&amp;lt;Face&amp;gt; factory = new ExampleFactory&amp;lt;&amp;gt;();
        //example 是代理对象
        Face example = exampleProxy.bind(new Example());
        example.hello(&quot;思婷&quot;);
    }
}
-----
log start
思婷 Hello!
log end
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;欢迎指正文中错误&quot;&gt;欢迎指正文中错误&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e3aee20b9c27f88715ee56e510479921.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 28 Sep 2020 14:53:00 +0000</pubDate>
<dc:creator>cscw</dc:creator>
<og:description>JAVA反射机制,JDK动态代理。Class\Constructor\Method\Field</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cscw/p/13747357.html</dc:identifier>
</item>
<item>
<title>ucore操作系统学习笔记(一)  ucore lab1系统启动流程分析 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/13714587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/13714587.html</guid>
<description>&lt;p&gt;　　操作系统作为一个基础系统软件，对下控制硬件(cpu、内存、磁盘网卡等外设)，屏蔽了底层复杂多样的硬件差异；对上则提供封装良好的应用程序接口，简化应用程序开发者的使用难度。站在应用程序开发人员的角度来看，日常开发中常见的各种关于并发、I/O、程序通信的问题等都和操作系统相关，因此一定程度上了解底层的操作系统工作原理是有必要的。&lt;/p&gt;
&lt;p&gt;　　另一方面，由于操作系统自身功能的复杂性，整体设计一般会有一个好的模块化架构；操作系统作为基础服务，对性能效率的要求也很高，底层会用到许多关于数据结构和算法相关的知识。如果仔细的研究一个操作系统的源码，既可以学习设计一个复杂软件的架构知识，又可以看到偏理论的数据结构和算法知识是如何被运用在实际场景中的，更深刻的体会不同数据结构、算法在特定场景下的性能差异。&lt;/p&gt;
&lt;p&gt;　　然而对于初学者而言，学习操作系统并不是一件轻松的事情。操作系统理论的学习过于抽象，往往看了就忘。而主流商业操作系统动辄十万、百万级的内核源码也令想要一窥究竟的普通人望而却步。对于一个已经迭代发展相当一段时间的系统，个人认为好的学习方法不是从最新的，相对复杂的版本开始了解，而是从最初始的，较为简单的版本起步，研究其是如何一步步优化、迭代至如今的这个版本。经过无数人迭代、优化的最新版本linux内核固然无比复杂，但90年代早期发布的版本却简单太多，更容易理解和学习，在掌握了相对简单的早期版本后，能降低后续学习更复杂的版本的难度。&lt;/p&gt;
&lt;p&gt;　　对于操作系统的学习而言，有不少大牛都出版了关于如何实现一个简易版操作系统的书籍，例如&lt;strong&gt;《Orange'S:一个操作系统的实现》&lt;/strong&gt;、&lt;strong&gt;《30天自制操作系统》&lt;/strong&gt;等等。不少大学也开始对操作系统的课程进行改革，不再是枯燥的灌输理论知识点，而是尝试着让学生亲自动手实现一个demo操作系统，加深对知识内容的理解。其中麻省理工大学的公开课&lt;strong&gt;MIT 6.828&lt;/strong&gt;是出品较早，久负盛名的。&lt;/p&gt;
&lt;p&gt;　　本系列博客的主角，是由清华大学出品的操作系统网上公开课，其中的实验课程就需要学生通过一个个的迭代实验，逐步实现一个名为&lt;strong&gt;ucore&lt;/strong&gt;的操作系统。其实验指导书上对ucore os的评价是&lt;strong&gt;&quot;麻雀虽小，五脏俱全&quot;&lt;/strong&gt;，非常适合操作系统初学者进行学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ucore项目github仓库链接：&lt;a href=&quot;https://github.com/chyyuu/os_kernel_lab&quot; target=&quot;_blank&quot;&gt;https://github.com/chyyuu/os_kernel_lab&lt;/a&gt;&lt;/strong&gt; (master分支)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ucore实验指导书链接：&lt;a href=&quot;https://chyyuu.gitbooks.io/ucore_os_docs/content/&quot; target=&quot;_blank&quot;&gt;https://chyyuu.gitbooks.io/ucore_os_docs/content/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ucore公开课视频链接(学堂在线)：&lt;a href=&quot;https://www.xuetangx.com/course/THU08091000267&quot; target=&quot;_blank&quot;&gt;https://www.xuetangx.com/course/THU08091000267&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　工欲善其事，必先利其器。操作系统作为一门综合性的课程，需要掌握一定的前置基础知识才能顺利的完成ucore操作系统的学习。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.C语言　　&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　ucore内核中绝大多数的功能都是使用C语言实现的，掌握C语言是学习ucore的基础。除了熟练掌握C语言的基础语法知识之外，最好能对宏、指针有一定了解。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;推荐学习书籍：《C primer》&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2.x86汇编语言（32位）&lt;/h3&gt;
&lt;p&gt;　　ucore内核是运行在80386这一32位x86架构的cpu之上的。虽然ucore的内核主要是由C语言实现的，但由于操作系统是贴近底层，与硬件有频繁交互的系统程序。在ucore中，CPU加电后的内核引导程序以及中断、与特定硬件交互时的部分都需要通过x86汇编来实现。&lt;/p&gt;
&lt;p&gt;　　如果是汇编语言的初学者，强烈建议先学习8086汇编语言，建立一个对底层CPU工作原理的基本知识结构后，再学习更为复杂的32位汇编。　　&lt;/p&gt;
&lt;p&gt;　　需要注意的一点是，ucore中的x86汇编代码是以AT&amp;amp;T格式编写的，和Intel格式的x86汇编虽然逻辑等价，但写法上有较大差异。对于通过Intel格式入门汇编的初学者来说，需要稍微适应一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　推荐学习书籍：《汇编语言》王爽著(8086汇编)、《X86汇编从实模式到保护模式》(80386汇编)&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;3.80386CPU工作原理&lt;/h3&gt;
&lt;p&gt;　　汇编语言对应的是机器码，其中的很多功能都与CPU硬件紧密关联。80386的分页、中断，特权级等功能在ucore操作系统的实现中扮演了重要的角色。如果对80386的工作原理了解不够，在阅读ucore与之相关的源码时会有困难。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;推荐学习书籍：《X86汇编从实模式到保护模式》、《intel 80386参考手册》&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4.C语言机器实现底层(与x86汇编的关联)&lt;/h3&gt;
&lt;p&gt;　　在ucore中经常会出现c和汇编代码互相调用的地方。要想理解其工作原理，需要去理解C语言编译后生成的底层机器指令(汇编)，统一的站在汇编语言的角度来思考。你需要了解C中的结构体、数组等数据结构在内存中的是如何排布的，C中的指针操作是如何被转换成各种内存寻址指令的，C中的函数调用与返回过程中，由于参数压栈出栈等等栈上数据的是如何变化的等等。&lt;/p&gt;
&lt;p&gt;　　其实C中的指针等比较难理解的概念，在有了一定的汇编语言基础后会理解的更加透彻。C中的指针和结构体使得程序员不必再去思考汇编层面中繁琐的内存访问偏移量计算，统统的交由编译器处理，C程序员的脑力得到解放，能够站在更高的抽象层面去思考更复杂的业务问题。&lt;/p&gt;
&lt;p&gt;　　有了C语言和汇编的基础后，可以通过编写简单的C程序，查看其反汇编代码来进行相关的学习(通过32位的编译器)。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;推荐学习书籍：《深入理解计算机系统》(Computer Systems A Programmer's perspective  CSAPP)&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;5.基本的数据结构知识&lt;/h3&gt;
&lt;p&gt;　　ucore中所涉及到的通用数据结构并不多，只需要对双向链表和哈希表有一定了解即可。&lt;/p&gt;
&lt;p&gt;　　虽然在后续的实验中参考linux的实现引入了红黑树等复杂数据结构优化一些算法的实现，但并不涉及核心流程，如果不是学有余力，在ucore的学习过程中当做一个黑盒子去看待就行。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;推荐学习公开课视频： 清华大学出品的数据结构公开课(邓俊辉)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　初学者在学习ucore的过程中碰到的一个很大的困难就是lab1作为最初始的一个实验，为了搭建起一个能实际运行的系统，一下子引入了很多内容。这里面既有生成img镜像的功能，也有bootloader加载内核的功能，还有许多与硬件交互的代码逻辑，这些信息铺天盖地的涌来，容易劝退初学者。当时的我就差点被劝退了，但由于自己强烈的好奇心以及实验指导书首页的提醒：“&lt;strong&gt;lab1和lab2比较困难，有些同学由于畏难而止步与此，很可惜。通过lab1和lab2后，对计算机原理中的中断、段页表机制、特权级等的理解会更深入，等会有等同于打通了任督二脉，后面的实验将一片坦途。&lt;/strong&gt;”，最终还是坚持了下来。实际的感觉也确实如此，如果能理解lab1、lab2中诸多硬件相关的知识和C内核实现中很多巧妙但晦涩的指针、宏的用法，后续的实验将简单很多。&lt;/p&gt;
&lt;p&gt;　　在整个ucore的学习过程中，除了公开课的视频和资料外，网上很多关于ucore学习的博客也给了我很大帮助，所以我也希望能通过博客分享自己的学习心得，帮助到更多对操作系统、ucore感兴趣的人。如果实验中碰到不懂的地方，多通过关键字去搜索相关资料以及网上关于ucore学习的博客能够起到事半功倍的作用。&lt;/p&gt;

&lt;p&gt;　　下面进入正题，开始分析ucore在实验课程lab1中的内容：ucore系统加载启动过程的分析。&lt;/p&gt;
&lt;p&gt;　　ucore的lab1项目结构从整体来看，按照执行的流程顺序分为三部分：&lt;strong&gt;img磁盘映像的生成&lt;/strong&gt;、&lt;strong&gt;引导内核的bootloader程序&lt;/strong&gt;、&lt;strong&gt;ucore内核的初始化&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;ucore的img磁盘映像生成&lt;/h2&gt;
&lt;p&gt;　　ucore整体是一个makefile项目。通过make指令，解析项目中的makefile文件后会生成一个ucore.img磁盘映像。(lab1的实验课视频演示中可以详细的看到构建的全过程)&lt;/p&gt;
&lt;p&gt;　　这个磁盘映像主要由两大部分组成：位于第一个扇区即引导扇区的ucore bootloader程序，以及第二个扇区开始往后的ucore kernel内核程序。&lt;/p&gt;
&lt;p&gt;　　80386CPU在加电启动之初，会执行固化在BIOS中的程序。BIOS由于容量有限，自身不提供加载完整操作系统内核的功能，而是约定好会读取磁盘中第一个扇区(引导扇区)中的内容，将其加载至内存地址空间0x7c00处，在加载完毕后，令CS:IP指向0x7c00，跳转执行引导扇区中的引导程序的第一条指令&lt;strong&gt;。为了避免所加载的磁盘引导扇区是一个无效扇区(可能引导扇区中的内容就是空的或是乱码)，要求512字节大小的扇区在其最后两字节必须是0x55AA(其余的空余空间可以用0填充)，否则无法通过BIOS的校验，引导失败。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　ucore的makefile文件中，将项目中位于boot文件夹下的程序放入了ucore的第一个扇区，在makefile的&quot;#create bootblock&quot;注释开头的段中有所体现。其中调用了/tool/sign.c来生成写入一个合法的引导扇区。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;由于项目中的makefile文件中有不少复杂脚本，如果对makefile工作原理不熟悉，在ucore的学习中可以降低要求，大致了解一下每一部分的代码大概在干什么即可，不必强求理解每一行，避免在学习之初就产生太强的挫败感。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想对通过makefile是如何一步步完整的生成磁盘映像感兴趣，可以参考以下内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. lab1项目目录下的report.md实验报告示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. &lt;a href=&quot;https://www.jianshu.com/p/2f95d38afa1d&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/2f95d38afa1d&lt;/a&gt;  其中对lab1中makefile的分析非常详细&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;ucore的bootloader引导程序&lt;/h2&gt;
&lt;p&gt;　　当BIOS加载完引导扇区的内容至内存后，CPU便会跳转到0x7c00执行命令，此时CPU的控制权便交给了ucore的引导程序bootloader。引导程序主体由boot文件夹下的bootasm.S和bootasm.c共同组成，其中bootasm.S由于构建时靠前，是先执行的。&lt;/p&gt;
&lt;h3&gt;令CPU进入保护模式&lt;/h3&gt;
&lt;p&gt;　　bootasm.S的主要工作就是令80386从加电时默认的实模式切换到32位保护模式，通过代码的注释可以看到，由于一些历史原因要令80386正确的进入保护模式还是有点小麻烦的(并不是简单的调整一个开关位就行)。在《X86汇编语言 从实模式到保护模式》一书中对此有更加详细的介绍。&lt;/p&gt;
&lt;p&gt;　　在通过汇编指令完成80386从实模式至保护模式的切换后，通过call bootmain指令，跳转至bootmain.c中的bootmain函数完成引导内核的工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bootasm.S：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#include &amp;lt;asm.h&amp;gt;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; # Start the &lt;span&gt;CPU:&lt;/span&gt; switch to &lt;span&gt;32&lt;/span&gt;-bit protected mode, jump &lt;span&gt;into&lt;/span&gt;&lt;span&gt; C.
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; # The BIOS loads this code from the first sector of the hard disk &lt;span&gt;into&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; # memory at physical address 0x7c00 &lt;span&gt;and&lt;/span&gt; starts executing &lt;span&gt;in&lt;/span&gt;&lt;span&gt; real mode
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; # with %cs=&lt;span&gt;0&lt;/span&gt;&lt;span&gt; %ip=7c00.
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;# 80386CPU为了兼容8086程序，最开始启动时是以16位的实模式进行工作的
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;# 生成img磁盘映像时，bootasm.S中的引导代码将会被放在引导扇区
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;# 80386CPU加电启动后，会执行BIOS中的默认引导程序，BIOS引导程序会将引导扇区中(第一个磁盘块)的内容读入内存，并放置在0x7C00(16位)/0x00007c00(32位)处
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; # 随后CPU会跳转到0x7c00处开始第一条指令的执行，即bootasm.S的第一条指令(&lt;span&gt;start:&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;.set CR0_PE_ON,             0x1                     # protected mode enable flag
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; # start address should be &lt;span&gt;0&lt;/span&gt;:7c00, &lt;span&gt;in&lt;/span&gt;&lt;span&gt; real mode, the beginning address of the running bootloader
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;.globl start
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;start:&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; .code16                                             # Assemble for &lt;span&gt;16&lt;/span&gt;&lt;span&gt;-bit mode
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;cli&lt;/span&gt;&lt;span&gt;                                             # Disable interrupts
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;cld&lt;/span&gt;&lt;span&gt;                                             # String operations increment
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    # Set up the important data segment registers (DS, ES, SS).
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    xorw %ax, %ax                                   # Segment number zero
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    movw %ax, %ds                                   # -&amp;gt; Data Segment
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    movw %ax, %es                                   # -&amp;gt; Extra Segment
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;    movw %ax, %ss                                   # -&amp;gt; Stack Segment
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;     # Enable &lt;span&gt;A20:&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    #  For backwards compatibility with the earliest PCs, physical
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     #  address line &lt;span&gt;20&lt;/span&gt;&lt;span&gt; is tied low, so that addresses higher than
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    #  1MB wrap around to zero by default. This code undoes this.
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;    # 为了进入32位保护模式，必须先开启A20(第21位内存访问线)，否则在32位寻址模式下给出的内存地址第21位始终为0，造成错误
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;    # 为什么需要特意开启A20总线?
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    # 在早期的8086CPU中，内存总线是20位的，由高16位的段基址和低16位的段内偏移共同构成一个20位的内存地址
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     # 但事实上在段基址和段内偏移比较大的情况下，其实际得出的结果是超过了20位的(例如0xFFFF段基址 &amp;lt;&amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt; + 0xFFFF段内偏移 &amp;gt; 0xFFFFF)，出现了溢出
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    # 而8086中对这种溢出是兼容的，这种溢出在8086上会体现为绕回0x00000低端
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    # “程序员，你是知道的，他们喜欢钻研，更喜欢利用硬件的某些特性来展示自己的技术，很难说在当年有多少程序在依赖这个回绕特性工作着”
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     # 摘自《X86汇编语言 从实模式到保护模式》 &lt;span&gt;11&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;&lt;span&gt; 关于第21条地址线A20的问题
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    # 到了更新版的80286时代，24位的内存总线，如果不默认关闭A20总线，那么就无法兼容使用回绕特性的8086程序了
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    # 而80386作为80286的后一代，也继承了80286这一特性
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; seta20.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     inb $0x64, %al                                  # &lt;span&gt;Wait&lt;/span&gt; for &lt;span&gt;not&lt;/span&gt; busy(&lt;span&gt;8042&lt;/span&gt;&lt;span&gt; input buffer empty).
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;    testb $0x2, %al
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;jnz&lt;/span&gt; seta20.&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    movb $0xd1, %al                                 # 0xd1 -&amp;gt; port 0x64
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     outb %al, $0x64                                 # 0xd1 &lt;span&gt;means:&lt;/span&gt; write data to &lt;span&gt;8042&lt;/span&gt;&lt;span&gt;’s P2 port
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; seta20.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     inb $0x64, %al                                  # &lt;span&gt;Wait&lt;/span&gt; for &lt;span&gt;not&lt;/span&gt; busy(&lt;span&gt;8042&lt;/span&gt;&lt;span&gt; input buffer empty).
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;    testb $0x2, %al
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;jnz&lt;/span&gt; seta20.&lt;span&gt;2&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    movb $0xdf, %al                                 # 0xdf -&amp;gt; port 0x60
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     outb %al, $0x60                                 # 0xdf = &lt;span&gt;11011111&lt;/span&gt;, means set P2’s A20 bit(the &lt;span&gt;1&lt;/span&gt; bit) to &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    # Switch from real to protected mode, using a bootstrap GDT
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     # &lt;span&gt;and&lt;/span&gt;&lt;span&gt; segment translation that makes virtual addresses
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;    # identical to physical addresses, so that the
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     # effective memory map does &lt;span&gt;not&lt;/span&gt;&lt;span&gt; change during the switch.
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    # 设置GDT，修改CRO寄存器中的保护模式允许位，进入保护模式
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;lgdt&lt;/span&gt;&lt;span&gt; gdtdesc
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    movl %cr0, %eax
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;    orl $CR0_PE_ON, %eax
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    movl %eax, %cr0
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;     # Jump to next instruction, but &lt;span&gt;in&lt;/span&gt; &lt;span&gt;32&lt;/span&gt;&lt;span&gt;-bit code segment.
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     # Switches processor &lt;span&gt;into&lt;/span&gt; &lt;span&gt;32&lt;/span&gt;&lt;span&gt;-bit mode.
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    # 通过一个远跳转指令指向protcseg处的指令，令CPU清空之前在实模式下保存在流水线中的指令(当前处于保护模式下执行实模式的指令会出现各种问题)
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;    ljmp $PROT_MODE_CSEG, $protcseg
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;# 下面的都是X86-32的汇编程序
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; .code32                                             # Assemble for &lt;span&gt;32&lt;/span&gt;&lt;span&gt;-bit mode
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;protcseg:&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    # Set up the protected-mode data segment registers
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    # 跳转至保护模式后，需要刷新数据段寄存器(因为引入了特权级保护，避免数据段寄存器之前的值不对而出现漏洞)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     movw %ax, %ds                                   # -&amp;gt; &lt;span&gt;DS:&lt;/span&gt;&lt;span&gt; Data Segment
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     movw %ax, %es                                   # -&amp;gt; &lt;span&gt;ES:&lt;/span&gt;&lt;span&gt; Extra Segment
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    movw %ax, %fs                                   # -&amp;gt; FS
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;    movw %ax, %gs                                   # -&amp;gt; GS
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     movw %ax, %ss                                   # -&amp;gt; &lt;span&gt;SS:&lt;/span&gt;&lt;span&gt; Stack Segment
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;     # Set up the stack pointer &lt;span&gt;and&lt;/span&gt; &lt;span&gt;call&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; C. The stack region is from &lt;span&gt;0&lt;/span&gt;&lt;span&gt;--start(0x7c00)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    # 设置栈段寄存器 栈基址0x0，栈顶指针指向start段所在位置(0x7c00)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    movl $0x0, %ebp
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    movl $start, %esp
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    # 调用跳转至bootmain.c中的bootmain函数，完成内核的引导
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt; bootmain
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    # If bootmain returns (it shouldn’t), loop.
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;    # 自旋死循环(但如果引导程序和内核实现正确，bootmain函数将永远不会返回并执行至此。因为操作系统内核本身就是通过自旋循环常驻内存的)
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;spin:&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; spin
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;# Bootstrap GDT
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; .p2align &lt;span&gt;2&lt;/span&gt;                                          # force &lt;span&gt;4&lt;/span&gt;&lt;span&gt; byte alignment
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;# SEG_ASM是位于asm.h中的宏，用于构造GDT中的段描述符
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;# 按照GDT的约定，第一个为NULL段。ucore采用的是平坦内存模型，所以代码段和数据段在内核中均只存在一个。
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;gdt:&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;    SEG_NULLASM                                     # null seg
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;     SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader &lt;span&gt;and&lt;/span&gt;&lt;span&gt; kernel
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader &lt;span&gt;and&lt;/span&gt;&lt;span&gt; kernel
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;gdtdesc:&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;     .word 0x17                                      # sizeof(gdt) - &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;     .long gdt                                       # address gdt
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;bootloader引导加载内核&lt;/h3&gt;
&lt;p&gt;　　bootloader引导程序是位于设备的第一个扇区，即引导扇区的，而ucore的内核程序则是从第二个磁盘扇区开始往后存放的。bootmain.c的任务就是将kernel内核部分从磁盘中读出并载入内存，并将程序的控制流转移至指定的内核入口处。&lt;/p&gt;
&lt;p&gt;　　ucore的内核文件在生成磁盘映像时是以&lt;strong&gt;ELF(Executable and linking format)&lt;/strong&gt;格式保存的。ELF文件是Unix/Linux下通用的一种可执行文件，对于ELF的详细介绍在《深入理解计算机系统》的&quot;链接&quot;一章中有较为详细的介绍。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;要想彻底的理解ELF格式的文件是如何被编译器、链接器等工具生成的，需要对编译原理相关的知识进行系统的学习，难度很大。因此在ucore的学习过程中，如果不是很了解ELF，可以简单的理解为ELF的文件头中标识了一个可执行程序中包含了哪些部分，比如代码段、数据段(只读数据段、可读写数据段)、栈段等等，分别存储在哪里；并指明了需要为这些段分配多少内存空间、需要被加载到内存的什么地址(虚拟地址)等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　ucore内核生成ELF文件的关键配置在/tools/kernel.ld中，可以清楚的看到内核加载的.text代码段基址为0x100000，后面紧跟着各种类型的数据段等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kernel.ld:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Simple linker script for the JOS kernel.
   See the GNU ld 'info' manual (&quot;info ld&quot;) to learn the syntax. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

OUTPUT_FORMAT(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;elf32-i386&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;elf32-i386&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;elf32-i386&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
OUTPUT_ARCH(i386)
ENTRY(kern_init)

SECTIONS {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Load the kernel at this address: &quot;.&quot; means the current address &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    . &lt;/span&gt;= &lt;span&gt;0x100000&lt;/span&gt;&lt;span&gt;;

    .text : {
        &lt;/span&gt;*(.text .stub .text.* .gnu.linkonce.t.*&lt;span&gt;)
    }

    PROVIDE(etext &lt;/span&gt;= .);    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Define the 'etext' symbol to this value &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    .rodata : {
        &lt;/span&gt;*(.rodata .rodata.* .gnu.linkonce.r.*&lt;span&gt;)
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Include debugging information in kernel memory &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    .stab : {
        PROVIDE(__STAB_BEGIN__ &lt;/span&gt;=&lt;span&gt; .);
        &lt;/span&gt;*&lt;span&gt;(.stab);
        PROVIDE(__STAB_END__ &lt;/span&gt;=&lt;span&gt; .);
        BYTE(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;)        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Force the linker to allocate space
                   for this section &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }

    .stabstr : {
        PROVIDE(__STABSTR_BEGIN__ &lt;/span&gt;=&lt;span&gt; .);
        &lt;/span&gt;*&lt;span&gt;(.stabstr);
        PROVIDE(__STABSTR_END__ &lt;/span&gt;=&lt;span&gt; .);
        BYTE(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;)        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Force the linker to allocate space
                   for this section &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Adjust the address for the data segment to the next page &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    . &lt;/span&gt;= ALIGN(&lt;span&gt;0x1000&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The data segment &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    .data : {
        &lt;/span&gt;*&lt;span&gt;(.data)
    }

    PROVIDE(edata &lt;/span&gt;=&lt;span&gt; .);

    .bss : {
        &lt;/span&gt;*&lt;span&gt;(.bss)
    }

    PROVIDE(end &lt;/span&gt;=&lt;span&gt; .);

    &lt;/span&gt;/DISCARD/&lt;span&gt; : {
        &lt;/span&gt;*(.eh_frame .note.GNU-&lt;span&gt;stack)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在libs/elf.h中定义了两个ELF相关的结构体，&lt;strong&gt;elfhdr&lt;/strong&gt;和&lt;strong&gt;proghdr&lt;/strong&gt;，用于映射读取出来的内核ELF头信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;elf.h：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef __LIBS_ELF_H__
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; __LIBS_ELF_H__&lt;span&gt;

#include &lt;/span&gt;&amp;lt;defs.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; ELF_MAGIC    0x464C457FU            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;\x7FELF&quot; in little endian&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; file header &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; elfhdr {
    uint32_t e_magic;     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; must equal ELF_MAGIC&lt;/span&gt;
    uint8_t e_elf[&lt;span&gt;12&lt;/span&gt;&lt;span&gt;];
    uint16_t e_type;      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1=relocatable, 2=executable, 3=shared object, 4=core image&lt;/span&gt;
    uint16_t e_machine;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3=x86, 4=68K, etc.&lt;/span&gt;
    uint32_t e_version;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; file version, always 1&lt;/span&gt;
    uint32_t e_entry;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; entry point if executable&lt;/span&gt;
    uint32_t e_phoff;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; file position of program header or 0&lt;/span&gt;
    uint32_t e_shoff;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; file position of section header or 0&lt;/span&gt;
    uint32_t e_flags;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; architecture-specific flags, usually 0&lt;/span&gt;
    uint16_t e_ehsize;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; size of this elf header&lt;/span&gt;
    uint16_t e_phentsize; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; size of an entry in program header&lt;/span&gt;
    uint16_t e_phnum;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number of entries in program header or 0&lt;/span&gt;
    uint16_t e_shentsize; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; size of an entry in section header&lt;/span&gt;
    uint16_t e_shnum;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number of entries in section header or 0&lt;/span&gt;
    uint16_t e_shstrndx;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; section number that contains section name strings&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; program section header &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; proghdr {
    uint32_t p_type;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; loadable code or data, dynamic linking info,etc.&lt;/span&gt;
    uint32_t p_offset; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; file offset of segment&lt;/span&gt;
    uint32_t p_va;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; virtual address to map segment&lt;/span&gt;
    uint32_t p_pa;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; physical address, not used&lt;/span&gt;
    uint32_t p_filesz; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; size of segment in file&lt;/span&gt;
    uint32_t p_memsz;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; size of segment in memory (bigger if contains bss）&lt;/span&gt;
    uint32_t p_flags;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; read/write/execute bits&lt;/span&gt;
    uint32_t p_align;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; required alignment, invariably hardware page size&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; /* !__LIBS_ELF_H__ */
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;bootmain.c:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
#include &amp;lt;defs.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;x86.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;elf.h&amp;gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; *********************************************************************
 * This a dirt simple boot loader, whose sole job is to boot
 * an ELF kernel image from the first IDE hard disk.
 *
 * DISK LAYOUT
 *  * This program(bootasm.S and bootmain.c) is the bootloader.
 *    It should be stored in the first sector of the disk.
 *         这个程序(bootasm.S and bootmain.c)是引导加载器程序，应该被保存在磁盘的第一个扇区
 *
 *  * The 2nd sector onward holds the kernel image.
 *         第二个扇区往后保存着内核映像
 *
 *  * The kernel image must be in ELF format.
 *         内核映像必须必须是ELF格式的
 *
 * BOOT UP STEPS
 *  * when the CPU boots it loads the BIOS into memory and executes it
 *
 *  * the BIOS intializes devices, sets of the interrupt routines, and
 *    reads the first sector of the boot device(e.g., hard-drive)
 *    into memory and jumps to it.
 *
 *  * Assuming this boot loader is stored in the first sector of the
 *    hard-drive, this code takes over...
 *
 *  * control starts in bootasm.S -- which sets up protected mode,
 *    and a stack so C code then run, then calls bootmain()
 *
 *  * bootmain() in this file takes over, reads in the kernel and jumps to it.
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;    SECTSIZE  =      &lt;span&gt;512&lt;/span&gt; ;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个磁盘扇区的大小为512字节&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt; elfhdr * ELFHDR    =      ((&lt;span&gt;struct&lt;/span&gt; elfhdr *)&lt;span&gt;0x10000&lt;/span&gt;) ;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; scratch space&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; waitdisk - wait for disk ready &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
waitdisk(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读数据，当0x1f7不为忙状态时，可以读&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; ((inb(&lt;span&gt;0x1F7&lt;/span&gt;) &amp;amp; &lt;span&gt;0xC0&lt;/span&gt;) != &lt;span&gt;0x40&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; do nothing &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; readsect - read a single sector at @secno into @dst &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取一个单独的扇区(由@secno指定)到@dst指针指向的内存中&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
readsect(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;dst, uint32_t secno) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; &lt;span&gt;https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_2_3_dist_accessing.html&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实验指导书lab1中的对ide硬盘的访问中有详细介绍

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait for disk to be ready&lt;/span&gt;
&lt;span&gt;    waitdisk();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 磁盘读取参数设置&lt;/span&gt;
    outb(&lt;span&gt;0x1F2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;);                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; count = 1&lt;/span&gt;
    outb(&lt;span&gt;0x1F3&lt;/span&gt;, secno &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;);
    outb(&lt;/span&gt;&lt;span&gt;0x1F4&lt;/span&gt;, (secno &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;);
    outb(&lt;/span&gt;&lt;span&gt;0x1F5&lt;/span&gt;, (secno &amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;);
    outb(&lt;/span&gt;&lt;span&gt;0x1F6&lt;/span&gt;, ((secno &amp;gt;&amp;gt; &lt;span&gt;24&lt;/span&gt;) &amp;amp; &lt;span&gt;0xF&lt;/span&gt;) | &lt;span&gt;0xE0&lt;/span&gt;&lt;span&gt;);
    outb(&lt;/span&gt;&lt;span&gt;0x1F7&lt;/span&gt;, &lt;span&gt;0x20&lt;/span&gt;);                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cmd 0x20 - read sectors

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait for disk to be ready&lt;/span&gt;
&lt;span&gt;    waitdisk();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; read a sector&lt;/span&gt;
    insl(&lt;span&gt;0x1F0&lt;/span&gt;, dst, SECTSIZE / &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; *
 * readseg - read @count bytes at @offset from kernel into virtual address @va,
 * might copy more than asked.
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
readseg(uintptr_t va, uint32_t count, uint32_t offset) {
    uintptr_t end_va &lt;/span&gt;= va +&lt;span&gt; count;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; round down to sector boundary&lt;/span&gt;
    va -= offset %&lt;span&gt; SECTSIZE;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; translate from bytes to sectors; kernel starts at sector 1
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算出需要读取的磁盘扇区号，由于第1个扇区被bootloader占据，kernel内核从第二个扇区开始(下标为1)，所以扇区号需要增加1&lt;/span&gt;
    uint32_t secno = (offset / SECTSIZE) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If this is too slow, we could read lots of sectors at a time.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We'd write more to memory than asked, but it doesn't matter --
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we load in increasing order.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环往复，通过va指针的自增，一个一个扇区的循环读取数据写入va指向的内存区域&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (; va &amp;lt; end_va; va += SECTSIZE, secno ++&lt;span&gt;) {
        readsect((&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)va, secno);
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; bootmain - the entry of bootloader &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
bootmain(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; read the 1st page off disk
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从硬盘中读取出内核文件ELF文件头数据，存入ELFHDR指针指向的内存区域 (大小为8个扇区)&lt;/span&gt;
    readseg((uintptr_t)ELFHDR, SECTSIZE * &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is this a valid ELF? 校验读取出来的ELF文件头的魔数值是否正确&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ELFHDR-&amp;gt;e_magic !=&lt;span&gt; ELF_MAGIC) {
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; bad;
    }

    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; proghdr *ph, *&lt;span&gt;eph;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; load each program segment (ignores ph flags)&lt;/span&gt;
    ph = (&lt;span&gt;struct&lt;/span&gt; proghdr *)((uintptr_t)ELFHDR + ELFHDR-&amp;gt;e_phoff); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据elf文件头，获得程序段的起始&lt;/span&gt;
    eph = ph + ELFHDR-&amp;gt;e_phnum; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 程序段起始指针(*ph)指针偏移程序段数目(ELFHDR-&amp;gt;e_phnum) = 最后一段程序的头部&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (; ph &amp;lt; eph; ph ++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环往复，将各个程序段的内容读取至指定的内存位置(ph-&amp;gt;p_va)&lt;/span&gt;
        readseg(ph-&amp;gt;p_va &amp;amp; &lt;span&gt;0xFFFFFF&lt;/span&gt;, ph-&amp;gt;p_memsz, ph-&amp;gt;&lt;span&gt;p_offset);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; call the entry point from the ELF header
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; note: does not return
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过函数指针的方式，跳转至ELFHDR-&amp;gt;e_entry指定的程序初始执行入口(即内核入口)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在makefile的配置中，ELFHDR-&amp;gt;e_entry指向的是kern/init/init.c中的kern_init函数 (kernel.ld中的ENTRY(kern_init))&lt;/span&gt;
    ((&lt;span&gt;void&lt;/span&gt; (*)(&lt;span&gt;void&lt;/span&gt;))(ELFHDR-&amp;gt;e_entry &amp;amp; &lt;span&gt;0xFFFFFF&lt;/span&gt;&lt;span&gt;))();

bad:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转至内核之后，不应该返回&lt;/span&gt;
    outw(&lt;span&gt;0x8A00&lt;/span&gt;, &lt;span&gt;0x8A00&lt;/span&gt;&lt;span&gt;);
    outw(&lt;/span&gt;&lt;span&gt;0x8A00&lt;/span&gt;, &lt;span&gt;0x8E00&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; do nothing &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;ucore内核结构分析&lt;/h2&gt;
&lt;p&gt;　　在bootloader将ucore的kernel内核完整的加载至内存，并通过ELF文件头中指定的entry入口跳转至内核入口，即/kern/init.c中的kern_init函数。&lt;/p&gt;
&lt;p&gt;　　kern_init函数是内核的总控函数，内核中的各个组成部分都在kern_init函数中完成初始化。&lt;/p&gt;
&lt;h3&gt;内核总控函数kern_init &lt;/h3&gt;
&lt;p&gt;　　总控函数一方面负责初始化与各种硬件的交互(例如与显卡、中断控制器、定时器等)，另一方面初始化各种内核功能(比如初始化物理内存管理器、中断描述符表IDT等)，之后便通过一个自旋死循环令操作系统常驻内存，通过监听各种中断提供操作系统服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;init.c(主体部分)：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &amp;lt;defs.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;console.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;kdebug.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;picirq.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;trap.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;clock.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;intr.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;pmm.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;kmonitor.h&amp;gt;
&lt;span&gt;void&lt;/span&gt; kern_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) __attribute__((noreturn));
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; grade_backtrace(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; lab1_switch_test(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 内核入口 总控函数
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
kern_init(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt; edata[], end[];
    memset(edata, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, end -&lt;span&gt; edata);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化控制台(控制显卡交互)，只有设置好了对显卡的控制后，std_out输出的信息（例如cprintf）才能显示在控制台中&lt;/span&gt;
    cons_init();                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; init the console&lt;/span&gt;

    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(THU.CST) os is loading ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, message);

    print_kerninfo();

    grade_backtrace();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化物理内存管理器&lt;/span&gt;
    pmm_init();                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; init physical memory management

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化中断控制器&lt;/span&gt;
    pic_init();                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; init interrupt controller
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化中断描述符表&lt;/span&gt;
    idt_init();                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; init interrupt descriptor table

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化定时芯片&lt;/span&gt;
    clock_init();               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; init clock interrupt
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开中断&lt;/span&gt;
    intr_enable();              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; enable irq interrupt

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; user/kernel mode switch test&lt;/span&gt;
&lt;span&gt;    lab1_switch_test();

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; do nothing &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 陷入死循环，避免内核程序退出。通过监听中断事件进行服务&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从kern_init函数的代码中可以看出，其依次完成了如下的几个主要工作：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1. cons_init &lt;/strong&gt; 初始化控制台(控制显卡交互)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2. pmm_init&lt;/strong&gt;  初始化物理内存管理器(lab1中里面暂时只是完成了GDT的重新设置，比较简单。而在lab2的物理内存管理的实现中，pmm_init才成为主角)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3. pic_init&lt;/strong&gt; 初始化中断控制器(内部通过与8259A中断控制器芯片进行交互，令ucore能够接收到来自硬件的各种中断请求)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4. idt_init&lt;/strong&gt; 初始化中断描述符表(在下面的中断机制一节中详细介绍)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5. clock_init&lt;/strong&gt; 初始化定时器(进行8253定时器的相关设置，将其设置为10ms发起一次时钟中断)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;6. intr_enable&lt;/strong&gt; 完成了内核结构的初始化后，开启中断，至此ucore内核正式开始运行&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;在kern_init的内核初始化过程中，涉及到的与显卡、定时器等硬件交互的地方，要想深入理解其工作原理，除了仔细阅读ucore的代码外，还需通过硬件手册等资料熟悉不同硬件提供的交互接口，限于篇幅就不再展开了。个人认为这一部分内容并不属于ucore的核心，如果不是特别感兴趣，可以将其暂时视为一个黑盒子，理解大致工作原理即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;ucore的中断工作机制&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　ucore在lab1中实现的一个非常重要的功能，就是建立了一个可以工作的中断服务框架。可以说操作系统的工作是离不开硬件提供的中断机制的。&lt;/p&gt;
&lt;p&gt;　　下面分析ucore的中断机制是如何工作的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;80386中断工作机制介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;前面提到过学习ucore的一个前提是对80386CPU的硬件工作原理有一定了解，这里先回顾一下80386的中断工作机制。&lt;/p&gt;
&lt;p&gt;　　1. 在80386中，为了更好的支持对中断服务例程的特权级保护，使用中断描述符表代替了8086中的中断向量表。和8086中断向量表被固定在低位内存不一样，80386CPU通过中断描述符表寄存器IDTR来定位中断描述符表IDT的位置，这给了操作系统的设计者一定的自主权。&lt;/p&gt;
&lt;p&gt;　　2. 80386在执行完每条指令后，都会检查当前是否存在中断请求。如果没有发现中断请求，则接着执行后续指令；如果发现存在中断请求，则会根据中断信号中给出的中断类型码，从中断描述符表中查找到对应的中断描述符，在中断描述符中记录了对应的中断服务例程的入口。&lt;/p&gt;
&lt;p&gt;　　3. 随后，CPU硬件会打断当前控制流，在栈上压入CS、EIP、EFLAGS等寄存器的内容(用于中断服务例程的返回)，跳转到对应的中断服务例程入口，进行中断请求的处理。当中断服务返回时，通过之前压入栈中的CS，EIP等返回到之前被中断请求打断的控制流中，恢复现场，继续运行。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;由于80386中断工作机制相对比较复杂，限于篇幅这里的流程介绍省略了不少细节。如果对这一块内容不熟悉的话需要通过实验指导书或是有关资料进行学习，或者参考我之前写的博客 &lt;a href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/archive/2004/01/13/13033786.html&quot; target=&quot;_blank&quot;&gt;80386学习（四） 80386中断&lt;/a&gt;，里面对此有较为详细的介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;ucore中断功能的组成部分&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　ucore的中断工作机制大致可以分为以下几个部分：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;1. IDT中断描述符表的建立&lt;/p&gt;
&lt;p&gt;　　2. 中断栈帧的生成&lt;/p&gt;
&lt;p&gt;　　3. 接收到中断栈帧，通过对应的中断服务例程进行处理&lt;/p&gt;
&lt;p&gt;　　4. 中断服务例程处理完毕，中断返回&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;IDT中断描述符表的建立&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在ucore中，对于中断描述符表IDT的初始化，是在&lt;strong&gt;kern_init&lt;/strong&gt;总控函数中通过&lt;strong&gt;idt_init&lt;/strong&gt;函数进行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; idt_init函数：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; *
 * Interrupt descriptor table:
 *
 * Must be built at run time because shifted function addresses can't
 * be represented in relocation records.
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; gatedesc idt[&lt;span&gt;256&lt;/span&gt;] = {{&lt;span&gt;0&lt;/span&gt;&lt;span&gt;}};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; pseudodesc idt_pd =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;(idt) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, (uintptr_t)idt
};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
idt_init(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; LAB1 YOUR CODE : STEP 2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
      *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?
      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c
      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR)
      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.
      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).
      *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT
      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.
      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
      *     Notice: the argument of lidt is idt_pd. try to find it!
      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;extern&lt;/span&gt;&lt;span&gt; uintptr_t __vectors[];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先通过tools/vector.c通过程序生成/kern/trap/verctor.S,并在加载内核时对之前已经声明的全局变量__vectors进行整体的赋值
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; __vectors数组中的每一项对应于中断描述符的中断服务例程的入口地址，在SETGATE宏的使用中可以体现出来
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将__vectors数组中每一项关于中断描述符的描述设置到下标相同的idt中，通过宏SETGATE构造出最终的中断描述符结构&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(idt) / &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; gatedesc); i ++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历idt数组，将其中的内容(中断描述符)设置进IDT中断描述符表中(默认的DPL特权级都是内核态DPL_KERNEL=0)&lt;/span&gt;
        SETGATE(idt[i], &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, GD_KTEXT, __vectors[i], DPL_KERNEL);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set for switch from user to kernel
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户态与内核态的互相转化是通过中断实现的，单独为其一个中断描述符
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于需要允许用户态的程序访问使用该中断，DPL特权级为用户态DPL_USER=3&lt;/span&gt;
    SETGATE(idt[T_SWITCH_TOK], &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; load the IDT 令IDTR中断描述符表寄存器指向idt_pd，加载IDT
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; idt_pd结构体中的前16位为描述符表的界限，pd_base指向之前完成了赋值操作的idt数组的起始位置&lt;/span&gt;
    lidt(&amp;amp;&lt;span&gt;idt_pd);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过上述代码的注释可以发现，在idt_init函数中，通过构建项目时自动生成的中断描述符元信息数组__vectors，在一个循环中，通过SETGATE宏，将idt[i]中的每一项都赋值了一个中断描述符。 可以看到中断描述符和gatedesc门描述符结构体的对应关系。&lt;strong&gt;(C中结构体的字段在内存中排布的顺序是按照定义的顺序，从低位到高位的)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中断门示意图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202009/1506329-20200926212300398-861111762.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gatedesc结构体：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Gate descriptors for interrupts and traps &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; gatedesc {
    unsigned gd_off_15_0 : &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; low 16 bits of offset in segment&lt;/span&gt;
    unsigned gd_ss : &lt;span&gt;16&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; segment selector&lt;/span&gt;
    unsigned gd_args : &lt;span&gt;5&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; # args, 0 for interrupt/trap gates&lt;/span&gt;
    unsigned gd_rsv1 : &lt;span&gt;3&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; reserved(should be zero I guess)&lt;/span&gt;
    unsigned gd_type : &lt;span&gt;4&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; type(STS_{TG,IG32,TG32})&lt;/span&gt;
    unsigned gd_s : &lt;span&gt;1&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; must be 0 (system)&lt;/span&gt;
    unsigned gd_dpl : &lt;span&gt;2&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; descriptor(meaning new) privilege level&lt;/span&gt;
    unsigned gd_p : &lt;span&gt;1&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Present&lt;/span&gt;
    unsigned gd_off_31_16 : &lt;span&gt;16&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; high bits of offset in segment&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;SETGATE宏：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; *
 * Set up a normal interrupt/trap gate descriptor
 *   - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate
 *   - sel: Code segment selector for interrupt/trap handler
 *   - off: Offset in code segment for interrupt/trap handler
 *   - dpl: Descriptor Privilege Level - the privilege level required
 *          for software to invoke this interrupt/trap gate explicitly
 *          using an int instruction.
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SETGATE(gate, istrap, sel, off, dpl) {            \&lt;span&gt;
    (gate).gd_off_15_0 &lt;/span&gt;= (uint32_t)(off) &amp;amp; &lt;span&gt;0xffff&lt;/span&gt;&lt;span&gt;;        \
    (gate).gd_ss &lt;/span&gt;=&lt;span&gt; (sel);                                \
    (gate).gd_args &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;                                    \
    (gate).gd_rsv1 &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;                                    \
    (gate).gd_type &lt;/span&gt;= (istrap) ?&lt;span&gt; STS_TG32 : STS_IG32;    \
    (gate).gd_s &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;                                    \
    (gate).gd_dpl &lt;/span&gt;=&lt;span&gt; (dpl);                                \
    (gate).gd_p &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;                                    \
    (gate).gd_off_31_16 &lt;/span&gt;= (uint32_t)(off) &amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;        \
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最终构建出了一个48位的结构体&lt;strong&gt;pseudodesc&lt;/strong&gt;，前16位标识着中断描述符表的大小(&lt;strong&gt;pd_lim&lt;/strong&gt;)，后32位标识着中断描述符表IDT的基址(&lt;strong&gt;pd_base&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;　　如果熟悉80386中断机制的话，就会发现这一结构与IDTR寄存器所需要的结构一致。在idt_init函数的最后，通过lidt函数执行汇编指令lidt，完成了对IDTR寄存器的赋值。至此，ucore的中断描述符表设置完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Pseudo-descriptors used for LGDT, LLDT(not used) and LIDT instructions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pseudodesc {
    uint16_t pd_lim;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Limit&lt;/span&gt;
    uint32_t pd_base;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Base address&lt;/span&gt;
} __attribute__ ((packed));
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;中断栈帧的生成&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　下面接着分析，中断描述符表里到底存放了什么数据结构，在ucore的中断服务功能的建立中是如何发挥作用的？&lt;/p&gt;
&lt;p&gt;　　打开之前用于构造中断描述符数组，为vertors赋值的/kern/trap/vector.S，可以看到其中的每一项的中断服务例程的代码都一样。有的项首先push了一个0，有的没有（下面会介绍为什么会有这种差异）。接下来将下标push压入栈中，便统一jmp跳转到了__alltraps处了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vector.S：&lt;/strong&gt;(很长，几乎都是脚本生成的模板代码)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_1da8e6e2-e5fa-4b54-b7f8-f2ada76b2b0a&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_1da8e6e2-e5fa-4b54-b7f8-f2ada76b2b0a&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1da8e6e2-e5fa-4b54-b7f8-f2ada76b2b0a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# handler
.text
.globl __alltraps
.globl vector0
&lt;/span&gt;&lt;span&gt;vector0:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector1
&lt;/span&gt;&lt;span&gt;vector1:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector2
&lt;/span&gt;&lt;span&gt;vector2:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector3
&lt;/span&gt;&lt;span&gt;vector3:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector4
&lt;/span&gt;&lt;span&gt;vector4:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector5
&lt;/span&gt;&lt;span&gt;vector5:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector6
&lt;/span&gt;&lt;span&gt;vector6:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector7
&lt;/span&gt;&lt;span&gt;vector7:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector8
&lt;/span&gt;&lt;span&gt;vector8:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector9
&lt;/span&gt;&lt;span&gt;vector9:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector10
&lt;/span&gt;&lt;span&gt;vector10:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector11
&lt;/span&gt;&lt;span&gt;vector11:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector12
&lt;/span&gt;&lt;span&gt;vector12:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector13
&lt;/span&gt;&lt;span&gt;vector13:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector14
&lt;/span&gt;&lt;span&gt;vector14:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector15
&lt;/span&gt;&lt;span&gt;vector15:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector16
&lt;/span&gt;&lt;span&gt;vector16:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector17
&lt;/span&gt;&lt;span&gt;vector17:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector18
&lt;/span&gt;&lt;span&gt;vector18:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector19
&lt;/span&gt;&lt;span&gt;vector19:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector20
&lt;/span&gt;&lt;span&gt;vector20:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector21
&lt;/span&gt;&lt;span&gt;vector21:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector22
&lt;/span&gt;&lt;span&gt;vector22:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector23
&lt;/span&gt;&lt;span&gt;vector23:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector24
&lt;/span&gt;&lt;span&gt;vector24:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector25
&lt;/span&gt;&lt;span&gt;vector25:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector26
&lt;/span&gt;&lt;span&gt;vector26:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector27
&lt;/span&gt;&lt;span&gt;vector27:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector28
&lt;/span&gt;&lt;span&gt;vector28:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector29
&lt;/span&gt;&lt;span&gt;vector29:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector30
&lt;/span&gt;&lt;span&gt;vector30:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector31
&lt;/span&gt;&lt;span&gt;vector31:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector32
&lt;/span&gt;&lt;span&gt;vector32:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector33
&lt;/span&gt;&lt;span&gt;vector33:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector34
&lt;/span&gt;&lt;span&gt;vector34:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector35
&lt;/span&gt;&lt;span&gt;vector35:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector36
&lt;/span&gt;&lt;span&gt;vector36:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector37
&lt;/span&gt;&lt;span&gt;vector37:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector38
&lt;/span&gt;&lt;span&gt;vector38:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector39
&lt;/span&gt;&lt;span&gt;vector39:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector40
&lt;/span&gt;&lt;span&gt;vector40:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector41
&lt;/span&gt;&lt;span&gt;vector41:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector42
&lt;/span&gt;&lt;span&gt;vector42:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector43
&lt;/span&gt;&lt;span&gt;vector43:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector44
&lt;/span&gt;&lt;span&gt;vector44:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector45
&lt;/span&gt;&lt;span&gt;vector45:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector46
&lt;/span&gt;&lt;span&gt;vector46:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector47
&lt;/span&gt;&lt;span&gt;vector47:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector48
&lt;/span&gt;&lt;span&gt;vector48:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector49
&lt;/span&gt;&lt;span&gt;vector49:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector50
&lt;/span&gt;&lt;span&gt;vector50:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector51
&lt;/span&gt;&lt;span&gt;vector51:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector52
&lt;/span&gt;&lt;span&gt;vector52:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector53
&lt;/span&gt;&lt;span&gt;vector53:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector54
&lt;/span&gt;&lt;span&gt;vector54:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector55
&lt;/span&gt;&lt;span&gt;vector55:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector56
&lt;/span&gt;&lt;span&gt;vector56:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector57
&lt;/span&gt;&lt;span&gt;vector57:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector58
&lt;/span&gt;&lt;span&gt;vector58:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector59
&lt;/span&gt;&lt;span&gt;vector59:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector60
&lt;/span&gt;&lt;span&gt;vector60:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector61
&lt;/span&gt;&lt;span&gt;vector61:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector62
&lt;/span&gt;&lt;span&gt;vector62:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector63
&lt;/span&gt;&lt;span&gt;vector63:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector64
&lt;/span&gt;&lt;span&gt;vector64:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector65
&lt;/span&gt;&lt;span&gt;vector65:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector66
&lt;/span&gt;&lt;span&gt;vector66:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector67
&lt;/span&gt;&lt;span&gt;vector67:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector68
&lt;/span&gt;&lt;span&gt;vector68:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector69
&lt;/span&gt;&lt;span&gt;vector69:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector70
&lt;/span&gt;&lt;span&gt;vector70:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector71
&lt;/span&gt;&lt;span&gt;vector71:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector72
&lt;/span&gt;&lt;span&gt;vector72:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector73
&lt;/span&gt;&lt;span&gt;vector73:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector74
&lt;/span&gt;&lt;span&gt;vector74:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector75
&lt;/span&gt;&lt;span&gt;vector75:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector76
&lt;/span&gt;&lt;span&gt;vector76:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector77
&lt;/span&gt;&lt;span&gt;vector77:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector78
&lt;/span&gt;&lt;span&gt;vector78:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector79
&lt;/span&gt;&lt;span&gt;vector79:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector80
&lt;/span&gt;&lt;span&gt;vector80:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector81
&lt;/span&gt;&lt;span&gt;vector81:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector82
&lt;/span&gt;&lt;span&gt;vector82:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector83
&lt;/span&gt;&lt;span&gt;vector83:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector84
&lt;/span&gt;&lt;span&gt;vector84:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector85
&lt;/span&gt;&lt;span&gt;vector85:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector86
&lt;/span&gt;&lt;span&gt;vector86:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector87
&lt;/span&gt;&lt;span&gt;vector87:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector88
&lt;/span&gt;&lt;span&gt;vector88:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector89
&lt;/span&gt;&lt;span&gt;vector89:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector90
&lt;/span&gt;&lt;span&gt;vector90:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector91
&lt;/span&gt;&lt;span&gt;vector91:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector92
&lt;/span&gt;&lt;span&gt;vector92:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector93
&lt;/span&gt;&lt;span&gt;vector93:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;93&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector94
&lt;/span&gt;&lt;span&gt;vector94:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;94&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector95
&lt;/span&gt;&lt;span&gt;vector95:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;95&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector96
&lt;/span&gt;&lt;span&gt;vector96:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;96&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector97
&lt;/span&gt;&lt;span&gt;vector97:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;97&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector98
&lt;/span&gt;&lt;span&gt;vector98:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;98&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector99
&lt;/span&gt;&lt;span&gt;vector99:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;99&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector100
&lt;/span&gt;&lt;span&gt;vector100:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector101
&lt;/span&gt;&lt;span&gt;vector101:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector102
&lt;/span&gt;&lt;span&gt;vector102:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector103
&lt;/span&gt;&lt;span&gt;vector103:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector104
&lt;/span&gt;&lt;span&gt;vector104:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector105
&lt;/span&gt;&lt;span&gt;vector105:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector106
&lt;/span&gt;&lt;span&gt;vector106:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector107
&lt;/span&gt;&lt;span&gt;vector107:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector108
&lt;/span&gt;&lt;span&gt;vector108:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector109
&lt;/span&gt;&lt;span&gt;vector109:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector110
&lt;/span&gt;&lt;span&gt;vector110:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector111
&lt;/span&gt;&lt;span&gt;vector111:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector112
&lt;/span&gt;&lt;span&gt;vector112:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector113
&lt;/span&gt;&lt;span&gt;vector113:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector114
&lt;/span&gt;&lt;span&gt;vector114:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector115
&lt;/span&gt;&lt;span&gt;vector115:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector116
&lt;/span&gt;&lt;span&gt;vector116:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector117
&lt;/span&gt;&lt;span&gt;vector117:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector118
&lt;/span&gt;&lt;span&gt;vector118:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector119
&lt;/span&gt;&lt;span&gt;vector119:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector120
&lt;/span&gt;&lt;span&gt;vector120:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector121
&lt;/span&gt;&lt;span&gt;vector121:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector122
&lt;/span&gt;&lt;span&gt;vector122:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector123
&lt;/span&gt;&lt;span&gt;vector123:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector124
&lt;/span&gt;&lt;span&gt;vector124:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector125
&lt;/span&gt;&lt;span&gt;vector125:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector126
&lt;/span&gt;&lt;span&gt;vector126:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector127
&lt;/span&gt;&lt;span&gt;vector127:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector128
&lt;/span&gt;&lt;span&gt;vector128:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector129
&lt;/span&gt;&lt;span&gt;vector129:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector130
&lt;/span&gt;&lt;span&gt;vector130:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector131
&lt;/span&gt;&lt;span&gt;vector131:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector132
&lt;/span&gt;&lt;span&gt;vector132:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector133
&lt;/span&gt;&lt;span&gt;vector133:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector134
&lt;/span&gt;&lt;span&gt;vector134:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector135
&lt;/span&gt;&lt;span&gt;vector135:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector136
&lt;/span&gt;&lt;span&gt;vector136:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector137
&lt;/span&gt;&lt;span&gt;vector137:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector138
&lt;/span&gt;&lt;span&gt;vector138:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector139
&lt;/span&gt;&lt;span&gt;vector139:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector140
&lt;/span&gt;&lt;span&gt;vector140:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector141
&lt;/span&gt;&lt;span&gt;vector141:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector142
&lt;/span&gt;&lt;span&gt;vector142:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector143
&lt;/span&gt;&lt;span&gt;vector143:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector144
&lt;/span&gt;&lt;span&gt;vector144:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector145
&lt;/span&gt;&lt;span&gt;vector145:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector146
&lt;/span&gt;&lt;span&gt;vector146:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector147
&lt;/span&gt;&lt;span&gt;vector147:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector148
&lt;/span&gt;&lt;span&gt;vector148:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector149
&lt;/span&gt;&lt;span&gt;vector149:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector150
&lt;/span&gt;&lt;span&gt;vector150:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector151
&lt;/span&gt;&lt;span&gt;vector151:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector152
&lt;/span&gt;&lt;span&gt;vector152:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector153
&lt;/span&gt;&lt;span&gt;vector153:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector154
&lt;/span&gt;&lt;span&gt;vector154:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector155
&lt;/span&gt;&lt;span&gt;vector155:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector156
&lt;/span&gt;&lt;span&gt;vector156:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector157
&lt;/span&gt;&lt;span&gt;vector157:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector158
&lt;/span&gt;&lt;span&gt;vector158:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector159
&lt;/span&gt;&lt;span&gt;vector159:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector160
&lt;/span&gt;&lt;span&gt;vector160:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector161
&lt;/span&gt;&lt;span&gt;vector161:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector162
&lt;/span&gt;&lt;span&gt;vector162:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector163
&lt;/span&gt;&lt;span&gt;vector163:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector164
&lt;/span&gt;&lt;span&gt;vector164:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector165
&lt;/span&gt;&lt;span&gt;vector165:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector166
&lt;/span&gt;&lt;span&gt;vector166:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector167
&lt;/span&gt;&lt;span&gt;vector167:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector168
&lt;/span&gt;&lt;span&gt;vector168:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector169
&lt;/span&gt;&lt;span&gt;vector169:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector170
&lt;/span&gt;&lt;span&gt;vector170:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector171
&lt;/span&gt;&lt;span&gt;vector171:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector172
&lt;/span&gt;&lt;span&gt;vector172:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector173
&lt;/span&gt;&lt;span&gt;vector173:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector174
&lt;/span&gt;&lt;span&gt;vector174:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector175
&lt;/span&gt;&lt;span&gt;vector175:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector176
&lt;/span&gt;&lt;span&gt;vector176:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector177
&lt;/span&gt;&lt;span&gt;vector177:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector178
&lt;/span&gt;&lt;span&gt;vector178:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector179
&lt;/span&gt;&lt;span&gt;vector179:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector180
&lt;/span&gt;&lt;span&gt;vector180:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector181
&lt;/span&gt;&lt;span&gt;vector181:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector182
&lt;/span&gt;&lt;span&gt;vector182:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector183
&lt;/span&gt;&lt;span&gt;vector183:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector184
&lt;/span&gt;&lt;span&gt;vector184:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector185
&lt;/span&gt;&lt;span&gt;vector185:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector186
&lt;/span&gt;&lt;span&gt;vector186:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector187
&lt;/span&gt;&lt;span&gt;vector187:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector188
&lt;/span&gt;&lt;span&gt;vector188:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector189
&lt;/span&gt;&lt;span&gt;vector189:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector190
&lt;/span&gt;&lt;span&gt;vector190:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector191
&lt;/span&gt;&lt;span&gt;vector191:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector192
&lt;/span&gt;&lt;span&gt;vector192:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector193
&lt;/span&gt;&lt;span&gt;vector193:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector194
&lt;/span&gt;&lt;span&gt;vector194:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector195
&lt;/span&gt;&lt;span&gt;vector195:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector196
&lt;/span&gt;&lt;span&gt;vector196:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector197
&lt;/span&gt;&lt;span&gt;vector197:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector198
&lt;/span&gt;&lt;span&gt;vector198:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector199
&lt;/span&gt;&lt;span&gt;vector199:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector200
&lt;/span&gt;&lt;span&gt;vector200:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector201
&lt;/span&gt;&lt;span&gt;vector201:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector202
&lt;/span&gt;&lt;span&gt;vector202:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector203
&lt;/span&gt;&lt;span&gt;vector203:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector204
&lt;/span&gt;&lt;span&gt;vector204:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector205
&lt;/span&gt;&lt;span&gt;vector205:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector206
&lt;/span&gt;&lt;span&gt;vector206:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector207
&lt;/span&gt;&lt;span&gt;vector207:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector208
&lt;/span&gt;&lt;span&gt;vector208:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector209
&lt;/span&gt;&lt;span&gt;vector209:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector210
&lt;/span&gt;&lt;span&gt;vector210:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector211
&lt;/span&gt;&lt;span&gt;vector211:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector212
&lt;/span&gt;&lt;span&gt;vector212:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector213
&lt;/span&gt;&lt;span&gt;vector213:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector214
&lt;/span&gt;&lt;span&gt;vector214:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector215
&lt;/span&gt;&lt;span&gt;vector215:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector216
&lt;/span&gt;&lt;span&gt;vector216:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector217
&lt;/span&gt;&lt;span&gt;vector217:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector218
&lt;/span&gt;&lt;span&gt;vector218:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector219
&lt;/span&gt;&lt;span&gt;vector219:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector220
&lt;/span&gt;&lt;span&gt;vector220:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector221
&lt;/span&gt;&lt;span&gt;vector221:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector222
&lt;/span&gt;&lt;span&gt;vector222:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector223
&lt;/span&gt;&lt;span&gt;vector223:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector224
&lt;/span&gt;&lt;span&gt;vector224:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector225
&lt;/span&gt;&lt;span&gt;vector225:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector226
&lt;/span&gt;&lt;span&gt;vector226:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector227
&lt;/span&gt;&lt;span&gt;vector227:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector228
&lt;/span&gt;&lt;span&gt;vector228:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector229
&lt;/span&gt;&lt;span&gt;vector229:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector230
&lt;/span&gt;&lt;span&gt;vector230:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector231
&lt;/span&gt;&lt;span&gt;vector231:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector232
&lt;/span&gt;&lt;span&gt;vector232:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector233
&lt;/span&gt;&lt;span&gt;vector233:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector234
&lt;/span&gt;&lt;span&gt;vector234:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector235
&lt;/span&gt;&lt;span&gt;vector235:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector236
&lt;/span&gt;&lt;span&gt;vector236:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector237
&lt;/span&gt;&lt;span&gt;vector237:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector238
&lt;/span&gt;&lt;span&gt;vector238:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector239
&lt;/span&gt;&lt;span&gt;vector239:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector240
&lt;/span&gt;&lt;span&gt;vector240:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector241
&lt;/span&gt;&lt;span&gt;vector241:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector242
&lt;/span&gt;&lt;span&gt;vector242:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector243
&lt;/span&gt;&lt;span&gt;vector243:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector244
&lt;/span&gt;&lt;span&gt;vector244:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector245
&lt;/span&gt;&lt;span&gt;vector245:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector246
&lt;/span&gt;&lt;span&gt;vector246:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector247
&lt;/span&gt;&lt;span&gt;vector247:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector248
&lt;/span&gt;&lt;span&gt;vector248:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector249
&lt;/span&gt;&lt;span&gt;vector249:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector250
&lt;/span&gt;&lt;span&gt;vector250:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector251
&lt;/span&gt;&lt;span&gt;vector251:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector252
&lt;/span&gt;&lt;span&gt;vector252:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector253
&lt;/span&gt;&lt;span&gt;vector253:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector254
&lt;/span&gt;&lt;span&gt;vector254:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps
.globl vector255
&lt;/span&gt;&lt;span&gt;vector255:&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  pushl $&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;
  &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; __alltraps

# vector table
.data
.globl __vectors
&lt;/span&gt;&lt;span&gt;__vectors:&lt;/span&gt;&lt;span&gt;
  .long vector0
  .long vector1
  .long vector2
  .long vector3
  .long vector4
  .long vector5
  .long vector6
  .long vector7
  .long vector8
  .long vector9
  .long vector10
  .long vector11
  .long vector12
  .long vector13
  .long vector14
  .long vector15
  .long vector16
  .long vector17
  .long vector18
  .long vector19
  .long vector20
  .long vector21
  .long vector22
  .long vector23
  .long vector24
  .long vector25
  .long vector26
  .long vector27
  .long vector28
  .long vector29
  .long vector30
  .long vector31
  .long vector32
  .long vector33
  .long vector34
  .long vector35
  .long vector36
  .long vector37
  .long vector38
  .long vector39
  .long vector40
  .long vector41
  .long vector42
  .long vector43
  .long vector44
  .long vector45
  .long vector46
  .long vector47
  .long vector48
  .long vector49
  .long vector50
  .long vector51
  .long vector52
  .long vector53
  .long vector54
  .long vector55
  .long vector56
  .long vector57
  .long vector58
  .long vector59
  .long vector60
  .long vector61
  .long vector62
  .long vector63
  .long vector64
  .long vector65
  .long vector66
  .long vector67
  .long vector68
  .long vector69
  .long vector70
  .long vector71
  .long vector72
  .long vector73
  .long vector74
  .long vector75
  .long vector76
  .long vector77
  .long vector78
  .long vector79
  .long vector80
  .long vector81
  .long vector82
  .long vector83
  .long vector84
  .long vector85
  .long vector86
  .long vector87
  .long vector88
  .long vector89
  .long vector90
  .long vector91
  .long vector92
  .long vector93
  .long vector94
  .long vector95
  .long vector96
  .long vector97
  .long vector98
  .long vector99
  .long vector100
  .long vector101
  .long vector102
  .long vector103
  .long vector104
  .long vector105
  .long vector106
  .long vector107
  .long vector108
  .long vector109
  .long vector110
  .long vector111
  .long vector112
  .long vector113
  .long vector114
  .long vector115
  .long vector116
  .long vector117
  .long vector118
  .long vector119
  .long vector120
  .long vector121
  .long vector122
  .long vector123
  .long vector124
  .long vector125
  .long vector126
  .long vector127
  .long vector128
  .long vector129
  .long vector130
  .long vector131
  .long vector132
  .long vector133
  .long vector134
  .long vector135
  .long vector136
  .long vector137
  .long vector138
  .long vector139
  .long vector140
  .long vector141
  .long vector142
  .long vector143
  .long vector144
  .long vector145
  .long vector146
  .long vector147
  .long vector148
  .long vector149
  .long vector150
  .long vector151
  .long vector152
  .long vector153
  .long vector154
  .long vector155
  .long vector156
  .long vector157
  .long vector158
  .long vector159
  .long vector160
  .long vector161
  .long vector162
  .long vector163
  .long vector164
  .long vector165
  .long vector166
  .long vector167
  .long vector168
  .long vector169
  .long vector170
  .long vector171
  .long vector172
  .long vector173
  .long vector174
  .long vector175
  .long vector176
  .long vector177
  .long vector178
  .long vector179
  .long vector180
  .long vector181
  .long vector182
  .long vector183
  .long vector184
  .long vector185
  .long vector186
  .long vector187
  .long vector188
  .long vector189
  .long vector190
  .long vector191
  .long vector192
  .long vector193
  .long vector194
  .long vector195
  .long vector196
  .long vector197
  .long vector198
  .long vector199
  .long vector200
  .long vector201
  .long vector202
  .long vector203
  .long vector204
  .long vector205
  .long vector206
  .long vector207
  .long vector208
  .long vector209
  .long vector210
  .long vector211
  .long vector212
  .long vector213
  .long vector214
  .long vector215
  .long vector216
  .long vector217
  .long vector218
  .long vector219
  .long vector220
  .long vector221
  .long vector222
  .long vector223
  .long vector224
  .long vector225
  .long vector226
  .long vector227
  .long vector228
  .long vector229
  .long vector230
  .long vector231
  .long vector232
  .long vector233
  .long vector234
  .long vector235
  .long vector236
  .long vector237
  .long vector238
  .long vector239
  .long vector240
  .long vector241
  .long vector242
  .long vector243
  .long vector244
  .long vector245
  .long vector246
  .long vector247
  .long vector248
  .long vector249
  .long vector250
  .long vector251
  .long vector252
  .long vector253
  .long vector254
  .long vector255&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 　　__alltraps是定义在同一目录下即/kern/trap/trapentry.S中的。&lt;/p&gt;
&lt;p&gt;　　在__alltraps中，按照顺序将当前的各个常用的寄存器的值压入了栈中，随后将ds、es等数据段寄存器载入了内核的数据段选择子(这是因为中断可能来自用户态，而中断服务例程必须在内核态运行以拥有所有资源的访问权限，避免内核中的中断服务例程由于特权级不够，访问数据时出现问题)。&lt;/p&gt;
&lt;p&gt;　　随后栈中压入esp的值，便通过call trap跳转到了内核的中断服务分发函数trap中。trap函数位于/kern/trap/trap.c中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trapentry.S：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include &amp;lt;memlayout.h&amp;gt;

# vectors.S sends all traps here.
.text
.globl __alltraps
&lt;/span&gt;&lt;span&gt;__alltraps:&lt;/span&gt;&lt;span&gt;
    # &lt;/span&gt;&lt;span&gt;push&lt;/span&gt;&lt;span&gt; registers to build a trap frame
    # therefore make the stack look like a struct trapframe
    pushl %ds
    pushl %es
    pushl %fs
    pushl %gs
    pushal

    # load GD_KDATA &lt;/span&gt;&lt;span&gt;into&lt;/span&gt; %ds &lt;span&gt;and&lt;/span&gt;&lt;span&gt; %es to set up data segments for kernel
    movl $GD_KDATA, %eax
    movw %ax, %ds
    movw %ax, %es

    # &lt;/span&gt;&lt;span&gt;push&lt;/span&gt;&lt;span&gt; %esp to pass a pointer to the trapframe as an argument to trap()
    pushl %esp

    # &lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt; trap(tf), where tf=%esp
    &lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt; trap

    # &lt;/span&gt;&lt;span&gt;pop&lt;/span&gt;&lt;span&gt; the pushed stack pointer
    popl %esp

    # return falls through to trapret...
.globl __trapret
&lt;/span&gt;&lt;span&gt;__trapret:&lt;/span&gt;&lt;span&gt;
    # restore registers from stack
    popal

    # restore %ds, %es, %fs &lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt; %gs
    popl %gs
    popl %fs
    popl %es
    popl %ds

    # get rid of the trap number &lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt; error code
    addl $0x8, %esp
    &lt;/span&gt;&lt;span&gt;iret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;trap函数入口：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; *
 * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
 * the code in kern/trap/trapentry.S restores the old CPU state saved in the
 * trapframe and then uses the iret instruction to return from the exception.
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
trap(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; trapframe *&lt;span&gt;tf) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dispatch based on what type of trap occurred&lt;/span&gt;
&lt;span&gt;    trap_dispatch(tf);
}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;trap函数的参数是trapframe结构体。仔细观察可以看到，trapframe中字段属性的定义和&lt;strong&gt;trapentry.S&lt;/strong&gt;中入栈的顺序是相反的。&lt;/p&gt;
&lt;p&gt;　　1. 第一个字段pushregs保存了pushal压入栈中的数据，后续的tf_gs + tf_padding0两个字段是因为pushl会压入一个32位的数据，而gs数据段寄存器本身保存的段选择子是16位的，需要一个16位的padding空闲字段合并起来与之对应。后面的fs、es、ds原理一样。&lt;/p&gt;
&lt;p&gt;　　2. 之后的tf_trapno属性对应着跳转至__alltraps之前所压入栈中的中断向量号，tf_err对应的是在上面的pushl $0，即错误号。根据注释可以看到，包括tf_err在内的中断错误号都是x86CPU硬件在中断发生时自动压入栈中的。但并不是所有的硬件中断都会被自动压入错误号(需要去阅读硬件手册才能知道具体细节)，&lt;strong&gt;为了能够以一个统一的接口去处理所有的中断请求&lt;/strong&gt;，在vertor.S中对于没有错误号的中断请求默认加上了pushl $0，压入一个默认的错误号0；对于CPU硬件会压入错误号的中断向量则没有进行默认处理，例如vertor8、vertor9等等。&lt;/p&gt;
&lt;p&gt;　　3. 发生中断时，x86CPU会默认按照顺序依次压入eflags、cs和eip用于中断后的现场恢复。对应的是tf_eip、tf_cs + tf_padding4以及tf_eflags。而当发生了CPL特权级的变化时，x86CPU硬件会发生不同特权级栈的切换，因此还会先依次压入切换特权级前的ss栈段寄存器和esp栈顶指针的值入栈，便于中断返回后回到对应的特权级中。一个很典型的例子就是，当用户程序执行系统调用时(系统调用是通过中断机制实现的，在ucore的lab5中实现了这一功能)，会从用户的CPL特权级ring3切换到内核的特权级ring0，系统调用的服务例程是在分配好的内核栈中执行的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; registers as pushed by pushal &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pushregs {
    uint32_t reg_edi;
    uint32_t reg_esi;
    uint32_t reg_ebp;
    uint32_t reg_oesp;            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Useless &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    uint32_t reg_ebx;
    uint32_t reg_edx;
    uint32_t reg_ecx;
    uint32_t reg_eax;
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; trapframe {
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pushregs tf_regs;
    uint16_t tf_gs;
    uint16_t tf_padding0;
    uint16_t tf_fs;
    uint16_t tf_padding1;
    uint16_t tf_es;
    uint16_t tf_padding2;
    uint16_t tf_ds;
    uint16_t tf_padding3;
    uint32_t tf_trapno;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; below here defined by x86 hardware &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    uint32_t tf_err;
    uintptr_t tf_eip;
    uint16_t tf_cs;
    uint16_t tf_padding4;
    uint32_t tf_eflags;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; below here only when crossing rings, such as from user to kernel &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    uintptr_t tf_esp;
    uint16_t tf_ss;
    uint16_t tf_padding5;
} __attribute__((packed));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;为什么tramframe中断栈帧的结构属性的定义顺序会和入栈时的顺序相反？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　要理解这个需要对C语言编译后的底层机器代码模型有一定了解。&lt;/p&gt;
&lt;p&gt;　　1.C语言结构体定义的内存排布是按照字段定义顺序，从内存的低位到高位延伸的。&lt;/p&gt;
&lt;p&gt;　　2.栈在压入数据时，栈顶指针是递减的，由高位往低位延伸的。&lt;/p&gt;
&lt;p&gt;　　3.trap函数的参数trapframe指针指向的是当前栈顶，相对处于低位，而对所包含的字段则是在这个指针的基础上向高位偏移对应的N个字节来访问的。&lt;strong&gt;要想在C中通过一个结构体映射出栈上的内存数据便于后续的访问，那么必须以和入栈顺序相反的顺序来定义结构体。&lt;/strong&gt;栈帧结构体trapframe定义最后的__attribute__((packed))指的是强制令C编译器使用&lt;strong&gt;紧凑模式&lt;/strong&gt;处理该结构体，避免编译器在字段的处理上进行额外的内存对齐操作，导致访问时最后生成的内存地址访问偏移量计算错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;这里需要注意的一点是，当处理没有发生特权级切换的中断时，trapframe对应的最后三个字段是不存在于栈上的，此时如果通过tf_ss等属性访问时，会越界访问到原本在栈上不相关的数据。所以在访问这几个字段时，必须先判断是否发生了特权级的变化，避免损坏栈上数据，令程序出错甚至崩溃。&lt;/p&gt;
&lt;h3&gt;中断服务例程进行处理&lt;/h3&gt;
&lt;p&gt;　　现在分析当中断发生时，trap函数接收到trapframe中断帧参数后是如何进行中断服务处理的。&lt;/p&gt;
&lt;p&gt;　　在lab1中，trap函数只是简单的调用了同一文件中的trap_dispatch函数，在trap_dispatch中通过对tf-&amp;gt;tf_trapno，即中断向量号进行判断，将控制流转移至中断向量号对应的中断服务例程中。(这里trap函数只是简单的调用trap_dispatch，是因为后续的lab中，会在trap函数中在中断处理服务开始前后加入许多逻辑，预先将对中断请求的分发逻辑抽取了出来)&lt;/p&gt;
&lt;p&gt;　　比如第一个case块便是用于处理时钟中断的。在lab1中，通过一个被volatile关键字修饰的ticks全局变量，在每次时钟中断时累加1，当次数每达到TICK_NUM时（默认100，对应的是10ms一次的时钟中断），便打印一段话。体现在lab1实验中便是，ucore内核启动完成后，控制台每秒钟周期性的打印出&quot;100ticks&quot;。&lt;/p&gt;
&lt;p&gt;　　可以看到，虽然80386CPU的硬件设计者希望操作系统的设计者直接在中断描述符中设置对应的中断服务例程的入口地址，但ucore却没有充分利用这一特性，而是选择了在中断服务例程的入口处简单压入几个数据后将中断服务的控制流程统一的指向了__alltraps，最后通过trap_dispatch函数进行分发。这样的设计虽然在性能上可能有微小的损失，但是却使得ucore的中断服务实现更加灵活、可控。(作为一个java后端程序员，这一设计令我想到了springmvc框架基于下层servlet的封装机制：通过一个/*的servlet获得所有请求的控制权，再由框架灵活封装各种参数，最后将参数和控制权交给对应的controller方法进行处理)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trap_dispatch函数：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; trap_dispatch - dispatch based on what type of trap occurred &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
trap_dispatch(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; trapframe *&lt;span&gt;tf) {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c;

    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (tf-&amp;gt;&lt;span&gt;tf_trapno) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; IRQ_OFFSET +&lt;span&gt; IRQ_TIMER:
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; LAB1 YOUR CODE : STEP 3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; handle the timer interrupt &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
         * (3) Too Simple? Yes, I think so!
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ticks &lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ticks % TICK_NUM == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            print_ticks();
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; IRQ_OFFSET +&lt;span&gt; IRQ_COM1:
        c &lt;/span&gt;=&lt;span&gt; cons_getc();
        cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;serial [%03d] %c\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, c, c);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; IRQ_OFFSET +&lt;span&gt; IRQ_KBD:
        c &lt;/span&gt;=&lt;span&gt; cons_getc();
        cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kbd [%03d] %c\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, c, c);
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; T_SWITCH_TOU:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tf-&amp;gt;tf_cs !=&lt;span&gt; USER_CS) {
            switchk2u &lt;/span&gt;= *&lt;span&gt;tf;
            switchk2u.tf_cs &lt;/span&gt;=&lt;span&gt; USER_CS;
            switchk2u.tf_ds &lt;/span&gt;= switchk2u.tf_es = switchk2u.tf_ss =&lt;span&gt; USER_DS;
            switchk2u.tf_esp &lt;/span&gt;= (uint32_t)tf + &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; trapframe) - &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
        
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set eflags, make sure ucore can use io under user mode.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if CPL &amp;gt; IOPL, then cpu will generate a general protection.&lt;/span&gt;
            switchk2u.tf_eflags |=&lt;span&gt; FL_IOPL_MASK;
        
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set temporary stack
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; then iret will jump to the right stack&lt;/span&gt;
            *((uint32_t *)tf - &lt;span&gt;1&lt;/span&gt;) = (uint32_t)&amp;amp;&lt;span&gt;switchk2u;
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; T_SWITCH_TOK:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tf-&amp;gt;tf_cs !=&lt;span&gt; KERNEL_CS) {
            tf&lt;/span&gt;-&amp;gt;tf_cs =&lt;span&gt; KERNEL_CS;
            tf&lt;/span&gt;-&amp;gt;tf_ds = tf-&amp;gt;tf_es =&lt;span&gt; KERNEL_DS;
            tf&lt;/span&gt;-&amp;gt;tf_eflags &amp;amp;= ~&lt;span&gt;FL_IOPL_MASK;
            switchu2k &lt;/span&gt;= (&lt;span&gt;struct&lt;/span&gt; trapframe *)(tf-&amp;gt;tf_esp - (&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; trapframe) - &lt;span&gt;8&lt;/span&gt;&lt;span&gt;));
            memmove(switchu2k, tf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; trapframe) - &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;*((uint32_t *)tf - &lt;span&gt;1&lt;/span&gt;) =&lt;span&gt; (uint32_t)switchu2k;
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; IRQ_OFFSET +&lt;span&gt; IRQ_IDE1:
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; IRQ_OFFSET +&lt;span&gt; IRQ_IDE2:
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; do nothing &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; in kernel, it must be a mistake&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((tf-&amp;gt;tf_cs &amp;amp; &lt;span&gt;3&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            print_trapframe(tf);
            panic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unexpected trap in kernel.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;中断返回&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;中断服务例程用于处理突发性的中断事件，一般来说都是短小精悍的服务代码，会很快的执行完毕并返回。下面接着分析ucore在中断返回时的处理机制。&lt;/p&gt;
&lt;p&gt;　　在trap函数返回后，代码的控制流回到了trapentry.S中，即CPU指令指向call trap的下一条指令。为了保证中断服务返回后之前被中断程序上下文的正确性，需要将执行call trap之前的压入的数据一一弹出还原。&lt;/p&gt;
&lt;p&gt;　　1. 按照相反的顺序弹出、还原各个常用寄存器的值(popl esp、popal、popl gs/fs/es/ds)。&lt;/p&gt;
&lt;p&gt;　　2. 通过addl $0x8, %esp，以直接上移栈顶指针的方式，略过之前压入的中断号tf_trapno和错误码tf_err。&lt;/p&gt;
&lt;p&gt;　　3. 执行iret指令，iret指令会将之前硬件自动压入的eip、cs、eflags按照顺序弹出。&lt;strong&gt;当CPU发现弹出时的cs值和当前cs值不一致，则认定此次中断发生了特权级的变化。此时CPU会接着弹出之前压入了的esp、ss寄存器的值，令其返回到中断发生前对应的特权级栈中继续执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;CPU认为只有之前发生特权级变化时才会额外压入ss、esp，所以中断返回时如果发现弹出的cs与当前cs不一致时，除了恢复之前栈上的cs(也恢复了CPL)，同时会额外的弹出esp、ss。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这特权级一机制在lab1的挑战练习&lt;strong&gt;lab1 challenge1&lt;/strong&gt;中被利用了起来，挑战练习1需要模拟出内核态转化至用户态，再从用户态再转换回内核态的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lab1挑战练习1实现原理分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在kern_init总控函数中，最后通过lab1_switch_test来实现这一过程。&lt;/p&gt;
&lt;p&gt;　　lab1_switch_to_user函数中，通过内联汇编执行了int命令，触发了一个软中断，中断号为T_SWITCH_TOU。控制流最终会指向trap_dispatch函数中对应的case块中，在其中通过修改当前中断栈帧中的cs代码段寄存器、ds、es、ss等数据段寄存器的值，使得中断栈帧上的CS的段选择子的值为用户态。这样在中断返回时，便&lt;strong&gt;&quot;欺骗&quot;&lt;/strong&gt;了CPU，使得CPU在中断返回后将当前的特权级由内核态切换到了用户态。在后续的实验中，例如通过系统调用加载并运行一个用户态应用程序，就是通过这一&quot;欺骗&quot;机制巧妙地实现特权级的切换。&lt;/p&gt;
&lt;p&gt;　　lab1_switch_to_kernel函数中，同样通过内联汇编执行int命令触发软中断，中断号为T_SWITCH_TOK。控制流最终指向trap_dispatch函数中对应的case块中，通过设置cs代码段寄存器的值为内核代码段、ds、es设置为内核数据段来实现中断返回后，令CPU再从用户态回到内核态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
lab1_switch_test(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    lab1_print_cur_status();
    cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+++ switch to  user  mode +++\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    lab1_switch_to_user();
    lab1_print_cur_status();
    cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+++ switch to kernel mode +++\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    lab1_switch_to_kernel();
    lab1_print_cur_status();
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
lab1_switch_to_user(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LAB1 CHALLENGE 1 : TODO&lt;/span&gt;
    asm &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; (
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sub $0x8, %%esp \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int %0 \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;movl %%ebp, %%esp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        : 
        : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(T_SWITCH_TOU)
    );
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;
lab1_switch_to_kernel(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LAB1 CHALLENGE 1 :  TODO&lt;/span&gt;
    asm &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; (
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int %0 \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;movl %%ebp, %%esp \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        : 
        : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(T_SWITCH_TOK)
    );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　从年初接触ucore到现在完成学习，通过博客总结心得已经过去了大半年。学习ucore就像攀爬一座高山一样，最初的我由于汇编、C等基础的前置知识掌握的不牢靠，导致每每想研究ucore源码时都因为看不懂代码而宣告失败，因此我下定决心将汇编和C重新学习了一遍。虽然最初的动机是为了更好的学习ucore，但在学习过程中我却收获颇丰，领略了登山途中的好风景。一方面使我对计算机底层的运行机制建立起了一个大致的知识框架，理解了CPU的运行机制、中断等硬件的工作原理（主要还是单核CPU的工作原理）。另一方面，随着对汇编、C语言的进一步学习，也慢慢的理解了《黑客与画家》中对于编程语言抽象能力的看法，为什么计算机硬件不断发展，抽象程度更高但性能较低的编程语言会变得越来越流行。&lt;/p&gt;
&lt;p&gt;　　正如C语言最初作为一种&quot;高级汇编语言&quot;而出现，其提供的数组、结构体、指针等机制简化了汇编中令人头疼的访问数据时的地址偏移问题。同时C还提供了标准库，在绝大多数场景下能够屏蔽掉不同硬件、操作系统平台的差异，使其做到一次编写，到处编译。而C++作为C的高级版本，提供了面向对象的编程机制，由编译器提供多态等诸多语法糖，由编译器来自动完成之前需要C程序员通过函数指针集合等方式手动实现的面向对象逻辑。java作为C++的后继者，认为C++为了兼容C依然保留了太多应用程序开发时不需要的底层功能，便将包括指针、goto在内的许多机制都隐藏起来了，不让程序员直接接触，通过jvm在绝大多数场景下屏蔽了不同操作系统平台的差异。而Lisp语言的抽象程度则更高，正同《程序员的呐喊》中所说的：“Lisp假装操作系统不存在”。如果不考虑在当前冯.诺依曼架构机器上的运行效率，LISP倡导的就是肆无忌惮的进行函数递归而不必担心栈溢出，为了使函数调用无副作用可以任意的copy数据，而不必担心内存不足和垃圾回收的负担，最重要的是程序的可读性、可维护性，怎么方便人思考怎么来，不太关心空间、时间性能。随着机器性能的不断提升，未来的编程语言实现中也许真的可以用kv Map完全的替代数组，甚至用丘奇数来替代整数以追求数学上极致简约的美？Orz&lt;/p&gt;
&lt;p&gt;　　任意编程语言的内容主要分为两部分，一是基础语法，另一部分则是在基于的特定平台上功能的封装。例如javascript由ECMA语法和对其工作平台浏览器相关功能的封装组成，而java、nodejs等通用编程语言则是由语法和对操作系统功能的封装。作为一个以java作为日常开发语言的我来说，学习ucore让我对java中诸如并发同步、BIO/NIO等机制有了进一步的理解，解开了不少对于jvm底层与操作系统交互机制的困惑。总而言之，学习操作系统还是能学到很多知识的，而ucore os网上公开课就是一个很好的学习方式。&lt;/p&gt;
&lt;p&gt;　　这是我ucore学习系列博客的第一篇博客，未来会不断的更新后续实验的学习心得，博客中会尝试着尽量将初学者可能碰到的各种疑惑一一解答。希望能帮助到对操作系统、ucore os感兴趣的人。&lt;/p&gt;
&lt;p&gt;　　这篇博客的完整代码在我的github上：&lt;a href=&quot;https://github.com/1399852153/ucore_os_lab&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/ucore_os_lab (fork自官方仓库)&lt;/a&gt;中的lab1_answer，存在许多不足之处，还请多多指教。&lt;/p&gt;
</description>
<pubDate>Mon, 28 Sep 2020 14:37:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>一、ucore操作系统介绍 操作系统作为一个基础系统软件，对下控制硬件(cpu、内存、磁盘网卡等外设)，屏蔽了底层复杂多样的硬件差异；对上则提供封装良好的应用程序接口，简化应用程序开发者的使用难度。站</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoxiongcanguan/p/13714587.html</dc:identifier>
</item>
<item>
<title>Java反应式框架Reactor中的Mono和Flux - 码农小胖哥</title>
<link>http://www.cnblogs.com/felordcn/p/13747262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/felordcn/p/13747262.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200928222605902-1781133476.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;最近写关于响应式编程的东西有点多，很多同学反映对&lt;code&gt;Flux&lt;/code&gt;和&lt;code&gt;Mono&lt;/code&gt;这两个&lt;strong&gt;Reactor&lt;/strong&gt;中的概念有点懵逼。但是目前&lt;strong&gt;Java&lt;/strong&gt;响应式编程中我们对这两个对象的接触又最多，诸如&lt;strong&gt;Spring WebFlux&lt;/strong&gt;、&lt;strong&gt;RSocket&lt;/strong&gt;、&lt;strong&gt;R2DBC&lt;/strong&gt;。我开始也对这两个对象头疼，所以今天我们就简单来探讨一下它们。&lt;/p&gt;
&lt;h2 id=&quot;2-响应流的特点&quot;&gt;2. 响应流的特点&lt;/h2&gt;
&lt;p&gt;要搞清楚这两个概念，必须说一下响应流规范。它是响应式编程的基石。他具有以下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应流必须是无阻塞的。&lt;/li&gt;
&lt;li&gt;响应流必须是一个数据流。&lt;/li&gt;
&lt;li&gt;它必须可以异步执行。&lt;/li&gt;
&lt;li&gt;并且它也应该能够处理背压。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;背压是反应流中的一个重要概念，可以理解为，生产者可以感受到消费者反馈的消费压力，并根据压力进行动态调整生产速率。形象点可以按照下面理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200928222606736-422622749.png&quot; alt=&quot;有没有背压的两种情形&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-publisher&quot;&gt;3. Publisher&lt;/h2&gt;
&lt;p&gt;由于响应流的特点，我们不能再返回一个简单的&lt;strong&gt;POJO&lt;/strong&gt;对象来表示结果了。必须返回一个类似&lt;strong&gt;Java&lt;/strong&gt;中的&lt;code&gt;Future&lt;/code&gt;的概念，在有结果可用时通知消费者进行消费响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reactive Stream&lt;/strong&gt;规范中这种被定义为&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt; ，&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;是一个可以提供0-N个序列元素的提供者，并根据其订阅者&lt;code&gt;Subscriber&amp;lt;? super T&amp;gt;&lt;/code&gt;的需求推送元素。一个&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;可以支持多个订阅者，并可以根据订阅者的逻辑进行推送序列元素。下面这个&lt;strong&gt;Excel&lt;/strong&gt;计算就能说明一些&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;的特点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200928222607141-761150947.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A1-A9&lt;/strong&gt;就可以看做&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;及其提供的元素序列。&lt;strong&gt;A10-A13&lt;/strong&gt;分别是求和函数&lt;code&gt;SUM(A1:A9)&lt;/code&gt;、平均函数&lt;code&gt;AVERAGE(A1:A9)&lt;/code&gt;、最大值函数&lt;code&gt;MAX(A1:A9)&lt;/code&gt;、最小值函数&lt;code&gt;MIN(A1:A9)&lt;/code&gt;，可以看作订阅者&lt;code&gt;Subscriber&lt;/code&gt;。假如说我们没有&lt;strong&gt;A10-A13&lt;/strong&gt;，那么&lt;strong&gt;A1-A9&lt;/strong&gt;就没有实际意义，它们并不产生计算。这也是响应式的一个重要特点：&lt;strong&gt;当没有订阅时发布者什么也不做&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;Flux&lt;/code&gt;和&lt;code&gt;Mono&lt;/code&gt;都是&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;在&lt;strong&gt;Reactor 3&lt;/strong&gt;实现。&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;提供了&lt;code&gt;subscribe&lt;/code&gt;方法，允许消费者在有结果可用时进行消费。如果没有消费者&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;不会做任何事情，他根据消费情况进行响应。 &lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;可能返回零或者多个，甚至可能是无限的，为了更加清晰表示期待的结果就引入了两个实现模型&lt;code&gt;Mono&lt;/code&gt;和&lt;code&gt;Flux&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;4-flux&quot;&gt;4. Flux&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Flux&lt;/code&gt; 是一个发出(emit)&lt;code&gt;0-N&lt;/code&gt;个元素组成的异步序列的&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;,可以被&lt;code&gt;onComplete&lt;/code&gt;信号或者&lt;code&gt;onError&lt;/code&gt;信号所终止。在响应流规范中存在三种给下游消费者调用的方法 &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onComplete&lt;/code&gt;, 和&lt;code&gt;onError&lt;/code&gt;。下面这张图表示了Flux的抽象模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200928222607378-323495194.png&quot; alt=&quot;Flux&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上的的讲解对于初次接触反应式编程的依然是难以理解的，所以这里有一个循序渐进的理解过程。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;有些类比并不是很妥当，但是对于你循序渐进的理解这些新概念还是有帮助的。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;传统数据处理&quot;&gt;传统数据处理&lt;/h3&gt;
&lt;p&gt;我们在平常是这么写的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public List&amp;lt;ClientUser&amp;gt; allUsers() {
    return Arrays.asList(new ClientUser(&quot;felord.cn&quot;, &quot;reactive&quot;),
            new ClientUser(&quot;Felordcn&quot;, &quot;Reactor&quot;));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过迭代返回值&lt;code&gt;List&lt;/code&gt;来&lt;code&gt;get&lt;/code&gt;这些元素进行再处理（消费），这种方式有点类似厨师做了很多菜，吃不吃在于食客。需要食客主动去来吃就行了（&lt;strong&gt;pull&lt;/strong&gt;的方式），至于喜欢吃什么不喜欢吃什么自己随意，怎么吃也自己随意。&lt;/p&gt;
&lt;h3 id=&quot;流式数据处理&quot;&gt;流式数据处理&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;Java 8&lt;/strong&gt;中我们可以改写为流的表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Stream&amp;lt;ClientUser&amp;gt; allUsers() {
    return  Stream.of(new ClientUser(&quot;felord.cn&quot;, &quot;reactive&quot;),
            new ClientUser(&quot;Felordcn&quot;, &quot;Reactor&quot;));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依然是厨师做了很多菜，但是这种就更加高级了一些，提供了菜品的搭配方式（不包含具体细节），食客可以按照说明根据自己的习惯搭配着去吃，一但开始概不退换，吃完为止，过期不候。&lt;/p&gt;
&lt;h3 id=&quot;反应式数据处理&quot;&gt;反应式数据处理&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;Reactor&lt;/strong&gt;中我们又可以改写为&lt;code&gt;Flux&lt;/code&gt;表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Flux&amp;lt;ClientUser&amp;gt; allUsers(){
    return Flux.just(new ClientUser(&quot;felord.cn&quot;, &quot;reactive&quot;),
            new ClientUser(&quot;Felordcn&quot;, &quot;Reactor&quot;));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候食客只需要订餐就行了，做好了自然就呈上来，而且可以随时根据食客的饭量进行调整。如果没有食客订餐那么厨师就什么都不用做。当然不止有这么点特性，不过对于方便我们理解来说这就够了。&lt;/p&gt;
&lt;h2 id=&quot;5-mono&quot;&gt;5. Mono&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Mono&lt;/code&gt; 是一个发出(emit)&lt;code&gt;0-1&lt;/code&gt;个元素的&lt;code&gt;Publisher&amp;lt;T&amp;gt;&lt;/code&gt;,可以被&lt;code&gt;onComplete&lt;/code&gt;信号或者&lt;code&gt;onError&lt;/code&gt;信号所终止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1739473/202009/1739473-20200928222607947-717859343.png&quot; alt=&quot;Mono&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就不翻译了，整体和&lt;code&gt;Flux&lt;/code&gt;差不多，只不过这里只会发出0-1个元素。也就是说不是有就是没有。象&lt;code&gt;Flux&lt;/code&gt;一样，我们来看看&lt;code&gt;Mono&lt;/code&gt;的演化过程以帮助理解。&lt;/p&gt;
&lt;h3 id=&quot;传统数据处理-2&quot;&gt;传统数据处理&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ClientUser currentUser () {
    return isAuthenticated ? new ClientUser(&quot;felord.cn&quot;, &quot;reactive&quot;) : null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接返回符合条件的对象或者&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;optional的处理方式&quot;&gt;Optional的处理方式&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Optional&amp;lt;ClientUser&amp;gt; currentUser () {
    return isAuthenticated ? Optional.of(new ClientUser(&quot;felord.cn&quot;, &quot;reactive&quot;))
            : Optional.empty();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;Optional&lt;/code&gt;我觉得就有反应式的那种味儿了，当然它并不是反应式。当我们不从返回值&lt;code&gt;Optional&lt;/code&gt;取其中具体的对象时，我们不清楚里面到底有没有，但是&lt;code&gt;Optional&lt;/code&gt;是一定客观存在的,不会出现&lt;strong&gt;NPE&lt;/strong&gt;问题。&lt;/p&gt;
&lt;h3 id=&quot;反应式数据处理-2&quot;&gt;反应式数据处理&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Mono&amp;lt;ClientUser&amp;gt; currentUser () {
    return isAuthenticated ? Mono.just(new ClientUser(&quot;felord.cn&quot;, &quot;reactive&quot;))
            : Mono.empty();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和&lt;code&gt;Optional&lt;/code&gt;有点类似的机制，当然&lt;code&gt;Mono&lt;/code&gt;不是为了解决&lt;strong&gt;NPE&lt;/strong&gt;问题的，它是为了处理响应流中单个值（也可能是&lt;code&gt;Void&lt;/code&gt;）而存在的。&lt;/p&gt;
&lt;h2 id=&quot;6-总结&quot;&gt;6. 总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Flux&lt;/code&gt;和&lt;code&gt;Mono&lt;/code&gt;是&lt;strong&gt;Java&lt;/strong&gt;反应式中的重要概念，但是很多同学包括我在开始都难以理解它们。这其实是规定了两种流式范式，这种范式让数据具有一些新的特性，比如基于发布订阅的事件驱动，异步流、背压等等。另外数据是推送（&lt;strong&gt;Push&lt;/strong&gt;）给消费者的以区别于平时我们的拉（&lt;strong&gt;Pull&lt;/strong&gt;）模式。同时我们可以像&lt;a href=&quot;https://felord.cn/java8streamapi.html&quot;&gt;Stream Api&lt;/a&gt;一样使用类似&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;flatmap&lt;/code&gt;等操作符（&lt;strong&gt;operator&lt;/strong&gt;）来操作它们。对&lt;code&gt;Flux&lt;/code&gt;和&lt;code&gt;Mono&lt;/code&gt;这两个概念需要花一些时间去理解它们，不能操之过急。如果你对我的这种看法有不同的观点可以留言讨论，多多关注：&lt;strong&gt;码农小胖哥&lt;/strong&gt; 获取更多干货知识。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;关注公众号：Felordcn 获取更多资讯&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://felord.cn&quot;&gt;个人博客：https://felord.cn&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Sep 2020 14:26:00 +0000</pubDate>
<dc:creator>码农小胖哥</dc:creator>
<og:description>1. 前言 最近写关于响应式编程的东西有点多，很多同学反映对Flux和Mono这两个Reactor中的概念有点懵逼。但是目前Java响应式编程中我们对这两个对象的接触又最多，诸如Spring WebF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/felordcn/p/13747262.html</dc:identifier>
</item>
</channel>
</rss>