<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring AOP概述 - 云源</title>
<link>http://www.cnblogs.com/ysource/p/12834298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysource/p/12834298.html</guid>
<description>&lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。&lt;/p&gt;&lt;p&gt;要理解切面编程，就需要先理解什么是切面。用刀把一个西瓜分成两瓣，切开的切口就是切面；炒菜，锅与炉子共同来完成炒菜，锅与炉子就是切面。web层级设计中，web层-&amp;gt;网关层-&amp;gt;服务层-&amp;gt;数据层，每一层之间也是一个切面。编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面。&lt;/p&gt;&lt;div readability=&quot;93&quot;&gt;
&lt;p&gt;然后举一个容易理解的例子：&lt;br/&gt;看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 AOP 的概念还是很模糊, 对 AOP 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 AOP 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的.&lt;br/&gt;下面我以一个简单的例子来比喻一下 AOP 中 Aspect, Joint point, Pointcut 与 Advice之间的关系.&lt;br/&gt;让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.&lt;/p&gt;
&lt;p&gt;来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系.&lt;br/&gt;首先我们知道, 在 Spring AOP 中 Joint point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 Joint point, 通过 point cut, 我们就可以确定哪些 Joint point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, Joint point 就相当于 爪哇的小县城里的百姓,pointcut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 Advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问.&lt;br/&gt;为什么可以这样类比呢?&lt;/p&gt;
&lt;p&gt;Joint point ： 爪哇的小县城里的百姓: 因为根据定义, Joint point 是所有可能被织入 Advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 Joint point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.&lt;/p&gt;
&lt;p&gt;Pointcut ：男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 Advice, 但是我们并不希望在所有方法上都织入 Advice, 而 Pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里 凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.&lt;/p&gt;
&lt;p&gt;Advice ：抓过来审问, Advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 Joint point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.&lt;/p&gt;
&lt;p&gt;Aspect:：Aspect 是 point cut 与 Advice 的组合, 因此在这里我们就可以类比: “根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问” 这一整个动作可以被认为是一个 Aspect.&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 06 May 2020 00:48:00 +0000</pubDate>
<dc:creator>云源</dc:creator>
<og:description>一、AOP的基本概念： 首先先给出一段比较专业的术语： 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ysource/p/12834298.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.18：刷 LeetCode 的正确姿势 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12832674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12832674.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200505204913898-1033759835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：找对路子，事半功倍，正如本周 GitHub Trending #刷 LeetCode# 主题想表达的那般，正确的学习姿势方能让人走得更远，走进大厂 🌚。学习除了正确姿势，“脑洞”也很重要，在五一假期掀起 Copy 风的 AR Cut &amp;amp; Paste 凭借所见即可拷的特性在 Twitter、微博等社交平台刷了屏。说到学习方法，本周特推的 亚马逊工程师亲测：coding-interview-university 无疑是非科班人员进大厂的最佳实践，读完它的作者自我介绍不得不感叹：正确的姿势也得坚持不懈的努力方能“得偿所愿”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周特推&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 所见即可拷：AR Cut &amp;amp; Paste&lt;/li&gt;
&lt;li&gt;1.2 亚马逊工程师亲测：coding-interview-university&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;GitHub Trending 周榜&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 扫码传输利器：qrcp&lt;/li&gt;
&lt;li&gt;2.2 算法实现：Java&lt;/li&gt;
&lt;li&gt;2.3 手绘图形库：Rough.js&lt;/li&gt;
&lt;li&gt;2.4 ins 千粉事迹（1/1）：InstaPy&lt;/li&gt;
&lt;li&gt;2.5 学…学…学不动 Vue 3.0：vue-next&lt;/li&gt;
&lt;li&gt;2.6 这应该是最全的 Flutter 学习教程：Flutter-Course-Resources&lt;/li&gt;
&lt;li&gt;2.7 建站萌新福利：Docusaurus&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本周 GitHub Trending #刷 LeetCode#主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 LeetCode GitHub 首席：LeetCode&lt;/li&gt;
&lt;li&gt;3.2 动起来：LeetCodeAnimation&lt;/li&gt;
&lt;li&gt;3.3 人手把手撕 LeetCode 题目：fucking-algorithm&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-本周特推&quot;&gt;1. 本周特推&lt;/h2&gt;
&lt;h3 id=&quot;11-所见即可拷：ar-cut--paste&quot;&gt;1.1 所见即可拷：AR Cut &amp;amp; Paste&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2900+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt;：可见即可拷，AR Cut &amp;amp; Paste 是一个 AR 复制粘贴工具，可无缝衔接 Photoshop 将实物粘贴到图层中。作为一个 AR + ML 原型，在未来它将支持你直接在环境中剪切元素，并将它们粘贴到一个图像编辑软件中，目前只支持 PS。btw，项目刚开源 24 小时不到已获得近 3k star 👏&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/cyrildiagne/ar-cutpaste&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200505204928154-1870784360.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-亚马逊工程师亲测：coding-interview-university&quot;&gt;1.2 亚马逊工程师亲测：coding-interview-university&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：850+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;coding-interview-university 是一名非科班程序员为入职 Google 制定的学习计划，并严格按照每天 8-12 小时的学习节奏实施。虽然他最后没有去面试 Google 而是入职了 Amazon，但是不妨碍这是一个不错的程序员学习清单，下面引用下作者的原话&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;自 1997 年以来，我一直从事于 Web 程序的构建、服务器的构建及创业型公司的创办。对于只有着一个经济学学位，而不是计算机科学学位（CS degree）的我来说，在职业生涯中所取得的都非常成功。然而，我想在 Google 工作，并进入大型系统中，真正地去理解计算机系统、算法效率、数据结构性能、低级别编程语言及其工作原理。可一项都不了解的我，怎么会被 Google 所应聘呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/jwasham/coding-interview-university&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200505204942128-822079283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-github-trending-周榜&quot;&gt;2. GitHub Trending 周榜&lt;/h2&gt;
&lt;h3 id=&quot;21-扫码传输利器：qrcp&quot;&gt;2.1 扫码传输利器：qrcp&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1000+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比微信传输更香，扫码传输利器 #GitHub Trending# qrcp 是一个文件传送工具，连上 Wi-Fi 之后通过 QR 码（二维码）可直接在 PC 与移动设备上传输文件。&lt;/p&gt;
&lt;p&gt;工作原理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;qrcp将 Web 服务器绑定 Wi-Fi 网络接口地址的随机端口，并为它创建一个处理程序。默认处理程序处理内容，并在传输完成时退出程序。&lt;/li&gt;
&lt;li&gt;当用于接收文件时，qrcp 提供一个上传页面并处理传输。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/claudiodangelis/qrcp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200505204951274-2051042187.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-算法实现：java&quot;&gt;2.2 算法实现：Java&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本周 #GitHub Trending# 上的 Java 不是一个 Java 入门到精通的项目，而是用 Java 实现所有算法的项目，虽然某些实现方式不如 Java 标准库高效，如果你在学习算法或者打算刷 LeetCode，不妨看看这个项目。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/TheAlgorithms/Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200505205007687-1816735268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-手绘图形库：roughjs&quot;&gt;2.3 手绘图形库：Rough.js&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：150+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Rough.js 是一个小巧的 js 库（小于 9KB），它提供了手绘风格的基础图形，包括：直线，曲线，圆弧，多边形，圆形和椭圆形等基础图形，支持 Canvas、SVG。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/pshihn/rough&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200505205016260-1821658319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-ins-千粉事迹（11）：instapy&quot;&gt;2.4 ins 千粉事迹（1/1）：InstaPy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InstaPy 是一个自动点赞/关注/评论的 Python 脚本，帮你自动完成 Instagram 的互动。作者设计初衷是通过 InstaPy 给 ins 的某些 tag 下内容自动点赞或者 follow 某些 ins 作者得到曝光，当然作者也成功的使用 InstaPy 获得超过了 3k 粉丝。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/timgrossmann/InstaPy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;25-学学学不动-vue-30：vue-next&quot;&gt;2.5 学…学…学不动 Vue 3.0：vue-next&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vue-next 是 Vue 3.0 repo，目前项目处于 Beta，包含了前端在开发过程中需要的套件、WebPack 插件等等内容。目前 Vue 3.0 状态如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;vue: Beta&lt;/li&gt;
&lt;li&gt;vue-router: Alpha&lt;/li&gt;
&lt;li&gt;vuex: Alpha&lt;/li&gt;
&lt;li&gt;vue-class-component: Alpha&lt;/li&gt;
&lt;li&gt;vue-cli: Experimental support via vue-cli-plugin-vue-next&lt;/li&gt;
&lt;li&gt;eslint-plugin-vue: Alpha&lt;/li&gt;
&lt;li&gt;vue-test-utils: Alpha&lt;/li&gt;
&lt;li&gt;vue-devtools: WIP&lt;/li&gt;
&lt;li&gt;jsx: WIP&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你想抢先体验 Vue 3.0 全家桶，不妨阅读下该链接的文章：&lt;a href=&quot;https://juejin.im/post/5e99c21b6fb9a03c590dfea8&quot;&gt;https://juejin.im/post/5e99c21b6fb9a03c590dfea8&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/vuejs/vue-next&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;26-这应该是最全的-flutter-学习教程：flutter-course-resources&quot;&gt;2.6 这应该是最全的 Flutter 学习教程：Flutter-Course-Resources&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flutter-Course-Resources 是一个 Flutter 开发训练营，它旨在你学习开发 App 的过程中习得 Flutter 之技，该训练一共分为 16 个章节，从 Flutter 介绍讲起，带你从安装部署、icon 设计到 Flutter 开发实践，一条龙学习 Flutter。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/londonappbrewery/Flutter-Course-Resources&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;27-建站萌新福利：docusaurus&quot;&gt;2.7 建站萌新福利：Docusaurus&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docusaurus 是 Faecbook 专门为开源项目开发者提供的一款易于维护的静态网站创建工具，使用 Markdown 即可更新网站。用它即可构建一个自带主页、文档、API、帮助 以及博客页面的静态网站。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/facebook/docusaurus&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200505205028013-1757496802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-本周-github-trending-刷-leetcode主题的主力军&quot;&gt;3. 本周 GitHub Trending #刷 LeetCode#主题的主力军&lt;/h2&gt;
&lt;p&gt;别的大厂小鱼干不了解，对于新晋 BAT 的字节跳动而言，大家对它的面试评价关键词一定有：&lt;code&gt;算法&lt;/code&gt;，而 LeetCode 是每位程序员自测算法的最佳方式，为此小鱼干选了 GitHub 上 3 个有代表性的项目，仅供你观摩。&lt;/p&gt;
&lt;h3 id=&quot;31-leetcode-github-首席：leetcode&quot;&gt;3.1 LeetCode GitHub 首席：LeetCode&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：750+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;超 30+k 的 star 坐实 LeetCode &lt;code&gt;LeetCode 在 GitHub 的首席代表&lt;/code&gt; 的身份，Repo 分为五个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个部分是 leetcode 经典题目的解析，包括思路，关键点和具体的代码实现。&lt;/li&gt;
&lt;li&gt;第二部分是对于数据结构与算法的总结&lt;/li&gt;
&lt;li&gt;第三部分是 anki 卡片， 将 leetcode 题目按照一定的方式记录在 anki 中，方便大家记忆。&lt;/li&gt;
&lt;li&gt;第四部分是每日一题，每日一题是在交流群（包括微信和 qq）里进行的一种活动，大家一起解一道题，这样讨论问题更加集中，会得到更多的反馈。而这些题目可以被记录下来，日后会进行筛选添加到仓库的题解模块。&lt;/li&gt;
&lt;li&gt;第五部分是计划， 这里会记录将来要加入到以上三个部分内容&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/azl397985856/leetcode&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;32-动起来：leetcodeanimation&quot;&gt;3.2 动起来：LeetCodeAnimation&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：350+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GitHub 上刷 LeetCode 的 Repo 千千万，为要独推荐 LeetCodeAnimation？有什么方式能比图解、动画更直观了解到整个运行过程的呢？LeetCodeAnimation 用动画的形式呈现解 LeetCode 题目的思路，尤其适合新手刷题使用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/MisterBooo/LeetCodeAnimation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200505205037469-1319368078.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-人手把手撕-leetcode-题目：fucking-algorithm&quot;&gt;3.3 人手把手撕 LeetCode 题目：fucking-algorithm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2150+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fucking-algorithm 是一个总结 LeetCode 刷题思路和技巧的项目，该项目不是简单地刷题，而是帮你培养解题思维，希望这份小抄能帮你打开升职加薪大门。btw，在上个月该项目获得超 10k 的 star 👏&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/labuladong/fucking-algorithm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 18 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200406212426655-796625417.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 May 2020 00:47:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 小鱼干 摘要：找对路子，事半功倍，正如本周 GitHub Trending 刷 LeetCode 主题想表达的那般，正确的学习姿势方能让人走得更远，走进大厂 &amp;#1277</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12832674.html</dc:identifier>
</item>
<item>
<title>airtest+poco多脚本、多设备批处理运行测试用例自动生成测试报告 - 秒秒开心</title>
<link>http://www.cnblogs.com/miaomiaokaixin/p/12809632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miaomiaokaixin/p/12809632.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一：主要内容&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;框架功能及测试报告效果&lt;/li&gt;
&lt;li&gt;airtest安装、环境搭建&lt;/li&gt;
&lt;li&gt;框架搭建、框架运行说明&lt;/li&gt;
&lt;li&gt;airtest自动化脚本编写注意事项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二：框架功能及测试报告效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 框架功能：&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该框架笔者用来作为公司的项目的前端自动化，支持pc和app，本文的air脚本是针对app的，关于pc的脚本会专门在写一篇文章说明，该框架功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持在安卓多台设备中批量运行所有后缀为air的测试脚本（因为ios的连接需要macOS，我是windows机所以暂时只连了安卓端的ios未做测试）&lt;/li&gt;
&lt;li&gt;支持指定某个用例或某几个用例在某台设备或某几台设备中进行运行&lt;/li&gt;
&lt;li&gt;支持控制测试用例执行顺序，默认会将登录用例排在第一，退出用例排在最后执行，如果想要自定义其他顺序，可以在run.py文件中修改sort_cases函数方法即可&lt;/li&gt;
&lt;li&gt;支持多脚本多设备运行完成后，生成一份汇总的测试报告，且点击汇总测试报告中具体的某一个用例，还能查看该用例详细的airtest报告&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. 框架架构说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/675608/202004/675608-20200430174240195-897842536.png&quot; alt=&quot;&quot; width=&quot;1127&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3. 测试报告效果：&lt;/p&gt;
&lt;p&gt;给大家看一下多设备、多脚本的测试报告效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/675608/202004/675608-20200430161849207-818134146.jpg&quot; alt=&quot;&quot; width=&quot;830&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击详情效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/675608/202004/675608-20200430163012714-638078124.png&quot; alt=&quot;&quot; width=&quot;1050&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三：airtest安装、环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.python环境安装&lt;/p&gt;
&lt;p&gt;这里不再赘述，安装并配置好环境变量后，执行python -V查看是否安装成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/675608/202004/675608-20200430164257678-687649285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.airtestIDE安装&lt;/p&gt;
&lt;p&gt;airtest安装很简单，安装airtestIDE，从官网下载：http://airtest.netease.com/&lt;/p&gt;
&lt;p&gt;下载后解压缩到本地，我的本地位置为：G:\AirtestIDE_2020-01-21_py3_win64\AirtestIDE_2020-01-21_py3_win64\AirtestIDE.exe，双击exe文件即为启动airtestIDE工具即可&lt;/p&gt;

&lt;p&gt;3.包安装&lt;/p&gt;
&lt;p&gt;需要安装如下包：&lt;/p&gt;
&lt;p&gt;pip install airtest&lt;/p&gt;
&lt;p&gt;pip install pocoui&lt;/p&gt;
&lt;p&gt;如果执行不能安装成功，则可以使用如下命令：&lt;/p&gt;
&lt;p&gt;pip install -i http://pypi.douban.com/simple --trusted-host pypi.douban.com airtest&lt;br/&gt;pip install -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com pocoui&lt;/p&gt;

&lt;p&gt;######如果想用airtest编写selenium即pc自动化脚本，则还需要安装如下包：&lt;/p&gt;
&lt;p&gt;pip install selenium&lt;/p&gt;
&lt;p&gt;pip install pynput&lt;/p&gt;
&lt;p&gt;pip install airtest_selenium&lt;/p&gt;
&lt;p&gt;关于这一步的安装也就是 pip install airtest_selenium，也可以从airtest安装目录下拷贝该文件夹到python目录下&lt;/p&gt;
&lt;p&gt;我的python目录为：G:\python3.6.5；&lt;/p&gt;
&lt;p&gt;我的airtest安装目录为：G:\AirtestIDE_2020-01-21_py3_win64\AirtestIDE_2020-01-21_py3_win64，该路径下有个airtest_selenium文件夹；&lt;/p&gt;
&lt;p&gt;可以拷贝airtest目录下的airtest_selenium文件夹到python目录下。&lt;/p&gt;

&lt;p&gt;######如果想用airtest编写selenium即pc自动化脚本，除了安装上面的包，因为airtest-selenium自动化因为需要打开浏览器，所以我们还需要配置谷歌浏览器路径和下载匹配的谷歌驱动文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;airtest设置谷歌启动路径：airtestIDE界面-点击选项-点击设置-点击chrome path-选择谷歌安装路径一直到chrome.exe文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/675608/202004/675608-20200430165927210-148067342.png&quot; alt=&quot;&quot; width=&quot;663&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;下载匹配的谷歌驱动文件：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以使用该网站下载：https://npm.taobao.org/mirrors/chromedriver&lt;/p&gt;
&lt;p&gt;下载后替换掉airtest根目录我的路径是G:\AirtestIDE_2020-01-21_py3_win64\AirtestIDE_2020-01-21_py3_win64下的chromedriver.exe文件即可&lt;/p&gt;

&lt;p&gt;4.框架版本说明&lt;/p&gt;
&lt;p&gt;该框架使用版本如下：&lt;/p&gt;
&lt;p&gt;python 3.6.5&lt;/p&gt;
&lt;p&gt;airtest 1.1.3&lt;/p&gt;
&lt;p&gt;pocoui 1.0.79&lt;/p&gt;
&lt;p&gt;pynput 1.6.8&lt;/p&gt;
&lt;p&gt;airtestIDE 1.2.3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四：框架搭建、框架运行说明&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.框架搭建&lt;/p&gt;
&lt;p&gt;该框架搭建很简单，就是一个python工程：&lt;/p&gt;
&lt;p&gt;该工程根目录下开始时有一个result空文件夹、一个report_tpl.html模板文件、run.py启动脚本、docs文件夹是我自己放的一些项目描述文档可有可无，.air文件是自己通过airtestIDE编写的项目的自动化脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/675608/202004/675608-20200430172632557-342558392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.框架脚本文件说明&lt;/p&gt;
&lt;pre&gt;
run.py   #启动文件，python run.py即可&lt;br/&gt;report_tpl.html  #测试报告模板文件&lt;br/&gt;report.html   #自动生成的测试报告文件，会将汇总的执行结果的json数据即下面的summary数据格式与report_tpl.html结合，生成测试报告&lt;br/&gt;result   #文件夹，用于存放每个测试用例的执行json结果数据格式为下面的results数据格式&lt;br/&gt;xxx.air  #测试用例，所有以.air文件名称结尾的文件夹都是测试用例&lt;br/&gt;xxx.air/log  #每个测试用例的日志文件，以设备号区分，每个设备号下存放一份测试结果日志文件&lt;br/&gt;log.html  #每个测试用例在每个设备中运行的具体效果，即测试报告中点击具体测试用例右侧弹出的页面详情效果&lt;br/&gt;log.txt   #每个测试用例在每个设备中运行的json结果数据&lt;/pre&gt;
&lt;p&gt;3.框架运行编写建议&lt;/p&gt;
&lt;pre&gt;
执行命令时可以用python run.py运行整个框架&lt;br/&gt;但是写脚本或者调试脚本时，用airtestIDE来操作，即从airtestIDE中新建编辑.air脚本保存到该框架的根目录下，调试通过后再用run.py进行批量脚本、批量设备去执行。&lt;br/&gt;这样就比较清晰&lt;/pre&gt;</description>
<pubDate>Wed, 06 May 2020 00:45:00 +0000</pubDate>
<dc:creator>秒秒开心</dc:creator>
<og:description>一：主要内容 框架功能及测试报告效果 airtest安装、环境搭建 框架搭建、框架运行说明 airtest自动化脚本编写注意事项 二：框架功能及测试报告效果 1. 框架功能： 该框架笔者用来作为公司的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/miaomiaokaixin/p/12809632.html</dc:identifier>
</item>
<item>
<title>FastDFS文件服务器安装指南附安装包和自启动(看此篇就够了) - xuxianshun</title>
<link>http://www.cnblogs.com/bcde/p/10947544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bcde/p/10947544.html</guid>
<description>[unable to retrieve full-text content]安装包在最后，本文为博主自己亲自安装记录 转载请注明出处 注意文字不清晰请放大看，放大看！！ 安装包地址</description>
<pubDate>Wed, 06 May 2020 00:42:00 +0000</pubDate>
<dc:creator>xuxianshun</dc:creator>
<og:description>安装包在最后，本文为博主自己亲自安装记录 转载请注明出处 注意文字不清晰请放大看，放大看！！ 安装包地址</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bcde/p/10947544.html</dc:identifier>
</item>
<item>
<title>聚类基础知识,看这一篇就足够了！ - justisme</title>
<link>http://www.cnblogs.com/justisme/p/12834282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justisme/p/12834282.html</guid>
<description>&lt;p&gt;原型聚类：聚类结构能通过一组原型刻画。KMEANS+GMM. 基于密度的聚类：DBSCAN. 层次聚类：在不同层次上对数据集进行分类。从N到1。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;68&quot;&gt;
&lt;h3 id=&quot;聚类：-相似的样本放在同一簇，不同的样本放在不同的簇中&quot;&gt;聚类： 相似的样本放在同一簇，不同的样本放在不同的簇中&lt;/h3&gt;
&lt;p&gt;图像分割可以看做是色块的聚类。&lt;/p&gt;
&lt;h4 id=&quot;聚类原则以及相应的评价指标&quot;&gt;聚类原则以及相应的评价指标&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;原则：簇内相似度 intra cluster similarity) 高，簇间相似度 inter cluster similarity) 低。&lt;/li&gt;
&lt;li&gt;评价指标：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;有参考模型，即外部指标：计数法&lt;/strong&gt;。4类点对，3种指标：Jaccard 系数、FM 指数、Rand 指数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接考察聚类结果，即内部指标：距离法&lt;/strong&gt;。DB 指数、Dunn 指数,&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;距离定义&quot;&gt;距离定义&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;非负性。&lt;/li&gt;
&lt;li&gt;同一性。&lt;/li&gt;
&lt;li&gt;对称性。&lt;/li&gt;
&lt;li&gt;三角不等式性质&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实例：闵可夫斯基距离。p=2时，欧氏距离，p=1时，曼哈顿距离。&lt;/p&gt;
&lt;h3 id=&quot;聚类分类&quot;&gt;聚类分类&lt;/h3&gt;
&lt;h4 id=&quot;原型聚类：聚类结构能通过一组原型刻画。&quot;&gt;原型聚类：聚类结构能通过一组原型刻画。&lt;/h4&gt;
&lt;p&gt;原型：指样本空间中具有代表性的点.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;K-均值：最小化均方误差&lt;/strong&gt;。&lt;mark&gt;1.确定每个样本的簇标记(最近)；2.通过均值来更新簇中心&lt;/mark&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200506083046312.png&quot;/&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要提前确定k。&lt;/li&gt;
&lt;li&gt;对噪声和离群点敏感(均值)&lt;/li&gt;
&lt;li&gt;对初值的选择较为敏感。&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;strong&gt;混合高斯模型&lt;/strong&gt;,隐变量-EM 算法。&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200506083134622.png&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200506083046335.png&quot;/&gt;&lt;h3 id=&quot;基于密度的聚类：dbscan&quot;&gt;基于密度的聚类：DBSCAN&lt;/h3&gt;
&lt;p&gt;基于一组“邻域” ”( 参数 є ,MinPts )来描述样本分布的紧密程度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;核心对象 core object) : 若 x j 的 є 邻域至少包含 MinPts 个样本。边缘对象，在 є 邻域内但个数&amp;lt;MinPts 。噪声对象，既不是核心对象也不是边缘对象。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;密度直达&lt;/code&gt;、&lt;code&gt;密度相连&lt;/code&gt;扩充簇的范围。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;层次聚类：在不同层次上对数据集进行分类。从n到1。&quot;&gt;层次聚类：在不同层次上对数据集进行分类。从N到1。&lt;/h3&gt;
&lt;p&gt;从N个样本点开始，计算&lt;strong&gt;距离矩阵(proximity matrix)&lt;/strong&gt;,合并距离最近的两个簇，直到簇的个数为1。通过&lt;code&gt;dendrogram图&lt;/code&gt;可视化。&lt;/p&gt;
&lt;h4 id=&quot;簇距离度量&quot;&gt;簇距离度量&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Single Link：簇之间的&lt;strong&gt;点的最小距离&lt;/strong&gt;作为簇的距离。&lt;/li&gt;
&lt;li&gt;Complete Link: 簇之间的&lt;strong&gt;点的最大距离&lt;/strong&gt;作为簇的距离。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不需要提前指定K。&lt;/li&gt;
&lt;li&gt;通过水平切割来获得指定簇个数的聚类结果。&lt;/li&gt;
&lt;li&gt;不同层代表不同的分类。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Wed, 06 May 2020 00:41:00 +0000</pubDate>
<dc:creator>justisme</dc:creator>
<og:description>原型聚类：聚类结构能通过一组原型刻画。KMEANS+GMM. 基于密度的聚类：DBSCAN. 层次聚类：在不同层次上对数据集进行分类。从N到1。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justisme/p/12834282.html</dc:identifier>
</item>
<item>
<title>重学数据结构之栈 - TM0831</title>
<link>http://www.cnblogs.com/TM0831/p/12831061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TM0831/p/12831061.html</guid>
<description>&lt;h2&gt;一、前言简介&lt;/h2&gt;
&lt;p&gt;　　数据结构课程是一门重要的计算机基础课程，而我本人在上学期间真是没学好这门课， 听课总是听得云里雾里的，写起代码来也不知道如何编写和运用这些数据结构，以致于后来考试也只能是低分飘过，所以现在就需要花时间重新学习一下数据结构了！&lt;/p&gt;
&lt;p&gt;　　为了能够更好地学习和掌握数据结构，除了学习和理解相应的概念，我还会找几个题目并用所学的数据结构来解决问题，相应的问题和代码也会一并记录在博客中。&lt;/p&gt;

&lt;h2&gt;二、栈的概念&lt;/h2&gt;
&lt;h3&gt;1.基本概念&lt;/h3&gt;
&lt;p&gt;　　栈（stack）又被称为堆栈，是一种保存数据元素的容器。栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表，允许进行插入和删除操作的一端叫做栈顶（top），另一端则叫做栈底（bottom），插入元素一般称为进栈（PUSH），删除元素一般称为出栈（POP）。&lt;/p&gt;
&lt;p&gt;　　栈按照后进先出的原则（LIFO， Last In First Out）存储数据，后存入的元素会先被取出来使用。存入栈中的元素相互之间并没有任何具体的关系，只有存入的时间先后顺序，而没有元素的前后顺序或者元素的位置等概念。&lt;/p&gt;
&lt;h3&gt;2.抽象数据类型&lt;/h3&gt;
&lt;p&gt;　　栈的基本操作一个封闭的数据集合，在一个栈里需要实现将元素压入栈中即进栈、从栈中弹出元素即出栈、返回最后一个插入栈中的元素、获取栈中元素的数量等方法，下面就是一个栈的抽象数据类型描述：&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;ADT Stack：&lt;/p&gt;
&lt;p&gt;　　Stack(self)  # 创建一个空栈&lt;/p&gt;
&lt;p&gt;　　empty(self)  # 判断栈是否为空&lt;/p&gt;
&lt;p&gt;　　push(self, x)  # 将元素压入栈中&lt;/p&gt;
&lt;p&gt;　　pop(self)  # 从栈中弹出元素&lt;/p&gt;
&lt;p&gt;　　peek(self)  # 返回最后一个插入的元素&lt;/p&gt;
&lt;p&gt;　　size(sellf)  # 获取栈中元素的数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3.用 Python 实现&lt;/h3&gt;
&lt;p&gt;　　在 Python 中没有栈这种数据结构，但我们可以借助 list 来实现，用 list 来存放数据，并实现一个栈所需要的各种方法，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自定义栈&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyStack:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.data =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; push(self, x):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        将数据压入栈中
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        :param x: 需要插入的元素
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        :return: 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        self.data.append(x)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; pop(self):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        从栈中弹出元素
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        :return: 弹出的元素
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.empty():
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             ret, self.data = self.data[-1], self.data[:-1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; empty(self):
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        判断栈是否为空
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        :return: 栈空--True，非空--False
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; len(self.data) ==&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; size(self):
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        获取栈中元素的数量
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        :return: 
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(self.data)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; peek(self):
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        返回最后一个插入的元素
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        :return: 最后一个插入的元素
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.empty():
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; self.data[-1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; None
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、栈的应用&lt;/h2&gt;
&lt;h3&gt;1.进制转换&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　输入一个任意的十进制正整数，将其转化成相应的二进制、八进制和十六进制的数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）解决思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这里首先需要介绍一个公式：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;N = (N div d) * d + N mod d&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　其中 div 表示整除，mod 表示求余。例如当输入的正整数 N 为777，输出的进制是八进制时，计算过程如下：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;N 　　   N div 8 　　 N mod 8&lt;/p&gt;
&lt;p&gt;777　　　97　　　　   1&lt;/p&gt;
&lt;p&gt;97　　　  12　　　　   1&lt;/p&gt;
&lt;p&gt;12　　　　1　　　　　4&lt;/p&gt;
&lt;p&gt;1　　　　  0　　　　　1　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在进行进制转换的时候，我们就可以将每次求余的结果保存在栈中，最后将栈中的数依次取出，就是转换后的结果了，例如十进制的777转换成八进制就是1411。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;如何用代码来解决这个问题？一个思路就是将每次求余的结果保存在栈中，而整除的结果则用来进行下一步的计算，直到这个整除的结果为0，表明计算结束，再出栈中依次取出元素，得到的结果就是转换成相应进制后的数。具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; solution(n: int, scale: int):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    进制转换
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    :param n: 正整数
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    :param scale: 进制
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     stack =&lt;span&gt; MyStack()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 循环计算&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; n // scale &amp;gt;= 0 &lt;span&gt;and&lt;/span&gt; n &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         stack.push(n %&lt;span&gt; scale)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         n = n //&lt;span&gt; scale
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; stack.empty():
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(stack.pop(), end=&lt;span&gt;&quot;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.括号匹配&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;输入一个字符串，里面可能有“()”、“[]”和“{}”三种括号，编写程序检查该字符串中的括号是否成对出现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）解决思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;遍历这个字符串，用栈来存放每次遍历的元素，如果遍历的元素和栈顶的括号是配对的，则进行出栈操作将栈顶元素弹出，反之若不配对，则进行入栈操作将该元素插入到栈中。等遍历结束后，若栈为空，则表明该字符串中的括号都是成对出现的，若栈不为空，则表明有括号不匹配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; solution(input_string: str):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    判断输入的字符中的括号是否成对出现
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    :param input_string: 输入字符串
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; match(c1: str, c2: str):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        判断两个括号是否匹配
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        :param c1: 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        :param c2: 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        :return: 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; c1 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; c2 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; c1 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; c2 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; c1 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; c2 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     stack =&lt;span&gt; MyStack()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(input_string)):
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; stack.empty():
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 栈空直接入栈&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            stack.push(input_string[i])
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 栈非空时进行比较&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; match(stack.peek(), input_string[i]):
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                stack.pop()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                stack.push(input_string[i])
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;匹配！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;if&lt;/span&gt; stack.empty() &lt;span&gt;else&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不匹配！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 06 May 2020 00:40:00 +0000</pubDate>
<dc:creator>TM0831</dc:creator>
<og:description>一、前言简介 数据结构课程是一门重要的计算机基础课程，而我本人在上学期间真是没学好这门课， 听课总是听得云里雾里的，写起代码来也不知道如何编写和运用这些数据结构，以致于后来考试也只能是低分飘过，所以现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TM0831/p/12831061.html</dc:identifier>
</item>
<item>
<title>我在 IntelliJ IDEA 中必有得插件和配置 - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/12834274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/12834274.html</guid>
<description>&lt;p&gt;| &lt;strong&gt;好看请赞，养成习惯&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你有一个思想，我有一个思想，我们交换后，一个人就有两个思想&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;If you can NOT explain it simply, you do NOT understand it well enough&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;现陆续将Demo代码和技术文章整理在一起 &lt;a href=&quot;https://github.com/FraserYu/learnings&quot;&gt;Github实践精选&lt;/a&gt; ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star&lt;/p&gt;
&lt;p&gt;最近在陆续写 &lt;a href=&quot;https://dayarch.top/categories/Coding/Java-Concurrency/&quot;&gt;Java 并发编程系列&lt;/a&gt;，好多朋私信问我的不是并发内容本身，而是我的 IDEA 主题配置。我就姑且认为好的主题配置可以写出更好的并发程序吧&lt;/p&gt;
&lt;p&gt;即便这种可能性只有万分之一，我也要把我的 IDEA 相关值得配置的内容/插件和大家分享出来（其实我还是很乐意将我的一些配置分享出来帮助大家更加高效的coding））&lt;/p&gt;
&lt;p&gt;先来一张我的 IDE 截图，有你看中的地方吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083550019-2022279366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;插件篇&quot;&gt;插件篇&lt;/h2&gt;
&lt;p&gt;好用的插件总是让人：&lt;/p&gt;
&lt;p&gt;神清气爽，精神抖擞 ，丰神异彩，炯炯有神，神采奕奕，气贯长虹 ，英姿飒爽，精神焕发&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面所有插件都可以按照文中标注的名称在 IDEA 插件市场中直接搜索并安装&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;material-theme-ui&quot;&gt;Material Theme UI&lt;/h3&gt;
&lt;p&gt;Material Theme UI 在主题下载量排行榜中高居第一。安装主题后（在页面底部就会有进入主题的快捷入口），选择自己喜欢的主题进行微调就可以啦，如果懒得做配置，按照下图勾选相应设置就和我的一样了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083552507-656044259.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;rainbow-brackets&quot;&gt;Rainbow Brackets&lt;/h3&gt;
&lt;p&gt;翻译过来叫【彩虹括号】，该插件除了可以实现多彩的括号匹配外，我使用更多的是其【区域代码高亮】功能 ，这样可以清晰定位区域代码内容&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Mac 快捷键：&lt;code&gt;cmd + 鼠标右键&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;Windows 快捷键：&lt;code&gt;ctrl + 鼠标右键&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083554372-1336846467.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你也可以使用非选中部分暗淡效果&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;快捷键：&lt;code&gt;alt + 鼠标右键&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083557225-152030681.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相比之下，我更喜欢第一种高亮效果&lt;/p&gt;
&lt;h3 id=&quot;codota&quot;&gt;Codota&lt;/h3&gt;
&lt;p&gt;Codota 总结起来有三大功能：&lt;/p&gt;
&lt;h4 id=&quot;1-智能自动补全让编码速度更快&quot;&gt;1. 智能自动补全让编码速度更快&lt;/h4&gt;
&lt;p&gt;当编写代码时，Codota 可以快速的完成智能补全以及高频用法提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083558929-1661036515.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-从经过测试或证明过的程序中获得编码建议&quot;&gt;2. 从经过测试或证明过的程序中获得编码建议&lt;/h4&gt;
&lt;p&gt;如果我们觉得给出的提示不够清晰，可以使用快捷键： &lt;code&gt;ctrl + shift + o&lt;/code&gt; ， 快速查询相关使用案例，同时可以通过添加关键字进行过滤，查找到更加精确的代码样例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083603411-2030861919.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-不脱离ide发现并利用更多开源代码&quot;&gt;3. 不脱离IDE发现并利用更多开源代码&lt;/h4&gt;
&lt;p&gt;当你不知道某个类如何使用时，可以直接使用快捷键：&lt;code&gt;ctrl + shift + y&lt;/code&gt; ， 然后输入关键字，会查询到很多【开源框架】中使用该类的经典案例。不用脱离 IDE，没有广告，没有废话，只有经典的代码样例，你说爽不爽？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083609023-846614841.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你用 Eclipse ，Codota 也是完美支持的&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083610625-1945770478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;key-promoter-x&quot;&gt;Key Promoter X&lt;/h3&gt;
&lt;p&gt;高效的编码脱离不开快捷键的使用，但是 IDEA 中的快捷键实在太多了，不是很方便记忆，Key Promoter X 会根据你使用的功能提示你设置快捷键&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083612402-464458973.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置完后，如果你忘记了该快捷键，再次通过鼠标点击该功能时，设置好的快捷键就会相应的提示出来，真是深知码农苦啊&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083616002-467794216.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;alibaba-java-code-guideline&quot;&gt;Alibaba Java Code Guideline&lt;/h3&gt;
&lt;p&gt;安装该插件后，你编写的代码就会按照 Alibaba 编码规约规范我们编写的代码（谁说我们不能写出和大厂一样规范的代码？）&lt;/p&gt;
&lt;p&gt;比如通过Executors 快速创建一个线程池是不被允许的，具体原因已经在&lt;a href=&quot;https://dayarch.top/p/why-we-need-to-use-threadpool.html&quot;&gt;我会手动创建线程，为什么要使用线程池?&lt;/a&gt; 中说明，当检测出之后，鼠标悬浮在上面会给出提示，按快捷键 &lt;code&gt;cmd + F1&lt;/code&gt; 会更完整的告诉你为什么不可以，同时还给出你应该怎样编写的样例 （暖暖的，很贴心）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083619893-1519644577.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;codeglance&quot;&gt;CodeGlance&lt;/h3&gt;
&lt;p&gt;英文直译【代码一瞥】，细心的朋友已经在开篇的图中看到了这个设置，安装该插件后，IDE右侧会出现一个mini 视图，比如看 ConcurrentHashMap 源码，那么长的内容，可以通过该插件快速的拖动到大概位置，方便很多&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083621535-303898726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;restful-tookit&quot;&gt;Restful Tookit&lt;/h3&gt;
&lt;p&gt;这个插件之前我有介绍过，编写 RESTful 接口必不可少的插件，编写完接口当然还需要调试，搭配HTTP Client 一起使用才更香 &lt;a href=&quot;https://dayarch.top/p/http-client-advanced-usage.html&quot;&gt;IntelliJ IDEA HTTP Client高级使用详解&lt;/a&gt;，相信你学会使用这个，不单单是你个人，你们整个小组都会因此受益&lt;/p&gt;
&lt;h3 id=&quot;camelcase&quot;&gt;CamelCase&lt;/h3&gt;
&lt;p&gt;编码离不开字符串的使用，安装该插件后，可以通过快捷键 &lt;code&gt;shift + alt + U&lt;/code&gt; 快速的切换字符串格式，当然如果你只是单纯的切换大小写，使用 &lt;code&gt;shift + cmd + U&lt;/code&gt; 更便捷一些&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083621895-1504098966.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;设置篇&quot;&gt;设置篇&lt;/h2&gt;
&lt;h3 id=&quot;方法分割线以及字符缩进&quot;&gt;方法分割线以及字符缩进&lt;/h3&gt;
&lt;p&gt;通过方法分割线可以更清晰明了的区分方法的边界，通过字符缩进也可以让代码的层次感更加明显，先来看整体效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083622282-1260946137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需要按照下图勾选相应选项就可以了 （现在是不是很清晰？）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083622590-1125800670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;editor-边栏位置设置&quot;&gt;Editor 边栏位置设置&lt;/h3&gt;
&lt;p&gt;如果你不能熟悉的使用 &lt;code&gt;cmd + E&lt;/code&gt; 快捷键（一不小心给了提示）打开你最近常用的文件，顶部位置可显示的打开的类名称少之又少，所以通过挪动 Editor 的显示位置，就可以解决这个痛点问题，现在是不是极度舒适了呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202005/1583165-20200506083627568-478526627.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当你觉得需要 IDEA 帮助你更高效的工作时，不妨去插件市场搜搜看，没准就有意想不到的惊喜。另外，这是一个 IDEA 设置篇的合集，我会陆续将更多设置和好用的插件整合到一起&lt;/p&gt;
&lt;p&gt;如果你有觉得让你神清气爽的配置或插件，还请留言告知帮助大家&lt;/p&gt;
</description>
<pubDate>Wed, 06 May 2020 00:37:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>| 好看请赞，养成习惯 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/12834274.html</dc:identifier>
</item>
<item>
<title>手把手教你使用ADB卸载手机内置App软件 - dcpeng</title>
<link>http://www.cnblogs.com/dcpeng/p/12834272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dcpeng/p/12834272.html</guid>
<description>&lt;p&gt;&lt;strong&gt;【一、前言】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不知道你们有没有那么一段黑暗时期，刚买个手机，手机上内置一堆app，还卸载不掉，然后每天各种广告，手机一共1G的运行内存，那些流氓app还要再占走一些内存，真是让人欲哭无泪啊，后来我就学会了root，各种各种root，各种卸载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083532099-269682564.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;终于，2020年了，手机早都已经发展的NB轰轰了，厂商们成功的限制住了其他流氓软件的发展，并且让自家产品名正缘顺的装在了自己手机上，当然，跟那段黑暗时期相比，现在的厂商简直就是菩萨了。&lt;/p&gt;
&lt;p&gt;但是现在手机基本上获取root权限有点无望，或者复杂，并且一旦获取就不维修了，咱们不做这种杀鸡取卵之事。&lt;/p&gt;
&lt;p&gt;咱们通过adb的方式连接手机，通过adb的方式卸载手机内置app，感受adb的强大。&lt;/p&gt;
&lt;p&gt;那还等什么，开始吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【二、需要的工具】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;PC端。adb连接手机工具，如下图所示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083532497-888799627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;手机端。es文件管理器，如下图所示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083533013-152585685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取方式：公众号&lt;strong&gt;[IT共享之家]&lt;/strong&gt;后台回复“&lt;strong&gt;手机工具&lt;/strong&gt;”四个字即可获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;工具
ES文件浏览器.apk
adb(1.0.36).rar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记得一定要用我们提供的adb，自己百度下载的可能版本太低，会有莫名其妙的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【三、手机端步骤】&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用数据线将电脑和手机连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;激活开发者模式，一般情况下是找到关于手机 ---&amp;gt; 多次点击软件版本号，会提示打开开发者选项，如下图所示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083533383-1869716522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;进入开发者选项打开开发者选项和usb调试，如下图所示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083533669-1118915206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;中间可能会提示授权，一律都要点击同意。请放心，这个是自己的电脑，不是共享充电宝。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083534016-1972945118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;完成这些，基本上算是完成了50%。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;【四、电脑端步骤】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开提供的adb工具，如下图所示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083534390-1573250398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在adb工具的文件夹里面按住shift+鼠标右键，选择红色方框的选项，如下图所示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083535456-1464672878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一定要按住shift再按鼠标右键噢。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;执行命令&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;adb.exe devices
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ps: 如果是win10的话，打完adb记得再按一下tab键，就会自动提示成 .\adb.exe ，下面所有的adb打完之后记得都要按一下tab键。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083535824-1937212962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有出现这个场面，才代表连接手机完成，此时基本完成了90%。&lt;/p&gt;
&lt;p&gt;unauthorized表示我手机并没有授权，如果此时手机提示授权，一定要同意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【五、开始卸载】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先需要执行一条命令，进入交互模式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;adb shell
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083536150-603065819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果出现了类似上截图，恭喜你，基本算是o98k了，只需要卸载就可以了。&lt;/p&gt;
&lt;p&gt;卸载命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pm uninstall -k --user 0 软件包名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个软件包名，该怎么获取呢？手机端通过已经安装好的es文件管理器进行获取。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开es文件管理器，点击应用，如下图所示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083536850-136545882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;点击左上角 用户已安装应用 --&amp;gt; 系统应用，如下图所示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083537441-873367666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;系统应用列表，如下图所示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083538022-545727815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【六、卸载案例】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我是iQOO手机，就vivo钱包，如下图所示，因为我没什么可卸了...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083538580-623470438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我就点击一下这个vivo钱包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083539115-678908867.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这，红色圈起来的就是包名。&lt;/p&gt;
&lt;p&gt;虽然有一个卸载的按钮，但是我试了N次，每次通知栏都会提示一个卸载失败的按钮，你们可以尝试一下，万一卸载了呢，是不是？&lt;/p&gt;
&lt;p&gt;执行命令卸载&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pm uninstall -k --user 0 com.vivo.wallet
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083539503-871153201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Success！&lt;/p&gt;
&lt;p&gt;当你再去手机上找时，这个内置app已经没了。&lt;/p&gt;
&lt;p&gt;【七、总结】&lt;/p&gt;
&lt;p&gt;通过上述步骤，我相信你应该已经学会了通过adb卸载手机内置app，但是仍有几个注意事项：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;手机端一定要打开 开发者选项，usb调试，并且授权&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;电脑端一定要执行adb devices查看设备是否连接上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;命令总结&lt;/p&gt;
&lt;p&gt;进入交互模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;adb shell
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;卸载：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pm uninstall -k --user 0 软件包名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据测试，主流的一些手机品牌都可以通过此方法卸载噢，欢迎大家积极尝试!!!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;看完本文有收获？请转发分享给更多的人&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IT共享之家&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;入群请在微信后台回复【入群】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1380669/202005/1380669-20200506083539818-185269397.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;往期精彩文章推荐：&lt;/p&gt;
&lt;blockquote readability=&quot;4.3661971830986&quot;&gt;
&lt;p&gt;本文由博客群发一文多发等运营工具平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 06 May 2020 00:36:00 +0000</pubDate>
<dc:creator>dcpeng</dc:creator>
<og:description>【一、前言】 不知道你们有没有那么一段黑暗时期，刚买个手机，手机上内置一堆app，还卸载不掉，然后每天各种广告，手机一共1G的运行内存，那些流氓app还要再占走一些内存，真是让人欲哭无泪啊，后来我就学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dcpeng/p/12834272.html</dc:identifier>
</item>
<item>
<title>Web 跨域请求问题的解决方案- CORS 方案 - AnonyStar</title>
<link>http://www.cnblogs.com/i-code/p/12834241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/i-code/p/12834241.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202005/2024393-20200506081739941-429701887.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;跨域是指跨域名的访问，以下情况都属于跨域：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;跨域现象&lt;/th&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;域名不相同&lt;/td&gt;
&lt;td&gt;&lt;code&gt;www.baidu.com&lt;/code&gt;与&lt;code&gt;www.taobao&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;一级域名相同，但是端口不相同&lt;/td&gt;
&lt;td&gt;&lt;code&gt;www.baidu.com：8080&lt;/code&gt; 与 &lt;code&gt;www.baidu.com:9090&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;二级域名不相同&lt;/td&gt;
&lt;td&gt;&lt;code&gt;news.baidu.com&lt;/code&gt; 与&lt;code&gt;baike.baidu.com&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：如果&lt;strong&gt;域名与端口均相同，只是请求的路径不相同&lt;/strong&gt;，则不属于跨域，例如：&lt;br/&gt;&lt;code&gt;www.baidu.com/item&lt;/code&gt;&lt;br/&gt;&lt;code&gt;www.baidu.com/guonei&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tpis:跨域不一定会有跨域问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为跨域问题是浏览器&lt;strong&gt;对于ajax请求&lt;/strong&gt;的一种安全限制：&lt;/p&gt;
&lt;p&gt;一个页面发起的ajax请求，只能是于当前页同域名的路径，这能有效的阻止跨站攻击。&lt;/p&gt;
&lt;p&gt;若没有该限制，那么任意一个网站中的js脚本都可以对其他任意网站进行恶意的攻击，因为cookie是浏览器端保存的重要数据，这样子就可以通过cookie在来跨域访问同一浏览器打开的网站，存在严重安全隐患；&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;因此：跨域问题 是针对ajax的一种限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是这却给我们的开发带来了不便，而且在实际生成环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同&lt;/p&gt;

&lt;p&gt;目前主流的解决跨域问题的方案有三种：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;jsonp&lt;/strong&gt;&lt;br/&gt;早期的跨域主流解决方案，其原理通过&lt;code&gt;script&lt;/code&gt;标签进行跨域实现&lt;br/&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要服务端的支持&lt;/li&gt;
&lt;li&gt;只能发起&lt;code&gt;GET&lt;/code&gt;请求，局限性大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;nginx反向代理&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;思想：&lt;/strong&gt; 利用&lt;code&gt;nginx&lt;/code&gt;方向代理的功能，将原本跨域的请求代理为不跨域的 ，支持各种请求方式&lt;br/&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 需要在&lt;code&gt;nginx&lt;/code&gt;服务器上进行额外的配置，同时需要维护大量的域名地址，如意混淆&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;CORS&lt;/strong&gt;&lt;br/&gt;目前主流的跨域解决方案，该方案安全可靠，目前应用广泛。&lt;br/&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在服务端进行控制来确定是否允许跨域，规则可以自定义&lt;/li&gt;
&lt;li&gt;支持各种请求方式 （七大请求方式均支持）&lt;br/&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;会产生额外的请求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;41-cors跨域解决方案&quot;&gt;4.1 CORS跨域解决方案&lt;/h2&gt;
&lt;h3 id=&quot;411-cors简介&quot;&gt;4.1.1 CORS简介&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CORS&lt;/code&gt;是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。&lt;/p&gt;
&lt;p&gt;它允许浏览器向跨源服务器，发出&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求，从而克服了&lt;code&gt;AJAX&lt;/code&gt;只能&lt;strong&gt;同源&lt;/strong&gt;使用的限制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CORS&lt;/code&gt;需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，&lt;strong&gt;IE浏览器不能低于IE10&lt;/strong&gt;。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;浏览器端：&lt;br/&gt;目前，所有浏览器都支持该功能（IE10以下不行）。整个&lt;code&gt;CORS&lt;/code&gt;通信过程，都是浏览器自动完成，不需要用户参与。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;服务端：&lt;br/&gt;&lt;code&gt;CORS&lt;/code&gt;通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。 &lt;strong&gt;&lt;code&gt;这一般通过过滤器即可实现&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;412-原理&quot;&gt;4.1.2 原理&lt;/h3&gt;
&lt;p&gt;当前浏览器会将我们的&lt;code&gt;Ajax&lt;/code&gt;请求进行分类，根据其处理方案的差异分为:&lt;code&gt;简单请求&lt;/code&gt;、&lt;code&gt;特殊请求&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单请求&lt;/strong&gt;&lt;br/&gt;需要同时满足以下两大条件，才属于简单请求：&lt;br/&gt;1）请求方式必须是以下三种方式中的一种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2）HTTP请求的头信息不能超出以下几种字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Last-Event-ID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Conten-Type&lt;/code&gt;:只能是 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;、&lt;code&gt;multipart/form-data&lt;/code&gt;、&lt;code&gt;text/plain&lt;/code&gt;三个中的任意一个&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当浏览器发现发送的ajax请求是简单请求时，会在请求头中携带一个字段：&lt;code&gt;Origin&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Origin&lt;/code&gt;中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。&lt;/p&gt;
&lt;p&gt;如果服务器允许跨域，需要在返回的响应头中携带下面信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access-Control-Allow-Origin: http://manage.leyou.com
Access-Control-Allow-Credentials: true
Content-Type: text/html; charset=utf-8
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意&lt;/li&gt;
&lt;li&gt;Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果跨域请求要想操作&lt;code&gt;cookie&lt;/code&gt;，需要满足3个条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务的响应头中需要携带&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;并且为true。&lt;/li&gt;
&lt;li&gt;浏览器发起ajax需要指定&lt;code&gt;withCredentials&lt;/code&gt; 为true&lt;/li&gt;
&lt;li&gt;响应头中的&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;一定不能为*，&lt;strong&gt;必须是指定的域名&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;特殊请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;预检请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特殊请求会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（&lt;code&gt;preflight&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。&lt;/p&gt;
&lt;p&gt;一个“预检”请求的样板：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OPTIONS /cors HTTP/1.1
Origin: http://baike.baidu.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.leyou.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与简单请求相比，除了Origin以外，多了两个头：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;：接下来会用到的请求方式，比如PUT&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;：会额外用到的头信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;预检请求的响应&lt;/p&gt;
&lt;p&gt;服务的收到预检请求，如果许可跨域，会发出响应：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://baike.baidu.com
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Max-Age: 1728000
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;和&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;以外，这里又额外多出3个头：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;：允许访问的方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;：允许携带的头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。&lt;/p&gt;
&lt;h3 id=&quot;413-代码实现&quot;&gt;4.1.3 代码实现&lt;/h3&gt;
&lt;p&gt;在我们代码实现时，其实非常简单，只需要明白一点，我们不需要管浏览器端，浏览器端会自动处理。我们只在乎服务端的处理，针对服务器端我们可以很明确。需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要对所有的controller层进行处理&lt;/li&gt;
&lt;li&gt;需要所有的请求都要进行跨域处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更具这种情况，是典型的AOP思想，我们可以采用拦截器实现该功能；&lt;br/&gt;实际上我们springmvc框架中已经自己实现了CORS的跨域过滤器，我们只需要直接调用处理就好；我们这里采用javacondif的方式进行配置书写，需要spring3以上版本支持；也可采用传统XML形式，这里不在阐述，具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class GlobalCorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        //1.添加CORS配置信息
        CorsConfiguration config = new CorsConfiguration();
        //1) 允许的域,不要写*，否则cookie就无法使用了
        config.addAllowedOrigin(&quot;http://manage.i-code.online&quot;);
        //2) 是否发送Cookie信息
        config.setAllowCredentials(true);
        //3) 允许的请求方式
        config.addAllowedMethod(&quot;OPTIONS&quot;);
        config.addAllowedMethod(&quot;HEAD&quot;);
        config.addAllowedMethod(&quot;GET&quot;);
        config.addAllowedMethod(&quot;PUT&quot;);
        config.addAllowedMethod(&quot;POST&quot;);
        config.addAllowedMethod(&quot;DELETE&quot;);
        config.addAllowedMethod(&quot;PATCH&quot;);
        // 4）允许的头信息
        config.addAllowedHeader(&quot;*&quot;);
        //5)有效时长
        config.setMaxAge(3600L);
        //2.添加映射路径，我们拦截一切请求
        UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource();
        configSource.registerCorsConfiguration(&quot;/**&quot;, config);

        //3.返回新的CorsFilter.
        return new CorsFilter(configSource);
    }
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7.7408906882591&quot;&gt;
&lt;p&gt;本文由AnonyStar 发布,可转载但需声明原文出处。&lt;br/&gt;仰慕「优雅编码的艺术」 坚信熟能生巧，努力改变人生&lt;br/&gt;欢迎关注微信公账号 ：coder简码 获取更多优质文章&lt;br/&gt;更多文章关注笔者博客 ：&lt;a href=&quot;https://i-code.online/&quot;&gt;IT简码&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 06 May 2020 00:18:00 +0000</pubDate>
<dc:creator>AnonyStar</dc:creator>
<og:description>1.什么是跨域 跨域是指跨域名的访问，以下情况都属于跨域： | 跨域现象 | 实例 | | | | | 域名不相同 | 与`www.taobao` | | 一级域名相同，但是端口不相同 | 与 | |</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/i-code/p/12834241.html</dc:identifier>
</item>
<item>
<title>不可错过的java面试博客之java集合篇 - 经典鸡翅</title>
<link>http://www.cnblogs.com/jichi/p/12834238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jichi/p/12834238.html</guid>
<description>&lt;h2&gt;1. &lt;strong&gt;List&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;List &lt;span&gt;是有序的&lt;/span&gt; &lt;span&gt;Collection&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;Java List&lt;/span&gt; &lt;span&gt;一共三个实现类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分别是&lt;/span&gt; ArrayList&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Vector&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;LinkedList&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ArrayList &lt;span&gt;是最常用的&lt;/span&gt; &lt;span&gt;List&lt;/span&gt; &lt;span&gt;实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt; &lt;span&gt;的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。&lt;/span&gt;&lt;span&gt;排列有序，可重复，容量不够的时候，当前容量&lt;/span&gt;*1.5+1&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vector&lt;span&gt;（数组实现、线程同步）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vector &lt;span&gt;与&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt; &lt;span&gt;一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写&lt;/span&gt; &lt;span&gt;Vector&lt;/span&gt;&lt;span&gt;，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt; &lt;span&gt;慢。&lt;/span&gt;默认扩展一倍容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LinkList&lt;span&gt;（链表）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LinkedList &lt;span&gt;是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了&lt;/span&gt; &lt;span&gt;List&lt;/span&gt; &lt;span&gt;接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。&lt;/span&gt;底层使用双向循环链表数据结构。线程不安全。&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;ArrayList&lt;span&gt;和&lt;/span&gt;&lt;span&gt;linkedList&lt;/span&gt;&lt;span&gt;的线程安全处理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;ArrayList&lt;span&gt;是线程不安全的，因此在并发编程时，经常会使用&lt;/span&gt;&lt;span&gt;Collections.synchronizedList&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;CopyOnWriteArrayList&lt;/span&gt;&lt;span&gt;来替代&lt;/span&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;，接下来对这两种&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;进行性能的比较。其中&lt;/span&gt;&lt;span&gt;Collections.synchronizedLis&lt;/span&gt;&lt;span&gt;在更新操作中使用了同步锁，而&lt;/span&gt;&lt;span&gt;CopyOnWriteArrayList&lt;/span&gt;&lt;span&gt;在更新操作中不仅使用了可重入锁，而且还需要进行数组的复制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法一&lt;/span&gt;:List&amp;lt;String&amp;gt; list = Collections.synchronizedList(new LinkedList&amp;lt;String&amp;gt;());&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法二&lt;/span&gt;:&lt;span&gt;将&lt;/span&gt;&lt;span&gt;LinkedList&lt;/span&gt;&lt;span&gt;全部换成&lt;/span&gt;&lt;span&gt;ConcurrentLinkedQueue&lt;/span&gt;；&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;Set&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Set &lt;span&gt;注重独一无二的性质&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;该体系集合用于存储无序&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;存入和取出的顺序不一定相同&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;元素，值不能重复。对象的相等性本质是对象&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt; &lt;span&gt;值（&lt;/span&gt;&lt;span&gt;java&lt;/span&gt; &lt;span&gt;是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt; &lt;span&gt;方法和&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt; &lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashSet&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt; &lt;span&gt;表）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哈希表边存放的是哈希值。&lt;/span&gt;HashSet &lt;span&gt;存储元素的顺序并不是按照存入时的顺序（和&lt;/span&gt; &lt;span&gt;List&lt;/span&gt; &lt;span&gt;显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的&lt;/span&gt;&lt;span&gt;hashcode&lt;/span&gt; &lt;span&gt;方法来获取的&lt;/span&gt;&lt;span&gt;, HashSet&lt;/span&gt; &lt;span&gt;首先判断两个元素的哈希值，如果哈希值一样，接着会比较&lt;/span&gt;&lt;span&gt;equals&lt;/span&gt; &lt;span&gt;方法 如果&lt;/span&gt; &lt;span&gt;equls&lt;/span&gt; &lt;span&gt;结果为&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;，&lt;/span&gt;&lt;span&gt;HashSet&lt;/span&gt; &lt;span&gt;就视为同一个元素。如果&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt; &lt;span&gt;为&lt;/span&gt; &lt;span&gt;false&lt;/span&gt; &lt;span&gt;就不是同一个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哈希值相同&lt;/span&gt; equals &lt;span&gt;为&lt;/span&gt; &lt;span&gt;false&lt;/span&gt; &lt;span&gt;的元素是怎么存储呢&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;表示&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt; &lt;span&gt;值不相同的情况；图&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;表示&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt; &lt;span&gt;值相同，但&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt; &lt;span&gt;不相同的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;HashSet &lt;span&gt;通过&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt; &lt;span&gt;值来确定元素在内存中的位置。一个&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt; &lt;span&gt;位置上可以存放多个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TreeSet&lt;span&gt;（二叉树）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. TreeSet()&lt;span&gt;是使用二叉树的原理对新&lt;/span&gt; &lt;span&gt;add()&lt;/span&gt;&lt;span&gt;的对象按照指定的顺序排序（升序、降序），每增&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加一个对象都会进行排序，将对象插入的二叉树指定的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. Integer &lt;span&gt;和&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;对象都可以进行默认的&lt;/span&gt; &lt;span&gt;TreeSet&lt;/span&gt; &lt;span&gt;排序，而自定义类的对象是不可以的，自己定义的类必须实现&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;span&gt;接口，并且覆写相应的&lt;/span&gt; &lt;span&gt;compareTo()&lt;/span&gt;&lt;span&gt;函数，才可以正常使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;在覆写&lt;/span&gt; &lt;span&gt;compare()&lt;/span&gt;&lt;span&gt;函数时，要返回相应的值才能使&lt;/span&gt; &lt;span&gt;TreeSet&lt;/span&gt; &lt;span&gt;按照一定的规则来排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LinkHashSet&lt;span&gt;（&lt;/span&gt;&lt;span&gt;HashSet+LinkedHashMap&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt; LinkedHashSet &lt;span&gt;而言，它继承与&lt;/span&gt; &lt;span&gt;HashSet&lt;/span&gt;&lt;span&gt;、又基于&lt;/span&gt; &lt;span&gt;LinkedHashMap&lt;/span&gt; &lt;span&gt;来实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LinkedHashSet &lt;span&gt;底层使用&lt;/span&gt; &lt;span&gt;LinkedHashMap&lt;/span&gt; &lt;span&gt;来保存所有元素，它继承与&lt;/span&gt; &lt;span&gt;HashSet&lt;/span&gt;&lt;span&gt;，其所有的方法操作上又与&lt;/span&gt; &lt;span&gt;HashSet&lt;/span&gt; &lt;span&gt;相同，因此&lt;/span&gt; &lt;span&gt;LinkedHashSet&lt;/span&gt; &lt;span&gt;的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个&lt;/span&gt; &lt;span&gt;LinkedHashMap&lt;/span&gt; &lt;span&gt;来实现，在相关操作上与父类&lt;/span&gt; &lt;span&gt;HashSet&lt;/span&gt; &lt;span&gt;的操作相同，直接调用父类&lt;/span&gt; &lt;span&gt;HashSet&lt;/span&gt; &lt;span&gt;的方法即可。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4. &lt;strong&gt;Map&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HashMap&lt;span&gt;（数组&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;链表&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;红黑树）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashMap &lt;span&gt;根据键的&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt; &lt;span&gt;值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt; &lt;span&gt;最多只允许一条记录的键为&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;，允许多条记录的值为&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt; &lt;span&gt;非线程安全，即任一时刻可以有多个线程同时写&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;，可能会导致数据的不一致。如果需要满足线程安全，可以用&lt;/span&gt; &lt;span&gt;Collections&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;synchronizedMap&lt;/span&gt; &lt;span&gt;方法使&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt; &lt;span&gt;具有线程安全的能力，或者使用&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java7&lt;span&gt;的&lt;/span&gt;&lt;span&gt;hashmap&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081209639-1917569525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;大方向上，&lt;/span&gt;HashMap &lt;span&gt;里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;的实例，&lt;/span&gt;&lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;包含四个属性：&lt;/span&gt;&lt;span&gt;key, value, hash&lt;/span&gt; &lt;span&gt;值和用于单向链表的&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. capacity&lt;span&gt;：当前数组容量，始终保持&lt;/span&gt; &lt;span&gt;2^n&lt;/span&gt;&lt;span&gt;，可以扩容，扩容后数组大小为当前的&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;倍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. loadFactor&lt;span&gt;：负载因子，默认为&lt;/span&gt; &lt;span&gt;0.75&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. threshold&lt;span&gt;：扩容的阈值，等于&lt;/span&gt; &lt;span&gt;capacity * loadFactor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java8&lt;span&gt;的&lt;/span&gt;&lt;span&gt;hashmap&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java8 &lt;span&gt;对&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt; &lt;span&gt;进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;链表&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;红黑树 组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据&lt;/span&gt; Java7 HashMap &lt;span&gt;的介绍，我们知道，查找的时候，根据&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt; &lt;span&gt;值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为&lt;/span&gt; &lt;span&gt;O(n)&lt;/span&gt;&lt;span&gt;。为了降低这部分的开销，在&lt;/span&gt; &lt;span&gt;Java8&lt;/span&gt; &lt;span&gt;中，当链表中的元素超过了&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为&lt;/span&gt; &lt;span&gt;O(logN)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081217008-2136217868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Segment &lt;span&gt;段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap &lt;span&gt;和&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt; &lt;span&gt;思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt; &lt;span&gt;由一个个&lt;/span&gt; &lt;span&gt;Segment&lt;/span&gt; &lt;span&gt;组成，&lt;/span&gt;&lt;span&gt;Segment&lt;/span&gt; &lt;span&gt;代表&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;部分&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;一段&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了&lt;/span&gt;“&lt;span&gt;槽&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;来代表一个&lt;/span&gt;&lt;span&gt;segment&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程安全（&lt;/span&gt;Segment &lt;span&gt;继承&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;加锁）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单理解就是，&lt;/span&gt;ConcurrentHashMap &lt;span&gt;是一个&lt;/span&gt; &lt;span&gt;Segment&lt;/span&gt; &lt;span&gt;数组，&lt;/span&gt;&lt;span&gt;Segment&lt;/span&gt; &lt;span&gt;通过继承&lt;/span&gt;&lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;来进行加锁，所以每次需要加锁的操作锁住的是一个&lt;/span&gt; &lt;span&gt;segment&lt;/span&gt;&lt;span&gt;，这样只要保证每个&lt;/span&gt; &lt;span&gt;Segment&lt;/span&gt; &lt;span&gt;是线程安全的，也就实现了全局的线程安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081222890-923253970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;并行度（默认&lt;/span&gt; 16&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;concurrencyLevel&lt;span&gt;：并行级别、并发数、&lt;/span&gt;&lt;span&gt;Segment&lt;/span&gt; &lt;span&gt;数，怎么翻译不重要，理解它。默认是&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说&lt;/span&gt; ConcurrentHashMap &lt;span&gt;有&lt;/span&gt; &lt;span&gt;16&lt;/span&gt; &lt;span&gt;个&lt;/span&gt; &lt;span&gt;Segments&lt;/span&gt;&lt;span&gt;，所以理论上，这个时候，最多可以同时支持&lt;/span&gt; &lt;span&gt;16&lt;/span&gt; &lt;span&gt;个线程并发写，只要它们的操作分别分布在不同的&lt;/span&gt; &lt;span&gt;Segment&lt;/span&gt; &lt;span&gt;上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个&lt;/span&gt; &lt;span&gt;Segment&lt;/span&gt; &lt;span&gt;内部，其实每个&lt;/span&gt; &lt;span&gt;Segment&lt;/span&gt; &lt;span&gt;很像之前介绍的&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;，不过它要保证线程安全，所以处理起来要麻烦些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java8&lt;span&gt;实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java8 &lt;span&gt;对&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt; &lt;span&gt;进行了比较大的改动&lt;/span&gt;&lt;span&gt;,Java8&lt;/span&gt; &lt;span&gt;也引入了红黑树。通过对链表的头加锁实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081230345-682082464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;HashTable&lt;span&gt;（线程安全）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hashtable &lt;span&gt;是遗留类，很多映射的常用功能与&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt; &lt;span&gt;类似，不同的是它承自&lt;/span&gt; &lt;span&gt;Dictionary&lt;/span&gt; &lt;span&gt;类，并且是线程安全的，任一时间只有一个线程能写&lt;/span&gt; &lt;span&gt;Hashtable&lt;/span&gt;&lt;span&gt;，并发性不如&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;，因为&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt; &lt;span&gt;引入了分段锁。&lt;/span&gt;&lt;span&gt;Hashtable&lt;/span&gt; &lt;span&gt;不建议在新代码中使用，不需要线程安全的场合可以用&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt; &lt;span&gt;替换，需要线程安全的场合可以用&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt; &lt;span&gt;替换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TreeMap&lt;span&gt;（可排序）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TreeMap &lt;span&gt;实现&lt;/span&gt; &lt;span&gt;SortedMap&lt;/span&gt; &lt;span&gt;接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用&lt;/span&gt; &lt;span&gt;Iterator&lt;/span&gt; &lt;span&gt;遍历&lt;/span&gt; &lt;span&gt;TreeMap&lt;/span&gt; &lt;span&gt;时，得到的记录是排过序的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果使用排序的映射，建议使用&lt;/span&gt; TreeMap&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在使用&lt;/span&gt; TreeMap &lt;span&gt;时，&lt;/span&gt;&lt;span&gt;key&lt;/span&gt; &lt;span&gt;必须实现&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;span&gt;接口或者在构造&lt;/span&gt; &lt;span&gt;TreeMap&lt;/span&gt; &lt;span&gt;传入自定义的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Comparator&lt;span&gt;，否则会在运行时抛出&lt;/span&gt; &lt;span&gt;java.lang.ClassCastException&lt;/span&gt; &lt;span&gt;类型的异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LinkHashMap&lt;span&gt;（记录插入顺序）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LinkedHashMap &lt;span&gt;是&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt; &lt;span&gt;的一个子类，保存了记录的插入顺序，在用&lt;/span&gt; &lt;span&gt;Iterator&lt;/span&gt; &lt;span&gt;遍历&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LinkedHashMap &lt;span&gt;时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5. &lt;strong&gt;HashMap&lt;span&gt;中，初始化设置长度时，容量自动转成&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的幂次长度的算法剖析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;默认情况下&lt;/span&gt;HashMap&lt;span&gt;的容量是&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;，但是，如果用户通过构造函数指定了一个数字作为容量，那么&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;会选择大于该数字的第一个&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的幂作为容量。&lt;/span&gt;&lt;span&gt;(3-&amp;gt;4&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;7-&amp;gt;8&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;9-&amp;gt;16)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以知道，在已知&lt;/span&gt;HashMap&lt;span&gt;中将要存放的&lt;/span&gt;&lt;span&gt;KV&lt;/span&gt;&lt;span&gt;个数的时候，设置一个合理的初始化容量可以有效的提高性能。&lt;/span&gt;因为减少扩容，提高效率。&lt;/p&gt;
&lt;p&gt;HashMap&lt;span&gt;有扩容机制，就是当达到扩容条件时会进行扩容。&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;的扩容条件就是当&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;中的元素个数（&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;）超过临界值（&lt;/span&gt;&lt;span&gt;threshold&lt;/span&gt;&lt;span&gt;）时就会自动扩容。在&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;中，&lt;/span&gt;&lt;span&gt;threshold = loadFactor * capacity&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，如果我们没有设置初始容量大小，随着元素的不断增加，&lt;/span&gt;HashMap&lt;span&gt;会发生多次扩容，而&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;中的扩容机制决定了每次扩容都需要重建&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;表，是非常影响性能的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，当我们设置&lt;/span&gt;HashMap&lt;span&gt;的初始化容量时，实际上&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;会采用第一个大于该数值的&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的幂作为初始化容量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;Jdk 1.7&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Jdk 1.8&lt;/span&gt;&lt;span&gt;中，&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;初始化这个容量的时机不同。&lt;/span&gt;&lt;span&gt;jdk1.8&lt;/span&gt;&lt;span&gt;中，在调用&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;的构造函数定义&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;的时候，就会进行容量的设定。而在&lt;/span&gt;&lt;span&gt;Jdk 1.7&lt;/span&gt;&lt;span&gt;中，要等到第一次&lt;/span&gt;&lt;span&gt;put&lt;/span&gt;&lt;span&gt;操作时才进行这一操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管是&lt;/span&gt;Jdk 1.7&lt;span&gt;还是&lt;/span&gt;&lt;span&gt;Jdk 1.8&lt;/span&gt;&lt;span&gt;，计算初始化容量的算法其实是如出一辙的，主要代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;int n = cap - 1;&lt;/p&gt;
&lt;p&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 1;&lt;/p&gt;
&lt;p&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 2;&lt;/p&gt;
&lt;p&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 4;&lt;/p&gt;
&lt;p&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 8;&lt;/p&gt;
&lt;p&gt;n |= n &amp;gt;&amp;gt;&amp;gt; 16;&lt;/p&gt;
&lt;p&gt;return (n &amp;lt;&amp;gt;0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据用户传入的容量值（代码中的&lt;/span&gt;cap&lt;span&gt;），通过计算，得到第一个比他大的&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的幂并返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过几次无符号右移和按位或运算，我们把&lt;/span&gt;1100 1100 1100&lt;span&gt;转换成了&lt;/span&gt;&lt;span&gt;1111 1111 1111&lt;/span&gt; &lt;span&gt;，再把&lt;/span&gt;&lt;span&gt;1111 1111 1111&lt;/span&gt;&lt;span&gt;加&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，就得到了&lt;/span&gt;&lt;span&gt;1 0000 0000 0000&lt;/span&gt;&lt;span&gt;，这就是大于&lt;/span&gt;&lt;span&gt;1100 1100 1100&lt;/span&gt;&lt;span&gt;的第一个&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的幂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是还有一种特殊情况套用以上公式不行，这些数字就是&lt;/span&gt;2&lt;span&gt;的幂自身。如果数字&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;套用公式的话。得到的会是&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; 。&lt;span&gt;为了解决这个问题，&lt;/span&gt;JDK&lt;span&gt;的工程师把所有用户传进来的数在进行计算之前先&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最好的初始化容量机制：&lt;/span&gt;expectedSize / 0.75F + 1.0F&lt;/p&gt;
&lt;h2&gt;6. &lt;strong&gt;&lt;span&gt;如果&lt;/span&gt;HashMap&lt;span&gt;的大小超过了负载因子&lt;/span&gt;&lt;span&gt;(load factor)&lt;/span&gt;&lt;span&gt;定义的容量，怎么办？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;默认的负载因子大小为&lt;/span&gt;0.75&lt;span&gt;，也就是说，当一个&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;填满了&lt;/span&gt;&lt;span&gt;75%&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;时候，和其它集合类&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;如&lt;/span&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;一样，将会创建原来&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;大小的两倍的&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;数组，来重新调整&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;的大小，并将原来的对象放入新的&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;数组中。这个过程叫作&lt;/span&gt;&lt;span&gt;rehashing&lt;/span&gt;&lt;span&gt;，因为它调用&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;方法找到新的&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;原下标&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;原容量&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;的位置&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;7. &lt;strong&gt;&lt;span&gt;重新调整&lt;/span&gt;HashMap&lt;span&gt;大小存在什么问题吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当重新调整&lt;/span&gt;HashMap&lt;span&gt;大小的时候，确实存在条件竞争，因为如果两个线程都发现&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;位置的时候，&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历&lt;/span&gt;&lt;span&gt;(tail traversing)&lt;/span&gt;&lt;span&gt;。如果条件竞争发生了，那么就死循环了。&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;多线程的环境下不使用&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;8. &lt;strong&gt;&lt;span&gt;为什么&lt;/span&gt;hashmap&lt;span&gt;多线程会进入死循环？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;HashMap&lt;span&gt;的容量是有限的。当经过多次元素插入，使得&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;达到一定饱和度时，&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;映射位置发生冲突的几率会逐渐提高。这时候，&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;需要扩展它的长度，也就是进行&lt;/span&gt;&lt;span&gt;Resize&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于扩容采用的是尾插法。会造成环形的情况，第一个线程&lt;/span&gt; &lt;span&gt;是&lt;/span&gt; 2&lt;span&gt;指向&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;。然后&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;执行另一个线程，尾插法 变成了&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;指向&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;。此时回到线程&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;指向&lt;/span&gt;&lt;span&gt;3 3&lt;/span&gt;&lt;span&gt;又指向&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;。就找不到尾部数据，产生死循环。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;9. &lt;strong&gt;hashmap&lt;span&gt;的工作原理是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;HashMap&lt;span&gt;是基于&lt;/span&gt;&lt;span&gt;hashing&lt;/span&gt;&lt;span&gt;的原理，我们使用&lt;/span&gt;&lt;span&gt;put(key, value)&lt;/span&gt;&lt;span&gt;存储对象到&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;中，使用&lt;/span&gt;&lt;span&gt;get(key)&lt;/span&gt;&lt;span&gt;从&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;中获取对象。当我们给&lt;/span&gt;&lt;span&gt;put()&lt;/span&gt;&lt;span&gt;方法传递键和值时，我们先对键调用&lt;/span&gt;&lt;span&gt;hashCode()&lt;/span&gt;&lt;span&gt;方法，计算并返回的&lt;/span&gt;&lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;是用于找到&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;数组的&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;位置来储存&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt; &lt;span&gt;对象。这里关键点在于指出，&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;是在&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;中储存键对象和值对象，作为&lt;/span&gt;&lt;span&gt;Map.Node&lt;/span&gt; &lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是具体的&lt;/span&gt;put&lt;span&gt;过程（&lt;/span&gt;&lt;span&gt;JDK1.8&lt;/span&gt;&lt;span&gt;版）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;对&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;求&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值，然后再计算下标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值相同，需要放到同一个&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;中）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;span&gt;如果碰撞了，则调用&lt;/span&gt;&lt;span&gt;equals()&lt;/span&gt; &lt;span&gt;比较&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;，相同则替换旧值，不同则以链表的方式链接到后面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;span&gt;如果链表长度超过阀值&lt;/span&gt;&lt;span&gt;( TREEIFY THRESHOLD==8)&lt;/span&gt;&lt;span&gt;，就把链表转成红黑树，链表长度低于&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;，就把红黑树转回链表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;span&gt;如果桶满了&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;容量&lt;/span&gt;&lt;span&gt;16*&lt;/span&gt;&lt;span&gt;加载因子&lt;/span&gt;&lt;span&gt;0.75)&lt;/span&gt;&lt;span&gt;，就需要&lt;/span&gt; &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;（扩容&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;倍后重排）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是具体&lt;/span&gt;get&lt;span&gt;过程&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;考虑特殊情况如果两个键的&lt;/span&gt;&lt;span&gt;hashcode&lt;/span&gt;&lt;span&gt;相同，你如何获取值对象？&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们调用&lt;/span&gt;get()&lt;span&gt;方法，&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;会使用键对象的&lt;/span&gt;&lt;span&gt;hashcode&lt;/span&gt;&lt;span&gt;找到&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;位置，找到&lt;/span&gt;&lt;span&gt;bucket&lt;/span&gt;&lt;span&gt;位置之后，会调用&lt;/span&gt;&lt;span&gt;keys.equals()&lt;/span&gt;&lt;span&gt;方法去找到链表中正确的节点，最终找到要找的值对象。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;10. &lt;strong&gt;HashMap&lt;span&gt;中&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;函数怎么是是实现的&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们可以看到在&lt;/span&gt;hashmap&lt;span&gt;中要找到某个元素，需要根据&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;值来求得对应数组中的位置。 所以我们首先想到的就是把&lt;/span&gt;&lt;span&gt;hashcode&lt;/span&gt;&lt;span&gt;对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;模&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看&lt;/span&gt;&lt;span&gt;JDK1.8&lt;/span&gt;&lt;span&gt;的源码是怎么做的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081247794-1809884850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;11. &lt;strong&gt;&lt;span&gt;拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持&lt;/span&gt;“&lt;span&gt;平衡&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;12. &lt;strong&gt;&lt;span&gt;说说你对红黑树的见解？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;每个节点非红即黑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根节点总是黑色的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果节点是红色的，则它的子节点必须是黑色的（反之不一定）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个叶子节点都是黑色的空节点（&lt;/span&gt;NIL&lt;span&gt;节点）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;13. &lt;strong&gt;&lt;span&gt;解决&lt;/span&gt;hash &lt;span&gt;碰撞还有那些办法？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;开放定址法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当冲突发生时，使用某种探查技术在散列表中形成一个探查&lt;/span&gt;(&lt;span&gt;测&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;序列。沿此序列逐个单元地查找，直到找到给定的地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;再哈希法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hi = RHi&lt;span&gt;（&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;&lt;span&gt;i=1,2,...k&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;RHi&lt;span&gt;均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到不发生冲突为止。这种方法不易产生聚集，但是增加了计算时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：增加了计算时间。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;建立一个公共溢出区&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设哈希函数的值域为&lt;/span&gt;[0,m-1]&lt;span&gt;，则设向量&lt;/span&gt;&lt;span&gt;HashTable[0...m-1]&lt;/span&gt;&lt;span&gt;为基本表，每个分量存放一个记录，另设立向量&lt;/span&gt;&lt;span&gt;OverTable[0....v]&lt;/span&gt;&lt;span&gt;为溢出表。所有关键字和基本表中关键字为同义词的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单地说就是搞个新表存冲突的元素。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;链地址法（拉链法）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将所有关键字为同义词的记录存储在同一线性链表中，也就是把冲突位置的元素构造成链表。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;14. &lt;strong&gt;为什么要用扰动函数？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081257846-1899638454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;扰动函数就是解决碰撞问题。若不使用扰动函数，则直接将&lt;/span&gt;key.hashCode()&lt;span&gt;和下面的步骤&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;做与运算，则会有以下情景。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以初始长度&lt;/span&gt;16&lt;span&gt;为例，&lt;/span&gt;&lt;span&gt;16-1=15&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;进制表示是&lt;/span&gt;&lt;span&gt;00000000 00000000 00001111&lt;/span&gt;&lt;span&gt;。和某散列值做&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;操作如下，结果就是截取了最低的四位值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081303184-1119471037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;这样就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，则碰撞会更严重。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;15. &lt;strong&gt;扰动函数如何实现？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由扰动函数源码可知，会有以下步骤：&lt;/span&gt;①&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;key.hashCode()&lt;/span&gt;&lt;span&gt;计算&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;值并赋值给变量&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;span&gt;②&lt;/span&gt;&lt;span&gt;将&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;向右移动&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;位；&lt;/span&gt;&lt;span&gt;③&lt;/span&gt;&lt;span&gt;将变量&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;和向右移&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;位的&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;做异或运算（二进制位相同为&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，不同为&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）。此时得到经过扰动函数后的&lt;/span&gt;&lt;span&gt;hansh&lt;/span&gt;&lt;span&gt;值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081311502-872812497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;右移&lt;/span&gt;16&lt;span&gt;位正好为&lt;/span&gt;&lt;span&gt;32bit&lt;/span&gt;&lt;span&gt;的一半，自己的高半区和低半区做异或，是为了混合原始哈希吗的高位和低位，来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，使高位的信息也被保留下来&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081317589-1959939842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;若直接使用&lt;/span&gt;key.hashCode()&lt;span&gt;计算出&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;值，则范围为：&lt;/span&gt;&lt;span&gt;-2147483648&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt;2147483648&lt;/span&gt;&lt;span&gt;，大约&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;亿的映射空间。若映射得比较均匀，是很难出现碰撞的。但是这么大范围无法放入内存中，况且&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;的 初始容量为&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;。所以必须要进行与运算取模。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;16. &lt;strong&gt;HashMap&lt;span&gt;的负载因子初始值为什么是&lt;/span&gt;&lt;span&gt;0.75?&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;比如说当前的容器容量是&lt;/span&gt;16&lt;span&gt;，负载因子是&lt;/span&gt;&lt;span&gt;0.75,16*0.75=12&lt;/span&gt;&lt;span&gt;，也就是说，当容量达到了&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;的时候就会进行扩容操作&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当负载因子是&lt;/span&gt;1.0&lt;span&gt;的时候，也就意味着，只有当数组的&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;个值（这个图表示了&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;个）全部填充了，才会发生扩容。这就带来了很大的问题，因为&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;冲突时避免不了的。当负载因子是&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;的时候，意味着会出现大量的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;的冲突，底层的红黑树变得异常复杂。对于查询效率极其不利。这种情况就是牺牲了时间来保证空间的利用率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此一句话总结就是负载因子过大，虽然空间利用率上去了，但是时间效率降低了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;负载因子是&lt;/span&gt;0.5&lt;span&gt;的时候，这也就意味着，当数组中的元素达到了一半就开始扩容，既然填充的元素少了，&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;冲突也会减少，那么底层的链表长度或者是红黑树的高度就会降低。查询效率就会增加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，兄弟们，这时候空间利用率就会大大的降低，原本存储&lt;/span&gt;1M&lt;span&gt;的数据，现在就意味着需要&lt;/span&gt;&lt;span&gt;2M&lt;/span&gt;&lt;span&gt;的空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一句话总结就是负载因子太小，虽然时间效率提升了，但是空间利用率降低了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大致意思就是说负载因子是&lt;/span&gt;0.75&lt;span&gt;的时候，空间利用率比较高，而且避免了相当多的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;17. &lt;strong&gt;&lt;span&gt;为什么&lt;/span&gt;hashMap&lt;span&gt;的容量扩容时一定是&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的幂次&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081336739-579950398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;HashMap&lt;span&gt;的容量为&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;转化成二进制为&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;length-1&lt;/span&gt;&lt;span&gt;得出的二进制为&lt;/span&gt;&lt;span&gt;01111&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哈希值为&lt;/span&gt;1111&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081342958-1084891724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;可以得出索引的位置为&lt;/span&gt;15&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设&lt;/span&gt; HashMap&lt;span&gt;的容量为&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;转化成二进制为&lt;/span&gt;&lt;span&gt;1111&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;length-1&lt;/span&gt;&lt;span&gt;得出的二进制为&lt;/span&gt;&lt;span&gt;1110&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哈希值为&lt;/span&gt;1111&lt;span&gt;和&lt;/span&gt;&lt;span&gt;1110&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200506081353659-1133836146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;那么两个索引的位置都是&lt;/span&gt;14&lt;span&gt;，就会造成分布不均匀了，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;增加了碰撞的几率，减慢了查询的效率，造成空间的浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为&lt;/span&gt;2&lt;span&gt;的幂&lt;/span&gt;-1&lt;span&gt;都是&lt;/span&gt;&lt;span&gt;11111&lt;/span&gt;&lt;span&gt;结尾的，所以碰撞几率小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;判断位置的时候代替取模运算，效率高。&lt;/p&gt;
&lt;h2&gt;18. &lt;strong&gt;linkedhashmap&lt;span&gt;如何保证有序性？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;继承自&lt;/span&gt;hashmap&lt;span&gt;，内部增加了&lt;/span&gt;&lt;span&gt;head tail&lt;/span&gt; &lt;span&gt;和&lt;/span&gt;&lt;span&gt;accessorder&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;19. &lt;strong&gt;Comparable &lt;span&gt;和&lt;/span&gt; &lt;span&gt;Comparator&lt;/span&gt; &lt;span&gt;的区别&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果在定义类时，就实现了&lt;/span&gt;Comparable&lt;span&gt;接口，直接在里面重写&lt;/span&gt;&lt;span&gt;compareTo()&lt;/span&gt;&lt;span&gt;方法，如果没实现，后面在业务开发中需要有比较排序的功能，就再单独写一个类实现&lt;/span&gt;&lt;span&gt;Comparator&lt;/span&gt;&lt;span&gt;接口，在里面重写&lt;/span&gt;&lt;span&gt;compare()&lt;/span&gt;&lt;span&gt;方法，然后这个类需要作为参数传入到工具类&lt;/span&gt;&lt;span&gt;Collections.sort&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Arrays.sort&lt;/span&gt;&lt;span&gt;方法中。&lt;/span&gt;最主要的区别就是一个一开始就实现，一个是后期实现。&lt;/p&gt;
&lt;h2&gt;20. &lt;strong&gt;Array &lt;span&gt;和&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt; &lt;span&gt;有何区别？什么时候更适合用&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Array &lt;span&gt;可以容纳基本类型和对象，而&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt; &lt;span&gt;只能容纳对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Array &lt;span&gt;是指定大小的，而&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt; &lt;span&gt;大小是固定的，可自动扩容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Array &lt;span&gt;没有提供&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt; &lt;span&gt;那么多功能，比如&lt;/span&gt; &lt;span&gt;addAll&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;removeAll&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;iterator&lt;/span&gt; &lt;span&gt;等。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;21. &lt;strong&gt;ArrayList&lt;span&gt;是如何扩容的？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果通过无参构造的话，初始数组容量为&lt;/span&gt; 0 &lt;span&gt;，当真正对数组进行添加时，才真正分配容量。每次按照&lt;/span&gt; &lt;span&gt;1.5&lt;/span&gt; &lt;span&gt;倍（位运算）的比率通过&lt;/span&gt; &lt;span&gt;copeOf&lt;/span&gt; &lt;span&gt;的方式扩容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt; JKD6 &lt;span&gt;中实现是，如果通过无参构造的话，初始数组容量为&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;，每次通过&lt;/span&gt; &lt;span&gt;copeOf&lt;/span&gt; &lt;span&gt;的方式扩容后容量为原来的&lt;/span&gt; &lt;span&gt;1.5&lt;/span&gt; &lt;span&gt;倍。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 May 2020 00:14:00 +0000</pubDate>
<dc:creator>经典鸡翅</dc:creator>
<og:description>1.&amp;#160;List List 是有序的 Collection。Java List 一共三个实现类： 分别是 ArrayList、Vector 和 LinkedList ArrayList Arr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jichi/p/12834238.html</dc:identifier>
</item>
</channel>
</rss>