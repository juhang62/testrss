<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Quartz3.0定时任务学习之异步调度器 - kiba518</title>
<link>http://www.cnblogs.com/kiba/p/12794928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kiba/p/12794928.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Quartz3与Quartz2的主要区别有两点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1，Quartz3将它的资源类库拆的更细了，比如，想使用Quartz3开发，最少要引用Quartz，Quartz.Jobs，Quartz.Plugins这三个类库。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2，Quartz3整体上使用的是异步创建实例，所以我们使用时就必须要async，await的语法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下面我们用Quartz3来做一个任务调度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建调度器管理类&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;首先创建Jops类库，然后在Nuget中搜索Quartz.Plugins；如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/243596/202004/243596-20200428160328332-1674269329.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1587868441211.png&quot;&gt;&lt;img alt=&quot;&quot; data-alt=&quot;1587868441211&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;span class=&quot;md-plain&quot;&gt;因为Quartz.Plugins依赖于Quartz，所以引入Quartz.Plugins就会自动引入Quartz。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;然后我们创建任务调度管理类—ScheduleControler。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class ScheduleControler
​
{
    private static IScheduler scheduler;
    private static Dictionary&amp;lt;IJobDetail, IReadOnlyCollection&amp;lt;ITrigger&amp;gt;&amp;gt; dicJop = new Dictionary&amp;lt;IJobDetail, IReadOnlyCollection&amp;lt;ITrigger&amp;gt;&amp;gt;();
    
    private static int triggerId = 0;
    private static string defaultGroupName = &quot;默认组&quot;;
    /// &amp;lt;summary&amp;gt;
    /// 初始化调度器
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static async Task Init()
    {
        try
        {
            //quartz.config配置文件里的键值对
            //NameValueCollection props = new NameValueCollection
            //{
            //   { &quot;quartz.serializer.type&quot;, &quot;binary&quot; }
            //};
            StdSchedulerFactory factory = new StdSchedulerFactory(); 
            scheduler = await factory.GetScheduler(); 
            await scheduler.Start(); 
        }
        catch (SchedulerException se)
        {
            System.Console.WriteLine(se);
        }
    }
    /// &amp;lt;summary&amp;gt;
    /// 运行调度器任务
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static async Task Run()
    {
        try
        {
            await scheduler.ScheduleJobs(dicJop, true);
​
        }
        catch (SchedulerException se)
        {
            System.Console.WriteLine(se);
        }
    }
    /// &amp;lt;summary&amp;gt;
    /// 关闭调度器
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static async Task Shutdown()
    {
        try
        { 
            await scheduler.Shutdown(); 
​
        }
        catch (SchedulerException se)
        {
            System.Console.WriteLine(se);
        }
    }
    /// &amp;lt;summary&amp;gt;
    /// 添加任务
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;任务类型，继承Ijop&amp;lt;/typeparam&amp;gt;
    /// &amp;lt;param name=&quot;jopName&quot;&amp;gt;任务名&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;Interval&quot;&amp;gt;运行间隔时间/秒**最小为1秒&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;period&quot;&amp;gt;等待启动时间/秒**-1为马上启动&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;repeatTime&quot;&amp;gt;重复次数**-1为永远运行&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;endAt&quot;&amp;gt;在指定时间后结束/秒**0为不指定结束时间，默认值0&amp;lt;/param&amp;gt;
    public static void PushJop&amp;lt;T&amp;gt;(string jopName, int Interval, int period=-1,int repeatTime=-1,int endAt=0)  where T:IJob
        {
            try
            {
                if (Interval &amp;lt;= 0)
                {
                    Interval = 1;
                }
                if (period &amp;lt; -1)
                {
                    period = -1;
                }
                if (repeatTime &amp;lt; -1)
                {
                    repeatTime = -1;
                } 
                if (endAt &amp;lt; 0)
                {
                    endAt = -1;
                }
                IJobDetail job = JobBuilder.Create&amp;lt;T&amp;gt;().WithIdentity(jopName, defaultGroupName).UsingJobData(&quot;Name&quot;, &quot;IJobDetail&quot;).Build();
            
                var triggerBuilder  = TriggerBuilder.Create().WithIdentity($&quot;{jopName}.trigger{triggerId}&quot;, defaultGroupName);
                if (period == -1)
                {
                    triggerBuilder = triggerBuilder.StartNow();
                }
                else
                {
                    DateTimeOffset dateTimeOffset = DateTimeOffset.Now.AddSeconds(period);
                    triggerBuilder = triggerBuilder.StartAt(dateTimeOffset);
                }
                if (endAt &amp;gt; 0)
                {
                    triggerBuilder = triggerBuilder.EndAt(new DateTimeOffset(DateTime.Now.AddSeconds(endAt)));
                }  
​
                if (repeatTime == -1)
                {
                    triggerBuilder = triggerBuilder.WithSimpleSchedule(x =&amp;gt; x.WithIntervalInSeconds(Interval).RepeatForever());  
                }
                else
                {
                    triggerBuilder = triggerBuilder.WithSimpleSchedule(x =&amp;gt; x.WithRepeatCount(Interval).WithRepeatCount(repeatTime));
                }
                ITrigger trigger = triggerBuilder.UsingJobData(&quot;Name&quot;, &quot;ITrigger&quot;)
                     .WithPriority(triggerId)//设置触发器优先级,当有多个触发器在相同时间出发时,优先级最高[数字最大]的优先
                     .Build(); 
​
                dicJop.Add(job, new HashSet&amp;lt;ITrigger&amp;gt;() { trigger }); 
                triggerId++; 
            }
            catch (SchedulerException se)
            {
                System.Console.WriteLine(se);
            }
        }
​
    public static void PushJop&amp;lt;T&amp;gt;(string jopName, string cronExpress) where T : IJob
    {
        try
        { 
            IJobDetail job = JobBuilder.Create&amp;lt;T&amp;gt;().WithIdentity(jopName, defaultGroupName).UsingJobData(&quot;Name&quot;, &quot;IJobDetail&quot;).Build(); 
            ITrigger trigger = TriggerBuilder.Create()
               .WithIdentity($&quot;{jopName}.trigger{triggerId}&quot;, defaultGroupName)
               .WithCronSchedule(cronExpress)
               .ForJob(job)
               .Build(); 
            dicJop.Add(job, new HashSet&amp;lt;ITrigger&amp;gt;() { trigger });
            triggerId++;
        }
        catch (SchedulerException se)
        {
            System.Console.WriteLine(se);
        }
    } 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;可以看到调度器管理类中包含四个主要函数，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;运行调度器任务(Run)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;初始化调度器(Init)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;关闭调度器(Shutdown)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;添加任务(PushJop)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;应用程序通过这四个函数的调用，就可以使用Quartz了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;添加配置文件&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;quartz.config&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;quartz.config是调度器工厂StdSchedulerFactory的配置文件，我们可以在初始化调度器时配置，但显然在配置文件里设置更易于修改。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;quartz.config内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# You can configure your scheduler in either &amp;lt;quartz&amp;gt; configuration section
# or in quartz properties file
# Configuration section has precedence
​
quartz.scheduler.instanceName = QuartzTest
​
# configure thread pool info
quartz.threadPool.type = Quartz.Simpl.SimpleThreadPool, Quartz
quartz.threadPool.threadCount = 10
quartz.threadPool.threadPriority = Normal
​
# job initialization plugin handles our xml reading, without it defaults are used
quartz.plugin.xml.type = Quartz.Plugin.Xml.XMLSchedulingDataProcessorPlugin, Quartz.Plugins
#指定quartz_jobs.xml路径
#quartz.plugin.xml.fileNames = ~/quartz_jobs.xml
​
# export this server to remoting context 使用CrystalQuartz 放开如下注释
quartz.scheduler.exporter.type = Quartz.Simpl.RemotingSchedulerExporter, Quartz
quartz.scheduler.exporter.port = 555
quartz.scheduler.exporter.bindName = QuartzScheduler
quartz.scheduler.exporter.channelType = tcp
quartz.scheduler.exporter.channelName = httpQuartz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;如果在初始化时配置，参考如下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
NameValueCollection props = new NameValueCollection
{
   { &quot;quartz.serializer.type&quot;, &quot;binary&quot; }
};
StdSchedulerFactory factory = new StdSchedulerFactory(props); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;quartz_jobs.xml&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;quartz_jobs.xml是任务配置文件，用于配置任务的。不过本文的调度器管理类已经通过的PushJop函数对任务进行了配置，所以就不需要在quartz_jobs.xml文件中配置了，不过为了测试方便，我们还是添加一个quartz_jobs.xml文件，因为quartz.config文件中指定配置了quartz_jobs.xml，所以没有它会异常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这里我们添加一个空的quartz_jobs.xml文件，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!-- This file contains job definitions in schema version 2.0 format --&amp;gt;
&amp;lt;job-scheduling-data xmlns=&quot;http://quartznet.sourceforge.net/JobSchedulingData&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; version=&quot;2.0&quot;&amp;gt;
  &amp;lt;processing-directives&amp;gt;
    &amp;lt;overwrite-existing-data&amp;gt;true&amp;lt;/overwrite-existing-data&amp;gt;
  &amp;lt;/processing-directives&amp;gt; 
  &amp;lt;schedule&amp;gt; 
  &amp;lt;/schedule&amp;gt;
&amp;lt;/job-scheduling-data&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;创建任务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;创建一个任务类(Jop)用于处理业务操作，任务类需继承IJop接口，代码如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public class HelloJob : IJob
 {
     public async Task Execute(IJobExecutionContext context)
     {
         Task task = new Task(() =&amp;gt; {
             LogicMethod(context);
         });
         task.Start();
         await task;
     }
     public void LogicMethod(IJobExecutionContext context)
     {
         Console.Out.WriteLine($&quot;HelloJob DateTime:{DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;)}  Key:{context.JobDetail.Key} &quot;);
     } 
 }　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试Quartz&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;创建一个新控制台项目—QuartzNetTest，引入Jops类库和Quartz.Plugins。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;然后修改Main函数，配置HelloJob任务每三秒运行一次，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
static void Main(string[] args)
{
    ScheduleControler.Init().GetAwaiter().GetResult();
    ScheduleControler.PushJop&amp;lt;HelloJob&amp;gt;(&quot;HelloWord&quot;, 3);
    ScheduleControler.Run().GetAwaiter().GetResult();
    var info = Console.ReadKey();
    if (info.Key == ConsoleKey.Enter)
    {
        ScheduleControler.Shutdown().GetAwaiter().GetResult();
        Console.WriteLine(&quot;结束&quot;);
    }
    Console.Read();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;运行项目，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/243596/202004/243596-20200428160616578-1369980507.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1587871192741.png&quot;&gt;&lt;img alt=&quot;&quot; data-alt=&quot;1587871192741&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;span class=&quot;md-plain&quot;&gt;Quartz运行成功。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Quartz任务管理器&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;QuartzNet除了定时运行任务，还提供了任务管理器。下面我们一起新建一个Quartz的任务管理。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;创建一个空的Web项目——QuartzNetWebManager。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/243596/202004/243596-20200428160706380-1743774539.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1586854666297.png&quot;&gt;&lt;img alt=&quot;&quot; data-alt=&quot;1586854666297&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;span class=&quot;md-plain&quot;&gt;添加依赖类库&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Nuget搜索CrystalQuartz.Remote安装。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/243596/202004/243596-20200428160726541-1818451234.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1586854065228.png&quot;&gt;&lt;img alt=&quot;&quot; data-alt=&quot;1586854065228&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1586854065228.png&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;再搜索Quartz安装，注意这里安装的Quartz不是Quartz.Plugins。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1586854065228.png&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1586854065228.png&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/243596/202004/243596-20200428160745474-921732794.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1586854922070.png&quot;&gt;&lt;img alt=&quot;&quot; data-alt=&quot;1586854922070&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1586854922070.png&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这样Quartz的任务管理就创建完成了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;然后我们打开WebConfig，可以看到configuration下多了一个crystalQuartz节点，webServer下多了一个handlers，阅读配置文件，发现Quartz的任务管理器指定了网页CrystalQuartzPanel.axd为访问地址，。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;WebConfig如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;crystalQuartz&amp;gt;
    &amp;lt;provider&amp;gt;
      &amp;lt;add property=&quot;Type&quot; value=&quot;CrystalQuartz.Core.SchedulerProviders.RemoteSchedulerProvider, CrystalQuartz.Core&quot; /&amp;gt;
      &amp;lt;!-- Edit scheduler host value below =================================== --&amp;gt;
      &amp;lt;add property=&quot;SchedulerHost&quot; value=&quot;tcp://localhost:555/QuartzScheduler&quot; /&amp;gt;
      &amp;lt;!--                                 =================================== --&amp;gt;
    &amp;lt;/provider&amp;gt;
&amp;lt;/crystalQuartz&amp;gt;
&amp;lt;system.webServer&amp;gt;
    &amp;lt;handlers&amp;gt;
      &amp;lt;add name=&quot;CrystalQuartzPanel&quot; verb=&quot;*&quot; path=&quot;CrystalQuartzPanel.axd&quot; type=&quot;CrystalQuartz.Web.PagesHandler, CrystalQuartz.Web&quot; /&amp;gt;
    &amp;lt;/handlers&amp;gt;
  &amp;lt;/system.webServer&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;访问网址&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://localhost:44302/CrystalQuartzPanel.axd&quot;&gt;https://localhost:44302/CrystalQuartzPanel.axd&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;，管理界面如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/243596/202004/243596-20200428160849789-831506522.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;D:%5CGitHub%5CTemp%5CQuartzNetTest%5C%E8%AF%B4%E6%98%8E.assets%5C1587872025929.png&quot;&gt;&lt;img alt=&quot;&quot; data-alt=&quot;1587872025929&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;span class=&quot;md-plain&quot;&gt;可以看到管理器中除了显示当前运行的任务，还提供删除任务，马上执行等等功能；非常方便。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当然，Quartz还有很多功能，我们可以去官网学习。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;QuartzNet官网：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.quartz-scheduler.net/&quot;&gt;https://www.quartz-scheduler.net/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;代码已经传到Github上了，欢迎大家下载。&lt;/p&gt;
&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/kiba518/QuartzTest&quot;&gt;https://github.com/kiba518/QuartzTest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;注：此文章为原创，任何形式的转载都请联系作者获得授权并注明出处！&lt;br/&gt;若您觉得这篇文章还不错，请点击下方的&lt;span&gt;【&lt;strong&gt;推荐】&lt;/strong&gt;&lt;/span&gt;，非常感谢！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kiba/p/12794928.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/kiba/p/12794928.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201909/243596-20190904083750507-629449790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 May 2020 00:42:00 +0000</pubDate>
<dc:creator>kiba518</dc:creator>
<og:description>前言 Quartz3与Quartz2的主要区别有两点： 1，Quartz3将它的资源类库拆的更细了，比如，想使用Quartz3开发，最少要引用Quartz，Quartz.Jobs，Quartz.Plu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kiba/p/12794928.html</dc:identifier>
</item>
<item>
<title>Python一切皆是对象，但这和内存管理有什么关系？ - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12928206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12928206.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;Python的第15篇&lt;/strong&gt;文章，我们来聊聊Python中内存管理机制，以及循环引用的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Python的内存管理机制&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于工程师而言，&lt;strong&gt;内存管理机制非常重要&lt;/strong&gt;，是绕不过去的一环。如果你是Java工程师，面试的时候一定会问JVM。C++工程师也一定会问内存泄漏，同样我们想要深入学习Python，内存管理机制也是绕不过去的一环。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过好在Python的内存管理机制相对来说比较简单，我们也不用特别深入其中的细节，简单做个了解即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python内存管理机制的核心就是引用计数，在Python当中一切都是对象，对象通过引用来使用。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/21/17234a52200d6099?w=630&amp;amp;h=296&amp;amp;f=jpeg&amp;amp;s=30925&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到的是变量名，但是变量名指向了内存当中的一块对象。这种关系在Python当中称为&lt;strong&gt;引用&lt;/strong&gt;，我们通过引用来操作对象。所以根据这点，引用计数很好理解，也就是说我们会对每一个对象进行统计所有指向它的指针的数量。如果一个对象引用计数为0，那么说明它没有任何引用指向它，也就是说它已经没有在使用了，这个时候，Python就会将这块内存收回。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说引用计数原理就是这些，但我们稍微深入一点，来简单看看哪些场景会引起对象引用的变化。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数的变化显然只有两种，一种是增加，一种是减少，这两种场景都只有4种情况。我们先来看下增加的情况：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;首先是初始化，最简单的就是我们用&lt;strong&gt;赋值操作&lt;/strong&gt;给一个变量赋值。举个例子：&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;n = &lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是最简单的初始化操作，虽然123在我们来看是一个常数，但是在Python底层同样被认为是一个&lt;strong&gt;常数对象&lt;/strong&gt;。n是它的一个引用。&lt;/p&gt;
&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;第二种情况是引用的传递，最简单的就是我们将一个变量的值赋值给了另外一个变量。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;m = n
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们将n赋值给m，它的本质是我们创建了一个新的引用，指向了同样一块内存。如果我们用id操作去查看m和n的id，会发现它们的id是一样的。也就是说它们并不是存储了两份相同的值，而是指向了同一份值。&lt;strong&gt;并不是有两个叫做王小二的人，而是王小二有两个不同的账号&lt;/strong&gt;。&lt;/p&gt;
&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;第三种情况是作为元素被存储进了容器当中，比如被存储进了list当中。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;a = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们用到了一个容器，但是容器并不会拷贝一份这些对象，还是只是&lt;strong&gt;存储这些对象的引用&lt;/strong&gt;。&lt;/p&gt;
&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;最后一种情况就是作为参数传给函数，在Python当中，所有的传参都是引用传递。这也是为什么，我们经常看到有人会这样写代码的原因：&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a)&lt;/span&gt;:&lt;/span&gt;
  a.append(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)
  
a = []
test(a)
print(a)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们根据上面列举的这四种引用计数增加的情况，不难推导出引用减少的情况， 其实基本上是&lt;strong&gt;对称的操作&lt;/strong&gt;。&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;和初始化对应的操作是&lt;strong&gt;销毁&lt;/strong&gt;，比如我们创建的对象被del操作给销毁了，那么同样引用计数会-1&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt; n
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;和赋值给其他变量名的操作相反的操作是&lt;strong&gt;覆盖&lt;/strong&gt;，比如之前我们的n=123，也就是n这个变量指向123，现在我们将n赋值成其他值，那么123这个对象的引用计数同样会减少。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;n = &lt;span class=&quot;hljs-number&quot;&gt;124&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;既然元素存储在容器当中会带来引用计数，那么同样元素&lt;strong&gt;从容器当中移除&lt;/strong&gt;也会减少引用计数。这个也很好理解，最简单的就是list调用remove方法移除一个元素：&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;a.remove(&lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;最后一个对应的就是作用域，也就是当变量&lt;strong&gt;离开了作用域&lt;/strong&gt;，那么它对应的内存块的引用计数同样会减少。比如我们函数调用结束，那么作为参数的这些变量对应的引用计数都会减1。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个对象的引用计数减到0，也就是没有引用再指向它的时候，那么当Python进行gc的时候，这块内存就会被释放，也就是这个对象会被清除，腾出空间来。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意一下，引用计数减到0与内存回收之间&lt;strong&gt;并不是立即发生的&lt;/strong&gt;，而是有一段间隔的。根据Python的机制，内存回收只会在特定条件下执行。在占用内存比较小还有很多富裕的情况下，往往是不会执行内存回收的。因为Python在执行gc（garbage collection）的时候也会stop the world，也就是暂停其他所有的任务，所以这是影响性能的一件事情，只会在有必要的时候执行。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们费这么大劲来介绍Python中的内存机制，除了向大家科普一下这一块内容之外，更重要的一点是为了引出我们开发的时候经常遇见的一种情况——&lt;strong&gt;循环引用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;循环引用&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果熟悉了Python的引用，来理解循环引用是非常容易的。说白了也很简单，就是你的一个变量引用我，我的一个变量引用你。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来写一段简单的代码，来看看循环引用：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;


&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;'__main__'&lt;/span&gt;:
    a = Test()
    b = Test()
    a.t = b
    b.t = a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你打个断点来看的话，会看到a和b之间的循环引用：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/21/17234a5254364876?w=636&amp;amp;h=200&amp;amp;f=jpeg&amp;amp;s=22177&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是&lt;strong&gt;无限展开&lt;/strong&gt;的，因为这是一个无限循环。无限循环并不会导致程序崩溃， 也不会带来太大的问题，它的问题只有一个，就是根据前面介绍的引用计数法，a和b的引用永远不可能为0。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说根据引用计数的原则，&lt;strong&gt;这两个变量永远不会被回收&lt;/strong&gt;，这显然是不合理的。虽然Python当中专门建立了机制来解决引用循环的问题，但是我们并不知道它什么时候会被触发。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题在Python当中非常普遍，尤其在我们实现一些数据结构的时候。举个最简单的例子就是树中的节点，就是引用循环的。因为父节点会存储所有的孩子，往往孩子节点也会存储父节点的信息。那么这就构成了引用循环。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt;:&lt;/span&gt;
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, val, father)&lt;/span&gt;:&lt;/span&gt;
    self.val = val
    self.father = father
    self.childs = []
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;弱引用&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，Python中提供了一个叫做弱引用的概念。弱引用本质也是一种引用，但是它不会增加对象的引用计数。也就是说它不能保证它引用的对象一定不会被销毁，只要没有销毁，弱引用就可以返回预期的结果。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;弱引用不用我们自己开发，这是Python当中集成的一个现成的模块&lt;strong&gt;weakref&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个模块当中的方法很多，用法也很多，但是我们基本上用不到，一般来说最常用的就是ref方法。通过weakref库中的ref方法，可以返回对象的一个弱引用。我们还是来看个例子：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; weakref


&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, name)&lt;/span&gt;:&lt;/span&gt;
        self.name = name

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.name


&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;'__main__'&lt;/span&gt;:
    a = Test(&lt;span class=&quot;hljs-string&quot;&gt;'a'&lt;/span&gt;)
    b = Test(&lt;span class=&quot;hljs-string&quot;&gt;'b'&lt;/span&gt;)
    a.t = weakref.ref(b)
    b.t = weakref.ref(a)

    print(a.t())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实还是之前的代码，只是做了一点简单的改动。一个是我们给Test加上了name这个属性，以及str方法。另一个是我们把直接赋值改成了使用weakref。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一次我们再打断点进来看的话，就&lt;strong&gt;看不到无限循环的情况&lt;/strong&gt;了：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/21/17234a5254ef3408?w=683&amp;amp;h=141&amp;amp;f=jpeg&amp;amp;s=10528&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ref返回的是一个获取引用对象的方法，而不是对象本身。所以我们想要获取这个对象的话，需要再把它当成函数调用一下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这样很麻烦，我们还有更好的办法，就是使用&lt;strong&gt;property注解&lt;/strong&gt;。通过property注解，我们可以把weakref封装掉，这样在使用的时候就没有感知了。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; weakref


&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, name)&lt;/span&gt;:&lt;/span&gt;
        self.name = name

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.name

&lt;span class=&quot;hljs-meta&quot;&gt;    @property&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; self._node &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; self._node()

&lt;span class=&quot;hljs-meta&quot;&gt;    @node.setter&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, node)&lt;/span&gt;:&lt;/span&gt;
        self._node = weakref.ref(node)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用和循环引用都是基于Python本身的机制，如果对这块机制不了解，很容易采坑。因为可能会出现逻辑是对的，但是有一些意想不到的bug的情况。这种时候，往往很难通过review代码或者是测试发现，这也是我们学习的瓶颈所在。很容易发现代码已经写得很熟练了，但是一些进阶的代码还是看不懂或者是写不出来，本质上就是因为缺少了对于底层的了解和认知。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;循环引用的问题在我们开发代码的时候还蛮常见的，尤其是涉及到&lt;strong&gt;树和图的数据结构&lt;/strong&gt;的时候。由于循环引用的关系，很有可能出现被删除的树仍然占用着空间，内存不足的情况发生。这个时候使用weakref就很有必要了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就到这里，原创不易，&lt;strong&gt;扫码关注&lt;/strong&gt;我，获取更多精彩文章。&lt;/p&gt;
</description>
<pubDate>Thu, 21 May 2020 00:34:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是Python的第15篇文章，我们来聊聊Python中内存管理机制，以及循环引用的问题。 Python的内存管理机制 对于工程师而言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12928206.html</dc:identifier>
</item>
<item>
<title>《机器学习_07_02_svm_软间隔支持向量机》 - 努力的番茄</title>
<link>http://www.cnblogs.com/zhulei227/p/12928195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhulei227/p/12928195.html</guid>
<description>&lt;h3 id=&quot;一简介&quot;&gt;一.简介&lt;/h3&gt;
&lt;p&gt;上一节介绍了硬间隔支持向量机，它可以在严格线性可分的数据集上工作的很好，但对于非严格线性可分的情况往往就表现很差了，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt
import copy
import random
import os
os.chdir('../')
from ml_models import utils
from ml_models.svm import HardMarginSVM
%matplotlib inline
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*** PS:请多试几次，生成含噪声点的数据***&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sklearn.datasets import make_classification
data, target = make_classification(n_samples=100, n_features=2, n_classes=2, n_informative=1, n_redundant=0,
                                   n_repeated=0, n_clusters_per_class=1, class_sep=2.0)
plt.scatter(data[:,0],data[:,1],c=target)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;matplotlib.collections.PathCollection at 0x202a6f55a58&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2037062/202005/2037062-20200521082358763-529386390.png&quot; alt=&quot;png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#训练
svm = HardMarginSVM()
svm.fit(data, target)
utils.plot_decision_function(data, target, svm, svm.support_vectors)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2037062/202005/2037062-20200521082417662-1806854147.png&quot; alt=&quot;png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那怕仅含有一个异常点，对硬间隔支持向量机的训练影响就很大，我们希望它能具有一定的包容能力，容忍哪些放错的点，但又不能容忍过度，我们可以引入变量&lt;span class=&quot;math inline&quot;&gt;\(\xi\)&lt;/span&gt;和一个超参&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt;来进行控制，原始的优化问题更新为如下：&lt;/p&gt;
&lt;p&gt;\[\min_{w,b,\xi} \frac{1}{2}w^Tw + C\sum_{i=1}^N\xi_i\\ s.t.y_i(w^Tx_i+b)\geq 1-\xi_i,i=1,2,...,N\\ \xi_i\geq0,i=1,2,...,N \]&lt;/p&gt;
&lt;p&gt;这里&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt;若越大，包容能力就越小，当取值很大时，就等价于硬间隔支持向量机，而&lt;span class=&quot;math inline&quot;&gt;\(\xi\)&lt;/span&gt;使得支持向量的间隔可以调整，不必像硬间隔那样，严格等于1&lt;/p&gt;
&lt;h4 id=&quot;lagrange函数&quot;&gt;Lagrange函数&lt;/h4&gt;
&lt;p&gt;关于原问题的Lagrange函数：&lt;/p&gt;
&lt;p&gt;\[L(w,b,\xi,\alpha,\mu)=\frac{1}{2}w^Tw+C\sum_{i=1}^N\xi_i+\sum_{i=1}^N\alpha_i(1-\xi_i-y_i(w^Tx_i+b))-\sum_{i=1}^N\mu_i\xi_i\\ s.t.\mu_i\geq 0,\alpha_i\geq0,i=1,2,...,N \]&lt;/p&gt;
&lt;h3 id=&quot;二对偶问题&quot;&gt;二.对偶问题&lt;/h3&gt;
&lt;p&gt;对偶问题的求解过程我就省略了，与硬间隔类似，我这里就直接写最终结果：&lt;/p&gt;
&lt;p&gt;\[\min_{\alpha} \frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum_{i=1}^N\alpha_i\\ s.t.\sum_{i=1}^N\alpha_iy_i=0,\\ 0\leq\alpha_i\leq C,i=1,2,...,N \]&lt;/p&gt;
&lt;p&gt;可以发现与硬间隔的不同是&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;加了一个上界的约束&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;三kkt条件&quot;&gt;三.KKT条件&lt;/h3&gt;
&lt;p&gt;这里就直接写KKT条件看原优化变量与拉格朗日乘子之间的关系：&lt;/p&gt;
&lt;p&gt;\[\frac{\partial L}{\partial w}=0\Rightarrow w^*=\sum_{i=1}^N\alpha_i^*y_ix_i(关系1)\\ \frac{\partial L}{\partial b}=0\Rightarrow \alpha_i^*y_i=0(关系2)\\ \frac{\partial L}{\partial \xi}=0\Rightarrow C-\alpha_i^*-\mu_i^*=0(关系3)\\ \alpha_i^*(1-\xi_i^*-y_i({w^*}^Tx_i+b^*))=0(关系4)\\ \mu_i^*\xi_i^*=0(关系5)\\ y_i({w^*}^Tx_i+b^*)-1-\xi_i^*\geq0(关系6)\\ \xi_i^*\geq0(关系7)\\ \alpha_i^*\geq0(关系8)\\ \mu_i^*\geq0(关系9)\\ \]&lt;/p&gt;
&lt;h3 id=&quot;四的求解&quot;&gt;四.&lt;span class=&quot;math inline&quot;&gt;\(w^*,b^*\)&lt;/span&gt;的求解&lt;/h3&gt;
&lt;p&gt;由KKT条件中的关系1，我们可以知道：&lt;/p&gt;
&lt;p&gt;\[w^*=\sum_{i=1}^N\alpha_i^*y_ix_i \]&lt;/p&gt;
&lt;p&gt;对于&lt;span class=&quot;math inline&quot;&gt;\(b^*\)&lt;/span&gt;的求解，我们可以取某点，其&lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;\alpha_k^*&amp;lt;C\)&lt;/span&gt;，由关系3,4,5可以推得到：&lt;span class=&quot;math inline&quot;&gt;\({w^*}^Tx_k+b^*=y_k\)&lt;/span&gt;，所以：&lt;/p&gt;
&lt;p&gt;\[b^*=y_k-{w^*}^Tx_k \]&lt;/p&gt;
&lt;h3 id=&quot;五smo求&quot;&gt;五.SMO求&lt;span class=&quot;math inline&quot;&gt;\(\alpha^*\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;好了，最终模型得求解落到了对&lt;span class=&quot;math inline&quot;&gt;\(\alpha^*\)&lt;/span&gt;得求解上，求解过程与硬间隔一样，无非就是就是对&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;多加了一个约束：&lt;span class=&quot;math inline&quot;&gt;\(\alpha_i^*&amp;lt;=C\)&lt;/span&gt;，具体而言需要对&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2^{new}\)&lt;/span&gt;的求解进行更新：&lt;/p&gt;
&lt;p&gt;当&lt;span class=&quot;math inline&quot;&gt;\(y_1\neq y_2\)&lt;/span&gt;时：&lt;/p&gt;
&lt;p&gt;\[L=max(0,\alpha_2^{old}-\alpha_1^{old})\\ H=min(C,C+\alpha_2^{old}-\alpha_1^{old}) \]&lt;/p&gt;
&lt;p&gt;当&lt;span class=&quot;math inline&quot;&gt;\(y_1=y_2\)&lt;/span&gt;时：&lt;/p&gt;
&lt;p&gt;\[L=max(0,\alpha_2^{old}+\alpha_1^{old}-C)\\ H=min(C,\alpha_2^{old}+\alpha_1^{old}) \]&lt;/p&gt;
&lt;p&gt;更新公式：&lt;/p&gt;
&lt;p&gt;\[\alpha_2^{new}=\left\{\begin{matrix} H &amp;amp; \alpha_2^{unc}&amp;gt; H\\ \alpha_2^{unc} &amp;amp; L \leq \alpha_2^{unc} \leq H\\ L &amp;amp; \alpha_2^{unc}&amp;lt;L \end{matrix}\right. \]&lt;/p&gt;
&lt;h3 id=&quot;六代码实现&quot;&gt;六.代码实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&quot;&quot;&quot;
软间隔支持向量机的smo实现，放到ml_models.svm模块中
&quot;&quot;&quot;
class SoftMarginSVM(object):
    def __init__(self, epochs=100, C=1.0):
        self.w = None
        self.b = None
        self.alpha = None
        self.E = None
        self.epochs = epochs
        self.C = C
        # 记录支持向量
        self.support_vectors = None

    def init_params(self, X, y):
        &quot;&quot;&quot;
        :param X: (n_samples,n_features)
        :param y: (n_samples,) y_i\in\{0,1\}
        :return:
        &quot;&quot;&quot;
        n_samples, n_features = X.shape
        self.w = np.zeros(n_features)
        self.b = .0
        self.alpha = np.zeros(n_samples)
        self.E = np.zeros(n_samples)
        # 初始化E
        for i in range(0, n_samples):
            self.E[i] = np.dot(self.w, X[i, :]) + self.b - y[i]

    def _select_j(self, best_i):
        &quot;&quot;&quot;
        选择j
        :param best_i:
        :return:
        &quot;&quot;&quot;
        valid_j_list = [i for i in range(0, len(self.alpha)) if self.alpha[i] &amp;gt; 0 and i != best_i]
        best_j = -1
        # 优先选择使得|E_i-E_j|最大的j
        if len(valid_j_list) &amp;gt; 0:
            max_e = 0
            for j in valid_j_list:
                current_e = np.abs(self.E[best_i] - self.E[j])
                if current_e &amp;gt; max_e:
                    best_j = j
                    max_e = current_e
        else:
            # 随机选择
            l = list(range(len(self.alpha)))
            seq = l[: best_i] + l[best_i + 1:]
            best_j = random.choice(seq)
        return best_j

    def _meet_kkt(self, w, b, x_i, y_i, alpha_i):
        &quot;&quot;&quot;
        判断是否满足KKT条件

        :param w:
        :param b:
        :param x_i:
        :param y_i:
        :return:
        &quot;&quot;&quot;
        if alpha_i &amp;lt; self.C:
            return y_i * (np.dot(w, x_i) + b) &amp;gt;= 1
        else:
            return y_i * (np.dot(w, x_i) + b) &amp;lt;= 1

    def fit(self, X, y2, show_train_process=False):
        &quot;&quot;&quot;

        :param X:
        :param y2:
        :param show_train_process: 显示训练过程
        :return:
        &quot;&quot;&quot;
        y = copy.deepcopy(y2)
        y[y == 0] = -1
        # 初始化参数
        self.init_params(X, y)
        for _ in range(0, self.epochs):
            if_all_match_kkt = True
            for i in range(0, len(self.alpha)):
                x_i = X[i, :]
                y_i = y[i]
                alpha_i_old = self.alpha[i]
                E_i_old = self.E[i]
                # 外层循环：选择违反KKT条件的点i
                if not self._meet_kkt(self.w, self.b, x_i, y_i, alpha_i_old):
                    if_all_match_kkt = False
                    # 内层循环，选择使|Ei-Ej|最大的点j
                    best_j = self._select_j(i)

                    alpha_j_old = self.alpha[best_j]
                    x_j = X[best_j, :]
                    y_j = y[best_j]
                    E_j_old = self.E[best_j]

                    # 进行更新
                    # 1.首先获取无裁剪的最优alpha_2
                    eta = np.dot(x_i - x_j, x_i - x_j)
                    # 如果x_i和x_j很接近，则跳过
                    if eta &amp;lt; 1e-3:
                        continue
                    alpha_j_unc = alpha_j_old + y_j * (E_i_old - E_j_old) / eta
                    # 2.裁剪并得到new alpha_2
                    if y_i == y_j:
                        L = max(0., alpha_i_old + alpha_j_old - self.C)
                        H = min(self.C, alpha_i_old + alpha_j_old)
                    else:
                        L = max(0, alpha_j_old - alpha_i_old)
                        H = min(self.C, self.C + alpha_j_old - alpha_i_old)

                    if alpha_j_unc &amp;lt; L:
                        alpha_j_new = L
                    elif alpha_j_unc &amp;gt; H:
                        alpha_j_new = H
                    else:
                        alpha_j_new = alpha_j_unc

                    # 如果变化不够大则跳过
                    if np.abs(alpha_j_new - alpha_j_old) &amp;lt; 1e-5:
                        continue
                    # 3.得到alpha_1_new
                    alpha_i_new = alpha_i_old + y_i * y_j * (alpha_j_old - alpha_j_new)
                    # 4.更新w
                    self.w = self.w + (alpha_i_new - alpha_i_old) * y_i * x_i + (alpha_j_new - alpha_j_old) * y_j * x_j
                    # 5.更新alpha_1,alpha_2
                    self.alpha[i] = alpha_i_new
                    self.alpha[best_j] = alpha_j_new
                    # 6.更新b
                    b_i_new = y_i - np.dot(self.w, x_i)
                    b_j_new = y_j - np.dot(self.w, x_j)
                    if self.C &amp;gt; alpha_i_new &amp;gt; 0:
                        self.b = b_i_new
                    elif self.C &amp;gt; alpha_j_new &amp;gt; 0:
                        self.b = b_j_new
                    else:
                        self.b = (b_i_new + b_j_new) / 2.0
                    # 7.更新E
                    for k in range(0, len(self.E)):
                        self.E[k] = np.dot(self.w, X[k, :]) + self.b - y[k]
                    # 显示训练过程
                    if show_train_process is True:
                        utils.plot_decision_function(X, y2, self, [i, best_j])
                        utils.plt.pause(0.1)
                        utils.plt.clf()

            # 如果所有的点都满足KKT条件，则中止
            if if_all_match_kkt is True:
                break
        # 计算支持向量
        self.support_vectors = np.where(self.alpha &amp;gt; 1e-3)[0]
        # 显示最终结果
        if show_train_process is True:
            utils.plot_decision_function(X, y2, self, self.support_vectors)
            utils.plt.show()

    def get_params(self):
        &quot;&quot;&quot;
        输出原始的系数
        :return: w
        &quot;&quot;&quot;

        return self.w, self.b

    def predict_proba(self, x):
        &quot;&quot;&quot;
        :param x:ndarray格式数据: m x n
        :return: m x 1
        &quot;&quot;&quot;
        return utils.sigmoid(x.dot(self.w) + self.b)

    def predict(self, x):
        &quot;&quot;&quot;
        :param x:ndarray格式数据: m x n
        :return: m x 1
        &quot;&quot;&quot;
        proba = self.predict_proba(x)
        return (proba &amp;gt;= 0.5).astype(int)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;svm = SoftMarginSVM(C=3.0)
svm.fit(data, target)
utils.plot_decision_function(data, target, svm, svm.support_vectors)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2037062/202005/2037062-20200521082449362-2900969.png&quot; alt=&quot;png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过控制&lt;code&gt;C&lt;/code&gt;可以调节宽容度，设置一个大的&lt;code&gt;C&lt;/code&gt;可以取得和硬间隔一样的效果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;svm = SoftMarginSVM(C=1000000)
svm.fit(data, target)
utils.plot_decision_function(data, target, svm, svm.support_vectors)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2037062/202005/2037062-20200521082507013-1173264621.png&quot; alt=&quot;png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有时，太过宽容也不一定好&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;svm = SoftMarginSVM(C=0.01)
svm.fit(data, target)
utils.plot_decision_function(data, target, svm, svm.support_vectors)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2037062/202005/2037062-20200521082518195-716088671.png&quot; alt=&quot;png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;七支持向量&quot;&gt;七.支持向量&lt;/h3&gt;
&lt;p&gt;软间隔支持向量机的支持向量复杂一些，因为对于&lt;span class=&quot;math inline&quot;&gt;\(\alpha&amp;gt;0\)&lt;/span&gt;有许多种情况，如下图所示，大概可以分为4类：&lt;/p&gt;
&lt;p&gt;（1）&lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;\alpha_i&amp;lt;C,\xi_i=0\)&lt;/span&gt;：位于间隔边界上；&lt;br/&gt;（2）&lt;span class=&quot;math inline&quot;&gt;\(\alpha_i=C,0&amp;lt;\xi_i&amp;lt;1\)&lt;/span&gt;：分类正确，位于间隔边界与分离超平面之间；&lt;br/&gt;（3）&lt;span class=&quot;math inline&quot;&gt;\(\alpha_i=C,\xi_i=1\)&lt;/span&gt;：位于分离超平面上；&lt;br/&gt;（4）&lt;span class=&quot;math inline&quot;&gt;\(\alpha_i=C,\xi_i&amp;gt;1\)&lt;/span&gt;：位于错误分类的一侧&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2037062/202005/2037062-20200521082553576-2102701383.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 21 May 2020 00:28:00 +0000</pubDate>
<dc:creator>努力的番茄</dc:creator>
<og:description>一.简介 上一节介绍了硬间隔支持向量机，它可以在严格线性可分的数据集上工作的很好，但对于非严格线性可分的情况往往就表现很差了，比如： PS:请多试几次，生成含噪声点的数据 那怕仅含有一个异常点，对硬间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhulei227/p/12928195.html</dc:identifier>
</item>
<item>
<title>[不得不知道系列]微服务面试你不得不知道的基础知识   - 分布式编程</title>
<link>http://www.cnblogs.com/daichangya/p/12928158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daichangya/p/12928158.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-memory-interview-1&quot;&gt;Java内存管理面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-basic-interview-1&quot;&gt;Java基础面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-basic-interview-2&quot;&gt;Java基础面试指南二&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-basic-interview-3&quot;&gt;Java基础面试指南三&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-basic-interview-4&quot;&gt;Java基础面试指南四&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-thread-interview-1&quot;&gt;Java线程面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-thread-interview-2&quot;&gt;Java线程面试指南二&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/redis-interview-1&quot;&gt;Redis面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/kafka-interview-1&quot;&gt;Kafka面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/spring-interview-1&quot;&gt;Spring面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/springboot-interview-1&quot;&gt;SpringBoot面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/microservice-interview-1&quot;&gt;微服务面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;1-什么是微服务为什么有人要考虑实现它&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-1317&quot;&gt;1. 什么是微服务,为什么有人要考虑实现它.&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;微服务是一种架构样式,其结构和应用程序是围绕业务功能组织的松散耦合,可独立维护,可测试和可部署的服务的集合.&lt;/p&gt;
&lt;p&gt;如果您以业务为中心,并且想要在没有技术限制的情况下有效地解决用例或问题,想要无限扩展独立的服务,易于维护和管理以及可独立测试的高可用性无状态服务,那么我们将继续实施微服务架构.&lt;/p&gt;
&lt;h4 id=&quot;2-什么时候应该考虑微服务类型的架构&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-1318&quot;&gt;2. 什么时候应该考虑微服务类型的架构?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;**有两种情况. **&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果您已经拥有一个整体应用程序,并且该应用程序的增长到一定程度,在扩展方面存在问题,或者我们无法跨不同项目/平台重新利用组件/模块/服务,则需要这样做. 同时实现新功能是痛苦的,而且更容易出错,并且很难进一步扩展.&lt;/li&gt;
&lt;li&gt;对于尚未开始实施的新应用程序,我们可以考虑一个有效实施的业务案例,该业务案例将来可以轻松维护,测试和扩展,并且可以同时用于其他项目/产品/平台. .&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;3-您将如何测试基于微服务的架构&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-1324&quot;&gt;3. 您将如何测试基于微服务的架构?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;应该进行单元测试和集成测试,以测试微服务的所有功能. 还应该进行基于组件的测试.&lt;/p&gt;
&lt;p&gt;人们应该通过合同测试来断言客户的期望没有打破. 但是,微服务的端到端测试应该仅测试关键流程,因为这些流程很耗时. 测试可以从两个方面进行,消费者驱动的合同测试和消费者方的合同测试.&lt;/p&gt;
&lt;p&gt;您还可以利用命令查询职责隔离来查询多个数据库并获得持久数据的组合视图.&lt;/p&gt;
&lt;h4 id=&quot;4-什么是服务发现它有什么帮助&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-1331&quot;&gt;4. 什么是服务发现?它有什么帮助?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在将docker映像动态部署在任何计算机或IP +端口组合上的云环境中,相关服务在运行时很难更新. 仅出于此目的而创建服务发现.&lt;/p&gt;
&lt;p&gt;服务发现是在微服务架构下运行的服务之一,它注册在服务网格下运行的所有服务的条目. 所有操作都可以通过REST API获得. 因此,每当服务启动并运行时,各个服务便会向服务发现服务进行注册,并且服务发现服务会保持心跳,以确保这些服务处于活动状态. 这也用于监视服务的目的. 服务发现还有助于在以公平方式部署的服务之间分配请求.&lt;/p&gt;
&lt;h4 id=&quot;5什么是客户端和服务器端服务发现&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-1332&quot;&gt;5,什么是客户端和服务器端服务发现?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在这种体系结构模式中,客户端不是连接到负载平衡器,而是直接连接到服务注册表并尝试从中获取数据或服务.&lt;/p&gt;
&lt;p&gt;一旦获得所有数据,它就会自行进行负载平衡,并直接与需要与之通信的服务联系.&lt;/p&gt;
&lt;p&gt;在存在多个代理层并且由于多层通信而发生延迟的情况下,这可能会有好处.&lt;/p&gt;
&lt;p&gt;在服务器端发现中,代理层或API网关稍后会尝试连接到服务注册表,然后再调用适当的服务. 客户端在此处连接到该代理层或API网关层.&lt;/p&gt;
&lt;h4 id=&quot;6-说明如何扩展基于微服务的系统&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-1334&quot;&gt;6. 说明如何扩展基于微服务的系统?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;假设大多数提供商都使用微服务架构,&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以通过启动更多容器来增加服务实例的数量来扩展系统.&lt;/li&gt;
&lt;li&gt;也可以将其应用于微服务层的缓存,因为微服务将是事实的唯一来源,因此缓存的失效可以非常容易地实现,因此可以轻松管理.&lt;/li&gt;
&lt;li&gt;也可以在API网关层引入缓存,在其中可以定义缓存规则,例如何时使缓存无效.&lt;/li&gt;
&lt;li&gt;当需求较少时,也可以关闭一些容器. 也就是说,按比例缩小.&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;7-定义微服务架构&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3580&quot;&gt;7. 定义微服务架构?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;微服务架构是一种开发由许多小型自治服务组成的可伸缩,分布式和高度自动化系统的样式. 它不是一项技术,而是SOA衍生出的一种新趋势.&lt;/p&gt;
&lt;p&gt;没有单一定义可以完全描述术语“微服务”. 一些著名的作者试图通过以下方式对其进行定义:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;微服务是可以协同工作的小型自治服务.&lt;/li&gt;
&lt;li&gt;带有边界上下文的松散耦合的面向服务的体系结构.&lt;/li&gt;
&lt;li&gt;微服务架构是在架构级别应用单责任原则的自然结果.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://www.images.mdan.top/1563516283327-Image-4_1589847729213.jpg&quot; alt=&quot;微服务架构&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;8-微服务和soa之间的区别&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3581&quot;&gt;8. 微服务和SOA之间的区别&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;_微服务是SOA的延续. _&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SOA由于其分布式体系结构方法而开始获得发展,并在2006年左右出现,以解决大型单片应用程序的问题.&lt;/p&gt;
&lt;p&gt;这些架构(SOA和微服务)都具有一个共同点,即它们都是分布式架构,并且都具有很高的可伸缩性. 在这两种服务中,服务组件都是通过远程访问协议(RMI,REST,SOAP,AMQP,JMS等)进行远程访问的. 两者都是模块化的,通过设计可以松散地耦合在一起,并具有很高的可扩展性. 在轻量级容器,Docker,编排框架(Kubernetes,Mesos)出现之后,微服务在2000年底开始引起关注. 微服务在概念上与SOA有很大的不同-&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SOA使用企业服务总线进行通信,而微服务使用REST或其他不太复杂的消息传递系统(AMQP等). 同样,微服务遵循“智能端点和哑点”,这意味着当微服务需要另一个作为依赖时,它应直接使用它,而无需任何路由逻辑/组件来处理管道.&lt;/li&gt;
&lt;li&gt;在微服务中,服务部署和管理应该是完全自动化的,而SOA服务通常是在部署整体中实现的.&lt;/li&gt;
&lt;li&gt;通常,微服务比SOA趋向要小得多. 这里我们不在这里讨论代码库,因为很少有语言比其他语言更冗长. 我们正在谈论服务本身的范围(问题域). 微服务通常以更好的方式做一件事.&lt;/li&gt;
&lt;li&gt;微服务应拥有自己的数据,而SOA可以共享一个公共数据库. 因此,一个微服务不应允许另一个微服务直接更改/读取其数据.&lt;/li&gt;
&lt;li&gt;经典SOA更加受平台驱动,而在微服务方面,我们具有很多技术独立性. 每个微服务都可以根据其自身的功能要求拥有自己的技术堆栈. 因此,微服务在各个维度上提供了更多选择.&lt;/li&gt;
&lt;li&gt;微服务对外部环境的假设尽可能少. 微服务应管理自己的功能域和数据模型.&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;9-什么是有界上下文&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3582&quot;&gt;9. 什么是有界上下文?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;有界上下文是域驱动设计中的中心模式. 在有界上下文中,与域相关的所有内容在内部上下文中都是可见的,但对其他有界上下文是不透明的. DDD通过将大型模型划分为不同的有界上下文并明确说明它们之间的相互关系来处理它们.&lt;/p&gt;
&lt;p&gt;_整体概念模型问题 _&lt;/p&gt;
&lt;p&gt;整个组织的单一概念模型很难处理. 这种统一模型的唯一好处是,在整个企业范围内集成都很容易,但是缺点很多,例如:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先,很难建立一个适用于整个组织的模型.&lt;/li&gt;
&lt;li&gt;其他人(团队)很难理解它.&lt;/li&gt;
&lt;li&gt;更改这种共享模型以适应新的业务需求非常困难. 这种变化的影响将在团队之间广泛传播.&lt;/li&gt;
&lt;li&gt;任何大型企业都需要一个非常大或抽象的模型.&lt;/li&gt;
&lt;li&gt;单个词的含义在组织的不同部门中可能有所不同,因此可能很难提出一个统一的模型. 即使创建了这样的模型,也会在团队中引起很多混乱.&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;10-微服务架构的特征&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3583&quot;&gt;10. 微服务架构的特征&lt;/a&gt;&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;高凝聚力&lt;/strong&gt; -小,专注于做好一件事. 小并不意味着更少的代码行,因为很少有编程语言比其他语言更冗长,但这意味着单个微服务所能满足的最小功能范围.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;松散耦合&lt;/strong&gt; -自主-能够独立部署不同服务的能力以及可靠性,这是因为即使另一个服务出现故障,该服务也可以运行.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限界上下文&lt;/strong&gt; -一个微服务供应域中的界上下文. 通过使用该有界上下文的接口,它与域的其余部分进行通信.&lt;/li&gt;
&lt;li&gt;围绕业务能力而非技术进行组织.&lt;/li&gt;
&lt;li&gt;持续交付和基础设施自动化.&lt;/li&gt;
&lt;li&gt;向后兼容的版本控制. 生产环境中甚至可以存在相同微服务的多个版本.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错&lt;/strong&gt; -如果一项服务失败,它将不会影响系统的其余部分. 例如,如果为电子商务提供评论和评论的微服务失败,则网站的其余部分应运行良好.&lt;/li&gt;
&lt;li&gt;分散式数据管理,每个服务拥有其数据库,而不是单个共享数据库. 每个微服务都可以自由选择适合其业务用例的数据库类型(例如,RDBMS用于订单管理,NoSql用于电子商务网站的目录管理)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终一致性&lt;/strong&gt; -事件驱动的异步更新.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt; -每个微服务都应具有保护其自身资源免受未经授权访问的能力. 这是通过使用无状态安全性机制(例如带有OAuth2的JSON Web令牌(JWT,发音为jot))实现的.&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;11-使用微服务架构有什么好处&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3584&quot;&gt;11. 使用微服务架构有什么好处?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;与在应用程序中使用整体式体系结构相比,采用微服务体系结构可带来许多好处,包括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;自主部署&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在单个微服务上工作的分散团队大多彼此独立,因此更改服务不需要与其他团队协调. 这可以导致明显更快的释放周期. 在现实的单片应用程序中,很难实现相同的目标,因为微小的变化可能需要整个系统的回归.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;理念转变&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;系统架构的微服务风格强调自由文化,单一责任,团队自治,更快的发布迭代和技术多样化.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;技术多元化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与单片应用程序不同,微服务没有绑定到一个技术堆栈(Java,.Net,Go,Erlang,Python等). 每个团队都可以自由选择最适合其要求的技术堆栈. 例如,我们可以自由地为微服务选择Java,为其他服务选择c ++,为另一个服务选择Go.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DevOps文化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该术语来自“开发”和“运营”的缩写. 这种文化强调产品管理,软件开发和运营团队之间的有效沟通与协作. 如果正确实施DevOps文化,可以缩短开发周期,从而加快产品上市时间.&lt;/p&gt;
&lt;h4 id=&quot;12--什么是多语种持久性这个想法也可以在整体应用中使用吗&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3585&quot;&gt;12 什么是多语种持久性?这个想法也可以在整体应用中使用吗?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;多语言持久性是关于在单个分布式系统中使用不同的数据库来满足不同的业务需求. 我们在市场上已经有不同的数据库产品,每种产品都可以满足特定的业务需求,例如:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;关系数据库管理系统&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关系数据库用于满足交易需求(存储财务数据,报告要求等)&lt;/p&gt;
&lt;p&gt;面向文档的数据库用于满足面向文档的需求(例如,产品目录). 文档是无架构的,因此架构中的更改可以轻松容纳到应用程序中.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Cassandra / Amazon DynamoDB&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于键值对的数据库(用户活动跟踪,分析等). DynamoDB可以存储文档以及键值对.&lt;/p&gt;
&lt;p&gt;在内存分布式数据库(用户会话跟踪)中,其主要用作多个微服务之间的分布式缓存.&lt;/p&gt;
&lt;p&gt;图表数据库(社交关系,建议等)&lt;/p&gt;
&lt;p&gt;_Polyglot Persistence的 _好处是多方面的,可以在整体以及微服务架构中获得. 任何体面大小的产品都会有各种各样的需求,仅凭一种数据库就无法满足. 例如,如果对特定的微服务没有事务需求,那么使用键值对或面向文档的NoSql比使用事务性RDBMS数据库更好.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考:&lt;/em&gt;&lt;a href=&quot;https://martinfowler.com/bliki/PolyglotPersistence.html&quot;&gt;https&lt;/a&gt; &lt;em&gt;:&lt;/em&gt; &lt;a href=&quot;https://martinfowler.com/bliki/PolyglotPersistence.html&quot;&gt;//martinfowler.com/bliki/PolyglotPersistence.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;13-什么是应用程序的十二要素&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3586&quot;&gt;13 什么是应用程序的十二要素?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;十二要素应用程序是一种用于编写作为服务运行的Web应用程序的最新方法(和/或宣言).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.images.mdan.top/12top_1590020008133.png&quot; alt=&quot;12因素应用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个代码库,多个部署. 这意味着我们仅应为不同版本的微服务使用一个代码库. 分支可以,但不同的存储库则不行.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;依存关系&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;明确声明并隔离依赖项. 声明建议不要依赖主机上的软件或库. 每个依赖项都应放入pom.xml或build.gradle文件中.&lt;/p&gt;
&lt;p&gt;将配置存储在环境中. 不要在源代码存储库中提交特定于环境的配置(最重要的是:密码). Spring Cloud Config为分布式系统中的外部化配置提供服务器和客户端支持. 使用Spring Cloud Config Server,您可以集中管理所有环境中应用程序的外部属性.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;支持服务&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将支持服务视为附加资源. 无论您是管理外部服务还是其他团队,微服务都应平等对待外部服务. 例如,即使从属微服务是由您自己的团队开发的,也不要在您的应用程序代码中硬编码从属服务的绝对URL. 例如,不要在RestTemplate中对其他服务的URL进行硬编码,而使用Ribbon(带有或不带有Eureka)来定义URL:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Release &amp;amp; Run&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;严格分开构建和运行阶段. 换句话说,您应该能够构建或编译代码,然后将其与特定的配置信息结合起来以创建特定的发行版,然后有意地运行该发行版. 在运行时更改代码应该是不可能的,例如,直接在tomcat中更改类文件. 每个版本的发行版都应该始终有一个唯一的ID,主要是时间戳记. 发布信息应该是不变的,任何更改都应导致新的发布.&lt;/p&gt;
&lt;p&gt;将应用程序作为一个或多个无状态进程执行. 这意味着我们的微服务本质上应该是无状态的,并且不应依赖于内存或文件系统中存在的任何状态. 实际上,状态不属于代码. 因此,没有粘性会话,没有内存中的缓存,没有本地文件系统的存储等. 应该使用分布式缓存(如memcache,ehcache或Redis)代替&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;端口绑定&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过端口绑定导出服务. 这是关于使您的应用程序独立运行,而不是依赖您要在其中部署的应用程序服务器的运行实例. Spring Boot提供了一种机制,可以创建一个包含所有依赖项和嵌入式servlet容器(jetty或tomcat)的可自我执行的uber jar.&lt;/p&gt;
&lt;p&gt;通过过程模型进行横向扩展. 在十二要素应用程序中,流程是一等公民. 这并不排除各个进程通过运行时VM内的线程或在诸如EventMachine,Twisted或Node.js之类的工具中找到的异步/事件模型来处理其自身的内部多路复用. 但是单个VM只能增长得如此之大(垂直规模),因此应用程序还必须能够跨越多个物理机上运行的多个进程. 十二因子应用程序进程绝不应写入PID文件,而应依赖于操作系统进程管理器,例如systemd-云平台上的分布式进程管理器.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Disposability&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;十二要素应用程序的过程是一次性的,这意味着它们可以立即启动或停止. 这有利于快速弹性扩展,代码或配置更改的快速部署以及生产部署的稳定性. 流程应努力减少启动时间. 理想情况下,从启动命令执行到启动并准备好接收请求或作业的过程需要花费几秒钟的时间. 较短的启动时间为发布过程和扩展提供了更大的灵活性;并且它有助于增强鲁棒性,因为在需要时,流程管理器可以更轻松地将流程移至新的物理机.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;开发/线上一致&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;保持开发,暂存和生产尽可能相似. 您的开发环境应该几乎与生产环境相同(例如,避免某些“在我的机器上工作”的问题). 但是,这并不意味着您的操作系统必须是在生产环境中运行的操作系统. Docker可用于为您的微服务创建逻辑隔离.&lt;/p&gt;
&lt;p&gt;将日志视为事件流,仅将所有日志发送到stdout. 但是,大多数Java开发人员不同意这个建议.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;管理流程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一次性运行管理/管理任务. 例如,应该完全使用单独的过程来运行数据库迁移.&lt;/p&gt;
&lt;h4 id=&quot;14-微服务面临哪些挑战&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3587&quot;&gt;14. 微服务面临哪些挑战?&lt;/a&gt;&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;由于生产系统中大量流程的激增,DevOps是必须的. 如何启动和停止服务团队?&lt;/li&gt;
&lt;li&gt;分布式计算的复杂性,例如“网络延迟,容错,消息序列化,不可靠的网络,异步o / p处理,应用程序层中不同的负载,分布式事务等”.&lt;/li&gt;
&lt;li&gt;如何以最小的努力在大型服务群中进行配置更改?&lt;/li&gt;
&lt;li&gt;如何部署单个微服务的多个版本并适当地路由调用?&lt;/li&gt;
&lt;li&gt;当微服务开始意外崩溃时,如何断开其与生态系统的连接?&lt;/li&gt;
&lt;li&gt;如何隔离发生故障的微服务并避免整个生态系统中的级联故障?&lt;/li&gt;
&lt;li&gt;考虑到服务在任何时间点都可能上升或下降,如何以弹性方式发现服务?&lt;/li&gt;
&lt;li&gt;如何汇总服务中的日志/指标?如何识别跨微服务范围的单个客户端请求的不同步骤?&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;15为什么微服务比单体应用更好&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3588&quot;&gt;15为什么微服务比单体应用更好?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;微服务体系结构旨在开发可安全扩展的大型分布式系统. 微服务架构相对于整体而言有很多好处,例如:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单体应用是作为一个整体构建的,它通常由3个组件组成–数据库(通常是RDBMS),服务器端可执行文件(部署在tomcat,websphere等中的war文件)和客户端接口(JSP等).&lt;/li&gt;
&lt;li&gt;每当我们要添加/更新功能时,开发人员都需要更改这三个组件中的至少一个并将新版本部署到生产中. 整个系统紧密耦合,在选择技术堆栈方面有局限性,凝聚力低.&lt;/li&gt;
&lt;li&gt;当我们需要缩放整体时,可以通过一次又一次地复制大war / ear文件,在多台机器上部署相同版本的整体. 一切都包含在一个可执行文件中.&lt;/li&gt;
&lt;li&gt;另一方面,微服务架构由小型的自治服务组成,这些服务由业务功能划分,业务功能主要通过异步方式在网络上相互通信.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://www.images.mdan.top/1563517219165-Image-5_1589847806236.jpg&quot; alt=&quot;典型的整体应用&quot;/&gt;&lt;br/&gt;如上面的示例所示,典型的整体eShop应用程序通常是部署在单个JVM进程(tomcat / jboss / websphere等)中的大型war文件. 整体中的不同组件使用进程内通信(例如直接方法调用)相互通信. 一个或多个数据库在整体应用程序的不同组件之间共享.&lt;/p&gt;
&lt;h4 id=&quot;16-如何将大型应用程序转换为微服务架构&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3589&quot;&gt;16. 如何将大型应用程序转换为微服务架构?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;微服务应该是自主的,并应根据业务功能进行划分. 每个软件组件都应具有单一的明确定义的职责(又称“单一职责原则”),并且应使用“受限上下文”的原则(由“域驱动设计”定义)来创建具有高度凝聚力的软件组件.&lt;/p&gt;
&lt;p&gt;例如,一个电子商务站点可以根据其业务功能分为以下微服务:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;产品目录&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;负责产品信息,搜索产品,过滤产品和产品方面.&lt;/p&gt;
&lt;p&gt;负责管理产品库存(库存/数量和方面).&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;产品评论和反馈&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;收集用户对产品的反馈.&lt;/p&gt;
&lt;p&gt;负责创建和管理订单.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;付款方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在线和离线处理付款(货到付款).&lt;/p&gt;
&lt;p&gt;根据订单管理和跟踪货运.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;用户帐号&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;管理用户及其偏好.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;推荐建议&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据用户的偏好或过去的购买来推荐新产品.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通知事项&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有关订单,付款和装运的电子邮件和SMS通知.&lt;/p&gt;
&lt;p&gt;客户端应用程序(浏览器,移动应用程序)将通过API网关与这些服务进行交互,并将相关信息呈现给用户.&lt;/p&gt;
&lt;h4 id=&quot;17-如果启动期间无法连接到config服务器如何在启动时停止基于spring-boot的微服务&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3590&quot;&gt;17. 如果启动期间无法连接到Config服务器,如何在启动时停止基于Spring Boot的微服务?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;如果要在引导过程中无法找到配置服务器时停止该服务,则需要在微服务的bootstrap.yml中配置以下属性:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
      cloud:
         config:
             fail-fast: true 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当引导过程中无法访问config-server时,使用此配置将使微服务启动失败并发生异常.&lt;/p&gt;
&lt;p&gt;我们可以启用重试机制,其中微服务将在抛出异常之前重试6次. 我们只需要在类路径中添加spring-retry和spring-boot-starter-aop即可启用此功能.&lt;/p&gt;
&lt;p&gt;build.gradle:-&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies {
   compile('org.springframework.boot:spring-boot-starter-aop')
   compile('org.springframework.retry:spring-retry')
   ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;18-单个微服务应该有多大&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3592&quot;&gt;18 单个微服务应该有多大?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;良好的经验法则(尽管非特定性)应尽可能小,但应尽可能大,以代表他们拥有的领域概念(由马丁·福勒(Martin Fowler)说)&lt;/p&gt;
&lt;p&gt;规模不应成为微服务中的决定因素,而应使用有限上下文原则和单一责任原则将业务能力隔离到单个微服务边界中.&lt;/p&gt;
&lt;p&gt;微服务通常很小,但并非所有的小服务都是微服务. 如果任何服务未遵循“绑定上下文原则”,“单一职责原则”等,则它不是微服务,无论其大小如何. 因此,规模并不是服务成为微服务的唯一资格标准.&lt;/p&gt;
&lt;p&gt;实际上,微服务的大小在很大程度上取决于您选择的语言(Java,Scala,PHP),因为很少有语言比其他语言更冗长.&lt;/p&gt;
&lt;h4 id=&quot;19-微服务如何相互通信&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3593&quot;&gt;19 微服务如何相互通信?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;微服务通常使用诸如HTTP上的REST之类的简单协议进行集成. 其他通信协议也可以用于集成,例如AMQP,JMS,Kafka等.&lt;/p&gt;
&lt;p&gt;通信协议可以大致分为两类:同步通信和异步通信.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;同步通讯&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RestTemplate,WebClient,FeignClient可用于两个微服务之间的同步通信. 理想情况下,我们应该最小化微服务之间的同步调用数量,因为网络很脆弱并且会引入延迟. 功能区-客户端负载平衡器可用于在RestTemplate顶部更好地利用资源. Hystrix断路器可用于优雅地处理部分故障,而不会对整个生态系统造成连锁影响. 应该不惜一切代价避免分布式提交,相反,我们将选择使用异步通信实现最终的一致性.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;异步通讯&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这种类型的通信中,客户端不等待响应,而是仅将消息发送到消息代理. AMQP(如RabbitMQ)或Kafka可用于跨微服务的异步通信,以实现最终的一致性.&lt;/p&gt;
&lt;h4 id=&quot;20-微服务中首选的通信方式是什么同步还是异步&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3594&quot;&gt;20 微服务中首选的通信方式是什么:同步还是异步?&lt;/a&gt;&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;您必须使用一些可靠的队列机制(RabbitMQ,AMQP等)在处理HTTP POST / PUT(任何修改数据的)请求时使用异步通信.&lt;/li&gt;
&lt;li&gt;可以在API网关级别将同步通信用于聚合模式. 但是,此聚合除聚合外不应包含任何业务逻辑. 不得在网关上转换数据值,否则,它将无法达到“受限上下文”的目的. 在异步通信中,事件应发布到队列中. 事件包含有关域的数据,它不应该告诉对此数据做什么(操作).&lt;/li&gt;
&lt;li&gt;如果微服务到微服务的通信仍然需要GET操作进行同步通信,那么请认真考虑为有限的上下文重新划分微服务,并在积压/技术债务中创建一些任务.&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;21-在微服务环境下业务流程和编排有什么区别&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3595&quot;&gt;21 在微服务环境下,业务流程和编排有什么区别?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在业务流程中,我们依靠中央系统以某种方式控制和调用其他微服务来完成给定的任务. 中央系统维护整个工作流程的每个步骤和顺序的状态. 在编排中,每个微服务都像状态机一样工作,并根据其他部分的输入做出反应. 每个服务都知道如何对来自其他系统的不同事件做出反应. 在这种情况下,没有中央命令.&lt;/p&gt;
&lt;p&gt;业务流程是紧密耦合的方法,并且是微服务体系结构中的反模式. 鉴于此,应尽可能采用编排的松散耦合方法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;例&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们要开发一种微服务,该服务将在虚拟的电子商店中发送产品推荐电子邮件. 为了发送建议,我们需要访问位于不同微服务中的用户的订单历史记录.&lt;/p&gt;
&lt;p&gt;在编排方法中,此新的建议微服务将同步调用订购服务并获取相关数据,然后根据其过去的购买量来计算建议. 为一百万用户执行此操作将变得很麻烦,并将两个微服务紧密结合在一起.&lt;/p&gt;
&lt;p&gt;在编排方法中,我们将使用基于事件的异步通信,每当用户进行购买时,订单服务都会发布事件. 推荐服务将监听此事件并开始建立用户推荐. 这是一种松散耦合的方法,具有高度的可扩展性. 在这种情况下,事件并不能说明操作,而只能说明数据.&lt;/p&gt;
&lt;h4 id=&quot;22-微服务发布到生产中的频率如何&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3596&quot;&gt;22. 微服务发布到生产中的频率如何?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个问题没有正确的答案,可能每十分钟,每小时或每周发布一次. 这完全取决于您在软件开发生命周期的不同级别上的自动化程度-构建自动化,测试自动化,部署自动化和监视. 当然还有业务需求-在一次发布中,您关心的低风险变化有多小.&lt;/p&gt;
&lt;p&gt;在一个理想的世界中,每个微服务的边界都明确定义(有界上下文),并且给定的服务不会影响其他微服务,您可以轻松地一天完成多次部署而不会造成很大的复杂性.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署/发布频率示例&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;据记录,亚马逊在2011年5月平均每11.6秒进行一次生产更改.&lt;/li&gt;
&lt;li&gt;Github以其积极的工程实践而闻名,平均每天将代码部署到生产中60次.&lt;/li&gt;
&lt;li&gt;Facebook每天发布两次.&lt;/li&gt;
&lt;li&gt;许多Google服务每周都会发布多个版本,而Google中的几乎所有内容都是在主线上开发的.&lt;/li&gt;
&lt;li&gt;Etsy每天部署超过50次.&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;23-什么是云原生应用程序&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3597&quot;&gt;23 什么是云原生应用程序?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;云原生应用程序(NCA)是一种应用程序开发样式,鼓励在连续交付和分布式软件开发领域轻松采用最佳实践. 这些应用程序是专门为云计算体系结构(AWS,Azure,CloudFoundary等)设计的.&lt;/p&gt;
&lt;p&gt;DevOps,持续交付,微服务和容器是开发云原生应用程序的关键概念.&lt;/p&gt;
&lt;p&gt;Spring Boot,Spring Cloud,Docker,Jenkins,Git是一些工具,可以帮助您轻松编写Cloud-Native Application.&lt;/p&gt;
&lt;p&gt;这是一种将分布式系统开发为小服务集合的体系结构方法. 每个服务负责特定的业务功能,在其自己的流程中运行,并通过HTTP REST API或消息传递(AMQP)进行通信.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;开发运维&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它是软件开发人员与IT运营部门之间的合作,其目标是根据客户的需求不断提供高质量的软件.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;持续交付&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有这些都涉及不断不断地自动交付低风险的小批量生产变更. 这样可以更快地收集反馈.&lt;/p&gt;
&lt;p&gt;容器(例如Docker)为每个微服务提供逻辑隔离,从而永远消除了“在我的机器上运行”的问题. 与虚拟机相比,它更快,更高效.&lt;/p&gt;
&lt;h4 id=&quot;24-您将如何使用java开发微服务&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3598&quot;&gt;24 您将如何使用Java开发微服务?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Spring Boot和Spring Cloud是开始使用Java语言构建微服务的一个很好的选择. Spring Cloud中有很多模块可以为微服务的不同设计模式提供样板代码,因此Spring Cloud确实可以加快开发过程. 此外,Spring Boot提供了开箱即用的支持,可将servlet容器(tomcat / jetty / undertow)嵌入可执行jar(超级jar)中,以便可以直接从命令行运行这些jar,从而无需部署war文件放入Servlet容器.&lt;/p&gt;
&lt;p&gt;您还可以使用Docker容器将整个可执行程序包运送并部署到云环境中. Docker还可以通过在开发阶段为运行时环境提供逻辑隔离来帮助消除“在我的机器上工作”的问题. 这样,您就可以跨本地和云环境获得可移植性.&lt;/p&gt;
&lt;h4 id=&quot;25-什么是spring-boot&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3599&quot;&gt;25 什么是Spring Boot?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Spring Boot使得创建独立的,基于生产级别的基于Spring的应用程序变得容易,您可以通过对Spring平台和第三方库的独到见解来“运行”这些应用程序,以便您大惊小怪.&lt;/p&gt;
&lt;p&gt;Spring Boot的主要功能&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建独立的Spring应用程序(12要素应用程序样式)&lt;/li&gt;
&lt;li&gt;直接嵌入Tomcat,Jetty或Undertow(无需部署WAR文件)&lt;/li&gt;
&lt;li&gt;提供可靠的入门POM,以简化您的Maven或Gradle配置&lt;/li&gt;
&lt;li&gt;尽可能自动配置Spring&lt;/li&gt;
&lt;li&gt;提供可用于生产的功能,例如指标,运行状况检查和外部化配置&lt;/li&gt;
&lt;li&gt;完全没有代码生成,也不需要XML配置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;您可以使用托管在https://start.spring.io/的在线工具为项目选择所需的依赖项来创建Spring Boot入门项目.&lt;/p&gt;
&lt;p&gt;任何Spring Boot应用程序的最小最小依赖关系是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
dependencies {
        compile(&quot;org.springframework.boot:spring-boot-starter-web:2.0.4.RELEASE&quot;)
}
        
import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;
import org.springframework.stereotype.*;
import org.springframework.web.bind.annotation.*;

@Controller
@EnableAutoConfiguration
public class HelloWorldController {
    @RequestMapping(&quot;/&quot;)
    @ResponseBody
    String home() {
        return &quot;Hello World!&quot;;
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(SampleController.class, args);
    }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可以直接运行此类,而无需将其部署到servlet容器中.&lt;/p&gt;
&lt;p&gt;_有用的参考 _&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring Boot Project&lt;/li&gt;
&lt;li&gt;Spring Boot Starter&lt;/li&gt;
&lt;li&gt;使用Spring Boot构建应用程序&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;26-什么是api网关&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3600&quot;&gt;26. 什么是API网关?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;API网关是一类特殊的微服务,可满足单个客户端应用程序(例如android应用程序,Web应用程序,Angular JS应用程序,iPhone应用程序等)的需求,并为其提供后端资源(微服务)的单个入口,向他们提供跨领域的关注,例如安全性,监视/指标和弹性.&lt;/p&gt;
&lt;p&gt;客户端应用程序可以与每个请求同时访问数十个或数百个微服务,汇总响应并将其转换为满足客户端应用程序的需求. Api Gateway可以使用客户端负载平衡器库(Ribbon)以循环方式在实例之间分配负载. 如果需要,它也可以进行协议转换,即HTTP到AMQP. 它也可以处理受保护资源的安全性.&lt;/p&gt;
&lt;p&gt;API网关的功能&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring Cloud DiscoveryClient集成&lt;/li&gt;
&lt;li&gt;请求速率限制(在Spring Boot 2.x中可用)&lt;/li&gt;
&lt;li&gt;路径改写&lt;/li&gt;
&lt;li&gt;Hystrix断路器集成,具有弹性&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;27-在部署期间如何实现零停机时间&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3601&quot;&gt;27 在部署期间如何实现零停机时间?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;顾名思义,零停机时间部署不会在生产环境中造成停机. 这是将更改部署到生产的一种聪明方法,在任何给定时间点,至少有一项服务将对客户可用.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;蓝绿色部署&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现此目标的一种方法是蓝色/绿色部署. 在这种方法中,一次部署了一个微服务的两个版本. 但是只有一个版本正在接受真正的请求. 一旦将新版本测试到所需的满意度,就可以从旧版本切换到新版本.&lt;/p&gt;
&lt;p&gt;您可以运行冒烟测试套件,以验证该功能在新部署的版本中是否正常运行. 根据冒烟测试的结果,可以发布较新的版本,成为实时版本.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;客户端代码中需要进行更改以处理零停机时间&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设您有两个同时运行的服务实例,并且两个实例都在Eureka注册表中注册. 此外,两个实例都使用两个不同的主机名进行部署:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/src/main/resources/application.yml 
  spring.application.name: ticketBooks-service
  ---
  spring.profiles: blue
  eureka.instance.hostname: ticketBooks-service -blue.example.com
  ---
  spring.profiles: green
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在需要对books-service进行api调用的客户端应用程序可能如下所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
@SpringBootApplication
@EnableDiscoveryClient
public class ClientApp {
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

    @RequestMapping(&quot;/hit-some-api&quot;)
    public Object hitSomeApi() {
        return restTemplate().getForObject(&quot;https://ticketBooks-service/some-uri&quot;, Object.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在,当ticketBooks-service-green.example.com停止升级时,它会正常关闭并从Eureka注册表中删除其条目. 但是,直到再次获取注册表(每30秒发生一次),这些更改才会反映在ClientApp中. 因此,长达30秒,ClientApp的@LoadBalanced RestTemplate可能会将请求发送到ticketBooks-service-green.example.com,即使它失败了.&lt;/p&gt;
&lt;p&gt;为了解决这个问题,我们可以在Ribbon客户端负载均衡器中使用Spring Retry支持. 要启用Spring Retry,我们需要执行以下步骤:&lt;/p&gt;
&lt;p&gt;_添加spring-retry到build.gradle依赖项 _&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;compile(&quot;org.springframework.boot:spring-boot-starter-aop&quot;)
compile(&quot;org.springframework.retry:spring-retry&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在,使用@EnableRetry批注在ClientApp中启用spring-retry机制,如下所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@EnableRetry
@RestController
@SpringBootApplication
@EnableDiscoveryClient
public class ClientApp { 
... 
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成此操作后,Ribbon将自动将其自身配置为使用重试逻辑,Ribbon将重试对ticketBooks-service-green.example.com com的任何失败请求(以循环方式). 您可以使用以下属性来自定义此行为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/src/main/resources/application.yml 
ribbon:
        MaxAutoRetries: 5 
        MaxAutoRetriesNextServer: 5 
        OkToRetryOnAllOperations: true
        OkToRetryOnAllErrors: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;28-数据库发生更改时如何实现零停机时间部署蓝色绿色&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3602&quot;&gt;28. 数据库发生更改时,如何实现零停机时间部署(蓝色/绿色)?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;当升级期间数据库发生更改时,部署方案将变得复杂. 有两种不同的方案:1.数据库更改是向后兼容的(例如,添加新的表列)2.数据库更改与应用程序的旧版本不兼容(例如,重命名现有的表列)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;向后兼容更改&lt;/strong&gt;:此方案易于实现,并且可以使用Flyway完全自动化. 我们可以添加脚本以创建新列,并且脚本将在部署时执行. 现在,在蓝/绿部署期间,该应用程序的两个版本(例如v1和v2)将连接到同一数据库. 我们需要确保新添加的列允许空值(顺便说一下,这是向后兼容更改的一部分). 如果一切顺利,那么我们可以关闭旧版本v1,否则可以关闭应用程序v2.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不兼容的数据库更改&lt;/strong&gt;:这是一个棘手的情况,在回滚的情况下可能需要手动干预. 假设我们要在数据库中将first_name列重命名为fname. 除了直接重命名,我们还可以创建一个新列fname,并将first_name的所有现有值复制到fname列中,并保持first_name列在数据库中的状态. 我们可以将对fname的非null检查推迟到部署后的成功. 如果部署成功,我们需要在关闭v1之后手动将v1写入first_name的数据迁移到新列(fname). 如果v2部署失败,则需要执行其他操作.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在实际的生产应用程序中,复杂性可能更大,此类讨论超出了本书的范围.&lt;/p&gt;
&lt;h4 id=&quot;29-如何在微服务架构中维护acid&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3603&quot;&gt;29 如何在微服务架构中维护ACID?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ACID是数据库事务管理器确保的四个主要属性(原子性,一致性,隔离性和持久性)的首字母缩写.&lt;/p&gt;
&lt;p&gt;在涉及两个或多个实体的事务中,所有记录都已提交,也没有提交.&lt;/p&gt;
&lt;p&gt;数据库事务必须仅遵循包括约束/触发等的特定规则,以允许的方式更改受影响的数据.&lt;/p&gt;
&lt;p&gt;任何进行中的事务(尚未提交)必须与其他任何事务保持隔离.&lt;/p&gt;
&lt;p&gt;提交的记录由数据库保存,这样即使发生故障或数据库重新启动,数据也可以以正确的状态使用.&lt;/p&gt;
&lt;p&gt;在涉及多个数据库的分布式系统中,我们有两种选择来实现ACID遵从性:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实现ACID遵从性的一种方法是使用两阶段提交(也称为2PC),以确保所有涉及的服务必须提交事务完成或所有事务回滚.&lt;/li&gt;
&lt;li&gt;使用最终的一致性,其中不同的微服务拥有的多个数据库最终会通过使用消息传递协议的异步消息传递而变得一致. 最终一致性是弱一致性的一种特定形式.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;理想的情况下,由于微服务架构的脆弱性和复杂性,不建议使用2期提交. 通过最终的一致性,我们可以在分布式系统中达到某种程度的ACID合规性,这应该是正确的方法.&lt;/p&gt;
&lt;h4 id=&quot;30-什么是spring-cloud&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12928158.html#collapse-beginner-3604&quot;&gt;30. 什么是Spring Cloud?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Spring团队整合了一些经过考验的开源项目,这些项目从Pivotal,Netflix等公司整合到一个称为Spring Cloud的Spring项目中. Spring Cloud提供了用于快速构建分布式系统的一些常见设计模式的库和工具,包括:&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;模式类型&lt;/th&gt;
&lt;th&gt;模式名称&lt;/th&gt;
&lt;th&gt;Spring Cloud Library&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;配置模式&lt;/td&gt;
&lt;td&gt;分布式/版本化配置管理&lt;/td&gt;
&lt;td&gt;Spring Cloud Config服务器&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;核心微服务模式&lt;/td&gt;
&lt;td&gt;Spring Boot&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;异步/分布式消息传递&lt;/td&gt;
&lt;td&gt;Spring Cloud Stream (AMQP and Kafka)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;服务间通信&lt;/td&gt;
&lt;td&gt;RestTemplate和Spring Cloud Feign&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;路由模式&lt;/td&gt;
&lt;td&gt;服务注册与发现&lt;/td&gt;
&lt;td&gt;Spring Cloud Netflix Eureka和领事&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;路由模式&lt;/td&gt;
&lt;td&gt;服务路由/ API网关模式&lt;/td&gt;
&lt;td&gt;Spring Cloud Netflix Zuul&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;弹性模式&lt;/td&gt;
&lt;td&gt;客户端负载均衡&lt;/td&gt;
&lt;td&gt;Spring Cloud Netflix功能区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;断路器和后备模式&lt;/td&gt;
&lt;td&gt;Spring Cloud Netflix Hystrix&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;Bulkhead pattern&lt;/td&gt;
&lt;td&gt;Spring Cloud / Spring Cloud Netflix Hystrix&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Logging Patterns&lt;/td&gt;
&lt;td&gt;Log Correlation&lt;/td&gt;
&lt;td&gt;Spring Cloud Sleuth&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;微服务跟踪&lt;/td&gt;
&lt;td&gt;Spring Cloud Sleuth / Zipkin&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;安全模式&lt;/td&gt;
&lt;td&gt;授权与认证&lt;/td&gt;
&lt;td&gt;Spring Cloud Security OAuth2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;凭证管理&lt;/td&gt;
&lt;td&gt;Spring Cloud Security OAuth2 / JWT&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;分布式会话&lt;/td&gt;
&lt;td&gt;Spring Cloud OAuth2和Redis&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Spring Cloud使得为Cloud开发,部署和操作JVM应用程序变得非常容易.&lt;/p&gt;
</description>
<pubDate>Thu, 21 May 2020 00:11:00 +0000</pubDate>
<dc:creator>分布式编程</dc:creator>
<og:description>1. &amp;quot;Java内存管理面试指南一&amp;quot; 2. &amp;quot;Java基础面试指南一&amp;quot; 3. &amp;quot;Java基础面试指南二&amp;quot; 4. &amp;quot;Java基础面试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daichangya/p/12928158.html</dc:identifier>
</item>
<item>
<title>Blazor WebAssembly 3.2 正式发布 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/12926686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/12926686.html</guid>
<description>&lt;p&gt;5月 20日，微软 &lt;a href=&quot;https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-now-available/&quot;&gt;发布&lt;/a&gt;了 Blazor WebAssembly 3.2(&lt;a title=&quot;https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-now-available/&quot; href=&quot;https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-now-available/&quot;&gt;https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-now-available/&lt;/a&gt;) 。&lt;a href=&quot;http://aka.ms/blazor&quot;&gt;Blazor&lt;/a&gt; 是 ASP.NET Core 中的一个新框架，支持使用 C#和 HTML 创建交互式 Web 应用程序。Blazor WebAssembly 使用基于 WebAssembly 的.NET 运行时在客户端的 Web 浏览器中运行单页应用程序。在客户端，它支持的场景包括渐进式 Web 应用程序（PWA）和使用客户端资源的离线应用程序。&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly 3.2.0 是一个功能齐全的版本，作为 Blazor WebAssembly实现，并用于生产部署。 也就是 Blazor WebAssembly 作为正式版本发布。 Blazor WebAssembly 3.2 的第一个预览版在 &lt;a href=&quot;https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-preview-1-release-now-available/&quot;&gt;1 月底发布&lt;/a&gt;。从那时起，接下来的预览版发布遵循了非常紧凑的时间表，今天在Build 大会上正式发布了Blazor WebAssembly 3.2 。&lt;/p&gt;
&lt;p&gt;通常，Web 浏览器可以执行使用 JavaScript 编写的代码，但2017年标准化的 WebAssembly 可以执行其他编程语言的编写的代码，现在主流的4大浏览器都可以完美支持，而且更重要的是他不需要安装插件就可以运行，性能还比JavaScript强。Blazor WebAssembly 正是使用&quot;WebAssembly&quot;，这一技术在 Web 浏览器中快速运行的二进制格式来打破现行前端世界的平静。可能是 Web 应用程序框架历史上的一件大事，标准着 WebAssembly 这一技术正式进入前端普及。&lt;/p&gt;
&lt;p&gt;微软去年10月和 NET Core 3.1 一起发布了&quot;Blazor Server&quot;，它使用Blazor技术作为服务器端。 &quot;Blazor WebAssembly&quot; 在客户端发布，使用 Blazor 技术，但&quot;Blazor PWA&quot;用于开发作为单个应用程序的 PWA。 同时还在进行开发一个实验项目，如&quot;Blazor Hybrid&quot;，使用 Electron 和 WebView 开发桌面应用程序，以及用于开发本机应用程序的&quot;Blazor Native&quot;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202005/510-20200520221715601-1787769116.gif&quot;&gt;&lt;img title=&quot;blazorwebassembly502&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202005/510-20200520221716070-660892311.gif&quot; alt=&quot;blazorwebassembly502&quot; width=&quot;622&quot; height=&quot;354&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面说了这么多Blazor相关内容，我们更关心的是落地，在官方博客上已经列出了大量的可用于生产的控件库和蓬勃发展的开源项目：&lt;/p&gt;
&lt;h4&gt;现成组件&lt;/h4&gt;
&lt;p&gt;当然，任何Web应用程序将需要美丽和功能丰富的组件。传统的.NET 生态的控件厂商已经做好了各种商业的 Blazor UI 组件，这些组件在任何 Blazor 应用程序中都工作出色，包括 Blazor WebAssembly 应用程序：&lt;/p&gt;
&lt;h4&gt;开源社区&lt;/h4&gt;
&lt;p&gt;Blazor 还有一个繁荣的开源社区和生态系统。社区成员已经构建了许多出色的组件库、互操作库、测试框架等，然后免费提供它们供您使用。一些很好的例子包括：&lt;/p&gt;
&lt;p&gt;这里要特别介绍的是国内的一个开源项目 ant-design-blazor，目标是成为Ant Design官方认可的Blazor实现，并丰富Blazor生态，当然国内还有一个ant desin blazor 实现，在国外还有一个，大家可以自己到github 去瞧一瞧。&lt;/p&gt;
&lt;p&gt;Github：&lt;a title=&quot;https://github.com/ant-design-blazor/ant-design-blazor&quot; href=&quot;https://github.com/ant-design-blazor/ant-design-blazor&quot;&gt;https://github.com/ant-design-blazor/ant-design-blazor&lt;/a&gt;&lt;br/&gt;Demo：&lt;a href=&quot;https://ant-design-blazor.gitee.io&quot;&gt;https://ant-design-blazor.gitee.io&lt;/a&gt;&lt;br/&gt;开发文档：&lt;a title=&quot;https://github.com/ant-design-blazor/ant-design-blazor/wiki&quot; href=&quot;https://github.com/ant-design-blazor/ant-design-blazor/wiki&quot;&gt;https://github.com/ant-design-blazor/ant-design-blazor/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;国内社区还有几个Blazor相关的库：&lt;/p&gt;
&lt;p&gt;1、Bootstrap 是 Blazor基于Bootstrap ，这个UI库目前只有服务器端，客户端wasm模式等正式版出来会搞， 仓库地址：https://gitee.com/LongbowEnterprise/BootstrapBlazor ，演示地址：&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/%20http://blazor.sdgxgz.com&quot;&gt;blazor.sdgxgz.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、Blazui  是 Element UI 的 CSS 和 HTML 结构 仓库地址：&lt;a href=&quot;https://github.com/wzxinchen/Blazui&quot;&gt;https://github.com/wzxinchen/Blazui&lt;/a&gt; ，演示地址 &lt;a href=&quot;http://blazui.com:9000&quot;&gt;http://blazui.com:9000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
</description>
<pubDate>Wed, 20 May 2020 22:59:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>5月 20日，微软 发布了 Blazor WebAssembly 3.2(https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/12926686.html</dc:identifier>
</item>
<item>
<title>二叉树的存储结构 - CoderJerry</title>
<link>http://www.cnblogs.com/yangyuanhu/p/12927657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyuanhu/p/12927657.html</guid>
<description>&lt;p&gt;二叉树可使用顺序结构和链表结构两种存储结构&lt;/p&gt;
&lt;h2 id=&quot;顺序结构&quot;&gt;顺序结构&lt;/h2&gt;
&lt;p&gt;顺序结构实现二叉树时,采用一个一维数组来存储所有结点,需要将所有结点按照在树中的位置安排成一个恰当的序列,使其能反应结点之间相互的逻辑关系,通常使用编号的方法;&lt;/p&gt;
&lt;h5 id=&quot;具体方法&quot;&gt;具体方法:&lt;/h5&gt;
&lt;p&gt;将二叉树中所有结点&lt;span&gt;按照完全二叉树进行编号&lt;/span&gt;,然后使用一维数组存储,同时使结点编号与数组下标相同,如编号为1的节点存储在数组下标为1的位置;该方法称为&lt;span&gt;以编号为地址&lt;/span&gt;的策略&lt;/p&gt;
&lt;h5 id=&quot;案例1完全二叉树&quot;&gt;案例1(完全二叉树):&lt;/h5&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202005/1440878-20200521021019045-1104316012.png&quot; alt=&quot;image-20200521020201337&quot;/&gt;&lt;p&gt;若二叉树为完全二叉树则上述方法,可以很好的利用存储空间,基本没有浪费,且对于结点的查找是很方便的;&lt;/p&gt;
&lt;h5 id=&quot;案例2一般二叉树&quot;&gt;案例2(一般二叉树):&lt;/h5&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202005/1440878-20200521021052476-1901895843.png&quot; alt=&quot;image-20200521020350552&quot;/&gt;&lt;p&gt;当二叉树为一般二叉树时,如想要使用顺序结构存储则必须增加虚拟结点,使其变为完全二叉树,像下面这样:&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202005/1440878-20200521021112391-1311921418.png&quot; alt=&quot;image-20200521020453983&quot;/&gt;&lt;p&gt;这样一来则需要浪费一部分存储空间,极端情况下,若二叉树是一分叉的(每个节点只有一个子节点),将造成极大的空间浪费&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202005/1440878-20200521021130378-534458747.png&quot; alt=&quot;image-20200521020818408&quot;/&gt;&lt;h2 id=&quot;链式存储结构&quot;&gt;链式存储结构&lt;/h2&gt;
&lt;p&gt;链式存储结构,分为两种二叉链表和三叉链表&lt;/p&gt;
&lt;h3 id=&quot;二叉链表&quot;&gt;二叉链表&lt;/h3&gt;
&lt;p&gt;每个结点由一个数据域和两个指针域组成,共三个部分,如下图所示&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202005/1440878-20200521021345400-1774419674.png&quot; alt=&quot;image-20200521011205379&quot;/&gt;&lt;h5 id=&quot;数据结构定义&quot;&gt;数据结构定义:&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct btnode {
        DataType data;
        struct btnode *lchild,*rchild;
}*BinTree;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;案例&quot;&gt;案例:&lt;/h5&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202005/1440878-20200521021418002-1218007227.png&quot; alt=&quot;image-20200521012125172&quot;/&gt;&lt;p&gt;由于使用了链式存储结构,在插入或删除结点时效率比顺序结构更好;并且不会造成较大的空间浪费;&lt;/p&gt;
&lt;h5 id=&quot;特性&quot;&gt;特性:&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;n个结点组成的二叉树&lt;span&gt;共有2n个指针域&lt;/span&gt;,其中有&lt;span&gt;n-1个指向左右子结点&lt;/span&gt;的非空指针域,(两个节点关联需要一个指针域,以此类推3个结点关联需要2个指针域)和&lt;span&gt;n+1个空指针域&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;已知某结点地址求其子结点方便,求其父节点则需要从头开始遍历&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三叉链表&quot;&gt;三叉链表&lt;/h3&gt;
&lt;p&gt;由于二叉链表查找父结点需要遍历所有结点,效率较低,若对于经常需要查询父结点的二叉树,则可以使用三叉链表来提高效率,三叉链表在二叉链表的基础上增加了一个parent指针域,如下图所示:&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202005/1440878-20200521021457600-371315523.png&quot; alt=&quot;image-20200521014338764&quot;/&gt;&lt;h5 id=&quot;案例-2&quot;&gt;案例:&lt;/h5&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202005/1440878-20200521021529530-943799562.png&quot; alt=&quot;image-20200521015716404&quot;/&gt; 可以看出三叉链表与二叉链表没有太大区别,牺牲一些空间换来了查询父结点的效率;</description>
<pubDate>Wed, 20 May 2020 18:16:00 +0000</pubDate>
<dc:creator>CoderJerry</dc:creator>
<og:description>二叉树的存储结构 二叉树可使用顺序结构和链表结构两种存储结构 顺序结构 顺序结构实现二叉树时,采用一个一维数组来存储所有结点,需要将所有结点按照在树中的位置安排成一个恰当的序列,使其能反应结点之间相互</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yangyuanhu/p/12927657.html</dc:identifier>
</item>
<item>
<title>520闷在家里做图（ 安卓统计图MPAndroidChart开发 ） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/12927251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/12927251.html</guid>
<description>&lt;p&gt;有些时候觉得一个人挺好的，可以更自由安排自己的时间；&lt;/p&gt;
&lt;p&gt;有些时候觉得有个人挺好的，很多事情一个人做起来太没意思了，纵使心中澎湃，倾听的独有自己。&lt;/p&gt;
&lt;p&gt;废话少说，直接上图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520233214510-1772067942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;MPAndroidChart是啥&lt;/h2&gt;
&lt;p&gt;一个可以在安卓上实现各种数据统计图的开源项目。来看看它都能显示啥图：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LineChart（带有图例，简单设计）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520234303651-2041555408.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;231&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; LineChart（带有图例，简单设计）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520234353402-1535212440.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;252&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; LineChart（立方线）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520234438030-353523482.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;184&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;LineChart（渐变填充）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520234521746-1818741672.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 条形图（带有图例，简单设计）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520234612950-1875048104.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条形图（分组数据集）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520234704677-805033108.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;水平条形图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520234752448-438427871.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合图（在这种情况下为条形图和折线图）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520234830303-1716234529.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PieChart（带有选择项，...）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                       &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520234916172-1382224754.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ScatterChart（带有正方形，三角形，圆形等）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520235039415-879170003.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;177&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CandleStickChart（用于财务数据）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520235119857-1405089063.png&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BubbleChart（气泡覆盖的区域表示yValue） &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520235153706-1937621469.png&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;121&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RadarChart（蜘蛛网络图表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                           &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520235230360-506095691.png&quot; alt=&quot;&quot; width=&quot;263&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;使用前的准备工作&lt;/h2&gt;
&lt;p&gt;需要先将库下载到我们的工程中，添加依赖后同步一下即可自动下载&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加依赖&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;repositories {
    maven { url &lt;/span&gt;'https://jitpack.io'&lt;span&gt; }
}

dependencies {
    implementation &lt;/span&gt;'com.github.PhilJay:MPAndroidChart:v3.1.0'&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200520235529560-202286314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 添加视图文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;com.github.mikephil.charting.charts.PieChart里的PieChart可以为LineChart, BarChart, ScatterChart, CandleStickChart, PieChart, BubbleChart or RadarChart，这些要根据实际情况决定&lt;/p&gt;
&lt;h2&gt;事件相关API&lt;/h2&gt;
&lt;p&gt;该库允许您完全自定义与图表视图的可能的触摸（和手势）交互，并通过回调方法对交互做出反应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启用/禁用交互&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setTouchEnabled(boolean enabled)：允许启用/禁用与图表的所有可能的触摸交互。&lt;/p&gt;
&lt;p&gt;setDragEnabled(boolean enabled)：启用/禁用图表的拖动（平移）。&lt;/p&gt;
&lt;p&gt;setScaleEnabled(boolean enabled)：启用/禁用两个轴上图表的缩放。&lt;/p&gt;
&lt;p&gt;setScaleXEnabled(boolean enabled)：启用/禁用x轴缩放。&lt;/p&gt;
&lt;p&gt;setScaleYEnabled(boolean enabled)：启用/禁用y轴缩放。&lt;/p&gt;
&lt;p&gt;setPinchZoom(boolean enabled)：如果设置为true，则启用缩放。如果禁用，则可以分别缩放x轴和y轴。&lt;/p&gt;
&lt;p&gt;setDoubleTapToZoomEnabled(boolean enabled)：将其设置为false可禁止通过双击来放大图表。&lt;/p&gt;
&lt;p&gt;注意：这里很多事件不支持饼状图，比如缩放、平移、放大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;触摸图表时运动/减速&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setDragDecelerationEnabled(boolean enabled)：如果设置为true，则在触摸后图表将继续滚动。默认值：true。&lt;/p&gt;
&lt;p&gt;setDragDecelerationFrictionCoef(float coef)：减速摩擦系数[0; 1]间隔，较高的值表示速度将缓慢降低，例如，如果将其设置为0，它将立即停止。1是无效值，并将自动转换为0.9999。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件监听接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;触摸事件监听&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; dongxiaodongchart.setOnChartGestureListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnChartGestureListener() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始触摸手势时回调&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChartGestureStart(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Toast.makeText(MainActivity.this,&quot;东小东：触摸事件开始&quot;,Toast.LENGTH_SHORT).show();&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束触摸手势时回调&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChartGestureEnd(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Toast.makeText(MainActivity.this,&quot;东小东：触摸事件结束&quot;,Toast.LENGTH_SHORT).show();&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;长按图表时回调&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChartLongPressed(MotionEvent me) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;东小东：图表长按&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;双击图表时回调&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChartDoubleTapped(MotionEvent me) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;东小东：图表被双击&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单击图表时进行回调&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onChartSingleTapped(MotionEvent me) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;东小东：图表单击&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;图幅描述变化&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;参数：
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    x的速度
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    y的速度
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onChartFling(MotionEvent me1, MotionEvent me2, &lt;span&gt;float&lt;/span&gt; velocityX, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; velocityY) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;东小东：图幅描述变化&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缩放图表时的回调&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;参数：
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    scaleX x轴上的比例因子
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    scaleY y轴上的比例因子
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onChartScale(MotionEvent me, &lt;span&gt;float&lt;/span&gt; scaleX, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; scaleY) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;东小东：图表正在缩放中。。。。。&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过拖动手势移动/转换图表时的回调&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;参数：
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;       dX 在x轴上的平移距离
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;       dY 在y轴上的平移距离
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onChartTranslate(MotionEvent me, &lt;span&gt;float&lt;/span&gt; dX, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; dY) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;东小东：图表正在移动中。。。。。&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;动画制作API&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;animateX(int durationMillis)：在水平轴上对图表值进行动画处理，这意味着图表将在指定的时间内从左到右建立。&lt;/p&gt;
&lt;p&gt;animateY(int durationMillis)：对垂直轴上的图表值进行动画处理，这意味着图表将在指定的时间内从下到上建立。&lt;/p&gt;
&lt;p&gt;animateXY(int xDuration, int yDuration)：对水平和垂直轴都进行动画处理，从而形成左/右底部/顶部&lt;/p&gt;
&lt;p&gt;上面三个函数还可以在最后添加一个参数：Easing.EasingOption option&lt;/p&gt;
&lt;p&gt;该库允许您将漂亮的缓动功能应用于动画。您可以在以下静态预定义 之间进行选择Easing.EasingOption：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; EasingOption {
      Linear,
      EaseInQuad,
      EaseOutQuad,
      EaseInOutQuad,
      EaseInCubic,
      EaseOutCubic,
      EaseInOutCubic,
      EaseInQuart,
      EaseOutQuart,
      EaseInOutQuart,
      EaseInSine,
      EaseOutSine,
      EaseInOutSine,
      EaseInExpo,
      EaseOutExpo,
      EaseInOutExpo,
      EaseInCirc,
      EaseOutCirc,
      EaseInOutCirc,
      EaseInElastic,
      EaseOutElastic,
      EaseInOutElastic,
      EaseInBack,
      EaseOutBack,
      EaseInOutBack,
      EaseInBounce,
      EaseOutBounce,
      EaseInOutBounce,
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认效果动画&lt;/span&gt;
dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
dongxiaodongchart.animateX(&lt;/span&gt;2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加固定效果动画&lt;/span&gt;
dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
dongxiaodongchart.animateX(&lt;/span&gt;2000,Easing. EaseInOutQuad);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;strong&gt;轴与网格线API&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;轴可以分为X和Y轴，其x和y轴的实例都可以使用下面的效果自定义&lt;/p&gt;
&lt;p&gt;X轴：&lt;/p&gt;
&lt;p&gt;相关函数&lt;/p&gt;
&lt;p&gt;setLabelRotationAngle(float angle);设置x轴刻度的显示的旋转度数&lt;/p&gt;
&lt;p&gt;setPosition(XAxisPosition pos);设置X轴在图表中的显示位置，TOP（图表上面，刻度在表格外），BOTTOM（图表下面，刻度在表格外），BOTH_SIDED（图表上下都显示），TOP_INSIDE（图表上面，刻度在表格内）或BOTTOM_INSIDE（图表下面，刻度在表格内）&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
XAxis xAxis &lt;/span&gt;= dongxiaodongchart.getXAxis();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取x轴的实例&lt;/span&gt;
xAxis.setLabelRotationAngle(-45);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刻度旋转-45度&lt;/span&gt;
xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只在图表下面显示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Y轴：&lt;/p&gt;
&lt;p&gt;获取y轴左右实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
YAxis leftAxis &lt;/span&gt;=&lt;span&gt; dongxiaodongchart.getAxisLeft();
YAxis rightAxis &lt;/span&gt;= dongxiaodongchart.getAxisRight();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制应绘制（轴的）哪些部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setEnabled(boolean enabled)：设置启用或禁用轴。如果禁用，则无论任何其他设置，都不会绘制轴的任何部分。&lt;/p&gt;
&lt;p&gt;setDrawLabels(boolean enabled)：将其设置为true以启用绘制轴的标签，（刻度）&lt;/p&gt;
&lt;p&gt;setDrawAxisLine(boolean enabled)：如果是否绘制沿轴的线（轴线），则将其设置为true。&lt;/p&gt;
&lt;p&gt;setDrawGridLines(boolean enabled)：将其设置为true以启用绘制轴的网格线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义轴范围（最小/最大）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setAxisMaximum(float max)：为此轴设置自定义最大值。如果设置，则根据提供的数据将不会自动计算该值。&lt;/p&gt;
&lt;p&gt;resetAxisMaximum()：调用此命令可撤消先前设置的最大值。这样，您将再次允许轴自动计算其最大值。&lt;/p&gt;
&lt;p&gt;setAxisMinimum(float min)：为此轴设置一个自定义最小值。如果设置，则根据提供的数据将不会自动计算该值。&lt;/p&gt;
&lt;p&gt;resetAxisMinimum()：调用此命令可撤消先前设置的最小值。这样，您将再次允许轴自动计算其最小值。&lt;/p&gt;
&lt;p&gt;setStartAtZero(boolean enabled)：已弃用 –使用setAxisMinValue(...)或setAxisMaxValue(...)代替。&lt;/p&gt;
&lt;p&gt;setInverted(boolean enabled)：如果设置为true，则该轴将反转，这意味着最大值将位于底部，最小值位于顶部。&lt;/p&gt;
&lt;p&gt;setSpaceTop(float percent)：设置图表中最大值与轴上最高值的顶部间距（以总轴范围的百分比为单位）。&lt;/p&gt;
&lt;p&gt;setSpaceBottom(float percent)：设置图表中最小值与轴上最小值的底部间距（以总轴范围的百分比为单位）。&lt;/p&gt;
&lt;p&gt;setShowOnlyMinMax(boolean enabled)：如果启用，则此轴将仅显示其最小值和最大值。这将忽略/覆盖已定义的标签计数（如果未强制执行）。&lt;/p&gt;
&lt;p&gt;setLabelCount(int count, boolean force)：设置y轴的标签数。请注意，此数字不是固定的（如果force == false），只能近似。如果启用了力（true），则会绘制确切的指定标签数-这会导致轴上的数字不均匀。&lt;/p&gt;
&lt;p&gt;setPosition(YAxisLabelPosition pos)：设置应绘制轴标签的位置。INSIDE_CHART或OUTSIDE_CHART。&lt;/p&gt;
&lt;p&gt;setGranularity(float gran)：设置y轴值之间的最小间隔。在放大到为轴设置的小数位数不再允许在两个轴值之间进行区分的点时，可以使用此方法来避免值重复。&lt;/p&gt;
&lt;p&gt;setCenterAxisLabels(true)；设置刻度值居中于y轴值之间的最小间隔&lt;/p&gt;
&lt;p&gt;setGranularityEnabled(boolean enabled)：启用放大功能，该功能限制放大时y轴的间隔。默认值：false&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;造型/修改轴样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setTextColor(int color)：设置轴标签（刻度）的颜色。&lt;/p&gt;
&lt;p&gt;setTextSize(float size)：设置轴标签的文本大小。&lt;/p&gt;
&lt;p&gt;setTypeface(Typeface tf)：设置Typeface轴标签的自定义。&lt;/p&gt;
&lt;p&gt;setGridColor(int color)：设置该轴的网格线的颜色。&lt;/p&gt;
&lt;p&gt;setGridLineWidth(float width)：设置该轴的网格线的宽度。&lt;/p&gt;
&lt;p&gt;setAxisLineColor(int color)：设置该轴的轴线的颜色。&lt;/p&gt;
&lt;p&gt;setAxisLineWidth(float width)：设置该轴的轴线的宽度。&lt;/p&gt;
&lt;p&gt;enableGridDashedLine(float lineLength, float spaceLength, float phase)：使用此绘制网格虚线，允许以虚线模式绘制网格线，例如“-– – – –-”。“ lineLength”控制线段的长度，“ spaceLength”控制线之间的间距，“ phase”控制起点。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;设定数据API&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果要向图表添加值（数据），则必须通过&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setData(ChartData data) { ... }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法。所述基类ChartData（ChartData）类封装被渲染期间所需图表的所有数据和信息。ChartData是所有数据类（子类），列如的基类LineData，BarData...等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;折线图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LineDataSet对象存放一条线的相关内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; LineDataSet(List&amp;lt;Entry&amp;gt; entries, String label) { ... }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LineDataSet需要一个List类型为Entry和的String来描述LineDataSet和，并将其作为用于的标签Legend&lt;/p&gt;
&lt;p&gt;其中Entry是x轴和y值在图表中的条目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Entry(&lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt; y) { ... }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;条形图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以为设置数据的方式BarChart与相似LineChart。主要区别在于需要用于设置数据的数据对象（例如BarEntry代替Entry）。除此之外，BarChart还有不同的样式选项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组条形图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从v3.0.0版本开始，MPAndroidChart支持显式分组的绘制条（在这种情况下，库将处理x位置）或用户定义的图形，这意味着用户可以通过更改绘制条的x位置来将其放置在所需的任何位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;积木条形图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆叠的BarChart设置与普通设置非常相似，只是创建BarChart单个BarEntry对象的方式不同。如果是堆叠式钢筋，BarEntry则必须使用的其他构造函数：&lt;/p&gt;
&lt;p&gt;public BarEntry （float x，float [] values ）{ ... }&lt;/p&gt;
&lt;p&gt;此构造函数允许values为y轴提供多个（数组），它们表示每个条形的“堆栈”的值，数组中的一个值是堆栈的一部分。考虑以下示例：&lt;/p&gt;
&lt;p&gt;BarEntry stackedEntry = new BarEntry(0f, new float[] { 10, 20, 30 });&lt;/p&gt;
&lt;p&gt;它BarEntry的x轴位置为0f，由三个值的堆栈组成，在y轴上的“高度”分别为“ 10”，“ 20”和“ 30”，累积的条形值/高度为60（ 10 + 20 + 30）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;饼图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与其他图表类型不同，PieChart汇整采用PieEntry对象形式的数据。这些对象的构造函数如下所示：&lt;/p&gt;
&lt;p&gt;public PieEntry(float value, String label) { ... }&lt;/p&gt;
&lt;p&gt;构造函数的第一个参数用于实际的“值”，该值应在中绘制为扇形&lt;code&gt;PieChart&lt;/code&gt;。第二个&lt;code&gt;String&lt;/code&gt;参数称为“标签”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据单位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LargeValueFormatter：可用于格式化大于“ 1.000”的大值。它将诸如“ 1.000”的值转换为“ 1k”，“ 1.000.000”将为“ 1m”（百万），“ 1.000.000.000”将为“ 1b”（十亿），诸如一万亿的值将为“ 1t” ”。&lt;/p&gt;
&lt;p&gt;PercentFormatter：用于在每个带有1个小数位的值之后显示一个“％”符号。对于尤其有用PieChart。50-&amp;gt; 50.0％&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;数据对象样式&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;图内文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setValueTextColor(int color)：设置所有DataSets此数据对象包含的值文本的颜色（绘制值标签的颜色）。&lt;/p&gt;
&lt;p&gt;setValueTextColors(List&amp;lt;Integer&amp;gt; colors)：设置用作值颜色的颜色列表&lt;/p&gt;
&lt;p&gt;setValueTextSize(float size)：设置所有DataSets此数据对象包含的值文本的大小（以dp为单位）&lt;/p&gt;
&lt;p&gt;setDrawValues(boolean enabled)：启用/禁用所有DataSets此数据对象包含的图形值（值文本）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据查找&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getDataSetByIndex(int index)：返回DataSet数据对象DataSet列表中给定索引处的对象。&lt;/p&gt;
&lt;p&gt;contains(Entry entry)：检查此数据对象是否包含指定的Entry。如果是，则返回true，否则返回false。注意：此功能的性能相当差，在性能关键的情况下不要过度使用。&lt;/p&gt;
&lt;p&gt;contains(T dataSet)：如果此数据对象包含提供的值DataSet，则返回true，否则返回false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;clearValues()：清除所有DataSet对象的数据对象，从而清除所有对象Entries。不删除提供的x值&lt;/p&gt;
&lt;p&gt;突出线上&lt;/p&gt;
&lt;p&gt;setHighlightEnabled(boolean enabled)：将其设置为true以允许通过触摸突出显示该ChartData对象和所有底层对象DataSets。&lt;/p&gt;
&lt;p&gt;setDrawVerticalHighlightIndicator(boolean enabled)：启用/禁用垂直高亮指示线。如果禁用，则不会绘制指示器。&lt;/p&gt;
&lt;p&gt;setDrawHorizontalHighlightIndicator(boolean enabled)：启用/禁用水平高光指示线。如果禁用，则不会绘制指示器。&lt;/p&gt;
&lt;p&gt;setHighLightColor(int color)；设置指示线的颜色&lt;/p&gt;
&lt;p&gt;setHighlightLineWidth(float width) 设置指示线的线宽，以dp设置高亮线（十字线）的宽度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图线条（线图）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setLineWidth(float width)：为此数据集设置线宽（最小值= 0.2f，最大值= 10f）；默认值1f注意：较细的线==更好的性能，较粗的线==性能差&lt;/p&gt;
&lt;p&gt;setColor(int color); 在线图中可以设置线的颜色&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;填充区域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线图的填充必须要setDrawFilled设置为true&lt;/p&gt;
&lt;p&gt;setDrawFilled(boolean filled)：将DataSet绘制为实心（曲面，面积），而不仅仅是将其绘制为直线时，将其设置为true，禁用此设置将提高性能。请注意，此方法使用canvas.clipPath(...)绘制填充区域的方法。对于API级别&amp;lt;18（Android 4.3）的设备，应关闭图表的硬件加速-参见此处。默认值：false&lt;/p&gt;
&lt;p&gt;setFillColor(int color)：设置用于填充线条表面的颜色。&lt;/p&gt;
&lt;p&gt;setFillAlpha(int alpha)：设置用于填充线表面（0-255）的Alpha值（透明度），默认值：85、255 =完全不透明，0 =完全透明&lt;/p&gt;
&lt;p&gt;setFillDrawable(Drawable d)：设置一个Drawable应覆盖填充区域的。这也允许使用渐变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LineDataSet（类LineDataSet）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setCircleRadius(float size)：设置圆形值指示器的大小（半径），默认大小= 4f&lt;/p&gt;
&lt;p&gt;setDrawCircles(boolean enabled)：将其设置为true可以为此绘制圆形指示器LineDataSet，默认为true&lt;/p&gt;
&lt;p&gt;setDrawCubic(boolean enabled)：如果设置为true，则折线图将以立方样式而不是线性样式绘制。这会对性能产生负面影响！默认值：false&lt;/p&gt;
&lt;p&gt;setCubicIntensity(float intensity)：设置立方线的强度（如果启用）。最大值= 1f =非常立方，最小值= 0.05f =低立方效应，默认值：0.2f&lt;/p&gt;
&lt;p&gt;setCircleColor(int color)：设置此数据集所有圆圈指示器应具有的颜色。&lt;/p&gt;
&lt;p&gt;setCircleColors(List&amp;lt;Integer&amp;gt; colors)：设置其外圆LineDataSet应具有的颜色。还有其他各种设置圆形颜色的方法。&lt;/p&gt;
&lt;p&gt;setCircleColorHole(int color)：设置直线圆（孔）的内圆的颜色。&lt;/p&gt;
&lt;p&gt;setDrawCircleHole(boolean enabled)：将其设置为true以允许在此数据集的每个圆中绘制孔。如果设置为false，则将绘制填充的圆圈（无孔）。&lt;/p&gt;
&lt;p&gt;enableDashedLine(float lineLength, float spaceLength, float phase)：允许以虚线模式绘制线条，例如“-– – – –-”。“ lineLength”是线段的长度，“ spaceLength”是线段之间的间隔的长度，“ phase”是偏移量，以度为单位（通常使用0）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BarDataSet（类BarDataSet）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setBarSpacePercent(float percent)：设置条之间的间隔，以条总宽度的百分比表示。&lt;/p&gt;
&lt;p&gt;setBarShadowColor(int color)：设置用于绘制条形阴影的颜色。条形阴影是条形后面的表面，指示最大值。不要用它getResources().getColor(...)来设置它。或者Color.rgb(...)。&lt;/p&gt;
&lt;p&gt;setHighLightAlpha(int alpha)：设置用于绘制突出显示指示条的Alpha值（透明度）。最小值= 0（完全透明），最大值= 255（完全不透明）。&lt;/p&gt;
&lt;p&gt;setStackLabels(String[] labels)：为标签设置不同的条形纸叠（如果有的话）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PieDataSet（类PieDataSet）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setSliceSpace(float degrees)：设置dp中的饼图切片之间留出的空间，默认值：0 –&amp;gt;无空间，最大20，最小0（无空间）&lt;/p&gt;
&lt;p&gt;setSelectionShift(float shift)：设置此数据集的突出显示的饼图切片与图表中心的距离，默认为12f&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;其它样式&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;invalidate()：在图表上调用此方法将刷新（重画）它。为了使图表上执行的更改生效，这是必需的。&lt;/p&gt;
&lt;p&gt;notifyDataSetChanged()：让图表知道其基础数据已更改，并执行所有必要的重新计算（偏移量，图例，最大值，最小值等）。特别是在动态添加数据时，这是必需的。&lt;/p&gt;
&lt;p&gt;setBackgroundColor(int color)：设置将覆盖整个图表视图的背景颜色。另外，可以.xml在布局文件中通过设置背景色。&lt;/p&gt;
&lt;p&gt;setDescription(String desc)：设置描述文字，该文字显示在图表的右下角。&lt;/p&gt;
&lt;p&gt;setDescriptionColor(int color)：设置说明文字的颜色。&lt;/p&gt;
&lt;p&gt;setDescriptionPosition(float x, float y)：在屏幕上以像素为单位设置描述文本的自定义位置。&lt;/p&gt;
&lt;p&gt;setDescriptionTypeface(Typeface t)：设置Typeface用于绘制描述文本。&lt;/p&gt;
&lt;p&gt;setDescriptionTextSize(float size)：设置说明文字的大小（以像素为单位），最小6f，最大16f。&lt;/p&gt;
&lt;p&gt;setNoDataText(String text)：设置图表为空时应显示的文本。&lt;/p&gt;
&lt;p&gt;setDrawGridBackground(boolean enabled)：如果启用，将在图表绘图区域后面绘制背景矩形。&lt;/p&gt;
&lt;p&gt;setGridBackgroundColor(int color)：设置绘制网格背景的颜色。&lt;/p&gt;
&lt;p&gt;setDrawBorders(boolean enabled)：启用/禁用绘制图表边框（图表周围的线）。&lt;/p&gt;
&lt;p&gt;setBorderColor(int color)：设置图表边框线的颜色。&lt;/p&gt;
&lt;p&gt;setBorderWidth(float width)：以dp设置图表边界线的宽度。&lt;/p&gt;
&lt;p&gt;setMaxVisibleValueCount(int count)：设置图表上最大可见绘制值标签的数量。这仅在setDrawValues()启用时生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线图，条形图，散点图，蜡烛图和气泡图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setAutoScaleMinMaxEnabled(boolean enabled)：用于指示是否启用y轴自动缩放的标志。如果启用，则每当视口更改时，y轴就会自动调整为当前x轴范围的最小和最大y值。对于显示财务数据的图表而言，这尤其有趣。默认值：false&lt;/p&gt;
&lt;p&gt;setKeepPositionOnRotation(boolean enabled)：设置方向更改后图表是否应保持其位置（缩放/滚动）。默认值：false&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条形图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setDrawValueAboveBar(boolean enabled)：如果设置为true，则所有值均绘制在其条形上方，而不是其顶部下方。&lt;/p&gt;
&lt;p&gt;setDrawBarShadow(boolean enabled)：如果设置为true，则在每个条后面绘制一个灰色区域，指示最大值。启用他的功能会使性能降低约40％。&lt;/p&gt;
&lt;p&gt;setDrawValuesForWholeStack(boolean enabled)：如果设置为true，则将分别绘制堆叠条形图的所有值，而不仅仅是总和。&lt;/p&gt;
&lt;p&gt;setDrawHighlightArrow(boolean enabled)：将其设置为true可以在突出显示时在每个栏上方绘制突出显示箭头&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;饼形图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setDrawSliceText(boolean enabled)：将其设置为true可将x值文本绘制到饼图中。&lt;/p&gt;
&lt;p&gt;setUsePercentValues(boolean enabled)：如果启用此功能，则图表内的值将以百分比而不是原始值绘制。ValueFormatter然后，以百分比形式提供为to格式提供的值。&lt;/p&gt;
&lt;p&gt;setCenterText(SpannableString text)：设置在PieChart中心绘制的文本。较长的文本将被自动“包装”，以避免被剪切成饼状。&lt;/p&gt;
&lt;p&gt;setCenterTextRadiusPercent(float percent)：设置中心文本的边框的矩形半径，以饼孔默认1.f（100％）的百分比表示。&lt;/p&gt;
&lt;p&gt;setHoleRadius(float percent)：以最大半径的百分比（最大值=整个图表的半径）设置饼图中心的孔的半径，默认为50％&lt;/p&gt;
&lt;p&gt;setTransparentCircleRadius(float percent)：以最大半径的百分比（最大值=整个图表的半径）设置在圆形图中绘制的孔旁边的透明圆的半径，默认为55％-&amp;gt;表示比中心孔大5％默认&lt;/p&gt;
&lt;p&gt;setTransparentCircleColor(int color)：设置透明圆圈的颜色。&lt;/p&gt;
&lt;p&gt;setTransparentCircleAlpha(int alpha)：设置透明圆圈应具有的透明度（0-255）。&lt;/p&gt;
&lt;p&gt;setMaxAngle(float maxangle)：设置用于计算扇形圆的最大角度。360f表示已满PieChart，180f表示半饼图。默认值：360f&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;图例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;图例是每个数据对象的指示，如饼状图中每个颜色的扇区指示是有图例完成的&lt;/p&gt;
&lt;p&gt;默认情况下，所有图表类型都支持图例，并且在为图表设置数据后将自动生成并绘制图例。的Legend通常由通过一个标签的形式/形状表示多个条目的每一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取图表的图例对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了自定义Legend，您可以Legend使用getLegend()方法从图表中检索对象：&lt;/p&gt;
&lt;p&gt;Legend legend = chart.getLegend();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制是否应绘制图例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setEnabled(boolean enabled)：设置Legend启用或禁用。如果禁用，Legend将不会绘制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样式/修改图例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setTextColor(int color)：设置图例标签的颜色。&lt;/p&gt;
&lt;p&gt;setTextSize(float size)：在dp中设置图例标签的文本大小。&lt;/p&gt;
&lt;p&gt;setTypeface(Typeface tf)：设置Typeface图例标签的自定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修剪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setWordWrapEnabled(boolean enabled)：如果启用，图例的内容将不会裁剪到图表范围之外，而是创建新的一行。请注意，这会降低性能，并且仅适用于图表下方的图例。&lt;/p&gt;
&lt;p&gt;setMaxSizePercent(float maxSize)：以百分比为单位设置整个图表视图中的最大相对大小。默认值：0.95f（95％）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义图例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setPosition(LegendPosition pos)：设置，LegendPosition以定义Legend应该出现的位置。在RIGHT_OF_CHART，RIGHT_OF_CHART_CENTER，RIGHT_OF_CHART_INSIDE，BELOW_CHART_LEFT，BELOW_CHART_RIGHT，BELOW_CHART_CENTER或PIECHART_CENTER中选择（PieChart…），等等。&lt;/p&gt;
&lt;p&gt;setForm(LegendForm shape)：设置LegendForm应使用的。这是图例标签旁边用DataSet图例条目代表的颜色绘制的形状。在SQUARE，CIRCLE或LINE之间选择。&lt;/p&gt;
&lt;p&gt;setFormSize(float size)：以dp设置图例形式的大小。&lt;/p&gt;
&lt;p&gt;setXEntrySpace(float space)：设置水平轴上图例项之间的间隔。&lt;/p&gt;
&lt;p&gt;setYEntrySpace(float space)：设置垂直轴上图例条目之间的间隔。&lt;/p&gt;
&lt;p&gt;setFormToTextSpace(float space)：设置图例标签和相应的图例形式之间的空间。&lt;/p&gt;
&lt;p&gt;setWordWrapEnabled(boolean enabled)：传奇文字应该换行吗？/当前仅以下，左下，右下，中图中心支持此功能。/您可能希望在自动换行时设置maxSizePercent，以设置文本自动换行的点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置自定义标签和颜色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setCustom(int[] colors, String[] labels)：设置自定义图例的标签和颜色数组。颜色计数应与标签计数匹配。每种颜色都是针对在相同索引处绘制的表单。空标签将启动一个组。（-2）颜色将避免绘制表单。这将禁用自动从数​​据集中计算图例标签和颜色的功能。调用resetCustom()以重新启用自动计算（然后notifyDataSetChanged()需要再次自动计算图例）&lt;/p&gt;
&lt;p&gt;resetCustom()：调用此选项将禁用自定义图例标签（由设置setCustom(...)）。而是，标签将再次自动计算（notifyDataSetChanged()调用后）。&lt;/p&gt;
&lt;p&gt;setExtra(int[] colors, String[] labels)：设置在计算图例后将设置在自动计算的颜色和标签数组末尾的颜色和标签。（如果已经计算了图例，则需要致电notifyDataSetChanged()以使更改生效）&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;获取描述对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Description description = chart.getDescription();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setEnabled(boolean enabled)启用或禁用描述&lt;/p&gt;
&lt;p&gt;setText(string str)设置描述文字&lt;/p&gt;
&lt;p&gt;setPosition（float x，float y）设置说明在屏幕上的位置&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;折线图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200521000847730-574705194.png&quot; alt=&quot;&quot; width=&quot;434&quot; height=&quot;445&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.github.mikephil.charting.charts.LineChart
    android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/chart&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找到控件&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; LineChart dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; dongxiaodongchart.getAxisRight().setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y轴右边不显示&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; dongxiaodongchart.getXAxis().setPosition(XAxis.XAxisPosition.BOTTOM);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只在图表下面显示x轴
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个数据集&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; List&amp;lt;Entry&amp;gt; valsComp1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Entry&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据集1&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; Entry(1,2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; Entry(1.2f,3.9f&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; Entry(2f,6&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; List&amp;lt;Entry&amp;gt; valsComp2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Entry&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据集2&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; valsComp2.add(&lt;span&gt;new&lt;/span&gt; Entry(1,2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; valsComp2.add(&lt;span&gt;new&lt;/span&gt; Entry(2.2f,3.9f&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; valsComp2.add(&lt;span&gt;new&lt;/span&gt; Entry(3f,6&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个线对象&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; LineDataSet setComp1 = &lt;span&gt;new&lt;/span&gt; LineDataSet(valsComp1, &quot;东小东1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; LineDataSet setComp2 = &lt;span&gt;new&lt;/span&gt; LineDataSet(valsComp2, &quot;东小东2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线对象的样式（更多见：数据对象样式 ）&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; setComp1.setColor(Color.RED);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置线的颜色&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; setComp2.setCircleRadius(10);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置数据点的大小
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据显示&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; LineData data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LineData(setComp1,setComp2);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;dongxiaodongchart.setData(data);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; dongxiaodongchart.invalidate();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;带颜色填充的折线图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200521001031290-2146099345.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;494&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.github.mikephil.charting.charts.LineChart
    android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/chart&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找到控件&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; LineChart dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; dongxiaodongchart.getAxisRight().setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y轴右边不显示&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; dongxiaodongchart.getXAxis().setPosition(XAxis.XAxisPosition.BOTTOM);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只在图表下面显示x轴
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个数据集&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; List&amp;lt;Entry&amp;gt; valsComp1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Entry&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据集1&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; Entry(1,2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; Entry(1.2f,3.9f&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; Entry(2f,6&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; List&amp;lt;Entry&amp;gt; valsComp2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Entry&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据集2&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; valsComp2.add(&lt;span&gt;new&lt;/span&gt; Entry(1,2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; valsComp2.add(&lt;span&gt;new&lt;/span&gt; Entry(2.2f,3.9f&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; valsComp2.add(&lt;span&gt;new&lt;/span&gt; Entry(3f,6&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个线对象&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; LineDataSet setComp1 = &lt;span&gt;new&lt;/span&gt; LineDataSet(valsComp1, &quot;东小东1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; LineDataSet setComp2 = &lt;span&gt;new&lt;/span&gt; LineDataSet(valsComp2, &quot;东小东2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线对象的样式（更多见：数据对象样式 ）&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; setComp1.setColor(Color.RED);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置线的颜色&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; setComp1.setDrawFilled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; setComp2.setDrawFilled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;setComp2.setFillColor(Color.YELLOW);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据显示&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; LineData data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LineData(setComp1,setComp2);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;dongxiaodongchart.setData(data);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; dongxiaodongchart.invalidate();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;span&gt;&lt;strong&gt;条形图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200521001149128-934408407.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;459&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;视图 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.github.mikephil.charting.charts.BarChart
    android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/chart&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找到控件&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; BarChart dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不显示描述&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; dongxiaodongchart.getDescription().setEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;y轴右边关闭&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; dongxiaodongchart.getAxisRight().setEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x轴设置无网格&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; XAxis xAxis =&lt;span&gt; dongxiaodongchart.getXAxis();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; xAxis.setDrawGridLines(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; xAxis.setGranularity(1f); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在放大到为轴设置的小数位数不再允许在两个轴值之间进行区分的点时，可以使用此方法来避免值重复。
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个数据集&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; List&amp;lt;BarEntry&amp;gt; valsComp1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;BarEntry&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据集1&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; BarEntry(1,2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; BarEntry(3f,3.9f&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; BarEntry(5f,6&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建条形图对象&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; BarDataSet setComp1 = &lt;span&gt;new&lt;/span&gt; BarDataSet(valsComp1, &quot;东小东1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;setComp1.setColor(Color.RED);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据显示&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; BarData data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BarData(setComp1);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; dongxiaodongchart.setData(data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置数据&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; dongxiaodongchart.invalidate();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置动画样式&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; dongxiaodongchart.animateY(2000,Easing. EaseInOutQuad);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;span&gt;&lt;strong&gt;分组条形图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200521001301007-779684319.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;454&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;视图 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.github.mikephil.charting.charts.BarChart
    android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/chart&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找到控件&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; BarChart dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置颜色图标在右上角显示，默认是在图表底部并排显示&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; Legend l =&lt;span&gt; dongxiaodongchart.getLegend();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;l.setVerticalAlignment(Legend.LegendVerticalAlignment.TOP);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;l.setHorizontalAlignment(Legend.LegendHorizontalAlignment.RIGHT);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;l.setOrientation(Legend.LegendOrientation.VERTICAL);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; l.setDrawInside(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;l.setYOffset(0f);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;l.setXOffset(10f);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;l.setYEntrySpace(0f);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;l.setTextSize(8f);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴设置&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; dongxiaodongchart.getAxisRight().setEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;X轴设置&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; XAxis xAxis = dongxiaodongchart.getXAxis();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到x轴对象&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; xAxis.setGranularity(1f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置网格宽度&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; xAxis.setCenterAxisLabels(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为刻度显示在网格中间&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只在图表下面显示&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; dongxiaodongchart.getDescription().setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不显示描述&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; groupSpace = 0.08f;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组间隔&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; barSpace = 0.03f; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个柱状图的间隔&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; barWidth = 0.2f; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个柱状图的宽度
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (0.2 + 0.03) * 4 + 0.08 = 1.00 -&amp;gt; interval per &quot;group&quot;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;-----数据-----&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; groupCount = 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; startYear = 1998&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; endYear = startYear +&lt;span&gt; groupCount;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; ArrayList&amp;lt;BarEntry&amp;gt; values1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; ArrayList&amp;lt;BarEntry&amp;gt; values2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; ArrayList&amp;lt;BarEntry&amp;gt; values3 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; ArrayList&amp;lt;BarEntry&amp;gt; values4 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; randomMultiplier = 6 * 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = startYear; i &amp;lt; endYear; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     values1.add(&lt;span&gt;new&lt;/span&gt; BarEntry(i, (&lt;span&gt;float&lt;/span&gt;) (Math.random() *&lt;span&gt; randomMultiplier)));
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     values2.add(&lt;span&gt;new&lt;/span&gt; BarEntry(i, (&lt;span&gt;float&lt;/span&gt;) (Math.random() *&lt;span&gt; randomMultiplier)));
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     values3.add(&lt;span&gt;new&lt;/span&gt; BarEntry(i, (&lt;span&gt;float&lt;/span&gt;) (Math.random() *&lt;span&gt; randomMultiplier)));
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     values4.add(&lt;span&gt;new&lt;/span&gt; BarEntry(i, (&lt;span&gt;float&lt;/span&gt;) (Math.random() *&lt;span&gt; randomMultiplier)));
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置样式和生成柱状图对象&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;BarDataSet set1, set2, set3, set4;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; set1 = &lt;span&gt;new&lt;/span&gt; BarDataSet(values1, &quot;东小东A&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; set1.setColor(Color.rgb(104, 241, 175&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; set2 = &lt;span&gt;new&lt;/span&gt; BarDataSet(values2, &quot;东小东B&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; set2.setColor(Color.rgb(164, 228, 251&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; set3 = &lt;span&gt;new&lt;/span&gt; BarDataSet(values3, &quot;东小东C&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; set3.setColor(Color.rgb(242, 247, 158&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; set4 = &lt;span&gt;new&lt;/span&gt; BarDataSet(values4, &quot;东小东D&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; set4.setColor(Color.rgb(255, 102, 0&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据显示&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; BarData data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BarData(set1, set2, set3, set4);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;dongxiaodongchart.setData(data);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置柱状宽度&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;dongxiaodongchart.getBarData().setBarWidth(barWidth);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置刻度最小值&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;dongxiaodongchart.getXAxis().setAxisMinimum(startYear);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置刻度最大值&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; dongxiaodongchart.getXAxis().setAxisMaximum(startYear + dongxiaodongchart.getBarData().getGroupWidth(groupSpace, barSpace) *&lt;span&gt; groupCount);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;组适配&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;dongxiaodongchart.groupBars(startYear, groupSpace, barSpace);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; dongxiaodongchart.invalidate();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新数据
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置动画样式&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt; dongxiaodongchart.animateY(2000,Easing. EaseInOutQuad);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;span&gt;积木条形图&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200521001433902-1934501976.png&quot; alt=&quot;&quot; width=&quot;478&quot; height=&quot;480&quot;/&gt;&lt;/h3&gt;
&lt;p&gt; 视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.github.mikephil.charting.charts.BarChart
    android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/chart&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找到控件&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; BarChart dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不显示描述&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; dongxiaodongchart.getDescription().setEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;y轴右边关闭&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; YAxis leftAxis =&lt;span&gt; dongxiaodongchart.getAxisLeft();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; leftAxis.setAxisMinimum(0f); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从零开始&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; dongxiaodongchart.getAxisRight().setEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x轴设置无网格&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; XAxis xAxis =&lt;span&gt; dongxiaodongchart.getXAxis();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; xAxis.setDrawGridLines(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; xAxis.setGranularity(1f); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在放大到为轴设置的小数位数不再允许在两个轴值之间进行区分的点时，可以使用此方法来避免值重复。
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个数据集&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; List&amp;lt;BarEntry&amp;gt; valsComp1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;BarEntry&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据集1&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; BarEntry(-2f,&lt;span&gt;new&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;[] { 5, 20, 4&lt;span&gt; }));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; BarEntry(0f,&lt;span&gt;new&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;[] { 10,6, 3&lt;span&gt; }));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; BarEntry(2f,&lt;span&gt;new&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;[] { 10, 20, 7&lt;span&gt; }));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建条形图对象&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; BarDataSet setComp1 = &lt;span&gt;new&lt;/span&gt; BarDataSet(valsComp1, &quot;东小东1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; setComp1.setDrawIcons(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; setComp1.setColors(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]{Color.RED,Color.GREEN,Color.BLUE });
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; setComp1.setStackLabels(&lt;span&gt;new&lt;/span&gt; String[]{&quot;东1&quot;, &quot;东2&quot;, &quot;东3&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; ArrayList&amp;lt;IBarDataSet&amp;gt; dataSets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;dataSets.add(setComp1);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; BarData data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BarData(dataSets);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;dongxiaodongchart.setData(data);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; dongxiaodongchart.setFitBars(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;dongxiaodongchart.invalidate();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置动画样式&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; dongxiaodongchart.animateY(2000,Easing. EaseInOutQuad);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;span&gt;饼形图&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200521001603724-1127255981.png&quot; alt=&quot;&quot; width=&quot;418&quot; height=&quot;425&quot;/&gt;&lt;/h3&gt;
&lt;p&gt; 视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.github.mikephil.charting.charts.PieChart
    android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/chart&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找到控件&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; PieChart dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;圆环中间显示&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; dongxiaodongchart.setCenterText(&quot;东小东\n主要标题&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; dongxiaodongchart.setCenterTextSize(15&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;边距设置&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; dongxiaodongchart.setExtraOffsets(20.f, 10.f, 20&lt;span&gt;.f, 10f);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据线条&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;dongxiaodongchart.setHoleRadius(58f);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;dongxiaodongchart.setTransparentCircleRadius(61f);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色标识显示&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; Legend l =&lt;span&gt; dongxiaodongchart.getLegend();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;l.setVerticalAlignment(Legend.LegendVerticalAlignment.TOP);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;l.setHorizontalAlignment(Legend.LegendHorizontalAlignment.RIGHT);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;l.setOrientation(Legend.LegendOrientation.VERTICAL);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;l.setDrawInside(false);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加不显示
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;l.setEnabled(false);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; List&amp;lt;PieEntry&amp;gt; list=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; list.add(&lt;span&gt;new&lt;/span&gt; PieEntry(30,&quot;东1&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; list.add(&lt;span&gt;new&lt;/span&gt; PieEntry(30,&quot;东2&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; list.add(&lt;span&gt;new&lt;/span&gt; PieEntry(40,&quot;东3&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; PieDataSet pieDataSet=&lt;span&gt;new&lt;/span&gt; PieDataSet(list,&quot;数据标题&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置样式&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; pieDataSet.setColors(Color.RED,Color.GRAY,Color.CYAN);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置各个数据的颜色
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为值外部显示,注释则内部显示&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;pieDataSet.setYValuePosition(PieDataSet.ValuePosition.OUTSIDE_SLICE);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; pieDataSet.setValueLineColor(Color.RED);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;值引线为红色&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; pieDataSet.setValueTextSize(30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出值&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; PieData data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PieData(pieDataSet);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; data.setValueTextSize(11f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示值的大小&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; data.setValueTextColor(Color.BLUE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示值的颜色&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; dongxiaodongchart.setData(data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置数据&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; dongxiaodongchart.invalidate();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;span&gt;全饼图&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200521001722148-1582623918.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.github.mikephil.charting.charts.PieChart
    android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/chart&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找到控件&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; PieChart dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; dongxiaodongchart.getDescription().setText(&quot;东小东图表描述字段&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;外边距设置&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; dongxiaodongchart.setExtraOffsets(20.f, 10.f, 20&lt;span&gt;.f, 10f);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;图例&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; Legend l =&lt;span&gt; dongxiaodongchart.getLegend();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;l.setVerticalAlignment(Legend.LegendVerticalAlignment.TOP);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;l.setHorizontalAlignment(Legend.LegendHorizontalAlignment.RIGHT);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;l.setOrientation(Legend.LegendOrientation.VERTICAL);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; List&amp;lt;PieEntry&amp;gt; list=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; list.add(&lt;span&gt;new&lt;/span&gt; PieEntry(300,&quot;东1&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; list.add(&lt;span&gt;new&lt;/span&gt; PieEntry(300,&quot;东2&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; list.add(&lt;span&gt;new&lt;/span&gt; PieEntry(700,&quot;东3&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; PieDataSet pieDataSet=&lt;span&gt;new&lt;/span&gt; PieDataSet(list,&quot;数据标题&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置样式&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; pieDataSet.setColors(Color.RED,Color.GRAY,Color.CYAN);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置各个数据的颜色
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出值&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; PieData data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PieData(pieDataSet);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据显示大小&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; data.setValueTextSize(11f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示值的大小&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; data.setValueTextColor(Color.WHITE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示值
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置显示单位为%&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; data.setValueFormatter(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PercentFormatter(dongxiaodongchart));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置开启百分比显示&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; dongxiaodongchart.setUsePercentValues(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中心圆设置&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; dongxiaodongchart.setHoleRadius(1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中心圆半径为1%&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; dongxiaodongchart.setTransparentCircleRadius(0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中心半透明圆半径为0%
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据刷新显示&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; dongxiaodongchart.setData(data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置数据&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; dongxiaodongchart.invalidate();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;动态数据线图&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200521001833957-122484172.png&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;652&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout
    &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;300dp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.github.mikephil.charting.charts.LineChart
    android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/chart&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button
    &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
    android:text&lt;/span&gt;&lt;span&gt;=&quot;添加一条新数据&quot;&lt;/span&gt;&lt;span&gt;
    android:onClick&lt;/span&gt;&lt;span&gt;=&quot;ButADD&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_marginTop&lt;/span&gt;&lt;span&gt;=&quot;30dp&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button
&lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
android:text&lt;/span&gt;&lt;span&gt;=&quot;刷新所有数据&quot;&lt;/span&gt;&lt;span&gt;
android:onClick&lt;/span&gt;&lt;span&gt;=&quot;ButREF&quot;&lt;/span&gt;&lt;span&gt;
android:layout_marginTop&lt;/span&gt;&lt;span&gt;=&quot;30dp&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找到控件&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; dongxiaodongchart =&lt;span&gt; findViewById(R.id.chart);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图标坐标样式&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; dongxiaodongchart.getAxisRight().setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y轴右边不显示&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; dongxiaodongchart.getXAxis().setPosition(XAxis.XAxisPosition.BOTTOM);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只在图表下面显示x轴
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶部的线，最高限值虚线&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; LimitLine ll1 = &lt;span&gt;new&lt;/span&gt; LimitLine(3f, &quot;最高限值&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是显示的y轴值&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; ll1.setLineWidth(2f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置线条宽度&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; ll1.enableDashedLine(10f, 10f, 0f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置虚线样式&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; ll1.setLabelPosition(LimitLine.LimitLabelPosition.RIGHT_TOP);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字体显示在线的上面&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; ll1.setTextSize(10f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字体大小
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;底部的线，最低限值虚线&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; LimitLine ll2 = &lt;span&gt;new&lt;/span&gt; LimitLine(-2f, &quot;最低限值&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;ll2.setLineWidth(2f);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;ll2.enableDashedLine(10f, 10f, 0f);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;ll2.setLabelPosition(LimitLine.LimitLabelPosition.RIGHT_BOTTOM);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;ll2.setTextSize(10f);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取y轴对象&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; YAxis yAxis =&lt;span&gt; dongxiaodongchart.getAxisLeft();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表的y轴显示最大最小值范围&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;yAxis.setAxisMaximum(15f);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; yAxis.setAxisMinimum(-&lt;span&gt;5f);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始显示两条限值线&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;yAxis.addLimitLine(ll1);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;yAxis.addLimitLine(ll2);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个数据集&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; List&amp;lt;Entry&amp;gt; valsComp1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Entry&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据集1&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; Entry(1,2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; Entry(1.2f,3.9f&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; valsComp1.add(&lt;span&gt;new&lt;/span&gt; Entry(2f,6&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建线对象&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; LineDataSet setComp1 = &lt;span&gt;new&lt;/span&gt; LineDataSet(valsComp1, &quot;东小东1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线对象的样式（更多见：数据对象样式 ）&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; setComp1.setColor(Color.BLUE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置线的颜色&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; setComp1.setDrawFilled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据显示&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; LineData data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LineData(setComp1);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;dongxiaodongchart.setData(data);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;dongxiaodongchart.invalidate();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据刷新函数&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshvalue(){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建新的数据&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     ArrayList&amp;lt;Entry&amp;gt; values = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;float&lt;/span&gt; val = (&lt;span&gt;float&lt;/span&gt;) (Math.random() * 10)-4;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Math.random()：产生一个[0，1)&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         values.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry(i,val));
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取现在的线对象&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     LineDataSet set1=(LineDataSet)  dongxiaodongchart.getData().getDataSetByIndex(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置新的数据&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    set1.setValues(values);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知数据改变&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    set1.notifyDataSetChanged();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    dongxiaodongchart.getData().notifyDataChanged();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    dongxiaodongchart.notifyDataSetChanged();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新显示&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    dongxiaodongchart.invalidate();
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据加入一条函数&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addvalue(){
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取现在的线对象&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;     LineDataSet set1=(LineDataSet)  dongxiaodongchart.getData().getDataSetByIndex(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置随意的坐标值&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; x=&lt;span&gt; set1.getEntryCount();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; y = (&lt;span&gt;float&lt;/span&gt;) (Math.random() * 10)-4;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Math.random()：产生一个[0，1)
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个点&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;     set1.addEntry(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry(x,y));
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知数据改变&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    set1.notifyDataSetChanged();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    dongxiaodongchart.getData().notifyDataChanged();
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    dongxiaodongchart.notifyDataSetChanged();
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新显示&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    dongxiaodongchart.invalidate();
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按键事件监听&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ButADD(View v){
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;添加一条数据&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;    addvalue();
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ButREF(View v){
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;     Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;刷新所有数据显示&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    refreshvalue();
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/PhilJay/MPAndroidChart&quot;&gt;https://github.com/PhilJay/MPAndroidChart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://weeklycoding.com/mpandroidchart-documentation/&quot;&gt;https://weeklycoding.com/mpandroidchart-documentation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/qq_44720366/article/details/104583622&quot;&gt;https://blog.csdn.net/qq_44720366/article/details/104583622&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 20 May 2020 16:28:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>有些时候觉得一个人挺好的，可以更自由安排自己的时间； 有些时候觉得有个人挺好的，很多事情一个人做起来太没意思了，纵使心中澎湃，倾听的独有自己。 废话少说，直接上图 MPAndroidChart是啥 一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxiaodong/p/12927251.html</dc:identifier>
</item>
<item>
<title>Maven整合JaCoCo和Sonar，看看你的测试写够了没 - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/12927398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/12927398.html</guid>
<description>&lt;p&gt;单元测试是保证代码质量的重要一环，而如何衡量单元测试写得好不好呢？&lt;code&gt;覆盖率（Coverage）&lt;/code&gt;是一个重要指标。而&lt;code&gt;JaCoCo&lt;/code&gt;则是专门为&lt;code&gt;Java&lt;/code&gt;提供的用于检测测试覆盖率的工具，英文全称为&lt;code&gt;Java Code Coverage&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;本文将讲解如何在&lt;code&gt;Maven&lt;/code&gt;项目中整合&lt;code&gt;JaCoCo&lt;/code&gt;，并在&lt;code&gt;SonarQube&lt;/code&gt;中展示。&lt;code&gt;SonarQube&lt;/code&gt;的安装可以参考这篇文章：&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;https://www.pkslow.com/archives/docker-sonarqube&quot;&gt;Docker搭建代码检测平台SonarQube并检测maven项目&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;这里所讲的&lt;code&gt;覆盖率&lt;/code&gt;是指测试代码的覆盖率，这个指标有多种计算方式，如下是比较常用的有：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;行覆盖率：执行代码行数 / 总代码行数，判断有多少行代码被测试执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类覆盖率：执行的类 / 代码中类总个数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分支覆盖率：执行的逻辑分支数 / 总的分支数，一般用于检测是不是&lt;code&gt;lf/else&lt;/code&gt;都有测试覆盖；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;方法覆盖率：执行的方法数 / 代码总方法数，检测是否有方法被遗漏，构造方法也看作为方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;圈复杂度：用于判断代码结构的复杂程序，&lt;code&gt;JaCoCo&lt;/code&gt;不考虑异常处理的分支；一般认为圈复杂度大于10，就存在比较大的风险，严格要求不可大于15。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;颜色标识：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JaCoCo&lt;/code&gt;会通过颜色来标识代码覆盖情况，使其一目了然。红色表示没有覆盖，绿色表示已经覆盖，黄色表示部分覆盖。&lt;/p&gt;
&lt;p&gt;执行方式：&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;JaCoCo&lt;/code&gt;有多种方式：&lt;/p&gt;
&lt;p&gt;（1）直接通过命令执行：&lt;a href=&quot;https://www.eclemma.org/jacoco/trunk/doc/agent.html&quot;&gt;https://www.eclemma.org/jacoco/trunk/doc/agent.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）Ant执行：&lt;a href=&quot;https://www.eclemma.org/jacoco/trunk/doc/ant.html&quot;&gt;https://www.eclemma.org/jacoco/trunk/doc/ant.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（3）Maven执行：&lt;a href=&quot;https://www.eclemma.org/jacoco/trunk/doc/maven.html&quot;&gt;https://www.eclemma.org/jacoco/trunk/doc/maven.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（4）集成IDE执行：&lt;a href=&quot;https://www.eclemma.org/&quot;&gt;https://www.eclemma.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们接下来主要讲解&lt;code&gt;maven&lt;/code&gt;的方式。&lt;/p&gt;

&lt;h2 id=&quot;31-基础整合&quot;&gt;3.1 基础整合&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Maven&lt;/code&gt;整合&lt;code&gt;JaCoCo&lt;/code&gt;也容易，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.jacoco&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jacoco-maven-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;${jacoco.version}&amp;lt;/version&amp;gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;skip&amp;gt;${maven.test.skip}&amp;lt;/skip&amp;gt;
    &amp;lt;destFile&amp;gt;${basedir}/target/coverage-reports/jacoco-unit.exec&amp;lt;/destFile&amp;gt;
    &amp;lt;dataFile&amp;gt;${basedir}/target/coverage-reports/jacoco-unit.exec&amp;lt;/dataFile&amp;gt;
    &amp;lt;output&amp;gt;file&amp;lt;/output&amp;gt;
    &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
    &amp;lt;excludes&amp;gt;
      &amp;lt;exclude&amp;gt;com/pkslow/basic/containsperformance/**&amp;lt;/exclude&amp;gt;
      &amp;lt;exclude&amp;gt;com/pkslow/basic/ReadPropertiesFile&amp;lt;/exclude&amp;gt;
    &amp;lt;/excludes&amp;gt;

  &amp;lt;/configuration&amp;gt;
  &amp;lt;executions&amp;gt;
    &amp;lt;execution&amp;gt;
      &amp;lt;id&amp;gt;jacoco-initialize&amp;lt;/id&amp;gt;
      &amp;lt;goals&amp;gt;
        &amp;lt;goal&amp;gt;prepare-agent&amp;lt;/goal&amp;gt;
      &amp;lt;/goals&amp;gt;
      &amp;lt;phase&amp;gt;test-compile&amp;lt;/phase&amp;gt;
    &amp;lt;/execution&amp;gt;

    &amp;lt;execution&amp;gt;
      &amp;lt;id&amp;gt;jacoco-site&amp;lt;/id&amp;gt;
      &amp;lt;phase&amp;gt;verify&amp;lt;/phase&amp;gt;
      &amp;lt;goals&amp;gt;
        &amp;lt;goal&amp;gt;report&amp;lt;/goal&amp;gt;
      &amp;lt;/goals&amp;gt;
    &amp;lt;/execution&amp;gt;
  &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;mvn clean test&lt;/code&gt;，则会生成报告&lt;code&gt;target/coverage-reports/jacoco-unit.exec&lt;/code&gt;，但这是人不可读的，&lt;code&gt;Sonar&lt;/code&gt;可读的。&lt;code&gt;Intellij Idea&lt;/code&gt;也可以阅读，按照&lt;code&gt;Run--Show Code Coverage Data&lt;/code&gt;打开即可。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;mvn clean verify&lt;/code&gt;，就会生成报告&lt;code&gt;target/site/jacoco/&lt;/code&gt;，有多种格式，用浏览器打开&lt;code&gt;index.html&lt;/code&gt;文件可以方便查看。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202005/946674-20200521000525426-697562546.png&quot; alt=&quot;SonarQube&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;32-选择范围&quot;&gt;3.2 选择范围&lt;/h2&gt;
&lt;p&gt;指定某些类不执行检测：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;excludes&amp;gt;
  &amp;lt;exclude&amp;gt;com/pkslow/basic/containsperformance/**&amp;lt;/exclude&amp;gt;
  &amp;lt;exclude&amp;gt;com/pkslow/basic/ReadPropertiesFile&amp;lt;/exclude&amp;gt;
&amp;lt;/excludes&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;33-规则与阈值&quot;&gt;3.3 规则与阈值&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Rules&lt;/code&gt;标签可以指定检查阈值，比如类覆盖率必须为&lt;code&gt;100%&lt;/code&gt;。在&lt;code&gt;configuration&lt;/code&gt;里面配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;rules&amp;gt;
  &amp;lt;rule implementation=&quot;org.jacoco.maven.RuleConfiguration&quot;&amp;gt;
    &amp;lt;element&amp;gt;BUNDLE&amp;lt;/element&amp;gt;
    &amp;lt;limits&amp;gt;　　
      &amp;lt;limit implementation=&quot;org.jacoco.report.check.Limit&quot;&amp;gt;
        &amp;lt;counter&amp;gt;METHOD&amp;lt;/counter&amp;gt;
        &amp;lt;value&amp;gt;COVEREDRATIO&amp;lt;/value&amp;gt;
        &amp;lt;minimum&amp;gt;0.50&amp;lt;/minimum&amp;gt;
      &amp;lt;/limit&amp;gt;
      &amp;lt;limit implementation=&quot;org.jacoco.report.check.Limit&quot;&amp;gt;
        &amp;lt;counter&amp;gt;BRANCH&amp;lt;/counter&amp;gt;
        &amp;lt;value&amp;gt;COVEREDRATIO&amp;lt;/value&amp;gt;
        &amp;lt;minimum&amp;gt;0.50&amp;lt;/minimum&amp;gt;
      &amp;lt;/limit&amp;gt;
      &amp;lt;limit implementation=&quot;org.jacoco.report.check.Limit&quot;&amp;gt;
        &amp;lt;counter&amp;gt;CLASS&amp;lt;/counter&amp;gt;
        &amp;lt;value&amp;gt;MISSEDCOUNT&amp;lt;/value&amp;gt;
        &amp;lt;maximum&amp;gt;0&amp;lt;/maximum&amp;gt;
      &amp;lt;/limit&amp;gt;
    &amp;lt;/limits&amp;gt;
  &amp;lt;/rule&amp;gt;
&amp;lt;/rules&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时需要有下面的&lt;code&gt;check&lt;/code&gt;才会执行这个规则校验：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;execution&amp;gt;
  &amp;lt;id&amp;gt;check&amp;lt;/id&amp;gt;
  &amp;lt;goals&amp;gt;
    &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt;
  &amp;lt;/goals&amp;gt;
&amp;lt;/execution&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不满足条件，&lt;code&gt;maven build&lt;/code&gt;就会失败。不过，如果我们集成了&lt;code&gt;SonarQube&lt;/code&gt;，我们则会通过&lt;code&gt;SonarQube&lt;/code&gt;来设置这个规则和阈值。&lt;/p&gt;

&lt;p&gt;添加&lt;code&gt;SonarQube&lt;/code&gt;配置信息如下，有三种配置方式：&lt;/p&gt;
&lt;p&gt;（1）配置数据库信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;profiles&amp;gt;
  &amp;lt;profile&amp;gt;
    &amp;lt;id&amp;gt;sonar&amp;lt;/id&amp;gt;
    &amp;lt;activation&amp;gt;
      &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;
    &amp;lt;/activation&amp;gt;
    &amp;lt;properties&amp;gt;
      &amp;lt;sonar.jdbc.url&amp;gt;jdbc:postgresql://localhost/sonar&amp;lt;/sonar.jdbc.url&amp;gt;
      &amp;lt;sonar.jdbc.driver&amp;gt;org.postgresql.Driver&amp;lt;/sonar.jdbc.driver&amp;gt;
      &amp;lt;sonar.jdbc.username&amp;gt;user&amp;lt;/sonar.jdbc.username&amp;gt;
      &amp;lt;sonar.jdbc.password&amp;gt;password&amp;lt;/sonar.jdbc.password&amp;gt;
      &amp;lt;sonar.host.url&amp;gt;http://localhost:9000&amp;lt;/sonar.host.url&amp;gt;
    &amp;lt;/properties&amp;gt;
  &amp;lt;/profile&amp;gt;
&amp;lt;/profiles&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）配置用户名密码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;profiles&amp;gt;
  &amp;lt;profile&amp;gt;
    &amp;lt;id&amp;gt;sonar&amp;lt;/id&amp;gt;
    &amp;lt;activation&amp;gt;
      &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;
    &amp;lt;/activation&amp;gt;
    &amp;lt;properties&amp;gt;
      &amp;lt;sonar.host.url&amp;gt;http://localhost:9000&amp;lt;/sonar.host.url&amp;gt;
      &amp;lt;sonar.login&amp;gt;admin&amp;lt;/sonar.login&amp;gt;
      &amp;lt;sonar.password&amp;gt;admin&amp;lt;/sonar.password&amp;gt;
    &amp;lt;/properties&amp;gt;
  &amp;lt;/profile&amp;gt;
&amp;lt;/profiles&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）配置令牌&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;profiles&amp;gt;
  &amp;lt;profile&amp;gt;
    &amp;lt;id&amp;gt;sonar&amp;lt;/id&amp;gt;
    &amp;lt;activation&amp;gt;
      &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;
    &amp;lt;/activation&amp;gt;
    &amp;lt;properties&amp;gt;
      &amp;lt;sonar.host.url&amp;gt;http://localhost:9000&amp;lt;/sonar.host.url&amp;gt;
      &amp;lt;sonar.login&amp;gt;9656c84090b2481db6ea97b6d14d87d546bff619&amp;lt;/sonar.login&amp;gt;
    &amp;lt;/properties&amp;gt;
  &amp;lt;/profile&amp;gt;
&amp;lt;/profiles&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上三种都可以，配置完成后，执行命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mvn clean verify sonar:sonar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不想添加配置，可以直接通过命令来指定，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mvn clean verify sonar:sonar -Dsonar.host.url=http://localhost:9000 -Dsonar.login=9656c84090b2481db6ea97b6d14d87d546bff619
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JaCoCo&lt;/code&gt;对项目质量管理作用重大，应该加以使用。最终的maven配置文件&lt;code&gt;pom.xml&lt;/code&gt;行数太大，请到（ &lt;a href=&quot;https://www.pkslow.com/archives/maven-jacoco-sonar&quot;&gt;https://www.pkslow.com/archives/maven-jacoco-sonar&lt;/a&gt; ）参考。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎访问&lt;a href=&quot;https://www.pkslow.com/&quot;&gt;南瓜慢说 www.pkslow.com&lt;/a&gt;获取更多精彩文章！&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202005/946674-20200521000525997-1976560565.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 May 2020 16:05:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>1 简介 单元测试是保证代码质量的重要一环，而如何衡量单元测试写得好不好呢？ 是一个重要指标。而 则是专门为 提供的用于检测测试覆盖率的工具，英文全称为 。 本文将讲解如何在 项目中整合 ，并在 中展</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/12927398.html</dc:identifier>
</item>
<item>
<title>异常检测算法演变及学习笔记 - FinTecher</title>
<link>http://www.cnblogs.com/zhengzhicong/p/12922836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengzhicong/p/12922836.html</guid>
<description>&lt;p&gt;异常检测，又称离群点检测，有着广泛应用。例如金融反欺诈、工业损毁检测、电网窃电行为等！ 一、基于时间序列分析 二、基于概率统计 三、基于距离 四、基于密度 五、基于聚类 六、基于线性方法：矩阵分解和PCA降维 七、基于分布 八、基于树模型 九、基于图模型 十、基于行为序列：马尔科夫链 十一、基于半监督模型 十二、基于有监督模型 十三、数据类型 十四、开源工具库&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;314.70961168346&quot;&gt;
&lt;p&gt;【说在前面】本人博客新手一枚，象牙塔的老白，职业场的小白。以下内容仅为个人见解，欢迎批评指正，不喜勿喷！[认真看图][认真看图]&lt;/p&gt;
&lt;p&gt;【补充说明】异常检测，又称离群点检测，有着广泛应用。例如金融反欺诈、工业损毁检测、电网窃电行为等！ &lt;/p&gt;
&lt;h2&gt;一、基于时间序列分析&lt;/h2&gt;
&lt;p data-spm-anchor-id=&quot;a2c6h.12873639.0.i19.7cff6e2eXFtHmU&quot;&gt;关于时间序列分析的介绍，欢迎浏览我的另一篇博客：&lt;strong&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12916915.html&quot;&gt;时间序列分析中预测类问题下的建模方案&lt;/a&gt;&lt;/strong&gt;，这里不再赘述。&lt;/p&gt;
&lt;h3 data-spm-anchor-id=&quot;a2c6h.12873639.0.i14.7cff6e2eXFtHmU&quot;&gt;1. 基于同比和环比&lt;/h3&gt;
&lt;p&gt;适合数据呈周期性规律的场景中。例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监控APP的DAU的环比和同比，及时发现DAU上涨或者下跌&lt;/li&gt;
&lt;li&gt;监控实时广告点击、消耗的环比和同比，及时发现变化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当上述比值超过一定阈值，则判定出现异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520171153011-1747071710.png&quot; alt=&quot;&quot; width=&quot;396&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;h3 data-spm-anchor-id=&quot;a2c6h.12873639.0.i19.7cff6e2eXFtHmU&quot;&gt;2. 基于统计学模型预测&lt;/h3&gt;
&lt;p data-spm-anchor-id=&quot;a2c6h.12873639.0.i14.7cff6e2eXFtHmU&quot;&gt;移动平均MA是一种分析时间序列的常用工具，它可过滤高频噪声和检测异常点。&lt;/p&gt;
&lt;ul&gt;&lt;li data-spm-anchor-id=&quot;a2c6h.12873639.0.i14.7cff6e2eXFtHmU&quot;&gt;根据计算方法的不同，常用的移动平均算法包括简单移动平均、加权移动平均、指数移动平均。&lt;/li&gt;
&lt;li data-spm-anchor-id=&quot;a2c6h.12873639.0.i14.7cff6e2eXFtHmU&quot;&gt;在序列取值随时间波动较小的场景中，上述移动均值与该时刻的真实值的差值超过一定阈值，则判定该时刻的值异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-spm-anchor-id=&quot;a2c6h.12873639.0.i14.7cff6e2eXFtHmU&quot;&gt;当然，还有ARMA、ARIMA、SARIMA等适用于时间序列分析的统计学模型，可以预测信号并指出其中的异常值。&lt;/p&gt;
&lt;h3&gt;3. 基于时间序列分解&lt;/h3&gt;
&lt;p&gt;STL是一种单维度时间指标异常检测算法。大致思路是：&lt;/p&gt;
&lt;p&gt;（1）先将指标做STL时序分解，得到seasonal、trend、residual成分。&lt;/p&gt;
&lt;p&gt;（2）用ESD算法对trend+residual成分进行异常检测。&lt;/p&gt;
&lt;p&gt;（3）为增强对异常点的鲁棒性，将ESD算法中的mean、std等统计量用median, MAD替换。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c6h.12873639.0.i22.7cff6e2eXFtHmU&quot;&gt;（4）异常分输出：abnorm_score = (value - median)/MAD，负分表示异常下跌，正分表示异常上升。&lt;/p&gt;
&lt;p&gt;当然，还有其他的时间序列分解算法，例如STL、X12-ARIMA、STAMP等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520124619807-215923348.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、基于概率统计&lt;/h2&gt;
&lt;p&gt;一般会构建一个概率分布模型，并计算对象符合该模型的概率，把具有低概率的对象视为异常点。&lt;/p&gt;
&lt;p&gt;还记得不，机器学习特征工程中的RobustScaler方法，在做数据特征值缩放的时候，利用数据特征的分位数分布，将数据根据分位数划分为多段，只取中间段来做缩放（例如只取25%分位数到75%分位数的数据做缩放等），这样减小了异常数据的影响。&lt;/p&gt;
&lt;h3&gt;1. 单特征且符合高斯分布&lt;/h3&gt;
&lt;p&gt;在正态分布的假设下，如果有一个新样本x，当x的正态分布值小于某个阈值时，就可以认为这个样本是异常的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520164925437-1304937017.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;144&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在正态分布中，μ-3σ&amp;lt;=x&amp;lt;=μ+3σ的区域包含了绝大部分数据，可以以此为参考，调整ε的值：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520165014631-994297663.png&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;158&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得一提的是，如果有些特征不符合高斯分布，可以通过一些函数变换，使其符合高斯分布，再使用基于统计的方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;例如取log变换、求内积、指数变换等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. 多个特征，不相关，且均符合高斯分布&lt;/h3&gt;
&lt;p&gt;可以直接对每个独立特征都进行单特征下的异常检测（参考1）。&lt;/p&gt;
&lt;h3&gt;3. 多个特征，相关，且符合多元高斯分布&lt;/h3&gt;
&lt;p&gt;可以通过以下函数判断一个样本是否是异常的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203675/201909/1203675-20190903175148445-1719137626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目的是设法根据训练集求得&lt;em&gt;μ&lt;/em&gt;和&lt;em&gt;σ&lt;/em&gt;，以得到一个确定的多元分正态布模型。具体来说，通过最大似然估计量可以得出下面的结论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203675/201909/1203675-20190903175209018-1398732674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中Σ是协方差对角矩阵，最终求得的多元正态分布模型可以写成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203675/201909/1203675-20190903175247248-1516585751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于最大似然估计量、协方差矩阵和多元正态分布最大似然估计的具体推导过程，这里不详细介绍。&lt;/p&gt;
&lt;h3&gt;4. 马氏距离 Mahalanobis distance&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=mahalanobis%28x-%5Cbar%7Bx%7D+%29%3D%28x-%5Cbar%7Bx%7D+%29S%5E%7B-1%7D+%28x-%5Cbar%7Bx%7D+%29%5E%7BT%7D+&quot; alt=&quot;[公式]&quot; data-formula=&quot;mahalanobis(x-\bar{x} )=(x-\bar{x} )S^{-1} (x-\bar{x} )^{T}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中S为二元高斯分布的协方差矩阵，&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbar%7Bx%7D+&quot; alt=&quot;[公式]&quot; data-formula=&quot;\bar{x}&quot;/&gt;为所有数据对象的均值。Mahalanobis距离越大，数据对象偏离均值越大，也就越异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520222100316-2008026199.png&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5. G检验 Grubbs' Test&lt;/h3&gt;
&lt;p&gt;Grubbs' Test可理解为检验最大值、最小值偏离均值的程度是否为异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520221405892-776981958.png&quot; alt=&quot;&quot; width=&quot;143&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，O为观测值，E为期望值。&lt;/p&gt;
&lt;p&gt;为了将Grubbs' Test扩展到k个异常值检测，需要在数据集中逐步删除与均值偏离最大的值（即最大值或最小值），同步更新对应的t分布临界值，检验原假设是否成立。基于此，Rosner提出了Grubbs' Test的泛化版ESD。&lt;/p&gt;
&lt;h3&gt;6. 箱线图&lt;/h3&gt;
&lt;p&gt;箱线图算法不需要数据服从特定分布。该方法需要先计算第一四分位数Q1（25%）和第三四分位数Q3（75%）。&lt;/p&gt;
&lt;p&gt;令IQR=Q3-Q1，然后算出异常值边界点Q3+λIQR和Q1- λIQR，通常λ取1.5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520120158523-971332875.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然还有其他的统计方法，例如基于混合模型的异常检测方法（假设正常和异常数据分布不同，然后用G检验）等，这里不再展开。&lt;/p&gt;
&lt;h2&gt;三、基于距离&lt;/h2&gt;
&lt;h3&gt;1. 基于角度的异常点检测&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520120303927-150144759.png&quot; alt=&quot;&quot; width=&quot;322&quot; height=&quot;176&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 基于KNN的异常点检测&lt;/h3&gt;
&lt;p&gt;D是点集，则对于任意点，计算其K近邻的距离之和Dist(K，X)。Dist(K，X)越大的点越异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520222308515-789366374.png&quot; alt=&quot;&quot; width=&quot;241&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、基于密度&lt;/h2&gt;
&lt;p&gt;基于距离的方法中，阈值是一个固定值，属于全局性方法。但是有的数据集数据分布不均匀，有的地方比较稠密，有的地方比较稀疏，这就可能导致阈值难以确定。我们需要根据样本点的局部密度信息去判断异常情况。&lt;/p&gt;
&lt;p&gt;基于密度的方法主要有LOF、COF、ODIN、MDEF、INFLO、LoOP、LOCI、aLOCI等，具体实现这里不具体介绍。&lt;/p&gt;
&lt;h3&gt;1. LOF&lt;/h3&gt;
&lt;p&gt;首先对于每一个数据点，找出它的K个近邻，然后计算LOF得分，得分越高越可能是异常点。&lt;/p&gt;
&lt;p&gt;LOF是一个比值，分子是K个近邻的平均局部可达密度，分母是该数据点的局部可达密度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可达密度是一个比值，分子是K-近邻的个数，分母是K-近邻可达距离之和。&lt;/li&gt;
&lt;li&gt;A到B的可达距离定义：A和B的真实距离与B的k-近邻距离的最大值。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. COF&lt;/h3&gt;
&lt;p&gt;LOF中计算距离是用的欧式距离，也是默认了数据是球状分布，而COF的局部密度是根据最短路径方法求出的，也叫做链式距离。&lt;/p&gt;
&lt;h3&gt;3. INFLO&lt;/h3&gt;
&lt;p&gt;LOF容易将边界处的点判断为异常，INFLO在计算密度时，利用k近邻点和反向近邻集合，改善了LOF的这个缺点。&lt;/p&gt;
&lt;h3&gt;4. LoOP&lt;/h3&gt;
&lt;p&gt;将LOF中计算密度的公式加了平方根，并假设近邻距离的分布符合正态分布。&lt;/p&gt;
&lt;h2&gt;五、基于聚类&lt;/h2&gt;
&lt;p&gt;关于聚类算法的介绍，欢迎浏览我的另一篇博客：&lt;strong&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12895421.html&quot;&gt;机器学习中的聚类算法演变及学习笔记&lt;/a&gt;&lt;/strong&gt;，这里不再赘述。&lt;/p&gt;
&lt;p&gt;此类方法主要有三种假设，三种假设下有各自的方法。&lt;/p&gt;
&lt;h3&gt;1. 假设一：不属于任何聚类的点是异常点&lt;/h3&gt;
&lt;p&gt;主要方法：DBSCAN、SNN clustering、FindOut algorithm、WaveCluster Algorithm。&lt;/p&gt;
&lt;p&gt;缺点：不能发现异常簇&lt;/p&gt;
&lt;h3&gt;2. 假设二：距离最近的聚类结果较远的点是异常点&lt;/h3&gt;
&lt;p&gt;主要方法：K-Means、Self-Organizing Maps（SOM）、GMM。&lt;/p&gt;
&lt;p&gt;主要步骤：首先进行聚类，然后计算样例与其所属聚类中心的距离，计算其所属聚类的类内平均距离，用两者的比值衡量异常程度。&lt;/p&gt;
&lt;p&gt;缺点：不能发现异常簇&lt;/p&gt;
&lt;h3&gt;3. 假设三：稀疏聚类和较小的聚类里的点都是异常点&lt;/h3&gt;
&lt;p&gt;主要方法：CBLOF、LDCOF、CMGOS。&lt;/p&gt;
&lt;p&gt;主要步骤：首先进行聚类，然后启发式地将聚类簇分成大簇和小簇。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果某一样例属于大簇，则利用该样例和其所属大簇计算异常得分&lt;/li&gt;
&lt;li&gt;如果某一样例属于小簇，则利用该样例和距离其最近的大簇计算异常得分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：考虑到了数据全局分布和局部分布的差异，可以发现异常簇&lt;/p&gt;
&lt;h2&gt;六、基于线性方法：矩阵分解和PCA降维&lt;/h2&gt;
&lt;p data-spm-anchor-id=&quot;a2c6h.12873639.0.i37.7cff6e2eXFtHmU&quot;&gt;基于矩阵分解的异常点检测方法的主要思想是利用主成分分析（PCA）去寻找那些违反了数据之间相关性的异常点。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c6h.12873639.0.i37.7cff6e2eXFtHmU&quot;&gt;为了找到这些异常点，基于主成分分析的算法会把数据从原始空间投影到主成分空间，然后再从主成分空间投影回原始空间。&lt;/p&gt;
&lt;ul&gt;&lt;li data-spm-anchor-id=&quot;a2c6h.12873639.0.i37.7cff6e2eXFtHmU&quot;&gt;对于大多数的数据而言，如果只使用第一主成分来进行投影和重构，重构之后的误差是较小的。&lt;/li&gt;
&lt;li data-spm-anchor-id=&quot;a2c6h.12873639.0.i37.7cff6e2eXFtHmU&quot;&gt;但是对于异常点而言，重构之后的误差相对较大。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-spm-anchor-id=&quot;a2c6h.12873639.0.i37.7cff6e2eXFtHmU&quot;&gt;这是因为第一主成分反映了正常点的方差，最后一个主成分反映了异常点的方差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200520120543355-1915959836.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;七、基于分布&lt;/h2&gt;
&lt;p&gt;即对比基准数据和待检测数据的某个特征的分布。&lt;/p&gt;
&lt;h3&gt;1. 相对熵（KL散度）&lt;/h3&gt;
&lt;p&gt;相对熵（KL散度）可以衡量两个随机分布之间的距离。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当两个随机分布相同时，它们的相对熵为零。&lt;/li&gt;
&lt;li&gt;当两个随机分布的差别增大时，它们的相对熵也会增大。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. 卡方检验&lt;/h3&gt;
&lt;p&gt;卡方检验通过检验统计量来比较期望结果和实际结果之间的差别，然后得出实际结果发生的概率。&lt;/p&gt;
&lt;p&gt;检验统计量提供了一种期望值与观察值之间差异的度量办法，最后根据设定的显著性水平查找卡方概率表来判定。&lt;/p&gt;
&lt;h2&gt;八、基于树模型&lt;/h2&gt;
&lt;p&gt;该类方法假设我们用一个随机超平面来切割数据空间，每切一次便可以生成两个子空间。接着继续用一个随机超平面来切割每个子空间，循环下去，直到每个子空间里面只有一个数据点为止。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;那些密度很高的簇是需要被切很多次才能让子空间中只有一个数据点&lt;/li&gt;
&lt;li&gt;那些密度很低的点的子空间则很快就被切割成只有一个数据点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此类方法不受球形邻近的限制，可以划分任意形状的异常点。不同的方法区别主要在三个地方：特征的选取、分割点的选取和分类空间打标签的方案。此类方法主要包括iForest、SCiForest、RRCF。&lt;/p&gt;
&lt;h3&gt;1. iForest&lt;/h3&gt;
&lt;p&gt;此方法适用于异常点较少的情况，采用构造多个决策树的方式进行异常检测。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对数据集进行有放回抽样，对每一次抽样出来的样本构建二叉树。&lt;/li&gt;
&lt;li&gt;构建二叉树时，随机选取一个特征，然后在特征上随机选一个分割点，将该特征小于分割点的数据放在二叉树左边，反之放在右边。&lt;/li&gt;
&lt;li&gt;直至二叉树达到一定深度或者叶子节点只包含一个数据点为止。&lt;/li&gt;
&lt;li&gt;进行异常检测时，计算该数据点在多个二叉树上的平均深度，深度越浅，越可能是异常值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;iForest只适合检测全局异常点，不适合检测局部异常点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如左图所示，黑点是异常点，被切几次就停到一个子空间。白点为正常点，白色点聚焦在一个簇中。&lt;/li&gt;
&lt;li&gt;如右图所示，用iForest切割4个数据，b和c的高度为3，a的高度为2，d的高度为1，d最先被孤立，它最有可能异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://ucc.alicdn.com/pic/developer-ecology/f1b64e221e9e450992deb67f76365448.png&quot; alt=&quot;image.png&quot; width=&quot;214&quot; height=&quot;195&quot;/&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://ucc.alicdn.com/pic/developer-ecology/f3481ca065904c5f82da475b9abb0e21.png&quot; alt=&quot;image.png&quot; width=&quot;228&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. SCiForest&lt;/h3&gt;
&lt;p&gt;传统iForest方法在选择特征是随机选取的，SCiForest在选择特征时利用了方差。&lt;/p&gt;
&lt;p&gt;传统iForest选择分割点后形成的分割超平面是平行于坐标轴的，SCiForest可以生成任意角度的分割超平面。&lt;/p&gt;
&lt;h3&gt;3. RRCF&lt;/h3&gt;
&lt;p&gt;可以动态增删树种的节点，适用于流数据异常检测。&lt;/p&gt;
&lt;h2&gt;九、基于图模型&lt;/h2&gt;
&lt;h3&gt;1. 最大联通图&lt;/h3&gt;
&lt;p&gt;在无向图G中，若从顶点A到顶点B有路径相连，则称A和B是连通的。在图G中存在若干子图，其中每个子图中所有顶点之间都是连通的，但不同子图间不存在顶点连通，那么称图G的这些子图为最大连通子图。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最大联通图的前提条件是每条边必须置信，当数据中存在不太置信的边时，需要先剔除脏数据，否则会影响最大联通图的效果。&lt;/li&gt;
&lt;li&gt;如图所示，device是设备id，mbr是会员id，节点之间有边表示设备上有对应的会员登录过，容易看出device_1、device_2、device_3、device_4是同人，可以根据场景用于判断作弊，常用于挖掘团伙作弊。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://ucc.alicdn.com/pic/developer-ecology/51c18233706844bea41dc465c6777d2a.png&quot; alt=&quot;image.png&quot; width=&quot;388&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 标签传播聚类&lt;/h3&gt;
&lt;p&gt;标签传播图聚类算法是根据图的拓扑结构，进行子图的划分，使得子图内部节点的连接较多，子图之间的连接较少。&lt;/p&gt;
&lt;p&gt;标签传播算法的基本思路是：节点的标签依赖其邻居节点的标签信息，影响程度由节点相似度决定，通过传播迭代更新达到稳定。&lt;/p&gt;
&lt;p&gt;标签传播聚类的子图间可以有少量连接。适用场景：节点之间“高内聚低耦合”。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图中的节点经标签传播聚类后将得2个子图，其中节点1、2、3、4属于一个子图，节点5、6、7、8属于一个子图。&lt;/li&gt;
&lt;li&gt;值得一提的是，图中如果用最大联通图（参考1）只会得到1个子图，用标签传播聚类则会得到2个子图。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://ucc.alicdn.com/pic/developer-ecology/0e8bec5c128242a9a85900a5bcffa077.png&quot; alt=&quot;image.png&quot; width=&quot;354&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;十、基于行为序列：马尔科夫链&lt;/h2&gt;
&lt;p&gt;如图所示，用户在搜索引擎上有5个行为状态：页面请求（P），搜索（S），自然搜索结果（W），广告点击（O），翻页（N）。状态之间有转移概率，由若干行为状态组成的一条链可以看做一条马尔科夫链。&lt;/p&gt;
&lt;p&gt;统计正常行为序列中任意两个相邻的状态，然后计算每个状态转移到其他任意状态的概率，得状态转移矩阵。针对每一个待检测用户行为序列，易得该序列的概率值，概率值越大，越像正常用户行为。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://ucc.alicdn.com/pic/developer-ecology/40af4eb249434d3fa8c2832e3e28a5ab.png&quot; alt=&quot;image.png&quot; width=&quot;332&quot; height=&quot;153&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;十一、基于半监督模型&lt;/h2&gt;
&lt;p&gt;此类方法&lt;strong&gt;适用于标注的数据全都是正常数据&lt;/strong&gt;，常用方法有one-class SVM、SVDD、AutoEncoder、GMM、Naïve Bayes等。&lt;/p&gt;
&lt;p&gt;此类方法与无监督方法有些重合，因为无监督方法的基本假设就是数据集中正常数据远远多于异常数据。&lt;/p&gt;
&lt;h3&gt;1. One-class SVM&lt;/h3&gt;
&lt;p&gt;利用核函数将数据映射到高维空间，寻找超平面使得数据和坐标原点间隔最大。&lt;/p&gt;
&lt;h3&gt;2. SVDD&lt;/h3&gt;
&lt;p&gt;利用核函数将数据映射到高维空间，寻找尽可能小的超球体包裹住正常数据。&lt;/p&gt;
&lt;h3&gt;3. AutoEncoder&lt;/h3&gt;
&lt;p&gt;对正常数据进行训练Encoder和Decoder，进行异常检测时，如果Decoder出来的向量与原始向量差别很大，就认为是异常数据。&lt;/p&gt;
&lt;h3&gt;4. GMM&lt;/h3&gt;
&lt;p&gt;对正常数据进行高斯混合模型建模，最大似然估计参数。进行异常检测时，将其特征带入模型，可得出它属于正常数据的概率。&lt;/p&gt;
&lt;h3&gt;5. Naïve Bayes&lt;/h3&gt;
&lt;p&gt;过程同高斯混合模型。&lt;/p&gt;
&lt;h3&gt;6. 生成对抗网络GAN：比较新的方法&lt;/h3&gt;
&lt;p&gt;最直观的理解：利用生成对抗的思想，生成器从随机噪声中生成异常数据，判别器判别数据是生成的异常数据，还是原始的正常数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成器的目标是生成尽可能和正常数据相似的数据，让判别器无法识别出。&lt;/li&gt;
&lt;li&gt;判别器的目标是尽可能判别出真实数据和异常数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两者进行博弈，最终达到平衡。在异常检测过程中，对于给定数据，只需要利用判别器判别出是正常数据还是异常数据。&lt;/p&gt;
&lt;h2&gt;十二、基于有监督模型&lt;/h2&gt;
&lt;p&gt;上述方法都是无监督方法，实现和理解相对简单。但是由于部分方法每次使用较少的特征，为了全方位拦截作弊，需要维护较多策略。&lt;/p&gt;
&lt;p&gt;同时，上述部分方法组合多特征的效果取决于人工经验。而有监督模型能自动组合较多特征，具备更强的泛化能力。&lt;/p&gt;
&lt;h3&gt;1. 基于机器学习模型&lt;/h3&gt;
&lt;p&gt;关于机器学习算法的介绍，欢迎浏览我的另一篇博客：&lt;strong&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12728491.html&quot;&gt;数据挖掘比赛/项目全流程介绍&lt;/a&gt; &lt;/strong&gt;，这里不再赘述。&lt;/p&gt;
&lt;p&gt;可以使用前面的无监督方法挖掘的作弊样本作为训练样本。如果作弊样本仍然较少，用SMOTE或者GAN生成作弊样本。&lt;/p&gt;
&lt;p&gt;可以采用LR、SVM、GBDT、XGBOOST等机器学习算法进行回归，实现二分类，完成异常检测。&lt;/p&gt;
&lt;h3&gt;2. 基于深度学习模型&lt;/h3&gt;
&lt;p&gt;关于深度学习算法的介绍，欢迎浏览我的另一篇博客：&lt;strong&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12890660.html&quot;&gt;深度学习中的序列模型演变及学习笔记&lt;/a&gt;&lt;/strong&gt;，这里不再赘述。&lt;/p&gt;
&lt;p&gt;关于深度学习组件的介绍，欢迎浏览我的另一篇博客：&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12900712.html&quot;&gt;&lt;strong&gt;深度学习中的一些组件及使用技巧&lt;/strong&gt;&lt;/a&gt; ，这里不再赘述。&lt;/p&gt;
&lt;p&gt;同样的，可以使用前面的无监督方法挖掘的作弊样本作为训练样本。如果作弊样本仍然较少，用SMOTE或者GAN生成作弊样本。&lt;/p&gt;
&lt;p&gt;可以采用CNN、RNN、LSTM等深度学习模型及其融合进行回归，实现二分类，完成异常检测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得一提的是，其他随笔提到的很多深度学习模型，均适用于“异常检测”这个应用场景，细品！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子，阿里的GEM模型实现了异构图网络在异常检测中的应用，采用图神经网络相关算法实现了“是否异常”的二分类。&lt;/p&gt;
&lt;p&gt;同时，自然还有基于知识图谱、引入迁移学习、引入强化学习等新技术的推进。&lt;/p&gt;
&lt;h2&gt;十三、数据类型&lt;/h2&gt;
&lt;p&gt;随着信息流的不断发展，除了上文提到的时间序列数据、高维数据，目前有图像、视频、文本、日志等数据类型的异常检测方法。&lt;/p&gt;
&lt;h2&gt;十四、开源工具库&lt;/h2&gt;
&lt;p&gt;可以使用Python异常检测工具库&lt;strong&gt;Pyod&lt;/strong&gt;。这个工具库除了支持&lt;strong&gt;Sklearn&lt;/strong&gt;上支持的模型外，还额外提供了很多模型。&lt;/p&gt;
&lt;p&gt;本文参考了阿里巴巴的一篇文章：异常检测的N种方法，阿里工程师都盘出来了&lt;/p&gt;

&lt;p&gt;如果您对人工智能算法感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12670260.html&quot;&gt;人工智能新手入门学习路线和学习资源合集（含AI综述/python/机器学习/深度学习/tensorflow）&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12875348.html&quot;&gt;人工智能领域常用的开源框架和库（含机器学习/深度学习/强化学习/知识图谱/图神经网络）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的应届毕业生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650878.html&quot;&gt;如果你是一个计算机领域的应届生，你如何准备求职面试？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的本科生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650191.html&quot;&gt;如果你是一个计算机领域的本科生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的研究生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650369.html&quot;&gt;如果你是一个计算机领域的研究生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你对金融科技感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12657428.html&quot;&gt;如果你想了解金融科技，不妨先了解金融科技有哪些可能？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之后博主将持续分享各大算法的学习思路和学习笔记：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12641421.html&quot;&gt;hello world: 我的博客写作思路&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 20 May 2020 15:11:00 +0000</pubDate>
<dc:creator>FinTecher</dc:creator>
<og:description>异常检测，又称离群点检测，有着广泛应用。例如金融反欺诈、工业损毁检测、电网窃电行为等！ 一、基于时间序列分析 二、基于概率统计 三、基于距离 四、基于密度 五、基于聚类 六、基于线性方法：矩阵分解和P</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhengzhicong/p/12922836.html</dc:identifier>
</item>
<item>
<title>SpringBoot切面Aop的demo简单讲解 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/12927081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/12927081.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇文章主要介绍的是SpringBoot切面Aop的demo简单讲解。&lt;/p&gt;
&lt;h2 id=&quot;springboot-aop&quot;&gt;SpringBoot Aop&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明：如果想直接获取工程那么可以直接跳到底部，通过链接下载工程代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;切面aop&quot;&gt;切面(Aop)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一、概念&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;AOP（Aspect OrientedProgramming）：面向切面编程，面向切面编程（也叫面向方面编程），是目前软件开发中的一个热点，也是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;二、用途&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;日志记录，性能统计，安全控制，权限管理，事务处理，异常处理，资源池管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;三、详解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.切面（Aspect）:&lt;br/&gt;官方的抽象定义为“一个关注点的模块化，这个关注点可能会横切多个对象”，在本例中，“切面”就是类TestAspect所关注的具体行为，例如：AServiceImpl.barA()的调用就是切面TestAspect所关注的行为之一。“切面”在ApplicationContext中&lt;a href=&quot;aop:aspect&quot;&gt;aop:aspect&lt;/a&gt;来配置。&lt;/p&gt;
&lt;p&gt;2.连接点（Joinpoint）:&lt;br/&gt;程序执行过程中的某一行为，例如，AServiceImpl.barA()的调用或者BServiceImpl.barB(String _msg, int _type)抛出异常等行为。&lt;/p&gt;
&lt;p&gt;3.通知（Advice）:&lt;br/&gt;“切面”对于某个“连接点”所产生的动作，例如，TestAspect中对com.spring.service包下所有类的方法进行日志记录的动作就是一个Advice。其中，一个“切面”可以包含多个“Advice”，例如TestAspect。Advice共有如下5种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A 前置通知（Before advice） ：在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行。xml中在&lt;a href=&quot;aop:aspect&quot;&gt;aop:aspect&lt;/a&gt;里面使用&lt;a href=&quot;aop:before&quot;&gt;aop:before&lt;/a&gt;元素进行声明；例如，TestAspect中的doBefore方法。注解中使用@Before声明；例如，TestAnnotationAspect中的doBefore方法。&lt;/li&gt;
&lt;li&gt;B 后通知（After advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。xml中在&lt;a href=&quot;aop:aspect&quot;&gt;aop:aspect&lt;/a&gt;里面使用&lt;a href=&quot;aop:after&quot;&gt;aop:after&lt;/a&gt;元素进行声明。例如，TestAspect中的doAfter方法，所以AOPTest中调用BServiceImpl.barB抛出异常时，doAfter方法仍然执行。注解中使用@After声明。&lt;/li&gt;
&lt;li&gt;C 返回后通知（After return advice）：在某连接点正常完成后执行的通知，不包括抛出异常的情况。xml中在&lt;a href=&quot;aop:aspect&quot;&gt;aop:aspect&lt;/a&gt;里面使用元素进行声明。注解中使用@AfterReturning声明；&lt;/li&gt;
&lt;li&gt;D 环绕通知（Around advice） ：包围一个连接点的通知，类似Web中Servlet规范中的Filter的doFilter方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。xml中在&lt;a href=&quot;aop:aspect&quot;&gt;aop:aspect&lt;/a&gt;里面使用&lt;a href=&quot;aop:around&quot;&gt;aop:around&lt;/a&gt;元素进行声明。例如，TestAspect中的doAround方法。注解中使用@Around声明。&lt;/li&gt;
&lt;li&gt;E 抛出异常后通知（After throwing advice） ： 在方法抛出异常退出时执行的通知。xml中在&lt;a href=&quot;aop:aspect&quot;&gt;aop:aspect&lt;/a&gt;里面使用&lt;a href=&quot;aop:after-throwing&quot;&gt;aop:after-throwing&lt;/a&gt;元素进行声明。例如，TestAspect中的doThrowing方法。注解中使用@AfterThrowing声明。&lt;/li&gt;
&lt;li&gt;通知执行顺序：前置通知→环绕通知连接点之前→连接点执行→环绕通知连接点之后→返回通知→后通知 →(如果发生异常)异常通知→后通知。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4.切入点（Pointcut）&lt;br/&gt;匹配连接点的断言，在AOP中通知和一个切入点表达式关联。例如，TestAspect中的所有通知所关注的连接点，都由切入点表达式execution(* com.spring.service.&lt;em&gt;.&lt;/em&gt;(..))来决定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注:以上的理论知识参考:&lt;a href=&quot;https://www.cnblogs.com/yepei/p/4735298.html&quot;&gt;https://www.cnblogs.com/yepei/p/4735298.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发准备&quot;&gt;开发准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;环境要求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt;：1.8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot&lt;/strong&gt;：2.2.6.RELEASE&lt;/p&gt;
&lt;p&gt;首先还是Maven的相关依赖，基本和普通springboot项目一样，就是多了&lt;code&gt;spring-boot-starter-aop&lt;/code&gt;这jar的依赖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;文件如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
                &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.2.68&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;application.properties&lt;/code&gt;的文件的配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;banner.charset=UTF-8
server.tomcat.uri-encoding=UTF-8
spring.http.encoding.charset=UTF-8
spring.http.encoding.enabled=true
spring.http.encoding.force=true
spring.messages.encoding=UTF-8
spring.application.name=springboot-aspect
server.port=8180
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码编写&quot;&gt;代码编写&lt;/h3&gt;
&lt;p&gt;SpringBoot在使用切面的时候，只需要在自定义的一个切面类中加上 &lt;code&gt;@Aspect&lt;/code&gt; 注解进行声明，然后在自定义切面的类方法中加上对应的注解即可。&lt;br/&gt;比如这里的示例我们想做一个请求响应的加解密切面处理，业务层只需关心代码逻辑实现，而不用关心请求参数和响应参数的加解密实现。那么首先我们需要自定义一个加解密的切面类，在该类添加&lt;code&gt;@Aspect&lt;/code&gt;注解，然后在定义一个公共的切入点（Pointcut），指向需要处理的包，然后在定义一个前置通知(添加&lt;code&gt;@Before&lt;/code&gt;注解)和后置通知(添加&lt;code&gt;@AfterReturning&lt;/code&gt;)方法实现即可。&lt;/p&gt;
&lt;p&gt;这里我们就将切入点设置为控制层包里所有的请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;切入点代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
                 @Pointcut(&quot;execution(public * com.pancm.web.*.*(..))&quot;)
                          public void doOperation() {
                 }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在定义一个前置通知，实现对请求参数的数据解密，这里我们就用User这个实体类的名称，对该数据进行解密。实际在运用是可以根据自身的情况来编写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前置通知代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     @Before(&quot;doOperation()&quot;)
    public void before(JoinPoint joinPoint) throws Throwable{
        Object[] objs = joinPoint.getArgs();
        for (Object obj : objs) {
            User user =(User) obj;
            System.out.println(&quot;前置通知接受的参数:&quot;+user);
            String name =base64DeStr(user.getName());
            user.setName(name);
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在编写完前置通知的方法之后，我们在编写后置通知的代码，这块基本和前置通知的一样，就是把返回的数据进行加密而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后置通知代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @AfterReturning(returning = &quot;object&quot;, pointcut = &quot;doOperation()&quot;)
    public void doAfterReturning(Object object) {
        ResultBody resultBody = (ResultBody) object;
        String str =null;
        try {
             str=base64EnStr(resultBody.getResult());
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        resultBody.setResult(str);
        System.out.println(&quot;后通知响应的参数:&quot;+resultBody);
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;完整代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@Aspect
@Component
public class ParamAspect {

    @Pointcut(&quot;execution(public * com.pancm.web.*.*(..))&quot;)
    public void doOperation() {

    }


    @Before(&quot;doOperation()&quot;)
    public void before(JoinPoint joinPoint) throws Throwable{
        Object[] objs = joinPoint.getArgs();
        for (Object obj : objs) {
            User user =(User) obj;
            System.out.println(&quot;前置通知接受的参数:&quot;+user);
            String name =base64DeStr(user.getName());
            user.setName(name);
        }
    }


    @AfterReturning(returning = &quot;object&quot;, pointcut = &quot;doOperation()&quot;)
    public void doAfterReturning(Object object) {
        ResultBody resultBody = (ResultBody) object;
        String str =null;
        try {
             str=base64EnStr(resultBody.getResult());
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        resultBody.setResult(str);
        System.out.println(&quot;前置通知响应的参数:&quot;+resultBody);
    }


    public  String base64EnStr(String str) throws UnsupportedEncodingException {
        return Base64.getEncoder().encodeToString(str.getBytes(&quot;UTF-8&quot;));
    }


    public static String base64DeStr(String encodeStr) throws UnsupportedEncodingException {
        byte[] decodeStr = Base64.getDecoder().decode(encodeStr);
        return new String(decodeStr, &quot;UTF-8&quot;);
    }


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实体类代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        public class User {
                
                 private Long id;
        
                 private String name;
                 
                 private Integer age;
                 
                //getter 和 setter 略
                
        }


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制层z这块的代码和普通的一样，我们这里只需简单的做下处理即可，这里为了方便理解，没有编写service层和dao的代码。:&lt;/p&gt;
&lt;p&gt;** 控制层代码**&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@RestController
@RequestMapping(value = &quot;/api&quot;)
public class UserRestController {

    @GetMapping(&quot;/user&quot;)
    public ResultBody findByUser(User  user) {
        System.out.println(&quot;用户查询接口请求的参数:&quot;+user);
        ResultBody resultBody = new ResultBody();
        List&amp;lt;User&amp;gt; userList =new ArrayList&amp;lt;&amp;gt;();
        User user2=new User();
        user2.setId(1L);
        user2.setName(&quot;xuwujing&quot;);
        user2.setAge(18);
        userList.add(user2);
        resultBody.setCode(&quot;0&quot;);
        resultBody.setResult(userList.toString());
        System.out.println(&quot;用户查询接口响应的参数:&quot;+resultBody);
        return resultBody;
    }
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;App 入口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和普通的SpringBoot项目基本一样！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        @SpringBootApplication
        public class AspectApp
        {
            public static void main( String[] args )
            {
                        SpringApplication.run(AspectApp.class, args);
                        System.out.println(&quot;Aspect启动成功！&quot;);
            }
        }


&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;功能测试&quot;&gt;功能测试&lt;/h3&gt;
&lt;p&gt;编写完代码之后，我们启动程序，因为是Get请求，在浏览器或者使用&lt;a href=&quot;https://blog.csdn.net/qazwsxpcm/article/details/70578600&quot;&gt;Postman&lt;/a&gt;输入地址都可以进行测试，需要注意的是这里我们需要对name的值进行base64加密请求。&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8180/api/user?name=eHV3dWppbmc=&quot;&gt;http://localhost:8180/api/user?name=eHV3dWppbmc=&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制台打印:&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;前置通知接受的参数:{&quot;name&quot;:&quot;eHV3dWppbmc=&quot;}&lt;br/&gt;用户查询接口请求的参数:{&quot;name&quot;:&quot;xuwujing&quot;}&lt;br/&gt;用户查询接口响应的参数:{&quot;code&quot;:&quot;0&quot;,&quot;result&quot;:&quot;[{&quot;age&quot;:18,&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;}]&quot;}&lt;br/&gt;后通知响应的参数:{&quot;code&quot;:&quot;0&quot;,&quot;result&quot;:&quot;W3siYWdlIjoxOCwiaWQiOjEsIm5hbWUiOiJ4dXd1amluZyJ9XQ==&quot;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请求响应参数:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&lt;br/&gt;&quot;code&quot;: &quot;0&quot;,&lt;br/&gt;&quot;message&quot;: null,&lt;br/&gt;&quot;result&quot;: &quot;W3siYWdlIjoxOCwiaWQiOjEsIm5hbWUiOiJ4dXd1amluZyJ9XQ==&quot;&lt;br/&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200518160714223.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200518160724904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;关于SpringBoot切面Aop的demo简单讲解的文章就讲解到这里了，如有不妥，欢迎指正！&lt;/p&gt;
&lt;h3 id=&quot;项目地址&quot;&gt;项目地址&lt;/h3&gt;
&lt;p&gt;SpringBoot 的aop的项目工程地址:&lt;br/&gt;&lt;a href=&quot;https://github.com/xuwujing/springBoot-study/tree/master/springboot-aspect&quot;&gt;https://github.com/xuwujing/springBoot-study/tree/master/springboot-aspect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot整个集合的地址:&lt;br/&gt;&lt;a href=&quot;https://github.com/xuwujing/springBoot-study&quot;&gt;https://github.com/xuwujing/springBoot-study&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;springboot整合系列的文章&quot;&gt;SpringBoot整合系列的文章&lt;/h3&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;翩若惊鸿，婉若游龙，荣曜秋菊，华茂春松。仿佛兮若轻云之蔽月，飘飘兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。--网易云网友评论&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　　　　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 May 2020 15:06:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 本篇文章主要介绍的是SpringBoot切面Aop的demo简单讲解。 SpringBoot Aop 说明：如果想直接获取工程那么可以直接跳到底部，通过链接下载工程代码。 切面(Aop) 一、概</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuwujing/p/12927081.html</dc:identifier>
</item>
</channel>
</rss>