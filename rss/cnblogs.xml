<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>面向对象三大特征 - 一梦三千年</title>
<link>http://www.cnblogs.com/tar8087/p/14391501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tar8087/p/14391501.html</guid>
<description>&lt;p&gt;　　　　看名字它是注重对象的。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。&lt;/p&gt;&lt;p&gt;　　　　　　　　4、执行：.冰箱.打开()，大象.进入()，冰箱.关闭(冰箱)&lt;/p&gt;&lt;div readability=&quot;80&quot;&gt;
&lt;h2 id=&quot;6425-1612777504641&quot;&gt;　　&lt;span&gt;1、封装&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;8421-1612777530091&quot;&gt;　　　　&lt;span&gt;a、定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　将代码通过权限修饰符来限定甚至隐藏起来，起到部分代码不可见从而减少被外部类对象调用修改的风险。&lt;/p&gt;
&lt;p&gt;　　　　　　权限修饰范围如下：&lt;/p&gt;
&lt;div&gt;　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1739529/202102/1739529-20210208225511306-1018991027.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　从表格中可以看出从上到下封装性越来越差　&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;h3 id=&quot;6716-1612778266548&quot;&gt;　　　　&lt;span&gt;b、this关键字&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　this关键字代表当前对象，采取this.属性，this.方法可以来进行操作当前的属性和方法&lt;/p&gt;
&lt;h3 id=&quot;1510-1612778413749&quot;&gt;　　　　&lt;span&gt;c、内部类（&lt;span&gt;Inner Class&lt;/span&gt;）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　定义在一个类(A)中的一个类(B)，可以对代码进行有效的封装，且相对于内部类(B)来说A就是外部类，内部类B可以 调用外部类中的一切属性和一切方法，不包括匿名方法，和代码块&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;68&quot;&gt;
&lt;h2 id=&quot;7435-1612778709764&quot;&gt;　　&lt;span&gt;2、继承&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;8818-1612778727900&quot;&gt;　　　　&lt;span&gt;a、定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　类与类之间达成 &quot;is a&quot; 的关系，比如：A继承B，那么A就是父类(基类)，B就是子类(派生类)&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1、java中类的继承是单继承的，即一个类的父类只能有一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　&lt;/span&gt;2、java中类的继承可以传递，C继承B，B继承A，那么C可以间接的继承了A，C中拥有A中的属性和方法(不包括 私有)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;3088-1612779063316&quot;&gt;　　　　&lt;span&gt;b、继承的好处&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　子类可以拥有父类除了private修饰的所有的属性和方法，从而实现了代码的复用&lt;/p&gt;
&lt;h3 id=&quot;7792-1612779148412&quot;&gt;　　　　&lt;span&gt;c、继承类加载执行顺序&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　B继承A&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;&lt;span&gt;0)、加载A的类模板&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　&lt;span&gt;1)、A产生静态区，加载A的静态方法，静态属性和静态代码块即：static 修饰的属性，static修饰的方法，static修饰的代码块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　&lt;span&gt;2)、加载B的类模板&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　&lt;span&gt;3)、B产生静态区，加载B的静态方法，静态属性和静态代码块即：static 修饰的属性，static修饰的方法，static修饰的代码块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　&lt;span&gt;4)、堆内存开辟空间，加载父类A的非静态元素(属性，方法，代码块，构造方法)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　5)、执行父类A代码块/执行父类A构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　6)、堆内存开辟空间，加载子类B的非静态元素(属性，方法，代码块，构造方法)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　7)、执行子类B代码块/执行子类B构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　8)、将堆内存的地址引用传递给占内存开辟的变量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;6019-1612779091780&quot;&gt;　　　　&lt;span&gt;d、final修饰符&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;修饰类：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;即为最终的类，不可被继承&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;修饰方法：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;即为最终的方法，不可被重写&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　&lt;strong&gt;&lt;span&gt;修饰属性：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;即为最终的属性&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;当属性为基本类型，则在声明时必须赋值，且属性不可修改。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;当属性为引用类型，则声明时可以不复制，但仅保留一次赋值机会，且赋值后，属性的值(地址)不可被修改&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;2797-1612780447270&quot;&gt;　　　　&lt;span&gt;e、super关键字&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　在子类对象内部使用，可以代替父类对象&lt;/p&gt;
&lt;p&gt;　　　　　　super.属性--&amp;gt;调用父类的属性&lt;/p&gt;
&lt;p&gt;　　　　　　super.方法--&amp;gt;调用父类的方法&lt;/p&gt;
&lt;p&gt;　　　　备注：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;子类在调用构造函数时，会默认调用super.父类构造函数(隐式构造函数)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　若是子类调用构造函数时，自己写super.父类构造函数，那么super.父类构造函数必须写在子类构造函数中的第一行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　如果子类构造方法中既没有显式调用父类的构造方法，而父类没有无参的构造方法，则编译出错。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;h2 id=&quot;0035-1612780961577&quot;&gt;　　&lt;span&gt;3、多态&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;5760-1612781118905&quot;&gt;　　　　&lt;span&gt;a、定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　父类引用指向子类的对象，此时形成多态的效果&lt;/p&gt;
&lt;h3 id=&quot;7800-1612791921424&quot;&gt;　　　　&lt;span&gt;b、举例说明&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　定义一个animal类如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 定义一个animal父类
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * 添加一个属性为name
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * 添加一个方法为eat()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;动物正在进食&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　定义一个dog类，且dog类继承animal&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;     * 定义一个dog类来继承animal
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;      
&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　此时我们在主方法中进行new 一个dog对象来看下&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMain {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 定义一个测试类
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * 类中定义一个主方法
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         Dog dog = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        dog.eat();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　执行结果为：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1739529/202102/1739529-20210208230327401-131926068.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　　　由此可知子类继承父类，也就继承了父类的所有的非private修饰的方法和属性，我们在dog类中重写父类的eat()方法&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;　　　　
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 定义一个dog类来继承animal
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;狗狗正在进食&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　此时我们在主方法中再次运行一下，结果如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1739529/202102/1739529-20210208230444593-1447614612.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;　　　　　由此我们可以知道当子类继承父类时，子类若是重写了父类的eat()方法，运行的结果是执行子类的方法，若是子类没有重写方法，那么就会直接调用父类的eat()方法
&lt;p&gt;　　　　　以下为多态的演示：&lt;/p&gt;
&lt;p&gt;　　　　　我们在dog类中在定义一个方法，且new Dog对象时，我们用父类来接收，代码如下：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 定义一个dog类来继承animal
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;狗狗正在进食&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新写一个dog类独有的方法&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.out.println(&quot;狗狗正在奔跑&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　此时我们在用父类来接受子类的对象&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1739529/202102/1739529-20210208230617841-702082087.png&quot; alt=&quot;&quot; width=&quot;844&quot; height=&quot;424&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　　　你会发现，我们找寻不到Dog类中独有的run()方法，接着我们在执行一下eat()方法&lt;/p&gt;
&lt;div&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1739529/202102/1739529-20210208230713842-796680551.png&quot; alt=&quot;&quot; width=&quot;856&quot; height=&quot;408&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　　　输出的是Dog类中重写的eat()方法，是不是很神奇，那么此时我们在纵向思考下，假设我们现在有一个Cat类也继承Animal类并且重写了eat()方法，那么我们若是在定义一个Cat类继承Animal并且重写eat()方法&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Animal animal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; animal.eat();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　此时执行出的结果就会是 “猫咪正在进食”，我都是用Animal类型接受的，但是我new的对象不同，我就会输出不同的结果，这就是多态；&lt;/p&gt;
&lt;p&gt;　　　　那我们要执行dog的独有run()方法怎么办呢？此时就要进行向下转型&lt;/p&gt;
&lt;div&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1739529/202102/1739529-20210208230949835-654598911.png&quot; alt=&quot;&quot; width=&quot;862&quot; height=&quot;514&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;　　　　进行向下转型后就会出现Dog独有的run()方法，由此我们总结以下堕胎的特性：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、必需存在继承关系&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　　　　　&lt;/span&gt;2、子类必需重写了父类的方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　　　　　&lt;/span&gt;3、父类来收子类的对象 Animal animal = new Dog() 此处就是向上转型。我new出一个狗的对象，用Animal动物来接受，相当于我说狗是一种动物，这是完全合理的。 总结为接受的类的类型必需大于或者等于子类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　　　　　&lt;/span&gt;4、父类接受子类对象后，调用的方法或者属性都是父类中拥有的方法或者属性，但是执行的结果若是子类有重写，那就执行执行子类重写的方法，若是子类没有重写方法，那么执行父类自己的方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　　　　　&lt;/span&gt;5、父类接受子类对象后，若是调用子类独有的方法或者属性，必需要将父类类型向下转型为子类类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以上就是面向对象的三大特性，到此结束！！！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;















&lt;div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;A82E41AC98AA4DA78B14BFCDD10F679B&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;A82E41AC98AA4DA78B14BFCDD10F679B&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 08 Feb 2021 15:26:00 +0000</pubDate>
<dc:creator>一梦三千年</dc:creator>
<og:description>一、面向对象和面向过程的区别 1、面向过程（Procedure Oriented 简称PO） 看名字它是注重过程的。当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和 数据（用于方法的参数）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tar8087/p/14391501.html</dc:identifier>
</item>
<item>
<title>Python 分析热卖年货，今年春节大家都在送啥？ - 那个萝卜在飘</title>
<link>http://www.cnblogs.com/syy1757528181/p/14391470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/syy1757528181/p/14391470.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/yamaNj&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/08/yamaNj.md.jpg&quot; alt=&quot;yamaNj.md.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;今年不知道有多少小伙伴留在原地过年，虽然今年过年不能回老家，但这个年也得过，也得买年货，给家人长辈送礼。于是我出于好奇心的想法利用爬虫获取某宝数据，并结合 Python 数据分析和第三方可视化平台来分析一下大家过年都买了哪些东西，分析结果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/yamUEQ&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/08/yamUEQ.jpg&quot; alt=&quot;yamUEQ.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面使用清洗好的数据后用 finebi 第三方可视化工具完成的。接下来是用 Python 的实现过程，对于本文的叙述，主要分为以下五步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分析思路&lt;/li&gt;
&lt;li&gt;爬虫部分&lt;/li&gt;
&lt;li&gt;数据清洗&lt;/li&gt;
&lt;li&gt;数据可视化及分析&lt;/li&gt;
&lt;li&gt;结论与建议&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一、分析思路&quot;&gt;一、分析思路&lt;/h2&gt;
&lt;p&gt;其实就今天的数据来讲，我们主要做的是探索性分析；首先梳理已有的字段，有标题（提取出品类）、价格、销量、店铺名、发货地。下面来做一下详细的维度拆分以及可视化图形选择：&lt;br/&gt;品类:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;品类销量的 TOP 10 有哪些？（表格或者横向条形图）&lt;/li&gt;
&lt;li&gt;热门（出现次数最多）品类展示；（词云）&lt;br/&gt;价格：年货的价格区间分布情况；（圆环图，观察占比）&lt;br/&gt;销量、店铺名：&lt;/li&gt;
&lt;li&gt;店铺销量最高的 TOP 10 有哪些？（条形图）&lt;/li&gt;
&lt;li&gt;结合品类做联动，比如点坚果，对应展示销量排名的店铺；（联动，利用三方工具）&lt;br/&gt;发货地：销量最高的城市有哪些？（地图）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、爬取数据&quot;&gt;二、爬取数据&lt;/h2&gt;
&lt;p&gt;爬取主要利用 selenium 模拟点击浏览器，前提是已经安装 selenium 和浏览器驱动，这里我是用的 Google 浏览器，找到对应的版本号后并下载对应的版本驱动，一定要对应浏览器的版本号。&lt;br/&gt;pip install selenium&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/yamtHg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/08/yamtHg.jpg&quot; alt=&quot;yamtHg.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;安装成功后，运行如下代码，输入关键字&quot;年货&quot;，进行扫码就可以了，等着程序慢慢采集。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# coding=utf8
import re
from selenium.webdriver.chrome.options import Options
from selenium import webdriver
import time
import csv


# 搜索商品，获取商品页码
def search_product(key_word):
    # 定位输入框
    browser.find_element_by_id(&quot;q&quot;).send_keys(key_word)
    # 定义点击按钮，并点击
    browser.find_element_by_class_name('btn-search').click()
    # 最大化窗口：为了方便我们扫码
    browser.maximize_window()
    # 等待15秒，给足时间我们扫码
    time.sleep(15)
    # 定位这个“页码”，获取“共100页这个文本”
    page_info = browser.find_element_by_xpath('//div[@class=&quot;total&quot;]').text
    # 需要注意的是：findall()返回的是一个列表，虽然此时只有一个元素它也是一个列表。
    page = re.findall(&quot;(\d+)&quot;, page_info)[0]
    return page


# 获取数据
def get_data():
    # 通过页面分析发现：所有的信息都在items节点下
    items = browser.find_elements_by_xpath('//div[@class=&quot;items&quot;]/div[@class=&quot;item J_MouserOnverReq  &quot;]')
    for item in items:
        # 参数信息
        pro_desc = item.find_element_by_xpath('.//div[@class=&quot;row row-2 title&quot;]/a').text
        # 价格
        pro_price = item.find_element_by_xpath('.//strong').text
        # 付款人数
        buy_num = item.find_element_by_xpath('.//div[@class=&quot;deal-cnt&quot;]').text
        # 旗舰店
        shop = item.find_element_by_xpath('.//div[@class=&quot;shop&quot;]/a').text
        # 发货地
        address = item.find_element_by_xpath('.//div[@class=&quot;location&quot;]').text
        # print(pro_desc, pro_price, buy_num, shop, address)
        with open('{}.csv'.format(key_word), mode='a', newline='', encoding='utf-8-sig') as f:
            csv_writer = csv.writer(f, delimiter=',')
            csv_writer.writerow([pro_desc, pro_price, buy_num, shop, address])


def main():
    browser.get('https://www.taobao.com/')
    page = search_product(key_word)
    print(page)
    get_data()
    page_num = 1
    while int(page) != page_num:
        print(&quot;*&quot; * 100)
        print(&quot;正在爬取第{}页&quot;.format(page_num + 1))
        browser.get('https://s.taobao.com/search?q={}&amp;amp;s={}'.format(key_word, page_num * 44))
        browser.implicitly_wait(25)
        get_data()
        page_num += 1
    print(&quot;数据爬取完毕！&quot;)


if __name__ == '__main__':
    key_word = input(&quot;请输入你要搜索的商品：&quot;)
    option = Options()
    browser = webdriver.Chrome(chrome_options=option,
                               executable_path=r&quot;C:\Users\cherich\AppData\Local\Google\Chrome\Application\chromedriver.exe&quot;)
    main()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;采集结果如下：&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/yam6DU&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/08/yam6DU.jpg&quot; alt=&quot;yam6DU.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;数据准备完成，中间从标题里提取类别过程比较耗时，建议大家直接用整理好的数据。&lt;br/&gt;大概思路是对标题进行分词，命名实体识别，标记出名词，找出类别名称，比如坚果、茶叶等。&lt;/p&gt;
&lt;h2 id=&quot;三、数据清洗&quot;&gt;三、数据清洗&lt;/h2&gt;
&lt;p&gt;这里的文件清洗几乎用 Excel 搞定，数据集小，用 Excel 效率很高，比如这里做了一个价格区间。到现在数据清洗已经完成（可以用三方工具做可视化了），如果大家爱折腾，可以接着往下看用 Python 如何进行分析。&lt;/p&gt;
&lt;h2 id=&quot;四、数据可视化及分析&quot;&gt;四、数据可视化及分析&lt;/h2&gt;
&lt;h3 id=&quot;1、读取文件&quot;&gt;1、读取文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import pandas as pd
import matplotlib as mpl
mpl.rcParams['font.family'] = 'SimHei'
from wordcloud import WordCloud
from ast import literal_eval
import matplotlib.pyplot as plt
datas = pd.read_csv('./年货.csv',encoding='gbk')
datas
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/yamrvV&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/08/yamrvV.jpg&quot; alt=&quot;yamrvV.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、可视化：词云图&quot;&gt;2、可视化：词云图&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;li = []
for each in datas['关键词'].values:
    new_list = str(each).split(',')
    li.extend(new_list)
def func_pd(words):
    count_result = pd.Series(words).value_counts()
    return count_result.to_dict()

frequencies = func_pd(li)
frequencies.pop('其他')

plt.figure(figsize = (10,4),dpi=80)
wordcloud = WordCloud(font_path=&quot;STSONG.TTF&quot;,background_color='white', width=700,height=350).fit_words(frequencies)
plt.imshow(wordcloud)
plt.axis(&quot;off&quot;)
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/yamyuT&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/08/yamyuT.jpg&quot; alt=&quot;yamyuT.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图表说明：我们可以看到词云图，热门（出现次数最多）品类字体最大，依次是：坚果、茶叶、糕点等。&lt;/p&gt;
&lt;h3 id=&quot;3、可视化：绘制圆环图&quot;&gt;3、可视化：绘制圆环图&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# plt.pie(x,lables,autopct,shadow,startangle,colors,explode)
food_type = datas.groupby('价格区间').size()
plt.figure(figsize=(8,4),dpi=80)
explodes= [0,0,0,0,0.2,0.1]
size = 0.3
plt.pie(food_type, radius=1,labels=food_type.index, autopct='%.2f%%', colors=['#F4A460','#D2691E','#CDCD00','#FFD700','#EEE5DE'],
       wedgeprops=dict(width=size, edgecolor='w'))
plt.title('年货价格区间占比情况',fontsize=18)
plt.legend(food_type.index,bbox_to_anchor=(1.5, 1.0))
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/yamhCR&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/08/yamhCR.jpg&quot; alt=&quot;yamhCR.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图表说明：圆环图和饼图类似，代表部分相对于整体的占比情况，可以看到0 ~ 200元的年货大概33%左右，100 ~ 200元也是33%。说明大部分的年货的价格趋于200以内。&lt;/p&gt;
&lt;h3 id=&quot;4、可视化：绘制条形图&quot;&gt;4、可视化：绘制条形图&lt;/h3&gt;
&lt;p&gt;data = datas.groupby(by='店铺名')['销量'].sum().sort_values(ascending=False).head(10)&lt;br/&gt;plt.figure(figsize = (10,4),dpi=80)&lt;/p&gt;
&lt;p&gt;plt.ylabel('销量')&lt;br/&gt;plt.title('年货销量前十名店铺',fontsize=18)&lt;br/&gt;colors = ['#F4A460','#D2691E','#CDCD00','#EEE5DE', '#EEB4B4', '#FFA07A', '#FFD700']&lt;br/&gt;plt.bar(data.index,data.values, color=colors)&lt;br/&gt;plt.xticks(rotation=45)&lt;br/&gt;plt.show()&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/yam481&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/08/yam481.jpg&quot; alt=&quot;yam481.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图表说明：以上是店铺按销量排名情况，可以看到第一名是三只松鼠旗舰店，看来过年大家都喜欢吃干货。&lt;/p&gt;
&lt;h3 id=&quot;5、可视化：绘制横向条形图&quot;&gt;5、可视化：绘制横向条形图&lt;/h3&gt;
&lt;p&gt;foods = datas.groupby(by='类别')['销量'].sum().sort_values(ascending=False).head(10)&lt;br/&gt;foods.sort_values(ascending=True,inplace=True)&lt;br/&gt;plt.figure(figsize = (10,4),dpi=80)&lt;br/&gt;plt.xlabel('销量')&lt;br/&gt;plt.title('年货推荐购买排行榜',fontsize=18)&lt;br/&gt;colors = ['#F4A460','#D2691E','#CDCD00','#CD96CD','#EEE5DE', '#EEB4B4', '#FFA07A', '#FFD700']&lt;br/&gt;plt.barh(foods.index,foods.values, color=colors,height=1)&lt;br/&gt;plt.show()&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/yamW59&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/02/08/yamW59.jpg&quot; alt=&quot;yamW59.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图表说明：根据类别销量排名，排名第一是坚果，验证了上面的假设，大家喜欢吃坚果。&lt;/p&gt;
&lt;h2 id=&quot;结论与建议&quot;&gt;结论与建议&lt;/h2&gt;
&lt;p&gt;淘宝热卖年货: 坚果，茶叶，糕点，饼干，糖果，白酒，核桃，羊肉，海参，枸杞；&lt;br/&gt;年货推荐清单（按销量）：坚果、零食、糕点、饼干、茶叶、糖果、松子、红枣、蛋糕、卤味、瓜子、牛奶、核桃；&lt;br/&gt;年货价格参考：66%以上的年货价格在0~200元之间；&lt;br/&gt;热门店铺：三只老鼠、天猫超市、百草味、良品铺子；&lt;/p&gt;
</description>
<pubDate>Mon, 08 Feb 2021 15:15:00 +0000</pubDate>
<dc:creator>那个萝卜在飘</dc:creator>
<og:description>今年不知道有多少小伙伴留在原地过年，虽然今年过年不能回老家，但这个年也得过，也得买年货，给家人长辈送礼。于是我出于好奇心的想法利用爬虫获取某宝数据，并结合 Python 数据分析和第三方可视化平台来分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/syy1757528181/p/14391470.html</dc:identifier>
</item>
<item>
<title>机器学习十讲-第三讲分类 - 清风紫雪</title>
<link>http://www.cnblogs.com/xiaofengzai/p/14391415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofengzai/p/14391415.html</guid>
<description>&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208222716532-1837337751.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 下面用一个 &lt;code&gt;perception&lt;/code&gt; 函数实现上述算法。为了深入观察算法运行过程，我们保留了每一轮迭代的参数 &lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-12-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mi mathvariant=&amp;quot;bold&amp;quot;&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-186&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-187&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-188&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-189&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-190&quot; class=&quot;mi&quot;&gt;w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;w，并对每一轮迭代中随机选取的样本也进行了记录。所以，&lt;code&gt;perception&lt;/code&gt; 函数返回三个取值: 最终学习到的参数 &lt;code&gt;w&lt;/code&gt;, 每轮迭代的参数 &lt;code&gt;W&lt;/code&gt;, 每轮迭代随机选取的样本 &lt;code&gt;mis_samples&lt;/code&gt; 。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; perception(X,y,learning_rate,max_iter=1000&lt;span&gt;):
    w &lt;/span&gt;= pd.Series(data=np.zeros_like(X.iloc[0]),index=X.columns) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化参数 w0&lt;/span&gt;
    W = [w] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个列表存放每次迭代的参数&lt;/span&gt;
    mis_samples = [] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存放每次误分类的样本&lt;/span&gt;
    
    &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(max_iter):
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.1 寻找误分类集合 M&lt;/span&gt;
        m = (X.dot(w))*y &lt;span&gt;#&lt;/span&gt;&lt;span&gt;yw^Tx &amp;lt; 0 的样本为误分类样本&lt;/span&gt;
        X_m = X[m &amp;lt;= 0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 误分类样本的特征数据&lt;/span&gt;
        y_m = y[m &amp;lt;= 0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 误分类样本的标签数据&lt;/span&gt;
        
        &lt;span&gt;if&lt;/span&gt;(len(X_m) &amp;gt; 0): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果有误分类样本，则更新参数；如果不再有误分类样本，则训练完毕。&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.2 从 M 中随机选取一个样本 i &lt;/span&gt;
            i =&lt;span&gt; np.random.randint(len(X_m))
            mis_samples.append(X_m.iloc[i,:])
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.3 更新参数 w &lt;/span&gt;
            w = w + learning_rate * y_m.iloc[i]*&lt;span&gt;X_m.iloc[i,:]
            W.append(w)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;: 
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            
    mis_samples.append(pd.Series(data&lt;/span&gt;=np.zeros_like(X.iloc[0]),index=&lt;span&gt;X.columns))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; w,W,mis_samples
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
w_percept,W,mis_samples = perception(data[[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ones&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]], data[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],1,max_iter=1000)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将学习到的感知机的决策直线可视化，观察分类效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
x1 = np.linspace(-6, 6, 50&lt;span&gt;)
x2 &lt;/span&gt;= - (w_percept[0]/w_percept[1])*x1 - w_percept[2]/w_percept[1]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
plt.figure(figsize=(8, 8)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置图片尺寸&lt;/span&gt;
&lt;span&gt;
plt.scatter(data_pos[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],data_pos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#E4007F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,marker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类别为1的数据绘制成洋红色&lt;/span&gt;
plt.scatter(data_neg[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],data_neg[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#007979&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,marker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类别为-1的数据绘制成深绿色&lt;/span&gt;
plt.plot(x1,x2,c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 画出分类直线&lt;/span&gt;
&lt;span&gt;
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$x_1$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置横轴标签&lt;/span&gt;
plt.ylabel(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$x_2$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置纵轴标签&lt;/span&gt;
plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;手动实现的感知机模型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlim(&lt;/span&gt;-6,6) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置横轴显示范围&lt;/span&gt;
plt.ylim(1,5) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置纵轴显示范围&lt;/span&gt;
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208223033434-2023675839.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208223120152-1024935571.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt; 代码实现&lt;/h2&gt;
&lt;h3 id=&quot;-3.1-梯度下降法求解逻辑回归&quot;&gt;梯度下降法求解逻辑回归&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义梯度下降法求解的迭代公式&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; logistic_regression(X,y,learning_rate,max_iter=1000&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化w&lt;/span&gt;
    w = np.zeros(X.shape[1&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(max_iter):      
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算yX&lt;/span&gt;
        yx = y.values.reshape((len(y),1)) *&lt;span&gt; X 
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算1 + e^(yXW)&lt;/span&gt;
        logywx = (1 +  np.power(np.e,X.dot(w)*y)).values.reshape(len(y),1&lt;span&gt;) 
        w_grad &lt;/span&gt;=&lt;span&gt; np.divide(yx,logywx).sum()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 迭代w&lt;/span&gt;
        w = w + learning_rate *&lt;span&gt; w_grad    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; w
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将数据及标签带入上面定义的函数，学习率设为 0.5 ，迭代次数为1000次，输出训练好的参数，并将分类结果进行可视化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出训练好的参数&lt;/span&gt;
w = logistic_regression(data[[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ones&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]], data[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],0.5,max_iter=1000&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(w)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可视化分类结果&lt;/span&gt;
x1 = np.linspace(-6, 6, 50&lt;span&gt;)
x2 &lt;/span&gt;= - (w[0]/w[1])*x1 - w[2]/w[1&lt;span&gt;]

plt.figure(figsize&lt;/span&gt;=(8, 8&lt;span&gt;))
plt.scatter(data_pos[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],data_pos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#E4007F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,marker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类别为1的数据绘制成洋红色&lt;/span&gt;
plt.scatter(data_neg[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],data_neg[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#007979&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,marker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类别为-1的数据绘制成深绿色&lt;/span&gt;
plt.plot(x1,x2,c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$x_1$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$x_2$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlim(&lt;/span&gt;-6,6&lt;span&gt;)
plt.ylim(&lt;/span&gt;1,5&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208223825734-1589209793.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h3 id=&quot;-3.2-随机梯度下降法求解逻辑回归&quot;&gt;随机梯度下降法求解逻辑回归&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208224332066-747769265.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义随机梯度下降法求解的迭代公式&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; logistic_regression_sgd(X,y, learning_rate, max_iter=1000&lt;span&gt;): 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化w&lt;/span&gt;
    w = np.zeros(X.shape[1&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(max_iter):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 随机选择一个样本&lt;/span&gt;
        i =&lt;span&gt; np.random.randint(len(X))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算yx&lt;/span&gt;
        yixi = y[i] *&lt;span&gt; X.values[i]
         &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算1 + e^(yxW)&lt;/span&gt;
        logyiwxi = 1 +  np.power(np.e, w.T.dot(X.values[i])*&lt;span&gt;y[i])
        w_grad &lt;/span&gt;= yixi /&lt;span&gt; logyiwxi
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 迭代w&lt;/span&gt;
        w = w + learning_rate *&lt;span&gt; w_grad  
        
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; w
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将学习率设为 0.5，迭代次数为1000次，并输出训练好的参数，将分类结果可视化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出训练好的参数&lt;/span&gt;
w = logistic_regression_sgd(data[[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ones&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]], data[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],0.5,max_iter=1000&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(w)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可视化分类结果&lt;/span&gt;
x1 = np.linspace(-6, 6, 50&lt;span&gt;)
x2 &lt;/span&gt;= - (w[0]/w[1])*x1 - w[2]/w[1&lt;span&gt;]

plt.figure(figsize&lt;/span&gt;=(8, 8&lt;span&gt;))
plt.scatter(data_pos[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],data_pos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#E4007F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,marker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类别为1的数据绘制成洋红色&lt;/span&gt;
plt.scatter(data_neg[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],data_neg[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#007979&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,marker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类别为-1的数据绘制成深绿色&lt;/span&gt;
plt.plot(x1,x2,c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$x_1$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$x_2$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlim(&lt;/span&gt;-6,6&lt;span&gt;)
plt.ylim(&lt;/span&gt;1,5&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208224431749-1835424196.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208224509821-1483221729.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt; 代码实现&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;%&lt;span&gt;matplotlib inline

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; linear_svm(X,y,lam,max_iter=2000&lt;span&gt;):  
    w &lt;/span&gt;= np.zeros(X.shape[1]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化w&lt;/span&gt;
    support_vectors = [] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建空列表保存支持向量&lt;/span&gt;
    
    &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; range(max_iter): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行迭代&lt;/span&gt;
&lt;span&gt;        
        learning_rate &lt;/span&gt;= 1/(lam * (t + 1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算本轮迭代的学习率&lt;/span&gt;
        i = np.random.randint(len(X)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从训练集中随机抽取一个样本&lt;/span&gt;
        ywx = w.T.dot(X.values[i])*y[i]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算y_i w^T x_i&lt;/span&gt;
        
        &lt;span&gt;if&lt;/span&gt; ywx &amp;lt; 1:&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行指示函数的判断&lt;/span&gt;
            w = w - learning_rate * lam*w + learning_rate * y[i] * X.values[i] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新参数       &lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            w &lt;/span&gt;= w - learning_rate * lam*w &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新参数&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(X)):
        ywx &lt;/span&gt;= w.T.dot(X.values[i])*y[i]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算y_i w^T x_i&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ywx &amp;lt;= 1: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据样本是否位于间隔附近判断是否为支持向量&lt;/span&gt;
&lt;span&gt;            support_vectors.append(X.values[i])
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; w,support_vectors
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，线性支持向量机的正则化项通常不包括截距项，我们可以将数据进行中心化，再调用上述代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对训练集数据进行归一化，则模型无需再计算截距项&lt;/span&gt;
X = data[[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]].apply(&lt;span&gt;lambda&lt;/span&gt; x: x -&lt;span&gt; x.mean())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练集标签&lt;/span&gt;
y = data[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
w,support_vectors &lt;/span&gt;= linear_svm(X,y, lam=0.05, max_iter=5000)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将得到的超平面可视化，同时将两个函数间隔为 1 的线也绘制出来。对于所有不满足约束的样本，使用圆圈标记出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建绘图框&lt;/span&gt;
plt.figure(figsize=(8, 8&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制两类样本点&lt;/span&gt;
X_pos = X[ y==1&lt;span&gt; ]
X_neg &lt;/span&gt;= X[ y==-1&lt;span&gt; ]
plt.scatter(X_pos[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],X_pos[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#E4007F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,marker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类别为1的数据绘制成洋红色&lt;/span&gt;
plt.scatter(X_neg[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],X_neg[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#007979&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,marker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类别为-1的数据绘制成深绿色&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制超平面&lt;/span&gt;
x1 = np.linspace(-6, 6, 50&lt;span&gt;)
x2 &lt;/span&gt;= - w[0]*x1/w[1&lt;span&gt;]
plt.plot(x1,x2,c&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制两个间隔超平面&lt;/span&gt;
plt.plot(x1,-(w[0]*x1+1)/w[1],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#007979&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(x1,&lt;/span&gt;-(w[0]*x1-1)/w[1],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#E4007F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 标注支持向量&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; support_vectors:
    plt.plot(x[0],x[&lt;/span&gt;1],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, linewidth=2, markersize=12,markerfacecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加轴标签和限制轴范围&lt;/span&gt;
plt.xlabel(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$x_1$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$x_2$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlim(&lt;/span&gt;-6,6&lt;span&gt;)
plt.ylim(&lt;/span&gt;-2,2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208224806398-2061726565.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;步骤&lt;/h2&gt;
&lt;p&gt;读取数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
raw_train = pd.read_csv(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./input/chinese_news_cutted_train_utf8.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,sep=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
raw_test &lt;/span&gt;= pd.read_csv(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./input/chinese_news_cutted_test_utf8.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,sep=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看训练集的前5行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
raw_train.head()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208224951556-273913300.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;为了简单，我们这里先只考虑二分类，我们选取主题为&quot;科技&quot;和“文化”新闻。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
raw_train_binary = raw_train[((raw_train[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;分类&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;科技&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) | (raw_train[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;分类&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))]
raw_test_binary &lt;/span&gt;= raw_test[((raw_test[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;分类&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;科技&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) | (raw_test[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;分类&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208225324545-202684417.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208225422358-2080037791.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208225525889-675340857.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208225542497-1312359240.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2 id=&quot;-6-模型效果评估&quot;&gt;模型效果评估&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面使用混淆矩阵来分析模型在测试集上的表现。混淆矩阵从样本的真实标签和模型预测标签两个维度对测试集样本进行分组统计，然后以矩阵的形式展示。借助混淆矩阵可以很好地分析模型在每一类样本上的分类效果。为了更直观地分析，我们借助 Python 中的可视化库 Seaborn 提供的 heatmap 函数，将线性支持向量机模型的混淆矩阵进行可视化。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; confusion_matrix
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; seaborn as sns
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
fig, ax &lt;/span&gt;= plt.subplots(figsize=(5,5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置正常显示中文&lt;/span&gt;
sns.set(font=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SimHei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制热力图&lt;/span&gt;
y_svm_pred = lsvm_clf.predict(X_test) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 预测标签&lt;/span&gt;
y_test_true = raw_test_binary[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;分类&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;真实标签&lt;/span&gt;
confusion_matrix = confusion_matrix(y_svm_pred,y_test_true)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算混淆矩阵&lt;/span&gt;
ax = sns.heatmap(confusion_matrix,linewidths=.5,cmap=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Greens&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                 annot&lt;/span&gt;=True, fmt=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,xticklabels=lsvm_clf.classes_, yticklabels=&lt;span&gt;lsvm_clf.classes_)
ax.set_ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;真实&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ax.set_xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;预测&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ax.xaxis.set_label_position(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
ax.xaxis.tick_top()
ax.set_title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;混淆矩阵热力图&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208225644121-1847248701.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可见：正对角线还是比较集中的，代表效果还不错&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在本案例中，我们使用随机梯度方法实现了三种使用回归的思想来解决分类问题的模型：感知机、逻辑回归和线性支持向量机。在实现时主要使用了 &lt;/span&gt;&lt;code&gt;NumPy&lt;/code&gt;&lt;span&gt;, &lt;/span&gt;&lt;code&gt;Pandas&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;Matplotlib&lt;/code&gt;&lt;span&gt; 等 Python 库。在 &lt;/span&gt;&lt;code&gt;Sklearn&lt;/code&gt;&lt;span&gt; 中，&lt;/span&gt;&lt;code&gt;linear.model.SGDClassifier&lt;/code&gt;&lt;span&gt; 类实现了常见算法的随机梯度下降实现。我们使用该类，在一份中文新闻数据上分别用随机梯度下降算法训练了感知机、逻辑回归和线性支持向量机模型，实现了对中文新闻主题的分类。最后，使用 &lt;/span&gt;&lt;code&gt;Sklearn.metrics&lt;/code&gt;&lt;span&gt; 实现的模型评价方法，用正确率和混淆矩阵对分类效果进行了简单的分析。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;%&lt;span&gt;matplotlib inline
yfx &lt;/span&gt;= np.linspace(-4, 4, 500&lt;span&gt;)
perception &lt;/span&gt;= [0 &lt;span&gt;if&lt;/span&gt; i &amp;gt;= 0 &lt;span&gt;else&lt;/span&gt; -i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; yfx]
hinge &lt;/span&gt;= [(1-i) &lt;span&gt;if&lt;/span&gt; i &amp;lt;= 1 &lt;span&gt;else&lt;/span&gt; 0 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; yfx]
log &lt;/span&gt;= np.log2(1 + np.power(np.e,-&lt;span&gt;yfx))
plt.figure(figsize&lt;/span&gt;=(8, 6&lt;span&gt;))
plt.plot(yfx,perception,c&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;感知机损失&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(yfx,hinge,c&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;合页损失(SVM)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(yfx,log,c&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;对数损失(LR)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.hlines(&lt;/span&gt;1,-4&lt;span&gt;,0)
plt.vlines(0,0,&lt;/span&gt;1&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$yf(x)$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$L_i(y_i,yf(x))$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlim(&lt;/span&gt;-4,4&lt;span&gt;)
plt.ylim(0,&lt;/span&gt;6&lt;span&gt;)
plt.legend()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208225831934-1211453191.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;以下为绘制三种分类模型的从回归到分类的映射函数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;%&lt;span&gt;matplotlib inline
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建画布并引入axisartist工具。&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; mpl_toolkits.axisartist as axisartist
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建画布&lt;/span&gt;
fig = plt.figure(figsize=(8, 8&lt;span&gt;))
fx &lt;/span&gt;= np.linspace(-10, 10, 500&lt;span&gt;)
step &lt;/span&gt;= [1 &lt;span&gt;if&lt;/span&gt; i &amp;gt;= 0 &lt;span&gt;else&lt;/span&gt; -1 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fx]
tanh &lt;/span&gt;=&lt;span&gt; np.tanh(fx)
sigmoid &lt;/span&gt;= 1/(1 + np.power(np.e,-&lt;span&gt;fx))
plt.axhline(0,&lt;/span&gt;-10,10,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.axvline(0,&lt;/span&gt;-2,2,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(fx,step,c&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;step&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(fx,tanh,c&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tanh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(fx,sigmoid,c&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sigmoid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$f$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$H(f)$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.grid(False)
plt.xlim(&lt;/span&gt;-10, 10&lt;span&gt;)
plt.ylim(&lt;/span&gt;-2,2&lt;span&gt;)
plt.axis(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.legend()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202102/1717524-20210208225854690-1018528932.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;raw_train = pd.read_csv(&quot;./input/chinese_news_cutted_train_utf8.csv&quot;,sep=&quot;\t&quot;,encoding=&quot;utf8&quot;)raw_test = pd.read_csv(&quot;./input/chinese_news_cutted_test_utf8.csv&quot;,sep=&quot;\t&quot;,encoding=&quot;utf8&quot;)&lt;/p&gt;
</description>
<pubDate>Mon, 08 Feb 2021 14:59:00 +0000</pubDate>
<dc:creator>清风紫雪</dc:creator>
<og:description>感知机 原理 下面用一个&amp;#160;perception&amp;#160;函数实现上述算法。为了深入观察算法运行过程，我们保留了每一轮迭代的参数&amp;#160;ww，并对每一轮迭代中随机选取的样本也进行了记录。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofengzai/p/14391415.html</dc:identifier>
</item>
<item>
<title>GDKOI2021 爆炸记 - あおいSakura</title>
<link>http://www.cnblogs.com/Sakura-TJH/p/GDKOI2021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sakura-TJH/p/GDKOI2021.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;


&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;害，我果然还是好菜。&lt;/p&gt;
&lt;p&gt;不会的照样不会，会打的还因为一堆奇奇怪怪的问题错了一大堆。&lt;/p&gt;
&lt;h2 id=&quot;普及（day-13）&quot;&gt;普及（Day 1~3）&lt;/h2&gt;
&lt;h3 id=&quot;day-one&quot;&gt;Day one&lt;/h3&gt;
&lt;h4 id=&quot;比赛&quot;&gt;比赛&lt;/h4&gt;
&lt;p&gt;拿到题目先看题。&lt;/p&gt;
&lt;p&gt;第一题看了一下，第一样过去人都蒙了。&lt;br/&gt;啊？这不是普及吗，怎么一个表的函数的呢？&lt;br/&gt;然后仔细看了几眼，发现只要简单模拟一下然后分类讨论就可以了。&lt;/p&gt;
&lt;p&gt;第二题，看到题目暴力很容易就出来了。&lt;br/&gt;然后想了想发现要快速求一个点左边比它高的一个和右边比它高的第一个。&lt;br/&gt;然后想了想没想到有什么算法。&lt;/p&gt;
&lt;p&gt;第三题，想了一会，发现它的数据 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 到了 &lt;span class=&quot;math inline&quot;&gt;\(1e6\)&lt;/span&gt;，而且觉得有点贪心，但是还没有完整的想法。&lt;br/&gt;然后想了一下，就去看下一题。&lt;/p&gt;
&lt;p&gt;第四题，一开始看了一会发现了一定是拿全部钱去买通行旅票的性质，然后就陷入和每次都要跑一个图会超时的思考。&lt;br/&gt;然后就滚去先敲第一题了。&lt;/p&gt;
&lt;p&gt;然后看题大概看了 &lt;span class=&quot;math inline&quot;&gt;\(15\)&lt;/span&gt; 分钟左右。&lt;/p&gt;
&lt;p&gt;然后先去搞第一题，因为思路完整，很快就写出来了。包上检查细节，大概用了 &lt;span class=&quot;math inline&quot;&gt;\(20\)&lt;/span&gt; 分钟。&lt;br/&gt;然后先去写第二题的暴力，就直接枚举两边第一个比它高的位置，然后前缀和算空间大小。大概用了 &lt;span class=&quot;math inline&quot;&gt;\(20\)&lt;/span&gt; 分钟。&lt;br/&gt;然后第三题还没有思路，就先去打第四题的暴力。然后打完暴力想了一下，发现可以离线处理，想弄最小生成树的样子，边按权值排序，然后依次处理出答案。&lt;br/&gt;（这个时候大概是过了 &lt;span class=&quot;math inline&quot;&gt;\(70\)&lt;/span&gt; 分钟）&lt;/p&gt;
&lt;p&gt;然后就去写，大概又写了 &lt;span class=&quot;math inline&quot;&gt;\(20\)&lt;/span&gt; 分钟，就写出来了。&lt;/p&gt;
&lt;p&gt;接着去想第三题，想了想，想到用最大加最小，然后具体的贪心方案也想了出来，就打。&lt;br/&gt;因为比较好实现，弄个 &lt;span class=&quot;math inline&quot;&gt;\(10\)&lt;/span&gt; 分钟就弄好了。&lt;/p&gt;
&lt;p&gt;接着去看第二题，做的时候一时间忘记了可以用单调队列找序列中第一个比它大的数，然后想来想去，最后用了二分+线段树来弄。&lt;br/&gt;然后这里大概又搞了二十分钟左右。&lt;/p&gt;
&lt;p&gt;然后全部打完了，就开始对拍。&lt;br/&gt;首先觉得第一题这么好弄是不是哪里有问题，就去弄第一个题的对拍。&lt;br/&gt;这题的对拍也是最好弄的，在生成随机数据的时候就可以先生成一个正确的，然后随机一个位置作为答案，然后改一下即可。&lt;/p&gt;
&lt;p&gt;结果我比赛时忘了生成随机种子是 &lt;code&gt;srand(time(0))&lt;/code&gt;，傻乎乎的一位是 &lt;code&gt;random()&lt;/code&gt;，然后就只能只能通过数据数组这个值过掉一些数，然后弄成随机的样子。&lt;/p&gt;
&lt;p&gt;然后在拍第一题的时候就去弄第二题的对拍。&lt;br/&gt;因为一开始打了暴力，就也很快弄好，就把第一题的对拍停了排第二题。&lt;br/&gt;注意，我这里的对拍没有看时间，只是看答案。&lt;/p&gt;
&lt;p&gt;然后拍第二题的时候就去弄第四题的对拍。&lt;br/&gt;（因为第三题贪心完之后实现很简单，而且暴力也不知道怎么打，就直接不对拍了）&lt;br/&gt;之前也是打过暴力，也很快弄好。&lt;/p&gt;
&lt;p&gt;然后我就三个对拍轮流跑，一直到比赛结束。&lt;/p&gt;
&lt;h4 id=&quot;赛后聊天&quot;&gt;赛后聊天&lt;/h4&gt;
&lt;p&gt;LYF 第二题用的是堆，然后一堆人全部用的算法各种各样。&lt;br/&gt;还说我的线段树常数很大，不知道能不能过。&lt;/p&gt;
&lt;p&gt;然后第三题的贪心跟一堆人对了应该是对的。&lt;/p&gt;
&lt;h4 id=&quot;下午讲题&quot;&gt;下午讲题&lt;/h4&gt;
&lt;p&gt;T1 分类套路，我的没问题。&lt;br/&gt;T2 结果是用单调队列来搞，就不知道我的线段树加二分能不能过。&lt;br/&gt;T3 贪心证实了是对的。&lt;br/&gt;T4 离线没问题。&lt;/p&gt;
&lt;p&gt;然后内心疯狂祈祷第二题能过。&lt;/p&gt;
&lt;h4 id=&quot;下午讲课&quot;&gt;下午讲课&lt;/h4&gt;
&lt;p&gt;讲数论，很多内容。&lt;br/&gt;我拿个草稿本不停记笔记，草稿本上没位置写了就跑回去拿个笔记本继续记。&lt;/p&gt;
&lt;p&gt;然后现在正在整理，到时会有一篇博客出来。&lt;/p&gt;
&lt;h4 id=&quot;晚上&quot;&gt;晚上&lt;/h4&gt;
&lt;p&gt;出成绩了，&lt;span class=&quot;math inline&quot;&gt;\(340\)&lt;/span&gt;。&lt;br/&gt;（&lt;span class=&quot;math inline&quot;&gt;\(100+40+100+100\)&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;LYF 和 LXY 两位大爷反手就 AK 了。&lt;/p&gt;
&lt;p&gt;第二题超时了，然后我才发现我打的对拍一直都没有看超时。&lt;br/&gt;然后就去跟 LYF 这个神仙的代码对拍。&lt;/p&gt;
&lt;p&gt;然后发现有的时候我确实会超时。&lt;/p&gt;
&lt;p&gt;然后 LYF 大爷看了一眼我的代码，说：“你怎么不用快读快输呢？”&lt;br/&gt;我：“哦！c！是哦！。”&lt;/p&gt;
&lt;p&gt;然后我加了个快读快输之后，它跑得飞快。&lt;br/&gt;。。。&lt;br/&gt;我直接哭死。&lt;/p&gt;
&lt;h3 id=&quot;day-two&quot;&gt;Day two&lt;/h3&gt;
&lt;h4 id=&quot;比赛-1&quot;&gt;比赛&lt;/h4&gt;
&lt;p&gt;听说题目难度会变高，感觉要凉。&lt;/p&gt;
&lt;p&gt;拿到题目先看题。&lt;br/&gt;第一题看到有点慌，然后想了一会觉得应该可以找每个数循环起来之后最后一个数的周期，然后最后把每个数轮到的周期数乘起来，就可以得到最后一位。&lt;br/&gt;第二题想了一会，感觉思路有点混乱，不知道先约束哪个条件，然后就跳去看下一题。&lt;br/&gt;第三题看了一下题，发现就是走树上的链。然后又是距离，然后直接跑又过不了，然后就想到了用倍增。但是具体怎么实现还不是很清楚，就去看下一题。&lt;br/&gt;最烦的构造题目，看着题目一脸懵逼。看半天也没有想法，就先做题了。&lt;/p&gt;
&lt;p&gt;看题大概都看了半个小时，人都傻掉了。&lt;/p&gt;
&lt;p&gt;然后去弄第一题，打完结果发现样例都过不了，自己的想法是错的。&lt;br/&gt;然后就更加慌了，感觉自己今天要爆蛋。&lt;br/&gt;然后调试了一下，发现 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(5\)&lt;/span&gt; 乘在一起会一一消掉。&lt;br/&gt;然后改了一下发现还是过不了。&lt;/p&gt;
&lt;p&gt;然后又发现其实可以把不是质数的数拆开，然后只剩下 &lt;span class=&quot;math inline&quot;&gt;\(2,3,5,7\)&lt;/span&gt;，二和五再消掉之后再按末尾规律乘起来。&lt;/p&gt;
&lt;p&gt;然后过了样例，自己出了几个小数据也过了，就去弄下一题了。&lt;/p&gt;
&lt;p&gt;然后先去弄第三题，先正常的弄个了树上倍增。然后想了想，因为要弄距离最小值，我们可以弄到根距离的最大值最小值，然后分类讨论一下乱搞，然后就试着打。&lt;br/&gt;但是因为比较混乱，打出来的也不知道对不对，过了样例和自己出的数据就走人了。&lt;/p&gt;
&lt;p&gt;然后去想第二题怎么搞，想了很久，想到一个方法，就是先按正则二叉树的规定建树，然后再看是否是正则二叉树。&lt;/p&gt;
&lt;p&gt;然后去看第四题，一脸懵，只会瞎搞，搞了个全部都是 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 和行列和为 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 的情况，还不知道会不会有锅。&lt;/p&gt;
&lt;h4 id=&quot;赛后聊天-1&quot;&gt;赛后聊天&lt;/h4&gt;
&lt;p&gt;第一题对了一下大家都差不多。&lt;/p&gt;
&lt;p&gt;第二题大家算法各有不同，问了一下我的算法，才突然想起来最后没有判断是否是 bfs 序，然后就贼慌。&lt;/p&gt;
&lt;p&gt;第三题大家似乎都是用倍增，但我思路糊成一团，应该都是没有分的了。&lt;/p&gt;
&lt;p&gt;第四题好像说可以把图转化成只有 &lt;span class=&quot;math inline&quot;&gt;\(0,1\)&lt;/span&gt; 的，然而这样我还是不会做。&lt;/p&gt;
&lt;h4 id=&quot;下午讲题-1&quot;&gt;下午讲题&lt;/h4&gt;
&lt;p&gt;第一题没问题。&lt;/p&gt;
&lt;p&gt;第二题好像是一个神奇的算法，弄成很多棵树，然后一个一个看放儿子。就不知道我的能不能过（应该不行，因为没看 bfs 序）。&lt;/p&gt;
&lt;p&gt;第三题正解也是倍增，而且想法和我的差不多。但我那垃圾的代码实现能力告诉我我应该是不行的。&lt;/p&gt;
&lt;p&gt;第四题真的可以把图转成 &lt;span class=&quot;math inline&quot;&gt;\(0,1\)&lt;/span&gt; ，然后简单判断一下就可以了。&lt;/p&gt;
&lt;h4 id=&quot;下午讲课-1&quot;&gt;下午讲课&lt;/h4&gt;
&lt;p&gt;讲的是概率，海星吧。&lt;/p&gt;
&lt;h4 id=&quot;晚上-1&quot;&gt;晚上&lt;/h4&gt;
&lt;p&gt;成绩出了，&lt;span class=&quot;math inline&quot;&gt;\(200\)&lt;/span&gt;。&lt;br/&gt;（&lt;span class=&quot;math inline&quot;&gt;\(100+100+0+0\)&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;第二题过了是我妹想到的。&lt;/p&gt;
&lt;p&gt;果然，第三题炸了。&lt;/p&gt;
&lt;p&gt;然后第四题的部分分还打错了，我就是个菜鸡。&lt;/p&gt;
&lt;p&gt;LYF 大爷还自己弄了个 Excel 表格看前两天分数的排名。&lt;/p&gt;
&lt;p&gt;AJ 说明天题目会没有前两天那么简单。&lt;br/&gt;LYF：我信你个鬼，第一天那么简单，怎么可能比第一天还简单。&lt;br/&gt;我和 LTH：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/693aee3254ece4bb83804d5163646cd0.png#pic_left&quot; alt=&quot;/jk&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/693aee3254ece4bb83804d5163646cd0.png#pic_left&quot; alt=&quot;/jk&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/693aee3254ece4bb83804d5163646cd0.png#pic_left&quot; alt=&quot;/jk&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会宿舍的时候，LYF 跟我说明天可能会有 dp、斜率优化……&lt;br/&gt;因为前面没有考。&lt;/p&gt;
&lt;p&gt;我：普及考斜率优化？&lt;br/&gt;LYF：斜率优化其实很简单。&lt;br/&gt;我：/jk&lt;/p&gt;
&lt;h3 id=&quot;day-three&quot;&gt;Day three&lt;/h3&gt;
&lt;h4 id=&quot;比赛-2&quot;&gt;比赛&lt;/h4&gt;
&lt;p&gt;拿到题目先看题。&lt;/p&gt;
&lt;p&gt;第一题看是否相似，直接三边比例相同即可。&lt;br/&gt;想了一下精度可能会有问题，但觉得用 double 应该不会出锅。&lt;/p&gt;
&lt;p&gt;第二题看了一下觉得就是看极限情况，觉得手推一下应该有结论，就没有管太多。&lt;/p&gt;
&lt;p&gt;第三题是数论，大概看了一下就想着暴力。&lt;/p&gt;
&lt;p&gt;第四题看起来也很数论，就也想了一下暴力。&lt;/p&gt;
&lt;p&gt;然后先去弄第一题，一开始忘了按长度排序，就直接暴力匹配。&lt;br/&gt;（但是这个不是问题）&lt;br/&gt;然后还是怕精度有问题，就弄了个 1e-6。&lt;/p&gt;
&lt;p&gt;然后第二题推了一下极限数据，就发现了大概的贪心。&lt;br/&gt;最低就是你永远零分，比你低的视为跟你一样零分，比你高的就是满分。然后每次把满分分给不同的人。&lt;br/&gt;最高就是你永远比满分只差无限小的分数，比你高的是满分，比你低的是零分。那就尽可能把满分分配给有过没有满分的人，那全部都是满分的人数就是当时在你前面的人数。&lt;/p&gt;
&lt;p&gt;然后就去先把第三第四题的暴力打出来。&lt;br/&gt;然后先去看第三题，一开始看能不能把最后里面的那一维去掉。&lt;br/&gt;当然，你会发现你可以在枚举到第二维的时候记忆化一下答案，因为第二维可能会多次选到同一个数，而且第一维对它是没有影响的。&lt;br/&gt;那我们就打一下表，看看结果：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(998244353,1,998244353,998244353,1,998244353,998244353,998244353,998244353,1\)&lt;/span&gt;&lt;br/&gt;等等，为什么会有 &lt;span class=&quot;math inline&quot;&gt;\(998244353\)&lt;/span&gt;，这个不是模数吗？&lt;br/&gt;哦，有个地方忘了取模。（国 际 憨 憨 TJH）&lt;br/&gt;把取模弄好之后：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(0,1,0,0,1,0,0,0,0,1\)&lt;/span&gt;&lt;br/&gt;好像一开始 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 的话是 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的话是 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，然后两个 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 之间隔开的距离从 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 开始每次增加 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;打个程序验证一下，发现是对的。&lt;/p&gt;
&lt;p&gt;然后再一看，发现这个就是平方数的位置是 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，否则是 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。&lt;br/&gt;那弄回去一看……&lt;br/&gt;兄嘚，这个不就是求 &lt;span class=&quot;math inline&quot;&gt;\(1\sim n\)&lt;/span&gt; 中每个数有多少个平方数因子，然后每个个数的和吗？&lt;/p&gt;
&lt;p&gt;然后就火速实现。&lt;/p&gt;
&lt;p&gt;然后去搞 T4。&lt;br/&gt;想了想 LYF 大爷的话，想到可能是 dp。&lt;br/&gt;然后想到一个十分暴力，可以说是 &lt;span class=&quot;math inline&quot;&gt;\(n^5\)&lt;/span&gt; 复杂度的暴力，然后一看数据范围，好像能过挺多的点。然后就去打。&lt;br/&gt;结果大数据跑得飞快，自己弄个了极限数据，也过了？！&lt;/p&gt;
&lt;p&gt;然后就开始搞对拍，由于前两题似乎不太好弄，就只弄了三四题的对拍。&lt;/p&gt;
&lt;p&gt;因为打过暴力，所以也很快。&lt;/p&gt;
&lt;p&gt;然后就看着对拍等结束。&lt;/p&gt;
&lt;h4 id=&quot;赛后聊天-2&quot;&gt;赛后聊天&lt;/h4&gt;
&lt;p&gt;好像也没聊啥特别的。&lt;/p&gt;
&lt;h4 id=&quot;下午讲题-2&quot;&gt;下午讲题&lt;/h4&gt;
&lt;p&gt;第一题证明方法是对的，但是说因为精度问题要化成最简分数的形式。&lt;br/&gt;危 TJH 危&lt;/p&gt;
&lt;p&gt;第二题大致的方向是对的，但是它的具体实现好像和我的不一样。&lt;/p&gt;
&lt;p&gt;第三题数论推对了。&lt;/p&gt;
&lt;p&gt;第四题就是 &lt;span class=&quot;math inline&quot;&gt;\(n^5\)&lt;/span&gt; 的 dp。&lt;/p&gt;
&lt;h4 id=&quot;下午讲课-2&quot;&gt;下午讲课&lt;/h4&gt;
&lt;p&gt;将的是凸包。&lt;br/&gt;有个初一的在讲课的时候当场把模板切了。&lt;br/&gt;我好菜，我可以退役了。/kk&lt;/p&gt;
&lt;h4 id=&quot;晚上-2&quot;&gt;晚上&lt;/h4&gt;
&lt;p&gt;成绩出来，&lt;span class=&quot;math inline&quot;&gt;\(355\)&lt;/span&gt;。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(85+70+100+100\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;果然，前两题出锅了。&lt;/p&gt;
&lt;p&gt;第一题应该是精度问题，听说改成 long double 然后 &lt;span class=&quot;math inline&quot;&gt;\(12\)&lt;/span&gt; 位精度就可以过。&lt;br/&gt;血亏。&lt;/p&gt;
&lt;p&gt;第二题应该是实现的问题。&lt;/p&gt;
&lt;p&gt;明天就要提高，想想普及的恶心难度，我觉得提高要凉。&lt;/p&gt;
&lt;h2 id=&quot;提高（day-46）&quot;&gt;提高（Day 4~6）&lt;/h2&gt;
&lt;h3 id=&quot;day-four&quot;&gt;Day four&lt;/h3&gt;
&lt;h4 id=&quot;比赛-3&quot;&gt;比赛&lt;/h4&gt;
&lt;p&gt;先看题。&lt;/p&gt;
&lt;p&gt;第一题就是一个构造题，一脸懵。&lt;br/&gt;然后想了想，可以每次选当时度数最大的点放到另一个集合。然后大概这个方法搞搞。&lt;br/&gt;结果一看只能过 &lt;span class=&quot;math inline&quot;&gt;\(20\)&lt;/span&gt; 分的。&lt;/p&gt;
&lt;p&gt;然后看第二题。想了一下，想了个 &lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt; 暴力就滚了。&lt;/p&gt;
&lt;p&gt;然后第三题，看到回文串就想到 hash，然后就想到了 &lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt; 算法。&lt;/p&gt;
&lt;p&gt;然后第四题，看到题目一脸懵，然后看了看数据，好像也就 &lt;span class=&quot;math inline&quot;&gt;\(k=0\)&lt;/span&gt; 能做。&lt;/p&gt;
&lt;p&gt;然后就先弄先把前两题暴力写出来。&lt;br/&gt;然后写第三题，就写 hash+二分那个。&lt;br/&gt;然后把第四题 &lt;span class=&quot;math inline&quot;&gt;\(k=0\)&lt;/span&gt; 的情况水了。&lt;/p&gt;
&lt;p&gt;然后发现第二题可以把每个点高度被选为最大值时贡献排序后的连续部分一起过掉。然后就打了一下。&lt;/p&gt;
&lt;p&gt;然后想了想第一题的二分图应该也可以试着做一做。&lt;br/&gt;然后就去弄。&lt;/p&gt;
&lt;p&gt;然后弄完之后只剩十多分钟，就检查了一下，就结束了。&lt;/p&gt;
&lt;h4 id=&quot;赛后聊天-3&quot;&gt;赛后聊天&lt;/h4&gt;
&lt;p&gt;LYF 神仙竟然只写了一题，不过是正解。&lt;br/&gt;LYF，永远的神！！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210208153038875.gif&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;下午讲题-3&quot;&gt;下午讲题&lt;/h4&gt;
&lt;p&gt;第一题似乎是 LYF 神仙的做法，sto LYF orz。&lt;br/&gt;第二题跟我的想法差不多，但是它可以提前处理出来，然后用二分，然后就可以不用每次都找一遍，只用二分一下弄一下就可以了。&lt;br/&gt;第三题好像是用马拉车，但是 hash 也行。（当然还要别的，这个只是说判断是否回文）然后好像要二分，然后还要用 ST 表来维护之类的玩意。&lt;br/&gt;第四题，好像要生成函数，然后又要化式子，一顿操作比例巴拉的。&lt;/p&gt;
&lt;h4 id=&quot;下午讲课-3&quot;&gt;下午讲课&lt;/h4&gt;
&lt;p&gt;讲拟阵，非常懵逼。&lt;br/&gt;一堆英文，然后念 PPT。&lt;br/&gt;好像一直听下去并且听懂的只有初一的 WCR 大爷。&lt;br/&gt;（又是初一的，我可能该退役了）&lt;/p&gt;
&lt;h4 id=&quot;晚上-3&quot;&gt;晚上&lt;/h4&gt;
&lt;p&gt;出成绩了，&lt;span class=&quot;math inline&quot;&gt;\(180\)&lt;/span&gt;。&lt;br/&gt;（&lt;span class=&quot;math inline&quot;&gt;\(100+50+30+0\)&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;第一题过了是我妹想到的。&lt;br/&gt;我好像大于 &lt;span class=&quot;math inline&quot;&gt;\(20\)&lt;/span&gt; 的情况都是当二分图来处理啊。&lt;/p&gt;
&lt;p&gt;然后好像很多人用二分图的算法过了这道题。&lt;/p&gt;
&lt;p&gt;LYF 血亏，惨。&lt;/p&gt;
&lt;h3 id=&quot;day-five&quot;&gt;Day five&lt;/h3&gt;
&lt;h4 id=&quot;比赛-4&quot;&gt;比赛&lt;/h4&gt;
&lt;p&gt;先看题目。&lt;/p&gt;
&lt;p&gt;第一题，好像在哪里见过……&lt;br/&gt;反正就是推方程嘛，让我想想方程啊。&lt;br/&gt;忘了，那重新推吧。&lt;br/&gt;（那时的我仍没有意识到事情的严重性）&lt;/p&gt;
&lt;p&gt;第二题，大概想了一下，发现可以用线段树维护一下一直向前跳。&lt;br/&gt;大概是 &lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt; 算法。&lt;/p&gt;
&lt;p&gt;第三题，看了一下觉得可以 hash 加贪心。&lt;/p&gt;
&lt;p&gt;至于第四题，看了一下打算直接暴力。&lt;/p&gt;
&lt;p&gt;然后推第一题的式子，推了个样例过了的。&lt;br/&gt;就不管了。&lt;/p&gt;
&lt;p&gt;然后第二题打线段树。&lt;br/&gt;也把第三题贪心了一下，结果发现我的贪心有问题。然后想了想，打了个部分分 dp。&lt;/p&gt;
&lt;p&gt;然后第四题打暴力。&lt;/p&gt;
&lt;h4 id=&quot;赛后聊天-4&quot;&gt;赛后聊天&lt;/h4&gt;
&lt;p&gt;我：对一下第一题的方程。&lt;br/&gt;LYF：啊？第一题不是做过吗。&lt;br/&gt;我：我忘了。&lt;br/&gt;LYF：你自己看。（打开博客）&lt;br/&gt;我：（看了眼方程）耶！推错了呢！&lt;br/&gt;LYF：这个不是做过吗，那你还错？&lt;br/&gt;我：我是废物啊！（神志丧失ing）&lt;/p&gt;
&lt;h4 id=&quot;下午讲题-4&quot;&gt;下午讲题&lt;/h4&gt;
&lt;p&gt;第一题。。。&lt;br/&gt;没事了，我是**。&lt;/p&gt;
&lt;p&gt;第二题大概的想法差不多，但是它的实现比较高级。&lt;/p&gt;
&lt;p&gt;第三题确实是 dp，但是要想要用堆来缩短一下时间。&lt;/p&gt;
&lt;p&gt;第四题，好像是要把操作转成上浮的，然后再做就会好做很多。&lt;/p&gt;
&lt;h4 id=&quot;下午讲课-4&quot;&gt;下午讲课&lt;/h4&gt;
&lt;p&gt;将的是有关随机的。&lt;/p&gt;
&lt;p&gt;一开始还听得懂，然后就逐渐蒙圈。&lt;br/&gt;然后就变成了半掉线的状态。&lt;/p&gt;
&lt;p&gt;（当然，初一神仙 WCR 肯定是全程听完了啦）&lt;/p&gt;
&lt;h4 id=&quot;晚上-4&quot;&gt;晚上&lt;/h4&gt;
&lt;p&gt;分数出了，&lt;span class=&quot;math inline&quot;&gt;\(120\)&lt;/span&gt;。&lt;br/&gt;（&lt;span class=&quot;math inline&quot;&gt;\(0+20+70+30\)&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;我就知道第一题没好事。&lt;/p&gt;
&lt;p&gt;LYF 神仙反手就切了第一第三题。&lt;/p&gt;
&lt;h3 id=&quot;day-six&quot;&gt;Day six&lt;/h3&gt;
&lt;h4 id=&quot;比赛-5&quot;&gt;比赛&lt;/h4&gt;
&lt;p&gt;先看题目。&lt;/p&gt;
&lt;p&gt;第一题看了一下，觉得自己不会暴力。&lt;br/&gt;想了一下因式分解，觉得勉强能水点分。&lt;br/&gt;第二题想了想，弄出了个 &lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt; 暴力。&lt;br/&gt;第三题想到暴力模拟，然后一看数据发现一个都过不了。但是觉得只有一个细胞开始的可以试着推规律。&lt;br/&gt;第四题，题目都看的一脸懵，就打算水部分分。&lt;/p&gt;
&lt;p&gt;第一题试着弄了一下暴力，然后打出了第二题的暴力。&lt;br/&gt;然后去看第三题一个细胞怎么弄，然后弄了一个多小时弄出了规律，就打了上去。（结果还是不能过一个细胞全部数据）&lt;/p&gt;
&lt;p&gt;然后去看第四题，也不知道写哪个部分分。&lt;br/&gt;就打了个分成两个集合的，也不知道对不对。&lt;/p&gt;
&lt;h4 id=&quot;下午讲题-5&quot;&gt;下午讲题&lt;/h4&gt;
&lt;p&gt;第一题好像确实要因式分解，然后一堆恶心分类讨论。&lt;br/&gt;第二题好像要 bitset 优化， 然后又 FFT。&lt;br/&gt;第三题好像是要探究出一个异或的东西来确定当前时间某个点是活是死。然后又要通过容斥来算个数，然后再弄一个数位 dp。&lt;br/&gt;第四题好像还要数据分治，分成两个集合的那个数据点时二分再弄一堆东西。其它的好像有一个是最小生成树，还有一个也是二分，但好像还有证明一个东西，然后再搞。&lt;/p&gt;
&lt;h4 id=&quot;下午讲课-5&quot;&gt;下午讲课&lt;/h4&gt;
&lt;p&gt;讲多项式。&lt;/p&gt;
&lt;p&gt;开局一个 FFT，中文名都不知道的我直接裂开。&lt;/p&gt;
&lt;p&gt;然后啥都不知道，就只能看看它证明的过程。&lt;br/&gt;连证明的前提条件和证出来了什么东西，是干嘛的都完全不知道。&lt;/p&gt;
&lt;p&gt;害，我太菜了。&lt;/p&gt;
&lt;h4 id=&quot;晚上-5&quot;&gt;晚上&lt;/h4&gt;
&lt;p&gt;虽然下午就出成绩的但还是写晚上吧。&lt;br/&gt;（不要破坏队形）&lt;/p&gt;
&lt;p&gt;分数是 &lt;span class=&quot;math inline&quot;&gt;\(85\)&lt;/span&gt;。&lt;br/&gt;（&lt;span class=&quot;math inline&quot;&gt;\(10+60+15+0\)&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;海星，但第二天的第一题让我彻底炸掉了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;海星，但是还是很爆炸。&lt;/p&gt;
&lt;p&gt;各种奇妙挂分。&lt;br/&gt;快读、精度、期望。&lt;/p&gt;
&lt;p&gt;最不应该的是做过的题都能错。&lt;br/&gt;不愧是我。&lt;/p&gt;
&lt;p&gt;不过有了这次的惨痛经历，下次比赛都会加上快读，好好看精度，好好推式子，不要依靠垃圾样例了。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Feb 2021 14:25:00 +0000</pubDate>
<dc:creator>あおいSakura</dc:creator>
<og:description>害，我果然还是好菜。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Sakura-TJH/p/GDKOI2021.html</dc:identifier>
</item>
<item>
<title>LSTM - 长短期记忆网络 - renyuzhuo</title>
<link>http://www.cnblogs.com/renyuzhuo/p/14391235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renyuzhuo/p/14391235.html</guid>
<description>&lt;h2 id=&quot;循环神经网络rnn&quot;&gt;循环神经网络(RNN)&lt;/h2&gt;
&lt;p&gt;人们不是每一秒都从头开始思考，就像你阅读本文时，不会从头去重新学习一个文字，人类的思维是有持续性的。传统的卷积神经网络没有记忆，不能解决这一个问题，循环神经网络(Recurrent Neural Networks)可以解决这一个问题，在循环神经网络中，通过循环可以解决没有记忆的问题，如下图：&lt;/p&gt;
&lt;center&gt;&lt;img width=&quot;150&quot; alt=&quot;RNN-rolled&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0436cf25dd8a0c602d293b0def07f78a.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;看到这里，你可能还是不理解为什循环神经网络就可以有记忆。我们把这个图展开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/60df123b5f7a9f15387bc22e261faac5.png&quot; alt=&quot;RNN-unrolled&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，我们输入 &lt;span class=&quot;math inline&quot;&gt;\(X_0\)&lt;/span&gt; 后，首先警告训练，得到输出 &lt;span class=&quot;math inline&quot;&gt;\(h_0\)&lt;/span&gt;，同时会把这个输出传递给下一次训练 &lt;span class=&quot;math inline&quot;&gt;\(X_1\)&lt;/span&gt;，普通的神经网络是不会这样做的，这时对 &lt;span class=&quot;math inline&quot;&gt;\(X_1\)&lt;/span&gt; 进行训练时，输入就包括了 &lt;span class=&quot;math inline&quot;&gt;\(X_1\)&lt;/span&gt; 本身和 训练 &lt;span class=&quot;math inline&quot;&gt;\(X_0\)&lt;/span&gt; 的输出，前面的训练对后面有印象，同样的道理，之后的每一次训练都收到了前面的输出的影响(对 &lt;span class=&quot;math inline&quot;&gt;\(X_1\)&lt;/span&gt; 训练的输出传递给训练 &lt;span class=&quot;math inline&quot;&gt;\(X_2\)&lt;/span&gt; 的过程，&lt;span class=&quot;math inline&quot;&gt;\(X_0\)&lt;/span&gt; 对 &lt;span class=&quot;math inline&quot;&gt;\(X_2\)&lt;/span&gt; 的影响是间接的)。&lt;/p&gt;
&lt;h2 id=&quot;遇到的问题&quot;&gt;遇到的问题&lt;/h2&gt;
&lt;p&gt;循环神经网络很好用，但是还有一些问题，主要体现在没办法进行长期记忆。我们可以想象(也有论文证明)，前期的某一次输入，在较长的链路上传递时，对后面的影响越来越小，相当于网络有一定的记忆能力，但是记忆力只有 7 秒，很快就忘记了，如下图 &lt;span class=&quot;math inline&quot;&gt;\(X_0\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(X_1\)&lt;/span&gt; 对 &lt;span class=&quot;math inline&quot;&gt;\(h_{t+1}\)&lt;/span&gt; 的影响就比较小了（理论上通过调整参数避免这个问题，但是寻找这个参数太难了，实践中不好应用，因此可以近似认为不可行），LSTM 的提出就是为了解决这个问题的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/017e2d0e4566f6e69b206ecdfd86c173.png&quot; alt=&quot;RNN-longtermdependencies&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;lstm&quot;&gt;LSTM&lt;/h2&gt;
&lt;p&gt;LSTM(Long Short Term Memory)本质还是一种 RNN，只不过其中的那个循环，上图中的那个 A被重新设计了，目的就是为了解决记忆时间不够长的问题，其他神经网络努力调整参数为的是使记忆力更好一点，结果 LSTM 天生过目不忘，简直降维打击！&lt;/p&gt;
&lt;p&gt;普通的 RNN 中的 A 如下图，前一次的输入和本次的输入，进行一次运算，图中用的是 tanh：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e89bf3a9094af060e4ac7c1aff97ce25.png&quot; alt=&quot;LSTM3-SimpleRNN&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相比较起来，LSTM 中的 A 就显得复杂了好多，不是上图单一的神经网络层，而是有四层，如下图，并且似乎这么看还有点看不懂，这就是本文需要重点分析的内容，仔细认真读下去，定会有收获：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/338578c02a522a5a8cfdca218fdfd025.png&quot; alt=&quot;LSTM3-chain&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义一些图形的含义，黄色方框是简单的神经网络层；粉色的代表逐点操作，如加法乘法；还有合并和分开(拷贝)操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/06bc65a119c1384d13a409e8033325e3.png&quot; alt=&quot;LSTM2-notation&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心思想&quot;&gt;核心思想&lt;/h2&gt;
&lt;p&gt;首先看下图高亮部分，前一次的输出，可以几乎没有阻碍的一直沿着这条高速公路流动，多么简单朴素的思想，既然希望前面的训练不被遗忘，那就一直传递下去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e064d3f9b48a7a25fbcccbbf90ad8e52.png&quot; alt=&quot;LSTM3-C-line&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，为了让这种传递更加有意义，需要加入一些门的控制，这种门具有选择性，可以完全通过，可以完全不通过，可以部分通过，S 函数(Sigmoid)可以达到这样的目的，下面这样就是一个简单的门：&lt;/p&gt;
&lt;center&gt;&lt;img width=&quot;150&quot; alt=&quot;LSTM3-gate&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d61d7749bc675d36995ea8a52c68bd71.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;总结一下，我们构造 LSTM 网络，这个网络有能力让前面的数据传递到最后，网络具有长期记忆的能力，同时也有门的控制，及时舍弃那些无用的记忆。&lt;/p&gt;
&lt;h2 id=&quot;详细分析&quot;&gt;详细分析&lt;/h2&gt;
&lt;p&gt;有了这样的核心思想，再看这个网络就简单了好多，从左到右第一层是“选择性忘记”。我们根据前一次的输出和本次的输入，通过 Sigmoid 判断出前一次哪些记忆需要保留和忘记：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f2e538854e835fb4474a14e7b4d7f389.png&quot; alt=&quot;LSTM3-focus-f&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二部分又分为了两个部分，一个部分是“输入门层”，用 Sigmoid 决定哪些信息需要进行更新，另一个部分是创建候选值向量，即本次输入和上次输出进行初步计算后的中间状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/24762713e096f50129af5de8775874f7.png&quot; alt=&quot;LSTM3-focus-i&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过前面的计算，我们可以更新单元格的状态了。第一步，前一个的单元格哪些数据需要传递，哪些数据需要忘记；第二步，本次的哪些数据需要更新，乘以本次计算的中间状态可以得到本次的更新数据；再把前两步的数据相加，就是新的单元格状态，可以继续向后传递。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7a7381a48e7d7fe8b41861f8646e2094.png&quot; alt=&quot;LSTM3-focus-C&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一步需要决定我们的输出：第一步，我们用 Sigmoid 来判断我们需要输出的部分；第二步，把上面计算得到的单元格状态通过 tanh 计算将数据整理到 -1 到 1 的区间内；第三步，把第一步和第二步的数据相乘，就得到了最后的输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/931908f3469eae8e6cd97701293cbc96.png&quot; alt=&quot;LSTM3-focus-o&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结一下我们刚刚做了什么：我们首先通过本次的输入和上次的输出，判断出上次单元格状态有哪些数据需要保留或舍弃，再根据本次的输入进行网络训练，进一步得到本次训练的单元格状态和输出，并将单元格状态和本次的输出继续往后传递。&lt;/p&gt;
&lt;p&gt;这里有一个疑问，为什么需要舍弃？举个例子，翻译一篇文章，一篇文章前一段介绍某一个人的详细信息和背景，下一段介绍今天发生的某个故事，两者的关系是弱耦合的，需要及时舍弃前面对人背景信息的记忆，才会更好的翻译下面的故事。&lt;/p&gt;
&lt;p&gt;其他一些基于 LSTM 修改版的网络，本质是一样的，只不过把某些地方打通了，有论文验证过，一般情况下对训练的结果影响很小，这里不展开介绍，大同小异，修内功而不是那些奇奇怪怪的招式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e852fb3efdc85cd5d7d9191fdcfb2088.png&quot; alt=&quot;LSTM3-var-peepholes&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/aeeaca22aa2af4eae7c652bb31c7713f.png&quot; alt=&quot;LSTM3-var-tied&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/ff0fee122a5d8183df1f39a3f3d12610.png&quot; alt=&quot;LSTM3-var-GRU&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了长短期记忆网络，在大多数情况下，若在某个领域用 RNN 取得了比较好的效果，其很可能就是使用的 LSTM。这是一篇好文，本文图片来自&lt;a href=&quot;http://colah.github.io/posts/2015-08-Understanding-LSTMs/&quot; target=&quot;_blank&quot;&gt;Understanding-LSTMs&lt;/a&gt;，值得一读。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文首发自: &lt;a href=&quot;https://ai.renyuzhuo.cn&quot; target=&quot;_blank&quot;&gt;RAIS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 08 Feb 2021 14:02:00 +0000</pubDate>
<dc:creator>renyuzhuo</dc:creator>
<og:description>循环神经网络(RNN) 人们不是每一秒都从头开始思考，就像你阅读本文时，不会从头去重新学习一个文字，人类的思维是有持续性的。传统的卷积神经网络没有记忆，不能解决这一个问题，循环神经网络(Recurre</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/renyuzhuo/p/14391235.html</dc:identifier>
</item>
<item>
<title>浅谈Webpack模块打包工具三 - メSerendipity</title>
<link>http://www.cnblogs.com/websiteblogs/p/14391197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/websiteblogs/p/14391197.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Source Map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生产代码与开发代码完全不同，如果需要调试应用的话会非常的麻烦,错误信息无法定位,Soutce Map就会逆向得到源代码,&lt;/p&gt;
&lt;p&gt;须在打包之后的代码文件的末尾位置例如添加//# sourceMappingURL=jquery-3.4.1.min.map字段即开启sourceMap我们就&lt;/p&gt;
&lt;p&gt;可以调试Jquery的源代码了打开浏览器调试工具的Source模块也可以看到引入的.js文件，（html引入的.min.js文件）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210208214220465-2134784437.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Webpack配置Source Map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;devtool配置我们开发工程中的辅助工具及与source map相关的一些配置,webpack支持12种sourceMap的格式，每种方式的效率&lt;/p&gt;
&lt;p&gt;和效果各不相同，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210208214310591-355631200.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面对其他模式的sourcemap进行模式对比&lt;/p&gt;
&lt;p&gt;1.eval模式：可以运行字符串中的代码eval('console.log(123)') 默认通过在代码中添加 //#sourceURL+路径 的形式定位源码文件这种&lt;/p&gt;
&lt;p&gt;模式不会生成sourcemap文件，这种模式的速度是最快的，但是只能定位文件名称,而不知道具体的行列信息。&lt;/p&gt;
&lt;p&gt;2.eval-sourceMap：除了可以定位文件 还可以定位行和列的信息,生成了SourceMap。&lt;/p&gt;
&lt;p&gt;3.cheap-eval-source-map：定位到行，而没有列的信息。&lt;/p&gt;
&lt;p&gt;4.cheap-module-eval-source-map 跟上面的cheap-eval-source-map对比多了个module,对比代码发现module对应源代码，跟我们编&lt;/p&gt;
&lt;p&gt;写的源代码是一摸一样的,而上面的则是编译成ES5的代码。&lt;/p&gt;
&lt;p&gt;综上所述拼接特点,基本上我们已经可以知道所有的模式了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210208214527322-1295581022.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.hidden-source-map：生成了注释文件 但是代码中并没有用注释的方式引入文件 我们是看不到效果的&lt;/p&gt;
&lt;p&gt;6.nosource-source-map 保护源代码 不允许查看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Webpack 自动刷新问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然有webpack-dev-server能给我们解决大部分问题,但是也有的问题显得比较鸡肋,比如输入文本字体样式，每次编辑完成之后刷页&lt;/p&gt;
&lt;p&gt;面字体消失 还要重新输入，Webpack提供了一种不刷新的前提下，模块也可以及时更新的方法Webpack HMR。&lt;/p&gt;
&lt;p&gt;Webpack HMR体验：模块热替换 应用运行过程中实时替换某个模块 应用运行状态不受影响。&lt;/p&gt;
&lt;p&gt;webpack HMR已经集成到了webpack-dev-server中 只需要加上 webpack-dev-server --hot,也可以通过配置文件去开启由于JS无法像&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;CSS&lt;/em&gt;那样有条理的覆盖,所以JS与图片等无规律的热更新需要手动配置，webpack没有一个通用的状态,除非用到框架，因为框架本身&lt;/p&gt;
&lt;p&gt;是一个模板，完整代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210208214807334-1110547981.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210208214815648-292219047.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 08 Feb 2021 13:48:00 +0000</pubDate>
<dc:creator>メSerendipity</dc:creator>
<og:description>Source Map 生产代码与开发代码完全不同，如果需要调试应用的话会非常的麻烦,错误信息无法定位,Soutce Map就会逆向得到源代码, 须在打包之后的代码文件的末尾位置例如添加//# sour</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/websiteblogs/p/14391197.html</dc:identifier>
</item>
<item>
<title>【Java】位操作符 - Nemo&amp;</title>
<link>http://www.cnblogs.com/blknemo/p/14141417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blknemo/p/14141417.html</guid>
<description>&lt;p&gt;java支持的位运算符有7个，分为两类：位逻辑运算和移位运算。位逻辑运算符包括按位取反（~）、按位与（&amp;amp;）、按位或（|）和按位异或（^）4种，。移位运算符包括左移（&amp;lt;&amp;lt;）、右移（&amp;gt;&amp;gt;）和无符号右移（&amp;gt;&amp;gt;&amp;gt;）3种。位运算符只能用于整型数据，包括byte、short、int、long和char类型。下表列出了各种位运算符的功能与示例。假设a = 10, b = 3。&lt;/p&gt;
&lt;p&gt;~运算符是对运算数的每一位按位取反。&lt;/p&gt;
&lt;p&gt;下表列出了位运算符的基本运算,假设整数变量A的值为60和变量B的值为13：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果相对应位都是1，则结果为1，否则为0&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A &amp;amp; B&lt;/code&gt;得到12，即0000 1100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果相对应位都是0，则结果为0，否则为1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A | B&lt;/code&gt;得到61，即 0011 1101&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果相对应位值相同，则结果为0，否则为1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A ^ B&lt;/code&gt;得到49，即 0011 0001&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按位取反运算符翻转操作数的每一位，即0变成1，1变成0。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~A&lt;/code&gt;得到-61，即1100 0011&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按位左移运算符。左操作数按位左移右操作数指定的位数。&lt;br/&gt;（低位补零）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A &amp;lt;&amp;lt; 2&lt;/code&gt;得到240，即 1111 0000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;“有符号”按位右移运算符。左操作数按位右移右操作数指定的位数。&lt;br/&gt;该操作符使用 “符号扩展”：若符号为正，则高位插入 0；若符号为负，则高位插入 1。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A &amp;gt;&amp;gt; 2&lt;/code&gt;得到15即 1111&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;“无符号”按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。&lt;br/&gt;该操作符使用 “零扩展”，无论正负，都在高位插入 0。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A&amp;gt;&amp;gt;&amp;gt;2&lt;/code&gt;得到15即0000 1111&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;按位操作符用来操作整数的二进制位，会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。&lt;/p&gt;
&lt;p&gt;与操作符 “&amp;amp;”，如果两个输入位都是 1，那么输出位是 1，否则输入位是 0；&lt;br/&gt;或操作符 “|” ，如果两个输入位有一个是 1，那么输出位是 1，只有两个输入位都是 0，输出位才是 0；&lt;br/&gt;异或运算符 “^”，如果两个输入位都为 1 或者都为 0，那么输出位是 0，否则输出位是 1。&lt;br/&gt;非运算符 “~”，这个一元操作符，只能对一个数操作，规则是输出位与输入位相反。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//转化为二进制：0101
int num1 = 5;
//转化为二进制：1001
int num2 = 9;
//与运算，二进制结果为 0001，打印结果为 1
System.out.println(num1 &amp;amp; num2);
//或运算，二进制结果为 1101，打印结果为 13
System.out.println(num1 | num2);
//异或运算，二进制结果为 1100，打印结果为 12
System.out.println(num1 ^ num2);
//非运算，二进制结果为 11111111111111111111111111111010，打印结果 -6
System.out.println(Integer.toBinaryString(~num1));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好吧，进哥承认，我看到那个 -6 也蒙了那么一下，所以整理了以下内容。&lt;/p&gt;
&lt;h2 id=&quot;补充&quot;&gt;补充&lt;/h2&gt;
&lt;p&gt;数字的二进制表现形式为 “有符号的二进制补码”。&lt;br/&gt;原码：数字的二进制表示法，最高位为符号位， “ 0 ” 为正，“ 1 ” 为负。&lt;br/&gt;反码：正数的反码与原码相同，负数的反码对原码逐位取反，符号位除外。&lt;br/&gt;补码：正数的补码与原码相同，负数的补码在其反码末位加 1。&lt;br/&gt;负数的二进制算法（以 -6 为例）：&lt;br/&gt;1）将 -6 的绝对值转化为二进制，即：00000000 00000000 00000000 00000110&lt;br/&gt;2）求该二进制数的反码，即：11111111 11111111 11111111 11111001&lt;br/&gt;3）对以上求得的二进制数加 1，即：11111111 11111111 11111111 11111010&lt;/p&gt;

&lt;p&gt;移位操作符的运算对象也是二进制的 “位”，但是只能用来处理整数类型。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;左移位操作符 “&amp;lt;&amp;lt;” 按照操作符右侧指定的位数将操作符左边的操作数向左移动（低位补零）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;“有符号”右移位操作符 “&amp;gt;&amp;gt;” 按照操作符右侧指定的位数将操作符左边的操作数向右移动。该操作符使用 “符号扩展”：若符号为正，则高位插入 0；若符号为负，则高位插入 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;“无符号”右移位操作符 “&amp;gt;&amp;gt;&amp;gt;”，该操作符使用 “零扩展”，无论正负，都在高位插入 0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//二进制 1111;
int i = 15;
//向右边移动两位，二进制结果为 0011，打印结果为 3
System.out.println(i &amp;gt;&amp;gt; 2);
//向左边移动两位，二进制结果为 111100，打印结果为 60
System.out.println(i &amp;lt;&amp;lt; 2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;移位操作符可以与等号组合使用（&amp;lt;&amp;lt;= 或 &amp;gt;&amp;gt;= 或 &amp;gt;&amp;gt;&amp;gt;=），表示操作符左边的值会移动由右边数值指定的位数，再将得到的结果赋给左边的变量。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Java运算符按功能可分为：算数运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和条件运算符。&lt;/p&gt;
&lt;h2 id=&quot;算数运算符&quot;&gt;算数运算符&lt;/h2&gt;
&lt;p&gt;算术运算符包括通常的加（+）、减（-）、乘（*）、除（/）、取模（%），完成整数型和浮点型数据的算术运算。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;许多语言中的取模运算只能用于整数型，Java对此做了扩展，它允许对浮点数进行取模操作。例如，3%2 的结果是 1, 15.2%5 的结果是 0.2。取模操作还可以用于负数，结果的符号与第一个操作数的符号相同，例如，5%-3 的结果是 2，-5%3 的结果是-2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，算术运算符还有“++”和“--”两种，分别称为加1和减1运算符。这两种运算符有前缀形式和后缀形式，含有有所不同。例如，i++ 和 ++i 的执行顺序是不一样的，i++ 在 i 使用之后再 +1，++i 在 i 使用之前先 +1。i-- 和 --i 的情况于此类似。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int i = 1;
System.out.println(i++); //i++，使用之后+1，此处输出1

int i = 1;
System.out.println(++i); //++i，先+1再使用，此处输出2

int i = 1;
System.out.println(i--); //i--，使用之后-1，此处输出1

int i = 1;
System.out.println(--i); //--i，先-1再使用，此处输出0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关系运算符&quot;&gt;关系运算符&lt;/h2&gt;
&lt;p&gt;关系运算符用来比较两个值，包括大于（&amp;gt;）、小于（&amp;lt;）、大于等于（&amp;gt;=）、小于等于（&amp;lt;=）、等于（==）和不等于（!=）6种。关系运算符都是二元运算符，也就是每个运算符都带有两个操作数，运算的结果是一个逻辑值。Java允许“==”和“!=”两种运算符用于任何数据类型。例如，既可以判断两个数的值是否相等，也可以判断对象或数组的实例是否相等。判断实例时比较的是两个对象在内存中的引用地址是否相等。&lt;/p&gt;
&lt;h2 id=&quot;逻辑运算符&quot;&gt;逻辑运算符&lt;/h2&gt;
&lt;p&gt;逻辑运算符包括逻辑与（&amp;amp;&amp;amp;）、逻辑或（||）和逻辑非（!）。前两个是二元运算符，后一个是一元运算符。Java对逻辑与和逻辑或提供“短路”功能，也就是在进行运算时，先计算运算符左侧的表达式的值，如果使用该值能得到整个表达式的值，则跳过运算符右侧表达式的计算，否则计算运算符右侧表达式，并得到整个表达式的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//逻辑与&amp;amp;&amp;amp;,有一个表达式的结果是false,整体就返回false
String str = null;
if(str != null &amp;amp;&amp;amp; str.length0 &amp;gt; 2) {
      // str是null, &amp;amp;&amp;amp;左侧的表达式的结果是false,不会计算&amp;amp;&amp;amp;右侧的表达式，直接整体返回false
}

str= &quot;abc&quot;;
if(str != null &amp;amp;&amp;amp; str.length0&amp;gt; 5) {
      // &amp;amp;&amp;amp;左侧的表达式的结果是true,会接着计算&amp;amp;&amp;amp;右侧的表达式，右侧表达式的值是false,整个if中的表达式的结果就返回false
}

//逻辑或||，有一个表达式的结果是true,整体就返回true
str= &quot;qq&quot;;
if(str == null II str.length0== 2) {
      // ||左侧的表达式的结果是false,会接着计算||右侧的表达式，右侧结果是true, 则整体返回true
}
if(str != null II str.ength0 == 2) {
      // ||左侧的表达式的结果是true, 不会计算||右侧的表达式, 直接整体返回true
}

//逻辑非!,表达式结果是true,就返回false; 表达式结果是false,就返回true
boolean flag = true;
System.out.printIn(!flag); //输出false
flag = false;
System.out.printn(!flag); //输出true&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;位运算符-1&quot;&gt;位运算符&lt;/h2&gt;
&lt;p&gt;位运算符用来对二进制位进行操作，包括按位取反（~）、按位与（&amp;amp;）、按位或（|）、异或（^）、右移（&amp;gt;&amp;gt;）、左移（&amp;lt;&amp;lt;）和无符号右移（&amp;gt;&amp;gt;&amp;gt;）。位运算符只能对整数型和字符型数据进行操作。&lt;/p&gt;
&lt;h3 id=&quot;取反&quot;&gt;1. 取反（~）&lt;/h3&gt;
&lt;p&gt;参加运算的一个数据，按二进制位进行“取反”运算。&lt;/p&gt;
&lt;p&gt;运算规则：~1=0； ~0=1；&lt;/p&gt;
&lt;p&gt;即：对一个二进制数按位取反，即将0变1，1变0。&lt;/p&gt;
&lt;h3 id=&quot;按位与&quot;&gt;2. 按位与（&amp;amp;）&lt;/h3&gt;
&lt;p&gt;参加运算的两个数据，按二进制位进行“与”运算。&lt;/p&gt;
&lt;p&gt;运算规则：0&amp;amp;0=0; 0&amp;amp;1=0; 1&amp;amp;0=0; 1&amp;amp;1=1；即：两位同时为“1，结果才为“1，否则为0。&lt;/p&gt;
&lt;p&gt;例如：3&amp;amp;5 即 0000 0011 &amp;amp; 0000 0101 = 0000 0001 因此，3 &amp;amp; 5的值得1。&lt;/p&gt;
&lt;h3 id=&quot;按位或&quot;&gt;3. 按位或（|）&lt;/h3&gt;
&lt;p&gt;参加运算的两个对象，按二进制位进行“或”运算。&lt;/p&gt;
&lt;p&gt;运算规则：0 | 0=0； 0 | 1=1； 1 | 0=1； 1 | 1=1；&lt;/p&gt;
&lt;p&gt;即 ：参加运算的两个对象只要有一个为1，其值为1。&lt;/p&gt;
&lt;p&gt;例如：3 | 5，即 0000 0011 | 0000 0101 = 0000 0111 因此，3 | 5的值得7。&lt;/p&gt;
&lt;h3 id=&quot;异或&quot;&gt;4. 异或（^）&lt;/h3&gt;
&lt;p&gt;参加运算的两个数据，按二进制位进行“异或”运算。&lt;/p&gt;
&lt;p&gt;运算规则：0^0=0； 0^1=1； 1^0=1； 1^1=0；&lt;/p&gt;
&lt;p&gt;即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。&lt;/p&gt;
&lt;h3 id=&quot;左移&quot;&gt;5. 左移（&amp;lt;&amp;lt;）&lt;/h3&gt;
&lt;p&gt;运算规则：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。例如： 12345 &amp;lt;&amp;lt; 1，则是将数字12345左移1位：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1542615/202101/1542615-20210117164217426-1889164234.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;位移后十进制数值变成：24690，刚好是12345的二倍，所以有些人会用左位移运算符代替乘2的操作，但是这并不代表是真的就是乘以2，很多时候，我们可以这样使用，但是一定要知道，位移运算符很多时候可以代替乘2操作，但是这个并不代表两者是一样的。&lt;/p&gt;
&lt;p&gt;思考一下：如果任意一个十进制的数左位移32位，右边补位32个0，十进制岂不是都是0了？当然不是！！！ 当int 类型的数据进行左移的时候，当左移的位数大于等于32位的时候，位数会先求余数，然后再进行左移，也就是说，如果真的左移32位 12345 &amp;lt;&amp;lt; 32 的时候，会先进行位数求余数，即为 12345&amp;lt;&amp;lt;(32%32) 相当于 12345&amp;lt;&amp;lt; 0 ，所以12345&amp;lt;&amp;lt; 33 的值和12345&amp;lt;&amp;lt;1 是一样的，都是 24690。&lt;/p&gt;
&lt;h3 id=&quot;右移&quot;&gt;6. 右移（&amp;gt;&amp;gt;）&lt;/h3&gt;
&lt;p&gt;同样，还是以12345这个数值为例，12345右移1位： 12345&amp;gt;&amp;gt;1。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1542615/202101/1542615-20210117164222086-2128481806.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右移后得到的值为 6172 和int 类型的数据12345除以2取整所得的值一样，所以有些时候也会被用来替代除2操作。另外，对于超过32位的位移，和左移运算符一样，，会先进行位数求余数。&lt;/p&gt;
&lt;h3 id=&quot;无符号右移&quot;&gt;7. 无符号右移（&amp;gt;&amp;gt;&amp;gt;）&lt;/h3&gt;
&lt;p&gt;无符号右移运算符和右移运算符是一样的，不过无符号右移运算符在右移的时候是补0的，而右移运算符是补符号位的。以下是-12345二进制表示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1542615/202101/1542615-20210117164231931-746865151.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于源码、反码、补码不熟悉的同学，请自行学习，这里就不再进行补充了讲解了，这里提醒一下，在右移运算符中，右移后补0，是由于正数 12345 符号位为0 ，如果为1，则应补1。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1542615/202101/1542615-20210117164236763-1292281200.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、原码、反码和补码说明：一个数可以分成符号位（0正1负）+ 真值，原码是我们正常想法写出来的二进制。由于计算机只能做加法，负数用单纯的二进制原码书写会出错，于是大家发明了反码（正数不变，负数符号位不变，真值部分取反）；再后来由于+0， -0的争端，于是改进反码，变成补码（正数不变，负数符号位不变，真值部分取反，然后+1）。二进制前面的0都可以省略，所以总结来说：计算机里的负数都是用补码（符号位1，真值部分取反+1）表示的。2、位运算符和2的关系位运算符和乘2、除2在大多数时候是很相似的，可以进行替代，同时效率也会高的多，但是两者切记不能混淆 ；很多时候有人会把两者的概念混淆，尤其是数据刚好是 2、4、6、8、100等偶数的时候，看起来就更相似了，但是对于奇数，如本文使用的12345 ，右移之后结果为6172 ，这个结果就和数学意义上的除以2不同了，不过对于int 类型的数据，除2 会对结果进行取整，所以结果也是6172 ，这就更有迷惑性了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;赋值运算符&quot;&gt;赋值运算符&lt;/h2&gt;
&lt;p&gt;赋值运算符的作用就是将常量、变量或表达式的值赋给某一个变量。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;赋值&lt;/td&gt;
&lt;td&gt;a=3;b=2;&lt;/td&gt;
&lt;td&gt;a=3;b=2;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;加等于&lt;/td&gt;
&lt;td&gt;a=3;b=2;a+=b;&lt;/td&gt;
&lt;td&gt;a=5;b=2;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;-=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;减等于&lt;/td&gt;
&lt;td&gt;a=3;b=2;a-=b;&lt;/td&gt;
&lt;td&gt;a=1;b=2;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;*=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;乘等于&lt;/td&gt;
&lt;td&gt;a=3;b=2;a*=b;&lt;/td&gt;
&lt;td&gt;a=6;b=2;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;/=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;除等于&lt;/td&gt;
&lt;td&gt;a=3;b=2;a/=b;&lt;/td&gt;
&lt;td&gt;a=1;b=2;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;%=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;模等于&lt;/td&gt;
&lt;td&gt;a=3;b=2;a%=b;&lt;/td&gt;
&lt;td&gt;a=3;b=2;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;除了“=”，其它的都是特殊的赋值运算符，以“+=”为例，x += 3就相当于x = x + 3，首先会进行加法运算x+3，再将运算结果赋值给变量x。-=、*=、/=、%=赋值运算符都可依此类推。&lt;/p&gt;
&lt;h2 id=&quot;条件运算符&quot;&gt;条件运算符&lt;/h2&gt;
&lt;p&gt;条件运算符（ ? : ）也称为 “三元运算符”或“三目运算符”。&lt;/p&gt;
&lt;p&gt;语法形式：布尔表达式 ？ 表达式1 ：表达式2。&lt;/p&gt;
&lt;p&gt;运算过程：如果布尔表达式的值为 true ，则返回 表达式1的值，否则返回 表达式2 的值。&lt;/p&gt;
&lt;h2 id=&quot;运算符的优先次序&quot;&gt;运算符的优先次序&lt;/h2&gt;
&lt;p&gt;在对一个表达式进行计算时，如果表达式中含有多种运算符，则要安运算符的优先次序一次从高向低进行。运算符的优先次序如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1542615/202101/1542615-20210117164913888-521540700.png&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;[]、.、()&lt;/td&gt;
&lt;td&gt;方法调用，属性获取&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;!、~、++、--&lt;/td&gt;
&lt;td&gt;一元运算符&lt;/td&gt;
&lt;td&gt;从右向左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;*、/、%&lt;/td&gt;
&lt;td&gt;乘、除、取模（余数）&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;+、-&lt;/td&gt;
&lt;td&gt;加、减&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、&amp;gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;左位移、右位移、无符号右位移&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=、instanceof&lt;/td&gt;
&lt;td&gt;小于、小于等于、大于、大于等于&lt;br/&gt;对象类型判断是否属于同类型&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;==、!=&lt;/td&gt;
&lt;td&gt;相等、不相等&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;按位与&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;按位异或&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;按位或&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;逻辑与&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;逻辑或&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;条件运算符&lt;/td&gt;
&lt;td&gt;从右向左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;=、+=、-=、*=、/=、%=、&amp;amp;=、|=、^=、&amp;gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;混合赋值运算符&lt;/td&gt;
&lt;td&gt;从右向左&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 08 Feb 2021 13:20:00 +0000</pubDate>
<dc:creator>Nemo&amp;</dc:creator>
<og:description>位运算符 java支持的位运算符有7个，分为两类：位逻辑运算和移位运算。位逻辑运算符包括按位取反（~）、按位与（&amp;amp;amp;）、按位或（|）和按位异或（^）4种，。移位运算符包括左移（&amp;amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blknemo/p/14141417.html</dc:identifier>
</item>
<item>
<title>Dapr 已在塔架就位 将发射新一代微服务 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/14390918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/14390918.html</guid>
<description>&lt;p&gt;微服务是云原生架构的核心，通常使用Kubernetes 来按需管理服务扩展。 微软一直走在 Cloud Native Computing Foundation的 最前沿，并通过使用Kubernetes来支持其超大规模Azure和其混合云Azure Stack，微软对云原生的投资一部分来自其工具，该工具具有一系列支持云原生微服务开发的不同平台和服务。除了.NET也是微软在云原生应用开发的一个重要平台，&lt;a href=&quot;https://dapr.io/&quot;&gt;Dapr&lt;/a&gt;（&lt;a href=&quot;https://dapr.io/&quot;&gt;分布式应用程序运行时）&lt;/a&gt;也是另外一个非常重要的平台，根据官方文档的说法，Dapr是一个可移植、事件驱动的运行时，让企业开发者更容易利用各种语言和框架构建柔性、无状态和有状态的微服务应用，并运行在云端和边缘。 Dapr的核心由Go语言写成，开发团队一开始有计划使用.NET Core/C#来写，但是考虑到社区的接受程度，遂最终选定Go作为开发语言。&lt;/p&gt;
&lt;p&gt;Dapr 自 2019年秋季发布以来已经有一段时间了，但是在过去的一年中一直在继续开发， 并且最近已经发布第三个候选版本可用，因此&lt;a href=&quot;https://blog.dapr.io/posts/2021/02/03/dapr-v1.0.0-rc.3-is-now-available/&quot;&gt;Dapr 1.0版本并不遥远&lt;/a&gt;，希望该候选版本是最后一个候选版本，并在未来几周内正式发布v1.0，也就是说春节后就可以正式投入生产了 。该开发过程包括开发工具和Dapr CLI，用于设置开发环境并帮助应用程序脚手架，随时为您添加代码。 如果您还没有看过Dapr，那么春节正是开始看看它是否可以帮助您更快地构建服务的好时机。&lt;/p&gt;
&lt;p&gt;Dapr CLI是一个不错的起点，它可与本地Docker安装一起使用。它适用于Linux，macOS和Windows，并提供主要版本的安装说明。推荐大家从几篇由朱永光 写的文章开始了解：&lt;/p&gt;
&lt;p&gt;云原生的微服务在任何现代应用程序框架中都越来越重要，因此选择正确的开发环境和工具至关重要。随着Dapr接近其1.0版本，它为我们提供了一组构建块和支持工具，可帮助我们以易于部署和可重复的方式实现关键的微服务设计模式。对通用语言的支持和与框架无关的方法确保了花几天时间评估Dapr是非常值得。特别对于.NET开发者来说，Dapr 里面的编程模型是很熟悉的，大家学起来吧。&lt;/p&gt;
&lt;p&gt;国内有一个Dapr社区，这个社区里大家都是跨语言的， Dapr SIG 是 &lt;a href=&quot;https://cloudnative.to/&quot;&gt;云原生社区&lt;/a&gt; 主办的特别兴趣小组SIG。SIG 目的是为了给在某一个领域志同道合的人共同学习和交流的平台。网址是 &lt;a title=&quot;https://i.cloudnative.to/dapr/&quot; href=&quot;https://i.cloudnative.to/dapr/&quot;&gt;https://i.cloudnative.to/dapr/&lt;/a&gt; ，社区也正在组织翻译Dapr的文档，非常欢迎你的加入进来翻译文档。翻译指导链接请到 &lt;a title=&quot;https://github.com/dapr-cn/docs&quot; href=&quot;https://github.com/dapr-cn/docs&quot;&gt;https://github.com/dapr-cn/docs&lt;/a&gt; 。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Feb 2021 13:06:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>微服务是云原生架构的核心，通常使用Kubernetes 来按需管理服务扩展。 微软一直走在 Cloud Native Computing Foundation的 最前沿，并通过使用Kubernetes</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/14390918.html</dc:identifier>
</item>
<item>
<title>Gome 高性能撮合引擎微服务 - stingbo</title>
<link>http://www.cnblogs.com/stingbo/p/14390898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stingbo/p/14390898.html</guid>
<description>&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;gome 目录说明：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;api，RPC 接口定义目录，使用 ProtoBuf 3 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;engine，撮合引擎实现逻辑目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;grpc，gRPC服务脚本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;redis，redis客户端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;utils，工具脚本目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;main.go 入口文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;match.go 撮合脚本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;match_notice.go 撮合结果消费脚本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;test.go 测试脚本，命令如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;  1. 下单:`go run test.go doOrder`
  2. 撤单:`go run test.go delOrder`
  3. 获取交易对深度:`go run test.go getDepth symbol transaction`
  4. 查看命令帮助:`go run test.go help`
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;gome 会使用 symbol 名作为下单队列，撮合引擎会消耗此队列，撮合成交结果会 push 到 notice:+symbol 作为名称的队列，如 notice:btc2usdt&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;目前消费消费成交结果队列时只打印了数据，没有其它功能，使用者可以自行消费此队列，实现后续逻辑，如更新数据库，通知用户等，gome 后续会增加根据配置的地址推送功能，这样使用者只需要配置接收地址即可接收结果然后处理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本项目是在我之前的 PHP 项目基础上，把队列替换为 RabbitMQ，Redis 只作为缓存，再使用 Golang 与 gRPC 实现微服务化&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.70526315789474&quot;&gt;
&lt;p&gt;gome 的具体实现思想与数据结构设计可以查看 &lt;strong&gt;&lt;a href=&quot;https://github.com/stingbo/mengine&quot; target=&quot;_blank&quot;&gt;基于Laravel的撮合服务&lt;/a&gt;&lt;/strong&gt; 项目&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本项目不用依赖其他环境，使用 docker 跑起环境后，其他项目对接调用即可，如：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;api 的 OrderRequest 里，uuid(用户标识)与 oid(订单标识)应该具有系统唯一性，话说回来，这两者在系统里也不应该重复，我定义的是 string 类型，方便主键是非自增整型数据库使用&lt;/p&gt;
&lt;/li&gt;
</description>
<pubDate>Mon, 08 Feb 2021 13:01:00 +0000</pubDate>
<dc:creator>stingbo</dc:creator>
<og:description>Gome 高性能撮合引擎微服务 使用 Golang 做计算，gRPC 做服务，ProtoBuf 做数据交换，RabbitMQ 做队列，Redis 做缓存实现的高性能撮合引擎微服务 依赖 具体依赖信息可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stingbo/p/14390898.html</dc:identifier>
</item>
<item>
<title>详解Go语言I/O多路复用netpoller模型 - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/14390824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/14390824.html</guid>
<description>&lt;blockquote readability=&quot;5.6111111111111&quot;&gt;
&lt;p&gt;转载请声明出处哦~，本篇文章发布于luozhiyun的博客：&lt;a href=&quot;https://www.luozhiyun.com&quot; target=&quot;_blank&quot;&gt;https://www.luozhiyun.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文使用的go的源码15.7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以从 Go 源码目录结构和对应代码文件了解 Go 在不同平台下的网络 I/O 模式的实现。比如，在 Linux 系统下基于 epoll，freeBSD 系统下基于 kqueue，以及 Windows 系统下基于 iocp。&lt;/p&gt;
&lt;p&gt;因为我们的代码都是部署在Linux上的，所以本文以epoll封装实现为例子来讲解Go语言中I/O多路复用的源码实现。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;h3 id=&quot;io多路复用&quot;&gt;I/O多路复用&lt;/h3&gt;
&lt;p&gt;所谓 I/O 多路复用指的就是 select/epoll 这一系列的多路选择器：支持单一线程同时监听多个文件描述符（I/O 事件），阻塞等待，并在其中某个文件描述符可读写时收到通知。以防很多同学对select或epoll不那么熟悉，所以下面先来讲讲这两个选择器。&lt;/p&gt;
&lt;p&gt;首先我们先说一下什么是文件描述符（File descriptor），根据它的英文首字母也简称FD，它是一个用于表述指向文件的引用的抽象化概念。它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。&lt;/p&gt;
&lt;h4 id=&quot;select&quot;&gt;select&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;int select(int nfds,
            fd_set *restrict readfds,
            fd_set *restrict writefds,
            fd_set *restrict errorfds,
            struct timeval *restrict timeout);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;writefds、readfds、和exceptfds是三个文件描述符集合。select会遍历每个集合的前nfds个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为就绪的描述符。&lt;/p&gt;
&lt;p&gt;timeout参数表示调用select时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果timeout参数设为 NULL，会无限阻塞直到某个描述符就绪；如果timeout参数设为 0，会立即返回，不阻塞。&lt;/p&gt;
&lt;p&gt;当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1204119/202102/1204119-20210208204544304-720218418.png&quot; alt=&quot;multiplexing model&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;select的缺点也列举一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024;&lt;/li&gt;
&lt;li&gt;每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大;&lt;/li&gt;
&lt;li&gt;每次 kernel 都需要线性扫描整个 fd_set，所以随着监控的描述符 fd 数量增长，其 I/O 性能会线性下降;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;epoll&quot;&gt;epoll&lt;/h4&gt;
&lt;p&gt;epoll是selec的增强版本，避免了“性能开销大”和“文件描述符数量少”两个缺点。&lt;/p&gt;
&lt;p&gt;为方便理解后续的内容，先看一下epoll的用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int listenfd = socket(AF_INET, SOCK_STREAM, 0);   
bind(listenfd, ...)
listen(listenfd, ...)

int epfd = epoll_create(...);
epoll_ctl(epfd, ...); //将所有需要监听的fd添加到epfd中

while(1){
    int n = epoll_wait(...)
    for(接收到数据的socket){
        //处理
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先用epoll_create创建一个epoll对象实例epfd，同时返回一个引用该实例的文件描述符，返回的文件描述符仅仅指向对应的epoll实例，并不表示真实的磁盘文件节点。&lt;/p&gt;
&lt;p&gt;epoll实例内部存储：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监听列表：所有要监听的文件描述符，使用红黑树；&lt;/li&gt;
&lt;li&gt;就绪列表：所有就绪的文件描述符，使用链表；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再通过epoll_ctl将需要监视的fd添加到epfd中，同时为fd设置一个回调函数，并监听事件event，并添加到监听列表中。当有事件发生时，会调用回调函数，并将fd添加到epoll实例的就绪队列上。&lt;/p&gt;
&lt;p&gt;最后调用epoll_wait阻塞监听 epoll 实例上所有的fd的 I/O 事件。当就绪列表中已有数据，那么epoll_wait直接返回，解决了select每次都需要轮询一遍的问题。&lt;/p&gt;
&lt;p&gt;epoll的优点：&lt;/p&gt;
&lt;p&gt;epoll的监听列表使用红黑树存储，epoll_ctl 函数添加进来的 fd 都会被放在红黑树的某个节点内，而红黑树本身插入和删除性能比较稳定，时间复杂度 O(logN)，并且可以存储大量的的fd，避免了只能存储1024个fd的限制；&lt;/p&gt;
&lt;p&gt;epoll_ctl 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此不需要像select一样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可；&lt;/p&gt;
&lt;h2 id=&quot;解析&quot;&gt;解析&lt;/h2&gt;
&lt;p&gt;netpoll本质上是对 I/O 多路复用技术的封装，所以自然也是和epoll一样脱离不了下面几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;netpoll创建及其初始化；&lt;/li&gt;
&lt;li&gt;向netpoll中加入待监控的任务；&lt;/li&gt;
&lt;li&gt;从netpoll获取触发的事件；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在go中对epoll提供的三个函数进行了封装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func netpollinit()
func netpollopen(fd uintptr, pd *pollDesc) int32
func netpoll(delay int64) gList
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;netpollinit函数负责初始化netpoll；&lt;/p&gt;
&lt;p&gt;netpollopen负责监听文件描述符上的事件；&lt;/p&gt;
&lt;p&gt;netpoll会阻塞等待返回一组已经准备就绪的 Goroutine；&lt;/p&gt;
&lt;p&gt;下面是Go语言中编写的一个TCP server：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func main() {
    listen, err := net.Listen(&quot;tcp&quot;, &quot;:8888&quot;)
    if err != nil {
        fmt.Println(&quot;listen error: &quot;, err)
        return
    } 
    for {
        conn, err := listen.Accept()
        if err != nil {
            fmt.Println(&quot;accept error: &quot;, err)
            break
        } 
        // 创建一个goroutine来负责处理读写任务
        go HandleConn(conn)
    }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们跟着这个TCP server的源码一起看看是在哪里使用了netpoll来完成epoll的调用。&lt;/p&gt;
&lt;h3 id=&quot;netlisten&quot;&gt;net.Listen&lt;/h3&gt;
&lt;p&gt;这个TCP server中会调用&lt;code&gt;net.Listen&lt;/code&gt;创建一个socket同时返回与之对应的fd，该fd用来初始化listener的netFD(go层面封装的网络文件描述符)，接着调用 netFD的listenStream方法完成对 socket 的 bind&amp;amp;listen和netFD的初始化。&lt;/p&gt;
&lt;p&gt;调用过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1204119/202102/1204119-20210208204547398-858014858.png&quot; alt=&quot;listen&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) {
        // 创建一个socket
        s, err := sysSocket(family, sotype, proto)
        if err != nil {
                return nil, err
        }
        ...
        // 创建fd
        if fd, err = newFD(s, family, sotype, net); err != nil {
                poll.CloseFunc(s)
                return nil, err
        } 
        if laddr != nil &amp;amp;&amp;amp; raddr == nil {
                switch sotype {
                case syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:
                        // 调用 netFD的listenStream方法完成对 socket 的 bind&amp;amp;listen和netFD的初始化
                        if err := fd.listenStream(laddr, listenerBacklog(), ctrlFn); err != nil {
                                fd.Close()
                                return nil, err
                        }
                        return fd, nil
                case syscall.SOCK_DGRAM:
                        ...
                }
        }
        ...
        return fd, nil
}

func newFD(sysfd syscall.Handle, family, sotype int, net string) (*netFD, error) {
        ret := &amp;amp;netFD{
                pfd: poll.FD{
                        Sysfd:         sysfd,
                        IsStream:      sotype == syscall.SOCK_STREAM,
                        ZeroReadIsEOF: sotype != syscall.SOCK_DGRAM &amp;amp;&amp;amp; sotype != syscall.SOCK_RAW,
                },
                family: family,
                sotype: sotype,
                net:    net,
        }
        return ret, nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sysSocket方法会发起一个系统调用创建一个socket，newFD会创建一个netFD，然后调用netFD的listenStream方法进行bind&amp;amp;listen操作，并对netFD进行init。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1204119/202102/1204119-20210208204547632-1827165543.png&quot; alt=&quot;netFD&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;netFD是一个文件描述符的封装，netFD中包含一个FD数据结构，FD中包含了Sysfd 和pollDesc两个重要的数据结构，Sysfd是sysSocket返回的socket系统文件描述符，pollDesc用于监控文件描述符的可读或者可写。&lt;/p&gt;
&lt;p&gt;我们继续看listenStream：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error {
        ...
        // 完成绑定操作
        if err = syscall.Bind(fd.pfd.Sysfd, lsa); err != nil {
                return os.NewSyscallError(&quot;bind&quot;, err)
        }
        // 进行监听操作
        if err = listenFunc(fd.pfd.Sysfd, backlog); err != nil {
                return os.NewSyscallError(&quot;listen&quot;, err)
        }
        // 初始化fd
        if err = fd.init(); err != nil {
                return err
        }
        lsa, _ = syscall.Getsockname(fd.pfd.Sysfd)
        fd.setAddr(fd.addrFunc()(lsa), nil)
        return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;listenStream方法会调用Bind方法完成fd的绑定操作，然后调用listenFunc进行监听，接着调用fd的init方法，完成FD、pollDesc初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (pd *pollDesc) init(fd *FD) error {
        // 调用到runtime.poll_runtime_pollServerInit
        serverInit.Do(runtime_pollServerInit)
        // 调用到runtime.poll_runtime_pollOpen
        ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))
        ...
        return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;runtime_pollServerInit用Once封装保证只能被调用一次，这个函数在Linux平台上会创建一个epoll文件描述符实例；&lt;/p&gt;
&lt;p&gt;poll_runtime_pollOpen调用了netpollopen会将fd注册到 epoll实例中，并返回一个pollDesc；&lt;/p&gt;
&lt;h4 id=&quot;netpollinit初始化&quot;&gt;netpollinit初始化&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func poll_runtime_pollServerInit() {
        netpollGenericInit()
}

func netpollGenericInit() {
        if atomic.Load(&amp;amp;netpollInited) == 0 {
                lock(&amp;amp;netpollInitLock)
                if netpollInited == 0 {
                        netpollinit()
                        atomic.Store(&amp;amp;netpollInited, 1)
                }
                unlock(&amp;amp;netpollInitLock)
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;netpollGenericInit会调用平台上特定实现的netpollinit，在Linux中会调用到netpoll_epoll.go的netpollinit方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var (
        epfd int32 = -1 // epoll descriptor 
)

func netpollinit() {
        // 创建一个新的 epoll 文件描述符
        epfd = epollcreate1(_EPOLL_CLOEXEC)
        ...
        // 创建一个用于通信的管道
        r, w, errno := nonblockingPipe()
        ...
        ev := epollevent{
                events: _EPOLLIN,
        }
        *(**uintptr)(unsafe.Pointer(&amp;amp;ev.data)) = &amp;amp;netpollBreakRd
        // 将读取数据的文件描述符加入监听
        errno = epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;amp;ev)
        ...
        netpollBreakRd = uintptr(r)
        netpollBreakWr = uintptr(w)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用epollcreate1方法会创建一个epoll文件描述符实例，需要注意的是epfd是一个全局的属性。然后创建一个用于通信的管道，调用epollctl将读取数据的文件描述符加入监听。&lt;/p&gt;
&lt;h4 id=&quot;netpollopen加入事件监听&quot;&gt;netpollopen加入事件监听&lt;/h4&gt;
&lt;p&gt;下面再看看poll_runtime_pollOpen方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func poll_runtime_pollOpen(fd uintptr) (*pollDesc, int) {
        pd := pollcache.alloc()
        lock(&amp;amp;pd.lock)
        if pd.wg != 0 &amp;amp;&amp;amp; pd.wg != pdReady {
                throw(&quot;runtime: blocked write on free polldesc&quot;)
        }
        if pd.rg != 0 &amp;amp;&amp;amp; pd.rg != pdReady {
                throw(&quot;runtime: blocked read on free polldesc&quot;)
        }
        pd.fd = fd
        pd.closing = false
        pd.everr = false
        pd.rseq++
        pd.rg = 0
        pd.rd = 0
        pd.wseq++
        pd.wg = 0
        pd.wd = 0
        pd.self = pd
        unlock(&amp;amp;pd.lock)

        var errno int32
        errno = netpollopen(fd, pd)
        return pd, int(errno)
}

func netpollopen(fd uintptr, pd *pollDesc) int32 {
        var ev epollevent
        ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET
        *(**pollDesc)(unsafe.Pointer(&amp;amp;ev.data)) = pd
        return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;amp;ev)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;poll_runtime_pollOpen方法会通过&lt;code&gt;pollcache.alloc&lt;/code&gt;初始化总大小约为 4KB的pollDesc结构体。然后重置pd的属性，调用netpollopen向epoll实例epfd加入新的轮询事件监听文件描述符的可读和可写状态。&lt;/p&gt;
&lt;p&gt;下面我们再看看pollCache是如何初始化pollDesc的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type pollCache struct {
        lock  mutex
        first *pollDesc 
}

const pollBlockSize = 4 * 1024

func (c *pollCache) alloc() *pollDesc {
        lock(&amp;amp;c.lock)
        // 初始化首节点
        if c.first == nil {
                const pdSize = unsafe.Sizeof(pollDesc{})
                n := pollBlockSize / pdSize
                if n == 0 {
                        n = 1
                } 
                mem := persistentalloc(n*pdSize, 0, &amp;amp;memstats.other_sys)
        // 初始化pollDesc链表
                for i := uintptr(0); i &amp;lt; n; i++ {
                        pd := (*pollDesc)(add(mem, i*pdSize))
                        pd.link = c.first
                        c.first = pd
                }
        }
        pd := c.first
        c.first = pd.link
        lockInit(&amp;amp;pd.lock, lockRankPollDesc)
        unlock(&amp;amp;c.lock)
        return pd
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pollCache的链表头如果为空，那么初始化首节点，首节点是一个pollDesc的链表头，每次调用该结构体都会返回链表头还没有被使用的pollDesc。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1204119/202102/1204119-20210208204547962-1949357529.png&quot; alt=&quot;pollCache&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里就完成了net.Listen的分析，下面我们看看listen.Accept。&lt;/p&gt;
&lt;h3 id=&quot;listeneraccept&quot;&gt;Listener.Accept&lt;/h3&gt;
&lt;p&gt;Listener.Accept方法最终会调用到netFD的accept方法中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1204119/202102/1204119-20210208204548221-944194477.png&quot; alt=&quot;Accept&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (fd *netFD) accept() (netfd *netFD, err error) {
        // 调用netfd.FD的Accept接受新的 socket 连接，返回 socket 的 fd
        d, rsa, errcall, err := fd.pfd.Accept()
        ...
        // 构造一个新的netfd
        if netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != nil {
                poll.CloseFunc(d)
                return nil, err
        }
        // 调用 netFD 的 init 方法完成初始化
        if err = netfd.init(); err != nil {
                netfd.Close()
                return nil, err
        }
        lsa, _ := syscall.Getsockname(netfd.pfd.Sysfd)
        netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))
        return netfd, nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法首先会调用到FD的Accept接受新的 socket 连接，并返回新的socket对应的fd，然后调用newFD构造一个新的netfd，并通过init 方法完成初始化。&lt;/p&gt;
&lt;p&gt;init方法上面我们已经看过了，下面我们来看看Accept方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (fd *FD) Accept() (int, syscall.Sockaddr, string, error) {
        ...
        for {
                // 使用 linux 系统调用 accept 接收新连接，创建对应的 socket
                s, rsa, errcall, err := accept(fd.Sysfd)
                if err == nil {
                        return s, rsa, &quot;&quot;, err
                }
                switch err {
                case syscall.EINTR:
                        continue
                case syscall.EAGAIN:
                        if fd.pd.pollable() {
                                // 如果当前没有发生期待的 I/O 事件，那么 waitRead 会通过 park goroutine 让逻辑 block 在这里
                                if err = fd.pd.waitRead(fd.isFile); err == nil {
                                        continue
                                }
                        }
                case syscall.ECONNABORTED: 
                        continue
                }
                return -1, nil, errcall, err
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;FD.Accept&lt;/code&gt;方法会使用 linux 系统调用 accept 接收新连接，创建对应的 socket，如果没有可读的消息，waitRead会被阻塞。这些被park住的goroutine会在goroutine的调度中调用&lt;code&gt;runtime.netpoll&lt;/code&gt;被唤醒。&lt;/p&gt;
&lt;h4 id=&quot;pollwait事件等待&quot;&gt;pollWait事件等待&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;pollDesc.waitRead&lt;/code&gt;实际上是调用了&lt;code&gt;runtime.poll_runtime_pollWait&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func poll_runtime_pollWait(pd *pollDesc, mode int) int {
        ...
    // 进入 netpollblock 并且判断是否有期待的 I/O 事件发生
        for !netpollblock(pd, int32(mode), false) {
                ...
        }
        return 0
}

func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {
        gpp := &amp;amp;pd.rg
        if mode == 'w' {
                gpp = &amp;amp;pd.wg
        }
        // 这个 for 循环是为了等待 io ready 或者 io wait
        for {
                old := *gpp
                // gpp == pdReady 表示此时已有期待的 I/O 事件发生，
                // 可以直接返回 unblock 当前 goroutine 并执行响应的 I/O 操作
                if old == pdReady {
                        *gpp = 0
                        return true
                }
                if old != 0 {
                        throw(&quot;runtime: double wait&quot;)
                }
                // 如果没有期待的 I/O 事件发生，则通过原子操作把 gpp 的值置为 pdWait 并退出 for 循环
                if atomic.Casuintptr(gpp, 0, pdWait) {
                        break
                }
        }
        if waitio || netpollcheckerr(pd, mode) == 0 {
                // 让出当前线程，将 Goroutine 转换到休眠状态并等待运行时的唤醒
                gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)
        }
        // be careful to not lose concurrent pdReady notification
        old := atomic.Xchguintptr(gpp, 0)
        if old &amp;gt; pdWait {
                throw(&quot;runtime: corrupted polldesc&quot;)
        }
        return old == pdReady
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;poll_runtime_pollWait会用for循环调用netpollblock函数判断是否有期待的 I/O 事件发生，直到netpollblock返回true表示io ready才会走出循环。&lt;/p&gt;
&lt;p&gt;netpollblock方法会判断当前的状态是不是处于pdReady，如果是那么直接返回true；如果不是，那么将gpp通过CAS设置为pdWait并退出 for 循环。通过gopark 把当前 goroutine 给 park 住，直到对应的 fd 上发生可读/可写或者其他I/O 事件为止。&lt;/p&gt;
&lt;p&gt;这些被park住的goroutine会在goroutine的调度中调用&lt;code&gt;runtime.netpoll&lt;/code&gt;被唤醒。&lt;/p&gt;
&lt;h3 id=&quot;netpoll轮询等待&quot;&gt;netpoll轮询等待&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;runtime.netpoll&lt;/code&gt;的核心逻辑是： 根据入参 delay设置调用 epoll_wait 的 timeout 值，调用 epoll_wait 从 epoll 的 &lt;code&gt;eventpoll.rdllist&lt;/code&gt;双向列表中获取IO就绪的fd列表，遍历epoll_wait 返回的fd列表， 根据调用&lt;code&gt;epoll_ctl&lt;/code&gt;注册fd时封装的上下文信息组装可运行的 goroutine 并返回。&lt;/p&gt;
&lt;p&gt;执行完 &lt;code&gt;netpoll&lt;/code&gt; 之后，会返回一个就绪 fd 列表对应的 goroutine 列表，接下来将就绪的 goroutine 加入到调度队列中，等待调度运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func netpoll(delay int64) gList {
        if epfd == -1 {
                return gList{}
        }
        var waitms int32
    // 因为传入delay单位是纳秒，下面将纳秒转换成毫秒
        if delay &amp;lt; 0 {
                waitms = -1
        } else if delay == 0 {
                waitms = 0
        } else if delay &amp;lt; 1e6 {
                waitms = 1
        } else if delay &amp;lt; 1e15 {
                waitms = int32(delay / 1e6)
        } else {
                // An arbitrary cap on how long to wait for a timer.
                // 1e9 ms == ~11.5 days.
                waitms = 1e9
        }
        var events [128]epollevent
retry:
        // 等待文件描述符转换成可读或者可写
        n := epollwait(epfd, &amp;amp;events[0], int32(len(events)), waitms)
        // 返回负值，那么重新调用epollwait进行等待
        if n &amp;lt; 0 {
                ...
                goto retry
        }
        var toRun gList
        // 意味着被监控的文件描述符出现了待处理的事件
        for i := int32(0); i &amp;lt; n; i++ {
                ev := &amp;amp;events[i]
                if ev.events == 0 {
                        continue
                } 
                ...
                // 判断发生的事件类型，读类型或者写类型
                var mode int32
                if ev.events&amp;amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
                        mode += 'r'
                }
                if ev.events&amp;amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
                        mode += 'w'
                }
                if mode != 0 {
                        // 取出保存在 epollevent 里的 pollDesc
                        pd := *(**pollDesc)(unsafe.Pointer(&amp;amp;ev.data))
                        pd.everr = false
                        if ev.events == _EPOLLERR {
                                pd.everr = true
                        }
                        // 调用 netpollready，传入就绪 fd 的 pollDesc
                        netpollready(&amp;amp;toRun, pd, mode)
                }
        }
        return toRun
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;netpoll会调用epollwait获取就绪的 fd 列表，对应的epoll函数是epoll_wait。toRun是一个 g 的链表，存储要恢复的 goroutines，最后返回给调用方。如果epollwait返回的n大于零，那么表示被监控的文件描述符出现了待处理的事件，那么需要调用for循环进行处理。循环里面会根据时间类型设置mode，然后拿出对应的pollDesc，调用netpollready方法。&lt;/p&gt;
&lt;p&gt;下面我们再看一下netpollready：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func netpollready(toRun *gList, pd *pollDesc, mode int32) {
        var rg, wg *g
        // 获取对应的g的指针
        if mode == 'r' || mode == 'r'+'w' {
                rg = netpollunblock(pd, 'r', true)
        }
        if mode == 'w' || mode == 'r'+'w' {
                wg = netpollunblock(pd, 'w', true)
        }
        // 将对应的g加入到toRun列表中
        if rg != nil {
                toRun.push(rg)
        }
        if wg != nil {
                toRun.push(wg)
        }
}

func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {
        gpp := &amp;amp;pd.rg
        // 根据传入的mode判断事件类型
        if mode == 'w' {
                gpp = &amp;amp;pd.wg
        }

        for {
                // 取出 gpp 存储的 g
                old := *gpp
                if old == pdReady {
                        return nil
                }
                if old == 0 &amp;amp;&amp;amp; !ioready {
                        return nil
                }
                var new uintptr
                if ioready {
                        new = pdReady
                }
                // cas 将读或者写信号量转换成 pdReady
                if atomic.Casuintptr(gpp, old, new) {
                        if old == pdWait {
                                old = 0
                        }
                        // 返回对应的 g指针
                        return (*g)(unsafe.Pointer(old))
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;讲完了&lt;code&gt;runtime.netpoll&lt;/code&gt;的源码有个需要注意的地方，调用&lt;code&gt;runtime.netpoll&lt;/code&gt;的地方有两处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在调度器中执行&lt;code&gt;runtime.schedule()&lt;/code&gt;，该方法中会执行&lt;code&gt;runtime.findrunable()&lt;/code&gt;，在&lt;code&gt;runtime.findrunable()&lt;/code&gt;中调用了&lt;code&gt;runtime.netpoll&lt;/code&gt;获取待执行的goroutine；&lt;/li&gt;
&lt;li&gt;Go runtime 在程序启动的时候会创建一个独立的sysmon监控线程，sysmon 每 20us~10ms 运行一次，每次运行会检查距离上一次执行netpoll是否超过10ms，如果是则会调用一次&lt;code&gt;runtime.netpoll&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些入口的调用感兴趣的可以自己去看看。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文从I/O多路复用开始讲解select以及epoll，然后再回到go语言中去看它是如何实现多路复用这样的结构的。通过追踪源码可以发现，其实go也是根据epoll来封装自己的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func netpollinit()
func netpollopen(fd uintptr, pd *pollDesc) int32
func netpoll(block bool) gList
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这三个函数来实现对epoll的创建实例、注册、事件等待操作。&lt;/p&gt;
&lt;p&gt;对于I/O多路复用不是很了解的同学也可以借此机会多多的去学习一下网络编程方面的知识，扩充一下知识面。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.infoq.cn/article/boeavgkiqmvcj8qjnbxk&quot; target=&quot;_blank&quot;&gt;https://www.infoq.cn/article/boeavgkiqmvcj8qjnbxk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/#66-%e7%bd%91%e7%bb%9c%e8%bd%ae%e8%af%a2%e5%99%a8&quot; target=&quot;_blank&quot;&gt;https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/#66-网络轮询器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64138532&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/64138532&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imageslr.github.io/2020/02/27/select-poll-epoll.html&quot; target=&quot;_blank&quot;&gt;https://imageslr.github.io/2020/02/27/select-poll-epoll.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://singlecool.com/2020/12/13/golang-netpoll/&quot; target=&quot;_blank&quot;&gt;http://singlecool.com/2020/12/13/golang-netpoll/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Feb 2021 12:46:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>转载请声明出处哦~，本篇文章发布于luozhiyun的博客：https://www.luozhiyun.com 本文使用的go的源码15.7 可以从 Go 源码目录结构和对应代码文件了解 Go 在不同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/14390824.html</dc:identifier>
</item>
</channel>
</rss>