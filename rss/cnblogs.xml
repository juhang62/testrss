<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Manjaro Linux 入门使用教程 - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/12806659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/12806659.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200419220905196.png&quot; alt=&quot;screenfetch&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;manjaro-初体验&quot;&gt;Manjaro 初体验&lt;/h2&gt;
&lt;p&gt;Manjaro 是一款基于 Arch LInux 的自由开源发行版，它吸收了 Arch Linux 优秀丰富的软件管理，同时提供了稳定流畅的操作体验。优雅简单是它的追求，稳定实用是它的优势。&lt;/p&gt;
&lt;p&gt;Manjaro 和 Arch Linux 一样采用滚动发行模式，但是它的滚动更新是在 Arch Linux 更新测试一段时间之后，这也保证了系统的稳定性。话虽如此，使用中你依旧可能面临大量的更新而不知如何选择，所以，&lt;strong&gt;如果使用已经满足需求，有升级的必要吗？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;下载镜像&quot;&gt;下载镜像&lt;/h3&gt;
&lt;p&gt;镜像下载可以去 &lt;a href=&quot;https://manjaro.org/get-manjaro/&quot;&gt;Manjaro&lt;/a&gt; 官方网站下载，国内速度太慢也可以到 &lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/osdn/storage/g/m/ma/manjaro/&quot;&gt;清华大学开源软件镜像站&lt;/a&gt; 进行下载。Manjaro 提供了多种桌面环境，可以根据喜好自行下载，我一般偏向于 kde 或者 gnome 桌面。&lt;/p&gt;
&lt;h3 id=&quot;制作启动盘&quot;&gt;制作启动盘&lt;/h3&gt;
&lt;p&gt;使用 &lt;a href=&quot;http://rufus.ie/&quot;&gt;Rufus&lt;/a&gt; 工具以 &lt;strong&gt;DD 模式&lt;/strong&gt;写入镜像到 U 盘，制作 U 盘启动成功之后，开机选择 U 盘进行启动即可。Rufus 工具这里选择的是 3.4 版本，经过测试，高版本的 Rufus 可能会存在分区类型等选项不能修改的 🐛 Bug。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200421213247256.png&quot; alt=&quot;Rufus 3.4&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装-manjaro&quot;&gt;安装 Manjaro&lt;/h3&gt;
&lt;p&gt;安装 Manjaro 这里不做描述，网上有很多优秀的教程可以参考。总体来说 Manjaro 安装还是比较轻松的，相比其他的 Linux 发行版，安装体验更好。特别是对显卡驱动方面的支持，一键安装，特别省心。&lt;/p&gt;
&lt;h2 id=&quot;更换软件源&quot;&gt;更换软件源&lt;/h2&gt;
&lt;p&gt;更换软件源为国内清华大学源，安装软件更迅速。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -Syy
sudo pacman-mirrors -i -c China -m rank  #选一个清华源就行
#sudo pacman -Syyu
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在弹出的窗口里选择一个镜像源即可，我这里选择的是清华大学镜像源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200419181748778.png&quot; alt=&quot;选择清华镜像源&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo vim /etc/pacman.conf
# 下面的内容添加到文件
[archlinuxcn]
SigLevel = Optional TrustedOnly
Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch
# 执行更新，导入GPG key
sudo pacman -Syy &amp;amp;&amp;amp; sudo pacman -S archlinuxcn-keyring
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装输入法&quot;&gt;安装输入法&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S fcitx-sogoupinyin
sudo pacman -S fcitx-im # 全部安装
sudo pacman -S fcitx-configtool # 图形化配置工具
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置中文输入法环境变量，编辑~/.xprofile文件，增加下面几行(如果文件不存在，则新建)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=&quot;@im=fcitx&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用-zsh&quot;&gt;使用 zsh&lt;/h2&gt;
&lt;p&gt;没体验过 zsh 的建议试试，命令敲起来十分顺畅。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S zsh
# 下载这个 install.sh 自行运行
# https://github.com/ohmyzsh/ohmyzsh/blob/master/tools/install.sh
# 下面这种方式已经失效
#sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
chsh -s /bin/zsha
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装常用软件&quot;&gt;安装常用软件&lt;/h2&gt;
&lt;p&gt;99% 的软件只需要几条命令就可以安装，像下面这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 生成 ssh 密钥 ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;
sudo pacman -S git
sudo pacman -S vim
sudo pacman -S visual-studio-code-bin # vscode
sudo pacman -S google-chrome  # 谷歌浏览器
sudo pacman -S netease-cloud-music  # 网易云音乐
sudo pacman -S wps-office
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网易云音乐还有一个基于 Python 编写的开源的命令行版本，使用命令行播放操控歌曲，十分极客炫酷，有兴趣的朋友可以尝试。&lt;/p&gt;
&lt;p&gt;NetEase-MusicBox 开源地址：&lt;a href=&quot;https://github.com/darknessomi/musicbox&quot;&gt;https://github.com/darknessomi/musicbox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装坚果云。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 下载坚果云安装包
wget https://www.jianguoyun.com/static/exe/installer/nutstore_linux_dist_x64.tar.gz
# 安装坚果云，解压后运行
./bin/install_core.sh
# 安装所需依赖
sudo pacman -S gvfs libappindicator-gtk3 python2-gobject
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装 TIM / QQ.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S deepin.com.qq.office
# 由于 qq 依赖了 cinnamon-settings-daemon
sudo pacman -S cinnamon-settings-daemon
/usr/lib/cinnamon-settings-daemon/csd-xsettings
# 可以尝试将上方的 csd-xsettings 加入到开自启
# 修改 TIM 字体大小，下面命令之后-》显示 DPI 120
env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-TIM&quot; /usr/bin/deepin-wine winecfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开发环境配置&quot;&gt;开发环境配置&lt;/h2&gt;
&lt;p&gt;安装 JDK，配置环境变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export JAVA_HOME=/home/niu/develop/program/jdk1.8.0_191
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$JAVA_HOME/bin:$PATH
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装 maven，配置环境变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export M2_HOME=/home/niu/program/apache-maven-3.6.3
export PATH=$PATH:$M2_HOME/bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字体渲染&quot;&gt;字体渲染&lt;/h2&gt;
&lt;p&gt;字体渲染的好坏直接影响到使用体验，这里推荐下面几款字体。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S ttf-roboto noto-fonts ttf-dejavu
# 文泉驿
sudo pacman -S wqy-bitmapfont wqy-microhei wqy-microhei-lite wqy-zenhei
# 思源字体
sudo pacman -S noto-fonts-cjk adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以从下面的 Git 仓库中下载微软 windows 10 字体，获得和 windows 相似的字体体验。Github 下载速度较慢，我已经克隆了一份到 Gitee 码云。&lt;/p&gt;
&lt;p&gt;GIthub：&lt;a href=&quot;https://github.com/fphoenix88888/ttf-mswin10-arch&quot;&gt;https://github.com/fphoenix88888/ttf-mswin10-arch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitee：&lt;a href=&quot;https://gitee.com/niumoo/ttf-mswin10-arch&quot;&gt;https://gitee.com/niumoo/ttf-mswin10-arch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你也可以自己下载喜欢的字体复制到 &lt;code&gt;/usr/share/fonts/TTF&lt;/code&gt; 文件夹下。然后使用命令 &lt;code&gt;fc-cache -fv&lt;/code&gt; 刷新字体。&lt;/p&gt;
&lt;p&gt;有时候你已经安装了不错的字体，显示效果还是不好，可以尝试调整设置里的屏幕缩放和强制字体 DPI 参数，缩放我一般不建议调整，可以调整字体 DPI 为 120 或者 144。&lt;/p&gt;
&lt;h2 id=&quot;可选操作&quot;&gt;可选操作&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;系统更新&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 更新所有软件系统
sudo pacman -Syyu
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你对更新内容不是很了解，对 Linux 操作还不熟练，那么我给你的建议是没问题不要更新，不然更新之后遇到一些问题之后你可能无法搞定。当然这个概率很小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200420080215272.png&quot; alt=&quot;sudo pacman -Syyu 更新系统&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;显卡驱动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;安装显卡驱动，如果你开机关机没有任何问题，就不要折腾了。如果你不幸开机或者关机卡死，可以尝试安装一下驱动，在硬件设定里点击 &lt;strong&gt;Auto Install Proprietary Driver&lt;/strong&gt; 自动检测安装，这个显卡驱动自动检测安装是我喜欢 Manjaro 的原因之一。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200420215953766.png&quot; alt=&quot;安装显卡驱动&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;垃圾清理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;清除系统中无用的包。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -R $(pacman -Qdtq)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清除已下载的安装包。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -Scc
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;几天使用下来，Manjaro 的体验比想象中的要好，在这之前我也体验过把 Deepin 和 Ubunut 作为主力系统，Deepin 对于某些机器显卡驱动不是特别友好，经常会开机或者关机卡死，但是桌面环境相对优秀。而 Ubuntu 在作为桌面环境使用时，经常会出现莫名的内部错误，安装软件有时候比较繁琐，当然 Ubuntu 的优点也很多，不错的界面，活跃的社区等。在Manjaro 的体验中我发现困扰很久的显卡驱动问题竟然可以如此轻松的解决。KDE 桌面环境也很舒服，目前不尽人意的地方在于字体渲染，不管我是调整缩放还是调整字体 DPI 效果都不明显。可能是我没有找到正确的方法吧，毕竟有的朋友可以开箱即用。&lt;/p&gt;
&lt;p&gt;&amp;lt;完&amp;gt;&lt;br/&gt;个人网站：&lt;a href=&quot;https://www.wdbyte.com&quot;&gt;https://www.wdbyte.com&lt;/a&gt;&lt;br/&gt;如果你喜欢这篇文章，可以关注公众号，一起成长。&lt;br/&gt;关注公众号回复资源可以没有套路的获取全网最火的的 Java 核心知识整理&amp;amp;面试核心资料。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202902/201911/1202902-20191126090837925-1632441965.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 Apr 2020 00:54:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>Manjaro 初体验 Manjaro 是一款基于 Arch LInux 的自由开源发行版，它吸收了 Arch Linux 优秀丰富的软件管理，同时提供了稳定流畅的操作体验。优雅简单是它的追求，稳定实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/12806659.html</dc:identifier>
</item>
<item>
<title>十分钟教条与经验，轻松搞定系统分析师的案例分析 - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/12806655.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/12806655.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;系统分析师培训班通过统计，得到一个结论：培训班的考生，死得最多的就是案例分析。&lt;/p&gt;
&lt;p&gt;为什么呢？因为客观题只要平时多看，多刷就行了，论文则有固定套路。但是案例则是需要考生自己主动对外输出，并且难以有一个统一的套路。所以，那些培训班的考生，死得最多的就是案例分析。&lt;/p&gt;
&lt;p&gt;而我对自己的案例分析是比较信心的。一方面是我参加的三次软考高级考试，每次案例分析分数都是客观，案例，论文三部分最高的。另一方面，我之前带过的一个同事，也是案例分析分数最高。&lt;/p&gt;
&lt;p&gt;所以，我尽可能将案例分析的方法与技巧说出来（但是有的方法真的很难通过文字描述）。&lt;/p&gt;
&lt;p&gt;文章将从案例准备，案例技巧，案例套路三个方面进行描述。&lt;/p&gt;
&lt;h2 id=&quot;案例准备&quot;&gt;案例准备&lt;/h2&gt;
&lt;p&gt;案例准备的要点有四个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础扎实：如果对案例设计的知识点一头雾水，那当然是凉凉了，而且是凉透了。&lt;/li&gt;
&lt;li&gt;主动输出：对知识点的认识不仅仅是知道（知道可以解决客观部分的那种多选一的题目），还要做到可以主动输出。如可以主动说出面向对象需求分析下用力模型的完整组成，毕竟案例需要的不是多选一，而是主动输出。&lt;/li&gt;
&lt;li&gt;熟悉题型：熟悉案例的常见题型，案例常见的题型，有：
&lt;ul&gt;&lt;li&gt;知识点背诵：如询问架构风格有哪些&lt;/li&gt;
&lt;li&gt;挖掘知识点：如从案例中挖掘王工的方案考虑了哪些系统属性&lt;/li&gt;
&lt;li&gt;优劣判断：如判断王工和李工的方案孰优孰劣，其本质还是需要大家从相关的知识点发散，套入&lt;/li&gt;
&lt;li&gt;对号入座：如判断图中各个流程点，分别对应哪种角色（如参与者，边界类等）&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;押题：和论文一样，不要押死题。而是根据往年的出题规律，判断这次考试各种类型题目的出题概率，从而确保自己将主要精力放在了核心考点上。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;往年案例分析题目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200428212501321.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;历年案例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图片绝对清晰。如果又看不清的，请在新页面打开，或者下载下来观看）&lt;/p&gt;
&lt;p&gt;以下是案例的考点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020042821200171.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;案例分析考点&quot;/&gt;&lt;br/&gt;（图片绝对清晰。如果又看不清的，请在新页面打开，或者下载下来观看）&lt;/p&gt;
&lt;p&gt;其实前两个要点，就是要求大家对知识点足够熟悉，适当进行背诵（不是所有都要背诵，根据第四个要点的结果，只背诵核心要点）。后两者就是研究历年的考题，需要大家自己在刷历年真题时，进行总结。&lt;/p&gt;
&lt;h2 id=&quot;案例技巧&quot;&gt;案例技巧&lt;/h2&gt;
&lt;p&gt;目的就是为了方便阅卷老师，让阅卷老师看到你的答案就感到舒服，那么你的分数自然就高了。&lt;/p&gt;
&lt;p&gt;案例的技巧主要分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;条理清晰：一定要让阅卷老师感受到你的条理清晰。因为阅卷老师是按答案的点给分的，所以，条理清晰便于阅卷老师迅速找到答案的点。最简单的做法，就是在答题时，对答案进行1，2，3，...点（并且这部分还有一些讨论，后面会说到）&lt;/li&gt;
&lt;li&gt;回答简洁：答案一定要在不破坏答案的点的前提下，尽可能精简
&lt;ul&gt;&lt;li&gt;简洁的答案会显得卷面整洁，给老师留下好的印象。&lt;/li&gt;
&lt;li&gt;简洁的回答会使得条理更加清晰。&lt;/li&gt;
&lt;li&gt;简洁的回答会节省大量时间。所以，许多考生都是踩着考试结束的铃声写完。而我案例考试则是写完了，还有20-30分钟时间用来检查答案。&lt;/li&gt;
&lt;li&gt;这点需要平时多加练习，追求和答案的点一样精简。那么答案应该精简到什么程度呢？这点会在后面的套路中说明。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用词精确：准确的用词
&lt;ul&gt;&lt;li&gt;可以做到回答简洁&lt;/li&gt;
&lt;li&gt;更大概率准确踩到答案的点（因为大部分案例问题的答案的点都是一个个的词）&lt;/li&gt;
&lt;li&gt;可以提升自己对知识点的准确把握&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;宁愿答错也多答：因为案例部分是正向给分的，也就是说看到对的点就给分，看到错的点也不扣分。当然也要适可而止，别写了100个点，阅卷老师根本就找不到正确的点。&lt;/li&gt;
&lt;li&gt;绝不留空：即使遇到不会的问题，也不要留空。因为留空意味着绝对没有分数。而一些合适的回答，也许可以获得一些分数。&lt;/li&gt;
&lt;li&gt;合理选题：由于案例分析是1 + 2/4（即第一题必写，后面四道题选做两道），但是答案纸只有三题的空间，所以合理选择要做的题目是很重要的。我见到不少考试后，抱怨说自己选择题目的。所以落笔前，花五分钟审阅一下后面四道选做题，确定每道题的把握分数（一定能拿到）和怀疑分数（不一定拿到），以及不可能分数（绝对拿不到）。然后根据自己日常对怀疑分数的获取情况（也可以使用其他评估方法，详见项目管理的时间管理等），判断出期望分数最高的两道题。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;案例套路&quot;&gt;案例套路&lt;/h2&gt;
&lt;p&gt;案例的讨论，其目的就是单纯为了获得更高的分数。并且可能不符合一般的考试技巧，但是又不属于作弊。&lt;/p&gt;
&lt;h3 id=&quot;看分写答案&quot;&gt;看分写答案&lt;/h3&gt;
&lt;p&gt;根据分数，判断答案的点的个数&lt;br/&gt;一般来说，答案的各个要点的分数都是一样的。所以，如果答案分数是8分，那么单点分数可能是1,2,4点（单点分数一般不会超过4分。超过了说明你还需要进行拆分）。这样我们就知道答案一共有8,4,2个点。如果你明确知道有三个点，那么正确答案很有可能有4个点，每个点2分。&lt;br/&gt;一旦知道问题答案有几个点。我们的回答策略就更加准确了。&lt;/p&gt;
&lt;p&gt;并根据每个点均分的分数，决定如何回答。如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1‘：层次架构。&lt;/li&gt;
&lt;li&gt;2‘：层次架构：归属于调用/返回架构风格，其提供了一种隔离系统各层功能的模型。&lt;/li&gt;
&lt;li&gt;3‘：层次架构：归属于调用/返回架构风格，其提供了一种隔离系统各层功能的模型。其优点是xxx。其缺点是xxx。&lt;/li&gt;
&lt;li&gt;3‘：层次架构：归属于调用/返回架构风格，其提供了一种隔离系统各层功能的模型。文中xxx与xxx特征，说明其采用的是层次架构。&lt;/li&gt;
&lt;li&gt;4‘：层次架构：归属于调用/返回架构风格，其提供了一种隔离系统各层功能的模型。其优点是xxx。其缺点是xxx。我们通常使用层次架构风格，实现xxxx，从而确保xxx。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模糊混分&quot;&gt;模糊混分&lt;/h3&gt;
&lt;p&gt;有的时候，我们会遇到一些难以确定的答案。比如遇到一个问题，不确定其到底是层次架构还是面向对象架构。以往的做法，通常是二选一，靠运气。还有一种做法，就是含糊回答调用/返回风格，调用/返回风格包含层次架构，面向对象架构。。。不过这种做法，需要考虑的因素比较多，与题型等都有一定关系。&lt;/p&gt;
&lt;p&gt;当然如果遇到三选一，四选一，那么选择这个做法，可能性价比更高一些。&lt;/p&gt;
&lt;h3 id=&quot;蒙混过关&quot;&gt;蒙混过关&lt;/h3&gt;
&lt;p&gt;有的时候，我们会遇到一道题完全不会做。&lt;br/&gt;那么千万不要留空，但是可以留到最后再做。因为在这个工程中，你可能就会做了。&lt;/p&gt;
&lt;p&gt;那么到了最后，自己还是不会做，该怎么办呢？&lt;/p&gt;
&lt;p&gt;简单说，就是蒙混过关。但是混也是有技巧的。&lt;/p&gt;
&lt;p&gt;首先，答案一定要与当前题目相关。聪明的小伙伴还会根据前后题目的问题与答案，猜测当前题目的答案在哪个范围。比如，第一题问需求获取，第三题需求定义，那么第二题大概率是需求分析相关。&lt;/p&gt;
&lt;p&gt;其次，答案的粒度需要把握好。太具体，可能会与正确答案偏差很大。太宽泛，阅卷老师绝对不会给分。所以需要把握好答案的粒度。&lt;/p&gt;
&lt;p&gt;最后，答案需要多一些内容。因为这道题是我们不会的。所以，我们需要通过“广撒网”的方式命中正确答案的点。起码能和正确答案的点擦个边，给老师放分的理由。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我一般会将软考这种考试分为两个部分，一个是学习部分，一个是考试部分。&lt;br/&gt;相对来说，我更加看中学习部分。记住，我们是抱着学习知识的目的来的，而证书只是顺带的。&lt;br/&gt;但是既然有考试，自然就有应试技巧。作为多年应试教育出来的小伙伴，相信都有着自己的应试技巧。&lt;/p&gt;
&lt;p&gt;平时，我们要做到努力学习。考试时，我们要“不择手段”获得每一分。因为平时我们是为了追求知识。而踏入考场后，我们唯一的目的就是通过考试。&lt;/p&gt;
&lt;p&gt;至此，系统分析师的案例分析就搞定了。&lt;/p&gt;
&lt;p&gt;愿与诸君共进步。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Apr 2020 00:54:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>十分钟教条与经验，轻松搞定系统分析师的案例分析 前言 系统分析师培训班通过统计，得到一个结论：培训班的考生，死得最多的就是案例分析。 为什么呢？因为客观题只要平时多看，多刷就行了，论文则有固定套路。但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/12806655.html</dc:identifier>
</item>
<item>
<title>Django Channel实时推送与聊天 - Sunzz</title>
<link>http://www.cnblogs.com/Sunzz/p/12788608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sunzz/p/12788608.html</guid>
<description>&lt;p&gt;先来看一下最终的效果吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1157397/202004/1157397-20200427184512361-1268642302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;开始聊天，输入消息并点击发送消息就可以开始聊天了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1157397/202004/1157397-20200427184843746-1575487506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;点击 “获取后端数据”开启实时推送&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1157397/202004/1157397-20200427185032485-1877733770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;先来简单了解一下 &lt;strong&gt;Django Channel&lt;/strong&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;9.9002493765586&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Channels是一个采用Django并将其功能扩展到HTTP以外的项目，以处理WebSocket，聊天协议，IoT协议等。&lt;/span&gt;&lt;span&gt;它基于称为&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;reference external&quot; href=&quot;http://asgi.readthedocs.io/&quot;&gt;ASGI&lt;/a&gt;&lt;span&gt;&lt;span&gt;的Python规范构建&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它以Django的核心为基础，并在其下面分层了一个完全异步的层，以同步模式运行Django本身，但异步处理了连接和套接字，并提供了以两种方式编写的选择，从而实现了这一点。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　详情请参考官方文档：&lt;a href=&quot;https://channels.readthedocs.io/en/latest/introduction.html&quot;&gt;https://channels.readthedocs.io/en/latest/introduction.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;再简单说下&lt;strong&gt;ASGI&lt;/strong&gt;是什么东东吧&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md_line&quot;&gt;ASGI 由 Django 团队提出，为了解决在一个网络框架里（如 Django）同时处理 HTTP、HTTP2、WebSocket 协议。为此，Django 团队开发了 Django Channels 插件，为 Django 带来了 ASGI 能力。&lt;br/&gt; &lt;span class=&quot;md_line&quot;&gt;在 ASGI 中，将一个网络请求划分成三个处理层面，最前面的一层，interface server（协议处理服务器），负责对请求协议进行解析，并将不同的协议分发到不同的 Channel（频道）；频道属于第二层，通常可以是一个队列系统。频道绑定了第三层的 Consumer（消费者）。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 　　详情请参考官方文档： &lt;a href=&quot;https://channels.readthedocs.io/en/latest/asgi.html&quot;&gt;https://channels.readthedocs.io/en/latest/asgi.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下边来说一下具体的实现步骤&lt;/p&gt;
&lt;p&gt; 转载请注明原文链接： &lt;a href=&quot;https://www.cnblogs.com/Sunzz/p/12788608.html&quot;&gt;https://www.cnblogs.com/Sunzz/p/12788608.html&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip3 &lt;span&gt;install&lt;/span&gt;&lt;span&gt; channels 
pip3 &lt;/span&gt;&lt;span&gt;install&lt;/span&gt; channels_redis
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span class=&quot;pln&quot;&gt;1.新建项目&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
django-admin startproject mysite
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.新建应用&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python3 manage.py startapp chat
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.编辑 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;mysite/settings.py&lt;/span&gt;&lt;/code&gt;文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注册应用&lt;/span&gt;
INSTALLED_APPS =&lt;span&gt; [
    ....
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chat.apps.ChatConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;channels&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
]
&lt;br/&gt;# 在文件尾部新增如下配置&lt;br/&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将ASGI_APPLICATION设置设置为指向该路由对象作为您的根应用程序：&lt;/span&gt;
ASGI_APPLICATION = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysite.routing.application&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;配置Redis&lt;/span&gt;
CHANNEL_LAYERS =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BACKEND&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;channels_redis.core.RedisChannelLayer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CONFIG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hosts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.0.6.29&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 6379&lt;span&gt;)],
        },
    },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1. 添加索引视图的模板&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;chat&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;目录中&lt;/span&gt;&lt;span&gt;创建一个templates&lt;/span&gt;&lt;span&gt;目录。&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;您刚刚创建&lt;/span&gt;&lt;span&gt;的templates &lt;/span&gt;&lt;span&gt;目录中，创建另一个名为的目录 &lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;chat&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，并在其中创建一个名为的文件&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;index.html&lt;/span&gt;&lt;/code&gt;&lt;span&gt;以保存索引视图的模板&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;将以下代码放入&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;chat/templates/chat/index.html&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; chat/templates/chat/index.html &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Chat Rooms&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    What chat room would you like to enter?&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;room-name-input&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; size&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;room-name-submit&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Enter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#room-name-input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).focus();
        document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#room-name-input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).onkeyup &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e.keyCode &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;&lt;span&gt;) {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; enter, return&lt;/span&gt;
&lt;span&gt;                document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#room-name-submit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click();
            }
        };

        document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#room-name-submit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).onclick &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; roomName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#room-name-input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).value;
            window.location.pathname &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/chat/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; roomName &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        };
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.创建聊天与消息推送模板&lt;/h2&gt;
&lt;p&gt;chat/templates/chat/room.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.0/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Chat Room&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;chat-log&quot;&lt;/span&gt;&lt;span&gt; cols&lt;/span&gt;&lt;span&gt;=&quot;150&quot;&lt;/span&gt;&lt;span&gt; rows&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;chat-message-input&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; size&lt;/span&gt;&lt;span&gt;=&quot;150&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;chat-message-submit&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;发送消息&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;input-sm&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;get_data&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-success&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;获取后端数据&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{{ room_name|json_script:&quot;room-name&quot; }}

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#get_data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $.ajax({
            url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{% url 'push' %}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            data: {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;room&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{ room_name }}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;csrfmiddlewaretoken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{ csrf_token }}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            },
        })
    });

    const roomName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; JSON.parse(document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;room-name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).textContent);
    const chatSocket &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebSocket(
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ws://&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; window.location.host
        &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/ws/chat/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;+&lt;/span&gt;&lt;span&gt; roomName &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    );
    let chatSocketa &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebSocket(
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ws://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; window.location.host &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/ws/push/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; roomName
    );
    chatSocket.onmessage &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        const data &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; JSON.parse(e.data);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; data 为收到后端发来的数据&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(data);&lt;/span&gt;
&lt;span&gt;        document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#chat-log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).value &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; (data.message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    };
    chatSocketa.onmessage &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        let data &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; JSON.parse(e.data);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;let message = data[&quot;message&quot;];&lt;/span&gt;
&lt;span&gt;        document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#chat-log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; (data.message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    };


    chatSocket.onclose &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        console.error(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Chat socket closed unexpectedly&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    };
    chatSocketa.onclose &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        console.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chat socket closed unexpectedly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    };
    document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#chat-message-input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).focus();
    document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#chat-message-input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).onkeyup &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e.keyCode &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;&lt;span&gt;) {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; enter, return&lt;/span&gt;
&lt;span&gt;            document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#chat-message-submit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click();
        }
    };

    document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#chat-message-submit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).onclick &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        const messageInputDom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#chat-message-input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        const message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; messageInputDom.value;
        chatSocket.send(JSON.stringify({
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: message
        }));
        messageInputDom.value &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
    };
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.&lt;span&gt;&lt;span&gt;创建房间的视图&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;将以下代码放入&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;chat/views.py&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
# chat/views.py
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.http &lt;span&gt;import&lt;/span&gt;&lt;span&gt; JsonResponse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; channels.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_channel_layer
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asgiref.sync &lt;span&gt;import&lt;/span&gt;&lt;span&gt; async_to_sync


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(request):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chat/index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; room(request, room_name):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chat/room.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;room_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: room_name})


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pushRedis(request):
    room &lt;/span&gt;= request.GET.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;room&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(room)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; push(msg):
        channel_layer &lt;/span&gt;=&lt;span&gt; get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            room,
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;push.message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: msg, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;room_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: room}
        )

    push(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;推送测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, )
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JsonResponse({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1})
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4. 创建项目二级路由&lt;/h2&gt;
&lt;p&gt;在chat目录下&lt;span&gt;&lt;span&gt;创建一个名为的文件&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;urls.py&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; mysite/chat/urls.py&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    path(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;, views.index, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),&lt;br/&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;　　 path&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'&amp;lt;str:room_name&amp;gt;/'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;views&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;room&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;name&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;s1&quot;&gt;'room'&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5. 修改根路由&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# mysite/urls.py&lt;p&gt;from&lt;/p&gt;&lt;/span&gt; django.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; admin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path, include
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; chat.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pushRedis

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, admin.site.urls),
    path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chat/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, include(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chat.urls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)),
    path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;push&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, pushRedis, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;push&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.&lt;span&gt;&lt;span&gt;创建一个消费者&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;chat/consumers.py&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pre&quot;&gt;&lt;span&gt;当Django接受HTTP请求时，它会查询根URLconf来查找视图函数，然后调用该视图函数来处理该请求。&lt;/span&gt;&lt;span&gt;同样，当Channels接受WebSocket连接时，它会查询根路由配置以查找使用者，然后在使用者上调用各种功能来处理来自连接的事件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; channels.generic.websocket &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebsocketConsumer, AsyncWebsocketConsumer
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asgiref.sync &lt;span&gt;import&lt;/span&gt;&lt;span&gt; async_to_sync
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis

pool &lt;/span&gt;=&lt;span&gt; redis.ConnectionPool(
    host&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10.0.6.29&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    port&lt;/span&gt;=6379&lt;span&gt;,
    max_connections&lt;/span&gt;=10&lt;span&gt;,
    decode_response&lt;/span&gt;=&lt;span&gt;True,
)
conn &lt;/span&gt;= redis.Redis(connection_pool=pool, decode_responses=&lt;span&gt;True)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChatConsumer(AsyncWebsocketConsumer):
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; connect(self, ):
        self.room_name &lt;/span&gt;= self.scope[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url_route&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kwargs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;room_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        self.room_group_name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chat_%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.room_name

        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name,
        )
        await self.accept()

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; disconnect(self, close_code):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;close_code: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, close_code)
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; receive(self, text_data=None, bytes_data=&lt;span&gt;None):
        text_data_json &lt;/span&gt;=&lt;span&gt; json.loads(text_data)
        message &lt;/span&gt;= text_data_json[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;receive_message：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, message)
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chat_message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: message
            }
        )

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; chat_message(self, event):
        receive_message &lt;/span&gt;= event[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        response_message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You message is :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; receive_message
        await self.send(text_data&lt;/span&gt;=&lt;span&gt;json.dumps({
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: response_message
        }))


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PushMessage(WebsocketConsumer):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; connect(self):
        self.room_group_name &lt;/span&gt;= self.scope[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url_route&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kwargs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;room_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        async_to_sync(self.channel_layer.group_add)(
            self.room_group_name,
            self.channel_name
        )
        self.accept()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; disconnect(self, code):
        async_to_sync(self.channel_layer.group_discard)(
            self.room_group_name,
            self.channel_name
        )

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; push_message(self, event):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        主动推送
        :param event:
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(event, type(event))
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            time.sleep(&lt;/span&gt;2&lt;span&gt;)
            msg &lt;/span&gt;= time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H:%M:%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---  room_name: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % event[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;room_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
            self.send(text_data&lt;/span&gt;=&lt;span&gt;json.dumps(
                {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: msg}
            ))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.为项目添加websocket的路由配置&lt;/h2&gt;
&lt;p&gt;在chat目录下创建一个名为的文件routing.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
# mysite/chat/&lt;span&gt;routing.py

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re_path, path
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; consumers

websocket_urlpatterns &lt;/span&gt;=&lt;span&gt; [
    re_path(r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ws/chat/(?P&amp;lt;room_name&amp;gt;\w+)/$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, consumers.ChatConsumer),
    path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ws/push/&amp;lt;room_name&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, consumers.PushMessage),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;8.配置websocket根路由&lt;/h2&gt;
&lt;p&gt;与setting同级目录新建ws根路由文件 routing.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; channels.routing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ProtocolTypeRouter, URLRouter
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; channels.auth &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AuthMiddlewareStack
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; chat.routing

application &lt;/span&gt;=&lt;span&gt; ProtocolTypeRouter({
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;websocket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: AuthMiddlewareStack(
        URLRouter(
            chat.routing.websocket_urlpatterns
        )
    ),
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;9.最终的文件关系如下图 &lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1157397/202004/1157397-20200427183915702-1564418275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;10.启动服务&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python3 manage.py runserver &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;6.2&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意看，这和django是不一样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1157397/202004/1157397-20200427185248328-1373426294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;还有另一种更稳健的启动方式&lt;/p&gt;
&lt;p&gt;和setting同级新增文件 asgi.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; django
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; channels.routing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_default_application

os.environ.setdefault(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DJANGO_SETTINGS_MODULE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mysite.settings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
django.setup()
application &lt;/span&gt;= get_default_application()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动方式为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
daphne -b &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;6.2&lt;/span&gt; -p &lt;span&gt;80&lt;/span&gt; mysite.asgi:application
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
daphne 在安装channel时已经自动安装好了
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1157397/202004/1157397-20200428093458724-935120735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://channels.readthedocs.io/en/latest/tutorial/index.html&quot;&gt;https://channels.readthedocs.io/en/latest/tutorial/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://blog.ernest.me/post/asgi-demonstration-realtime-blogging&quot;&gt;https://blog.ernest.me/post/asgi-demonstration-realtime-blogging&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 Apr 2020 00:29:00 +0000</pubDate>
<dc:creator>Sunzz</dc:creator>
<og:description>先来看一下最终的效果吧 开始聊天，输入消息并点击发送消息就可以开始聊天了 点击 “获取后端数据”开启实时推送 先来简单了解一下 Django Channel Channels是一个采用Django并将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Sunzz/p/12788608.html</dc:identifier>
</item>
<item>
<title>Component Object Model (COM) 是什么？ - Bitssea</title>
<link>http://www.cnblogs.com/bitssea/p/12590702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bitssea/p/12590702.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文主要介绍 COM 的基础知识，倾向于理论性的理解，面向初学者，浅尝辄止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;h3 id=&quot;1-com-是什么：&quot;&gt;1. COM 是什么：&lt;/h3&gt;
&lt;p&gt;COM 的英文全称是，Component Object Model，中文译为，组件对象模型。它官方的概念是：The Microsoft Component Object Model (COM) is a platform-independent, distributed, object-oriented system for creating binary software components that can interact. 与其说 COM 是 System，更确切的说，应该叫做 Standard。因为它实际上是一套公共的 binary 标准，用于规定 software component 的接口的标准。也有人会把 COM 叫做 Common Object Model，但这其实是一种误传，起源于当初一名微软的工作人员 Mark Ryland！&lt;/p&gt;
&lt;p&gt;但是，在长期的使用中，大家口中念叨的 COM 渐渐生出了各种各样的含义，已经不仅仅是最初的含义了。这也是为什么，对于初学者来说，理解起来特别费劲。因为总会查到层出不穷，又参差不齐的含义，让人很疑惑到底哪个含义才是标准！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，在系统设计上，它是一种，设计理念，&lt;/li&gt;
&lt;li&gt;然后，在 Object 的世界中，它是那个世界中的，规范和标准，&lt;/li&gt;
&lt;li&gt;再然后，在编程语境下，它是一种，可以调用的，其他程序的接口，&lt;/li&gt;
&lt;li&gt;再然后，在实际的电脑文件中，它多数是一个个 DLL 文件，&lt;/li&gt;
&lt;li&gt;最后，在内部性质上，它是一个个二进制（Binary）的小程序，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实在我 Research 的时候，这些概念也是最头疼的地方。因为对 COM 概念的不了解，所以无法区分在不同视角，或者不同角度下的概念。而在 Research 的时候，往往会看到很多不同的网页，给出各种 COM 的概念。而让人头疼的就是，这些概念都不统一，让人无法理解。甚至开始怀疑，这些网页真的都是说的同一个东西的概念么？这种混乱，就是因为，不同的网站，在解释 COM 的时候，用的是不同的角度。而同一个东西，在不同的角度和情景之下，自然会有不同的含义。所以，往往 COM 到底是什么，要因情景而视之！但是，上面列出的几个角度，已足以让我们对 COM 的概念，构建出一个较为立体的理解了！&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;2-科技历史与-com-的由来：&quot;&gt;2. 科技历史与 COM 的由来：&lt;/h3&gt;
&lt;p&gt;要了解 COM 的历史由来，我们首先要从科技发展的历史开始捋顺下来。先说 Object Oriented 这种概念，其实，这种概念据说是19世纪60年代就有了，是源自于 MIT。但是那个时候 PC 还没有普及，大多数公司使用的都是十分昂贵的大型机，微软还没有成立，这种情况下，自然对软件的需求也是非常基本的，大多数停留在数学计算，文字处理，和军事使用的范围。而且那个时候，CPU 的概念都还没出现，自然电脑也是不可能具备足够的运算能力的。第一个 CPU，是 Intel 在 1971 年，为完成一家日本公司的订单而设计发明的，自此才解锁的计算的巨大潜力，进入了现代计算机的篇章。而 CPU 的发展与成熟，才造就了后来的软件行业。微软也于 1975 年正式成立。同年，IBM 也开始生产 Portable Computers。那时起，微型电脑开始变成潮流。Microsoft BASIC 这种最早期的编程语言，也诞生于 1975年。那时候，绝大多数的微型电脑，虽然系统都不同，但是几乎都支持 BASIC 这种编程语言。正是这种编程语言，成为了日后微软的基础。1981年，微软首次为 IBM 提供了操作系统，叫做 QDOC，是微软的第一套系统，但却是买来的，别人研发的系统。1983年，微软研发出了 Lotus Software，是最早期的电子表格软件，这个软件成为了 IBM 电脑上的明星软件，装机必备。后来 1985年 Windows 1 诞生了，同时伴随着 Microsoft Excel 的诞生。自此之后，软件行业开始变得日益繁荣，微软也开启了自己的软件帝国。&lt;/p&gt;
&lt;p&gt;软件行业变得日益繁荣，但是 Object Oriented 这种思想，还并没有发展到一定的高度。那时候，开发个软件或者系统是非常麻烦，非常复杂的。日后，想给软件添加一个功能，或者升级一个功能时，就更麻烦，因为，没办法独立的，去更新，或者改进，某一个特定的功能。若想要添加新功能，需要全盘改动后，再重新进行编译，非常的费时费力。于是人们就开始想办法解决，上面这个问题，然后 Object Oriented Programming（面向对象的编程）的概念就开始兴起。这时，虽然面向对象编程的概念已经兴起，但是，还没有统一的 Framework 或者说是标准，能让不同软件之间里的 Object 可以互相交流。于是，不同的软件，就变成了一个个，孤立在大海中的小岛，里面住着一堆 Objects，无法和外界交流。人们想出的解决办法就是，开发一个系统或者体系，在这个体系中，写软件的人只需要制造出，Software Component 就行了。而，这个 Component 就像是，买回来一个，方块形的，电子配件一样，插在我们自己的电路板上，就可以开始发挥作用。而这些，Software Component 外表上，必须遵循系统中的统一标准，而内部，就随便怎么编程都可以。后来，微软在1993年，开发出了这个标准，这标准就被叫做，Component Object Model (COM)。&lt;/p&gt;
&lt;p&gt;我们再把 COM 形成前后的，技术发展，掰开来看下。首先，在 1987年，也就是在 Windows 2 发行的时候，Dynamic Data Exchange (DDE) 技术产生了，作为一种进程间通信手段（Inter-process communication）。在这个技术之前，只支持系统和客户端应用程序之间的通信，这个通信，则是通过 Windows Messaging Layer 实现的。而 DDE 技术，则再此基础之上，实现了客户端应用程序之间的通信，这也就成为了进程间通信技术的开端。但这时的通信，还只是停留在 Text conversations 和 Windows messages 的层面上。之后 Antony Williams 分别于 1988年 和 1990年 发表了两篇微软内部文章，分别是 【Object Architecture: Dealing With the Unknown】和【On Inheritance: What It Means and How To Use It】。正是两篇文章奠定了日后 COM 产生的理论基础。之后，1991年，微软在 DDE 的基础上，开发出了第一个 object-based framework（基于对象的框架），叫做 Object Linking and Embedding (OLE)，即对象的连接与嵌入。这个技术是同 Word 软件的发行一同发布的，专注于实现 Compound document（复合型文件），就是将 Excel 文件，嵌入到 Word 中。同在 1991年，微软发布了 Visual Basic 1.0 编程语言，并以 dynamic-link library (DLL) 的形式，附带了 Visual Basic Extensions (VBX) 插件。这个插件让使用者，可以通过 Properties and Methods 来操控 objects （对象）。1992年，随着 Windows 3.1 的发布，OLE2 和它自己的 Object Model，也一同发布了。和 OLE1 不同，OLE2 是在 COM 概念的基础上重新实施的。这时的 COM Application binary interface (ABI)，即 COM 应用接口的标准也发生了改变。1994的时候，微软宣布，OLE2 改名为 OLE，从此 OLE 变成了，微软组件技术（Component Technologies）的统称。同年还发布了 OLE Custom Controls (OCXs) ，作为 VBX 的升级版。后来，在1995年，微软发布了 Visual Basic 4.0，开始支持 OCXs，这时微软也开始考如何让 COM 组件可以实现跨语言支持。这就要求，COM 架构下，必须要提供一个一致的接口，以及提供一组可以调用接口内方法的能力。此后，才发展成了我们现今熟悉的 COM 的含义。在1996年，微软有发现 OCXs 可以应用在浏览器上，所以就把部分 OLE 改名为 Internet &quot;ActiveX&quot;，然后，逐渐的，所有的 OLE 都改名叫做 ActiveX 了。同年后期，微软又拓展了 COM 的能力，使得组件对象，拥有了在网络上通信的的能力。这个技术被称为 DCOM （Distributed COM）。自此便形成了今时今日的 COM 的概念。&lt;/p&gt;
&lt;p&gt;这篇文章中涉及到了不少的历史，之前在学习，近200年的，科技发展历史时，把 &lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/bitssea/p/12717282.html&quot;&gt;Technology Timeline&lt;/a&gt;&lt;/em&gt; 写在博客里，感兴趣的同学可以点进去看一下。在那篇博客中，我把微软技术发展的 Timeline，和科技发展的 Timeline 揉合在了一起，这样能帮助我们感觉到，技术是在伴随着科技的发展而发展。也可以看到，COM 这种技术理念的产生，是在PC渐渐普及起来，操作系统渐渐成熟，软件需求逐渐提高之后才有的。所以很多事情的发展，往往都是自然而然的，因为有了需求，才会有相应的发展。COM 的产生，从这个角度说，也是一种必然。因为 COM 实际上，就是一种规范，就像行业规范一样，行业太小自然不用规范，而规模大了，需求大了，自然会产生规范，所以 COM 的产生是一种必然结果。而技术的发展，既在推进着科技的发展，也受制于现有科技的边缘。&lt;/p&gt;
&lt;h3 id=&quot;3-接口（interface）周围的概念：&quot;&gt;3. 接口（Interface）周围的概念：&lt;/h3&gt;
&lt;p&gt;个人认为，关于 COM，的一切的一切，最后都是为了这个“接口”。因为只有有了“接口”，才算是真正的实现了 Component Object 的理念（或者说，才算是实现了，把 Object 变成 Component 的想法）。因为只有有了“接口”，Component 才能被叫做组件，才能被调用。所以下面简单描述下，几个常见的，围绕着“接口”的概念：&lt;/p&gt;
&lt;h4 id=&quot;31-api-application-programming-interface&quot;&gt;3.1. API (Application Programming Interface)&lt;/h4&gt;
&lt;p&gt;API 中文为，应用程序编程接口；很多时候，都被直接叫做 “接口” (Interface)。“接口”是“操作系统” 或 “程序库”，提供给应用程序的，接入点，让应用程序能调用，系统某一方面的功能。其主要作用是，让开发人员，可以轻松调用这些功能，而不需要了解，到底怎么做到的，和底层代码。但是，API 并不是代码，他只是一个接口，或者说只是一个地址。&lt;/p&gt;
&lt;h4 id=&quot;32-idl（interface-defining-language）&quot;&gt;3.2. IDL（Interface Defining Language）&lt;/h4&gt;
&lt;p&gt;IDL 中文为，接口描述语言。它是一种 Specification language（规范语言）。是用来描述，软件 Component 的 API 的 “规范语言”。与之相比，Programming Language（编程语言）是可以直接运行，用于系统实现的，形式语言。而，“规范语言” 是通常不能直接运行的，而是用于系统分析和设计的，描述语言。然后，这些一段一段的用来描述 Interface 的文字，就被储存在了 IDL 文件中（文件后缀就是 “.idl”）。每个这样的文件里面都有，一个 header 和一个 body。格式很整齐。&lt;/p&gt;
&lt;h4 id=&quot;33-ole-object-linking-and-embedding&quot;&gt;3.3. OLE (Object Linking and Embedding)&lt;/h4&gt;
&lt;p&gt;OLE 中文为，对象链接与嵌入。是能让应用程序创建，包含不同来源的文档，的复合文档技术。OLE 是建立在 COM 理念的基础之上的。COM 是理论框架，而 OLE 是根据这个框架，实施出来的一套技术。正如之前在，PC Mag 杂质上看到的一个副标题，就很好的诠释了这种关系型：&quot;COM-the master plan that lets Windows apps interact through OLE.&quot; 一个比较常见的例子就是，把 Excel 表格，整个插入到 Word 文档中。而这个 Excel Object，就是通过这个 OLE 技术，连接并嵌入（Linking and Embedding）到 Word 中的。但，正如上文所说，后来 OLE 就变成了，微软组件技术（Component Technologies）的统称。而，像这样的一个典型的 OLE 功能（或 OLE 特性），其背后是有一大堆，Interface（接口）作为支持，才得以实现的。&lt;/p&gt;
&lt;h4 id=&quot;34-guid-globally-unique-identifier&quot;&gt;3.4. GUID (Globally Unique Identifier)&lt;/h4&gt;
&lt;p&gt;GUID 中文为，全局唯一标识符，也被称为，UUID (Universally Unique Identifier)，即，通用唯一识别码。是一个用于标识信息的，128-bit的，标识符；由一组，32位數的，16进制的，数字组成。数字串，的格式为 8-4-4-4-12 的32个字元；大概长成这样：550e8400-e29b-41d4-a716-446655440000。GUID 具有全球唯一性，出现重复的概率几乎为零。所以才叫做，全局唯一标识符。&lt;/p&gt;
&lt;h4 id=&quot;35-clsid-class-identifier&quot;&gt;3.5. CLSID (Class IDentifier)&lt;/h4&gt;
&lt;p&gt;CLSID 中文为，类标识符。是一个 GUID，但是，是专门用于，标识 COM class object 的。每一个 OLE Class，都会有一个与之对应的，全球独一的 CLSID。&lt;/p&gt;
&lt;h4 id=&quot;36-progid-programmatic-identifier&quot;&gt;3.6. ProgID (PROGrammatic IDentifier)&lt;/h4&gt;
&lt;p&gt;ProgID 可以翻译为，程序标识符，或者，编程标识符。通常情况下，每个 CLSID，都会有对应的 ProgID。例如，ProgID 是 Msxml2.DOMDocument 的字符串；而 CLSID 则长成这个样子 {F9043C85-F6F2-101A-A3C9-08002B2F49FB}。所以 ProgID 的存在，是为了编程的时候，方便调用。&lt;/p&gt;
&lt;h4 id=&quot;37-registry-windows&quot;&gt;3.7. Registry (Windows)&lt;/h4&gt;
&lt;p&gt;Registry 中文为，注册表。它是一个 hierarchical database (分层的数据库)。用于储存 Windows 系统，或者应用程序的 low-level settings。但并不是，所有的应用程序都选择把设置，存在注册表里。Registry 是从 Windows 3.0，推出 OLE 的时候，开始有的。在那之前，应用程序都是把自己的设置信息存在一个后缀为“.ini”的文本文件中的。除了设置之外，所有的 OLE Objects 的 CLSID， 也都储存在这个 Registry 中。感兴趣的同学可以去 Regedit.exe 中，这个位置（HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID）看下，所有的 CLSID 都长成什么样。而在每个 CLSID 的“文件夹”中，又都会储存着，这个 Class 的 ProgID 的名字。&lt;/p&gt;
&lt;h3 id=&quot;4-调用组件的流程&quot;&gt;4. 调用组件的流程&lt;/h3&gt;
&lt;p&gt;阅读到这里的同学，应该已经对基本的概念有一些了解。那么我们就再来看下，在实际运行中，Component（组件）到底是怎么被调用的。就用在 Word 里面插入一张 Bitmap Image 来举例；当我们在 Word 程序里，点击插入 Object 的时候，Word 会弹出，插入对象的对话框。然后，程序会立刻开始扫描，系统的 Registry，看哪些 Object 是能够插入的，然后，把它们都列在你面前，供你选择。当你选中 Bitmap Image 这个对象后，程序会，立刻调出他的 ProgID 名字，然后，把这个名字，递给一个叫做 CoCreateInstance 的 OLE Function。再然后，在这个 Function 的内部，就开始了一系列流程。&lt;/p&gt;
&lt;p&gt;首先 OLE 会用立刻这个 ProgID（或者 CLSID）去找出与它对应的 Regstry 条目。然后，通过注册表里登记的信息，便可以轻易的找到，提供这个“服务”的，应用程序，或者 Component（.exe 或者 .dll）到底住在哪里。一旦找到了，便可以立刻调用（Invoke）这个 Component，然后创建出，一个 Bitmap 对象的 Instance（这个Instance，似乎也叫做 Interface Pointer）。&lt;/p&gt;
&lt;p&gt;这和我们写代码的时候是一样的，在我们要使用某个模块的功能之前，都是先通过 PorgID 创建一个 Instance（例如，在 VBScript 中，通常是用&lt;code&gt;Set XL = CreateObject(&quot;Excel.Application&quot;)&lt;/code&gt;这样的语句）。然后通过这个 Instance，和它提供的 Interface（接口），我们就可以开始调用，这个实例的各种属性和功能了（例如 &lt;code&gt;XL.Workbooks.Open(&quot;FilePath&quot;)&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;当然，这个流程中省略了很多的细节，想要了解具体细节的同学，就去看我“脚注2”中的 Article 吧，这篇文章虽然是1995年的，但是写的非常的好，非常值得阅读，尤其是在学习 COM 的同学，这篇文章能很好的提升我们的理解。好吧，这部分就这么多啦。&lt;/p&gt;
&lt;h3 id=&quot;5-篇尾结语：&quot;&gt;5. 篇尾结语：&lt;/h3&gt;
&lt;p&gt;研究的过程中发现，COM 相关的东西，真的是博大精深，作为一只小白，也只能是浅尝辄止了。感谢您花时间阅读，小白贡献，语失莫怪。文章中涉及到的历史并没有列在这里的参考阅读，而是列在了我另一篇叫做 &lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/bitssea/p/12717282.html&quot;&gt;Technology Timeline&lt;/a&gt;&lt;/em&gt; 的博客里，有需要的同学可以点进去看下 (^_−)☆。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;P.S. 为了写完这篇，关于 COM 的小白文章，真的是有一种，跋山涉水，翻山越岭的感觉啊 (T^T)，希望能对同学们有所帮助....&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关书籍：&quot;&gt;相关书籍：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;《COM技术内幕》，Dale Rogerson&lt;/li&gt;
&lt;li&gt;《Learning DCOM》，Thuan L. Thai&lt;/li&gt;
&lt;li&gt;《Inside OLE》，Kraig Brockschmidt&lt;/li&gt;
&lt;li&gt;《COM本质论》，Don Box&lt;/li&gt;
&lt;li&gt;《MFC Windows程序设计》，Jeff Prosise&lt;/li&gt;
&lt;li&gt;《Windows XP Under the Hood》，Brian Knittel&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;参考阅读：&quot;&gt;参考阅读：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E7%BB%84%E4%BB%B6%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/3351546?fromtitle=Component%20Object%20Model&amp;amp;fromid=4234962&quot;&gt;组件对象模型_百度百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Component_Object_Model&quot;&gt;Component Object Model - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/com/com-technical-overview&quot;&gt;COM Technical Overview - Win32 apps | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/com/the-component-object-model&quot;&gt;The Component Object Model - Win32 apps | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh4ui.net/tags/com/&quot;&gt;COM - Marvin's Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://books.google.co.uk/books?id=COEmRfcp2RAC&amp;amp;pg=PA282&amp;amp;lpg=PA282&amp;amp;dq=every+COM+interface+has+a+GUID&amp;amp;source=bl&amp;amp;ots=VLqsEnHQqL&amp;amp;sig=ACfU3U2sQtvjT910nIevgGwLevrt-L8CRw&amp;amp;hl=en&amp;amp;sa=X&amp;amp;ved=2ahUKEwiqvLqBqInpAhXJiFwKHUtuAcQQ6AEwCXoECAUQAQ#v=onepage&amp;amp;q&amp;amp;f=false&quot;&gt;PC Mag - Google Books&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 30 Apr 2020 00:27:00 +0000</pubDate>
<dc:creator>Bitssea</dc:creator>
<og:description>本文主要介绍 COM 的基础知识，倾向于理论性的理解，面向初学者，浅尝辄止。 1. COM 是什么： COM 的英文全称是，Component Object Model，中文译为，组件对象模型。它官方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bitssea/p/12590702.html</dc:identifier>
</item>
<item>
<title>设计数据库 ER 图太麻烦？不妨试试这两款工具，自动生成数据库 ER 图！！！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12806549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12806549.html</guid>
<description>&lt;h2 id=&quot;忙，真忙&quot;&gt;忙，真忙&lt;/h2&gt;
&lt;blockquote readability=&quot;4.9913043478261&quot;&gt;
&lt;p&gt;点赞再看，养成习惯，微信搜索『程序通事』,关注就完事了！&lt;br/&gt;&lt;a href=&quot;https://studyidea.cn/&quot;&gt;点击查看更多精彩的文章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这两个星期真是巨忙，年前有个项目因为各种莫名原因，一直拖到这个月才开始真正测试。然后上周又接到新需求，马不停蹄进入开发。&lt;/p&gt;
&lt;p&gt;一边开发着新需求，一边改着旧项目的 Bug。再加上这个项目算是从别人那交给过来的，这部分新功能代码并不是很熟，改 Bug 的时候又需要理清楚上下文逻辑，非常耗时间。&lt;/p&gt;
&lt;p&gt;这不有一天状态还不好，迷迷糊糊中改了一天 Bug，又写了一天 Bug。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081010040-685616401.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自产自销，问题有点大，后面几天一直填自己的挖的坑，那叫一个酸爽。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081010263-2006260991.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，不水了，不水了！&lt;/p&gt;
&lt;p&gt;上面写这么多，本周没啥时间写技术文，那就写点轻松的，分享一个日常比较实用的功能『&lt;strong&gt;自动生成数据库 ER 图&lt;/strong&gt;』&lt;/p&gt;
&lt;h2 id=&quot;自动生成-er-图&quot;&gt;自动生成 ER 图&lt;/h2&gt;
&lt;p&gt;平常做技术方案设计的时候，如果有涉及到表结构的变更，就需要在文档中说明，还得将表结构信息写到文档中，类似如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081010391-2135417498.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是一个新项目，新增了多张表，手动将字段填到表格中，再画个 ER 图，很是费劲。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081010650-1206304913.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这不最近刚好发现了 IDEA Database 插件，可以自动生成 ER 图。&lt;/p&gt;
&lt;p&gt;假设现有两张表 &lt;code&gt;activity&lt;/code&gt; 与 &lt;code&gt;visitor&lt;/code&gt;，表结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE activity
(
    activity_id int          NOT NULL,
    title       varchar(256) NOT NULL,
    PRIMARY KEY (activity_id)

);


CREATE TABLE visitor
(
    id          int NOT NULL,
    activity_id int NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (activity_id) REFERENCES activity(activity_id)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 IDEA Database 弹框中选中相应的表，右键菜单选择 &lt;strong&gt;Diagrams-Show Visualisation&lt;/strong&gt;，就可以生成 ER 图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081011119-613768205.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps: maven 包之间的层级关系也可以用这个功能展示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于存在真实外键，IDEA Database 生成 ER 图的时候将会自动生成外键的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081011283-576500756.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是真实生产环境，我们很少会建立这种真实物理外键关系，仅仅只会在逻辑上生成一个虚拟的外键的关系。&lt;/p&gt;
&lt;p&gt;具体原因可以参考阿里巴巴『&lt;strong&gt;Java 开发手册&lt;/strong&gt;』&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081011418-1612290060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，如果 IDEA 的版本低于 2019.3.2，那就别想了，直接用下节提到的工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IDEA 2019.3.2&lt;/strong&gt; 新增了虚拟外键的功能，在 ER 图增加生成虚拟外键的功能。&lt;/p&gt;
&lt;p&gt;假设现有表结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE activity
(
    activity_id int          NOT NULL,
    visitor_id      int NOT NULL,
    PRIMARY KEY (activity_id)

);


CREATE TABLE visitor
(
    id          int NOT NULL,
    first_name int NOT NULL,
    PRIMARY KEY (id)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;系统生成 ER 图中将会生成虚拟外键关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081011767-1703358938.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过不要高兴太早，IDEA 是根据一定规则生成虚拟外键关系的。&lt;/p&gt;
&lt;p&gt;如果你的表中外键命名不符合规则，IDEA 是不会生成外键的。我们需要在 &lt;strong&gt;Setting | Editor | Code Completion&lt;/strong&gt; 设置规则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081011886-220960609.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说白了就是设置正则表达式，设置完成之后，可以点击 &lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081012018-1410152695.jpg&quot; alt=&quot;&quot;/&gt;这个按钮进行调试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081012159-1039730437.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面功能比较适合表结构比较规范的情况，但是真实场景可能比较复杂，外键命名也不是规范。为了生成这个外键关系，还要配置正则规则，学习成本过很大，也很难啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081012329-6556222.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过好在 IDEA 有另外一个功能，可以手动指定表之间的外键关系。&lt;/p&gt;
&lt;p&gt;首先我们需要打开一个 IDEA &lt;strong&gt;Database console&lt;/strong&gt; 窗口，在里面输入连表 sql，然后使用 &lt;em&gt;&lt;strong&gt;Alt+Enter&lt;/strong&gt;&lt;/em&gt; 快捷键选择 &lt;strong&gt;Store table relation&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081012437-926093349.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是 IDEA 会提醒你保存这个外键关系到 xml 文件中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081012568-38954992.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成 XML 文件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081012751-684746704.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还需要生成外键关系，直接在这个配置文件中增加即可。&lt;/p&gt;
&lt;h2 id=&quot;dbschema&quot;&gt;dbschema&lt;/h2&gt;
&lt;p&gt;IDEA Database 生成虚拟外键，这样看起来还是比较繁琐的，下面介绍一款软件『&lt;strong&gt;dbschema&lt;/strong&gt;』,可以图形化生成虚拟外键。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://dbschema.com/&quot;&gt;https://dbschema.com/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps:收费软件，免费 15 天&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这款软件专门简化数据库设计和管理，功能很强大，这里仅仅介绍其虚拟外键这个小功能，其他功能感兴趣同学可以自行研究一下。&lt;/p&gt;
&lt;p&gt;首先我们新建一个 Layout，导入指定表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081012891-798287539.jpg&quot; alt=&quot;image-20200427211102133&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成 ER 图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081013092-338794730.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择相应的表，右键菜单选择 &lt;strong&gt;Add Foreign Key&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081013227-85967896.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在新建窗口选择相应的表以及字段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081013380-1463761998.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里需要注意，我们是要生成虚拟的外键关系，所以一定要勾选下 &lt;strong&gt;Virtual&lt;/strong&gt;,不然会生成真实物理外键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后 ER 图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081013548-1062184621.jpg&quot; alt=&quot;image-20200427212309363&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以将这个 ER 图以及表结构导出到 PDF 中。在 Layout 选择 Export。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081013699-1320047786.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081013827-209117120.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后生成 PDF 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081013974-917847566.jpg&quot; alt=&quot;image-20200427212355699&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/help/idea/foreign-keys.html&quot;&gt;https://www.jetbrains.com/help/idea/foreign-keys.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.jetbrains.com/datagrip/2020/01/22/datagrip-2019-3-2-virtual-foreign-keys-and-more/&quot;&gt;https://blog.jetbrains.com/datagrip/2020/01/22/datagrip-2019-3-2-virtual-foreign-keys-and-more/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;最后（点个赞，不过分吧！）&quot;&gt;最后（点个赞，不过分吧！）&lt;/h2&gt;
&lt;p&gt;嘿嘿，本以为这周这么忙，可能会断更。幸好靠这个又水了一篇文章，哈哈哈！！！&lt;/p&gt;
&lt;p&gt;好了，溜啦溜啦，还有一堆 Bug 等着要改~&lt;/p&gt;
&lt;p&gt;我是楼下小黑哥，咱们下篇文章再见~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200430081014096-106455519.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 30 Apr 2020 00:10:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>忙，真忙 点赞再看，养成习惯，微信搜索『程序通事』,关注就完事了！ &amp;quot;点击查看更多精彩的文章&amp;quot; 这两个星期真是巨忙，年前有个项目因为各种莫名原因，一直拖到这个月才开始真正测试。然后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12806549.html</dc:identifier>
</item>
<item>
<title>如何优雅的维护 K8S Worker 节点 - 抄袭者将变孤儿-KAnts</title>
<link>http://www.cnblogs.com/ants/p/12804407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ants/p/12804407.html</guid>
<description>&lt;h2 id=&quot;正常维护工作节点的流程&quot;&gt;正常维护工作节点的流程&lt;/h2&gt;
&lt;p&gt;当我们要进行 K8S 节点维护时往往需要执行 &lt;code&gt;kubectl drain&lt;/code&gt;, 等待节点上的 Pod 被驱逐后再进行维护动作。&lt;br/&gt;命令行如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;kubectl drain NODE
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;待节点排空后再进行维护操作, 内核升级等。&lt;/p&gt;
&lt;h2 id=&quot;存在问题吗？&quot;&gt;存在问题吗？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;drain&lt;/code&gt; 命令有一个问题, 他不会考虑资源所定义的 UpdateStrategy, 而直接强制驱逐或删除 Pod, 这样就会导致 Deployment 或 StatefulSet 资源的 Pod 达不到所设置的策略数.&lt;/p&gt;
&lt;h3 id=&quot;思考一个案例&quot;&gt;思考一个案例&lt;/h3&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;有一个 Deployment 资源, 它使用了如下配置
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt; replicas: 2
 strategy:
     rollingUpdate:
     maxSurge: 1
     maxUnavailable: 0
 type: RollingUpdate
&lt;/code&gt;
&lt;/pre&gt;
副本数为 3, 采用了滚动更新, 并且先启动完成一个 Pod 后再进行旧 Pod 的删除(最大不可用为0,最小可用为2).&lt;/li&gt;
&lt;li&gt;当下集群有 2 个 worker 节点&lt;br/&gt;意味着, 其中一个节点被调度了 2 个 Pod, 其中一个节点被调度了 1 个 Pod.&lt;br/&gt;假设 node1 运行着 pod1 和 pod3, node2 运行着 pod2.&lt;/li&gt;
&lt;li&gt;这时候 drain node1, 会出现 Deployment 只有一个 Pod 可用&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;更糟糕的情况&quot;&gt;更糟糕的情况&lt;/h3&gt;
&lt;p&gt;Deployment 的 Pod 全部运行在需要维护的节点上, 这时候执行 &lt;code&gt;drain&lt;/code&gt; 那将是一个灾难, 这个 Deployment 在新的Pod启动之前它无法在对外提供服务了, 恢复的时间取决于新 Pod 的启动速度。&lt;/p&gt;

&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/majian159/kubectl-safe-drain&quot;&gt;https://github.com/majian159/kubectl-safe-drain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个 kubectl 插件, 用于更为安全的排空节点。&lt;br/&gt;对于 Deployment 和 StatefulSet 资源会根据其配置的更新策略先将Pod调度到其它可用节点。&lt;/p&gt;
&lt;h2 id=&quot;逻辑和原理&quot;&gt;逻辑和原理&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;先将需要排空的节点标记为不可调度 (kubectl cordon)&lt;/li&gt;
&lt;li&gt;在找到该节点上的 Deployment 和 StatefulSet 资源&lt;/li&gt;
&lt;li&gt;修改 Deployment 和 StatefulSet 的 PodTemplate, 让K8S根据对应的更新策略重新部署Pod, 这时候需要排空的节点不可被调度, 从而达到先将排空节点中的Pod安全重建到其它节点的逻辑。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;目前支持安全迁移的资源&quot;&gt;目前支持安全迁移的资源&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Deployment&lt;/li&gt;
&lt;li&gt;StatefulSet&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;效果&quot;&gt;效果&lt;/h2&gt;
&lt;h3 id=&quot;首先我们有一个-deployment-配置如下&quot;&gt;首先我们有一个 Deployment 配置如下&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;spec:
    replicas: 2
strategy:
    type: RollingUpdate
    rollingUpdate:
        maxSurge: 1
        maxUnavailable: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;操作前有两个可用 Pod&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_29_19_42_iaR3Cs%20.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_29_19_42_Nb8NZA%20.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;执行-safe-drain-后&quot;&gt;执行 &lt;code&gt;safe-drain&lt;/code&gt; 后&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_29_19_43_xc2Jhz%20.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看-deployment-变化过程&quot;&gt;查看 Deployment 变化过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_29_19_43_lmDtYv%20.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看-pod-变化过程&quot;&gt;查看 Pod 变化过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_29_19_43_Nd6lPE%20.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;流程简述&quot;&gt;流程简述&lt;/h3&gt;
&lt;p&gt;从 Deployment watch 的信息中可见最小 Ready 数没有小于 2, 从 Pod watch 的信息中可见 kind-worker2 上承载了 2 个准备就绪的 nginx Pod, 也就是说 nginx 从 kind-worker 安全的移动到了 kind-worker2 节点上。&lt;/p&gt;
&lt;h2 id=&quot;与-pdb-pod-disruption-budget-有什么区别&quot;&gt;与 PDB (Pod Disruption Budget) 有什么区别?&lt;/h2&gt;
&lt;p&gt;PDB 只会保障 Pod 不被驱逐, 而不会帮助它在其它可用节点上重建。&lt;br/&gt;使用了 PDB 后能防止服务不可用的尴尬情况，但它还是需要人工手动迁移 Pod。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理想的情况是搭配 PDB 使用, 防止严苛情况下服务不可用的问题。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;二进制文件&quot;&gt;二进制文件&lt;/h2&gt;
&lt;h3 id=&quot;linux&quot;&gt;Linux&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -sLo sdrain.tgz https://github.com/majian159/kubectl-safe-drain/releases/download/v0.0.1-preview1/kubectl-safe-drain_0.0.1-preview1_linux_amd64.tar.gz \
&amp;amp;&amp;amp; tar xf sdrain.tgz \
&amp;amp;&amp;amp; rm -f sdrain.tgz \
&amp;amp;&amp;amp; mv kubectl-safe-drain /usr/local/bin/kubectl-safe_drain
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;macos&quot;&gt;macOS&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -sLo sdrain.tgz https://github.com/majian159/kubectl-safe-drain/releases/download/v0.0.1-preview1/kubectl-safe-drain_0.0.1-preview1_darwin_amd64.tar.gz \
&amp;amp;&amp;amp; tar xf sdrain.tgz \
&amp;amp;&amp;amp; rm -f sdrain.tgz \
&amp;amp;&amp;amp; mv kubectl-safe-drain /usr/local/bin/kubectl-safe_drain
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;windows&quot;&gt;Windows&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/majian159/kubectl-safe-drain/releases/download/v0.0.1-preview1/kubectl-safe-drain_0.0.1-preview1_windows_amd64.tar.gz&quot;&gt;https://github.com/majian159/kubectl-safe-drain/releases/download/v0.0.1-preview1/kubectl-safe-drain_0.0.1-preview1_windows_amd64.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于-krew&quot;&gt;基于 Krew&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -O https://raw.githubusercontent.com/majian159/kubectl-safe-drain/master/krew.yaml \
&amp;amp;&amp;amp; kubectl krew install --manifest=krew.yaml \
&amp;amp;&amp;amp; rm -f krew.yaml
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;kubectl safe-drain NODE

# safe-drain并没有调用 drain命令, 而是利用了 SchedulingDisabled 机制
# 所以如有需要可以继续使用 drain 命令来确保节点被驱逐
kubectl drain NODE
&lt;/code&gt;
&lt;/pre&gt;

&lt;ol&gt;&lt;li&gt;考虑节点亲和力和节点选择器的情况&lt;/li&gt;
&lt;li&gt;输出更为友好的提示信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该项目部分代码源于 kubectl 项目。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Apr 2020 00:02:00 +0000</pubDate>
<dc:creator>抄袭者将变孤儿-KAnts</dc:creator>
<og:description>前言 正常维护工作节点的流程 当我们要进行 K8S 节点维护时往往需要执行 , 等待节点上的 Pod 被驱逐后再进行维护动作。 命令行如下: 待节点排空后再进行维护操作, 内核升级等。 存在问题吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ants/p/12804407.html</dc:identifier>
</item>
<item>
<title>咦，Java拆分个字符串都这么讲究 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12806523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12806523.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到 Java 拆分字符串，我猜你十有八九会撂下一句狠话，“这有什么难的，直接上 String 类的 &lt;code&gt;split()&lt;/code&gt; 方法不就拉到了！”假如你真的这么觉得，那可要注意了，事情远没这么简单。&lt;/p&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-split-01.gif&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来来来，搬个小板凳坐下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如现在有这样一串字符“沉默王二，一枚有趣的程序员”，需要按照中文的逗号“，”进行拆分，这意味着第一串字符为逗号前面的“沉默王二”，第二串字符为逗号后面的“一枚有趣的程序员”（这不废话）。另外，在拆分之前，要先进行检查，判断一下这串字符是否包含逗号，否则应该抛出异常。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String cmower = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二，一枚有趣的程序员&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (cmower.contains(&lt;span class=&quot;hljs-string&quot;&gt;&quot;，&quot;&lt;/span&gt;)) {&lt;br/&gt;String [] parts = cmower.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;，&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第一部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] +&lt;span class=&quot;hljs-string&quot;&gt;&quot; 第二部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;当前字符串没有包含逗号&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码看起来挺严谨的，对吧？程序输出的结果完全符合预期：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;第一部分：沉默王二 第二部分：一枚有趣的程序员
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是建立在字符串是确定的情况下，最重要的是分隔符是确定的。否则，麻烦就来了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大约有 12 种英文特殊符号，如果直接拿这些特殊符号替换上面代码中的分隔符（中文逗号），这段程序在运行的时候就会出现以下提到的错误。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;反斜杠 &lt;code&gt;\&lt;/code&gt;（ArrayIndexOutOfBoundsException）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;插入符号 &lt;code&gt;^&lt;/code&gt;（同上）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;美元符号 &lt;code&gt;$&lt;/code&gt;（同上）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;逗点 &lt;code&gt;.&lt;/code&gt;（同上）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;竖线 &lt;code&gt;|&lt;/code&gt;（正常，没有出错）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;问号 &lt;code&gt;?&lt;/code&gt;（PatternSyntaxException）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;星号 &lt;code&gt;*&lt;/code&gt;（同上）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;加号 &lt;code&gt;+&lt;/code&gt;（同上）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;左小括号或者右小括号 &lt;code&gt;()&lt;/code&gt;（同上）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;左方括号或者右方括号 &lt;code&gt;[]&lt;/code&gt;（同上）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;左大括号或者右大括号 &lt;code&gt;{}&lt;/code&gt;（同上）&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，可能有小伙伴会说，“这不是钻牛角尖嘛”，不不不，做技术就应该秉持严谨的态度，否则，老大会给你的绩效打低分的——奖金拿得少，可不是好滋味。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那遇到特殊符号该怎么办呢？上正则表达式呗。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那可能又有小伙伴说，“正则表达式那么多，我记不住啊！”别担心，我已经替你想好对策了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这个链接是 GitHub 上学习正则表达式的一个在线文档，非常详细。遇到正则表达式的时候，掏出这份手册就完事了。记不住那么多正则表达式没关系啊，活学活用呗。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://github.com/cdoco/learn-regex-zh&quot;&gt;https://github.com/cdoco/learn-regex-zh&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这份文档，还有一份：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://github.com/cdoco/common-regex&quot;&gt;https://github.com/cdoco/common-regex&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者收集了一些在平时项目开发中经常用到的正则表达式，可以直接拿来用，妙啊。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决了心病之后，我们来用英文逗点“.”来替换一下分隔符：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String cmower = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二.一枚有趣的程序员&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (cmower.contains(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.&quot;&lt;/span&gt;)) {&lt;br/&gt;String [] parts = cmower.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\.&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第一部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] +&lt;span class=&quot;hljs-string&quot;&gt;&quot; 第二部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用 &lt;code&gt;split()&lt;/code&gt; 方法的时候，就需要使用正则表达式 &lt;code&gt;\\.&lt;/code&gt; 来替代特殊字符英文逗点“.”了。为什么用两个反斜杠呢？因为它本身就是一个特殊字符，需要先转义。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以使用字符类 &lt;code&gt;[]&lt;/code&gt; 来包含英文逗点“.”，它也是一个正则表达式，用来匹配方括号中包含的任意字符。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;cmower.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;[.]&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外， 还可以使用 Pattern 类的 &lt;code&gt;quote()&lt;/code&gt; 方法来包裹英文逗点“.”，该方法会返回一个使用 &lt;code&gt;\Q\E&lt;/code&gt; 包裹的字符串。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-split-02.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，&lt;code&gt;String.split()&lt;/code&gt; 方法的使用示例如下所示：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String [] parts = cmower.split(Pattern.quote(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当通过调试模式进入 &lt;code&gt;String.split()&lt;/code&gt; 方法源码的话，会发现以下细节：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Pattern.compile(regex).split(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, limit);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;String 类的 &lt;code&gt;split()&lt;/code&gt; 方法调用了 Pattern 类的 &lt;code&gt;split()&lt;/code&gt; 方法。也就意味着，我们拆分字符串有了新的选择，可以不使用 String 类的 &lt;code&gt;split()&lt;/code&gt; 方法了。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestPatternSplit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Pattern twopart = Pattern.compile(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\.&quot;&lt;/span&gt;);&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String [] parts = twopart.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二.一枚有趣的程序员&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第一部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] +&lt;span class=&quot;hljs-string&quot;&gt;&quot; 第二部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还可以使用 Pattern 配合 Matcher 类进行字符串拆分，这样做的好处是可以对要拆分的字符串进行一些严格的限制，来看一段示例代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;7&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestPatternMatch&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Pattern twopart = Pattern.compile(&lt;span class=&quot;hljs-string&quot;&gt;&quot;(.+)\\.(.+)&quot;&lt;/span&gt;);&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;checkString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二.一枚有趣的程序员&quot;&lt;/span&gt;);&lt;br/&gt;checkString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二.&quot;&lt;/span&gt;);&lt;br/&gt;checkString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.一枚有趣的程序员&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;checkString&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String str)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Matcher m = twopart.matcher(str);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (m.matches()) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第一部分：&quot;&lt;/span&gt; + m.group(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) + &lt;span class=&quot;hljs-string&quot;&gt;&quot; 第二部分：&quot;&lt;/span&gt; + m.group(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;));&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;不匹配&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，正则表达式为 &lt;code&gt;(.+)\\.(.+)&lt;/code&gt;，意味着可以把字符串按照英文逗点拆分成一个字符组，英文小括号 &lt;code&gt;()&lt;/code&gt; 的作用就在于此（可以查看我之前提供的正则表达式手册）。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于模式是确定的，所以可以把 Pattern 表达式放在 &lt;code&gt;main()&lt;/code&gt; 方法外面，通过 static 的预编译功能提高程序的效率。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一下程序的输出结果：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;第一部分：沉默王二 第二部分：一枚有趣的程序员&lt;br/&gt;不匹配&lt;br/&gt;不匹配&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，使用 Matcher 来匹配一些简单的字符串时相对比较沉重一些，使用 String 类的 &lt;code&gt;split()&lt;/code&gt; 仍然是首选，因为该方法还有其他一些牛逼的功能。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说，你想把分隔符包裹在拆分后的字符串的第一部分，可以这样做：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String cmower = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二，一枚有趣的程序员&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (cmower.contains(&lt;span class=&quot;hljs-string&quot;&gt;&quot;，&quot;&lt;/span&gt;)) {&lt;br/&gt;String [] parts = cmower.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;(?&amp;lt;=，)&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第一部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] +&lt;span class=&quot;hljs-string&quot;&gt;&quot; 第二部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出的结果如下所示：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;第一部分：沉默王二， 第二部分：一枚有趣的程序员
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到分隔符“，”包裹在了第一部分，如果希望包裹在第二部分，可以这样做：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String [] parts = cmower.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;(?=，)&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有些小伙伴很好奇，&lt;code&gt;?&amp;lt;=&lt;/code&gt; 和 &lt;code&gt;?=&lt;/code&gt; 是什么东东啊？它其实是正则表达式中的断言模式。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-split-03.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;温馨提醒：如果对断言模式比较生疏的话，可以查看我之前提供的正则表达式手册。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，假如说字符串中包含了多个分隔符，而我们只需要 2 个的话，还可以这样做：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;String cmower = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二，一枚有趣的程序员，宠爱他&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (cmower.contains(&lt;span class=&quot;hljs-string&quot;&gt;&quot;，&quot;&lt;/span&gt;)) {&lt;br/&gt;String [] parts = cmower.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;，&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第一部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] +&lt;span class=&quot;hljs-string&quot;&gt;&quot; 第二部分：&quot;&lt;/span&gt; + parts[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;split()&lt;/code&gt; 方法可以传递 2 个参数，第一个为分隔符，第二个为拆分的字符串个数。查看该方法源码的话，你就可以看到以下内容：&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-split-04.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接 &lt;code&gt;substring()&lt;/code&gt; 到原字符串的末尾，也就是说，第二个分隔符处不再拆分。然后就 break 出循环了。来看一下程序输出的结果：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;第一部分：沉默王二 第二部分：一枚有趣的程序员，宠爱他
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-split-05.gif&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我亲爱的读者朋友，以上就是本文的全部内容了。是不是突然感觉拆分个字符串真的挺讲究的？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是沉默王二，一枚有趣的程序员。如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5.7831325301205&quot;&gt;
&lt;p&gt;回复【&lt;strong&gt;666&lt;/strong&gt;】更有我为你精心准备的 500G 高清教学视频（已分门别类）。本文 &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;GitHub&lt;/a&gt; 已经收录，有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;原创不易，莫要白票，请你为本文点赞个吧&lt;/strong&gt;，这将是我写作更多优质文章的最强动力。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Apr 2020 23:36:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>提到 Java 拆分字符串，我猜你十有八九会撂下一句狠话，“这有什么难的，直接上 String 类的 split() 方法不就拉到了！”假如你真的这么觉得，那可要注意了，事情远没这么简单。 来来来，搬</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12806523.html</dc:identifier>
</item>
<item>
<title>CSS躬行记（8）——裁剪和遮罩 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12534739.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12534739.html</guid>
<description>&lt;p&gt;　　裁剪（clipping）能让元素显示指定形状的区域，在布局时可起点缀的作用，丰富了视觉呈现。注意，裁剪本质上只是让元素的部分区域透明，由此可知，裁剪完后元素所占的空间仍旧会保留。裁剪最早是在CSS 2.1时代由clip属性引入，但该属性只能应用于绝对定位的元素，并且只能裁剪成矩形。CSS3提供了强大的clip-path属性，突破了clip属性的众多限制，接下来将围绕clip-path属性展开讲解。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）裁剪形状&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　clip-path属性可以使用四种裁剪函数：circle()、ellipse()、inset()和polygon()，它们的作用和浮动形状中的shape-outside属性中的形状函数相同。&lt;/p&gt;
&lt;p&gt;　　下面用一个例子来演示这四个函数的效果，将它们分别应用到四个div元素中，样式如下，得到的形状如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; url(./lake.png)&lt;/span&gt;;
}&lt;span&gt;
.circle &lt;/span&gt;{&lt;span&gt;
  clip-path&lt;/span&gt;:&lt;span&gt; circle(50%)&lt;/span&gt;;
}&lt;span&gt;
.ellipse &lt;/span&gt;{&lt;span&gt;
  clip-path&lt;/span&gt;:&lt;span&gt; ellipse(50% 30%)&lt;/span&gt;;
}&lt;span&gt;
.inset &lt;/span&gt;{&lt;span&gt;
  clip-path&lt;/span&gt;:&lt;span&gt; inset(20px 10px)&lt;/span&gt;;
}&lt;span&gt;
.polygon &lt;/span&gt;{&lt;span&gt;
  clip-path&lt;/span&gt;:&lt;span&gt; polygon(0 0, 100px 0, 160px 200px, 0 200px)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320203017179-552869448.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）裁剪盒子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　裁剪盒子可指定形状的边界，其中margin-box、border-box、padding-box和content-box的作用与shape-outside属性中的相同，并且这些关键字也能与裁剪函数组合使用，如下所示。在下图中，左侧是原图，右侧是使用了clip-path属性后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 160px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 160px&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;&lt;span&gt;
  clip-path&lt;/span&gt;:&lt;span&gt; content-box circle(50%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320203130552-1019352911.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　还有三个关键字view-box、fill-box和stroke-box适用于SVG元素，具体用途可在网上查到相关资料。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）裁剪路径&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　对于复杂的形状，可以采用SVG来创建裁剪路径，实现自定义。引用方式和滤镜中的一样，也是使用url()函数，但指向的是SVG文件中的clipPath元素，下面的SVG文件源自MDN网站。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;svg &lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2000/svg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;defs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;clipPath &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;cross&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rect &lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;=&quot;110&quot;&lt;/span&gt;&lt;span&gt; x&lt;/span&gt;&lt;span&gt;=&quot;137&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rect &lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; y&lt;/span&gt;&lt;span&gt;=&quot;110&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rect &lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;=&quot;137&quot;&lt;/span&gt;&lt;span&gt; y&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rect &lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; y&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;clipPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;defs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;svg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有两种方式引用SVG文件中的形状，第一种是外部引用，将SVG元素放在单独的文件中；第二种是行内引用，将SVG元素放在当前的HTML结构中。下面用两个CSS类来演示这两种引用方式，其中url()函数接收的参数的最大区别就是是否包含文件路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.url-cross &lt;/span&gt;{&lt;span&gt;
  clip-path&lt;/span&gt;:&lt;span&gt; url(./shapes.svg#cross)&lt;/span&gt;;
}&lt;span&gt;
.inline-cross &lt;/span&gt;{&lt;span&gt;
  clip-path&lt;/span&gt;:&lt;span&gt; url(#cross)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　两种方式的效果是相同的，都是将元素裁剪成四部分，如下图所示。注意，外部引用的浏览器支持度比较糟糕，目前只有Firefox支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320203304360-1886887781.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）蒙版&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　蒙版（masking）与裁剪类似，也是让元素以某种形状显示，但蒙版能根据透明度和灰度值计算裁剪边缘，并且有更多的蒙版属性可供选择，例如定位、尺寸、填充方式等。&lt;/p&gt;
&lt;p&gt;　　下面用一个例子来演示蒙版的用法，首先创建HTML结构，包含三个div元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;lake&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;star&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;lake star-mask&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后为三个div元素添加背景图，并给第三个元素定义蒙版，样式如下。注意，在Chrome浏览器中定义蒙版属性时，需要额外添加-webkit-前缀，例如将原来的mask-image属性改成-webkit-mask-image属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.lake &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; url(./lake.png)&lt;/span&gt;;
}&lt;span&gt;
.star &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; url(./star-shadow.png)&lt;/span&gt;;&lt;span&gt;
  background-position&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
  background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;
}&lt;span&gt;
.star-mask &lt;/span&gt;{&lt;span&gt;
  mask-image&lt;/span&gt;:&lt;span&gt; url(./star-shadow.png)&lt;/span&gt;;&lt;span&gt;
  mask-position&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
  mask-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在下图中，将第二张五角星作为蒙版，作用到第一张风景照中，第三张是发生遮罩后的效果图，可以看到五角星中不透明和半透明的区域会显示风景照中的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320203449638-824562223.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在.star-mask类中用到了mask-position，它的语法与background-position一样，下表列出了所有的蒙版属性和背景属性之间的对应关系。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;蒙版属性&lt;/td&gt;
&lt;td&gt;背景属性&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mask-size&lt;/td&gt;
&lt;td&gt;background-size&lt;/td&gt;
&lt;td&gt;调整蒙版的尺寸&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mask-repeat&lt;/td&gt;
&lt;td&gt;background-repeat&lt;/td&gt;
&lt;td&gt;调整蒙版的填充方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mask-position&lt;/td&gt;
&lt;td&gt;background-position&lt;/td&gt;
&lt;td&gt;调整蒙版的定位&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mask-origin&lt;/td&gt;
&lt;td&gt;background-origin&lt;/td&gt;
&lt;td&gt;调整蒙版的原点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mask-clip&lt;/td&gt;
&lt;td&gt;background-clip&lt;/td&gt;
&lt;td&gt;调整蒙版的裁剪区域&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　CSS还提供了一个简写属性mask，可将上述属性合并到该属性中。关于蒙版还有一点需要注意，那就是遮罩用的蒙版图像既可以是位图图像（png、jpg等），也可以是矢量图形（指向SVG中的mask元素）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）替换元素的填充和定位&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CSS3引入了两个新属性，用于遮罩替换元素。第一个是object-fit属性，用来控制替换元素的内容以何种方式填充当前所使用的元素盒子，它有5个关键字可供选择，如下所列，效果如下图所示。&lt;/p&gt;
&lt;p&gt;　　（1）fill：将元素盒子填充满，它是object-fit属性的默认值。&lt;/p&gt;
&lt;p&gt;　　（2）contain：保持宽高比缩放，直到能将整块内容填充进元素盒子为止。&lt;/p&gt;
&lt;p&gt;　　（3）none：保持原有尺寸填充。&lt;/p&gt;
&lt;p&gt;　　（4）cover：保持宽高比缩放，直到水平或垂直方向撑满元素盒子为止。&lt;/p&gt;
&lt;p&gt;　　（5）scale-down：作用与none或contain中的一个相同，取决于谁的尺寸更小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320203902937-2004036483.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第二个是object-position属性，用来控制替换元素的内容在元素盒子中的位置，其语法和background-position相同。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Apr 2020 23:17:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、 裁剪 裁剪（clipping）能让元素显示指定形状的区域，在布局时可起点缀的作用，丰富了视觉呈现。注意，裁剪本质上只是让元素的部分区域透明，由此可知，裁剪完后元素所占的空间仍旧会保留。裁剪最早是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12534739.html</dc:identifier>
</item>
<item>
<title>Elasticsearch系列---实现分布式锁 - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/12806508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/12806508.html</guid>
<description>&lt;h3 id=&quot;概要&quot;&gt;概要&lt;/h3&gt;
&lt;p&gt;Elasticsearch在文档更新时默认使用的是乐观锁方案，而Elasticsearch利用文档的一些create限制条件，也能达到悲观锁的效果，我们一起来看一看。&lt;/p&gt;
&lt;h3 id=&quot;乐观锁与悲观锁&quot;&gt;乐观锁与悲观锁&lt;/h3&gt;
&lt;h4 id=&quot;乐观锁&quot;&gt;乐观锁&lt;/h4&gt;
&lt;p&gt;ES默认实现乐观锁，所有的数据更新默认使用乐观锁机制。document更新时，必须要带上currenct version，更新时与document的version进行比较，如果相同进行更新操作，不相同表示已经被别的线程更新过了，此时更新失败，并且重新获取新的version再尝试更新。&lt;/p&gt;
&lt;h4 id=&quot;悲观锁&quot;&gt;悲观锁&lt;/h4&gt;
&lt;p&gt;我们举一个这样的例子：Elasticsearch存储文件系统的目录、文件名信息，有多个线程需要对/home/workspace/ReadMe.txt进行追加修改，而且是并发执行的，有先后顺序之分，跟之前的库存更新案例有点不一样，此时单纯使用乐观锁，可能会出现乱序的问题。&lt;/p&gt;
&lt;p&gt;这种场景就需要使用悲观锁控制，保证线程的执行顺序，有一个线程在修改，其他的线程只能挂起等待。悲观锁通过/index/lock/实现，只有一个线程能做修改操作，其他线程block掉。&lt;/p&gt;
&lt;p&gt;悲观锁有三种，分别对应三种粒度，由粗到细可为分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局锁：最粗的锁，直接锁整个索引&lt;/li&gt;
&lt;li&gt;document锁：指定id加锁，只锁一条数据，类似于数据库的行锁&lt;/li&gt;
&lt;li&gt;共享锁和排他锁：也叫读写锁，针对一条数据分读和写两种操作，一般共享锁允许多个线程对同一条数据进行加锁，排他锁只允许一个线程对数据加锁，并且排他锁和共享锁互斥。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;锁的基本操作步骤&quot;&gt;锁的基本操作步骤&lt;/h4&gt;
&lt;p&gt;我们使用锁的基本步骤都是一样的，无论是关系型数据库、Redis/Memcache/Zookeeper分布式锁，还是今天介绍的Elasticsearch实现的锁机制，都有如下三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上锁&lt;/li&gt;
&lt;li&gt;执行事务方法&lt;/li&gt;
&lt;li&gt;解锁&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;全局锁&quot;&gt;全局锁&lt;/h3&gt;
&lt;p&gt;假定有两个线程，线程1和线程2&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程1上锁命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /files/file/global/_create
{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;files表示索引名称。&lt;/li&gt;
&lt;li&gt;file为type，6.3.1一个索引只允许有一个type，选用file作用type名称。&lt;/li&gt;
&lt;li&gt;global：即document的id，固定写为global表示全局锁，或者使用专门的索引进行加锁操作。&lt;/li&gt;
&lt;li&gt;_create: 强制必须是创建，如果已经存在，那么创建失败，报错。&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;线程1执行事务方法：更新文件名&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;POST /files/file/global/_update
{
  &quot;doc&quot;: {
    &quot;name&quot;:&quot;ReadMe.txt&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;线程2尝试加锁，失败，此时程序进行重试阶段，直到线程1释放锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;# 请求：
PUT /files/file/global/_create
{}

# 响应：
{
  &quot;error&quot;: {
    &quot;root_cause&quot;: [
      {
        &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,
        &quot;reason&quot;: &quot;[file][global]: version conflict, document already exists (current version [1])&quot;,
        &quot;index_uuid&quot;: &quot;_6E1d7BLQmy9-7gJptVp7A&quot;,
        &quot;shard&quot;: &quot;2&quot;,
        &quot;index&quot;: &quot;files&quot;
      }
    ],
    &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,
    &quot;reason&quot;: &quot;[file][global]: version conflict, document already exists (current version [1])&quot;,
    &quot;index_uuid&quot;: &quot;_6E1d7BLQmy9-7gJptVp7A&quot;,
    &quot;shard&quot;: &quot;2&quot;,
    &quot;index&quot;: &quot;files&quot;
  },
  &quot;status&quot;: 409
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;线程1释放锁&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;DELETE files/file/global&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;线程2加锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /files/file/global/_create
{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;响应&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;_index&quot;: &quot;files&quot;,
  &quot;_type&quot;: &quot;file&quot;,
  &quot;_id&quot;: &quot;global&quot;,
  &quot;_version&quot;: 3,
  &quot;result&quot;: &quot;created&quot;,
  &quot;_shards&quot;: {
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  },
  &quot;_seq_no&quot;: 2,
  &quot;_primary_term&quot;: 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;加锁成功，然后执行事务方法。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;优缺点&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;全局锁本质上是所有线程都用_create语法来创建id为global的文档，利用Elasticsearch对_create语法的校验来实现锁的目的。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;优点：操作简单，容易使用，成本低。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;缺点：直接锁住整个索引，除了加锁的那个线程，其他所有对此索引的线程都block住了，并发量较低。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;适用场景：读多写少的数据，并且加解锁的时间非常短，类似于数据库的表锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意事项：加锁解锁的控制必须严格在程序里定义，因为单纯基于doc的锁控制，如果id固定使用global，在有锁的情况，任何线程执行delete操作都是可以成功的，因为大家都知道id。&lt;/p&gt;
&lt;h3 id=&quot;document-level级别的锁&quot;&gt;document level级别的锁&lt;/h3&gt;
&lt;p&gt;document level级别的锁是更细粒度的锁，以文档为单位进行锁控制。&lt;/p&gt;
&lt;p&gt;我们新建一个索引专门用于加锁操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /files-lock/_mapping/lock
{
  &quot;properties&quot;: {
    
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先创建一个script脚本，ES6.0以后默认使用painless脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;POST _scripts/document-lock
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;if ( ctx._source.process_id != params.process_id ) { Debug.explain('already locked by other thread'); }  ctx.op = 'noop';&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Debug.explain表示抛出一个异常，内容为already locked by other thread。&lt;br/&gt;ctx.op = 'noop'表示不执行更新。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程1增加行锁，此时传入的process_id为181ab3ee-28cc-4339-ba35-69802e06fe42&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;POST /files-lock/lock/1/_update
{
  &quot;upsert&quot;: { &quot;process_id&quot;: &quot;181ab3ee-28cc-4339-ba35-69802e06fe42&quot; },
  &quot;script&quot;: {
    &quot;id&quot;: &quot;document-lock&quot;, 
    &quot;params&quot;: {
      &quot;process_id&quot;: &quot;181ab3ee-28cc-4339-ba35-69802e06fe42&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;响应结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;_index&quot;: &quot;files-lock&quot;,
  &quot;_type&quot;: &quot;lock&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 1,
  &quot;result&quot;: &quot;created&quot;,
  &quot;_shards&quot;: {
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  },
  &quot;_seq_no&quot;: 0,
  &quot;_primary_term&quot;: 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;线程1、线程2查询锁信息&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;_index&quot;: &quot;files-lock&quot;,
  &quot;_type&quot;: &quot;lock&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 1,
  &quot;found&quot;: true,
  &quot;_source&quot;: {
    &quot;process_id&quot;: &quot;181ab3ee-28cc-4339-ba35-69802e06fe42&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;线程2传入的process_id为181ab3ee-28cc-4339-ba35-69802e06fe42，尝试加锁，失败，此时应该启动重试机制&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;POST /files-lock/lock/1/_update
{
  &quot;upsert&quot;: { &quot;process_id&quot;: &quot;a6d13529-86c0-4422-b95a-aa0a453625d5&quot; },
  &quot;script&quot;: {
    &quot;id&quot;: &quot;document-lock&quot;, 
    &quot;params&quot;: {
      &quot;process_id&quot;: &quot;a6d13529-86c0-4422-b95a-aa0a453625d5&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提示该文档已经被别的线程（线程1）锁住了，你不能更新了，响应报文如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;error&quot;: {
    &quot;root_cause&quot;: [
      {
        &quot;type&quot;: &quot;remote_transport_exception&quot;,
        &quot;reason&quot;: &quot;[node-1][192.168.17.137:9300][indices:data/write/update[s]]&quot;
      }
    ],
    &quot;type&quot;: &quot;illegal_argument_exception&quot;,
    &quot;reason&quot;: &quot;failed to execute script&quot;,
    &quot;caused_by&quot;: {
      &quot;type&quot;: &quot;script_exception&quot;,
      &quot;reason&quot;: &quot;runtime error&quot;,
      &quot;painless_class&quot;: &quot;java.lang.String&quot;,
      &quot;to_string&quot;: &quot;already locked by other thread&quot;,
      &quot;java_class&quot;: &quot;java.lang.String&quot;,
      &quot;script_stack&quot;: [
        &quot;Debug.explain('already locked by other thread'); }  &quot;,
        &quot;              ^---- HERE&quot;
      ],
      &quot;script&quot;: &quot;judge-lock&quot;,
      &quot;lang&quot;: &quot;painless&quot;,
      &quot;caused_by&quot;: {
        &quot;type&quot;: &quot;painless_explain_error&quot;,
        &quot;reason&quot;: null
      }
    }
  },
  &quot;status&quot;: 400
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;线程1执行事务方法&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;POST /files/file/1/_update
{
  &quot;doc&quot;: {
    &quot;name&quot;:&quot;README1.txt&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;线程1的事务方法执行完成，并通过删除id为1的文档，相当于释放锁&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;DELETE /files-lock/lock/1&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;线程2在线程1执行事务的期间，一直在模拟挂起，重试的操作，直到线程1完成释放锁，然后线程2加锁成功&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;POST /files-lock/lock/1/_update
{
  &quot;upsert&quot;: { &quot;process_id&quot;: &quot;a6d13529-86c0-4422-b95a-aa0a453625d5&quot; },
  &quot;script&quot;: {
    &quot;id&quot;: &quot;document-lock&quot;, 
    &quot;params&quot;: {
      &quot;process_id&quot;: &quot;a6d13529-86c0-4422-b95a-aa0a453625d5&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;_index&quot;: &quot;files-lock&quot;,
  &quot;_type&quot;: &quot;lock&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 3,
  &quot;found&quot;: true,
  &quot;_source&quot;: {
    &quot;process_id&quot;: &quot;a6d13529-86c0-4422-b95a-aa0a453625d5&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时锁的process_id变成线程2传入的&quot;a6d13529-86c0-4422-b95a-aa0a453625d5&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;_index&quot;: &quot;files-lock&quot;,
  &quot;_type&quot;: &quot;lock&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 3,
  &quot;found&quot;: true,
  &quot;_source&quot;: {
    &quot;process_id&quot;: &quot;a6d13529-86c0-4422-b95a-aa0a453625d5&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样基于ES的行锁操作控制过程就完成了。&lt;/p&gt;
&lt;h4 id=&quot;脚本解释&quot;&gt;脚本解释&lt;/h4&gt;
&lt;p&gt;update+upsert操作，如果该记录没加锁（此时document为空），执行upsert操作，设置process_id，如果已加锁，执行script&lt;br/&gt;script内的逻辑是：判断传入参数与当前doc的process_id，如果不相等，说明有别的线程尝试对有锁的doc进行加锁操作，Debug.explain表示抛出一个异常。&lt;/p&gt;
&lt;p&gt;process_id可以由Java应用系统里生成，如UUID。&lt;/p&gt;
&lt;p&gt;如果两个process_id相同，说明当前执行的线程与加锁的线程是同一个，ctx.op = 'noop'表示什么都不做，返回成功的响应，Java客户端拿到成功响应的报文，就可以继续下一步的操作，一般这里的下一步就是执行事务方法。&lt;/p&gt;
&lt;h4 id=&quot;点评&quot;&gt;点评&lt;/h4&gt;
&lt;p&gt;文档级别的锁颗粒度小，并发性高，吞吐量大，类似于数据库的行锁。&lt;/p&gt;
&lt;h3 id=&quot;共享锁与排他锁&quot;&gt;共享锁与排他锁&lt;/h3&gt;
&lt;h4 id=&quot;概念&quot;&gt;概念&lt;/h4&gt;
&lt;p&gt;共享锁：允许多个线程获取同一条数据的共享锁进行读操作&lt;br/&gt;排他锁：同一条数据只能有一个线程获取排他锁，然后进行增删改操作&lt;/p&gt;
&lt;p&gt;互斥性：共享锁与排他锁是互斥的，如果这条数据有共享锁存在，那么排他锁无法加上，必须得共享锁释放完了，排他锁才能加上。&lt;br/&gt;反之也成立，如果这条数据当前被排他锁锁信，那么其他的排他锁不能加，共享锁也加不上。必须等这个排他锁释放完了，其他锁才加得上。&lt;br/&gt;有人在改数据，就不允许别人来改，也不让别人来读。&lt;/p&gt;
&lt;p&gt;读写锁的分离&lt;br/&gt;如果只是读数据，每个线程都可以加一把共享锁，此时该数据的共享锁数量一直递增，如果这时有写数据的请求（写请求是排他锁），由于互斥性，必须等共享锁全部释放完，写锁才加得上。&lt;br/&gt;有人在读数据，就不允许别人来改。&lt;/p&gt;
&lt;h4 id=&quot;案例实验&quot;&gt;案例实验&lt;/h4&gt;
&lt;p&gt;我们先创建一个共享锁的脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;# 读操作加锁脚本
POST _scripts/rw-lock
{
    &quot;script&quot;: {
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;source&quot;: &quot;if (ctx._source.lock_type == 'exclusive') { Debug.explain('one thread is writing data, the lock is exclusive now'); } ctx._source.lock_count++&quot;
    }
}

# 读操作完毕释放锁脚本
POST _scripts/rw-unlock
{
    &quot;script&quot;: {
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;source&quot;: &quot;if ( --ctx._source.lock_count == 0) { ctx.op = 'delete' }&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;每次有一个线程读数据时，执行一次加锁操作&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;POST /files-lock/lock/1/_update
{
  &quot;upsert&quot;: { 
    &quot;lock_type&quot;:  &quot;shared&quot;,
    &quot;lock_count&quot;: 1
  },
  &quot;script&quot;: {
    &quot;id&quot;: &quot;rw-lock&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在多个页面上尝试，可以看到lock_count在逐一递增，模拟多个线程同时读一个文档的操作。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在有线程读文档，还未释放的情况下，尝试对该文档加一个排他锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /files-lock/lock/1/_create
{ &quot;lock_type&quot;: &quot;exclusive&quot; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果肯定会报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;error&quot;: {
    &quot;root_cause&quot;: [
      {
        &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,
        &quot;reason&quot;: &quot;[lock][1]: version conflict, document already exists (current version [8])&quot;,
        &quot;index_uuid&quot;: &quot;XD7LFToWSKe_6f1EvLNoFw&quot;,
        &quot;shard&quot;: &quot;3&quot;,
        &quot;index&quot;: &quot;files-lock&quot;
      }
    ],
    &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,
    &quot;reason&quot;: &quot;[lock][1]: version conflict, document already exists (current version [8])&quot;,
    &quot;index_uuid&quot;: &quot;XD7LFToWSKe_6f1EvLNoFw&quot;,
    &quot;shard&quot;: &quot;3&quot;,
    &quot;index&quot;: &quot;files-lock&quot;
  },
  &quot;status&quot;: 409
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;线程读数据完成后，对共享锁进行释放，执行释放锁的脚本&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;POST /files-lock/lock/1/_update
{
  &quot;script&quot;: {
    &quot;id&quot;: &quot;rw-unlock&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;释放1次lock_count减1，减到0时，说明所有的共享锁已经释放完毕，就把这个doc删除掉&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;所有共享锁释放完毕，尝试加排他锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /files-lock/lock/1/_create
{ &quot;lock_type&quot;: &quot;exclusive&quot; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时能够加锁成功，响应报文：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;_index&quot;: &quot;files-lock&quot;,
  &quot;_type&quot;: &quot;lock&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 1,
  &quot;found&quot;: true,
  &quot;_source&quot;: {
    &quot;lock_type&quot;: &quot;exclusive&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;有排他锁的情况，尝试加一个共享锁，失败信息如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;error&quot;: {
    &quot;root_cause&quot;: [
      {
        &quot;type&quot;: &quot;remote_transport_exception&quot;,
        &quot;reason&quot;: &quot;[node-1][192.168.17.137:9300][indices:data/write/update[s]]&quot;
      }
    ],
    &quot;type&quot;: &quot;illegal_argument_exception&quot;,
    &quot;reason&quot;: &quot;failed to execute script&quot;,
    &quot;caused_by&quot;: {
      &quot;type&quot;: &quot;script_exception&quot;,
      &quot;reason&quot;: &quot;runtime error&quot;,
      &quot;painless_class&quot;: &quot;java.lang.String&quot;,
      &quot;to_string&quot;: &quot;one thread is writing data, the lock is exclusive now&quot;,
      &quot;java_class&quot;: &quot;java.lang.String&quot;,
      &quot;script_stack&quot;: [
        &quot;Debug.explain('one thread is writing data, the lock is exclusive now'); } &quot;,
        &quot;              ^---- HERE&quot;
      ],
      &quot;script&quot;: &quot;rw-lock&quot;,
      &quot;lang&quot;: &quot;painless&quot;,
      &quot;caused_by&quot;: {
        &quot;type&quot;: &quot;painless_explain_error&quot;,
        &quot;reason&quot;: null
      }
    }
  },
  &quot;status&quot;: 400
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;排他锁事务执行完成时，删除文档即可对锁进行释放&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;DELETE /files-lock/lock/1&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;脚本解释-2&quot;&gt;脚本解释&lt;/h4&gt;
&lt;p&gt;读锁的加锁脚本和释放锁脚本，成对出现，用来统计线程的数量。&lt;/p&gt;
&lt;p&gt;写锁利用&lt;code&gt;_create&lt;/code&gt;语法来实现，如果有线程对某一文档有读取操作，那么对这个文档执行_create操作肯定报错。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;利用Elasticsearch一些语法的特性，加上painless脚本的配合，也能完整的复现全局锁、行锁、读写锁的特性，实现的思路还是挺有意思的，跟使用redis、zookeeper实现分布式锁有异曲同工之处，只是生产案例上用redis实现分布式锁是比较成功的实践，Elasticsearch的对这种分布式锁的实现方式可能不是最佳实践，但也可以了解一下。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;可以扫左边二维码添加好友，邀请你加入Java架构社区微信群共同探讨技术&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1834889/202003/1834889-20200303074927076-1724862603.jpg&quot; alt=&quot;Java架构社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Apr 2020 23:01:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>概要 Elasticsearch在文档更新时默认使用的是乐观锁方案，而Elasticsearch利用文档的一些create限制条件，也能达到悲观锁的效果，我们一起来看一看。 乐观锁与悲观锁 乐观锁 E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/12806508.html</dc:identifier>
</item>
<item>
<title>C++统一初始化语法（列表初始化） - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12806284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12806284.html</guid>
<description>&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;要是世上不曾存在C++14和C++17该有多好！&lt;code&gt;constexpr&lt;/code&gt;是好东西，但是让编译器开发者痛不欲生；新标准库的确好用，但改语法细节未必是明智之举，尤其是3年一次的频繁改动。C++带了太多历史包袱，我们都是为之买账的一员。&lt;/p&gt;
&lt;p&gt;我没那么多精力考虑C++14/17的问题，所以本文基于C++11标准。&lt;/p&gt;
&lt;p&gt;知其所以然，是学习C++越发复杂的语法的最佳方式。因此，我们从列表初始化的动机讲起。&lt;/p&gt;

&lt;h3 id=&quot;动机&quot;&gt;动机&lt;/h3&gt;
&lt;p&gt;早在2005年，Bjarne Stroustrup就提出要统一C++中的初始化语法。这是因为在C++11以前，初始化存在一系列问题，包括：&lt;/p&gt;
&lt;p&gt;虽然每一个都有办法解决，但加在一起将会变得非常复杂，对编译器和开发者都是负担。换句话说，唯一的需求就是一种&lt;strong&gt;统一的初始化语法&lt;/strong&gt;，其适用范围能涵盖先前的各种问题。&lt;/p&gt;
&lt;p&gt;于是，&lt;strong&gt;列表初始化&lt;/strong&gt;诞生了。&lt;/p&gt;

&lt;h3 id=&quot;语法&quot;&gt;语法&lt;/h3&gt;
&lt;p&gt;正因为列表初始化是为解决初始化问题而生，列表初始化的适用范围是&lt;strong&gt;任何初始化&lt;/strong&gt;。你能想到的都写写看，写对就是赚到。&lt;/p&gt;
&lt;p&gt;当然，全凭感觉是行不通的，还是得讲点道理。列表初始化分为两类：直接初始化与拷贝初始化。&lt;/p&gt;
&lt;p&gt;在直接初始化中，无论构造函数是否&lt;code&gt;explicit&lt;/code&gt;，都有可能被调用：&lt;/p&gt;
&lt;ol readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;T object { arg1, arg2, ... };&lt;/code&gt;，用&lt;code&gt;arg1, arg2, ...&lt;/code&gt;构造&lt;code&gt;T&lt;/code&gt;类型的对象&lt;code&gt;object&lt;/code&gt;——参数可以是一个值，也可以是一个初始化列表，下同；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;Class { T member { arg1, arg2, ... }; };&lt;/code&gt;，构造&lt;code&gt;member&lt;/code&gt;成员对象——花括号的优势在这里体现出来，因为如果是圆括号的话&lt;code&gt;member&lt;/code&gt;会被看作一个函数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;T { arg1, arg2, ... }&lt;/code&gt;，构造临时对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;new T { arg1, arg2, ... }&lt;/code&gt;，构造heap上的对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;Class::Class() : member{arg1, arg2, ...} {...&lt;/code&gt;，成员初始化列表——除了2以外，其余都与用&lt;code&gt;()&lt;/code&gt;初始化没有区别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在拷贝初始化中，无论构造函数是否&lt;code&gt;explicit&lt;/code&gt;都会被考虑，但是如果重载决议为一个&lt;strong&gt;&lt;code&gt;explicit&lt;/code&gt;函数&lt;/strong&gt;，则此调用错误：&lt;/p&gt;
&lt;ol readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;T object = {arg1, arg2, ...};&lt;/code&gt;，与直接初始化中的&lt;code&gt;1&lt;/code&gt;类似，除了&lt;code&gt;explicit&lt;/code&gt;以外都相同，&lt;code&gt;operator=&lt;/code&gt;不会被调用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;object = { arg1, arg2, ... }&lt;/code&gt;，赋值语句，调用&lt;code&gt;operator=&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;Class { T member = { arg1, arg2, ... }; };&lt;/code&gt;，与直接初始化中的&lt;code&gt;2&lt;/code&gt;类似，&lt;code&gt;explicit&lt;/code&gt;同理；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;function( { arg1, arg2, ... } )&lt;/code&gt;，构造函数参数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;return { arg1, arg2, ... } ;&lt;/code&gt;，构造返回值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;object[ { arg1, arg2, ... } ]&lt;/code&gt;，构造&lt;code&gt;operator[]&lt;/code&gt;的参数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;U( { arg1, arg2, ... } )&lt;/code&gt;，构造&lt;code&gt;U&lt;/code&gt;构造函数的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;4~7可以概括为，在该有一个对象的地方，可以用一个列表来构造它。这句话不是很严谨，因为除了&lt;code&gt;operator()&lt;/code&gt;和&lt;code&gt;operator[]&lt;/code&gt;以外，其他运算符的参数都不能用列表初始化。&lt;/p&gt;
&lt;p&gt;还有一个要注意的地方，是列表初始化&lt;strong&gt;不允许窄化转换&lt;/strong&gt;（narrowing conversion），即可能丢失信息的转换，如&lt;code&gt;float&lt;/code&gt;转换为&lt;code&gt;int&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;utility&amp;gt;

struct Test
{
    Test(int, int)
    {
        std::cout &amp;lt;&amp;lt; &quot;Test(int, int)&quot; &amp;lt;&amp;lt; std::endl;
    }
    explicit Test(int, int, int)
    {
        std::cout &amp;lt;&amp;lt; &quot;explicit Test(int, int, int)&quot; &amp;lt;&amp;lt; std::endl;
    }
    void operator[](std::pair&amp;lt;int, int&amp;gt;)
    {
        std::cout &amp;lt;&amp;lt; &quot;void operator[](std::pair&amp;lt;int, int&amp;gt;)&quot; &amp;lt;&amp;lt; std::endl;
    }
    void operator()(std::pair&amp;lt;int, int&amp;gt;)
    {
        std::cout &amp;lt;&amp;lt; &quot;void operator()(std::pair&amp;lt;int, int&amp;gt;)&quot; &amp;lt;&amp;lt; std::endl;
    }
};

Test test()
{
    return { 1, 2 };
}

int main()
{
    Test t{ 1, 2 };
    Test t1 = { 1, 2 };
    Test t2 = { 1, 2, 3 }; // error
    t[{ 1, 2 }];
    t({ 1, 2 });
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;initializer_list&quot;&gt;initializer_list&lt;/h3&gt;
&lt;p&gt;列表不是表达式，更&lt;strong&gt;不属于任何类型&lt;/strong&gt;，所以&lt;code&gt;decltype({1, 2})&lt;/code&gt;是非法的，这还适用于模板参数推导。但是在以下几种情况中，列表可以转换成&lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt;实例：&lt;/p&gt;
&lt;ol readability=&quot;0.96657381615599&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;直接初始化中，对应构造函数参数类型为&lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;拷贝初始化中，对应参数类型为&lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.94202898550725&quot;&gt;
&lt;p&gt;绑定到&lt;code&gt;auto&lt;/code&gt;上（列表元素类型必须严格一致），包括范围&lt;code&gt;for&lt;/code&gt;（range for）循环——当绑定&lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;时，变量的实际类型为&lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;，这是&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/12733924.html&quot; target=&quot;_blank&quot;&gt;转发引用&lt;/a&gt;的特例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;std::initializer_list&lt;/code&gt;是为列表初始化提供的特殊的工具，是一个轻量级的数组代理（proxy），其元素类型为&lt;code&gt;const T&lt;/code&gt;。虽然你能在&lt;code&gt;&amp;lt;initializer_list&amp;gt;&lt;/code&gt;中看到&lt;code&gt;std::initializer_list&lt;/code&gt;类模板的实现，但它实际上是与编译器内部绑定的，你无法用一个自己写的相似的类替换它（除非改编译器）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::initializer_list&lt;/code&gt;有构造函数、&lt;code&gt;size&lt;/code&gt;、&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;函数，用法与其他STL顺序容器类似。迭代器解引用得到&lt;code&gt;const T&amp;amp;&lt;/code&gt;类型，元素是不能修改的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::initializer_list&lt;/code&gt;带来的最明显的进步就是STL容器可以用列表来初始化，无需再写那么多&lt;code&gt;push_back&lt;/code&gt;了。&lt;/p&gt;

&lt;h3 id=&quot;重载决议&quot;&gt;重载决议&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;struct Test
{
    Test(int, int)
    {
        std::cout &amp;lt;&amp;lt; &quot;Test(int, int)&quot; &amp;lt;&amp;lt; std::endl;
    }
    Test(std::initializer_list&amp;lt;int&amp;gt;)
    {
        std::cout &amp;lt;&amp;lt; &quot;Test(std::initializer_list&amp;lt;int&amp;gt;)&quot; &amp;lt;&amp;lt; std::endl;
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我写&lt;code&gt;Test{1, 2}&lt;/code&gt;，哪个构造函数会被调用呢？回答这个问题，需要对与列表相关的重载决议有所了解。&lt;/p&gt;
&lt;p&gt;对于涉及到构造函数的列表初始化（不涉及到的包括聚合初始化等），各构造函数分两个阶段考虑：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果有构造函数第一个参数为&lt;code&gt;std::initializer_list&lt;/code&gt;，没有其他参数或其他参数都有默认值，则匹配该构造函数（这里似乎允许窄化转换，我测试起来也是如此）——&lt;strong&gt;&lt;code&gt;std::initializer_list&lt;/code&gt;优先级高&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;否则，所有构造函数参与重载决议，除了窄化转换不允许，以及拷贝初始化与&lt;code&gt;explicit&lt;/code&gt;的冲突依然有效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以上面那段程序中&lt;code&gt;Test{1, 2}&lt;/code&gt;会匹配第二个构造函数。&lt;/p&gt;
&lt;p&gt;如果有多个&lt;code&gt;std::initializer_list&lt;/code&gt;重载呢？众所周知，重载决议中参数转换有完美、提升、转换三个等级，&lt;code&gt;std::initializer_list&lt;/code&gt;参数的转换等级定义为所有元素中最差的（不允许窄化转换），然后找出等级最高的调用，如果有多个则为二义调用。&lt;/p&gt;
&lt;p&gt;如果没有&lt;code&gt;std::initializer_list&lt;/code&gt;重载呢？由于从列表到参数本身就是转换，属于最差的等级，如果有多个函数可以通过参数转换后匹配，则该调用就是二义调用；只有当只有一个函数可行时才合法。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;列表初始化是一种万能的初始化语法，适用范围广导致其规则比较复杂，我们应当结合其动机来理解标准规定的行为。&lt;/p&gt;
&lt;p&gt;列表初始化包括直接初始化与拷贝初始化，后者涵盖了参数与返回值等情形。当我们不想要隐式拷贝初始化时，要用&lt;code&gt;explicit&lt;/code&gt;关键字来拒绝。&lt;/p&gt;
&lt;p&gt;列表不属于任何类型，但一些情况下可以转换成&lt;code&gt;std::initializer_list&lt;/code&gt;。在重载决议中，&lt;code&gt;std::initializer_list&lt;/code&gt;有更高的优先级。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Apr 2020 17:43:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>引言 要是世上不曾存在C++14和C++17该有多好！ 是好东西，但是让编译器开发者痛不欲生；新标准库的确好用，但改语法细节未必是明智之举，尤其是3年一次的频繁改动。C++带了太多历史包袱，我们都是为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12806284.html</dc:identifier>
</item>
</channel>
</rss>