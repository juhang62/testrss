<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux Capabilities 简介 - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/11417781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/11417781.html</guid>
<description>&lt;p&gt;&lt;span&gt;为了执行权限检查，Linux 区分两类进程：特权进程(其有效用户标识为 0，也就是超级用户 root)和非特权进程(其有效用户标识为非零)。 特权进程绕过所有内核权限检查，而非特权进程则根据进程凭证(通常为有效 UID，有效 GID 和补充组列表)进行完全权限检查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以常用的 passwd 命令为例，修改用户密码需要具有 root 权限，而普通用户是没有这个权限的。但是实际上普通用户又可以修改自己的密码，这是怎么回事？在 Linux 的权限控制机制中，有一类比较特殊的权限设置，比如 SUID(Set User ID on execution)，不了解 SUID 的同学请参考《&lt;a href=&quot;https://www.cnblogs.com/sparkdev/p/9651622.html&quot; target=&quot;_blank&quot;&gt;Linux 特殊权限 SUID,SGID,SBIT&lt;/a&gt;》。因为程序文件 /bin/passwd 被设置了 SUID 标识，所以普通用户在执行 passwd 命令时，进程是以 passwd 的所有者，也就是 root 用户的身份运行，从而修改密码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SUID 虽然可以解决问题，却带来了安全隐患。当运行设置了 SUID 的命令时，通常只是需要很小一部分的特权，但是 SUID 给了它 root 具有的全部权限。因此一旦 被设置了 SUID 的命令出现漏洞，就很容易被利用。也就是说 SUID 机制在增大了系统的安全攻击面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Linux 引入了 capabilities 机制对 root 权限进行细粒度的控制，实现按需授权，从而减小系统的安全攻击面。本文将介绍 capabilites 机制的基本概念和用法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：本文的演示环境为 Ubuntu 18.04。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有 capability &lt;strong&gt;CAP_KILL&lt;/strong&gt;；如果设置系统时间，就得具有 capability &lt;strong&gt;CAP_SYS_TIME&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是从 &lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot; target=&quot;_blank&quot;&gt;capabilities man page&lt;/a&gt; 中摘取的 capabilites 列表：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;32.672649976382&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;capability 名称&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_AUDIT_CONTROL&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_AUDIT_READ&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许通过 multicast netlink 套接字读取审计日志&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_AUDIT_WRITE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;将记录写入内核审计日志&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_BLOCK_SUSPEND&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;使用可以阻止系统挂起的特性&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_CHOWN&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;修改文件所有者的权限&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_DAC_OVERRIDE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;忽略文件的 DAC 访问限制&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_DAC_READ_SEARCH&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;忽略文件读及目录搜索的 DAC 访问限制&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_FOWNER&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;忽略文件属主 ID 必须和进程用户 ID 相匹配的限制&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_FSETID&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许设置文件的 setuid 位&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_IPC_LOCK&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许锁定共享内存片段&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_IPC_OWNER&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;忽略 IPC 所有权检查&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_KILL&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许对不属于自己的进程发送信号&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_LEASE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许修改文件锁的 FL_LEASE 标志&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_LINUX_IMMUTABLE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许修改文件的 IMMUTABLE 和 APPEND 属性标志&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_MAC_ADMIN&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许 MAC 配置或状态更改&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_MAC_OVERRIDE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;覆盖 MAC(Mandatory Access Control)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_MKNOD&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许使用 mknod() 系统调用&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_NET_ADMIN&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许执行网络管理任务&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_NET_BIND_SERVICE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许绑定到小于 1024 的端口&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_NET_BROADCAST&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许网络广播和多播访问&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_NET_RAW&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许使用原始套接字&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SETGID&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许改变进程的 GID&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SETFCAP&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许为文件设置任意的 capabilities&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;0.95&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SETPCAP&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;参考 &lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot; target=&quot;_blank&quot;&gt;capabilities man page&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SETUID&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许改变进程的 UID&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_ADMIN&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_BOOT&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许重新启动系统&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_CHROOT&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许使用 chroot() 系统调用&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_MODULE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许插入和删除内核模块&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_NICE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许提升优先级及设置其他进程的优先级&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_PACCT&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许执行进程的 BSD 式审计&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_PTRACE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许跟踪任何进程&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_RAWIO&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_RESOURCE&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;忽略资源限制&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_TIME&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许改变系统时钟&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;CAP_SYS_TTY_CONFIG&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许配置 TTY 设备&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_SYSLOG&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许使用 syslog() 系统调用&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CAP_WAKE_ALARM&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getcap&lt;/strong&gt; 命令和 &lt;strong&gt;setcap&lt;/strong&gt; 命令分别用来查看和设置程序文件的 capabilities 属性。下面我们演示如何使用 capabilities 代替 ping 命令的 SUID。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因为 ping 命令在执行时需要访问网络，这就需要获得 root 权限，常规的做法是通过 SUID 实现的(和 passwd 命令相同)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201908/952033-20190827131206051-822318192.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红框中的 s 说明应用程序文件被设置了 SUID，这样普通用户就可以执行这些命令了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;移除 ping 命令文件上的 SUID 权限：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;755&lt;/span&gt; /bin/&lt;span&gt;ping&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201908/952033-20190827131249843-476290261.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在移除 SUID 权限后，普通用户在执行 ping 命令时碰到了 &quot;ping: socket: Operation not permitted&quot; 错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为 ping 命令文件添加 capabilities&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;执行 ping 命令所需的 capabilities 为 cap_net_admin 和 cap_net_raw，通过 setcap 命令可以添加它们：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;sudo&lt;/span&gt; setcap cap_net_admin,cap_net_raw+ep /bin/&lt;span&gt;ping&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201908/952033-20190827131337128-1338283849.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;被赋予合适的 capabilities 后，ping 命令又可以正常工作了，相比 SUID 它只具有必要的特权，在最大程度上减小了系统的安全攻击面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果要移除刚才添加的 capabilities，执行下面的命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201908/952033-20190827131417280-784006507.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命令中的 ep 分别表示 Effective 和 Permitted 集合(接下来会介绍)，+ 号表示把指定的 capabilities 添加到这些集合中，- 号表示从集合中移除(对于 Effective 来说是设置或者清除位)。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在上面的示例中我们通过 setcap 命令修改了程序文件 /bin/ping 的 capabilities。在可执行文件的属性中有三个集合来保存三类 capabilities，它们分别是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Permitted&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Inheritable&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Effective&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在进程执行时，&lt;strong&gt;Permitted 集合&lt;/strong&gt;中的 capabilites 自动被加入到进程的 Permitted 集合中。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;Inheritable 集合&lt;/strong&gt;中的 capabilites 会与进程的 Inheritable 集合执行与操作，以确定进程在执行 execve 函数后哪些 capabilites 被继承。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;Effective&lt;/strong&gt; 只是一个 bit。如果设置为开启，那么在执行 execve 函数后，Permitted 集合中新增的 capabilities 会自动出现在进程的 Effective 集合中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;进程中有五种 capabilities 集合类型，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Permitted&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Inheritable&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Effective&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Bounding&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Ambient&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;相比文件的 capabilites，进程的 capabilities 多了两个集合，分别是 Bounding 和 Ambient。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/proc/[pid]/status 文件中包含了进程的五个 capabilities 集合的信息，我们可以通过下面的命名查看当前进程的 capabilities 信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;cat&lt;/span&gt; /proc/$$/status | &lt;span&gt;grep&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cap&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201908/952033-20190827131538795-92607142.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这中方式获得的信息无法阅读，我们需要使用 capsh 命令把它们转义为可读的格式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ capsh --decode=0000003fffffffff
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/952033/201908/952033-20190827131610081-1024332375.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;把特权用户仅仅分为 root 和普通用户显然是过于粗糙了，这会带来安全问题。Capabilities 为解决这一问题而生，&lt;/span&gt;&lt;span&gt;它能提供精细粒度的特权集，从而有效的减小系统的安全攻击面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;capability man page&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://rk700.github.io/2016/10/26/linux-capabilities/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Linux的capabilities机制&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cis.syr.edu/~wedu/seed/Documentation/Linux/How_Linux_Capability_Works.pdf&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;How Linux Capability Works in 2.6.25&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.insecure.ws/linux/getcap_setcap.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;getcap, setcap and file capabilities&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://linux-audit.com/linux-capabilities-101/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Linux capabilities 101&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man8/getcap.8.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;getcap man page&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man8/setcap.8.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;setcap man page&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 28 Aug 2019 00:42:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<og:description>为了执行权限检查，Linux 区分两类进程：特权进程(其有效用户标识为 0，也就是超级用户 root)和非特权进程(其有效用户标识为非零)。 特权进程绕过所有内核权限检查，而非特权进程则根据进程凭证(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sparkdev/p/11417781.html</dc:identifier>
</item>
<item>
<title>Python学习 之三 Python基础&amp;运算符 - duncan1863</title>
<link>http://www.cnblogs.com/duncan1863/p/11421836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duncan1863/p/11421836.html</guid>
<description>&lt;h2 id=&quot;第三章python基础-运算符&quot;&gt;第三章：Python基础 &amp;amp; 运算符&lt;/h2&gt;
&lt;h3 id=&quot;内容回顾-补充&quot;&gt;3.1 内容回顾 &amp;amp; 补充&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;计算机基础&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;编码&lt;/p&gt;
&lt;p&gt;字符串： &quot;中国&quot; &quot;Hello&quot;&lt;/p&gt;
&lt;p&gt;字 符： 中 e&lt;/p&gt;
&lt;p&gt;字 节：&lt;/p&gt;
&lt;p&gt;​ unicode： 中 -&amp;gt; 4个字节， e -&amp;gt; 4个字节&lt;/p&gt;
&lt;p&gt;​ utf-8 ： 中 -&amp;gt; 3个字节， e -&amp;gt; 1个字节&lt;/p&gt;
&lt;p&gt;位 ： 01101111 -&amp;gt; 8位表示一个字节&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;unicode： 一般用于内存中的数据计算&lt;/p&gt;
&lt;p&gt;utf-8 ：一般用于网络传输及数据保存&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装解释器
&lt;/li&gt;
&lt;li&gt;语法
&lt;ul&gt;&lt;li&gt;print / input&lt;/li&gt;
&lt;li&gt;整型 int / 字符串 str / 布尔值 boolen&lt;/li&gt;
&lt;li&gt;条件语句&lt;/li&gt;
&lt;li&gt;and 运算符&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;练习&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# 练习题： 用户输入成绩，根据成绩的不同显示不同的级别，评分规则：A &amp;gt;=90; B &amp;gt;=80; C &amp;gt;=70; D 其他。

score = input(&quot;请输入成绩：&quot;)
score_int = int(score)   # 如果不使用int强制转换，执行会报错 TypeError: '&amp;gt;=' not supported between instances of 'str' and 'int'

if score_int &amp;gt;= 90:
    print(&quot;A&quot;)
elif score_int &amp;gt;= 80:
    print(&quot;B&quot;)
elif score_int &amp;gt;= 70:
    print(&quot;C&quot;)
else:
    print(&quot;D&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;补充&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 10086示例
message = &quot;&quot;&quot;欢迎致电10086
1、话费查询
2、流量服务
3、业务办理
4、人工服务
&quot;&quot;&quot;
print(message)

index = input(&quot;请输入你要选择的业务：&quot;)
index = int(index)
if index == 1:
    print('话费查询')
elif index == 2:
    print('流量服务')
elif index == 3:
    content = &quot;&quot;&quot;业务办理
    1、修改密码
    2、更改套餐
    3、停机
    &quot;&quot;&quot;
    print(content)
    value = input('请输入要办理的业务编号：')
    value = int(value)
    if value == 1:
        print('修改密码')
    elif value == 2:
        print('更改套餐')
    elif value == 3:
        print('停机')
    else:
        print('错误')
elif index == 4:
    print('人工服务')
else:
    print('输入错误')&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pycharm 变更解释器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1690689/201908/1690689-20190828083548043-1897820986.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1690689/201908/1690689-20190828083558529-1326386623.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;循环语句&quot;&gt;3.2 循环语句&lt;/h3&gt;
&lt;p&gt;​ 1、循环打印 “ 人生苦短，我用Python ”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while True:   # 没有终止循环条件，这叫死循环
    print('人生苦短，我用Python')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 2、while 后加条件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while 1 &amp;gt; 0:
    print('人生苦短，我用Python')
    
while 1 &amp;gt; 0 and 2 &amp;gt; 1:
    print('人生苦短，我用Python')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 3、数字相加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;&quot;&quot;
count = 1
value = count + 1
print(value)
&quot;&quot;&quot;

&quot;&quot;&quot;
count = 1
count = count + 1
print(count)
&quot;&quot;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 4、请通过循环，让 count 每次循环都 +1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;count = 1
while True:
    print(count)
    count = count + 1

count = 1
while True:
    print(count)
    count = count + 2
# 练习
while True:   # 这个代码执行的结果就是永远打印1
    count = 1
    print(count)
    count = count + 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 5、请通过循环，打印 1 2 3 ...10&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;count = 1
while count &amp;lt;= 10:
    print(count)
    count = count + 1
print(&quot;结束&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 6、请通过循环，打印 1 2 3 4 5 6 8 9 10&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 错误示例
count = 1
while count &amp;lt;= 10 and count != 7:
    print(count)
    count = count + 1
    
#正确
count = 1
while count &amp;lt;= 6:
    print(count)
    count = count + 1
count = 8
while count &amp;lt;= 10:
    print(count)
    count = count + 1

#正确
count = 1
while count &amp;lt;= 10:
    if count != 7:
        print(count)
    count = count + 1

#正确
count = 1
while count &amp;lt;= 10:
    if count == 7:
        pass
    else:
        print(count)
        count = count + 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 7、关键字：break - 是终止当前循环&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while True:
    print(666)
    break  # 终止当前循环
print('结束')

# 练习：

# 通过 break 实现打印 1-10
count = 1
while True:
    print(count)
    if count == 10:
        break
    count = count + 1
print(&quot;结束&quot;)

# break 是终止当前循环
while True:
    print('你好')
    while True:
        print(666)
        break
    break&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 8、关键字：continue&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;count = 1
while count &amp;lt;= 10:
    print(count)
    continue    # 本次循环如果遇到 continue，则不再继续往下走，而是回到 while 条件位置
    count = count + 1&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;#示例：1 2 3 4 5 6 8 9 10
count = 1
while count &amp;lt;= 10:
    if count == 7:
        continue
    print(count)   # 会打印1到6，但程序不会自动终止
    count = count + 1
    
    
count = 1
while count &amp;lt;= 10:
    if count == 7:
        count = count + 1
        continue
    print(count)   
    count = count + 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 9、while else&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;count = 1
while count &amp;lt; 10:
    print(count)
    count = count + 1
else:      #不再满足 while 后面的条件时，触发。 或 条件 = False
    print(&quot;ELSE代码块&quot;)
print('结束')
count = 1
while True:
    print(count)
    if count == 10:
        break
    count = count + 1
else:      # 不再满足 while 后面的条件时，触发。 或 条件 = False
    print(&quot;ELSE代码块&quot;)  # 这段代码中这行不会执行，因为条件不会为 False 时，break 已经终止了当前循环 
print('结束')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 10、while 循环代码执行顺序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1690689/201908/1690689-20190828083641428-502467076.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 11、其他&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1690689/201908/1690689-20190828083649985-1996266778.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1690689/201908/1690689-20190828083702570-520483825.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1690689/201908/1690689-20190828083717347-1563711270.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 12、总结&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;while 基本结构&lt;/li&gt;
&lt;li&gt;break&lt;/li&gt;
&lt;li&gt;continue&lt;/li&gt;
&lt;li&gt;while else&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;字符串格式化&quot;&gt;3.3 字符串格式化&lt;/h3&gt;
&lt;p&gt;​ 1、%s 占位符&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name = input('姓名：')
do = input('在干什么：')
template = &quot;%s在教室，%s。&quot; % (name,do,)
print(template)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 2、%d 占位符&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template = &quot;我是%s, 年龄%s, 职业%s&quot; % (&quot;alex&quot;,78,&quot;讲鸡汤&quot;)
print(template)

template = &quot;我是%s, 年龄%d, 职业%s&quot; % (&quot;alex&quot;,78,&quot;讲鸡汤&quot;)
print(template)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 3、%%&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name = 'alex'
template = '%s现在手机的电量是100%%'%(name,)  # 如果是 100% 会报错
print(template)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 4、示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name = input('请输入姓名：')
age = input('请输入年龄：')
job = input('请输入职业：')
hobby = input('请输入爱好：')
msg = &quot;&quot;&quot;
------------ info od Alex ------------
Name  : %s
Age   : %s
Job   : %s
Hobby : %s
------------ end ------------&quot;&quot;&quot;

#print(msg%(name,age,job,hobby))

data = msg % (name,age,job,hobby)
print(data)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运算符&quot;&gt;3.4 运算符&lt;/h3&gt;
&lt;h4 id=&quot;算数运算&quot;&gt;3.4.1 算数运算&lt;/h4&gt;
&lt;p&gt;以下假设变量 a=2, b=3&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加——&amp;gt;两个对象相加&lt;/td&gt;
&lt;td&gt;a+b=5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减——&amp;gt;两个数相减&lt;/td&gt;
&lt;td&gt;a-b=-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘——&amp;gt;两个数相乘或是返回一个被重复若干次的字符串&lt;/td&gt;
&lt;td&gt;a*b=6&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;除——&amp;gt;x除以y&lt;/td&gt;
&lt;td&gt;b/a=1.5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;取模——&amp;gt;返回除法的余数&lt;/td&gt;
&lt;td&gt;b%a=1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;幂——&amp;gt;返回x的y次幂&lt;/td&gt;
&lt;td&gt;b**a=9&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;//&lt;/td&gt;
&lt;td&gt;取整除——&amp;gt;返回商的整数部分&lt;/td&gt;
&lt;td&gt;b//a=1 , 如果是3.0//2.0=1.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;a = 10
b = 20
print(a + b)  # 结果为 30&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;a = 10
b = 20
print(a - b)  # 结果为 -10&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;a = 10
b = 20
print(a * b)  # 结果为 200&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;a = 10
b = 20
print(a / b)  # 结果为 0.2&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;value = 11 % 3
print(value)  # 结果为 2&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;a = 10
b = 20
print(a ** b)  # 结果为 100000000000000000000
val = 2**8
print(val)   # 结果为 256&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;取整除 //&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;val = 9/2
print(val)  # 结果为 4.5
c = 9
d = 2
print(c // d)   # 结果为4, 9.0//2.0输出结果为4.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 练习：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#练习题：打印 1 - 100 之间的奇数
count = 1
while count &amp;lt;= 100:
    val = count % 2
    if val == 1:
        print(count)
    count = count + 1
    
#练习题：打印 1 - 100 之间所有的数相加
total = 0
count = 1
while count &amp;lt;= 100:
    total = total + count
    count = count + 1
print(total)

#练习题：打印 1 - 2 + 3 -4 + 5...+ 99 - 100 的结果
total = 0
count = 1
while count &amp;lt;= 100:
    if count % 2 == 1:
    total = total + count
else:
    total = total - count
count = count + 1
print(total)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;比较运算&quot;&gt;3.4.2 比较运算&lt;/h4&gt;
&lt;p&gt;以下假设变量 a=10 , b=20&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;等于——&amp;gt;比较对象是否相等&lt;/td&gt;
&lt;td&gt;(a==b) 返回 False&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不等于——&amp;gt;比较对象是否不相等&lt;/td&gt;
&lt;td&gt;(a!=b) 返回 True&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于——&amp;gt;返回 x 是否大于 y&lt;/td&gt;
&lt;td&gt;(a&amp;gt;b) 返回 False&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于——&amp;gt;返回 x 是否小于 y，&lt;/td&gt;
&lt;td&gt;(a&amp;lt;b) 返回 True&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;大于等于——&amp;gt;返回 x 是否大于等于 y&lt;/td&gt;
&lt;td&gt;(a&amp;gt;=b) 返回 False&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;小于等于——&amp;gt;返回 x 是否小于等于 y&lt;/td&gt;
&lt;td&gt;(a&amp;lt;=b) 返回 True&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;赋值运算&quot;&gt;3.4.3 赋值运算&lt;/h4&gt;
&lt;p&gt;以下假设变量 a=10 , b=20&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;简单的赋值运算符&lt;/td&gt;
&lt;td&gt;c=a+b 将 a+b 的运算结果赋值为c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;+=&lt;/td&gt;
&lt;td&gt;加法赋值运算符&lt;/td&gt;
&lt;td&gt;c+=a 等效于 c= c+a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;-=&lt;/td&gt;
&lt;td&gt;减法赋值运算符&lt;/td&gt;
&lt;td&gt;c-=a 等效于 c=c-a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;*=&lt;/td&gt;
&lt;td&gt;乘法赋值运算符&lt;/td&gt;
&lt;td&gt;c*=a 等效于 c=c*a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;/=&lt;/td&gt;
&lt;td&gt;除法赋值运算符&lt;/td&gt;
&lt;td&gt;c/=a 等效于 c=c/a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;%=&lt;/td&gt;
&lt;td&gt;取模赋值运算符&lt;/td&gt;
&lt;td&gt;c%=a 等效于 c=c%=a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;**=&lt;/td&gt;
&lt;td&gt;幂赋值运算符&lt;/td&gt;
&lt;td&gt;c**=a 等效于 c=c**a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;//=&lt;/td&gt;
&lt;td&gt;取整除赋值运算符&lt;/td&gt;
&lt;td&gt;c//=a 等效于 c=c//a&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​ 练习：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;count = 1
while count &amp;lt;= 100:
    print(count)
    count += 1   # 等效于  count = count + 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;逻辑运算&quot;&gt;3.4.4 逻辑运算&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;布尔‘与’ 如果a为False，a and b返回False，否则它返回 b 的计算值&lt;/td&gt;
&lt;td&gt;(a and b) 返回 False&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;布尔‘或’ 如果a为True，它返回True，否则它返回b的计算值&lt;/td&gt;
&lt;td&gt;(a or b) 返回 True&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;not&lt;/td&gt;
&lt;td&gt;布尔‘非’ 如果a为True，它返回False，如果a为False，它返回True&lt;/td&gt;
&lt;td&gt;not(a and b) 返回 True&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​ 1、一般情况下的使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if 1 &amp;gt; 0 and 1 &amp;lt; 2:
    print(666)
if 1 &amp;gt; 0 and 1 &amp;gt; 2:
    print(777)  
if 1 &amp;gt; 0 or 1 &amp;gt; 2:
    print(888)
if not 1 &amp;gt; 0 or 1 &amp;gt; 2:
    print(999)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 2、二般情况下的使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;小知识:
    - int
    - str
    - bool

#数字转字符串
v1 = 666
v2 = str(v1)
print(v2)  # &quot;666&quot;

#字符串转数字
v1 = &quot;666&quot;
v2 = int(v1)
print(v2)  # 666

#数字转布尔值
v1 = 1
v2 = bool(v1)
print(v2)  # True
v1 = 0
v2 = bool(v1)
print(v2)  # False

#字符串转布尔值
v1 = &quot;1&quot;
v2 = bool(v1)
print(v2)  # True
v1 = &quot;0&quot;
v2 = bool(v1)
print(v2)  # True
v1 = &quot; &quot;
v2 = bool(v1)
print(v2)  # True
v1 = &quot;&quot;  # 表示空字符串
v2 = bool(v1)
print(v2)  # Flase

#布尔值转换其他
v1 = True
v2 = int(v1)
print(v2)  # 1
v1 = False
v2 = int(v1)
print(v2)  # 0
v1 = True
v2 = str(v1)
print(v2)  # True
v1 = False
v2 = str(v1)
print(v2)  # False
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 3、转换需要记住的：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;字符串转数字&lt;/li&gt;
&lt;li&gt;数字转字符串&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;&quot;&quot; / 0 转换布尔值之后是 False&lt;/p&gt;
&lt;p&gt;4、经典面试题&lt;/p&gt;
&lt;p&gt;#对于 or ：&lt;br/&gt;value = 1 or 9&lt;br/&gt;第一个值转换成布尔值如果是真，则 value = 第一个值。&lt;br/&gt;第一个值转换成布尔值如果是假，则 value = 第二个值。&lt;br/&gt;如果有多个 or 条件，则从左到右依次进行上述流程。&lt;br/&gt;示例:&lt;br/&gt;v1 = 0 or 1&lt;br/&gt;v2 = 8 or 10&lt;br/&gt;v3 = 0 or 9 or 8&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#示例：
value = 0 or 9
print(value)  # 结果为 9
value = 0 or 0
print(value)  # 结果为 0
value = 0 or &quot;&quot;
print('---&amp;gt;',value,'&amp;lt;---')  # 结果为 ---&amp;gt;  &amp;lt;---
value = 0 or 9 or 8
print(value)  # 结果为 9&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#对于 and ：
如果第一个值转换成布尔值是True，则 value = 第二个值。
如果第一个值转换成布尔值是False，则 value = 第一个值。
如果有多个 and 条件，则从左到右依次进行上述流程。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;#示例：
v1 = 1 and 9
print(v1)  # 结果为 9

v1 = 1 and 0
print(v1)  # 结果为 0

v1 = 0 and 7
print(v1)  # 结果为 0

v1 = 0 and &quot;&quot;
print(v1)  # 结果为 0

v1 = 1 and 0 and 9
print(v1)  # 结果为 0&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;#and 和 or 综合 : 先看 and 再看 or （前提是在没有括号的情况下）

#示例：
v1 = 1 and 9 or 0 and 6
print(v1)  # 结果为 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 5、逻辑运算的优先级：&lt;/p&gt;
&lt;p&gt;​ 在没有 () 的情况下 not 的优先级高于 and ， and 的优先级高于 or ，即优先级关系为 ()&amp;gt;not&amp;gt;and&amp;gt;or,同一优先级从左往右计算。&lt;/p&gt;
&lt;h4 id=&quot;成员运算&quot;&gt;3.4.5 成员运算&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;如果在指定的序列中找到值返回True，否则返回False&lt;/td&gt;
&lt;td&gt;x 在 y 的序列中，如果x在y的序列中返回True&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;not in&lt;/td&gt;
&lt;td&gt;如果在指定的序列中没有找到值返回True，否则返回False&lt;/td&gt;
&lt;td&gt;x 不在 y 的序列中，如果x不在y的序列中返回True&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;value = &quot;我是中国人&quot;
#判断‘中国’是否在 value 所代指的字符串中。  或者说 ‘中国’是否是 value 所代指的字符串的子序列。
v1 = &quot;中国&quot; in value

#示例
content = input('请输入内容：')
if &quot;退钱&quot; in content:
    print('包含敏感字符！')&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;#示例
while True:
    content = input('请输入内容：')
    if &quot;退钱&quot; in content:
        print('包含敏感字符')
    else:
        print(content)
        break&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;value = &quot;我是中国人&quot;
#判断‘北京’是否不在 value 所代指的字符串中。  或者说 ‘北京’是否不是 value 所代指的字符串的子序列。
v1 = &quot;北京&quot; not in value&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;身份运算&quot;&gt;3.4.6 身份运算&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;is&lt;/td&gt;
&lt;td&gt;is 是判断两个标识符是不是引用自一个对象&lt;/td&gt;
&lt;td&gt;x is y，如果 id(x) 等于 id(y)，is 返回结果 1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;is not&lt;/td&gt;
&lt;td&gt;is not 是判断两个标识符是不是引用自不同对象&lt;/td&gt;
&lt;td&gt;x is not y，如果 id(x) 不等于 id(y)，is not 返回结果 1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;a = 20
b = 20

print(id(a)) # 打印对象id值
print(id(b))

if a is b:
    print('1 - a 和 b 有相同的标识')
else:
    print('1 - a 和 b 没有相同的标识')  
    
if a is not b:
    print('2 - a 和 b 没有相同的标识')
else:
    print('2 - a 和 b 有相同的标识')
    
#修改 b 的变量
b = 30
if a is b:
    print('3 - a 和 b 有相同的标识')
else:
    print('3 - a 和 b 没有相同的标识')

if a is not b:
    print('4 - a 和 b 没有相同的标识')
else:
    print('4 - a 和 b 有相同的标识')

以上示例输出结果：
1543007904
1543007904
1 - a 和 b 有相同的标识
2 - a 和 b 有相同的标识
3 - a 和 b 没有相同的标识
4 - a 和 b 没有相同的标识&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;#is 和 == 的区别 后面学到列表时会学习
#is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。

a = [1,2,3]
b = a
print(b is a)  # True
print(b == a)  # True
b = a[:]
print(b is a)  # False
print(b == a)  # True&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;位运算&quot;&gt;3.4.7 位运算&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;按位与运算符&lt;/td&gt;
&lt;td&gt;(a &amp;amp; b) 输出结果 12，二进制解释： 0000 1100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;按位或运算符&lt;/td&gt;
&lt;td&gt;(a | b) 输出结果 61，二进制解释： 0011 1101&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;按位异或运算符&lt;/td&gt;
&lt;td&gt;(a ^ b) 输出结果 49，二进制解释： 0011 0001&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;按位取反运算符&lt;/td&gt;
&lt;td&gt;(~a)输出结果 -61, 二进制解释: 1100 0011 ,在一个有符号二进制数的补码形式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;左移动运算符&lt;/td&gt;
&lt;td&gt;a &amp;lt;&amp;lt; 2 输出结果 240，二进制解释：1111 0000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;右移动运算符&lt;/td&gt;
&lt;td&gt;a &amp;gt;&amp;gt; 2 输出结果 15，二进制解释： 0000 1111&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;a = 60  # 60 = 0011 1100
b = 13  # 13 = 0000 1101
c = 0
c = a &amp;amp; b;  # 12 = 0000 1100
print(&quot;1 - c 的值为： %s&quot;% c)
c = a | b;  # 61 = 0011 1101
print(&quot;2 - c 的值为： %s&quot;% c)
c = a ^ b;  # 49 = 0011 0001
print(&quot;3 - c 的值为： %s&quot;% c)
c = ~a;  # -61 = 1100 0011
print(&quot;4 - c 的值为： %s&quot;% c)
c = a &amp;lt;&amp;lt; 2;  # 240 = 1111 0000
print(&quot;5 - c 的值为： %s&quot;% c)
c = a &amp;gt;&amp;gt; 2;  # 15 = 0000 1111
print(&quot;6 - c 的值为： %s&quot;% c)

以上示例输出结果：
1 - c 的值为： 12
2 - c 的值为： 61
3 - c 的值为： 49
4 - c 的值为： -61
5 - c 的值为： 240
6 - c 的值为： 15&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.4.8 运算符优先级&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;指数 (最高优先级)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;~ + -&lt;/td&gt;
&lt;td&gt;按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;* / % //&lt;/td&gt;
&lt;td&gt;乘，除，取模和取整除&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;+ -&lt;/td&gt;
&lt;td&gt;加法减法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;gt;&amp;gt; &amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;右移，左移运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;位 'AND'&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;^ |&lt;/td&gt;
&lt;td&gt;位运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&amp;lt;= &amp;lt; &amp;gt; &amp;gt;=&lt;/td&gt;
&lt;td&gt;比较运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;lt;&amp;gt; == !=&lt;/td&gt;
&lt;td&gt;等于运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;= %= /= //= -= += *= **=&lt;/td&gt;
&lt;td&gt;赋值运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;is is not&lt;/td&gt;
&lt;td&gt;身份运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;in not in&lt;/td&gt;
&lt;td&gt;成员运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;not and or&lt;/td&gt;
&lt;td&gt;逻辑运算符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;编码补充&quot;&gt;3.5 编码补充&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;编码扩展
&lt;ul readability=&quot;5&quot;&gt;&lt;li&gt;
&lt;p&gt;ascii&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unicode&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ecs2 — Unicode 通过2个字节来表示，这样表示的内容不够多&lt;/li&gt;
&lt;li&gt;ecs4 — Unicode 通过4个字节来表示，现在基本上都是这种&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;utf-8 — 全球通用，中文用3字节。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;utf-16&lt;/p&gt;
&lt;p&gt;在Windows系统使用记事本写完数据后，点击文件-另存为，弹框中点击编码后的选择按钮，有个Unicode的选项，这个指的就是utf-16，因为Unicode不能写在硬盘上。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;gbk2312 ，中文用2字节。&lt;/p&gt;
&lt;p&gt;由中华人民共和国政府制定的，简体汉字编码规范，大陆所有计算机中的简体中文，都使用此种编码格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;gbk ，中文用2字节。&lt;/p&gt;
&lt;p&gt;gbk2312的升级版，又称GBK大字符集，简而言之就是将所有亚洲文字的双字节字符，包括简体中文，繁体中文，日语，韩语等 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;单位转化&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;8bit = 1byte
1024byte = 1kb
1024kb = 1MB
1024MB = 1GB
1024GB = 1TB
1024TB = 1PB
1024PB = 1EB
1024EB = 1ZB
1024ZB = 1YB
1024YB = 1NB
1024NB = 1DB
常用到 TB 就够了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有不足之处欢迎各位评论指正！&lt;/p&gt;
</description>
<pubDate>Wed, 28 Aug 2019 00:40:00 +0000</pubDate>
<dc:creator>duncan1863</dc:creator>
<og:description>第三章：Python基础 &amp; 运算符 3.1 内容回顾 &amp; 补充 计算机基础 编码 字符串： '中国' 'Hello' 字 符： 中 e 字 节： ​	unicode： 中 4个字节， e 4个字节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duncan1863/p/11421836.html</dc:identifier>
</item>
<item>
<title>net core天马行空系列：原生DI+AOP实现spring boot注解式编程 - 三合视角</title>
<link>http://www.cnblogs.com/hezp/p/11346120.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hezp/p/11346120.html</guid>
<description>&lt;p&gt;       写过spring boot之后，那种无处不在的注解让我非常喜欢，比如属性注入@autowire，配置值注入@value，声明式事物@Transactional等，都非常简洁优雅，那么我就在想，这些在net core里能实现么？经过一番摸索，终于实现并整理成此文。&lt;/p&gt;
&lt;p&gt;       IOC方面，个人非常喜欢net core自带的DI，因为他注册服务简洁优雅，3个生命周期通俗易懂，所以就没使用autofac等其他容器，AOP方面，使用了业内鼎鼎大名的Castle.DynamicProxy(简称DP),所以要在nuget中添加Castle.Core的依赖包，这里大家可能会有疑问，利用mvc的actionFilter不就可以实现了么，为什么还要引用DP呢，因为呀，actionFilter只在controller层有效，普通类他就无能为力了，而DP无所不能。&lt;/p&gt;

&lt;p&gt;属性注入注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  [AttributeUsage(AttributeTargets.Property)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AutowiredAttribute : Attribute
    {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置值注入注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   [AttributeUsage(AttributeTargets.Property)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueAttribute : Attribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueAttribute(&lt;span&gt;string&lt;/span&gt; value = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Value =&lt;span&gt; value;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Value { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;声明式事物注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   [AttributeUsage(AttributeTargets.Method)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransactionalAttribute : Attribute
    {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;工作单元接口及实现类，用来实现事物操作，注入级别为scope，一次请求公用一个工作单元实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUnitOfWork : IDisposable
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开启事务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BeginTransaction();
        
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 提交
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Commit();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事物回滚
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RollBack();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnitOfWork : IUnitOfWork
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BeginTransaction()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开启事务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Commit()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;throw new System.NotImplementedException();&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RollBack()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回滚事务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拦截器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事物拦截器
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransactionalInterceptor : StandardInterceptor
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IUnitOfWork Uow { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TransactionalInterceptor(IUnitOfWork uow)
        {
            Uow &lt;/span&gt;=&lt;span&gt; uow;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PreProceed(IInvocation invocation)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}拦截前&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, invocation.Method.Name);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method =&lt;span&gt; invocation.TargetType.GetMethod(invocation.Method.Name);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (method != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; method.GetCustomAttribute&amp;lt;TransactionalAttribute&amp;gt;() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                Uow.BeginTransaction();
            }
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PerformProceed(IInvocation invocation)
        {
            invocation.Proceed();
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PostProceed(IInvocation invocation)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}拦截后， 返回值是{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, invocation.Method.Name, invocation.ReturnValue);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method =&lt;span&gt; invocation.TargetType.GetMethod(invocation.Method.Name);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (method != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; method.GetCustomAttribute&amp;lt;TransactionalAttribute&amp;gt;() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                Uow.Commit();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用来测试注入效果的接口以及实现类，这里我们定义一辆汽车，汽车拥有一个引擎（属性注入），它能点火启动，点火操作带事物，这里为了演示【接口-实现类】注入和【实现类】注入2种情况，引擎就没添加接口，只有实现类，并且AOP拦截仅有【实现类】的类时，只能拦截虚方法，所以Start和Stop函数为虚函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 汽车引擎
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Engine
    {
        [Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelpNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; HelpNumber { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发动机启动&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Stop();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Stop()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发动机熄火,拨打求救电话&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; HelpNumber);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICar
    {
        Engine Engine { &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Fire();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car : ICar
    {
        [Autowired]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Engine Engine { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        [Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oilNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OilNo { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        [Transactional]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Fire()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;加满&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + OilNo + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;号汽油,点火&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Engine.Start();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制器HomeController&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
    {
        [Autowired]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICar Car{ &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        [Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Description { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; car =&lt;span&gt; Car;

            Console.WriteLine(Description);

            Car.Fire();

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 修改appsettings.json，添加一些测试键值对，（如果测试时发现输出的中文乱码，把appsettings.json保存为utf8格式即可），具体代码如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedHosts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oilNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;95&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelpNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我要开始飙车了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1323385/201908/1323385-20190827165033166-1766345863.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，正常注入，正常开启拦截器和事务，正确读取配置值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1323385/201908/1323385-20190827165106650-842075862.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，我们的控制器，ICar和Engine全部都是动态代理类，注入正常。&lt;/p&gt;

&lt;p&gt;第一部分，添加一个扩展类，名叫SummerBootExtentions.cs，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d61b6b68-a6eb-4527-ae60-24feb3170309')&quot; readability=&quot;57.5&quot;&gt;&lt;img id=&quot;code_img_closed_d61b6b68-a6eb-4527-ae60-24feb3170309&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d61b6b68-a6eb-4527-ae60-24feb3170309&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d61b6b68-a6eb-4527-ae60-24feb3170309',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d61b6b68-a6eb-4527-ae60-24feb3170309&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;110&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SummerBootExtentions
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 瞬时
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TService&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TImplementation&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;interceptorTypes&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSbTransient&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] interceptorTypes)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddSbService(&lt;span&gt;typeof&lt;/span&gt;(TService), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TImplementation), ServiceLifetime.Transient, interceptorTypes);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 请求级别
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TService&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TImplementation&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;interceptorTypes&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSbScoped&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] interceptorTypes)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddSbService(&lt;span&gt;typeof&lt;/span&gt;(TService), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TImplementation), ServiceLifetime.Scoped, interceptorTypes);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 单例
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TService&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TImplementation&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;interceptorTypes&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSbSingleton&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] interceptorTypes)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddSbService(&lt;span&gt;typeof&lt;/span&gt;(TService), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TImplementation), ServiceLifetime.Singleton, interceptorTypes);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSbService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType,
            ServiceLifetime lifetime, &lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] interceptorTypes)
        {
            services.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceDescriptor(implementationType, implementationType, lifetime));

            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Factory(IServiceProvider provider)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; target =&lt;span&gt; provider.GetService(implementationType);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; implementationType.GetTypeInfo().DeclaredProperties;

                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (PropertyInfo info &lt;span&gt;in&lt;/span&gt;&lt;span&gt; properties)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性注入&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (info.GetCustomAttribute&amp;lt;AutowiredAttribute&amp;gt;() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyType =&lt;span&gt; info.PropertyType;
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; impl =&lt;span&gt; provider.GetService(propertyType);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (impl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            info.SetValue(target, impl);
                        }
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置值注入&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (info.GetCustomAttribute&amp;lt;ValueAttribute&amp;gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ValueAttribute valueAttribute)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; valueAttribute.Value;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (provider.GetService(&lt;span&gt;typeof&lt;/span&gt;(IConfiguration)) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; IConfiguration configService)
                        {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pathValue =&lt;span&gt; configService.GetSection(value).Value;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pathValue != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            {
                                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pathV =&lt;span&gt; Convert.ChangeType(pathValue, info.PropertyType);
                                info.SetValue(target, pathV);
                            }
                        }

                    }
                }

                List&lt;/span&gt;&amp;lt;IInterceptor&amp;gt; interceptors =&lt;span&gt; interceptorTypes.ToList()
                    .ConvertAll&lt;/span&gt;&amp;lt;IInterceptor&amp;gt;(interceptorType =&amp;gt; provider.GetService(interceptorType) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IInterceptor);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; proxy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyGenerator().CreateInterfaceProxyWithTarget(serviceType, target, interceptors.ToArray());

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceDescriptor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceDescriptor(serviceType, Factory, lifetime);
            services.Add(serviceDescriptor);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 瞬时
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TService&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;interceptorTypes&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSbTransient&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] interceptorTypes)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddSbService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TService), ServiceLifetime.Transient, interceptorTypes);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 请求
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TService&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;interceptorTypes&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSbScoped&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] interceptorTypes)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddSbService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TService), ServiceLifetime.Scoped, interceptorTypes);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 单例
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TService&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;interceptorTypes&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSbSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] interceptorTypes)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddSbService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TService), ServiceLifetime.Singleton, interceptorTypes);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSbService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType,
            ServiceLifetime lifetime, &lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] interceptorTypes)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (services == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(services));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (serviceType == (Type)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(serviceType));

            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Factory(IServiceProvider provider)
            {
                List&lt;/span&gt;&amp;lt;IInterceptor&amp;gt; interceptors =&lt;span&gt; interceptorTypes.ToList()
                    .ConvertAll&lt;/span&gt;&amp;lt;IInterceptor&amp;gt;(interceptorType =&amp;gt; provider.GetService(interceptorType) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IInterceptor);


                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; proxy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyGenerator().CreateClassProxy(serviceType, interceptors.ToArray());

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; serviceType.GetTypeInfo().DeclaredProperties;

                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (PropertyInfo info &lt;span&gt;in&lt;/span&gt;&lt;span&gt; properties)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性注入&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (info.GetCustomAttribute&amp;lt;AutowiredAttribute&amp;gt;() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyType =&lt;span&gt; info.PropertyType;
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; impl =&lt;span&gt; provider.GetService(propertyType);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (impl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            info.SetValue(proxy, impl);
                        }
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置值注入&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (info.GetCustomAttribute&amp;lt;ValueAttribute&amp;gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ValueAttribute valueAttribute)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; valueAttribute.Value;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (provider.GetService(&lt;span&gt;typeof&lt;/span&gt;(IConfiguration)) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; IConfiguration configService)
                        {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pathValue =&lt;span&gt; configService.GetSection(value).Value;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pathValue != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            {
                                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pathV =&lt;span&gt; Convert.ChangeType(pathValue, info.PropertyType);
                                info.SetValue(proxy, pathV);
                            }
                        }
                    }
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceDescriptor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceDescriptor(serviceType, Factory, lifetime);
            services.Add(serviceDescriptor);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 添加summer boot扩展
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;builder&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IMvcBuilder AddSB(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IMvcBuilder builder)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (builder == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(builder));
            ControllerFeature feature &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ControllerFeature();
            builder.PartManager.PopulateFeature&lt;/span&gt;&amp;lt;ControllerFeature&amp;gt;&lt;span&gt;(feature);
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (Type type &lt;span&gt;in&lt;/span&gt; feature.Controllers.Select&amp;lt;TypeInfo, Type&amp;gt;((Func&amp;lt;TypeInfo, Type&amp;gt;)(c =&amp;gt;&lt;span&gt; c.AsType())))
                builder.Services.TryAddTransient(type, type);
            builder.Services.Replace(ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IControllerActivator, SbControllerActivator&amp;gt;&lt;span&gt;());

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第二部分，添加一个自定义控制器激活类，用以替换掉mvc自带的激活类，这个类命名为SbControllerActivator.cs，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b0c8a204-d4f9-4c3f-b5f5-d0fd4bed7a71')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_b0c8a204-d4f9-4c3f-b5f5-d0fd4bed7a71&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b0c8a204-d4f9-4c3f-b5f5-d0fd4bed7a71&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b0c8a204-d4f9-4c3f-b5f5-d0fd4bed7a71',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b0c8a204-d4f9-4c3f-b5f5-d0fd4bed7a71&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SbControllerActivator : IControllerActivator
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;inheritdoc /&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Create(ControllerContext actionContext)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (actionContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(actionContext));

            Type serviceType &lt;/span&gt;=&lt;span&gt; actionContext.ActionDescriptor.ControllerTypeInfo.AsType();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; target =&lt;span&gt; actionContext.HttpContext.RequestServices.GetRequiredService(serviceType);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; serviceType.GetTypeInfo().DeclaredProperties;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; proxy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyGenerator().CreateClassProxyWithTarget(serviceType, target);

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (PropertyInfo info &lt;span&gt;in&lt;/span&gt;&lt;span&gt; properties)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性注入&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (info.GetCustomAttribute&amp;lt;AutowiredAttribute&amp;gt;() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyType =&lt;span&gt; info.PropertyType;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; impl =&lt;span&gt; actionContext.HttpContext.RequestServices.GetService(propertyType);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (impl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        info.SetValue(proxy, impl);
                    }
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置值注入&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (info.GetCustomAttribute&amp;lt;ValueAttribute&amp;gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ValueAttribute valueAttribute)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; valueAttribute.Value;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (actionContext.HttpContext.RequestServices.GetService(&lt;span&gt;typeof&lt;/span&gt;(IConfiguration)) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; IConfiguration configService)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pathValue =&lt;span&gt; configService.GetSection(value).Value;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pathValue != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pathV =&lt;span&gt; Convert.ChangeType(pathValue, info.PropertyType);
                            info.SetValue(proxy, pathV);
                        }
                    }

                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;inheritdoc /&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Release(ControllerContext context, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; controller)
        {
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第三部分，在Startup.cs中，修改ConfigureServices方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.Configure&lt;/span&gt;&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This lambda determines whether user consent for non-essential cookies is needed for a given request.&lt;/span&gt;
                options.CheckConsentNeeded = context =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                options.MinimumSameSitePolicy &lt;/span&gt;=&lt;span&gt; SameSiteMode.None;
            });

            
            services.AddMvc()
                .SetCompatibilityVersion(CompatibilityVersion.Version_2_1)
                .AddSB();

            services.AddSbScoped&lt;/span&gt;&amp;lt;Engine&amp;gt;(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TransactionalInterceptor));
            
            services.AddScoped&lt;/span&gt;&amp;lt;IUnitOfWork,UnitOfWork&amp;gt;&lt;span&gt;();
            services.AddScoped(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TransactionalInterceptor));

            services.AddSbScoped&lt;/span&gt;&amp;lt;ICar, Car&amp;gt;(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TransactionalInterceptor));

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       从上面代码我们可以看到，在addMvc后加上了我们替换默认控制器的AddSB方法，接管了控制器的生成。AddSbScoped&amp;lt;Engine&amp;gt;和AddSbScoped&amp;lt;ICar, Car&amp;gt;这种添加依赖注入的方式也保持了net core自带DI的原滋原味，简洁优雅，并且实现了动态代理，只需要在参数里添加拦截器，就能实时拦截，这里参数为params Type[],可以添加N个拦截器。&lt;/p&gt;

&lt;p&gt;   在博客园潜水了好几年，见证了net core从1.0到快出3.0，这也是第一次尝试着写博客，为net core的发扬光大尽自己的一份力。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 28 Aug 2019 00:39:00 +0000</pubDate>
<dc:creator>三合视角</dc:creator>
<og:description>写过spring boot之后，那种无处不在的注解让我非常喜欢，比如属性注入@autowire，配置值注入@value，声明式事物@Transactional等，都非常简洁优雅，那么我就在想，这些在n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hezp/p/11346120.html</dc:identifier>
</item>
<item>
<title>12款好用超赞的国外搜索资源网站 ，开发者们的标配，你都知道吗？不知道就OUT了 - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/11417951.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/11417951.html</guid>
<description>&lt;h2 class=&quot;postTitle&quot;&gt; 简介&lt;/h2&gt;
&lt;div class=&quot;postBody&quot; readability=&quot;32&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot; readability=&quot;59&quot;&gt;
&lt;p&gt;　　看了 看了网上有好多推荐插件的文章，很少有推荐搜索资源网站，于是今天决定推荐一波搜索资源网站。这些网站帮助我开阔视眼、增长知识、解决问题。所以在这里整理一下，分享给朋友和博友们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7253165-2b24e88e3eadbe7d?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827160140314-1103405039.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;学习技术过程我们经常需要使用搜索引擎来检索资料，国内常用的也就是某度了。&lt;/p&gt;
&lt;p&gt;当然有条件的话，搜索引擎首先还是推荐使用 Google，如果没办法使用，可以使用以下几个作为备用：&lt;/p&gt;
&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 1.Bing&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Bing 国际版：&lt;a href=&quot;https://cn.bing.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://cn.bing.com/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比某度好用，之前还被停用了几天，最近可以了。分为国内版和国际版。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827142850330-1230378921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 2.DuckDuckGo&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DuckDuckGo：&lt;a href=&quot;https://duckduckgo.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://duckduckgo.com/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从官网的介绍来看这个搜索引擎不收集用户信息，而且没有广告。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827142513917-1637664459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 3.Stack Overflow&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Stack Overflow：&lt;a href=&quot;https://stackoverflow.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们如果常用 Google，很多技术问题的答案就在这个网站上，如果你无法使用 Google 可以在这个网站上直接检索就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827142954481-1458416904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 4.Gitlogs&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Gitlogs：&lt;a href=&quot;https://www.gitlogs.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.gitlogs.com/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gitlogs 是专门针对 GitHub 项目的搜索引擎，我们通过他可以快速找到想要项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827143024996-40122136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 5.jiumo search&lt;/h2&gt;
&lt;p&gt;文档搜索引擎 jiumo search 鸠摩搜书：&lt;a href=&quot;https://www.jiumodiary.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.jiumodiary.com/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;可以用来找一些技术文档手册，很多在百度网盘里。&lt;/p&gt;
&lt;p&gt;这个是一个在国内外的问答社区都拥有比较高的用户评价的电子说搜索网站，据说能够下载到大部分你需要的书籍的PDF资源。&lt;/p&gt;
&lt;p&gt;喜欢读书的朋友，特别是喜欢读电子书的朋友，这个网站可以说莫大的福利啦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827143108359-1449067438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 6.Ebooke&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Ebooke：&lt;a href=&quot;https://ebookee.org/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://ebookee.org/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ebookee 是一个基于互联网并提供免费电子图书下载的搜索引擎网站。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827142754834-772798115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 7.Iconfinder&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;图标搜索：&lt;a href=&quot;https://www.iconfinder.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.iconfinder.com/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用来查找 logo 图片。&lt;/p&gt;
&lt;p&gt;这是一个icon素材站点，通过主站的icon搜索引擎，此站收集了大量的icon素材。并且每一种素材都提供了来源地址，你不仅可以查找素材，通过更多的网址找到更多的可用素材。这个网站燕归来曾不止一次向大家推荐过，总之一个词——好用！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827143208709-212064407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 8.“以图找图”--TinEye&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TinEye：&lt;a href=&quot;https://www.tineye.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.tineye.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用图片来检索图片，我们可以上传图片或输入图片的 URL 来检索。&lt;/p&gt;
&lt;p&gt;给出一个图案，引擎会搜索包含该图案的图片出来。可能大家还没明白这个引擎的神奇性，也不知道它的重要用途在哪里。下面是这个引擎自己给出的一些Cool Searches，你就明白它的真正作用在哪里了。&lt;/p&gt;
&lt;p&gt;作用一、打击非法使用认证标识行为&lt;/p&gt;
&lt;p&gt;搜索源介绍:Fairtrade Certified，国际公平贸易标签组织。据传言这个认证可不是那么容易就拿到的，不过这个图片是很容易就拿到的。于是，非法使用标签的人们就被该组织用TinEye的搜索抓到了…&lt;/p&gt;
&lt;p&gt;作用二、发现山寨(盗用Logo)&lt;/p&gt;
&lt;p&gt;搜索源介绍:Mac软件Transmit的Logo。结果发现，用这小卡车作为logo的好像不再是自己了…&lt;/p&gt;
&lt;p&gt;山寨就是这么被发现的吧?&lt;/p&gt;
&lt;p&gt;作用三、发现恶搞&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827150312916-1283337064.png&quot; alt=&quot;&quot; width=&quot;1298&quot; height=&quot;407&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 9.SemanticScholar&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SemanticScholar：&lt;a href=&quot;https://www.semanticscholar.org/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.semanticscholar.org/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SemanticScholar 是一个免费学术搜索引擎，其检索结果来自于期刊、学术会议资料或者是学术机构的文献。&lt;/p&gt;
&lt;p&gt;由微软联合创始人 Paul Allen 做的免费学术搜索引擎，其检索结果来自于期刊、学术会议资料或者是学术机构的文献。这个搜索引擎用上了机器学习的技术，希望减少科学家的检索论文的时间。&lt;/p&gt;
&lt;p&gt;对于科学研究人员来说，Semantic Scholar 看上去最大的用处是有更多信息筛选的角度，包括论文的影响力，媒体报道(Twitter 数据)、作者等，另外它直接提供图表预览，看起来能方便研究人员省下更多筛选的工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827144054110-644320788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 10.LibreStock&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;LibreStock：&lt;a href=&quot;https://librestock.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://librestock.com/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LibreStock 上可以检索一些优质的高清图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827143513623-1157095557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 11.CC Search&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CC Search：&lt;a href=&quot;https://ccsearch.creativecommons.org/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://ccsearch.creativecommons.org/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CC Search 上搜索到的图片资源都是无版权的，我们可以免费的使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827143417935-2020020556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 12.The App Store&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;The App Store：&lt;a href=&quot;https://theappstore.org/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://theappstore.org/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The App Store 是一个针对苹果手机、iPad、Mac 设备的应用搜索工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190827143340785-1559775014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;最后宅男宅女福利&lt;/h2&gt;
&lt;h2 id=&quot;谷歌访问助手&quot;&gt;## 搜电影——疯狂影视搜索&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt; 网址：http://ifkdy.com/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个非常不错的影视搜索网站。上面可以搜索到许多经典的电影，而且还能下载观看。总之，有了这个网站，不再愁电影无处可寻啦！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;您的肯定就是我进步的动力。&lt;/strong&gt;如果你感觉还不错，就请鼓励一下吧！记得点波 &lt;span&gt;推荐&lt;/span&gt; 哦！！！（点击右边的小球即可！(^__^) 嘻嘻……）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201908/1232840-20190816135641371-1314831001.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 28 Aug 2019 00:30:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 看了&amp;#160;看了网上有好多推荐插件的文章，很少有推荐搜索资源网站，于是今天决定推荐一波搜索资源网站。这些网站帮助我开阔视眼、增长知识、解决问题。所以在这里整理一下，分享给朋友和博友们。 看了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/du-hong/p/11417951.html</dc:identifier>
</item>
<item>
<title>python聚类算法解决方案（rest接口/mpp数据库/json数据/下载图片及数据） - 软件老王</title>
<link>http://www.cnblogs.com/ruanjianlaowang/p/11421785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruanjianlaowang/p/11421785.html</guid>
<description>&lt;h3 id=&quot;场景描述&quot;&gt;1. 场景描述&lt;/h3&gt;
&lt;p&gt;一直做java，因项目原因，需要封装一些经典的算法到平台上去，就一边学习python，一边网上寻找经典算法代码，今天介绍下经典的K-means聚类算法，算法原理就不介绍了，只从代码层面进行介绍，包含：rest接口、连接mpp数据库、回传json数据、下载图片及数据。&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;2. 解决方案&lt;/h3&gt;
&lt;h4 id=&quot;项目套路&quot;&gt;2.1 项目套路&lt;/h4&gt;
&lt;p&gt;（1）python经典算法是单独的服务器部署，提供rest接口出来，供java平台调用，交互的方式是http+json；&lt;/p&gt;
&lt;p&gt;（2）数据从mpp数据库-Greenplum中获取；&lt;/p&gt;
&lt;p&gt;（3）返回的数据包括三个：1是生成聚类图片的地址；2是聚类项目完整数据地址；3是返回给前端的200条json预览数据。&lt;/p&gt;
&lt;h4 id=&quot;restapi类&quot;&gt;2.2 restapi类&lt;/h4&gt;
&lt;p&gt;分两个类，第一个是restapi类，封装rest接口类，其他的经典算法在这里都有对应的方法，是个公共类。&lt;/p&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

from flask import Flask, request, send_from_directory
from k_means import exec
import logging
app = Flask(__name__)

#1.服务器上更改为服务器地址，用于存放数据
dirpath = 'E:\\ruanjianlaowang'

#2. 测试连通性，软件老王
@app.route('/')
def index():
    return &quot;Hello, World!&quot;


#3. k-means算法 软件老王
@app.route('/getKmeansInfoByLaowang', methods=['POST'])
def getKmeansInfoByLaowang():
    try:
         result = exec(request.get_json(), dirpath)
    except IndexError as e:
        logging.error(str(e))
        return 'exception:' + str(e)
    except KeyError as e:
        logging.error(str(e))
        return 'exception:' + str(e)
    except ValueError as e:
        logging.error(str(e))
        return 'exception:' + str(e)
    except Exception as e:
        logging.error(str(e))
        return 'exception:' + str(e)
    else:
        return result

#4.文件下载（图片及csv）
@app.route(&quot;/&amp;lt;path:filename&amp;gt;&quot;)
def getImages(filename):
    return send_from_directory(dirpath, filename, as_attachment=True)

#5.启动
if __name__ == '__main__':
    app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用的是第三方的flask提供的rest服务&lt;/p&gt;
&lt;p&gt;（1）服务器上更改为服务器地址，用于存放数据&lt;/p&gt;
&lt;p&gt;（2）测试连通性，软件老王&lt;/p&gt;
&lt;p&gt;（3）k-means算法 软件老王&lt;/p&gt;
&lt;p&gt;（4）文件下载（图片及csv）&lt;/p&gt;
&lt;p&gt;（5）启动&lt;/p&gt;
&lt;h4 id=&quot;k-means算法类&quot;&gt;2.3 k-means算法类&lt;/h4&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pandas as pd
import dbgp as dbgp
from pandas.io import json
from numpy import *
import matplotlib.pyplot as plt
import numpy as np
plt.switch_backend('agg')
import logging

# 执行 软件老王
def exec(params, dirpath):

    #1.获取参数，软件老王
    sql = params.get(&quot;sql&quot;)
    xlines = params.get(&quot;xlines&quot;)
    ylines = params.get(&quot;ylines&quot;)
    xlinesname = params.get(&quot;xlinesname&quot;)
    ylinesname = params.get(&quot;ylinesname&quot;)
    grouplinesname = params.get(&quot;grouplinesname&quot;)

    times = int(params.get(&quot;times&quot;))
    groupnum = int(params.get(&quot;groupnum&quot;))
    url = params.get(&quot;url&quot;)
    name = params.get(&quot;name&quot;)

    #2. 校验是否为空，软件老王
    flag = checkparam(sql, xlines, ylines, times, groupnum)
    if not flag is None and len(flag) != 0:
        return flag

    #3. 从数据库获取数据，软件老王
    try:
        data = dbgp.queryGp(sql)
    except IndexError:
        return sql
    except KeyError:
        return sql
    except ValueError:
        return sql
    except Exception:
        return sql

    if data.empty:
        return &quot;exception:此数据集无数据，请确认后重试&quot;
    #4 调用第三方sklearn的KMeans聚类算法，软件老王
    # data_zs = 1.0 * (data - data.mean()) / data.std()  数据标准化，不需要标准话
    from sklearn.cluster import KMeans
    model = KMeans(n_clusters=groupnum, n_jobs=4, max_iter=times)
    model.fit(data)  # 开始聚类

    return export(model, data, data, url, dirpath, name,grouplinesname,xlines, ylines,xlinesname,ylinesname)

    # 5.生成导出excel 软件老王
def export(model, data, data_zs, url, dirpath, name,grouplinesname,xlines, ylines,xlinesname,ylinesname):


    # #详细输出原始数据及其类别
    detail_data = pd.DataFrame().append(data)
    if not grouplinesname is None and len(grouplinesname) != 0:
        detail_data.columns = grouplinesname.split(',')

    r_detail_new = pd.concat([detail_data, pd.Series(model.labels_, index=detail_data.index)], axis=1)  # 详细输出每个样本对应的类别
    r_detail_new.columns = list(detail_data.columns) + [u'聚类类别']  # 重命名表头
    outputfile = dirpath + name + '.csv'
    r_detail_new.to_csv(outputfile, encoding='utf_8_sig')  # 保存结果


    #重命名表头
    r1 = pd.Series(model.labels_).value_counts()  # 统计各个类别的数目
    r2 = pd.DataFrame(model.cluster_centers_)  # 找出聚类中心
    r = pd.concat([r2, r1], axis=1)  # 横向连接（0是纵向），得到聚类中心对应的类别下的数目
    r.columns = list(data.columns) + [u'类别数目']  # 重命名表头

    return generateimage(r, data_zs, url, dirpath, name,model,xlines, ylines,xlinesname,ylinesname)

#6.生成图片及返回json，软件老王
def generateimage(r, data_zs, url, dirpath, name,model,xlines, ylines,xlinesname,ylinesname):
    image = dirpath + name + '.jpg'

    #6.1 中文处理，软件老王
    plt.rcParams['font.sans-serif'] = ['simhei']
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['axes.unicode_minus'] = False
    # 6.2 画图，生成图片，软件老王
    labels = model.labels_
    centers = model.cluster_centers_
    data_zs['label'] = labels
    data_zs['label'] = data_zs['label'].astype(np.int)
    # 图标集合
    markers = ['o', 's', '+', 'x', '^', 'v', '&amp;lt;', '&amp;gt;']
    colors = ['b', 'c', 'g', 'k', 'm', 'r', 'y']
    symbols = []
    for m in markers:
        for c in colors:
            symbols.append((m, c))
    # 画每个类别的散点及质心
    for i in range(0, len(centers)):
        df_i = data_zs.loc[data_zs['label'] == i]
        symbol = symbols[i]
        center = centers[i]

        x = df_i[xlines].values.tolist()
        y = df_i[ylines].values.tolist()

        plt.scatter(x, y, marker=symbol[0], color=symbol[1], s=10)
        plt.scatter(center[0], center[1], marker='*', color=symbol[1], s=50)

    plt.title(name)
    plt.xlabel(xlinesname)
    plt.ylabel(ylinesname)
    plt.savefig(image, dpi=150)
    plt.clf()
    plt.close(0)

    # 6.3 返回json数据给前端展示，软件老王
    result = {}
    result['image_url'] = url + '/' + name + '.jpg'
    result['details_url'] = url + '/' + name + '.csv'
    result['data'] = r[:200]   #显示200，多的话，相当于预览
    result = json.dumps(result, ensure_ascii=False)
    result = result.replace('\\', '')
    return result

def checkparam(sql, xlines, ylines, times, groupnum):
    if sql is None or sql.strip() == '' or len(sql.strip()) == 0:
        return &quot;数据集或聚类数据列，不能为空&quot;
    if xlines is None or xlines.strip() == '' or len(xlines.strip()) == 0:
        return &quot;X轴，不能为空&quot;
    if ylines is None or ylines.strip() == '' or len(ylines.strip()) == 0:
        return &quot;Y轴，不能为空&quot;
    if times is None or times &amp;lt;= 0:
        return &quot;聚类个数，不能为空或小于等于0&quot;
    if groupnum is None or groupnum &amp;lt;= 0:
        return &quot;迭代次数，不能为空或小于等于0&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）获取参数，软件老王；&lt;/p&gt;
&lt;p&gt;（2）校验是否为空，软件老王；&lt;/p&gt;
&lt;p&gt;（3）从数据库获取数据，软件老王；&lt;/p&gt;
&lt;p&gt;（4）第三方sklearn的KMeans聚类算法，软件老王；&lt;/p&gt;
&lt;p&gt;（5）生成导出excel 软件老王&lt;/p&gt;
&lt;p&gt;（6）生成图片及返回json，软件老王&lt;/p&gt;
&lt;p&gt;​ （6.1） 中文处理，软件老王&lt;/p&gt;
&lt;p&gt;​ （6.2） 画图，生成图片，软件老王&lt;/p&gt;
&lt;p&gt;​ （6.3） 返回json数据给前端展示，软件老王&lt;/p&gt;
&lt;h4 id=&quot;执行效果&quot;&gt;2.4 执行效果&lt;/h4&gt;
&lt;h5 id=&quot;json返回&quot;&gt;2.4.1 json返回&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;image_url&quot;:&quot;http://10.192.168.1:5000/ruanjianlaowang_65652.jpg&quot;,&quot;details_url&quot;:&quot;http://10.192.168.1:5000/ruanjianlaowang_65652.csv&quot;,&quot;data&quot;:{&quot;empno&quot;:{&quot;0&quot;:7747.2,&quot;1&quot;:7699.625,&quot;2&quot;:7839.0},&quot;mgr&quot;:{&quot;0&quot;:7729.8,&quot;1&quot;:7745.25,&quot;2&quot;:7566.0},&quot;sal&quot;:{&quot;0&quot;:2855.0,&quot;1&quot;:1218.75,&quot;2&quot;:5000.0},&quot;comm&quot;:{&quot;0&quot;:29.5110766,&quot;1&quot;:117.383964625,&quot;2&quot;:31.281453},&quot;deptno&quot;:{&quot;0&quot;:20.0,&quot;1&quot;:25.0,&quot;2&quot;:10.0},&quot;类别数目&quot;:{&quot;0&quot;:5,&quot;1&quot;:8,&quot;2&quot;:1}}}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;返回图片&quot;&gt;2.4.2 返回图片&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1727736/201908/1727736-20190828081556857-38091048.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;返回的数据&quot;&gt;2.4.3 返回的数据&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1727736/201908/1727736-20190828081607760-1345013168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外说明：&lt;/strong&gt; 目前项目环境上用的是8核16G的虚拟机，执行数据量是30万，运行状况良好。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;I’m 「软件老王」，如果觉得还可以的话，关注下呗，后续更新秒知！欢迎讨论区、同名公众号留言交流！&lt;/p&gt;
</description>
<pubDate>Wed, 28 Aug 2019 00:17:00 +0000</pubDate>
<dc:creator>软件老王</dc:creator>
<og:description>python聚类算法解决方案（rest接口/mpp数据库/json数据/下载图片及数据）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ruanjianlaowang/p/11421785.html</dc:identifier>
</item>
<item>
<title>持续集成高级篇之Jekins脚本参数化构建 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11421782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11421782.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;本系列已经很久没有更新了,接前面基础篇,本系统主要介绍jenkins构建里的一些高级特性.包括脚本参数化,Jenkins Pipeline与及在PipeLine模式下如何执行常见的传统构建任务(这里指jenkins自由风格构建模式),jenkins cli,jenkins ssh,jenkins任务调度,资源调度,jenkins任务远程触发,jenkins混合集群搭建(同时包含windows和linux节点)等高级功能.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在一些复杂的构建中,我们可能需要指定很多参数,如果这些参数都写死在cmd或者powershell脚本或者ssh脚本里,脚本的可扩展性将严重受限,最为重要的是修改构建脚本可能会造成严重后果(尤其是一些非常复杂的脚本),这里的一个最佳实践就是不要轻易更改生产环境的脚本文件.而参数化构建可以大大增加脚本的可扩展性.&lt;/p&gt;
&lt;p&gt;Jenkins提供了丰富的参数配置入口结合脚本自身的外部参数处理可以实现非常灵活的脚本参数配置.下面从脚本自身参数化选项,项目级参数化配置,节点级参数化配置以及全局参数配置来详细讲解如何在Jenkins里实现参数化配置.&lt;/p&gt;
&lt;h2 id=&quot;脚本自身参数化配置&quot;&gt;脚本自身参数化配置&lt;/h2&gt;
&lt;p&gt;下面分别介绍bat脚本和powershell脚本如何接收外部参数&lt;/p&gt;
&lt;h3 id=&quot;bat脚本接收外部参数&quot;&gt;bat脚本接收外部参数&lt;/h3&gt;
&lt;p&gt;在windows bat脚本命令里,可以通过%0,%1,%2...以此类推来接收外部传入参数,其中%0为脚本自身的名称,很多时候不是我们需要的,我们可以从%1开始接收外部传入参数.我们假如有以下一个名为&lt;code&gt;build.bat&lt;/code&gt;的脚本,它用作构建测试环境和生产环境的脚本,测试环境和生产环境的构建可以通过一个外部参数来判断.为了简单起见我们并不使用真实环境的构建脚本,而是简单模拟,希望读者能够举一反三,联系到真实环境应用场景.&lt;/p&gt;
&lt;p&gt;这个bat脚本非常简单,就一行代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo %1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;shell接收外部参数&quot;&gt;shell接收外部参数&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;在Jenkins中,除了powershell和bat命令外,其它地方接收外部参数的方法写法都是shell语法写法,即&lt;code&gt;${参数名}&lt;/code&gt;形式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们传入什么就会打印什么,我们传入development,或者production,bat脚本就会接收到它们.以上非常简单,这里不在jenkins里单独创建项目演示,大家可以自己动手试一试.&lt;/p&gt;
&lt;h3 id=&quot;powershell接收外部参数&quot;&gt;powershell接收外部参数&lt;/h3&gt;
&lt;p&gt;相对于windows cmd,powershell更为强大,也更为灵活.下面分别介绍powershell的&lt;code&gt;位置参数&lt;/code&gt;和&lt;code&gt;命名参数&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;powershell位置参数&quot;&gt;powershell位置参数&lt;/h4&gt;
&lt;p&gt;位置参数类似于上面讲的cmd通过%0,%1获取参数一样,通过参数的顺序来决定调用的是哪一个参数.在Powershell里,位置参数传入到ps1文件后都存储在了一个叫作$args的数组变量里,可以通过$args[0],$args[1]来获取各位置上的参数(位置通过空格区分,如果参数包含空格需要加引号)&lt;/p&gt;
&lt;p&gt;类似上面bat,我们新建一个叫作'build.ps1'的powershell脚本文件,代码与上面的bat类似,如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo $args[0]&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;需要注意的是,powrshell脚本文件(即后缀名为ps1的文件)无法通过cmd命令窗口打开.需要使用powershell窗口或者调用powershell.exe来打开&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;ps1文件的执行方式&quot;&gt;ps1文件的执行方式&lt;/h5&gt;
&lt;p&gt;1) 使用powrshell命令窗口打开,就像打开cmd命令一下打开powershell命令窗口,需要注意的是powershell窗口执行ps1文件需要使用相对路径或者绝对路径,比如你要打开一个名称为&lt;code&gt;Build.ps1&lt;/code&gt;的文件,打开方式应该是&lt;code&gt;.\Build.ps1&lt;/code&gt;(相对路径形式)或者&lt;code&gt;C:\build.ps1&lt;/code&gt;形式,不能是直接&lt;code&gt;Build.ps1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2) 使用cmd打开powershell,在cmd中输入&lt;code&gt;powershell&lt;/code&gt;就会进入powershell命令窗口,和直接打开powershell命令窗口效果是一样的.&lt;/p&gt;
&lt;p&gt;3) 通过powrshell.exe 执行powershell命令.在cmd中输入powershell.exe -File 要执行的ps1文件即可运行ps1脚本&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;第三种方式提供了一种在cmd环境执行powershell脚本的方法,这在jenkins环境中非常有用,可以不必使用powershell插件即可调用powershell脚本.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;powershell-命名参数&quot;&gt;powershell 命名参数&lt;/h4&gt;
&lt;p&gt;很多时候,尤其在要传入的参数非常多的时候,位置参数语义不是很清析,对于调试脚本很不方便,而命名参数可以在一定程度上使语义更清楚,出错的可能性也会更小.下面就介绍一下powershell中的命名参数,我们新建一个名为&lt;code&gt;build.ps1&lt;/code&gt;(名称可以随便起)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;param($build,$version)

echo &quot;current build type is: $build,and the version is:$version&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上脚本我们通过param关键字创建了两个命名参数,$build和$version(powershell中参数命名前面要加一个&lt;code&gt;$&lt;/code&gt;符号),我们在当前脚本所在文件夹下打开powershell命令窗口,然后执行以下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\build.ps1 -version 1.0 -build development&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这里是通过&lt;code&gt;-+参数名&lt;/code&gt;的方式来传入命名参数&lt;/p&gt;
&lt;p&gt;可以看到输出如下结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;current build type is: development,and the version is:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家可以看到,不管&lt;code&gt;-version&lt;/code&gt;和&lt;code&gt;-build&lt;/code&gt;位置如何,输出的结果都是一样的.&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;明眼的同学可能会发现一点小问题,那就是&lt;code&gt;-versoin&lt;/code&gt;输入的参数是&lt;code&gt;1.0&lt;/code&gt;而输出的结果却是&lt;code&gt;1&lt;/code&gt;,这是因为powershell把1.0当作数字来处理了,舍弃掉了没有用的小数位,我们想要输出1.0只需要把1.0用引号引起来就行了,当然还有其它办法,那就是指定参数的类型,指定参数类型超出了本节讲解的范围.有兴趣的童鞋可以查阅相关资料深入了解.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 28 Aug 2019 00:15:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 本系列已经很久没有更新了,接前面基础篇,本系统主要介绍jenkins构建里的一些高级特性.包括脚本参数化,Jenkins Pipeline与及在PipeLine模式下如何执行常见的传统构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11421782.html</dc:identifier>
</item>
<item>
<title>Java虚拟机详解（七）------虚拟机监控和分析工具（1）——命令行 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/11311667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/11311667.html</guid>
<description>&lt;p&gt;　　通过前面的几篇博客，我们介绍了Java虚拟机的内存分配以及内存回收等理论知识，了解这些知识对于我们在实际生产环境中提高系统的运行效率是有很大的帮助的。但是话又说回来，在实际生产环境中，线上项目正在运行，我们怎么去监控虚拟机运行效率？又或者线上项目发生了OOM，异常堆栈信息，我们又怎么去抓取，然后怎么去分析定位问题呢？&lt;/p&gt;
&lt;p&gt;　　本篇博客，我们就来介绍各种虚拟机监控和分析工具，当然都是命令行工具，不够直观，下篇博客我们会介绍各种可视化工具。&lt;/p&gt;
&lt;h3&gt;1、jps：显示虚拟机进程&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
JVM Process Status Tools ，显示指定系统内所有的 HotSpot 虚拟机进程。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该命令有如下常用参数：&lt;/p&gt;
&lt;p&gt;　　①、-l &lt;/p&gt;
&lt;p&gt;　　显示应用程序main类的完整包名称或应用程序的JAR文件的完整路径名。&lt;/p&gt;
&lt;p&gt;　　②、-v&lt;/p&gt;
&lt;p&gt;　　显示虚拟机启动时的JVM参数。&lt;/p&gt;
&lt;p&gt;　　③、-m&lt;/p&gt;
&lt;p&gt;　　显示虚拟机进程启动时传递给主类 main() 函数的参数。&lt;/p&gt;
&lt;p&gt;　　比如，我在服务器上启动了一个Tomcat，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190820200641843-2112367170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后，输入 jps 命令，打印信息如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190820200714344-692232240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里的 Bootstrap 便是启动的 Tomcat进程。可以加上 -v 参数，显示所有传递给 JVM的参数信息。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190820201543363-49183902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　PS：jps 命令默认是没有安装的，需要进行安装，具体安装步骤可以百度，我这里就不做详细介绍了。&lt;/p&gt;
&lt;p&gt;　　jps更多详细信息，请参考官方文档：&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html&quot;&gt;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2、jstat：统计监视虚拟机信息工具&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
JVM Statistics Monitoring Tool，用于收集虚拟机各方面的运行数据。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　jstat 是用于监视虚拟机各种运行时状态信息的命令行工具。它可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行时数据，它是&lt;strong&gt;运行时期定位虚拟机性能问题的首选工具&lt;/strong&gt;。但是终究只是命令行工具，后面我们会介绍图形化工具，更加直观。&lt;/p&gt;
&lt;p&gt;　　该命令监控本地的格式如下：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;jstat -参数  vmid 采样间隔时间 采样次数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　①、常用参数有如下&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190820203351874-2091875600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②、vmid&lt;/p&gt;
&lt;p&gt;　　表示目标虚拟机的标识符，在Linux系统上可以通过上小节我们介绍的 jps 命令，前面输出的数字便是进程 PID。在windows平台上，可以通过任务管理器查看。&lt;/p&gt;
&lt;p&gt;　　③、采样间隔时间&lt;/p&gt;
&lt;p&gt;　　默认单位是毫毛，必须是正整数。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;实例1&lt;/strong&gt;：这里我们加入 -class 参数，查看类装载信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190820203925569-1409729786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　相关表头信息：&lt;/p&gt;
&lt;p&gt;　　Loaded：加载的类数量。&lt;/p&gt;
&lt;p&gt;　　Bytes：加载的类字节KB大小。&lt;/p&gt;
&lt;p&gt;　　Unloaded：卸载的类数量。&lt;/p&gt;
&lt;p&gt;　　Bytes：卸载的类字节KB大小。&lt;/p&gt;
&lt;p&gt;　　Time：执行类加载和卸载操作所花费的时间。&lt;/p&gt;

&lt;p&gt;　　jstat更多详细信息，请参考官方文档：&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html&quot;&gt;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、jinfo:实时的查看和调整虚拟机各项参数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
jinfo(Confiiguration Info &lt;span&gt;for&lt;/span&gt; Java)：实时的查看和调整虚拟机各项参数
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　jinfo ，通过此命令，我们可以实时的查看和调整虚拟机的各项参数（包括显示指定或默认配置的）。&lt;/p&gt;
&lt;p&gt;　　该命令格式如下：&lt;/p&gt;
&lt;p&gt;　　jinfo [ 选项 ] pid&lt;/p&gt;
&lt;p&gt;　　①、常用选项如下&lt;/p&gt;
&lt;p&gt;　　一、没有选项&lt;/p&gt;
&lt;p&gt;　　打印系统属性名称键值对。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190820205901149-1592990124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　二、-参数名称&lt;/p&gt;
&lt;p&gt;　　打印指定参数的名称和值。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190820210235344-421974861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　三、-flag [+|-] 参数名称&lt;/p&gt;
&lt;p&gt;　　启用或者禁用指定的布尔命令。&lt;/p&gt;
&lt;p&gt;　　四、-flag name=value&lt;/p&gt;
&lt;p&gt;　　设置参数name的值为value&lt;/p&gt;
&lt;p&gt;　　五、-sysprops&lt;/p&gt;
&lt;p&gt;　　打印Java属性名称键值对。&lt;/p&gt;
&lt;p&gt;　　②、pid&lt;/p&gt;
&lt;p&gt;　　进程号，和上面一样，可以通过jps命令获取。&lt;/p&gt;
&lt;p&gt;　　 jinfo更多详细信息，请参考官方文档：&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html&quot;&gt;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4、jmap:内存映像工具&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
jmap(Memory Map &lt;span&gt;for&lt;/span&gt; Java)：用于生成堆存储快照
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　jmap主要用于获取堆存储快照文件，在生产环境中，发生OOM（堆内存溢出）异常时，我们可以通过这个快照文件来快速定位到具体代码位置。&lt;/p&gt;
&lt;p&gt;　　这个命令还可以查询 finalize 队列，Java堆和永久代信息，如空间使用率、当前用的是哪种垃圾收集器等。&lt;/p&gt;
&lt;p&gt;　　该命令格式如下：&lt;/p&gt;
&lt;p&gt;　　jmap [参数] pid&lt;/p&gt;
&lt;p&gt;　　①、常用参数如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190821202756420-1693076792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于堆内存溢出异常，在前面介绍&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/11109018.html#_label3&quot; target=&quot;_blank&quot;&gt;虚拟机参数&lt;/a&gt;时，我们介绍过，通过下面两个参数，也能够打印堆内存快照。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　-XX:+&lt;span&gt;HeapDumpOnOutOfMemoryError

　　&lt;/span&gt;-XX:HeapDumpPath
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面，我们通过如下代码，演示堆内存溢出异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.algorithmproject.leetcode.demo.JVM;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Create by YSOcean
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JmapTest {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _1MB = 1024*1024&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * 虚拟机参数设置： -Xms20M -Xmx20M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         List&amp;lt;Object&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             list.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[_1MB]);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　设置虚拟机参数后，然后运行这段代码，就会发生堆内存溢出异常，并在根目录下生成快照文件 java_pid10840.hprof。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190821203810625-903488951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么，怎么通过 jmap 命令来生成堆内存快照呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
jmap -dump:format=b,file=heap20190821.hprof  16823
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　后面的数字是进程PID，可以通过jps命令来获取。&lt;/p&gt;
&lt;p&gt;　　得到堆内存快照了，那么我们怎么去查看呢？&lt;/p&gt;
&lt;p&gt;　　在eclipse中，可以下载 &lt;strong&gt;MAT&lt;/strong&gt; 工具，而在 IDEA中，可以下载 &lt;strong&gt;JProfiler &lt;/strong&gt;插件。实在不行，可以用我们下篇博客介绍的几个可视化工具，具体情况见下篇博客。&lt;/p&gt;
&lt;p&gt;　　jmap更多详细信息，请参考官方文档：&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html&quot;&gt;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;5、jstack：Java堆栈跟踪工具 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 Stack Trace &lt;span&gt;for&lt;/span&gt; Java，用于生成虚拟机当前时刻的线程快照。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　线程快照其实就是当前虚拟机每一条线程正在执行的堆栈的集合，通过线程快照可以用来定位线程出现长时间停顿的原因（线程间死锁、死循环、请求外部资源导致的长时间等待）。&lt;/p&gt;
&lt;p&gt;　　该命令格式如下：&lt;/p&gt;
&lt;p&gt;　　jstack [选项] pid&lt;/p&gt;
&lt;p&gt;　　①、常用选项如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190826212928098-88887238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/index.html&quot;&gt;https://docs.oracle.com/javase/8/docs/technotes/tools/index.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 28 Aug 2019 00:04:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Java虚拟机详解（七）------虚拟机监控和分析工具（1）——命令行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ysocean/p/11311667.html</dc:identifier>
</item>
<item>
<title>Spring与后端模板引擎的故事 - 全菜工程师小辉</title>
<link>http://www.cnblogs.com/mseddl/p/11421746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mseddl/p/11421746.html</guid>
<description>&lt;p&gt;更多内容，欢迎关注微信公众号：全菜工程师小辉。公众号回复关键词，领取免费学习资料。&lt;/p&gt;
&lt;p&gt;现在很多开发，都采用了前后端完全分离的模式，随着近几年前端工程化工具和MVC框架的完善，使得这种模式的维护成本逐渐降低。但是这种模式目前并不利于SEO（前后端分离的SEO问题会慢慢改善），而且某些场景使用模板引擎会更方便，比如说邮件模板以及数据变化不频繁的后台系统。&lt;br/&gt;Spring，确切来说是Spring MVC除了可以实现RESTful web服务之外，还可以使用它提供动态HTML内容。Spring MVC支持多种模板技术，包括Thymeleaf、FreeMarker和JSP等。&lt;/p&gt;

&lt;p&gt;模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的文档。&lt;br/&gt;模板引擎的基本机理就是替换（转换），将指定的标签转换为需要的业务数据；将指定的伪语句按照某种流程来变换输出。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190828072816083-1333876824.jpg&quot; alt=&quot;什么是模板引擎?&quot;/&gt;&lt;/p&gt;

&lt;p&gt;SpringMVC处理请求的流程图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190828072816341-1164138126.png&quot; alt=&quot;SpringMVC处理请求的流程图&quot;/&gt;&lt;br/&gt;模板引擎发挥作用是在第8，9，10步骤。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/y277an/article/details/90145318&quot;&gt;更详细的原理介绍，点我跳转&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;重点介绍Velocity，因为其2010年以后连续6年没有更新，版本停留在1.7，直到最近两年才有更新，最新版本是2019年3月更新的2.1，但是变化并不大。&lt;br/&gt;Spring官网原文：&lt;br/&gt;As of Spring Framework 4.3, Velocity support has been deprecated due to six years without active maintenance of the Apache Velocity project. We recommend Spring’s FreeMarker support instead, or Thymeleaf which comes with Spring support itself.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Spring Framework 4.3、SpringBoot 1.5删除了对Velocity的支持, 所以想在后续版本使用，需要手动引入。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JSP使用的视图解析器：InternalResourceViewResovler继承了UrlBasedViewResolver&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190828072817259-404747324.png&quot; alt=&quot;JSP视图解析器继承关系&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Freemarker和Velocity的视频解析器：FreemarkerViewResolver和VelocityViewResolver，两种解析器都继承了AbstractTemplateViewResolver&lt;/p&gt;
&lt;p&gt;FreeMarker视图解析器继承关系：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190828072818623-16566844.png&quot; alt=&quot;FreeMarker视图解析器继承关系&quot;/&gt;&lt;br/&gt;Velocity视图解析器继承关系：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190828072820209-253006998.png&quot; alt=&quot;Velocity视图解析器继承关系&quot;/&gt;&lt;/p&gt;

&lt;p&gt;JSP只能运行在servlet容器中，其他模板引擎没有限制，而且其他模板引擎并不是只用于web开发（由于提前编译，JSP的速度也最快）&lt;/p&gt;
&lt;p&gt;当SpringBoot启用一个内嵌的servlet容器启动时，对JSP的支持有一些限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用tomcat或者使用jetty时，需要使用war包。tomcat/jetty中由于硬编码了文件模式，可执行jar不能运行JSP&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Undertow不支持JSP&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;创建的自定义error.jsp无法覆盖默认的错误处理&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在docker中使用JSP要注意：由于jsp渲染后会生成java文件和class文件存放在磁盘，如果使用docker需要指定环境变量中的temp目录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;学习难度：&lt;br/&gt;Thymeleaf &amp;lt; Velocity &amp;lt; JSP&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Thymeleaf更接近h5语法，现代模板语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;移植性：&lt;br/&gt;Thymeleaf:移植性强，有Spring生态&lt;br/&gt;Velocity：移植性强，缺少周边生态&lt;br/&gt;JSP：必须是Servlet或者JSP容器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;性能：&lt;br/&gt;Themeleaf:解释执行，性能较差（后台用，前台最好别用）&lt;br/&gt;Velocity：解释执行，性能良好（采用了大量反射）&lt;br/&gt;JSP:性能最好，因为先翻译成源码再编译执行，性能优秀&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201908/1327889-20190828072820711-1108010905.png&quot; alt=&quot;哎呀，如果我的名片丢了。微信搜索“全菜工程师小辉”，依然可以找到我&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Aug 2019 23:28:00 +0000</pubDate>
<dc:creator>全菜工程师小辉</dc:creator>
<og:description>更多内容，欢迎关注微信公众号：全菜工程师小辉。公众号回复关键词，领取免费学习资料。 现在很多开发，都采用了前后端完全分离的模式，随着近几年前端工程化工具和MVC框架的完善，使得这种模式的维护成本逐渐降</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mseddl/p/11421746.html</dc:identifier>
</item>
<item>
<title>《Java 8 in Action》Chapter 7：并行数据处理与性能 - HelloDeveloper</title>
<link>http://www.cnblogs.com/HelloDeveloper/p/11421737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HelloDeveloper/p/11421737.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在Java 7之前，并行处理数据集合非常麻烦。第一，你得明确地把包含数据的数据结构分成若干子部分。第二，你要给每个子部分分配一个独立的线程。第三，你需要在恰当的时候对它们进行同步来避免不希望出现的竞争条件，等待所有线程完成，最后把这些部分结果合并起来。Java 7引入了一个叫作分支/合并的框架，让这些操作更稳定、更不易出错。&lt;br/&gt;Stream接口让你不用太费力气就能对数据集执行并行操作。它允许你声明性地将顺序流变为并行流。此外，你将看到Java是如何变戏法的，或者更实际地来说， 流是如何在幕后应用Java 7引入的分支/合并框架的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static long sequentialSum(long n) {
             return Stream.iterate(1L, i -&amp;gt; i + 1)
                          .limit(n)
                          .reduce(0L, Long::sum);
}
传统写法：
public static long iterativeSum(long n) {
        long result = 0;
        for (long i = 1L; i &amp;lt;= n; i++) {
            result += i;
        }
        return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;将顺序流转换为并行流&quot;&gt;1.1 将顺序流转换为并行流&lt;/h2&gt;
&lt;p&gt;可以把流转换成并行流，从而让前面的函数归约过程(也就是求和)并行运行——对顺序流调用parallel方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static long parallelSum(long n) {
        return Stream.iterate(1L, i -&amp;gt; i + 1)
                     .limit(n)
                     .parallel()
                     .reduce(0L, Long::sum);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在现实中，对顺序流调用parallel方法并不意味着流本身有任何实际的变化。它在内部实际上就是设了一个boolean标志，表示你想让调用parallel之后进行的所有操作都并行执行。类似地，你只需要对并行流调用sequential方法就可以把它变成顺序流。请注意，你可能以为把这两个方法结合起来，就可以更细化地控制在遍历流时哪些操作要并行执行，哪些要顺序执行。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;配置并行流使用的线程池&lt;br/&gt;看看流的parallel方法，你可能会想，并行流用的线程是从哪来的?有多少个?怎么自定义这个过程呢?&lt;br/&gt;并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available- Processors()得到的。&lt;br/&gt;但是你可以通过系统属性 java.util.concurrent.ForkJoinPool.common.parallelism来改变线程池大小，如下所示:&lt;br/&gt;System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;,&quot;12&quot;);&lt;br/&gt;这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，&lt;br/&gt;除非你有很好的理由，否则我们强烈建议你不要修改它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;测量流性能&quot;&gt;1.2 测量流性能&lt;/h2&gt;
&lt;p&gt;并行编程可能很复杂，有时候甚至有点违反直觉。如果用得不对(比如采用了一 个不易并行化的操作，如iterate)，它甚至可能让程序的整体性能更差，所以在调用那个看似神奇的parallel操作时，了解背后到底发生了什么是很有必要的。&lt;br/&gt;并行化并不是没有代价的。并行化过程本身需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。但在多个内核之间移动数据的代价也可能比你想的要大，所以很重要的一点是要保证在内核中并行执行工作的时间比在内核之间传输数据的时间长。总而言之，很多情况下不可能或不方便并行化。然而，在使用 并行Stream加速代码之前，你必须确保用得对;如果结果错了，算得快就毫无意义了。&lt;/p&gt;
&lt;h2 id=&quot;正确使用并行流&quot;&gt;1.3 正确使用并行流&lt;/h2&gt;
&lt;p&gt;错用并行流而产生错误的首要原因，就是使用的算法改变了某些共享状态。下面是另一种实现对前n个自然数求和的方法，但这会改变一个共享累加器:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static long sideEffectSum(long n) {
    Accumulator accumulator = new Accumulator();
    LongStream.rangeClosed(1, n).forEach(accumulator::add)
    return accumulator.total;
}
public class Accumulator {
    public long total = 0;
    public void add(long value) { total += value; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码本身上就是顺序的，因为每次访问total都会出现数据竞争。接下来将这段代码改为并行：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static long sideEffectParallelSum(long n) {
    Accumulator accumulator = new Accumulator();
    LongStream.rangeClosed(1, n).parallel().forEach(accumulator::add);
    return accumulator.total;}
System.out.println(&quot;SideEffect parallel sum done in: &quot; + measurePerf(ParallelStreams::sideEffectParallelSum, 10_000_000L) +&quot; msecs&quot; );
Result: 5959989000692
Result: 7425264100768
Result: 6827235020033
Result: 7192970417739
Result: 6714157975331
Result: 7715125932481
SideEffect parallel sum done in: 49 msecs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这回方法的性能无关紧要了，唯一要紧的是每次执行都会返回不同的结果，都离正确值50000005000000差很远。这是由于多个线程在同时访问累加器，执行total += value，而这一句􏱵然看似简单，却不是一个原子操作。问题的根源在于，forEach中调用的方法有副作用，它会改变多个线程共享的对象的可变状态。要是你想用并行Stream又不想引发类似的意外，就必须避免这种情况。现在你知道了，共享可变状态会影响并行流以及并行计算。&lt;/p&gt;
&lt;h2 id=&quot;高效使用并行流&quot;&gt;1.4 高效使用并行流&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如果有疑问，测量。把顺序流转成并行流轻而易举，但却不一定是好事。我们在本节中已经指出，并行流并不总是比顺序流快。此外，并行流有时候会和你的直觉不一致，所以在考虑选择顺序流还是并行流时，第一个也是最重要的建议就是用适当的基准来检查其性能。&lt;/li&gt;
&lt;li&gt;留意装箱。自动装箱和拆箱操作会大大降低性能。Java 8中有原始类型流(IntStream、 LongStream、DoubleStream)来避免这种操作，但凡有可能都应该用这些流。&lt;/li&gt;
&lt;li&gt;有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny会比findFirst性能好，因为它不一定要按顺序来执行。你总是可以调用unordered方法来把有序流变成无序流。那么，如果你需要流中的n个元素而不是专门要前n个的话，对无序并行流调用 limit可能会比单个有序流(比如数据源是一个List)更高效。&lt;/li&gt;
&lt;li&gt;还要考虑流的操作流水线的总计算成本。设N是要处理的元素的总数，Q是一个元素通过 流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味着使用并行流时性能好的可能性比较大。&lt;/li&gt;
&lt;li&gt;对于较小的数据量，选择并行流几乎从来都不是一个好的决定。并行处理少数几个元素的好处还抵不上并行化造成的额外开销。&lt;/li&gt;
&lt;li&gt;要考虑流背后的数据结构是否易于分解。例如，ArrayList的拆分效􏶲比LinkedList 高得多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。另外，用range工厂方法创建的原始类型流也可以快速分解。最后，你将在7.3节中学到，你可以自己实现Spliterator来完全掌握分解过程。&lt;/li&gt;
&lt;li&gt;流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。例如，一个SIZED流可以分成大小相等的两部分，这样每个部分都可以比较高效地并行处理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知。&lt;/li&gt;
&lt;li&gt;还要考虑终􏲧操作中合并步骤的代价是大是小(例如Collector中的combiner方法)。 如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超出通过并行流得到的性能提升。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1774630/201908/1774630-20190828071844960-703522444.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;并行流背后使用的基础架构是Java 7中引入的分支/合并框架。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池(称为ForkJoinPool)中的工作线程。&lt;/p&gt;
&lt;h2 id=&quot;使用recursivetask&quot;&gt;2.1 使用RecursiveTask&lt;/h2&gt;
&lt;p&gt;要把任务提交到这个池，必须创建RecursiveTask的一个子类，其中R是并行化任务(以 及所有子任务)产生的结果类型，或者如果任务不返回结果，则是RecursiveAction类型(当然它可能会更新其他非局部机构)。要定义RecursiveTask，只需实现它唯一的抽象方法 compute:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected abstract R compute();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。下图表示了递归任务的拆分过程：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1774630/201908/1774630-20190828071845419-466938977.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们试着用这个框架为一个数字范围(这里用一个 long[]数组表示)求和。如前所述，你需要先为RecursiveTask类做一个实现，就是下面代码清单中的ForkJoinSumCalculator。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ForkJoinSumCalculator extends RecursiveTask&amp;lt;Long&amp;gt; {
    private final long[] numbers;
    private final int start;
    private final int end;

    public static final long THRESHOLD = 10_000;

    public ForkJoinSumCalculator(long[] numbers) {
        this(numbers, 0, numbers.length);
    }

    public ForkJoinSumCalculator(long[] numbers, int start, int end) {
        this.numbers = numbers;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        int length = end - start;
        if (length &amp;lt;= THRESHOLD) {
            return computeSequentially();
        }
        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(numbers, start, start + length / 2);
        leftTask.fork();

        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(numbers, start + length / 2, end);
        Long rightResult = rightTask.compute();
        Long leftResult = leftTask.join();
        return leftResult + rightResult;
    }

    private long computeSequentially() {
        long sum = 0;
        for (int i = start; i &amp;lt; end; i++) {
            sum += numbers[i];
        }
        return sum;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里用了一个LongStream来生成包含前n个自然数的数组，然后创建一个ForkJoinTask (RecursiveTask的父类)，并把数组传递给代码清单7-2所示ForkJoinSumCalculator的公共构造函数。最后，你创建了一个新的ForkJoinPool，并把任务传给它的调用方法 。在ForkJoinPool中执行时，最后一个方法返回的值就是ForkJoinSumCalculator类定义的任务结果。&lt;br/&gt;请注意在实际应用时，使用多个ForkJoinPool是没有什么意义的。正是出于这个原因，一般来说把它实例化一次，然后把实例保存在静态字段中，使之成为单例，这样就可以在软件中任何部分方便地重用了。这里创建时用了其默认的无参数构造函数，这意味着想让线程池使用JVM能够使用的所有处理器。更确切地说，该构造函数将使用Runtime.availableProcessors的返回值来决定线程􏶈使用的线程数。请注意availableProcessors方法虽然看起来是处理器， 但它实际上返回的是可用内核的数量，包括超线程生成的虚拟内核。&lt;br/&gt;当把ForkJoinSumCalculator任务传给ForkJoinPool时，这个任务就由􏶈中的一个线程 执行，这个线程会调用任务的compute方法。该方法会检查任务是否小到足以顺序执行，如果不够小则会把要求和的数组分成两半，分给两个新的ForkJoinSumCalculator，而它们也由ForkJoinPool安排执行。因此，这一过程可以递归重复，把原任务分为更小的任务，直到满足不方便或不可能再进一步拆分的条件(本例中是求和的项目数小于等于10000)。这时会顺序计算每个任务的结果，然后由分支过程创建的(隐含的)任务二叉树遍历回到它的根。接下来会合并每个子任务的部分结果，从而得到总任务的结果。这一过程如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1774630/201908/1774630-20190828071845851-641060885.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用分支合并框架的最佳做法&quot;&gt;2.2 使用分支/合并框架的最佳做法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;对一个任务调用join方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子任务的计算都开始之后再调用它。否则，你得到的版本会比原始的顺序算法更慢更复杂，因为每个子任务都必须等待另一个子任务完成才能启动。&lt;/li&gt;
&lt;li&gt;不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。相反，你应该始终直接调用compute或fork方法，只有顺序代码才应该用invoke来启动并行计算。&lt;/li&gt;
&lt;li&gt;对子任务调用fork方法可以把它排进ForkJoinPool。同时对左边和右边的子任务调用它似乎很自然，但这样做的效􏶲要比直接对其中一个调用compute低。这样做你可以为其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销。&lt;/li&gt;
&lt;li&gt;调试使用分支/合并框架的并行计算可能有点棘手。特别是你平常都在你喜欢的IDE里面看栈跟踪(stack trace)来找问题，但放在分支-合并并计算上就不行了，因为调用compute的线程并不是概念上的调用方，后者是调用fork的那个。&lt;/li&gt;
&lt;li&gt;和并行流一样，你不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。我们已经说过，一个任务可以分解成多个独立的子任务，才能让性能在并行化时有所提升。所有这些子任务的运行时间都应该比分出新任务所花的时间长;一个惯用方法是把输入/输出放在一个子任务里，计算放在另一个里，这样计算就可以和输入/输出同时进行。此外，在比较同一算法的顺序和并行版本的性能时还有别的因素要考虑。就像任何其他Java代码一样，分支/合并框架需要“预热”或者说要执行几遍才会被JIT编译器优化。这就是为什么在测量性能之前跑几遍程序很重要，我们的测试框架就是这么做的。同时还要知道，编译器内置的优化可能会为顺序版本带来一些优􏲵(例如执行死码分析——删去从未被使用的计算)。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;工作窃取&quot;&gt;2.3 工作窃取&lt;/h2&gt;
&lt;p&gt;实际中，每个子任务所花的时间可能天差地别，要么是因为划分策略效率低，要么是有不可预知的原因，比如磁盘访问慢，或是需要和外部任务协调执行。分支/合并框架工程用一种称为工作窃取(work stealing)的技术来解决这个问题。&lt;br/&gt;在实际应用中，这意味着这些任务差不多被平均分配到ForkJoinPool中的所有线程上。每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行。基于前面所述的原因，某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从队列的尾巴上“偷走”一个任务。这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空。这就是为什么要划成许多小任务而不是少数几个大任务，这有助于更好地在工作线程之间平衡负载。一般来说，这种工作窃取算法用于在池中的工作线程之间重新分配和平衡任务。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1774630/201908/1774630-20190828071846278-1517720318.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Spliterator是Java 8中加入的另一个新接口;这个名字代表“可分迭代器”(splitable iterator)。和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Spliterator&amp;lt;T&amp;gt; {
        boolean tryAdvance(Consumer&amp;lt;? super T&amp;gt; action);
        Spliterator&amp;lt;T&amp;gt; trySplit();
        long estimateSize();
        int characteristics();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与往常一样，T是Spliterator遍历的元素的类型。tryAdvance方法的行为类似于普通的 Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍历就返回true。但trySplit是专为Spliterator接口设计的，因为它可以把一些元素划出去分给第二个Spliterator(由该方法返回)，让它们两个并行处理。Spliterator还可通过 estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值也有助于让拆分均匀一点。&lt;/p&gt;
&lt;h2 id=&quot;拆分过程&quot;&gt;3.1 拆分过程&lt;/h2&gt;
&lt;p&gt;将Stream拆分成多个部分的算法是一个递􏰒过程，如图7-6所示。第一步是对第一个 Spliterator调用trySplit，生成第二个Spliterator。第二步对这两个Spliterator调用 trysplit，这样总共就有了四个Spliterator。这个框架不断对Spliterator调用trySplit直到它返回null，表明它处理的数据结构不能再分割，如第三步所示。最后，这个递归拆分过程到第四步就终止了，这时所有的Spliterator在调用trySplit时都返回了null。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1774630/201908/1774630-20190828071846721-1212836726.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Spliterator的特性
Spliterator接口声明的最后一个抽象方法是characteristics，它将返回一个int，代 表Spliterator本身特性集的编码。
使用Spliterator的客户可以用这些特性来更好地控制和优化它的使用。
表7-2总结了这些特性。(不幸的是，虽然它们在概念上与收集器的特性有重叠，编码却不一样。)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1774630/201908/1774630-20190828071847171-1770939186.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现自定义spliterator&quot;&gt;3.2 实现自定义Spliterator&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;

&lt;p&gt;在本章中，你了解了以下内容。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内部迭代让你可以并行处理一个流，而无需在代码中显式使用和􏷡调不同的线程。&lt;/li&gt;
&lt;li&gt;虽然并行处理一个流很容易，却不能保证程序在所有情况下都运行得更快。并行软件的行为和性能有时是违反直觉的，因此一定要测量，确保你并没有把程序拖得更慢。&lt;/li&gt;
&lt;li&gt;像并行流那样对一个数据集并行执行操作可以提升性能，特别是要处理的元素数量庞大，或处理单个元素特别耗时的时候。&lt;/li&gt;
&lt;li&gt;从性能角度来看，使用正确的数据结构，如尽可能利用原始流而不是一般化的流，几乎总是比尝试并行化某些操作更为重要。&lt;/li&gt;
&lt;li&gt;分支/合并框架让你得以用递归方式将可以并行的任务拆分成更小的任务，在不同的线程上执行，然后将各个子任务的结果合并起来生成整体结果。&lt;/li&gt;
&lt;li&gt;Spliterator定义了并行流如何拆分它要遍历的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;资源获取&quot;&gt;资源获取&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;tips&quot;&gt;Tips&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧&lt;/li&gt;
&lt;li&gt;欢迎关注我的公众号：庄里程序猿，读书笔记教程资源第一时间获得！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1774630/201908/1774630-20190828071848199-815375794.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Aug 2019 23:19:00 +0000</pubDate>
<dc:creator>HelloDeveloper</dc:creator>
<og:description>在Java 7之前，并行处理数据集合非常麻烦。第一，你得明确地把包含数据的数据结构分成若干子部分。第二，你要给每个子部分分配一个独立的线程。第三，你需要在恰当的时候对它们进行同步来避免不希望出现的竞争</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/HelloDeveloper/p/11421737.html</dc:identifier>
</item>
<item>
<title>Scala 系列（二）—— 基本数据类型和运算符 - 黑白影</title>
<link>http://www.cnblogs.com/heibaiying/p/11421732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heibaiying/p/11421732.html</guid>
<description>&lt;h2 id=&quot;一数据类型&quot;&gt;一、数据类型&lt;/h2&gt;
&lt;h3 id=&quot;类型支持&quot;&gt;1.1 类型支持&lt;/h3&gt;
&lt;p&gt;Scala 拥有下表所示的数据类型，其中 Byte、Short、Int、Long 和 Char 类型统称为整数类型，整数类型加上 Float 和 Double 统称为数值类型。Scala 数值类型的取值范围和 Java 对应类型的取值范围相同。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Byte&lt;/td&gt;
&lt;td&gt;8 位有符号补码整数。数值区间为 -128 到 127&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Short&lt;/td&gt;
&lt;td&gt;16 位有符号补码整数。数值区间为 -32768 到 32767&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;32 位有符号补码整数。数值区间为 -2147483648 到 2147483647&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;64 位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;32 位, IEEE 754 标准的单精度浮点数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Double&lt;/td&gt;
&lt;td&gt;64 位 IEEE 754 标准的双精度浮点数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Char&lt;/td&gt;
&lt;td&gt;16 位无符号 Unicode 字符, 区间值为 U+0000 到 U+FFFF&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;字符序列&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;true 或 false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Unit&lt;/td&gt;
&lt;td&gt;表示无值，等同于 Java 中的 void。用作不返回任何结果的方法的结果类型。Unit 只有一个实例值，写成 ()。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Null&lt;/td&gt;
&lt;td&gt;null 或空引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Nothing&lt;/td&gt;
&lt;td&gt;Nothing 类型在 Scala 的类层级的最低端；它是任何其他类型的子类型。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Any&lt;/td&gt;
&lt;td&gt;Any 是所有其他类的超类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AnyRef&lt;/td&gt;
&lt;td&gt;AnyRef 类是 Scala 里所有引用类 (reference class) 的基类&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;定义变量&quot;&gt;1.2 定义变量&lt;/h3&gt;
&lt;p&gt;Scala 的变量分为两种，val 和 var，其区别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;val&lt;/strong&gt; ： 类似于 Java 中的 final 变量，一旦初始化就不能被重新赋值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;var&lt;/strong&gt; ：类似于 Java 中的非 final 变量，在整个声明周期内 var 可以被重新赋值；&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; val a=1
a: Int = 1

scala&amp;gt; a=2
&amp;lt;console&amp;gt;:8: error: reassignment to val // 不允许重新赋值

scala&amp;gt; var b=1
b: Int = 1

scala&amp;gt; b=2
b: Int = 2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类型推断&quot;&gt;1.3 类型推断&lt;/h3&gt;
&lt;p&gt;在上面的演示中，并没有声明 a 是 Int 类型，但是程序还是把 a 当做 Int 类型，这就是 Scala 的类型推断。在大多数情况下，你都无需指明变量的类型，程序会自动进行推断。如果你想显式的声明类型，可以在变量后面指定，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt;  val c:String=&quot;hello scala&quot;
c: String = hello scala&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;scala解释器&quot;&gt;1.4 Scala解释器&lt;/h3&gt;
&lt;p&gt;在 scala 命令行中，如果没有对输入的值指定赋值的变量，则输入的值默认会赋值给 &lt;code&gt;resX&lt;/code&gt;(其中 X 是一个从 0 开始递增的整数)，&lt;code&gt;res&lt;/code&gt; 是 result 的缩写，这个变量可以在后面的语句中进行引用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; 5
res0: Int = 5

scala&amp;gt; res0*6
res1: Int = 30

scala&amp;gt; println(res1)
30&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二字面量&quot;&gt;二、字面量&lt;/h2&gt;
&lt;p&gt;Scala 和 Java 字面量在使用上很多相似，比如都使用 F 或 f 表示浮点型，都使用 L 或 l 表示 Long 类型。下文主要介绍两者差异部分。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; 1.2
res0: Double = 1.2

scala&amp;gt; 1.2f
res1: Float = 1.2

scala&amp;gt; 1.4F
res2: Float = 1.4

scala&amp;gt; 1
res3: Int = 1

scala&amp;gt; 1l
res4: Long = 1

scala&amp;gt; 1L
res5: Long = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;整数字面量&quot;&gt;2.1 整数字面量&lt;/h3&gt;
&lt;p&gt;Scala 支持 10 进制和 16 进制，但不支持八进制字面量和以 0 开头的整数字面量。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; 012
&amp;lt;console&amp;gt;:1: error: Decimal integer literals may not have a leading zero. (Octal syntax is obsolete.)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串字面量&quot;&gt;2.2 字符串字面量&lt;/h3&gt;
&lt;h4 id=&quot;字符字面量&quot;&gt;1. 字符字面量&lt;/h4&gt;
&lt;p&gt;字符字面量由一对单引号和中间的任意 Unicode 字符组成。你可以显式的给出原字符、也可以使用字符的 Unicode 码来表示，还可以包含特殊的转义字符。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; '\u0041'
res0: Char = A

scala&amp;gt; 'a'
res1: Char = a

scala&amp;gt; '\n'
res2: Char =&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;字符串字面量-1&quot;&gt;2. 字符串字面量&lt;/h4&gt;
&lt;p&gt;字符串字面量由双引号包起来的字符组成。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; &quot;hello world&quot;
res3: String = hello world&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;原生字符串&quot;&gt;3.原生字符串&lt;/h4&gt;
&lt;p&gt;Scala 提供了 &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; 语法，通过三个双引号来表示原生字符串和多行字符串，使用该种方式，原生字符串中的特殊字符不会被转义。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; &quot;hello \tool&quot;
res4: String = hello    ool

scala&amp;gt; &quot;&quot;&quot;hello \tool&quot;&quot;&quot;
res5: String = hello \tool

scala&amp;gt; &quot;&quot;&quot;hello
     | world&quot;&quot;&quot;
res6: String =
hello
world&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;符号字面量&quot;&gt;2.3 符号字面量&lt;/h3&gt;
&lt;p&gt;符号字面量写法为： &lt;code&gt;'标识符&lt;/code&gt; ，这里 标识符可以是任何字母或数字的组合。符号字面量会被映射成 &lt;code&gt;scala.Symbol&lt;/code&gt; 的实例，如:符号字面量 &lt;code&gt;'x&lt;/code&gt; 会被编译器翻译为 &lt;code&gt;scala.Symbol(&quot;x&quot;)&lt;/code&gt;。符号字面量可选方法很少，只能通过 &lt;code&gt;.name&lt;/code&gt; 获取其名称。&lt;/p&gt;
&lt;p&gt;注意：具有相同 &lt;code&gt;name&lt;/code&gt; 的符号字面量一定指向同一个 Symbol 对象，不同 &lt;code&gt;name&lt;/code&gt; 的符号字面量一定指向不同的 Symbol 对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; val sym = 'ID008
sym: Symbol = 'ID008

scala&amp;gt; sym.name
res12: String = ID008&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;插值表达式&quot;&gt;2.4 插值表达式&lt;/h3&gt;
&lt;p&gt;Scala 支持插值表达式。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; val name=&quot;xiaoming&quot;
name: String = xiaoming

scala&amp;gt; println(s&quot;My name is $name,I'm ${2*9}.&quot;)
My name is xiaoming,I'm 18.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三运算符&quot;&gt;三、运算符&lt;/h2&gt;
&lt;p&gt;Scala 和其他语言一样，支持大多数的操作运算符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算术运算符（+，-，*，/，%）&lt;/li&gt;
&lt;li&gt;关系运算符（==，!=，&amp;gt;，&amp;lt;，&amp;gt;=，&amp;lt;=）&lt;/li&gt;
&lt;li&gt;逻辑运算符 (&amp;amp;&amp;amp;，||，!，&amp;amp;，|)&lt;/li&gt;
&lt;li&gt;位运算符 (~，&amp;amp;，|，^，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，&amp;gt;&amp;gt;&amp;gt;)&lt;/li&gt;
&lt;li&gt;赋值运算符 (=，+=，-=，*=，/=，%=，&amp;lt;&amp;lt;=，&amp;gt;&amp;gt;=，&amp;amp;=，^=，|=)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上操作符的基本使用与 Java 类似，下文主要介绍差异部分和注意事项。&lt;/p&gt;
&lt;h3 id=&quot;运算符即方法&quot;&gt;3.1 运算符即方法&lt;/h3&gt;
&lt;p&gt;Scala 的面向对象比 Java 更加纯粹，在 Scala 中一切都是对象。所以对于 &lt;code&gt;1+2&lt;/code&gt;,实际上是调用了 Int 类中名为 &lt;code&gt;+&lt;/code&gt; 的方法，所以 1+2,也可以写成 &lt;code&gt;1.+(2)&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; 1+2
res14: Int = 3

scala&amp;gt; 1.+(2)
res15: Int = 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Int 类中包含了多个重载的 &lt;code&gt;+&lt;/code&gt; 方法，用于分别接收不同类型的参数。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/scala-int+.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;逻辑运算符&quot;&gt;3.2 逻辑运算符&lt;/h3&gt;
&lt;p&gt;和其他语言一样，在 Scala 中 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;，&lt;code&gt;||&lt;/code&gt; 的执行是短路的，即如果左边的表达式能确定整个结果，右边的表达式就不会被执行，这满足大多数使用场景。但是如果你需要在无论什么情况下，都执行右边的表达式，则可以使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;|&lt;/code&gt; 代替。&lt;/p&gt;
&lt;h3 id=&quot;赋值运算符&quot;&gt;3.3 赋值运算符&lt;/h3&gt;
&lt;p&gt;在 Scala 中没有 Java 中的 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 运算符，如果你想要实现类似的操作，只能使用 &lt;code&gt;+=1&lt;/code&gt;，或者 &lt;code&gt;-=1&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; var a=1
a: Int = 1

scala&amp;gt; a+=1

scala&amp;gt; a
res8: Int = 2

scala&amp;gt; a-=1

scala&amp;gt; a
res10: Int = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运算符优先级&quot;&gt;3.4 运算符优先级&lt;/h3&gt;
&lt;p&gt;操作符的优先级如下：优先级由上至下，逐级递减。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/scala-%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;在表格中某个字符的优先级越高，那么以这个字符打头的方法就拥有更高的优先级。如 &lt;code&gt;+&lt;/code&gt; 的优先级大于 &lt;code&gt;&amp;lt;&lt;/code&gt;，也就意味则 &lt;code&gt;+&lt;/code&gt; 的优先级大于以 &lt;code&gt;&amp;lt;&lt;/code&gt; 开头的 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;，所以 &lt;code&gt;2&amp;lt;&amp;lt;2+2&lt;/code&gt; , 实际上等价于 &lt;code&gt;2&amp;lt;&amp;lt;(2+2)&lt;/code&gt; :&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; 2&amp;lt;&amp;lt;2+2
res0: Int = 32

scala&amp;gt; 2&amp;lt;&amp;lt;(2+2)
res1: Int = 32&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对象相等性&quot;&gt;3.5 对象相等性&lt;/h3&gt;
&lt;p&gt;如果想要判断两个对象是否相等，可以使用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt;,这两个操作符可以用于所有的对象，包括 null。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;scala&amp;gt; 1==2
res2: Boolean = false

scala&amp;gt; List(1,2,3)==List(1,2,3)
res3: Boolean = true

scala&amp;gt; 1==1.0
res4: Boolean = true

scala&amp;gt; List(1,2,3)==null
res5: Boolean = false

scala&amp;gt; null==null
res6: Boolean = true&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Martin Odersky . Scala 编程 (第 3 版)[M] . 电子工业出版社 . 2018-1-1&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;&lt;strong&gt;更多大数据系列文章可以参见 GitHub 开源项目&lt;/strong&gt;： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;&lt;strong&gt;大数据入门指南&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 27 Aug 2019 23:11:00 +0000</pubDate>
<dc:creator>黑白影</dc:creator>
<og:description>一、数据类型 1.1 类型支持 Scala 拥有下表所示的数据类型，其中 Byte、Short、Int、Long 和 Char 类型统称为整数类型，整数类型加上 Float 和 Double 统称为数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heibaiying/p/11421732.html</dc:identifier>
</item>
</channel>
</rss>