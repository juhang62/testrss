<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>在阿里云函数计算上部署.NET Core 3.1 - 波多尔斯基</title>
<link>http://www.cnblogs.com/podolski/p/12847037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/podolski/p/12847037.html</guid>
<description>&lt;p&gt;使用阿里云ECS或者其他常见的VPS服务部署应用的时候，需要手动配置环境，并且监测ECS的行为，做补丁之类的，搞得有点复杂。好在很多云厂商（阿里云、Azure等）提供了Serverless服务，借助于Serverless，开发人员可以更加专注于代码的开发，减少运维的成本。&lt;/p&gt;
&lt;p&gt;Azure的部署直接集成在了VS中，非常方便，本文主要介绍一下使用ASP.NET CORE 3.1部署在阿里云Serverless（函数计算）的内容。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;阿里云的函数计算提供了很多运行库，对.NET的支持现在到ASP.NET CORE 2.1，如果我们需要自定义runtime，那么需要使用到函数计算的custom runtime功能。&lt;/p&gt;
&lt;p&gt;首先准备好一个ASP.NET CORE 3.1程序，保证其可以正常运行（Release模式下能够正常工作）。然后做以下改动：&lt;/p&gt;
&lt;h3 id=&quot;修改端口&quot;&gt;修改端口&lt;/h3&gt;
&lt;p&gt;阿里云函数计算自定义runtime使用的是固定的监听端口9000，因此，需要修改Program.cs文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
    WebHost.CreateDefaultBuilder(args)
    //指定监听9000端口
           .UseUrls(&quot;http://*:9000&quot;)
           .UseStartup&amp;lt;Startup&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置发布选项&quot;&gt;设置发布选项&lt;/h3&gt;
&lt;p&gt;VS右键点击工程，点发布，选择高级。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/616093/202005/616093-20200508014352736-1606363931.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于目标是linux系统，因此需要选择目标运行时为&lt;code&gt;linux-64&lt;/code&gt;，部署模式选择独立。（阿里云暂时没有配置.NET Core 3.1 Runtime，需要自带运行组件，但是不要选择单一文件，实测有问题）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/616093/202005/616093-20200508014353532-834857411.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发布完成之后，转到对应的publish目录，将应用程序名称相同的一个无拓展名的文件，重命名为&lt;code&gt;bootstrap&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;windows默认的情况下，这个文件就是可以执行的，如果是其他系统，需要确保这个文件有可执行权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;部署&quot;&gt;部署&lt;/h2&gt;
&lt;p&gt;这里需要借助阿里云函数计算的工具&lt;code&gt;fun.exe&lt;/code&gt;，在正式部署之前，需要先运行&lt;code&gt;fun.exe config&lt;/code&gt;进行配置。具体的使用方式可以参考阿里云的文档。&lt;/p&gt;
&lt;p&gt;部署需要一个配置的文件，我的文件配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;ROSTemplateFormatVersion: '2015-09-01'
Transform: 'Aliyun::Serverless-2018-04-03'
Resources:
  MonitorService:
    Type: 'Aliyun::Serverless::Service'
    Properties:
      Description: 'rsystem'
    RSystemApi:
      Type: 'Aliyun::Serverless::Function'
      Properties:
        Handler: index.handler
        Runtime: custom
        CodeUri: 'RSystemApi/RSystemApi/bin/Release/netcoreapp3.1/publish/'
      Events:
        httpTrigger:
          Type: HTTP
          Properties:
            AuthType: ANONYMOUS
            Methods:
              - GET
              - POST
              - PUT 
              - PATCH
              - DELETE 
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用powershell执行&lt;code&gt;fun.exe deploy -t deploy.yml&lt;/code&gt;，一路下一步，等待提示完成，就可以在函数计算中心看到新部署的服务。&lt;/p&gt;
&lt;p&gt;服务可以通过阿里云的控制台进行访问，但是不推荐，容易有各种各样的问题。建议大家使用自定义域名的方式进行访问，详情见文末参考资料。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽量控制文件压缩后的大小在50M以内，否则部署不会成功，如果需要更大文件的部署，那么可以使用NAS服务。&lt;/li&gt;
&lt;li&gt;fun config可以设置超时时间，文件比较大的情况，deploy超时时间段可能会造成部署失败。（我设置了120s）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;以上步骤也适用于其他语言环境应用custom的情况。详情见&lt;a href=&quot;https://help.aliyun.com/document_detail/132044.html&quot;&gt;https://help.aliyun.com/document_detail/132044.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;顺便吐槽一下阿里云，官方提供custom runtime示例里面有F#，里面是基于.NET CORE 3.1的，直接原生支持多好。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;常见问题：&quot;&gt;常见问题：&lt;/h2&gt;
&lt;p&gt;对于.NET Core 3.1的调试，大多数情况本地能行，那么生产服务器也就可以，当然也有一些例外情况。&lt;/p&gt;
&lt;h3 id=&quot;提示cafilenotfound&quot;&gt;提示CAFileNotFound&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;ErrorCode&quot;: &quot;CAFileNotFound&quot;,
    &quot;ErrorMessage&quot;: &quot;The CA process cannot be started due to missing files:ContainerStartDuration:100000000. CA process cannot be started due to missing file: invalid header field value \&quot;oci runtime error: container_linux.go:247: starting container process caused \\\&quot;exec: \\\\\\\&quot;/code/bootstrap\\\\\\\&quot;: stat /code/bootstrap: no such file or directory\\\&quot;\\n\&quot;Error response from daemon: invalid header field value \&quot;oci runtime error: container_linux.go:247: starting container process caused \\\&quot;exec: \\\\\\\&quot;/code/bootstrap\\\\\\\&quot;: stat /code/bootstrap: no such file or directory\\\&quot;\\n\&quot;&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查一下是不是没有将主文件改名成bootstrap&lt;/p&gt;
&lt;h3 id=&quot;提示caexited&quot;&gt;提示CAExited&lt;/h3&gt;
&lt;p&gt;检查一下代码是不能够在本地正常运行，有没有代码里面强行限制为localhost的情况。&lt;/p&gt;
&lt;h3 id=&quot;提示404错误&quot;&gt;提示404错误&lt;/h3&gt;
&lt;p&gt;使用阿里云的控制台调用的时候，经常出现本地调用成功，远程调用报404的问题。需要注意，阿里云给的调试地址是：&lt;br/&gt;&lt;code&gt;https://xxxxxxxxxxxxxxxx.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/[ServiceName]/[FuctionName]/xxx&lt;/code&gt;的地址模式。这个大概率和我们提供的路由解析规则不符。因此，请尽量使用自定义域名。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;自定义域名必须是已经备案的域名才可以，而且解析需要在阿里云才行。可是暂时不知道什么方法可以单独搞到备案的域名，比较通用的方式是申请域名，并且解析到ECS进行备案，等备案完成，再解析到函数计算服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考资料：&quot;&gt;参考资料：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/731985&quot;&gt;https://yq.aliyun.com/articles/731985&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 May 2020 17:45:00 +0000</pubDate>
<dc:creator>波多尔斯基</dc:creator>
<og:description>使用阿里云ECS或者其他常见的VPS服务部署应用的时候，需要手动配置环境，并且监测ECS的行为，做补丁之类的，搞得有点复杂。好在很多云厂商（阿里云、Azure等）提供了Serverless服务，借助于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/podolski/p/12847037.html</dc:identifier>
</item>
<item>
<title>NLP（二十九）一步一步，理解Self-Attention - 山阴少年</title>
<link>http://www.cnblogs.com/jclian91/p/12846772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/12846772.html</guid>
<description>&lt;p&gt;  本文大部分内容翻译自&lt;a href=&quot;https://towardsdatascience.com/illustrated-self-attention-2d627e33b20a&quot;&gt;Illustrated Self-Attention, Step-by-step guide to self-attention with illustrations and code&lt;/a&gt;，仅用于学习，如有翻译不当之处，敬请谅解！&lt;/p&gt;
&lt;h3 id=&quot;什么是self-attention（自注意力机制）？&quot;&gt;什么是Self-Attention（自注意力机制）？&lt;/h3&gt;
&lt;p&gt;  如果你在想Self-Attention（自注意力机制）是否和Attention（注意力机制）相似，那么答案是肯定的。它们本质上属于同一个概念，拥有许多共同的数学运算。&lt;br/&gt;  一个Self-Attention模块拥有n个输入，返回n个输出。这么模块里面发生了什么？从非专业角度看，Self-Attention（自注意力机制）允许输入之间互相作用（“self”部分），寻找出谁更应该值得注意（“attention”部分）。输出的结果是这些互相作用和注意力分数的聚合。&lt;/p&gt;
&lt;h3 id=&quot;一步步理解self-attention&quot;&gt;一步步理解Self-Attention&lt;/h3&gt;
&lt;p&gt;  理解分为以下几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;准备输入；&lt;/li&gt;
&lt;li&gt;初始化权重；&lt;/li&gt;
&lt;li&gt;获取&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;query&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;为第1个输入计算注意力分数；&lt;/li&gt;
&lt;li&gt;计算softmax;&lt;/li&gt;
&lt;li&gt;将分数乘以values；&lt;/li&gt;
&lt;li&gt;对权重化后的values求和，得到输出1；&lt;/li&gt;
&lt;li&gt;对其余的输入，重复第4-7步。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：实际上，这些数学运算都是向量化的，也就是说，所有的输入都会一起经历这些数学运算。我们将会在后面的代码部分看到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;第一步：准备输入&quot;&gt;第一步：准备输入&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200507223434720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pjbGlhbjkx,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;准备数据&quot;/&gt;&lt;br/&gt;在这个教程中，我们从3个输入开始，每个输入的维数为4。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Input 1: [1, 0, 1, 0] 
Input 2: [0, 2, 0, 2]
Input 3: [1, 1, 1, 1]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二步：初始化权重&quot;&gt;第二步：初始化权重&lt;/h4&gt;
&lt;p&gt;  每个输入必须由三个表示（看下图）。这些输入被称作&lt;code&gt;key&lt;/code&gt;（橙色），&lt;code&gt;query&lt;/code&gt;（红色）&lt;code&gt;value&lt;/code&gt;（紫色）。在这个例子中，我们假设我们想要的表示维数为3。因为每个输入的维数为4，这就意味着每个权重的形状为4×3。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：我们稍后会看到&lt;code&gt;value&lt;/code&gt;的维数也是output的维数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200507224517664.gif#pic_center&quot; alt=&quot;从每个输入中获取key，value，query的表示&quot;/&gt;&lt;br/&gt;  为了获取这些表示，每个输入（绿色）会乘以一个权重的集合得到&lt;code&gt;keys&lt;/code&gt;，乘以一个权重的集合得到&lt;code&gt;queries&lt;/code&gt;，乘以一个权重的集合得到&lt;code&gt;values&lt;/code&gt;。在我们的例子中，我们初始化三个权重的集合如下。&lt;br/&gt;  &lt;code&gt;key&lt;/code&gt;的权重：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[0, 0, 1],
 [1, 1, 0],
 [0, 1, 0],
 [1, 1, 0]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  &lt;code&gt;query&lt;/code&gt;的权重：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[1, 0, 1],
 [1, 0, 0],
 [0, 0, 1],
 [0, 1, 1]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  &lt;code&gt;value&lt;/code&gt;的权重：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[0, 2, 0],
 [0, 3, 0],
 [1, 0, 3],
 [1, 1, 0]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意： 在神经网络设置中，这些权重通常都是一些小的数字，利用随机分布，比如Gaussian, Xavier and Kaiming分布，随机初始化。在训练开始前已经完成初始化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第三步：获取key，query和value；&quot;&gt;第三步：获取&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;query&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;；&lt;/h3&gt;
&lt;p&gt;  现在我们有了3个权重的集合，让我们来给每个输入获取&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;query&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;。&lt;br/&gt;  第1个输入的&lt;code&gt;key&lt;/code&gt;表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;               [0, 0, 1]
[1, 0, 1, 0] x [1, 1, 0] = [0, 1, 1]
               [0, 1, 0]
               [1, 1, 0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  利用相同的权重集合获取第2个输入的&lt;code&gt;key&lt;/code&gt;表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;               [0, 0, 1]
[0, 2, 0, 2] x [1, 1, 0] = [4, 4, 0]
               [0, 1, 0]
               [1, 1, 0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  利用相同的权重集合获取第3个输入的&lt;code&gt;key&lt;/code&gt;表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;               [0, 0, 1]
[1, 1, 1, 1] x [1, 1, 0] = [2, 3, 1]
               [0, 1, 0]
               [1, 1, 0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  更快的方式是将这些运算用向量来描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;               [0, 0, 1]
[1, 0, 1, 0]   [1, 1, 0]   [0, 1, 1]
[0, 2, 0, 2] x [0, 1, 0] = [4, 4, 0]
[1, 1, 1, 1]   [1, 1, 0]   [2, 3, 1]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200507230007824.gif#pic_center&quot; alt=&quot;获取key表示&quot;/&gt;&lt;br/&gt;  让我们用相同的操作来获取每个输入的&lt;code&gt;value&lt;/code&gt;表示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200507230133445.gif#pic_center&quot; alt=&quot;获取value&quot;/&gt;&lt;br/&gt;最后是&lt;code&gt;query&lt;/code&gt;的表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;               [1, 0, 1]
[1, 0, 1, 0]   [1, 0, 0]   [1, 0, 2]
[0, 2, 0, 2] x [0, 0, 1] = [2, 2, 2]
[1, 1, 1, 1]   [0, 1, 1]   [2, 1, 3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200507230240639.gif#pic_center&quot; alt=&quot;获取query&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：实际上，一个偏重向量也许会加到矩阵相乘后的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;第四步：为第1个输入计算注意力分数&quot;&gt;第四步：为第1个输入计算注意力分数&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200507230653550.gif#pic_center&quot; alt=&quot;为第1个输入计算注意力分数（蓝色）&quot;/&gt;&lt;br/&gt;  为了获取注意力分数，我们从输入1的&lt;code&gt;query&lt;/code&gt;（红色）和所有&lt;code&gt;keys&lt;/code&gt;（橙色）的点积开始。因为有3个&lt;code&gt;key&lt;/code&gt;表示（这是由于我们有3个输入），我们得到3个注意力分数（蓝色）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            [0, 4, 2]
[1, 0, 2] x [1, 4, 3] = [2, 4, 4]
            [1, 0, 1]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到我们只用了输入的&lt;code&gt;query&lt;/code&gt;。后面我们会为其他的&lt;code&gt;queries&lt;/code&gt;重复这些步骤。&lt;/p&gt;
&lt;h4 id=&quot;第五步：计算softmax&quot;&gt;第五步：计算softmax&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200507231505965.gif#pic_center&quot; alt=&quot;对注意力分数进行softmax运算&quot;/&gt;&lt;br/&gt;  对这些注意力分数进行softmax函数运算（蓝色部分）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;softmax([2, 4, 4]) = [0.0, 0.5, 0.5]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第六步：-将分数乘以values&quot;&gt;第六步： 将分数乘以values&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202005072317296.gif#pic_center&quot; alt=&quot;将value（紫色）和score（蓝色）相乘得到权重化value的表示&quot;/&gt;&lt;br/&gt;  将每个输入（绿色）的softmax作用后的注意力分数乘以各自对应的&lt;code&gt;value&lt;/code&gt;（紫色）。这会产生3个向量（黄色）。在这个教程中，我们把它们称作&lt;code&gt;权重化value&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1: 0.0 * [1, 2, 3] = [0.0, 0.0, 0.0]
2: 0.5 * [2, 8, 0] = [1.0, 4.0, 0.0]
3: 0.5 * [2, 6, 3] = [1.0, 3.0, 1.5]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第七步：对权重化后的values求和，得到输出1&quot;&gt;第七步：对权重化后的values求和，得到输出1&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200507232414393.gif#pic_center&quot; alt=&quot;将权重后value（黄色）相加得到输出1&quot;/&gt;&lt;br/&gt;  将&lt;code&gt;权重后value&lt;/code&gt;按元素相加得到输出1：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  [0.0, 0.0, 0.0]
+ [1.0, 4.0, 0.0]
+ [1.0, 3.0, 1.5]
-----------------
= [2.0, 7.0, 1.5]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  产生的向量[2.0, 7.0, 1.5]（暗绿色）就是输出1，这是基于输入1的&lt;code&gt;query&lt;/code&gt;表示与其它的&lt;code&gt;keys&lt;/code&gt;，包括它自身的&lt;code&gt;key&lt;/code&gt;互相作用的结果。&lt;/p&gt;
&lt;h4 id=&quot;第八步：对输入2、3，重复第4-7步&quot;&gt;第八步：对输入2、3，重复第4-7步&lt;/h4&gt;
&lt;p&gt;  既然我们已经完成了输入1，我们重复步骤4-7能得到输出2和3。这个可以留给读者自己尝试，相信聪明的你可以做出来。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200507233321491.gif#pic_center&quot; alt=&quot;重复之前的步骤，得到输出2和3&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;p&gt;  这里有PyTorch的实现代码，PyTorch是一个主流的Python深度学习框架。为了能够很好地使用代码片段中的&lt;code&gt;@&lt;/code&gt;运算符, &lt;code&gt;.T&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt;操作，请确保Python≥3.6，PyTorch ≥1.3.1。&lt;/p&gt;
&lt;h4 id=&quot;1-准备输入&quot;&gt;1. 准备输入&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import torch

x = [
  [1, 0, 1, 0], # Input 1
  [0, 2, 0, 2], # Input 2
  [1, 1, 1, 1]  # Input 3
 ]
x = torch.tensor(x, dtype=torch.float32)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2-初始化权重&quot;&gt;2. 初始化权重&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;w_key = [
  [0, 0, 1],
  [1, 1, 0],
  [0, 1, 0],
  [1, 1, 0]
]
w_query = [
  [1, 0, 1],
  [1, 0, 0],
  [0, 0, 1],
  [0, 1, 1]
]
w_value = [
  [0, 2, 0],
  [0, 3, 0],
  [1, 0, 3],
  [1, 1, 0]
]
w_key = torch.tensor(w_key, dtype=torch.float32)
w_query = torch.tensor(w_query, dtype=torch.float32)
w_value = torch.tensor(w_value, dtype=torch.float32)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-获取key，query和value&quot;&gt;3. 获取&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;query&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;
keys = x @ w_key
querys = x @ w_query
values = x @ w_value

print(keys)
# tensor([[0., 1., 1.],
#         [4., 4., 0.],
#         [2., 3., 1.]])

print(querys)
# tensor([[1., 0., 2.],
#         [2., 2., 2.],
#         [2., 1., 3.]])

print(values)
# tensor([[1., 2., 3.],
#         [2., 8., 0.],
#         [2., 6., 3.]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4-为第1个输入计算注意力分数&quot;&gt;4. 为第1个输入计算注意力分数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;attn_scores = querys @ keys.T

# tensor([[ 2.,  4.,  4.],  # attention scores from Query 1
#         [ 4., 16., 12.],  # attention scores from Query 2
#         [ 4., 12., 10.]]) # attention scores from Query 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5-计算softmax&quot;&gt;5. 计算softmax&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from torch.nn.functional import softmax

attn_scores_softmax = softmax(attn_scores, dim=-1)
# tensor([[6.3379e-02, 4.6831e-01, 4.6831e-01],
#         [6.0337e-06, 9.8201e-01, 1.7986e-02],
#         [2.9539e-04, 8.8054e-01, 1.1917e-01]])

# For readability, approximate the above as follows
attn_scores_softmax = [
  [0.0, 0.5, 0.5],
  [0.0, 1.0, 0.0],
  [0.0, 0.9, 0.1]
]
attn_scores_softmax = torch.tensor(attn_scores_softmax)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6-将分数乘以values&quot;&gt;6. 将分数乘以values&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;weighted_values = values[:,None] * attn_scores_softmax.T[:,:,None]

# tensor([[[0.0000, 0.0000, 0.0000],
#          [0.0000, 0.0000, 0.0000],
#          [0.0000, 0.0000, 0.0000]],
# 
#         [[1.0000, 4.0000, 0.0000],
#          [2.0000, 8.0000, 0.0000],
#          [1.8000, 7.2000, 0.0000]],
# 
#         [[1.0000, 3.0000, 1.5000],
#          [0.0000, 0.0000, 0.0000],
#          [0.2000, 0.6000, 0.3000]]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;7-对权重化后的values求和，得到输出&quot;&gt;7. 对权重化后的values求和，得到输出&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;outputs = weighted_values.sum(dim=0)

# tensor([[2.0000, 7.0000, 1.5000],  # Output 1
#         [2.0000, 8.0000, 0.0000],  # Output 2
#         [2.0000, 7.8000, 0.3000]]) # Output 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：PyTorch已经提供了这个API，名字为&lt;code&gt;nn.MultiheadAttention&lt;/code&gt;。但是，这个API需要你提供PyTorch的Tensor形式的key，value，query。还有，这个模块的输出会经历一个线性变换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;自己实现？&quot;&gt;自己实现？&lt;/h3&gt;
&lt;p&gt;  以下是笔者自己写的部分。&lt;br/&gt;  对于不熟悉PyTorch的读者来说，上述的向量操作理解起来有点困难，因此，笔者自己用简单的Python代码实现了一遍上述Self-Attention的过程。&lt;br/&gt;  完整的Python代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-

from typing import List
import math
from pprint import pprint

x = [[1, 0, 1, 0], # Input 1
     [0, 2, 0, 2], # Input 2
     [1, 1, 1, 1]  # Input 3
    ]

w_key = [[0, 0, 1],
        [1, 1, 0],
        [0, 1, 0],
        [1, 1, 0]
        ]

w_query = [[1, 0, 1],
            [1, 0, 0],
            [0, 0, 1],
            [0, 1, 1]
          ]

w_value = [[0, 2, 0],
            [0, 3, 0],
            [1, 0, 3],
            [1, 1, 0]
          ]


# vector dot of two vectors
def vector_dot(list1: List[float or int], list2: List[float or int]) -&amp;gt; float or int:
    dot_sum = 0
    for element_i, element_j in zip(list1, list2):
        dot_sum += element_i * element_j

    return dot_sum


# get weights matrix by x, using matrix multiplication
def get_weights_matrix_by_x(x, weight_matrix):
    x_matrix = []
    for i in range(len(x)):
        x_row = []
        for j in range(len(weight_matrix[0])):
            x_row.append(vector_dot(x[i], [_[j] for _ in weight_matrix]))

        x_matrix.append(x_row)

    return x_matrix


# softmax function
def softmax(x: List[float or int]) -&amp;gt; List[float or int]:
    x_sum = sum([math.exp(_) for _ in x])
    return [math.exp(_)/x_sum for _ in x]


x_key = get_weights_matrix_by_x(x, w_key)
x_value = get_weights_matrix_by_x(x, w_value)
x_query = get_weights_matrix_by_x(x, w_query)
# print(x_key)
# print(x_value)
# print(x_query)

outputs = []
for query in x_query:
    score_list = [vector_dot(query, key) for key in x_key]
    softmax_score_list = softmax(score_list)

    weights_list = []
    for i in range(len(softmax_score_list)):
        weights = [softmax_score_list[i] * _ for _ in x_value[i]]
        weights_list.append(weights)

    output = []
    for j in range(len(weights_list[0])):
        output.append(sum([_[j] for _ in weights_list]))

    outputs.append(output)

pprint(outputs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[1.9366210616669624, 6.683105308334811, 1.5950684074995565],
 [1.9999939663351456, 7.9639915951322156, 0.0539764053125496],
 [1.9997046127769653, 7.759892254657784, 0.3583892946751152]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;  本文主要讲述了如何一步一步来实现Self-Attention机制，对于想要自己实现算法的读者来说，值得一读。&lt;br/&gt;  本文分享到此结束，感谢大家的阅读~&lt;/p&gt;
</description>
<pubDate>Thu, 07 May 2020 15:58:00 +0000</pubDate>
<dc:creator>山阴少年</dc:creator>
<og:description>NLP（二十九）一步一步，理解Self-Attention</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jclian91/p/12846772.html</dc:identifier>
</item>
<item>
<title>行为型设计模式 - 备忘录模式详解 - 农夫三拳有点疼~</title>
<link>http://www.cnblogs.com/songjilong/p/12846761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songjilong/p/12846761.html</guid>
<description>&lt;p&gt;备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200507233754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Originator（发起者）&lt;/strong&gt;：记录当前的状态，负责创建和恢复备忘录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Memento（备忘录）&lt;/strong&gt;：负责存储发起者的状态，在需要的时候提供发起人需要的状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Caretaker（管理者）&lt;/strong&gt;：管理备忘录&lt;/p&gt;

&lt;p&gt;（这里我们以单角色、单状态、单备份来演示，思想是相同的，无非是存储数据结构上的区别）&lt;/p&gt;
&lt;p&gt;备忘录角色，定义了存储状态的变量，可以根据实际需求定义对应的存储对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Memento {
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发起者角色，存储状态，并且可以创建备忘录和将状态恢复为备忘录的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Originator {
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Memento createMemento() {
        Memento memento = new Memento();
        memento.setState(state);
        return memento;
    }

    public void restoreMemento(Memento memento) {
        this.state = memento.getState();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;管理者角色，管理了备忘录&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Caretaker {
    private Memento memento;

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    @Test
    public void test() {
        //设置初始状态
        Originator originator = new Originator();
        originator.setState(&quot;状态1&quot;);
        System.out.println(&quot;初始状态：&quot; + originator.getState());

        //创建管理者
        Caretaker caretaker = new Caretaker();
        caretaker.setMemento(originator.createMemento());

        //更新状态
        originator.setState(&quot;状态2&quot;);
        System.out.println(&quot;跟新状态：&quot; + originator.getState());

        //恢复状态
        originator.restoreMemento(caretaker.getMemento());
        System.out.println(&quot;恢复状态：&quot; + originator.getState());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;初始状态：状态1
跟新状态：状态2
恢复状态：状态1
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给用户提供了一种可以恢复状态的机制，使用户可以比较方便的回退到某个历史的状态&lt;/li&gt;
&lt;li&gt;实现了信息的封装，使用户不需要关心备忘录中状态的保存细节&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在实际应用中，备忘录模式都是多状态和多备份的，发起人角色的状态需要存储到备忘录对象中，对资源的消耗是比较严重的，为了节约内存，可以配合原型模式使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;游戏的存档&lt;/li&gt;
&lt;li&gt;CTRL + Z 撤销&lt;/li&gt;
&lt;li&gt;浏览器的后退&lt;/li&gt;
&lt;li&gt;数据库的事务管理&lt;/li&gt;
&lt;li&gt;... ...&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 07 May 2020 15:57:00 +0000</pubDate>
<dc:creator>农夫三拳有点疼~</dc:creator>
<og:description>基本介绍 备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态 模式结构 Originato</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/songjilong/p/12846761.html</dc:identifier>
</item>
<item>
<title>树莓派4B踩坑指南 - （15）搭建在线python IDE - Bowen404</title>
<link>http://www.cnblogs.com/bowen404/p/12846548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bowen404/p/12846548.html</guid>
<description>&lt;blockquote readability=&quot;6.6121495327103&quot;&gt;
&lt;p&gt;今天想在树莓派上自己搭一个在线的python IDE，于是找到了一篇教程--Fred913大神的&lt;a href=&quot;https://www.cnblogs.com/sheng-fan/p/11357074.html&quot;&gt;从头开始制作OJ-在线IDE的搭建&lt;/a&gt;&lt;br/&gt;自己尝试动手做了一下, 还是发现不少细节需要注意, 记录在此&lt;br/&gt;如果不知道怎么用树莓派搭建网站的可以参考我之前的文章: &lt;a href=&quot;https://www.cnblogs.com/bowen404/p/11979429.html&quot;&gt;树莓派4B踩坑指南 - （11）免费搭建网站（宝塔，花生壳）&lt;/a&gt;&lt;br/&gt;demo地址: &lt;a href=&quot;http://bowen.51mypc.cn/editor/&quot;&gt;http://bowen.51mypc.cn/editor/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;Nginx/Apache&lt;/li&gt;
&lt;li&gt;Python3&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-apipythonphp&quot;&gt;1) /api/python.php&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;网站根目录下新建文件夹&lt;code&gt;api&lt;/code&gt;, 注意这里需要sudo或者su权限(下同), 然后使用&lt;code&gt;mkdir api&lt;/code&gt;来创建&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch python.php&lt;/code&gt; # 在&lt;code&gt;api&lt;/code&gt;中新建文件&lt;code&gt;python.php&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nano python.php&lt;/code&gt; # 在文件中粘贴以下内容&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
//Powered By ShengFAN
//使用世界上最好的语言PHP进行开发-_-
$randint = rand();//为用户的代码取一个随机数作为唯一码
$f = fopen(&quot;/tmp/usrcode&quot;.$randint.&quot;.py&quot;, &quot;w&quot;);
fwrite($f,$_GET['code']);
fclose($f);
echo str_replace(&quot;\n&quot;,&quot;&amp;lt;br&amp;gt;&quot;,passthru(&quot;python3 /tmp/usrcode&quot;.$randint.&quot;.py 2&amp;gt;&amp;amp;1&quot;)); //把换行转为html格式
unlink(&quot;/tmp/usrcode&quot;.$randint.&quot;.py&quot;); //删除用户代码，以免造成tmp目录拥挤
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;保存退出&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;2-editorsrc&quot;&gt;2) /editor/src&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;回到网站根目录, &lt;code&gt;mkdir editor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;去这里(&lt;a href=&quot;https://github.com/ajaxorg/ace-builds&quot;&gt;https://github.com/ajaxorg/ace-builds&lt;/a&gt;)点&lt;code&gt;download zip&lt;/code&gt;, 然后把&lt;code&gt;ace-builds-master.zip&lt;/code&gt;随便解压到哪个地方, 然后把&lt;code&gt;ace-builds-master&lt;/code&gt;里边所有的东西复制到&lt;code&gt;editor&lt;/code&gt;文件夹, 如&lt;code&gt;cp -r /home/pi/Desktop/n/ace-builds-master/* /www/wwwroot/bowen.51mypc.cn/editor/&lt;/code&gt;, 命令中的 &lt;code&gt;-r&lt;/code&gt; 和 &lt;code&gt;/*&lt;/code&gt; 不要漏了. 复制完确认一下应该有这样的一个目录:&lt;code&gt;/editor/src&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新建&lt;code&gt;index.php&lt;/code&gt;, &lt;code&gt;touch index.php&lt;/code&gt;(这里跟原文有出入, 下载的包里没有index.html)&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;index.php&lt;/code&gt;中放入如下代码(这里跟原文有出入, 原文写的是作者自己的网址, 这里删掉了php和html的选项并将python.php的地址改成了相对路径):&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;FredTools IDE&amp;lt;/title&amp;gt;
    &amp;lt;link href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdn.staticfile.org/jquery-cookie/1.4.1/jquery.cookie.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
      function runcode(code,type)
      {
        if(type == &quot;python&quot;)
        {
          console.log(code);
          var xmlhttp;
          if (window.XMLHttpRequest)
          {
            //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
            xmlhttp=new XMLHttpRequest();
          }
          else
          {
            // IE6, IE5 浏览器执行代码
            xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
          }
          xmlhttp.open(&quot;GET&quot;,&quot;../api/python.php?code=&quot; + escape(code),false);
          xmlhttp.send();
          var data = xmlhttp.responseText;
          $(&quot;#output&quot;).html(&quot;&amp;lt;pre class=\&quot;fillall\&quot;&amp;gt;&quot; + data.replace(/&amp;lt;/g,&quot;&amp;amp;lt;&quot;).replace(/&amp;gt;/g,&quot;&amp;amp;gt;&quot;).replace(/\n/g,&quot;&amp;lt;br&amp;gt;&quot;) + &quot;&amp;lt;/pre&amp;gt;&quot;);
        }
      }
    &amp;lt;/script&amp;gt;
    &amp;lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&amp;gt;
      #editor {
        margin: 0;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }
      .container {
        margin: 0;
        //position: absolute;
        top: 0;
        bottom: 0;
      }
      #editordiv {
        margin: 0;
        position: absolute;
        top: 0;
        bottom: 0;
        left:0;
        right:58.33333333333334%;
      }
      #iframediv {
        margin: 0;
        position: absolute;
        top: 0;
        bottom: 50%;
        left: 41.66666666666667%;
        right:16.66666666666667%;
      }
      #stepdiv {
        margin: 0;
        position: absolute;
        top: 50%;
        bottom: 0;
        left: 41.66666666666667%;
        right:16.66666666666667%;
      }
      .col-md-2 {
        margin: 0;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 83.33333333333334%;
        right:0;
      }
    &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;

    &amp;lt;div class=&quot;container&quot;&amp;gt;
      &amp;lt;div class=&quot;col-md-5 column&quot; id=&quot;editordiv&quot;&amp;gt;
        &amp;lt;pre id=&quot;editor&quot;&amp;gt;&amp;lt;/pre&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;col-md-5 column&quot; id=&quot;iframediv&quot;&amp;gt;
        &amp;lt;h3&amp;gt;运行结果：&amp;lt;/h3&amp;gt;
        &amp;lt;div id=&quot;output&quot;&amp;gt;&amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;col-md-5 column&quot; id=&quot;stepdiv&quot;&amp;gt;
        &amp;lt;h3 id=&quot;stepcount&quot;&amp;gt;自由模式&amp;lt;/h3&amp;gt;
        &amp;lt;p id=&quot;steptext&quot;&amp;gt;在此模式下，你可以自由的使用FredTools IDE。&amp;lt;/p&amp;gt;
        &amp;lt;p id=&quot;task&quot;&amp;gt;任务：无&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;col-md-2 column&quot;&amp;gt;
        &amp;lt;!-- 更改语言-start --&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
          &amp;lt;select name=&quot;language&quot; id=&quot;language&quot; class=&quot;form-control&quot;&amp;gt;
            &amp;lt;option value=&quot;python&quot; selected&amp;gt;Python（.py）&amp;lt;/option&amp;gt;
          &amp;lt;/select&amp;gt;

          &amp;lt;button id=&quot;changelang&quot; class=&quot;btn btn-default&quot;&amp;gt;
            更改语言
          &amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!-- 更改语言-end --&amp;gt;
        &amp;lt;br&amp;gt;
        &amp;lt;!-- 更改皮肤-end --&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
          &amp;lt;select name=&quot;skin&quot; id=&quot;skin&quot; class=&quot;form-control&quot;&amp;gt;
            &amp;lt;?php require &quot;../skin.html&quot;; ?&amp;gt;
          &amp;lt;/select&amp;gt;
          &amp;lt;button id=&quot;changeskin&quot; class=&quot;btn btn-default&quot;&amp;gt;
            更改皮肤
          &amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!-- 更改语言-end --&amp;gt;
        &amp;lt;button class=&quot;btn btn-default&quot; id=&quot;cheak&quot;&amp;gt;
          &amp;lt;span class=&quot;glyphicon glyphicon-play-circle&quot;&amp;gt;&amp;lt;/span&amp;gt;运行代码
        &amp;lt;/button&amp;gt;
        &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
          &amp;lt;input type=&quot;text&quot; id=&quot;filename&quot; placeholder=&quot;请输入此文件文件名......&quot; class=&quot;form-control&quot;&amp;gt;
          &amp;lt;button class=&quot;btn btn-default&quot; id=&quot;savecode&quot;&amp;gt;
            &amp;lt;span class=&quot;glyphicon glyphicon-save&quot;&amp;gt;&amp;lt;/span&amp;gt;保存代码（通过Cookie）
          &amp;lt;/button&amp;gt;
          &amp;lt;button class=&quot;btn btn-default&quot; id=&quot;readcode&quot;&amp;gt;
            &amp;lt;span class=&quot;glyphicon glyphicon-open&quot;&amp;gt;&amp;lt;/span&amp;gt;读入代码（通过Cookie）
          &amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;src-noconflict/ace.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
      var editor = ace.edit(&quot;editor&quot;);
      editor.setOptions({enableLiveAutocompletion: true});
      editor.setTheme(&quot;ace/theme/Chrome&quot;);
      editor.session.setMode(&quot;ace/mode/python&quot;);
      $(&quot;#changelang&quot;).click(function(){
        editor.session.setMode(&quot;ace/mode/&quot; + $(&quot;#language&quot;).val());
      });
      $(&quot;#changeskin&quot;).click(function(){
        editor.setTheme(&quot;ace/theme/&quot; + $(&quot;#skin&quot;).val());
      });
      $(&quot;#cheak&quot;).click(function(){
        var result = runcode(editor.getValue(), $(&quot;#language&quot;).val());
      });
      $(&quot;#savecode&quot;).click(function(){
        $.cookie(&quot;File-&quot; + $(&quot;#filename&quot;).val(), editor.getValue());
      });
      $(&quot;#readcode&quot;).click(function(){
        editor.setValue($.cookie(&quot;File-&quot; + $(&quot;#filename&quot;).val()));
      });
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-调试运行&quot;&gt;3) 调试运行&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;满心欢喜的打开&lt;code&gt;bowen.51mypc.cn/editor&lt;/code&gt;, 然后就悲剧了:&lt;img src=&quot;https://img2020.cnblogs.com/blog/1044828/202005/1044828-20200507234157540-1861225697.jpg&quot; alt=&quot;无法使用&quot;/&gt;&lt;/li&gt;
&lt;li&gt;仔细读代码发现里边有一行&lt;code&gt;&amp;lt;?php require &quot;../skin.html&quot;; ?&amp;gt;&lt;/code&gt; 哦, 原来没有这个文件所以卡这了, 那就回去新建一个吧&lt;/li&gt;
&lt;li&gt;回到网站根目录, &lt;code&gt;nano skin.html&lt;/code&gt;, 写入一行&lt;code&gt;&amp;lt;option value='chrome'&amp;gt;Chrome&amp;lt;/option&amp;gt;&lt;/code&gt;, 保存退出. (这里跟原文有出入, 因为实际上并没有皮肤可以换, 就把其他的删掉了...)&lt;/li&gt;
&lt;li&gt;刷新页面, 诶, 果然可以了...吗? &lt;img src=&quot;https://img2020.cnblogs.com/blog/1044828/202005/1044828-20200507234741702-1090515190.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;百度了一下, 这个问题应该是&lt;code&gt;php.ini&lt;/code&gt;中的&lt;code&gt;passthru函数&lt;/code&gt;被禁用了, 本想去找这个ini文件, 后来想想这种东西估计宝塔面板里就有,就去找了一下, 还真找到了: &lt;img src=&quot;https://img2020.cnblogs.com/blog/1044828/202005/1044828-20200507234930925-1421788028.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;大功告成! &lt;code&gt;print(&quot;hello world&quot;)&lt;/code&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1044828/202005/1044828-20200507235017870-2002055605.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;待解决问题&quot;&gt;待解决问题&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;试了下, 这里用不了input()函数(&lt;code&gt;EOFError: EOF when reading a line&lt;/code&gt;), 估计是交互性没法满足, 希望后续能补上这个不足吧!&lt;/li&gt;
&lt;li&gt;不知道性能占用怎么样, 如果多人同时调用的话, 有可能会有新问题, 以后再测试.&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 07 May 2020 15:56:00 +0000</pubDate>
<dc:creator>Bowen404</dc:creator>
<og:description>今天想在树莓派上自己搭一个在线的python IDE，于是找到了一篇教程 Fred913大神的 &amp;quot;从头开始制作OJ 在线IDE的搭建&amp;quot; 自己尝试动手做了一下, 还是发现不少细节需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bowen404/p/12846548.html</dc:identifier>
</item>
<item>
<title>【Java8新特性】还没搞懂函数式接口？赶快过来看看吧！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/12846649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/12846649.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Java8中内置了一些在开发中常用的函数式接口，极大的提高了我们的开发效率。那么，问题来了，你知道都有哪些函数式接口吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;函数式接口总览&quot;&gt;函数式接口总览&lt;/h2&gt;
&lt;p&gt;这里，我使用表格的形式来简单说明下Java8中提供的函数式接口。&lt;/p&gt;
&lt;h3 id=&quot;四大核心函数式接口&quot;&gt;四大核心函数式接口&lt;/h3&gt;
&lt;p&gt;首先，我们来看四大核心函数式接口，如下所示。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数式接口&lt;/th&gt;
&lt;th&gt;参数类型&lt;/th&gt;
&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Consumer消费型接口&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;对类型为T的对象应用操作，接口定义的方法：void accept(T t)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Supplier供给型接口&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;返回类型为T的对象，接口定义的方法：T get()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;Function&amp;lt;T, R&amp;gt;函数式接口&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;对类型为T的对象应用操作，并R类型的返回结果。接口定义的方法：R apply(T t)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Predicate断言型接口&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;确定类型为T的对象是否满足约束条件，并返回boolean类型的数据。接口定义的方法：boolean test(T t)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;其他函数接口&quot;&gt;其他函数接口&lt;/h3&gt;
&lt;p&gt;除了四大核心函数接口外，Java8还提供了一些其他的函数式接口。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数式接口&lt;/th&gt;
&lt;th&gt;参数类型&lt;/th&gt;
&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;BiFunction(T, U, R)&lt;/td&gt;
&lt;td&gt;T, U&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;对类型为T,U的参数应用操作，返回R类型的结果。接口定义的方法：R apply(T t, U u)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;UnaryOperator（Function子接口）&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;对类型为T的对象进行一 元运算， 并返回T类型的 结果。 包含方法为 T apply(T t)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;BinaryOperator (BiFunction 子接口)&lt;/td&gt;
&lt;td&gt;T, T&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;对类型为T的对象进行二 元运算， 并返回T类型的 结果。 包含方法为 T apply(T t1, T t2)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;BiConsumer&amp;lt;T, U&amp;gt;&lt;/td&gt;
&lt;td&gt;T, U&lt;/td&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;对类型为T, U 参数应用 操作。 包含方法为 void accept(T t, U u)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ToIntFunction&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;计算int值的函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ToLongFunction&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;计算long值的函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ToDoubleFunction&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;计算double值的函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IntFunction&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;参数为int 类型的函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LongFunction&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;参数为 long类型的函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DoubleFunction&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;参数为double类型的函数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;四大核心函数式接口-2&quot;&gt;四大核心函数式接口&lt;/h2&gt;
&lt;h2 id=&quot;consumer接口&quot;&gt;Consumer接口&lt;/h2&gt;
&lt;h3 id=&quot;1接口说明&quot;&gt;1.接口说明&lt;/h3&gt;
&lt;p&gt;Consumer接口是消费性接口，无返回值。Java8中对Consumer的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Consumer&amp;lt;T&amp;gt; {

    void accept(T t);
    
    default Consumer&amp;lt;T&amp;gt; andThen(Consumer&amp;lt;? super T&amp;gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&amp;gt; { accept(t); after.accept(t); };
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2使用示例&quot;&gt;2.使用示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void handlerConsumer(Integer number, Consumer&amp;lt;Integer&amp;gt; consumer){
    consumer.accept(number);
}

@Test
public void test1(){
    this.handlerConsumer(10000, (i) -&amp;gt; System.out.println(i));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;supplier接口&quot;&gt;Supplier接口&lt;/h2&gt;
&lt;h3 id=&quot;1接口说明-2&quot;&gt;1.接口说明&lt;/h3&gt;
&lt;p&gt;Supplier接口是供给型接口，有返回值，Java8中对Supplier接口的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Supplier&amp;lt;T&amp;gt; {
    T get();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2使用示例-2&quot;&gt;2.使用示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public List&amp;lt;Integer&amp;gt; getNumberList(int num, Supplier&amp;lt;Integer&amp;gt; supplier){
    List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    for(int i = 0; i &amp;lt; num; i++){
        list.add(supplier.get())
    }
    return list;
}

@Test
public void test2(){
    List&amp;lt;Integer&amp;gt; numberList = this.getNumberList(10, () -&amp;gt; new Random().nextInt(100));
    numberList.stream().forEach(System.out::println);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;function接口&quot;&gt;Function接口&lt;/h2&gt;
&lt;h3 id=&quot;1接口说明-3&quot;&gt;1.接口说明&lt;/h3&gt;
&lt;p&gt;Function接口是函数型接口，有返回值，Java8中对Function接口的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    
    R apply(T t);
    
    default &amp;lt;V&amp;gt; Function&amp;lt;V, R&amp;gt; compose(Function&amp;lt;? super V, ? extends T&amp;gt; before) {
        Objects.requireNonNull(before);
        return (V v) -&amp;gt; apply(before.apply(v));
    }

    default &amp;lt;V&amp;gt; Function&amp;lt;T, V&amp;gt; andThen(Function&amp;lt;? super R, ? extends V&amp;gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&amp;gt; after.apply(apply(t));
    }

    static &amp;lt;T&amp;gt; Function&amp;lt;T, T&amp;gt; identity() {
        return t -&amp;gt; t;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2使用示例-3&quot;&gt;2.使用示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String handlerString(String str, Function&amp;lt;String, String&amp;gt; func){
    return func.apply(str);
}

@Test
public void test3(){
    String str = this.handlerString(&quot;binghe&quot;, (s) -&amp;gt; s.toUpperCase());
    System.out.println(str);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;predicate接口&quot;&gt;Predicate接口&lt;/h2&gt;
&lt;h3 id=&quot;1接口说明-4&quot;&gt;1.接口说明&lt;/h3&gt;
&lt;p&gt;Predicate接口是断言型接口，返回值类型为boolean，Java8中对Predicate接口的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Predicate&amp;lt;T&amp;gt; {

    boolean test(T t);

    default Predicate&amp;lt;T&amp;gt; and(Predicate&amp;lt;? super T&amp;gt; other) {
        Objects.requireNonNull(other);
        return (t) -&amp;gt; test(t) &amp;amp;&amp;amp; other.test(t);
    }

    default Predicate&amp;lt;T&amp;gt; negate() {
        return (t) -&amp;gt; !test(t);
    }

    default Predicate&amp;lt;T&amp;gt; or(Predicate&amp;lt;? super T&amp;gt; other) {
        Objects.requireNonNull(other);
        return (t) -&amp;gt; test(t) || other.test(t);
    }

    static &amp;lt;T&amp;gt; Predicate&amp;lt;T&amp;gt; isEqual(Object targetRef) {
        return (null == targetRef)
                ? Objects::isNull
                : object -&amp;gt; targetRef.equals(object);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2使用示例-4&quot;&gt;2.使用示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public List&amp;lt;String&amp;gt; filterString(List&amp;lt;String&amp;gt; list, Predicate&amp;lt;String&amp;gt; predicate){
    List&amp;lt;String&amp;gt; strList = new ArrayList&amp;lt;&amp;gt;();
    for(String str : list){
        if(predicate.test(str)){
            strList.add(str);
        }
    }
    return strList;
}

@Test
public void test4(){
    List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;Hello&quot;, &quot;Lambda&quot;, &quot;binghe&quot;, &quot;lyz&quot;, &quot;World&quot;);
    List&amp;lt;String&amp;gt; strList = this.filterString(list, (s) -&amp;gt; s.length() &amp;gt;= 5);
    strList.stream().forEach(System.out::println);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：只要我们学会了Java8中四大核心函数式接口的用法，其他函数式接口我们也就知道如何使用了！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习Java8新特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，附上Java8新特性核心知识图，祝大家在学习Java8新特性时少走弯路。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1729473/202005/1729473-20200507233306440-1608200870.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 May 2020 15:34:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 Java8中内置了一些在开发中常用的函数式接口，极大的提高了我们的开发效率。那么，问题来了，你知道都有哪些函数式接口吗？ 函数式接口总览 这里，我使用表格的形式来简单说明下Java8中提供的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/12846649.html</dc:identifier>
</item>
<item>
<title>如何在C#/.NET Core中使用责任链模式 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/12846451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/12846451.html</guid>
<description>&lt;p&gt;最近我有一个朋友在研究经典的“Gang Of Four”设计模式。他经常来询问我在实际业务应用中使用了哪些设计模式。单例模式、工厂模式、中介者模式 - 都是我之前使用过，甚至写过相关文章的模式。但是有一种模式是我还没有写过文章，即责任链模式。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;190.66778460085&quot;&gt;
&lt;blockquote readability=&quot;2.3863636363636&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://dotnetcoretutorials.com/2020/04/19/chain-of-responsbility-pattern-in-c-net-core/&quot;&gt;Chain Of Responsbility Pattern In C#/.NET Core&lt;/a&gt;&lt;br/&gt;作者：&lt;strong&gt;Wade&lt;/strong&gt;&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/65831/202005/65831-20200507230714777-1389216687.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近我有一个朋友在研究经典的“Gang Of Four”设计模式。他经常来询问我在实际业务应用中使用了哪些设计模式。单例模式、工厂模式、中介者模式 - 都是我之前使用过，甚至写过相关文章的模式。但是有一种模式是我还没有写过文章，即责任链模式。&lt;/p&gt;

&lt;p&gt;责任链模式（之前我经常称之为命令链模式）是一种允许以使用分层方式”处理“对象的模式。在维基百科中的经典定义是&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在面向对象设计中，责任链模式是一种由命令对象源及其一系列处理对象组成的设计模式。每个处理对象包含了它可以处理的命令对象的逻辑，其余的将传递给链中的下一个处理对象。当然，这里还存在一种将新的处理对象追加到链尾的机制。因此责任链是&lt;code&gt;If..else if.. else if...else...endif&lt;/code&gt;的面向对象版本。其优点是可以在运行时动态重新排列或配置条件操作块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也许你会觉着上面的概念描述过于抽象，不容易理解，那么下面让我们来看一个真实生活中的例子。&lt;/p&gt;
&lt;p&gt;这里假设我们拥有一家银行，银行里面有3个级别的员工，分别是“柜员”、“主管”、“银行经理”。如果有人来取款，“柜员”只允许10,000美元以下的取款操作。如果金额超过10,000美元，那么它的请求将传递给“主管”。“主管”可以处理不超过100,000美元的请求，但前提是该账户在必须有身份证ID。如果没有身份证ID，则当前请求必须被拒绝。如果取款金额超过100,000美元，则当前请求可以转交给“银行经理”，“银行经理”可以批准任何取款金额，因为如果有人取超过100,000美元的金额，他们就是VIP, 我们不在乎VIP的身份证ID和其他规定。&lt;/p&gt;
&lt;p&gt;这就是我们前面讨论的分层“链”，每个人都尝试处理当前请求，如果没有满足要求，就传递给下一个。如果我们将这种场景转换成代码，就是我们所说的责任链模式。但是在这之前，让我们先来看一个糟糕的实现方法。&lt;/p&gt;

&lt;p&gt;下面我们先使用If/Else块来解决当前问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class BankAccount
{
    bool idOnRecord { get; set; }

    void WithdrawMoney(decimal amount)
    {
        // 柜员处理
        if(amount &amp;lt; 10000)
        {
            Console.WriteLine(&quot;柜员提取的金额&quot;);
        } 
        // 主管处理
        else if (amount &amp;lt; 100000)
        {
            if(!idOnRecord)
            {
                throw new Exception(&quot;客户没有身份证ID&quot;);
            }

            Console.WriteLine(&quot;主管提取的金额&quot;);
        }
        else
        {
            Console.WriteLine(&quot;银行经理提取的金额&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上这种实现方式有几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加一种新的员工级别会相当困难，因为IF/Else代码块看起来太乱了&lt;/li&gt;
&lt;li&gt;“主管”检查身份证ID的逻辑在某种程度上很难进行单元测试，因为它必须首先通过其他的检查&lt;/li&gt;
&lt;li&gt;虽然现在我们只定义了提款金额的逻辑，但是如果在将来我们想要添加其他检查（例如：VIP客户始终由主管来处理）, 这种逻辑将很难管理，并且很容易失控。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面让我们重写一些这部分代码。与之前不同，这里我们创建一些“员工”对象，里面封装了他们的处理逻辑。这里最重要的是，我们需要给每个员工对象指定一个直属上级，以便当他们处理不了当前请求的时候，可以将请求传递给直属上级。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;interface IBankEmployee
{
    IBankEmployee LineManager { get; }
    void HandleWithdrawRequest(BankAccount account, decimal amount);
}

class Teller : IBankEmployee
{
    public IBankEmployee LineManager { get; set; }

    public void HandleWithdrawRequest(BankAccount account, decimal amount)
    {
        if(amount &amp;gt; 10000)
        {
            LineManager.HandleWithdrawRequest(account, amount);
            return;
        }

        Console.WriteLine(&quot;柜员提取的金额&quot;);
    }
}

class Supervisor : IBankEmployee
{
    public IBankEmployee LineManager { get; set; }

    public void HandleWithdrawRequest(BankAccount account, decimal amount)
    {
        if (amount &amp;gt; 100000)
        {
            LineManager.HandleWithdrawRequest(account, amount);
            return;
        }

        if(!account.idOnRecord)
        {
            throw new Exception(&quot;客户没有身份证ID&quot;);
        }

        Console.WriteLine(&quot;主管提取的金额&quot;);
    }
}

class BankManager : IBankEmployee
{
    public IBankEmployee LineManager { get; set; }

    public void HandleWithdrawRequest(BankAccount account, decimal amount)
    {
        Console.WriteLine(&quot;银行经理提取的金额&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过指定上级的方式创建出责任链。这看起来很像一个组织结构图。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var bankManager = new BankManager();
var bankSupervisor = new Supervisor { LineManager = bankManager };
var frontLineStaff = new Teller { LineManager = bankSupervisor };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们可以创建一个&lt;code&gt;BankAccount&lt;/code&gt;类，并将取款方法转换为由前台员工处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class BankAccount
{
    public bool idOnRecord { get; set; }

    public void WithdrawMoney(IBankEmployee frontLineStaff, decimal amount)
    {
         frontLineStaff.HandleWithdrawRequest(this, amount);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，当我们进行取款请求的时候，“柜员”总是第一个来处理，如果处理不了，它会自动将请求发给直属领导。这种模式的优雅之处有以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;链中的后续子项并不需要知道是哪个子项将命令传递给它的。就像这里，“主管”不需要知道是为什么下级“柜员”为什么会把请求传递给他&lt;/li&gt;
&lt;li&gt;&quot;柜员&quot;不需要知道整个链。他仅负责将请求传递给上级&quot;&quot;主管&quot;&quot;，期望请求能在上级“主管”那里被处理（当前也许还需要进一步的传递处理）即可&lt;/li&gt;
&lt;li&gt;当引入新员工类型的时候，整个组织架构图很容易变更。例如， 我创建了一个新的“柜员经理”角色，他能处理10,000-50,000美元之间的提款请求，“柜员经理”的直属上级是“主管”。这里我们并不需要对“主管”对象做任何的处理，只需要将“柜员”的直属上级改为“柜员经理”即可&lt;/li&gt;
&lt;li&gt;当编写单元测试的时候，我们可以一次只关注一个雇员角色了。例如，在测试“主管”逻辑的时候，我们就不需要测试“柜员”的逻辑了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管我认为以上的例子已经能很好的说明这种模式，但是通常你会发现有些人会使用一个方法叫做&lt;code&gt;SetNext&lt;/code&gt;.一般来说，我觉着这在C#中是非常罕见的，因为C#中我们可以使用属性获取器和设置器。使用&lt;code&gt;SetVariableName&lt;/code&gt;方法通常都是C++时代的事情了，那时候这通常是封装变量的首选方法。&lt;/p&gt;
&lt;p&gt;但这里最重要的是，其他示例通常使用抽象类来加强请求传递的方式。在前面代码中有一个问题是，将请求传递给下一个处理器的时候，编写了许多重复代码。那么就让我们来整理一下代码。&lt;/p&gt;
&lt;p&gt;这里我们要做的第一件事情就是创建一个抽象类，这个抽象类使我们能够通过标准化的方式处理提款请求。它应该定义一个检测条件，如果条件满足，就执行提款，反之，就将请求传递给直属上级。经过修改之后的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;interface IBankEmployee
{
    IBankEmployee LineManager { get; }
    void HandleWithdrawRequest(BankAccount account, decimal amount);
}

abstract class BankEmployee : IBankEmployee
{
    public IBankEmployee LineManager { get; private set; }

    public void SetLineManager(IBankEmployee lineManager)
    {
        this.LineManager = lineManager;
    }

    public void HandleWithdrawRequest(BankAccount account, decimal amount)
    {
        if (CanHandleRequest(account, amount))
        {
            Withdraw(account, amount);
        } 
        else
        {
            LineManager.HandleWithdrawRequest(account, amount);
        }
    }

    abstract protected bool CanHandleRequest(BankAccount account, decimal amount);

    abstract protected void Withdraw(BankAccount account, decimal amount);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下一步，我们需要修改所有的员工类，使其继承自&lt;code&gt;BankEmployee&lt;/code&gt;抽象类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Teller : BankEmployee, IBankEmployee
{
    protected override bool CanHandleRequest(BankAccount account, decimal amount)
    {
        if (amount &amp;gt; 10000)
        {
            return false;
        }
        return true;
    }

    protected override void Withdraw(BankAccount account, decimal amount)
    {
        Console.WriteLine(&quot;柜员提取的金额&quot;);
    }
}

class Supervisor : BankEmployee, IBankEmployee
{
    protected override bool CanHandleRequest(BankAccount account, decimal amount)
    {
        if (amount &amp;gt; 100000)
        {
            return false;
        }
        return true;
    }

    protected override void Withdraw(BankAccount account, decimal amount)
    {
        if (!account.idOnRecord)
        {
            throw new Exception(&quot;客户没有身份证ID&quot;);
        }

        Console.WriteLine(&quot;主管提取的金额&quot;);
    }
}

class BankManager : BankEmployee, IBankEmployee
{
    protected override bool CanHandleRequest(BankAccount account, decimal amount)
    {
        return true;
    }

    protected override void Withdraw(BankAccount account, decimal amount)
    {
        Console.WriteLine(&quot;银行经理提取的金额&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里请注意，在所有的场景中，都会调用抽象类中的&lt;code&gt;HandleWithdrawRequest&lt;/code&gt;公共方法。 该方法会调用子类中定义的&lt;code&gt;CanHandleRequest&lt;/code&gt;方法来检测当前角色是否满足处理请求的条件，如果满足，就调用子类中的&lt;code&gt;Withdraw&lt;/code&gt;方法处理请求，否则就会尝试将请求传递给上级角色。&lt;/p&gt;
&lt;p&gt;我们只需要像以下代码这样，更改创建员工链的方式即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var bankManager = new BankManager();

var bankSupervisor = new Supervisor();
bankSupervisor.SetLineManager(bankManager);

var frontLineStaff = new Teller();
frontLineStaff.SetLineManager(bankSupervisor);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我需要再次重申，我并不喜欢使用&lt;code&gt;SetXXX&lt;/code&gt;这种方法，但是许多例子中都喜欢这么使用，所以我就把它加了进来。&lt;/p&gt;
&lt;p&gt;在一些例子中，也会将判断员工是否满足处理请求的条件放在抽象类中。我个人不喜欢这样做，因为这意味着所有的处理程序不得不使用相似的逻辑。例如，目前所有的检查都是基于提取金额的，但是如果我们想要实现一个特殊的处理程序，它的条件和VIP标志有关，那么我们将不得不又在抽象类中重新使用IF/Else, 这又将我们带回到了IF/Else地狱中。&lt;/p&gt;

&lt;p&gt;这种模式最佳的使用场景是，你的业务上有一个逻辑上的处理链，这个处理链每次必须按照顺序运行。这里请注意，链分叉是这种模式的一个变体， 但是很快处理起来就会非常复杂。因此，当我对现实世界中“命令链”场景建模的时候，我通常会使用这种模式。这就是我以银行为例的原因，因为它就是现实世界中可以用代码建模的“责任链”。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 07 May 2020 15:09:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>最近我有一个朋友在研究经典的“Gang Of Four”设计模式。他经常来询问我在实际业务应用中使用了哪些设计模式。单例模式、工厂模式、中介者模式 - 都是我之前使用过，甚至写过相关文章的模式。但是有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/12846451.html</dc:identifier>
</item>
<item>
<title>Node 内存泄漏排查案例 - Ever-Lose</title>
<link>http://www.cnblogs.com/everlose/p/12846250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/everlose/p/12846250.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;在阿里云上看到我运行了一段时间的程序，发现 memory 一项基本是在稳步提升，就知道有内存泄漏的情况出现。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/625864/202005/625864-20200507223540106-1525574753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;近三日从 35% 升到 40%，缓慢而坚定的提升。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;排查此问题需要分析其堆内存快照，当然我们不能直接使用线上机器调试。不幸的是测服机器在内网，和阿里云联不通，alinode 发挥不了作用。但所幸的是 V8 引擎提供了内部接口可以直接把堆中的JS对象导出来供开发者分析。我们采用heapdump这个模块，执行如下命令安装&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ npm install heapdump --save

&quot;heapdump&quot;: &quot;^0.3.15&quot;,
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;const heapdump = require('heapdump');
heapdump.writeSnapshot(`./${Date.now()}.heapsnapshot`);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的文件如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ ll -lh

-rw-rw-r-- 1 souche souche  38M Nov 19 19:00 1574161221512.heapsnapshot
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总之我在测服上定时每 2 小时打印堆栈快照。&lt;/p&gt;
&lt;p&gt;总之，你可以使用 scp 命令把测服的代码导出到本地&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 传递单个文件

$ scp 【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】【本地文件的路径】

# 例如

$ scp souche@172.11.xxx.xxx:/home/souche/app/egg-test/current/1574161221512.heapsnapshot /Users/dasouche/workspace/sc-node

# 传递文件夹

scp -r 【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】【本地文件的路径】
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分析步骤&quot;&gt;分析步骤&lt;/h2&gt;
&lt;p&gt;打开 chrome-控制台-Memory-load&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/625864/202005/625864-20200507223550492-1441536808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加载完后得到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/625864/202005/625864-20200507223600979-26027339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简而言之，Shallow Size 就是对象自身被创建时所需要内存的大小，Retained Size 就是当把对象从支配树上拿掉，对象和它的下级节点一共能释放的内存大小。&lt;/p&gt;
&lt;p&gt;其术语简介可参见：&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101&quot;&gt;https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析过程&quot;&gt;分析过程&lt;/h2&gt;
&lt;p&gt;从线上机器导出两个堆文件，一个是10月30日打印的，一个是11月4日打印的，其内存上升了 100+ MB。&lt;/p&gt;
&lt;p&gt;比对两个堆，把第二个堆文件的 Summary 切换成 Comparison，并按 Delta 倒叙排，发现增长最快的是 (concatenated string) 。其中有很多连接字符串，其中有大量的sql语句，并且有大量的schedule执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/625864/202005/625864-20200507223610155-501717881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(constructor) 增长排第二，其中也见到不少 schedule，那我们可以确认就是 noticeJob.ts 这个定时器的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/625864/202005/625864-20200507223618131-1810305002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本项目使用了 egg 作为框架，schedule 就是指定时触发的逻辑。联系代码我们发现在一个 5 秒触发一次的 schedule 里，里面不停的触发队列的 process 监听事件，猜测是 Queue.process 监听事件越绑越多的毛病，也导致里面的逻辑越触发越多。&lt;/p&gt;
&lt;p&gt;这其实就是队列绑定监听事件的误用了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// app/schedule/noticeJob.ts
'use strict';

import { Context } from 'egg';
import * as kue from 'kue';

module.exports = {
  schedule: {
    disable: false,
    // 每五秒触发一次
    cron: '*/5 * * * * *',
    immediate: true,
    type: 'worker',
  },

  async task(ctx: Context) {
    const Queue = ctx.app.kue;

    Queue.process('noticeCalling', async function(job, done) {
      const { uid, rid, subId } = job.data;
      await ctx.service.message.noticedCalling(uid, rid);
      // done();
    });
  },
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在测服注释掉这段定时器后，每隔一小时打印一次（因为测服无法连阿里云），观察一天，内存没有上升趋势，这很好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-rw-rw-r--  1 souche souche  38M Nov 24 11:24 1574565877609.heapsnapshot
-rw-rw-r--  1 souche souche  37M Nov 24 12:24 1574569477611.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 13:24 1574573077611.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 14:24 1574576677613.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 15:24 1574580277614.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 16:24 1574583877614.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 17:24 1574587477616.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 18:24 1574591077616.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 19:24 1574594677616.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 20:24 1574598277618.heapsnapshot
-rw-rw-r--  1 souche souche  37M Nov 24 21:24 1574601877620.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 22:24 1574605477621.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 24 23:24 1574609077622.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 00:24 1574612677622.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 01:24 1574616277622.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 02:24 1574619877623.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 03:24 1574623477624.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 04:24 1574627077626.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 05:24 1574630677627.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 06:24 1574634277627.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 07:24 1574637877628.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 08:24 1574641477629.heapsnapshot
-rw-rw-r--  1 souche souche  38M Nov 25 09:24 1574645077630.heapsnapshot
-rw-rw-r--  1 souche souche  39M Nov 25 10:24 1574648677630.heapsnapshot
-rw-rw-r--  1 souche souche  39M Nov 25 11:24 1574652277632.heapsnapshot
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;解决方法&lt;/h2&gt;
&lt;p&gt;最后就在 app.ts 设置这个 process 的监听，移除 schedule 里的定时脚本&lt;/p&gt;
</description>
<pubDate>Thu, 07 May 2020 14:35:00 +0000</pubDate>
<dc:creator>Ever-Lose</dc:creator>
<og:description>背景 在阿里云上看到我运行了一段时间的程序，发现 memory 一项基本是在稳步提升，就知道有内存泄漏的情况出现。如下图 近三日从 35% 升到 40%，缓慢而坚定的提升。 代码 排查此问题需要分析其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/everlose/p/12846250.html</dc:identifier>
</item>
<item>
<title>还在用迭代器处理集合吗？试试Stream，真香 - 后青春期的Keats</title>
<link>http://www.cnblogs.com/keatsCoder/p/12846233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keatsCoder/p/12846233.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇博客&lt;a href=&quot;https://www.cnblogs.com/keatsCoder/p/12839050.html&quot;&gt;一文带你深入了解 Lambda 表达式和方法引用&lt;/a&gt;我给大家介绍了 Java8 函数式特性中的 Lambda，这篇文章我将继续讨论 stream 流的用法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;声明：本文首发于博客园，作者：后青春期的Keats；地址：&lt;a href=&quot;https://www.cnblogs.com/keatsCoder/&quot;&gt;https://www.cnblogs.com/keatsCoder/&lt;/a&gt; 转载请注明，谢谢！&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;show-time&quot;&gt;Show Time&lt;/h2&gt;
&lt;p&gt;首先给大家看一段代码，让大家直观感受下 Java7 和 Java8 遍历处理集合的不同&lt;/p&gt;
&lt;p&gt;Dish 是一个菜肴对象，calories 属性表示该菜品的卡路里值，name 则是菜品的名称。我们需要过滤出卡路里小于400、然后根据卡路里值升序、接着拿到他们的名称列表并返回&lt;/p&gt;
&lt;p&gt;Java7&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static List&amp;lt;String&amp;gt; getLowCaloricDishesNamesInJava7(List&amp;lt;Dish&amp;gt; dishes){
    List&amp;lt;Dish&amp;gt; lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;();
    for(Dish d: dishes){
        if(d.getCalories() &amp;lt; 400){
            lowCaloricDishes.add(d);
        }
    }
    List&amp;lt;String&amp;gt; lowCaloricDishesName = new ArrayList&amp;lt;&amp;gt;();
    Collections.sort(lowCaloricDishes, new Comparator&amp;lt;Dish&amp;gt;() {
        public int compare(Dish d1, Dish d2){
            return Integer.compare(d1.getCalories(), d2.getCalories());
        }
    });
    for(Dish d: lowCaloricDishes){
        lowCaloricDishesName.add(d.getName());
    }
    return lowCaloricDishesName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java8&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static List&amp;lt;String&amp;gt; getLowCaloricDishesNamesInJava8(List&amp;lt;Dish&amp;gt; dishes){
    return dishes.stream()
        .filter(d -&amp;gt; d.getCalories() &amp;lt; 400)
        .sorted(comparing(Dish::getCalories))
        .map(Dish::getName)
        .collect(toList());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要多核并行处理，则只需调用 &lt;code&gt;dishes.parallelStream()&lt;/code&gt; 即可&lt;/p&gt;
&lt;p&gt;在 Java8 之前，程序员需要通过 2次遍历 + 一次集合排序才能完成的工作，Java8 只需要一个链式调用就可以解决。这就是 stream 的强大之处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1654189/202005/1654189-20200507223039981-1259589654.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;认识流&quot;&gt;认识流&lt;/h2&gt;
&lt;h3 id=&quot;流是什么&quot;&gt;流是什么&lt;/h3&gt;
&lt;p&gt;流是 Java API 的新成员，允许程序员以声明式的方式处理集合数据，并且支持链式调用、支持并行处理。用流处理的集合数据高效且易读。&lt;/p&gt;
&lt;h3 id=&quot;流与集合的异同&quot;&gt;流与集合的异同&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;集合的主要功能是以一定的时间和空间复杂度存储和访问元素，而流主要是用于元素计算&lt;/li&gt;
&lt;li&gt;集合中的元素可以随意添加和删除，而流不能添加和删除元素&lt;/li&gt;
&lt;li&gt;流的元素是按需计算的，只有当用到时他才会参与计算，而集合中的元素必须提前全都准备好&lt;/li&gt;
&lt;li&gt;流只能遍历一次,下面的代码会报错 &lt;code&gt;java.lang.IllegalStateException: stream has already been operated upon or closed&lt;/code&gt; 流已经被消费掉&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; names = Arrays.asList(&quot;Java8&quot;, &quot;Lambdas&quot;, &quot;In&quot;, &quot;Action&quot;);
Stream&amp;lt;String&amp;gt; s = names.stream();
s.forEach(System.out::println);
s.forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;集合采用外部迭代，流采用内部迭代。内部迭代意味着 Java 可以替你选择更优的迭代策略和并行处理。而外部迭代如果程序员想着做个更有的迭代/采用并行就相当于“下次一定”😅了&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;流操作分类&quot;&gt;流操作分类&lt;/h3&gt;
&lt;p&gt;对流的操作可以分为两类，可以继续执行下一个流操作的称为中间操作(方法的返回值是 Stream)，关闭流的操作称为终止操作。&lt;/p&gt;
&lt;h4 id=&quot;中间操作&quot;&gt;中间操作&lt;/h4&gt;
&lt;p&gt;除非流水线上执行终端操作，否则中间操作不会执行任何处理。流会对中间操作进行合并、短路等优化&lt;/p&gt;
&lt;h4 id=&quot;终端操作&quot;&gt;终端操作&lt;/h4&gt;
&lt;p&gt;终端操作会从流的流水线生成结果，返回一个非 Stream 的任意类型值&lt;/p&gt;
&lt;h2 id=&quot;使用流&quot;&gt;使用流&lt;/h2&gt;
&lt;h3 id=&quot;筛选和切片&quot;&gt;筛选和切片&lt;/h3&gt;
&lt;h4 id=&quot;筛选&quot;&gt;筛选&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;filter(Predicate&amp;lt;? super T&amp;gt; predicate)&lt;/code&gt; 方法可以将流中满足某条件的元素筛选出来。该方法接收一个谓词函数，返回流。比如要选出某个苹果集合中红色的苹果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Apple&amp;gt; appleList = new ArrayList&amp;lt;&amp;gt;();
List&amp;lt;Apple&amp;gt; redAppleList = appleList.stream().filter(a -&amp;gt; &quot;red&quot;.equals(a.getColor())).collect(Collectors.toList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;去重&quot;&gt;去重&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;distinct()&lt;/code&gt; 方法会根据元素的 hashCode() 和 equals() 方法对流中元素进行去重操作&lt;/p&gt;
&lt;h4 id=&quot;截断&quot;&gt;截断&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;limit(n)&lt;/code&gt; 方法会返回流的前 n 个元素，对于有序集合List，流会按照添加顺序返回前 n 个元素，而无序集合则不会&lt;/p&gt;
&lt;h4 id=&quot;跳过&quot;&gt;跳过&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;skip(n)&lt;/code&gt; 方法会跳过流的前 n 个元素，可以通过 skip(m).limit(n) 返回列表中第 m - (m+n) 区间的元素，类似与 mysql 中的 limit m,n&lt;/p&gt;
&lt;h3 id=&quot;映射&quot;&gt;映射&lt;/h3&gt;
&lt;h4 id=&quot;对流中的每个元素应用函数&quot;&gt;对流中的每个元素应用函数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper)&lt;/code&gt; 方法。该方法接收一个 Function 函数，对流中的每一个元素使用。然后可以返回任意类型的对象。有了该方法，就可以结合 Lambda 表达式对集合中的元素使用函数进行各种转换&lt;/p&gt;
&lt;h4 id=&quot;流的扁平化&quot;&gt;流的扁平化&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flatMap()&lt;/code&gt; 可以将流操作中多个流合并成一个流的多个元素。举个例子：集合 words 有两个单词，现在想获得&lt;code&gt;[H, e, l, o, W, r, d]&lt;/code&gt; 在 split 方法执行完毕后，返回的是 Stream(String[]) 对象，而此时如果执行 map 方法，返回的就是多个流的集合(这个例子中就是两个 Stream(String))，这时是无法继续接下来的 distinct 操作的，因此需要 flatMap 将两个 Stream 扁平化成一个 Stream，然后进行操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;);

List&amp;lt;String&amp;gt; charList = words.stream().map(word -&amp;gt; word.split(&quot;&quot;)).flatMap(Arrays::stream).distinct().collect(Collectors.toList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法的方法声明 &lt;code&gt;flatMap(Function&amp;lt;? super T, ? extends Stream&amp;lt;? extends R&amp;gt;&amp;gt; mapper)&lt;/code&gt; 中可以看出，他所使用的函数式接口 Function 第二个泛型 R 必须是 Stream 流。即函数式接口的抽象方法返回值必须是 Stream 流及其子类对象。&lt;/p&gt;
&lt;h3 id=&quot;查找和匹配&quot;&gt;查找和匹配&lt;/h3&gt;
&lt;h4 id=&quot;检查谓词是否至少匹配一个元素&quot;&gt;检查谓词是否至少匹配一个元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;anyMatch&lt;/code&gt; 方法可以回答“流中是否存在至少一个复合谓词条件的元素”返回 boolean 类型的值，因此是一个终端操作，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; num = Arrays.asList(1, 2, 3, 4, 5, 6);

if (num.stream().anyMatch(n -&amp;gt; n % 3 == 0)) {
    System.out.println(&quot;集合中有元素是3的整数倍&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台会输出'集合中有元素是3的整数倍',因为集合中 3、6都是3的整数倍，符合谓词的条件&lt;/p&gt;
&lt;h4 id=&quot;检查谓词是否匹配所有元素&quot;&gt;检查谓词是否匹配所有元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;allMatch&lt;/code&gt; 方法和 &lt;code&gt;anyMatch&lt;/code&gt; 方法原理类似，但是它仅当所有元素满足谓词条件时，返回 true。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;noneMatch&lt;/code&gt; 与 &lt;code&gt;allMatch&lt;/code&gt; 正好相反，仅当所有元素不满足谓词条件时，返回 true&lt;/p&gt;
&lt;p&gt;ps:和 &amp;amp;&amp;amp; || 运算符类似，以上三个操作都用到了短路的思想来提高效率。&lt;/p&gt;
&lt;h4 id=&quot;查找元素&quot;&gt;查找元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;findAny()&lt;/code&gt; 该方法返回当前流中的任意元素,可以和其他流操作结合使用,这里需要注意 findAny() 返回的结果被 Optional 所包裹，Optional 是 Java8 为优雅的避免 NPE 所采用的新 API，关于 Optional 的用法我会在下一篇博客和大家讨论，敬请期待。这里需要说明的就是 Optional.ifPresent(Consumer&amp;lt;? super T&amp;gt; consumer) 表示当 Optional 包裹的元素不为空时，执行 consumer&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;num.stream().filter(n -&amp;gt; n &amp;gt; 2).findAny().ifPresent(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;findFirst()&lt;/code&gt; 该方法返回当前流中的第一个元素,一般也和其他流操作(例如 filter() 过滤)结合使用。与 &lt;code&gt;findAny()&lt;/code&gt; 不同的是，他一定返回有序集合的第一个满足条件的元素。当然有得必有失，作为代价，&lt;code&gt;findFirst()&lt;/code&gt; 在并行处理时限制更多一些。&lt;/p&gt;
&lt;h3 id=&quot;归约&quot;&gt;归约&lt;/h3&gt;
&lt;h4 id=&quot;元素求和&quot;&gt;元素求和&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);&lt;/code&gt; 方法接收两个参数：identity 初始值，accumulator 对两个数的操作。例如求集合中数字的和：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;num.stream().reduce(0, (a, b) -&amp;gt; a + b) // 计算完成，返回 21
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ps：Lambda 表达式 &lt;code&gt;(a, b) -&amp;gt; a + b)&lt;/code&gt; 中 a 是上一轮执行完后的累计值，b 是本次循环流中的元素。通过累加就可以计算出数字的和&lt;/p&gt;
&lt;h4 id=&quot;最大值和最小值&quot;&gt;最大值和最小值&lt;/h4&gt;
&lt;p&gt;reduce 方法不仅可以求和、求积。甚至可以计算最大值、最小值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;num.stream().reduce(Integer::max);
num.stream().reduce(Integer::min);

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;流是 Java API 的新成员，允许程序员以声明式的方式处理集合数据，并且支持链式调用、支持并行处理。用流处理的集合数据高效且易读。&lt;/li&gt;
&lt;li&gt;流的API中可以分为两大类，中间操作和终端操作，中间操作返回流对象，可以链式调用，终端操作则返回非流对象。&lt;/li&gt;
&lt;li&gt;流提供了很多方便的API，如筛选 filter、去重 distinct、截断 limit、跳过 skip、函数转换 map、扁平化 flatMap、判断流中是否有任意元素符合要求 anyMatch、是否所有元素都符合要求 allMatch、是否所有元素都不符合要求 noneMatch、查找元素 findAny findFirst、累计式的计算元素 reduce&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;码字不易，如果你觉得读完以后有收获，不妨点个推荐让更多的人看到吧！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 May 2020 14:31:00 +0000</pubDate>
<dc:creator>后青春期的Keats</dc:creator>
<og:description>前言 上一篇博客 &amp;quot;一文带你深入了解 Lambda 表达式和方法引用&amp;quot; 我给大家介绍了 Java8 函数式特性中的 Lambda，这篇文章我将继续讨论 stream 流的用法 声明</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/keatsCoder/p/12846233.html</dc:identifier>
</item>
<item>
<title>使用Golang + lua实现一个值班机器人 - 连程</title>
<link>http://www.cnblogs.com/anxin1225/p/12846183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anxin1225/p/12846183.html</guid>
<description>&lt;p&gt;我们在的项目组呢，有一项工作是，收邮件（很大程度上使用邮件是为了存个底），然后从我们的系统里边查一下相关信息，然后回复个邮件的工作。虽然工作量并不大，但是会把时间切的稀碎。为了拯救我的时间，所以做了一个邮件的值班机器人。让他来顶替我自动回复邮件，考虑到这个东西应该也有不少人会用得到，所以就把这个东西分享出来。先把效果分享出来。&lt;/p&gt;
&lt;p&gt;服务器上就很简单，dutyrobot就是Golang编译之后的框架。lua文件夹中就是使用lua编写的业务逻辑。Data.json就是保存了一些相关的数据，防止重启之后，数据丢掉，比如说Cookie信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507214919221-283848648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用最基础的alpine进行启动一下，并且将相关的文件夹映射到容器里边，然后在容器里边启动软件。这么做主要是为了让镜像能够拥有自己的环境变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507215338408-667543664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后业务逻辑里边定期，收邮件，然后判定业务逻辑，执行对应的lua脚本，然后回复邮件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507215933363-1883517838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在顺手往我们的内部事务群里边推一条相关结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507215827006-692423897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;其实我本职是C#程序员来着，做这个东西，最先也是使用C#来实现的，不过C#跟Lua相性不好，我没有找到比较优雅的类库。要上Linux系统，用.net core + C 调用lua的方式虽然也尝试过，但是我本身对这件事情还是非常虚的。Python的各种包安装都给我搞蒙蔽了。所以最后就选用了Golang来写底层函数公布给Lua，然后让lua来写各种业务逻辑的方式来实现整个项目。框架部分嘛，一旦写完，改动的几率还是比较低的，并且Window交叉编译Linux，直接就可以部署上线，连个环境都不用装，简直爽歪歪。lua解释性语言，出了啥都没有以外其他的都挺好的。&lt;/p&gt;
&lt;p&gt;基础框架都是通用的，所以可以直接放出来，拿出来用。只需要关心自己的业务内容就可以了。&lt;/p&gt;
&lt;p&gt;基础框架：&lt;a href=&quot;https://gitee.com/anxin1225/DutyRobotGo&quot;&gt;https://gitee.com/anxin1225/DutyRobotGo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这个框架里边，我给lua提供了不少功能，主要包括收发邮件，发起网络请求，发起网络监听（甚至可以拿这个做底层做一个小型的API站，信我，我这么做过了已经），临时存个数据，获取环境变量，获取文件内容，再启动一个Lua容器（没错，lua又再起一个lua容器的能力），获取当前系统信息，cron定时任务。当然如果你觉得不够的话，还可以进行二次扩展，其实非常容易，我已经写了好多了，比着抄一下，很容易的。不过一般情况下不用扩展了，我这边就不深入讲解框架部分了，毕竟，怎么做业务才是重点。&lt;/p&gt;
&lt;p&gt;然后，讲一下Lua部分是怎么实现的。因为Golang里边的代码是直接找到了main.lua进行执行的，我们也就从这个文件开始讲起。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507220847739-1432956169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我将好多服务注册了进来，究竟有哪些服务呢，还是得去看看框架里边怎么写的。Cron就是我写的其中一个小功能。其实就是task任务，对应到框架部分呢可以查看tasks文件夹里去看具体的实现，可以看到俩边有两个文件，其中task.go是Golang的语言函数task_4lua.go就是把Golang的函数公开给lua来调用的接口注册的位置。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507221256010-1592736338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们来看到task_4lua.go这个文件里边，一般会存在一个函数叫做RegisterFunc_4lua就是注册用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507221448779-1073577690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这就很眼熟了，Cron就是lua用的类的名字，下边这个map就是他们对应的需要调用的名字，后边会对照着golang这边的函数，一般函数里边我会写上lua那边应该怎么调用。如果找不到的话，可以来框架这边翻一翻，有惊喜也说不定。&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507220847739-1432956169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的业务里边。就是每分钟接收一下，每5分钟保存一下Cookie。真正的业务逻辑其实就写在各个lua文件里边。我们去看一下怎么接收消息和处理消息的。&lt;/p&gt;


&lt;p&gt; 这里边就是简单的lua的业务逻辑了，收一下邮件，然后调用对应的处理lua，处理完了就完事了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507221939118-831294566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/385305/202005/385305-20200507222119945-1091563375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 07 May 2020 14:22:00 +0000</pubDate>
<dc:creator>连程</dc:creator>
<og:description>我们在的项目组呢，有一项工作是，收邮件（很大程度上使用邮件是为了存个底），然后从我们的系统里边查一下相关信息，然后回复个邮件的工作。虽然工作量并不大，但是会把时间切的稀碎。为了拯救我的时间，所以做了一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/anxin1225/p/12846183.html</dc:identifier>
</item>
<item>
<title>【漫画】JAVA并发编程三大Bug源头(可见性、原子性、有序性) - 胖滚猪学编程</title>
<link>http://www.cnblogs.com/liuyanling/p/12845755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyanling/p/12845755.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原创声明：本文转载自公众号【胖滚猪学编程】​&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;某日，胖滚猪写的代码导致了一个生产bug，奋战到凌晨三点依旧没有解决问题。胖滚熊一看，只用了一个volatile就解决了。并告知胖滚猪，这是并发编程导致的坑。这让胖滚猪坚定了要学好并发编程的决心。。于是，开始了我们并发编程的第一课。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/e1d85f718b364fef96f087b13300db0faf6fefc7.jpeg&quot; alt=&quot;con2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;刚刚我们说到，CPU缓存可以提高程序性能，但缓存也是造成BUG源头之一，因为缓存可以导致可见性问题。我们先来看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static int count = 0;
public static void main(String[] args) throws Exception {
    Thread th1 = new Thread(() -&amp;gt; {
        count = 10;
    });
    Thread th2 = new Thread(() -&amp;gt; {
        //极小概率会出现等于0的情况
        System.out.println(&quot;count=&quot; + count);
    });
    th1.start();
    th2.start();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按理来说，应该正确返回10，但结果却有可能是0。&lt;/p&gt;
&lt;p&gt;一个线程对变量的改变另一个线程没有get到，这就是可见性导致的bug。一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。&lt;/p&gt;
&lt;p&gt;那么在谈论可见性问题之前，你必须了解下JAVA的内存模型，我绘制了一张图来描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/217ba14a5c1cb5155974050bdfeec953314f3b39.jpeg&quot; alt=&quot;JAVA_&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主内存（Main Memory）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作内存（Working Memory）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工作内存可以简单理解为计算机当中的CPU高速缓存，但准确的说它是涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在再回到刚刚的问题，为什么那段代码会导致可见性问题呢，根据内存模型来分析，我相信你会有答案了。当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存&lt;br/&gt;&lt;img src=&quot;https://yqfile.alicdn.com/83734113d085378660e601c80fb8a0971de46a1f.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，那么对于共享变量V，它们首先是在自己的工作内存，之后再同步到主内存。可是并不会及时的刷到主存中，而是会有一定时间差。很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/6b4cc09b2fac7de4dd35e12a0a771d9a195517bb.jpeg&quot; alt=&quot;con3_1&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private volatile long count = 0;
​
private void add10K() {
    int idx = 0;
    while (idx++ &amp;lt; 10000) {
        count++;
    }
}
​
public static void main(String[] args) throws InterruptedException {
    TestVolatile2 test = new TestVolatile2();
    // 创建两个线程，执行 add() 操作
    Thread th1 = new Thread(()-&amp;gt;{
        test.add10K();
    });
    Thread th2 = new Thread(()-&amp;gt;{
        test.add10K();
    });
    // 启动两个线程
    th1.start();
    th2.start();
    // 等待两个线程执行结束
    th1.join();
    th2.join();
    // 介于1w-2w,即使加了volatile也达不到2w
    System.out.println(test.count);
}
​
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/8e4df5531113ac5f357432b84283dcd0db9c0dc9.jpeg&quot; alt=&quot;con3_2&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原创声明：本文转载自公众号【胖滚猪学编程】​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个不可分割的操作叫做原子性操作，它不会被线程调度机制打断的，这种操作一旦开始，就一直运行到结束，中间不会有任何线程切换。注意线程切换是重点！&lt;/p&gt;
&lt;p&gt;我们都知道CPU资源的分配都是以线程为单位的,并且是分时调用,操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。而任务的切换大多数是在时间片段结束以后,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/b0fd9bdb11240493b7ffc2b1841e8cb6347d25dd.jpeg&quot; alt=&quot;_&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么线程切换为什么会带来bug呢？因为操作系统做任务切换，可以发生在任何一条CPU 指令执行完！注意，是 CPU 指令，CPU 指令，CPU 指令，而不是高级语言里的一条语句。比如count++，在java里就是一句话，但高级语言里一条语句往往需要多条 CPU 指令完成。其实count++包含了三个CPU指令！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；&lt;/li&gt;
&lt;li&gt;指令 2：之后，在寄存器中执行 +1 操作；&lt;/li&gt;
&lt;li&gt;指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;小技巧:可以写一个简单的count++程序，依次执行javac TestCount.java，javap -c -s TestCount.class得到汇编指令，验证下count++确实是分成了多条指令的。&lt;/p&gt;
&lt;p&gt;volatile虽然能保证执行完及时把变量刷到主内存中，但对于count++这种非原子性、多指令的情况，由于线程切换，线程A刚把count=0加载到工作内存，线程B就可以开始工作了，这样就会导致线程A和B执行完的结果都是1，都写到主内存中，主内存的值还是1不是2，下面这张图形象表示了该历程:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/844cb7d6cf97eb9474a53063afce89c890dc18e4.jpeg&quot; alt=&quot;_&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/3f9303166aaab3ad052ec54365ce8f64ae91c07f.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原创声明：本文转载自公众号【胖滚猪学编程】​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JAVA为了优化性能，允许编译器和处理器对指令进行重排序，即有时候会改变程序中语句的先后顺序：&lt;/p&gt;
&lt;p&gt;例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”只是在这个程序中不影响程序的最终结果。&lt;/p&gt;
&lt;p&gt;有序性指的是程序按照代码的先后顺序执行。但是不要望文生义，这里的顺序不是按照代码位置的依次顺序执行指令,指的是最终结果在我们看起来就像是有序的。&lt;/p&gt;
&lt;p&gt;重排序的过程不会影响单线程程序的执行，却会影响到多线程并发执行的正确性。有时候编译器及解释器的优化可能导致意想不到的 Bug。比如非常经典的双重检查创建单例对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton { 
 static Singleton instance; 
 static Singleton getInstance(){ 
 if (instance == null) { 
 synchronized(Singleton.class) { 
 if (instance == null) 
 instance = new Singleton(); 
 } 
 } 
 return instance; 
 } 
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能会觉得这个程序天衣无缝，我两次判断是否为空，还用了synchronized，刚刚也说了，synchronized 是独占锁/排他锁。按照常理来说，应该是这么一个逻辑:&lt;br/&gt;线程A和B同时进来，判断instance == null，线程A先获取了锁，B等待，然后线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时加锁会成功，然后线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。&lt;/p&gt;
&lt;p&gt;但多线程往往要有非常理性的思维，我们先分析一下 instance = new Singleton()这句话，根据刚刚原子性说到的，一句高级语言在cpu层面其实是多条指令，这也不例外，我们也很熟悉new了，它会分为以下几条指令:&lt;br/&gt;1、分配一块内存 M；&lt;br/&gt;2、在内存 M 上初始化 Singleton 对象；&lt;br/&gt;3、然后 M 的地址赋值给 instance 变量。&lt;/p&gt;
&lt;p&gt;如果真按照上述三条指令执行是没问题的，但经过编译优化后的执行路径却是这样的：&lt;br/&gt;&lt;strong&gt;1、分配一块内存 M；&lt;br/&gt;2、将 M 的地址赋值给 instance 变量；&lt;br/&gt;3、最后在内存 M 上初始化 Singleton 对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假如当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；而此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/fda190fd58940c4fd3166e8325688e1ecae4a1fd.jpeg&quot; alt=&quot;_&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/f766dd14f723c1ffbefedf8d51f2a9d573aeaa74.jpeg&quot; alt=&quot;con4&quot;/&gt;&lt;/p&gt;

&lt;p&gt;并发程序是一把双刃剑，一方面大幅度提升了程序性能，另一方面带来了很多隐藏的无形的难以发现的bug。我们首先要知道并发程序的问题在哪里，只有确定了“靶子”，才有可能把问题解决，毕竟所有的解决方案都是针对问题的。并发程序经常出现的诡异问题看上去非常无厘头，但是只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的。&lt;br/&gt;总结一句话：可见性是缓存导致的，而线程切换会带来的原子性问题，编译优化会带来有序性问题。至于怎么解决呢！欲知后事如何，且听下回分解。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原创声明：本文转载自公众号【胖滚猪学编程】​&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文转载自公众号【胖滚猪学编程】 用漫画让编程so easy and interesting！欢迎关注！形象来源于微信表情包【胖滚家族】喜欢可以下载哦~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 07 May 2020 13:27:00 +0000</pubDate>
<dc:creator>胖滚猪学编程</dc:creator>
<og:description>原创声明：本文转载自公众号【胖滚猪学编程】​ 某日，胖滚猪写的代码导致了一个生产bug，奋战到凌晨三点依旧没有解决问题。胖滚熊一看，只用了一个volatile就解决了。并告知胖滚猪，这是并发编程导致的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuyanling/p/12845755.html</dc:identifier>
</item>
</channel>
</rss>