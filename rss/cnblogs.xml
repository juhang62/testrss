<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core 3.x控制IHostedService启动顺序浅探 - 老王Plus</title>
<link>http://www.cnblogs.com/tiger-wang/p/13636641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-wang/p/13636641.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;想写好中间件，这是基础。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;今天这个内容，基于于ASP.NET Core 3.x。&lt;/p&gt;
&lt;p&gt;从3.x开始，ASP.NET Core使用了通用主机模式。它将&lt;code&gt;WebHostBuilder&lt;/code&gt;放到了通用的&lt;code&gt;IHost&lt;/code&gt;之上，这样可以确保&lt;code&gt;Kestrel&lt;/code&gt;可以运行在&lt;code&gt;IHostedService&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;我们今天就来研究一下这个启动方式和启动顺序。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    &lt;span&gt;为了防止不提供原网址的转载，特在这里加上原文链接：&lt;a class=&quot;ng-star-inserted&quot; href=&quot;https://www.cnblogs.com/tiger-wang/p/13636641.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tiger-wang/p/13636641.html&lt;/a&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;通常情况下，&lt;code&gt;IHostedService&lt;/code&gt;的任何实现在添加到&lt;code&gt;Startup.ConfigureServices()&lt;/code&gt;后，都会在&lt;code&gt;GenericWebHostService&lt;/code&gt;之前启动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/907112/202009/907112-20200909004753410-513418571.png&quot; alt=&quot;&quot; width=&quot;1072&quot; height=&quot;472&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是微软官方给出的图。&lt;/p&gt;
&lt;p&gt;这个图展示了在&lt;code&gt;IHost&lt;/code&gt;上调用&lt;code&gt;RunAsync()&lt;/code&gt;时的启动顺序（后者又调用&lt;code&gt;StartAsync()&lt;/code&gt;）。对我们来说，最重要的部分是启动的&lt;code&gt;IHostedServices&lt;/code&gt;。从图上也可以看到，自定义&lt;code&gt;IHostedServices&lt;/code&gt;先于&lt;code&gt;GenericWebHostSevice&lt;/code&gt;启动。&lt;/p&gt;
&lt;p&gt;我们来看一个简单的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StartupHostedService&lt;/span&gt; :&lt;/span&gt; IHostedService&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; readonly ILogger _logger;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StartupHostedService&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ILogger&amp;lt;StartupHostedService&amp;gt; logger)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger = logger;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;StartAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger.LogInformation(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Starting IHostedService registered in Startup&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Task.CompletedTask;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;StopAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger.LogInformation(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Stopping IHostedService registered in Startup&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Task.CompletedTask;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们做一个简单的&lt;code&gt;IHostedService&lt;/code&gt;。希望加到&lt;code&gt;Startup.cs&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Startup&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceCollection services)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;services.AddHostedService&amp;lt;StartupHostedService&amp;gt;();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;info: demo.StartupHostedService[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]            &lt;span class=&quot;hljs-meta&quot;&gt;# 这是上边的StartupHostedService&lt;/span&gt;&lt;br/&gt;Starting IHostedService registered &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; Startup&lt;br/&gt;info: Microsoft.Hosting.Lifetime[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]            &lt;span class=&quot;hljs-meta&quot;&gt;# 这是GenericWebHostSevice&lt;/span&gt;&lt;br/&gt;Now listening &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt;: https:&lt;br/&gt;info: Microsoft.Hosting.Lifetime[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]&lt;br/&gt;Application started. Press Ctrl+C to shut down.&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如预期的那样，&lt;code&gt;IHostedService&lt;/code&gt;首先执行，然后是&lt;code&gt;GenericWebHostSevice&lt;/code&gt;。&lt;code&gt;ApplicationLifetime&lt;/code&gt;事件在所有&lt;code&gt;IHostedServices&lt;/code&gt;执行之后触发。无论在什么地方注册了&lt;code&gt;Startup.ConfigureServices()&lt;/code&gt;中的&lt;code&gt;IHostedService&lt;/code&gt;， &lt;code&gt;GenericWebHostSevice&lt;/code&gt;都在最后启动。&lt;/p&gt;

&lt;p&gt;那么问题来了，为什么&lt;code&gt;GenericWebHostSevice&lt;/code&gt;在最后启动？&lt;/p&gt;

&lt;p&gt;先看看多个&lt;code&gt;IHostedService&lt;/code&gt;的情况。&lt;/p&gt;
&lt;p&gt;当有多个&lt;code&gt;IHostedService&lt;/code&gt;的实现加入到&lt;code&gt;Startup.ConfigureServices()&lt;/code&gt;时，运行次序取决于它被加入的次序。&lt;/p&gt;
&lt;p&gt;看例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Service1&lt;/span&gt; :&lt;/span&gt; IHostedService&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; readonly ILogger _logger;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Service1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ILogger&amp;lt;Service1&amp;gt; logger)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger = logger;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;StartAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger.LogInformation(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Starting Service1&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Task.CompletedTask;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;StopAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger.LogInformation(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Stoping Service1&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Task.CompletedTask;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Service2&lt;/span&gt; :&lt;/span&gt; IHostedService&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; readonly ILogger _logger;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Service2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ILogger&amp;lt;Service2&amp;gt; logger)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger = logger;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;StartAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger.LogInformation(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Starting Service2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Task.CompletedTask;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;StopAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger.LogInformation(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Stoping Service2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Task.CompletedTask;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Startup.cs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Startup&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceCollection services)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;services.AddHostedService&amp;lt;Service1&amp;gt;();&lt;br/&gt;services.AddHostedService&amp;lt;Service2&amp;gt;();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;info: demo.Service1[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]                &lt;span class=&quot;hljs-meta&quot;&gt;# 这是Service1&lt;/span&gt;&lt;br/&gt;Starting Service1&lt;br/&gt;info: demo.Service2[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]                &lt;span class=&quot;hljs-meta&quot;&gt;# 这是Service2&lt;/span&gt;&lt;br/&gt;Starting Service2&lt;br/&gt;info: Microsoft.Hosting.Lifetime[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]        &lt;span class=&quot;hljs-meta&quot;&gt;# 这是GenericWebHostSevice&lt;/span&gt;&lt;br/&gt;Now listening &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt;: https:&lt;br/&gt;info: Microsoft.Hosting.Lifetime[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]&lt;br/&gt;Application started. Press Ctrl+C to shut down.&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;那么，&lt;code&gt;GenericWebHostSevice&lt;/code&gt;是什么时候注册的？&lt;/p&gt;
&lt;p&gt;我们看看另一个文件&lt;code&gt;Program.cs&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;CreateHostBuilder(args).Build().Run();&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; IHostBuilder &lt;span class=&quot;hljs-title&quot;&gt;CreateHostBuilder&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args)&lt;/span&gt; &lt;/span&gt;=&amp;gt;&lt;br/&gt;Host.CreateDefaultBuilder(args)&lt;br/&gt;.ConfigureWebHostDefaults(webBuilder =&amp;gt;            # 这是GenericWebHostSevice注册的位置&lt;br/&gt;{&lt;br/&gt;webBuilder.UseStartup&amp;lt;Startup&amp;gt;();&lt;br/&gt;});&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ConfigureWebHostDefaults&lt;/code&gt;扩展方法调用&lt;code&gt;ConfigureWebHost&lt;/code&gt;方法，该方法执行&lt;code&gt;Startup.ConfigureServices()&lt;/code&gt;，然后注册&lt;code&gt;GenericWebHostService&lt;/code&gt;。整理一下代码，就是下面这个样子：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; IHostBuilder &lt;span class=&quot;hljs-title&quot;&gt;ConfigureWebHost&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; IHostBuilder builder, Action&amp;lt;IWebHostBuilder&amp;gt; configure)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;var webhostBuilder = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; GenericWebHostBuilder(builder);&lt;p&gt;configure(webhostBuilder);&lt;/p&gt;&lt;p&gt;builder.ConfigureServices((context, services) =&amp;gt; services.AddHostedService&amp;lt;GenericWebHostService&amp;gt;());&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; builder;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样可以确保GenericWebHostService总是最后运行，以保持通用主机实现和&lt;code&gt;WebHost（已弃用）&lt;/code&gt;实现之间的行为一致。&lt;/p&gt;

&lt;p&gt;因此，可以采用同样的方式，让&lt;code&gt;IHostedService&lt;/code&gt;在&lt;code&gt;GenericWebHostService&lt;/code&gt;后面启动。&lt;/p&gt;

&lt;p&gt;在大多数情况下，在&lt;code&gt;GenericWebHostService&lt;/code&gt;之前启动&lt;code&gt;IHostedServices&lt;/code&gt;就可以满足常规的应用。但是，&lt;code&gt;GenericWebHostService&lt;/code&gt;还负责构建应用程序的中间件管道。如果&lt;code&gt;IHostedService&lt;/code&gt;依赖于中间件管道或路由，那么就需要将它的启动延迟到&lt;code&gt;GenericWebHostService&lt;/code&gt;完成之后。&lt;/p&gt;
&lt;p&gt;根据上面的说明，在&lt;code&gt;GenericWebHostService&lt;/code&gt;之后执行&lt;code&gt;IHostedService&lt;/code&gt;的唯一方法是将它添加到&lt;code&gt;GenericWebHostService&lt;/code&gt;之后的DI容器中。这意味着你必须跳出&lt;code&gt;Startup.ConfigureServices()&lt;/code&gt;，在调用&lt;code&gt;ConfigureWebHostDefaults&lt;/code&gt;之后，直接在&lt;code&gt;IHostBuilder&lt;/code&gt;上调用&lt;code&gt;ConfigureServices()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ProgramHostedService&lt;/span&gt; :&lt;/span&gt; IHostedService&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; readonly ILogger _logger;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ProgramHostedService&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ILogger&amp;lt;ProgramHostedService&amp;gt; logger)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger = logger;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;StartAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger.LogInformation(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Starting ProgramHostedService registered in Program&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Task.CompletedTask;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;StopAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger.LogInformation(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Stopping ProgramHostedService registered in Program&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Task.CompletedTask;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加到&lt;code&gt;Program.cs&lt;/code&gt;中：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;CreateHostBuilder(args).Build().Run();&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; IHostBuilder &lt;span class=&quot;hljs-title&quot;&gt;CreateHostBuilder&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args)&lt;/span&gt; &lt;/span&gt;=&amp;gt;&lt;br/&gt;Host.CreateDefaultBuilder(args)&lt;br/&gt;.ConfigureWebHostDefaults(webBuilder =&amp;gt;            # 这是GenericWebHostSevice注册的位置&lt;br/&gt;{&lt;br/&gt;webBuilder.UseStartup&amp;lt;Startup&amp;gt;();&lt;br/&gt;})&lt;br/&gt;.ConfigureServices(services =&amp;gt; &lt;br/&gt;services.AddHostedService&amp;lt;ProgramHostedService&amp;gt;());            # 这是ProgramHostedService注册的位置&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;info: demo.StartupHostedService[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]            &lt;span class=&quot;hljs-meta&quot;&gt;# 这是StartupHostedService&lt;/span&gt;&lt;br/&gt;Starting IHostedService registered &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; Startup&lt;br/&gt;info: Microsoft.Hosting.Lifetime[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]            &lt;span class=&quot;hljs-meta&quot;&gt;# 这是GenericWebHostSevice&lt;/span&gt;&lt;br/&gt;Now listening &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt;: https:&lt;br/&gt;info: demo.ProgramHostedService[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]            &lt;span class=&quot;hljs-meta&quot;&gt;# 这是ProgramHostedService&lt;/span&gt;&lt;br/&gt;Starting ProgramHostedService registered &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; Program&lt;br/&gt;info: Microsoft.Hosting.Lifetime[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]&lt;br/&gt;Application started. Press Ctrl+C to shut down.&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，在关闭应用时，&lt;code&gt;IHostedServices&lt;/code&gt;被反向停止，所以&lt;code&gt;ProgramHostedService&lt;/code&gt;首先停止，接着是&lt;code&gt;GenericWebHostSevice&lt;/code&gt;，最后是&lt;code&gt;StartupHostedService&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;info&lt;/span&gt;: &lt;span class=&quot;hljs-selector-tag&quot;&gt;Microsoft&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.Hosting&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.Lifetime&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[0]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;shutting&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;down&lt;/span&gt;...&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;info&lt;/span&gt;: &lt;span class=&quot;hljs-selector-tag&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.ProgramHostedService&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[0]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Stopping&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;ProgramHostedService&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;registered&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;Program&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;info&lt;/span&gt;: &lt;span class=&quot;hljs-selector-tag&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.StartupHostedService&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[0]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Stopping&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;IHostedService&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;registered&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;Startup&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;最后总结一下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IHostedServices&lt;/code&gt;的执行顺序与它们在&lt;code&gt;Startup.configureservices()&lt;/code&gt;中添加到DI容器中的顺序相同。运行侦听HTTP请求的&lt;code&gt;Kestrel&lt;/code&gt;服务器的&lt;code&gt;GenericWebHostSevice&lt;/code&gt;总是注册的&lt;code&gt;IHostedServices&lt;/code&gt;之后运行。&lt;/p&gt;
&lt;p&gt;要在&lt;code&gt;GenericWebHostSevice&lt;/code&gt;之后启动&lt;code&gt;IHostedService&lt;/code&gt;，需要在&lt;code&gt;Program.cs&lt;/code&gt;中的&lt;code&gt;IHostBuilder上&lt;/code&gt;的&lt;code&gt;ConfigureServices()&lt;/code&gt;扩展方法中进行注册。&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;
&lt;p&gt;本文的代码在：&lt;a href=&quot;https://github.com/humornif/Demo-Code/tree/master/0024/demo&quot;&gt;https://github.com/humornif/Demo-Code/tree/master/0024/demo&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/907112/202005/907112-20200527230728396-985375280.jpg&quot; alt=&quot;&quot; width=&quot;160&quot; height=&quot;160&quot;/&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;微信公众号：老王Plus&lt;/p&gt;
&lt;p&gt;扫描二维码，关注个人公众号，可以第一时间得到最新的个人文章和内容推送&lt;/p&gt;
&lt;p&gt;本文版权归作者所有，转载请保留此声明和原文链接&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 09 Sep 2020 00:10:00 +0000</pubDate>
<dc:creator>老王Plus</dc:creator>
<og:description>想写好中间件，这是基础。 一、前言 今天这个内容，基于于ASP.NET Core 3.x。 从3.x开始，ASP.NET Core使用了通用主机模式。它将WebHostBuilder放到了通用的IHo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tiger-wang/p/13636641.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】各种各样形状的组件 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13636789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13636789.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071041930-1600506941.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;老孟导读&lt;/strong&gt;：Flutter中很多组件都有一个叫做&lt;code&gt;shape&lt;/code&gt;的属性，类型是&lt;code&gt;ShapeBorder&lt;/code&gt;，比如&lt;strong&gt;Button&lt;/strong&gt;类、&lt;strong&gt;Card&lt;/strong&gt;等组件，&lt;code&gt;shape&lt;/code&gt;表示控件的形状，系统已经为我们提供了很多形状，对于没有此属性的组件，可以使用 &lt;strong&gt;Clip&lt;/strong&gt; 类组件进行裁减。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;beveledrectangleborder&quot;&gt;BeveledRectangleBorder&lt;/h2&gt;
&lt;p&gt;斜角矩形边框，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: BeveledRectangleBorder(
      side: BorderSide(width: 1, color: Colors.red),
      borderRadius: BorderRadius.circular(10)),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071042187-822513215.png&quot; alt=&quot;image-20200522172909192&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果设置的半径比控件还大，就会变成&lt;strong&gt;菱形&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt; 3RaisedButton(
  shape: BeveledRectangleBorder(
      side: BorderSide(width: 1, color: Colors.red),
      borderRadius: BorderRadius.circular(100)),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071042338-2104017426.png&quot; alt=&quot;image-20200522173147073&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理，如果半径设置为0，就是矩形。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: BeveledRectangleBorder(
      side: BorderSide(width: 1, color: Colors.red),
      borderRadius: BorderRadius.circular(0)),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071042491-2034576295.png&quot; alt=&quot;image-20200522173458904&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;border&quot;&gt;Border&lt;/h2&gt;
&lt;p&gt;Border允许单独设置每一个边上的线条样式.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: Border(
    top: BorderSide(color: Colors.red,width: 2)
  ),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071042665-2134410992.png&quot; alt=&quot;image-20200522173801387&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置全部&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
        shape: Border(
          top: BorderSide(color: Colors.red,width: 10),
          right: BorderSide(color: Colors.blue,width: 10),
          bottom: BorderSide(color: Colors.yellow,width: 10),
          left: BorderSide(color: Colors.green,width: 10),
        ),
        child: Text('老孟'),
        onPressed: () {},
      )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071042798-616809994.png&quot; alt=&quot;image-20200522182443777&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;borderdirectional&quot;&gt;BorderDirectional&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;BorderDirectional&lt;/strong&gt;和&lt;strong&gt;Border&lt;/strong&gt;基本一样，区别就是&lt;strong&gt;BorderDirectional&lt;/strong&gt;带有阅读方向，大部分国家阅读是从左到右，但有的国家是从右到左的，比如阿拉伯等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: BorderDirectional(
    start: BorderSide(color: Colors.red,width: 2),
    end: BorderSide(color: Colors.blue,width: 2),
  ),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071042953-1463455665.png&quot; alt=&quot;image-20200522182150780&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;circleborder&quot;&gt;CircleBorder&lt;/h2&gt;
&lt;p&gt;圆形&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: CircleBorder(side: BorderSide(color: Colors.red)),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071043206-1571996567.png&quot; alt=&quot;image-20200522182549205&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;continuousrectangleborder&quot;&gt;ContinuousRectangleBorder&lt;/h2&gt;
&lt;p&gt;连续的圆角矩形，直线和圆角平滑连续的过渡，和RoundedRectangleBorder相比，圆角效果会小一些。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: ContinuousRectangleBorder(
      side: BorderSide(color: Colors.red),
      borderRadius: BorderRadius.circular(20)),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071043354-672552536.png&quot; alt=&quot;image-20200522182922984&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;roundedrectangleborder&quot;&gt;RoundedRectangleBorder&lt;/h2&gt;
&lt;p&gt;圆角矩形&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: RoundedRectangleBorder(
      side: BorderSide(color: Colors.red),
      borderRadius: BorderRadius.circular(10)),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071043500-1896534059.png&quot; alt=&quot;image-20200522183032650&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;stadiumborder&quot;&gt;StadiumBorder&lt;/h2&gt;
&lt;p&gt;类似&lt;strong&gt;足球场&lt;/strong&gt;的形状，两边圆形，中间矩形&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: StadiumBorder(
      side: BorderSide(color: Colors.red),),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071043653-857992254.png&quot; alt=&quot;image-20200522183814823&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;outlineinputborder&quot;&gt;OutlineInputBorder&lt;/h2&gt;
&lt;p&gt;带外边框&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: OutlineInputBorder(
    borderSide: BorderSide(color: Colors.red),
    borderRadius: BorderRadius.circular(10),
  ),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071043784-1622393886.png&quot; alt=&quot;image-20200522184044810&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;underlineinputborder&quot;&gt;UnderlineInputBorder&lt;/h2&gt;
&lt;p&gt;下划线边框&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  shape: UnderlineInputBorder(
    borderSide: BorderSide(color: Colors.red),
  ),
  child: Text('老孟'),
  onPressed: () {},
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071043951-933313724.png&quot; alt=&quot;image-20200522184216659&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cliprect&quot;&gt;ClipRect&lt;/h2&gt;
&lt;p&gt;ClipRect组件使用矩形裁剪子组件，通常情况下，ClipRect作用于&lt;code&gt;CustomPaint&lt;/code&gt; 、 &lt;code&gt;CustomSingleChildLayout&lt;/code&gt; 、 &lt;code&gt;CustomMultiChildLayout&lt;/code&gt; 、 &lt;code&gt;Align&lt;/code&gt; 、 &lt;code&gt;Center&lt;/code&gt; 、 &lt;code&gt;OverflowBox&lt;/code&gt; 、 &lt;code&gt;SizedOverflowBox&lt;/code&gt;组件，例如ClipRect作用于Align，可以仅显示上半部分，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ClipRect(
  child: Align(
    alignment: Alignment.topCenter,
    heightFactor: 0.5,
    child: Container(
      height: 150,
      width: 150,
      child: Image.asset(
        'images/1.png',
        fit: BoxFit.cover,
      ),
    ),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全图效果：&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200324160500474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmdrczE5ODc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;p&gt;裁剪效果：&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200324160537832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmdrczE5ODc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;p&gt;&lt;code&gt;clipper&lt;/code&gt;参数定义裁剪规则，下面具体介绍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clipBehavior&lt;/code&gt;参数定义了裁剪的方式，只有子控件超出父控件的范围才有裁剪的说法，各个方式说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;none：不裁剪，系统默认值，如果子组件不超出边界，此值没有任何性能消耗。&lt;/li&gt;
&lt;li&gt;hardEdge：裁剪但不应用抗锯齿，速度比&lt;code&gt;none&lt;/code&gt;慢一点，但比其他方式快。&lt;/li&gt;
&lt;li&gt;antiAlias：裁剪而且抗锯齿，此方式看起来更平滑，比&lt;code&gt;antiAliasWithSaveLayer&lt;/code&gt;快，比&lt;code&gt;hardEdge&lt;/code&gt;慢，通常用于处理圆形和弧形裁剪。&lt;/li&gt;
&lt;li&gt;antiAliasWithSaveLayer：裁剪、抗锯齿而且有一个缓冲区，此方式很慢，用到的情况比较少。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;cliprrect&quot;&gt;ClipRRect&lt;/h2&gt;
&lt;p&gt;ClipRRect组件可以对子组件进行圆角裁剪，默认圆角半径为0，注意ClipRRect有2个R，不是上面介绍的ClipRect。&lt;/p&gt;
&lt;p&gt;用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ClipRRect(
  borderRadius: BorderRadius.circular(20),
  child: Container(
    height: 150,
    width: 150,
    child: Image.asset(
      'images/1.png',
      fit: BoxFit.cover,
    ),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200324160615913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmdrczE5ODc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;h2 id=&quot;clipoval&quot;&gt;ClipOval&lt;/h2&gt;
&lt;p&gt;ClipOval裁剪为椭圆形，椭圆形的大小为正切父组件，因此如果父组件为正方形，切出来是圆形，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ClipOval(
  child: Container(
    height: 150,
    width: 250,
    child: Image.asset(
      'images/1.png',
      fit: BoxFit.cover,
    ),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200324160734820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmdrczE5ODc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;h2 id=&quot;clippath&quot;&gt;ClipPath&lt;/h2&gt;
&lt;p&gt;ClipPath组件根据路径进行裁剪，我们自定义裁剪路径也可以使用系统提供的，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ClipPath.shape(
  shape: StadiumBorder(),
  child: Container(
    height: 150,
    width: 250,
    child: Image.asset(
      'images/1.png',
      fit: BoxFit.cover,
    ),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;shape&lt;/code&gt;参数是ShapeBorder类型，系统已经定义了很多形状，介绍如下：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;RoundedRectangleBorder：圆角矩形&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ContinuousRectangleBorder：直线和圆角平滑连续的过渡，和RoundedRectangleBorder相比，圆角效果会小一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;StadiumBorder：类似于足球场的形状，两端半圆。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BeveledRectangleBorder：斜角矩形。效果如图：&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200324160806686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmdrczE5ODc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CircleBorder：圆形。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;customclipper&quot;&gt;CustomClipper&lt;/h2&gt;
&lt;p&gt;CustomClipper并不是一个组件，而是一个&lt;code&gt;abstract&lt;/code&gt;(抽象)类，使用CustomClipper可以绘制出任何我们想要的形状，比如三角形，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;@override
Widget build(BuildContext context) {
  return Center(
    child: ClipPath(
      clipper: TrianglePath(),
      child: Container(
        height: 150,
        width: 250,
        child: Image.asset(
          'images/1.png',
          fit: BoxFit.cover,
        ),
      ),
    ),
  );
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义TrianglePath代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class TrianglePath extends CustomClipper&amp;lt;Path&amp;gt;{
  @override
  Path getClip(Size size) {
    var path = Path();
    path.moveTo(size.width/2, 0);
    path.lineTo(0, size.height);
    path.lineTo(size.width, size.height);
    return path;
  }

  @override
  bool shouldReclip(CustomClipper&amp;lt;Path&amp;gt; oldClipper) {
    return true;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200324160835511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmdrczE5ODc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;p&gt;我们还可以绘制五角星，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class StarPath extends CustomClipper&amp;lt;Path&amp;gt; {
  StarPath({this.scale = 2.5});

  final double scale;

  double perDegree = 36;

  /// 角度转弧度公式
  double degree2Radian(double degree) {
    return (pi * degree / 180);
  }

  @override
  Path getClip(Size size) {
    var R = min(size.width / 2, size.height / 2);
    var r = R / scale;
    var x = size.width / 2;
    var y = size.height / 2;

    var path = Path();
    path.moveTo(x, y - R);
    path.lineTo(x - sin(degree2Radian(perDegree)) * r,
        y - cos(degree2Radian(perDegree)) * r);
    path.lineTo(x - sin(degree2Radian(perDegree * 2)) * R,
        y - cos(degree2Radian(perDegree * 2)) * R);
    path.lineTo(x - sin(degree2Radian(perDegree * 3)) * r,
        y - cos(degree2Radian(perDegree * 3)) * r);
    path.lineTo(x - sin(degree2Radian(perDegree * 4)) * R,
        y - cos(degree2Radian(perDegree * 4)) * R);
    path.lineTo(x - sin(degree2Radian(perDegree * 5)) * r,
        y - cos(degree2Radian(perDegree * 5)) * r);
    path.lineTo(x - sin(degree2Radian(perDegree * 6)) * R,
        y - cos(degree2Radian(perDegree * 6)) * R);
    path.lineTo(x - sin(degree2Radian(perDegree * 7)) * r,
        y - cos(degree2Radian(perDegree * 7)) * r);
    path.lineTo(x - sin(degree2Radian(perDegree * 8)) * R,
        y - cos(degree2Radian(perDegree * 8)) * R);
    path.lineTo(x - sin(degree2Radian(perDegree * 9)) * r,
        y - cos(degree2Radian(perDegree * 9)) * r);
    path.lineTo(x - sin(degree2Radian(perDegree * 10)) * R,
        y - cos(degree2Radian(perDegree * 10)) * R);
    return path;
  }

  @override
  bool shouldReclip(StarPath oldClipper) {
    return oldClipper.scale != this.scale;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scale&lt;/code&gt;参数表示间隔的点到圆心的缩放比例，五角星效果如下：&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/2020032416085643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmdrczE5ODc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;p&gt;下面用动画动态设置&lt;code&gt;scale&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class StartClip extends StatefulWidget {
  @override
  State&amp;lt;StatefulWidget&amp;gt; createState() =&amp;gt; _StartClipState();
}

class _StartClipState extends State&amp;lt;StartClip&amp;gt;
    with SingleTickerProviderStateMixin {
  AnimationController _controller;
  Animation _animation;

  @override
  void initState() {
    _controller =
        AnimationController(duration: Duration(seconds: 2), vsync: this)
          ..addStatusListener((status) {
            if (status == AnimationStatus.completed) {
              _controller.reverse();
            } else if (status == AnimationStatus.dismissed) {
              _controller.forward();
            }
          });
    _animation = Tween(begin: 1.0, end: 4.0).animate(_controller);
    _controller.forward();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: AnimatedBuilder(
          animation: _animation,
          builder: (context, child) {
            return ClipPath(
              clipper: StarPath(scale: _animation.value),
              child: Container(
                height: 150,
                width: 150,
                color: Colors.red,
              ),
            );
          }),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071044566-2129401670.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071044894-796337596.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200909071045126-1689860059.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 08 Sep 2020 23:11:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：Flutter中很多组件都有一个叫做shape的属性，类型是ShapeBorder，比如Button类、Card等组件，shape表示控件的形状，系统已经为我们提供了很多形状，对于没有此属性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13636789.html</dc:identifier>
</item>
<item>
<title>数据分析与数据挖掘 - 04科学计算 - 马一特</title>
<link>http://www.cnblogs.com/mayite/p/13636770.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayite/p/13636770.html</guid>
<description>&lt;h3 id=&quot;一-认识科学计算&quot;&gt;一 认识科学计算&lt;/h3&gt;
&lt;p&gt;在人工智能的研发中，其本质就是把一切问题转化为数学问题，所以数学运算非常重要。很多数学运算采用的都是numpy这个库，因为它提供了非常多的科学计算的方法，能让我们的工作变得非常便利，这一章我将从numpy的基本使用开始，逐渐解决掉那些数学问题，让Python与数学能够更紧密的结合在一起。&lt;/p&gt;
&lt;h3 id=&quot;二-认识numpy&quot;&gt;二 认识numpy&lt;/h3&gt;
&lt;p&gt;numpy的本质其实还是一个多维数组，虽然我们之前学习过数组对象(Python中的list或者tuple)和numpy的数据看似一样，但是数组是无法直接参与数值运算的，而numpy对象却可以。&lt;/p&gt;
&lt;h3 id=&quot;三-数组创建&quot;&gt;三 数组创建&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np

arr1 = np.array([1, 2, 3, 4, 5, 6])
arr2 = np.array([[1, 2, 3, 4, ], [5, 6, 7, 8, ]])
print(arr1, arr1.shape, arr1.dtype)
print(arr2, arr2.shape, arr1.dtype)  # shape获取数组形状2行4列，dtype获取数组中元素类型
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们创建数组时，元素类型不一样，numpy会给我们自动处理成一样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;arr3 = np.array([1, 2.5, 3])  # 只要数组元素中出现float类型，就会全部处理成float
print(arr3, arr3.dtype)
arr4 = np.array(['4', 5, 5.6])  # 只要数组元素中出现str，就会全部处理成str
print(arr4, arr4.dtype)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四-数组访问&quot;&gt;四 数组访问&lt;/h3&gt;
&lt;p&gt;numpy的访问与Python中list或者tuple访问原理一样，方法也非常类似，只不过是加了一个纬度的概念。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 首先我们定义了一个二维数组
arr5 = np.array([[1, 2, 3],
                 [4, 5, 6],
                 [7, 8, 9],
                 [10, 11, 12]])

print(arr5[1])  # 第一行 [4 5 6]
print(arr5[1][0])  # 第一行第0个 4
print(arr5[:, 2])  # 所有行第2个 [ 3  6  9 12]
print(arr5[:2])  # 前2行 [[1 2 3] [4 5 6]]
print(arr5[1, :])  # 第1行所有列 [4 5 6]
print(arr5[:, 1:2])  # 所有行第2到第3列 [[ 2] [ 5] [ 8] [11]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于二维来说，如果有逗号，逗号前是行筛选，逗号后是列筛选。对于n维来说，第一个逗号前是第一维，后面依次是二维三维等。&lt;/p&gt;
&lt;h3 id=&quot;五-形状处理&quot;&gt;五 形状处理&lt;/h3&gt;
&lt;h4 id=&quot;1-预览修改与真正修改&quot;&gt;1 预览修改与真正修改&lt;/h4&gt;
&lt;p&gt;numpy对象有一个shape属性，在Python基础中，对于形状并不敏感，而在科学计算中，形状却很重要，在后面的算法模型计算中，我们会使用地很频繁。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 定义一个6行3列的numpy数组对象
arr6 = np.array([[1, 2, 3],
                 [4, 5, 6],
                 [7, 8, 9],
                 [10, 11, 12],
                 [13, 14, 15],
                 [16, 17, 18]])

print(arr6.shape)  # 注意看每次打印的结果
print(arr6.reshape(2, 9))  # 得到一个新的形状，原来的对象不变
print(arr6.shape, arr6)
print(arr6.resize(2, 9))  # 无返回值，真正修改
print(arr6.shape, arr6)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在这段代码中，分别使用了reshape和resize两种方法来对数组进行形状上的改变。其中reshape只是返回改变形状后的预览状态，或者说如果我们要使用这个结果只能把结果赋值给一个单独的变量，然后再进行使用。resize方法的返回结果为空，但是它却真正的改变了组数的形状，仔细看打印结果你就能够发现这两种形状操作方法的区别了。&lt;/p&gt;
&lt;h4 id=&quot;2-降维操作&quot;&gt;2 降维操作&lt;/h4&gt;
&lt;p&gt;降维是人工智能算法中非常常用且重要的一个操作，原因是有时我们去描述一个事物的特征时，会有非常多的维度，但过多的维度会给我们的计算带来麻烦，这个时候我们就需要去降低它的维度，然后再进行计算。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;arr7 = np.array([[1, 10, 100], [2, 20, 200], [3, 30, 300]])

# 按照数组的行顺序降至一维
print(arr7)
print(arr7.ravel())
print(arr7.reshape(-1))
print(arr7.flatten())

# 按照大小顺序降至一维
print(arr7.ravel(order=&quot;F&quot;))
print(arr7.reshape(-1, order=&quot;F&quot;))
print(arr7.flatten(order=&quot;F&quot;))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;降维后再进行修改&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print('ravel：{}'.format(arr7.ravel()))
arr7.ravel()[1] = 1000
print(arr7)

print('reshape: {}'.format(arr7.reshape(-1)))
arr7.reshape(-1)[2] = 3000
print(arr7)

print('flatten: {}'.format(arr7.flatten()))
arr7.flatten()[0] = 2000
print(arr7)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果中，我们看到通过flatten方法实现的降维返回的是复制的操作，如果要用，那么只能把结果赋值给另外的变量了。它并没有影响原来数组的结果。通过ravel和reshape两个方法，返回的则是视图，也就是通过对视图的修改，是会直接影响到原数组中的值的。&lt;/p&gt;
&lt;h4 id=&quot;3-数组堆叠&quot;&gt;3 数组堆叠&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;arr8 = np.array([[1, 10, 100], [2, 20, 200], [3, 30, 300]])
arr9 = np.array([1, 2, 3])
arr10 = np.array([[5], [6], [7]])

# 纵向堆叠
print(np.vstack([arr8, arr9]))
print(np.row_stack([arr8, arr9]))

# 横向合并
print(np.hstack([arr8, arr10]))
print(np.column_stack([arr8, arr10]))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是：多个数组横向堆叠时，要保证行数相同，纵向合并，则要保证列数相同。&lt;/p&gt;
&lt;h3 id=&quot;六-基本运算&quot;&gt;六 基本运算&lt;/h3&gt;
&lt;h4 id=&quot;1-四则运算&quot;&gt;1 四则运算&lt;/h4&gt;
&lt;p&gt;在以前，我们如果要对两个同形状的数组进行对应位置的四则运算时，我们必须要对两个数组进行循环处理，代码量上来说并不少，并且容易出错。有了NumPy之后，这些运算将会变的非常的简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np

arr1 = np.array([11, 12, 13])
arr2 = np.array([21, 22, 23])
arr3 = np.array([31, 32, 33])

print(arr1 + arr2)
print(arr1 + arr2 + arr3)
print(arr1 - arr2)
print(arr1 - arr2 - arr3)
print(arr1 * arr2)
print(arr1 * arr2 * arr3)
print(arr1 / arr2)
print(arr1 / arr2 / arr3)
print(arr1 // arr2)
print(arr1 % arr2)
print(arr1 ** arr2)

print(np.add(arr1, arr2))
print(np.add(np.add(arr1, arr2), arr3))
print(np.subtract(arr1, arr2))
print(np.multiply(arr1, arr2))
print(np.divide(arr1, arr2))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码的运行结果中我们可以看到，当我们使用符号进行四则运算的时候，是可以连续进行操作的。当我们使用对象的方法进行四则运算的时候，不可以连续进行操作，因为这个方法只接收两个参数。如果我们想要对多个数组对象进行操作的时候，我们必须使用方法嵌套的方式来进行操作。除了四则运算，在学习Python基础时，所学习的取余数、整除、幂运算等都是支持的。&lt;/p&gt;
&lt;h4 id=&quot;2-比较运算&quot;&gt;2 比较运算&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(arr1 &amp;lt;= arr2)
print(arr1 == arr2)
print(arr1 != arr2)

print(np.greater(arr1, arr2))
print(np.greater_equal(arr1, arr2))
print(np.less(arr1, arr2))
print(np.less_equal(arr1, arr2))
print(np.equal(arr1, arr2))
print(np.not_equal(arr1, arr2))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果上看，运用比较运算符可以返回布尔类型的值，也就是True和False。那我们什么时候会用到这样的运算呢？第一种情况是从数组中查询满足条件的元素，第二种情况是根据判断的结果执行不同的操作，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;arr3 = np.array([23, 12, 25])
arr4 = np.array([21, 15, 23])

print(arr3[arr3 &amp;gt; arr4])  # 取出arr3中元素大于arr4的
print(arr3[arr3 &amp;gt; 24])  # 取出arr3中元素大于24的
print(np.where(arr3 &amp;gt; 24, 0, arr3))  # 类似三元表达式，把大于24的修改成0，其他不变
print(list(0 if x &amp;gt; 24 else x for x in arr3))
print(np.where(arr4 &amp;gt; 16, 0, arr4))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-广播运算&quot;&gt;3 广播运算&lt;/h4&gt;
&lt;p&gt;上面我们所有的运算都是基于相同形状的数组，那么当数组形状不同时，能够让它们之间进行运算吗？答案是肯定的，但是有相应的规则，不能随意计算，这种计算就叫做广播运算。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 1 广播运算，末尾的纬度值加上去
arr3 = np.arange(60).reshape(5, 4, 3)
arr4 = np.arange(12).reshape(4, 3)
print(arr3)
print(arr4)
print(arr3 + arr4)

# 2 纬度值有一个为1
arr5 = np.arange(60).reshape(5, 4, 3)
arr6 = np.arange(4).reshape(4, 1)
print(arr5)
print(arr6)
print(arr5 + arr6)

# 3 arr7会自动补齐，类似上面纬度值有一个为1
arr7 = np.arange(12).reshape(4, 3)
arr8 = np.array([1, 2, 3])
print(arr7)
print(arr8)
print(arr7 + arr8)

arr9 = np.arange(60).reshape(5, 4, 3)
arr10 = np.arange(8).reshape(4, 2)
print(arr9)
print(arr10)
# print(arr9 + arr10)  # 不在上述三种讨论范围内，无法运算
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实，广播运算中的广播就是一对多，它的规律就是两者有相似的地方可以对应的上就能运算，缺少的部分，会自动用相同的部分补齐。&lt;/p&gt;
&lt;h3 id=&quot;七-数学函数&quot;&gt;七 数学函数&lt;/h3&gt;
&lt;p&gt;numpy提供给我们一些常见的函数，除了np.pi或者np.e这样的常量函数，numpy也提供给我们很多数学函数供我们直接调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np

arr1 = np.array([1.3, 1.5, -1.8, 2.4, 3.2])
arr2 = np.array([1, 2, 3, 4, 5])

print(np.fabs(arr1))  # 绝对值
print(np.ceil(arr1))  # 向上取整
print(np.floor(arr1))  # 向下取整
print(np.round(arr1))  # 四舍五入
print(np.fmod(arr2, arr1))  # 余数
print(np.modf(arr1))  # 取小数部分和整数部分
print(np.sqrt(arr2))  # 算法平方根
print(np.square(arr2))  # 平方
print(np.exp(arr2))  # 以e为底的指数
print(np.power(arr2, 3))  # 各元素的3次方
print(np.log2(arr2))  # 以2为底的对数
print(np.log10(arr2))  # 以10为底的对数
print(np.log(arr2))  # 以e为底的对数
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;八-轴方向&quot;&gt;八 轴方向&lt;/h3&gt;
&lt;p&gt;数组对象有几个维度就有几个轴，对于我们常见的二维数组来说，轴0是竖直方向，轴1是水平方向。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np

arr1 = np.array([[3, 7, 25, 8, 15, 20],
                 [4, 5, 6, 9, 14, 21]])

print(arr1)
print(np.max(arr1))  # 所有数组元素最大值
print(np.max(arr1, axis=1))  # 轴1最大值
print(np.max(arr1, axis=0))  # 轴0最大值
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;numpy提供了很多可以按照轴方向来计算的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(np.min(arr1, axis=0))  # 最小值
print(np.min(arr1, axis=1))
print(np.mean(arr1, axis=0))  # 平均值
print(np.median(arr1, axis=0))  # 中位数
print(np.sum(arr1, axis=1))  # 求和
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 08 Sep 2020 22:09:00 +0000</pubDate>
<dc:creator>马一特</dc:creator>
<og:description>一 认识科学计算 在人工智能的研发中，其本质就是把一切问题转化为数学问题，所以数学运算非常重要。很多数学运算采用的都是numpy这个库，因为它提供了非常多的科学计算的方法，能让我们的工作变得非常便利，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mayite/p/13636770.html</dc:identifier>
</item>
<item>
<title>高可用服务之Keepalived基础入门 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13634755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13634755.html</guid>
<description>&lt;p&gt;　　前面我们聊了聊高可用集群corosync+pacemaker的相关概念以及相关工具的使用和说明，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/category/1838133.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/category/1838133.html&lt;/a&gt;；今天我们说一下高可用服务keepalived；&lt;/p&gt;
&lt;p&gt;　　keepalived相对corosync+pacemaker这种高可用集群，它要轻量很多；它的工作原理就是vrrp的实现；vrrp（Virtual Router Redundancy Protocol，虚拟路由冗余协议 ），设计之初它主要用于对LVS集群的高可用，同时它也能够对LVS后端real server做健康状态检测；它主要功能有基于vrrp协议完成地址流动，从而实现服务的故障转移；为VIP地址所在的节点生成ipvs规则；为ipvs集群的各RS做健康状态检测；基于脚本调用接口通过执行脚本完成脚本中定义的功能，进而影响集群事务；&lt;/p&gt;
&lt;p&gt;　　keepalved架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908212425424-2009331704.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：keepalived的主要由vrrp stack、checkers、ipvs wrapper以及控制组件配置文件分析器，IO复用器，内存管理这些组件组成，其中vrrp stack 是用来实现vip的高可用；checkers用于基于不同协议对后端服务做检测，它两都是基于系统调用和SMTP协议来完成对vip的转移，以及故障转移后的邮件通知，以及vip和后端服务的检测；ipvs wrapper主要用于生成ipvs规则；而对于keepalved的核心组件vrrp stack 和checkers是由watchdog进程一直监控着，一旦vrrp stack 或者checkers宕掉，watchdog会立即启动一个新的vrrp stack或checkers，从而保证了keepalived自身的组件的高可用；&lt;/p&gt;
&lt;p&gt;　　keepalived实现&lt;/p&gt;
&lt;p&gt;　　环境说明&lt;/p&gt;
&lt;p&gt;　　准备两台keepalived服务器，各server必须满足时间同步，确保iptables及selinux都是关闭着；如果有必要可以配置各节点通过hosts文件解析以及各节点的ssh互信，后面的主机名解析和ssh互信不是必须的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908214913884-1428874590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908214943226-775911138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：有关ssh互信，可以参考本人博客&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/11783371.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/11783371.html&lt;/a&gt;；除了确保以上几条外，还需要确保我们的网卡支持多播功能；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908222510002-864363419.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果网卡没有启动多播功能需要用ip link set multicast on dev 网卡名称即可；&lt;/p&gt;
&lt;p&gt;　　安装keepalived程序包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
yum install keepalived -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：两节点都要安装；&lt;/p&gt;
&lt;p&gt;　　查看keepalived的程序环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# rpm -ql keepalived
/etc/keepalived
/etc/keepalived/keepalived.conf
/etc/sysconfig/keepalived
/usr/bin/genhash
/usr/lib/systemd/system/keepalived.service
/usr/libexec/keepalived
/usr/sbin/keepalived
/usr/share/doc/keepalived-1.3.5
/usr/share/doc/keepalived-1.3.5/AUTHOR
/usr/share/doc/keepalived-1.3.5/CONTRIBUTORS
/usr/share/doc/keepalived-1.3.5/COPYING
/usr/share/doc/keepalived-1.3.5/ChangeLog
/usr/share/doc/keepalived-1.3.5/NOTE_vrrp_vmac.txt
/usr/share/doc/keepalived-1.3.5/README
/usr/share/doc/keepalived-1.3.5/TODO
/usr/share/doc/keepalived-1.3.5/keepalived.conf.SYNOPSIS
/usr/share/doc/keepalived-1.3.5/samples
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.HTTP_GET.port
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.IPv6
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.SMTP_CHECK
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.SSL_GET
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.fwmark
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.inhibit
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.misc_check
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.misc_check_arg
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.quorum
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.sample
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.status_code
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.track_interface
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.virtual_server_group
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.virtualhost
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.localcheck
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.lvs_syncd
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.routes
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.rules
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.scripts
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.static_ipaddress
/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.sync
/usr/share/doc/keepalived-1.3.5/samples/sample.misccheck.smbcheck.sh
/usr/share/man/man1/genhash.1.gz
/usr/share/man/man5/keepalived.conf.5.gz
/usr/share/man/man8/keepalived.8.gz
/usr/share/snmp/mibs/KEEPALIVED-MIB.txt
/usr/share/snmp/mibs/VRRP-MIB.txt
/usr/share/snmp/mibs/VRRPv3-MIB.txt
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：主配置文件是/etc/keepalived/keepalived.conf；主程序文件/usr/sbin/keepalived；unit file是/usr/lib/systemd/system/keepalived.service；unit file的环境配置文件是/etc/sysconfig/keepalived；&lt;/p&gt;
&lt;p&gt;　　keepalived默认配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# cat /etc/keepalived/keepalived.conf
! Configuration File for keepalived

global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.200.16
        192.168.200.17
        192.168.200.18
    }
}

virtual_server 192.168.200.100 443 {
    delay_loop 6
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 192.168.201.100 443 {
        weight 1
        SSL_GET {
            url {
              path /
              digest ff20ad2481f97b1754ef3e12ecd3a9cc
            }
            url {
              path /mrtg/
              digest 9b3a0c85a887a256d6939da88aabd8cd
            }
            connect_timeout 3
            nb_get_retry 3
            delay_before_retry 3
        }
    }
}

virtual_server 10.10.10.2 1358 {
    delay_loop 6
    lb_algo rr 
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    sorry_server 192.168.200.200 1358

    real_server 192.168.200.2 1358 {
        weight 1
        HTTP_GET {
            url { 
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url { 
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url { 
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            connect_timeout 3
            nb_get_retry 3
            delay_before_retry 3
        }
    }

    real_server 192.168.200.3 1358 {
        weight 1
        HTTP_GET {
            url { 
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334c
            }
            url { 
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334c
            }
            connect_timeout 3
            nb_get_retry 3
            delay_before_retry 3
        }
    }
}

virtual_server 10.10.10.3 1358 {
    delay_loop 3
    lb_algo rr 
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 192.168.200.4 1358 {
        weight 1
        HTTP_GET {
            url { 
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url { 
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url { 
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            connect_timeout 3
            nb_get_retry 3
            delay_before_retry 3
        }
    }

    real_server 192.168.200.5 1358 {
        weight 1
        HTTP_GET {
            url { 
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url { 
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url { 
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            connect_timeout 3
            nb_get_retry 3
            delay_before_retry 3
        }
    }
}
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：keepalived的配置文件主要由global configuration、vrrpdconfiguration、LVS configuration这三部分配置段组成；其中global配置段主要定义全局属性以及静态路由和地址相关配置；vrrp配置段主要定义VRRP实例或vrrp同步组相关配置；LVS配置段主要定义IPVS集群和LVS后端各real server相关的配置；&lt;/p&gt;
&lt;p&gt;　　keepalived配置说明&lt;/p&gt;
&lt;p&gt;　　全局配置常用指令说明&lt;/p&gt;
&lt;p&gt;　　global_defs {...}：用于定义全局配置段，在这个配置段里可以配置全局属性，以及邮件通知相关配置；&lt;/p&gt;
&lt;p&gt;　　notification_email {...}:该配置段是globald_defs配置段的一个子配置段用于配置当集群发生状态变化时，接受通知的邮箱；&lt;/p&gt;
&lt;p&gt;　　notification_email_from：用于指定发送邮件的发件人邮箱地址；&lt;/p&gt;
&lt;p&gt;　　smtp_server：用于指定邮件服务器地址；&lt;/p&gt;
&lt;p&gt;　　smtp_connect_timeout：用于指定邮件服务器连接超时时间；&lt;/p&gt;
&lt;p&gt;　　router_id：集群节点ID，通常这个ID是唯一的，不和其他节点相同；&lt;/p&gt;
&lt;p&gt;　　vrrp_skip_check_adv_addr：忽略检查通告vrrp通告和上一次接收的vrrp是同master地址的通告；&lt;/p&gt;
&lt;p&gt;　　vrrp_strict：严格遵守VRRP协议；&lt;/p&gt;
&lt;p&gt;　　vrrp_garp_interval：设定同一接口的两次arp广播的延迟时长，默认为0表示不延迟；&lt;/p&gt;
&lt;p&gt;　　vrrp_gna_interval：设定同一接口的两次na消息延迟时长，默认为0表示不延迟；&lt;/p&gt;
&lt;p&gt;　　vrrp_mcast_group4：设定组播ip地址，默认是224.0.0.18；组播地址是一个D类地址，它的范围是224.0.0.0-239.255.255.255；&lt;/p&gt;
&lt;p&gt;　　vrrp_iptables：关闭生成iptables规则；&lt;/p&gt;
&lt;p&gt;　　vrrp实例常用指令&lt;/p&gt;
&lt;p&gt;　　vrrp_instance：指定一个vrrp示例名称，并引用一个配置实例上下文配置段用大括号括起来；&lt;/p&gt;
&lt;p&gt;　　state：用于定义该vrrp实例的角色，常用的有MASTER和BACKUP两个角色，并且多个节点上同虚拟路由id的实例，只能有一个MASTER角色且优先级是最高的，其他的都为BACKUP优先级都要略小于MASTER角色的优先级；&lt;/p&gt;
&lt;p&gt;　　interface：用于指定vrrp实例的网卡名称，就是把vip配置在那个接口上；&lt;/p&gt;
&lt;p&gt;　　virtual_router_id：虚拟路由ID取值范围是0-255；&lt;/p&gt;
&lt;p&gt;　　advert_int：指定发送心跳间隔时长，默认是1秒；&lt;/p&gt;
&lt;p&gt;　　priority：指定该实例的优先级；&lt;/p&gt;
&lt;p&gt;　　authentication {...}：用于定义认证信息；&lt;/p&gt;
&lt;p&gt;　　auth_type：指定认证类型，常用认证类型有PASS和AH，PASS指简单的密码认证，AH指IPSEC认证；如果使用PASS类型，默认只会取前8个字符作为认证密码；&lt;/p&gt;
&lt;p&gt;　　auth_pass：指定认证密码；&lt;/p&gt;
&lt;p&gt;　　virtual_ipaddress {..}：用于设定虚拟ip地址的配置，用大括号括起来；定义虚拟ip的语法格式为：&amp;lt;IPADDR&amp;gt;/&amp;lt;MASK&amp;gt; brd &amp;lt;IPADDR&amp;gt; dev &amp;lt;STRING&amp;gt; scope &amp;lt;SCOPE&amp;gt; label &amp;lt;LABEL&amp;gt;；其中brd用于指定广播地址，dev用于指定接口名称，scope用于指定作用域，label用于指定别名；可以配置多个虚拟ip，通常一个实例中只配置一个虚拟ip；&lt;/p&gt;
&lt;p&gt;　　示例：在node01和node02利用keepalived配置vip192.168.0.33&lt;/p&gt;
&lt;p&gt;　　node01上的配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908234047407-987577469.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0079162c-e16a-4d5d-9c4c-f056dfc42e83')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_0079162c-e16a-4d5d-9c4c-f056dfc42e83&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_0079162c-e16a-4d5d-9c4c-f056dfc42e83&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0079162c-e16a-4d5d-9c4c-f056dfc42e83&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
! Configuration File &lt;span&gt;for&lt;/span&gt;&lt;span&gt; keepalived

global_defs {
   notification_email {
        root@localhost
   }
   notification_email_from node01_keepalived@localhost
   smtp_server &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id node01
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_mcast_group4 &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;12.132&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.33&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt; dev ens33 label ens33:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　node02上的配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908234252798-1067962370.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1c91c9ff-b322-421e-903e-b58e10d465f4')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_1c91c9ff-b322-421e-903e-b58e10d465f4&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_1c91c9ff-b322-421e-903e-b58e10d465f4&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1c91c9ff-b322-421e-903e-b58e10d465f4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
! Configuration File &lt;span&gt;for&lt;/span&gt;&lt;span&gt; keepalived

global_defs {
   notification_email {
        root@localhost
   }
   notification_email_from node02_keepalived@localhost
   smtp_server &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id node02
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_mcast_group4 &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;12.132&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.33&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt; dev ens33 label ens33:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　启动node01和node02上的keepalived&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908234454686-1582381758.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到把node01上的keepalived启动起来以后，vip就配置在外面指定的ens33接口上；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908234837514-53512994.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到node02上的keepalived启动起来以后，vip并没有从node01上抢过来，并且在node02上看keepalived的状态信息，清楚的看到node02以backup角色运行着，这意味着只有当master宕机以后，它才会有可能把vip抢过来；&lt;/p&gt;
&lt;p&gt;　　在node02上抓包，看看心跳信息是否是我们指定1秒一个呢？是否是在我们指定的组播域？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908235413628-1778141501.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到node01(MASTER节点)一秒一个心跳报文给指定的组播域发送通告信息，只要在组播域内地主机能够收到MASTER的通告，它们都认为MASTER还活着，一旦master没有发通告，那么backup节点就会触发重新争夺VIP；&lt;/p&gt;
&lt;p&gt;　　验证：把master keepalived停掉，看看VIP是否飘到node02上呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200908235957632-728930675.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200909000034577-475696094.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当把node01上的keepalived停掉以后，对应vip会飘到node02上，并且node02会向组播域一直通告自己的vrrid 优先级 等等信息；&lt;/p&gt;
&lt;p&gt;　　验证：把node01的keepalived启动起来，vip是否会被node01抢过去呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200909000738209-406404064.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：默认我们没有指定是否工作在抢占模式，默认就为抢占模式，意思是只要对应的组播域有比当前VIP所在节点上的优先级高的通告，拥有VIP的节点会自动把vip让出来，让其优先级高的节点应用；&lt;/p&gt;
&lt;p&gt;　　在node02上查看keepalived的状态以及ip地址信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200909001324565-276895200.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从node02的keepalived的状态信息可以看到，它接收到更高优先级的通告，然后自己自动移除了VIP ，iptables规则，并工作为BACKUP角色；&lt;/p&gt;
&lt;p&gt;　　示例：配置keepalived的双主模型&lt;/p&gt;
&lt;p&gt;　　node01上的配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200909003319011-1945825670.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e6f9f8ea-554d-4426-adef-1f7d0820b368')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_e6f9f8ea-554d-4426-adef-1f7d0820b368&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_e6f9f8ea-554d-4426-adef-1f7d0820b368&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e6f9f8ea-554d-4426-adef-1f7d0820b368&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
! Configuration File &lt;span&gt;for&lt;/span&gt;&lt;span&gt; keepalived

global_defs {
   notification_email {
        root@localhost
   }
   notification_email_from node01_keepalived@localhost
   smtp_server &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id node01
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_mcast_group4 &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;12.132&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.33&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt; dev ens33 label ens33:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
}
vrrp_instance VI_2 {
    state BACKUP
    interface ens33
    virtual_router_id &lt;/span&gt;&lt;span&gt;52&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;87654321&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.34&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt; dev ens33 label ens33:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　node02上的配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200909003543528-1700555171.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('be091b31-c14d-452b-8287-60154c90223f')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_be091b31-c14d-452b-8287-60154c90223f&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_be091b31-c14d-452b-8287-60154c90223f&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be091b31-c14d-452b-8287-60154c90223f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
! Configuration File &lt;span&gt;for&lt;/span&gt;&lt;span&gt; keepalived

global_defs {
   notification_email {
        root@localhost
   }
   notification_email_from node02_keepalived@localhost
   smtp_server &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id node02
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_mcast_group4 &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;12.132&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.33&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt; dev ens33 label ens33:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
}
vrrp_instance VI_2 {
    state MASTER
    interface ens33
    virtual_router_id &lt;/span&gt;&lt;span&gt;52&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;87654321&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.34&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt; dev ens33 label ens33:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　提示：定义双主模型，通常我们会利用两个vrrp实例来配置，中心思想就是利用两个节点的两个vrrp实例，把两个实例分别在node01和node02上各配置一个实例为MASTER，对应剩下节点就为BACKUP；这样配置以后，重启keepalived，如果node01和node02都正常在线，那么对于两个vip他们会各自占一个，如果其中一台server宕机，他们都会把自身为MASTER角色的vip转移到另外的节点；&lt;/p&gt;
&lt;p&gt;　　验证：重启node01和node02上的keepalived，看看对应vip是否都会在两个节点各自一个呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200909004157719-1475118906.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200909004218183-2105531699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到重启两个节点上的keepalived后，根据我们配置的初始化角色各自都占用了一个vip；这样我们只需在把对位的域名（如果是web服务）的A记录解析分别解析到这两个vip后，这两个vip就可以各自承担一部分请求，从而实现两个keepalived都在工作；&lt;/p&gt;
&lt;p&gt;　　验证：把node01宕机以后，看看192.168.0.33这个地址是否会飘到node02上呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200909004607022-843090030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200909004635936-973161809.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当node01宕机以后，node02就把原来在node01上的vip抢过来应用在自身节点上；这样一来就实现了把原来访问192.168.0.33的流量转移到node02上了；同样的道理我们把node02宕机，在node02上的VIP也会转移到node01上；&lt;/p&gt;
</description>
<pubDate>Tue, 08 Sep 2020 17:05:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前面我们聊了聊高可用集群corosync+pacemaker的相关概念以及相关工具的使用和说明，回顾请参考https://www.cnblogs.com/qiuhom-1874/category/18</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13634755.html</dc:identifier>
</item>
<item>
<title>搭建一个低配版的Mock Server - 丰臣正一</title>
<link>http://www.cnblogs.com/cnroadbridge/p/13636665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnroadbridge/p/13636665.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;mock翻译过来是模仿的意思，Server是服务器。粗暴点直译就是模仿服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;通过阅读本文，你将对Mock的使用有一定的了解，对前后端分离的概念有了更深一步的认识，对Koa的使用有一定的了解。本文先从背景出发去抛出“我们为什么要用Mock？”的灵魂拷问，紧接着我们通过Mock在前后端的使用来进行实战落地，最后我们再总结回顾，展望高配版的Mock Server。&lt;/p&gt;
&lt;p&gt;本文不会像念经一样把官方文档的API抄一遍告诉读者这个怎么用，那个怎么用，更多地是提供一个思路或者想法以及项目的落地带着大家学习Mock的使用。因为我坚信“官方文档始终是最权威的文档。”，所以“Do Not Repeat&quot;原则，不要做念经这种事情，因为官方文档写的已经很详细了。还有就是有些项目API茫茫多，如果都全面地写一遍，累死啦，这个是官方文档干的事情。技术只有转换成生产力，才是程序员的赚钱的核心竞争力，劝君莫惜金缕衣，劝君惜取少年时。&lt;/p&gt;
&lt;p&gt;这里简单地罗列下Mock的整体知识，读者后续可以根据这个大纲有选择地去看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mock.mock()&lt;/li&gt;
&lt;li&gt;Mock.setup()&lt;/li&gt;
&lt;li&gt;Mock.random()&lt;/li&gt;
&lt;li&gt;Mock.valid()&lt;/li&gt;
&lt;li&gt;Mock.toJSONSchema()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;据不完全统计，Mock支持18种数据定义，172种数据定义写法。具体的参见：&lt;a href=&quot;http://mockjs.com/examples.html&quot;&gt;http://mockjs.com/examples.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202009/2055171-20200909005838197-1415572600.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参见：&lt;a href=&quot;https://github.com/ataola/node-blacksmith/blob/master/code/framework/koa-study/koa-mock/mock/random/basic.js&quot;&gt;https://github.com/ataola/node-blacksmith/blob/master/code/framework/koa-study/koa-mock/mock/random/basic.js&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用mock的背景&quot;&gt;使用Mock的背景&lt;/h2&gt;
&lt;h3 id=&quot;我们为什么要使用mock？&quot;&gt;我们为什么要使用Mock？&lt;/h3&gt;
&lt;p&gt;传统的非前后端分离的项目，后端老哥除了要做对接服务器数据库相关的工作，还要搞前端页面，太多太累太杂了。随着时代的发展、人类社会的进步，编程技术的更新迭代，慢慢地开始有了专职的前端程序员和后端程序员等等，项目越来越复杂，前后端的要求度逐步提高，尤其是Node.JS技术的迅猛发展，十一年弹指一挥间，在npm、github各类库和项目如雨后春笋般蹭蹭蹭地雄起，给开发者提供了很多解决方案，这也使得前后端分离成为可能。事物存在的即是合理的，但我们也要辩证地去看待这个事物。前后端分离项目的落地比前后端不分离的落地增加了开发人员对接沟通的成本，在某些场景下，前端开发会受限制于后端开发，接地气地说就是后端接口没写好没提供前端可能就无从下手了，为了解决这个问题，我们需要进行相关地Mock，来模拟后端返回的数据也好或者后端的接口也好，总之，我们需要一个Mock Server。&lt;/p&gt;
&lt;h2 id=&quot;mock在前端的使用&quot;&gt;Mock在前端的使用&lt;/h2&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# npm安装
npm i mockjs -D
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;引入方式&quot;&gt;引入方式&lt;/h3&gt;
&lt;h4 id=&quot;传统script脚本引入&quot;&gt;传统script脚本引入&lt;/h4&gt;
&lt;p&gt;去Bootcdn引入相关的脚本，地址：&lt;a href=&quot;https://www.bootcdn.cn/Mock.js/%EF%BC%8C&quot;&gt;https://www.bootcdn.cn/Mock.js/，&lt;/a&gt; 形如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 生产环境 --&amp;gt;
&amp;lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/Mock.js/0.1.1/mock-min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- 开发环境 --&amp;gt;
&amp;lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/Mock.js/0.1.1/mock.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;es-module&quot;&gt;ES Module&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;import Mock from 'mockjs';
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;commonjs&quot;&gt;CommonJS&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const Mock = require('mockjs');
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mockmock-rurl-rtype-templatefunction-options--使用&quot;&gt;Mock.mock( rurl?, rtype?, template|function( options ) )使用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;rurl: 当拦截到匹配 &lt;code&gt;rurl&lt;/code&gt; 的 Ajax 请求时，将根据数据模板 &lt;code&gt;template&lt;/code&gt; 生成模拟数据，并作为响应数据返回&lt;/li&gt;
&lt;li&gt;rtype：当拦截到匹配&lt;code&gt;rtype&lt;/code&gt; 的 Ajax 请求时，将根据数据模板 &lt;code&gt;template&lt;/code&gt; 生成模拟数据，并作为响应数据返回。&lt;/li&gt;
&lt;li&gt;template：生成模拟数据的模板&lt;/li&gt;
&lt;li&gt;function: 当拦截到匹配 &lt;code&gt;rurl&lt;/code&gt; 的 Ajax 请求时，函数 &lt;code&gt;function(options)&lt;/code&gt; 将被执行，并把执行结果作为响应数据返回。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的参见：&lt;a href=&quot;https://github.com/ataola/node-blacksmith/tree/master/code/framework/koa-study/koa-mock/static&quot;&gt;https://github.com/ataola/node-blacksmith/tree/master/code/framework/koa-study/koa-mock/static&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;mock在后端的使用&quot;&gt;Mock在后端的使用&lt;/h2&gt;
&lt;p&gt;在前面我们了解了Mock在前端的使用，我们还需要思考这么一个问题，模拟也要模拟的深沉一点，也就是像一点，前面的写法足以应付大部分场景，但是有的时候我们需要拟合后端的服务，比如网络的延迟、跨域、性能等等问题，我们更加期望是搞一个服务器，模拟后端的一些API行为。作为前端选手，Javascript天然会，既然用了Javascript的基础，我们自然而然地会想到用Node.JS去搭建一个后端服务。&lt;/p&gt;
&lt;p&gt;笔者这里使用Koa搭建一个后端服务，主体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const http = require('http');

const Koa = require('koa');
const app = new Koa();
const logger = require('koa-logger');
const bodyparser = require('koa-bodyparser')
const onerror = require('koa-onerror');
const errorMiddleware = require('./middlewares/error');
const ipBlackListMiddleware = require('./middlewares/ip_blacklist');
const { host, port, ip_blacklist } = require('./config/index');

// import routes
const IndexRoute = require('./routes/index');
const MockRoute = require('./routes/mock');

// error handler
onerror(app);

app.use(ipBlackListMiddleware(ip_blacklist));

// when post, use x-www-form-urlencoded or json
app.use(bodyparser({
  enableTypes:['json', 'form', 'text']
}));

// use koa-logger
app.use(logger());


// routes middleware
app.use(IndexRoute.routes(), IndexRoute.allowedMethods());
app.use(MockRoute.routes(), MockRoute.allowedMethods());

// error-handling
app.on('error', errorMiddleware());

// create a server
const server = http.createServer(app.callback());

// listen port
server.listen(port, host, () =&amp;gt; {
  console.log(`mock server is running in http://${host}:${port}`);
});

module.exports = server;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大致的一个流程是，导入了项目的npm包，中间件、路由，初始化Koa实例，调用了相关的中间件和路由，最后监听服务器端口。&lt;/p&gt;
&lt;p&gt;如果对Mock不是很熟，我们大致会这样做，把相关返回信息写在JSON文件中或者js文件中，然后通过引入或者读取相关文件来做这件事&lt;/p&gt;
&lt;h3 id=&quot;json文件形式&quot;&gt;JSON文件形式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;data&quot;: {
    &quot;name&quot;: &quot;zjt&quot;,
    &quot;age&quot;: 23
  },
  &quot;success&quot;: true,
  &quot;code&quot;: 1,
  &quot;message&quot;: &quot;获取用户信息成功&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义完返回格式后，我们可以通过commonJS的语法用require引入，也可以通过内置的fs模块的读取文件的函数去读取这部分JSON的内容，然后把它衔接到相关路由上面构成一个Mock API。&lt;/p&gt;
&lt;p&gt;形如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const user_json = require('../mock/json/user.json');

router.get('/json/user', async ctx =&amp;gt; {
  ctx.body = user_json;
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;js文件形式&quot;&gt;JS文件形式&lt;/h3&gt;
&lt;p&gt;这里仿照楼上也是类似的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const user_js = require('../mock/js/user');

router.get('/js/user', async ctx =&amp;gt; {
  ctx.body = user_js;
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样做的话，能够满足我们日常生活中的大部分开发，但是太费劲了，每次我们都要写这么多一坨坨的JSON或者JS文件，我们希望这个Mock Server能够更加智能一点，本着”简单、短小精悍“的原则去思考，我们自然而然会想到引入Mock.JS去做这件事情。&lt;/p&gt;
&lt;h3 id=&quot;mockjs的应用&quot;&gt;Mock.JS的应用&lt;/h3&gt;
&lt;p&gt;这里我们思考一个例子，最常见的就以返回用户身份信息为例。我们就意思下，罗列一下用户常见的属性，比如说用户id、用户名字、用户昵称、用户生日、用户地址、用户邮箱、能量值（也可以理解成阳光值）、创建时间、更新时间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const Mock = require('mockjs');

const data = Mock.mock({
  'data|4-10': [{
    'id': '@id',
    'name': '@cname',
    'nickname|1': ['沉鱼', '落雁', '闭月', '羞花'],
    'birthday': '@date',
    'address': '@county(true)',
    'email': '@email',
    'power|1-5': '★',
    'created': '@now',
    'updated': '@now'
  }]
});

module.exports = {
  data,
  success: true,
  code: 1,
  message: '获取用户数据成功'
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单的讲下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;'data|4-10'[{}]&lt;/code&gt;: 表示有个数组data，它里面至少有4个对象，上限10个对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@id&lt;/code&gt;: 表示数据占位符定义，一个id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@name&lt;/code&gt;: 表示数据占位符定义，一个name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'nickname|1': ['沉鱼', '落雁', '闭月', '羞花'],&lt;/code&gt;: 表示nickname为一个字符串，值为沉鱼落雁闭月羞花中的一个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@date&lt;/code&gt;: 表示数据占位符定义，一个形如&lt;code&gt;1997-06-13&lt;/code&gt;这样的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@county(true)&lt;/code&gt;: 表示数据占位符定义， 一个形如&lt;code&gt;江苏省 淮安市 金湖县&lt;/code&gt;这样的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@email&lt;/code&gt;: 表示数据占位符定义，一个邮箱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'power|1-5': '★'&lt;/code&gt;: 表示有个字符串，值为最少1颗星，最多5颗星，其实这个做外卖五分好评或者老师课程评价这种数据展示应景一些&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@now&lt;/code&gt;: 表示当前时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后的效果就是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202009/2055171-20200909005857716-1035326668.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们可以看出Mock的结果还是有些不可控性，比如我就想让它显示正常点的邮箱、可读性强一点的段落文字，这里就要用到文中的沉鱼落雁闭月羞花的例子，我们事先准备好部分结果集让其Mock数据。&lt;/p&gt;
&lt;h3 id=&quot;mock数据的单元测试&quot;&gt;Mock数据的单元测试&lt;/h3&gt;
&lt;p&gt;这里我是结合Mocha(测试框架)、chai（断言）、supertest（模拟http测试）对Mock的API进行了一个单元测试，具体的如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const app = require('../server');
const supertest = require('supertest')(app);
const expect = require('chai').expect;

describe('mock Server', () =&amp;gt; {
  describe('#GET /', () =&amp;gt; {
    it('should return a response with HTTP code 200', function(done) {
      supertest
        .get('/')
        .expect(200, done);
    });
  });

  describe('#GET /mock/js/user', () =&amp;gt; {
    it('response data success should return true', (done) =&amp;gt; {
      supertest
        .get('/mock/js/user')
        .expect(200)
        .end((err, res) =&amp;gt; {
          if (err) {
            done(err);
          } 
          const { code, data, message, success } = res.body;
          expect(res.statusCode).to.equal(200);
          expect(res.body).to.be.an('object'); 
          expect(code).to.eql(1);
          expect(data).to.eql({ name: 'ataola', skill: 'node.js' });
          expect(message).to.eql('获取用户信息成功');
          expect(success).to.eql(true);
          done();
        });
    });
  });
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;高配版的mock-server&quot;&gt;高配版的Mock Server&lt;/h3&gt;
&lt;p&gt;站在产品经理的角度，我想，高配版的Mock Server就是打开浏览器，有个界面给你点点点进行增删改查，然后生成一个API，有兴趣的童鞋可以去实现下，溜了溜了。。。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;本文选自“Node.JS打铁”系列文章，项目地址：&lt;a href=&quot;https://github.com/ataola/node-blacksmith&quot;&gt;https://github.com/ataola/node-blacksmith&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文中涉及到的项目例子地址：&lt;a href=&quot;https://github.com/ataola/node-blacksmith/tree/master/code/framework/koa-study/koa-mock&quot;&gt;https://github.com/ataola/node-blacksmith/tree/master/code/framework/koa-study/koa-mock&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;Mock.JS官网： &lt;a href=&quot;http://mockjs.com/&quot;&gt;http://mockjs.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MockJS 文档：&lt;a href=&quot;https://github.com/nuysoft/Mock/wiki&quot;&gt;https://github.com/nuysoft/Mock/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MockJS 示例：&lt;a href=&quot;http://mockjs.com/examples.html&quot;&gt;http://mockjs.com/examples.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MockJS语法规范：&lt;a href=&quot;https://github.com/nuysoft/Mock/wiki/Syntax-Specification&quot;&gt;https://github.com/nuysoft/Mock/wiki/Syntax-Specification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mock.Mock()的使用：&lt;a href=&quot;https://github.com/nuysoft/Mock/wiki/Mock.mock()&quot;&gt;https://github.com/nuysoft/Mock/wiki/Mock.mock()&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Sep 2020 17:00:00 +0000</pubDate>
<dc:creator>丰臣正一</dc:creator>
<og:description>mock翻译过来是模仿的意思，Server是服务器。粗暴点直译就是模仿服务器。 写在前面 通过阅读本文，你将对Mock的使用有一定的了解，对前后端分离的概念有了更深一步的认识，对Koa的使用有一定的了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cnroadbridge/p/13636665.html</dc:identifier>
</item>
<item>
<title>【Spring】IOC容器注解汇总，你想要的都在这儿了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13636625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13636625.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;之前，我们在【Spring】专题中更新了不少关于Spring注解相关的文章，有些小伙伴反馈说，看历史文章的话比较零散，经常会忘记自己看到哪一篇了。当打开一篇新文章时，总感觉自己似乎是看到过了，又感觉自己没有看到过。那怎么办呢？为了小伙伴们查看方便，我在这里将Spring注解的使用方式做个汇总，也算是对之前写的Spring文章的一个总结吧！&lt;/p&gt;
&lt;p&gt;如果文章对你有点帮助，请点个赞，给个在看和转发，大家的支持是对我持续创作的最大动力。&lt;/p&gt;
&lt;p&gt;微信搜索并关注“冰河技术”微信公众号，每天推送超硬核技术干货！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;xml配置与类配置&quot;&gt;xml配置与类配置&lt;/h2&gt;
&lt;h3 id=&quot;1xml配置&quot;&gt;1.xml配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/sp
        &amp;lt;bean id=&quot;person&quot; class=&quot;com.binghe.spring.Person&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取Person实例如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main( String[] args ){
        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        System.out.println(ctx.getBean(&quot;person&quot;));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2类配置&quot;&gt;2.类配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class MainConfig {
    @Bean
    public Person person(){
        return new Person();
    }
}               
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里，有一个需要注意的地方：通过@Bean的形式是使用的话， bean的默认名称是方法名，若@Bean(value=&quot;bean的名称&quot;)那么bean的名称是指定的 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取Person实例如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main( String[] args ){
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MainConfig.class);
        System.out.println(ctx.getBean(&quot;person&quot;));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;compentscan注解&quot;&gt;@CompentScan注解&lt;/h2&gt;
&lt;p&gt;我们可以使用@CompentScan注解来进行包扫描，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@ComponentScan(basePackages = {&quot;com.binghe.spring&quot;})
        public class MainConfig {
}       
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;excludefilters-属性&quot;&gt;excludeFilters 属性&lt;/h3&gt;
&lt;p&gt;当我们使用@CompentScan注解进行扫描时，可以使用@CompentScan注解的excludeFilters 属性来排除某些类，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@ComponentScan(basePackages = {&quot;com.binghe.spring&quot;},excludeFilters = {
@ComponentScan.Filter(type = FilterType.ANNOTATION,value = {Controller.class}),
@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,value = {PersonService.class})
})
public class MainConfig {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;includefilters属性&quot;&gt;includeFilters属性&lt;/h3&gt;
&lt;p&gt;当我们使用@CompentScan注解进行扫描时，可以使用@CompentScan注解的includeFilters属性将某些类包含进来。这里需要注意的是：需要把useDefaultFilters属性设置为false（true表示扫描全部的）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@ComponentScan(basePackages = {&quot;com.binghe.spring&quot;},includeFilters = {
@ComponentScan.Filter(type = FilterType.ANNOTATION,value = {Controller.class, PersonService.class})
},useDefaultFilters = false)
public class MainConfig {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;componentscanfilter-type的类型&quot;&gt;@ComponentScan.Filter type的类型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;注解形式的FilterType.ANNOTATION @Controller @Service @Repository @Compent&lt;/li&gt;
&lt;li&gt;指定类型的 FilterType.ASSIGNABLE_TYPE @ComponentScan.Filter(type =FilterType.ASSIGNABLE_TYPE,value = {Person.class})&lt;/li&gt;
&lt;li&gt;aspectj类型的 FilterType.ASPECTJ(不常用)&lt;/li&gt;
&lt;li&gt;正则表达式的 FilterType.REGEX(不常用)&lt;/li&gt;
&lt;li&gt;自定义的 FilterType.CUSTOM&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum FilterType {
    //注解形式 比如@Controller @Service @Repository @Compent
    ANNOTATION,
    //指定的类型
    ASSIGNABLE_TYPE,
    //aspectJ形式的
    ASPECTJ,
    //正则表达式的
    REGEX,
    //自定义的
    CUSTOM
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;filtertypecustom-自定义类型&quot;&gt;FilterType.CUSTOM 自定义类型&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomFilterType implements TypeFilter {
@Override
public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
    //获取当前类的注解源信息
    AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
    //获取当前类的class的源信息
    ClassMetadata classMetadata = metadataReader.getClassMetadata();
    //获取当前类的资源信息
    Resource resource = metadataReader.getResource();
        return classMetadata.getClassName().contains(&quot;Service&quot;);
}
    
@ComponentScan(basePackages = {&quot;com.binghe.spring&quot;},includeFilters = {
@ComponentScan.Filter(type = FilterType.CUSTOM,value = CustomFilterType.class)
},useDefaultFilters = false)
public class MainConfig {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置bean的作用域对象&quot;&gt;配置Bean的作用域对象&lt;/h2&gt;
&lt;h3 id=&quot;不指定scope&quot;&gt;不指定@Scope&lt;/h3&gt;
&lt;p&gt;在不指定@Scope的情况下，所有的bean都是单实例的bean，而且是饿汉加载(容器启动实例就创建好了)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
public Person person() {
        return new Person();
}       
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;scope为-prototype&quot;&gt;@Scope为 prototype&lt;/h3&gt;
&lt;p&gt;指定@Scope为 prototype 表示为多实例的，而且还是懒汉模式加载（IOC容器启动的时候，并不会创建对象，而是在第一次使用的时候才会创建）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
@Scope(value = &quot;prototype&quot;)
public Person person() {
    return new Person();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;scope取值&quot;&gt;@Scope取值&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;singleton 单实例的(默认)&lt;/li&gt;
&lt;li&gt;prototype 多实例的&lt;/li&gt;
&lt;li&gt;request 同一次请求&lt;/li&gt;
&lt;li&gt;session 同一个会话级别&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;懒加载&quot;&gt;懒加载&lt;/h2&gt;
&lt;p&gt;Bean的懒加载@Lazy(主要针对单实例的bean 容器启动的时候，不创建对象，在第一次使用的时候才会创建该对象)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
@Lazy
public Person person() {
        return new Person();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;conditional条件判断&quot;&gt;@Conditional条件判断&lt;/h2&gt;
&lt;p&gt;场景，有二个组件CustomAspect 和CustomLog ，我的CustomLog组件是依赖于CustomAspect的组件&lt;br/&gt;应用：自己创建一个CustomCondition的类 实现Condition接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomCondition implements Condition {
/****
@param context
* @param metadata
* @return
*/
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        //判断容器中是否有CustomAspect的组件
        return context.getBeanFactory().containsBean(&quot;customAspect&quot;);
    }   
} 

public class MainConfig {
    @Bean
    public CustomAspect customAspect() {
        return new CustomAspect();
    } 
    @Bean
    @Conditional(value = CustomCondition.class)
    public CustomLog customLog() {
                return new CustomLog();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;向ioc-容器添加组件&quot;&gt;向IOC 容器添加组件&lt;/h2&gt;
&lt;p&gt;（1）通过@CompentScan +@Controller @Service @Respository @compent。适用场景: 针对我们自己写的组件可以通过该方式来进行加载到容器中。&lt;/p&gt;
&lt;p&gt;（2）通过@Bean的方式来导入组件(适用于导入第三方组件的类)&lt;/p&gt;
&lt;p&gt;（3）通过@Import来导入组件 （导入组件的id为全类名路径）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@Import(value = {Person.class})
public class MainConfig {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过@Import 的ImportSeletor类实现组件的导入 (导入组件的id为全类名路径)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomImportSelector implements ImportSelector {  
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{&quot;com.binghe.spring&quot;};
    }
} 
Configuration
@Import(value = {Person.class}
public class MainConfig {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过@Import的 ImportBeanDefinitionRegister导入组件 (可以指定bean的名称)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DogBeanDefinitionRegister implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        //创建一个bean定义对象
        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Dog.class);
        //把bean定义对象导入到容器中
        registry.registerBeanDefinition(&quot;dog&quot;,rootBeanDefinition);
    }
} 
@Configuration
@Import(value = {Person.class, Car.class, CustomImportSelector.class, DogBeanDefinitionRegister.class})
public class MainConfig {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过实现FacotryBean接口来实现注册 组件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CarFactoryBean implements FactoryBean&amp;lt;Car&amp;gt; {
    @Override
    public Car getObject() throws Exception {
        return new Car();
    } 
    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return Car.class;
    } 

    @Override
    public boolean isSingleton() {
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bean的初始化与销毁&quot;&gt;Bean的初始化与销毁&lt;/h2&gt;
&lt;h3 id=&quot;指定bean的初始化方法和bean的销毁方法&quot;&gt;指定bean的初始化方法和bean的销毁方法&lt;/h3&gt;
&lt;p&gt;由容器管理Bean的生命周期，我们可以通过自己指定bean的初始化方法和bean的销毁方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class MainConfig {
    //指定了bean的生命周期的初始化方法和销毁方法.@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)
    public Car car() {
        return new Car();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对单实例bean的话，容器启动的时候，bean的对象就创建了，而且容器销毁的时候，也会调用Bean的销毁方法&lt;/p&gt;
&lt;p&gt;针对多实例bean的话,容器启动的时候，bean是不会被创建的而是在获取bean的时候被创建，而且bean的销毁不受IOC容器的管理&lt;/p&gt;
&lt;h3 id=&quot;通过-initializingbean和disposablebean实现&quot;&gt;通过 InitializingBean和DisposableBean实现&lt;/h3&gt;
&lt;p&gt;通过 InitializingBean和DisposableBean个接口实现bean的初始化以及销毁方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class Person implements InitializingBean,DisposableBean {
    public Person() {
        System.out.println(&quot;Person的构造方法&quot;);
    } 
    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;DisposableBean的destroy()方法 &quot;);
    } 
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;InitializingBean的 afterPropertiesSet方法&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过jsr250规范&quot;&gt;通过JSR250规范&lt;/h3&gt;
&lt;p&gt;通过JSR250规范 提供的注解@PostConstruct 和@ProDestory标注的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class Book {
    public Book() {
        System.out.println(&quot;book 的构造方法&quot;);
    } 
    @PostConstruct
    public void init() {
        System.out.println(&quot;book 的PostConstruct标志的方法&quot;);
    } 
    @PreDestroy
    public void destory() {
        System.out.println(&quot;book 的PreDestory标注的方法&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过beanpostprocessor实现&quot;&gt;通过BeanPostProcessor实现&lt;/h3&gt;
&lt;p&gt;通过Spring的BeanPostProcessor的 bean的后置处理器会拦截所有bean创建过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;postProcessBeforeInitialization 在init方法之前调用&lt;/li&gt;
&lt;li&gt;postProcessAfterInitialization 在init方法之后调用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;CustomBeanPostProcessor...postProcessBeforeInitialization:&quot;+beanName);
                return bean;
    } 
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;CustomBeanPostProcessor...postProcessAfterInitialization:&quot;+beanName);
        return bean;
    }
}       
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;beanpostprocessor的执行时机&quot;&gt;BeanPostProcessor的执行时机&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;populateBean(beanName, mbd, instanceWrapper)
initializeBean{
    applyBeanPostProcessorsBeforeInitialization()
    invokeInitMethods{
    isInitializingBean.afterPropertiesSet()
    自定义的init方法
}
applyBeanPostProcessorsAfterInitialization()方法
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过value-propertysource来给组件赋值&quot;&gt;通过@Value +@PropertySource来给组件赋值&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Person {
    //通过普通的方式
    @Value(&quot;独孤&quot;)
    private String firstName;
    //spel方式来赋值
    @Value(&quot;#{28-8}&quot;)
    private Integer age;
    通过读取外部配置文件的值
    @Value(&quot;${person.lastName}&quot;)
    private String lastName;
} 
@Configuration
@PropertySource(value = {&quot;classpath:person.properties&quot;}) //指定外部文件的位置
public class MainConfig {
    @Bean
    public Person person() {
        return new Person();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自动装配&quot;&gt;自动装配&lt;/h2&gt;
&lt;h3 id=&quot;autowired的使用&quot;&gt;@AutoWired的使用&lt;/h3&gt;
&lt;p&gt;自动注入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Repository
public class CustomDao {
} 
@Service
public class CustomService {
    @Autowired
    private CustomDao customDao;
｝
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论:&lt;br/&gt;（1）自动装配首先时按照类型进行装配，若在IOC容器中发现了多个相同类型的组件，那么就按照 属性名称来进行装配&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
private CustomDao customDao;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如，我容器中有二个CustomDao类型的组件 一个叫CustomDao 一个叫CustomDao2那么我们通过@AutoWired 来修饰的属性名称时CustomDao，那么拿就加载容器的CustomDao组件，若属性名称为tulignDao2 那么他就加载的时CustomDao2组件&lt;/p&gt;
&lt;p&gt;（2）假设我们需要指定特定的组件来进行装配，我们可以通过使用@Qualifier(&quot;CustomDao&quot;)来指定装配的组件&lt;br/&gt;或者在配置类上的@Bean加上@Primary注解&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
@Qualifier(&quot;CustomDao&quot;)
private CustomDao customDao2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）假设我们容器中即没有CustomDao 和CustomDao2,那么在装配的时候就会抛出异常&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;No qualifying bean of type 'com.binghhe.spring.dao.CustomDao' available
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若我们想不抛异常 ，我们需要指定 required为false的时候可以了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired(required = false)
@Qualifier(&quot;customDao&quot;)
private CustomDao CustomDao2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）@Resource(JSR250规范)&lt;br/&gt;功能和@AutoWired的功能差不多一样，但是不支持@Primary 和@Qualifier的支持&lt;/p&gt;
&lt;p&gt;（5）@InJect（JSR330规范）&lt;br/&gt;需要导入jar包依赖，功能和支持@Primary功能 ,但是没有Require=false的功能&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.inject&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.inject&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）使用@Autowired 可以标注在方法上&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标注在set方法上&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//@Autowired
public void setCustomLog(CustomLog customLog) {
        this.customLog = customLog;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;标注在构造方法上&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
public CustomAspect(CustomLog customLog) {
        this.customLog = customLog;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;标注在配置类上的入参中（可以不写）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
public CustomAspect CustomAspect(@Autowired CustomLog customLog) {
    CustomAspect customAspect = new CustomAspect(customLog);
    return ustomAspect;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;xxxawarce接口&quot;&gt;XXXAwarce接口&lt;/h2&gt;
&lt;p&gt;我们自己的组件 需要使用spring ioc的底层组件的时候,比如 ApplicationContext等我们可以通过实现XXXAware接口来实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class CustomCompent implements ApplicationContextAware,BeanNameAware {
    private ApplicationContext applicationContext;
    @Override
    public void setBeanName(String name) {
        System.out.println(&quot;current bean name is :【&quot;+name+&quot;】&quot;);
    } 
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;profile注解&quot;&gt;@Profile注解&lt;/h2&gt;
&lt;p&gt;通过@Profile注解 来根据环境来激活标识不同的Bean&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Profile标识在类上，那么只有当前环境匹配，整个配置类才会生效&lt;/li&gt;
&lt;li&gt;@Profile标识在Bean上 ，那么只有当前环境的Bean才会被激活&lt;/li&gt;
&lt;li&gt;没有标志为@Profile的bean 不管在什么环境都可以被激活&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@PropertySource(value = {&quot;classpath:ds.properties&quot;})
public class MainConfig implements EmbeddedValueResolverAware {
    @Value(&quot;${ds.username}&quot;)
    private String userName;
    @Value(&quot;${ds.password}&quot;)
    private String password;
    private String jdbcUrl;
    private String classDriver;
    @Override
    public void setEmbeddedValueResolver(StringValueResolver resolver) {
        this.jdbcUrl = resolver.resolveStringValue(&quot;${ds.jdbcUrl}&quot;);
        this.classDriver = resolver.resolveStringValue(&quot;${ds.classDriver}&quot;);
    } 
    @Bean
    @Profile(value = &quot;test&quot;)
    public DataSource testDs() {
                return buliderDataSource(new DruidDataSource());
    }
    @Bean
    @Profile(value = &quot;dev&quot;)
    public DataSource devDs() {
        return buliderDataSource(new DruidDataSource());
    } 
    @Bean
    @Profile(value = &quot;prod&quot;)
    public DataSource prodDs() {
        return buliderDataSource(new DruidDataSource());
    } 
    private DataSource buliderDataSource(DruidDataSource dataSource) {
        dataSource.setUsername(userName);
        dataSource.setPassword(password);
        dataSource.setDriverClassName(classDriver);
        dataSource.setUrl(jdbcUrl);
        return dataSource;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;激活切换环境的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）运行时jvm参数来切换&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; -Dspring.profiles.active=test|dev|prod  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）通过代码的方式来激活&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.getEnvironment().setActiveProfiles(&quot;test&quot;,&quot;dev&quot;);
    ctx.register(MainConfig.class);
    ctx.refresh();
    printBeanName(ctx);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，后台回复 “&lt;strong&gt;设计模式&lt;/strong&gt;” 关键字领取《&lt;strong&gt;深入浅出Java 23种设计模式&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;Java8&lt;/strong&gt;”关键字领取《&lt;strong&gt;Java8新特性教程&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;限流&lt;/strong&gt;”关键字获取《&lt;strong&gt;亿级流量下的分布式限流解决方案&lt;/strong&gt;》PDF文档，三本PDF均是由冰河原创并整理的超硬核教程，面试必备！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906013715889.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Sep 2020 16:39:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 之前，我们在【Spring】专题中更新了不少关于Spring注解相关的文章，有些小伙伴反馈说，看历史文章的话比较零散，经常会忘记自己看到哪一篇了。当打开一篇新文章时，总感觉自己似乎是看到过了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13636625.html</dc:identifier>
</item>
<item>
<title>SpringSecurity中的Authentication信息与登录流程 - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/13636285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/13636285.html</guid>
<description>&lt;p&gt;本篇文章参考于【江南一点雨】的公众号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202009/1771072-20200908230622230-312166616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用SpringSecurity可以在任何地方注入Authentication进而获取到当前登录的用户信息，可谓十分强大。&lt;/p&gt;
&lt;p&gt;在Authenticaiton的继承体系中，实现类UsernamePasswordAuthenticationToken 算是比较常见的一个了，在这个类中存在两个属性：principal和credentials，其实分别代表着用户和密码。【当然其他的属性存在于其父类中，如&lt;code&gt;authorities&lt;/code&gt;和&lt;code&gt;details&lt;/code&gt;。】&lt;/p&gt;
&lt;p&gt;我们需要对这个对象有一个基本地认识，它保存了用户的基本信息。用户在登录的时候，进行了一系列的操作，将信息存与这个对象中，后续我们使用的时候，就可以轻松地获取这些信息了。&lt;/p&gt;
&lt;p&gt;那么，用户信息如何存，又是如何取的呢？继续往下看吧。&lt;/p&gt;

&lt;h2 id=&quot;一、与认证相关的usernamepasswordauthenticationfilter&quot;&gt;一、与认证相关的UsernamePasswordAuthenticationFilter&lt;/h2&gt;
&lt;p&gt;通过Servlet中的Filter技术进行实现，通过一系列内置的或自定义的安全Filter，实现接口的认证与授权。&lt;/p&gt;
&lt;p&gt;比如：&lt;code&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public Authentication attemptAuthentication(HttpServletRequest request,
                        HttpServletResponse response) throws AuthenticationException {
                if (postOnly &amp;amp;&amp;amp; !request.getMethod().equals(&quot;POST&quot;)) {
                        throw new AuthenticationServiceException(
                                        &quot;Authentication method not supported: &quot; + request.getMethod());
                }
                //获取用户名和密码
                String username = obtainUsername(request);
                String password = obtainPassword(request);

                if (username == null) {
                        username = &quot;&quot;;
                }

                if (password == null) {
                        password = &quot;&quot;;
                }
                username = username.trim();
                //构造UsernamePasswordAuthenticationToken对象
                UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(
                                username, password);

                // 为details属性赋值
                setDetails(request, authRequest);
                // 调用authenticate方法进行校验
                return this.getAuthenticationManager().authenticate(authRequest);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取用户名和密码&quot;&gt;获取用户名和密码&lt;/h3&gt;
&lt;p&gt;从request中提取参数，这也是SpringSecurity默认的表单登录需要通过key/value形式传递参数的原因。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       @Nullable
        protected String obtainPassword(HttpServletRequest request) {
                return request.getParameter(passwordParameter);
        }
        @Nullable
        protected String obtainUsername(HttpServletRequest request) {
                return request.getParameter(usernameParameter);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造usernamepasswordauthenticationtoken对象&quot;&gt;构造UsernamePasswordAuthenticationToken对象&lt;/h3&gt;
&lt;p&gt;传入获取到的用户名和密码，而用户名对应UPAT对象中的principal属性，而密码对应credentials属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(
    username, password);

//UsernamePasswordAuthenticationToken 的构造器
public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {
    super(null);
    this.principal = principal;
    this.credentials = credentials;
    setAuthenticated(false);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为details属性赋值&quot;&gt;为details属性赋值&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Allow subclasses to set the &quot;details&quot; property 允许子类去设置这个属性
setDetails(request, authRequest);

protected void setDetails(HttpServletRequest request,
                          UsernamePasswordAuthenticationToken authRequest) {
    authRequest.setDetails(authenticationDetailsSource.buildDetails(request));
}

//AbstractAuthenticationToken 是UsernamePasswordAuthenticationToken的父类
public void setDetails(Object details) {
    this.details = details;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;details属性存在于父类之中，主要描述两个信息，一个是remoteAddress 和sessionId。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public WebAuthenticationDetails(HttpServletRequest request) {
                this.remoteAddress = request.getRemoteAddr();

                HttpSession session = request.getSession(false);
                this.sessionId = (session != null) ? session.getId() : null;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;调用authenticate方法进行校验&quot;&gt;调用authenticate方法进行校验&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;this.getAuthenticationManager().authenticate(authRequest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、providermanager的校验逻辑&quot;&gt;二、ProviderManager的校验逻辑&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Authentication authenticate(Authentication authentication)
    throws AuthenticationException {
    Class&amp;lt;? extends Authentication&amp;gt; toTest = authentication.getClass();
    AuthenticationException lastException = null;
    AuthenticationException parentException = null;
    Authentication result = null;
    Authentication parentResult = null;
    boolean debug = logger.isDebugEnabled();

    for (AuthenticationProvider provider : getProviders()) {
        //获取Class，判断当前provider是否支持该authentication
        if (!provider.supports(toTest)) {
            continue;
        }
        //如果支持，则调用provider的authenticate方法开始校验
        result = provider.authenticate(authentication);
        
                //将旧的token的details属性拷贝到新的token中。
        if (result != null) {
            copyDetails(authentication, result);
            break;
        }
    }
    //如果上一步的结果为null，调用provider的parent的authenticate方法继续校验。
    if (result == null &amp;amp;&amp;amp; parent != null) {
        result = parentResult = parent.authenticate(authentication);
    }

    if (result != null) {
        if (eraseCredentialsAfterAuthentication
            &amp;amp;&amp;amp; (result instanceof CredentialsContainer)) {
            //调用eraseCredentials方法擦除凭证信息
            ((CredentialsContainer) result).eraseCredentials();
        }
        if (parentResult == null) {
            //publishAuthenticationSuccess将登录成功的事件进行广播。
            eventPublisher.publishAuthenticationSuccess(result);
        }
        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;获取Class，判断当前provider是否支持该authentication。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果支持，则调用provider的authenticate方法开始校验，校验完成之后，返回一个新的Authentication。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将旧的token的details属性拷贝到新的token中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果上一步的结果为null，调用provider的parent的authenticate方法继续校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;调用eraseCredentials方法擦除凭证信息，也就是密码，具体来说就是让credentials为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;publishAuthenticationSuccess将登录成功的事件进行广播。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三、authenticationprovider的authenticate&quot;&gt;三、AuthenticationProvider的authenticate&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Authentication authenticate(Authentication authentication)
                throws AuthenticationException {
    //从Authenticaiton中提取登录的用户名。
        String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot;
                        : authentication.getName();
    //返回登录对象
        user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);
    //校验user中的各个账户状态属性是否正常
        preAuthenticationChecks.check(user);
    //密码比对
        additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication);
    //密码比对
        postAuthenticationChecks.check(user);
        Object principalToReturn = user;
    //表示是否强制将Authentication中的principal属性设置为字符串
        if (forcePrincipalAsString) {
                principalToReturn = user.getUsername();
        }
    //构建新的UsernamePasswordAuthenticationToken
        return createSuccessAuthentication(principalToReturn, authentication, user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;从Authenticaiton中提取登录的用户名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;retrieveUser&lt;/code&gt;方法将会调用&lt;code&gt;loadUserByUsername&lt;/code&gt;方法，这里将会返回登录对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preAuthenticationChecks.check(user);&lt;/code&gt;校验user中的各个账户状态属性是否正常，如账号是否被禁用，账户是否被锁定，账户是否过期等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;additionalAuthenticationChecks&lt;/code&gt;用于做密码比对，密码加密解密校验就在这里进行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postAuthenticationChecks.check(user);&lt;/code&gt;用于密码比对。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forcePrincipalAsString&lt;/code&gt;表示是否强制将Authentication中的principal属性设置为字符串，默认为false，也就是说默认登录之后获取的用户是对象，而不是username。&lt;/li&gt;
&lt;li&gt;构建新的&lt;code&gt;UsernamePasswordAuthenticationToken&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们来到UsernamePasswordAuthenticationFilter 的父类AbstractAuthenticationProcessingFilter 中，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
                throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
        Authentication authResult;
        try {
        //实际触发了上面提到的attemptAuthentication方法
                authResult = attemptAuthentication(request, response);
                if (authResult == null) {
                        return;
                }
                sessionStrategy.onAuthentication(authResult, request, response);
        }
    //登录失败
        catch (InternalAuthenticationServiceException failed) {
                unsuccessfulAuthentication(request, response, failed);
                return;
        }
        catch (AuthenticationException failed) {
                unsuccessfulAuthentication(request, response, failed);
                return;
        }
        if (continueChainBeforeSuccessfulAuthentication) {
                chain.doFilter(request, response);
        }
    //登录成功
        successfulAuthentication(request, response, chain, authResult);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于登录成功调用的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void successfulAuthentication(HttpServletRequest request,
                HttpServletResponse response, FilterChain chain, Authentication authResult)
                throws IOException, ServletException {
    //将登陆成功的用户信息存储在SecurityContextHolder.getContext()中
        SecurityContextHolder.getContext().setAuthentication(authResult);
        rememberMeServices.loginSuccess(request, response, authResult);
        // Fire event
        if (this.eventPublisher != null) {
                eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(
                                authResult, this.getClass()));
        }
    //登录成功的回调方法
        successHandler.onAuthenticationSuccess(request, response, authResult);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过&lt;code&gt;SecurityContextHolder.getContext().setAuthentication(authResult);&lt;/code&gt;得到两点结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果我们想要获取用户信息，我们只需要调用&lt;code&gt;SecurityContextHolder.getContext().getAuthentication()&lt;/code&gt;即可。&lt;/li&gt;
&lt;li&gt;如果我们想要更新用户信息，我们只需要调用&lt;code&gt;SecurityContextHolder.getContext().setAuthentication(authResult);&lt;/code&gt;即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面说到，我们可以利用Authenticaiton轻松得到用户信息，主要有下面几种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过上下文获取。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SecurityContextHolder.getContext().getAuthentication();
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;直接在Controller注入Authentication。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/hr/info&quot;)
public Hr getCurrentHr(Authentication authentication) {
    return ((Hr) authentication.getPrincipal());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;为什么多次请求可以获取同样的信息&quot;&gt;为什么多次请求可以获取同样的信息&lt;/h2&gt;
&lt;p&gt;前面已经谈到，SpringSecurity将登录用户信息存入SecurityContextHolder 中，本质上，其实是存在ThreadLocal中，为什么这么说呢？&lt;/p&gt;
&lt;p&gt;原因在于，SpringSecurity采用了策略模式，在SecurityContextHolder 中定义了三种不同的策略，而如果我们不配置，默认就是&lt;code&gt;MODE_THREADLOCAL&lt;/code&gt;模式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       
public static final String MODE_THREADLOCAL = &quot;MODE_THREADLOCAL&quot;;
public static final String MODE_INHERITABLETHREADLOCAL = &quot;MODE_INHERITABLETHREADLOCAL&quot;;
public static final String MODE_GLOBAL = &quot;MODE_GLOBAL&quot;;
public static final String SYSTEM_PROPERTY = &quot;spring.security.strategy&quot;;
private static String strategyName = System.getProperty(SYSTEM_PROPERTY);

private static void initialize() {
    if (!StringUtils.hasText(strategyName)) {
        // Set default
        strategyName = MODE_THREADLOCAL;
    }
    if (strategyName.equals(MODE_THREADLOCAL)) {
        strategy = new ThreadLocalSecurityContextHolderStrategy();
    }   
}

private static final ThreadLocal&amp;lt;SecurityContext&amp;gt; contextHolder = new ThreadLocal&amp;lt;&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;了解这个之后，又有一个问题抛出：ThreadLocal能够保证同一线程的数据是一份，那进进出出之后，线程更改，又如何保证登录的信息是正确的呢。&lt;/p&gt;
&lt;p&gt;这里就要说到一个比较重要的过滤器：&lt;code&gt;SecurityContextPersistenceFilter&lt;/code&gt;，它的优先级很高，仅次于&lt;code&gt;WebAsyncManagerIntegrationFilter&lt;/code&gt;。也就是说，在进入后面的过滤器之前，将会先来到这个类的doFilter方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SecurityContextPersistenceFilter extends GenericFilterBean {
        public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
                        throws IOException, ServletException {
                HttpServletRequest request = (HttpServletRequest) req;
                HttpServletResponse response = (HttpServletResponse) res;
        if (request.getAttribute(FILTER_APPLIED) != null) {
                        // 确保这个过滤器只应对一个请求
                        chain.doFilter(request, response);
                        return;
                }
        //分岔路口之后，表示应对多个请求
                HttpRequestResponseHolder holder = new HttpRequestResponseHolder(request,
                                response);
        //用户信息在 session 中保存的 value。
                SecurityContext contextBeforeChainExecution = repo.loadContext(holder);
                try {
            //将当前用户信息存入上下文
                        SecurityContextHolder.setContext(contextBeforeChainExecution);
                        chain.doFilter(holder.getRequest(), holder.getResponse());
                }
                finally {
            //收尾工作，获取SecurityContext
                        SecurityContext contextAfterChainExecution = SecurityContextHolder
                                        .getContext();
            //清空SecurityContext
                        SecurityContextHolder.clearContext();
            //重新存进session中
                        repo.saveContext(contextAfterChainExecution, holder.getRequest(),
                                        holder.getResponse());
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;SecurityContextPersistenceFilter&lt;/code&gt; 继承自 &lt;code&gt;GenericFilterBean&lt;/code&gt;，而 &lt;code&gt;GenericFilterBean&lt;/code&gt; 则是 Filter 的实现，所以 &lt;code&gt;SecurityContextPersistenceFilter&lt;/code&gt; 作为一个过滤器，它里边最重要的方法就是 &lt;code&gt;doFilter&lt;/code&gt; 了。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;doFilter&lt;/code&gt; 方法中，它首先会从 repo 中读取一个 &lt;code&gt;SecurityContext&lt;/code&gt; 出来，这里的 repo 实际上就是 &lt;code&gt;HttpSessionSecurityContextRepository&lt;/code&gt;，读取 &lt;code&gt;SecurityContext&lt;/code&gt; 的操作会进入到 &lt;code&gt;readSecurityContextFromSession(httpSession)&lt;/code&gt; 方法中。&lt;/li&gt;
&lt;li&gt;在这里我们看到了读取的核心方法 &lt;code&gt;Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);&lt;/code&gt;，这里的 &lt;code&gt;springSecurityContextKey&lt;/code&gt; 对象的值就是 &lt;code&gt;SPRING_SECURITY_CONTEXT&lt;/code&gt;，读取出来的对象最终会被转为一个 &lt;code&gt;SecurityContext&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SecurityContext&lt;/code&gt; 是一个接口，它有一个唯一的实现类 &lt;code&gt;SecurityContextImpl&lt;/code&gt;，这个实现类其实就是用户信息在 session 中保存的 value。&lt;/li&gt;
&lt;li&gt;在拿到 &lt;code&gt;SecurityContext&lt;/code&gt; 之后，通过 &lt;code&gt;SecurityContextHolder.setContext&lt;/code&gt; 方法将这个 &lt;code&gt;SecurityContext&lt;/code&gt; 设置到 &lt;code&gt;ThreadLocal&lt;/code&gt; 中去，这样，在当前请求中，Spring Security 的后续操作，我们都可以直接从 &lt;code&gt;SecurityContextHolder&lt;/code&gt; 中获取到用户信息了。&lt;/li&gt;
&lt;li&gt;接下来，通过 &lt;code&gt;chain.doFilter&lt;/code&gt; 让请求继续向下走（这个时候就会进入到 &lt;code&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt; 过滤器中了）。&lt;/li&gt;
&lt;li&gt;在过滤器链走完之后，数据响应给前端之后，&lt;strong&gt;finally 中还有一步收尾操作，这一步很关键&lt;/strong&gt;。这里从 &lt;code&gt;SecurityContextHolder&lt;/code&gt; 中获取到 &lt;code&gt;SecurityContext&lt;/code&gt;，获取到之后，会把 &lt;code&gt;SecurityContextHolder&lt;/code&gt; 清空，然后调用 &lt;code&gt;repo.saveContext&lt;/code&gt; 方法将获取到的 &lt;code&gt;SecurityContext&lt;/code&gt; 存入 session 中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;每个请求到达服务端的时候，首先从session中找出SecurityContext ，为了本次请求之后都能够使用，设置到SecurityContextHolder 中。&lt;/p&gt;
&lt;p&gt;当请求离开的时候，SecurityContextHolder 会被清空，且SecurityContext 会被放回session中，方便下一个请求来获取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;资源放行的两种方式&quot;&gt;资源放行的两种方式&lt;/h2&gt;
&lt;p&gt;用户登录的流程只有走过滤器链，才能够将信息存入session中，因此我们配置登录请求的时候需要使用configure(HttpSecurity http)，因为这个配置会走过滤器链。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;http.authorizeRequests()
        .antMatchers(&quot;/hello&quot;).permitAll()
        .anyRequest().authenticated()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 configure(WebSecurity web)不会走过滤器链，适用于静态资源的放行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers(&quot;/index.html&quot;,&quot;/img/**&quot;,&quot;/fonts/**&quot;,&quot;/favicon.ico&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 08 Sep 2020 15:15:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>本篇文章参考于【江南一点雨】的公众号。 Authentication 使用SpringSecurity可以在任何地方注入Authentication进而获取到当前登录的用户信息，可谓十分强大。 在Au</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/13636285.html</dc:identifier>
</item>
<item>
<title>Kubernetes K8S在IPVS代理模式下Service服务的ClusterIP类型访问失败处理 - 踏歌行666</title>
<link>http://www.cnblogs.com/zhanglianghhh/p/13636007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglianghhh/p/13636007.html</guid>
<description>&lt;p&gt;Kubernetes K8S使用IPVS代理模式，当Service的类型为ClusterIP时，如何处理访问service却不能访问后端pod的情况。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;143.0285023668&quot;&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Kubernetes K8S使用IPVS代理模式，当Service的类型为ClusterIP时，如何处理访问service却不能访问后端pod的情况。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;Kubernetes K8S使用IPVS代理模式，当Service的类型为ClusterIP时，出现访问service却不能访问后端pod的情况。&lt;/p&gt;


&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务器名称(hostname)&lt;/th&gt;
&lt;th&gt;系统版本&lt;/th&gt;
&lt;th&gt;配置&lt;/th&gt;
&lt;th&gt;内网IP&lt;/th&gt;
&lt;th&gt;外网IP(模拟)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;k8s-master&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.110&lt;/td&gt;
&lt;td&gt;10.0.0.110&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;k8s-node01&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.111&lt;/td&gt;
&lt;td&gt;10.0.0.111&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;k8s-node02&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.112&lt;/td&gt;
&lt;td&gt;10.0.0.112&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h2 id=&quot;Deployment的yaml信息&quot;&gt;Deployment的yaml信息&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;service
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;cat&lt;/span&gt; myapp-&lt;span&gt;deploy.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; apiVersion: apps/&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Deployment
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: myapp-&lt;span&gt;deploy
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   replicas: &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  selector:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    matchLabels:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      app: myapp
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;      release: v1
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  template:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    metadata:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      labels:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        app: myapp
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        release: v1
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;env&lt;/span&gt;&lt;span&gt;: test
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    spec:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      containers:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       -&lt;span&gt; name: myapp
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         image: registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        imagePullPolicy: IfNotPresent
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        ports:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         -&lt;span&gt; name: http
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;           containerPort: &lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动Deployment并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# kubectl apply -f myapp-&lt;span&gt;deploy.yaml 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; deployment.apps/myapp-&lt;span&gt;deploy created
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master service]# kubectl get deploy -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; NAME           READY   UP-TO-&lt;span&gt;DATE   AVAILABLE   AGE   CONTAINERS   IMAGES                                                      SELECTOR
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; myapp-deploy   &lt;span&gt;3&lt;/span&gt;/&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt;            &lt;span&gt;3&lt;/span&gt;           14s   myapp        registry.cn-beijing.aliyuncs.com/google_registry/myapp:v1   app=myapp,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-master service]# kubectl get rs -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;NAME                      DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES                                                      SELECTOR
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; myapp-deploy-5695bb5658   &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;3&lt;/span&gt;       21s   myapp        registry.cn-beijing.aliyuncs.com/google_registry/myapp:v1   app=myapp,pod-template-hash=5695bb5658,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@k8s-&lt;span&gt;master service]#
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; [root@k8s-master service]# kubectl get pod -o wide --show-&lt;span&gt;labels
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;NAME                            READY   STATUS    RESTARTS   AGE     IP             NODE         NOMINATED NODE   READINESS GATES   LABELS
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; myapp-deploy-5695bb5658-7tgfx   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          39s     &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.111&lt;/span&gt;   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            app=myapp,&lt;span&gt;env&lt;/span&gt;=test,pod-template-hash=5695bb5658,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; myapp-deploy-5695bb5658-95zxm   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          39s     &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;3.165&lt;/span&gt;   k8s-node01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            app=myapp,&lt;span&gt;env&lt;/span&gt;=test,pod-template-hash=5695bb5658,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; myapp-deploy-5695bb5658-xtxbp   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          39s     &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;3.164&lt;/span&gt;   k8s-node01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            app=myapp,&lt;span&gt;env&lt;/span&gt;=test,pod-template-hash=5695bb5658,release=v1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;curl访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.111&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;7tgfx
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;3.165&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;95zxm
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;3.164&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; myapp-deploy-5695bb5658-xtxbp
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;Service的ClusterIP类型信息&quot;&gt;Service的ClusterIP类型信息&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;service
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;cat&lt;/span&gt; myapp-svc-&lt;span&gt;ClusterIP.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Service
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: myapp-&lt;span&gt;clusterip
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  type: ClusterIP  # 可以不写，为默认类型
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  selector:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    app: myapp
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    release: v1
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  ports:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   -&lt;span&gt; name: http
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     port: &lt;span&gt;8080&lt;/span&gt;&lt;span&gt;  # 对外暴露端口
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     targetPort: &lt;span&gt;80&lt;/span&gt;  # 转发到后端端口
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动Service并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# kubectl apply -f myapp-svc-&lt;span&gt;ClusterIP.yaml 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; service/myapp-&lt;span&gt;clusterip created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master service]# kubectl get svc -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; NAME              TYPE        CLUSTER-IP       EXTERNAL-&lt;span&gt;IP   PORT(S)    AGE   SELECTOR
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; kubernetes        ClusterIP   &lt;span&gt;10.96&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;        &amp;lt;none&amp;gt;        &lt;span&gt;443&lt;/span&gt;/TCP    16d   &amp;lt;none&amp;gt;
&lt;span&gt;7&lt;/span&gt; myapp-clusterip   ClusterIP   &lt;span&gt;10.102&lt;/span&gt;.&lt;span&gt;246.104&lt;/span&gt;   &amp;lt;none&amp;gt;        &lt;span&gt;8080&lt;/span&gt;/TCP   6s    app=myapp,release=v1
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;查看ipvs信息&quot;&gt;查看ipvs信息&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# ipvsadm -&lt;span&gt;Ln
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; IP Virtual Server version &lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; (size=&lt;span&gt;4096&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Prot LocalAddress:Port Scheduler Flags
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   -&amp;gt;&lt;span&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; TCP  &lt;span&gt;10.102&lt;/span&gt;.&lt;span&gt;246.104&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt; rr
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.111&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;  
&lt;span&gt;8&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;3.164&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;  
&lt;span&gt;9&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;3.165&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由此可见，正常情况下：当我们访问Service时，访问链路是能够传递到后端的Pod并返回信息。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;Curl访问结果&quot;&gt;Curl访问结果&lt;/h2&gt;
&lt;p&gt;直接访问Pod，如下所示是能够正常访问的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.111&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;7tgfx
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;3.165&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;95zxm
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;3.164&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; myapp-deploy-5695bb5658-xtxbp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;但通过Service访问结果异常&lt;/span&gt;，信息如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.102&lt;/span&gt;.&lt;span&gt;246.104&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; curl: (&lt;span&gt;7&lt;/span&gt;) Failed connect to &lt;span&gt;10.102&lt;/span&gt;.&lt;span&gt;246.104&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;; Connection timed out
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&quot;抓包核实&quot;&gt;抓包核实&lt;/h2&gt;
&lt;p&gt;使用如下命令进行抓包，并通过Wireshark工具进行分析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tcpdump -i any -n -nn port &lt;span&gt;80&lt;/span&gt; -&lt;span&gt;w&lt;/span&gt; ./$(&lt;span&gt;date&lt;/span&gt; +%Y%m%d%H%M%S).pcap
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202009/1395193-20200908220545352-330959803.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可见，已经向Pod发了请求，但是没有得到回复。结果TCP又重传了【TCP Retransmission】。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;查看kube-proxy日志&quot;&gt;查看kube-proxy日志&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# kubectl get pod -A | &lt;span&gt;grep&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kube-proxy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; kube-system            kube-proxy-6bfh7                             &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;1&lt;/span&gt;&lt;span&gt;          3h52m
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; kube-system            kube-proxy-6vfkf                             &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;1&lt;/span&gt;&lt;span&gt;          3h52m
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; kube-system            kube-proxy-bvl9n                             &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;1&lt;/span&gt;&lt;span&gt;          3h52m
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [root@k8s-master service]# kubectl logs -n kube-system kube-proxy-&lt;span&gt;6bfh7
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; W0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.170506&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; feature_gate.go:&lt;span&gt;235&lt;/span&gt;] Setting GA feature gate SupportIPVSProxyMode=&lt;span&gt;true&lt;/span&gt;. It will be removed &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a future release.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.338922&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; node.go:&lt;span&gt;135&lt;/span&gt;] Successfully retrieved node IP: &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.112&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.338960&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; server_others.go:&lt;span&gt;172&lt;/span&gt;&lt;span&gt;] Using ipvs Proxier.  ##### 可见使用的是ipvs模式
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; W0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.339400&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; proxier.go:&lt;span&gt;420&lt;/span&gt;&lt;span&gt;] IPVS scheduler not specified, use rr by default
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.339638&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; server.go:&lt;span&gt;571&lt;/span&gt;] Version: v1.&lt;span&gt;17.4&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.340126&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; conntrack.go:&lt;span&gt;100&lt;/span&gt;] Set sysctl &lt;span&gt;'&lt;/span&gt;&lt;span&gt;net/netfilter/nf_conntrack_max&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; to &lt;span&gt;131072&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.340159&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; conntrack.go:&lt;span&gt;52&lt;/span&gt;] Setting nf_conntrack_max to &lt;span&gt;131072&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.340500&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; conntrack.go:&lt;span&gt;83&lt;/span&gt;] Setting conntrack hashsize to &lt;span&gt;32768&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.346991&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; conntrack.go:&lt;span&gt;100&lt;/span&gt;] Set sysctl &lt;span&gt;'&lt;/span&gt;&lt;span&gt;net/netfilter/nf_conntrack_tcp_timeout_established&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; to &lt;span&gt;86400&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.347035&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; conntrack.go:&lt;span&gt;100&lt;/span&gt;] Set sysctl &lt;span&gt;'&lt;/span&gt;&lt;span&gt;net/netfilter/nf_conntrack_tcp_timeout_close_wait&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; to &lt;span&gt;3600&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.347703&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; config.go:&lt;span&gt;313&lt;/span&gt;&lt;span&gt;] Starting service config controller
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.347718&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; shared_informer.go:&lt;span&gt;197&lt;/span&gt;] Waiting &lt;span&gt;for&lt;/span&gt; caches to &lt;span&gt;sync&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; service config
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.347736&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; config.go:&lt;span&gt;131&lt;/span&gt;&lt;span&gt;] Starting endpoints config controller
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.347743&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; shared_informer.go:&lt;span&gt;197&lt;/span&gt;] Waiting &lt;span&gt;for&lt;/span&gt; caches to &lt;span&gt;sync&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; endpoints config
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.448223&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; shared_informer.go:&lt;span&gt;204&lt;/span&gt;] Caches are synced &lt;span&gt;for&lt;/span&gt;&lt;span&gt; endpoints config 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; I0601 &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;13.448236&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; shared_informer.go:&lt;span&gt;204&lt;/span&gt;] Caches are synced &lt;span&gt;for&lt;/span&gt; service config
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见kube-proxy日志无异常&lt;/p&gt;

&lt;h2 id=&quot;网卡设置并修改&quot;&gt;网卡设置并修改&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;备注：在k8s-master节点操作的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之后进一步搜索表明，这可能是由于“Checksum offloading” 造成的。信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# ethtool -k flannel.&lt;span&gt;1&lt;/span&gt; | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; checksum
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; rx-&lt;span&gt;checksumming: on
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; tx-&lt;span&gt;checksumming: on     ##### 当前为 on
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     tx-checksum-&lt;span&gt;ipv4: off [fixed]
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     tx-checksum-ip-&lt;span&gt;generic: on    ##### 当前为 on
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     tx-checksum-&lt;span&gt;ipv6: off [fixed]
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     tx-checksum-fcoe-&lt;span&gt;crc: off [fixed]
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     tx-checksum-sctp: off [fixed]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;flannel的网络设置将&lt;span&gt;发送端&lt;/span&gt;的checksum打开了，而实际应该关闭，从而让物理网卡校验。操作如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 临时关闭操作
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; [root@k8s-master service]# ethtool -K flannel.&lt;span&gt;1&lt;/span&gt; tx-checksum-ip-&lt;span&gt;generic off  
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Actual changes:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; tx-&lt;span&gt;checksumming: off
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     tx-checksum-ip-&lt;span&gt;generic: off
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; tcp-segmentation-&lt;span&gt;offload: off
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     tx-tcp-&lt;span&gt;segmentation: off [requested on]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     tx-tcp-ecn-&lt;span&gt;segmentation: off [requested on]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     tx-tcp6-&lt;span&gt;segmentation: off [requested on]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     tx-tcp-mangleid-&lt;span&gt;segmentation: off [requested on]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; udp-fragmentation-&lt;span&gt;offload: off [requested on]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# 再次查询结果
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; [root@k8s-master service]# ethtool -k flannel.&lt;span&gt;1&lt;/span&gt; | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; checksum
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; rx-&lt;span&gt;checksumming: on
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; tx-&lt;span&gt;checksumming: off     ##### 当前为 off
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     tx-checksum-&lt;span&gt;ipv4: off [fixed]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     tx-checksum-ip-&lt;span&gt;generic: off     ##### 当前为 off
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     tx-checksum-&lt;span&gt;ipv6: off [fixed]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     tx-checksum-fcoe-&lt;span&gt;crc: off [fixed]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     tx-checksum-sctp: off [fixed]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然上述操作只能临时生效。机器重启后flannel虚拟网卡还会开启Checksum校验。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;之后我们再次curl尝试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master ~]# curl &lt;span&gt;10.102&lt;/span&gt;.&lt;span&gt;246.104&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Hello MyApp | Version: v1 | &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hostname.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Pod Name&amp;lt;/a&amp;gt;
&lt;span&gt; 3&lt;/span&gt; [root@k8s-master ~&lt;span&gt;]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master ~]# curl &lt;span&gt;10.102&lt;/span&gt;.&lt;span&gt;246.104&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;7tgfx
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [root@k8s-master ~&lt;span&gt;]# 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-master ~]# curl &lt;span&gt;10.102&lt;/span&gt;.&lt;span&gt;246.104&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;95zxm
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; [root@k8s-master ~&lt;span&gt;]# 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@k8s-master ~]# curl &lt;span&gt;10.102&lt;/span&gt;.&lt;span&gt;246.104&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;xtxbp
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; [root@k8s-master ~&lt;span&gt;]# 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; [root@k8s-master ~]# curl &lt;span&gt;10.102&lt;/span&gt;.&lt;span&gt;246.104&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; myapp-deploy-5695bb5658-7tgfx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由上可见，能够正常访问了。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;永久关闭flannel网卡发送校验&quot;&gt;永久关闭flannel网卡发送校验&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;备注：所有机器都操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用以下代码创建服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-node02 ~]# &lt;span&gt;cat&lt;/span&gt; /etc/systemd/system/k8s-flannel-tx-checksum-&lt;span&gt;off.service 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;[Unit]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; Description=Turn off checksum offload on flannel.&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; After=sys-devices-virtual-net-flannel.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.device
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;[Install]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; WantedBy=sys-devices-virtual-net-flannel.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.device
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;[Service]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; Type=&lt;span&gt;oneshot
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; ExecStart=/sbin/ethtool -K flannel.&lt;span&gt;1&lt;/span&gt; tx-checksum-ip-generic off
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;开机自启动，并启动服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; systemctl enable k8s-flannel-tx-checksum-&lt;span&gt;off
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; systemctl start  k8s-flannel-tx-checksum-off
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1、&lt;a href=&quot;https://blog.csdn.net/comeyes/article/details/106123409&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;关于k8s的ipvs转发svc服务访问慢的问题分析(一)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://t.du9l.com/2020/03/kubernetes-flannel-udp-packets-dropped-for-wrong-checksum-workaround/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Kubernetes + Flannel: UDP packets dropped for wrong checksum – Workaround&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;———END———&lt;br/&gt;如果觉得不错就关注下呗 (-^O^-) ！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202009/1395193-20200908220826329-530966117.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Tue, 08 Sep 2020 14:09:00 +0000</pubDate>
<dc:creator>踏歌行666</dc:creator>
<og:description>Kubernetes K8S使用IPVS代理模式，当Service的类型为ClusterIP时，如何处理访问service却不能访问后端pod的情况。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanglianghhh/p/13636007.html</dc:identifier>
</item>
<item>
<title>使用vuepress搭建GitHub pages静态博客页面 - 站住，别跑</title>
<link>http://www.cnblogs.com/zjjDaily/p/13633786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjjDaily/p/13633786.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.vuepress.cn/&quot; target=&quot;_blank&quot;&gt;vuepress官网&lt;/a&gt; vuepress是尤大开发来写文档的静态页面。可以用Markdown 语法，并且也可以使用vue模块化的方式开发页面。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://vuepress-theme-reco.recoluan.com/&quot; target=&quot;_blank&quot;&gt;vuepress-theme-reco&lt;/a&gt; 是另外的开发者开发的 vuepress主题。本文将介绍依赖这个主题，构建GitHub pages静态博客的详细过程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提前说明：本过程比较详细，相当于手把手的教，针对于不熟悉vuepress的人介绍的，大佬不喜勿喷。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一步：新建一个GitHub仓库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908142840993-286611916.png&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;445&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 仓库名随便取，不用以 username.github.io 这种方式。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 仓库不要选 private ，不然不能发布为GitHub pages。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 选择添加一个README文件，虽然没什么作用，因为后面要覆盖。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二步：克隆新建仓库的git地址，初始化项目&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1.  cmd 中执行 git clone 刚才复制的 git 地址&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.  推荐使用yarn 来进行安装，不然有可能会有其它不可未知的错误&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3.  执行 &lt;span class=&quot;cnblogs_code&quot;&gt;yarn global add @vuepress-reco/theme-cli&lt;/span&gt;  安装全局主题脚手架。安装完成后：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908144049792-1890019736.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;158&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span&gt;　　4. 执行  &lt;span class=&quot;cnblogs_code&quot;&gt;theme-cli init&lt;/span&gt;  然后会提示你选择一些东西：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908144158856-1042609335.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;最后一个让选择主页是什么样式的时候，有三种主题 blog，doc，afternoon-grocery。&lt;/p&gt;
&lt;p&gt;我三个都试了一下，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;blog与doc感觉基本上一样&lt;/li&gt;
&lt;li&gt;afternoon-grocery 目录和vuepress标准的目录一致，文章都放到view文件夹里&lt;/li&gt;
&lt;li&gt;和前两个相比，多了选择颜色主题的功能（并非明暗）；但是首页右边分类 个人认为没有 blog或者doc的好看。&lt;/li&gt;
&lt;li&gt;还多了个全屏的功能　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我选择了blog 主题。怎么选择就看你自己了。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;如果 yarn 过程出现错误，比如类似的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908150818318-1680872794.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 需要先把 &lt;span&gt;&lt;strong&gt;yarn.lock 删掉&lt;/strong&gt;&lt;/span&gt; 再重新安装。那里面的库路径有问题。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　&lt;strong&gt;5. 如果是安装的blog或者doc，那么安装完成之后，如果package.json中的dev项有  &lt;span class=&quot;cnblogs_code&quot;&gt;--open --host localhost&lt;/span&gt; ，要改成 &lt;span class=&quot;cnblogs_code&quot;&gt;vuepress dev .&lt;/span&gt; 不然运行不起。注意有个点，不过这个点可有可无。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　6. 改完之后，执行 &lt;span class=&quot;cnblogs_code&quot;&gt;yarn dev&lt;/span&gt;  等待编译完成，就能看到本地运行的 url 地址，打开即可看到页面了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三步：推到GitHub 自动转换成GitHub pages。步骤是blog主题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上传代码到GitHub之前，需要改一些代码，不然上传上去 在GitHub pages里显示的就是404&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 修改代码，push代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1） 根目录 .vuepress 下的config.js 中的dest项去掉，使用默认的打包后的路径，及： &lt;span class=&quot;cnblogs_code&quot;&gt;.vuepress/dist&lt;/span&gt; 。不过这项不重要，用自定义的也可以，后面新建脚本的时候，路径对上即可&lt;/p&gt;
&lt;p&gt;（2） 在config.js 中 和刚才去掉的dest同级的地方加上  &lt;span class=&quot;cnblogs_code&quot;&gt;“base”:”/Blogs/”&lt;/span&gt;   这个Blogs 不能乱取，&lt;span&gt;必须是你当前GitHub仓库名&lt;/span&gt;，并且&lt;span&gt;前后都有 / 斜杠&lt;/span&gt;！！！不然打包后静态资源路径会有问题。&lt;/p&gt;
&lt;p&gt;（3） 推送代码到GitHub仓库中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git add . 
git commit &lt;/span&gt;-&lt;span&gt;m’init’
git push&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 新建分支&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1） 这时候，可以在GitHub的仓库中，看到最新提交的代码，然后切换到setting选项&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908153725451-143222435.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2） 下拉到下面 GitHub Pages 项，如果这时候Soure里面是none，切换成master。点击save即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908153753981-631240060.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;（3） 页面自动刷新后，再拉到这个地方，就能看到已经自动发布好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908153838234-811544036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;（4） 但是这时候点击链接，打开的却是404，这是什么原因呢？仔细看404页面提示的原因，原来是GitHub pages 必须要有index.html，由于vuepress是Markdown语法没有html，所以显示不了。&lt;/p&gt;
&lt;p&gt;（5） 我们知道打包之后的静态文件项目就有html文件，所以只需要用另外的分支用来存放打包后的静态文件，html文件符合GitHub pages的规则，这样就能正确的显示了。&lt;/p&gt;
&lt;p&gt;（6） GitHub上 点击master分支，输入新分支名并create branch 这时候会自动切换到blogs分支上，并且内容和master一样。blogs分支名随便取，只要后面发布的时候，脚本里面的分支名对应上即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908154029317-1165511804.png&quot; alt=&quot;&quot; width=&quot;429&quot; height=&quot;251&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.  新建脚本，自动推送到blog分支&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）本地master分支新建一个 deploy.sh文件 名字随意，后面执行的时候名称一致即可，后缀是shell的后缀名 .sh ;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 确保脚本抛出遇到的错误
set &lt;/span&gt;-&lt;span&gt;e

# 生成静态文件
yarn build

# 进入生成的文件夹，这里是默认的路径，可以自定义
cd .vuepress&lt;/span&gt;/dist
&lt;span&gt;
# 如果是发布到自定义域名
# echo &lt;/span&gt;'www.isunbeam.cn' &amp;gt;&lt;span&gt; CNAME

git init
git add &lt;/span&gt;-&lt;span&gt;A
git commit &lt;/span&gt;-m 'deploy'&lt;span&gt;

# 如果发布到 https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;USERNAME&amp;gt;.github.io/&amp;lt;REPO&amp;gt;&lt;/span&gt;
# git push -f git@github.com:&amp;lt;USERNAME&amp;gt;/&amp;lt;REPO&amp;gt;.git master:&amp;lt;BranchName&amp;gt;
git push -f git@github.com:isunbeam/Blogs.git master:blogs
&lt;span&gt;
cd &lt;/span&gt;-&lt;span&gt;

# 最后发布的时候执行 bash deploy.sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2） 注意 git push 的时候，分支名一定要和GitHub上新建的分支名一样。&lt;/p&gt;
&lt;p&gt;（3） 执行  bash deploy.sh  。执行完成，到GitHub的仓库里，切换到setting，然后拉到GitHub Pages 这时候已经发布了，但是打开链接还是404，原因就是作为github pages的分支不正确，默认是master，下面切换成blogs，点击save即可&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908154517444-1584196221.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）等待页面刷新后，再次打开即可看到。如果还是没有，强制刷新一下 ctrl + f5。可能有缓存。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;到此，你的博客已经正常发布到GitHub pages了。\(^o^)/~&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;下面介绍怎么发表博客：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先说说目录：该目录是选择的blog主题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908155829644-587461490.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1） dist 是打包后的静态文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2） public 是存放图片等内容的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3） config.js 是最重要的，主题的配置项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4） blogs 是发表博客文章的地方，第二级目录表示分类，第三级目录表示年份，应该是用来做时间线用的，应该不能改成其它的内容。然后年份里面就是真正的博客页面，是 xxx.md 一般是以时间来命名文件的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如我现在要新建一个博客：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;（a）在blogs 里新建一个 2020 名称的文件夹，里面再新建一个 090801.md  的md文档，01表示0908号第一篇，02表示第二篇依此类推。写好了之后保存，直接刷新页面或者重启项目，即可看到新增的博客。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　 &lt;/span&gt;&lt;/span&gt;（b）在写的 md 里面的 date 日期项，&lt;strong&gt;感觉不能精确到时分秒&lt;/strong&gt;，不然时间轴 文章的日期就会多一天。比如date 是写的 2020-09-08 18:08:08 ，&lt;strong&gt;时间轴中就会被解析成 2020年的9月9号发表的&lt;/strong&gt;。所以建议不用时分秒。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 （c）如果想写的&lt;span&gt;博客有摘要&lt;/span&gt;，在正文前加上  &lt;span class=&quot;cnblogs_code&quot;&gt;&amp;lt;!-- more --&amp;gt;&lt;/span&gt;  这以上的代码就会被解析成摘要。类似下面的文章摘要&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908215226166-822783320.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;180&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（5） docs 是写文档的地方，相当于是 左边是大标题，右边是大标题对应的描述内容。第二级目录表示文档分类，和大标题的第一个内容，里面的README.md就是内容详情。然后里面的其余 .md 文档是另外的大标题的详情，然后要想新增后生效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　比如我现在要新建一个文档说明&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;（a）docs下面新建一个文件夹testdoc，在这个文件夹里再新建一个READEME.md作为大标题1的内容页，再建一个test1.md表示大标题2的内容页&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040666/202009/1040666-20200908165839934-1150798078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（b）每个内容页里随意编写内容，但是顶部需要有&lt;a href=&quot;https://vuepress-theme-reco.recoluan.com/views/1.x/frontMatter.html&quot; target=&quot;_blank&quot;&gt;Front Matter&lt;/a&gt;配置，然后再写md文档。写好后，在 config.js 中去配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（c）Docs配置项的items里面加上 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;text&quot;: &quot;test&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;link&quot;: &quot;/docs/testdoc/&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　（d）sidebar的配置项里加上 。数组第一项要为空&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&quot;/docs/testdoc/&quot;&lt;span&gt;: [
    &lt;/span&gt;&quot;&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;test1&quot;&lt;span&gt;
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（6） 配置完之后，会自动构建代码，然后强制刷新一下页面 ctrl + f5 。如果未生效，就重新启动一下项目就可以看到最新的文档了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;自定义域名&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 如果有人还想用自己的域名，不用 &amp;lt;username&amp;gt;.github.io/Blogs/ 这种域名，那么可以按下面的步骤来实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步：把  config.js 中的 base 项注释掉，这样默认静态文件根目录是  / ，不然发布之后会出现静态文件路径不正确的问题&lt;/p&gt;
&lt;p&gt;第二步：把 deploy.sh 的 echo 'xxx'  &amp;gt; CNAME 这一项放开，并且 把 xxx 换成 自己的域名，比如我是 www.isunbeam.cn 就是 echo 'www.isunbeam.cn' &amp;gt; CNAME&lt;/p&gt;
&lt;p&gt;第三步：保存。然后重新构建项目 bash deploy.sh 即可&lt;/p&gt;
&lt;p&gt;第四步：域名解析&lt;/p&gt;
&lt;p&gt;　　（1） 新建一个 主机值为www，记录类型为 CNAME，记录值为 &amp;lt;username&amp;gt;.github.io 的解析&lt;/p&gt;
&lt;p&gt;第五步： 在 GitHub 仓库的 setting 中，GitHub pages选项里 有一个Custom domain，把它更新为你刚才 CNAME解析的   www.xxx.xx 。点击save即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;到此，自定义域名的静态博客就完整搭建成功了，其余的就剩看 vuepress-theme-reco的文档啦。O(∩_∩)O哈哈~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果有想自己折腾的，也可以自己用组件的方式，自定义主题。(#^.^#)&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 08 Sep 2020 13:53:00 +0000</pubDate>
<dc:creator>站住，别跑</dc:creator>
<og:description>vuepress官网&amp;#160;vuepress是尤大开发来写文档的静态页面。可以用Markdown 语法，并且也可以使用vue模块化的方式开发页面。 vuepress-theme-reco&amp;#160</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zjjDaily/p/13633786.html</dc:identifier>
</item>
<item>
<title>阿里面试官：HashMap 熟悉吧？好的，那就来聊聊 Redis 字典吧！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13635904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13635904.html</guid>
<description>&lt;p&gt;最近，小黑哥的一个朋友出去面试，回来跟小黑哥抱怨，面试官不按套路出牌，直接打乱了他的节奏。&lt;/p&gt;
&lt;p&gt;事情是这样的，前面面试问了几个 Java 的相关问题，我朋友回答还不错，接下来面试官就问了一句：看来 Java 基础还不错，Java HashMap 你熟悉吧？&lt;/p&gt;
&lt;p&gt;我朋友回答。工作经常用，有看过源码。&lt;/p&gt;
&lt;p&gt;我朋友本来想着，你随便来吧，这个问题之前已经准备好了，随便问吧。&lt;/p&gt;
&lt;p&gt;谁知道，面试官下面一句：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那好的，我们来聊聊 Redis 字典吧。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接将他整蒙逼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215010489-1965884606.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小黑哥的朋友由于没怎么研究过 Redis 字典，所以这题就直接回答不知道了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然，如果面试中真不知道，那就回答不了解，直接下一题，不要乱答。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不过这一题，小黑哥觉得还是很可惜，其实 Redis 字典基本原理与 HashMap 差不多，那我们其实可以套用这其中的原理，不求回答满分，但是怎么也可以得个及格分吧~&lt;/p&gt;
&lt;p&gt;面试过程真要碰到这个问题，我们可以从下面三个方面回答。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;元素增加过程&lt;/li&gt;
&lt;li&gt;扩容&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;字典数据结构&quot;&gt;字典数据结构&lt;/h2&gt;
&lt;p&gt;说起字典，也许大家比较陌生，但是我们都知道 Redis 本身提供 KV 查询的方式，这个 KV 就是其实通过底层就是通过字典保存。&lt;/p&gt;
&lt;p&gt;另外，Redis 支持多种数据类型，其中一种类型为 Hash 键，也可以用来存储 KV 数据。&lt;/p&gt;
&lt;p&gt;小黑哥刚开始了解的这个数据结构的时候，本来以为这个就是使用字典实现。其实并不是这样的，初始创建 Hash 键，默认使用另外一种数据结构-&lt;strong&gt;ZIPLIST&lt;/strong&gt;(压缩列表)，以此节省内存空间。&lt;/p&gt;
&lt;p&gt;不过一旦以下任何条件被满足，Hash 键的数据结构将会变为字典，加快查询速度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哈希表中某个键或某个值的长度大于 &lt;code&gt;server.hash_max_ziplist_value&lt;/code&gt; （默认值为 &lt;code&gt;64&lt;/code&gt; ）。&lt;/li&gt;
&lt;li&gt;压缩列表中的节点数量大于 &lt;code&gt;server.hash_max_ziplist_entries&lt;/code&gt; （默认值为 &lt;code&gt;512&lt;/code&gt; ）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Redis 字典新建时默认将会创建一个哈希表数组，保存两个哈希表。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;ht[0]&lt;/code&gt; 哈希表在第一次往字典中添加键值时分配内存空间，而另一个 &lt;code&gt;ht[1]&lt;/code&gt; 将会在下文中扩容/缩容才会进行空间分配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215010640-1948215560.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字典中哈希表其实就等同于Java HashMap，我们知道 Java 采用数组加链表/红黑树的实现方式，其实哈希表也是使用类似的数据结构。&lt;/p&gt;
&lt;p&gt;哈希表结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215010919-1617876782.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;table&lt;/code&gt; 属性是个数组， 其中数组元素保存一种 &lt;code&gt;dictEntry&lt;/code&gt; 的结构，这个结构完全类似与 HashMap 中的 &lt;code&gt;Entry&lt;/code&gt; 类型，这个结构存储一个 KV 键值对。&lt;/p&gt;
&lt;p&gt;同时，为了解决 hash 碰撞的问题，&lt;code&gt;dictEntry&lt;/code&gt; 存在一个 next 指针，指向下一个&lt;code&gt;dictEntry&lt;/code&gt; ，这样就形成 &lt;code&gt;dictEntry&lt;/code&gt; 的链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215011569-26663009.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，我们回头对比 Java 中 HashMap，可以发现两者数据结构基本一致。&lt;/p&gt;
&lt;p&gt;只不过 HashMap 为了解决链表过长问题导致查询变慢，JDK1.8 时在链表元素过多时采用红黑树的数据结构。&lt;/p&gt;
&lt;p&gt;下面我们开始添加新元素，了解这其中的原理。&lt;/p&gt;
&lt;h2 id=&quot;元素增加过程&quot;&gt;元素增加过程&lt;/h2&gt;
&lt;p&gt;当我们往一个新字典中添加元素，默认将会为字典中 &lt;code&gt;ht[0]&lt;/code&gt; 哈希表分配空间，默认情况下哈希表 table 数组大小为 4（&lt;strong&gt;DICT_HT_INITIAL_SIZE&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;新添加元素的键值将会经过哈希算法，确定哈希表数组的位置，然后添加到相应的位置,如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215014019-702335073.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续增加元素，此时如果两个不同键经过哈希算法产生相同的哈希值，这样就发生了哈希碰撞。&lt;/p&gt;
&lt;p&gt;假设现在我们哈希表中拥有是三个元素，：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215015199-542395996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再增加一个新元素，如果此时刚好在数组 3 号位置上发生碰撞，此时 Redis 将会采用链表的方式解决哈希碰撞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215016279-1466397838.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，新元素将会放在链表头结点，这么做目的是因为新增加的元素，很大概率上会被再次访问，放在头结点增加访问速度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我们在对比一下元素添加过程，可以发现 Redis 流程其实与 JDK 1.7 版本的 HashMap 类似。&lt;/p&gt;
&lt;p&gt;当我们元素增加越来越多时，哈希碰撞情况将会越来越频繁，这就会导致链表长度过长，极端情况下 O(1) 查询效率退化成 O(N) 的查询效率。&lt;/p&gt;
&lt;p&gt;为此，字典必须进行扩容，这样就会使触发字典 rehash 操作。&lt;/p&gt;
&lt;h2 id=&quot;扩容&quot;&gt;扩容&lt;/h2&gt;
&lt;p&gt;当 Redis 进行 Rehash 扩容操作，首先将会为字典没有用到 &lt;code&gt;ht[1]&lt;/code&gt; 哈希表分配更大空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215022399-715780123.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;画外音：&lt;code&gt;ht[1]&lt;/code&gt; 哈希表大小为第一个大于等于 &lt;code&gt;ht[0].used*2&lt;/code&gt; 的 2^2(2的n 次方幂)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后再将 &lt;code&gt;ht[0]&lt;/code&gt; 中所有键值对都迁移到 &lt;code&gt;ht[1]&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215027699-1989821614.png&quot; alt=&quot;简单起见，忽略指向空节点&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当节点全部迁移完毕，将会释放 &lt;code&gt;ht[0]&lt;/code&gt;占用空间,并将 &lt;code&gt;ht[1]&lt;/code&gt; 设置为 &lt;code&gt;ht[0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215033239-29013810.png&quot; alt=&quot;s&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扩容 操作需要将 &lt;code&gt;ht[0]&lt;/code&gt;所有键值对都 &lt;code&gt;Rehash&lt;/code&gt; 到 &lt;code&gt;ht[1]&lt;/code&gt; 中，如果键值过多，假设存在十亿个键值对，这样一次性的迁移，势必导致服务器会在一段时间内停止服务。&lt;/p&gt;
&lt;p&gt;另外如果每次 &lt;code&gt;rehash&lt;/code&gt; 都会阻塞当前操作，这样对于客户端处理非常不友好。&lt;/p&gt;
&lt;p&gt;为了避免 &lt;code&gt;rehash&lt;/code&gt;对服务器的影响，Redis 采用渐进式的迁移方式，慢慢将数据迁移分散到多个操作步骤。&lt;/p&gt;
&lt;p&gt;这个操作依赖字典中一个属性 &lt;code&gt;rehashidx&lt;/code&gt;,这是一个索引位置计数器，记录下一个哈希表 table 数组上元素，默认情况为值为 &lt;strong&gt;-1&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设此时扩容前字典如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215040469-1750688934.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当开始 rehash 操作，&lt;code&gt;rehashidx&lt;/code&gt;将会被设置为 &lt;strong&gt;0&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这个期间每次收到增加，删除，查找，更新命令，除了这些命令将会被执行以外，还会顺带将 &lt;code&gt;ht[0]&lt;/code&gt;哈希表在 &lt;code&gt;rehashidx&lt;/code&gt; 位置的元素 rehash 到 &lt;code&gt;ht[1]&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;假设此时收到一个 &lt;strong&gt;K3&lt;/strong&gt; 键的查询操作，Redis 首先执行查询操作，接着 Redis 将会为 &lt;code&gt;ht[0]&lt;/code&gt;哈希表上 &lt;code&gt;table&lt;/code&gt; 数组第 &lt;code&gt;rehashidx&lt;/code&gt;索引上所有节点都迁移到 &lt;code&gt;ht[1]&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200908215045910-1147925553.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当操作完成之后，再将 &lt;code&gt;rehashidx&lt;/code&gt; 属性值加 1。&lt;/p&gt;
&lt;p&gt;最后当所有键值对都 &lt;code&gt;rehash&lt;/code&gt; 到 &lt;code&gt;ht[1]&lt;/code&gt;中时，&lt;code&gt;rehashidx&lt;/code&gt;将会被重新设置为 -1。&lt;/p&gt;
&lt;p&gt;虽然渐进式的 rehash 操作减少了工作量，但是却带来键值操作的复杂度。&lt;/p&gt;
&lt;p&gt;这是因为在渐进式 &lt;code&gt;rehash&lt;/code&gt; 操作期间，Redis 无法明确知道键到底在 &lt;code&gt;ht[0]&lt;/code&gt;中，还是在 &lt;code&gt;ht[1]&lt;/code&gt; 中,所以这个时候 Redis 不得不查找两个哈希表。&lt;/p&gt;
&lt;p&gt;以查找为例，Redis 首先查询 &lt;code&gt;ht[0]&lt;/code&gt; ，如果没找到将会继续查找 &lt;code&gt;ht[1]&lt;/code&gt;,除了查询以外，更新，删除也会执行如上的操作。&lt;/p&gt;
&lt;p&gt;添加操作其实就没这么麻烦，因为&lt;code&gt;ht[0]&lt;/code&gt;不会在使用，那就统一都添加到 &lt;code&gt;ht[1]&lt;/code&gt; 中就好了。&lt;/p&gt;
&lt;p&gt;最后我们再对比一下 Java HashMap 扩容操作，它是一个一次性操作，每次扩容需要将所有键值对都迁移到新的数组中，所以如果数据量很大，消耗时间就会久。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Redis 字典使用哈希表作为底层实现，每个字典包含两个哈希表，一个平时使用，一个仅在 rehash 操作中使用。&lt;/p&gt;
&lt;p&gt;哈希表总的来说，跟 Java HashMap 真的很类似，底层实现也是一个数组加链表数据结构。&lt;/p&gt;
&lt;p&gt;最后，当对哈希表进行扩容操作时间，将会采用渐进性 rehash 操作，慢慢将所有键值对迁移到新哈希表中。&lt;/p&gt;
&lt;p&gt;其实了解 Redis 字典的其中的原理，再去比较 Java HashMap ，其实可以发现这两者有如此多的相似点。&lt;/p&gt;
&lt;p&gt;所以学习这类知识时，不要仅仅去背，我们要了解其底层原理，知其然知其所以然。&lt;/p&gt;
&lt;h2 id=&quot;帮助资料&quot;&gt;帮助资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://redisbook.readthedocs.io/en/latest/internal-datastruct/dict.html&quot;&gt;https://redisbook.readthedocs.io/en/latest/internal-datastruct/dict.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 08 Sep 2020 13:51:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>最近，小黑哥的一个朋友出去面试，回来跟小黑哥抱怨，面试官不按套路出牌，直接打乱了他的节奏。 事情是这样的，前面面试问了几个 Java 的相关问题，我朋友回答还不错，接下来面试官就问了一句：看来 Jav</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13635904.html</dc:identifier>
</item>
</channel>
</rss>