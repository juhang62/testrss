<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>开始入秋，一场秋雨一场寒 - liuzhiyong</title>
<link>http://www.cnblogs.com/oneofyou/p/13737624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oneofyou/p/13737624.html</guid>
<description>&lt;p&gt;
&lt;h4 id=&quot;前两天广州还是炎热的天气，但昨日下午就开始下雨，一直不停的下，好久没有那么长时间的雨。下班走在路上，鞋子都灌满了水。&quot;&gt;前两天广州还是炎热的天气，但昨日下午就开始下雨，一直不停的下，好久没有那么长时间的雨。下班走在路上，鞋子都灌满了水。&lt;/h4&gt;
&lt;h4 id=&quot;回到家第一时间是换掉衣服，赶紧穿回长袖！&quot;&gt;回到家第一时间是换掉衣服，赶紧穿回长袖！&lt;/h4&gt;
&lt;h4 id=&quot;不过下雨之后的空气质量真是好，很舒服，昨晚一个晚上居然可以不用开空调，早上起来才22度，可以愉快的穿长袖了。。&quot;&gt;不过下雨之后的空气质量真是好，很舒服，昨晚一个晚上居然可以不用开空调，早上起来才22度，可以愉快的穿长袖了。。&lt;/h4&gt;
&lt;h4 id=&quot;正所谓一场秋雨一场寒，秋天，来了！&quot;&gt;正所谓一场秋雨一场寒，秋天，来了！&lt;/h4&gt;
&lt;/p&gt;



</description>
<pubDate>Sun, 27 Sep 2020 00:37:00 +0000</pubDate>
<dc:creator>liuzhiyong</dc:creator>
<og:description>前两天广州还是炎热的天气，但昨日下午就开始下雨，一直不停的下，好久没有那么长时间的雨。下班走在路上，鞋子都灌满了水。 回到家第一时间是换掉衣服，赶紧穿回长袖！ 不过下雨之后的空气质量真是好，很舒服，昨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/oneofyou/p/13737624.html</dc:identifier>
</item>
<item>
<title>使用Flutter完成10个商业项目后的经验教训 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13737582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13737582.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200927073424480-333432207.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.6496815286624&quot;&gt;
&lt;p&gt;作者：Łukasz Kosman 和 Jakub Wojtczak&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://medium.com/swlh/lessons-learned-after-making-the-first-10-commercial-apps-in-flutter-f420808048cd&quot;&gt;https://medium.com/swlh/lessons-learned-after-making-the-first-10-commercial-apps-in-flutter-f420808048cd&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在过去的24个月中，我们花费 17.193,00 个小时使用 Flutter 完成了10个商业应用程序，本文将分享我们的见解。&lt;/p&gt;
&lt;p&gt;阅读本文后，您将学习到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择Flutter的原因是什么？ Flutter对预算和稳定性有什么影响？&lt;/li&gt;
&lt;li&gt;Flutter准备好用于企业应用程序了吗？&lt;/li&gt;
&lt;li&gt;与Xamarin相比，Flutter的表现如何？&lt;/li&gt;
&lt;li&gt;Flutter适合哪些项目？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200927073425545-1842575485.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自2018年7月在LeanCode上开始在Flutter上开发我们的第一个商业应用程序以来，到现在已经有两年了，当我第一次了解Flutter时，尽管它很有前景，但我仍然持怀疑态度，主要是因为我们最近对Xamarin的投资给我们带来了负面体验。 由于我们的团队一直希望在项目中使用一些激动人心的新技术，因此我们希望它能够证明它能给客户带来真正的价值。&lt;/p&gt;
&lt;p&gt;这是一个农业项目，与牧群管理打交道，这是一个非常有趣而且典型的项目，管理员使用该系统来计算对谷仓的需求，而我们的团队认为，从UX的角度来看，这是一个很好的见解。&lt;/p&gt;
&lt;p&gt;在两天内，他们自豪地展示了概念验证方案，证明了制作动画非常容易，可以为您带来出色而流畅的体验。最终，这已演变为完整比例的动画，您可以在此处看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200927073427447-1149102952.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有了这个喜悦，我确信Flutter值得尝试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最初，我们没有将自己100％投入Flutter，而是与 React Native 项目并行进行。在没有Flutter团队官方支持的情况下编写第一个Google Maps实现，对此我感到悲观。您可以在&lt;a href=&quot;https://leancode.pl/case-studies/kezia-app&quot;&gt;此处&lt;/a&gt;了解有关在Flutter中编写第一个商业应用程序的经验以及相关困难的更多信息。最终，我们交付的是一个相对简单的应用程序，少于40个视图，且Flutter开发时间不到500小时。&lt;/p&gt;
&lt;p&gt;自从我们交付了第一个应用程序并从客户那里收集到了五星级好评，我们认为，我们应该开始更加积极地向客户推荐Flutter。从2019年5月开始，我们决定Flutter将是我们移动技术的第一选择。同时，我们将停止在其他不同框架上开发应用程序的工作。&lt;/p&gt;
&lt;p&gt;自那时以来，我们已经在Flutter中交付了10多种移动产品，并提供了数十种MVP / PoC。现在，该得出结论了。&lt;/p&gt;
&lt;h4 id=&quot;flutter-更快&quot;&gt;Flutter 更快&lt;/h4&gt;
&lt;p&gt;我们并未在这里讨论理论方法（在此处可以查找&lt;a href=&quot;https://blog.codemagic.io/flutter-vs-ios-android-reactnative-xamarin/&quot;&gt;Bran De Connick的论文&lt;/a&gt;），尽管这也很有趣。后来我们重写了基于 Xamarin 和 ReactJS 的App，将二者进行对比，在后端使用相同API的情况下，与Xamarin（667h vs 987h）相比，我们减少了33％的时间，使用ReactJS（486h vs 704h）相比，则减少了31％的时间。&lt;/p&gt;
&lt;p&gt;停下来思考一下这些数字。这些数据回答了如何更快，更便宜地构建移动应用程序（使用Flutter）。随着经济不景气，在预算范围内按时交付产品变得越来越重要。这也意味着对于相同的预算，您可以多交付50％的订单。想象一下，您是一名产品负责人，负责开发团队的优先事项，能够将预算壁垒进一步提高50％。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200927073427821-245012458.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这将极大地提高团队的创造力和他们交付的工作质量。有关GastroJob案例的详细分析，请查看我们在&lt;a href=&quot;https://www.google.com/sorry/index?continue=https://www.youtube.com/watch%3Fv%3DbE2xqtl0Jhw&amp;amp;q=EgR3UaQPGKT9tvsFIhkA8aeDS-Z7tPHwBoUS4lcIB2tdcoOpSehfMgFy&quot;&gt;Flutter Europe Conference&lt;/a&gt;上的演讲，或在&lt;a href=&quot;https://leancode.pl/case-studies/gastrojob&quot;&gt;此处&lt;/a&gt;查看我们的案例研究。&lt;/p&gt;
&lt;h4 id=&quot;平均90％的代码在ios和android之间共享。&quot;&gt;平均90％的代码在iOS和Android之间共享。&lt;/h4&gt;
&lt;p&gt;我们的90％的代码不会在两个本机平台上都编写两次。与本地应用程序开发相比，节省了90％的时间，并且由于一致性和团队围绕一个目标团结而不是分成两个本地流，因此释放了很多创造力。除了共享业务逻辑和用户体验外，我们还可以使用大量现成的库，这些库带来了更多的好处。首先，他们可以通过为应用程序内使用的许多不同事物提供常用逻辑来加快开发过程（例如与服务器（HTTP客户端）的通信，推送通知，安全存储，数据库，动画等）。其次，与许多流行的服务（例如Firebase，地图，支付，社交登录，分析，崩溃报告服务等）集成起来更加容易。因此，只有在编写特定于平台的自定义代码时，才需要编写两次代码（分别适用于iOS和Android）。但是，即使那样，在Dart和本机代码之间进行桥接还是相当合理的 简单，这将在本文后面进行解释。&lt;/p&gt;
&lt;p&gt;更重要的是，如果考虑到质量因素，则可以节省更多，因此从长远来看，该应用程序的维护成本也更低。事实上，我们研究在Xamarin，React Native和Flutter构建的所有项目中修复bug的时间，，Flutter通常需要8–10％的修复bug时间。而 React Native 需要7–14％，Xamarin 需要11–23％。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200927073428070-683046451.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;与ux--ui的合作从未如此之好&quot;&gt;与UX / UI的合作从未如此之好&lt;/h4&gt;
&lt;p&gt;在Flutter项目期间，需要UX / UI设计师和开发人员之间进行合作。可能是因为他们不需要进行这种乏味的本地改编，而使他们的创造力松散。但是，从React Native团队的经验中也可以期望得到同样的结果，事实并非如此。当我们更深入地挖掘时，我们发现Flutter为能够编写漂亮界面的开发人员带来了纯粹的欢乐，以前这些界面会带来额外的负担，从而减慢了步伐。因此，他们更愿意合作，并且我们已经看到结对编程会议开始于设计师与开发人员携手进行现场实验的过程中。经过几次这样的互动，得益于强大的主题引擎，团队能够为该应用程序提供一种自适应的设计语言，该语言不仅在Figma或Adobe XD中看起来很棒，而且还提供了最佳的用户体验以及连贯的感觉。正确的设计顺序。怎么样 在项目的整个生命周期中保持这种连贯性也很有趣。 以前，当UX / UI设计师在演示会议上审查产品时，他们在项目结束时拥有大部分评论，在实践经验之后改变主意或简化事情。 Flutter的独特之处在于，在项目结束时，设计师的参与已完全消失，因为他们在试验和错误的设计循环的初期就开始工作。 这也意味着后续sprint的优化花费的时间更少，并且这种持续的合作体现在下一个发行版的稳定Scrum速度上。&lt;/p&gt;
&lt;h4 id=&quot;动画是如此的简单和实惠&quot;&gt;动画是如此的简单和实惠&lt;/h4&gt;
&lt;p&gt;在Flutter中实现静态视图不仅容易，而且在动画方面也提供了许多新的机会。这将这种UX-DEV的合作推向了新的高度，从而实现了前所未有的出色过渡效果。到目前为止，这仅对大型预算项目而言是典型的。如今，感谢Flutter，所有开发人员都可以使用它。之所以会发生这种情况，是因为Flutter可以直接在画布上进行渲染，并且可以完全控制图形，这使我们能够在所有平台上创建像素完美的图像，而无需像其他跨平台框架一样进行附加的条件格式设置。例如，在使用React Native进行绘制时，您基于默认视图，这些视图可以改变新控件的外观，因此，构建了一个臭代码，该代码依赖于平台，并且与共享代码不应采用的方法直接矛盾进入部署平台。&lt;/p&gt;
&lt;h4 id=&quot;flutter应用程序更轻巧&quot;&gt;Flutter应用程序更轻巧&lt;/h4&gt;
&lt;p&gt;面对PWA业务选择时，PWA证明了在手机上添加快捷方式来像保存应用程序一样保存网站是多么容易。我们先不讨论用户体验，而只考虑下载应用程序的负担。是的，在两种情况下都并非易事。根据SimiCart博客，最佳PWA网站要求用户在加载时从4.9MB到11.6MB。这远远低于我们的Xamarin应用程序的平均大小25MB，甚至低于我们的React Native 32MB应用程序的平均大小，但非常接近Flutter的平均值11MB，所有Flutter应用程序的范围为9-14MB （请注意，尽管这些数字突出显示了模式，但它们不能直接比较）。您必须承认，对于本机应用程序体验，平滑的外观，快速的反应以及本机应用程序典型的所有服务（例如推送通知）而言，此（11MB）的空间非常低。这意味着没有障碍。 用户下载该应用程序，并开始与所有插件和集成一起尽可能高效地使用它。 这也意味着应用程序性能更高，因为它们可以使用较小的代码执行类似的任务。 与其他跨平台框架相比，这种性能上的提升直接转化为毫秒数，从而为您提供了较冷的应用程序，动画，CPU和内存使用方面的更快体验（实际上，在Flutter可以提供更好的冷启动应用程序的情况下，即使相比 到Swift / Kotlin本机应用程序）。&lt;/p&gt;
&lt;h4 id=&quot;需要时可以访问本机代码。&quot;&gt;需要时可以访问本机代码。&lt;/h4&gt;
&lt;p&gt;Flutter的优点在于，移动团队更希望使用本机代码并编写一些Kotlin / Swift软件包，因为它们可以完全控制本机实现，而Xamarin就是这种情况最终代码在一个孤立的黑匣子中生成。到本机代码的桥也更强大，因为它们是完全透明的，因此对于从本机环境转移过来的开发人员来说更友好。由于采用了这种方法，因此可以轻松实现特定功能，例如本地支付提供商或一些复杂的库。更重要的是，即使是需要生物特征识别算法进行面部识别或指纹检查的高级功能，也可以在Flutter上顺利运行，这是由ING商业在Flutter中开发的银行应用程序展示的，该应用程序是在JakubBiliński在Flutter Warsaw Meetup上展示的（&lt;a href=&quot;https://leancode.pl/blog/flutter-warsaw-jakub-bilinski&quot;&gt;链接&lt;/a&gt;）。&lt;/p&gt;
&lt;h4 id=&quot;flutter中的概念非常简单&quot;&gt;Flutter中的概念非常简单&lt;/h4&gt;
&lt;p&gt;当我们需要构建概念证明以检查最危险的假设测试时，与本机代码的集成带来的其他好处。这意味着在客户决定签署整个项目的合同之前，我们可以构建最小的应用程序，以回答最关键的业务或技术问题。在这一点上，我们不能高估Flutter的功能。每次我们将此类计划定为两天的开发时间，试图找出在这么短的时间内可以实现的目标。到目前为止，我们正在尝试各种PoC，包括支持AR的图像检测系统（如下），&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200927073431500-2035986398.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过白板图纸绘制高级动画。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200927073432963-489957534.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建立快速的PoC不仅使我们能够展示开发的速度，而且还有助于我们为最终项目提供更准确的估算。&lt;/p&gt;
&lt;h4 id=&quot;开发人员很高兴&quot;&gt;开发人员很高兴&lt;/h4&gt;
&lt;p&gt;从建立内部团队的角度来看，Flutter被证明是一个不错的选择。最初，Flutter开发人员很少，因为没有专业经验。但是，与开发人员具有C＃背景的Xamarin相比，情况有所不同，在Flutter的情况下，所有候选人都是已经从本地（主要是Android）背景转移的移动开发人员。随着Flutter变得越来越受欢迎，并且由于社区组织的活跃以及定期聚会和网络研讨会的兴起，可用的候选人数量呈指数增长，如今，有大量的专业人士愿意在Flutter项目中寻找工作经过多年的本机应用程序开发，我们改变了看法。得益于文件详尽的Flutter代码以及社区提供的其他库的可用性，进行此类转移非常容易。因此，一些以前拥有独立移动团队的公司 正在投资以使它们围绕Flutter。 在LeanCode，我们甚至组织了Flutter训练营，在湖边进行了为期三天的培训计划，以提供动手经验，并为密集的，为期两个月的学习计划选择最佳人选，在那里学习Flutter 伴随着做一些非商业项目。 我们惊讶地注意到，经过9个星期的培训，开发人员准备与他们的同事并肩工作，他们从早期就开始在Flutter中进行编码。 如此短暂的学习周期证明，从企业主的角度出发，选择从本地应用程序切换到Flutter并不是一场革命，而是一场内部团队可以发挥重要作用的演变。&lt;/p&gt;
&lt;p&gt;对技术栈做出正确的决定可能会对您的业务和个人职业产生持久的影响。然而，很少有选择如此简单。 Flutter已经成为不可阻挡的运动，不可忽视的力量，并且它仍在发展并向具有银行或保险等极高质量标准的非常保守的行业扩展（例如NuBank，ING和AXA等）。&lt;/p&gt;
&lt;p&gt;如果考虑到甚至在生产阶段发布Flutter for Web或Flutter for Desktop之前都会发生这种情况，则表明Flutter for mobile具有足够的价值，可以在这个非常先进的市场上竞争。无论您从事的行业是什么，早期采用者的时代都已经过去，我们很快就会见证越来越多的成熟参与者进入Flutter生态系统。我希望这将使我们能够在Flutter中制作出另外10款出色的应用程序后，在明年的总结中分享从这些实现中学到的经验教训。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客（330个控件用法+实战入门系列文章）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200927073435072-491661536.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200927073435878-864267223.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Sat, 26 Sep 2020 23:35:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>作者：Łukasz Kosman 和 Jakub Wojtczak 原文：https://medium.com/swlh/lessons-learned-after-making-the-first-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13737582.html</dc:identifier>
</item>
<item>
<title>golang开发:channel使用 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/13737559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/13737559.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;channel主要是用于多个goroutine之间通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;channel语法&quot;&gt;channel语法&lt;/h3&gt;
&lt;p&gt;channel是引用类型,需要实用make来创建channel,如下&lt;br/&gt;make(chan Type, [buffer])&lt;br/&gt;chan Type 通道的类型&lt;br/&gt;buffer 是可选参数，代表通道缓冲区的大小(省略则代表无缓冲)&lt;br/&gt;向channel里面写入数据使用 &amp;lt;- 符号&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;q := make(chan bool)
q&amp;lt;-true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从channel里面读取数据也是使用 &amp;lt;- 符号，只不过写入的channel在右边，读取的时候channel在左边。意思跟方向是一致的，一个是数据进入channel，一个是数据从channel出去&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;q := make(chan bool)
&amp;lt;-q
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;有缓冲channel的使用&quot;&gt;有缓冲channel的使用&lt;/h3&gt;
&lt;p&gt;我们一直使用的无缓冲的channel，今天主要学习下有缓存的channel。&lt;br/&gt;无缓冲的channel，写入数据后一定要有goroutine 从channel读取数据后再写入，否则程序会panic。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
        ch := make(chan int)
        ch&amp;lt;-1
}

fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有缓冲的channel，可以写入缓冲大小个数据，可以没有goroutine从channel读取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
        ch := make(chan int,2)
        ch&amp;lt;-1
        ch&amp;lt;-2
}


Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果跟预期是一致的。&lt;/p&gt;
&lt;h3 id=&quot;有缓冲大小的channel使用场景&quot;&gt;有缓冲大小的channel使用场景&lt;/h3&gt;
&lt;p&gt;假如我们有一个任务需要10个goroutine去调度执行，只要有一个goroutine执行完毕，调度就应该结束。我们看下伪代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func test(wg *sync.WaitGroup,ch chan int,i int) {
        fmt.Println(&quot;test code&quot;)
        ch&amp;lt;-i
}

func main() {
        fmt.Println(&quot;start&quot;,runtime.NumGoroutine())
        ch := make(chan int)
        wg := new(sync.WaitGroup)
        for i:=0;i&amp;lt;10;i++ {
                wg.Add(1)
                go test(wg,ch,i)
        }
        fmt.Println(&amp;lt;-ch)
        fmt.Println(&quot;end&quot;,runtime.NumGoroutine())
        wg.Done()
}

start 1
test code
9
end 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从执行结果上看，是第9个goroutine首先执行完毕了。程序也正常退出了。但是我们看到，加上主goroutine，内存中一共有11个goroutine，程序退出的时候还有10个goroutine，减去一个主goroutine，还有9个goroutine没有退出，这个对程序来说是不允许，可能会泄漏或者长期占用资源不释放。&lt;/p&gt;
&lt;p&gt;但是我们如果使用了有缓冲的channel，就可以利用channel的缓冲机制正常退出全部的goroutine了。&lt;br/&gt;看下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func test(wg *sync.WaitGroup,ch chan int,i int) {
        ch&amp;lt;-i
}

func main() {
        fmt.Println(&quot;start&quot;,runtime.NumGoroutine())
        ch := make(chan int, 10)
        wg := new(sync.WaitGroup)
        for i:=0;i&amp;lt;10;i++ {
                wg.Add(1)
                go test(wg,ch,i)
        }
        fmt.Println(&amp;lt;-ch,&quot;success&quot;)
        for i:= 0;i&amp;lt;9;i++ {
         fmt.Println(&amp;lt;-ch)
        }
        fmt.Println(&quot;end&quot;,runtime.NumGoroutine())
        wg.Done()
}

start 1
0 success
1
2
4
3
5
6
7
8
9
end 1

Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印success的时候，第一个goroutine已经将任务完成，循环9次将channel里面的数据读取出来，保证创建的goroutine都不会阻塞能够正常退出来。&lt;/p&gt;
</description>
<pubDate>Sat, 26 Sep 2020 22:29:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>channel主要是用于多个goroutine之间通信 channel语法 channel是引用类型,需要实用make来创建channel,如下 make(chan Type, [buffer]) c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feixiangmanon/p/13737559.html</dc:identifier>
</item>
<item>
<title>RectTransform简析 - blueberryzzz</title>
<link>http://www.cnblogs.com/blueberryzzz/p/13737501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blueberryzzz/p/13737501.html</guid>
<description>&lt;p&gt;  UGUI主要提供了两个能力&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;UI元素的渲染与适配（其中UI元素的Mesh中的position信息就是通过RectTransform生成的，本文重点）&lt;/li&gt;
&lt;li&gt;设备事件的响应与处理（EventSystem系统，及封装的Button、Toggle等常用组件）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020010362-2005760090.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  也就是说RectTransform是通过这四个属性来确定RectTransform的四个顶点的（position）。&lt;/p&gt;

&lt;h2 id=&quot;额外属性的含义&quot;&gt;额外属性的含义&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;anchorMin:左下角锚点距离父节点左下角的标准距离（父节点所确定四个顶点的矩形的左下角看作(0,0)，右上角看作(1,1)）。&lt;/li&gt;
&lt;li&gt;anchorMax:右上角距离父节点左下角的标准距离。&lt;/li&gt;
&lt;li&gt;pivot:中心点距离自身所确定的矩形的左下角的标准距离。&lt;/li&gt;
&lt;li&gt;sizeDelta:自身所确定的矩形长宽相对于anchorMin、anchorMax所确定的矩形的偏移量（偏移时会按照pivot的比例来偏移，举个例子：pivot是(0.3,pY)，sizeDelta是(100, sY)，那么自身的矩形左下角会相对于anchorMin负向偏移30，右上角会相对anchorMax正向偏移70，整体将矩形扩大了100。y轴一样）。&lt;/li&gt;
&lt;li&gt;anchoredPosition:自身矩形的中心点相对于anchorMin、anchorMax所确定的矩形中心点的位置（或者也可以理解为偏移量，下面会说）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何通过这几个参数来确定自身的矩形&quot;&gt;如何通过这几个参数来确定自身的矩形&lt;/h2&gt;
&lt;p&gt;  通过一个例子来说明一个RectTransform的形状是如何通过上面的几个参数确定的。&lt;br/&gt;  父节点信息&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020026799-372130791.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  子节点信息&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020043970-1749818938.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;1确定anchormin、anchormax代表的矩形&quot;&gt;1.确定anchorMin、anchorMax代表的矩形&lt;/h3&gt;
&lt;p&gt;  父节点的长宽为(1920,1080)，子节点的anchorMin为(0.2,0.3)，所以如果把父节点矩形的左下角看作原点，那么anchorMin所代标的点的坐标即为(1920 * 0.2,1080 * 0.3)，也就是(384,324)。同理，得到anchorMax代表点的坐标(1152,972)。&lt;br/&gt;  也就是一个左下角坐标为(384,324)，长宽为(1152 - 384,972 - 324)，即(768,648)的矩形。&lt;br/&gt;  用RectTransform来表示的话就是下图这样，anchorMin、anchorMax、pivot都为(0,0)，Pos为（384,324），长宽(768,648)。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020103386-133297844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2通过sizedelta和pivot确定自身矩形的大小&quot;&gt;2.通过sizeDelta和pivot确定自身矩形的大小&lt;/h3&gt;
&lt;p&gt;  因为sizeDelta是(100,300)，所以接下来对上一步确定的矩形的左下角平移(-100 * 0.4, -300 * 0.5)，平移后为(344,174)。右上角的点平移(100 * 0.6, 300 * 0.5)，平移后为(1212,1122)。&lt;br/&gt;  用RectTransform来表示的话就是下图这样，anchorMin、anchorMax、pivot都为(0,0)，Pos为（344,174），长宽(868,948)。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020115342-1464531639.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3通过anchoredposition对自身进行平移&quot;&gt;3.通过anchoredPosition对自身进行平移&lt;/h3&gt;
&lt;p&gt;  把上一步确定的矩形平移子节点的anchoredPositino(60,-200)。&lt;br/&gt;  用RectTransform来表示的话就是下图这样，anchorMin、anchorMax、pivot都为(0,0)，Pos为（404,-26），长宽(868,948)。&lt;br/&gt;  这个RectTransform所表示的矩形正好可以和子节点的重合，虽然参数不一样。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020124441-783793817.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;注意&quot;&gt;注意&lt;/h2&gt;
&lt;p&gt;  严格来说并不是左下角或者右上角，而是指的anchorMin、anchorMax所确定的点。向左、向右指的是父节点空间内的负方向和正方向。但是因为绝大多数情况下anchorMin的xy坐标会小于anchorMax的xy坐标，这样才是一个几何意义明显的矩形。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020139908-210771754.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;就是anchorsMin、anchorsMax、pivot，上面已经说过了，这理解不说了。&lt;/li&gt;
&lt;li&gt;是就是Transform的localRotaion和localScale属性，也没啥好说的。&lt;/li&gt;
&lt;li&gt;这四个数值是对sizeDelta和anchoredPosition的封装。让开发者可以更直观的进行位置和大小的调整。&lt;br/&gt;具体来说就是左侧的两个值代表了sizeDelta和anchoredPosition的x值，右侧的两个值代表了y值。&lt;br/&gt;下面就来说一下左边两个值的具体含义，当anchorsMin和anchorsMax的x值相等时，也就是这两个锚点的x坐标重合。这个时候这两个值会变成PosX和Width，其实就是anchoredPosition.x和sizeDelta.x的几何意义。&lt;br/&gt;anchoreMin和anchoreMax的x值不等时，也就是这两个锚点的x坐标分离时。会变成left，right。分别代表子节点左侧、右侧相对于anchoredMin、Max确定的矩形向内的偏移量，十分直观。其实还是对anchoredPosition.x和sizeDelta.x的封装。&lt;br/&gt;右边的两个值就对应anchoredPosition.y和sizeDelta.y。&lt;/li&gt;
&lt;li&gt;就是localPosition的z值。在Inspetor中，把localPostion.xy隐藏了，只暴露了z值出来，因为localPositino的xy值一般不会主动去修改，是通过RectorTranform中这几个额外的属性动态算出来的。&lt;/li&gt;
&lt;li&gt;一些预设的常用值，纵向代表y，横向代表x。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020356256-606509416.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;这两个按钮是蓝图模式和原始模式，蓝图模式就是在Scene中的那个小框是把RectTranform包起来，还是展示通过这几个额外属性确定的矩形（不考虑旋转和缩放）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020213897-1447465383.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020228632-1292705669.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;原始模式就是在调整anchors和pivot的时候是否需要动态调整sizeDelta和anchoredPosition来保持该节点的矩形区域不变。选中时代表不动态调整。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  localPosition就是tranform所确定的坐标系原点在父tranform所确定的坐标系下的位置。在RectTransform中，自身所确定的坐标系原点位置在RectTransform确定的矩形的中心。&lt;br/&gt;  所以在RectTranform下，localPosition也可以理解为自身矩形与父节点确定的矩形中心的相对位置（偏移量）。&lt;/p&gt;

&lt;p&gt;  先建立以父节点左下角为原点的坐标系o。&lt;br/&gt;  定义：&lt;br/&gt;  childPivotPos代表子节点中心点在o中的坐标。&lt;br/&gt;  parentPivotPos代表父节点中心点在o中的坐标。&lt;br/&gt;  anchorsPivotPos代表子节点anchors确定的矩形的中心点在o中的坐标。&lt;br/&gt;  则有：&lt;br/&gt;  localPosition.xy&lt;br/&gt;  = childPivotPos - parentPivotPos&lt;br/&gt;  = (childPivotPos - anchorsPivotPos) + (anchorsPivotPos - parentPivotPos)&lt;br/&gt;  = anchoredPosition + (anchorsPivotPos - parentPivotPos)&lt;br/&gt;  = anchoredPosition + anchorsPivotPos相对于父节点中心的偏移量&lt;br/&gt;  接下来就可以实际上进行计算了。&lt;br/&gt;  定义：&lt;br/&gt;  pSize代表父节点的长宽（除了根Canvas外，其他所有的RectTransform所确定的矩形都是依赖于父节点的。所以我们跳过父节点矩形的计算，直接用rect属性获取父节点长宽）。&lt;br/&gt;  pPivot代表父节点的pivot。&lt;br/&gt;  cAnchorsMin、cAnchorsMax、cPivot代表子节点的anchorsMin、anchorsMax、pivot。&lt;br/&gt;  则有：&lt;br/&gt;  parentPivotPos = Vector2.Scale(pSize, pPivot)&lt;br/&gt;  anchorsPivotPos = Vector2.Scale(pSize, cAnchorsMin) + Vector.Scale(pSize, (cAnchorsMax - cAnchorsMin) * cPivot)&lt;br/&gt;  anchorsPivotPos - parentPivotPos = Vector2.Scale(pSize,cAnchorsMin + (cAnchorsMax - cAnchorsMin) * cPivot - pPivot)&lt;br/&gt;  简单测一下，随便调调父节点和子节点的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class PositionTest : MonoBehaviour
{
    public Vector3 localPosition;
    public Vector2 anchoredPosition;
    public Vector3 delta;
    public Vector3 calculation;

    // Update is called once per frame
    void Update()
    {
        var parentRectTrans = (transform.parent as RectTransform);
        var rectTrans = transform as RectTransform;
        localPosition = rectTrans.localPosition;
        anchoredPosition = rectTrans.anchoredPosition;
        //差值
        delta = (Vector2)localPosition - anchoredPosition;
        //通过公式计算的插值
        calculation = Vector2.Scale(
            parentRectTrans.rect.size,
            rectTrans.anchorMin + (rectTrans.anchorMax - rectTrans.anchorMin) * rectTrans.pivot - parentRectTrans.pivot
        );
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202009/1362861-20200927020247680-1872986471.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Sep 2020 18:05:00 +0000</pubDate>
<dc:creator>blueberryzzz</dc:creator>
<og:description>UGUI简述 UGUI主要提供了两个能力 UI元素的渲染与适配（其中UI元素的Mesh中的position信息就是通过RectTransform生成的，本文重点） 设备事件的响应与处理（EventSy</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blueberryzzz/p/13737501.html</dc:identifier>
</item>
<item>
<title>告别硬编码，让你的前端表格自动计算 - 冯海涛</title>
<link>http://www.cnblogs.com/fenghaitao/p/autocalculate-user-manual.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fenghaitao/p/autocalculate-user-manual.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/feng-haitao/auto-calculate&quot;&gt;GitHub&lt;/a&gt; | &lt;a href=&quot;http://autocal.fenghaitao.net&quot;&gt;Demo&lt;/a&gt; | &lt;a href=&quot;http://www.fenghaitao.net&quot;&gt;博客&lt;/a&gt; | &lt;a href=&quot;https://www.jianshu.com/p/b0f350b1a4de&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;当我的团队进行税务系统模块开发的时候，我发现他们需要花费80%的时间去解决计算问题，尤其体现在表格（Grid）中的计算，这些时间花在：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写前台js代码（因为用户在表格中的输入会影响其他单元格，所以需要即时将运算后的新值呈现给用户看）&lt;/li&gt;
&lt;li&gt;写后台代码（因为用户对表格数据的更改会影响其他表格，所以要在用户点击保存时更新受影响表格的数据）&lt;/li&gt;
&lt;li&gt;实施修改计算方法，导致开发者需要修改代码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;于是我调研了税务其他模块的功能，发现税务系统大量使用表格控件，而其中或多或少都会涉及到计算问题。而处理计算的方法，都是采用硬编码。&lt;/p&gt;
&lt;p&gt;计算，这个习以为常的编码动作，其实很容易让人联想到Excel中的公式，更何况需求文档本身就是以Excel的形式提供的。当我们在使用Excel的时候，可以在单元格中设置公式，通过改变源头单元格的值，Excel将自动计算单元格公式，将结果值赋予目标单元格。那么，我们是否可以参考这种模式，开发者不再需要写复杂难懂的计算逻辑，只需要根据实施提供的公式，将它们转成某种格式的语句，再调用某种计算引擎产出结果，将结果呈现给用户看或者持久化到数据库？答案是肯定的，而这一切的核心就是自动计算引擎——&lt;strong&gt;AutoCalculate&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;作用&quot;&gt;作用&lt;/h2&gt;
&lt;p&gt;AutoCalculate是表格复杂运算的解决方案，可以让你省掉成百上千行的计算逻辑代码，从此写代码就像写Excel公式一般简单。&lt;/p&gt;
&lt;h2 id=&quot;适用范围&quot;&gt;适用范围&lt;/h2&gt;
&lt;p&gt;前台：&lt;/p&gt;
&lt;p&gt;适用于ElementUI表格、EasyUI Grid控件、ParamQuery Grid等所有js表格控件中带有公式的复杂运算&lt;/p&gt;
&lt;p&gt;后台：&lt;/p&gt;
&lt;p&gt;适用，需要V8引擎&lt;/p&gt;
&lt;h2 id=&quot;前台用法&quot;&gt;前台用法&lt;/h2&gt;
&lt;p&gt;AutoCalculate由两部分组成，分别是公式和计算引擎，公式是就是根据特定语法编写的字符串，如：[Month12,1]#3 = [Month11,1] * 10，计算引擎即是AutoCalculate.js，负责解析公式。以下开始介绍如何书写公式。&lt;/p&gt;
&lt;h3 id=&quot;单元格&quot;&gt;单元格&lt;/h3&gt;
&lt;p&gt;假设有这样的场景，单元格①=单元格②+单元格③，对应的公式是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Month1,1] = [Month1,2] + [Month1,3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_1.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先来看看&lt;code&gt;[Month1,1]&lt;/code&gt;代表什么，首先，中括号&lt;code&gt;[ ]&lt;/code&gt;代表一个单元格，Month1即“1月”对应的列名，紧接着是一个逗号&lt;code&gt;,&lt;/code&gt;，后面的1代表RowNo = 1，以此类推，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[Month1,2]&lt;/code&gt;代表列为“1月”且RowNo = 2的单元格&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[Month1,3]&lt;/code&gt;代表列为“1月”且RowNo = 3的单元格&lt;/p&gt;
&lt;p&gt;所以我们可以用&lt;code&gt;[y,x]&lt;/code&gt;来代表一个单元格，y即列名，也称作纵坐标， x即RowNo的值，也称作横坐标&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;如果表格没有RowNo列怎么办？如想寻找答案，请继续往下阅读&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;让公式生效&quot;&gt;让公式生效&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;//首先引入AutoCalculate.js
import AutoCalculate from '../components/AutoCalculate';
...

//定义一个AutoCalculate实例，formulas为公式数组
let autoCal = new AutoCalculate(formulas);

/* 调用cal方法
 * gridDatas（必填）：表格数据
 * refField（必填）：参考字段，即单元格[y,x]中x是哪个字段的值
 */
autoCal.cal(gridDatas, refField);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;区域公式&quot;&gt;区域公式&lt;/h3&gt;
&lt;p&gt;实际上，除了1月，2月，3月……10月也存在类似的公式，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Month1,1] = [Month1,2] + [Month1,3]

[Month2,1] = [Month2,2] + [Month2,3]

[Month3,1] = [Month3,2] + [Month3,3]

……
……
……

[Month10,1] = [Month10,2] + [Month10,3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说我们需要写10条这样的公式，对于简单的场景来说，这不成问题，但是对于某些包含大量公式的表格，这种写法存在一些弊端，比如容易写错，还有，公式长的时候也需要花费较多时间才能写完。所以，便有了区域公式。&lt;/p&gt;
&lt;p&gt;观察上面的公式可以发现，其实每条公式都可以用一条公式来代替，例如以下公式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[@,1] = [@,2] + [@,3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里没有明确的列名，只是用了一个占位符@，但它足以代表以上10条公式。这个时候，我们只需要在适当的位置补上列名就可以了，所以，最终的公式就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{Month1, Month2, Month3, Month4, Month5, Month6, Month7, Month8, Month9, Month10}[@,1] = [@,2] + [@,3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你需要将列名用&lt;code&gt;,&lt;/code&gt;隔开，并放置在大括号&lt;code&gt;{ }&lt;/code&gt;内，如此，1条公式便相当于10条公式。&lt;/p&gt;
&lt;p&gt;占位符不仅仅可以用于纵坐标，还可用于横坐标，如以下公式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;//公式1：
[YearTotal,3] = [Month1,3] + [Month2,3] + [Month3,3] + [Month4,3] + [Month5,3] + [Month6,3] + [Month7,3] + [Month8,3] + [Month9,3] + [Month10,3]

//公式2：
[YearTotal,4] = [Month1,4] + [Month2,4] + [Month3,4] + [Month4,4] + [Month5,4] + [Month6,4] + [Month7,4] + [Month8,4] + [Month9,4] + [Month10,4]

//公式3：
[YearTotal,5] = [Month1,5] + [Month2,5] + [Month3,5] + [Month4,5] + [Month5,5] + [Month6,5] + [Month7,5] + [Month8,5] + [Month9,5] + [Month10,5]

//公式4：
[YearTotal,6] = [Month1,6] + [Month2,6] + [Month3,6] + [Month4,6] + [Month5,6] + [Month6,6] + [Month7,6] + [Month8,6] + [Month9,6] + [Month10,6]

//公式5：
[YearTotal,2] = [Month1,2] + [Month2,2] + [Month3,2] + [Month4,2] + [Month5,2] + [Month6,2] + [Month7,2] + [Month8,2] + [Month9,2] + [Month10,2]

//公式6：
[YearTotal,7] = [Month1,7] + [Month2,7] + [Month3,7] + [Month4,7] + [Month5,7] + [Month6,7] + [Month7,7] + [Month8,7] + [Month9,7] + [Month10,7]

//公式7：
[YearTotal,9] = [Month1,9] + [Month2,9] + [Month3,9] + [Month4,9] + [Month5,9] + [Month6,9] + [Month7,9] + [Month8,9] + [Month9,9] + [Month10,9]

//公式8：
[YearTotal,12] = [Month1,12] + [Month2,12] + [Month3,12] + [Month4,12] + [Month5,12] + [Month6,12] + [Month7,12] + [Month8,12] + [Month9,12] + [Month10,12]

//公式9：
[YearTotal,13] = [Month1,13] + [Month2,13] + [Month3,13] + [Month4,13] + [Month5,13] + [Month6,13] + [Month7,13] + [Month8,13] + [Month9,13] + [Month10,13]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用区域公式，可以写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{2, 3, 4, 5, 6, 7, 9, 12, 13}[YearTotal,@] = [Month1,@] + [Month2,@] + [Month3,@] + [Month4,@] + [Month5,@] + [Month6,@] + [Month7,@] + [Month8,@] + [Month9,@] + [Month10,@]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，区域公式为公式的书写带来了极大的便利。&lt;/p&gt;
&lt;h3 id=&quot;支持js语法&quot;&gt;支持js语法&lt;/h3&gt;
&lt;p&gt;在实际场景中，我们经常会碰到一些复杂的公式，如下图，单元格公式使用了Excel自带的Max函数，对于这样的公式，我们可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Month1,9] = ([Month1,6] - [Month1,7] - [Month1,8] &amp;gt; 0 ? [Month1,6] - [Month1,7] - [Month1,8] : 0) + [Month1,5]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_2.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如你所见，公式支持js语法，你可以在公式等号右边放入一个js变量，甚至js函数，只要是js解析引擎认识的语法，都被支持。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;这里有个需要注意的地方，就是不可以将数组元素放入公式中，因为js的数组元素通常带有“[ ]”符号，这与公式当中的单元格表示符”[ ]”产生冲突，所以数组元素被禁止使用，请留意这一点。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;y公式&quot;&gt;[y]公式&lt;/h3&gt;
&lt;p&gt;接下来，带大家看一看另外一种场景，如图，存在这样的关系：&lt;/p&gt;
&lt;p&gt;单元格① = 单元格② - 单元格③&lt;/p&gt;
&lt;p&gt;你可能很快就写出了以下公式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[column3,1] = [column2,1] - [column1,1]
[column3,2] = [column2,2] - [column1,2]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_3.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样写本身没有错，但是我得提醒你，这里的行是不固定的，也就是说表格有多少行完全取决于当时的数据库情况，有可能今天只有3行数据，明天会有5行，后天会有50行。我们不可能随着行数增多而增加公式，所以对于这种行数不确定的表格，我们有一种新的写法，我将它称为[y]公式，因为跟普通公式相比，它没有横坐标：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[column3] = [column2] - [column1]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要一行公式，AutoCalculate便会将公式应用于指定列名下的所有行。&lt;/p&gt;
&lt;h3 id=&quot;合计列与小数位数&quot;&gt;合计列与小数位数&lt;/h3&gt;
&lt;p&gt;有时候，我们需要求某一列的和，虽然求某一列的和可能不是我们的最终目的，但却是我们完成计算的必要步骤，如存在以下关系：&lt;/p&gt;
&lt;p&gt;单元格③ = 单元格① / 单元格②&lt;/p&gt;
&lt;p&gt;单元格②是&lt;code&gt;GroupApprovedTotal&lt;/code&gt;列的合计值，我们用&lt;code&gt;&amp;lt;列名&amp;gt;&lt;/code&gt;来表示，即：&lt;code&gt;&amp;lt;GroupApprovedTotal&amp;gt;&lt;/code&gt;。加上这里的行不固定，需要用到[y]公式，所以公式应该写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[GroupApprovedTotalPercent] = [GroupApprovedTotal] / &amp;lt;GroupApprovedTotal&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_4.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道，在除法中，除数是不可以为0的，所以正确的写法应该是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[GroupApprovedTotalPercent] = &amp;lt;GroupApprovedTotal&amp;gt; === 0 ? 0 : [GroupApprovedTotal] / &amp;lt;GroupApprovedTotal&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你将这条公式放你的代码，并启动程序后，聪明的你应该很快发现，你得到的值不够精确，如上面单元格③显示的数值是66.91%，如果你的单元格①和单元格②跟上图的数值相同，你的单元格③很可能是67%，这是为什么呢？&lt;/p&gt;
&lt;p&gt;默认的，AutoCalculate会将计算结果保留2位小数，67%，即0.67，如果想得到66.91%，即0.6691，那就是需要保留4位小数，这时，你需要告诉AutoCalculate，你需要保留4位小数，所以，完整的写法应该是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[GroupApprovedTotalPercent]#4 = &amp;lt;GroupApprovedTotal&amp;gt; === 0 ? 0 : [GroupApprovedTotal] / &amp;lt;GroupApprovedTotal&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在公式的等号左边，被赋值单元格的右边，加“#”号，紧跟着写上小数位数，注意，“#”和小数位数之间不能有空格，前后可以有空格。&lt;/p&gt;
&lt;h3 id=&quot;没有rowno的表格&quot;&gt;没有RowNo的表格&lt;/h3&gt;
&lt;p&gt;终于到了回答这个问题的时候，我想问问大家，我们是如何在一个平面找到一个点的？答案就是需要这个点的横坐标和纵坐标，同样的，在一个表中，如何找到一个单元格？首先我们可以确定纵坐标，因为所有的列名都是已知的，关键就在于横坐标的确定。采用RowNo来定位，大家一定会觉得似曾相识，因为它跟Excel左侧的序号很像，但不代表只有数字才能作为横坐标。只要值具有唯一性，即不重复，就可以作为横坐标。&lt;/p&gt;
&lt;p&gt;举个例子，假设以下的表格是固定两行，没有RowNo，但是可以看出公司编号（BuCode）具有唯一性，那么BuCode就可以作为参考字段，BuCode的值就是横坐标，那么公式就可以写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[SumDiffMonth1,F1136] = [GroupApprovalMonth1,F1136] - [Month1,F1136]
[SumDiffMonth1,F2056] = [GroupApprovalMonth1,F2056] - [Month1,F2056]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果有RowNo，用RowNo做参考字段时这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[SumDiffMonth1,2] = [GroupApprovalMonth1,2] - [Month1,2]
[SumDiffMonth1,3] = [GroupApprovalMonth1,3] - [Month1,3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_5.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;跨数据源计算&quot;&gt;跨数据源计算&lt;/h3&gt;
&lt;p&gt;何为跨数据源计算？用过Excel公式的朋友应该能看懂下面这个单元格的公式代表的意思。很明显这个单元格的值是其他Sheet的数据经过运算后的值，跨数据源计算就是专门处理这样的场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_6.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们很少甚至不会在前台做跨数据源计算，这里是想告诉大家如何书写公式及调用AutoCalculate的方法，以便在“后台用法”这一章节真正使用到它。&lt;/p&gt;
&lt;p&gt;首先，为了取得其他数据源单元格的数据，我们需要拓展一下单元格，之前，我们的单元格是这样的：[y,x]，暂且称为二元单元格吧，还有这样的单元格：[y]，成为一元单元格，现在，你会看到这样的单元格：[外部数据源,y,x]，即三元单元格，三元单元格的出现令到AutoCalculate定位单元格的能力从二维拓展到三维，即不管你有多少表，AutoCalculate都能找到你要的数据。&lt;/p&gt;
&lt;p&gt;这是一条使用了三元单元格的公式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Month1,4] = [OutputTax,Month1,7] 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中OutputTax是某个数据源的名称，你可以任意取名，越简洁越好，否则复杂的公式会被写得很长，难以阅读。&lt;/p&gt;
&lt;p&gt;下面这条公式会从两个数据源OutputTax和TaxRate取值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Month1,5] = [OutputTax,Month1,10] * (1 + [TaxRate,Month1,1] / 100)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我相信通过阅读前面章节的内容，你已经能够看懂下面公式的意思，其中前三行公式使用了外部数据源，并结合了区域公式的写法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_7.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是时候调用我们的计算方法了，为了演示效果，我添加了一个按钮，并将方法写在按钮事件中&lt;/p&gt;
&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_8.png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;看看我们做了什么：&lt;/p&gt;
&lt;p&gt;① 取得某个外部数据源outputTaxDatas&lt;/p&gt;
&lt;p&gt;② 取得当前表格的数据源payableTaxDatas&lt;/p&gt;
&lt;p&gt;③ 从数据库获取另一个外部数据源taxRateDatas&lt;/p&gt;
&lt;p&gt;④ 这里是重点，先来看看AutoCalculate 的构造函数，这里有两个参数：&lt;/p&gt;
&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_9.png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;formulas：公式，一个数组&lt;/p&gt;
&lt;p&gt;options：可选参数，一个object对象&lt;/p&gt;
&lt;p&gt;options有个属性externalDatas，表示外部数据源，是一个数组，因为数据可能有多个，每个数组元素都是一个对象，有3个属性：&lt;/p&gt;
&lt;p&gt;name：外部数据源名称，这里取什么名称，对应公式中的外部数据源名称&lt;/p&gt;
&lt;p&gt;refField：参考字段&lt;/p&gt;
&lt;p&gt;datas：数据源&lt;/p&gt;
&lt;p&gt;实例化AutoCalculate后，这里调用了一个新的方法calculate，它有2个参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_10.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;gridDatas：需要重新计算的表格数据，是一个数组&lt;/p&gt;
&lt;p&gt;refField：参考字段&lt;/p&gt;
&lt;p&gt;AutoCalculate之所有支持所有的js表格控件以及能被后台调用，就是借助于这个方法，因为不论是哪种js表格控件，都能够提取出表格数据（纯数据），数据通常是数组形式，只要将这个数组传进来就可以了。&lt;/p&gt;
&lt;p&gt;⑤ 调用calculate后，payableTaxDatas的值已经是运算过的最新值，现在将它绑定到当前的表格即可。&lt;/p&gt;
&lt;p&gt;运行程序后的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_11.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击获取数据后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_12.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;后台用法&quot;&gt;后台用法&lt;/h2&gt;
&lt;p&gt;后台调用AutoCalculate，我们需要用到V8引擎，还有一点很重要，后台调用AutoCalculate也需要用到公式，我们之前的做法是将所有公式放在Extjs的Controller文件中，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_13.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了方便后台调用，我们将公式提取出来作为一个单独的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_14.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目中对AutoCalculate后台调用进行了封装，使用非常简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_15.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用方法如图：&lt;/p&gt;
&lt;img src=&quot;http://www.fenghaitao.net/wp-content/uploads/2020/07/AutoCalculate_16.png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;还是分步解析：&lt;/p&gt;
&lt;p&gt;① 保存当前表格的数据&lt;/p&gt;
&lt;p&gt;② 获取公式所在js文件的目录&lt;/p&gt;
&lt;p&gt;③ 获取两个外部数据源&lt;/p&gt;
&lt;p&gt;④ 调用封装后的后台方法，使用了第②步和第③步获取的数据，其中FormulaExpression是公式表达式，即通过这个表达是来找到你提供的js文件中的公式&lt;/p&gt;
&lt;p&gt;⑤ 上一步返回的newDatas已经是经过运算的最新数据，现在将这些数据保存到数据库&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;书写公式时有两点需要注意：&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;单元格中不允许出现空格&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;//正确写法：
[Month12,1] = [Month11,1] * 10

//错误写法：
[Month12,1 ] = [ Month11, 1] * 10
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;小数位数标记与小数位数之前不能有空格&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;//正确写法：
[Month12,1] #3 = [Month11,1] * 10

//错误写法：
[Month12,1] # 3 = [Month11,1] * 10
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 26 Sep 2020 17:54:00 +0000</pubDate>
<dc:creator>冯海涛</dc:creator>
<og:description>GitHub | Demo | 博客 | 原文链接 序言 当我的团队进行税务系统模块开发的时候，我发现他们需要花费80%的时间去解决计算问题，尤其体现在表格（Grid）中的计算，这些时间花在： 写前台</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fenghaitao/p/autocalculate-user-manual.html</dc:identifier>
</item>
<item>
<title>Elasticsearch数据库 | Elasticsearch-7.5.0应用基础实战 - PivotalCloud</title>
<link>http://www.cnblogs.com/mazhilin/p/13737482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhilin/p/13737482.html</guid>
<description>&lt;blockquote readability=&quot;5.0551181102362&quot;&gt;
&lt;p&gt;Elasticsearch 是一个可用于分布式以及符合RESTful 风格的搜索和数据分析引擎。—— &lt;a href=&quot;https://www.elastic.co/cn/elasticsearch/&quot;&gt;Elastic Stack 官网&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;关于elasticsearch的爱恨情仇&quot;&gt;关于Elasticsearch的爱恨情仇&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;或许提起搜索服务器,大部分人都会想起Solr 和 Elasticsearch&lt;br/&gt;甚至以及国产大厂自研等。随着人工智能和大数据时代的到来，甚至还带动了一系列的机器引擎的出现，譬如Splunk等。其中Solr 和&lt;br/&gt;Elasticsearch是基于Lucene的搜索服务器。一般Solr是面向的是全文检索引擎，而Elasticsearch是用于全文搜索、结构化搜索、分析。而对于Splunk机器数据的引擎，可收集、索引和利用所有应用程序、服务器和设备生成的快速移动型计算机数据。可是不论技术如何发展和更替，作为一位程序员，我们要做的不就是即时地维护技术储备知识库和实时更新自己的技术缓存，以及实现可扩展性的技术深度树的增长。&lt;/li&gt;
&lt;li&gt;关于Elasticsearch，记得当时接触到Elasticsearch的名词的时候，那是2017年的夏天。当时的工作任务是实现一个关于知识库的系统。当时小伙伴们技术选型主要还是偏向Solr+Lucene来的做，有的甚至说直接使用Mysql数据库的自带函数来做。我是在无意中，在网上查询搜索引擎的技术实战的时候,看见了一篇对于Elasticsearch应用实战的应用报告分析，才去查询了Elasticsearch的相关资料。不过，当时网上大部分对于搜索功能的Demo，大部分还是关于Solr&lt;br/&gt;的比较多。也许在那个时候，大部分的技术概念基本都是偏向于技术长期稳定和文档资料全，使用程度相对较重的因素。但是，我个人却留了一个心眼，自己尝试去实战Elasticsearch。&lt;/li&gt;
&lt;li&gt;第一次，动手实操还是在Windows本机上安装(22G内存)的。其中，安装过程相比利用Tomcat+Solr来说，相对较复杂，而且对于本机的内存和功耗占用较重。个开发基本只能说是能运行起来，可稳定性方面，就有点显得望而却步的感觉。第二次，动手实战是在本机搭建了一个虚拟机去实战(2核8G)，可在网络通信方面，当时选的是网络桥接方式，也让我对此觉得很是麻烦。第三次，是自己拥有了自己的阿里云服务器，在上面按照传统部署方式(相对于Docker部署来说)，可无奈个人服务器内存较低(2核4G)，修改配置JVM等无法启动成功，总是抛出GC日志什么的问题，主要还是当时囊中羞涩的问题，甚至一旦运行Elasticsearch服务，其它的应用便无法启动和&lt;br/&gt;运行。后来，接触了Docker，于是，有了第四次的Elasticsearch实战（单节点部署）。第四次，升级了阿里云服务器的配置(2核8G)，最终实现了额自己的第一个Elasticsearch服务。甚至，为在后来工作中，动手实战Elasticsearch分布式集群服务奠定基础。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基本概述&quot;&gt;基本概述&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;似乎从某种意义来说Elasticsearch和MongoDB/Redis/Memcache一样，是一种Nosql数据库。是一个接近实时的搜索平台，从索引这个文档到这个文档能够被搜索到只有一个轻微的延迟，企业应用定位：采用Restful API标准的可扩展和高可用的实时数据分析的全文搜索工具。不过在当时，Elastic Stack只有Elasticsearch、Kibana 和 Logstash用例，还没有包含Beats等。而且在应用方面，除了来当作ELK分布式日志系统搭建外，更多的是Elasticsearch +Elasticsearch-Head插件在满足业务场景方面的需求，能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化等。&lt;/li&gt;
&lt;li&gt;基本特点：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;可拓展：支持一主多从且扩容简易，只要cluster.name一致且在同一个网络中就能自动加入当前集群；本身就是开源软件，也支持很多开源的第三方插件&lt;/li&gt;
&lt;li&gt;高可用：在一个集群的多个节点中进行分布式存储，索引支持shards和复制，即使部分节点down掉，也能自动进行数据恢复和主从切换&lt;/li&gt;
&lt;li&gt;采用RestfulAPI标准：通过http接口使用JSON格式进行操作数据&lt;/li&gt;
&lt;li&gt;数据存储的最小单位是文档，本质上是一个JSON 文本&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;elasticsearch关键词&quot;&gt;Elasticsearch关键词&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Node&lt;/strong&gt; : 节点，单个装有Elasticsearch服务并且提供故障转移和实现可扩展的服务器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cluster&lt;/strong&gt; : 集群，一个Elasticsearch-Cluster集群是有一个Node或者至少2个Node组成的服务器，共同服务和分享Node节点数据的具有负载均衡的功能，甚至基于Zookeeper集群的高可用服务等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Index&lt;/strong&gt; : 索引,具有相同或者相似特征的Document文档对象的集合&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type&lt;/strong&gt; : 类型，相同Filed字段的文档定义一个Type类型，一个Type可以创建多个Index索引&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Document&lt;/strong&gt; ：文档，一个Document文档可以被用作Index索引的基础信息单元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Field&lt;/strong&gt; : 字段列，Field是Elasticsearch的最小单元，相挡当于数据的某一列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shards&lt;/strong&gt; ：分片，Elasticsearch把Index索引分成若干份，每一个部分就是一个Shard分片&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replicas&lt;/strong&gt; ： 复制，每个Inex索引里每个Shard分片的拷贝或者说是数据备份&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;elasticsearch-结构与其它数据库对比&quot;&gt;Elasticsearch 结构与其它数据库对比&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;databaseType&lt;/th&gt;
&lt;th&gt;databaseName&lt;/th&gt;
&lt;th&gt;database&lt;/th&gt;
&lt;th&gt;databaseTable&lt;/th&gt;
&lt;th&gt;databaseRow&lt;/th&gt;
&lt;th&gt;databaseColumn&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;sql&lt;/td&gt;
&lt;td&gt;Mysql&lt;/td&gt;
&lt;td&gt;数据库-database&lt;/td&gt;
&lt;td&gt;表-table&lt;/td&gt;
&lt;td&gt;数据行-row&lt;/td&gt;
&lt;td&gt;数据列-column&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Nosql&lt;/td&gt;
&lt;td&gt;Elasticsearch&lt;/td&gt;
&lt;td&gt;索引-index&lt;/td&gt;
&lt;td&gt;类型-type&lt;/td&gt;
&lt;td&gt;文档-document&lt;/td&gt;
&lt;td&gt;字段列-field&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Nosql&lt;/td&gt;
&lt;td&gt;Hbase&lt;/td&gt;
&lt;td&gt;命名空间-namespace&lt;/td&gt;
&lt;td&gt;域/切片-region&lt;/td&gt;
&lt;td&gt;数据行-row&lt;/td&gt;
&lt;td&gt;数据列-column&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;版权声明：本文为博主原创文章，遵循相关版权协议，如若转载或者分享请附上原文出处链接和链接来源。&lt;/p&gt;
</description>
<pubDate>Sat, 26 Sep 2020 17:19:00 +0000</pubDate>
<dc:creator>PivotalCloud</dc:creator>
<og:description>Elasticsearch 是一个可用于分布式以及符合RESTful 风格的搜索和数据分析引擎。—— Elastic Stack 官网 关于Elasticsearch的爱恨情仇 或许提起搜索服务器,大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhilin/p/13737482.html</dc:identifier>
</item>
<item>
<title>go练手：简单的单词格式转换工具 - 大鹏SP</title>
<link>http://www.cnblogs.com/sunpong/p/13737297.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunpong/p/13737297.html</guid>
<description>&lt;h3 id=&quot;声明&quot;&gt;声明&lt;/h3&gt;
&lt;p&gt;​ 代码引自书籍 《Go语言编程之旅：一起用Go做项目》 作者：陈剑煜 徐新华&lt;/p&gt;
&lt;p&gt;​ 部分代码实现上做了调整，达到了自己想要的效果。&lt;/p&gt;
&lt;h3 id=&quot;功能描述&quot;&gt;功能描述&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;支持5种单词格式转换， 模式如下:
1: 全部单词转大写
2: 全部单词转小写
3: 下划线转大写驼峰
4: 下划线转小写驼峰
5: 驼峰转下划线

举例:
TimeForFun  使用模式1  转换为  TIMEFORFUN
              使用模式2  转换为  timeforfun

time_for_fun 使用模式3  转换为  TimeForFun
             使用模式4  转换为  timeForFun
             
TimeForFun   使用模式5  转换为  time_for_fun
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;目录结构及代码和简要说明&quot;&gt;目录结构及代码和简要说明&lt;/h3&gt;
&lt;h4 id=&quot;目录&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;tour
&lt;ul&gt;&lt;li&gt;cmd
&lt;ul&gt;&lt;li&gt;root.go&lt;/li&gt;
&lt;li&gt;word.go&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;internal
&lt;/li&gt;
&lt;li&gt;go.mod&lt;/li&gt;
&lt;li&gt;main.go&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;代码及说明&quot;&gt;代码及说明&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;main.go&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;package main

import (
        &quot;log&quot;
        &quot;tour/cmd&quot;
)

func main() {
        err := cmd.Execute()
        if err != nil {
                log.Fatalf(&quot;cmd.Execute err: %v&quot;, err)
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;go.mod&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;module tour

go 1.14

require (
    github.com/spf13/cobra v1.0.0
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;cmd - root.go&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加 wordcmd, 也就是cmd - word.go 中声明的wordCmd&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;package cmd

import (
        &quot;github.com/spf13/cobra&quot;
)


var rootCmd = &amp;amp;cobra.Command{}

func Execute() error {
        return rootCmd.Execute()
}

func init() {
        rootCmd.AddCommand(wordCmd)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;cmd - word.go&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用iota自增对各模式赋值，编写word子命令，使用switch进行模式选择，然后执行对应方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;package cmd

import (
        &quot;github.com/spf13/cobra&quot;
        &quot;log&quot;
        &quot;strings&quot;
        &quot;tour/internal/word&quot;
)

const (
        ModeUpper                      = iota + 1 //全部单词转大写
        ModeLower                                 //全部单词转小写
        ModeUnderscoreToUpperCamelCase            //下划线转大写驼峰
        ModeUnderscoreToLowerCamelCase            //下划线转小写驼峰
        ModeCamelCaseToUnderscore                 //驼峰转下划线
)

var str string
var mode int8

var desc = strings.Join([]string{
        &quot;该子命令支持各种单词格式转换， 模式如下:&quot;,
        &quot;1: 全部单词转大写&quot;,
        &quot;2: 全部单词转小写&quot;,
        &quot;3: 下划线转大写驼峰&quot;,
        &quot;4: 下划线转小写驼峰&quot;,
        &quot;5: 驼峰转下划线&quot;,
}, &quot;\r\n&quot;)


var wordCmd = &amp;amp;cobra.Command{
        Use:   &quot;word&quot;,
        Short: &quot;单词格式转换&quot;,
        Long:  desc,
        Run: func(cmd *cobra.Command, args []string) {
                var content string
                switch mode {
                case ModeUpper:
                        content = word.ToUpper(str)
                case ModeLower:
                        content = word.ToLower(str)
                case ModeUnderscoreToUpperCamelCase:
                        content = word.UderscoreToUpperCamelCase(str)
                case ModeUnderscoreToLowerCamelCase:
                        content = word.UderscoreToLowerCamelCase(str)
                case ModeCamelCaseToUnderscore:
                        content = word.CamelCaseToUdnderscore(str)
                default:
                        log.Fatalf(&quot;暂不支持该格式转换,请执行help word查看帮助文档&quot;)
                }
                log.Printf(&quot;转换结果: %s&quot;, content)
        },
}

func init() {
        wordCmd.Flags().StringVarP(&amp;amp;str, &quot;str&quot;, &quot;s&quot;, &quot;&quot;, &quot;请输入单词&quot;)
        wordCmd.Flags().Int8VarP(&amp;amp;mode, &quot;mode&quot;, &quot;m&quot;, 0, &quot;请输入转换模式&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;internal - word - word.go&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;全部转化为大写&lt;/p&gt;
&lt;p&gt;使用strings.ToUpper方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;全部转化为小写&lt;/p&gt;
&lt;p&gt;使用strings.ToLower方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;下划线单词转为大写驼峰单词&lt;/p&gt;
&lt;p&gt;把 '_' 替换为空，然后字符串调用strings.Title方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;下划线单词转为小写驼峰单词&lt;/p&gt;
&lt;p&gt;调用上面的方法那字符串转为大写驼峰，然后再调用unicode.ToLower转为小写驼峰，再用string方法转为字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;驼峰单词转下划线单词&lt;/p&gt;
&lt;p&gt;遍历字符串，先把第一个字符转为小写，然后遇到大写字母就在前面加个 '_' 然后再把大写字母转为小写，直至遍历完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;package word

import (
        &quot;strings&quot;
        &quot;unicode&quot;
)

//单词全部转化为大写
func ToUpper(s string) string {
        return strings.ToUpper(s)
}

//单词全部转化为小写
func ToLower(s string) string {
        return strings.ToLower(s)
}

//下划线单词转为大写驼峰单词
func UderscoreToUpperCamelCase(s string) string {
        s = strings.Replace(s, &quot;_&quot;, &quot; &quot;, -1)
        s = strings.Title(s)
        return strings.Replace(s, &quot; &quot;, &quot;&quot;, -1)
}

//下划线单词转为小写驼峰单词
func UderscoreToLowerCamelCase(s string) string {
        s = UderscoreToUpperCamelCase(s)
        return string(unicode.ToLower(rune(s[0]))) + s[1:]
        return s
}

//驼峰单词转下划线单词
func CamelCaseToUdnderscore(s string) string {
        var output []rune
        for i, r := range s {
                if i == 0 {
                        output = append(output, unicode.ToLower(r))
                } else {
                        if unicode.IsUpper(r) {
                                output = append(output, '_')
                        }

                        output = append(output, unicode.ToLower(r))
                }
        }
        return string(output)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;执行效果如下&quot;&gt;执行效果如下&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2144409/202009/2144409-20200926232958541-697489061.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2144409/202009/2144409-20200926233004764-774994903.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Sep 2020 15:31:00 +0000</pubDate>
<dc:creator>大鹏SP</dc:creator>
<og:description>声明 ​	代码引自书籍 《Go语言编程之旅：一起用Go做项目》 作者：陈剑煜 徐新华 ​	部分代码实现上做了调整，达到了自己想要的效果。 功能描述 支持5种单词格式转换， 模式如下: 1: 全部单词转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunpong/p/13737297.html</dc:identifier>
</item>
<item>
<title>曹工说面试题：一个线程协同问题，解法繁多，都要被玩坏了，趁着没坏，一起玩吧 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/13737109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/13737109.html</guid>
<description>&lt;p&gt;最近两个月写文章很少，因为自己学习状态也不是很好，我看了下，上一篇文章，都是一个月前了。&lt;/p&gt;
&lt;p&gt;不知道大家有没有感觉，小学初中读的一些书，看的一些文章，到现在都印象深刻，反倒是高中学的知识，高考后就慢慢消散，直到遗忘。&lt;/p&gt;
&lt;p&gt;我想说的是，记得初中学过鲁迅的《藤野先生》，里面有一段话，大意是：久了不联系，有时候想联系，却又无从下笔，到最后就更是不了了之了。&lt;/p&gt;
&lt;p&gt;我找了下原文：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;将走的前几天，他叫我到他家里去，交给我一张照相，后面写着两个字道：“惜别”，还说希望将我的也送他。但我这时适值没有照相了;他便叮嘱我将来照了寄给他，并且时时通信告诉他此后的状况。&lt;/p&gt;
&lt;p&gt;我离开仙台之后，就多年没有照过相，又因为状况也无聊，说起来无非使他失望，便连信也怕敢写了。经过的年月一多，话更无从说起，所以虽然有时想写信，却又难以下笔，这样的一直到现在，竟没有寄过一封信和一张照片。从他那一面看起来，是一去之后，杳无消息了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实写文章也是这样的，久了不写更不想写，但是心里又时时记着这么个事情，玩也不是很自在；今天先随便写一下，找下状态吧，因为现在文章可能在博客和公众号发，比如博客，一般来说会随意点，但是公众号的话，一般大家质量要求会高一些，结果就是，为了追求高质量，而非要找到一些很厉害的技术点，或者自己研究透了才动笔，这样会导致一些想法难产，因为可能觉得很简单，不值得发到公众号，实际上，很多时候都是浮于表面地觉得很简单，一旦深挖，立马就废。&lt;/p&gt;
&lt;p&gt;扯这么多，也是给我自己，或者其他刚开始写技术公众号的同学，也不用觉得非要写的多么多么好才发出来，本来大家都是一步一步来的，各种大佬也不是一下就变成大佬的，把自己的学习过程和成长过程发出来，大家也就知道：哦，大佬原来也这么菜啊，哈哈。&lt;/p&gt;
&lt;p&gt;比如最近看到一些算法大佬，一开始也是10道算法题，全部都要看答案的好么。。&lt;/p&gt;
&lt;p&gt;扯了不少，言归正传吧，最近在网上看到一个面试题目，感觉挺有意思的，大意如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202009/519126-20200926203742890-403133210.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ok，大家看到这个题，可以先理解下，这里启动了两个线程，a和b，但是虽然说a在b之前start，不一定就可以保证线程a的逻辑，可以先于线程b执行，所以，这里的意思是，线程a和b，执行顺序互不干扰，我们不应该假定其中一个线程可以先于另外一个执行。&lt;/p&gt;
&lt;p&gt;另外，既然是面试题，那常规做法自然是不用上了，比如让b先sleep几秒钟之类的，如果真这么答，那可能面试就结束了吧。&lt;/p&gt;
&lt;p&gt;ok，我们下面开始分析解法。&lt;/p&gt;

&lt;p&gt;程序里定义了一个全局变量，var = 1；线程a会修改这个变量为2，线程b则在变量为2时，执行自己的业务逻辑。&lt;/p&gt;
&lt;p&gt;那么，这里首先，我们要做的是，先讲var使用volatile修饰，保证多线程操作时的可见性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static volatile int var = 1;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;经过前面的可见性保证的分析，我们知道，要想达到目的，其实就是要保证：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a中的对var+1的操作，需要先于b执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，现在的问题是，两个线程同时启动，不知道谁先谁后，怎么保证a先执行，b后执行呢？&lt;/p&gt;
&lt;p&gt;让线程b先不执行，大概有两种思路，一种是阻塞该线程，一种是不阻塞该线程，阻塞的话，我们可以想想，怎么阻塞一个线程。&lt;/p&gt;
&lt;p&gt;大概有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;synchronized，取不到锁时，阻塞&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.ReentrantLock#lock，取不到锁时，阻塞&lt;/li&gt;
&lt;li&gt;object.wait，取到synchronized了，但是因为一些条件不满足，执行不下去，调用wait，将释放锁，并进入等待队列，线程暂停运行&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.Condition.await，和object.wait类似，只不过object.wait在jvm层面，使用c++实现，Condition.await在jdk层面使用java语言实现&lt;/li&gt;
&lt;li&gt;threadA.join()，等待对应的线程threadA执行完成后，本线程再继续运行；threadA没结束，则当前线程阻塞；&lt;/li&gt;
&lt;li&gt;CountDownLatch#await，在对应的state不为0时，阻塞&lt;/li&gt;
&lt;li&gt;Semaphore#acquire()，在state为0时（即剩余令牌为0时），阻塞&lt;/li&gt;
&lt;li&gt;其他阻塞队列、FutureTask等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果不让线程进入阻塞，则一般可以让线程进入一个while循环，循环的退出条件，可以由线程a来修改，线程a修改后，线程b跳出循环。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;volatile boolean stop = false;
while (!stop){
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面也说了这么多了，我们实际上手写一写吧。&lt;/p&gt;

&lt;p&gt;下面的思路是基于wait、notify；线程b直接wait，线程a在修改了变量后，进行notify。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Global1 {
    public static volatile int var = 1;
    public static final Object monitor = new Object();

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            // 1
            Global1.var++;
            // 2
            synchronized (monitor) {
                monitor.notify();
            }
        });
        Thread b = new Thread(() -&amp;gt; {
            // 3
            synchronized (monitor) {
                try {
                    monitor.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 4
            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        a.start();
        b.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家觉得这个代码能行吗？实际是不行的。因为实际的顺序可能是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;线程a--1

线程a--2

线程b--1

线程b--2

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在线程a-2时，线程a去notify，但是此时线程b还没开始wait，所以此时的notify是没有任何效果的：没人在等，notify个锤子。&lt;/p&gt;
&lt;p&gt;怎么修改，本方案才行得通呢？&lt;/p&gt;
&lt;p&gt;那就是，修改线程a的代码，不要急着notify，先等等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (monitor) {
                monitor.notify();
            }
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样的话，明显不合适，有作弊嫌疑，也不优雅。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class Global1 {
    public static volatile int var = 1;
    public static final ReentrantLock reentrantLock = new ReentrantLock();
    public static final Condition condition = reentrantLock.newCondition();

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
            final ReentrantLock lock = reentrantLock;
            lock.lock();
            try {
                condition.signal();
            } finally {
                lock.unlock();
            }
        });
        Thread b = new Thread(() -&amp;gt; {
            final ReentrantLock lock = reentrantLock;
            lock.lock();
            try {
                condition.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        a.start();
        b.start();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方案使用了Condition对象来实现object的notify、wait效果。当然，这个也有同样的问题。&lt;/p&gt;

&lt;p&gt;我们看看，前面问题的根源在于，我们线程a，在去通知线程b的时候，有可能线程b还没开始wait，所以此时通知失效。&lt;/p&gt;
&lt;p&gt;那么，我们是不是可以先等等，等线程b开始wait了，再去通知呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
            final ReentrantLock lock = reentrantLock;
            lock.lock();
            try {
                // 1
                while (!reentrantLock.hasWaiters(condition)) {
                    Thread.yield();
                }
                condition.signal();
            } finally {
                lock.unlock();
            }
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1处代码，就是这个思想，在signal之前，判断当前condition上是否有waiter线程，如果没有，就死循环；如果有，才去执行signal。&lt;/p&gt;
&lt;p&gt;这个方法实测是可行的。&lt;/p&gt;

&lt;p&gt;对正确解法1，换一个api，就变成了正确解法2.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Thread a = new Thread(() -&amp;gt; {
    Global1.var++;
    final ReentrantLock lock = reentrantLock;
    lock.lock();
    try {
        // 1
        while (reentrantLock.getWaitQueueLength(condition) == 0) {
            Thread.yield();
        }
        condition.signal();
    } finally {
        lock.unlock();
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1这里，获取condition上等待队列的长度，如果为0，说明没有等待者，则死循环。&lt;/p&gt;

&lt;p&gt;刚开始，我们初始化一个信号量，state为0. 线程b去获取信号量的时候，就会阻塞。&lt;/p&gt;
&lt;p&gt;然后我们线程a再去释放一个信号量，此时线程b就可以继续执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Global1 {
    public static volatile int var = 1;
    public static final Semaphore semaphore = new Semaphore(0);

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
            semaphore.release();
        });
        a.setName(&quot;thread a&quot;);
        Thread b = new Thread(() -&amp;gt; {
            try {
                semaphore.acquire();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        b.setName(&quot;thread b&quot;);
        a.start();
        b.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Global1 {
    public static volatile int var = 1;
    public static final CountDownLatch countDownLatch = new CountDownLatch(1);

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
            countDownLatch.countDown();
        });
        a.setName(&quot;thread a&quot;);
        Thread b = new Thread(() -&amp;gt; {
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        b.setName(&quot;thread b&quot;);
        a.start();
        b.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里使用了ArrayBlockingQueue，其他的阻塞队列也是可以的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import countdown.CountdownTest;


public class Global1 {
    public static volatile int var = 1;
    public static final ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&amp;lt;Object&amp;gt;(1);

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
            arrayBlockingQueue.offer(new Object());
        });
        a.setName(&quot;thread a&quot;);
        Thread b = new Thread(() -&amp;gt; {
            try {
                arrayBlockingQueue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        b.setName(&quot;thread b&quot;);
        a.start();
        b.start();
    }
}

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们也可以让线程b等待一个task的执行结果；而线程a在执行完修改var为2后，执行该任务，任务执行完成后，线程b就会被通知继续执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Global1 {
    public static volatile int var = 1;
    public static final FutureTask futureTask = new FutureTask&amp;lt;Object&amp;gt;(new Callable&amp;lt;Object&amp;gt;() {
        @Override
        public Object call() throws Exception {
            System.out.println(&quot;callable task &quot;);
            return null;
        }
    });

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
            futureTask.run();
        });
        a.setName(&quot;thread a&quot;);
        Thread b = new Thread(() -&amp;gt; {
            try {
                futureTask.get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        b.setName(&quot;thread b&quot;);
        a.start();
        b.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这个可能是最简洁直观的，哈哈。也是群里同学们提供的解法，真的有才！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Global1 {
    public static volatile int var = 1;

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
        });
        a.setName(&quot;thread a&quot;);
        Thread b = new Thread(() -&amp;gt; {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        b.setName(&quot;thread b&quot;);
        a.start();
        b.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这个和第6种类似。都是基于future。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Global1 {
    public static volatile int var = 1;
    public static final CompletableFuture&amp;lt;Object&amp;gt; completableFuture =
            new CompletableFuture&amp;lt;Object&amp;gt;();

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
            completableFuture.complete(new Object());
        });
        a.setName(&quot;thread a&quot;);
        Thread b = new Thread(() -&amp;gt; {
            try {
                completableFuture.get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        b.setName(&quot;thread b&quot;);
        a.start();
        b.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这种代码量也少，只要线程b在变量为1时，死循环就行了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Global1 {
    public static volatile int var = 1;

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
        });
        a.setName(&quot;thread a&quot;);
        Thread b = new Thread(() -&amp;gt; {
            while (var == 1) {
                Thread.yield();
            }

            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        b.setName(&quot;thread b&quot;);
        a.start();
        b.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;忙等待的方案很多，反正就是某个条件不满足时，不阻塞自己，阻塞了会释放cpu，我们就是不希望释放cpu的。&lt;/p&gt;
&lt;p&gt;比如像下面这样也可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Global1 {
    public static volatile int var = 1;
    public static final AtomicInteger atomicInteger =
            new AtomicInteger(1);

    public static void main(String[] args) {
        Thread a = new Thread(() -&amp;gt; {
            Global1.var++;
            atomicInteger.set(2);
        });
        a.setName(&quot;thread a&quot;);
        Thread b = new Thread(() -&amp;gt; {
            while (true) {
                boolean success = atomicInteger.compareAndSet(2, 1);
                if (success) {
                    break;
                } else {
                    Thread.yield();
                }
            }

            if (Global1.var == 2) {
                //do something;
                System.out.println(Thread.currentThread().getName() + &quot; good job&quot;);
            }
        });
        b.setName(&quot;thread b&quot;);
        a.start();
        b.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;暂时想了这么写，方案还是比较多的，大家可以开动脑筋，头脑风暴吧！我是逐日，混迹成都的老java程序猿，博客里有我更多的一些文章，大家可以看看，暂时没有迁移到公众号的打算。&lt;/p&gt;
</description>
<pubDate>Sat, 26 Sep 2020 14:37:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>前言 最近两个月写文章很少，因为自己学习状态也不是很好，我看了下，上一篇文章，都是一个月前了。 不知道大家有没有感觉，小学初中读的一些书，看的一些文章，到现在都印象深刻，反倒是高中学的知识，高考后就慢</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/13737109.html</dc:identifier>
</item>
<item>
<title>JUC 常用4大并发工具类 - 彼岸舞</title>
<link>http://www.cnblogs.com/flower-dance/p/13714006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flower-dance/p/13714006.html</guid>
<description>&lt;p&gt;&lt;span&gt;什么是JUC?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　JUC就是java.util.concurrent包,这个包俗称JUC,里面都是解决并发问题的一些东西&lt;/p&gt;
&lt;p&gt;　　该包的位置位于java下面的rt.jar包下面&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4大常用并发工具类:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CountDownLatch&lt;/p&gt;
&lt;p&gt;　　CyclicBarrier&lt;/p&gt;
&lt;p&gt;　　Semaphore&lt;/p&gt;
&lt;p&gt;　　ExChanger&lt;/p&gt;

&lt;p&gt;&lt;span&gt;CountDownLatch:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CountDownLatch,俗称闭锁,作用是类似加强版的Join,是让一组线程等待其他的线程完成工作以后才执行&lt;/p&gt;
&lt;p&gt;　　就比如在启动框架服务的时候,我们主线程需要在环境线程初始化完成之后才能启动,这时候我们就可以实现使用CountDownLatch来完成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; CountDownLatch} initialized with the given count.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; count the number of times {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #countDown} must be invoked
     *        before threads can pass through {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #await}
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException if {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; count} is negative
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CountDownLatch(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;lt; 0) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;count &amp;lt; 0&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sync = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sync(count);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在源码中可以看到,创建CountDownLatch时,需要传入一个int类型的参数,将决定在执行次扣减之后,等待的线程被唤醒&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202009/1979837-20200921101405587-1070697815.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 通过这个类图就可以知道其实CountDownLatch并没有多少东西&lt;/p&gt;
&lt;p&gt;　　方法介绍:&lt;/p&gt;
&lt;p&gt;　　　　CountDownLatch:初始化方法&lt;/p&gt;
&lt;p&gt;　　　　await:等待方法,同时带参数的是超时重载方法&lt;/p&gt;
&lt;p&gt;　　　　countDown:每执行一次,计数器减一,就是初始化传入的数字,也代表着一个线程完成了任务&lt;/p&gt;
&lt;p&gt;　　　　getCount:获取当前值&lt;/p&gt;
&lt;p&gt;　　　　toString:这个就不用说了&lt;/p&gt;
&lt;p&gt;　　里面的Sync是一个内部类,外面的方法其实都是操作这个内部类的,这个内部类继承了AQS,实现的标准方法,AQS将在后面的章节写&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202009/1979837-20200921103241194-475569344.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;主线程中创建CountDownLatch(3),然后主线程await阻塞,然后线程A,B,C各自完成了任务,调用了countDown,之后,每个线程调用一次计数器就会减一,初始是3,然后A线程调用后变成2,B线程调用后变成1,C线程调用后,变成0,这时就会唤醒正在await的主线程,然后主线程继续执行&lt;/p&gt;
&lt;p&gt;说一千道一万,不如代码写几行,上代码:&lt;/p&gt;
&lt;p&gt;休眠工具类,之后的代码都会用到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.tools;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 类说明：线程休眠辅助工具类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepTools {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 按秒休眠
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; seconds 秒数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; second(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; seconds) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            TimeUnit.SECONDS.sleep(seconds);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 按毫秒数休眠
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; seconds 毫秒数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ms(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; seconds) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            TimeUnit.MILLISECONDS.sleep(seconds);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day2.util;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dance.tools.SleepTools;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.CountDownLatch;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * CountDownLatch的使用,有五个线程,6个扣除点
 * 扣除完成后主线程和业务线程,才能执行工作
 *  扣除点一般都是大于等于需要初始化的线程的
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseCountDownLatch {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置为6个扣除点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(6&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 初始化线程
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InitThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

            System.out.println(&lt;/span&gt;&quot;thread_&quot; + Thread.currentThread().getId() + &quot; ready init work .....&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行扣减 扣减不代表结束&lt;/span&gt;
&lt;span&gt;            countDownLatch.countDown();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2; i++&lt;span&gt;) {
                System.out.println(&lt;/span&gt;&quot;thread_&quot; + Thread.currentThread().getId() + &quot;.....continue do its work&quot;&lt;span&gt;);
            }

        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 业务线程
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BusiThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 业务线程需要在等初始化完毕后才能执行&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                countDownLatch.await();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
                    System.out.println(&lt;/span&gt;&quot;BusiThread &quot; + Thread.currentThread().getId() + &quot; do business-----&quot;&lt;span&gt;);
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建单独的初始化线程&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                SleepTools.ms(&lt;/span&gt;1&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;thread_&quot; + Thread.currentThread().getId() + &quot; ready init work step 1st.....&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扣减一次&lt;/span&gt;
&lt;span&gt;                countDownLatch.countDown();
                System.out.println(&lt;/span&gt;&quot;begin stop 2nd.....&quot;&lt;span&gt;);
                SleepTools.ms(&lt;/span&gt;1&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;thread_&quot; + Thread.currentThread().getId() + &quot; ready init work step 2nd.....&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扣减一次&lt;/span&gt;
&lt;span&gt;                countDownLatch.countDown();

            }
        }.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动业务线程&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BusiThread()).start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动初始化线程&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;= 3; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InitThread()).start();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主线程进入等待&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            countDownLatch.await();
            System.out.println(&lt;/span&gt;&quot;Main do ites work.....&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;thread_13 ready init work .....
thread_13.....&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; its work
thread_13.....&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; its work
thread_14 ready init work .....
thread_14.....&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; its work
thread_14.....&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; its work
thread_15 ready init work .....
thread_15.....&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; its work
thread_11 ready init work step 1st.....
begin stop 2nd.....
thread_16 ready init work .....
thread_16.....&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; its work
thread_16.....&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; its work
thread_15.....&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; its work
thread_11 ready init work step 2nd.....
Main &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; ites work.....
BusiThread &lt;/span&gt;12 &lt;span&gt;do&lt;/span&gt; business-----&lt;span&gt;
BusiThread &lt;/span&gt;12 &lt;span&gt;do&lt;/span&gt; business-----&lt;span&gt;
BusiThread &lt;/span&gt;12 &lt;span&gt;do&lt;/span&gt; business-----
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过返回结果就可以很直接的看到业务线程是在初始化线程完全跑完之后,才开始执行的&lt;/p&gt;

&lt;p&gt;&lt;span&gt;CyclicBarrier:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CyclicBarrier,俗称栅栏锁,作用是让一组线程到达某个屏障,被阻塞,一直到组内的最后一个线程到达,然后屏障开放,接着,所有的线程继续运行&lt;/p&gt;
&lt;p&gt;　　这个感觉和CountDownLatch有点相似,但是其实是不一样的,所谓的差别,将在下面详解&lt;/p&gt;
&lt;p&gt;　　CyclicBarrier的构造参数有两个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a new {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; CyclicBarrier} that will trip when the
     * given number of parties (threads) are waiting upon it, and
     * does not perform a predefined action when the barrier is tripped.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parties the number of threads that must invoke {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #await}
     *        before the barrier is tripped
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException if {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; parties} is less than 1
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CyclicBarrier(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; parties) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(parties, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a new {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; CyclicBarrier} that will trip when the
     * given number of parties (threads) are waiting upon it, and which
     * will execute the given barrier action when the barrier is tripped,
     * performed by the last thread entering the barrier.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parties the number of threads that must invoke {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #await}
     *        before the barrier is tripped
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; barrierAction the command to execute when the barrier is
     *        tripped, or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} if there is no action
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException if {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; parties} is less than 1
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CyclicBarrier(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; parties, Runnable barrierAction) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parties &amp;lt;= 0) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parties =&lt;span&gt; parties;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; parties;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.barrierCommand =&lt;span&gt; barrierAction;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显能感觉出来,上面的构造参数调用了下面的构造参数,是一个构造方法重载&lt;/p&gt;
&lt;p&gt;首先这个第一个参数也树Int类型的,传入的是执行线程的个数,这个数量和CountDownLatch不一样,这个数量是需要和线程数量吻合的,CountDownLatch则不一样,CountDownLatch可以大于等于,而CyclicBarrier只能等于,然后是第二个参数,第二个参数是barrierAction,这个参数是当屏障开放后,执行的任务线程,如果当屏障开放后需要执行什么任务,可以写在这个线程中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202009/1979837-20200921120553716-1740188626.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;主线程创建CyclicBarrier(3,barrierAction),然后由线程开始执行,线程A,B执行完成后都调用了await,然后他们都在一个屏障前阻塞者,需要等待线程C也,执行完成,调用await之后,然后三个线程都达到屏障后,屏障开放,然后线程继续执行,并且barrierAction在屏障开放的一瞬间也开始执行&lt;/p&gt;
&lt;p&gt;上代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day2.util;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dance.tools.SleepTools;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.BrokenBarrierException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.CyclicBarrier;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * CyclicBarrier的使用
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseCyclicBarrier {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 存放子线程工作结果的安全容器
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Long&amp;gt; resultMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CyclicBarrier cyclicBarrier = &lt;span&gt;new&lt;/span&gt; CyclicBarrier(5,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CollectThread());

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 结果打印线程
     * 用来演示CyclicBarrier的第二个参数,barrierAction
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CollectThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

            StringBuffer result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, Long&amp;gt;&lt;span&gt; workResult : resultMap.entrySet()) {
                result.append(&lt;/span&gt;&quot;[&quot; + workResult.getValue() + &quot;]&quot;&lt;span&gt;);
            }

            System.out.println(&lt;/span&gt;&quot;the result = &quot; +&lt;span&gt; result);
            System.out.println(&lt;/span&gt;&quot;do other business.....&quot;&lt;span&gt;);

        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 工作子线程
     * 用于CyclicBarrier的一组线程
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SubThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程的ID&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; id =&lt;span&gt; Thread.currentThread().getId();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放入统计容器中&lt;/span&gt;
&lt;span&gt;            resultMap.put(String.valueOf(id), id);

            Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (random.nextBoolean()) {
                    Thread.sleep(&lt;/span&gt;1000 +&lt;span&gt; id);
                    System.out.println(&lt;/span&gt;&quot;Thread_&quot;+id+&quot;..... do something&quot;&lt;span&gt;);
                }
                System.out.println(id&lt;/span&gt;+&quot; is await&quot;&lt;span&gt;);
                cyclicBarrier.await();
                Thread.sleep(&lt;/span&gt;1000+&lt;span&gt;id);
                System.out.println(&lt;/span&gt;&quot;Thread_&quot;+id+&quot;.....do its business&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BrokenBarrierException e) {
                e.printStackTrace();
            }

        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;= 4; i++&lt;span&gt;) {
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubThread());
            thread.start();
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
11&lt;span&gt; is await
&lt;/span&gt;14&lt;span&gt; is await
&lt;/span&gt;15&lt;span&gt; is await
Thread_12..... &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; something
&lt;/span&gt;12&lt;span&gt; is await
Thread_13..... &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; something
&lt;/span&gt;13&lt;span&gt; is await
the result &lt;/span&gt;= [11][12][13][14][15&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; other business.....
Thread_11.....&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; its business
Thread_12.....&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; its business
Thread_13.....&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; its business
Thread_14.....&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; its business
Thread_15.....&lt;/span&gt;&lt;span&gt;do&lt;/span&gt; its business
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过返回结果可以看出前面的11 14 15三个线程没有进入if语句块,在执行到await的时候进入了等待,而另外12 13两个线程进入到了if语句块当中,多休眠了1秒多,然后当5个线程同时到达await的时候,屏障开放,执行了barrierAction线程,然后线程组继续执行&lt;/p&gt;
&lt;p&gt;解释一下CountDownLatch和CyclicBarrier的却别吧!&lt;/p&gt;
&lt;p&gt;首先就是CountDownLatch的构造参数传入的数量一般都是大于等于线程,数量的,因为他是有第三方控制的,可以扣减多次,然后就是CyclicBarrier的构造参数第一个参数传入的数量一定是等于线程的个数的,因为他是由一组线程自身控制的&lt;/p&gt;
&lt;p&gt;区别&lt;/p&gt;
&lt;p&gt;　　　　　　CountDownLatch　　CyclicBarrier&lt;/p&gt;
&lt;p&gt;控制　　       第三方控制　　　　   自身控制&lt;/p&gt;
&lt;p&gt;传入数量　　大于等于线程数量       等于线程数量&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Semaphore:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Semaphore,俗称信号量,作用于控制同时访问某个特定资源的线程数量,用在流量控制&lt;/p&gt;
&lt;p&gt;　　一说特定资源控制,那么第一时间就想到了数据库连接..&lt;/p&gt;
&lt;p&gt;　　之前用等待超时模式写了一个数据库连接池,打算用这个Semaphone也写一个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Semaphore} with the given number of
     * permits and nonfair fairness setting.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; permits the initial number of permits available.
     *        This value may be negative, in which case releases
     *        must occur before any acquires will be granted.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Semaphore(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; permits) {
        sync &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonfairSync(permits);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在源码中可以看到在构建Semaphore信号量的时候,需要传入许可证的数量,这个数量就是资源的最大允许的访问的线程数&lt;/p&gt;
&lt;p&gt;接下里用信号量实现一个数据库连接池&lt;/p&gt;
&lt;p&gt;连接对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day2.util.pool;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dance.tools.SleepTools;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.sql.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executor;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 数据库连接
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SqlConnection &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Connection {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取数据库连接
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Connection fetchConnection(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlConnection();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; commit() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        SleepTools.ms(&lt;/span&gt;70&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Statement createStatement() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        SleepTools.ms(&lt;/span&gt;1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PreparedStatement prepareStatement(String sql) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CallableStatement prepareCall(String sql) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String nativeSQL(String sql) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAutoCommit(&lt;span&gt;boolean&lt;/span&gt; autoCommit) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; getAutoCommit() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rollback() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; close() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isClosed() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DatabaseMetaData getMetaData() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setReadOnly(&lt;span&gt;boolean&lt;/span&gt; readOnly) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isReadOnly() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCatalog(String catalog) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String getCatalog() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTransactionIsolation(&lt;span&gt;int&lt;/span&gt; level) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getTransactionIsolation() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SQLWarning getWarnings() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clearWarnings() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Statement createStatement(&lt;span&gt;int&lt;/span&gt; resultSetType, &lt;span&gt;int&lt;/span&gt; resultSetConcurrency) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PreparedStatement prepareStatement(String sql, &lt;span&gt;int&lt;/span&gt; resultSetType, &lt;span&gt;int&lt;/span&gt; resultSetConcurrency) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CallableStatement prepareCall(String sql, &lt;span&gt;int&lt;/span&gt; resultSetType, &lt;span&gt;int&lt;/span&gt; resultSetConcurrency) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; getTypeMap() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTypeMap(Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; map) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setHoldability(&lt;span&gt;int&lt;/span&gt; holdability) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getHoldability() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Savepoint setSavepoint() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Savepoint setSavepoint(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rollback(Savepoint savepoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; releaseSavepoint(Savepoint savepoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Statement createStatement(&lt;span&gt;int&lt;/span&gt; resultSetType, &lt;span&gt;int&lt;/span&gt; resultSetConcurrency, &lt;span&gt;int&lt;/span&gt; resultSetHoldability) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PreparedStatement prepareStatement(String sql, &lt;span&gt;int&lt;/span&gt; resultSetType, &lt;span&gt;int&lt;/span&gt; resultSetConcurrency, &lt;span&gt;int&lt;/span&gt; resultSetHoldability) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CallableStatement prepareCall(String sql, &lt;span&gt;int&lt;/span&gt; resultSetType, &lt;span&gt;int&lt;/span&gt; resultSetConcurrency, &lt;span&gt;int&lt;/span&gt; resultSetHoldability) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PreparedStatement prepareStatement(String sql, &lt;span&gt;int&lt;/span&gt; autoGeneratedKeys) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PreparedStatement prepareStatement(String sql, &lt;span&gt;int&lt;/span&gt;[] columnIndexes) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PreparedStatement prepareStatement(String sql, String[] columnNames) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Clob createClob() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blob createBlob() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; NClob createNClob() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SQLXML createSQLXML() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isValid(&lt;span&gt;int&lt;/span&gt; timeout) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setClientInfo(String name, String value) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLClientInfoException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setClientInfo(Properties properties) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLClientInfoException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String getClientInfo(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Properties getClientInfo() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Array createArrayOf(String typeName, Object[] elements) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Struct createStruct(String typeName, Object[] attributes) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSchema(String schema) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String getSchema() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; abort(Executor executor) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNetworkTimeout(Executor executor, &lt;span&gt;int&lt;/span&gt; milliseconds) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getNetworkTimeout() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T unwrap(Class&amp;lt;T&amp;gt; iface) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isWrapperFor(Class&amp;lt;?&amp;gt; iface) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连接池对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day2.util.pool;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Semaphore;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用信号量控制数据库的链接和释放
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DBPoolSemaphore {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 池容量
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; POOL_SIZE = 10&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * useful 代表可用连接
     * useless 代表已用连接
     *  为什么要使用两个Semaphore呢?是因为,在连接池中不只有连接本身是资源,空位也是资源,也需要记录
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Semaphore useful, useless;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 连接池
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LinkedList&amp;lt;Connection&amp;gt; POOL = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用静态块初始化池
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; POOL_SIZE; i++&lt;span&gt;) {
            POOL.addLast(SqlConnection.fetchConnection());
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DBPoolSemaphore() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始可用的许可证等于池容量&lt;/span&gt;
        useful = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Semaphore(POOL_SIZE);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始不可用的许可证容量为0&lt;/span&gt;
        useless = &lt;span&gt;new&lt;/span&gt; Semaphore(0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取数据库连接
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 连接对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Connection takeConnection() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可用许可证减一&lt;/span&gt;
&lt;span&gt;        useful.acquire();
        Connection connection;
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (POOL) {
            connection &lt;/span&gt;=&lt;span&gt; POOL.removeFirst();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不可用许可证数量加一&lt;/span&gt;
&lt;span&gt;        useless.release();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connection;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 释放链接
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; connection 连接对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; returnConnection(Connection connection) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;!=&lt;span&gt;connection){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印日志&lt;/span&gt;
            System.out.println(&quot;当前有&quot;+useful.getQueueLength()+&quot;个线程等待获取连接,,&quot;
                    +&quot;可用连接有&quot;+useful.availablePermits()+&quot;个&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不可用许可证减一&lt;/span&gt;
&lt;span&gt;            useless.acquire();
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (POOL){
                POOL.addLast(connection);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可用许可证加一&lt;/span&gt;
&lt;span&gt;            useful.release();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day2.util.pool;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dance.tools.SleepTools;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试Semaphore
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseSemaphore {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 连接池
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; DBPoolSemaphore pool = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DBPoolSemaphore();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BusiThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机数工具类 为了让每个线程持有连接的时间不一样&lt;/span&gt;
            Random random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Connection connection &lt;/span&gt;=&lt;span&gt; pool.takeConnection();
                System.out.println(&lt;/span&gt;&quot;Thread_&quot;+Thread.currentThread().getId()+
                        &quot;_获取数据库连接耗时[&quot;+(System.currentTimeMillis()-start)+&quot;]ms.&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟使用连接查询数据&lt;/span&gt;
                SleepTools.ms(100+random.nextInt(100&lt;span&gt;));
                System.out.println(&lt;/span&gt;&quot;查询数据完成归还连接&quot;&lt;span&gt;);
                pool.returnConnection(connection);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 50; i++&lt;span&gt;) {
            BusiThread busiThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BusiThread();
            busiThread.start();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试返回结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
Thread_11_获取数据库连接耗时[0&lt;span&gt;]ms.
Thread_12_获取数据库连接耗时[&lt;/span&gt;0&lt;span&gt;]ms.
Thread_13_获取数据库连接耗时[&lt;/span&gt;0&lt;span&gt;]ms.
Thread_14_获取数据库连接耗时[&lt;/span&gt;0&lt;span&gt;]ms.
Thread_15_获取数据库连接耗时[&lt;/span&gt;0&lt;span&gt;]ms.
Thread_16_获取数据库连接耗时[&lt;/span&gt;0&lt;span&gt;]ms.
Thread_17_获取数据库连接耗时[&lt;/span&gt;0&lt;span&gt;]ms.
Thread_18_获取数据库连接耗时[&lt;/span&gt;0&lt;span&gt;]ms.
Thread_19_获取数据库连接耗时[&lt;/span&gt;0&lt;span&gt;]ms.
Thread_20_获取数据库连接耗时[&lt;/span&gt;0&lt;span&gt;]ms.
查询数据完成归还连接
当前有40个线程等待获取连接,,可用连接有0个
Thread_21_获取数据库连接耗时[&lt;/span&gt;112&lt;span&gt;]ms.
查询数据完成归还连接
...................&lt;br/&gt;&lt;/span&gt;&lt;span&gt;查询数据完成归还连接
当前有2个线程等待获取连接,,可用连接有0个
Thread_59_获取数据库连接耗时[&lt;/span&gt;637&lt;span&gt;]ms.
查询数据完成归还连接
当前有1个线程等待获取连接,,可用连接有0个
Thread_60_获取数据库连接耗时[&lt;/span&gt;660&lt;span&gt;]ms.
查询数据完成归还连接
当前有0个线程等待获取连接,,可用连接有0个
查询数据完成归还连接&lt;br/&gt;...................
当前有0个线程等待获取连接,,可用连接有8个
查询数据完成归还连接
当前有0个线程等待获取连接,,可用连接有9个&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过执行结果可以很明确的看到,一上来就有10个线程获取到了连接,,然后后面的40个线程进入阻塞,然后只有释放链接之后,等待的线程就会有一个拿到,然后越后面的线程等待的时间就越长,然后一直到所有的线程执行完毕&lt;/p&gt;
&lt;p&gt;最后打印的可用连接有九个不是因为少了一个是因为在释放之前打印的,不是错误&lt;/p&gt;
&lt;p&gt;从结果中可以看到,我们对连接池中的资源的到了控制,这就是信号量的流量控制&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Exchanger:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Exchanger,俗称交换器,用于在线程之间交换数据,但是比较受限,因为只能两个线程之间交换数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a new Exchanger.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exchanger() {
        participant &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Participant();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个构造函数没有什么好说的,也没有入参,只有在创建的时候指定一下需要交换的数据的泛型即可,下面看代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day2.util;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Exchanger;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 线程之间交换数据
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseExchange {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Exchanger&amp;lt;Set&amp;lt;String&amp;gt;&amp;gt; exchanger = &lt;span&gt;new&lt;/span&gt; Exchanger&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                Set&lt;/span&gt;&amp;lt;String&amp;gt; aSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
                aSet.add(&lt;/span&gt;&quot;A&quot;&lt;span&gt;);
                aSet.add(&lt;/span&gt;&quot;B&quot;&lt;span&gt;);
                aSet.add(&lt;/span&gt;&quot;C&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Set&lt;/span&gt;&amp;lt;String&amp;gt; exchange =&lt;span&gt; exchanger.exchange(aSet);
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String s : exchange) {
                        System.out.println(&lt;/span&gt;&quot;aSet&quot;+&lt;span&gt;s);
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }.start();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                Set&lt;/span&gt;&amp;lt;String&amp;gt; bSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
                bSet.add(&lt;/span&gt;&quot;1&quot;&lt;span&gt;);
                bSet.add(&lt;/span&gt;&quot;2&quot;&lt;span&gt;);
                bSet.add(&lt;/span&gt;&quot;3&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Set&lt;/span&gt;&amp;lt;String&amp;gt; exchange =&lt;span&gt; exchanger.exchange(bSet);
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String s : exchange) {
                        System.out.println(&lt;/span&gt;&quot;bSet&quot;+&lt;span&gt;s);
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }.start();

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bSetA
bSetB
bSetC
aSet1
aSet2
aSet3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过执行结果可以清晰的看到,两个线程中的数据发生了交换,这就是Exchanger的线程数据交换了&lt;/p&gt;
&lt;p&gt;以上就是JUC的4大常用并发工具类了&lt;/p&gt;
&lt;p&gt;作者：彼岸舞&lt;/p&gt;
&lt;p&gt;时间：2020\09\26&lt;/p&gt;
&lt;p&gt;内容关于：并发编程&lt;/p&gt;
&lt;p&gt;本文来源于网络，只做技术分享，一概不负任何责任&lt;/p&gt;

</description>
<pubDate>Sat, 26 Sep 2020 14:24:00 +0000</pubDate>
<dc:creator>彼岸舞</dc:creator>
<og:description>什么是JUC? JUC就是java.util.concurrent包,这个包俗称JUC,里面都是解决并发问题的一些东西 该包的位置位于java下面的rt.jar包下面 4大常用并发工具类: Count</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flower-dance/p/13714006.html</dc:identifier>
</item>
<item>
<title>手撸Mysql原生语句--多表 - AndreasZhou</title>
<link>http://www.cnblogs.com/stu-zhouqian/p/13736738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stu-zhouqian/p/13736738.html</guid>
<description>&lt;p&gt;在开始之前，我们需要建立表，做建表和数据的准备的工作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;1.建表
create table department(
        id int,
    name varchar(20)
);
create table employee(
        id int primary key auto_increment,
    name varchar(20),
    sex enmu('male','female') not null default = 'male',
    age int,
    dep_id int,
    constraint fk_id foreign key(dep_id) references department(id),
);

2.插入数据
insert into department values 
(200,'技术'),
(201,'人力资源'),
(202,'销售'),
(203,'运营');

insert into employee （name,sex,age,dep_id）values
('egon','male',18,200),
('alex','female',48,201),
('wupeiqi','male',38,201),
('yuanhao','female',28,202),
('liwenzhou','male',18,200),
('jingliyang','female',18,204);

# 查看表结构
desc department;
desc employee;

# 查看我们插入的数据
select * from department;
select * from employee;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多表的查询，我们主要是分为两种查询，这两种查询分别是多表连接查询和子查询两种情况。&lt;/p&gt;
&lt;h3 id=&quot;多表连接查询&quot;&gt;多表连接查询&lt;/h3&gt;
&lt;p&gt;1.交叉连接：不适用任何匹配条件。生成笛卡尔积。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;select * from employee,department;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.内连接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 找两张表共有部分，相当于利用笛卡儿积结果中筛选出正确的结果。
# department没有204这个部门，因而employee表中关于204这条员工信息没有匹配出来
select employee.id,employee.name,employee.age,employee.sex,department.name from employee inner join department on employee.dep_id=department.id;

上面的sql语句等价于下面的sql语句
select employee.id,employee.name,employee.age,employee.sex,department.name from employee,department where employee.dep_id=department.id;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.外连接之左连接：优先显示左表全部记录&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 以左表为标准，即找出所有员工信息，当然包括没有部门的员工
# 本质就是：在内连接的基础上增加左边有而右边没有的结果
select employee.id,employee.name,department.name as depart_name from employee letf join department on employee.dep_id=department.id;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.外连接之右连接：优先显示右表全部记录&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 以右表为标准，即找出所有部门信息，包括没有员工的部门
# 本质就是：在内连接的基础上增加右边有而左边没有的结果
select employee.id,employee.name,department.name as depart_name from employee right join department on empolyee.dep_id=department.id; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.全外连接：显示左右两个表全部的记录&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;select * from employee left join department on employee.dep_id = department.id
union
select * from employee right join department on employee.dep_id = department.id;
#注意 union与union all的区别：union会去掉相同的纪录
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.符合条件连接查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 实例1：以内连接的方式查询employee和department表，并且employee表中的age字段值必须大于25，即找出年龄大于25岁的员工以及员工所在的部门
select employee.name,department.name from employee inner join department on employee.dep_id=department.id where age &amp;gt; 25;
#示例2：以内连接的方式查询employee和department表，并且以age字段的升序方式显示
select employee.id,employee.name,employee.age,department.name from employee inner join department on employee.dep_id=department.id order by age asc;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;子查询&quot;&gt;子查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 1.子查询是将一个查询语句嵌套在另外一个查询语句中。
# 2.内层查询语句的查询结果，可以为外层查询语句提供查询条件。
#3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字
#4：还可以包含比较运算符：= 、 !=、&amp;gt; 、&amp;lt;等
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.带IN关键字的子查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#查询平均年龄在25岁以上的部门名
select id,name from department
    where id in 
        (select dep_id from employee group by dep_id having avg(age) &amp;gt; 25);
这两个sql语句是等价的。
 select department.name from employee inner join department on employee.dep_id=department.id where employee.age &amp;gt; (select avg(age) from employee group by dep_id);
#查看技术部员工姓名
select name from employee
    where dep_id in 
        (select id from department where name='技术');

#查看不足1人的部门名(子查询得到的是有人的部门id)
select name from department where id not in (select distinct dep_id from employee);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.带比较运算符的子查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#比较运算符：=、!=、&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、&amp;lt;&amp;gt;
#查询大于所有人平均年龄的员工名与年龄
mysql&amp;gt; select name,age from emp where age &amp;gt; (select avg(age) from emp);
+---------+------+
| name    | age  |
+---------+------+
| alex    | 48   |
| wupeiqi | 38   |
+---------+------+
2 rows in set (0.00 sec)


#查询大于部门内平均年龄的员工名、年龄
select t1.name,t1.age from emp t1
inner join 
(select dep_id,avg(age) avg_age from emp group by dep_id) t2
on t1.dep_id = t2.dep_id
where t1.age &amp;gt; t2.avg_age; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3 带EXISTS关键字的子查询&lt;/p&gt;
&lt;p&gt;EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。&lt;br/&gt;而是返回一个真假值。True或False&lt;br/&gt;当返回True时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#department表中存在dept_id=203，Ture
mysql&amp;gt; select * from employee
    -&amp;gt;     where exists
    -&amp;gt;         (select id from department where id=200);
+----+------------+--------+------+--------+
| id | name       | sex    | age  | dep_id |
+----+------------+--------+------+--------+
|  1 | egon       | male   |   18 |    200 |
|  2 | alex       | female |   48 |    201 |
|  3 | wupeiqi    | male   |   38 |    201 |
|  4 | yuanhao    | female |   28 |    202 |
|  5 | liwenzhou  | male   |   18 |    200 |
|  6 | jingliyang | female |   18 |    204 |
+----+------------+--------+------+--------+
#department表中存在dept_id=205，False
mysql&amp;gt; select * from employee
    -&amp;gt;     where exists
    -&amp;gt;         (select id from department where id=204);
Empty set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 26 Sep 2020 12:56:00 +0000</pubDate>
<dc:creator>AndreasZhou</dc:creator>
<og:description>在开始之前，我们需要建立表，做建表和数据的准备的工作。 1.建表 create table department( id int, name varchar(20) ); create table e</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stu-zhouqian/p/13736738.html</dc:identifier>
</item>
</channel>
</rss>