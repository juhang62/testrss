<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小白学 Python 爬虫（27）：自动化测试框架 Selenium 从入门到放弃（上） - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/12100183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/12100183.html</guid>
<description>[unable to retrieve full-text content]人生苦短，我用 Python 前文传送门： &quot;小白学 Python 爬虫（1）：开篇&quot; &quot;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&quot; &quot;小白学 Python 爬虫（3）：前置准备（二）Linux基础入门&quot; &quot;小白学 Python 爬虫（4）：前置准备（三）Docker基础入门&quot;</description>
<pubDate>Thu, 26 Dec 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<dc:identifier>http://www.cnblogs.com/babycomeon/p/12100183.html</dc:identifier>
</item>
<item>
<title>如何把单体式应用拆解成微服务？【下】 - IT老兵哥</title>
<link>http://www.cnblogs.com/itlaobingge/p/12100154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itlaobingge/p/12100154.html</guid>
<description>&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;&lt;strong&gt;热评博文：&lt;/strong&gt;&lt;/span&gt;《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12089657.html&quot;&gt;如何设计出优美的Web API？&lt;/a&gt;》，现阅读量超 2300，小伙伴们不要错过哦！&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;紧接昨天的上篇《&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12095774.html&quot;&gt;如何把单体式应用拆解成微服务？【上】&lt;/a&gt;》，今天我们一起来看看具体的拆解场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;场景1：数据库表外键引用关系&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果单体式应用中两个功能模块存在数据引用关系，那我们在拆解微服务时如何消除这种外键引用关系呢？首先，停⽌外键引⽤；然后，改成通过RESTful HTTP API⽅式获取原先外键关联的信息。如下图，改造前Payment数据库表中的记录通过外键引用Order，代码层面通常会借助对象关系映射（ORM）框架建立数据对象的关联，改造后代码层面就不能通过ORM框架做关联了。在Payment数据库表的记录中会保存Order的主键值，除此之外还会保存Order的关键属性信息，这样可以避免频繁的跨进程调用，从而可以提高系统的整体效率表现。&lt;/p&gt;
&lt;p&gt;下图是改造前的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q2zx8rp1q.bkt.clouddn.com/microservice-refactoring-04.jpeg&quot; alt=&quot;改造前&quot; width=&quot;558&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是改造后的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q2zx8rp1q.bkt.clouddn.com/microservice-refactoring-05.jpeg&quot; alt=&quot;改造后&quot; width=&quot;558&quot; height=&quot;347&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;场景2：共享静态数据关系&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果单体式应用中两个功能模块彼此共享静态数据，那我们在拆解微服务时如何消除这种共享关系呢？静态数据通常存储在数据库当中，例如：商品类目代号。如果这些静态数据需要更新，那我们就需要频繁地发布系统，这样会导致多个服务的中断。&lt;/p&gt;
&lt;p&gt;为了避免这个问题，我们也可以将这些静态数据拷贝多份，分别⽤于每个服务，但维护多份数据拷⻉的一致性是个问题。另外，我们也可以将这些静态数据存⼊每个服务的配置文件，降低更新数据的难度。统一配置中心，微服务架构中的必选组件，我们可以通过它来管理这些静态数据，这样在维护更新上会带来极大的便利。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;场景3：共享基础数据关系&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果单体式应用中两个功能模块共享某类基础数据，那我们在拆解微服务时如何消除这种共享关系呢？多个服务共享某类基础数据，例如：用户数据、物流公司数据等等，那我们要为这类数据提炼出专门的领域模型，将它封装成微服务，然后通过该服务来访问这些共享的基础数据。服务化带来的好处就是彼此之间仅仅依赖服务契约，双方具体采用什么技术和方案都是自由的。只要服务契约没有改变，那彼此的升级改造就不会影响。&lt;/p&gt;
&lt;p&gt;下图是改造前的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q2zx8rp1q.bkt.clouddn.com/microservice-refactoring-06.jpeg&quot; alt=&quot;改造前&quot; width=&quot;551&quot; height=&quot;335&quot;/&gt;&lt;br/&gt;下图是改造后的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q2zx8rp1q.bkt.clouddn.com/microservice-refactoring-07.jpeg&quot; alt=&quot;改造后&quot; width=&quot;561&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;场景4：共享数据库表格&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果单体式应用中两个功能模块共享一张数据表格，那我们在拆解微服务时如何消除这种共享关系呢？多个服务各自引⽤的数据被合并存储在一张数据库表当中，代码层面借助ORM框架实现多态，这种情况我们需要将每个服务所关注的数据剥离出来，分别存到不同的表格当中。&lt;/p&gt;
&lt;p&gt;下图是改造前的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q2zx8rp1q.bkt.clouddn.com/microservice-refactoring-08.jpeg&quot; alt=&quot;改造前&quot; width=&quot;559&quot; height=&quot;348&quot;/&gt;&lt;br/&gt;下图是改造后的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q2zx8rp1q.bkt.clouddn.com/microservice-refactoring-09.jpeg&quot; alt=&quot;改造后&quot; width=&quot;558&quot; height=&quot;355&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;场景4：共享数据库&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在拆解微服务过程中，我们该如何拆分数据库呢？最稳妥的方案就是分阶段重构数据库，数据是最宝贵的资源，我们不要贪图一步到位。&lt;/p&gt;
&lt;p&gt;下图是改造前的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q2zx8rp1q.bkt.clouddn.com/microservice-refactoring-10.jpeg&quot; alt=&quot;改造前&quot; width=&quot;561&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，按照业务上下文先将一个数据库拆解成两个数据库，但应用仍然是单体式应用，通过多数据源相关技术应用可以同时访问两个数据库，如下图所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://q2zx8rp1q.bkt.clouddn.com/microservice-refactoring-11.jpeg&quot; alt=&quot;第一步&quot; width=&quot;557&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第二步，将单体式应用拆解成微服务，每个微服务都有各自独立的数据库，如下图所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://q2zx8rp1q.bkt.clouddn.com/microservice-refactoring-12.jpeg&quot; alt=&quot;第二步&quot; width=&quot;551&quot; height=&quot;368&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;旧模块微服务改造优先级原则&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从单体式应用中划分出有界的上下文，作为剥离微服务的候选，然后开始依次重构每个功能模块。那如何判断哪些模块应该优先被剥离成微服务呢？从模块剥离难度看，我们可以遵循先易后难的原则，逐步积累重构经验，这适用于在微服务构建方面经验不太丰富的团队；从需求变化频率看，优先剥离那些变更频繁的模块，整体收益会更大一些，这对于人力资源较为紧张的团队不失为一个好的判断准则；从资源消耗类型看，那些计算或内存密集的模块适合优先剥离，这样有利于弹性伸缩时提升资源利用效率，这对系统规模较大的场景效果最明显；从服务边界粒度看，粒度越粗越好剥离。具体按哪个规则来安排微服务的改造顺序，这就要根据每个团队的具体情况来具体分析了。&lt;/p&gt;
&lt;p&gt;我们在支持不同系统实施微服务改造的过程中，上述优先级原则都被采用过，优先级存在的原因就是资源不够。微服务改造不是一蹴而就的事情，这个过程会持续很长时间，可能跨度几年，在不同阶段需要考虑的问题也就不同，最核心的原则就是按照适合自己的节奏有条不紊地开展工作，在确保线上业务稳定的前提下适当地追求速度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;微服务改造是否结束判断标准&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那什么时候才算完成微服务改造呢？判断标准就是旧系统中全部有界上下文都被剥离成微服务，此时反腐层就可以被废除了；或者遗留的单体式应用相对较稳定，不再发生变化，重构的投入产出比不再划算；或者遗留的单体式应用关联业务已经退出市场了，系统下线了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;微服务架构新挑战与解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当单体式应用被拆解成多个微服务之后，原先在一个事务边界内的操作现在要跨多个事务边界了，我们如何保证事务的一致性呢？下面是一些分布式事务机制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;再次尝试，最终一致：将每个操作步骤放⼊队列排队，后续再次尝试，确保最后执行成功，状态达成⼀致。&lt;/li&gt;
&lt;li&gt;撤销全部操作：补偿事务机制，原事务操作失败之后，启动一个新的事务去撤销之前的操作。如果补偿事务也失败了，那系统需要提供手动或自动再次运⾏补偿事务的功能。&lt;/li&gt;
&lt;li&gt;分布式事务：通过一个全局事务管理器来协调各个事务得以成功执行。对于短期事务，通常采用两阶段提交（Two-Phase Commit），第一阶段是投票阶段，分布式事务的参与者告诉事务管理器，判断本地事务是否可以顺利执行。如果事务管理器收集到所有投票结果都是YES，那就开始提交事务执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分布式事务机制本身不算太复杂，我们借鉴业界的一些开源产品自研了一套分布式事务框架，跟微服务框架结合起来，应用开发者只需要按照框架的约定实现特定的接口，通过一些注解就可以发起分布式事务，相关细节可以参考阿里的全局事务服务GTS。&lt;/p&gt;
&lt;p&gt;当单体式应用被拆解成多个微服务之后，原先集中存储的数据也被分开存储了，报表生成将会遇到新的挑战。在单体式应⽤情况下，通常有一个用于生成报表的从库，从主库同步数据，仅⽤于查询等读操作，避免⽣成报表过程影响主库的读写效率。在微服务情况下，我们将要通过服务调用来获取数据，设计适合报表统计的批量接口，以及增加缓存用于提升数据获取效率。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据抽取：通过服务调⽤来获取报表所需数据，这会造成非常⼤的负载，以及专⻔为报表设计的API。为了弥补上述不足，我们可以将数据抽取程序独立出来，专门从业务数据库中抽取数据到报表数据库。&lt;/li&gt;
&lt;li&gt;事件驱动数据抽取：基于事件驱动的微服务架构，我们可以开发特定事件的订阅者，负责将数据同步到报表数据库，这样可以解耦底层数据库系统。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;微服务改造是一个长期过程，这个过程会遇到各式各样的问题，方法论可以帮助我们更好地解决这些问题，并且降低风险。欢迎大家一起探讨微服务改造过程中遇到的任何问题！&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;今天先分享到这里，如果你觉得有价值，麻烦动动手指点下文 「&lt;span&gt; &lt;strong&gt;推荐&lt;/strong&gt; &lt;/span&gt;」按钮，让更多小伙伴可以看到，我也会更加有动力坚持分享。另外，老兵哥我后续还会分享职业规划、应聘面试、技能提升、影响力打造等经验，欢迎 &lt;strong&gt;&lt;span&gt;关注&lt;/span&gt; &lt;/strong&gt;本专栏或歪信公主号 「 &lt;strong&gt;&lt;span&gt;IT老兵哥&lt;/span&gt; 」&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;关注「 IT老兵哥 」，赋能程序人生！&quot; src=&quot;http://q2zx8rp1q.bkt.clouddn.com/itlaobingge-weixin-mp.jpeg&quot; alt=&quot;微信公众号「 IT老兵哥 」&quot; width=&quot;674&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关注「 &lt;span&gt;&lt;strong&gt;IT老兵哥&lt;/strong&gt;&lt;/span&gt; 」，赋能程序人生！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;软技能-热点文章：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11985486.html&quot;&gt;“花式”裁员套路深，你知道吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12037268.html&quot;&gt;遭遇裁员，如何渡过心理危机？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12083665.html&quot;&gt;如何在寒冬中找到好工作？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11928497.html&quot;&gt;2C 还是 2B，跟找工作有什么关系？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11928530.html&quot;&gt;大公司 vs 小公司，你会选哪个？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11928607.html&quot;&gt;记住这一点，不怕找不到好工作！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11928713.html&quot;&gt;跳槽，跳还是不跳，该怎么跳？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11928758.html&quot;&gt;程序员“求包养”攻略揭秘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11928879.html&quot;&gt;很努力了，为什么我还在原地踏步？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;硬技能-热点文章：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itlaobingge/p/12089657.html&quot; target=&quot;_blank&quot;&gt;如何设计出优美的Web API？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11928564.html&quot;&gt;程序员必须懂的架构入门课&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11947473.html&quot;&gt;从程序员到架构师，有捷径吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11962255.html&quot;&gt;图解 Spring：HTTP 请求的处理流程与机制【1】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11963286.html&quot;&gt;图解 Spring：HTTP 请求的处理流程与机制【2】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11963311.html&quot;&gt;图解 Spring：HTTP 请求的处理流程与机制【3】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11963351.html&quot;&gt;图解 Spring：HTTP 请求的处理流程与机制【4】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11963380.html&quot;&gt;图解 Spring：HTTP 请求的处理流程与机制【5】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11987672.html&quot;&gt;如何正确使用 Spring Cloud？【上】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11987713.html&quot;&gt;如何正确使用 Spring Cloud？【中】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/11987739.html&quot;&gt;如何正确使用 Spring Cloud？【下】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12005284.html&quot;&gt;Spring 核心技术与产品理念剖析【上】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12005510.html&quot;&gt;Spring 核心技术与产品理念剖析【下】&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 26 Dec 2019 00:32:00 +0000</pubDate>
<dc:creator>IT老兵哥</dc:creator>
<og:description>微服务改造是一个长期过程，这个过程会遇到各式各样的问题，方法论可以帮助我们更好地解决这些问题，并且降低风险。紧接昨天的上篇《如何把单体式应用拆解成微服务？【上】》，今天我们一起来看看具体的拆解场景。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itlaobingge/p/12100154.html</dc:identifier>
</item>
<item>
<title>关于C#异步编程你应该了解的几点建议 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/12099219.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/12099219.html</guid>
<description>[unable to retrieve full-text content]前段时间写了一篇关于C 异步编程入门的文章，你可以点击《 &quot;C 异步编程入门看这篇就够了&quot; 》查看。这篇文章我们来讨论下关于C 异步编程几个不成文的建议，希望对你写出高性能的异步编程代码有所帮助。注：本文的很多内容都是学习《Effective C 》的总结。 作者：依乐祝 原文地址：https://</description>
<pubDate>Thu, 26 Dec 2019 00:06:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/12099219.html</dc:identifier>
</item>
<item>
<title>Spring中如何使用工厂模式实现程序解耦？ - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/12093138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/12093138.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;
&lt;h2 id=&quot;啥是耦合解耦&quot;&gt;1、 啥是耦合、解耦？&lt;/h2&gt;
&lt;p&gt;既然是程序解耦，那我们必须要先知道啥是耦合，耦合简单来说就是程序的依赖关系，而依赖关系则主要包括&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1、 类之间的依赖&lt;br/&gt;2、 方法间的依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如下面这段代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  public class A{
        public int i;
    }

    public class B{
        public void put(A a){
            System.out.println(a.i);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这个例子中A类和B类之间存在一种强耦合关系，&lt;code&gt;B&lt;/code&gt;类直接依赖&lt;code&gt;A&lt;/code&gt;类，&lt;code&gt;B&lt;/code&gt;类的&lt;code&gt;put&lt;/code&gt;方法非&lt;code&gt;A&lt;/code&gt;类类型不可，我们把这种情况叫做强耦合关系。&lt;/p&gt;
&lt;p&gt;实际开发中应该做到：&lt;span&gt;&lt;strong&gt;编译期不依赖，运行时才依赖。&lt;/strong&gt;&lt;/span&gt;怎么理解呢？我们很容易想到&lt;span&gt;&lt;strong&gt;多态向上转型&lt;/strong&gt;&lt;/span&gt;，是的，编译时不确定，运行时才确定,当然接触面更广一点的童鞋会想到&lt;span&gt;&lt;strong&gt;接口回调&lt;/strong&gt;&lt;/span&gt;，是的接口回调方式也能有效的解耦！如下代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//一个接口叫做Inter，里面定义了一个happy（）方法，有两个类A、B实现了这个接口

interface Inter{
    void happy();
}

class A implements Inter{

    @Override
    public void happy() {
        System.out.println(&quot;happy...A&quot;);
    }
}

class B implements Inter{

    @Override
    public void happy() {
        System.out.println(&quot;happy...B&quot;);
    }
}

public class Test{
    public void happys(Inter inter){
        inter.happy();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是的，如上代码正是典型的接口回调，&lt;code&gt;Test&lt;/code&gt;类中的&lt;code&gt;happys&lt;/code&gt;方法参数变的相对灵活起来，代码中&lt;code&gt;Test类&lt;/code&gt;与&lt;code&gt;A类&lt;/code&gt;、&lt;code&gt;B类&lt;/code&gt;之间就存在一种弱耦合关系，&lt;code&gt;Test类&lt;/code&gt;的&lt;code&gt;happys&lt;/code&gt;方法的参数可以使&lt;code&gt;A类&lt;/code&gt;类型也可以是&lt;code&gt;B类&lt;/code&gt;类型，不像强耦合关系中非&lt;code&gt;A类&lt;/code&gt;类型不可的情形。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;从某一意义上来讲使用类的向上转型或接口回调的方式进行解耦都是利用多态的思想！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然解耦的方式还有很多，从根本意义上讲实现低耦合就是对两类之间进行解耦，解除类之间的直接关系，将直接关系转换成间接关系，从而也有很多设计模式也对程序进行解耦，比如：适配器模式、观察者模式、工厂模式....总之，必须明确一点：耦合性强的程序独立性很差！&lt;/p&gt;
&lt;h2 id=&quot;jdbc程序进行解耦&quot;&gt;2、 jdbc程序进行解耦&lt;/h2&gt;
&lt;p&gt;先来看一段代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//1、注册驱动
DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //如果把jdbc的MySQLjar包依赖去除直接编译失败提示没有mysql    
//2、获取连接
Connection conn=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/ufida&quot;,&quot;root&quot;,&quot;root&quot;);
//3、获取操作数据库的预处理对象
PreparedStatement pstm=conn.prepareStatement(&quot;select * from client&quot;);
//4、执行SQL，得到结果集
ResultSet rs=pstm.executeQuery();
//5\遍历结果集
while(rs.next()){
    System.out.println(rs.getString(&quot;name&quot;));
}
//6、释放资源
rs.close();
pstm.close();
conn.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等等等等，好熟悉好怀念的代码.....&lt;/p&gt;
&lt;p&gt;没错就是jdbc的代码，不是用来怀旧的，而是如果这样设计，你会觉得这样的程序耦合性如何？又如何进行解耦？先仔细思考一番。&lt;/p&gt;
&lt;p&gt;一分钟过去了.....&lt;br/&gt;两分钟过去了.....&lt;/p&gt;
&lt;p&gt;好了，我们都知道jdbc连接MySQL需要一个&lt;code&gt;mysql-connector&lt;/code&gt;的jar包，如果我们把这个jar包依赖或者这个jar包给去掉，显然上面的这个程序会编译报错，如下图&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224153407666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;显然这样的程序耦合性过高！于是我们可以这样设计，将第一步的注册驱动代码new的方式改成反射的方式如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; //1、new的方式注册驱动
DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //如果把jdbc的MySQLjar包依赖去除直接编译失败提示没有mysql相关的jar包

改为如下方式

 //2、反射的方式注册驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //改用这种方式注册驱动会发现不会编译失败，相比上面的方式相对解耦，但是依然存在缺陷：若连接改为Oracle数据库，这里的字符串又要进行改动！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如注释的解释一样，又一个缺陷就浮现了：若连接改为Oracle数据库，这里的字符串又要进行改动！&lt;/p&gt;
&lt;p&gt;于是对于这个jdbc程序来说就有这样的一个解耦思路：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;第一步：通过反射来创建对象，尽量避免使用new关键字&lt;br/&gt;第二步：通过读取配置文件来获取创建的对象全限定类名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;传统daoservicecontroller的程序耦合性&quot;&gt;3、传统dao、service、controller的程序耦合性&lt;/h2&gt;
&lt;p&gt;顺着jdbc程序的解耦思路，我们再来看看传统dao、service、controller的程序耦合性分析&lt;/p&gt;
&lt;p&gt;由于只是一个demo，省去dao层的操作.....&lt;/p&gt;
&lt;p&gt;定义一个Service接口&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public interface IAccountOldService{
    public void save();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Service接口实现类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class AccountServiceOldImpl implements IAccountOldService{

    @Override
    public void save() {
        System.out.println(&quot;save成功一个账户....&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;controller代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class AccountCencollertOld {
    public static void main(String[] args) {
        IAccountOldService iaccount=new AccountServiceOldImpl (); 
        iaccount.save();  //运行结果：save成功一个账户....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，有何想法？表面上来看是没有一点问题的，So Beautiful，但仔细的看。表现层与业务层、业务层与持久层紧紧的互相依赖关联，这与我们开发程序的高内聚低耦合原则相违背,哦My God,So Bad！我们顺着jdbc程序的解耦思路，我们应该尽量避免使用new关键字，我们发现这些层里面service层new 持久层dao，controller表现层new 业务层service....太糟糕了&lt;/p&gt;
&lt;p&gt;那么对此，你有何解耦思路？&lt;/p&gt;
&lt;h2 id=&quot;使用工厂模式实现解耦&quot;&gt;4、使用工厂模式实现解耦&lt;/h2&gt;
&lt;p&gt;别想了，工厂模式实现程序解耦你值得拥有！顺着jdbc程序的解耦思路：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1、通过读取配置文件来获取创建的对象全限定类名&lt;br/&gt;2、通过反射来创建对象，尽量避免使用new关键字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先在resources目录下中写一个bean.properties配置类，具体内容如下&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;accountServiceOld=com.factory.service.impl.AccountServiceOldImpl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着使用工厂方法代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * 一个创建Bean对象的工厂
 *
 *    1、需要一个配置文件来配置我们的service和dao    配置文件的内容：唯一标识=全限定类名（key-value）
 *    2、通过读取配置文件中配置的内容，反射创建对象
 *
 *    场景：主要是service调用dao，controller调用service的程序。这里面耦合性非常的高，互相new互相依赖
 *
 *    为了解耦，利用工厂模式进行
 */
 public class BeanFactoryOld {
    private static Properties props;

    static{
        try {
            //实例化对象
            props = new Properties();

            //获取properties文件的流对象
            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);
            props.load(in);//加载其对应路径下的配置文件

        }catch (Exception e){
            throw new ExceptionInInitializerError(&quot;初始化properties失败！&quot;);
        }
    }

    //根据bean的名称获取bean对象
    public static Object getBean(String beanName){
        Object bean=null;
        try {
        String beanPath= props.getProperty(beanName);
        bean = Class.forName(beanPath).newInstance();   //这里的newInstance创建实例（默认无参构造器）每次执行都需要创建一次
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bean;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，controller的代码就可以编写为&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * 这里模拟一个controller调用service
 *
 */
public class AccountCencollertOld {
    public static void main(String[] args) {
   //    IAccountOldService iaccount=new AccountServiceOldImpl ();  //使用工厂方法不再通过new方式

        IAccountOldService iaccount= (IAccountOldService) BeanFactoryOld.getBean(&quot;accountServiceOld&quot;);
        iaccount.save(); //运行结果：save成功一个账户....   说明成功调用了service
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过运行结果，属实没毛病，成功降低程序耦合！So Beautiful！先高兴一会吧，因为马上出现.....但是，随之而来的问题又出现了，我们对这个controller进行一下改写&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;for(int i=0;i&amp;lt;5;i++){
        IAccountOldService iaccount= (IAccountOldService) BeanFactoryOld.getBean(&quot;accountServiceOld&quot;);
        iaccount.save(); 
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
com.factory.service.impl.AccountServiceImpl@677327b6
save成功一个账户....
com.factory.service.impl.AccountServiceImpl@14ae5a5
save成功一个账户....
com.factory.service.impl.AccountServiceImpl@7f31245a
save成功一个账户....
com.factory.service.impl.AccountServiceImpl@6d6f6e28
save成功一个账户....&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印的是五个不同的对象，说明是多例的，每次调用getBean的时候都会newInstance出一个新对象，如下&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019122417054712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;多例每次都要创建对象，资源浪费、效率低下&lt;/p&gt;
&lt;p&gt;针对单例多例情况，我们再对service业务层代码进行修改：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class AccountServiceImpl implements IAccountService {
    //定义类成员
    private int i=1; 

    @Override
    public void save() {
        System.out.println(&quot;save成功一个账户....&quot;);
        System.out.println(i);
        i++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行controller代码，运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;save成功一个账户....
1
save成功一个账户....
1
save成功一个账户....
1
save成功一个账户....
1
save成功一个账户....
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;why？多例因为每次都是新的对象，上面也验证过了，因此每次创建新对象都会初始化一次，重新赋值，所以都是1，如果我们把类成员改为局部成员变量如下&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class AccountServiceOldImpl implements IAccountOldService {

//    private int i=1; 
    @Override
    public void save() {
        int i=1;   //改为局部变量
        System.out.println(&quot;save成功一个账户....&quot;);
        System.out.println(i);
        i++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不用猜，运行结果同样是1。算了还是运行一下吧哈哈哈&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;save成功一个账户....
1
save成功一个账户....
1
save成功一个账户....
1
save成功一个账户....
1
save成功一个账户....
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说了这么多，通过观察service和dao之间单不单例好像无所谓，因为他们之间并没有业务方法中改变的类成员，所以并不需要多例来保证线程安全。那说这些有何意义？不要忘了，由于使用了工厂改进如下中的.&lt;code&gt;newInstance&lt;/code&gt;创建实例（默认无参构造器）每次执行都需要创建一次，这样就不好了（浪费资源），因此我们要设计出只&lt;code&gt;newInstance&lt;/code&gt;创建一次实例就很完美了，这也是我为啥要在&lt;code&gt;service&lt;/code&gt;和&lt;code&gt;controller&lt;/code&gt;中都添加一个&lt;code&gt;Old&lt;/code&gt;关键字的原因了，接下来我们来看看工厂是如何改进的！&lt;/p&gt;
&lt;h2 id=&quot;工厂模式改进&quot;&gt;5、工厂模式改进&lt;/h2&gt;
&lt;p&gt;为了不被搞晕，我们重新写代码，也就是重头开始写代码~其实就是把Old去掉~&lt;/p&gt;
&lt;p&gt;由于只是一个demo，省去dao层的操作.....&lt;/p&gt;
&lt;p&gt;定义一个Service接口&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public interface IAccountService {
    public void save();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Service接口实现类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class AccountServiceImpl implements IAccountService{

    @Override
    public void save() {
        System.out.println(&quot;save成功一个账户....&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;controller代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * 这里模拟一个controller调用service
 *
 */
public class AccountCencollert {
    public static void main(String[] args) {
//        IAccountService iaccount=new AccountServiceImpl(); 

        IAccountService iaccount= (IAccountService) BeanFactory.getBean(&quot;accountService&quot;);
        iaccount.save(); //运行结果：save成功一个账户....   说明了成功调用了service
      }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改进的工厂方法代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class BeanFactory {
    private static Properties props;

    //定义一个map容器，用于存放创建的对象
    private static Map&amp;lt;String,Object&amp;gt; beans; //改进的代码============

    static{
        try {
            //实例化对象
            props = new Properties();

            //获取properties文件的流对象
            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);
            props.load(in);//加载其对应路径下的配置文件

            ////////////////////以下是改进的代码=======================
            //实例化容器
            beans=new HashMap&amp;lt;String,Object&amp;gt;();
            //取出配置文件中所有的key值
            Enumeration&amp;lt;Object&amp;gt; keys = props.keys();
            //遍历枚举
            while(keys.hasMoreElements()){
                //取出每个key
                String key = keys.nextElement().toString();
                //根据key取出对应的value  (这里因为每个value值对应着类路径)
                String beanPath = props.getProperty(key);
                //反射创建对象
                Object value = Class.forName(beanPath).newInstance();
                //把key和value存入容器中
                beans.put(key,value);
            }
        }catch (Exception e){
            throw new ExceptionInInitializerError(&quot;初始化properties失败！&quot;);
        }
    }


    //随着代码的改进，我们就可以简化下面的获取bean对象的方法，如下代码
    /**
     * 根据bean的名称获取对象（单例）
     */
    public static Object getBean(String beanName){
        //通过Map容器对应key来获取对应对象
        return beans.get(beanName);    //这里通过Map容器中获取，这样就不会每次都创建一次实例！
    }

//不再使用下面的方法
  /*
    //根据bean的名称获取bean对象
    public static Object getBean(String beanName){
        Object bean=null;
        try {
        String beanPath= props.getProperty(beanName);
        bean = Class.forName(beanPath).newInstance();   //这里的newInstance创建实例（默认无参构造器）每次执行都需要创建一次，这样就不好了
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bean;
    }*/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面改进的工厂代码，我们可以发现一开始就定义一个Map容器，用于存放创建的对象，为啥要先定义一个Map容器呢？用一个容器将这个实例装起来，这是由于不把这个对象装存起来的话，这个对象不使用很容易被GC掉，何况我们现在只使用这一个对象！&lt;/p&gt;
&lt;p&gt;定义一个Map容器存放配置好的文件中的每个对象，之后我们就直接提供一个根据Map的key来取value的getBean方法，这样不仅仅扩展了程序的配置文件的灵活性而且还保证了只产生一个对象，保证资源不浪费，So Beautiful !&lt;/p&gt;
&lt;p&gt;那如何证明已经是单例的模式了呢？很简单，如下设计一下service业务层、controller表现层代码即可：&lt;/p&gt;
&lt;p&gt;service业务层：添加一个类成员属性，并在方法内部 i++;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class AccountServiceImpl implements IAccountService {

    private int i=1; //类成员属性

    @Override
    public void save() {
        System.out.println(&quot;save成功一个账户....&quot;);
        System.out.println(i);
        i++;//二次改革代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;controller表现层: 创建调用工厂5次创建对象的方法&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * 这里模拟一个controller调用service
 *
 */
public class AccountCencollert {
    public static void main(String[] args) {
        for(int i=0;i&amp;lt;5;i++){
            IAccountService iaccount= (IAccountService) BeanFactory.getBean(&quot;accountService&quot;);
            System.out.println(iaccount);  //打印的是五个不同的对象，说明是多例的
            iaccount.save();  //会发现打印的i值都是1，并没有自增成功
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行代码结果：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
1
com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
2
com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
3
com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
4
com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现，确实5个对象都是同一个，并且出现了改变类成员属性的现象。&lt;/p&gt;
&lt;p&gt;如果我们把类成员属性改为局部成员属性呢？&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class AccountServiceImpl implements IAccountService {

    @Override
    public void save() {
        int i=1; //局部成员属性
        System.out.println(&quot;save成功一个账户....&quot;);
        System.out.println(i);
        i++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
1
com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
1
com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
1
com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
1
com.factory.service.impl.AccountServiceImpl@1540e19d
save成功一个账户....
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这个结果，我们就能联想到，之前为什么servlet中为啥要避免定义类成员，原因就在这里！多例情况下，就不会出现这种情况！！！！&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;6、结语&lt;/h2&gt;
&lt;p&gt;到这里我们已经基本了解了程序间的耦合与解耦，并且对单例多例也一并进行了进一步的了解。而spring中正是使用工厂模式来实现程序解耦的，spring是一个大工厂, 或许你并没有察觉哈哈哈哈.....&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，你的赞同是我最大的动力，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，里面有一些java学习资料和一大波java电子书籍，比如说周志明老师的深入java虚拟机、java编程思想、核心技术卷、大话设计模式、java并发编程实战.....都是java的圣经，不说了快上Tomcat车，咋们走！最主要的是一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Dec 2019 00:04:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>@[toc] 1、 啥是耦合、解耦？ 既然是程序解耦，那我们必须要先知道啥是耦合，耦合简单来说就是程序的依赖关系，而依赖关系则主要包括 1、 类之间的依赖 2、 方法间的依赖 比如下面这段代码： 上面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/12093138.html</dc:identifier>
</item>
<item>
<title>.NET ORM 开源项目 FreeSql 1.0 正式版发布 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/12098419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/12098419.html</guid>
<description>[unable to retrieve full-text content]一、简介 FreeSql 是 .NET 平台下的对象关系映射技术(O/RM)，支持 .NetCore 2.1+ 或 .NetFramework 4.0+ 或 Xamarin。 从 0.0.1 发布，历时整整一年的迭代更新，原计划元旦发布1.0，可能作者比较急提前了几天发布。其实是元旦有其他事…… 本</description>
<pubDate>Wed, 25 Dec 2019 21:53:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<dc:identifier>http://www.cnblogs.com/kellynic/p/12098419.html</dc:identifier>
</item>
<item>
<title>改善Azure App Service托管应用程序性能的几个技巧 - nodotnet</title>
<link>http://www.cnblogs.com/JulianHuang/p/12098385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JulianHuang/p/12098385.html</guid>
<description>
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本文介绍了几个技巧，这些技巧可以改善Azure App Service托管应用程序的性能。其中一些技巧是你现在就可以进行的配置变更，&lt;/p&gt;
&lt;p&gt;而其他技巧则可能需要对应用程序进行一些重新设计和重构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发者都希望从部署在Azure的App Services中压榨出最佳性能。&lt;br/&gt;更好的性能不仅能够获得更佳的响应体验；而且如果我们在Azure中能“四两拨千斤”，那么性能的提升还可以为我们省钱。&lt;br/&gt;在本文中，我们将研究提高Azure App Services中运行的Web程序性能的设置和策略。&lt;/p&gt;
&lt;p&gt;下面几个性能提升意见在 App Service 配置界面即可操作，这一组技巧的主题是压榨出App Service本身的性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201912/587720-20191225233849912-341064056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;1.   启动HTTP/2&lt;/p&gt;
&lt;p&gt;Microsoft于2018年初宣布在App Services中支持HTTP/2，但到目前为止在Azure中默认创建的App Service还是以HTTP1.1协议工作。HTTP/2对常见的的Web协议进行了重大更改，许多更改旨在提高性能并减少Web上的延迟。例如，HTTP/2中的标头压缩和二进制格式将减少有效负载大小。另外请求管道和多路复用等功能允许使用更少的网络套接字来执行更多并发请求，并有助于避免一个缓慢的请求阻止所有后续请求，这是HTTP 1.1中的常见问题。&lt;/p&gt;
&lt;p&gt;为你的的App Service启动HTTP/2协议，如上图所示，下拉列表指定HTTP2.0版本后，所有支持HTTP/2的客户端都将自动升级其连接， 不支持HTTP/2的客户端仍然以原有Http1.1 方式交互。&lt;/p&gt;
&lt;p&gt;HTTP/2不会使每个应用都受益，下面是一个简单的测试以验证HTTP/2的改进：&lt;/p&gt;
&lt;p&gt;某App Service托管页面引用了脚本、CSS资源、16张图像，每个图像的大小超过200 KB。&lt;/p&gt;
&lt;p&gt; 使用developer tool记录使用HTTP 1.1在App Service上发生的情况。&lt;/p&gt;
&lt;p&gt;请注意观察条形红色部分显示了后置请求以阻塞状态开始。这是可怕的“行头阻塞”问题，其中对连接数和并发请求的限制限制了客户端和服务器之间的吞吐量。直到第一个请求开始后800毫秒，客户端才会收到该页面的最终字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201912/587720-20191225183455136-1906000439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接下来在App Service中启用了HTTP / 2支持：&lt;/p&gt;
&lt;p&gt;不需要对客户端或服务器上进行任何其他配置更改，最后一个字节不到500ms到达。由于HTTP/2提高了网络利用率，我们避免了阻塞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201912/587720-20191225183519460-886719354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.  关闭空闲休眠&lt;/p&gt;
&lt;p&gt;如果你有将应用程序部署到IIS的经历，那么你应该知道IIS在一段时间不活动之后将休眠（这个配置在IIS理默认是20分钟）。&lt;/p&gt;
&lt;p&gt;Azure App Service延续了这一传统。尽管休眠可为在同一App Service Plan上运行的其他App Service提供资源，但是此策略会损害当前应用程序的性能，因为下一个传入请求将经历Web服务器冷启动的过程：缓存为空、连接池为空，站点预热，所有请求的速度都比正常情况慢。为了防止空闲关闭，您可以在“ App Service配置”刀片中设置“始终开启”标志。&lt;/p&gt;

&lt;p&gt;3. 关闭App Service实例亲和力&lt;/p&gt;
&lt;p&gt;即使你仅运行App Service Plan的单实例，每个Azure App Service前面都是负载平衡器。负载均衡器会转发请求到App Service实例。&lt;/p&gt;
&lt;p&gt;因此，当App Service因流量缩放出多实例，负载均衡器使用&lt;a href=&quot;http://www.iis.net/learn/extensions/planning-for-arr&quot;&gt;Application Request Routing&lt;/a&gt;将连接会话分发给实例。&lt;/p&gt;
&lt;p&gt;因为Azure无法知晓应用程序是不是stateless服务， 故默认的App Service将确保客户端在会话期间访问同一App Service实例。&lt;/p&gt;
&lt;p&gt;为了实现这种亲和力，负载均衡器会在对客户端的第一个响应中注入&lt;strong&gt;ARRAffinity&lt;/strong&gt;  Cookie。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201912/587720-20191226000646433-483118391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如果你的应用程序是stateless，并允许负载平衡器在实例之间分配请求，请关闭请求路由cookie，以提高性能和弹性。&lt;/p&gt;
&lt;p&gt;--------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;下面的改进需要一些其他网络规划或重组（某些情况下，还需要更改应用程序本身）&lt;/p&gt;
&lt;p&gt;下一组技巧中的主题是缩短数据在网络上传输的距离&lt;/p&gt;
&lt;p&gt;如果大多数客户流量都来自世界的特定区域，则将资源放置在离客户最近的Azure区域中是很有意义的。当然，我们许多人的客户分布在世界各地。在这种情况下，您可以考虑跨多个Azure区域进行地理复制，以与每个人保持亲密关系，之后你使用类似Azure Traffic Manager（基于DNS技术的负载均衡器）将你的客户直接路由到 最近的服务实例。&lt;/p&gt;
&lt;p&gt;脚本、图片、CSS，视频等静态资源是在CDN边缘服务器上缓存的较好选择，一旦缓存，Azure App Service 不需要花费带宽和时间在这些资源上，专注处理动态资源。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Azure支持CDN边缘服务器的搭建 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回过头来，看以上性能优化建议，第一步还是要评估当前App Service现状和性能，不是每一个策略都对你的App Service 有效。&lt;/p&gt;

</description>
<pubDate>Wed, 25 Dec 2019 17:26:00 +0000</pubDate>
<dc:creator>nodotnet</dc:creator>
<og:description>本文介绍了几个技巧，这些技巧可以改善Azure App Service托管应用程序的性能。其中一些技巧是你现在就可以进行的配置变更， 而其他技巧则可能需要对应用程序进行一些重新设计和重构。 开发者都希</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JulianHuang/p/12098385.html</dc:identifier>
</item>
<item>
<title>我的小小实验室之实现最简单的跳转 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/12099875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/12099875.html</guid>
<description>[unable to retrieve full-text content]需求： 由于工作需要，我自己的工作站上搭建有很多套实验环境，而在某种特定场景下，我需要通过默认连接的终端能随时跳转切换到其他环境下临时测试使用，因为只有我自己用，无需引入复杂的跳转机系统，也不需要审计。 环境： 均为Linux服务器 实现： 我想通过最简单的一些运维知识，搭建一套最简易的跳转程序，提</description>
<pubDate>Wed, 25 Dec 2019 16:58:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:identifier>https://www.cnblogs.com/jyzhao/p/12099875.html</dc:identifier>
</item>
<item>
<title>当我有一台服务器时我做了什么 - 山月水风</title>
<link>http://www.cnblogs.com/xianwang/p/12099871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xianwang/p/12099871.html</guid>
<description>[unable to retrieve full-text content]当一八年末的时候，我写了一篇文章 &quot;当我有一台服务器时我做了什么&quot; 又是年末，我服务器的架构也发生了一些变化，因此总结一番 &lt;! more + 原文地址: &quot;当我有一台服务器时我做了什么&quot; + 系列文章: &quot;当我有一台服务器时我做了什么&quot; 概览 去年服务器有两台，一台 2C4G，一台 1C2G 今年</description>
<pubDate>Wed, 25 Dec 2019 16:47:00 +0000</pubDate>
<dc:creator>山月水风</dc:creator>
<dc:identifier>https://www.cnblogs.com/xianwang/p/12099871.html</dc:identifier>
</item>
<item>
<title>.Net Core 授权系统组件解析 - 郑小超</title>
<link>http://www.cnblogs.com/GreenLeaves/p/12099760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GreenLeaves/p/12099760.html</guid>
<description>&lt;p&gt;前面关于.Net Core如何进行用户认证的核心流程介绍完毕之后,&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/GreenLeaves/p/12093972.html&quot;&gt;.Net Core 认证系统之Cookie认证源码解析&lt;/a&gt;远程认证暂时不介绍,后期有时间,我会加上.接下去介绍认证组件是如何和认证组件一起协同工作.源码的路径如下,自行去github下载.ok,开始!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225214905432-99764288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、认证组件的执行流程&lt;/p&gt;
&lt;p&gt;Core启动认证组件的方式很简单.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225214834431-2081738987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225214959184-999936548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 和认证系统一样,都是以中间件的形式提供服务.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225215547630-1540597035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 验证有没有注入授权组件的核心服务. &lt;/p&gt;
&lt;p&gt;接下去查看中间件的代码,如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225215705781-2096060158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225215726623-761172519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225215745346-1554643069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225215756423-1743967754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 校验过程就不说了,第一步:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225215847403-173524023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 从终结点元数据中读取打了Authorize的特性的控制器和方法.那么意味这此时控制器已经被注入了,所以一般services.AddMvc()和add.UseMvc()是先于认证组件注入的.&lt;/p&gt;
&lt;p&gt;且微软提示,如果你自定义了一个授权Filter,改变了认证逻辑,可能会造成错误,不建议这种方式.因为核心认证组件支持所有的业务扩展,没必要再去定义额外的Filter.&lt;/p&gt;
&lt;p&gt;接着看如下代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225220631812-2119278900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; AuthorizationPolicy类合并了需要认证的元数据和认证策略提供类.那去找找IAuthorizationPolicyProvider接口的实现,如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225220958410-1991092686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在注入服务的时候,微软注入了默认的实现，又是Provider模式,Core底层大量采用了这个模式,所以如果你不知道,先去补补设计模式的知识点,可以参考本人的设计模式分类.这个设计模式很简单.不看代码就能猜出大致的实现，内部肯定维护了一个键值对,Dic或者HashMap.那就去看看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225221253684-1443800863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225221316788-290499715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 调用了AuthorizationOptions参数中的GetPolicy方法,对应&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225221346760-902467920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 果然是个字典.这意味这我们可以通过认证参数来配置认证策略,添加策略的方法如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225221523178-332130355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ok,再去看看AuthorizationPolicy的构造,其维护了两个主要的属性,后面会介绍.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225221630865-1126196262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 一个认证方案的名称和一个授权条件集合,到这里可以知道认证组件可以和授权组件集成到一起使用的结论.&lt;/p&gt;
&lt;p&gt;讲到这,回到中间件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225222016733-661340032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; _prolicyProvider提供的是认证方案的名称和授权条件集合,以及需要被认证的元数据集合.&lt;/p&gt;
&lt;p&gt;接着,看看AuthorizationPolicy.CombineAsync的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225224422818-2112250818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225224433187-568790137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225224451494-1374714984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225224510297-1040060417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 跳过参数校验,分析核心代码,第一步:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225224949699-1475975750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 遍历需要授权的元数据集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225225204833-1490606879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; AuthorizationPolicyBuilder,授权策略Buidler生成器,负责生成授权策略。Buidler生成器模式,不懂其移步本人设计模式分类,很简单.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225225331754-957020429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 判断需要授权元数据的Policy属性,ok,到这里.很明显.我们得看看Authorize特性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225225430872-1293013716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225225518522-555201270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225225552962-1815097590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个时候&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225225655742-1313874560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 红框里得值就为&quot;自定义授权策略&quot;,接着通过policyProvider拿到对应得AuthorizationPolicy实例,本质就是认证策略名称为&quot;自定义授权策略&quot;的认证方案和授权条件集合.&lt;/p&gt;
&lt;p&gt;接着通过policyBuilder将认证策略名称为&quot;自定义授权策略&quot;的认证方案和授权条件集合.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225230303526-598338542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 添加到AuthorizationPolicyBuilder实例的下面两个属性中去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225230335231-1920204613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 此时,当你这样设置控制器或者其下的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225230525252-701593482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 说明你不在采用授权组件的默认策略,所以&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225230602793-735301837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接着&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225230637150-1741384803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 又去判断当前需要授权元数据的Authorize特性中是否设置了Roles特性,且可以设置多个,以&quot;，&quot;分隔&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225230752131-1974357967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 到这里说明自定义策略授权和Role授权是可以共存的,可以向下面这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225230927139-1391418791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225231023497-451775828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个方法本质,就是向AuthorizationPolicyBuilder实例的&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225231120326-306951070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 追加授权条件.&lt;/p&gt;
&lt;p&gt;简单说下为什么微软要给授权组件预留Roles角色集合,因为当前市面上主流的权限设计系统都是RBAC模式,中文就是基于角色(Role)的权限管理系统.&lt;/p&gt;
&lt;p&gt;接着&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225231522141-668183035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里和角色一样不介绍了&lt;/p&gt;
&lt;p&gt;到这里你会发现 基于认证方案授权策略+基于角色的授权策略=自定义策略的授权策略.&lt;/p&gt;
&lt;p&gt;接着,如果没有任何控制器或者方法使用授权策略,那么使用最基本的拒绝匿名访问api策略&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225232153476-527707116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 核心代码如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225232322366-491925319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如果当前用户未认证,则不能访问.&lt;/p&gt;
&lt;p&gt;当然这个策略也可以通过AuthorizationOptions参数进行重写.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225232408021-1834747517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225232511661-21021489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 去重构建一个新的PolicyBuilder对象实例.&lt;/p&gt;
&lt;p&gt; 接着&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225232801019-1635397843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225233040055-924158147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 执行PolicyBuilder中的用户认证,其中做了一些重复登陆的处理.本质就是如此.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225233124023-308731863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这段代码就可以看出.如果当前用户未登陆,则返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225233157481-1005261697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接着回到中间件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225233228565-1531146071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 认证完毕之后,如果当前元数据打了AllowAnonymous特性像下面这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225233358449-1320507195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这样意味这之前的工作都白做了.直接跳过授权.&lt;/p&gt;
&lt;p&gt;最后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225233515909-2960064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225233602920-1865683581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 调用授权服务,进行授权校验.默认的授权服务注入点如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225233756040-891957951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225234305659-1472666008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 构建授权上下文,接着拿到所有的授权处理器.遍历执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225234504133-858164023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个参数,可配置,当一个授权策略校验失败,便不再执行接下去的授权策略.&lt;/p&gt;
&lt;p&gt;最后返回授权结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225234604608-727136814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结:本质就是将&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772156/201912/772156-20191225234912707-969111156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 特性中的这两个参数,交给IAuthorizationHandler授权处理器处理.当然如果你制定了认证方案,那么则会去判断当前用户是否登陆.&lt;/p&gt;
&lt;p&gt;  整个流程结束.纯属个人理解,能力有限,有问题,请指正,谢谢.&lt;/p&gt;

&lt;p&gt;接下去会写一篇动态授权的文章,这样就能将授权组件+认证组件+权限系统集合起来实现完成用户认证和api动态授权.为后期的前端后端分离架构-基于id4的password模式+JwtBear认证+identity的授权认证中心做准备.最后形成一个完整的授权认证中心.&lt;/p&gt;
&lt;p&gt;g&lt;/p&gt;
</description>
<pubDate>Wed, 25 Dec 2019 15:56:00 +0000</pubDate>
<dc:creator>郑小超</dc:creator>
<og:description>前面关于.Net Core如何进行用户认证的核心流程介绍完毕之后,.Net Core 认证系统之Cookie认证源码解析远程认证暂时不介绍,后期有时间,我会加上.接下去介绍认证组件是如何和认证组件一起</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GreenLeaves/p/12099760.html</dc:identifier>
</item>
<item>
<title>三分钟学会在ASP.NET Core MVC 中使用Cookie - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/12099286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/12099286.html</guid>
<description>&lt;h2&gt;一.Cookie是什么？&lt;/h2&gt;
&lt;p&gt;　　我的朋友问我cookie是什么，用来干什么的，可是我居然无法清楚明白简短地向其阐述cookie，这不禁让我陷入了沉思：为什么我无法解释清楚，我对学习的方法产生了怀疑！所以我们在学习一个东西的时候，一定要做到知其然知其所以然。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。Cookie实际上是一小段的文本信息）。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　打个比方，这就犹如你办理了银行卡，下次你去银行办业务，直接拿银行卡就行，不需要身份证。&lt;/p&gt;
&lt;h2&gt;二.在.NET Core中尝试&lt;/h2&gt;
&lt;p&gt;　　废话不多说，干就完了，现在我们创建ASP.NET Core MVC项目，撰写该文章时使用的.NET Core SDK 3.0 构建的项目，创建完毕之后我们无需安装任何包，&lt;/p&gt;
&lt;p&gt;　　但是我们需要在Startup中添加一些配置，用于Cookie相关的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public const string CookieScheme = &quot;YourSchemeName&quot;;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CookieAuthenticationDefaults.AuthenticationScheme Cookies Default Value
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;you can change scheme&lt;/span&gt;
&lt;span&gt;            services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
                .AddCookie(options &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                    options.LoginPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/LoginOrSignOut/Index/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                });
            services.AddControllersWithViews();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is able to also use other services.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;services.AddSingleton&amp;lt;IConfigureOptions&amp;lt;CookieAuthenticationOptions&amp;gt;, ConfigureMyCookie&amp;gt;();&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在其中我们配置登录页面，其中 &lt;span class=&quot;cnblogs_code&quot;&gt;AddAuthentication&lt;/span&gt; 中是我们的方案名称，这个是做什么的呢？很多小伙伴都懵懵懂懂表示很懵逼啊，我看很多人也是都写得默认，那它到底有啥用，经过我看AspNetCore源码发现它这个是可以做一些配置的。看下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConfigureMyCookie : IConfigureNamedOptions&amp;lt;CookieAuthenticationOptions&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; You can inject services here&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigureMyCookie()
        {}
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, CookieAuthenticationOptions options)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only configure the schemes you want
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (name == Startup.CookieScheme)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; options.LoginPath = &quot;/someotherpath&quot;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(CookieAuthenticationOptions options)
            &lt;/span&gt;=&amp;gt;&lt;span&gt; Configure(Options.DefaultName, options);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在其中你可以定义某些策略，随后你直接改变 &lt;span class=&quot;cnblogs_code&quot;&gt;CookieScheme&lt;/span&gt; 的变量就可以替换某些配置，在配置中一共有这几项，这无疑是帮助我们快速使用Cookie的好帮手~点个赞。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191225222511332-957231715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在源码中可以看到Cookie默认保存的时间是14天，这个时间我们可以去选择，支持TimeSpan的那些类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CookieAuthenticationOptions()
        {
            ExpireTimeSpan &lt;/span&gt;= TimeSpan.FromDays(&lt;span&gt;14&lt;/span&gt;&lt;span&gt;);
            ReturnUrlParameter &lt;/span&gt;=&lt;span&gt; CookieAuthenticationDefaults.ReturnUrlParameter;
            SlidingExpiration &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            Events &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookieAuthenticationEvents();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来LoginOrOut Controller，我们模拟了登录和退出，通过 &lt;span class=&quot;cnblogs_code&quot;&gt;SignInAsync&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;SignOutAsync&lt;/span&gt; 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Login(LoginModel loginModel)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loginModel.Username == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;haozi zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                loginModel.Password &lt;/span&gt;== &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Claim&amp;gt;&lt;span&gt;
                 {
                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(ClaimTypes.Name, loginModel.Username)
                 };
                ClaimsPrincipal principal &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClaimsPrincipal(&lt;span&gt;new&lt;/span&gt; ClaimsIdentity(claims, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; HttpContext.SignInAsync(principal);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Just redirect to our index after logging in. &lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; Redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; this action for web lagout 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Logout()
        {
            Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注销登录的用户，相当于ASP.NET中的FormsAuthentication.SignOut  &lt;/span&gt;
                &lt;span&gt;await&lt;/span&gt;&lt;span&gt; HttpContext.SignOutAsync();
            }).Wait();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就拿出推出的源码来看，其中获取了Handler的某些信息，随后将它转换为 &lt;span class=&quot;cnblogs_code&quot;&gt;IAuthenticationSignOutHandler&lt;/span&gt; 接口类型，这个接口 as 接口，像是在地方实现了这个接口，然后将某些运行时的值引用传递到该接口上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task SignOutAsync(HttpContext context, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; scheme, AuthenticationProperties properties)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (scheme == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; defaultScheme = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Schemes.GetDefaultSignOutSchemeAsync();
                scheme &lt;/span&gt;= defaultScheme?&lt;span&gt;.Name;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (scheme == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No authenticationScheme was specified, and there was no DefaultSignOutScheme found. The default schemes can be set using either AddAuthentication(string defaultScheme) or AddAuthentication(Action&amp;lt;AuthenticationOptions&amp;gt; configureOptions).&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handler = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Handlers.GetHandlerAsync(context, scheme);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; CreateMissingSignOutHandlerException(scheme);
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; signOutHandler = handler &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IAuthenticationSignOutHandler;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (signOutHandler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; CreateMismatchedSignOutHandlerException(scheme, handler);
            }
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; signOutHandler.SignOutAsync(properties);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;span class=&quot;cnblogs_code&quot;&gt;GetHandlerAsync&lt;/span&gt; 中根据认证策略创建了某些实例，这里不再多说，因为源码深不见底，我也说不太清楚...只是想表达一下看源码的好处和坏处....&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IAuthenticationHandler&amp;gt; GetHandlerAsync(HttpContext context, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; authenticationScheme)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_handlerMap.ContainsKey(authenticationScheme))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _handlerMap[authenticationScheme];
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scheme = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Schemes.GetSchemeAsync(authenticationScheme);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (scheme == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handler = (context.RequestServices.GetService(scheme.HandlerType) ??&lt;span&gt;
                ActivatorUtilities.CreateInstance(context.RequestServices, scheme.HandlerType))
                &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; IAuthenticationHandler;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; handler.InitializeAsync(scheme, context);
                _handlerMap[authenticationScheme] &lt;/span&gt;=&lt;span&gt; handler;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handler;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后我们在页面上想要获取登录的信息，可以通过 &lt;span class=&quot;cnblogs_code&quot;&gt;HttpContext.User.Claims&lt;/span&gt; 中的签名信息获取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using Microsoft.AspNetCore.Authentication
&lt;/span&gt;&amp;lt;h2&amp;gt;HttpContext.User.Claims&amp;lt;/h2&amp;gt;
&amp;lt;dl&amp;gt;&lt;span&gt;
    @foreach (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claim &lt;span&gt;in&lt;/span&gt;&lt;span&gt; User.Claims)
    {
        &lt;/span&gt;&amp;lt;dt&amp;gt;@claim.Type&amp;lt;/dt&amp;gt;
        &amp;lt;dd&amp;gt;@claim.Value&amp;lt;/dd&amp;gt;&lt;span&gt;
    }
&lt;/span&gt;&amp;lt;/dl&amp;gt;
&amp;lt;h2&amp;gt;AuthenticationProperties&amp;lt;/h2&amp;gt;
&amp;lt;dl&amp;gt;&lt;span&gt;
    @foreach (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prop &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Context.AuthenticateAsync()).Properties.Items)
    {
        &lt;/span&gt;&amp;lt;dt&amp;gt;@prop.Key&amp;lt;/dt&amp;gt;
        &amp;lt;dd&amp;gt;@prop.Value&amp;lt;/dd&amp;gt;&lt;span&gt;
    }
&lt;/span&gt;&amp;lt;/dl&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三.最后效果以及源码地址&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191225230634000-2135186270.gif&quot; alt=&quot;&quot; width=&quot;1023&quot; height=&quot;477&quot;/&gt;&lt;/p&gt;
&lt;p&gt; GitHub地址：&lt;a href=&quot;https://github.com/zaranetCore/aspNetCore_JsonwebToken/tree/master/src/Identity.Cookie/DotNetCore_Cookie_Sample&quot;&gt;https://github.com/zaranetCore/aspNetCore_JsonwebToken/tree/master/src/Identity.Cookie/DotNetCore_Cookie_Sample&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Dec 2019 15:13:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>一.Cookie是什么？ 我的朋友问我cookie是什么，用来干什么的，可是我居然无法清楚明白简短地向其阐述cookie，这不禁让我陷入了沉思：为什么我无法解释清楚，我对学习的方法产生了怀疑！所以我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZaraNet/p/12099286.html</dc:identifier>
</item>
</channel>
</rss>