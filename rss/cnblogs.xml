<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>死磕 java同步系列之JMM（Java Memory Model） - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/10884421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/10884421.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Java内存模型是在硬件内存模型上的更高层的抽象，它屏蔽了各种硬件和操作系统访问的差异性，保证了Java程序在各种平台下对内存的访问都能达到一致的效果。&lt;/p&gt;
&lt;h2 id=&quot;硬件内存模型&quot;&gt;硬件内存模型&lt;/h2&gt;
&lt;p&gt;在正式讲解Java的内存模型之前，我们有必要先了解一下硬件层面的一些东西。&lt;/p&gt;
&lt;p&gt;在现代计算机的硬件体系中，CPU的运算速度是非常快的，远远高于它从存储介质读取数据的速度，这里的存储介质有很多，比如磁盘、光盘、网卡、内存等，这些存储介质有一个很明显的特点——距离CPU越近的存储介质往往越小越贵越快，距离CPU越远的存储介质往往越大越便宜越慢。&lt;/p&gt;
&lt;p&gt;所以，在程序运行的过程中，CPU大部分时间都浪费在了磁盘IO、网络通讯、数据库访问上，如果不想让CPU在那里白白等待，我们就必须想办法去把CPU的运算能力压榨出来，否则就会造成很大的浪费，而让CPU同时去处理多项任务则是最容易想到的，也是被证明非常有效的压榨手段，这也就是我们常说的“并发执行”。&lt;/p&gt;
&lt;p&gt;但是，让CPU并发地执行多项任务并不是那么容易实现的事，因为所有的运算都不可能只依靠CPU的计算就能完成，往往还需要跟内存进行交互，如读取运算数据、存储运算结果等。&lt;/p&gt;
&lt;p&gt;前面我们也说过了，CPU与内存的交互往往是很慢的，所以这就要求我们要想办法在CPU和内存之间建立一种连接，使它们达到一种平衡，让运算能快速地进行，而这种连接就是我们常说的“高速缓存”。&lt;/p&gt;
&lt;p&gt;高速缓存的速度是非常接近CPU的，但是它的引入又带来了新的问题，现代的CPU往往是有多个核心的，每个核心都有自己的缓存，而多个核心之间是不存在时间片的竞争的，它们可以并行地执行，那么，怎么保证这些缓存与主内存中的数据的一致性就成为了一个难题。&lt;/p&gt;
&lt;p&gt;为了解决缓存一致性的问题，多个核心在访问缓存时要遵循一些协议，在读写操作时根据协议来操作，这些协议有MSI、MESI、MOSI等，它们定义了何时应该访问缓存中的数据、何时应该让缓存失效、何时应该访问主内存中的数据等基本原则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%90%8C%E6%AD%A5%E7%B3%BB%E5%88%97/resource/JMM1.png&quot; alt=&quot;JMM&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而随着CPU能力的不断提升，一层缓存就无法满足要求了，就逐渐衍生出了多级缓存。&lt;/p&gt;
&lt;p&gt;按照数据读取顺序和CPU的紧密程度，CPU的缓存可以分为一级缓存（L1）、二级缓存（L2）、三级缓存（L3），每一级缓存存储的数据都是下一级的一部分。&lt;/p&gt;
&lt;p&gt;这三种缓存的技术难度和制作成本是相对递减的，容量也是相对递增的。&lt;/p&gt;
&lt;p&gt;所以，在有了多级缓存后，程序的运行就变成了：&lt;/p&gt;
&lt;p&gt;当CPU要读取一个数据的时候，先从一级缓存中查找，如果没找到再从二级缓存中查找，如果没找到再从三级缓存中查找，如果没找到再从主内存中查找，然后再把找到的数据依次加载到多级缓存中，下次再使用相关的数据直接从缓存中查找即可。&lt;/p&gt;
&lt;p&gt;而加载到缓存中的数据也不是说用到哪个就加载哪个，而是加载内存中连续的数据，一般来说是加载连续的64个字节，因此，如果访问一个 long 类型的数组时，当数组中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中，这就是“缓存行”的概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%90%8C%E6%AD%A5%E7%B3%BB%E5%88%97/resource/JMM2.png&quot; alt=&quot;JMM&quot;/&gt;&lt;/p&gt;
&lt;p&gt;缓存行虽然能极大地提高程序运行的效率，但是在多线程对共享变量的访问过程中又带来了新的问题，也就是非常著名的“伪共享”。&lt;/p&gt;
&lt;p&gt;关于伪共享的问题，我们这里就不展开讲了，有兴趣的可以看彤哥之前发布的【&lt;a href=&quot;https://mp.weixin.qq.com/s/rd13SOSxhLA6TT13N9ni8Q&quot;&gt;杂谈 什么是伪共享（false sharing）？&lt;/a&gt;】章节的相关内容。&lt;/p&gt;
&lt;p&gt;除此之外，为了使CPU中的运算单元能够充分地被利用，CPU可能会对输入的代码进行乱序执行优化，然后在计算之后再将乱序执行的结果进行重组，保证该结果与顺序执行的结果一致，但并不保证程序中各个语句计算的先后顺序与代码的输入顺序一致，因此，如果一个计算任务依赖于另一个计算任务的结果，那么其顺序性并不能靠代码的先后顺序来保证。&lt;/p&gt;
&lt;p&gt;与CPU的乱序执行优化类似，java虚拟机的即时编译器也有类似的指令重排序优化。&lt;/p&gt;
&lt;p&gt;为了解决上面提到的多个缓存读写一致性以及乱序排序优化的问题，这就有了内存模型，它定义了共享内存系统中多线程读写操作行为的规范。&lt;/p&gt;
&lt;h2 id=&quot;java内存模型&quot;&gt;Java内存模型&lt;/h2&gt;
&lt;p&gt;Java内存模型（Java Memory Model，JMM）是在硬件内存模型基础上更高层的抽象，它屏蔽了各种硬件和操作系统对内存访问的差异性，从而实现让Java程序在各种平台下都能达到一致的并发效果。&lt;/p&gt;
&lt;p&gt;Java内存模型定义了程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。这里所说的变量包括实例字段、静态字段，但不包括局部变量和方法参数，因为它们是线程私有的，它们不会被共享，自然不存在竞争问题。&lt;/p&gt;
&lt;p&gt;为了获得更好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码的执行顺序等这类权利。&lt;/p&gt;
&lt;p&gt;Java内存模型规定了所有的变量都存储在主内存中，这里的主内存跟介绍硬件时所用的名字一样，两者可以类比，但此处仅指虚拟机中内存的一部分。&lt;/p&gt;
&lt;p&gt;除了主内存，每条线程还有自己的工作内存，此处可与CPU的高速缓存进行类比。工作内存中保存着该线程使用到的变量的主内存副本的拷贝，线程对变量的操作都必须在工作内存中进行，包括读取和赋值等，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递必须通过主内存来完成。&lt;/p&gt;
&lt;p&gt;线程、工作内存、主内存三者的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%90%8C%E6%AD%A5%E7%B3%BB%E5%88%97/resource/JMM3.png&quot; alt=&quot;JMM&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，这里所说的主内存、工作内存跟Java虚拟机内存区域划分中的堆、栈是不同层次的内存划分，如果两者一定要勉强对应起来，主内存主要对应于堆中对象的实例部分，而工作内存主要对应与虚拟机栈中的部分区域。&lt;/p&gt;
&lt;p&gt;从更低层次来说，主内存主要对应于硬件内存部分，工作内存主要对应于CPU的高速缓存和寄存器部分，但也不是绝对的，主内存也可能存在于高速缓存和寄存器中，工作内存也可能存在于硬件内存中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%90%8C%E6%AD%A5%E7%B3%BB%E5%88%97/resource/JMM4.png&quot; alt=&quot;JMM&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;内存间的交互操作&quot;&gt;内存间的交互操作&lt;/h2&gt;
&lt;p&gt;关于主内存与工作内存之间具体的交互协议，Java内存模型定义了以下8种具体的操作来完成：&lt;/p&gt;
&lt;p&gt;（1）lock，锁定，作用于主内存的变量，它把主内存中的变量标识为一条线程独占状态；&lt;/p&gt;
&lt;p&gt;（2）unlock，解锁，作用于主内存的变量，它把锁定的变量释放出来，释放出来的变量才可以被其它线程锁定；&lt;/p&gt;
&lt;p&gt;（3）read，读取，作用于主内存的变量，它把一个变量从主内存传输到工作内存中，以便后续的load操作使用；&lt;/p&gt;
&lt;p&gt;（4）load，载入，作用于工作内存的变量，它把read操作从主内存得到的变量放入工作内存的变量副本中；&lt;/p&gt;
&lt;p&gt;（5）use，使用，作用于工作内存的变量，它把工作内存中的一个变量传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；&lt;/p&gt;
&lt;p&gt;（6）assign，赋值，作用于工作内存的变量，它把一个从执行引擎接收到的变量赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时使用这个操作；&lt;/p&gt;
&lt;p&gt;（7）store，存储，作用于工作内存的变量，它把工作内存中一个变量的值传递到主内存中，以便后续的write操作使用；&lt;/p&gt;
&lt;p&gt;（8）write，写入，作用于主内存的变量，它把store操作从工作内存得到的变量的值放入到主内存的变量中；&lt;/p&gt;
&lt;p&gt;如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，同样地，如果要把一个变量从工作内存同步回主内存，就要按顺序地执行store和write操作。注意，这里只说明了要按顺序，并没有说一定要连续，也就是说可以在read与load之间、store与write之间插入其它操作。比如，对主内存中的变量a和b的访问，可以按照以下顺序执行：&lt;/p&gt;
&lt;p&gt;read a -&amp;gt; read b -&amp;gt; load b -&amp;gt; load a。&lt;/p&gt;
&lt;p&gt;另外，Java内存模型还定义了执行上述8种操作的基本规则：&lt;/p&gt;
&lt;p&gt;（1）不允许read和load、store和write操作之一单独出现，即不允许出现从主内存读取了而工作内存不接受，或者从工作内存回写了但主内存不接受的情况出现；&lt;/p&gt;
&lt;p&gt;（2）不允许一个线程丢弃它最近的assign操作，即变量在工作内存变化了必须把该变化同步回主内存；&lt;/p&gt;
&lt;p&gt;（3）不允许一个线程无原因地（即未发生过assign操作）把一个变量从工作内存同步回主内存；&lt;/p&gt;
&lt;p&gt;（4）一个新的变量必须在主内存中诞生，不允许工作内存中直接使用一个未被初始化（load或assign）过的变量，换句话说就是对一个变量的use和store操作之前必须执行过load和assign操作；&lt;/p&gt;
&lt;p&gt;（5）一个变量同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才能被解锁。&lt;/p&gt;
&lt;p&gt;（6）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值；&lt;/p&gt;
&lt;p&gt;（7）如果一个变量没有被lock操作锁定，则不允许对其执行unlock操作，也不允许unlock一个其它线程锁定的变量；&lt;/p&gt;
&lt;p&gt;（8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作；&lt;/p&gt;
&lt;p&gt;注意，这里的lock和unlock是实现synchronized的基础，Java并没有把lock和unlock操作直接开放给用户使用，但是却提供了两个更高层次的指令来隐式地使用这两个操作，即moniterenter和moniterexit。&lt;/p&gt;
&lt;h2 id=&quot;原子性可见性有序性&quot;&gt;原子性、可见性、有序性&lt;/h2&gt;
&lt;p&gt;Java内存模型就是为了解决多线程环境下共享变量的一致性问题，那么一致性包含哪些内容呢？&lt;/p&gt;
&lt;p&gt;一致性主要包含三大特性：原子性、可见性、有序性，下面我们就来看看Java内存模型是怎么实现这三大特性的。&lt;/p&gt;
&lt;p&gt;（1）原子性&lt;/p&gt;
&lt;p&gt;原子性是指一段操作一旦开始就会一直运行到底，中间不会被其它线程打断，这段操作可以是一个操作，也可以是多个操作。&lt;/p&gt;
&lt;p&gt;由Java内存模型来直接保证的原子性操作包括read、load、user、assign、store、write这两个操作，我们可以大致认为基本类型变量的读写是具备原子性的。&lt;/p&gt;
&lt;p&gt;如果应用需要一个更大范围的原子性，Java内存模型还提供了lock和unlock这两个操作来满足这种需求，尽管不能直接使用这两个操作，但我们可以使用它们更具体的实现synchronized来实现。&lt;/p&gt;
&lt;p&gt;因此，synchronized块之间的操作也是原子性的。&lt;/p&gt;
&lt;p&gt;（2）可见性&lt;/p&gt;
&lt;p&gt;可见性是指当一个线程修改了共享变量的值，其它线程能立即感知到这种变化。&lt;/p&gt;
&lt;p&gt;Java内存模型是通过在变更修改后同步回主内存，在变量读取前从主内存刷新变量值来实现的，它是依赖主内存的，无论是普通变量还是volatile变量都是如此。&lt;/p&gt;
&lt;p&gt;普通变量与volatile变量的主要区别是是否会在修改之后立即同步回主内存，以及是否在每次读取前立即从主内存刷新。因此我们可以说volatile变量保证了多线程环境下变量的可见性，但普通变量不能保证这一点。&lt;/p&gt;
&lt;p&gt;除了volatile之外，还有两个关键字也可以保证可见性，它们是synchronized和final。&lt;/p&gt;
&lt;p&gt;synchronized的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作”这条规则获取的。&lt;/p&gt;
&lt;p&gt;final的可见性是指被final修饰的字段在构造器中一旦被初始化完成，那么其它线程中就能看见这个final字段了。&lt;/p&gt;
&lt;p&gt;（3）有序性&lt;/p&gt;
&lt;p&gt;Java程序中天然的有序性可以总结为一句话：如果在本线程中观察，所有的操作都是有序的；如果在另一个线程中观察，所有的操作都是无序的。&lt;/p&gt;
&lt;p&gt;前半句是指线程内表现为串行的语义，后半句是指“指令重排序”现象和“工作内存和主内存同步延迟”现象。&lt;/p&gt;
&lt;p&gt;Java中提供了volatile和synchronized两个关键字来保证有序性。&lt;/p&gt;
&lt;p&gt;volatile天然就具有有序性，因为其禁止重排序。&lt;/p&gt;
&lt;p&gt;synchronized的有序性是由“一个变量同一时刻只允许一条线程对其进行lock操作”这条规则获取的。&lt;/p&gt;
&lt;h2 id=&quot;先行发生原则happens-before&quot;&gt;先行发生原则（Happens-Before）&lt;/h2&gt;
&lt;p&gt;如果Java内存模型的有序性都只依靠volatile和synchronized来完成，那么有一些操作就会变得很啰嗦，但是我们在编写Java并发代码时并没有感受到，这是因为Java语言天然定义了一个“先行发生”原则，这个原则非常重要，依靠这个原则我们可以很容易地判断在并发环境下两个操作是否可能存在竞争冲突问题。&lt;/p&gt;
&lt;p&gt;先行发生，是指操作A先行发生于操作B，那么操作A产生的影响能够被操作B感知到，这种影响包括修改了共享内存中变量的值、发送了消息、调用了方法等。&lt;/p&gt;
&lt;p&gt;下面我们看看Java内存模型定义的先行发生原则有哪些：&lt;/p&gt;
&lt;p&gt;（1）程序次序原则&lt;/p&gt;
&lt;p&gt;在一个线程内，按照程序书写的顺序执行，书写在前面的操作先行发生于书写在后面的操作，准确地讲是控制流顺序而不是代码顺序，因为要考虑分支、循环等情况。&lt;/p&gt;
&lt;p&gt;（2）监视器锁定原则&lt;/p&gt;
&lt;p&gt;一个unlock操作先行发生于后面对同一个锁的lock操作。&lt;/p&gt;
&lt;p&gt;（3）volatile原则&lt;/p&gt;
&lt;p&gt;对一个volatile变量的写操作先行发生于后面对该变量的读操作。&lt;/p&gt;
&lt;p&gt;（4）线程启动原则&lt;/p&gt;
&lt;p&gt;对线程的start()操作先行发生于线程内的任何操作。&lt;/p&gt;
&lt;p&gt;（5）线程终止原则&lt;/p&gt;
&lt;p&gt;线程中的所有操作先行发生于检测到线程终止，可以通过Thread.join()、Thread.isAlive()的返回值检测线程是否已经终止。&lt;/p&gt;
&lt;p&gt;（6）线程中断原则&lt;/p&gt;
&lt;p&gt;对线程的interrupt()的调用先行发生于线程的代码中检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否发生中断。&lt;/p&gt;
&lt;p&gt;（7）对象终结原则&lt;/p&gt;
&lt;p&gt;一个对象的初始化完成（构造方法执行结束）先行发生于它的finalize()方法的开始。&lt;/p&gt;
&lt;p&gt;（8）传递性原则&lt;/p&gt;
&lt;p&gt;如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。&lt;/p&gt;
&lt;p&gt;这里说的“先行发生”与“时间上的先发生”没有必然的关系。&lt;/p&gt;
&lt;p&gt;比如，下面的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int a = 0;

// 操作A：线程1对进行赋值操作
a = 1;

// 操作B：线程2获取a的值

int b = a;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果线程1在时间顺序上先对a进行赋值，然后线程2再获取a的值，这能说明操作A先行发生于操作B吗？&lt;/p&gt;
&lt;p&gt;显然不能，因为线程2可能读取的还是其工作内存中的值，或者说线程1并没有把a的值刷新回主内存呢，这时候线程2读取到的值可能还是0。&lt;/p&gt;
&lt;p&gt;所以，“时间上的先发生”不一定“先行发生”。&lt;/p&gt;
&lt;p&gt;再看一个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 同一个线程中
int i = 1;

int j = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据第一条程序次序原则，&lt;code&gt;int i = 1;&lt;/code&gt;先行发生于&lt;code&gt;int j = 2;&lt;/code&gt;，但是由于处理器优化，可能导致&lt;code&gt;int j = 2;&lt;/code&gt;先执行，但是这并不影响先行发生原则的正确性，因为我们在这个线程中并不会感知到这点。&lt;/p&gt;
&lt;p&gt;所以，“先行发生”不一定“时间上先发生”。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）硬件内存架构使得我们必须建立内存模型来保证多线程环境下对共享内存访问的正确性；&lt;/p&gt;
&lt;p&gt;（2）Java内存模型定义了保证多线程环境下共享变量一致性的规则；&lt;/p&gt;
&lt;p&gt;（3）Java内存模型提供了工作内存与主内存交互的8大操作：lock、unlock、read、load、use、assign、store、write；&lt;/p&gt;
&lt;p&gt;（4）Java内存模型对原子性、可见性、有序性提供了一些实现；&lt;/p&gt;
&lt;p&gt;（5）先行发生的8大原则：程序次序原则、监视器锁定原则、volatile原则、线程启动原则、线程终止原则、线程中断原则、对象终结原则、传递性原则；&lt;/p&gt;
&lt;p&gt;（6）先行发生不等于时间上的先发生；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;Java内存模型是Java中很重要的概念，理解它非常有助于我们编写多线程代码，理解多线程的本质，笔者这里整理了一些不错的资料提供给大家。&lt;/p&gt;
&lt;p&gt;《深入理解Java虚拟机》&lt;/p&gt;
&lt;p&gt;《Java并发编程的艺术》&lt;/p&gt;
&lt;p&gt;《深入理解java内存模型》&lt;/p&gt;
&lt;p&gt;关注我的公众号“彤哥读源码”回复“JMM”领取上面三本书籍。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章,与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 17:44:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>硬件内存架构？ Java内存模型？ 内存间交互的操作有哪些？ 原子性、可见性、有序性？ 先行发生原则有哪些？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/10884421.html</dc:identifier>
</item>
<item>
<title>黑科技抢先尝(续) - Windows terminal中WSL Linux 终端的极简美化指南 - dotNET匠人</title>
<link>http://www.cnblogs.com/enjoy233/p/simple_guide_to_WSL_terminals_in_Windows_Terminal.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoy233/p/simple_guide_to_WSL_terminals_in_Windows_Terminal.html</guid>
<description>&lt;p&gt;之前，本人写了一篇文章 &lt;a href=&quot;https://www.cnblogs.com/enjoy233/p/awesome_windows_terminal_build_and_trial.html&quot;&gt;黑科技抢先尝 - Windows全新终端初体验(附无需编译就能安装的Preview版本及代码Build全过程&lt;/a&gt;，介绍了玩转Windows terminal的两种方式。&lt;/p&gt;
&lt;p&gt;今天这篇文章，主要介绍如何美化 Windows terminal 中 WSL 的 Linux 终端，依然是以本人最熟悉的&lt;code&gt;Ubuntu&lt;/code&gt;为例，其他版本的 Linux 请参考本文的流程换用对应的命令。假定你已按我的上一篇文章已安装好 Windows terminal预编译版本，同时安装好了 Ubuntu，并设置号了 &lt;code&gt;WSL&lt;/code&gt;的权限，然后就可以按本文继续操作了。&lt;/p&gt;
&lt;h2 id=&quot;修改默认源为apt-get安装提速&quot;&gt;修改默认源，为apt-get安装提速&lt;/h2&gt;
&lt;p&gt;由于 &lt;code&gt;Ubuntu&lt;/code&gt;官方的源实在是太慢了，建议大家缓存阿里云镜像的 Ubuntu 源，其具体操作步骤如下：&lt;/p&gt;
&lt;p&gt;首先将原配置文件备份&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo cp /etc/apt/sources.list /etc/apt/sources.list.20190516&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后 vim 打开&lt;code&gt;sources.list&lt;/code&gt;,&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo vim /etc/apt/sources.list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;(插入)模式下，在末尾输入依次输入每一行进行替换:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;:%s/security.ubuntu/mirrors.aliyun/g
:%s/archive.ubuntu/mirrors.aliyun/g&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每输入一行，回车一次，然后就替换好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更新源:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt update; sudo apt upgrade&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装python-和-python-pip&quot;&gt;安装python 和 python pip&lt;/h2&gt;
&lt;p&gt;依次输入如下命令:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt-get install python3
sudo apt-get install build-essential
sudo apt-get install python-pip
pip install --upgrade pip&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装-zsh&quot;&gt;安装 zsh&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt-get install zsh&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装powerline-font中的特定字体&quot;&gt;安装powerline-font中的特定字体&lt;/h2&gt;
&lt;p&gt;从&lt;a href=&quot;https://github.com/yanglr/WindowsDevTools/tree/master/awosomeTerminal/fonts-Ubuntu&quot;&gt;github&lt;/a&gt;下载字体&quot;DejaVu Sans Mono for Powerline&quot;，并安装。安装字体时，选择对应的哪一个ttf后缀的安装即可。&lt;/p&gt;
&lt;p&gt;手动安装字体&quot;Fira code&quot; 或 &quot;DejaVu Sans Mono for Powerline&quot;&lt;/p&gt;
&lt;p&gt;然后在命令行应用之，具体操作是在profiles.json中把字体设置成它，即可生效。&lt;/p&gt;
&lt;p&gt;powerline/fonts: Patched fonts for Powerline users.&lt;br/&gt;&lt;a href=&quot;https://github.com/powerline/fonts&quot; class=&quot;uri&quot;&gt;https://github.com/powerline/fonts&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装powerline-shell&quot;&gt;安装powerline-shell&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd ~
mkdir src
cd src
git clone https://github.com/b-ryan/powerline-shell
cd powerline-shell
sudo python setup.py install&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改目录下的配置文件-.bashrc-和-.zshrc&quot;&gt;修改~目录下的配置文件 .bashrc 和 .zshrc&lt;/h2&gt;
&lt;p&gt;首先，插入一点背景知识:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ps1格式简介：&lt;/strong&gt;&lt;br/&gt;shell有四种不同的命令提示，称为PS1，PS2，PS3和PS4。 PS代表Prompt String。Windows/Linux/Ubuntu都用得比较多的是PS1脚本。&lt;/p&gt;
&lt;p&gt;&quot;$PS1&quot;, &quot;Prompt String 1&quot; 指定命令行界面中的环境变量。&lt;/p&gt;
&lt;p&gt;先编辑文件 &lt;code&gt;.zshrc&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;vim ~/.zshrc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在末尾加入内容:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;function powerline_precmd() {

    PS1=&quot;(powerline-shell --shell zsh ?)&quot;

}

 

function install_powerline_precmd() {

  for s in &quot;${precmd_functions[@]}&quot;; do

    if [ &quot;$s&quot; = &quot;powerline_precmd&quot; ]; then

      return

    fi

  done

  precmd_functions+=(powerline_precmd)

}
 

if [ &quot;$TERM&quot; != &quot;linux&quot; ]; then

    install_powerline_precmd

fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑完后更新文件 &lt;code&gt;.zshrc&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;source ~/.zshrc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再编辑文件&lt;code&gt;.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;vim ~/.bashrc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在末尾加入内容:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;function _update_ps1() {

    PS1=&quot;(powerline-shell ?)&quot;

}

 

if [ &quot;$TERM&quot; != &quot;linux&quot; ]; then

    PROMPT_COMMAND=&quot;_update_ps1; $PROMPT_COMMAND&quot;

fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑完后更新文件 &lt;code&gt;.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;source ~/.bashrc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我随便输入几个命令:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo su
ls&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时Windows terminal中的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518025115846-1068002612.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我直接就使用这个默认主题了。&lt;/p&gt;
&lt;p&gt;那么，如果要在命令提示符中插入emoji表情，怎么弄呢？就在下图相应的地方(对应文件 &lt;code&gt;.bashrc&lt;/code&gt;)加~&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518013926229-1636878313.png&quot; alt=&quot;emoji-prompt&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时的 terminal 为:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518014400599-1258964235.png&quot; alt=&quot;vim-addEmoji&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更有意思的玩法可以参考:&lt;br/&gt;&lt;a href=&quot;https://loige.co/random-emoji-in-your-prompt-how-and-why/&quot; class=&quot;uri&quot;&gt;https://loige.co/random-emoji-in-your-prompt-how-and-why/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;zsh主题定制&quot;&gt;zsh主题定制&lt;/h2&gt;
&lt;p&gt;此外，如果想更深入地定制&lt;code&gt;zsh&lt;/code&gt;主题，推荐安装&lt;code&gt;oh_my_zsh&lt;/code&gt;，下面详细介绍。&lt;/p&gt;
&lt;h2 id=&quot;安装-oh_my_zsh&quot;&gt;安装 oh_my_zsh&lt;/h2&gt;
&lt;p&gt;Linux下安装&lt;code&gt;oh-my-zsh&lt;/code&gt;，需要在终端输入命令:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 遇到证书类似问题&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;apt-get install ca-certificates&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决权限问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果启动时会出现&lt;code&gt;zsh-syntax-highlighting&lt;/code&gt;权限问题，运行下面的命令即可：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;compaudit | xargs chmod g-w,o-w&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;卸载&lt;code&gt;oh_my_zsh&lt;/code&gt;的方法&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;uninstall_oh_my_zsh&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;从-windows-10-的-bash-中运行-wsl&quot;&gt;从 Windows 10 的 Bash 中运行 WSL&lt;/h2&gt;
&lt;p&gt;对于windows 10中 &lt;code&gt;WSL&lt;/code&gt; 独立的默认Bash窗口，只能选择字体&quot;DejaVu Sans Mono for Powerline&quot;，可以在界面上选择后使用。&lt;br/&gt;开始菜单中搜索 bash 并打开，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518024307461-934415003.png&quot; alt=&quot;bash&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右键 属性-&amp;gt; 字体，选字体&quot;DejaVu Sans Mono for Powerline&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518022156762-2034582728.png&quot; alt=&quot;font&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后的运行结果是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518023622078-1538515723.png&quot; alt=&quot;bash&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scott Hanselman:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请注意我在 prompt 中也使用了&lt;a href=&quot;https://github.com/b-ryan/powerline-shell&quot;&gt;Powerline&lt;/a&gt; 。 我正在使用&lt;a href=&quot;https://www.hanselman.com/blog/MonospacedProgrammingFontsWithLigatures.aspx&quot;&gt;Fira Code&lt;/a&gt; ，它含有我需要的glyphs，但你当然也可以使用&lt;a href=&quot;https://github.com/powerline/fonts&quot;&gt;改进过的Powerline字体&lt;/a&gt;或使用像&lt;a href=&quot;https://github.com/ryanoasis/nerd-fonts&quot;&gt;Nerd Fonts&lt;/a&gt;和&lt;a href=&quot;https://github.com/ryanoasis/nerd-fonts&quot;&gt;它的字体补丁程序&lt;/a&gt;那样的工具制作&lt;a href=&quot;https://github.com/ryanoasis/nerd-fonts&quot;&gt;自己的字体&lt;/a&gt; 。 此字体补丁程序通常用于获取你最喜欢的等宽字体，并为其添加Powerline glyphs。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果您看到字形有任何奇怪的间距问题，您可以尝试使用&lt;code&gt;--use-single-width-glyphs&lt;/code&gt;来解决它。 通过发布，我认为所有这些小问题都将得到解决。 在我的终端环境下使用&lt;code&gt;Fira Code&lt;/code&gt;没有任何问题，您的环境可能有所不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改 WSL Ubuntu 18.04 默认源为阿里云镜像 - Windows - 大象笔记&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sunzhongwei.com/modify-the-wsl-ubuntu-1804-default-source-for-ali-cloud-images&quot; class=&quot;uri&quot;&gt;https://www.sunzhongwei.com/modify-the-wsl-ubuntu-1804-default-source-for-ali-cloud-images&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;b-ryan/powerline-shell: A beautiful and useful prompt for your shell&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/b-ryan/powerline-shell&quot; class=&quot;uri&quot;&gt;https://github.com/b-ryan/powerline-shell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;How to Install Powerline Fonts, Symbols for Bash on Windows 10 - The Customize Windows&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://thecustomizewindows.com/2018/01/install-powerline-fonts-symbols-bash-windows-10/&quot; class=&quot;uri&quot;&gt;https://thecustomizewindows.com/2018/01/install-powerline-fonts-symbols-bash-windows-10/&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;br/&gt;&lt;strong&gt;敲黑板&lt;/strong&gt;：更多干货可关注 公号「dotNET匠人」，持续输出优质的技术文章~</description>
<pubDate>Fri, 17 May 2019 17:41:00 +0000</pubDate>
<dc:creator>dotNET匠人</dc:creator>
<og:description>今天这篇文章，主要介绍如何美化 Windows terminal 中 WSL 的 Linux 终端，依然是以本人最熟悉的`Ubuntu`为例，其他版本的 Linux 请参考本文的流程换用对应的命令。假</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoy233/p/simple_guide_to_WSL_terminals_in_Windows_Terminal.html</dc:identifier>
</item>
<item>
<title>hibernate详解一 - 子爵号</title>
<link>http://www.cnblogs.com/dsj-66/p/10884359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dsj-66/p/10884359.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;hibernate介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;hibernate是一个开源的轻量级的框架，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;hibernate框架应用在javaee三层结构中的dao层框架，在dao层对数据库进行crud操作，使用hibernate框架实现crud操作；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;hibernate底层就是jdbc,hibernate对jdbc进行了封装；使用hibernate的好处，不必再写复杂的jdbc代码了，不需要写sql语句实现了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;hibernate使用orm思想对数据库进行crud操作，orm即对象关系映射&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;orm解释：让实体类和数据库表进行一 一对应关系，让实体类首先和数据库表进行对应，再让实体类属性和表字段进行对应。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;不需要直接操作数据库表，而是操作数据库表对应的实体类对象。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190517233543776-233433669.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;一导入hibernate相关jar包，这是我java项目里的jar包&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190517234114259-1031996853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 二 创建实体类，使用hibernate的时候不用我们自己创建表，由hibernate自动创建&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190517234410775-1530079707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 三 配置实体类和数据库表的一 一对应关系，使用xml配置文件映射关系，映射文件名称和位置没有特定要求，建议和实体类在同一包下，实体类名称.hbm.xml&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190517235643418-266035764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四 创建hibernate的核心配置文件，核心配置文件的名称和位置都是固定的，位置在src下，名称是 hibernate.cfg.xml&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190518000224574-1855939863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190518000316270-1342554835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;hibernate工具类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190518001203642-1082277424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190518001240197-294239510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;hibernate测试，运行完成后会自动在数据库中创建对应的表，并保存一条数据&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190518001735641-1357937021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1649429/201905/1649429-20190518002017637-1609669459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;session介绍（重点）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;session类似于jdbc中的connection连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用session里面的不同方法来实现crud操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;session对象是单线程对象，不能公用，只能自己使用，所以上面使用了与本地线程绑定的session&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 16:31:00 +0000</pubDate>
<dc:creator>子爵号</dc:creator>
<og:description>hibernate介绍 hibernate是一个开源的轻量级的框架， hibernate框架应用在javaee三层结构中的dao层框架，在dao层对数据库进行crud操作，使用hibernate框架实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dsj-66/p/10884359.html</dc:identifier>
</item>
<item>
<title>PJzhang：经典子域名爆破工具subdomainsbrute - PJzhang白话安全</title>
<link>http://www.cnblogs.com/landesk/p/10884000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/landesk/p/10884000.html</guid>
<description>&lt;p&gt;&lt;span&gt;猫宁！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.waitalone.cn/subdomainsbrute.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.secpulse.com/archives/5900.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多人知道子域名挖掘机，不过我最早使用的子域名爆破工具是lijiejie的subdomainsbrute，简单容易上手，而且字典符合中国人习惯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一次更新已经是2018.02.06的事情了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;github地址：https://github.com/lijiejie/subDomainsBrute&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我用的操作系统是kali linux&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先下载到本地再说&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;git clone https://github.com/lijiejie/subDomainsBrute.git&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cd /root/subDomainsBrute&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行python脚本，作者采用的python2，作者说需要pip install gevent dnspython，2个python模块，不过我的电脑已经安装好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python subDomainsBrute.py&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显示基础命令项：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190517223949793-904429754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看这个工具的版本，现在已经是1.1版本了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python subDomainsBrute.py --version&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显示帮助文件内容，和执行python subDomainsBrute.py没区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;python subDomainsBrute.py&lt;/span&gt;  -h&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;爆破子域名，采用默认字典subnames.txt，这个字典有15374个关键词，爆破出870个子域名，花费时间5-6分钟左右。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时爆破出来的子域名中还有一些三级域名，例如app.news.baidu.com，这就是为什么爆破次数为129583次了，进行了循环爆破。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python subDomainsBrute.py baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190517225329121-256261885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;爆破结束以后，会生成一份txt文档，里面除了公网域名，还有很多的内网域名可以看到，私有dns和公有dns共用的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里用到2家公共dns服务器，阿里的223.6.6.6，223.5.5.5，腾讯的119.29.29.29 ，182.254.116.116。txt文档域名后面对应的是解析的IP，ip可以扫描端口，也可以使用nessus进行扫描，发现其他有价值的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190517230324954-1033377466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面自动生成的文档，名字是baidu.com.txt，名称是可以自定义的，如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python subDomainsBrute.py baidu.com -o baidu.txt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里默认的进程是6，默认的线程是200，都是可以调整的，线程是最小的执行单元，进程中至少包含1个线程，这里把进程设置为1会好些，线程开的过高也会有更高的误报。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python subDomainsBrute.py -p 1 -t 200 baidu.com  -o baidu.txt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成的结果txt文档中，有很多的内网ip，如果想要忽视掉，可以这样，加一个-i就好，域名对应的ip是内网的会被清除掉，结果只发现692个子域名，花费时间7-8分钟。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python subDomainsBrute.py -p 1 -t 200 -i baidu.com  -o baidu.txt&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190517234633555-1895416072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;字典是子域名爆破中非常关键的一个环节，字典也是可以自定义的，作者提供了一份清单，dns_servers.txt是dns服务器的ip，sample_qq.com.txt是针对腾讯的爆破结果样例展示，subnames_all_5_letters.txt表示的是最多到4级域名，如a.aa.aaa.baidu.com，如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{alphnum}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{alphnum}{alphnum}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{alphnum}{alphnum}{alphnum}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{alphnum}{alphnum}{alphnum}{alphnum}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{alphnum}{alphnum}{alphnum}{alphnum}{alphnum}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190517233811071-280375006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果采用大字典subnames_full.txt，爆破三级及以上域名采用next_sub_full.txt字典，无疑需要花费更多的时间，如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python subDomainsBrute.py -p 1 -t 200 -i --full baidu.com  -o baidu.txt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-f的功能是首先调用next_sub.txt进行子域名爆破，工具会自动调用next_sub.txt进行深入轮循爆破，-f引用的字典名字也可以自定义的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python subDomainsBrute.py -f next_sub.txt baidu.com -o baidu.txt&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190518000706512-720427612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果发现比较好的关键词，也可以向里面的字典中进行添加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lijiejie的子域名爆破工具实用性很强，对于里面的细节使用不能浅尝辄止，如果只是python subDomainsBrute.py baidu.com -o baidu.txt就算完了，对自己的子域名收集和深入了解信息收集会是阻碍。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 17 May 2019 16:25:00 +0000</pubDate>
<dc:creator>PJzhang白话安全</dc:creator>
<og:description>猫宁！！！ 参考链接： https://www.waitalone.cn/subdomainsbrute.html https://www.secpulse.com/archives/5900.htm</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/landesk/p/10884000.html</dc:identifier>
</item>
<item>
<title>记微软OpenHack机器学习挑战赛 - 可健康了</title>
<link>http://www.cnblogs.com/easymind223/p/10884332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/easymind223/p/10884332.html</guid>
<description>&lt;p&gt;　　有幸参加了微软OpenHack挑战赛，虽然题目难度不大，但是很有意思，学到了很多东西，还有幸认识了微软梁健老师，谢谢您的帮助！同时还认识同行的很多朋友，非常高兴，把这段难忘的比赛记录一下~~也分享一下代码，给那些没有参加的朋友，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据集(文末链接)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先每支队伍会收到一个数据集，它是一个登山公司提供的装备图片，有登山镐，鞋子，登山扣，不知道叫什么的雪地爪？手套，冲锋衣，安全带。。。一共12个类别，每个类别几百个样本，&lt;/span&gt;&lt;span&gt;我们的任务就是对这些图片分类和识别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单看一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423745/201905/423745-20190517224838794-1420071222.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;378&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;赛题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;赛题共有6道，简单描述一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、搭建环境(略过)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、图像正规化(包括颜色和大小)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、通过机器学习方法对图像分类，precision&amp;gt;0.8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、通过深度学习方法对图像分类，precision&amp;gt;0.9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、部署(略过)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、目标检测(用全新的数据集，检测雪地中的登山者是否带头盔！！航拍图像，有点难度~)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;_______________________________________&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面是每道题目的详细描述和代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;题目2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完成以下任务:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择一种基本颜色，例如白色并填充所有图片尺寸不是1:1比例的图像&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;不通过直接拉伸的方式，重塑至128x128x3像素的阵列形状&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;确保每个图像的像素范围从0到255(包含或[0,255])，也称为“对比度拉伸”(contrast stretching).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标准化或均衡以确保像素在[0,255]范围内.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成功完成的标准&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;团队将在Jupyter Notebook中运行一个代码单元，绘制原始图像，然后绘制填充后的像素值归一化或均衡图像, 展示给教练看.&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;团队将在Jupyter notebook 为教练运行一个代码单元，显示的像素值的直方图应该在0到255的范围内（包括0和255）.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c90160f9-4374-42da-80d4-d402f8b4a274')&quot; readability=&quot;65.5&quot;&gt;&lt;img id=&quot;code_img_closed_c90160f9-4374-42da-80d4-d402f8b4a274&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c90160f9-4374-42da-80d4-d402f8b4a274&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c90160f9-4374-42da-80d4-d402f8b4a274',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c90160f9-4374-42da-80d4-d402f8b4a274&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;126&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; normalize(src):
    arr &lt;/span&gt;=&lt;span&gt; array(src)
    arr &lt;/span&gt;= arr.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Do not touch the alpha channel&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
        minval &lt;/span&gt;=&lt;span&gt; arr[...,i].min()
        maxval &lt;/span&gt;=&lt;span&gt; arr[...,i].max()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; minval !=&lt;span&gt; maxval:
            arr[...,i] &lt;/span&gt;-=&lt;span&gt; minval
            arr[...,i] &lt;/span&gt;*= (255.0/(maxval-&lt;span&gt;minval))
    arr &lt;/span&gt;=&lt;span&gt; arr.astype(uint8)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Image.fromarray(arr,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageColor 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib.pyplot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; imshow
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pylab &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy

plt.figure(figsize&lt;/span&gt;=(10,10)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置窗口大小&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; src = Image.open(&quot;100974.jpeg&quot;)&lt;/span&gt;
src = Image.open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rose.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

src_array &lt;/span&gt;=&lt;span&gt; array(src)
plt.subplot(&lt;/span&gt;2,2,1), plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.imshow(src), plt.axis(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


ar&lt;/span&gt;=&lt;span&gt;src_array[:,:,0].flatten()
ag&lt;/span&gt;=src_array[:,:,1&lt;span&gt;].flatten()
ab&lt;/span&gt;=src_array[:,:,2&lt;span&gt;].flatten()
plt.subplot(&lt;/span&gt;2,2,2),  plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;src hist&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.axis([0,&lt;/span&gt;255,0,0.03&lt;span&gt;])
plt.hist(ar, bins&lt;/span&gt;=256, normed=1,facecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,hold=1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原始图像直方图&lt;/span&gt;
plt.hist(ag, bins=256, normed=1,facecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,hold=1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原始图像直方图&lt;/span&gt;
plt.hist(ab, bins=256, normed=1,facecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原g始图像直方图&lt;/span&gt;
&lt;span&gt;

dst &lt;/span&gt;=&lt;span&gt; normalize(src)
dst_array &lt;/span&gt;=&lt;span&gt; array(dst)

plt.subplot(&lt;/span&gt;2,2,3), plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dst&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.imshow(dst), plt.axis(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

ar&lt;/span&gt;=&lt;span&gt;dst_array[:,:,0].flatten()
ag&lt;/span&gt;=dst_array[:,:,1&lt;span&gt;].flatten()
ab&lt;/span&gt;=dst_array[:,:,2&lt;span&gt;].flatten()
plt.subplot(&lt;/span&gt;2,2,4),  plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dst hist&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.axis([0,&lt;/span&gt;255,0,0.03&lt;span&gt;])
plt.hist(ar, bins&lt;/span&gt;=256, normed=1,facecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,hold=1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原始图像直方图&lt;/span&gt;
plt.hist(ag, bins=256, normed=1,facecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,hold=1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原始图像直方图&lt;/span&gt;
plt.hist(ab, bins=256, normed=1,facecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,edgecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原g始图像直方图&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423745/201905/423745-20190517230550205-2036407420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题目3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用一个非参数化分类方法(参考 参考文档)来创建一个模型，预测新的户外装备图像的分类情况，训练来自挑战2的预处理过的128x128x3的装备图像。所使用的算法可以从scikit-learn库中挑选现有的非参数化算法来做分类。向教练展示所提供的测试数据集的精确度，并且精确度分数需要超过80%。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0565b50a-350c-43dc-b0fa-c5668228b3f3')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_0565b50a-350c-43dc-b0fa-c5668228b3f3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0565b50a-350c-43dc-b0fa-c5668228b3f3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0565b50a-350c-43dc-b0fa-c5668228b3f3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0565b50a-350c-43dc-b0fa-c5668228b3f3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
dir_data =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data/preprocess_images/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

equipments &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;boots&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;carabiners&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;crampons&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gloves&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hardshell_jackets&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;harnesses&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;helmets&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
              &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;insulated_jackets&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pulleys&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rope&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tents&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
train_data &lt;/span&gt;=&lt;span&gt; [] 
y &lt;/span&gt;=&lt;span&gt; [] 

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; equip_name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; equipments:
    dir_equip &lt;/span&gt;= dir_data +&lt;span&gt; equip_name
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; filename &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.listdir(dir_equip):             
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(filename.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jpeg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)!=-1&lt;span&gt;):
            name &lt;/span&gt;= dir_equip + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; filename
            img &lt;/span&gt;= Image.open(name).convert(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            train_data.append(list(img.getdata()))
            y.append(equip_name)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('247aff28-f048-4c40-a008-bea348b7493f')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_247aff28-f048-4c40-a008-bea348b7493f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_247aff28-f048-4c40-a008-bea348b7493f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('247aff28-f048-4c40-a008-bea348b7493f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_247aff28-f048-4c40-a008-bea348b7493f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; svm
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.cross_validation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split  

train_X,test_X, train_y, test_y &lt;/span&gt;= train_test_split(train_data, y, test_size = 0.3, random_state =&lt;span&gt; 0)

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; neighbors 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; precision_recall_fscore_support as score
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; precision_score,recall_score

clf_knn &lt;/span&gt;= neighbors.KNeighborsClassifier(algorithm=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kd_tree&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
clf_knn.fit(train_X, train_y)
y_pred &lt;/span&gt;= clf_knn.predict(test_X)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c2ab156c-a49c-48ea-ae14-3fef2c026e67')&quot; readability=&quot;48.5&quot;&gt;&lt;img id=&quot;code_img_closed_c2ab156c-a49c-48ea-ae14-3fef2c026e67&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c2ab156c-a49c-48ea-ae14-3fef2c026e67&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c2ab156c-a49c-48ea-ae14-3fef2c026e67',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c2ab156c-a49c-48ea-ae14-3fef2c026e67&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;92&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; itertools
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; svm, datasets
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; confusion_matrix

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; plot_confusion_matrix(cm, classes,
                          
                          normalize&lt;/span&gt;=&lt;span&gt;False,
                          title&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Confusion matrix&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                          cmap&lt;/span&gt;=&lt;span&gt;plt.cm.Blues):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; normalize:
        cm &lt;/span&gt;= cm.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) / cm.sum(axis=1&lt;span&gt;)[:, np.newaxis]
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Normalized confusion matrix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Confusion matrix, without normalization&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(cm)

    plt.imshow(cm, interpolation&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nearest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, cmap=&lt;span&gt;cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks &lt;/span&gt;=&lt;span&gt; np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation&lt;/span&gt;=45&lt;span&gt;)
    plt.yticks(tick_marks, classes)

    fmt &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.2f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; normalize &lt;span&gt;else&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    thresh &lt;/span&gt;= cm.max() / 2&lt;span&gt;.
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; itertools.product(range(cm.shape[0]), range(cm.shape[1&lt;span&gt;])):
        plt.text(j, i, format(cm[i, j], fmt),
                 horizontalalignment&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                 color&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; cm[i, j] &amp;gt; thresh &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    plt.tight_layout()
    plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Predicted label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Compute confusion matrix&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; cnf_matrix = confusion_matrix(y_test, y_pred)&lt;/span&gt;
np.set_printoptions(precision=2&lt;span&gt;)
confusion_mat &lt;/span&gt;= confusion_matrix(test_y, y_pred, labels =&lt;span&gt; equipments)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Plot non-normalized confusion matrix&lt;/span&gt;
plt.figure(figsize=(10,10&lt;span&gt;))
plot_confusion_matrix(confusion_mat, classes&lt;/span&gt;=&lt;span&gt;equipments,
                      title&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Confusion matrix, without normalization&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Plot normalized confusion matrix&lt;/span&gt;
plt.figure(figsize=(10,10&lt;span&gt;))

plot_confusion_matrix(confusion_mat, classes&lt;/span&gt;=equipments, normalize=&lt;span&gt;True,
                      title&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Normalized confusion matrix&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　因为要求精确度&amp;gt;0.8，sklearn中的很多算法应该都能满足，我选择了准确度比较高的KNN来建模，应该足够用了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423745/201905/423745-20190517231154612-798626361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 算一下presion和recall，轻松超越0.8&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423745/201905/423745-20190517231205371-1317652782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题目4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挑战完成标准，使用深度学习模型，如CNN分析复杂数据&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;团队将在Jupyter Notebook上为教练运行一个代码单元，展示模型的准确度为90％或更高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;准确度如果要&amp;gt;0.9，sklearn中的机器学习算法就很难达到了，关键时刻只能上CNN&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0f602230-a694-4497-bb4f-1e2a3b96451f')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_0f602230-a694-4497-bb4f-1e2a3b96451f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0f602230-a694-4497-bb4f-1e2a3b96451f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0f602230-a694-4497-bb4f-1e2a3b96451f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0f602230-a694-4497-bb4f-1e2a3b96451f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageColor 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib.pyplot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; imshow
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pylab &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;
dir_data &lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data/preprocess_images/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

equipments &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;boots&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;carabiners&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;crampons&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gloves&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hardshell_jackets&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;harnesses&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;helmets&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
              &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;insulated_jackets&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pulleys&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rope&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tents&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
train_data &lt;/span&gt;=&lt;span&gt; [] 
y &lt;/span&gt;=&lt;span&gt; [] 

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image
i&lt;/span&gt;=&lt;span&gt;0
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; equip_name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; equipments:
    dir_equip &lt;/span&gt;= dir_data +&lt;span&gt; equip_name
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; filename &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.listdir(dir_equip):             
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(filename.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jpeg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)!=-1&lt;span&gt;):
            name &lt;/span&gt;= dir_equip + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; filename
            img &lt;/span&gt;= Image.open(name).convert(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            train_data.append(array(img).tolist())
            y.append(i)
    i &lt;/span&gt;+= 1&lt;span&gt;
train_data &lt;/span&gt;= np.asarray(train_data)  
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a27af073-2b1e-4082-a647-ea632052efe3')&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_a27af073-2b1e-4082-a647-ea632052efe3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a27af073-2b1e-4082-a647-ea632052efe3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a27af073-2b1e-4082-a647-ea632052efe3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a27af073-2b1e-4082-a647-ea632052efe3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; svm
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.cross_validation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split  
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras
num_classes&lt;/span&gt;=12&lt;span&gt;
img_rows&lt;/span&gt;=128&lt;span&gt;
img_cols&lt;/span&gt;=128&lt;span&gt;
train_X, test_X, train_y, test_y &lt;/span&gt;= train_test_split(train_data, y, test_size = 0.3, random_state =&lt;span&gt; 0)

train_X &lt;/span&gt;= train_X.reshape(train_X.shape[0], img_rows, img_cols, 1&lt;span&gt;)
test_X &lt;/span&gt;= test_X.reshape(test_X.shape[0], img_rows, img_cols, 1&lt;span&gt;)
    
train_X &lt;/span&gt;= train_X.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
test_X &lt;/span&gt;= test_X.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
train_X &lt;/span&gt;/= 255&lt;span&gt;
test_X &lt;/span&gt;/= 255
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x_train shape:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, train_X.shape)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(train_X.shape[0], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;train samples&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(test_X.shape[0], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test samples&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; convert class vectors to binary class matrices&lt;/span&gt;
train_y =&lt;span&gt; keras.utils.to_categorical(train_y, num_classes)
test_y &lt;/span&gt;= keras.utils.to_categorical(test_y, num_classes)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b9ebdd1c-b94b-40ec-b3e8-548ce820a3e7')&quot; readability=&quot;48&quot;&gt;&lt;img id=&quot;code_img_closed_b9ebdd1c-b94b-40ec-b3e8-548ce820a3e7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b9ebdd1c-b94b-40ec-b3e8-548ce820a3e7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b9ebdd1c-b94b-40ec-b3e8-548ce820a3e7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b9ebdd1c-b94b-40ec-b3e8-548ce820a3e7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dense, Activation, Convolution2D, MaxPooling2D, Flatten
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Sequential
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Convolution2D,MaxPooling2D, Conv2D
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras

model &lt;/span&gt;=&lt;span&gt; Sequential()
model.add(Conv2D(&lt;/span&gt;32, kernel_size=(3, 3&lt;span&gt;),
                 activation&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                 input_shape&lt;/span&gt;=(128, 128, 1&lt;span&gt;)))
model.add(MaxPooling2D(pool_size&lt;/span&gt;=(2, 2&lt;span&gt;)))
model.add(Conv2D(&lt;/span&gt;64, (3, 3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
model.add(MaxPooling2D(pool_size&lt;/span&gt;=(2, 2&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; model.add(Dropout(0.25))&lt;/span&gt;
&lt;span&gt;model.add(Flatten())
model.add(Dense(&lt;/span&gt;128, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; model.add(Dropout(0.5))&lt;/span&gt;
model.add(Dense(12, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

model.compile(loss&lt;/span&gt;=&lt;span&gt;keras.losses.categorical_crossentropy,
              optimizer&lt;/span&gt;=&lt;span&gt;keras.optimizers.Adadelta(),
              metrics&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

model.fit(train_X, train_y,
          batch_size&lt;/span&gt;=128&lt;span&gt;,
          epochs&lt;/span&gt;=50&lt;span&gt;,
          verbose&lt;/span&gt;=1&lt;span&gt;,
          validation_data&lt;/span&gt;=&lt;span&gt;(test_X, test_y))
score &lt;/span&gt;= model.evaluate(test_X, test_y, verbose=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test loss:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, score[0])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test accuracy:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, score[1])
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;CNN的混淆矩阵比KNN的好了不少&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423745/201905/423745-20190517232142616-2054279769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 训练了好多次，不断调整各个卷积层和参数，终于达到了一个比较好的效果~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423745/201905/423745-20190517232301939-1775984758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题目6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用深度学习框架，基于一个常用的模型，比如Faster R-CNN，训练一个目标检测的模型。这个模型需要能够检测并且使用方框框出图片中出现的每一个头盔。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这道题目首先要自己标注样本，几百张图像标注完累的半死。。。这里我们使用VOTT来标注，它会自动生成一个样本描述文件，很方便。Faster R-CNN的程序我们参考了git上的一个红细胞检测的项目，&lt;a href=&quot;https://github.com/THULiusj/CosmicadDetection-Keras-Tensorflow-FasterRCNN&quot;&gt;https://github.com/THULiusj/CosmicadDetection-Keras-Tensorflow-FasterRCNN&lt;/a&gt;，代码非常多就不贴了&lt;/p&gt;
&lt;p&gt;最后来一张效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423745/201905/423745-20190517233941860-313002606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文数据集和VOTT工具 链接：&lt;/p&gt;
&lt;p&gt;https://pan.baidu.com/s/1FFw0PLJrrOhwR6J1HexPJA   &lt;/p&gt;
&lt;p&gt;提取码 s242&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 16:16:00 +0000</pubDate>
<dc:creator>可健康了</dc:creator>
<og:description>有幸参加了微软OpenHack挑战赛，虽然题目难度不大，但是很有意思，学到了很多东西，还有幸认识了微软梁健老师，谢谢您的帮助！同时还认识同行的很多朋友，非常高兴，把这段难忘的比赛记录一下~~也分享一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/easymind223/p/10884332.html</dc:identifier>
</item>
<item>
<title>MySQL 常用操作 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/mysql_most_used_actions.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/mysql_most_used_actions.html</guid>
<description>&lt;p&gt;如果是本地开发，使用 GUI 工具比如官方的 &lt;a href=&quot;https://www.mysql.com/products/workbench/&quot; rel=&quot;nofollow&quot;&gt;MySQL Workbench&lt;/a&gt; 会省事很多，但命令行方式在服务器环境特别有用。&lt;/p&gt;
&lt;p&gt;另，如果官方的下载地址很慢的话，可尝试这个&lt;a href=&quot;http://www.mirrorservice.org/sites/ftp.mysql.com/Downloads/MySQLGUITools/&quot; rel=&quot;nofollow&quot;&gt;镜像&lt;/a&gt;，速度超快的。&lt;/p&gt;
&lt;h2&gt;数据库&lt;/h2&gt;
&lt;h3&gt;创建数据库&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
CREATE DATABASE &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;db_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除数据库&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;DATABASE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;db_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意 &lt;code&gt;DROP&lt;/code&gt; 操作没有确认步骤，回车就执行了。所以进行删除操作时需要谨慎。&lt;/p&gt;
&lt;h3&gt;重命名数据库&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RENAME&lt;/code&gt; 命令是用来对表进行重命名的，数据库没有对应的命令，只能间接实现。原理是将老数据库中的所有表重命名到新数据库下。当然，首先得创建新数据库。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
RENAME TABLE &lt;span class=&quot;pl-c1&quot;&gt;old_db&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;table&lt;/span&gt; TO &lt;span class=&quot;pl-c1&quot;&gt;new_db&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;table&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个重复性的操作，所以可以通过脚本来实现，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
mysql -u username -ppassword old_db -sNe &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;show tables&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;read&lt;/span&gt; table&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-cce&quot;&gt;\ &lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt; mysql -u username -ppassword -sNe &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;rename table old_db.&lt;span class=&quot;pl-smi&quot;&gt;$table&lt;/span&gt; to new_db.&lt;span class=&quot;pl-smi&quot;&gt;$table&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;mysql -u root -ppassword -s -N -e &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;use old_db;show tables from old_db;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt; mysql -u root -ppassword -s -N -e &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;use old_db;rename table old_db.&lt;span class=&quot;pl-smi&quot;&gt;$table&lt;/span&gt; to new_db.&lt;span class=&quot;pl-smi&quot;&gt;$table&lt;/span&gt;;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;-ppassword&lt;/code&gt; 中 &lt;code&gt;password&lt;/code&gt; 为你的密码，和 &lt;code&gt;-p&lt;/code&gt; 之间没有空格。&lt;/p&gt;
&lt;p&gt;注：上面为 shell 脚本而非 sql 脚本，在 shell 中运行或保存成 shell 文件执行。&lt;/p&gt;
&lt;h3&gt;清空数据库&lt;/h3&gt;
&lt;p&gt;清空数据库，即清空数据库中所有表中的记录。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;SELECT&lt;/span&gt; @str :&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; CONCAT(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;TRUNCATE TABLE &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, table_schema, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;.&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, table_name, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt;   &lt;span class=&quot;pl-c1&quot;&gt;information_schema&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;tables&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt;  table_type   &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;BASE TABLE&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt;  table_schema &lt;span class=&quot;pl-k&quot;&gt;IN&lt;/span&gt; (&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;db1_name&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;db2_name&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

PREPARE stmt &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; @str;

EXECUTE stmt;

DEALLOCATE PREPARE stmt;

&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;导出数据库&lt;/h3&gt;
&lt;p&gt;导出操作是通过 &lt;code&gt;mysqldump&lt;/code&gt; 命令行工具来完成的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ mysqldump &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;u &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;username&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;p &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt;dabases [db1] [db2]... &amp;gt; backup.sql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认导出时是带数据记录的，可通过 &lt;code&gt;--no-data&lt;/code&gt; 只导出表结构，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ mysqldump &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;u &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;username&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;p &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt;no-data --dabases [db1] [db2]... &amp;gt; backup.sql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多 &lt;code&gt;mysqldump&lt;/code&gt; 相关的参数可参见&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html&quot; rel=&quot;nofollow&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;导入数据库&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ mysql &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;u username &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;ppassword database_name &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;backup&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;sql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;表&lt;/h2&gt;
&lt;h3&gt;创建表&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
CREATE TABLE [IF NOT EXISTS] table_name(
    column_list
);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;重命名表&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot;&gt;
&lt;pre&gt;
RENAME TABLE tb1 TO tb2;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想一次重命名多张表，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
RENAME TABLE tb1 TO tb2, tb3 TO tb4;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除表&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时删除多张表，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; table1,table2...;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像这种操作表记录的，如果表存在外键关联，一般会报错，如果你明显知道自己在干什么，且知道操作是安全的，可暂时关闭 MySQL 的外键检查，操作完成后再开启。后续的操作中遇到该报错可同样应用此设置。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; 
&lt;span class=&quot;pl-k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;清空表&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
TRUNCATE [TABLE] tbl_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;列&lt;/h2&gt;
&lt;h3&gt;更新列&lt;/h3&gt;
&lt;p&gt;更新列的定义可通过 &lt;code&gt;CHANGE&lt;/code&gt; 或 &lt;code&gt;MODIFY&lt;/code&gt;。 区别仅在于后者不需要重新指定一个新的一列名。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; MyTable CHANGE COLUMN foo bar &lt;span class=&quot;pl-k&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt; FIRST;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; MyTable MODIFY COLUMN foo &lt;span class=&quot;pl-k&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt; AFTER baz;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;添加列&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; ADD COLUMN tempID &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;NULL&lt;/span&gt; DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认会添加到表中最后一列，可通过 &lt;code&gt;AFTER&lt;/code&gt; 来控制其位置。比如，将新增的列添加到 &lt;code&gt;ID&lt;/code&gt; 列后面。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; ADD COLUMN tempID &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;NULL&lt;/span&gt; DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; AFTER ID;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除列&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;table_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; DROP COLUMN &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;column_name&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一次删除多列，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; table
DROP COLUMN column_1,
DROP COLUMN column_2,
…;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;记录&lt;/h2&gt;
&lt;h3&gt;插入记录&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;INSERT INTO&lt;/span&gt; table_name (column1, column2, column3, ...)
&lt;span class=&quot;pl-k&quot;&gt;VALUES&lt;/span&gt; (value1, value2, value3, ...);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一次插入多条记录：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;INSERT INTO&lt;/span&gt; table(c1,c2,...)
&lt;span class=&quot;pl-k&quot;&gt;VALUES&lt;/span&gt; 
   (v11,v12,...),
   (v21,v22,...),
    ...
   (vnn,vn2,...);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除记录&lt;/h3&gt;
&lt;p&gt;删除满足条件的列：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;table_name&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt; [&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; condition];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是删除某列其值介于一个区间，比如 id 在 50~100 的记录，可以这样：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; tablename &lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; id BETWEEN &lt;span class=&quot;pl-c1&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;100&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要删除的记录，其某列的值，在一个可选的列表中，可以将 &lt;code&gt;WHERE&lt;/code&gt; 搭配 &lt;code&gt;IN&lt;/code&gt; 关键词：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; tablename &lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; id &lt;span class=&quot;pl-k&quot;&gt;IN&lt;/span&gt; (&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;,...,&lt;span class=&quot;pl-c1&quot;&gt;254&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像上面范围命中时，还可配合 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 不等于来进一步控制：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; tablename &lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; id BETWEEN &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;254&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; id&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;范围的情况常用的场景是命中一个日期区间的记录：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;objects&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt; (date_field BETWEEN &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2010-01-30 14:15:55&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2010-09-29 10:15:55&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;更新记录&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; [LOW_PRIORITY] [IGNORE] table_name 
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; 
    column_name1 &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; expr1,
    column_name2 &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; expr2,
    ...
[&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt;
    condition];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; employees 
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; 
    lastname &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Hill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    email &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;mary.hill@classicmodelcars.com&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;WHERE&lt;/span&gt;
    employeeNumber &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1056&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;外键&lt;/h2&gt;
&lt;h3&gt;创建外键&lt;/h3&gt;
&lt;p&gt;外键可在创建表时指定，通过 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CONSTRAINT&lt;/span&gt; constraint_name
&lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; foreign_key_name (columns)
&lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; parent_table(columns)
&lt;span class=&quot;pl-k&quot;&gt;ON DELETE&lt;/span&gt; action
&lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; action
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Orders&lt;/span&gt; (
    OrderID &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt;,
    OrderNumber &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt;,
    PersonID &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;,
    &lt;span class=&quot;pl-k&quot;&gt;PRIMARY KEY&lt;/span&gt; (OrderID),
    &lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; (PersonID) &lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; Persons(PersonID)
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于已经存在的表，使用 &lt;code&gt;ALTER TABLE&lt;/code&gt; 配合 &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; 来完成。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
ALTER table_name
ADD &lt;span class=&quot;pl-k&quot;&gt;CONSTRAINT&lt;/span&gt; constraint_name
&lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; foreign_key_name(columns)
&lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; parent_table(columns)
&lt;span class=&quot;pl-k&quot;&gt;ON DELETE&lt;/span&gt; action
&lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; action;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; Orders
ADD &lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; (PersonID) &lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; Persons(PersonID);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建的同时可指定一个外键名，否则 MySQL 会自己生成一个。这个名字在删除时有用。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; Orders
ADD &lt;span class=&quot;pl-k&quot;&gt;CONSTRAINT&lt;/span&gt; FK_PersonOrder
&lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; (PersonID) &lt;span class=&quot;pl-k&quot;&gt;REFERENCES&lt;/span&gt; Persons(PersonID);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;外键删除&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; table_name 
DROP &lt;span class=&quot;pl-k&quot;&gt;FOREIGN KEY&lt;/span&gt; constraint_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建并查看表的关系图&lt;/h2&gt;
&lt;p&gt;有一样是命令行无法进行的，那就是生成数据库整体的表关系图(&lt;a href=&quot;https://dev.mysql.com/doc/workbench/en/wb-creating-eer-diagram.html&quot; rel=&quot;nofollow&quot;&gt;EER 图&lt;/a&gt;)。这个需要借助文章开头提到的 GUI 工具 MySQL Workbench。&lt;/p&gt;
&lt;p&gt;方法是从菜单中 &lt;code&gt;database&lt;/code&gt; -&amp;gt; &lt;code&gt;Reverse Engineer...&lt;/code&gt; 进入，然后跟着向导一步步直到结束，便创建好了相应数据库的表间关系图。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/57940394-ff31f080-78fe-11e9-8010-96cb561734c1.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/57940394-ff31f080-78fe-11e9-8010-96cb561734c1.png&quot; alt=&quot;MySQL Reverse Engineer 菜单&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;MySQL Reverse Engineer 菜单&lt;/p&gt;
&lt;p&gt;生成结果示例：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/57940601-5e900080-78ff-11e9-809e-118d12a6d910.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/57940601-5e900080-78ff-11e9-809e-118d12a6d910.png&quot; alt=&quot;MySQL EER 图&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;MySQL EER 图&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Fri, 17 May 2019 15:47:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>如果是本地开发，使用 GUI 工具比如官方的 MySQL Workbench 会省事很多，但命令行方式在服务器环境特别有用。 另，如果官方的下载地址很慢的话，可尝试这个镜像，速度超快的。 数据库 创建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/mysql_most_used_actions.html</dc:identifier>
</item>
<item>
<title>Java面试题总结之Java基础(三) - AlbertYang666</title>
<link>http://www.cnblogs.com/yangxianyang/p/10884192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangxianyang/p/10884192.html</guid>
<description>&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;JAVA&lt;/strong&gt; &lt;strong&gt;语言如何进行异常处理，关键字：&lt;/strong&gt;&lt;strong&gt;throws,throw,try,catch,finally&lt;/strong&gt;&lt;strong&gt;分别代表什么意义？在&lt;/strong&gt;&lt;strong&gt;try&lt;/strong&gt; &lt;strong&gt;块中可以抛出异常吗&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws 和finally。一般情况下是用try 来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try 用来指定一块预防所有“异常”的程序；catch 子句紧跟在try 块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws 用来标明一个成员函数可能抛出的各种“异常”；Finally 为确保一段代码不管发生什么“异常”都被执行的一段代码；可以在一个成员函数调用的外面写一个try 语句，在这个成员函数内部写另一个try 语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到堆栈上面，直到所有的try 语句都完成。如果下一级的try 语句没有对某种“异常”进行处理，堆栈就会展开，直到遇到有处理这种“异常”的try 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、运行时异常与一般异常有何异同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、说出一个你最常见到的&lt;/strong&gt;&lt;strong&gt;runtime exception&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：&lt;span&gt;ArithmeticException, ArrayStoreException, BufferOverflowException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BufferUnderflowException, CannotRedoException, CannotUndoException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ClassCastException, CMMException, ConcurrentModificationException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DOMException, EmptyStackException, IllegalArgumentException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IllegalMonitorStateException, IllegalPathStateException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IllegalStateException, ImagingOpException, IndexOutOfBoundsException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MissingResourceException, NegativeArraySizeException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NoSuchElementException, NullPointerException, ProfileDataException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ProviderException, RasterFormatException, SecurityException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SystemException, UndeclaredThrowableException,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UnmodifiableSetException, UnsupportedOperationException&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;final, finally, finalize&lt;/strong&gt; &lt;strong&gt;的区别&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：final：修饰符（关键字）；如果一个类被声明为final，意味着它不能不能作为父类被继承，因此一个类不能既被声明为abstract的，又被声明为final 的；将变量或方法声明为final，可以保证它们在使用中不被改变；被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改；被声明为final 的方法也同样只能使用，不能重载。finally：异常处理时提供finally 块来执行任何清除操作。finalize：方法名；Java 技术允许使用finalize() 方法在垃圾收集器，将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时，对这个对象调用的。它是在Object 类中定义的，因此所有的类都继承了它。子类覆盖finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;、类&lt;/strong&gt;&lt;strong&gt;Example A&lt;/strong&gt; &lt;strong&gt;继承&lt;/strong&gt;&lt;strong&gt;Exception&lt;/strong&gt;&lt;strong&gt;，类&lt;/strong&gt;&lt;strong&gt;ExampleB&lt;/strong&gt; &lt;strong&gt;继承&lt;/strong&gt;&lt;strong&gt;Example A&lt;/strong&gt;&lt;strong&gt;；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有如下代码片断：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{

&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExampleB(“b”)；

}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;（ExampleA e）{

System.out.printfln（“ExampleA”）；

}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;（Exception e）{

System.out.printfln（“Exception”）；

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出的内容应该是：&lt;/p&gt;
&lt;p&gt;A：ExampleA  B：Exception  C：b  D：无&lt;/p&gt;
&lt;p&gt;答：输出为A。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;、介绍&lt;/strong&gt;&lt;strong&gt;JAVA&lt;/strong&gt; &lt;strong&gt;中的&lt;/strong&gt;&lt;strong&gt;Collection FrameWork(&lt;/strong&gt;&lt;strong&gt;及如何写自己的数据结构&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Collection FrameWork 如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Collection&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;├List元素可以重复，有序(存入顺序和取出顺序一致)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;│├LinkedList底层数据结构是链表，查询慢，增删快，线程不安全效率高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;│├ArrayList底层数据结构是数组，查询快，增删慢，线程不安全效率高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;│└Vector底层数据结构是数组，查询快，增删慢，线程安全效率低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;│ └Stack&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;└Set元素无序，不可以重复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   ├HashSet线程不安全，存取速度快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; └TreeSet线程不安全，可以对Set集合中的元素进行排序。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;├Hashtable线程安全，速度快。底层是哈希表数据结构。是&lt;strong&gt;同步&lt;/strong&gt;的。不允许null作为键，null作为值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;├HashMap线程不安全，速度慢。底层也是哈希表数据结构。是&lt;strong&gt;不同步&lt;/strong&gt;的。允许null作为键，null作为值。替代了Hashtable.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;└WeakHashMap可以用来对Map集合中的&lt;strong&gt;键&lt;/strong&gt;进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Collection 是最基本的集合接口，一个Collection 代表一组Object，即Collection 的元素（Elements）； Map 提供key 到value 的映射。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collection &lt;/strong&gt;&lt;strong&gt;和 Collections&lt;/strong&gt;&lt;strong&gt;的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collection&lt;/strong&gt;是集合类的上级接口，子接口主要有Set 和List、Map。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collections&lt;/strong&gt;是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;、你所知道的集合类都有哪些？主要方法有哪些？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：最常用的集合类是List 和Map。List 的具体实现包括ArrayList 和Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。Map 提供了一个更通用的元素存储方法。Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;strong&gt;、说出&lt;/strong&gt;&lt;strong&gt;ArrayList,Vector, LinkedList&lt;/strong&gt; &lt;strong&gt;的存储性能和特性？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：ArrayList 和Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Collection&lt;/strong&gt; &lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;Collections&lt;/strong&gt; &lt;strong&gt;的区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Collection 是java.util 下的接口，它是各种集合的父接口，继承于它的接口主要有Set 和List；Collections 是个java.util 下的类，是针对集合的帮助类，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;HashMap&lt;/strong&gt; &lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;Hashtable&lt;/strong&gt; &lt;strong&gt;的区别&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：二者都实现了Map 接口，是将惟一键映射到特定的值上；主要区别在于：&lt;/p&gt;
&lt;p&gt;1)HashMap 没有排序，允许一个null 键和多个null 值,而Hashtable 不允许；&lt;/p&gt;
&lt;p&gt;2)HashMap 把Hashtable 的contains 方法去掉了，改成containsvalue 和containsKey,因为contains 方法容易让人引起误解；&lt;/p&gt;
&lt;p&gt;3)Hashtable 继承自Dictionary 类，HashMap 是Java1.2 引进的Map 接口的实现；&lt;/p&gt;
&lt;p&gt;4)Hashtable 的方法是Synchronize 的，而HashMap 不是，在多个线程访问Hashtable 时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。Hashtable 和HashMap 采用的hash/rehash 算法大致一样，所以性能不会有很大的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Arraylist&lt;/strong&gt; &lt;strong&gt;与&lt;/strong&gt;&lt;strong&gt;Vector&lt;/strong&gt; &lt;strong&gt;区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：就ArrayList 与Vector 主要从二方面来说：&lt;/p&gt;
&lt;p&gt;1）同步性：Vector 是线程安全的（同步），而ArrayList 是线程序不安全的；&lt;/p&gt;
&lt;p&gt;2）数据增长：当需要增长时,Vector 默认增长一倍，而ArrayList 却是一半。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;List&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Set&lt;/strong&gt; &lt;strong&gt;三个接口，存取元素时，各有什么特点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value 值，value 可多值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Set&lt;/strong&gt; &lt;strong&gt;里的元素是不能重复的，那么用什么方法来区分重复与否呢&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt; &lt;strong&gt;是用&lt;/strong&gt;&lt;strong&gt;==&lt;/strong&gt;&lt;strong&gt;还是&lt;/strong&gt;&lt;strong&gt;equals()?&lt;/strong&gt; &lt;strong&gt;它们有何区别&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Set 里的元素是不能重复的，用equals ()方法来区分重复与否。覆盖equals()方法用来判断对象的内容是否相同，而”==”判断地址是否相等,用来决定引用值是否指向同一对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14&lt;/strong&gt;&lt;strong&gt;、用程序给出随便大小的&lt;/strong&gt;&lt;strong&gt;10&lt;/strong&gt; &lt;strong&gt;个数，序号为&lt;/strong&gt;&lt;strong&gt;1-10&lt;/strong&gt;&lt;strong&gt;，按从小到大顺序输出，并输出相应的序号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;

 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RandomSort {

      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printRandomBySort() {

             Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Random(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建随机数生成器&lt;/span&gt;
&lt;span&gt;
             List&lt;/span&gt;&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成10 个随机数，并放在集合list 中&lt;/span&gt;

             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {

                    list.add(random.nextInt(&lt;/span&gt;1000&lt;span&gt;));

             }

             Collections.sort(list); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对集合中的元素进行排序

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种输出方法&lt;/span&gt;
&lt;span&gt;
             Iterator&lt;/span&gt;&amp;lt;Integer&amp;gt; it =&lt;span&gt; list.iterator();

             &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

             &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (it.hasNext()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 顺序输出排序后集合中的元素&lt;/span&gt;
&lt;span&gt;
                    System.out.println(&lt;/span&gt;++count + &quot;: &quot; +&lt;span&gt; it.next());

             }

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种输出方法&lt;/span&gt;

             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Integer integer : list) {

                    System.out.println(integer);

             }

      }

 

      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

             printRandomBySort();

      }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;15&lt;/strong&gt;&lt;strong&gt;、用&lt;/strong&gt;&lt;strong&gt;JAVA&lt;/strong&gt; &lt;strong&gt;实现一种排序，&lt;/strong&gt;&lt;strong&gt;JAVA&lt;/strong&gt; &lt;strong&gt;类实现序列化的方法？&lt;/strong&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;strong&gt;COLLECTION&lt;/strong&gt; &lt;strong&gt;框架中，实现比较要实现什么样的接口？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：用选择排序代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChooseSort {

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array;

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length;

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ChooseSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.array =&lt;span&gt; array;

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.length =&lt;span&gt; array.length;

   }

 

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;

    * 打印数组中的所有元素

    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display() {

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : array) {

        System.out.print(i &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);

      }

      System.out.println();

   }

 

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;

    * 选择排序算法

    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; chooseSort() {

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; length - 1; i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做第i趟排序&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt; minIndex =&lt;span&gt; i;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = minIndex + 1; j &amp;lt; length; j++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选最小的记录&lt;/span&gt;

           &lt;span&gt;if&lt;/span&gt; (array[minIndex]&amp;gt;&lt;span&gt;array[j]) {

              minIndex &lt;/span&gt;= j;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记下目前找到的最小值所在的位置&lt;/span&gt;
&lt;span&gt;
           }

        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (i != minIndex) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换a[i]和a[minIndex]&lt;/span&gt;

           &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; array[i];

           array[i] &lt;/span&gt;=&lt;span&gt; array[minIndex];

           array[minIndex] &lt;/span&gt;=&lt;span&gt; temp;

        }

      }

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] array = { 100, 45, 36, 21, 17, 13, 7&lt;span&gt; };

      ChooseSort cs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChooseSort(array);

      System.out.println(&lt;/span&gt;&quot;排序前的数据为：&quot;&lt;span&gt;);

      cs.display();

      cs.chooseSort();

      System.out.println(&lt;/span&gt;&quot;排序后的数据为：&quot;&lt;span&gt;);

      cs.display();

   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;JAVA 类实现序例化的方法是实现java.io.Serializable 接口；Collection 框架中实现比较要实现Comparable 接口和Comparator 接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;16&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;sleep()&lt;/strong&gt; &lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;wait()&lt;/strong&gt; &lt;strong&gt;有什么区别&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：sleep 是线程类（Thread）的方法，使此线程暂停执行并指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep 不会释放对象锁。wait 是Object 类的方法，对对象调用wait 方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备，获得对象锁进入运行状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;17&lt;/strong&gt;&lt;strong&gt;、当一个线程进入一个对象的一个&lt;/strong&gt;&lt;strong&gt;synchronized&lt;/strong&gt; &lt;strong&gt;方法后，其它线程是否可进入此对象的其它方法&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：其它线程只能访问该对象的其它非同步方法，同步方法则不能进入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18&lt;/strong&gt;&lt;strong&gt;、请说出你所知道的线程同步的方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：wait():使一个线程处于等待状态，并且释放所持有的对象的lock；sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常；notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM 确定唤醒哪个线程，而且不是按优先级；&lt;/p&gt;
&lt;p&gt;notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们互相竞争。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;19&lt;/strong&gt;&lt;strong&gt;、多线程有几种实现方法&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;都是什么&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;strong&gt;同步有几种实现方法&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;都是什么&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：多线程有两种实现方法，分别是继承Thread 类与实现Runnable 接口,同步的实现方面有两种，分别是synchronized,wait 与notify。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;strong&gt;、同步和异步有何异同，在什么情况下使用他们？举例说明。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;21&lt;/strong&gt;&lt;strong&gt;、启动一个线程是用&lt;/strong&gt;&lt;strong&gt;run()&lt;/strong&gt;&lt;strong&gt;还是&lt;/strong&gt;&lt;strong&gt;start()?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行。这并不意味着线程就会立即运行。当cpu分配给它时间时，才开始执行run()方法(如果有的话)。start()是方法,它调用run()方法.而run()方法是你必须重写的. run()方法中包含的是线程的主体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;22&lt;/strong&gt;&lt;strong&gt;、线程的基本概念、线程的基本状态以及状态之间的关系？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身；Java 中的线程有四种状态分别是：运行、就绪、挂起、结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;23&lt;/strong&gt;&lt;strong&gt;、简述&lt;/strong&gt;&lt;strong&gt;synchronized&lt;/strong&gt; &lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;java.util.concurrent.locks.Lock&lt;/strong&gt; &lt;strong&gt;的异同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：相同点：Lock 能完成synchronized 所实现的所有功能；&lt;/p&gt;
&lt;p&gt;不同点：Lock 有比synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而Lock 一定要求程序员手工释放，并且必须在finally中释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;24&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;java&lt;/strong&gt; &lt;strong&gt;中有几种方法可以实现一个线程？用什么关键字修饰同步方法&lt;/strong&gt;&lt;strong&gt;?stop()&lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;suspend()&lt;/strong&gt;&lt;strong&gt;方法为何不推荐使用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：有两种实现方法，分别是继承Thread 类与实现Runnable 接口；用synchronized 关键字修饰同步方法；反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在；suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。故不应该使用suspend()，而应在自己的Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;25&lt;/strong&gt;&lt;strong&gt;、设计&lt;/strong&gt;&lt;strong&gt;4&lt;/strong&gt; &lt;strong&gt;个线程，其中两个线程每次对&lt;/strong&gt;&lt;strong&gt;j&lt;/strong&gt; &lt;strong&gt;增加&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;，另两个线程对&lt;/strong&gt;&lt;strong&gt;j&lt;/strong&gt; &lt;strong&gt;每次减少&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;；写出程序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：以下程序使用内部类实现线程，对j 增减的时候没有考虑顺序问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestThread {

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TestThread(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.j =&lt;span&gt; j;

   }

 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加j&lt;/span&gt;
   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inc() {

      j&lt;/span&gt;++&lt;span&gt;;

      System.out.println(j &lt;/span&gt;+ &quot;--Inc--&quot; +&lt;span&gt; Thread.currentThread().getName());

   }

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减少j&lt;/span&gt;

   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dec() {

      j&lt;/span&gt;--&lt;span&gt;;

      System.out.println(j &lt;/span&gt;+ &quot;--Dec--&quot; +&lt;span&gt; Thread.currentThread().getName());

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dec().start();

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inc()).start();

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dec().start();

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inc()).start();

   }

 

   &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Dec &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {

      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {

           dec();

        }

      }

   }

 

   &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Inc &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {

 

           inc();

        }

      }

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TestThread(5&lt;span&gt;).run();

   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;26&lt;/strong&gt;&lt;strong&gt;、什么是&lt;/strong&gt;&lt;strong&gt;java&lt;/strong&gt; &lt;strong&gt;序列化，如何实现&lt;/strong&gt;&lt;strong&gt;java&lt;/strong&gt; &lt;strong&gt;序列化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；序列化的实现：将需要被序列化的类实现Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;27&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;java&lt;/strong&gt; &lt;strong&gt;中有几种类型的流？&lt;/strong&gt;&lt;strong&gt;JDK&lt;/strong&gt; &lt;strong&gt;为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：字节流，字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;28&lt;/strong&gt;&lt;strong&gt;、文件和目录（&lt;/strong&gt;&lt;strong&gt;IO&lt;/strong&gt;&lt;strong&gt;）操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1)如何列出某个目录下的所有文件？&lt;/p&gt;
&lt;p&gt;2)如何列出某个目录下的所有子目录？&lt;/p&gt;
&lt;p&gt;3)如何判断一个文件或目录是否存在？&lt;/p&gt;
&lt;p&gt;4)如何读写文件？&lt;/p&gt;
&lt;p&gt;答：1)示例代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
File file = &lt;span&gt;new&lt;/span&gt; File(&quot;e:&quot;&lt;span&gt;);

      File[] files &lt;/span&gt;=&lt;span&gt; file.listFiles();

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; files.length; i++&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (files[i].isFile())

           System.out.println(files[i]);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2)示例代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
File file = &lt;span&gt;new&lt;/span&gt; File(&quot;e:\\&quot;&lt;span&gt;);

      File[] files &lt;/span&gt;=&lt;span&gt; file.listFiles();

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; files.length; i++&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (files[i].isDirectory())

           System.out.println(files[i]);

  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3)创建File 对象,调用其exsit()方法即可返回是否存在,如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
System.out.println(&lt;span&gt;new&lt;/span&gt; File(&quot;d:\\t.txt&quot;).exists());
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4)示例代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读文件:&lt;/span&gt;
&lt;span&gt;
      FileInputStream fin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;e:\\tt.txt&quot;&lt;span&gt;);

      &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bs = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[100&lt;span&gt;];

      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; fin.read(bs);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len &amp;lt;= 0&lt;span&gt;)

           &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        System.out.print(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(bs, 0&lt;span&gt;, len));

      }

      fin.close();

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写文件:&lt;/span&gt;
&lt;span&gt;
      FileWriter fw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;e:\\test.txt&quot;&lt;span&gt;);

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.getProperty(&quot;line.separator&quot;)相当于&quot;/n&quot;\n’ 这样写的话，剔除了平台无关性&lt;/span&gt;
&lt;span&gt;
      fw.write(&lt;/span&gt;&quot;hello world!&quot; + System.getProperty(&quot;line.separator&quot;&lt;span&gt;));

      fw.write(&lt;/span&gt;&quot;你好！郑州！&quot;&lt;span&gt;);

      fw.close();

 

   }

 

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;29&lt;/strong&gt;&lt;strong&gt;、写一个方法&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;输入一个文件名和一个字符串&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;统计这个字符串在这个文件中出现的次数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; countWords(String file, String find) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

      Reader in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader(file);

      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c;

      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((c = in.read()) != -1&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (c == find.charAt(0&lt;span&gt;)) {

           &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; find.length(); i++&lt;span&gt;) {

              c &lt;/span&gt;=&lt;span&gt; in.read();

              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c !=&lt;span&gt; find.charAt(i))

                 &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == find.length() - 1&lt;span&gt;)

                 count&lt;/span&gt;++&lt;span&gt;;

           }

        }

      }

      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;30&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Java&lt;/strong&gt; &lt;strong&gt;的通信编程，编程题&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;strong&gt;或问答&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;strong&gt;，用&lt;/strong&gt;&lt;strong&gt;JAVA SOCKET&lt;/strong&gt; &lt;strong&gt;编程，读服务器几个字符，再写入本地显示？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Server 端程序:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.net.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;

 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Server {

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ServerSocket ss;

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Socket socket;

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BufferedReader in;

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PrintWriter out;

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server() {

      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建 ServerSocket 对象（并绑定端口）&lt;/span&gt;
&lt;span&gt;
        ss &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ServerSocket(10000&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用 accept 方法，等待来自客户端的连接&lt;/span&gt;
&lt;span&gt;
           socket &lt;/span&gt;=&lt;span&gt; ss.accept();

           String RemoteIP &lt;/span&gt;=&lt;span&gt; socket.getInetAddress().getHostAddress();

           String RemotePort &lt;/span&gt;= &quot;:&quot; +&lt;span&gt; socket.getLocalPort();

           System.out.println(&lt;/span&gt;&quot;A client come in!IP:&quot; + RemoteIP +&lt;span&gt; RemotePort);

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用 getXXXStream 方法，进行 I/O操作&lt;/span&gt;
&lt;span&gt;
           in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(socket.getInputStream()));

           String line &lt;/span&gt;=&lt;span&gt; in.readLine();

           System.out.println(&lt;/span&gt;&quot;Cleint send is :&quot; +&lt;span&gt; line);

           out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PrintWriter(socket.getOutputStream(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

           out.println(&lt;/span&gt;&quot;Your Message Received!&quot;&lt;span&gt;);

           out.close();

           in.close();

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭 Socket&lt;/span&gt;
&lt;span&gt;
           socket.close();

        }

      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {

        out.println(&lt;/span&gt;&quot;wrong&quot;&lt;span&gt;);

      }

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Server();

   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Client 端程序:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.net.*&lt;span&gt;;

 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

   Socket socket;

   BufferedReader in;

   PrintWriter out;

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Client() {

      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

        System.out.println(&lt;/span&gt;&quot;Try to Connect to 127.0.0.1:10000&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建 Socket 对象，并连接服务器 （ip字符串,端口号）&lt;/span&gt;
&lt;span&gt;
        socket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Socket(&quot;127.0.0.1&quot;, 10000&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;The Server Connected!&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;Please enter some Character:&quot;&lt;span&gt;);

        BufferedReader line &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(System.in));

        out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PrintWriter(socket.getOutputStream(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

        out.println(line.readLine());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.调用 getXXXStream 方法，进行 I/O操作&lt;/span&gt;
&lt;span&gt;
        in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(socket.getInputStream()));

        System.out.println(in.readLine());

        out.close();

        in.close();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、关闭 Socket&lt;/span&gt;
&lt;span&gt;
        socket.close();

      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {

        out.println(&lt;/span&gt;&quot;Wrong&quot;&lt;span&gt;);

      }

   }

 

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client();

   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 17 May 2019 15:05:00 +0000</pubDate>
<dc:creator>AlbertYang666</dc:creator>
<og:description>1、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try 块中可以抛出异常吗？ 答：Java 通过面向对象的方法进行异常处理，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangxianyang/p/10884192.html</dc:identifier>
</item>
<item>
<title>Python基础（四）——迭代器/对象，生成器 - 孔胡子</title>
<link>http://www.cnblogs.com/KongHuZi/p/10878145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KongHuZi/p/10878145.html</guid>
<description>&lt;p&gt;　　首先&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128&quot; target=&quot;_blank&quot;&gt;廖雪峰网站&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;写的内容就我目前初步学习来说，已经相当详实，知识点平铺直叙让人易接受，所以以下内容均作为一种摘&lt;span&gt;&lt;em&gt;&lt;strong&gt;记记录以及补充&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　主要目的是创建 list 。多看例子就能清楚：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(list(range(1,10,2)))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;[1, 3, 5, 7, 9].生成1~&lt;span&gt;9（左闭右开）&lt;/span&gt;,相隔为2&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;([t * t &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; range(1,10,3) &lt;span&gt;if&lt;/span&gt; t % 2 == 0]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;[16].生成1~9相隔4,且是偶数的平方和&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;([m + n &lt;span&gt;for&lt;/span&gt; m &lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;['14', '15', '16', '24', '25', '26', '34', '35', '36'].全排列&lt;/span&gt;
&lt;span&gt;
d &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; d.items():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(k, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, v)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;([m + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + n &lt;span&gt;for&lt;/span&gt; m,n &lt;span&gt;in&lt;/span&gt; d.items()])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;['x=A', 'y=B', 'z=C']&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;筛选单词，并全变小写&lt;/span&gt;
L = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 18, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;([t.lower() &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; L &lt;span&gt;if&lt;/span&gt; isinstance(t, str)])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;['hello', 'world', 'apple']&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　iterable 是&lt;span&gt;可迭代对象&lt;/span&gt;，iterator 是&lt;span&gt;迭代器&lt;/span&gt;。两者都是 collection.abc 中得抽象类。iterator 继承自 iterable 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　iterable 有常见得 list，dict，str，tuple 等或者自定义的类（该类必须实现抽象方法 _iter()_）。当一个可迭代对象作为参数调用自身的 iter() 方法时，会返回一个迭代器。&lt;span&gt;迭代器拥有 _next()_ 抽象方法，可迭代对象没有&lt;/span&gt;，通过该方法就可以逐个得到 “序列” 中的各个值，不断调用 _next()_ 方法，最后会引起 StopIteration 异常报错，代表迭代结束了。同时&lt;span&gt;迭代器还拥有 _iter()_ 方法&lt;/span&gt;，所以迭代器也是个可迭代对象。即&lt;span&gt;所有的迭代器都是可迭代对象，但是&lt;/span&gt;可迭代对象并不都是迭代器，基本判断方法是是否调用 next() 方法，list，dect，str，tuple 都并不行，即不是迭代器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　   我们可以通过 isinstance 来判断：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable,Iterator
t &lt;/span&gt;= [1,2,3&lt;span&gt;]   #列表
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(isinstance(t, Iterable)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(isinstance(t, Iterator)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         我们常用的 for...in [ ] 。就是利用了迭代器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable,Iterator
L &lt;/span&gt;= [1,2,3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(isinstance(L, Iterator)) #Flase
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(t, end=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;) #1  2  3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;          这是我们常写的代码，输出123。既然 L 不是迭代器为啥也能迭代输出呢。这就是在使用 for...in 的时候，&lt;span&gt;Python 解释器主动将可迭代对象调用了 iter() 返回迭代器&lt;/span&gt;，即每次都是通过迭代器的 next() 方法进行输出。那么哪个异常 StopIteration 呢？异常应该被 for...in 内部处理了，并不显式的抛出。&lt;/p&gt;
&lt;p&gt;　　   我们换一种更明显的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable,Iterator
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; L = [1,2,3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(L, Iterator))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; T = L.&lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(T, Iterator))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;true。现在T就是迭代器了，拥有了next()方法。&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(T.&lt;span&gt;__next__&lt;/span&gt;())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(T.&lt;span&gt;__next__&lt;/span&gt;())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(T.&lt;span&gt;__next__&lt;/span&gt;())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(T.&lt;span&gt;__next__&lt;/span&gt;())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; StopIteration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         结果和我们想的是一样的。或者再这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable,Iterator
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; L = [1,2,3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(L, Iterator))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; T =&lt;span&gt; iter(L)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(next(T), end=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结束&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（点击图片查看原文）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nvie.com/posts/iterators-vs-generators/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1144707/201905/1144707-20190517160723155-1980435125.png&quot; alt=&quot;&quot; width=&quot;772&quot; height=&quot;258&quot;/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;生成器是返回一个 generator iterator 的函数。但是这个函数中包含 yield 表达式，除此之外别无它异，用来产生一系列供 for 循环使用的值或者通过 next() 逐一获取。所以生成器一般也称为生成器函数。&lt;/li&gt;
&lt;li&gt;生成迭代器 generator iterator 是由生成器 generator 创建的对象。每遇到 yield 会暂停（相当于return），&lt;span&gt;并记住当前位置&lt;/span&gt;，之后在继续在记住的位置继续向下运行。而不同于普通函数每次都由上往下运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;第一种创建生成器的方法&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;：将列表生成式的 [ ] 换成 ( )&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
L = ( t * t &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; range(1,10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x0000028D2F68B840&amp;gt;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(next(L)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(next(L)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; L: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 迭代输出&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(i)
&lt;/pre&gt;&lt;/div&gt;



&lt;ul&gt;&lt;li&gt;&lt;span&gt;当一个生成函数被调用时，返回一个迭代器，成为生成器&lt;/span&gt;。这个&lt;span&gt;生成器来控制&lt;/span&gt;生成函数的执行，遇到 yield 就挂起，下次继续从 挂起处执行。前面说过迭代器有 next() 方法，所以这里的yield 就是干了 next() 方法的事。一样不断next 直到无数据 StopIteration。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;第二种是通过定义函数&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test():
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; t = test()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; t 是生成器，生成器来控制函数&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;generator object test at 0x0000021EF6C5B840&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; next(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; next(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; next(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; next(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; StopIteration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　可以通过 11~14 行看出，yield 起的作用就是挂起。第一次调用next() 方法，函数执行到第三句就停了，第二次调用 next() 执行到第五句。yield 就像是 OS 中的中断语句，保护现场--恢复现场。&lt;/p&gt;
&lt;p&gt;　　再来看一个斐波那契例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;斐波那契数列&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;常规写法一：&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; def fib(max):&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     n, a, b = 0, 0, 1&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     while n &amp;lt; max:&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         print(b)&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         a, b = b, a + b&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         n = n + 1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     return 'done'&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; fib(6)&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成器写法二：&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterator,Iterable
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(max):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     n, a, b = 0, 0, 1
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; n &amp;lt;&lt;span&gt; max:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; b     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; yield 类似于return 将 b 返回&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         a, b = b, a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         n = n + 1
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; f = fib(6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(f)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;generator object fib at 0x00000124DDD8B840&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(f, Iterator)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True。生成函数返回迭代器&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(n, end=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 1 2 3 5 8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过观察24，25行可以知道，调用了 fib() 之后，函数并没有执行到尾（否则返回 str = 'done'），正如上文所说，返回的是一个 生成器，也就是调用生成函数（含 yield语句的）返回生成器，然后我们通过生成器来控制函数的执行。只有执行27行的 for...in 的时候，才会去执行15~21这段函数代码。&lt;/p&gt;
&lt;p&gt;　　具体执行过程：第一次从16至18行停止，因为yield的存在，执行到18行就停了，然后返回一个值 b 给 for 循环，然后执行28行输出 b，然后next()迭代器继续从上次停止的地方的下一行19行继续执行(迭代器next()只要不是StopIteration 或者生成函数结束了，for 循环就得以继续)，然后在while循环内，再次执行到18行停止，返回 b 给 for。继续重复，直至跳出while循环，fib() 这段生成器函数结束了，for...in 也就结束了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # &lt;span&gt;生成器写法三
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections.abc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterator,Iterable
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(max):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     n, a, b = 0, 0, 1
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; n &amp;lt;&lt;span&gt; max:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; b     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; yield 类似于return 将 b 返回&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         a, b = b, a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         n = n + 1
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; f = fib(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(f)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;generator object &amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(isinstance(f, Iterator)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True。生成函数返回迭代器&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(f))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(f))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(f))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(f))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; StopIteration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;　　stackoverflow 上还有关于生成 yield 配合使用 send()的方法。查阅官网，send(value) 函数意思：恢复执行，并向生成器发送一个值，value 参数将被当作 yield 表达式结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         x = &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; x * 2
&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; g =&lt;span&gt; test()
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(next(g)) # none
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(g.send(12)) #24
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　我们已经知道 yield 可以当作return来理解。&lt;/p&gt;
&lt;p&gt;　　首先第六行创建了 g (生成器)，第七行输出 none，因为执行第七行，也就是去执行test()函数了，函数顺利执行到第三行，3 = yield 明显是我们学的赋值语句，难道是将yield赋值给3？不是的。先解释输出的none，因为没有参数写在yield的右边，即没有参数返回，所以第七行输出 None。同时因为yield存在而停止继续。&lt;/p&gt;
&lt;p&gt;　　而第八行：遇到g.send() 会继续执行上次执行到第三行的地方，&lt;span&gt;这里传入的参数12就是赋值给x的&lt;/span&gt;。所以再往下第四行，yiled看成return 返回12*2，同时test()函数被挂起，返回24给第八行。至此函数结束。&lt;/p&gt;
&lt;p&gt;　　又比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(x):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         x *= 2
&lt;span&gt;4&lt;/span&gt;         x = &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; g = test(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next(g)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(g.send(12))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第四行意思：先看右边yield x 就是返回 x 。再看左边 x = yield 就是赋值给 x 。所以不难理解了。不解释了。 &lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://nvie.com/posts/iterators-vs-generators/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1144707/201905/1144707-20190517203043671-1660204524.png&quot; alt=&quot;&quot; width=&quot;1006&quot; height=&quot;454&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 17 May 2019 12:30:00 +0000</pubDate>
<dc:creator>孔胡子</dc:creator>
<og:description>首先廖雪峰网站写的内容就我目前初步学习来说，已经相当详实，知识点平铺直叙让人易接受，所以以下内容均作为一种摘记记录以及补充。 1. 列表生成器 主要目的是创建 list 。多看例子就能清楚： 2. I</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KongHuZi/p/10878145.html</dc:identifier>
</item>
<item>
<title>当Python中混进一只薛定谔的猫…… - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/10883351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/10883351.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g34jsy035ij21g80yt0va.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文原创并首发于公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】，未经授权，请勿转载。&lt;br/&gt;原文地址：https://mp.weixin.qq.com/s/-fFVTgWVsydFsNu1nyxUzA&lt;/p&gt;
&lt;p&gt;Python 是一门强大的动态语言，那动态体现在哪里，强大又体现在哪里呢？除了好的方面，Python 的动态性是否还藏着一些使用陷阱呢，有没有办法识别与避免呢？&lt;/p&gt;
&lt;p&gt;沿着它的动态特性话题，猫哥有几篇文章依次探及了：动态修改变量、动态定义函数、动态执行代码等内容，然而，当混合了变量赋值、动态赋值、命名空间、作用域、函数的编译原理等等内容时，问题就可能会变得非常棘手。&lt;/p&gt;
&lt;p&gt;因此，这篇文章将前面一些内容融汇起来，再做一次延展的讨论，希望能够理清一些使用的细节，更深入地探索 Python 语言的奥秘。&lt;/p&gt;
&lt;h2 id=&quot;疑惑重重的例子&quot;&gt;（1）疑惑重重的例子&lt;/h2&gt;
&lt;p&gt;先看看这一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例0
def foo():
    exec('y = 1 + 1')
    z = locals()['y']
    print(z)
    
foo()

# 输出：2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;exec() 函数的代码块中定义了变量 y，这个值可以被随后的 locals() 取到，在赋值后也打印了出来。然而，在这个例子的基础上，只需做出小小的改变，结果就可能大不相同了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例1
def foo():
    exec('y = 1 + 1')
    y = locals()['y']
    print(y)
    
foo()

# 报错：KeyError: 'y'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把前例的 z 改为 y ，就报错了。其中，&lt;code&gt;KeyError&lt;/code&gt; 指的是在字典中不存在对应的 key 。为什么会这样呢，新赋值的变量是 y 或者 z，为什么对结果有这么不同的影响？&lt;/p&gt;
&lt;p&gt;试试把 exec 去掉，不报错！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例2
def foo():
    y = 1 + 1
    y = locals()['y']
    print(y)

foo()

# 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题：直接对 y 赋值，跟动态地在 exec() 中赋值，会对 locals() 取值产生怎样的影响？&lt;/p&gt;
&lt;p&gt;再试试对例 1 的 locals() 先赋值，还是报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例3
def foo():
    exec('y = 1 + 1')
    boc = locals()
    y = boc['y']
    print(y)
 
foo()

# KeyError: 'y'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先做一次赋值，难道没有用么？也不是，如果把赋值的顺序调前，就不报错了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例4
def foo():
    boc = locals()
    exec('y = 1 + 1')
    y = boc['y']
    print(y)

foo()

# 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，locals() 的值并不是固定的，它的值与调用时的上下文相关，调用 locals() 的时机至关重要。&lt;/p&gt;
&lt;p&gt;然而，如果想要验证一下，在函数中增加一个 locals() 的打印，这个动作却会影响到最终的执行结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例5
def foo():
    boc = locals()
    exec('y = 1 + 1')
    print(locals())
    y = boc['y']
    print(y)

foo()

# {'boc': {...}}
# KeyError: 'y'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这到底是怎么回事呢？&lt;/p&gt;
&lt;h2 id=&quot;多元知识的储备&quot;&gt;（2）多元知识的储备&lt;/h2&gt;
&lt;p&gt;以上例子在细微之处有较大的不同，主要由于以下知识点的影响：&lt;/p&gt;
&lt;p&gt;1、变量的声明与赋值&lt;/p&gt;
&lt;p&gt;2、locals() 取值与修改的逻辑&lt;/p&gt;
&lt;p&gt;3、locals() 字典与局部命名空间的关系&lt;/p&gt;
&lt;p&gt;4、函数的编译，抽象语法树的解析&lt;/p&gt;
&lt;p&gt;注意：exec() 函数有两个缺省的参数 globals() 与 locals() （与内置函数同名），起的是限定字符串参数中变量的作用，若添加出来，只会增加以上例子的复杂度，因此，我们都做缺省处理，这里讨论的是 exec() 只有一个参数的情况。&lt;/p&gt;
&lt;p&gt;在某些编程语言中，变量的声明与赋值是可以分开的，例如在声明时写 &lt;code&gt;int a&lt;/code&gt; ，需要赋值时，再写 &lt;code&gt;a = 1&lt;/code&gt; ，当然也可不拆分，则是 &lt;code&gt;int a = 1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;对应到 Python 中，情况就不同了，这两个动作在书写时是合二为一的。首先它不用指定变量的类型，任何时候都不需要（也不能）在变量前加类型（如 int），其次，声明与赋值过程无法拆分书写，即只能写成 &lt;code&gt;a = 1&lt;/code&gt; 这样。看起来它跟其它语言的赋值写法一样，但实际上，它的效果是 &lt;code&gt;int a = 1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这虽然是一种便利，但也隐藏了一个不易察觉的陷阱（划重点）：&lt;strong&gt;当看到 &lt;code&gt;a = 1&lt;/code&gt; 时，你无法确定 a 是初次声明的，还是已被声明过的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 locals() 的创建过程，在《&lt;a href=&quot;https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A&quot;&gt;Python 动态赋值的陷阱&lt;/a&gt;》文中有所分析，locals() 字典是局部命名空间的代理，它会采集局部作用域的变量，代码运行期若动态修改局部变量，只会影响该字典，并不会影响真正的局部作用域的变量。因此，当再次调用 locals() 时，由于重新采集，则动态修改的内容会被丢弃。&lt;/p&gt;
&lt;p&gt;运行期的局部命名空间不可改变，这意味着 exec() 函数中的变量赋值不会对它产生影响，但 locals() 字典是可变的，会受到 exec() 函数的影响。&lt;/p&gt;
&lt;p&gt;而关于函数的编译，我在《&lt;a href=&quot;https://mp.weixin.qq.com/s/EsWmCbH3RtL_QpafyMryOw&quot;&gt;Python与家国天下&lt;/a&gt;》中写到了对 &lt;strong&gt;抽象语法树&lt;/strong&gt; 的分析，Python 在编译时就确定了局部作用域内合法的变量名，在运行时再与内容绑定。作用域内变量的解析跟它的执行顺序无关，更与是否会被执行无关。&lt;/p&gt;
&lt;h2 id=&quot;薛定谔的猫&quot;&gt;（3）薛定谔的猫&lt;/h2&gt;
&lt;p&gt;以上内容是前提，友情提示，如你有理解模糊之处，请先阅读对应的文章。接下来则是基于这些内容而作的分析。&lt;/p&gt;
&lt;p&gt;我不敢保证每个细节都准确无误，但这个分析力求达到深入浅出、面面俱到、逻辑自恰，而且顺便幽默有趣……&lt;/p&gt;
&lt;p&gt;例 0 中，局部作用域内虽然没有 ‘y’，但 exec() 函数动态创建了它，因此动态地写入了 locals() 字典中，所以能查找到而不报错。&lt;/p&gt;
&lt;p&gt;例 1 中，exec() 不影响局部作用域，即此时 y 未在局部作用域内做过声明与赋值，接下来的一句才是&lt;strong&gt;第一次在局部作用域中对 y 作声明与赋值&lt;/strong&gt; ！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;y = locals()['y']&lt;/code&gt; ，等号左侧在做声明，只要等号右侧的结果成立，整个声明与赋值的过程就成立。右侧需在 locals() 字典中查找 y 对应的值。&lt;/p&gt;
&lt;p&gt;在创建 locals() 字典时，由于局部作用域内有变量 y 的声明，因此我们首先在其中采集到了 y，而不必在 exec() 函数的动态结果中查找。这就有了字典的一个 key，接着要匹配这个 key 对应的值，也即 y 所绑定的值。&lt;/p&gt;
&lt;p&gt;但是，刚才说了这是 y 的第一次赋值，并未完成呢，因此 y 并无有效的绑定值。&lt;/p&gt;
&lt;p&gt;矛盾出现了，这里有点绕，我们理一下：左侧的 y 等着完成赋值，因此需要右侧的执行结果；而右侧的字典需要使用到 y 的值，因此就依赖着左侧的 y 完成赋值。两边的操作都未完成，但双方都需要依赖对方先完成，这是个无法破解的死局。&lt;/p&gt;
&lt;p&gt;可以说，y 的值是一团混沌，它必然等于 “locals()['y']” ，然而只有解开这团代码才能确切得到结果——只有打开笼子才知道结果，你是否想到了薛定谔的那只猫呢？&lt;/p&gt;
&lt;p&gt;locals() 字典虽然拿到了 y 的名，却拿不到它的实，空欢喜一场，所以报 KeyError。&lt;/p&gt;
&lt;p&gt;例 3 同理，未完成赋值就使用，所以报错。&lt;/p&gt;
&lt;p&gt;例 2 中，y 在二次赋值的过程时，局部命名空间中已经存在着有效的 y 等于 2，因此 locals() 查找到它而用于赋值，所以不报错。&lt;/p&gt;
&lt;p&gt;至于例 4，它跟例 3 只差了一个执行顺序，为什么不会报错呢？还有更奇怪的，在例 4 上再加一个打印（例5），理应不会影响结果，可事实却是又报错了，为什么？&lt;/p&gt;
&lt;p&gt;例 4 中，&lt;code&gt;boc = locals()&lt;/code&gt; 这句同样存在循环引用的问题，因此执行后的字典中没有 y，接着 exec() 这句动态地修改了 locals()，执行后 boc 的结果是 {'y' : 2}，因此再下一句的 boc['y'] 能查找到结果，而不报错。&lt;/p&gt;
&lt;p&gt;例 4 与例 3 的 ”y = boc['y']“ ，虽然都是第一次在局部作用域中声明与赋值 y，但例 4 的 boc 已被 exec() 修改过，因此它能取到实实在在的值，就不再有循环引用的问题了。&lt;/p&gt;
&lt;p&gt;接着看例 5，第一个 locals() 还是存在循环引用现象，接着 exec() 往字典中写入变量 y，但是，第二个 locals() 又触发了新的创建字典过程，会把 exec() 的执行结果覆盖，因此进入第二轮循环引用，导致报错。&lt;/p&gt;
&lt;p&gt;例 5 与例 4 的不同在于，它是根据局部作用域重新生成的字典，其效果等同于例 3。&lt;/p&gt;
&lt;p&gt;另外，请特别注意打印的结果：&lt;strong&gt;{'boc': {…}}&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这个结果说明，第二个 locals() 是一个字典，而且它只有唯一的 key 是 ’boc‘，而 ’boc‘ 映射的是第一个 locals() 字典，也即是 {...} 。这个写法表示它内部出现了循环引用，直观地证实了前面的所有分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典内部出现循环引用&lt;/strong&gt; ，这个现象极其罕见！前面虽然做了分析，但看到这里的时候，不知道你是否觉得不可思议？&lt;/p&gt;
&lt;p&gt;之所以第一次的循环引用能被记录下来，原因在于我们没有试图去取出 ’y‘ 的值，而第二个循环引用则由于取值报错而无法记录下来。&lt;/p&gt;
&lt;p&gt;这个例子告诉大家：&lt;strong&gt;薛定谔的猫混入了 Python 的字典中，而且答案是，打开笼子，这只猫就会死亡。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字典的循环引用现象在几个例子中扮演了极其重要的角色，但是往往被人忽视。之所以难以被人觉察，原因还是前面划重点的内容：&lt;strong&gt;当看到 &lt;code&gt;a = 1&lt;/code&gt; 时，你无法确定 a 是初次声明的，还是已被声明过的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s/EsWmCbH3RtL_QpafyMryOw&quot;&gt;Python与家国天下&lt;/a&gt;》文中，猫哥分析了两类经典的报错：name 'x' is not defined、local variable 'x' referenced before assignment。它们通常也是由于声明与赋值不分，而导致的失察。&lt;/p&gt;
&lt;p&gt;本文中的 KeyError 实际上就是 “local variable 'y' referenced before assignment”，y 已 defined 而未 assigned，导致 reference 时报错。&lt;/p&gt;
&lt;p&gt;已赋值还是未赋值，这是个问题。也是一只猫。&lt;/p&gt;
&lt;p&gt;最后，尽管这只猫在暗中捣了大乱，我们还是要感谢它：感谢它串联了其它知识被我们“一锅端”，感谢它为这篇抽象烧脑的文章挠出了几分活泼生动的趣味……（以及，感谢它带来的标题灵感，不知道有多少人是冲着标题而阅读的？）&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;本文中的几个例子早在 3 月 24 日就想到了，但我没法给自己一套完全满意的解答。在与群内小伙伴们陆续讨论了一整个下午后，我依然不满足，最终打消了写入《&lt;a href=&quot;https://mp.weixin.qq.com/s/6V8z2Gr94PpLbbUUo1K3AQ&quot;&gt;深度辨析 Python 的 eval() 与 exec()&lt;/a&gt;》这篇文章的念头。两个月来，群内偶尔讨论过几次相关的知识点，感谢好几位同学（特别@樱雨楼）的讨论，我终于觉得时机到了（其实是稿荒啦），把沉睡近两个月的草稿翻出来……如今的分析，我自认为是能说得通，而且关键细节无遗漏的，但仍可能有瑕疵，如果你有什么想交流的，欢迎给我留言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bly1g2aiq1kpa8j21hc0nmgs4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】， 本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、技术写作、优质英文推荐与翻译等等，欢迎关注哦。后台回复“&lt;strong&gt;爱学习&lt;/strong&gt;”，免费获得一份学习大礼包。&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 11:49:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>本文原创并首发于公众号【 Python猫 】，未经授权，请勿转载。 原文地址：https://mp.weixin.qq.com/s/ fFVTgWVsydFsNu1nyxUzA Python 是一门强</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythonista/p/10883351.html</dc:identifier>
</item>
<item>
<title>I/O复用 - 一盏淡酒、醉了夕阳</title>
<link>http://www.cnblogs.com/helloworldcode/p/10883130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helloworldcode/p/10883130.html</guid>
<description>&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;　　内核（操作系统）一旦发现进程指定的一个或者多个IO条件准备读或者准备写的时候，就会给该进程发一个通知。当服务端要处理多个套接字文件描述符的时候，这个时候可以采用IO复用，操作系统发现哪些套接字文件描述符可读或可写的时候，就会通知相应的进程才去执行对应的read（保证文件描述符对应的地址有可用的数据返回，而不是由于试探性的返回无用的值）或write操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可以举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　例如：现在李老师收取刚刚布置给学生要默写在纸上的古诗的作业。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　第一种情况：李老师按照学号的顺序来收取，并且会等待将要收取作业的同学同意提交作业，直到该同学提交作业，才会去下一个学号的同学那里去询问是否提交作业。（循环处理每个socket，不支持高并发，效率低）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　第二种情况：李老师向其他老师请求帮助，拉来了很多老师帮忙收作业，每个老师处理一小部分学生的古诗词作业的提交任务。（相当与创建多个进程或者线程处理socket）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　第三种情况：李老师站在讲台上，根据同学们的反应来做出相应的动作（如果谁的要提交作业，该同学就举手），某些同学举手后，李就会去收取这些同学的作业。（IO复用）&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;系统调用函数实现IO复用&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;将多个文件描述符集中到一起统一监视。比如对多个套接字进行统一管理与调度 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.select函数&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　函数会做的事情包括：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;检测是否存在套接字接受数据&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;检测是否存在套接字无阻塞的传输数据&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;哪些套接字发生了异常&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;该函数的调用时的顺序&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1. 设置文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;将需要监视的文件描述符集中到一起(fd_set)，集中的时候要按照监视项来区分（包括接收，传输，异常）。&lt;span&gt;&lt;code&gt;fd_set&lt;/code&gt;&lt;span&gt;结构体如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
/* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;
/* Number of descriptors that can fit in an `fd_set'.  */
#define __FD_SETSIZE        1024
/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
#define __NFDBITS   (8 * (int) sizeof (__fd_mask))
/* fd_set for select and pselect.  */
typedef struct
  {
    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
  } fd_set;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;fd_set&lt;/code&gt;&lt;span&gt;结构如下（有三种情况，监听接收作用的fd_set，监听传输作用的fd_set，监听异常作用的fd_set），当对应的区上的位置的值0被置为1，表示该位置对应的文件描述符正在被监视，或可读或可写，亦或者是有异常：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1047362/201905/1047362-20190517185054034-1749463044.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./img/fd_set_s.jpg&quot;&gt;在&lt;code&gt;fd_set&lt;/code&gt;中注册文件描述符或者更改值的操作都是由相关宏来完成的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
/* Access macros for `fd_set'.  */
#define FD_SET(fd, fdsetp)  __FD_SET (fd, fdsetp)  
#define FD_CLR(fd, fdsetp)  __FD_CLR (fd, fdsetp)  
#define FD_ISSET(fd, fdsetp)    __FD_ISSET (fd, fdsetp)
#define FD_ZERO(fdsetp)     __FD_ZERO (fdsetp)  
​
FD_ZERO(fd_set* fdset);           //将fd_set的所有位都初始化为0 
FD_SET(int fd, fd_set* fdset);    //在fd_set中注册文件描述符fd的信息
FD_CLR(int fd, fd_set* fdset);    //从参数fd_set中清除文件描述符fd的信息
FD_ISSET(int fd, fd_set* fdset);  //若参数fd_set所指向的变量包含文件描述符fd的信息，则返回1，否则返回0/* Access macros for `fd_set'.  */
#define FD_SET(fd, fdsetp)  __FD_SET (fd, fdsetp)  
#define FD_CLR(fd, fdsetp)  __FD_CLR (fd, fdsetp)  
#define FD_ISSET(fd, fdsetp)    __FD_ISSET (fd, fdsetp)
#define FD_ZERO(fdsetp)     __FD_ZERO (fdsetp)  
​
FD_ZERO(fd_set* fdset);           //将fd_set的所有位都初始化为0 
FD_SET(int fd, fd_set* fdset);    //在fd_set中注册文件描述符fd的信息
FD_CLR(int fd, fd_set* fdset);    //从参数fd_set中清除文件描述符fd的信息
FD_ISSET(int fd, fd_set* fdset);  //若参数fd_set所指向的变量包含文件描述符fd的信息，则返回1，否则返回0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.指定监视范围和超时&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;　　select&lt;/code&gt;&lt;span&gt;函数的原型如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.
​
   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds,
           fd_set *__restrict __writefds,
           fd_set *__restrict __exceptfds,
           struct timeval *__restrict __timeout);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个参数：监视对象文件描述符的数量&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第二个参数：传递包含所有关注“是否存在待读取”的文件描述符的fdset。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第三个参数：传递包含所有关注“是否可传输无阻塞数据”的文件描述符的fdset 。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第三个参数：传递包含所有关注“是否可发生异常”的文件描述符的fdset 。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第四个参数：为防止陷入无限阻塞的状态， 传递超时信息。&lt;/span&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3. 调用select函数&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　调用函数返回结果：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot;&gt;&lt;li&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;4. 调用select查看结果&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;　　select&lt;/code&gt;&lt;span&gt;函数返回值如果是大于0的整数，表示相应数量的文件描述符发生了变化。如下图示例，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1047362/201905/1047362-20190517185338260-1803784896.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./img/fd_set_change.png&quot;&gt;&lt;img src=&quot;file:///home/gqx/github/Socket-Program/concurrence_Server/img/fd_set_change.png?lastModify=1558089890&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　调用函数select函数时，向其传递的fd_set变量将发送变化，所有的1都被为0，但发生变化变化的文件描述符对应的位除外，如图，调用select函数结束后，可知传入的fd_set中只有fd1和fd3是1，即它们对应的文件描述符发生了变化。&lt;/span&gt;&lt;/p&gt;

&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;进一步理解select函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;理解select模型的关键在于理解fd_set(这里声明的变量名为reads)这个数据结构，现在假设fd_set的大小是1字节，即8个bit（位）。执行过程可以这样表示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;5.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;第一步：FD_ZERO(&amp;amp;reads); 将read指向的fd_set初始化为00000000。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;将对应位设置处于监听状态，如fd=6，FD_SET(fd, &amp;amp;reads);此时fd_set变为00100000。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果还有需要监听的文件描述符，fd1=1，fd2=2，通过FD_SET后结果变为00100011。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;4&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;调用select(7,reads,0,0,timeval)阻塞等待。默认是从位置0开始，所以要将最大的fd_max+1。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果此时fd=2对应的文件描述服发生了可读事件，select调用结束，此时fd_set对应的值是00000010，没有事件发生所对应的位将被清空。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;示例程序&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;利用select监听键盘输入操作：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;sys/select.h&amp;gt;
using namespace std;
#define BUF_SIZE 30
​
int main(){
    fd_set reads, temps;
    int result, str_len;
    char buf[BUF_SIZE];
    struct timeval timeout;
​
    FD_ZERO(&amp;amp;reads);
    FD_SET(0, &amp;amp;reads);  //0-该位置是控制台的标准输入
​
    while (1) {
        temps = reads;
        timeout.tv_sec = 5; //秒
        timeout.tv_usec = 0; //微秒
        result = select(1, &amp;amp;temps, 0, 0, &amp;amp;timeout);
        if(result == -1){
            puts(&quot;select() error...&quot;);
            break;
        }
        else if(result == 0){
            puts(&quot;Time wait...&quot;);
        }else{
            if(FD_ISSET(0, &amp;amp;temps)){    //fd_set指向的变量中包含文件描述符的信息，返回真
                str_len = read(0, buf, BUF_SIZE);
                buf[str_len] = 0;
                printf(&quot;message from console: %s.&quot;, buf);
            }
        }
​
    }
​
    return 0;
}
​
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;select模型的特点&lt;/strong&gt;&lt;/h4&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可监控的文件描述符的数量与机器对应的fd_set大小有关，即sizeof(fd_set);&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;将fd_set传入到select函数调用前，还需要一个fd_set结构存储源数据，用于和调用select函数后的fd_set进行逐位对比，如果有事件发生，则通过FD_ISSET返回；如果原来标记为1，处于监听的文件描述符但没有事件发生，此时会将其置为0;。如上面示例程序的reads和temps。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;select上接收到普通数据或者带外数据会使select返回不同的就绪状态，普通数据触发可读状态，带外数据触发异常状态。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如下，是一个I/O复用的服务端的案例用来解决多客户端请求的问题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;68&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include&amp;lt;sys/socket.h&amp;gt;
​
#define BUF_SIZE 100
void error_handling(char* message);
​
int main(int argc, char *argv[]){
    int serv_sock, clnt_sock;
    struct sockaddr_in serv_adr, clnt_adr;
    struct timeval timeout;
    fd_set reads, cpy_reads;
​
    socklen_t adr_sz;
    int fd_max, str_len, fd_num, i;
    char buf[BUF_SIZE];
    if(argc != 2){
        printf(&quot;Usage : %s &amp;lt;port&amp;gt;\n&quot;, argv[0]);
        exit(1);
    }
​
    serv_sock = socket(PF_INET, SOCK_STREAM, 0);
    memset(&amp;amp;serv_adr, 0, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(atoi(argv[1]));
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
​
    if(bind(serv_sock, (struct sockaddr*)&amp;amp;serv_adr, sizeof(serv_adr)) == -1){
        error_handling(&quot;bind() error.........&quot;);
    }
​
    if(listen(serv_sock, 5) == -1){
        error_handling(&quot;listen error.........&quot;);
    }
​
    FD_ZERO(&amp;amp;reads);
    FD_SET(serv_sock, &amp;amp;reads);
    fd_max = serv_sock;
​
    while(1){   //无限循环中调用select
        cpy_reads = reads;
        timeout.tv_sec = 5;
        timeout.tv_usec = 500;
​
        if((fd_num = select(fd_max+1, &amp;amp;cpy_reads, 0, 0, &amp;amp;timeout)) == -1)
            break;
​
        if(fd_num == 0)
            continue;
​
        for(i = 0; i &amp;lt; fd_max+1; i++){  //遍历观察那些文件描述符发生了变化
            if(FD_ISSET(i, &amp;amp;cpy_reads))  //观察fd_set中位发生变化
            {
                if(i == serv_sock){     //如果是连接请求
                    adr_sz = sizeof(clnt_adr);
                    clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;amp;clnt_adr, &amp;amp;adr_sz);
                    FD_SET(clnt_sock, &amp;amp;reads);
                    if(fd_max &amp;lt; clnt_sock)  //如果clnt_sock对应fd_set中位置大于原先设定的需要监听的范围，则修改监听范围。
                        fd_max  = clnt_sock;
                    printf(&quot;Connected client : %d \n&quot;, clnt_sock);
                }
                else{   //某些套接字文件描述符指向的信息发生了改变，即收到通知，该文件描述符现在可读
                    str_len = read(i, buf, BUF_SIZE);
                    if(str_len == 0){
                        FD_CLR(i,&amp;amp;reads);
                        close(i);
                        printf(&quot;close client:%d \n&quot;, i);
                    }else{
                        write(i, buf, str_len);
                    }
                }
            }
        }
    }
    close(serv_sock);
    return 0;
}
​
void error_handling(char* message){
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.epoll&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;epoll是在2.5.44版内核中提出的（在使用前，应该验证一下内核版本，现在大部分内核版本都在2.6以上，可以通过&lt;span&gt;&lt;code&gt;cat /proc/sys/kernel/osrelease&lt;/code&gt;&lt;span&gt;查看），而且epoll方式只在linux下体统支持。关于epoll实现的三个函数：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;sys/epoll.h&amp;gt;
int epoll_create(int size); 
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;epoll_create&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int epoll_create(int size);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通过调用该函数执行成功后创建的文件描述符保存空间被称为“epoll例程”，参数size只是为操作系统提供一个参考需要为epoll例程多大的空间，即size大小并不等于最终的epoll例程大小。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;epoll_ctl&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;生成epoll例程后，在其内部注册监视对象文件描述符时需要用到&lt;span&gt;&lt;code&gt;epoll_ctl&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;epfd 用于注册监视对象的epoll实例（文件描述符）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;op 指定监视对象的添加，删除或修改等操作&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;fd 需要监视对象的文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;event 监视对象的事件类型&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;op可以有3个值，分别为：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLL_CTL_ADD : 添加监听的事件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLL_CTL_DEL : 删除监听的事件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLL_CTL_MOD : 修改监听的事件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如&lt;span&gt;&lt;code&gt;epoll_ctl(A, EPOLL_CTL_ADD, B, C)&lt;/code&gt;&lt;span&gt;表示在epoll例程A中注册文件描述符B用于监视参数C中的事件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　epoll_event的结构体如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct epoll_event {
    __uint32_t   events; /* Epoll events */
    epoll_data_t data;   /* User data variable 根据用户需求定制 */
};
typedef union epoll_data {
    void        *ptr;
    int          fd;
    __uint32_t   u32;
    __uint64_t   u64;
} epoll_data_t;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;epoll_event的event中保存的常量及其对应的具体时间类型&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLERR : 文件上发上了一个错误。这个事件是一直监控的，即使没有明确指定&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLHUP : 文件被挂断。这个事件是一直监控的，即使没有明确指定&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLRDHUP : 对端关闭连接或者shutdown写入半连接&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLET : 开启边缘触发，默认的是水平触发，所以我们并未看到EPOLLLT&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLONESHOT : 一个事件发生并读取后，文件自动不再监控&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLIN : 文件可读&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLPRI : 文件有紧急数据可读&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLOUT : 文件可写&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EPOLLWAKEUP : 如果EPOLLONESHOT和EPOLLET清除了，并且进程拥有CAP_BLOCK_SUSPEND权限，那么这个标志能够保证事件在挂起或者处理的时候，系统不会挂起或休眠&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如下示例代码展示其过程&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct epoll_event event;
event.events = EPOLLIN; //发生需要读取数据的情况时
event.data.fd = sockfd;
epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,event);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果&lt;span&gt;&lt;code&gt;epoll_ctl&lt;/code&gt;&lt;span&gt;方法返回-1，则标志出现了问题，我们可以读取errno来定位错误，有如下errno会被设置：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EBADF : epfd或者fd不是一个有效的文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EEXIST : op为EPOLL_CTL_ADD，但fd已经被监控&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;EINVAL : epfd是无效的epoll文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ENOENT : op为EPOLL_CTL_MOD或者EPOLL_CTL_DEL，并且fd未被监控&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ENOMEM : 没有足够的内存完成当前操作&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ENOSPC : epoll实例超过了/proc/sys/fs/epoll/max_user_watches中限制的监听数量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;epoll_wait&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;参数说明：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;epfd 用于注册监视对象的epoll实例（文件描述符）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;events 保存发生事件的文件描述符集合的结构体地址值（数组首地址）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;maxevents 保存的最大事件数量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;timeout 等待时间（毫秒），-1表示一直等待事件的发生&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;该函数的作用类似与select函数。该函数被调用后，返回发生事件的文件描述符数，同时，第二个参数保存发生事件的文件描述符集合。此时，就不需要向像select那样针对所有文件描述符进行循环扫描，确定发生事件的文件描述符。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;工作模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　epoll对文件描述符的操作有两种模式：LT（level trigger 条件触发）和ET（edge trigger 边缘触发）。LT模式是默认模式，LT模式与ET模式的区别可以通过TCP/IP网络编程书中的案例进行解释：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;LT 水平触发&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;7&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，我收到了5000元压岁钱。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“恩，省着点花！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，我今天买了个ipad，花了3000元。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“噢，这东西真贵。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，我今天买好多吃的，还剩1000元。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“用完了这些钱，我可不会再给你了。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，那1000元我没花，零花钱够用了。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“恩，这才是明智的做法！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，那1000元我没花，我要攒起来。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“恩，加油！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　&lt;/span&gt;只要儿子手中还有钱，他就会一直汇报，这就是LT模式。有钱就是1，没钱就是0，那么只要儿子还有钱，这种事件就是1-&amp;gt;1类型事件，自然是LT。将案例中儿子钱包换成输入缓冲区，压岁钱换成输入数据，在条件触发中，只要输入缓冲区有数据，将将会以事件的方式再次注册。&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ET 边缘触发&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“妈妈，我收到了5000元压岁钱。”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“恩，省着点花！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;儿子：“……”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;妈妈：“你倒是说话啊？压岁钱呢？！”&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　儿子从没钱到有钱，是一个0-&amp;gt;1的过程，因此为ET。儿子和妈妈说过自己拿到了压岁钱就完事了，至于怎么花钱，还剩多少钱，一概不说。可以看出，边缘触发中输入缓冲区中收到数据时仅注册一次，即使输入缓冲区中还有数据，也不会再次注册。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;示例程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　基于socket的客户端和服务端利用epoll来处理I/O复用问题：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务端程序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;70&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include&amp;lt;sys/socket.h&amp;gt;
#include&amp;lt;sys/epoll.h&amp;gt;
#define BUF_SIZE 4
#define EPOLL_SIZE 50
void error_handling(char* message);
​
int main(int argc, char *argv[]){
    int serv_sock, clnt_sock;
    struct sockaddr_in serv_adr, clnt_adr;
​
​
    socklen_t adr_sz;
    int  str_len, i;
    char buf[BUF_SIZE];
    if(argc != 2){
        printf(&quot;Usage : %s &amp;lt;port&amp;gt;\n&quot;, argv[0]);
        exit(1);
    }
​
    struct epoll_event* ep_events;
    struct epoll_event event;
    int epfd, event_cnt;
​
    serv_sock = socket(PF_INET, SOCK_STREAM, 0);
    memset(&amp;amp;serv_adr, 0, sizeof(serv_adr));
    serv_adr.sin_family = AF_INET;
    serv_adr.sin_port = htons(atoi(argv[1]));
    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
​
    if(bind(serv_sock, (struct sockaddr*)&amp;amp;serv_adr, sizeof(serv_adr)) == -1){
        error_handling(&quot;bind() error.........&quot;);
    }
​
    if(listen(serv_sock, 5) == -1){
        error_handling(&quot;listen error.........&quot;);
    }
​
    epfd = epoll_create(EPOLL_SIZE); //返回创建的epoll文件描述符
    ep_events = (struct epoll_event*)malloc(sizeof(struct epoll_event)*EPOLL_SIZE);
​
    event.events = EPOLLIN; //发生读取事件的时候
    event.data.fd = serv_sock;
    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;amp;event);
​
    while(1){
        event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1);
​
        if(event_cnt == -1){
            error_handling(&quot;epoll_wait() failed...&quot;);
        }
​
        puts(&quot;return epoll_wait&quot;);
        for(i = 0; i &amp;lt; event_cnt; i++){
            if(ep_events[i].data.fd == serv_sock){  //处理新进的连接请求
                adr_sz = sizeof(clnt_adr);
                clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;amp;clnt_adr, &amp;amp;adr_sz);
                event.data.fd = clnt_sock;
                event.events= EPOLLIN;
                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;amp;event);
                printf(&quot;Connected client: %d \n&quot;, clnt_sock);
            }else{
                str_len = read(ep_events[i].data.fd, buf, BUF_SIZE);
                if(str_len == 0){   // 关闭客户端连接
                    epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); //将读取完的连接取消监听
                    close(ep_events[i].data.fd);    //关闭客户端连接
                    printf(&quot;close client: %d \n&quot;, ep_events[i].data.fd);
                }else{
                    write(ep_events[i].data.fd, buf, str_len);
                }
            }
        }
    }
    close(serv_sock);
    close(epfd);
    return 0;
}
​
void error_handling(char* message){
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;客户端程序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
using namespace std;
​
#define BUF_SIZE 1024
void errorhandling(char *message);
​
int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in serv_addr;
    char message[BUF_SIZE];
    int str_len = 0 ,idx = 0, read_len = 0;
​
    if(argc != 3){
        printf( &quot;Usage : %d &amp;lt;IP&amp;gt; &amp;lt;port&amp;gt; &quot;, argv[0]);
        exit(0);
    }
​
    sock = socket(PF_INET, SOCK_STREAM, 0);
    if(sock == -1){
        errorhandling(&quot;socket() error;&quot;);
    }
​
    memset(&amp;amp;serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
    serv_addr.sin_port = htons(atoi(argv[2]));
​
    if(connect(sock, (struct sockaddr*)&amp;amp;serv_addr, sizeof(serv_addr)) == -1){
        errorhandling(&quot;connect error!&quot;);
    }else{
        printf(&quot;connected.....\n&quot;);
    }
​
    while(1){
        fgets(message, BUF_SIZE, stdin);
        fflush(stdin);
        if(!strcmp(message, &quot;q\n&quot;) || !strcmp(message, &quot;Q\n&quot;))
            break;
        write(sock, message, strlen(message));
         memset(message, 0, sizeof(message));
        str_len = read(sock, message, BUF_SIZE - 1);
        message[str_len] = '\0';
        printf(&quot;Message from server : %s&quot;, message);
    }
​
    close(sock);
    return 0;
}
​
void errorhandling(char *message){
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;TCP/IP网络编程（[韩&lt;span&gt;] &lt;span&gt;尹圣雨 ）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.zhihu.com/question/28594409&quot;&gt;&lt;span&gt;I/O多路复用技术（multiplexing）是什么？&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/skyfsm/p/7079458.html&quot;&gt;&lt;span&gt;Linux编程之select&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/Anker/p/3263780.html&quot;&gt;&lt;span&gt;IO多路复用之epoll总结&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;span class=&quot;md-content md-url&quot;&gt;&lt;span class=&quot;md-meta&quot;&gt;&lt;span class=&quot;md-content md-link-title&quot;&gt;&lt;span class=&quot;md-meta md-after&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 10:59:00 +0000</pubDate>
<dc:creator>一盏淡酒、醉了夕阳</dc:creator>
<og:description>内核（操作系统）一旦发现进程指定的一个或者多个IO条件准备读或者准备写的时候，就会给该进程发一个通知。当服务端要处理多个套接字文件描述符的时候，这个时候可以采用IO复用，操作系统发现哪些套接字文件描述</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/helloworldcode/p/10883130.html</dc:identifier>
</item>
</channel>
</rss>