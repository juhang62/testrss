<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>单元测试框架之unittest(五) - davieyang</title>
<link>http://www.cnblogs.com/davieyang/p/10162485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davieyang/p/10162485.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding = utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  被测试类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ToBeTest(object):
    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sum(cls, a, b):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b

    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; div(cls, a, b):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a/&lt;span&gt;b

    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; return_none(cls):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  单元测试类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestToBeTest(unittest.TestCase):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertEqual()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertequal(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            a, b &lt;/span&gt;= 100, 200&lt;span&gt;
            sum &lt;/span&gt;= 300
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言a+b等于sum&lt;/span&gt;
            self.assertEqual(a + b, sum, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;断言失败，%s+%s != %s &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(a, b, sum))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertNotEqual()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertnotequal(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            a, b &lt;/span&gt;= 100, 200&lt;span&gt;
            res &lt;/span&gt;= -1000
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言a-b不等于res&lt;/span&gt;
            self.assertNotEqual(a - b, res, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;断言失败，%s-%s != %s &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(a, b, res))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertTure()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_asserttrue(self):
        list1 &lt;/span&gt;= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10&lt;span&gt;]
        list2 &lt;/span&gt;= [10, 9, 8, 7, 6, 5, 4, 3, 2, 1&lt;span&gt;]
        list3 &lt;/span&gt;= list1[::-1&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list3)
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言表达式为真&lt;/span&gt;
            self.assertTrue(list3 == list2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;表达式为假&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertFalse()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertfalse(self):
        list1 &lt;/span&gt;= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10&lt;span&gt;]
        list2 &lt;/span&gt;= [10, 9, 8, 7, 6, 5, 4, 3, 2, 1&lt;span&gt;]
        list3 &lt;/span&gt;= list1[::-1&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  断言表达式为假&lt;/span&gt;
            self.assertFalse(list3 == list1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;表达式为真&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertIs()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertis(self):
        list1 &lt;/span&gt;= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10&lt;span&gt;]
        list2 &lt;/span&gt;=&lt;span&gt; list1
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言list2和list1属于同一个对象&lt;/span&gt;
            self.assertIs(list1, list2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 与 %s 不属于同一对象&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (list1, list2))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertIsNot()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertisnot(self):
        list1 &lt;/span&gt;= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10&lt;span&gt;]
        list2 &lt;/span&gt;= [10, 9, 8, 7, 6, 5, 4, 3, 2, 1&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言list2和list1不属于同一个对象&lt;/span&gt;
            self.assertIsNot(list2, list1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 与 %s 属于同一对象&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (list1, list2))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertIsNone()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertisnone(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            results &lt;/span&gt;=&lt;span&gt; ToBeTest.return_none()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言表达式结果是none&lt;/span&gt;
            self.assertIsNone(results, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is not none&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertIsNotNone()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertisnotnone(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            results &lt;/span&gt;= ToBeTest.sum(4, 5&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言表达式结果不是none&lt;/span&gt;
            self.assertIsNotNone(results, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is none&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertIn()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertin(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            str1 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is unit test demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            str2 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言str2包含在str1中&lt;/span&gt;
            self.assertIn(str2, str1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 不被包含在 %s中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(str2, str1))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertNotIn()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertnotin(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            str1 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is unit test demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            str2 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言str2不包含在str1中&lt;/span&gt;
            self.assertNotIn(str2, str1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 包含在 %s 中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (str2, str1))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertIsInstance()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertisinstance(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            o &lt;/span&gt;=&lt;span&gt; ToBeTest
            k &lt;/span&gt;=&lt;span&gt; object
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言测试对象o是k的类型&lt;/span&gt;
            self.assertIsInstance(o, k, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的类型不是%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (o, k))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertNotIsInstance()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertnotisinstance(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            o &lt;/span&gt;=&lt;span&gt; ToBeTest
            k &lt;/span&gt;=&lt;span&gt; int
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言测试对象o不是k的类型&lt;/span&gt;
            self.assertNotIsInstance(o, k, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 的类型是%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (o, k))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertRaises()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertraises(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试抛出指定的异常类型&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertRaises(exception)&lt;/span&gt;
&lt;span&gt;        with self.assertRaises(TypeError) as exc:
            random.sample([&lt;/span&gt;1, 2, 3, 4, 5, 6], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印详细的异常信息&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exc.exception)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertRaises(exception, callable, *args, **kwds)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.assertRaises(ZeroDivisionError, ToBeTest.div, &lt;/span&gt;3&lt;span&gt;, 0)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ZeroDivisionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertRaisesRegexp()方法实例&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_assertraisesregex(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试抛出指定的异常类型，并用正则表达式去匹配异常信息&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertRaisesRegex(exception, regexp)&lt;/span&gt;
        with self.assertRaisesRegex(ValueError, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;literal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as exc:
            int(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印详细的异常信息&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exc.exception)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; assertRaisesRegex(exception, regexp, callable, *args, **kwds)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.assertRaisesRegex(ValueError, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;invalid literal for.*\'abc\'$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; AssertionError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    unittest.main()&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 26 Dec 2018 15:43:00 +0000</pubDate>
<dc:creator>davieyang</dc:creator>
<og:description>一、摘要 单元测试里很重要的一个部分就是断言，unittest为我们提供了很多断言方法 assertEqual(a, b, msg=None)断言 a == b assertNotEqual(a, b</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davieyang/p/10162485.html</dc:identifier>
</item>
<item>
<title>抽象类和接口的区别 - 丘壑山河</title>
<link>http://www.cnblogs.com/xyfer1018/p/10173186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyfer1018/p/10173186.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;抽象类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;1、抽象类使用abstract修饰；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;2、抽象类不能实例化，即不能使用new关键字来实例化对象；&lt;/p&gt;
&lt;p&gt;　　　　3、含有抽象方法（使用abstract关键字修饰的方法）的类是抽象类，必须使用abstract关键字修饰；&lt;/p&gt;
&lt;p&gt;　　　　4、抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；&lt;/p&gt;
&lt;p&gt;　　　　5、如果一个子类实现了父类（抽象类）的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类；&lt;/p&gt;
&lt;p&gt;　　　　6、抽象类中的抽象方法只有方法体，没有具体实现；&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;接口：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;1、接口使用interface修饰；&lt;/p&gt;
&lt;p&gt;　　　　2、接口不能被实例化；&lt;/p&gt;
&lt;p&gt;　　　　3、一个类只能继承一个类，但是可以实现多个接口；&lt;/p&gt;
&lt;p&gt;　　　　4、接口中方法均为抽象方法；&lt;/p&gt;
&lt;p&gt;　　　　5、接口中不能包含实例域或静态方法（静态方法必须实现，接口中方法是抽象方法，不能实现）；&lt;/p&gt;

</description>
<pubDate>Wed, 26 Dec 2018 15:34:00 +0000</pubDate>
<dc:creator>丘壑山河</dc:creator>
<og:description>抽象类： 1、抽象类使用abstract修饰； 2、抽象类不能实例化，即不能使用new关键字来实例化对象； 3、含有抽象方法（使用abstract关键字修饰的方法）的类是抽象类，必须使用abstrac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyfer1018/p/10173186.html</dc:identifier>
</item>
<item>
<title>单一职责原则 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10182494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10182494.html</guid>
<description>&lt;p&gt;个人博客原文：&lt;br/&gt;&lt;a href=&quot;http://www.liebrother.com/single-responsibility-principle&quot;&gt;单一职责原则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/5774f5e39f334c94bd20b08c2821652f_0012_01.jpg&quot; alt=&quot;景&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;设计模式六大原则之一：单一职责原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;姓名&lt;/strong&gt; ：单一职责原则&lt;br/&gt;&lt;strong&gt;英文名&lt;/strong&gt; ：Single Responsibility Principle&lt;br/&gt;&lt;strong&gt;座右铭&lt;/strong&gt; ：There should never be more than one reason for a class to change. 应当有且仅有一个原因引起类的变更。。。意思就是不管干啥，我都只干一件事，你叫我去买菜，我就只买菜，叫我顺便去倒垃圾就不干了，就这么拽&lt;br/&gt;&lt;strong&gt;脾气&lt;/strong&gt; ：一个字“拽”，两个字“特拽“&lt;br/&gt;&lt;strong&gt;伴侣&lt;/strong&gt; ：老子职责单一，哪来的伴侣？&lt;br/&gt;&lt;strong&gt;个人介绍&lt;/strong&gt; ：在这个人兼多责的社会里，我显得那么的特立独行，殊不知，现在社会上发生的很多事情都是因为没有处理好职责导致的，比如，经常有些父母带着小孩，一边玩手机，导致小孩弄丢、发生事故等等&lt;/p&gt;
&lt;h3 id=&quot;单一职责应用范围&quot;&gt;单一职责应用范围&lt;/h3&gt;
&lt;p&gt;单一职责原则适用的范围有接口、方法、类。按大家的说法，接口和方法必须保证单一职责，类就不必保证，只要符合业务就行。&lt;/p&gt;
&lt;h4 id=&quot;方法&quot;&gt;方法&lt;/h4&gt;
&lt;p&gt;设想一下这个场景：假设我们要做一个用户修改名字以及修改密码的功能，可以有多种实现方案，比如下面列举 2 种实现方式&lt;br/&gt;代码：&lt;a href=&quot;https://github.com/1CSH1/DesignPatterns/blob/master/src/com/liebrother/designpatterns/srp/SrpOfMethod.java&quot;&gt;SrpOfMethod.java&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;第一种实现方式&quot;&gt;第一种实现方式&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 错误的示范
 */
enum OprType {
    /**
     * 更新密码
     */
    UPDATE_PASSWORD,
    /**
     * 更新名字
     */
    UPDATE_NAME;
}

interface UserOpr {
    boolean updateUserInfo(User user, OprType oprType);
}

class UserOprImpl implements UserOpr {

    @Override
    public boolean updateUserInfo(User user, OprType oprType) {
        if (oprType == OprType.UPDATE_NAME) {
            // update name
        } else if (oprType == OprType.UPDATE_PASSWORD) {
            // update password
        }
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二种实现方式&quot;&gt;第二种实现方式&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 正确的示范
 */
interface UserOpr2 {
    boolean updatePassword(User user, String password);
    boolean updateUserInfo(User user);
}

class UserOprImpl2 implements UserOpr2 {

    @Override
    public boolean updatePassword(User user, String password) {
        user.setPassword(password);
        // update password
        return true;
    }

    @Override
    public boolean updateUserInfo(User user) {
        // update user info
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2 种实现有什么区别呢？ 第一种实现通过 OprType 类型的不同来做不同的事情，把修改密码和修改名字耦合在一起，容易引起问题，只要稍不注意，传错枚举值就悲剧了，在代码中也没法很直接看到是做什么操作，也就是这个方法的职责不明确。而第二种实现，把修改密码和修改名字分离开来，也就是把修改密码和修改名字都当做独自的职责处理，这样子就很清晰明了，你调用哪个方法，就很明确的知道这个方法是实现什么逻辑。结论是啥呢？用第二种方式实习才符合单一职责原则。现实中看到很多像第一种实现的代码，而且是枚举有十来个的情况，看代码真费劲。&lt;/p&gt;
&lt;h4 id=&quot;接口&quot;&gt;接口&lt;/h4&gt;
&lt;p&gt;设想一下这个场景，假设我们让小明去倒垃圾，小红去买菜，小红回来后再叫小红去洗碗。下面也举 2 个实现的例子。&lt;br/&gt;代码：&lt;a href=&quot;https://github.com/1CSH1/DesignPatterns/blob/master/src/com/liebrother/designpatterns/srp/SrpOfInterface.java&quot;&gt;SrpOfInterface.java&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;第一种实现方式-1&quot;&gt;第一种实现方式&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 错误的示范
 */
interface Housework {
    void shopping();
    void pourGarbage();
}

class XiaoMing implements Housework {

    @Override
    public void shopping() {
        // 不购物
    }

    @Override
    public void pourGarbage() {
        System.out.println(&quot;pourGarbage ...&quot;);
    }
}

class XiaoHong implements Housework {

    @Override
    public void shopping() {
        System.out.println(&quot;shopping ...&quot;);
    }

    @Override
    public void pourGarbage() {
        // 从不倒垃圾
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;中途回来小红去洗碗，要怎么实现？按这个写法，就在 Housework 接口添加 washingUp() 方法，然后小明和小红依次都实现洗碗这个方法，只是小明不做具体实现代码，这样子是不是觉得很别扭，不符合单一职责原则的，修改一个地方，不影响其他不需要改变的地方，只对需要用到的地方做修改。小明本来就不用洗碗，却要去实现洗碗这个方法。&lt;/p&gt;
&lt;h4 id=&quot;第二种实现方式-1&quot;&gt;第二种实现方式&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 正确的示范
 */
interface Shopping {
    void doShopping();
}

interface PourGarbage {
    void doPourGarbage();
}

interface WashingUp {
    void doWashingUp();
}

class XiaoMing2 implements PourGarbage {

    @Override
    public void doPourGarbage() {
        System.out.println(&quot;pourGarbage ...&quot;);
    }
}

class XiaoHong2 implements Shopping, WashingUp {

    @Override
    public void doShopping() {
        System.out.println(&quot;shopping ...&quot;);
    }

    @Override
    public void doWashingUp() {
        System.out.println(&quot;washing up ...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这种实现把不同的家务都当做不同的职责，分离开来，这种实现可以按需实现做家务的类型，小明只需要去倒垃圾，就实现 PourGarbage 接口，小红去购物和洗碗，就实现 Shopping 和 WashingUp 接口，完全不会影响到对方，这才是完美的根据单一职责原则编写出来的代码。&lt;/p&gt;
&lt;h4 id=&quot;类&quot;&gt;类&lt;/h4&gt;
&lt;p&gt;类这个看了一些资料都说没法硬性要求一定按单一职责原则分，或者说类的职责可大可小，没有很明确的像上面接口那样按照单一职责原则分就很清晰也很有道理。&lt;br/&gt;设想一下这个场景：我们要实现一个用户注册、登录、注销操作，可以像如下 2 种实现方式&lt;br/&gt;代码：&lt;a href=&quot;https://github.com/1CSH1/DesignPatterns/blob/master/src/com/liebrother/designpatterns/srp/SrpOfClass.java&quot;&gt;SrpOfClass.java&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;第一种实现方式-2&quot;&gt;第一种实现方式&lt;/h4&gt;
&lt;p&gt;从用户的角度考虑，这些操作都是用户的行为，可以放在一个统一的类 UserBiz&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class UserBiz {

    public boolean register(User user){
        // 注册操作
        return true;
    }

    public boolean login(User user) {
        // 登录操作
        return true;
    }

    public boolean logout(User user) {
        // 注销操作
        return true;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二种实现方式-2&quot;&gt;第二种实现方式&lt;/h4&gt;
&lt;p&gt;有人又说，不是说单一职责么？从业务操作考虑，需要把注册、登录、注销分开&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class UserRegisterBiz {

    public boolean register(User user){
        // 注册操作
        return true;
    }

}

class UserLoginBiz {

    public boolean login(User user) {
        // 登录操作
        return true;
    }

}

class UserLogoutBiz {

    public boolean logout(User user) {
        // 注销操作
        return true;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感觉像是在抬杠，其实这个没有好坏之分，根据具体业务具体分析，你说你的登录、注册、注销操作代码很多，需要分开，那就分开，无可厚非。&lt;/p&gt;
&lt;h3 id=&quot;好处&quot;&gt;好处&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;类的复杂性降低，实现什么职责都有清晰明确的定义&lt;/li&gt;
&lt;li&gt;可读性提高，复杂性降低，那当然可读性提高了&lt;/li&gt;
&lt;li&gt;可维护性提高，可读性提高，那当然更容易维护了&lt;/li&gt;
&lt;li&gt;变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助&lt;br/&gt;(来自《设计模式之禅》)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这个单一职责原则，目的就是提高代码的可维护性、可读性、扩展性，如果为了单一职责而破坏了这 3 个特性，可能会得不偿失。&lt;/p&gt;
&lt;p&gt;参考资料：《大话设计模式》、《Java设计模式》、《设计模式之禅》、《研磨设计模式》、《Head First 设计模式》&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/df81ac224abe46b38131a0e78f4dcf9c_wechat.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Dec 2018 15:09:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>设计模式六大原则之一：单一职责原则</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10182494.html</dc:identifier>
</item>
<item>
<title>Surging1.0发布在即，.NET开发者们，你们还在等什么？ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10182364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10182364.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;　　Surging1.0发布在即，.NET开发者们，你们还在等什么？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源，是近三十年来互联网经久不衰的话题。它不仅仅是一种技术分享的形态，更是一种开放，包容，互利共赢的互联网精神。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       不到30年前，大神林纳德·托瓦兹，在赫尔辛基大学实验室里，开发出了第一个版本的linux后，把它捐献给开源社区，开启了开源的新时代。 也许在那一天，他并没有想到，他的平凡举动对技术圈会造成如此深远的影响。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　三十年白驹过隙，三十年沧海桑田。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　  从世界，到中国，无论哪里，开源生态都呈现出一幅欣欣向荣的繁华景象。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      世界范围内著名的开源项目，除了前面提到的史诗力作Linux，还有划时代的java和hadoop，还有Chromium，还有python等，数之不尽的开源项目。这些优秀的开源框架是当今互联网的技术基石，更是无数开发者们赖以为生的法宝。开源，是当今互联网时代的主题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      中国互联网飞速发展的背后，同样离不开开源项目，包括阿里和腾讯在内的顶级互联网公司，无不把拥抱开源当作技术建设的关键一环。社区知名的Dubbo项目，将有望成为阿帕奇基金会的顶级项目，这既是阿里的骄傲，也是国人的自豪。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      犹记得记得十年前，正是倪光南老先生，为中国的开源社区摇旗呐喊，让这种思维逐渐的普及。在他的带领下，在无数优秀的企业、以及无数的开发者，一代又一代工程师们的努力下，中国的开源社区迎来了爆发期。我们有理由相信，中国的开源社区，已经有资格跟世界范围内的其他社区共同同台竞技。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       辉煌如今天，来之不易，我们也将迎来更加美好的明天。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       如果说，在开源时代，最后知后觉的企业，莫过于微软了。多少年前，微软前任CEO史蒂夫·鲍尔默，曾经一度把Linux当做毒药，然而最终却也是在以Linux为代表的开源生态的全面包围之中，将黄金宝座拱手相让。新任微软CEO萨提亚·纳德拉，临危受命，力挽狂澜，让微软最终又重新回到了巅峰。纵观世界市场，能够如此从低谷再回到巅峰的IT技术企业不多，他是如何创造这个神话的？开放的思想、勇于刷新、勇于挑战的勇敢者精神，是非常重要的原因。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　 作为微软亲儿子的.NET技术，一直以来受.NET框架的诟病，无法与其他开发语言同台竞技。而今，随着.NET CORE的诞生，终于可以摆脱历史的束缚，逆势崛起，开启新纪元。我们看到了中国NCC小组，为了推动社区的发展，做出了巨大努力。今年2018年以来，几乎每个月都会有各种类型的技术活动的举办，截止年底，参与聆听专家讲座的.NET 开发者已经超过数千人。这几千人，也许看起来只有几千人，在中国数以百万计的IT从业人员当中，也许不过沧海一粟，但也将成为未来中国最优秀开发者们的种子。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　  如点滴雨露，如润物无声。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　  也将如春华秋实，也将如百川汇海。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        他们将成长为中国IT技术工程师的顶梁柱！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        国产.NET Core微服务架构，滔滔（Surging)，从一开始就以其非凡的魅力，在技术圈获得了许多拥趸。框架的作者是中国优秀开发者们的杰出代表。Fanly，一位平凡而又伟大的开发者，一位执着而坚强的开发者。细若蔷薇，心如猛虎。曾经，作为一位优秀的开发者之外，他对摄影艺术也充满了不懈的追求。而今，他把他对于艺术的执着精神，投入到.NET Core开源社区。微服务技术在中国市场存在非常广大的需求，无论是电商、企业应用、工业领域都或多或少需要通过微服务架构来实现IT体系架构的改造，市场上也有很多微服务架构，但是这些架构，往往都是基于Java或Go语言构建的，而.NET技术圈，鲜能找到一款真正意义上、完整的微服务框架。因此他把业余时间全贡献了出来，致力于打造技术先进、思想一流、功能齐全、使用便捷、性能优异的框架。 今天我们所看到的Surging，这款充满艺术气息、基于.NetCore的微服务架构，以及与微服务相关一整套应用体系和组件，正是他智慧的结晶。短短一年多时间，从第一行代码开始，到今天即将发布1.0版本，Fanly已经为了这个产品倾注了大量精力，这数万行核心代码代表着不仅仅是一些代码，更是一种奋斗者的精神。在国内.NET开发技术圈来说，也许他外表不够英俊潇洒，也许他不是技术先行者，也许他并非大厂出身，但，他内心丰满，他的贡献堪称卓越，他的壮举令人惊叹。新生的框架，也许并非完美无瑕，但是却是五脏俱全，饱含的都是一位优秀开发者多年来技术的沉淀以及他对于未来的美好向往。没错，如果程序员热爱这个世界的方式，正是通过这一行行代码！这一行行代码，其实，正是程序员献给这大好世界的绝美乐章！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      我们期待这样的框架，我们更期待更多像Fanly这样的优秀开发者。社区之强大，不是个人之强大，也不是微软之强大，而是你、我、他之强大，是我们所有人之强大。相信，今天有一位Fanly站出来了，后面也有无穷无尽的Fanly站出来。每一个微小的组件，或宏大的架构，或者一篇技术文章，都可以成为社区的贡献。大家一起共同努力，众志成城，共同创造更好的.NET技术社区。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      相信.NET开发者们，将迎来无比灿烂的春天。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      2019年初，Surging1.0版本即将发布，让我们共同期待。&lt;/p&gt;

</description>
<pubDate>Wed, 26 Dec 2018 15:01:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>Surging1.0发布在即，.NET开发者们，你们还在等什么？ 开源，是近三十年来互联网经久不衰的话题。它不仅仅是一种技术分享的形态，更是一种开放，包容，互利共赢的互联网精神。 不到30年前，大神林</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10182364.html</dc:identifier>
</item>
<item>
<title>Redis集群架构 - palapala</title>
<link>http://www.cnblogs.com/ssskkk/p/10162651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssskkk/p/10162651.html</guid>
<description>&lt;h3&gt;Redis集群概述&lt;/h3&gt;
&lt;p&gt;集群的核心意义只有一个：保证一个节点出现了问题之后，其他的节点可以继续提供服务使用。&lt;/p&gt;
&lt;p&gt;Redis基础部分讲解过主从配置：对于主从配置可以有两类：一主二从，层级关系。开发者一主二从是常用的手段。&lt;/p&gt;
&lt;p&gt;Redis的主从配置是所有Redis集群的一个基础。但是只是依靠主从依然无法实现高可用的配置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redis集群有以下两种方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1)keepalived+twemproxy+HAProxy+sentinel&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对redis集群而言，首先在主从的基础上发展出了一个叫哨兵的处理机制，所谓的哨兵的处理机制指的是，当我三台主机的master节点出现了问题之后，会自动的在两个slave节点下重新退选举出一个新的master节点，这样就可以保证原master出现问题之后，redis数据依然存在有主从的配置。&lt;/p&gt;
&lt;p&gt;但是哨兵机制也只是针对于一种单主机的配置形式。因为不可能只使用一台主机来实现我们redis的配置。而推特网站发布了一个代理机制。可以有效的实现数据的分片存储。即：根据不同算法 实现不同主机的分片存储。&lt;/p&gt;
&lt;p&gt;以保证负载均衡，同时可以结合keepalivedh和HAProxy组件实现twemproxy的高可用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2)Redis Cluster&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis在后来的版本发展之中也退出了一个自己的redis Cluster集群配置，利用这样的配置可以不用自己来通过配置文件实现主从关系的实现，而直接通过命令完成。&lt;/p&gt;
&lt;h3&gt;keepalived+twemproxy+HAProxy+sentinel&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;哨兵机制简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;只要是进行高可用的架构部署，那么就必须保证多节点，在Redis里面使用了主从模式可以多节点配置，但是传统的主从模式设计 一旦master主机出现问题之后，两台Slave主机无法提供正常的工作支持，列如：Slave主机为只读主机，而且如果要想继续提供支持，那么至少应该通过剩余的几台Slave里面去推选出一个新的Master，并且最为重要的是：这个新的Master能够被用户的程序找到。&lt;/p&gt;
&lt;p&gt;如果要想进行哨兵机制的实现，一定需要具备有如下的几个特点：&lt;/p&gt;
&lt;p&gt;sentinel的功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）监控Monitoring&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sentinel时刻监控着redis master-slave是否正常运行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）通知Notification&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sentinel可以通过api来通知管理员，被监控的redis master-slave出现了问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）自动故障转移Automatic failover&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当redis master出现故障不可用状态，sentinel会开始一次故障转移，将其中一个salve提升为一个新的master，将其他salve重新配置使用新的master同步，并使用Redis的服务器应用程序连接时收到使用新的地址连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）配置提供者Configuration provider&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sentinel作为在集群中的权威来源，客户端连接到sentinel来获取某个服务的当前Redis主服务器的地址和其他信息。当故障发生转移时，Sentinel会报告新地址(更改哨兵文件对应的配置内容)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通常一台主机运行三个哨兵，并且该哨兵运行的端口不同，但是这三个哨兵都要去监控同一个master的地址。(找到了master就等于找到了所有的slave)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;twemproxy分片处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不管你电脑性能多好，只要你运行了Redis,那么就有可能造成一种非常可怕的局面：你电脑的内存将立刻被占满，而且一台Redis数据库的性能终归是有限制的。&lt;/p&gt;
&lt;p&gt;TwemProxy是一个专门为了这种nosql数据库设计的一款代理工具软件，这个工具软件最大的特征是可以实现数据的分片处理。所为的分片指的是根据一定的算法将要保存的数据保存到不同的节点之中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;twemProxy整合sentinel&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Twemproxy如果要与Redis集成使用的是Redis的Master节点，因为只有Master节点才具有写功能。&lt;/p&gt;
&lt;p&gt;一旦某一个Master被干掉了，则一定要重新选举出一个新的Master节点，但是这个时候会出现有一个问题：twemproxy所使用的配置文件时单独存在的。哨兵选举完成后，需要更新配置文件&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果要想保证所有的Redis集群高可用设计，需要单独准备一个shell脚本与所有的哨兵机制一起使用。 两步操作：1.、更改redis_master.conf文件(twemproxy的配置文件) 2、重新启动twemproxy进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HAProxy与twemproxy集成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Twemproxy主要功能在于数据的分片处理，而且会发现在整个Redis集群里面必须通过twemProxy，于是这个时候就有可能造成一种问题&lt;span&gt;你后面Redis集群一定会速度爆快，因为一堆的redis数据库。但是所有的性能都卡在了代理上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决办法：用HAProxy做twemproxy的代理。&lt;/p&gt;
&lt;p&gt;HAProxy是一个开源的，高性能的，基于TCP第四层和http第七应用层的千万级高并发负载均衡软件；&lt;/p&gt;
&lt;p&gt;为了保证HAProxy的高可用设计，所以应该设计有两套的HAProxy的代理主机，但是现在就出现了一个问题，如果现在提供了两套的HAProxy主机，用户应该怎么访问？需要记住两个地址吗。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;用户访问Keepalived虚拟IP，Keepalived访问主(备)HAProxy&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Keepalived是一个基于VRRP协议来实现的服务高可用方案，可用利用其来避免IP单点故障，类似的工具还有heartbeat，pacemaker。但是它一般不会单独出现，而是与其他负载均衡技术(如lvs，nginx，haproxy)一起工作来达到集群高可用。&lt;/p&gt;
&lt;p&gt;VRRP协议全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是keepalived+twemproxy+HAProxy+sentinel的整个架构图(小人是指哨兵)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1341698/201812/1341698-20181226214217224-1745962965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Redis Cluster&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;以上Redis集群作为项目的部署环境，需要追加twemproxy代理做分片，而后使用HAProxy做twemproxy的负载均衡，而后使用Keepalived作为HAProxy的vip技术，但是这样的设计成本太高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;redis-cluster，直接使用redis就可以实现所谓的分片，高可用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;redis-cluster设计的时候考虑到了去中心化，中间件，因为中心点的存在导致了性能的瓶颈，解决一个问题 会解决第二个 第三个问题。。。&lt;/p&gt;
&lt;p&gt;redis-cluster中每一个redis的服务它都可以具备分片，都可以具备集群的功能。&lt;/p&gt;
&lt;p&gt;也就是说集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其它所有节点连接，而且这些连接保持活跃。&lt;/p&gt;
&lt;p&gt;这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;redis-cluster选举(容错)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选举过程是集群中所有master参与，如果半数以上master节点与master节点通信超过设置时间(cluster-node-timeout)，认为当前master节点挂掉。&lt;/p&gt;
&lt;p&gt;当我发现某一台主机的master挂掉了，我们从新选举一个salve当做master(整个过程中把哨兵避免了，不需要修改哨兵的配置文件了)&lt;/p&gt;
&lt;p&gt;这样可以去掉所有的代理层组件，由Redis自己来完成，这就是redis-cluster的设计方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1341698/201812/1341698-20181226224606472-1096954237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Dec 2018 14:47:00 +0000</pubDate>
<dc:creator>palapala</dc:creator>
<og:description>Redis集群概述 集群的核心意义只有一个：保证一个节点出现了问题之后，其他的节点可以继续提供服务使用。 Redis基础部分讲解过主从配置：对于主从配置可以有两类：一主二从，层级关系。开发者一主二从是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ssskkk/p/10162651.html</dc:identifier>
</item>
<item>
<title>渐变色进度条的两种绘制方案 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/10182351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/10182351.html</guid>
<description>&lt;pre&gt;
let context =&lt;span&gt; UIGraphicsGetCurrentContext()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渐变色&lt;/span&gt;
let colorSpace =&lt;span&gt; CGColorSpaceCreateDeviceRGB()
let locations:[CGFloat] &lt;/span&gt;= [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
let startC &lt;/span&gt;= UIColor(hex: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EEA13A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
let endC &lt;/span&gt;= UIColor(hex: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1283C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
let colors &lt;/span&gt;=&lt;span&gt; [startC.cgColor,endC.cgColor]
let gradient &lt;/span&gt;= CGGradient(colorsSpace: colorSpace, colors: colors &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CFArray, locations: locations)
context&lt;/span&gt;?.drawLinearGradient(gradient!, start: CGPoint(x: &lt;span&gt;0&lt;/span&gt;, y: &lt;span&gt;0&lt;/span&gt;), end: CGPoint(x: rect.size.width, y: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;), options: CGGradientDrawingOptions.drawsBeforeStartLocation)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渐变色弧&lt;/span&gt;
context?&lt;span&gt;.saveGState()
context&lt;/span&gt;?&lt;span&gt;.addRect(rect)
context&lt;/span&gt;?.move(to: CGPoint(x: width-&lt;span&gt;edgeDistance, y: bigOuterRadius))
context&lt;/span&gt;?.addArc(center: arcCenter, radius: bigOuterRadius, startAngle: &lt;span&gt;0&lt;/span&gt;, endAngle: CGFloat(M_PI), clockwise: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
context&lt;/span&gt;?.addArc(center: CGPoint(x: smailRadius+edgeDistance, y: arcCenter.y), radius: smailRadius, startAngle: CGFloat(M_PI), endAngle: CGFloat(M_PI*&lt;span&gt;2&lt;/span&gt;), clockwise: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
context&lt;/span&gt;?.addArc(center: arcCenter, radius: bigInnerRadius, startAngle: CGFloat(M_PI), endAngle: CGFloat(M_PI*&lt;span&gt;2&lt;/span&gt;), clockwise: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
context&lt;/span&gt;?.addArc(center: CGPoint(x: width-smailRadius-edgeDistance, y: arcCenter.y), radius: smailRadius, startAngle: CGFloat(M_PI), endAngle: CGFloat(M_PI*&lt;span&gt;2&lt;/span&gt;), clockwise: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
context&lt;/span&gt;?&lt;span&gt;.setFillColor(UIColor.white.cgColor)
context&lt;/span&gt;?&lt;span&gt;.fillPath()


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;灰色弧&lt;/span&gt;
context?&lt;span&gt;.restoreGState()
let context1 &lt;/span&gt;=&lt;span&gt; UIGraphicsGetCurrentContext()
var endAng &lt;/span&gt;=  CGFloat(M_PI*&lt;span&gt;2&lt;/span&gt;) - (_progressValue *&lt;span&gt; CGFloat(M_PI))
context1&lt;/span&gt;?.move(to: CGPoint(x: width-&lt;span&gt;edgeDistance, y: bigOuterRadius))
context1&lt;/span&gt;?.addArc(center: arcCenter, radius: bigOuterRadius, startAngle: &lt;span&gt;0&lt;/span&gt;, endAngle: endAng, clockwise: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)

let midSmallX: CGFloat &lt;/span&gt;= arcCenter.x + cos(endAng)*(bigOuterRadius-&lt;span&gt;smailRadius)
let midSmallY: CGFloat &lt;/span&gt;= arcCenter.y + sin(endAng)*(bigOuterRadius-&lt;span&gt;smailRadius)

context1&lt;/span&gt;?.addArc(center: CGPoint(x: midSmallX, y: midSmallY), radius: smailRadius, startAngle: endAng, endAngle: endAng-CGFloat(M_PI), clockwise: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)

context1&lt;/span&gt;?.addArc(center: arcCenter, radius: bigInnerRadius, startAngle: endAng, endAngle: CGFloat(M_PI*&lt;span&gt;2&lt;/span&gt;), clockwise: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
context1&lt;/span&gt;?.addArc(center: CGPoint(x: width-smailRadius-edgeDistance, y: arcCenter.y), radius: smailRadius, startAngle: CGFloat(M_PI), endAngle: CGFloat(M_PI*&lt;span&gt;2&lt;/span&gt;), clockwise: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
context1&lt;/span&gt;?.setFillColor(UIColor(hex: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e7e3e3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).cgColor)
context1&lt;/span&gt;?.fillPath()
&lt;/pre&gt;</description>
<pubDate>Wed, 26 Dec 2018 14:45:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>在App开发中经常会用到渐变色进度条控件，而自定义进度条的实现也不难，下面提供了两种渐变色进度条的实现方案。 效果图如下： 第一种实现方案：使用图层layer实现 层级结构如图所示： 构建过程如下：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/10182351.html</dc:identifier>
</item>
<item>
<title>知识小罐头08（tomcat8启动源码分析 上） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10165874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10165874.html</guid>
<description>&lt;p&gt;　　前面好几篇都说的是一个请求是怎么到servlet中的service方法的，这一篇我们来看看Tomcat8是怎么启动并且初始化其中的组件的？&lt;/p&gt;
&lt;p&gt;　　相信看了前面几篇的小伙伴应该对Tomcat中的各个组件不陌生了，所以我们就可以加快一点速度；&lt;/p&gt;
&lt;p&gt;　　简单说一下Tomcat启动流程，首先是设置一下各种类加载器，然后加载server.xml配置文件，然后初始化Container各个容器，最后就是连接器Connector。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.批处理文件&lt;/strong&gt;&lt;/span&gt;　　&lt;/p&gt;
&lt;p&gt;　　双击startup.bat文件启动tomcat，其实内部就是跳转到catalina.bat文件（.bat文件时windows系统用的，那些.sh配置文件是Unix、Linux系统使用的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223200050248-1051863287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　startup.bat文件内部其实就是一些指令从上到下顺序执行，作用是进行一些目录的判断，并找到catalina.bat文件的位置，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223200420220-1636680646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　 注意：.bat文件其实就是一个批处理文件，里面一条条的命令都有自己独特的语法，你知需要百度“startup.bat详解”可以看到很多博客，其实就我感觉很像mysql的触发器吧，里面封装了很多命令，有自己独特的语法，只要一触发就会一连串的执行，这里就不多说，不是我们的重点，用到的时候再去仔细研究，这里粗略提一下。&lt;/p&gt;

&lt;p&gt;　　 我们再看看catalina.bat文件　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223201540344-2046620257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　由于tomcat是用java语言开发出来的，所以启动Tomcat本质上就是运行一个java程序的main方法，然后后续就会初始化一系列的东西。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.看看Bootstrap类的main方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;我们就看看main方法内核心部分，在下图中标识了三步：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223201958716-1327884756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223202218480-169949607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　总结一下，main方法内部核心就是创建一个Bootstrap对象，然后调用这个对象的init、load、start方法，看名字就应该大概猜出一点东西了：&lt;/p&gt;
&lt;p&gt;　　init：大概是初始化一些类加载器什么的；&lt;/p&gt;
&lt;p&gt;　　load：应该是加载什么配置文件，还记得我说过最重要的配置文件是哪个吗？对，就是server.xml文件，其实就是加载这个文件；&lt;/p&gt;
&lt;p&gt;　　start：内部差不多初始化完了所有的容器和连接器，等待连接；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们分别对这三个方法加断点进行调试，理解其中的原理之后整个Tomcat的启动流程也就清楚了！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.init方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;还是只看核心的逻辑，至于怎么实例化类加载器和设置类加载器，感兴趣的小伙伴就自己去研究走走源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223203556739-1984927471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223204259908-456390640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4.load方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;通过看源码，其实可以看到Bootstrap的load方法，就是通过反射调用Catalina的load方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223204518847-557090389.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223204749293-994532711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们断点进入最后的那个invoke方法，看看Catalina的load方法是加载了些什么东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223205501558-244309562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　这个Digester就是为了解析servler.xml定义了很多的解析规则，真要搞懂这个东西，肯定要花一定的时间去好好研究的；&lt;/p&gt;
&lt;p&gt;　　我们在这里简单而随意看几个我们熟悉的东西，具体的解析过程肯定要自己去了解的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223210253684-13816925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223210214297-820962699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223210513916-236149384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223210622307-434589597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这个Digester是了解servler.xml具体解析规则必要的东西，我们把规则已经指定好了，下一步肯定就是加载server.xml文件了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223211309561-1578157190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223211338105-444437463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223211403746-1640097292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　准备好了Digester和server.xml的流之后，然后底层用SAX去解析这个xml文件（注意，前面只是解析出来了server.xml中的各个组件对应的类名以及组件之间的父子关系， 没有实例化，到&lt;strong&gt;&lt;span&gt;parse方法才真正实例化&lt;/span&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223211911670-1273746186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 接着我们就要去把一些需要用到的容器进行一些初始化设置，更方便我们使用！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181223213312567-1225875385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　从这里开始我们就会看到一个类似多米诺骨牌效应的这么一个现象，一个接一个的初始化，而且这里涉及到了一个知识点叫做JMX，有关于这个JMX（Java Management Extensions），我查了很多的资料，网上复制粘贴的一大堆，看得很乱，虽然我没有怎么仔细的去研究，但是大概的逻辑我是知道了，下面就简单的说说；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.JMX的简介和事件监听&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　便于理解，JMX可以想象成工商局，每家公司必须要向工商局注册自己，这个时候工商局就对每一家公司都有了管理的权利，无论是哪一家公司要改名字，要合并，注销等等，都必须经过工商局的的同意，工商局还能对一些非法公司进行整改什么的，可以说工商局就是管理了每一家公司的生命周期，可以对每家公司进行监控符合管理。&lt;/p&gt;
&lt;p&gt;　　对应在Tomcat中，我们必须要把Tomcat中的所有组件（在这里叫做MBean，类似spring容器中叫做bean）给注册到一个叫做Registry的地方，Registry就是基于JMX搞出来的一个东西，然后我们执行所有组件的init，start方法，都可以在JMX中找到对应的MBean执行对应的init、start方法；这里也只是稍微提一下JMX，内容很多一下子说不完，最好自己多查查资料看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226223724711-1562639974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226203650036-312623964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　JMX的结构图找了好久，终于看到一个图比较满意的，进行一些小小的修改，如下所示：&lt;/p&gt;
&lt;p&gt;　　Agent Layer（代理层）：主要包括Agent Services中几个服务（计时器、监控、动态加载MBean、关系服务），还有MBean Server两部分组成&lt;/p&gt;
&lt;p&gt;　　Distributed layer（分布层）：包含一些比较厉害的组件，其实我感觉就类似可视化工具，可以很方便的对那些MBean进行一些管理和修改。&lt;/p&gt;
&lt;p&gt;　　还有在MBean Server中的多个MBean组成一个Instrumentation Layer（指示层），这个就没啥说的；总之，JMX我用得不是很多，需要真正用到的时候再慢慢研究吧，哈哈！&lt;/p&gt;
&lt;p&gt;　　感兴趣的小伙伴可以自己研究这个写几个HelloWorldMBean试试就ok了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226201507235-413609446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　再说说事件监听，事件监听又是一个什么鬼呢？不准确的来说，在Tomcat启动的时候会有个全局事件（就类似一个全局变量），很多的监听器会时时刻刻监听这个全局事件，当对一个组件进行一些操作（会修改状态码state），那么这个全局事件就会变化，遍历所有监听器执行某方法，下面就随便看看这个全局事件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226205417347-1660757661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226204712350-1014046534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226205228641-190313273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 还记得最前面的server.xml配置文件的&amp;lt;server&amp;gt;中配置的很多监听器吗？其实就是配合这个全局事件起作用的（看英文应该翻译成生命周期事件吧。。。）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 6.接第4步继续&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;这里一定要理清楚一个逻辑，Tomcat中所有组件都必须是LifecycleBase的子类（其实都直接或者间接的继承了LifecycleBase这个类），这个类就是所有组件的爸爸，假如这个爸爸有九个儿子，大儿子要给最小的儿子一颗糖，你就会看到一个很有趣很坑爹的现象：大儿子--------&amp;gt;爸爸----------&amp;gt;二儿子---------&amp;gt;爸爸---------&amp;gt;三儿子----------&amp;gt;爸爸----------&amp;gt;四儿子----------&amp;gt;.......-------&amp;gt;爸爸-------&amp;gt;最小的儿子！&lt;/p&gt;
&lt;p&gt;　　这样糖才能到最小的儿子手里，是不是真的很坑爹，哈哈！&lt;/p&gt;
&lt;p&gt;　　所以我们在Tomcat也可以看到一个这样的逻辑：&lt;/p&gt;
&lt;p&gt;　　server.init()----------&amp;gt;LifecycleBase.init(), 在init()方法内部就会执行initInternal()方法，并改变全局事件-------------&amp;gt;service.init()方法------------&amp;gt;LifecycleBase.init()，执行initInternal()方法，并改变全局事件---------&amp;gt;connector.init()和engine.init()----------&amp;gt;LifecycleBase.init()。。。。。后面都是这个逻辑，几乎一模一样，初始化之后启动start（）的逻辑也是这个，所以这个逻辑一定要搞清楚，搞清楚这个了后面就没难度了。&lt;/p&gt;
&lt;p&gt;　　下面我们就简单看看一些关键的地方，由于绝大部分都是相同的，就不一一截图了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226205834737-18567899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　看看initInternal()方法内部：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226205906992-292585309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226210029211-1591497498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226210151648-1641715551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　一直往下看，我们看看StandardService中的initInternal()方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226220254618-1702212205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226215358858-1808765148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　engine的初始化是在看不出来什么有趣的东西，我们就重点看看HTTP连接器的初始化的关键代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226220708458-1899439126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226220723096-1286891252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　 【省略很多重复步骤】&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226220933754-1564003978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　 【省略很多重复步骤】&lt;/p&gt;
&lt;p&gt;　　这个是Tomcat的NIO连接，其中addr=0.0.0.0/0.0.0.0:8080；acceptCount = 100;看这个就知道监听8080端口，默认并发连接数100个，这个可以自己根据实际情况设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226221043503-440329195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181226221432912-1611507157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　到这里Tomcat启动初始化的步骤算是结束了，内容看起来比较多，但是思路自我感觉还是比较清晰的，了解JMX和事件监听的相关知识之后，还是比较容易的，不过强调一点，一定要自己走走源码，加深理解！&lt;/p&gt;
&lt;p&gt;　　这篇说的东西不多，就是初始化了几乎所有组件，就好像一个厨师，把所有的菜都洗好并且切好、分类、分盘，调料也准备就绪，下一步，就是开始做出美味的菜肴了。&lt;/p&gt;
&lt;p&gt;　　下一篇我们简单看看Tomcat的start过程。&lt;/p&gt;
</description>
<pubDate>Wed, 26 Dec 2018 14:43:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>前面好几篇都说的是一个请求是怎么到servlet中的service方法的，这一篇我们来看看Tomcat8是怎么启动并且初始化其中的组件的？ 相信看了前面几篇的小伙伴应该对Tomcat中的各个组件不陌生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10165874.html</dc:identifier>
</item>
<item>
<title>Spring入门详细教程（三） - 经典鸡翅</title>
<link>http://www.cnblogs.com/jichi/p/10177004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jichi/p/10177004.html</guid>
<description>&lt;p&gt;本篇紧接着spring入门详细教程（二），建议阅读本篇前，先阅读第一篇和第二篇。链接如下：&lt;/p&gt;
&lt;p&gt;Spring入门详细教程（一） &lt;a href=&quot;https://www.cnblogs.com/jichi/p/10165538.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jichi/p/10165538.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spring入门详细教程（二） &lt;a href=&quot;https://www.cnblogs.com/jichi/p/10176601.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jichi/p/10176601.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇主要讲解spring的aop相关。&lt;/p&gt;

&lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。AOP是可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。&lt;/p&gt;
&lt;p&gt;AOP主要实现功能日志记录，性能统计，安全控制，事务处理，异常处理等等。将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。&lt;/p&gt;
&lt;p&gt;AOP主要思想总结为横向重复，纵向抽取。&lt;/p&gt;

&lt;p&gt;spring实现aop的底层使用了两种代理机制。一种是jdk的动态代理，一种是cglib的动态代理。下面来分析一下两种代理模式。&lt;/p&gt;
&lt;p&gt;1、jdk的动态代理&lt;/p&gt;
&lt;p&gt;被代理对象必须要实现接口才能产生代理对象，如果被代理对象不能实现接口，则这种方式的动态代理技术无效。&lt;/p&gt;
&lt;p&gt;接下来做一个底层代码的编写来进行理解。&lt;/p&gt;
&lt;p&gt;（1）首先jdk的动态代理要求被代理对象必须实现接口。我们准备一个接口以及一个接口的实现类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveUser();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveUser(){
        System.out.println(&lt;/span&gt;&quot;保存用户&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）建立一个UserDao的动态代理类，实现接口InvocationHandler。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDao userDao ;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserProxy(UserDao userDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userDao =&lt;span&gt; userDao;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDao createProxy(){
        UserDao userDaoProxy &lt;/span&gt;= (UserDao) Proxy.newProxyInstance(userDao.getClass().getClassLoader(),userDao.getClass().getInterfaces(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userDaoProxy;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        System.out.println(&lt;/span&gt;&quot;动态代理&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(userDao, args);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）进行单元测试，发现第一个方法执行的时候没有被动态代理，第二个执行的时候进行了动态代理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestJunit {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        UserDaoImpl userDaoImpl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserDaoImpl();
        userDaoImpl.saveUser();
        UserProxy userProxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserProxy(userDaoImpl);
        UserDao createProxy &lt;/span&gt;=&lt;span&gt; userProxy.createProxy();
        createProxy.saveUser();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、cglib动态代理&lt;/p&gt;
&lt;p&gt;针对一些不能实现接口的代理对象产生代理，可以对没有被final修饰的任何对象进行继承代理，其底层应用的是字节码增强的技术，生成代理对象的子类对象。如果被final修饰，类不可继承，便不可使用cglib动态代理。&lt;/p&gt;
&lt;p&gt;（1）创建一个cglib动态代理对象实现接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CglibProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDaoImpl userDaoImpl;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CglibProxy(UserDaoImpl userDaoImpl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userDaoImpl =&lt;span&gt; userDaoImpl;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDaoImpl createProxy(){
        Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
        enhancer.setSuperclass(UserDaoImpl.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        enhancer.setCallback(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        UserDaoImpl udi &lt;/span&gt;=&lt;span&gt; (UserDaoImpl) enhancer.create();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; udi;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        Object obj &lt;/span&gt;=&lt;span&gt; methodProxy.invokeSuper(proxy, args);
        System.out.println(&lt;/span&gt;&quot;动态代理&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）进行单元测试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test4(){
        UserDaoImpl userDaoImpl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserDaoImpl();
        userDaoImpl.saveUser();
        CglibProxy cglib &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CglibProxy(userDaoImpl);
        UserDaoImpl userDaoImpl2 &lt;/span&gt;=&lt;span&gt; cglib.createProxy();
        userDaoImpl2.saveUser();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现第一个saveUser没有执行动态代理，第二个执行了动态代理。&lt;/p&gt;
&lt;p&gt;结论：两种代理技术针对不同情况，互相弥补，从而使任何对象都可以实现动态代理。spring在进行aop的时候，默认使用jdk的动态代理技术，当发现jdk的动态代理技术不好使的情况下，使用cglib动态代理技术，保证被代理对象能够被正常代理。如需使用cglib动态代理可以再spring的配置文件中进行配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;aop:conﬁg proxy-target-&lt;span&gt;class&lt;/span&gt;=&quot;true&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1、Joinpoint（连接点）：目标对象中，所有可以增强的方法。&lt;/p&gt;
&lt;p&gt;2、Pointcut（切入点）：目标对象中，已经增强的方法。&lt;/p&gt;
&lt;p&gt;3、Advice（通知）：对于目标对象来说，需要给目标对象增强的方法。&lt;/p&gt;
&lt;p&gt;4、Target（目标对象）：被代理对象。&lt;/p&gt;
&lt;p&gt;5、Weaving（织入）：将通知应用到切入点的过程。&lt;/p&gt;
&lt;p&gt;6、Proxy（代理）：将通知织入到目标对象后，形成的增强后的对象。&lt;/p&gt;
&lt;p&gt;7、Aspect（切面）：切入点和通知的结合。&lt;/p&gt;

&lt;p&gt;分两种方式介绍，一种是xml配置方式，一种是注解方式。&lt;/p&gt;
&lt;p&gt;1、xml配置方式&lt;/p&gt;
&lt;p&gt;（1）实现spring的aop需要导入aop包，aspect包，aopalliance包，weaver包。在&lt;a href=&quot;https://www.cnblogs.com/jichi/p/10165538.html&quot; target=&quot;_blank&quot;&gt;spring教程一&lt;/a&gt;中可以找到获取这些包的方法。&lt;/p&gt;
&lt;p&gt;（2）编写需要增加的方法类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDaoImpl{
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveUser(){
        System.out.println(&lt;/span&gt;&quot;保存用户&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteUser(){
        System.out.println(&lt;/span&gt;&quot;删除用户&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）编写通知，也就是说想要增加的代码方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAdvice{
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;前置通知&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturning(){
        System.out.println(&lt;/span&gt;&quot;后置通知（不发生异常的情况下调用）&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object around(ProceedingJoinPoint pjp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable{
        System.out.println(&lt;/span&gt;&quot;执行前&quot;&lt;span&gt;);
        Object proceed &lt;/span&gt;=&lt;span&gt; pjp.proceed();
        System.out.println(&lt;/span&gt;&quot;执行后&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proceed;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowException(){
        System.out.println(&lt;/span&gt;&quot;发生异常调用&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;后置通知，发生异常也会调用&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）在spring的配置文件中进行配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;bean name = &quot;userDaoImpl&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.jichi.aop.UserDaoImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean name=&quot;userAdvice&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.jichi.aop.UserAdvice&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:pointcut expression=&quot;execution(* com.jichi.aop..UserDaoImpl.*(..))&quot; id=&quot;pc&quot;/&amp;gt;
        &amp;lt;aop:aspect ref=&quot;userAdvice&quot;&amp;gt;
            &amp;lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pc&quot;/&amp;gt;
            &amp;lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pc&quot;/&amp;gt;
            &amp;lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pc&quot;/&amp;gt;
            &amp;lt;aop:after-throwing method=&quot;afterThrowException&quot; pointcut-ref=&quot;pc&quot;/&amp;gt;
            &amp;lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pc&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）进行单元测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestAop {

    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDaoImpl userDaoImpl;
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        userDaoImpl.saveUser();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：织入成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201812/1534147-20181226222249566-1468063743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、注解配置方式&lt;/p&gt;
&lt;p&gt;（1）同第一种方式需要导入包&lt;/p&gt;
&lt;p&gt;（2）编写需要增加的方法类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; UserDaoImpl{
    
    public void&lt;span&gt; saveUser(){
        System.out.println(&quot;保存用户&quot;&lt;span&gt;);
    }
    public void&lt;span&gt; deleteUser(){
        System.out.println(&quot;删除用户&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）编写通知，也就是说想要增加的代码方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; UserAdvice{
    
    public void&lt;span&gt; before(){
        System.out.println(&quot;前置通知&quot;&lt;span&gt;);
    }
    
    public void&lt;span&gt; afterReturning(){
        System.out.println(&quot;后置通知（不发生异常的情况下调用）&quot;&lt;span&gt;);
    }

    public Object around(ProceedingJoinPoint pjp) throws&lt;span&gt; Throwable{
        System.out.println(&quot;执行前&quot;&lt;span&gt;);
        Object proceed =&lt;span&gt; pjp.proceed();
        System.out.println(&quot;执行后&quot;&lt;span&gt;);
        return&lt;span&gt; proceed;
    }
    
    public void&lt;span&gt; afterThrowException(){
        System.out.println(&quot;发生异常调用&quot;&lt;span&gt;);
    }
    
    public void&lt;span&gt; after(){
        System.out.println(&quot;后置通知，发生异常也会调用&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）在spring配置文件中进行配置，并开启注解aop&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;bean name = &quot;userDaoImpl&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.jichi.aop.UserDaoImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean name=&quot;userAdvice&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.jichi.aop.UserAdvice&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;aop:aspectj-autoproxy&amp;gt;&amp;lt;/aop:aspectj-autoproxy&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）在通知类上打上aspect的注解。在方法上打上相应注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Aspect
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAdvice{
    
    @Before(&lt;/span&gt;&quot;execution(* com.jichi.aop..UserDaoImpl.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;前置通知&quot;&lt;span&gt;);
    }
    
    @AfterReturning(&lt;/span&gt;&quot;execution(* com.jichi.aop..UserDaoImpl.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturning(){
        System.out.println(&lt;/span&gt;&quot;后置通知（不发生异常的情况下调用）&quot;&lt;span&gt;);
    }

    @Around(&lt;/span&gt;&quot;execution(* com.jichi.aop..UserDaoImpl.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object around(ProceedingJoinPoint pjp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable{
        System.out.println(&lt;/span&gt;&quot;执行前&quot;&lt;span&gt;);
        Object proceed &lt;/span&gt;=&lt;span&gt; pjp.proceed();
        System.out.println(&lt;/span&gt;&quot;执行后&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proceed;
    }
    
    @AfterThrowing(&lt;/span&gt;&quot;execution(* com.jichi.aop..UserDaoImpl.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowException(){
        System.out.println(&lt;/span&gt;&quot;发生异常调用&quot;&lt;span&gt;);
    }
    
    @After(&lt;/span&gt;&quot;execution(* com.jichi.aop..UserDaoImpl.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;后置通知，发生异常也会调用&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;优化方式：每个方法都配置方法抽取，显得比较臃肿，可以进行提取，方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Aspect
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAdvice{
    
    @Pointcut(&lt;/span&gt;&quot;execution(* com.jichi.aop..UserDaoImpl.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; adc(){}
    
    @Before(&lt;/span&gt;&quot;UserAdvice.adc()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;前置通知&quot;&lt;span&gt;);
    }
    
    @AfterReturning(&lt;/span&gt;&quot;UserAdvice.adc()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturning(){
        System.out.println(&lt;/span&gt;&quot;后置通知（不发生异常的情况下调用）&quot;&lt;span&gt;);
    }

    @Around(&lt;/span&gt;&quot;UserAdvice.adc()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object around(ProceedingJoinPoint pjp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable{
        System.out.println(&lt;/span&gt;&quot;执行前&quot;&lt;span&gt;);
        Object proceed &lt;/span&gt;=&lt;span&gt; pjp.proceed();
        System.out.println(&lt;/span&gt;&quot;执行后&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proceed;
    }
    
    @AfterThrowing(&lt;/span&gt;&quot;UserAdvice.adc()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowException(){
        System.out.println(&lt;/span&gt;&quot;发生异常调用&quot;&lt;span&gt;);
    }
    
    @After(&lt;/span&gt;&quot;UserAdvice.adc()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;后置通知，发生异常也会调用&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 26 Dec 2018 14:38:00 +0000</pubDate>
<dc:creator>经典鸡翅</dc:creator>
<og:description>前言 本篇紧接着spring入门详细教程（二），建议阅读本篇前，先阅读第一篇和第二篇。链接如下： Spring入门详细教程（一） https://www.cnblogs.com/jichi/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jichi/p/10177004.html</dc:identifier>
</item>
<item>
<title>学好数据结构和算法 —— 非线性结构（中） - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9978610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9978610.html</guid>
<description>&lt;h2&gt;1、树&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;树是一种很常见的分线性数据结构，公司的组织架构，行政区划结构等都是树形结构。树形结构里常见的有树和二叉树。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;树的定义&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;树是n（n&amp;gt;=0）个结点的有限集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在任意一棵非空树中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）有且仅有一个特定的称为根（root）的结点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）当n&amp;gt;1时，其余结点可分为m（m&amp;gt;0）个互不相交的有限集，其中每一个集合本身又是一棵树，称为根的子树（递归的过程）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118111558281-1227327951.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3-1是n=0的树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3-2是n=1只有一个根节点的树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3-3是一棵普通的树，B为根节点的树T&lt;sub&gt;1&lt;/sub&gt; = {B，E，F，J} 是A的子树，B为T&lt;sub&gt;1&lt;/sub&gt;的根节点，同时也有自己的子树。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;树的3种表示方法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118114051181-1670485532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图所示的树有以下3中表示方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118121758048-604489510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中1是集合形式看起来很清晰；2是层级表示方式，类似书的目录；3是一种广义表的表示方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;树的一些概念&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;结点&lt;/strong&gt;&lt;span&gt;：包含一个数据元素 及 若干指向其子树的分支。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如结点B，包含了结点数据B 和 指向子树E和F的分支。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;度&lt;/span&gt;&lt;/strong&gt;：结点拥有的子树数称为结点的度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：结点B包含了两个子树，度为2；结点D包含了3个子树，度为3.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;叶子（终端结点）&lt;/strong&gt;&lt;span&gt;：度为0的结点（没有子树的结点）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如：J、F、C、G、H、I都是树的叶子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分支结点（非终端结点）&lt;/span&gt;&lt;/strong&gt;：度不为0的结点（有子树的结点）。除了根节点外，分支结点也成为内部结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如：A、B、E、D为分支结点；B、E、D为内部结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;树的度&lt;/span&gt;&lt;/strong&gt;：树内各个结点的度的最大值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如：A的度为3；B的度为2；D的度为3，其余结点度为0，所以树的度为3。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;孩子&lt;/span&gt;&lt;/strong&gt;：结点的子树称为结点的孩子，反过来，该节点称为孩子的&lt;strong&gt;&lt;span&gt;双亲&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如：结点A有B、C、D 3个孩子，A是B、C、D的双亲结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;兄弟&lt;/span&gt;&lt;/strong&gt;：同一双亲的孩子互为兄弟。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;祖先&lt;/strong&gt;：&lt;span&gt;从根节点到某个结点（N）经历的所有结点称为该节点（N）的祖先；反之，以某结点&lt;/span&gt;&lt;span&gt;&lt;span&gt;（N）为根的任一结点都是该节点&lt;/span&gt;&lt;span&gt;&lt;span&gt;（N）的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;子孙&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;堂兄弟&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：双亲结点在同一层的结点互为堂兄弟。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　例如：E 和 G、H、I为堂兄弟。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结点的层次&lt;/span&gt;&lt;/strong&gt;：结点的层次是从根节点开始，根为第一层，依次递增，所以上面树的结点A在第1层，J在第4层。如果结点在n层，其子树（如果有子树）就在第n+1层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;树的深度（高度）&lt;/span&gt;&lt;/strong&gt;：树种结点的最大层次称为树的深度（Depth）或高度。上面树的深度为4。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;有序树&lt;/strong&gt;&lt;span&gt;：如果树中结点的各子树从左到右是有次序的（即不能互换），则次树是有序树；反之，则为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;无序树&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、二叉树（Binary Tree）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;二叉树是一种有限制的树，每个结点最多只有两颗子树（即二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，次序不能任意颠倒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以简单理解为：二叉树是一棵任意结点度不大于2的有序树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二叉树有以下5中结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118122518195-2060296102.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1：空二叉树；&lt;/p&gt;
&lt;p&gt;2：只有根节点的二叉树；&lt;/p&gt;
&lt;p&gt;3：右子树为空的二叉树；&lt;/p&gt;
&lt;p&gt;4：左右子树均非空的二叉树；&lt;/p&gt;
&lt;p&gt;5：左子树为空的二叉树&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;满二叉树&lt;/strong&gt;&lt;span&gt;：一棵深度为k且有&lt;span&gt;2&lt;sup&gt;k&lt;/sup&gt; - 1个结点的二叉树称为满二叉树。满二叉树上每一层的结点数都是最大节点数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;完全二叉树&lt;/span&gt;&lt;/strong&gt;：深度为k的，有n个结点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中自上而下，从左往右编号完全相同的时候，就是完全二叉树。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：&lt;/strong&gt;完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118150232874-1799784612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二叉树的特性&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）二叉树的第i层上至多有2&lt;sup&gt;i-1&lt;/sup&gt;个结点（i &amp;gt;= 1）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）深度为k的二叉树至多有2&lt;sup&gt;k&lt;/sup&gt; - 1个结点（k &amp;gt;= 1）;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）对于任意一棵二叉树T，如果其终端节点数为&lt;span&gt;n&lt;sub&gt;0&lt;/sub&gt;，度为2的结点数为&lt;span&gt;n&lt;sub&gt;2，&lt;/sub&gt;则&lt;span&gt;= &lt;sub&gt;&lt;span&gt;n&lt;span&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt; + 1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;二叉树的存储结构&lt;/h3&gt;
&lt;h4&gt;1、顺序存储结构&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;有以下3中二叉树：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118164126037-1468480242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按顺序存储的时候，用一组连续的存储空间从上至下，从左至右，将二叉树编号 i 的元素存储在对应1维数组的下标为 i-1 的位置，对应的存储结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118164208977-172372769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组里元素为0的表示没有此结点，可以看出：顺序存储结构适合于完全二叉树，对于非完全二叉树比较浪费空间，图(3)只有四个结点对于最坏情况下，需要的空间却是最多的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;因此，在最坏情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）需要的存储长度是2&lt;sup&gt;k&lt;/sup&gt; - 1的一维数组。&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;2、链式存储结构&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;由二叉树的定义得知：二叉树的结点由一个数据元素 和 分别指向左子树、右子树的两个分支构成。有时候为了方便，也可以加个双亲结点的指针域，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118153429889-1215405763.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只含有左右子树的结点 和 含有左右子树和双亲指针的结点的数据结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118172800945-432835041.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只含有左右子树指针的链式结构称为&lt;strong&gt;&lt;span&gt;二叉链表&lt;/span&gt;&lt;/strong&gt;；含有左右子树指针和双亲结点指针的链式结构称为&lt;span&gt;&lt;strong&gt;三叉链表&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下2种结构的二叉树：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118165633893-181793088.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对应的链式存储结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118165754977-1344588319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由存储结构可以得出：&lt;span&gt;&lt;strong&gt;有n个结点的二叉链表中有n+1个空链域&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;二叉链表和三叉链表比较&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）二叉链表少存储了个parent指针，所以更节省内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）在二叉链表中查找某个元素的双亲结点需要从根节点遍历查询，而在三叉链表中可以直接通过parent指针拿到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二叉链表和三叉链表各有优缺点，具体使用哪种存储结构需要根据实际情况来决定。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;遍历二叉树&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;二叉树不像线性表结构只需要从前向后遍历即可访问每个元素，二叉树每个结点都可能有两个分支，所以遍历方式肯定不像线性表那么简单。二叉树是由若干个结点递归构成的，每个结点又由根节点、左子树和右子树3个基本单元组成，因此遍历二叉树就是依次遍历这三个部分，每个结点都按某种方法来遍历，遍历完所有结点即完成了对二叉树的遍历过程。假如限定先左后右，假如一棵二叉树不为空&lt;/span&gt;，&lt;span&gt;则有以下3种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先序遍历&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）访问根节点；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）先序遍历左子树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）先序遍历右子树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中序遍历&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（1）中序遍历左子树；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（2）访问根节点；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（3）中序遍历右子树。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后序遍历&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）后序遍历左子树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）后&lt;span&gt;&lt;span&gt;序遍历右子树&lt;/span&gt;&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（3）&lt;span&gt;&lt;span&gt;访问根节点&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;按层次遍历&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从上到下，从左往右，逐层遍历。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于二叉树：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118204812328-722882643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;先序遍历（中左右）：&lt;/strong&gt;A-&amp;gt;B-&amp;gt;D-&amp;gt;H-&amp;gt;I-&amp;gt;E-&amp;gt;J-&amp;gt;k-&amp;gt;C-&amp;gt;F-&amp;gt;L-&amp;gt;G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;中序遍历&lt;span&gt;&lt;strong&gt;（左中右）&lt;/strong&gt;&lt;/span&gt;：&lt;/strong&gt;H-&amp;gt;D-&amp;gt;I-&amp;gt;B-&amp;gt;J-&amp;gt;E-&amp;gt;K-&amp;gt;A-&amp;gt;L-&amp;gt;F-&amp;gt;C-&amp;gt;G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;后续遍历&lt;span&gt;&lt;strong&gt;（左右中）&lt;/strong&gt;&lt;/span&gt;：&lt;/strong&gt;H-&amp;gt;I-&amp;gt;D-&amp;gt;J-&amp;gt;K-&amp;gt;E-&amp;gt;B-&amp;gt;L-&amp;gt;F-&amp;gt;G-&amp;gt;C-&amp;gt;A&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;按层遍历（上-&amp;gt;下，左-&amp;gt;右）：&lt;/strong&gt;A-&amp;gt;B-&amp;gt;C-&amp;gt;D-&amp;gt;E-&amp;gt;F-&amp;gt;G-&amp;gt;H-&amp;gt;I-&amp;gt;J-&amp;gt;K-&amp;gt;L&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;用递归来实现前序、中序、后续遍历：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('92c614ee-ca99-4010-92fe-c17106340d12')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_92c614ee-ca99-4010-92fe-c17106340d12&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_92c614ee-ca99-4010-92fe-c17106340d12&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('92c614ee-ca99-4010-92fe-c17106340d12',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_92c614ee-ca99-4010-92fe-c17106340d12&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前序 &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prePrint(Node node ) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        System.out.print(node.getVal());
        prePrint(node.getLeftChild());
        prePrint(node.getRightChild());
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; middlePrint(Node node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        middlePrint(node.getLeftChild());
        System.out.print(node.getVal() &lt;/span&gt;+ &quot;-&amp;gt;&quot;&lt;span&gt;);
        middlePrint(node.getRightChild());
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后续&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sufPrint(Node node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        sufPrint(node.getLeftChild());
        sufPrint(node.getRightChild());
        System.out.println(node.getVal());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;线索二叉树&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;遍历二叉树是以一定规则将二叉树中结点排列成一个线性序列，不同方法会得到不同序列方式，如先序序列、中序序列和后序序列。这实际上是对一个非线性结构进行线性化的操作，使每个节点（除了第一个和最后一个外）在这些线性序列中有且仅有一个直接前驱和直接后继。但是，当以二叉链表作为存储结构时候，只能找到左右孩子结点信息，不能直接得到结点在任一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到。如何保持这种线性关系呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）如果在每个结点上增加两个指针域prefix 和 suffix，分别表示结点在任一次序遍历时候的前驱和后继，虽然可用实现，但是增加的两个指针域比较耗费空间；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）前面我们知道，在有n个结点的二叉链表中必定有n+1个空链域，如果用空链域来存储结点的前驱和后继就可以充分利用内存空间，所以只需要新增两个标识位lTag和rTag，用来区分什么时候指向孩子节点，什么时候指向前驱（后继），标识位是布尔类型的，比(1)里的指针更省空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果结点有左子树，则其lchild指向其左孩子结点，否则让lchild域指向其前驱；若结点有右子树，则其rchild指向其右孩子，否则让rchild指向其后继。新增两个标识位，结点结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181118224135543-2053134049.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       lTag：0   lchild域指示结点的左孩子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               1   lchild域指示结点的前驱&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       rTag：0   rchild域指示结点的右孩子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               1   rchild域指示结点的后继&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以这种结点结构构成的二叉链表作为二叉树的存储结构叫做&lt;span&gt;&lt;strong&gt;线索链表&lt;/strong&gt;&lt;/span&gt;，其中指向结点前驱和后继的指针叫做&lt;span&gt;&lt;strong&gt;线索&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;加上线索的二叉树叫做&lt;span&gt;&lt;strong&gt;线索二叉树&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;对二叉树以某种次序遍历使其变为线索二叉树的过程叫做&lt;span&gt;&lt;strong&gt;线索化&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为线索化的过程是将二叉链表中的空指针改为指向前驱或后继的线索，而且前驱或后继信息是在遍历过程中才有的，所以线索化即为改变二叉链表空指针的过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面分别是前中后序对于的线索二叉树和线索二叉链表，如果给二叉链表增加一个head指针，那么在给定任意一个结点都可以遍历得到整棵树：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181120225532439-1354449608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181120225617075-41097210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181120225659885-2092714647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3、树和森林&lt;/h2&gt;
&lt;h3&gt;树的3中常用链表结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201812/1042079-20181205212845983-85707163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示的二叉树，有以下3中表示方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201812/1042079-20181205212928924-832844698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;图（a）双亲表示法&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　假设以一组连续空间存储树的结点，存储结点的同时附加存储指示双亲的结点在链表里的位置，有图可知，方便找每个结点的双亲，不太方便找孩子结点（需要遍历）。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;图（b）、图（c）孩子表示法&lt;/h4&gt;
&lt;p&gt;　　&lt;span&gt;图(b)由每个结点分别指向自己的子树，构成多重链表结构；图(c)在图(b)基础上增加了双亲节点。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;图（d）孩子兄弟表示法&lt;/h4&gt;
&lt;p&gt;　　&lt;span&gt;又称为二叉树表示法或二叉链表表示法。链表里每个结点的两个指针分别指向该节点的第一个孩子结点和下一个兄弟结点。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;森林和二叉树的转换&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;前面知道二叉树可以用二叉链表表示，上小结提到树可以用二叉链表表示，所以就可以用二叉链表作为存储媒介将树与二叉树对应起来，也就是说对于一棵给定的树可以找到唯一的一棵二叉树与之对应，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201812/1042079-20181205224701709-92268850.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由上节树的二叉链表表示法可以知道：&lt;strong&gt;&lt;span&gt;任何一棵树对应的二叉树，其右子树肯定为空&lt;/span&gt;&lt;/strong&gt;（由于根节点肯定没有兄弟结点）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果把第二棵树根节点看作第一棵树根节点的兄弟，那么第二颗树根节点就是第一棵树的右子树，以此类推可以将若干棵树构成一棵二叉树（即森林与二叉树对应关系），如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201812/1042079-20181205225415673-47256112.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;树的遍历&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由树的结构定义可以引出两种次序遍历方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先根（次序）遍历树：先访问树的根节点，然后依次先根遍历根的每颗子树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后根（次序）遍历树：先依次后根遍历每颗子树，然后访问根节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201812/1042079-20181205230136386-503463000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对这棵树进行先根遍历：A B E F C D G&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对这棵树进行后根遍历：E F B C G D A&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;森林的遍历&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　按照森林和树的定义，可以推出森林的两种遍历方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先序遍历森林&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果森林非空，可以按下面规则遍历：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）访问森林中第一棵树的根节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）先序遍历第一棵树中根节点的子树森林&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）先序遍历除去第一棵树之后的树构成的森林&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中序遍历森林&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果森林非空，可以按下面规则遍历：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）中序遍历森林中第一棵树的根节点的子树森林&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）访问第一棵树的根节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）中序遍历除去第一棵树之后的树构成的森林&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201812/1042079-20181205231043238-759712260.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对上图森林进行遍历：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先序：A B C E D F G H I J K&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中序：B E C D A G F I K J H&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由森林转化成二叉树得知，对应的二叉树为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201812/1042079-20181205231436326-1082207763.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以森林的先序和中序也就是转化成二叉树后，二叉树的先序和中序遍历。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 26 Dec 2018 14:31:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>1、树 树是一种很常见的分线性数据结构，公司的组织架构，行政区划结构等都是树形结构。树形结构里常见的有树和二叉树。 树的定义 树是n（n&gt;=0）个结点的有限集。 在任意一棵非空树中： （1）有且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9978610.html</dc:identifier>
</item>
<item>
<title>Elasticsearch 通关教程（四）： 分布式工作原理 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/10176604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/10176604.html</guid>
<description>&lt;p&gt;通过前面章节的了解，我们已经知道 Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以一个之前从未有过的速度和规模，去探索你的数据。它被用作全文检索、结构化搜索、分析以及这三个功能的组合。 Elasticsearch 可以横向扩展至数百（甚至数千）的服务器节点，同时可以处理PB级数据。&lt;/p&gt;
&lt;p&gt;虽然说 Elasticsearch 是分布式的，但是对于我们开发者来说并未过多的参与其中，我们只需启动对应数量的 ES 实例(即节点)，并给它们分配相同的 &lt;code&gt;cluster.name&lt;/code&gt; 让它们归属于同一个集群，创建索引的时候只需指定索引 &lt;em&gt;分片数&lt;/em&gt; 和 &lt;em&gt;副本数&lt;/em&gt; 即可，其他的都交给了 ES 内部自己去实现。&lt;/p&gt;
&lt;p&gt;这和数据库的分布式和 同源的 solr 实现分布式都是有区别的，数据库分布式(分库分表)需要我们指定路由规则和数据同步策略等，solr的分布式也需依赖 zookeeper，但是 Elasticsearch 完全屏蔽了这些。&lt;/p&gt;
&lt;p&gt;所以我们说，Elasticsearch 天生就是分布式的，并且在设计时屏蔽了分布式的复杂性。Elasticsearch 在分布式方面几乎是透明的。我们可以使用笔记本上的单节点轻松地运行Elasticsearch 的程序，但如果你想要在 100 个节点的集群上运行程序，一切也依然顺畅。&lt;/p&gt;
&lt;p&gt;Elasticsearch 尽可能地屏蔽了分布式系统的复杂性。这里列举了一些在后台自动执行的操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分配文档到不同的容器 或 分片 中，文档可以储存在一个或多个节点中。&lt;/li&gt;
&lt;li&gt;按集群节点来均衡分配这些分片，从而对索引和搜索过程进行负载均衡。&lt;/li&gt;
&lt;li&gt;复制每个分片以支持数据冗余，从而防止硬件故障导致的数据丢失。&lt;/li&gt;
&lt;li&gt;将集群中任一节点的请求路由到存有相关数据的节点。&lt;/li&gt;
&lt;li&gt;集群扩容时无缝整合新节点，重新分配分片以便从离群节点恢复。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然我们可以不了解 Elasticsearch 分布式内部实现机制也能将Elasticsearch使用的很好，但是了解它们将会从另一个角度帮助我们更完整的学习和理解 Elasticsearch 知识。接下里我们从以下几个部分来详细讲解 Elasticsearch 分布式的内部实现机制。&lt;/p&gt;

&lt;p&gt;对于我们之前的分布式经验，我们知道，提升分布式性能可以通过购买性能更强大（ &lt;strong&gt;垂直扩容&lt;/strong&gt; ，或 &lt;strong&gt;纵向扩容&lt;/strong&gt; ） 或者数量更多的服务器（ &lt;strong&gt;水平扩容&lt;/strong&gt; ，或 &lt;strong&gt;横向扩容&lt;/strong&gt; ）来实现。&lt;/p&gt;
&lt;p&gt;虽然Elasticsearch 可以获益于更强大的硬件设备，例如将存储硬盘设为SSD，但是 &lt;em&gt;垂直扩容&lt;/em&gt; 由于硬件设备的技术和价格限制，&lt;em&gt;垂直扩容&lt;/em&gt; 是有极限的。真正的扩容能力是来自于 &lt;em&gt;水平扩容&lt;/em&gt; --为集群添加更多的节点，并且将负载压力和稳定性分散到这些节点中。&lt;/p&gt;
&lt;p&gt;对于大多数的数据库而言，通常需要对应用程序进行非常大的改动，才能利用上横向扩容的新增资源。 与之相反的是，ElastiSearch天生就是 分布式的 ，它知道如何通过管理多节点来提高扩容性和可用性。 这也意味着你的应用无需关注这个问题。那么它是如何管理的呢？&lt;/p&gt;
&lt;h2 id=&quot;主节点&quot;&gt;主节点&lt;/h2&gt;
&lt;p&gt;启动一个 ES 实例就是一个节点，节点加入集群是通过配置文件中设置相同的 &lt;code&gt;cluste.name&lt;/code&gt; 而实现的。所以集群是由一个或者多个拥有相同 &lt;code&gt;cluster.name&lt;/code&gt; 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。&lt;/p&gt;
&lt;p&gt;与其他组件集群(mysql，redis)的 master-slave模式一样，ES集群中也会选举一个节点成为&lt;strong&gt;主节点&lt;/strong&gt;，主节点它的职责是维护全局集群状态，在节点加入或离开集群的时候重新分配分片。具体关于主节点选举的内容可以阅读&lt;a href=&quot;https://www.cnblogs.com/jajian/p/10176707.html&quot;&gt;选举主节点&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;所有主要的文档级别API（索引，删除，搜索）都不与主节点通信，主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。如果集群中就只有一个节点，那么它同时也就是主节点。&lt;/p&gt;
&lt;p&gt;所以如果我们使用 kibana 来作为视图操作工具的话，我们只需在&lt;code&gt;kibana.yml&lt;/code&gt;的配置文件中，将&lt;code&gt;elasticsearch.url: &quot;http://localhost:9200&quot;&lt;/code&gt;设置为主节点就可以了，通过主节点 ES 会自动关联查询所有节点和分片以及副本的信息。所以 kibana 一般都和主节点在同一台服务器上。&lt;/p&gt;
&lt;p&gt;作为用户，我们可以将请求发送到 &lt;em&gt;集群中的任何节点&lt;/em&gt; ，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。&lt;/p&gt;
&lt;h2 id=&quot;发现机制&quot;&gt;发现机制&lt;/h2&gt;
&lt;p&gt;ES 是如何实现只需要配置相同的&lt;code&gt;cluste.name&lt;/code&gt;就将节点加入同一集群的呢？答案是&lt;strong&gt;发现机制&lt;/strong&gt;（discovery module）。&lt;/p&gt;
&lt;p&gt;发现机制 负责发现集群中的节点，以及选择主节点。每次集群状态发生更改时，集群中的其他节点都会知道状态（具体方式取决于使用的是哪一种发现机制）。&lt;/p&gt;
&lt;p&gt;ES目前主要推荐的自动发现机制，有如下几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/plugins/6.5/discovery-azure-classic.html&quot;&gt;Azure classic discovery&lt;/a&gt; 插件方式，多播&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/plugins/6.5/discovery-ec2.html&quot;&gt;EC2 discovery&lt;/a&gt; 插件方式，多播&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/plugins/6.5/discovery-gce.html&quot;&gt;Google Compute Engine (GCE) discovery&lt;/a&gt; 插件方式，多播&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-zen.html&quot;&gt;Zen discovery&lt;/a&gt; 默认实现，多播/单播&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里额外介绍下单播，多播，广播的定义和区别，方便我们更好的理解发现机制。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;单播，多播，广播的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;单播(unicast)&lt;/strong&gt;：网络节点之间的通信就好像是人们之间的对话一样。如果一个人对另外一个人说话，那么用网络技术的术语来描述就是“单播”，此时信息的接收和传递只在两个节点之间进行。例如，你在收发电子邮件、浏览网页时，必须与邮件服务器、Web服务器建立连接，此时使用的就是单播数据传输方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;多播(multicast)&lt;/strong&gt;：“多播”也可以称为“组播”，多播”可以理解为一个人向多个人（但不是在场的所有人）说话，这样能够提高通话的效率。因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率极低，是不可取的。如果你要通知特定的某些人同一件事情，但是又不想让其他人知道，使用电话一个一个地通知就非常麻烦。多播方式，既可以实现一次传送所有目标节点的数据，也可以达到只对特定对象传送数据的目的。多播在网络技术的应用并不是很多，网上视频会议、网上视频点播特别适合采用多播方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;广播(broadcast)&lt;/strong&gt;：可以理解为一个人通过广播喇叭对在场的全体说话，这样做的好处是通话效率高，信息一下子就可以传递到全体，广播是不区分目标、全部发送的方式，一次可以传送完数据，但是不区分特定数据接收对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;上面列举的发现机制中， Zen Discovery 是 ES 默认内建发现机制。它提供&lt;strong&gt;单播&lt;/strong&gt;和&lt;strong&gt;多播&lt;/strong&gt;的发现方式，并且可以扩展为通过插件支持云环境和其他形式的发现。所以我们接下来重点介绍下 Zen Discovery是如何在Elasticsearch中使用的。&lt;/p&gt;
&lt;p&gt;集群是由相同&lt;code&gt;cluster.name&lt;/code&gt;的节点组成的。当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 &lt;code&gt;cluster.name&lt;/code&gt; 配置，它就会自动发现集群并加入到其中。但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。&lt;/p&gt;
&lt;p&gt;单播主机列表通过&lt;code&gt;discovery.zen.ping.unicast.hosts&lt;/code&gt;来配置。这个配置在 elasticsearch.yml 文件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;discovery.zen.ping.unicast.hosts: [&quot;host1&quot;, &quot;host2:port&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的值是一个主机数组或逗号分隔的字符串。每个值应采用&lt;code&gt;host：port&lt;/code&gt;或&lt;code&gt;host&lt;/code&gt;的形式（其中&lt;code&gt;port&lt;/code&gt;默认为设置&lt;code&gt;transport.profiles.default.port&lt;/code&gt;，如果未设置则返回&lt;code&gt;transport.tcp.port&lt;/code&gt;）。请注意，必须将IPv6主机置于括号内。此设置的默认值为&lt;code&gt;127.0.0.1，[:: 1]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Elasticsearch 官方推荐我们使用 &lt;em&gt;单播&lt;/em&gt; 代替 &lt;em&gt;组播&lt;/em&gt;。而且 Elasticsearch 默认被配置为使用 &lt;em&gt;单播&lt;/em&gt; 发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。&lt;/p&gt;
&lt;p&gt;虽然 &lt;em&gt;组播&lt;/em&gt; 仍然作为插件提供， 但它应该永远不被使用在生产环境了，否则你得到的结果就是一个节点意外的加入到了你的生产环境，仅仅是因为他们收到了一个错误的 &lt;em&gt;组播&lt;/em&gt; 信号。对于 &lt;em&gt;组播&lt;/em&gt; 本身并没有错，组播会导致一些愚蠢的问题，并且导致集群变的脆弱（比如，一个网络工程师正在捣鼓网络，而没有告诉你，你会发现所有的节点突然发现不了对方了）。&lt;/p&gt;
&lt;p&gt;使用单播，你可以为 Elasticsearch 提供一些它应该去尝试连接的节点列表。当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 master 节点，并加入集群。&lt;/p&gt;
&lt;p&gt;这意味着你的单播列表不需要包含你的集群中的所有节点，它只是需要足够的节点，当一个新节点联系上其中一个并且说上话就可以了。如果你使用 master 候选节点作为单播列表，你只要列出三个就可以了。&lt;/p&gt;
&lt;p&gt;关于 Elasticsearch 节点发现的详细信息，请参阅 &lt;a href=&quot;https://www.cnblogs.com/jajian/p/10176707.html&quot;&gt;Zen Discovery&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;对于分布式系统的熟悉，我们应该知道分布式系统设计的目的是为了提高可用性和容错性。在单点系统中的问题在 ES 中同样也会存在。&lt;/p&gt;
&lt;h2 id=&quot;单节点的问题&quot;&gt;单节点的问题&lt;/h2&gt;
&lt;p&gt;如果我们启动了一个单独的节点，里面不包含任何的数据和索引，那我们的集群就是一个包含空内容节点的集群，简称&lt;strong&gt;空集群&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201812/1162587-20181225224211859-1069567695.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。单点的最大问题是系统容错性不高，当单节点所在服务器发生故障后，整个 ES 服务就会停止工作。&lt;/p&gt;
&lt;p&gt;让我们在包含一个空节点的集群内创建名为 user 的索引。索引在默认情况下会被分配5个主分片和每个主分片的1个副本， 但是为了演示目的，我们将分配3个主分片和一份副本（每个主分片拥有一个副本分片）：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT /user
{
   &quot;settings&quot; : {
      &quot;number_of_shards&quot; : 3,
      &quot;number_of_replicas&quot; : 1
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的集群现在是下图所示情况，所有3个主分片都被分配在 Node 1 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201812/1162587-20181225224131842-1923692456.png&quot; alt=&quot;拥有一个索引的单节点集群&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时检查集群的健康状况&lt;code&gt;GET /_cluster/health&lt;/code&gt;，我们会发现：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;cluster_name&quot;: &quot;elasticsearch&quot;,
  &quot;status&quot;: &quot;yellow&quot;,                     # 1
  &quot;timed_out&quot;: false,
  &quot;number_of_nodes&quot;: 1,
  &quot;number_of_data_nodes&quot;: 1,
  &quot;active_primary_shards&quot;: 3,
  &quot;active_shards&quot;: 3,
  &quot;relocating_shards&quot;: 0,
  &quot;initializing_shards&quot;: 0,
  &quot;unassigned_shards&quot;: 3,                 # 2
  &quot;delayed_unassigned_shards&quot;: 0,
  &quot;number_of_pending_tasks&quot;: 0,
  &quot;number_of_in_flight_fetch&quot;: 0,
  &quot;task_max_waiting_in_queue_millis&quot;: 0,
  &quot;active_shards_percent_as_number&quot;: 50
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;#1 集群的状态值是 yellow&lt;br/&gt;#2 未分配的副本数是 3&lt;/p&gt;
&lt;p&gt;集群的健康状况为 yellow 则表示全部 主 分片都正常运行（集群可以正常服务所有请求），但是 副本 分片没有全部处在正常状态。 实际上，所有3个副本分片都是 unassigned —— 它们都没有被分配到任何节点。 在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;主分片和对应的副本分片是不会在同一个节点上的。所以副本分片数的最大值是 n -1（其中n 为节点数）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然当前我们的集群是正常运行的，但是在硬件故障时有丢失数据的风险。&lt;/p&gt;
&lt;h2 id=&quot;水平扩容&quot;&gt;水平扩容&lt;/h2&gt;
&lt;p&gt;既然单点是有问题的，那我们只需再启动几个节点并加入到当前集群中，这样就可以提高可用性并实现故障转移，这种方式即 &lt;strong&gt;水平扩容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201812/1162587-20181225230224763-1623024858.png&quot; alt=&quot;拥有两个节点的集群&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还以上面的 user 为例，我们新增一个节点后，新的集群如上图所示。&lt;/p&gt;
&lt;p&gt;当第二个节点加入到集群后，3个 副本分片 将会分配到这个节点上——每个主分片对应一个副本分片。 这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。&lt;/p&gt;
&lt;p&gt;所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cluster-health&lt;/code&gt;现在展示的状态为 &lt;code&gt;green&lt;/code&gt; ，这表示所有6个分片（包括3个主分片和3个副本分片）都在正常运行。我们的集群现在不仅仅是正常运行的，并且还处于 始终可用 的状态。&lt;/p&gt;
&lt;h2 id=&quot;动态扩容&quot;&gt;动态扩容&lt;/h2&gt;
&lt;p&gt;产品不断升级，业务不断增长，用户数也会不断新增，也许我们之前设计的索引容量（3个主分片和3个副本分片）已经不够使用了，用户数据的不断增加，每个主分片和副本分片的数据不断累积，达到一定程度之后也会降低搜索性能。那么怎样为我们的正在增长中的应用程序按需扩容呢？&lt;/p&gt;
&lt;p&gt;我们将之前的两个节点继续水平扩容，再增加一个节点，此时集群状态如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201812/1162587-20181225230025843-1978704951.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了分散负载，ES 会对分片进行重新分配。Node 1 和 Node 2 上各有一个分片被迁移到了新的 Node 3 节点，现在每个节点上都拥有2个分片，而不是之前的3个。 这表示每个节点的硬件资源（CPU, RAM, I/O）将被更少的分片所共享，每个分片的性能将会得到提升。&lt;/p&gt;
&lt;p&gt;分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有6个分片（3个主分片和3个副本分片）的索引可以最大扩容到6个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是如果我们想要扩容超过6个节点怎么办呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主分片的数目在索引创建时 就已经确定了下来。实际上，这个数目定义了这个索引能够 存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;索引的主分片数这个值在索引创建后就不能修改了（默认值是 5），但是每个主分片的副本数（默认值是 1 ）对于活动的索引库，这个值可以随时修改的。&lt;/strong&gt;至于索引的主分片数为什么在索引创建之后就不能修改了，我们在下面的文档存储原理章节中说明。&lt;/p&gt;
&lt;p&gt;既然在运行中的集群上是可以动态调整副本分片数目的 ，那么我们可以按需伸缩集群。让我们把副本数从默认的 1 增加到 2 ：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT /user/_settings
{
   &quot;number_of_replicas&quot; : 2
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图 所示， user 索引现在拥有9个分片：3个主分片和6个副本分片。 这意味着我们可以将集群扩容到9个节点，每个节点上一个分片。相比原来3个节点时，集群搜索性能可以提升 3 倍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201812/1162587-20181225232137959-1207402272.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每个分片从节点上获得的资源会变少。 你需要增加更多的硬件资源来提升吞吐量。&lt;/p&gt;
&lt;p&gt;但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去2个节点的情况下不丢失任何数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;节点故障&quot;&gt;节点故障&lt;/h2&gt;
&lt;p&gt;如果我们某一个节点发生故障，节点服务器宕机或网络不可用，这里假设主节点1发生故障，这时集群的状态为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201812/1162587-20181225232447898-1479964935.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们检查一下集群的健康状况，可以发现状态为 &lt;code&gt;red&lt;/code&gt;，表示不是所有主分片都在正常工作。&lt;/p&gt;
&lt;p&gt;我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： Node 2 。&lt;/p&gt;
&lt;p&gt;在我们关闭 Node 1 的同时也失去了主分片 1 和 2 ，并且在缺失主分片的时候索引也不能正常工作。&lt;/p&gt;
&lt;p&gt;幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片， 此时集群的状态将会为 &lt;code&gt;yellow&lt;/code&gt;。 这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。&lt;/p&gt;
&lt;p&gt;为什么我们集群状态是 &lt;code&gt;yellow&lt;/code&gt; 而不是 &lt;code&gt;green&lt;/code&gt; 呢？ 虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应2份副本分片，而此时只存在一份副本分片。 所以集群不能为 &lt;code&gt;green&lt;/code&gt; 的状态，不过我们不必过于担心：如果我们同样关闭了 Node 2 ，我们的程序 依然 可以保持在不丢任何数据的情况下运行，因为 Node 3 为每一个分片都保留着一份副本。&lt;/p&gt;
&lt;p&gt;如果我们重新启动 Node 1 ，集群可以将缺失的副本分片再次进行分配，那么集群的状态又将恢复到原来的正常状态。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。&lt;/p&gt;

&lt;p&gt;分布式系统中最麻烦的就是并发冲突，既然 ES 也是分布式的那它是如何处理并发冲突的呢？&lt;/p&gt;
&lt;p&gt;通常当我们使用 索引 API 更新文档时 ，可以一次性读取原始文档，做我们的修改，然后重新索引 整个文档 。 最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。&lt;/p&gt;
&lt;p&gt;很多时候这是没有问题的。也许我们的主数据存储是一个关系型数据库，我们只是将数据复制到 Elasticsearch 中并使其可被搜索。也许两个人同时更改相同的文档的几率很小。或者对于我们的业务来说偶尔丢失更改并不是很严重的问题。&lt;/p&gt;
&lt;p&gt;但有时丢失了一个变更就是非常严重的 。试想我们使用 Elasticsearch 存储我们网上商城商品库存的数量， 每次我们卖一个商品的时候，我们在 Elasticsearch 中将库存数量减少。&lt;/p&gt;
&lt;p&gt;有一天，管理层决定做一次促销。突然地，我们一秒要卖好几个商品。 假设有两个 web 程序并行运行，每一个都同时处理所有商品的销售，那么会造成库存结果不一致的情况。&lt;/p&gt;
&lt;p&gt;变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。&lt;/p&gt;
&lt;h2 id=&quot;乐观并发控制---版本号&quot;&gt;乐观并发控制 - 版本号&lt;/h2&gt;
&lt;p&gt;在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;悲观锁&lt;br/&gt;这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;乐观锁&lt;br/&gt;Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Elasticsearch 中对文档的 index ， GET 和 delete 请求时，我们指出每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。&lt;/p&gt;
&lt;p&gt;Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。&lt;/p&gt;
&lt;p&gt;我们可以利用 _version 号来确保应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version 号来达到这个目的。 如果该版本不是当前版本号，我们的请求将会失败。&lt;/p&gt;
&lt;p&gt;所有文档的更新或删除 API，都可以接受 &lt;code&gt;version&lt;/code&gt; 参数，这允许你在代码中使用乐观的并发控制，这是一种明智的做法。&lt;/p&gt;
&lt;h2 id=&quot;乐观并发控制---外部系统&quot;&gt;乐观并发控制 - 外部系统&lt;/h2&gt;
&lt;p&gt;版本号（version）只是其中一个实现方式，我们还可以借助外部系统使用版本控制，一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索， 这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。&lt;/p&gt;
&lt;p&gt;如果你的主数据库已经有了版本号，或一个能作为版本号的字段值比如 &lt;code&gt;timestamp&lt;/code&gt;，那么你就可以在 Elasticsearch 中通过增加 &lt;code&gt;version_type=external&lt;/code&gt;到查询字符串的方式重用这些相同的版本号，版本号必须是大于零的整数， 且小于 &lt;code&gt;9.2E+18&lt;/code&gt;(一个 Java 中 long 类型的正值)。&lt;/p&gt;
&lt;p&gt;外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 &lt;code&gt;_version&lt;/code&gt; 和请求中指定的版本号是否相同，而是检查当前&lt;code&gt;_version&lt;/code&gt; 是否小于指定的版本号。如果请求成功，外部的版本号作为文档的新&lt;code&gt;_version&lt;/code&gt; 进行存储。&lt;/p&gt;
&lt;p&gt;外部版本号不仅在索引和删除请求是可以指定，而且在创建新文档时也可以指定。&lt;/p&gt;
&lt;p&gt;例如，要创建一个新的具有外部版本号 5 的博客文章，我们可以按以下方法进行：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT /website/blog/2?version=5&amp;amp;version_type=external
{
  &quot;title&quot;: &quot;My first external blog entry&quot;,
  &quot;text&quot;:  &quot;Starting to get the hang of this...&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在响应中，我们能看到当前的 _version 版本号是 5 ：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;_index&quot;:   &quot;website&quot;,
  &quot;_type&quot;:    &quot;blog&quot;,
  &quot;_id&quot;:      &quot;2&quot;,
  &quot;_version&quot;: 5,
  &quot;created&quot;:  true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们更新这个文档，指定一个新的 version 号是 10 ：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT /website/blog/2?version=10&amp;amp;version_type=external
{
  &quot;title&quot;: &quot;My first external blog entry&quot;,
  &quot;text&quot;:  &quot;This is a piece of cake...&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求成功并将当前 _version 设为 10 ：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;_index&quot;:   &quot;website&quot;,
  &quot;_type&quot;:    &quot;blog&quot;,
  &quot;_id&quot;:      &quot;2&quot;,
  &quot;_version&quot;: 10,
  &quot;created&quot;:  false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你要重新运行此请求时，它将会失败，并返回像我们之前看到的同样的冲突错误，因为指定的外部版本号不大于 Elasticsearch 的当前版本号。&lt;/p&gt;

&lt;p&gt;创建索引的时候我们只需要指定分片数和副本数，ES 就会自动将文档数据分发到对应的分片和副本中。那么文件究竟是如何分布到集群的，又是如何从集群中获取的呢？ Elasticsearch 虽然隐藏这些底层细节，让我们好专注在业务开发中，但是我们深入探索这些核心的技术细节，这能帮助你更好地理解数据如何被存储到这个分布式系统中。&lt;/p&gt;
&lt;h2 id=&quot;文档是如何路由到分片中的&quot;&gt;文档是如何路由到分片中的&lt;/h2&gt;
&lt;p&gt;当索引一个文档的时候，文档会被存储到一个主分片中。 Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？&lt;/p&gt;
&lt;p&gt;首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shard = hash(routing) % number_of_primary_shards&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;routing&lt;/code&gt; 是一个可变值，默认是文档的 &lt;code&gt;_id&lt;/code&gt; ，也可以设置成一个自定义的值。 &lt;code&gt;routing&lt;/code&gt; 通过 &lt;code&gt;hash&lt;/code&gt; 函数生成一个数字，然后这个数字再除以 &lt;code&gt;number_of_primary_shards&lt;/code&gt; （主分片的数量）后得到 余数 。这个分布在 0 到 &lt;code&gt;number_of_primary_shards-1&lt;/code&gt; 之间的余数，就是我们所寻求的文档所在分片的位置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就解释了为什么我们要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;你可能觉得由于 Elasticsearch 主分片数量是固定的会使索引难以进行扩容，所以在创建索引的时候合理的预分配分片数是很重要的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有的文档 API（ get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 &lt;code&gt;routing&lt;/code&gt; 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中。更多路由相关的内容可以访问&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;主分片和副本分片如何交互&quot;&gt;主分片和副本分片如何交互&lt;/h2&gt;
&lt;p&gt;上面介绍了一个文档是如何路由到一个分片中的，那么主分片是如何和副本分片交互的呢？&lt;/p&gt;
&lt;p&gt;假设有个集群由三个节点组成， 它包含一个叫 user 的索引，有两个主分片，每个主分片有两个副本分片。相同分片的副本不会放在同一节点，所以我们的集群看起来如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201812/1162587-20181226214933637-1289106103.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。 在下面的例子中，将所有的请求发送到 Node 1 ，我们将其称为 &lt;strong&gt;协调节点(coordinating node)&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当发送请求的时候，为了扩展负载，更好的做法是轮询集群中所有的节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对文档的新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201812/1162587-20181226215010964-845400353.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是在主副分片和任何副本分片上面 成功新建，索引和删除文档所需要的步骤顺序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端向 Node 1 发送新建、索引或者删除请求。&lt;/li&gt;
&lt;li&gt;节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。&lt;/li&gt;
&lt;li&gt;Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node1 和 Node2 的副本分片上。一旦所有的副本分片都报告成功，Node 3 将向协调节点报告成功，协调节点向客户端报告成功。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。&lt;/p&gt;
&lt;p&gt;在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。&lt;/p&gt;
&lt;p&gt;在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。&lt;/p&gt;
</description>
<pubDate>Wed, 26 Dec 2018 14:30:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>前言 通过前面章节的了解，我们已经知道 Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以一个之前从未有过的速度和规模，去探索你的数据。它被用作全文检索、结构化搜索、分析以及这三个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/10176604.html</dc:identifier>
</item>
</channel>
</rss>