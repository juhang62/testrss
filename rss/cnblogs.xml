<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[翻译] 正式宣布 .NET 5 - Rwing</title>
<link>http://www.cnblogs.com/Rwing/p/introducing-net-5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rwing/p/introducing-net-5.html</guid>
<description>&lt;p&gt;原文: &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/introducing-net-5/&quot;&gt;Introducing .NET 5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天，我们宣布 .NET Core 3.0 之后的下一个版本将是 .NET 5 。这将是 .NET 系列的下一个重要版本。&lt;/p&gt;
&lt;p&gt;将来只会有一个 .NET ，您将能够使用它来开发 Windows，Linux，macOS，iOS，Android，tvOS，watchOS 和 WebAssembly 等等。&lt;/p&gt;
&lt;p&gt;我们将在 .NET 5 中引入新的 .NET API、运行时功能和语言功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet5_platform.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从 .NET Core 项目开始，我们已经向平台添加了大约五万个 .NET Framework API。 .NET Core 3.0 弥补了 .NET Framework 4.8 的大部分剩余功能差距，支持 Windows Forms，WPF 和Entity Framework 6。 .NET 5 构建于此工作之上，利用 .NET Core 和 Mono 的最佳功能创建一个平台，您可以用于所有现代 .NET 代码。&lt;/p&gt;
&lt;p&gt;我们打算在 2020 年 11 月发布 .NET 5，并在 2020 年上半年推出第一个预览版。将在 Visual Studio 2019、Visual Studio for Mac 和 Visual Studio Code 的未来更新中支持它。&lt;/p&gt;
&lt;h2 id=&quot;net-5-.net-core-vnext&quot;&gt;.NET 5 = .NET Core vNext&lt;/h2&gt;
&lt;p&gt;NET 5 是 .NET Core 的下一步。该项目旨在通过以下几个关键方式改进 .NET：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;制造一个可在任何地方使用的 .NET 运行时和框架, 并具有统一的运行时行为和开发人员体验。&lt;/li&gt;
&lt;li&gt;通过充分利用 .NET Core、.NET Framework、Xamarin 和 Mono 来扩展 .NET 的功能。&lt;/li&gt;
&lt;li&gt;从单个代码库构建该产品，开发人员（ Microsoft 和社区）可以一起工作并一起扩展，从而改进所有方案。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个新项目和方向是 .NET 的一个重要转折。使用 .NET 5，无论您正在构建哪种类型的应用程序，您的代码和项目文件都将是相同的。每个应用都可以访问相同的运行时、API 和语言功能。也包括几乎每天都在进行的 corefx 的&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/&quot;&gt;性能改进&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;您所喜欢 .NET Core 的所有内容将继续存在：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 GitHub 上开源和面向社区。&lt;/li&gt;
&lt;li&gt;跨平台实现。&lt;/li&gt;
&lt;li&gt;支持利用特定于平台的功能，例如 Windows 上的 Windows form 和 WPF 以及来自 Xamarin 的每个原生平台的原生绑定。&lt;/li&gt;
&lt;li&gt;高性能。&lt;/li&gt;
&lt;li&gt;并排安装。&lt;/li&gt;
&lt;li&gt;小型项目文件（SDK风格）。&lt;/li&gt;
&lt;li&gt;兼容命令行界面（CLI）。&lt;/li&gt;
&lt;li&gt;Visual Studio，Visual Studio for Mac 和 Visual Studio Code集成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也有一些新的东西：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;您将有更多关于运行时体验的选择（更多内容见下文）。&lt;/li&gt;
&lt;li&gt;Java 互操作性将在所有平台上提供。&lt;/li&gt;
&lt;li&gt;多个操作系统将支持 Objective-C 和 Swift 互操作性。&lt;/li&gt;
&lt;li&gt;CoreFX 将扩展为支持 .NET 的静态编译（ahead-of-time – AOT），更小的空间占用和对更多操作系统的支持。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们将在今年 9 月发布 .NET Core 3.0，在 2020 年 11 月发布 .NET 5，然后我们打算每年 11 月发布一次主要版本的 .NET：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet_schedule.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们跳过了版本 4，因为它会让熟悉 .NET Framework 的用户感到困惑，因为 .NET Framework 已经使用了很长时间的4.x系列。此外，我们希望清楚地传达 .NET 5 是 .NET 平台的未来。将其称为 .NET 5 使其成为我们发布过的最高版本。&lt;/p&gt;
&lt;p&gt;我们也借此机会简化命名。我们认为如果只有一个 .NET 是最好的了，我们就不需要像 “Core” 这样的澄清术语。较短的名称是一种简化, 还传达了 .NET 5 具有统一的功能和行为的信息。当然如果您愿意也可以继续使用 “.NET Core” 这个名称。&lt;/p&gt;
&lt;h2 id=&quot;运行时体验&quot;&gt;运行时体验&lt;/h2&gt;
&lt;p&gt;Mono 是 .NET 的原始跨平台实现。它最初是作为 .NET Framework 的开源替代品，并随着 iPhone/iOS 和 Android设 备的普及而转变为针对移动设备。Mono 是用作 Xamarin 一部分的运行时。&lt;/p&gt;
&lt;p&gt;CoreCLR 是用作 .NET Core 一部分的运行时。它主要用于支持云应用程序，包括 Microsoft 的最大服务，现在也用于 Windows 桌面，物联网和机器学习应用程序。&lt;/p&gt;
&lt;p&gt;总而言之，.NET Core 和 Mono 运行时有许多相似之处（毕竟它们都是 .NE T运行时），但也有宝贵的独特功能。让选择所需的运行时体验成为可能是非常有意义的。我们正在使 CoreCLR 和 Mono 可以互相替换。我们将使它像构建开关一样简单，以便在不同的运行时选项之间进行选择。&lt;/p&gt;
&lt;p&gt;以下部分描述了我们计划用于 .NET 5 的主要重心。它们为我们计划如何单独和共同发展这两个运行时提供了清晰的视角。&lt;/p&gt;
&lt;h2 id=&quot;高吞吐量和高生产率&quot;&gt;高吞吐量和高生产率&lt;/h2&gt;
&lt;p&gt;从一开始，.NET 就依赖于即时编译器（JIT）将中间语言（IL）代码转换为优化的机器代码。从那时起，我们构建了业界领先的基于 JIT 的托管运行时，该运行时具有非常高的吞吐量，并且还提高了开发人员体验，使编程变得快速而简单。&lt;/p&gt;
&lt;p&gt;JIT 非常适合长期运行的云和客户端方案。他们能够生成针对特定机器配置的代码，包括特定的 CPU 指令。JIT 还可以在运行时&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/&quot;&gt;重新生成方法&lt;/a&gt;，这一共让 JIT 更快速的技术，同时仍可选择生成高度优化的代码版本 (如果这成为经常使用的方法)。&lt;/p&gt;
&lt;p&gt;我们努力使 ASP.NET Core 在 &lt;a href=&quot;https://www.techempower.com/benchmarks/&quot;&gt;Techpower 基准测试&lt;/a&gt;上运行得更快, 这是 JIT 强大的力量和我们在 CoreCLR 上的投资的一个很好的例子。我们为&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/&quot;&gt;容器强化 .NET Core&lt;/a&gt;的努力也证明了运行时动态适应受限环境的能力。&lt;/p&gt;
&lt;p&gt;开发人员工具是 JIT 非常棒的另一个好例子，例如 &lt;code&gt;dotnet watch&lt;/code&gt; 工具或&lt;code&gt;编辑并继续&lt;/code&gt;。工具通常需要在单个进程中多次编译和加载代码, 而无需重新启动, 并且需要非常快速地执行此操作。&lt;/p&gt;
&lt;p&gt;使用 .NET Core 或 .NET Framework 的开发人员主要依赖于 JIT 。因此，这种体验应该是熟悉的。&lt;/p&gt;
&lt;p&gt;大多数 .NET 5 工作场景的默认体验将使用基于 JIT 的 CoreCLR 运行时。两个值得注意的例外是 iOS 和客户端 Blazor（web assembly），因为它们都需要 ahead-of-time (AOT) 原生编译。&lt;/p&gt;
&lt;h2 id=&quot;快速启动占用空间小内存使用率低&quot;&gt;快速启动，占用空间小，内存使用率低&lt;/h2&gt;
&lt;p&gt;Mono 项目的大部分精力都集中在移动和游戏机上。该项目的一个关键功能和结果是基于业界领先的 LLVM 编译器项目的 .NET AOT 编译器。Mono AOT 编译器允许将 .NET 代码内置到一个可以在计算机上运行的原生代码可执行文件中, 就像 C++ 代码一样。AOT 编译的应用可以在较小的位置高效运行, 并在需要时交换吞吐量以进行启动。&lt;/p&gt;
&lt;p&gt;Blavor 项目已经在使用 Mono AOT。这将是最早过渡到 .NET 5 的项目之一。我们把它作为证明这个计划的方案之一。&lt;/p&gt;
&lt;p&gt;有两种类型的 AOT 解决方案:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要 100% AOT 编译的解决方案。&lt;/li&gt;
&lt;li&gt;大多数代码是 AOT 编译的解决方案, 但 JIT 或解释器可用于与 AOT 不友好的代码模式 (如泛型)。&lt;br/&gt;Mono AOT 支持这两种情况。出于安全原因，苹果对 iOS 和一些游戏机需要第一种 AOT。第二种方法是更好的选择, 因为它提供了 AOT 的优点并且避免了一些缺点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.NET Native 是我们用于 Windows UWP 应用程序的 AOT 编译器, 也是上面列出的第一种 AOT 类型的示例。在这个特定实现里, 我们限制了 .NET API 和您可以使用的功能。我们从这一经验中了解到, AOT 解决方案需要涵盖 .NET API 和模式的所有方面。&lt;/p&gt;
&lt;p&gt;在 iOS、 web assembly 和一些游戏机里 AOT 编译仍需要。对于更需要快速启动或低占用空间的应用程序, 我们将使 AOT 编译成为一个选项。&lt;/p&gt;
&lt;h2 id=&quot;该项目的诞生&quot;&gt;该项目的诞生&lt;/h2&gt;
&lt;p&gt;我们于 2018 年 12 月在波士顿召开了一个技术团队，开始了这个项目。来自 .NET 团队（Mono/Xamarin和.NET Core）以及 Unity 的设计领导者介绍了各种技术能力和架构方向。&lt;/p&gt;
&lt;p&gt;我们现在正在将这个项目作为一个团队推进，并提供一套可交付成果。自 12 月以来，我们在一些项目上取得了很多进展：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义了一个最小层，它定义了运行时 &amp;lt;-&amp;gt; 托管代码层，目标是实现 &amp;gt;99% 的 CoreFX 公共代码。&lt;/li&gt;
&lt;li&gt;MonoVM 现在可以使用 CoreFX 及其类库。&lt;/li&gt;
&lt;li&gt;使用 CoreFX 实现在 MonoVM 上运行所有 CoreFX 测试。&lt;/li&gt;
&lt;li&gt;使用 MonoVM 运行 ASP.NET Core 3.0 应用程序。&lt;/li&gt;
&lt;li&gt;在 CoreCLR 上运行 MonoDevelop，然后运行 Visual Studio for Mac。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;迁移到单个.NET实现会引发一些重要问题: 目标框架将是什么？ NuGet包兼容性规则是否相同？ .NET 5 SDK 应该支持哪些工作负载？如何为特定架构编写代码？我们还需要 .NET Standard吗？&lt;br/&gt;我们现在正在解决这些问题，很快将分享设计文档供您阅读并提供反馈。&lt;/p&gt;
&lt;h2 id=&quot;尾声&quot;&gt;尾声&lt;/h2&gt;
&lt;p&gt;.NET 5 项目是 .NET 的重要且令人兴奋的新方向。您将看到 .NET 变得更简单，但也具有更广泛，更广泛的功能和实用性。所有新的开发和功能都将成为 .NET 5 的一部分，包括新的 C# 版本。&lt;/p&gt;
&lt;p&gt;我们看到了光明的未来，您可以使用相同的 .NET API 和语言来面向各种应用程序类型、操作系统和芯片架构。在 Visual Studio ，Visual Studio for Mac，Visual Studio Code，Azure DevOps 或命令行中，可以轻松更改构建配置以构建不同的应用程序。&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 17:18:00 +0000</pubDate>
<dc:creator>Rwing</dc:creator>
<og:description>今天，我们宣布 .NET Core 3.0 之后的下一个版本将是 .NET 5 。这将是 .NET 系列的下一个重要版本。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rwing/p/introducing-net-5.html</dc:identifier>
</item>
<item>
<title>死磕 java并发包之AtomicInteger源码分析 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/AtomicInteger.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/AtomicInteger.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）什么是原子操作？&lt;/p&gt;
&lt;p&gt;（2）原子操作和数据库的ACID有啥关系？&lt;/p&gt;
&lt;p&gt;（3）AtomicInteger是怎么实现原子操作的？&lt;/p&gt;
&lt;p&gt;（4）AtomicInteger是有什么缺点？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;AtomicInteger是java并发包下面提供的原子类，主要操作的是int类型的整型，通过调用底层Unsafe的CAS等方法实现原子操作。&lt;/p&gt;
&lt;p&gt;还记得Unsafe吗？点击链接直达【&lt;a href=&quot;https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA&quot;&gt;死磕 java魔法类之Unsafe解析&lt;/a&gt;】&lt;/p&gt;
&lt;h2 id=&quot;原子操作&quot;&gt;原子操作&lt;/h2&gt;
&lt;p&gt;原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。&lt;/p&gt;
&lt;p&gt;原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。&lt;/p&gt;
&lt;p&gt;我们这里说的原子操作与数据库ACID中的原子性，笔者认为最大区别在于，数据库中的原子性主要运用在事务中，一个事务之内的所有更新操作要么都成功，要么都失败，事务是有回滚机制的，而我们这里说的原子操作是没有回滚的，这是最大的区别。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;主要属性&quot;&gt;主要属性&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 获取Unsafe的实例
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 标识value字段的偏移量
private static final long valueOffset;
// 静态代码块，通过unsafe获取value的偏移量
static {
    try {
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
    } catch (Exception ex) { throw new Error(ex); }
}
// 存储int类型值的地方，使用volatile修饰
private volatile int value;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）使用int类型的value存储值，且使用volatile修饰，volatile主要是保证可见性，即一个线程修改对另一个线程立即可见，主要的实现原理是内存屏障，这里不展开来讲，有兴趣的可以自行查阅相关资料。&lt;/p&gt;
&lt;p&gt;（2）调用Unsafe的objectFieldOffset()方法获取value字段在类中的偏移量，用于后面CAS操作时使用。&lt;/p&gt;
&lt;h3 id=&quot;compareandset方法&quot;&gt;compareAndSet()方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
// Unsafe中的方法
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用Unsafe.compareAndSwapInt()方法实现，这个方法有四个参数：&lt;/p&gt;
&lt;p&gt;（1）操作的对象；&lt;/p&gt;
&lt;p&gt;（2）对象中字段的偏移量；&lt;/p&gt;
&lt;p&gt;（3）原来的值，即期望的值；&lt;/p&gt;
&lt;p&gt;（4）要修改的值；&lt;/p&gt;
&lt;p&gt;可以看到，这是一个native方法，底层是使用C/C++写的，主要是调用CPU的CAS指令来实现，它能够保证只有当对应偏移量处的字段值是期望值时才更新，即类似下面这样的两步操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(value == expect) {
    value = newValue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过CPU的CAS指令可以保证这两步操作是一个整体，也就不会出现多线程环境中可能比较的时候value值是a，而到真正赋值的时候value值可能已经变成b了的问题。&lt;/p&gt;
&lt;h3 id=&quot;getandincrement方法&quot;&gt;getAndIncrement()方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}

// Unsafe中的方法
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getAndIncrement()方法底层是调用的Unsafe的getAndAddInt()方法，这个方法有三个参数：&lt;/p&gt;
&lt;p&gt;（1）操作的对象；&lt;/p&gt;
&lt;p&gt;（2）对象中字段的偏移量；&lt;/p&gt;
&lt;p&gt;（3）要增加的值；&lt;/p&gt;
&lt;p&gt;查看Unsafe的getAndAddInt()方法的源码，可以看到它是先获取当前的值，然后再调用compareAndSwapInt()尝试更新对应偏移量处的值，如果成功了就跳出循环，如果不成功就再重新尝试，直到成功为止，这可不就是（CAS+自旋）的乐观锁机制么^^&lt;/p&gt;
&lt;p&gt;AtomicInteger中的其它方法几乎都是类似的，最终会调用到Unsafe的compareAndSwapInt()来保证对value值更新的原子性。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）AtomicInteger中维护了一个使用volatile修饰的变量value，保证可见性；&lt;/p&gt;
&lt;p&gt;（2）AtomicInteger中的主要方法最终几乎都会调用到Unsafe的compareAndSwapInt()方法保证对变量修改的原子性。&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;（1）为什么需要AtomicInteger？&lt;/p&gt;
&lt;p&gt;让我们来看一个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AtomicIntegerTest {
    private static int count = 0;

    public static void increment() {
        count++;
    }

    public static void main(String[] args) {
        IntStream.range(0, 100)
                .forEach(i-&amp;gt;
                        new Thread(()-&amp;gt;IntStream.range(0, 1000)
                                .forEach(j-&amp;gt;increment())).start());

        // 这里使用2或者1看自己的机器
        // 我这里是用run跑大于2才会退出循环
        // 但是用debug跑大于1就会退出循环了
        while (Thread.activeCount() &amp;gt; 1) {
            // 让出CPU
            Thread.yield();
        }

        System.out.println(count);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里起了100个线程，每个线程对count自增1000次，你会发现每次运行的结果都不一样，但它们有个共同点就是都不到100000次，所以直接使用int是有问题的。&lt;/p&gt;
&lt;p&gt;那么，使用volatile能解决这个问题吗？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static volatile int count = 0;

public static void increment() {
    count++;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;答案是很遗憾的，volatile无法解决这个问题，因为volatile仅有两个作用：&lt;/p&gt;
&lt;p&gt;（1）保证可见性，即一个线程对变量的修改另一个线程立即可见；&lt;/p&gt;
&lt;p&gt;（2）禁止指令重排序；&lt;/p&gt;
&lt;p&gt;这里有个很重要的问题，count++实际上是两步操作，第一步是获取count的值，第二步是对它的值加1。&lt;/p&gt;
&lt;p&gt;使用volatile是无法保证这两步不被其它线程调度打断的，所以无法保证原子性。&lt;/p&gt;
&lt;p&gt;这就引出了我们今天讲的AtomicInteger，它的自增调用的是Unsafe的CAS并使用自旋保证一定会成功，它可以保证两步操作的原子性。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AtomicIntegerTest {
    private static AtomicInteger count = new AtomicInteger(0);

    public static void increment() {
        count.incrementAndGet();
    }

    public static void main(String[] args) {
        IntStream.range(0, 100)
                .forEach(i-&amp;gt;
                        new Thread(()-&amp;gt;IntStream.range(0, 1000)
                                .forEach(j-&amp;gt;increment())).start());

        // 这里使用2或者1看自己的机器
        // 我这里是用run跑大于2才会退出循环
        // 但是用debug跑大于1就会退出循环了
        while (Thread.activeCount() &amp;gt; 1) {
            // 让出CPU
            Thread.yield();
        }

        System.out.println(count);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里总是会打印出100000。&lt;/p&gt;
&lt;p&gt;（2）说了那么多，你知道AtomicInteger有什么缺点吗？&lt;/p&gt;
&lt;p&gt;当然就是著名的ABA问题啦，我们下章接着聊^^&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 16:21:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>什么是原子操作？ 原子操作和数据库的ACID有啥关系？ AtomicInteger是怎么实现原子操作的？ AtomicInteger是有什么缺点？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/AtomicInteger.html</dc:identifier>
</item>
<item>
<title>用Python搞定九宫格式的朋友圈。内附“马云”朋友圈 - 初一丶</title>
<link>http://www.cnblogs.com/wyl-0120/p/10823102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyl-0120/p/10823102.html</guid>
<description>&lt;p&gt;PIL(Python Imaging Library)是一个非常强大的Python库，但是它支持Python2.X， 在Python3中则使用的是Pillow库，它是从PIL中fork出来的一个分支。提供了非常强大的图片处理能力，包括存储、格式转换、图像处理等操作&lt;/p&gt;

&lt;p&gt;有时候看到朋友圈的九宫格动态，是不是感觉非常有逼格呢？ 今天就用Python来实现九宫格切图。&lt;/p&gt;

&lt;p&gt;先来看几张效果图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190507000351101-595647882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190507000355072-752399495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致思路分为以下几步&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;读取初始照片&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;比较照片的宽高，数值较大的作为边长生成一个新的空白图片&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将初始图片粘贴至第二部创建的空白图片上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将图片进行切割&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直接上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image

image &lt;/span&gt;= Image.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;图片路径.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
width, height &lt;/span&gt;=&lt;span&gt; image.size

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  高和宽进行比较，较大的为新图片的长度&lt;/span&gt;
new_length = height &lt;span&gt;if&lt;/span&gt; height &amp;gt; width &lt;span&gt;else&lt;/span&gt;&lt;span&gt; width

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一张正方形空图片，底色为白色,&lt;/span&gt;
new_image = Image.new(image.mode, (new_length, new_length), color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将要处理的图片粘贴到新创建的图片上，居中&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; height &amp;gt; width: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果高度大于宽，则填充图片的宽度&lt;/span&gt;
    new_image.paste(image, (int((new_length - width) / 2&lt;span&gt;)), 0)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    new_image.paste(image, (0, int((new_length &lt;/span&gt;- height) / 2&lt;span&gt;)))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 朋友圈一排三张图片因此宽度切割成3份&lt;/span&gt;
new_length = int(new_length / 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用来保存每一个切图&lt;/span&gt;
box_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 3&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(0, 3&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 确定每个图片的位置&lt;/span&gt;
        box = (j * new_length, i * new_length, (j + 1) * new_length, (i + 1) * new_length)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; (left, top, right, bottom)&lt;/span&gt;
&lt;span&gt;        box_list.append(box)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过crop函数对图片进行切割&lt;/span&gt;
image_list = [new_image.crop(box) &lt;span&gt;for&lt;/span&gt; box &lt;span&gt;in&lt;/span&gt;&lt;span&gt; box_list]

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (index, image) &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(image_list):
    image.save(str(index) &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PNG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;九宫格图片生成完毕！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了方便使用，通过pyinstaller对脚本进行打包成exe文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip3 install pyinstaller
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pyinstaller -F cut_picture.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就会在当前目录生成一个dist文件夹，里面就有我们最终需要的exe文件。如何使用呢？只需要在将要切割的图片重命名为“a.jpg”，放入同级目录中，双击启动即可&lt;/p&gt;
&lt;p&gt;效果图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190507000500491-1674389053.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有需要的同学可以在公众号【程序员共成长】后台 回复【&lt;strong&gt;cut&lt;/strong&gt;】获取exe文件的下载链接。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190507000529616-1338133676.png&quot; alt=&quot;&quot; width=&quot;835&quot; height=&quot;835&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 06 May 2019 16:06:00 +0000</pubDate>
<dc:creator>初一丶</dc:creator>
<og:description>PIL(Python Imaging Library)是一个非常强大的Python库，但是它支持Python2.X， 在Python3中则使用的是Pillow库，它是从PIL中fork出来的一个分支。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyl-0120/p/10823102.html</dc:identifier>
</item>
<item>
<title>外观模式 - mingmingcome</title>
<link>http://www.cnblogs.com/mingmingcome/p/10823092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mingmingcome/p/10823092.html</guid>
<description>&lt;p&gt;&lt;code&gt;2019年3月27日09:03:40&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;外观模式-facade-pattern&quot;&gt;外观模式（ facade pattern）&lt;/h2&gt;
&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;纵然身体里每个细胞都复杂得仿佛是一个宇宙，但是给人第一印象的你帅气的脸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;外观模式，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。————《设计模式：可复用面向对象软件的基础》&lt;/p&gt;
&lt;p&gt;外观模式是一种对象结构型模式。&lt;/p&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1、为了使子系统简单易用，为子系统的一组接口提供一个简单的接口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2、最小化对子系统的依赖性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3、构建层次化的子系统的时候，使用外观模式定义系统每一层的入口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单明了的例子就是家里的开关系统，灯、空调、冰箱等有自己的开关，而外观模式定义的就是总开关，你通过调用总开关就调用所有子系统即所有开关。&lt;/p&gt;
&lt;h4 id=&quot;角色&quot;&gt;角色&lt;/h4&gt;
&lt;p&gt;客户角色（Client）：调用外观角色&lt;/p&gt;
&lt;p&gt;外观角色（Facade）：知道哪些子系统负责处理请求，将客户端的请求转发给适当的子系统对象。&lt;/p&gt;
&lt;p&gt;子系统类角色（Subsystem Classes）：实现子系统的功能，处理外观角色指派的任务。&lt;/p&gt;
&lt;h4 id=&quot;图示&quot;&gt;图示&lt;/h4&gt;
&lt;p&gt;当一个系统拥有复杂的子系统时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/facade-without-facade.jpg&quot; alt=&quot;没有应用外观模式的系统&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同的客户端调用了不同子系统类的时候，如第一个客户端调用了Class1和Class2，第二个客户端调用了Class1、Class2、Class3等，导致耦合紧密，对于开发来说不利于修改，对于用户来说不利于使用。&lt;/p&gt;
&lt;p&gt;当使用了外观模式之后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/facade-with-facade.jpg&quot; alt=&quot;应用外观模式的系统&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了Facade外观类这个高层接口，耦合降低，开发不用一个个去问用户：“你们有没有使用到Class1这个类”，等到所有用户都确认了之后才开始动手，本来可能是几行代码的工作量，但是这个询问的过程都得好几天，谁用谁知道。对于用户来说也不需要关注子系统类是否修改，如果功能不变的话还是使用之前的接口方法，如果功能需要改变且现有的接口方法无法满足那只有提需求添加接口方法了。&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;代码示例&lt;/h4&gt;
&lt;p&gt;例子：这里有一台计算机，开机需要CPU、硬盘、内存的配合，但是用户不需要知道CPU是否运行、硬盘是否被读取、内存是否被加载，计算机应用外观模式定义了一个开机键，用户只需要按了开机键就可以完成开机了。&lt;/p&gt;
&lt;p&gt;CPU类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CPU {
    public void freeze() {
        System.out.println(&quot;CPU执行freeze操作&quot;);
    }
    public void jump() {
        System.out.println(&quot;CPU执行jump操作&quot;);
    }
    public void execute() {
        System.out.println(&quot;CPU正常运行&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;硬盘类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HardDrive {
    public void read() {
        System.out.println(&quot;读取硬盘&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内存类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Memory {
    public void load() {
        System.out.println(&quot;将硬盘中读取到信息加载到运行内存&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;外观类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ComputerFacade {
    private CPU processor;
    private Memory ram;
    private HardDrive hd;

    public ComputerFacade() {
        this.processor = new CPU();
        this.ram = new Memory();
        this.hd = new HardDrive();
    }

    public void start() {
        processor.freeze();
        hd.read();
        ram.load();
        processor.jump();
        processor.execute();
        System.out.println(&quot;计算机正常启动完毕&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;start方法就是相当于开机键。&lt;/p&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User {
    public static void main(String[] args) {
        ComputerFacade computerFacade = new ComputerFacade();
        computerFacade.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/facade-example-result.png&quot; alt=&quot;测试结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果显示只需要调用外观类的start方法就可以启动计算机。&lt;/p&gt;
&lt;h4 id=&quot;模式扩展&quot;&gt;模式扩展&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一个系统可以有多个外观类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不要试图通过外观类为子系统增加新行为&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个装饰者模式所做的事情，为某个对象动态增加新的行为。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;外观模式与迪米特法则&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;外观模式是迪米特法则的践行者，遵循着让客户端知道最少的原则，实现客户端和子系统类的解耦&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;抽象外观类的引入&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;外观模式不符合“开闭模式”，当子系统类增加或者减少的时候，都需要修改外观类中的方法。引入抽象外观类在一定程度上解决了这个问题，但是维护抽象外观类及其子类也需要一定的成本。&lt;/p&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;p&gt;1、解耦。降低客户端与子系统类耦合性，增加和删除子系统类只需要修改外观类即可。&lt;/p&gt;
&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;p&gt;1、不符合开闭原则。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;外观模式适用于客户端与子系统的多个接口直接关联，关系错综复杂。子系统增加外观类，提供一个简单的接口给客户端调用，降低客户端与子系统的耦合性，有利于子系统更新或迁移。&lt;/p&gt;
&lt;h4 id=&quot;完&quot;&gt;完&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;2019年5月6日23:57:41&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 16:03:00 +0000</pubDate>
<dc:creator>mingmingcome</dc:creator>
<og:description>`2019年3月27日09:03:40` 外观模式（ facade pattern） 定义 纵然身体里每个细胞都复杂得仿佛是一个宇宙，但是给人第一印象的你帅气的脸。 外观模式，为子系统中的一组接口提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mingmingcome/p/10823092.html</dc:identifier>
</item>
<item>
<title>【设计模式+原型理解】第四章：函数的三种角色+原型链终结版 - 彭胜光</title>
<link>http://www.cnblogs.com/pengshengguang/p/10817033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengshengguang/p/10817033.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、函数的三种角色&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　1）作为普通函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）作为对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）作为类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ps：可以同时存在，之间没有任何冲突&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、怎么理解函数的三种角色&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这三种角色可以同时存在，没有任何冲突，举个例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;// 这三种角色是没有冲突的，看下面的例子
function Fn1() { // 这时候，Fn就是一个普通函数，形参赋值，预解释，代码执行
    var num = 500
    this.x = 100;
}
Fn.prototype.getX = function () {
    console.log(this.x);
};
Fn.aaa = 1000; // 这时候，Fn就是作为一个对象（有私有属性，有方法，还有原型）
var f = new Fn; // 这时候，Fn就是一个类，可以通过new创建对象 ，this指向的是f！！

console.log(f.num); //-&amp;gt;undefined   这个时候，Fn就是一个类，num是Fn作为普通函数才有用，num跟类完全没关系
console.log(f.aaa); //-&amp;gt;undefined   这个时候，Fn就是一个类，aaa是Fn作为对象才有用，aaa跟类完全没有关系

var res = Fn();
console.log(res); //-&amp;gt;undefined   这个时候，Fn就是一个普通函数，函数里没返回值，this指向的是window！！！！！！！！
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面的例子完美的解释了，函数三种角色真的没有任何联系。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　感觉函数真的是模拟了真实人生，就好比我带着我爸妈，带着我闺女，我作为人类、作为父亲、作为儿子，没有任何冲突，该干嘛干嘛！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面的代码，可以打印一下Fn函数里面到底有什么东西。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　输出信息如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254758/201905/1254758-20190506224436934-1916715435.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看到，Fn作为对象，有自己的属性值（arguments、caller、length、name、prototype、__proto__）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、深入理解原型 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　其实，上面的一二两点，都是总结，&lt;span&gt;你有想过，为什么函数会存在三种角色吗？&lt;/span&gt;其实，想要理解函数的三种角色，就必须深入探索一个完整的原型链的工作方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先看一个例子，帮助我们理解函数的三种角色&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;function Fn() {
    this.x = 100;
}
Fn.prototype.getX = function () {
    console.log(this.x);
};
var f = new Fn;
console.log(f instanceof Fn); //-&amp;gt;true
console.log(f instanceof Object); //-&amp;gt;true
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　　简单说明一下上面的代码，使用的原型继承的方式，首先声明定义一个Fn函数类，然后再Fn函数类的原型上添加一个公有的方法getX，之后，使用new关键字创建一个Fn函数类的一个实例，从而f继承了Fn的私有+公有的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　很明显，f instanceof Fn 是true的，因为f是通过new Fn来创建出来的，但是&lt;span&gt;为什么f instanceof Object 也是为true呢？&lt;/span&gt;要回答这个问题，得理解下面的话。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;span&gt;1）Function是浏览器内置的函数类（Function也是对象），所有的函数都是Function类的一个实例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）Object是浏览器内置的对象类，所有对象都是Object类的一个实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）所有实例，都是对象数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4）根据1、2两点，可以知道，上面定义的Fn函数，是Function类的一个实例，那么Fn函数其实就是一个实例，根据第3点，Fn函数就是一个对象数据类型；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      同理，因为Object对象类是一个类，类其实也是就函数，所以Object对象类是Function类的一个实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5）根据第3、4点，可以知道，内置类Function、内置类Object、函数Fn它们都是对象，那么是对象会拥有__proto__属性，所以它们都拥有__proto__属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、第三点中代码的完整原型链&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254758/201905/1254758-20190506001153281-1211133805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;　　值得注意的是，上图中，&lt;strong&gt;Function.prototype&lt;/strong&gt;其实并不是对象，是函数数据类型，非常坑爹！其实它叫做&lt;strong&gt;anonymous（匿名函数）&lt;/strong&gt;，没有实际意义的一个函数，但是操作起来跟对象一模一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 打印Function.prototype，样子如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254758/201905/1254758-20190506230748872-412406667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　&lt;span&gt;　函数在整个JS中是最复杂也是最重要的知识，一个函数存在多面性，而且相互不冲突：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;-&amp;gt; “函数”：&lt;/strong&gt;它本身是一个函数，执行的时候形成私有作用域（闭包），形参赋值、预解释、代码执行、执行完后栈内存销毁/不销毁；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;-&amp;gt; “类”： &lt;/strong&gt;   它有自己的实例，也有一个叫做prototoype属性是自己的原型；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;-&amp;gt; “普通对象”：&lt;/strong&gt;和var obj = {} 中的obj一样，就是一个普通的对象，它作为对象有自己的私有属性，也可以通过__proto__找到Function.ptototype。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 15:11:00 +0000</pubDate>
<dc:creator>彭胜光</dc:creator>
<og:description>一、函数的三种角色 1）作为普通函数 2）作为对象 3）作为类 ps：可以同时存在，之间没有任何冲突 二、怎么理解函数的三种角色 这三种角色可以同时存在，没有任何冲突，举个例子 上面的例子完美的解释了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pengshengguang/p/10817033.html</dc:identifier>
</item>
<item>
<title>初识Kotlin之函数 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/10822831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/10822831.html</guid>
<description>&lt;p&gt;本章通过介绍Kotlin的基本函数，默认参数函数，参数不定长函数，尾递归函数，高阶函数，Lamdba表达式。来对Kotlin函数做进一步了解。将上一篇的Kotlin变量的知识得以运用。&lt;a href=&quot;https://www.cnblogs.com/itdragon/p/10780707.html&quot;&gt;Kotlin变量&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;kotlin函数简介&quot;&gt;Kotlin函数简介&lt;/h3&gt;
&lt;p&gt;Kotlin中是通过关键字fun声明函数。和变量一样，返回值类型放在名称后面，并用&quot;:&quot;冒号分开。Kotlin函数默认修饰符public，且可以在文件顶层声明。其格式如下&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun 函数名(变量): 返回值类型  {
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;kotlin常见函数&quot;&gt;Kotlin常见函数&lt;/h3&gt;
&lt;h4 id=&quot;基础函数&quot;&gt;基础函数&lt;/h4&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun getValue(v: Int): Int {
    return v
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当函数不需要返回任何值时，可以将返回值类型定义成Unit，也可以不显式返回。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun setValue(v: Int) {
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;参数默认值函数&quot;&gt;参数默认值函数&lt;/h4&gt;
&lt;p&gt;函数的参数可以有默认值，当函数调用者不给默认参数赋值时，函数体就使用参数的默认值。这样可以减少很多方法重载的代码量。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun setValue(x: Int, y: Int = 10): Int {
    retunr x + y
}
setValue(10) -----&amp;gt; 20
setValue(10, 20) -----&amp;gt; 30&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数默认值函数固然好用。但是由于每个人的编程习惯和编程水平的不同。项目中出现下面的代码的概率还不低。通过程序打印的结果可以看出，输出的结果并不是我们预期的21.2，而且10。说明编译器是调用的是第一个函数。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;) {
    println(setValue(10)) -----&amp;gt; 10
}
fun setValue(x: Int) = x
fun setValue(x: Int, y: Int = 10, z: Double = 1.2) = x + y + z&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还一个语法问题，子类继承父类的参数默认值函数后，是不允许重写的函数为其参数指定默认值。好在这种情况编译器会提示错误。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;open class FatherClass {
    open fun setValue(x: Int, y: Int = 10, z: Double = 1.2) = x + y + z
}

class SunClass: FatherClass() {
//  An overriding function is not allowed to specify default values for its paramete
    override fun setValue(x: Int, y: Int, z: Double) = x + y + z
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;单表达式函数&quot;&gt;单表达式函数&lt;/h4&gt;
&lt;p&gt;若函数体只是单个表达式时，可以省略花括号并用&quot;=&quot; 指定代码体。了解一下即可，至少遇到了不要惊讶。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun setValue(x: Int, y: Int) = x + y&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;不定长参数函数&quot;&gt;不定长参数函数&lt;/h4&gt;
&lt;p&gt;有很多场景函数的变量的个数是不确定。Java是通过三个点&quot;...&quot;表示不定个数的参数。而Kotlin需要通过关键字vararg定义参数，表示函数的参数个数不确定。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun mathPlus(vararg arguments: Any): Any {
    var result: BigDecimal = BigDecimal.ZERO
    arguments.map {
        result = result.plus(BigDecimal(it.toString()))
    }
    return result
}
mathPlus(1,2,3,4.5) ------&amp;gt; 10.5&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;尾递归函数&quot;&gt;尾递归函数&lt;/h4&gt;
&lt;p&gt;Kotlin支持尾递归的编程风格。&lt;strong&gt;允许一些算法可以通过循环而不是递归解决问题，避免堆栈溢出导致的系统不稳定&lt;/strong&gt;。Kotlin还提供了尾递归优化的关键字tailrec。但要符合 tailrec 修饰符的条件，需要函数必须将其自身调用作为它执行的最后一个操作。我们用求阶乘的代码演示尾递归。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;// 尾递归，可以保证堆栈不溢出，但是还要考虑数据类型的取值范围
tailrec fun fibolaAlgorithm(num: Int, result: Int): Int {
    println(&quot;剩余递归次数 : $num \t 计算结果: $result&quot;)
    return if (num == 0) {
        1
    } else {
        fibolaAlgorithm(num - 1, result + num)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;高阶函数&quot;&gt;高阶函数&lt;/h4&gt;
&lt;p&gt;高阶函数是Kotlin的一大亮点，高阶函数是可以将函数用作参数或返回值的函数。下面代码中，forEach是函数，println也是一个方法，通过双冒号将函数作为一个参数传递。这种用法在Kotlin中非常常见。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;// 函数作为参数
fun paramFun() {
    val list = listOf(1, 2)
    list.forEach(::println)
}
// 函数作为返回值
fun returnFun(): (Int, Int) -&amp;gt; Int {
    return { j, i -&amp;gt; j + i }
}
println(returnFun().invoke(1,2))&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;闭包函数&quot;&gt;闭包函数&lt;/h4&gt;
&lt;p&gt;闭包就是能够读取其他函数内部变量的函数。当我们的程序希望读取到函数的内部变量，或者希望被访问的变量保存在内存中。就需要用到闭包。这下这段代码算是比较典型的闭包函数。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun closureMethod(i: Int): () -&amp;gt; Int {
    var memoryValue = 1
    return fun(): Int {
        return i + memoryValue++
    }
}
val closure = closureMethod(0)
println(closure()) ------&amp;gt; 1
println(closure()) ------&amp;gt; 2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;kotlin-lamdba表达式&quot;&gt;Kotlin Lamdba表达式&lt;/h3&gt;
&lt;p&gt;Lambda表达式的本质其实是匿名函数，底层还是通过匿名函数来实现。Lambda的出现确实是减少了代码量，同时代码变得更加简洁明了。&lt;/p&gt;
&lt;p&gt;Lamdba语法结构&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;val/var 变量名: (参数类型，参数类型，...) -&amp;gt; 返回值类型 = { 参数1，参数2，... -&amp;gt; 代码块 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个基础上，Kotlin还支持智能推导模式，让代码更简单，让读者更摸不清头脑，新手看这种代码一定觉得怪怪的。注意：&lt;strong&gt;实参并没有用括号括起来，而是通过箭头将实参和代码块区分开&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;//  无参: val/var 变量名: () -&amp;gt; 返回值类型 = { 代码块 },
val a:() -&amp;gt; Int = { 10 }

//  有参: val/var 变量名: (变量类型...) -&amp;gt; 返回值类型 = { 参数1,参数2, ... -&amp;gt; 操作参数的代码 }
val b: (Int, Int) -&amp;gt; Int = {x, y -&amp;gt; x + y }

//  推导: val/var 变量名 = { 参数1: 类型, 参数2: 类型, ... -&amp;gt; 操作参数的代码 }
val c = { x: Int, y: Int -&amp;gt; x + y }
println(c(1,2)) ------&amp;gt; 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Lamdba和集合可以擦出爱情的火花，下一章介绍Kotlin集合函数API（filter，map，groupBy，maxBy...）时，你就知道Lamdba有多么强大了。&lt;/p&gt;
&lt;h3 id=&quot;kotlin-扩展函数&quot;&gt;Kotlin 扩展函数&lt;/h3&gt;
&lt;p&gt;扩展函数指的是在已有类中添加新的方法，且不会对原类做修改。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun receiverType.funName(params): returnType{
    /*代码块*/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;receiverType：扩展函数的接收者，也就是函数扩展的对象&lt;/li&gt;
&lt;li&gt;returnType: 扩展函数的返回值类型&lt;/li&gt;
&lt;li&gt;funName：扩展函数的名称&lt;/li&gt;
&lt;li&gt;params：扩展函数的参数，可以为NULL&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun Int.extensionFun(i: Int): Int {
    return this + i
}
println(10.extensionFun(20)) ------&amp;gt; 30&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为扩展函数是可以让程序员自己添加的，出现函数重名的情况非常常见。所以，如果遇到重名的情况。可以在导入包时，通过 as 关键字进行改名。注意：&lt;strong&gt;改名后不能再用原来的函数名&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;import com.kotlin.demo.extensionFun as aliasITDragon
fun main(args: Array&amp;lt;String&amp;gt;) {
    println(1.aliasITDragon(2)) ------&amp;gt; 3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果扩展函数只有一个变量，我们可以使用中缀符号（ infix 关键字）修饰函数，位于fun关键字之前。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;infix fun Int.extensionFun(i: Int): Int {
    return this + i
}
println(10 extensionFun 20) ------&amp;gt; 30
println(10.extensionFun(20)) ------&amp;gt; 30&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章到这里就介绍了，Kotlin提供的扩展函数，Lamdba表达式提高了我们的开发效率。值得我们去深入学习。&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 15:06:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<og:description>本章通过介绍Kotlin的基本函数，默认参数函数，参数不定长函数，尾递归函数，高阶函数，Lamdba表达式。来对Kotlin函数做进一步了解。将上一篇的Kotlin变量的知识得以运用。 'Kotlin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/10822831.html</dc:identifier>
</item>
<item>
<title>用python在前程无忧高效投递简历 - 神一样了</title>
<link>http://www.cnblogs.com/shenyiyangle/p/10822688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenyiyangle/p/10822688.html</guid>
<description>&lt;h3&gt;&lt;span&gt; 在前程无忧上投递简历发现有竞争力分析，免费能看到匹配度评价和综合竞争力分数，可以做投递参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506210853005-73768646.png&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;计算方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506210607912-555924299.png&quot; alt=&quot;&quot; width=&quot;799&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;综合竞争力得分应该越高越好，匹配度评语也应该评价越高越好&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;抓取所有职位关键字搜索结果并获取综合竞争力得分和匹配度评语，最后筛选得分评语自动投递合适的简历&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;登陆获取cookie&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.chrome.options &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Options
chrome_options &lt;/span&gt;=&lt;span&gt; Options()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; chrome_options.add_argument('--headless')&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sleep
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json&lt;/span&gt;&lt;span&gt;

driver &lt;/span&gt;= webdriver.Chrome(chrome_options=chrome_options,executable_path = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\python\chromedriver.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
headers&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
driver.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://search.51job.com/list/020000,000000,0000,00,9,99,%2520,2,1.html?lang=c&amp;amp;stype=&amp;amp;postchannel=0000&amp;amp;workyear=99&amp;amp;cotype=99&amp;amp;degreefrom=99&amp;amp;jobterm=99&amp;amp;companysize=99&amp;amp;providesalary=99&amp;amp;lonlat=0%2C0&amp;amp;radius=-1&amp;amp;ord_field=0&amp;amp;confirmdate=9&amp;amp;fromType=&amp;amp;dibiaoid=0&amp;amp;address=&amp;amp;line=&amp;amp;specialarea=00&amp;amp;from=&amp;amp;welfare=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;webdriver需要在相应域名写入cookie，所以转到职位搜索页面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506221459240-1997850031.png&quot; alt=&quot;&quot; width=&quot;1078&quot; height=&quot;73&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
def get_cookie():&lt;br/&gt;driver.get(&quot;https://login.51job.com/login.php?loginway=1&amp;amp;lang=c&amp;amp;url=&quot;)&lt;br/&gt;sleep(2)&lt;br/&gt;phone=input(&quot;输入手机号：&quot;)&lt;br/&gt;driver.find_element_by_id(&quot;loginname&quot;).send_keys(phone)&lt;br/&gt;driver.find_element_by_id(&quot;btn7&quot;).click()&lt;br/&gt;sleep(1)&lt;br/&gt;code=input(&quot;输入短信：&quot;)&lt;br/&gt;driver.find_element_by_id(&quot;phonecode&quot;).send_keys(code)&lt;br/&gt;driver.find_element_by_id(&quot;login_btn&quot;).click()&lt;br/&gt;sleep(2)&lt;br/&gt;cookies = driver.get_cookies()&lt;br/&gt;with open(&quot;cookie.json&quot;, &quot;w&quot;)as f:&lt;br/&gt;f.write(json.dumps(cookies))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;检查cookie文件是否存在，如果不存在执行get_cookie把cookie写入文件，在登陆的时候最好不用无头模式，偶尔有滑动验证码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;前程无忧手机短信一天只能发送三条，保存cookie下次登陆用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_job():
    driver.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://search.51job.com/list/020000,000000,0000,00,9,99,%2520,2,1.html?lang=c&amp;amp;stype=&amp;amp;postchannel=0000&amp;amp;workyear=99&amp;amp;cotype=99&amp;amp;degreefrom=99&amp;amp;jobterm=99&amp;amp;companysize=99&amp;amp;providesalary=99&amp;amp;lonlat=0%2C0&amp;amp;radius=-1&amp;amp;ord_field=0&amp;amp;confirmdate=9&amp;amp;fromType=&amp;amp;dibiaoid=0&amp;amp;address=&amp;amp;line=&amp;amp;specialarea=00&amp;amp;from=&amp;amp;welfare=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    sleep(&lt;/span&gt;2&lt;span&gt;)
    job&lt;/span&gt;=input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入职位：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kwdselectid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).send_keys(job)
    driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//button[@class=&quot;p_but&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
    url&lt;/span&gt;=&lt;span&gt;driver.current_url
    page&lt;/span&gt;=&lt;span&gt;driver.page_source
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; url,page
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在职位搜索获取职位搜索结果，需要返回页面源码和地址&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506221400095-1485844094.png&quot; alt=&quot;&quot; width=&quot;1047&quot; height=&quot;810&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506221857700-1673005263.png&quot; alt=&quot;&quot; width=&quot;779&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506221934312-343877205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;分析页码结构html前的是页码，全部页码数量通过共XX页得到&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_pages(url,page):
    tree&lt;/span&gt;=&lt;span&gt;etree.HTML(page)
    href&lt;/span&gt;=&lt;span&gt;[]
    x &lt;/span&gt;= tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//span[@class=&quot;td&quot;]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
    total_page&lt;/span&gt;=int(re.findall(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(\d+)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, x)[0])
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,total_page+1&lt;span&gt;):
        href.append(re.sub(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\d.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{i}.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, url))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; href
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;获取全部页码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506222302838-942052479.png&quot; alt=&quot;&quot; width=&quot;1012&quot; height=&quot;611&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_job_code(url):
    headers&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
    r&lt;/span&gt;=session.get(url,headers=&lt;span&gt;headers)
    tree&lt;/span&gt;=&lt;span&gt;etree.HTML(r.text)
    divs&lt;/span&gt;=tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;el&quot;]/p/span/a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    job&lt;/span&gt;=&lt;span&gt;str(divs)
    job_id&lt;/span&gt;=re.findall(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\/(\d+).html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,job)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; job_id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;获取职位id&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506222548999-634318077.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;126&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修改id请求网址到竞争力分析页面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_info(job_id):
    href&lt;/span&gt;=f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://i.51job.com/userset/bounce_window_redirect.php?jobid={job_id}&amp;amp;redirect_type=2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    r&lt;/span&gt;=session.get(href,headers=&lt;span&gt;headers)
    r.encoding&lt;/span&gt;=&lt;span&gt;r.apparent_encoding
    tree&lt;/span&gt;=&lt;span&gt;etree.HTML(r.text)
    pingjia&lt;/span&gt;=tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;warn w1&quot;]//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0].strip()
    gongsi&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;lf&quot;]//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; i.strip():
            gongsi.append(i.strip())
    fenshu&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//ul[@class=&quot;rt&quot;]//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; i.strip():
            fenshu.append(i.strip())
    url&lt;/span&gt;=f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://jobs.51job.com/shanghai/{job_id}.html?s=03&amp;amp;t=0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;公司&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:gongsi[1],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;职位&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:gongsi[0],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;匹配度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:pingjia,fenshu[3]:fenshu[2],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;链接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:url,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:job_id}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506222732603-595205251.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;抓取竞争力分析页面，返回一个字典&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;主程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;if not os.path.exists(&quot;cookie.json&quot;):&lt;br/&gt;　　get_cookie()&lt;br/&gt;f=open(&quot;cookie.json&quot;,&quot;r&quot;)&lt;br/&gt;cookies=json.loads(f.read())&lt;br/&gt;f.close()&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;检查cookie文件载入cookie，不存在执行get_cookie()把cookie保存到文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
session =&lt;span&gt; requests.Session()
　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; cookie &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cookies: 
　　driver.add_cookie(cookie)
session.cookies.set(cookie[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],cookie[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
url, page &lt;/span&gt;=&lt;span&gt; get_job()
driver.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在session和webdriver写入cookie登陆&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;获取第一页和url后webdriver就可以关掉了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
code=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; get_pages(url,page):
    code&lt;/span&gt;=code+get_job_code(i)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;获取的职位id添加到列表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymongo
client&lt;/span&gt;=pymongo.MongoClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,27017&lt;span&gt;)
db&lt;/span&gt;=client[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job_he&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
job_info&lt;/span&gt;=db[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job_info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; code:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; job_info.find_one({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:i}):
            info&lt;/span&gt;=&lt;span&gt;get_info(i)
            sleep(&lt;/span&gt;1&lt;span&gt;)&lt;/span&gt;&lt;span&gt;
            job_info.insert_one(info)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(info，&quot;插入成功&quot;)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　except&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(code)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;龟速爬取，用MongDB保存结果，职位id作为索引id，插入之前检查id是否存在简单去重减少访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506220226674-2133828681.png&quot; alt=&quot;&quot; width=&quot;880&quot; height=&quot;505&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;吃完饭已经抓到8000个职位了，筛选找到127个匹配度好的，开始批量投递&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506220438044-563534086.png&quot; alt=&quot;&quot; width=&quot;663&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;登陆状态点击申请职位，用wevdriver做&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; job_info.find({&quot;匹配度&quot;:{$regex:&quot;排名很好&quot;},&quot;综合竞争力得分&quot;:{$gte:&quot;80&quot;}}&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        driver.get(i)
        driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app_ck&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;用cookie登陆简单for循环投递，在Mongodb里查表，正则筛选匹配度和竞争力得分获取所有匹配结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1581786/201905/1581786-20190506223200271-36102282.png&quot; alt=&quot;&quot; width=&quot;269&quot; height=&quot;76&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;投递成功&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.chrome.options &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Options
chrome_options &lt;/span&gt;=&lt;span&gt; Options()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; chrome_options.add_argument('--headless')&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sleep
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json&lt;/span&gt;&lt;span&gt;

driver &lt;/span&gt;= webdriver.Chrome(chrome_options=chrome_options,executable_path = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\python\chromedriver.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
headers&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
driver.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://search.51job.com/list/020000,000000,0000,00,9,99,%2520,2,1.html?lang=c&amp;amp;stype=&amp;amp;postchannel=0000&amp;amp;workyear=99&amp;amp;cotype=99&amp;amp;degreefrom=99&amp;amp;jobterm=99&amp;amp;companysize=99&amp;amp;providesalary=99&amp;amp;lonlat=0%2C0&amp;amp;radius=-1&amp;amp;ord_field=0&amp;amp;confirmdate=9&amp;amp;fromType=&amp;amp;dibiaoid=0&amp;amp;address=&amp;amp;line=&amp;amp;specialarea=00&amp;amp;from=&amp;amp;welfare=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_cookie():
    driver.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://login.51job.com/login.php?loginway=1&amp;amp;lang=c&amp;amp;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    sleep(&lt;/span&gt;2&lt;span&gt;)
    phone&lt;/span&gt;=input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入手机号：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loginname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).send_keys(phone)
    driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
    sleep(&lt;/span&gt;1&lt;span&gt;)
    code&lt;/span&gt;=input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入短信：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;phonecode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).send_keys(code)
    driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login_btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
    sleep(&lt;/span&gt;2&lt;span&gt;)
    cookies &lt;/span&gt;=&lt;span&gt; driver.get_cookies()
    with open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cookie.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)as f:
        f.write(json.dumps(cookies))

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_job():
    driver.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://search.51job.com/list/020000,000000,0000,00,9,99,%2520,2,1.html?lang=c&amp;amp;stype=&amp;amp;postchannel=0000&amp;amp;workyear=99&amp;amp;cotype=99&amp;amp;degreefrom=99&amp;amp;jobterm=99&amp;amp;companysize=99&amp;amp;providesalary=99&amp;amp;lonlat=0%2C0&amp;amp;radius=-1&amp;amp;ord_field=0&amp;amp;confirmdate=9&amp;amp;fromType=&amp;amp;dibiaoid=0&amp;amp;address=&amp;amp;line=&amp;amp;specialarea=00&amp;amp;from=&amp;amp;welfare=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    sleep(&lt;/span&gt;2&lt;span&gt;)
    job&lt;/span&gt;=input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入职位：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kwdselectid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).send_keys(job)
    driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//button[@class=&quot;p_but&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
    url&lt;/span&gt;=&lt;span&gt;driver.current_url
    page&lt;/span&gt;=&lt;span&gt;driver.page_source
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; url,page

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_driver():
    driver.close()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_pages(url,page):
    tree&lt;/span&gt;=&lt;span&gt;etree.HTML(page)
    href&lt;/span&gt;=&lt;span&gt;[]
    x &lt;/span&gt;= tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//span[@class=&quot;td&quot;]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
    total_page&lt;/span&gt;=int(re.findall(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(\d+)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, x)[0])
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,total_page+1&lt;span&gt;):
        href.append(re.sub(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\d.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{i}.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, url))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; href

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_job_code(url):
    headers&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
    r&lt;/span&gt;=session.get(url,headers=&lt;span&gt;headers)
    tree&lt;/span&gt;=&lt;span&gt;etree.HTML(r.text)
    divs&lt;/span&gt;=tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;el&quot;]/p/span/a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    job&lt;/span&gt;=&lt;span&gt;str(divs)
    job_id&lt;/span&gt;=re.findall(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\/(\d+).html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,job)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; job_id

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_info(job_id):
    href&lt;/span&gt;=f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://i.51job.com/userset/bounce_window_redirect.php?jobid={job_id}&amp;amp;redirect_type=2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    r&lt;/span&gt;=session.get(href,headers=&lt;span&gt;headers)
    r.encoding&lt;/span&gt;=&lt;span&gt;r.apparent_encoding
    tree&lt;/span&gt;=&lt;span&gt;etree.HTML(r.text)
    pingjia&lt;/span&gt;=tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;warn w1&quot;]//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0].strip()
    gongsi&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;lf&quot;]//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; i.strip():
            gongsi.append(i.strip())
    fenshu&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//ul[@class=&quot;rt&quot;]//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; i.strip():
            fenshu.append(i.strip())
    url&lt;/span&gt;=f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://jobs.51job.com/shanghai/{job_id}.html?s=03&amp;amp;t=0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;公司&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:gongsi[1],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;职位&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:gongsi[0],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;匹配度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:pingjia,fenshu[3]:fenshu[2],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;链接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:url,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:job_id}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; os.path.exists(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cookie.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    get_cookie()
f&lt;/span&gt;=open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cookie.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
cookies&lt;/span&gt;=&lt;span&gt;json.loads(f.read())
f.close()
session &lt;/span&gt;=&lt;span&gt; requests.Session()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; cookie &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cookies:
    driver.add_cookie(cookie)
    session.cookies.set(cookie[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], cookie[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
url, page &lt;/span&gt;=&lt;span&gt; get_job()
driver.close()
code&lt;/span&gt;=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; get_pages(url,page):
    code&lt;/span&gt;=code+&lt;span&gt;get_job_code(i)
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymongo
client&lt;/span&gt;=pymongo.MongoClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,27017&lt;span&gt;)
db&lt;/span&gt;=client[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job_he&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
job_info&lt;/span&gt;=db[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job_info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; code:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; job_info.find_one({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:i}):
            info&lt;/span&gt;=&lt;span&gt;get_info(i)
            sleep(&lt;/span&gt;1&lt;span&gt;)&lt;/span&gt;&lt;span&gt;
            job_info.insert_one(info)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(info)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;插入成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(code)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 06 May 2019 14:41:00 +0000</pubDate>
<dc:creator>神一样了</dc:creator>
<og:description>高效投递简历</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shenyiyangle/p/10822688.html</dc:identifier>
</item>
<item>
<title>深度解密Go语言之反射 - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/10822655.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/10822655.html</guid>
<description>&lt;p&gt;反射和 Interface 息息相关，而 Interface 是我们&lt;a href=&quot;https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA&quot;&gt;上一篇文章&lt;/a&gt;的内容。在开始正文前，和大家说点题外话。&lt;/p&gt;
&lt;p&gt;上一篇关于 Interface 的文章发出后，获得了很多的关注和阅读。比如，登上了 GoCN 的每日新闻第一条：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/57132448-3c13c880-6dd2-11e9-91b0-4d6b846a605e.png&quot; alt=&quot;gocn&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能是编辑者觉得这篇文章称不上“深度解密”，把标题给小小地改动了下，哈哈~~&lt;/p&gt;
&lt;p&gt;在博客园登上了 48 小时阅读排行榜：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/57132468-4a61e480-6dd2-11e9-953c-a981ed048dae.png&quot; alt=&quot;博客园&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在开发者头条 APP （类似于今日头条，不过内容都是技术相关的，还挺有意思的）上收获了 150 收藏，并被推荐到首页最显眼的 banner 位置，阅读量达到了 1w 多，只是不知道这个数字是否是真实的，有点难以相信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/57132395-0e2e8400-6dd2-11e9-88e7-f71605c3bb66.png&quot; alt=&quot;开发者头条&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很多同学在后台向我反映文章太长了，不利于阅读，建议拆分一下。我非常理解，读屏时代，大家需要快速地读完全文，拿到收益。而码农桃花源的文章都非常长，读者很难在短时间内读完，并且获得相应的收益。&lt;/p&gt;
&lt;p&gt;首先非常感谢大家的建议！其实我的想法是这样的：大家都在说，现在是一个信息严重过载的时代，信息多得看不完，不免产生很多焦虑。但是，我想说，优质的信息真有那么多吗？在我看来，文章的水平都是参差不齐，很多毫无内容和价值，大家把时间浪费在这些信息上面是很不值得的。因为你读了这些文章，就没有了读其他好的文章的精力。&lt;/p&gt;
&lt;p&gt;所以，码农桃花源想做一个优质信息源，提供优质的内容。每一篇文章都是有深度，有内容，有收获。一篇文章，我一般得花费 2 周左右，算是半月更，和那些日更的没法比。当然，只是在数量上没法比。而这个时代，最不缺的就是数量。&lt;/p&gt;
&lt;p&gt;另外，文章长也算是我的一个特色。我完全可以拆分成上、中、下等等，但我希望一次性交付给我的读者所有有价值的内容。这样，你可以集中一个小时或是更长时间，精读完一篇文章。&lt;/p&gt;
&lt;p&gt;闲话结束，今天要讲的内容是反射，进入正题。&lt;/p&gt;

&lt;p&gt;直接看维基百科上的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那我就要问个问题了：不用反射就不能在运行时访问、检测和修改它本身的状态和行为吗？&lt;/p&gt;
&lt;p&gt;问题的回答，其实要首先理解什么叫访问、检测和修改它本身状态或行为，它的本质是什么？&lt;/p&gt;
&lt;p&gt;实际上，它的本质是程序在运行期探知对象的类型信息和内存结构，不用反射能行吗？可以的！使用汇编语言，直接和内层打交道，什么信息不能获取？但是，当编程迁移到高级语言上来之后，就不行了！就只能通过&lt;code&gt;反射&lt;/code&gt;来达到此项技能。&lt;/p&gt;
&lt;p&gt;不同语言的反射模型不尽相同，有些语言还不支持反射。《Go 语言圣经》中是这样定义反射的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要反射的 2 个常见场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;有时你需要编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。&lt;/li&gt;
&lt;li&gt;有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在讲反射的原理以及如何用之前，还是说几点不使用反射的理由：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。&lt;/li&gt;
&lt;li&gt;Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。&lt;/li&gt;
&lt;li&gt;反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上一篇文章讲到了 &lt;code&gt;interface&lt;/code&gt;，它是 Go 语言实现抽象的一个非常强大的工具。当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的，反射建立在类型的基础上。&lt;/p&gt;
&lt;p&gt;Go 语言在 reflect 包里定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。&lt;/p&gt;
&lt;h2 id=&quot;types-和-interface&quot;&gt;types 和 interface&lt;/h2&gt;
&lt;p&gt;Go 语言中，每个变量都有一个静态类型，在编译阶段就确定了的，比如 &lt;code&gt;int, float64, []int&lt;/code&gt; 等等。注意，这个类型是声明时候的类型，不是底层数据类型。&lt;/p&gt;
&lt;p&gt;Go 官方博客里就举了一个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type MyInt int

var i int
var j MyInt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尽管 i，j 的底层类型都是 int，但我们知道，他们是不同的静态类型，除非进行类型转换，否则，i 和 j 不能同时出现在等号两侧。j 的静态类型就是 &lt;code&gt;MyInt&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;反射主要与 interface{} 类型相关。前面一篇关于 interface 相关的文章已经探讨过 interface 的底层结构，这里再来复习一下。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type iface struct {
    tab  *itab
    data unsafe.Pointer
}

type itab struct {
    inter  *interfacetype
    _type  *_type
    link   *itab
    hash   uint32
    bad    bool
    inhash bool
    unused [2]byte
    fun    [1]uintptr
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;itab&lt;/code&gt; 由具体类型 &lt;code&gt;_type&lt;/code&gt; 以及 &lt;code&gt;interfacetype&lt;/code&gt; 组成。&lt;code&gt;_type&lt;/code&gt; 表示具体类型，而 &lt;code&gt;interfacetype&lt;/code&gt; 则表示具体类型实现的接口类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/56564826-82527600-65e1-11e9-956d-d98a212bc863.png&quot; alt=&quot;iface 结构体全景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上，iface 描述的是非空接口，它包含方法；与之相对的是 &lt;code&gt;eface&lt;/code&gt;，描述的是空接口，不包含任何方法，Go 语言里有的类型都 &lt;code&gt;“实现了”&lt;/code&gt; 空接口。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type eface struct {
    _type *_type
    data  unsafe.Pointer
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比 &lt;code&gt;iface&lt;/code&gt;，&lt;code&gt;eface&lt;/code&gt; 就比较简单了。只维护了一个 &lt;code&gt;_type&lt;/code&gt; 字段，表示空接口所承载的具体的实体类型。&lt;code&gt;data&lt;/code&gt; 描述了具体的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/56565105-318f4d00-65e2-11e9-96bd-4b2e192791dc.png&quot; alt=&quot;eface 结构体全景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是用 Go 官方关于反射的博客里的例子，当然，我会用图形来详细解释，结合两者来看会更清楚。顺便提一下，搞技术的不要害怕英文资料，要想成为技术专家，读英文原始资料是技术提高的一条必经之路。&lt;/p&gt;
&lt;p&gt;先明确一点：接口变量可以存储任何实现了接口定义的所有方法的变量。&lt;/p&gt;
&lt;p&gt;Go 语言中最常见的就是 &lt;code&gt;Reader&lt;/code&gt; 和 &lt;code&gt;Writer&lt;/code&gt; 接口：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，就是接口之间的各种转换和赋值了：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var r io.Reader
tty, err := os.OpenFile(&quot;/Users/qcrao/Desktop/test&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}
r = tty&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先声明 &lt;code&gt;r&lt;/code&gt; 的类型是 &lt;code&gt;io.Reader&lt;/code&gt;，注意，这是 &lt;code&gt;r&lt;/code&gt; 的静态类型，此时它的动态类型为 &lt;code&gt;nil&lt;/code&gt;，并且它的动态值也是 &lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;之后，&lt;code&gt;r = tty&lt;/code&gt; 这一语句，将 &lt;code&gt;r&lt;/code&gt; 的动态类型变成 &lt;code&gt;*os.File&lt;/code&gt;，动态值则变成非空，表示打开的文件对象。这时，r 可以用&lt;code&gt;&amp;lt;value, type&amp;gt;&lt;/code&gt;对来表示为： &lt;code&gt;&amp;lt;tty, *os.File&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/56844299-b29b5c80-68e0-11e9-8211-d227448806b7.png&quot; alt=&quot;r=tty&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意看上图，此时虽然 &lt;code&gt;fun&lt;/code&gt; 所指向的函数只有一个 &lt;code&gt;Read&lt;/code&gt; 函数，其实 &lt;code&gt;*os.File&lt;/code&gt; 还包含 &lt;code&gt;Write&lt;/code&gt; 函数，也就是说 &lt;code&gt;*os.File&lt;/code&gt; 其实还实现了 &lt;code&gt;io.Writer&lt;/code&gt; 接口。因此下面的断言语句可以执行：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var w io.Writer
w = r.(io.Writer)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以用断言，而不能直接赋值，是因为 &lt;code&gt;r&lt;/code&gt; 的静态类型是 &lt;code&gt;io.Reader&lt;/code&gt;，并没有实现 &lt;code&gt;io.Writer&lt;/code&gt; 接口。断言能否成功，看 &lt;code&gt;r&lt;/code&gt; 的动态类型是否符合要求。&lt;/p&gt;
&lt;p&gt;这样，w 也可以表示成 &lt;code&gt;&amp;lt;tty, *os.File&amp;gt;&lt;/code&gt;，仅管它和 &lt;code&gt;w&lt;/code&gt; 一样，但是 w 可调用的函数取决于它的静态类型 &lt;code&gt;io.Writer&lt;/code&gt;，也就是说它只能有这样的调用形式： &lt;code&gt;w.Write()&lt;/code&gt; 。&lt;code&gt;w&lt;/code&gt; 的内存形式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/56844534-4884b680-68e4-11e9-8be5-63b342e4447b.png&quot; alt=&quot;w = r.(io.Writer)&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和 &lt;code&gt;w&lt;/code&gt; 相比，仅仅是 &lt;code&gt;fun&lt;/code&gt; 对应的函数变了：&lt;code&gt;Read -&amp;gt; Write&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，再来一个赋值：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var empty interface{}
empty = w&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 &lt;code&gt;empty&lt;/code&gt; 是一个空接口，因此所有的类型都实现了它，w 可以直接赋给它，不需要执行断言操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/56844669-9b5f6d80-68e6-11e9-8a31-8d38951c7742.png&quot; alt=&quot;empty=w&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的三张图可以看到，interface 包含三部分信息：&lt;code&gt;_type&lt;/code&gt; 是类型信息，&lt;code&gt;*data&lt;/code&gt; 指向实际类型的实际值，&lt;code&gt;itab&lt;/code&gt; 包含实际类型的信息，包括大小、包路径，还包含绑定在类型上的各种方法（图上没有画出方法），补充一下关于 os.File 结构体的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/56946658-4bd6a700-6b5d-11e9-9a3d-0e781957be31.png&quot; alt=&quot;struct_type&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一节的最后，复习一下上一篇关于 interface 的文章，提到的一个技巧，这里再展示一下：&lt;/p&gt;
&lt;p&gt;先参考源码，分别定义一个&lt;code&gt;“伪装”&lt;/code&gt;的 iface 和 eface 结构体。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type iface struct {
    tab  *itab
    data unsafe.Pointer
}
type itab struct {
    inter uintptr
    _type uintptr
    link uintptr
    hash  uint32
    _     [4]byte
    fun   [1]uintptr
}

type eface struct {
    _type uintptr
    data unsafe.Pointer
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，将接口变量占据的内存内容强制解释成上面定义的类型，再打印出来：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
    &quot;os&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;unsafe&quot;
)

func main() {
    var r io.Reader
    fmt.Printf(&quot;initial r: %T, %v\n&quot;, r, r)

    tty, _ := os.OpenFile(&quot;/Users/qcrao/Desktop/test&quot;, os.O_RDWR, 0)
    fmt.Printf(&quot;tty: %T, %v\n&quot;, tty, tty)

    // 给 r 赋值
    r = tty
    fmt.Printf(&quot;r: %T, %v\n&quot;, r, r)

    rIface := (*iface)(unsafe.Pointer(&amp;amp;r))
    fmt.Printf(&quot;r: iface.tab._type = %#x, iface.data = %#x\n&quot;, rIface.tab._type, rIface.data)

    // 给 w 赋值
    var w io.Writer
    w = r.(io.Writer)
    fmt.Printf(&quot;w: %T, %v\n&quot;, w, w)

    wIface := (*iface)(unsafe.Pointer(&amp;amp;w))
    fmt.Printf(&quot;w: iface.tab._type = %#x, iface.data = %#x\n&quot;, wIface.tab._type, wIface.data)

    // 给 empty 赋值
    var empty interface{}
    empty = w
    fmt.Printf(&quot;empty: %T, %v\n&quot;, empty, empty)

    emptyEface := (*eface)(unsafe.Pointer(&amp;amp;empty))
    fmt.Printf(&quot;empty: eface._type = %#x, eface.data = %#x\n&quot;, emptyEface._type, emptyEface.data)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;initial r: &amp;lt;nil&amp;gt;, &amp;lt;nil&amp;gt;
tty: *os.File, &amp;amp;{0xc4200820f0}
r: *os.File, &amp;amp;{0xc4200820f0}
r: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020
w: *os.File, &amp;amp;{0xc4200820f0}
w: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020
empty: *os.File, &amp;amp;{0xc4200820f0}
empty: eface._type = 0x10bfcc0, eface.data = 0xc420080020&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;r，w，empty&lt;/code&gt; 的动态类型和动态值都一样。不再详细解释了，结合前面的图可以看得非常清晰。&lt;/p&gt;
&lt;h2 id=&quot;反射的基本函数&quot;&gt;反射的基本函数&lt;/h2&gt;
&lt;p&gt;reflect 包里定义了一个接口和一个结构体，即 &lt;code&gt;reflect.Type&lt;/code&gt; 和 &lt;code&gt;reflect.Value&lt;/code&gt;，它们提供很多函数来获取存储在接口里的类型信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reflect.Type&lt;/code&gt; 主要提供关于类型相关的信息，所以它和 &lt;code&gt;_type&lt;/code&gt; 关联比较紧密；&lt;code&gt;reflect.Value&lt;/code&gt; 则结合 &lt;code&gt;_type&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 两者，因此程序员可以获取甚至改变类型的值。&lt;/p&gt;
&lt;p&gt;reflect 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func TypeOf(i interface{}) Type 
func ValueOf(i interface{}) Value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TypeOf&lt;/code&gt; 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 &lt;code&gt;interface{}&lt;/code&gt;，调用此函数时，实参会先被转化为 &lt;code&gt;interface{}&lt;/code&gt;类型。这样，实参的类型信息、方法集、值信息都存储到 &lt;code&gt;interface{}&lt;/code&gt; 变量里了。&lt;/p&gt;
&lt;p&gt;看下源码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func TypeOf(i interface{}) Type {
    eface := *(*emptyInterface)(unsafe.Pointer(&amp;amp;i))
    return toType(eface.typ)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;emptyInterface&lt;/code&gt; 和上面提到的 &lt;code&gt;eface&lt;/code&gt; 是一回事（字段名略有差异，字段是相同的），且在不同的源码包：前者在 &lt;code&gt;reflect&lt;/code&gt; 包，后者在 &lt;code&gt;runtime&lt;/code&gt; 包。 &lt;code&gt;eface.typ&lt;/code&gt; 就是动态类型。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type emptyInterface struct {
    typ  *rtype
    word unsafe.Pointer
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于 &lt;code&gt;toType&lt;/code&gt; 函数，只是做了一个类型转换：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func toType(t *rtype) Type {
    if t == nil {
        return nil
    }
    return t
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，返回值 &lt;code&gt;Type&lt;/code&gt; 实际上是一个接口，定义了很多方法，用来获取类型相关的各种信息，而 &lt;code&gt;*rtype&lt;/code&gt; 实现了 &lt;code&gt;Type&lt;/code&gt; 接口。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type Type interface {
    // 所有的类型都可以调用下面这些函数

    // 此类型的变量对齐后所占用的字节数
    Align() int
    
    // 如果是 struct 的字段，对齐后占用的字节数
    FieldAlign() int

    // 返回类型方法集里的第 `i` (传入的参数)个方法
    Method(int) Method

    // 通过名称获取方法
    MethodByName(string) (Method, bool)

    // 获取类型方法集里导出的方法个数
    NumMethod() int

    // 类型名称
    Name() string

    // 返回类型所在的路径，如：encoding/base64
    PkgPath() string

    // 返回类型的大小，和 unsafe.Sizeof 功能类似
    Size() uintptr

    // 返回类型的字符串表示形式
    String() string

    // 返回类型的类型值
    Kind() Kind

    // 类型是否实现了接口 u
    Implements(u Type) bool

    // 是否可以赋值给 u
    AssignableTo(u Type) bool

    // 是否可以类型转换成 u
    ConvertibleTo(u Type) bool

    // 类型是否可以比较
    Comparable() bool

    // 下面这些函数只有特定类型可以调用
    // 如：Key, Elem 两个方法就只能是 Map 类型才能调用
    
    // 类型所占据的位数
    Bits() int

    // 返回通道的方向，只能是 chan 类型调用
    ChanDir() ChanDir

    // 返回类型是否是可变参数，只能是 func 类型调用
    // 比如 t 是类型 func(x int, y ... float64)
    // 那么 t.IsVariadic() == true
    IsVariadic() bool

    // 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用
    Elem() Type

    // 返回结构体类型的第 i 个字段，只能是结构体类型调用
    // 如果 i 超过了总字段数，就会 panic
    Field(i int) StructField

    // 返回嵌套的结构体的字段
    FieldByIndex(index []int) StructField

    // 通过字段名称获取字段
    FieldByName(name string) (StructField, bool)

    // FieldByNameFunc returns the struct field with a name
    // 返回名称符合 func 函数的字段
    FieldByNameFunc(match func(string) bool) (StructField, bool)

    // 获取函数类型的第 i 个参数的类型
    In(i int) Type

    // 返回 map 的 key 类型，只能由类型 map 调用
    Key() Type

    // 返回 Array 的长度，只能由类型 Array 调用
    Len() int

    // 返回类型字段的数量，只能由类型 Struct 调用
    NumField() int

    // 返回函数类型的输入参数个数
    NumIn() int

    // 返回函数类型的返回值个数
    NumOut() int

    // 返回函数类型的第 i 个值的类型
    Out(i int) Type

    // 返回类型结构体的相同部分
    common() *rtype
    
    // 返回类型结构体的不同部分
    uncommon() *uncommonType
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见 &lt;code&gt;Type&lt;/code&gt; 定义了非常多的方法，通过它们可以获取类型的一切信息，大家一定要完整的过一遍上面所有的方法。&lt;/p&gt;
&lt;p&gt;注意到 &lt;code&gt;Type&lt;/code&gt; 方法集的倒数第二个方法 &lt;code&gt;common&lt;/code&gt;&lt;br/&gt;返回的 &lt;code&gt;rtype&lt;/code&gt;类型，它和上一篇文章讲到的 &lt;code&gt;_type&lt;/code&gt; 是一回事，而且源代码里也注释了：两边要保持同步：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt; // rtype must be kept in sync with ../runtime/type.go:/^type._type.&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type rtype struct {
    size       uintptr
    ptrdata    uintptr
    hash       uint32
    tflag      tflag
    align      uint8
    fieldAlign uint8
    kind       uint8
    alg        *typeAlg
    gcdata     *byte
    str        nameOff
    ptrToThis  typeOff
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有的类型都会包含 &lt;code&gt;rtype&lt;/code&gt; 这个字段，表示各种类型的公共信息；另外，不同类型包含自己的一些独特的部分。&lt;/p&gt;
&lt;p&gt;比如下面的 &lt;code&gt;arrayType&lt;/code&gt; 和 &lt;code&gt;chanType&lt;/code&gt; 都包含 &lt;code&gt;rytpe&lt;/code&gt;，而前者还包含 slice，len 等和数组相关的信息；后者则包含 &lt;code&gt;dir&lt;/code&gt; 表示通道方向的信息。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// arrayType represents a fixed array type.
type arrayType struct {
    rtype `reflect:&quot;array&quot;`
    elem  *rtype // array element type
    slice *rtype // slice type
    len   uintptr
}

// chanType represents a channel type.
type chanType struct {
    rtype `reflect:&quot;chan&quot;`
    elem  *rtype  // channel element type
    dir   uintptr // channel direction (ChanDir)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到，&lt;code&gt;Type&lt;/code&gt; 接口实现了 &lt;code&gt;String()&lt;/code&gt; 函数，满足 &lt;code&gt;fmt.Stringer&lt;/code&gt; 接口，因此使用 &lt;code&gt;fmt.Println&lt;/code&gt; 打印的时候，输出的是 &lt;code&gt;String()&lt;/code&gt; 的结果。另外，&lt;code&gt;fmt.Printf()&lt;/code&gt; 函数，如果使用 &lt;code&gt;%T&lt;/code&gt; 来作为格式参数，输出的是 &lt;code&gt;reflect.TypeOf&lt;/code&gt; 的结果，也就是动态类型。例如：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;fmt.Printf(&quot;%T&quot;, 3) // int&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;讲完了 &lt;code&gt;TypeOf&lt;/code&gt; 函数，再来看一下 &lt;code&gt;ValueOf&lt;/code&gt; 函数。返回值 &lt;code&gt;reflect.Value&lt;/code&gt; 表示 &lt;code&gt;interface{}&lt;/code&gt; 里存储的实际变量，它能提供实际变量的各种信息。相关的方法常常是需要结合类型信息和值信息。例如，如果要提取一个结构体的字段信息，那就需要用到 _type (具体到这里是指 structType) 类型持有的关于结构体的字段信息、偏移信息，以及 &lt;code&gt;*data&lt;/code&gt; 所指向的内容 —— 结构体的实际值。&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func ValueOf(i interface{}) Value {
    if i == nil {
        return Value{}
    }
    
   // ……
    return unpackEface(i)
}

// 分解 eface
func unpackEface(i interface{}) Value {
    e := (*emptyInterface)(unsafe.Pointer(&amp;amp;i))

    t := e.typ
    if t == nil {
        return Value{}
    }
    
    f := flag(t.Kind())
    if ifaceIndir(t) {
        f |= flagIndir
    }
    return Value{t, e.word, f}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码看，比较简单：将先将 &lt;code&gt;i&lt;/code&gt; 转换成 &lt;code&gt;*emptyInterface&lt;/code&gt; 类型， 再将它的 &lt;code&gt;typ&lt;/code&gt; 字段和 &lt;code&gt;word&lt;/code&gt; 字段以及一个标志位字段组装成一个 &lt;code&gt;Value&lt;/code&gt; 结构体，而这就是 &lt;code&gt;ValueOf&lt;/code&gt; 函数的返回值，它包含类型结构体指针、真实数据的地址、标志位。&lt;/p&gt;
&lt;p&gt;Value 结构体定义了很多方法，通过这些方法可以直接操作 Value 字段 ptr 所指向的实际数据：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// 设置切片的 len 字段，如果类型不是切片，就会panic
 func (v Value) SetLen(n int)
 
 // 设置切片的 cap 字段
 func (v Value) SetCap(n int)
 
 // 设置字典的 kv
 func (v Value) SetMapIndex(key, val Value)

 // 返回切片、字符串、数组的索引 i 处的值
 func (v Value) Index(i int) Value
 
 // 根据名称获取结构体的内部字段值
 func (v Value) FieldByName(name string) Value
 
 // ……&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Value&lt;/code&gt; 字段还有很多其他的方法。例如：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// 用来获取 int 类型的值
func (v Value) Int() int64

// 用来获取结构体字段（成员）数量
func (v Value) NumField() int

// 尝试向通道发送数据（不会阻塞）
func (v Value) TrySend(x reflect.Value) bool

// 通过参数列表 in 调用 v 值所代表的函数（或方法
func (v Value) Call(in []Value) (r []Value) 

// 调用变参长度可变的函数
func (v Value) CallSlice(in []Value) []Value &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不一一列举了，反正是非常多。可以去 &lt;code&gt;src/reflect/value.go&lt;/code&gt; 去看看源码，搜索 &lt;code&gt;func (v Value)&lt;/code&gt; 就能看到。&lt;/p&gt;
&lt;p&gt;另外，通过 &lt;code&gt;Type()&lt;/code&gt; 方法和 &lt;code&gt;Interface()&lt;/code&gt; 方法可以打通 &lt;code&gt;interface&lt;/code&gt;、&lt;code&gt;Type&lt;/code&gt;、&lt;code&gt;Value&lt;/code&gt; 三者。Type() 方法也可以返回变量的类型信息，与 reflect.TypeOf() 函数等价。Interface() 方法可以将 Value 还原成原来的 interface。&lt;/p&gt;
&lt;p&gt;这里引用老钱《快学Go语言第十五课——反射》的一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/57130652-bb060280-6dcc-11e9-9c63-6e2bc4e33509.png&quot; alt=&quot;三者关系&quot;/&gt;&lt;br/&gt;总结一下：&lt;code&gt;TypeOf()&lt;/code&gt; 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； &lt;code&gt;ValueOf()&lt;/code&gt; 函数返回一个结构体变量，包含类型信息以及实际值。&lt;/p&gt;
&lt;p&gt;用一张图来串一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/56848267-6f111480-6919-11e9-826f-a809093d17ea.png&quot; alt=&quot;value rtype&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，&lt;code&gt;rtye&lt;/code&gt; 实现了 &lt;code&gt;Type&lt;/code&gt; 接口，是所有类型的公共部分。emptyface 结构体和 eface 其实是一个东西，而 rtype 其实和 _type 是一个东西，只是一些字段稍微有点差别，比如 emptyface 的 word 字段和 eface 的 data 字段名称不同，但是数据型是一样的。&lt;/p&gt;
&lt;h2 id=&quot;反射的三大定律&quot;&gt;反射的三大定律&lt;/h2&gt;
&lt;p&gt;根据 Go 官方关于反射的博客，反射有三大定律：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;Reflection goes from interface value to reflection object.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;Reflection goes from reflection object to interface value.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;To modify a reflection object, the value must be settable.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;第一条是最基本的：反射是一种检测存储在 &lt;code&gt;interface&lt;/code&gt; 中的类型和值机制。这可以通过 &lt;code&gt;TypeOf&lt;/code&gt; 函数和 &lt;code&gt;ValueOf&lt;/code&gt; 函数得到。&lt;/p&gt;
&lt;p&gt;第二条实际上和第一条是相反的机制，它将 &lt;code&gt;ValueOf&lt;/code&gt; 的返回值通过 &lt;code&gt;Interface()&lt;/code&gt; 函数反向转变成 &lt;code&gt;interface&lt;/code&gt; 变量。&lt;/p&gt;
&lt;p&gt;前两条就是说 &lt;code&gt;接口型变量&lt;/code&gt; 和 &lt;code&gt;反射类型对象&lt;/code&gt; 可以相互转化，反射类型对象实际上就是指的前面说的 &lt;code&gt;reflect.Type&lt;/code&gt; 和 &lt;code&gt;reflect.Value&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第三条不太好懂：如果需要操作一个反射变量，那么它必须是可设置的。反射变量可设置的本质是它存储了原变量本身，这样对反射变量的操作，就会反映到原变量本身；反之，如果反射变量不能代表原变量，那么操作了反射变量，不会对原变量产生任何影响，这会给使用者带来疑惑。所以第二种情况在语言层面是不被允许的。&lt;/p&gt;
&lt;p&gt;举一个经典例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Error: will panic.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面的代码会产生 panic，原因是反射变量 &lt;code&gt;v&lt;/code&gt; 不能代表 &lt;code&gt;x&lt;/code&gt; 本身，为什么？因为调用 &lt;code&gt;reflect.ValueOf(x)&lt;/code&gt; 这一行代码的时候，传入的参数在函数内部只是一个拷贝，是值传递，所以 &lt;code&gt;v&lt;/code&gt; 代表的只是 &lt;code&gt;x&lt;/code&gt; 的一个拷贝，因此对 &lt;code&gt;v&lt;/code&gt; 进行操作是被禁止的。&lt;/p&gt;
&lt;p&gt;可设置是反射变量 &lt;code&gt;Value&lt;/code&gt; 的一个性质，但不是所有的 &lt;code&gt;Value&lt;/code&gt; 都是可被设置的。&lt;/p&gt;
&lt;p&gt;就像在一般的函数里那样，当我们想改变传入的变量时，使用指针就可以解决了。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var x float64 = 3.4
p := reflect.ValueOf(&amp;amp;x)
fmt.Println(&quot;type of p:&quot;, p.Type())
fmt.Println(&quot;settability of p:&quot;, p.CanSet())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出是这样的：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type of p: *float64
settability of p: false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;p&lt;/code&gt; 还不是代表 &lt;code&gt;x&lt;/code&gt;，&lt;code&gt;p.Elem()&lt;/code&gt; 才真正代表 &lt;code&gt;x&lt;/code&gt;，这样就可以真正操作 &lt;code&gt;x&lt;/code&gt; 了：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;v := p.Elem()
v.SetFloat(7.1)
fmt.Println(v.Interface()) // 7.1
fmt.Println(x) // 7.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于第三条，记住一句话：如果想要操作原变量，反射变量 &lt;code&gt;Value&lt;/code&gt; 必须要 hold 住原变量的地址才行。&lt;/p&gt;

&lt;h2 id=&quot;代码样例&quot;&gt;代码样例&lt;/h2&gt;
&lt;p&gt;网络上各种博客文章里使用反射的样例代码非常多，读过这篇文章后，基本没有看不懂的，哈哈！不过，我这里还是举一个例子，并讲解一番：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
    &quot;reflect&quot;
    &quot;fmt&quot;
)

type Child struct {
    Name     string
    Grade    int
    Handsome bool
}

type Adult struct {
    ID         string `qson:&quot;Name&quot;`
    Occupation string
    Handsome   bool
}

// 如果输入参数 i 是 Slice，元素是结构体，有一个字段名为 `Handsome`，
// 并且有一个字段的 tag 或者字段名是 `Name` ，
// 如果该 `Name` 字段的值是 `qcrao`，
// 就把结构体中名为 `Handsome` 的字段值设置为 true。
func handsome(i interface{}) {
    // 获取 i 的反射变量 Value
    v := reflect.ValueOf(i)

    // 确定 v 是一个 Slice
    if v.Kind() != reflect.Slice {
        return
    }

    // 确定 v 是的元素为结构体
    if e := v.Type().Elem(); e.Kind() != reflect.Struct {
        return
    }

    // 确定结构体的字段名含有 &quot;ID&quot; 或者 json tag 标签为 `name`
    // 确定结构体的字段名 &quot;Handsome&quot;
    st := v.Type().Elem()

    // 寻找字段名为 Name 或者 tag 的值为 Name 的字段
    foundName := false
    for i := 0; i &amp;lt; st.NumField(); i++ {
        f := st.Field(i)
        tag := f.Tag.Get(&quot;qson&quot;)

        if (tag == &quot;Name&quot; || f.Name == &quot;Name&quot;) &amp;amp;&amp;amp; f.Type.Kind() == reflect.String {
            foundName = true
            break
        }
    }

    if !foundName {
        return
    }

    if niceField, foundHandsome := st.FieldByName(&quot;Handsome&quot;); foundHandsome == false || niceField.Type.Kind() != reflect.Bool {
        return
    }

    // 设置名字为 &quot;qcrao&quot; 的对象的 &quot;Handsome&quot; 字段为 true
    for i := 0; i &amp;lt; v.Len(); i++ {
        e := v.Index(i)
        handsome := e.FieldByName(&quot;Handsome&quot;)

        // 寻找字段名为 Name 或者 tag 的值为 Name 的字段
        var name reflect.Value
        for j := 0; j &amp;lt; st.NumField(); j++ {
            f := st.Field(j)
            tag := f.Tag.Get(&quot;qson&quot;)

            if tag == &quot;Name&quot; || f.Name == &quot;Name&quot; {
                name = v.Index(i).Field(j)
            }
        }

        if name.String() == &quot;qcrao&quot; {
            handsome.SetBool(true)
        }
    }
}

func main() {
    children := []Child{
        {Name: &quot;Ava&quot;, Grade: 3, Handsome: true},
        {Name: &quot;qcrao&quot;, Grade: 6, Handsome: false},
    }

    adults := []Adult{
        {ID: &quot;Steve&quot;, Occupation: &quot;Clerk&quot;, Handsome: true},
        {ID: &quot;qcrao&quot;, Occupation: &quot;Go Programmer&quot;, Handsome: false},
    }

    fmt.Printf(&quot;adults before handsome: %v\n&quot;, adults)
    handsome(adults)
    fmt.Printf(&quot;adults after handsome: %v\n&quot;, adults)

    fmt.Println(&quot;-------------&quot;)

    fmt.Printf(&quot;children before handsome: %v\n&quot;, children)
    handsome(children)
    fmt.Printf(&quot;children after handsome: %v\n&quot;, children)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;adults before handsome: [{Steve Clerk true} {qcrao Go Programmer false}]
adults after handsome: [{Steve Clerk true} {qcrao Go Programmer true}]
-------------
children before handsome: [{Ava 3 true} {qcrao 6 false}]
children after handsome: [{Ava 3 true} {qcrao 6 true}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码主要做的事情是：找出传入的参数为 Slice，并且 Slice 的元素为结构体，如果其中有一个字段名是 &lt;code&gt;Name&lt;/code&gt; 或者是 标签名称为 &lt;code&gt;Name&lt;/code&gt;，并且还有一个字段名是 &lt;code&gt;Handsome&lt;/code&gt; 的情形。如果找到，并且字段名称为 &lt;code&gt;Name&lt;/code&gt; 的实际值是 &lt;code&gt;qcrao&lt;/code&gt; 的话，就把另一个字段 &lt;code&gt;Handsome&lt;/code&gt; 的值置为 true。&lt;/p&gt;
&lt;p&gt;程序并不关心传入的结构体到底是什么，只要它的字段名包含 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Handsome&lt;/code&gt;，都是 handsome 函数要工作的对象。&lt;/p&gt;
&lt;p&gt;注意一点，&lt;code&gt;Adult&lt;/code&gt; 结构体的标签 &lt;code&gt;qson:&quot;Name&quot;&lt;/code&gt;，中间是没有空格的，否则 &lt;code&gt;Tag.Get(&quot;qson&quot;)&lt;/code&gt; 识别不出来。&lt;/p&gt;
&lt;h2 id=&quot;未导出成员&quot;&gt;未导出成员&lt;/h2&gt;
&lt;p&gt;利用反射机制，对于结构体中未导出成员，可以读取，但不能修改其值。&lt;/p&gt;
&lt;p&gt;注意，正常情况下，代码是不能读取结构体未导出成员的，但通过反射可以越过这层限制。另外，通过反射，结构体中可以被修改的成员只有是导出成员，也就是字段名的首字母是大写的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一个可取地址的 reflect.Value 变量会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。&lt;br/&gt;CanAddr 不能说明一个变量是否可以被修改。&lt;br/&gt;CanSet 则可以检查对应的 reflect.Value 是否可取地址并可被修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
    &quot;reflect&quot;
    &quot;fmt&quot;
)

type Child struct {
    Name     string
    handsome bool
}

func main() {
    qcrao := Child{Name: &quot;qcrao&quot;, handsome: true}

    v := reflect.ValueOf(&amp;amp;qcrao)

    f := v.Elem().FieldByName(&quot;Name&quot;)
    fmt.Println(f.String())

    f.SetString(&quot;stefno&quot;)
    fmt.Println(f.String())

    f = v.Elem().FieldByName(&quot;handsome&quot;)
    
    // 这一句会导致 panic，因为 handsome 字段未导出
    //f.SetBool(true)
    fmt.Println(f.Bool())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;qcrao
stefno
true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，handsome 字段未导出，可以读取，但不能调用相关 set 方法，否则会 panic。反射用起来一定要小心，调用类型不匹配的方法，会导致各种 panic。&lt;/p&gt;

&lt;p&gt;反射的实际应用非常广：IDE 中的代码自动补全功能、对象序列化（json 函数库）、fmt 相关函数的实现、ORM（全称是：Object Relational Mapping，对象关系映射）……&lt;/p&gt;
&lt;p&gt;这里举 2 个例子：json 序列化和 DeepEqual 函数。&lt;/p&gt;
&lt;h2 id=&quot;json-序列化&quot;&gt;json 序列化&lt;/h2&gt;
&lt;p&gt;开发过 web 服务的同学，一定用过 &lt;code&gt;json&lt;/code&gt; 数据格式。&lt;code&gt;json&lt;/code&gt; 是一种独立于语言的数据格式。最早用于浏览器和服务器之间的实时无状态的数据交换，并由此发展起来。&lt;/p&gt;
&lt;p&gt;Go 语言中，主要提供 2 个函数用于序列化和反序列化：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Marshal(v interface{}) ([]byte, error)
func Unmarshal(data []byte, v interface{}) error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个函数的参数都包含 &lt;code&gt;interface&lt;/code&gt;，具体实现的时候，都会用到反射相关的特性。&lt;/p&gt;
&lt;p&gt;对于序列化和反序列化函数，均需要知道参数的所有字段，包括字段类型和值，再调用相关的 get 函数或者 set 函数进行实际的操作。&lt;/p&gt;
&lt;h2 id=&quot;deepequal-的作用及原理&quot;&gt;DeepEqual 的作用及原理&lt;/h2&gt;
&lt;p&gt;在测试函数中，经常会需要这样的函数：判断两个变量的实际内容完全一致。&lt;/p&gt;
&lt;p&gt;例如：如何判断两个 slice 所有的元素完全相同；如何判断两个 map 的 key 和 value 完全相同等等。&lt;/p&gt;
&lt;p&gt;上述问题，可以通过 &lt;code&gt;DeepEqual&lt;/code&gt; 函数实现。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func DeepEqual(x, y interface{}) bool&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;DeepEqual&lt;/code&gt; 函数的参数是两个 &lt;code&gt;interface&lt;/code&gt;，实际上也就是可以输入任意类型，输出 true 或者 flase 表示输入的两个变量是否是“深度”相等。&lt;/p&gt;
&lt;p&gt;先明白一点，如果是不同的类型，即使是底层类型相同，相应的值也相同，那么两者也不是“深度”相等。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type MyInt int
type YourInt int

func main() {
    m := MyInt(1)
    y := YourInt(1)

    fmt.Println(reflect.DeepEqual(m, y)) // false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，m, y 底层都是 int，而且值都是 1，但是两者静态类型不同，前者是 &lt;code&gt;MyInt&lt;/code&gt;，后者是 &lt;code&gt;YourInt&lt;/code&gt;，因此两者不是“深度”相等。&lt;/p&gt;
&lt;p&gt;在源码里，有对 DeepEqual 函数的非常清楚地注释，列举了不同类型，DeepEqual 的比较情形，这里做一个总结：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Array&lt;/td&gt;
&lt;td&gt;相同索引处的元素“深度”相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Struct&lt;/td&gt;
&lt;td&gt;相应字段，包含导出和不导出，“深度”相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Func&lt;/td&gt;
&lt;td&gt;只有两者都是 nil 时&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Interface&lt;/td&gt;
&lt;td&gt;两者存储的具体值“深度”相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Map&lt;/td&gt;
&lt;td&gt;1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Pointer&lt;/td&gt;
&lt;td&gt;1、使用 == 比较的结果相等；2、指向的实体“深度”相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Slice&lt;/td&gt;
&lt;td&gt;1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;amp;x[0] == &amp;amp;y[0] 或者 相同索引处的元素“深度”相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;numbers, bools, strings, and channels&lt;/td&gt;
&lt;td&gt;使用 == 比较的结果为真&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;一般情况下，DeepEqual 的实现只需要递归地调用 == 就可以比较两个变量是否是真的“深度”相等。&lt;/p&gt;
&lt;p&gt;但是，有一些异常情况：比如 func 类型是不可比较的类型，只有在两个 func 类型都是 nil 的情况下，才是“深度”相等；float 类型，由于精度的原因，也是不能使用 == 比较的；包含 func 类型或者 float 类型的 struct， interface， array 等。&lt;/p&gt;
&lt;p&gt;对于指针而言，当两个值相等的指针就是“深度”相等，因为两者指向的内容是相等的，即使两者指向的是 func 类型或者 float 类型，这种情况下不关心指针所指向的内容。&lt;/p&gt;
&lt;p&gt;同样，对于指向相同 slice， map 的两个变量也是“深度”相等的，不关心 slice， map 具体的内容。&lt;/p&gt;
&lt;p&gt;对于“有环”的类型，比如循环链表，比较两者是否“深度”相等的过程中，需要对已比较的内容作一个标记，一旦发现两个指针之前比较过，立即停止比较，并判定二者是深度相等的。这样做的原因是，及时停止比较，避免陷入无限循环。&lt;/p&gt;
&lt;p&gt;来看源码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func DeepEqual(x, y interface{}) bool {
    if x == nil || y == nil {
        return x == y
    }
    v1 := ValueOf(x)
    v2 := ValueOf(y)
    if v1.Type() != v2.Type() {
        return false
    }
    return deepValueEqual(v1, v2, make(map[visit]bool), 0)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先查看两者是否有一个是 nil 的情况，这种情况下，只有两者都是 nil，函数才会返回 true。&lt;/p&gt;
&lt;p&gt;接着，使用反射，获取x，y 的反射对象，并且立即比较两者的类型，根据前面的内容，这里实际上是动态类型，如果类型不同，直接返回 false。&lt;/p&gt;
&lt;p&gt;最后，最核心的内容在子函数 &lt;code&gt;deepValueEqual&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;代码比较长，思路却比较简单清晰：核心是一个 switch 语句，识别输入参数的不同类型，分别递归调用 deepValueEqual 函数，一直递归到最基本的数据类型，比较 int，string 等可以直接得出 true 或者 false，再一层层地返回，最终得到“深度”相等的比较结果。&lt;/p&gt;
&lt;p&gt;实际上，各种类型的比较套路比较相似，这里就直接节选一个稍微复杂一点的 &lt;code&gt;map&lt;/code&gt; 类型的比较：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// deepValueEqual 函数
// ……

case Map:
    if v1.IsNil() != v2.IsNil() {
        return false
    }
    if v1.Len() != v2.Len() {
        return false
    }
    if v1.Pointer() == v2.Pointer() {
        return true
    }
    for _, k := range v1.MapKeys() {
        val1 := v1.MapIndex(k)
        val2 := v2.MapIndex(k)
        if !val1.IsValid() || !val2.IsValid() || !deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+1) {
            return false
        }
    }
    return true
    
// ……   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和前文总结的表格里，比较 map 是否相等的思路比较一致，也不需要多说什么。说明一点，&lt;code&gt;visited&lt;/code&gt; 是一个 map，记录递归过程中，比较过的“对”：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type visit struct {
    a1  unsafe.Pointer
    a2  unsafe.Pointer
    typ Type
}

map[visit]bool&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比较过程中，一旦发现比较的“对”，已经在 map 里出现过的话，直接判定“深度”比较结果的是 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Go 作为一门静态语言，相比 Python 等动态语言，在编写过程中灵活性会受到一定的限制。但是通过接口加反射实现了类似于动态语言的能力：可以在程序运行时动态地捕获甚至改变类型的信息和值。&lt;/p&gt;
&lt;p&gt;Go 语言的反射实现的基础是类型，或者说是 interface，当我们使用反射特性时，实际上用到的就是存储在 interface 变量中的和类型相关的信息，也就是常说的 &lt;code&gt;&amp;lt;type, value&amp;gt;&lt;/code&gt; 对。&lt;/p&gt;
&lt;p&gt;只有 interface 才有反射的说法。&lt;/p&gt;
&lt;p&gt;反射在 reflect 包中实现，涉及到两个相关函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func TypeOf ( i interface{} ) Type
func ValueOf ( i interface{} ) Value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Type 是一个接口，定义了很多相关方法，用于获取类型信息。Value 则持有类型的具体值。Type、Value、Interface 三者间通过函数 TypeOf，ValueOf，Interface 进行相互转换。&lt;/p&gt;
&lt;p&gt;最后温习一下反射三大定律：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;Reflection goes from interface value to reflection object.&lt;/li&gt;
&lt;li&gt;Reflection goes from reflection object to interface value.&lt;/li&gt;
&lt;li&gt;To modify a reflection object, the value must be settable.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;翻译一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;反射将接口变量转换成反射对象 Type 和 Value；&lt;/li&gt;
&lt;li&gt;反射可以通过反射对象 Value 还原成原先的接口变量；&lt;/li&gt;
&lt;li&gt;反射可以用来修改一个变量的值，前提是这个值可以被修改。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png&quot; alt=&quot;QR&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【维基百科中文】&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&quot;&gt;https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【码洞老钱 反射】&lt;a href=&quot;https://juejin.im/post/5c2040d76fb9a049c643d9bd&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5c2040d76fb9a049c643d9bd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go官方博客 reflection】&lt;a href=&quot;https://blog.golang.org/laws-of-reflection&quot; class=&quot;uri&quot;&gt;https://blog.golang.org/laws-of-reflection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【GCTT译文，不错】&lt;a href=&quot;https://mp.weixin.qq.com/s/dkgJ_fA0smvpv69t5Nv-7A&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s/dkgJ_fA0smvpv69t5Nv-7A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【json库 源码分析】&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37165706&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/37165706&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【reflect 代码例子和图比较好】&lt;a href=&quot;https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/&quot; class=&quot;uri&quot;&gt;https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【反射使用讲得不错】&lt;a href=&quot;https://juejin.im/post/5a75a4fb5188257a82110544&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5a75a4fb5188257a82110544&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【接口和反射的关系 ，english】&lt;a href=&quot;https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/&quot; class=&quot;uri&quot;&gt;https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【总结成知识点】&lt;a href=&quot;http://www.cnblogs.com/susufufu/p/7653579.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/susufufu/p/7653579.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Type Value】&lt;a href=&quot;https://colobu.com/2016/07/09/dive-into-go-13/&quot; class=&quot;uri&quot;&gt;https://colobu.com/2016/07/09/dive-into-go-13/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【讲得比较清晰简单】&lt;a href=&quot;https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2017/11/06/golang-reflection.html&quot;&gt;https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2017/11/06/golang-reflection.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【DeepEqual】&lt;a href=&quot;https://github.com/Chasiny/Blog/blob/master/blog/go/package/go-reflect-deepequal.md&quot; class=&quot;uri&quot;&gt;https://github.com/Chasiny/Blog/blob/master/blog/go/package/go-reflect-deepequal.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【反射使用场景】&lt;a href=&quot;https://yq.aliyun.com/articles/599584&quot; class=&quot;uri&quot;&gt;https://yq.aliyun.com/articles/599584&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 14:36:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>Go 作为一门静态语言，相比 Python 等动态语言，在编写过程中灵活性会受到一定的限制。但是通过接口加反射实现了类似于动态语言的能力：可以在程序运行时动态地捕获甚至改变类型的信息和值。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcrao-2018/p/10822655.html</dc:identifier>
</item>
<item>
<title>线程间通信 - 木瓜芒果</title>
<link>http://www.cnblogs.com/volcano-liu/p/10783003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcano-liu/p/10783003.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;在我们使用多个线程来同时运行多个任务时，可以通过使用锁(互斥)来同步两个或多个任务的行为，从而使得一个任务不会干涉另一个任务使用的资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个问题已经解决了，下一步是学习如何使任务彼此之间可以协作，以使得多个任务可以一起工作去解决某个问题。在这类问题中不可避免会碰到某些部分必须在其他部分被解决之前解决。在解决这类问题时，关键是多个任务之间如何“握手”，即通过何种方式来通知对方。在Java中有多种方式以及工具可以帮助我们实现这种“握手”。方式比较多，总结了一下，主要如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783003.html#a&quot;&gt;中断和检查中断机制&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783003.html#b&quot;&gt;加入线程(Join)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783003.html#c&quot;&gt;互斥+信号(synchronized、ReentrantLock)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783003.html#d&quot;&gt;利用并发工具包中的构件(CountLatchDown、Cyclicbarrier)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783003.html#e&quot;&gt;共享内存变量(volatile)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783003.html#f&quot;&gt;管道(PipedWriter、PipedReader)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783003.html#g&quot;&gt;通过线程池的一个方法(awaitTermination方法)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1. 中断和检查中断机制&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;利用中断和加入线程(join)属于Thread提供的原生机制，用来实现线程之间的通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关于中断，Java中的线程是通过中断状态来标识，可以通过线程的实例方法interrupt()来设置(该方法内部会调用一个native方法interrupt0()进行设置)。中断状态只是一个状态，并不会直接影响线程的运行，Java中是通过一些间接的方式来达到控制线程的效果，比如：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;检查在循环中断状态，判断是否需要退出线程；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;或者通过对中断状态进行监控，用一旦发现改变就抛出异常这种方式来通知程序；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　我们通过两个实例看一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){        
        Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadCheckInterrupt());
        t.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {        
        }
        t.interrupt();        
    }
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadCheckInterrupt &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{        
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.out.println(&lt;/span&gt;&quot;thread start --&quot; +&lt;span&gt; System.currentTimeMillis());
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;Thread.interrupted()) {
            }
            System.out.println(&lt;/span&gt;&quot;thread interrupt -- &quot; +&lt;span&gt; System.currentTimeMillis());
        }        
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 输出结果
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
thread start &lt;/span&gt;--1556775343297&lt;span&gt;
thread interrupt &lt;/span&gt;-- 1556775343407
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;上面的例子中，主线程启动子线程t，子线程进入循环，判断条件是!Thread.interrupted()，每次循环开始都检查一下中断状态，如果中断状态被设置了，则退出循环，这就是检查中断状态机制，这里例子中是在主线程中调用子线程的interrupt()方法来设置子线程中断状态的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadInterruptDemo());
        t.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {        
        }
        t.interrupt();        
    }
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadInterruptDemo &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                System.out.println(&lt;/span&gt;&quot;interrupt works&quot;&lt;span&gt;);
            }
        }       
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 输出结果
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
 interrupt works&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在这个例子中，主线程仍然开启一个子线程，主线程休眠100ms，子线程休眠1000ms，确保主线程能够在子线程休眠时设置其中断状态，以触发中断异常的抛出。这种通过中断来触发异常来通知程序的方式即是Java中的中断机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在调用&lt;strong&gt;wait()&lt;/strong&gt;、&lt;strong&gt;sleep()&lt;/strong&gt;、&lt;strong&gt;join()&lt;/strong&gt;等方法导致的线程阻塞期间，如果有其他线程调用了该线程的interrupt()来中断该线程，则会导致前面这种阻塞状态停止，抛出InterruptedException异常，并且其中断状态会复原。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. 加入线程(Join)&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;join()方法也是Thread提供的一个实例方法，提供了一个类似线程之间等待的效果。一个线程可以调用另一个线程的join()方法，调用之后，该线程将进入等待状态，直到另一个线程执行完毕，该线程才会继续执行，示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        System.out.println(&lt;/span&gt;&quot;main thread start , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
        Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadJoin());
        t.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            t.join();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {}
        System.out.println(&lt;/span&gt;&quot;main thread end , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
    }
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadJoin &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.out.println(&lt;/span&gt;&quot;sub thread start&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                
            }
            System.out.println(&lt;/span&gt;&quot;sub thread end&quot;&lt;span&gt;);
        }
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 输出结果
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
main thread start , time &lt;/span&gt;-- &amp;gt; 1556801790138&lt;span&gt;
sub thread start
sub thread end
main thread end , time &lt;/span&gt;-- &amp;gt; 1556801791138
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;主线程开始之后，启动子线程t，并调用t的join()方法，可以看到，直到子线程执行结束，主线程才继续执行，这就实现了线程之间的等待效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　join()方法也有带参数的重载版本，可以指定等待的时间，即使当超过指定时间等待的线程仍然没有执行结束，join()方法将返回，不会继续等待。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. 互斥+信号(synchronized、ReentrantLock)&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Java中线程之间的互斥主要是借助于synchronized、ReentrantLock来实现，互斥既可以保证任务之间的串行，也可以保证某一时刻只有一个任务可以响应某个信号。在互斥之上，我们为任务添加了一种途径，可以将其自身挂起，直至某些外部条件发生变化，表示是时候让这个任务向前继续执行。这种握手可以通过Object的方法wait()和notify()来安全地实现，也可以通过Java SE5中并发类库提供的具有await()和signal()方法的Condition对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;通过synchronized实现的互斥和Object提供的wait()、notify()/notifyAll()方法互相配合，可以实现线程之间的等待通知机制。调用wait()、notify()等方法的对象必须为对象锁，且必须在同步块内执行调用。调用wait()方法的线程将进入等待状态，且会释放已经获取的同步锁；调用notify()/notifyAll()方法的线程将会通知处于等待状态的线程，从等待状态切换到准备竞争同步锁，一旦抢到锁则继续从之前等待的地方(即wait()处)执行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; String content;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; String LOCK = &quot;lock&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
                &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(LOCK){
                    content &lt;/span&gt;= &quot;hello world&quot;&lt;span&gt;;
                    LOCK.notifyAll();
                }
            } 
        }.start();

        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(LOCK){
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(content == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    LOCK.wait();
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println(content.toUpperCase());
            }
        }
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;
HELLO WORLD
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;而ReentrantLock提供的互斥是和其内部类Condition提供的await()、signal()相配合来实现线程之间的等待通知机制。与上面一样，await()、signal()方法必须在获取锁的情况下才能够调用，否则会抛出异常。Condition实例对象通过ReentrantLock对象获取。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReentrantLockCondition {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition c =&lt;span&gt; lock.newCondition();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;main thread start , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
        Thread sub &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConditionTest());
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            lock.lock();&lt;br/&gt;　　　　　　　sub.start();
            c.await();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
        System.out.println(&lt;/span&gt;&quot;main thread end , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
    }
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConditionTest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.out.println(&lt;/span&gt;&quot;sub thread start , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                lock.lock();
                Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
                c.signal();
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e) {
                
            }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                lock.unlock();
            }
            System.out.println(&lt;/span&gt;&quot;sub thread end , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
        }
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 输出结果
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
main thread start , time &lt;/span&gt;-- &amp;gt; 1556883481141&lt;span&gt;
sub thread start , time &lt;/span&gt;-- &amp;gt; 1556883481141&lt;span&gt;
sub thread end , time &lt;/span&gt;-- &amp;gt; 1556883482141&lt;span&gt;
main thread end , time &lt;/span&gt;-- &amp;gt; 1556883482141
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如上，主线程获取锁，启动子线程，并调用await()方法进入阻塞状态，并释放锁，这时子线程会获取锁，休眠1s之后调用signal()方法通知主线程，子线程释放锁之后，主线程可以获取锁，获取成功之后继续执行。所以结果是先有主线程启动的日志，然后是子线程启动和结束的日志，最后则是主线程结束的日志。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4. 利用并发工具包中的构件(CountLatchDown、CyclicBarrier)&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;java.util.concurrent包在JDK1.5之后引入了大量用来解决并发问题的新类，比如CountDownLatch、CyclicBarrier等，各有自己的特点，我们仍然看一些例子：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.1 CountLatchDown&lt;/h3&gt;
&lt;p&gt;　　它可以用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成，用法入下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDownLatchSimpleDemo {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CountDownLatch c = &lt;span&gt;new&lt;/span&gt; CountDownLatch(2&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;main thread start , time -&amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
        Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Count());
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Count());
        t1.start();
        t2.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            c.await();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;main thread end , time -&amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
    }
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Count &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id = counter++&lt;span&gt;;
        
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.out.println(&lt;/span&gt;&quot;thread &quot; + id + &quot; start , time -&amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e) {
                
            }
            System.out.println(&lt;/span&gt;&quot;thread &quot; + id + &quot; end , time -&amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
            c.countDown();
        }
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 输出结果
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
main thread start , time &lt;/span&gt;-&amp;gt; 1557065917966&lt;span&gt;
thread &lt;/span&gt;0 start , time -&amp;gt; 1557065917968&lt;span&gt;
thread &lt;/span&gt;1 start , time -&amp;gt; 1557065917968　　&lt;span&gt;
thread &lt;/span&gt;0 end , time -&amp;gt; 1557065918968&lt;span&gt;
thread &lt;/span&gt;1 end , time -&amp;gt; 1557065918968&lt;span&gt;
main thread end , time &lt;/span&gt;-&amp;gt; 1557065918968
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;主线程启动两个子线程，然后调用await()方法之后进入等待状态，两个子线程启动之后会调用CountDownLatch的countDown()方法，总共调用了两次，就将CountDownLatch对象初始化时指定的计数2消去，这时候主线程就会从等待状态中被唤醒，继续执行。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.2 CyclicBarrier&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;这个东西江湖人称&lt;strong&gt;栅栏&lt;/strong&gt;，可以协调多个线程一起运行，实现类似多个线程都达到某个状态之后再继续运行的效果。实现机制简单介绍下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;首先将要参与的线程初始化；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用await()方法的线程将会进入等待状态；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;直到指定数量的线程都调用了await()方法，之前处于等待状态的线程才会从调用await()处继续执行；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CyclicBarrierSimpleDemo {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger id = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger count = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CyclicBarrier barrier = &lt;span&gt;new&lt;/span&gt; CyclicBarrier(2, ()-&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count.get() &amp;gt; 2&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        count.incrementAndGet();
        System.out.println(&lt;/span&gt;&quot;barrier trip &quot; +&lt;span&gt; count.get());
        }
    );
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubTask());
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubTask());
        t1.start();
        t2.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;500&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e) {
            
        }
        t1.interrupt();
        t2.interrupt();
    }
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SubTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; threadId =&lt;span&gt; id.getAndIncrement();
        
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;Thread.interrupted()) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;thread &quot; + threadId + &quot; play&quot;&lt;span&gt;);
                    barrier.await();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    System.out.println(&lt;/span&gt;&quot;thread &quot; + threadId + &quot; interrupt&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&lt;/span&gt;&quot;thread &quot; + threadId + &quot; end&quot;&lt;span&gt;);
        }
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * 运行结果
  *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
thread &lt;/span&gt;0&lt;span&gt; play
thread &lt;/span&gt;1&lt;span&gt; play
barrier trip &lt;/span&gt;1&lt;span&gt;
thread &lt;/span&gt;1&lt;span&gt; play
thread &lt;/span&gt;0&lt;span&gt; play
barrier trip &lt;/span&gt;2&lt;span&gt;
thread &lt;/span&gt;1&lt;span&gt; play
thread &lt;/span&gt;0&lt;span&gt; play
barrier trip &lt;/span&gt;3&lt;span&gt;
thread &lt;/span&gt;1&lt;span&gt; play
thread &lt;/span&gt;0&lt;span&gt; play
thread &lt;/span&gt;0&lt;span&gt; interrupt
thread &lt;/span&gt;1 interrupt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如上是一个简单的demo，主线程会启动两个子线程，子线程会调用CyclicBarrier的await()方法，从上面输出结果可以看出，子线程之间会互相等待，执行一次，越过一次栅栏。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5. 共享内存变量(volatile)&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;volatile关键字可以保证可见性和有序性，这里也是利用其可见性来实现线程之间的通信的，因为被volatile修饰的变量一旦发生变化，对其它线程是可见的。通过监控某个共享变量，当其状态发生改变时，就可以认为是收到别的线程的信号了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VolatileDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; index = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread sub &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubThread());
        sub.start();
        System.out.println(&lt;/span&gt;&quot;main thread notify sub thread , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e) {            
        }
        index &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; SubThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        System.out.println(&lt;/span&gt;&quot;sub thread start , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;VolatileDemo.index) {
        }
        System.out.println(&lt;/span&gt;&quot;sub thread end , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 运行结果
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
main thread notify sub thread , time &lt;/span&gt;-- &amp;gt; 1557145592276&lt;span&gt;
sub thread start , time &lt;/span&gt;-- &amp;gt; 1557145592276&lt;span&gt;
sub thread end , time &lt;/span&gt;-- &amp;gt; 1557145592477
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如上面的例子，线程一直监控共享变量index，当主线程将index改为true时，子线程可以马上监控到，就可以退出while循环了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6. 管道(PipedWriter、PipedReader)&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;通过IO阻塞的方式，我们也能实现线程之间的通信：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PipeNotifyDemo {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        PipedWriter writer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PipedWriter();
        PipedReader reader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PipedReader();
        writer.connect(reader);
        
        Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;writer running&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 5 ; i++&lt;span&gt;) {
                    writer.write(i);
                    Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                e.printStackTrace();
            }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    writer.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&lt;/span&gt;&quot;writer ending&quot;&lt;span&gt;);
        });
        
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;reader running&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; message = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((message = reader.read()) != -1&lt;span&gt;) {
                    System.out.println(&lt;/span&gt;&quot;message = &quot; + message + &quot; , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
                }
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e) {
            }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    reader.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&lt;/span&gt;&quot;reader ending&quot;&lt;span&gt;);
        });
        
        t1.start();
        t2.start();
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 输出结果
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
reader running
writer running
message &lt;/span&gt;= 0 , time -- &amp;gt; 1557148872499&lt;span&gt;
message &lt;/span&gt;= 1 , time -- &amp;gt; 1557148872499&lt;span&gt;
message &lt;/span&gt;= 2 , time -- &amp;gt; 1557148873499&lt;span&gt;
message &lt;/span&gt;= 3 , time -- &amp;gt; 1557148875499&lt;span&gt;
message &lt;/span&gt;= 4 , time -- &amp;gt; 1557148875499&lt;span&gt;
writer ending
reader ending&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;线程2源源不断收到线程1写入的数据。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;7. 通过线程池的一个方法(awaitTermination方法)&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;线程池中有一个方法awaitTermination()方法，可以用来判断调用线程池的shutdown()方法之后，线程池中的线程是否执行完毕。因为shutdown()方法是不会阻塞的，调用之后线程池不会接受新任务，但是已有的任务会继续执行，所以通过awaitTermination方法来判断是否存在还在执行的任务，这也算是一种线程之前的通信吧。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolNotifyDemo {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        ExecutorService exec &lt;/span&gt;=&lt;span&gt; Executors.newCachedThreadPool();
        exec.execute(()&lt;/span&gt;-&amp;gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;thread1 running&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        exec.execute(()&lt;/span&gt;-&amp;gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;thread2 running&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        exec.shutdown();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!exec.awaitTermination(1&lt;span&gt;, TimeUnit.SECONDS)) {
            System.out.println(&lt;/span&gt;&quot;thread in thread pool is still running , time -- &amp;gt; &quot; +&lt;span&gt; System.currentTimeMillis());
        }
        System.out.println(&lt;/span&gt;&quot;main thread over&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 输出结果
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
thread1 running
thread2 running
thread in thread pool is still running , time &lt;/span&gt;-- &amp;gt; 1557150326140&lt;span&gt;
thread in thread pool is still running , time &lt;/span&gt;-- &amp;gt; 1557150327141&lt;span&gt;
main thread over&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;8. 总结   &lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;关于线程间通信的方法五花八门，本文只是罗列了一下，如果不正确，还请指正。话说这会儿还在上班的卧铺车厢上写博客呢。。。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 13:58:00 +0000</pubDate>
<dc:creator>木瓜芒果</dc:creator>
<og:description>线程通信机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volcano-liu/p/10783003.html</dc:identifier>
</item>
<item>
<title>机器学习——Java调用sklearn生成好的Logistic模型进行鸢尾花的预测 - Baby-Lily</title>
<link>http://www.cnblogs.com/baby-lily/p/10822048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baby-lily/p/10822048.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　机器学习是python语言的长处，而Java在web开发方面更具有优势，如何通过java来调用python中训练好的模型进行在线的预测呢？在java语言中去调用python构建好的模型主要有三种方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1.在Java语言中，通过python的解释器执行python代码，简单来说就是在java中通过python解释器对象，传入写好的python代码，进行执行，这样的方式运行的效率非常低，而且存在很多python包无法使用的情况，只适合做简单的python代码的运行，并不推荐使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.通过PMML工具，将在sklearn中训练好的模型生成一个pmml格式的文件，在该文件中，主要包含了模型的一些训练好的参数，以及输入数据的格式和名称等信息。生成了pmml文件之后，在java中导入pmml相关的包，我们就能通过pmml相关的类读取生成的pmml文件，使用其中的方法传入指定的参数就能实现模型的预测，速度快，效果不错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.第二种方法因为模型已经训练好了，无法改变，不能实现在线调参的功能，我们可以通过socket服务来进行python和java之间的网络通信，python提供socket服务，java端将模型的参数通过网络传给python端，python端接受到参数之后，进行模型的训练，训练完成之后，将得到的结果返回给Java端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;下面给是使用pmml方式调用的步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.在python端生成pmml模型文件，下面以logistic回归为例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    x_train, x_test, y_train, y_test = train_test_split(x, y, train_size=0.85, random_state=1&lt;span&gt;)
    model &lt;/span&gt;= PMMLPipeline([(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LogisticModer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, LogisticRegression())])
    model.fit(x_train, y_train)
    y_hat &lt;/span&gt;=&lt;span&gt; model.predict(x_test)
    loss &lt;/span&gt;= y_hat ==&lt;span&gt; y_test
    accuracy &lt;/span&gt;=&lt;span&gt; np.mean(loss)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(accuracy)
    sklearn2pmml(model, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.\LogisticRegression.pmml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, with_repr=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　需要加载的包&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn2pmml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sklearn2pmml
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn2pmml.pipeline &lt;span&gt;import&lt;/span&gt; PMMLPipeline
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们使用PMMLPipeline()的管道函数，还可以在管道中加入其它的一些预处理的操作，比如归一化。sklearn2pmml()函数能够将训练好的模型生成pmml文件，下面来看生成的pmml文件是怎样的吧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190506211413234-1373176357.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;554&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190506211546496-684849823.png&quot; alt=&quot;&quot; width=&quot;738&quot; height=&quot;447&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面，我们建一个JavaWeb工程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt; 2&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.jpmml&amp;lt;/groupId&amp;gt;
&lt;span&gt; 3&lt;/span&gt;             &amp;lt;artifactId&amp;gt;pmml-evaluator&amp;lt;/artifactId&amp;gt;
&lt;span&gt; 4&lt;/span&gt;             &amp;lt;version&amp;gt;1.4.1&amp;lt;/version&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt; 9&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.jpmml&amp;lt;/groupId&amp;gt;
&lt;span&gt;10&lt;/span&gt;             &amp;lt;artifactId&amp;gt;pmml-evaluator-extension&amp;lt;/artifactId&amp;gt;
&lt;span&gt;11&lt;/span&gt;             &amp;lt;version&amp;gt;1.4.1&amp;lt;/version&amp;gt;
&lt;span&gt;12&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;13&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在maven中引入相关的依赖，我们将要用到的方法进行封装，制作成一个工具类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; PMML getPMMLModel(InputStream inputStream) {
        PMML pmml &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PMML();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            pmml &lt;/span&gt;=&lt;span&gt; org.jpmml.model.PMMLUtil.unmarshal(inputStream);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SAXException e1) {
            e1.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JAXBException e2) {
            e2.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                inputStream.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pmml;
        }
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Evaluator loadPmmlAndgetEvaluator(MachineLearnType machineLearnType) {

            String modefile &lt;/span&gt;= getJpmmlModelPath(machineLearnType);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取模型的pmml文件路径&lt;/span&gt;
&lt;span&gt;
            InputStream inputStream &lt;/span&gt;= readPmmlFile(modefile);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据文件路径返回输入流&lt;/span&gt;
&lt;span&gt;
            PMML pmml &lt;/span&gt;= getPMMLModel(inputStream);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据输入流返回PMML&lt;/span&gt;
&lt;span&gt;
            ModelEvaluatorFactory modelEvaluatorFactory &lt;/span&gt;= ModelEvaluatorFactory.newInstance();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 ModelEvaluatorFactory&lt;/span&gt;
&lt;span&gt;
            Evaluator evaluator &lt;/span&gt;= modelEvaluatorFactory.newModelEvaluator(pmml);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 PMML 模型返回 Evaluator 对象&lt;/span&gt;
&lt;span&gt;
            pmml &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; evaluator;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; modelPrediction(Evaluator evaluator, Map&amp;lt;String, Object&amp;gt;&lt;span&gt; paramData) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (evaluator == &lt;span&gt;null&lt;/span&gt; || paramData == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;--------------传入对象 evaluator 或 dataMap 为空, 无法进行预测----------------&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        List&lt;/span&gt;&amp;lt;InputField&amp;gt; inputFields = evaluator.getInputFields();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取模型的输入域&lt;/span&gt;
        Map&amp;lt;FieldName, FieldValue&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (InputField inputField : inputFields) {            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将参数通过模型对应的名称进行添加&lt;/span&gt;
            FieldName inputFieldName = inputField.getName();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取模型中的参数名&lt;/span&gt;
            Object paramValue = paramData.get(inputFieldName.getValue());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取模型参数名对应的参数值&lt;/span&gt;
            FieldValue fieldValue = inputField.prepare(paramValue);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将参数值填入模型中的参数中&lt;/span&gt;
            arguments.put(inputFieldName, fieldValue);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放在map列表中&lt;/span&gt;
&lt;span&gt;        }
        Map&lt;/span&gt;&amp;lt;FieldName, ?&amp;gt; results =&lt;span&gt; evaluator.evaluate(arguments);
        List&lt;/span&gt;&amp;lt;TargetField&amp;gt; targetFields =&lt;span&gt; evaluator.getTargetFields();

        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; resultMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(TargetField targetField : targetFields) {
            FieldName targetFieldName &lt;/span&gt;=&lt;span&gt; targetField.getName();
            Object targetFieldValue &lt;/span&gt;=&lt;span&gt; results.get(targetFieldName);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (targetFieldValue &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Computable) {
                Computable computable &lt;/span&gt;=&lt;span&gt; (Computable) targetFieldValue;
                resultMap.put(targetFieldName.getValue(), computable.getResult());
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                resultMap.put(targetFieldName.getValue(), targetFieldValue);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上述的方法中，我们将生成的pmml文件读取，得到InputStream对象，调用上述的方法就行了。上面的代码中，MachineLearnType的作用就是获取pmml的路径，我们将要输入的参数放入Map中，进行预测，最后返回预测结果的Map，下面来看Service层的代码，其中&lt;/span&gt;MachineLearnType.LOGISTIC_REGRESSION就是根据名称获取pmml文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Evaluator evaluator =&lt;span&gt; JPmmlModelUtil.loadPmmlAndgetEvaluator(MachineLearnType.LOGISTIC_REGRESSION);
Map&lt;/span&gt;&amp;lt;String , Object&amp;gt; results =&lt;span&gt; JPmmlModelUtil.modelPrediction(evaluator, paramMap);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =(&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;double&lt;/span&gt;)results.get(&quot;y&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　下面是Controller层的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　/**&lt;/span&gt;&lt;span&gt;
     * 使用pmml方式对输入的参数进行线性回归预测
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @PostMapping(&lt;/span&gt;&quot;/logispmml&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServerResponse&amp;lt;String&amp;gt; IrisLogosPmmlPredict(@RequestParam @Valid &lt;span&gt;double&lt;/span&gt;&lt;span&gt; x1,
                                                         @RequestParam @Valid &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x2,
                                                         @RequestParam @Valid &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x3,
                                                         @RequestParam @Valid &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x4) {
        logger.info(&lt;/span&gt;&quot;x1: &quot; + x1 + &quot; x2: &quot; + x2 + &quot; x3:&quot; + x3 + &quot;x4:&quot; +&lt;span&gt; x4);
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; paramMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        paramMap.put(&lt;/span&gt;&quot;x1&quot;&lt;span&gt;, x1);
        paramMap.put(&lt;/span&gt;&quot;x2&quot;&lt;span&gt;, x2);
        paramMap.put(&lt;/span&gt;&quot;x3&quot;&lt;span&gt;, x3);
        paramMap.put(&lt;/span&gt;&quot;x4&quot;&lt;span&gt;, x4);
        String result &lt;/span&gt;=&lt;span&gt; logisticRegressionService.pridictlogisticpmml(paramMap);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createBySuccess(result);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们生成的模型是logistic回归进行鸢尾花数据集的分类，输入的是样本的四个特征，输出是类别0,1,2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; result =(&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;double&lt;/span&gt;)results.get(&quot;y&quot;&lt;span&gt;));
String irisName &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String();
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result == 0&lt;span&gt;){
    irisName &lt;/span&gt;= &quot;Iris-setosa&quot;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result == 1&lt;span&gt;){
    irisName &lt;/span&gt;= &quot;Iris-versicolor&quot;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result == 2&lt;span&gt;){
    irisName &lt;/span&gt;= &quot;Iris-virginica&quot;&lt;span&gt;;
}
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; irisName;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们在service中将预测结果转换为对应的类别，下面使用测试工具进行测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190506213209241-204206337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190506213253570-150228515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们就可以在python中将模型构建好，来进行调用啦！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 06 May 2019 13:52:00 +0000</pubDate>
<dc:creator>Baby-Lily</dc:creator>
<og:description>Java调用sklearn生成好的Logistic模型进行鸢尾花的预测，机器学习是python语言的长处，而Java在web开发方面更具有优势，如何通过java来调用python中训练好的模型进行在线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baby-lily/p/10822048.html</dc:identifier>
</item>
</channel>
</rss>