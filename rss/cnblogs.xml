<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小白学 Python 爬虫（7）：HTTP 基础 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11955593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11955593.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191129084423814-1399324186.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/13/3303836941/&quot;&gt;小白学 Python 爬虫（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/20/2586166930/&quot;&gt;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/21/1005563697/&quot;&gt;小白学 Python 爬虫（3）：前置准备（二）Linux基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/22/3679472340/&quot;&gt;小白学 Python 爬虫（4）：前置准备（三）Docker基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/24/334078215/&quot;&gt;小白学 Python 爬虫（5）：前置准备（四）数据库基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/25/1881661601/&quot;&gt;小白学 Python 爬虫（6）：前置准备（五）爬虫框架的安装&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;网络的起源&quot;&gt;网络的起源&lt;/h2&gt;
&lt;p&gt;这个其实是一个冷知识，各位同学可以猜测一下计算机网络的起源是在哪里。&lt;/p&gt;
&lt;p&gt;硅谷？大学？实验室？有点接近了，但还不够准确。&lt;/p&gt;
&lt;p&gt;准确的答案是在美苏冷战背景下的&lt;strong&gt;美国国防部&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;对的，你没看错，是&lt;strong&gt;美国军方&lt;/strong&gt; ，最先进的技术总是先应用于军事领域，随着时间的推移才会慢慢的民用化。&lt;/p&gt;
&lt;p&gt;1968年，在美国国防部高级计划局的领导下，阿帕网（ ARPANET ）诞生了。&lt;/p&gt;
&lt;p&gt;ARPANET只有四个节点，连接起加利福尼亚州大学洛杉矶分校、加州大学圣巴巴拉分校、斯坦福大学、犹他州大学这四所学校的大型计算机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阿帕网&lt;/strong&gt; ，是全球公认的计算机网络的始祖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191129084427620-1213217769.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;uri-url-和-urn&quot;&gt;URI 、 URL 和 URN&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;爬虫是一个模拟浏览器进行 HTTP 请求的过程。这就需要我们了解从浏览器输入 URL 到获取到网页中间究竟发生了什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先介绍一组概念， URI 和 URL ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;URI = Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。&lt;/li&gt;
&lt;li&gt;URL = Universal Resource Locator 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol、host、port、path、parameter、anchor。&lt;/li&gt;
&lt;li&gt;URN = Universal Resource Name 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191129084427870-1471837817.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没看懂是吧，没事儿，不需要懂，了解一下就好了，我们来举例子。&lt;/p&gt;
&lt;p&gt;比如上面这张图片的地址：&lt;a href=&quot;https://cdn.geekdigging.com/python-spider/uri-url-urn.png&quot; class=&quot;uri&quot;&gt;https://cdn.geekdigging.com/python-spider/uri-url-urn.png&lt;/a&gt; ，它是一个 URL 同时也是一个 URI ， URL 是 URI 的子集，也就是说每个 URL 都是 URI ，但不是每个 URI 都是 URL ，因为 URI 还包括一个子类叫 URN 。在目前的网络中 URN 的使用非常少，所以几乎所有的 URI 都是 URL ，一般的网页链接我们既可以称为 URL ，也可以称为 URI ，完全看个人喜好。&lt;/p&gt;
&lt;h2 id=&quot;超文本&quot;&gt;超文本&lt;/h2&gt;
&lt;p&gt;什么是超文本？&lt;/p&gt;
&lt;p&gt;超文本是指可以链接到另一个文档或文本的单词，短语或大块文本。超文本涵盖了文本超链接和图形超链接。&lt;/p&gt;
&lt;p&gt;我们在浏览器中访问的网页是由 HTML 编写而成，而 HTML 则被称作为“超文本标记语言”。在 HTML 代码中，包含了一系列的标签，包括图片等的超链接。&lt;/p&gt;
&lt;p&gt;我们来看一下一个真实的网站的源代码是怎么样的，在 Chrome 浏览器中，使用 F12 打开开发者工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191129084430334-618179885.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;http-和-https&quot;&gt;HTTP 和 HTTPS&lt;/h2&gt;
&lt;p&gt;什么是 HTTP ？&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么是HTTPS？&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。&lt;/p&gt;
&lt;p&gt;PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在越来越多的网站和App都已经向HTTPS方向发展，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;苹果公司强制所有iOS App在2017年1月1日前全部改为使用HTTPS加密，否则App就无法在应用商店上架；&lt;/li&gt;
&lt;li&gt;谷歌从2017年1月推出的Chrome 56开始，对未进行HTTPS加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户“此网页不安全”；&lt;/li&gt;
&lt;li&gt;腾讯微信小程序的官方需求文档要求后台使用HTTPS请求进行网络通信，不满足条件的域名和协议无法请求。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;http协议&quot;&gt;HTTP协议&lt;/h2&gt;
&lt;p&gt;HTTP 协议本身是非常简单的。它规定，只能由客户端主动发起请求，服务器接收请求处理后返回响应结果，同时 HTTP 是一种无状态的协议，协议本身不记录客户端的历史请求记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191129084430822-411915201.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了比较直观的展示这个过程，我们依然打开 Chrome 浏览器，按 F12 开启开发者模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191129084432175-1512575631.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看第一行，www.geekdigging.com 那一行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Name：请求的名称。&lt;/li&gt;
&lt;li&gt;Status：状态码， 200 代表正常响应。&lt;/li&gt;
&lt;li&gt;Type：文旦类型，这里我们是请求了一个 HTML 文档。&lt;/li&gt;
&lt;li&gt;Initiator：请求源。用来标记请求是由哪个对象或进程发起的。&lt;/li&gt;
&lt;li&gt;Size：资源大小，这个标识了我们请求的资源的大小。&lt;/li&gt;
&lt;li&gt;Time：消耗的时间，单位是 ms 。&lt;/li&gt;
&lt;li&gt;Watefall：网络请求的可视化瀑布流。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们点击一下那一行，可以看到更加详细的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191129084433164-702859309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;包含了 Header 头信息， Preview （Response Preview） 响应信息预览， Response 响应具体的 HTML 代码， Cookies ，Timing 整个请求周期耗时。&lt;/p&gt;
&lt;p&gt;General部分： Request URL 为请求的URL， Request Method 为请求的方法， Status Code 为响应状态码， Remote Address 为远程服务器的地址和端口， Referrer Policy 为Referrer判别策略。&lt;/p&gt;
&lt;h2 id=&quot;request-请求&quot;&gt;Request 请求&lt;/h2&gt;
&lt;p&gt;一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191129084433357-1385374270.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;请求行&quot;&gt;请求行&lt;/h3&gt;
&lt;p&gt;分为三个部分：请求方法、请求地址URL和HTTP协议版本，它们之间用空格分割。&lt;/p&gt;
&lt;p&gt;例如，GET /index.html HTTP/1.1。&lt;/p&gt;
&lt;p&gt;HTTP/1.1 定义的请求方法有8种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GET ：请求页面，并返回页面内容。&lt;/li&gt;
&lt;li&gt;POST ：大多用于提交表单或上传文件，数据包含在请求体中。&lt;/li&gt;
&lt;li&gt;PUT ：从客户端向服务器传送的数据取代指定文档中的内容。&lt;/li&gt;
&lt;li&gt;DELETE ：请求服务器删除指定的页面。&lt;/li&gt;
&lt;li&gt;PATCH ：是对 PUT 方法的补充，用来对已知资源进行局部更新 。&lt;/li&gt;
&lt;li&gt;HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。&lt;/li&gt;
&lt;li&gt;OPTIONS：允许客户端查看服务器的性能。&lt;/li&gt;
&lt;li&gt;TRACE：回显服务器收到的请求，主要用于测试或诊断。&lt;/li&gt;
&lt;li&gt;CONNECT ：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用的有 GET 和 POST 。&lt;/p&gt;
&lt;h4 id=&quot;get&quot;&gt;GET&lt;/h4&gt;
&lt;p&gt;在浏览器中直接输入URL并回车，这就发起了一个 GET 请求，请求的参数会直接包含在 URL 里，请求参数和对应的值附加在URL后面，利用一个问号 &lt;code&gt;?&lt;/code&gt; 代表URL的结尾与请求参数的开始，传递参数长度受限制。由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。&lt;/p&gt;
&lt;h4 id=&quot;post&quot;&gt;POST&lt;/h4&gt;
&lt;p&gt;允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。&lt;/p&gt;
&lt;h3 id=&quot;请求头&quot;&gt;请求头&lt;/h3&gt;
&lt;p&gt;因为请求行所携带的信息量非常有限，以至于客户端还有很多想向服务器要说的事情不得不放在请求首部（Header），请求首部用于给服务器提供一些额外的信息，比如 User-Agent 用来表明客户端的身份，让服务器知道你是来自浏览器的请求还是爬虫，是来自 Chrome 浏览器还是 FireFox。HTTP/1.1 规定了47种首部字段类型。 HTTP 首部字段的格式很像 Python 中的字典类型，由键值对组成，中间用冒号隔开。&lt;/p&gt;
&lt;p&gt;下面简要说明一些常用的头信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Accept：请求报头域，用于指定客户端可接受哪些类型的信息。&lt;/li&gt;
&lt;li&gt;Accept-Language：指定客户端可接受的语言类型。&lt;/li&gt;
&lt;li&gt;Accept-Encoding：指定客户端可接受的内容编码。&lt;br/&gt;Host：用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置。从HTTP 1.1版本开始，请求必须包含此内容。&lt;/li&gt;
&lt;li&gt;Cookie：也常用复数形式 Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。&lt;/li&gt;
&lt;li&gt;Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如作来源统计、防盗链处理等。&lt;/li&gt;
&lt;li&gt;User-Agent：简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。&lt;/li&gt;
&lt;li&gt;Content-Type：也叫互联网媒体类型（Internet Media Type）或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。例如，text/html代表HTML格式，image/gif代表GIF图片，application/json代表JSON类型，更多对应关系可以查看此对照表：&lt;a href=&quot;http://tool.oschina.net/commons&quot; class=&quot;uri&quot;&gt;http://tool.oschina.net/commons&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;请求数据&quot;&gt;请求数据&lt;/h3&gt;
&lt;p&gt;请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空。&lt;/p&gt;
&lt;p&gt;注意这里提交数据的方式和请求头设置的 Content-Type 息息相关。&lt;/p&gt;
&lt;h2 id=&quot;response-响应&quot;&gt;Response 响应&lt;/h2&gt;
&lt;p&gt;服务端接收请求并处理后，返回响应内容给客户端，同样地，响应内容也必须遵循固定的格式浏览器才能正确解析。HTTP 响应也由3部分组成，分别是：响应行、响应首部、响应体，与 HTTP 的请求格式是相对应的。&lt;/p&gt;
&lt;h3 id=&quot;响应行&quot;&gt;响应行&lt;/h3&gt;
&lt;p&gt;响应行同样也是3部分组成，由服务端支持的 HTTP 协议版本号、状态码、以及对状态码的简短原因描述组成。&lt;/p&gt;
&lt;h4 id=&quot;状态码&quot;&gt;状态码&lt;/h4&gt;
&lt;p&gt;响应状态码表示服务器的响应状态，常见的如200代表服务器正常响应，404代表页面未找到，500代表服务器内部发生错误。&lt;/p&gt;
&lt;h4 id=&quot;响应头&quot;&gt;响应头&lt;/h4&gt;
&lt;p&gt;响应头包含了服务器对请求的应答信息，如Content-Type、Server、Set-Cookie等。下面简要说明一些常用的头信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Date：标识响应产生的时间。&lt;/li&gt;
&lt;li&gt;Last-Modified：指定资源的最后修改时间。&lt;/li&gt;
&lt;li&gt;Content-Encoding：指定响应内容的编码。&lt;/li&gt;
&lt;li&gt;Server：包含服务器的信息，比如名称、版本号等。&lt;/li&gt;
&lt;li&gt;Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。&lt;/li&gt;
&lt;li&gt;Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。&lt;/li&gt;
&lt;li&gt;Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;响应体&quot;&gt;响应体&lt;/h4&gt;
&lt;p&gt;最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码；请求一张图片时，它的响应体就是图片的二进制数据。&lt;/p&gt;
&lt;p&gt;在做爬虫时，我们主要通过响应体得到网页的源代码、JSON数据等，然后从中做相应内容的提取。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/koflance/article/details/79635240&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/koflance/article/details/79635240&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xiaoming100001/article/details/81109617&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/xiaoming100001/article/details/81109617&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cuiqingcai.com/5465.html&quot; class=&quot;uri&quot;&gt;https://cuiqingcai.com/5465.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ailunlee/article/details/90600174&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/ailunlee/article/details/90600174&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Nov 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 前文传送门： '小白学 Python 爬虫（1）：开篇' '小白学 Python 爬虫（2）：前置准备（一）基本类库的安装' '小白学 Python 爬虫（3）：前置准备</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11955593.html</dc:identifier>
</item>
<item>
<title>Maven入门【小白千万别点进】 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11930017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11930017.html</guid>
<description>&lt;p&gt;曾经有个女孩问我为什么要学Maven，我吧唧嘴就怼：Maven项目没有jar包它不香嘛，照样运行它不香嘛？如果让我一句话形容Maven，我会这样形容：“妈妈再也不用担心小明拿U盘去小红电脑里烤jar包了”，女孩听了瞬间泪崩了：”我其实也是一个中央仓库，以后缺jar包直接来找我，用不着小红”，我顿时有点受宠若惊~小鹿乱撞~。&lt;/p&gt;
&lt;p&gt;进入正题，其实进行框架开发的时候难免会遇到一个叫Maven的鬼东西，&lt;span&gt;&lt;strong&gt;重点强调&lt;/strong&gt;&lt;/span&gt;一下这个读“ 妹文 ”，而不是什么“ 马文 ”或者什么“ 妈瘟”什么瘟的，读的跟闹瘟疫似的。我觉得会读了之后，你基本上就掌握了Maven一半了，不要觉得夸张，因为Maven真的很好学（会读掌握一半还是有点夸张），总得比一些学加用好几个月还天天读“ 妈瘟”的强多了。好了不扯犊子了，直接上干货！&lt;/p&gt;
&lt;h2 id=&quot;什么是-maven&quot;&gt;什么是 Maven&lt;/h2&gt;
&lt;p&gt;一个老哥对 Maven 比较正式的定义是这么说的：Maven 是一个项目管理工具，它包含了一个项目对象模型，一组标准集合，一个项目生命周期，一个依赖管理系统，和用来运行定义在生命周期阶段中插件目标的逻辑。 我听了当时就笑了，&lt;span&gt;&lt;strong&gt;maven不就一个管理jar包直接上坐标就能自动下载对应jar包的工具&lt;/strong&gt;&lt;/span&gt;嘛，什么罗里吧嗦的定义嘛，装什么装（气势这一方面，我没服过谁），不过，这老哥总结的还真不错，立竿见影，文表齐全，真香！（秒怂~捂脸~）&lt;/p&gt;
&lt;h2 id=&quot;maven-能解决什么问题&quot;&gt;Maven 能解决什么问题&lt;/h2&gt;
&lt;p&gt;这么说吧，我讲几个更通俗的方式来说明，哥几个感受一下：&lt;br/&gt;项目开发不仅仅是写写代码而已，期间会伴随着各种必不可少的事情要做，这个时候，问题就来了&lt;br/&gt;1、我们需要引用各种 jar 包，尤其是比较大的工程，引用的 jar 包往往有几十个乃至上百个， 每用到一种 jar 包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的 jar 包冲突，版本冲突。&lt;/p&gt;
&lt;p&gt;2、我们辛辛苦苦写好了 Java 文件，可是只懂 0 和 1 的白痴电脑却完全读不懂，需要将它编译成二进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA 等都可以将代码即时编译。当然，如果你嫌生命漫长，何不铺张，也可以用记事本来敲代码，然后用 javac 命令一个个地去编译，逗电脑玩。&lt;/p&gt;
&lt;p&gt;3、世界上没有不存在 bug 的代码，计算机喜欢 bug 就和人们总是喜欢美女帅哥一样。为了追求美为了减少 bug，因此写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。&lt;/p&gt;
&lt;p&gt;4、再优雅的代码也是要出来卖的。我们后面还需要把代码与各种配置文件、资源整合到一起，定型打包，如果是 web 项目，还需要将之发布到服务器，供人蹂躏。试想，如果现在有一种工具，可以把你从上面的繁琐工作中解放出来，能帮你构建工程，管理 jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站点，你会心动吗？&lt;/p&gt;
&lt;p&gt;好了，说的不多，但实际上Maven 就可以解决上面所提到的这些问题。&lt;/p&gt;
&lt;h2 id=&quot;maven项目没有jar包它不香嘛照样运行它不香嘛&quot;&gt;Maven项目没有jar包它不香嘛，照样运行它不香嘛？&lt;/h2&gt;
&lt;p&gt;首先，我证明一下Maven项目中确实没有具体jar包&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190912115528111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;经过我严密整段并运用大量高数分析并花了半个小时，推断它里面一定没有 jar 包！不然它怎么可能这么小，才100来Kb，佩奇都能看出来~&lt;/p&gt;
&lt;h2 id=&quot;学maven必须要知道的&quot;&gt;学maven必须要知道的&lt;/h2&gt;
&lt;p&gt;Maven 的一个&lt;span&gt;核心特性就是依赖管理&lt;/span&gt;，而依赖管理明了的说就是一个&lt;span&gt;管理jar包的过程&lt;/span&gt;，既然maven项目不需要具体的jar包，那是怎么可以运行的呢？其实简单来说，一个Maven项目关于jar包主要看&lt;code&gt;pom.xml&lt;/code&gt; 文件，然后通过&lt;span&gt;坐标&lt;/span&gt;去&lt;span&gt;仓库&lt;/span&gt;找到对应jar包,专业名词听着是不是很不得劲，哈哈&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;坐标&lt;/span&gt; = 公司名/组织名 + 项目名 + 版本号 ，要找某个jar包必须确定坐标&lt;br/&gt;&lt;span&gt;仓库&lt;/span&gt;： 分为本地仓库和远程仓库\中央仓库&lt;br/&gt;&lt;span&gt;本地仓库&lt;/span&gt;：具体自己电脑下载jar包的地方&lt;br/&gt;&lt;span&gt;中央仓库&lt;/span&gt;：联网去网上找jar包的地方&lt;br/&gt;私服： 公司自己的仓库（了解有这么个东西就行）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看图理解可能会更得劲&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190912154503967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;maven根据坐标具体找jar包的流程如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190912155034965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何去中央仓库找jar包坐标并化为本地仓库jar包&quot;&gt;如何去中央仓库找jar包坐标并化为本地仓库jar包？&lt;/h2&gt;
&lt;p&gt;其实很简单，在中央仓库的字典里只要知道要找什么jar包，就能得到什么jar包，具体操作如下：&lt;br/&gt;具体以找spring aop jar包为例子：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190913090728842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190913091156517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190913091430616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;是不是也很简单？get到了嘛~&lt;/p&gt;
&lt;h2 id=&quot;maven的生命周期和命令&quot;&gt;maven的生命周期和命令&lt;/h2&gt;
&lt;p&gt;我觉得，到现在我用了这么久maven都没怎么去使用它的生命周期，所以我觉得也没必要写长篇大论，&lt;strong&gt;了解即可&lt;/strong&gt;（如果你想精通maven，如果你有这个时间和精力也可去找这方面资料深入）&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190912160456603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;到这里，基本上常用的东西已经讲完了，而且我讲的都是重点，maven的重点很少，是不是很简单，当然我讲的也简单。学习其实就是一个化繁为简的过程！&lt;/p&gt;
&lt;h2 id=&quot;maven的下载安装&quot;&gt;maven的下载安装&lt;/h2&gt;
&lt;p&gt;下载：&lt;br/&gt;方法一：maven官网：&lt;a href=&quot;http://maven.apache.org/&quot; class=&quot;uri&quot;&gt;http://maven.apache.org/&lt;/a&gt;&lt;br/&gt;方法二：直接百度maven （推荐！！！不要问我为什么，我就喜欢酱紫，简单粗暴，不搞那些花里胡哨的）&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019091216163167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190912161935360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;至于安装，解压就相当于安装了，一解压就完事了，我感觉maven开发者就是天才，就是像我这样的乡下人，喜欢简单粗暴，不搞那些花里胡哨的！&lt;/p&gt;
&lt;h2 id=&quot;maven-及-jdk-配置了解&quot;&gt;Maven 及 JDK 配置（了解）&lt;/h2&gt;
&lt;p&gt;至于我为啥写了解，是因为看到配置，是不是很烦？觉得烦的哥几个，咋们是亲兄弟啊，我还记得那天下午我特么配了一下午，才配好（而且我流程没问题，还冒出一个特别奇葩的问题，提起就伤心，不提了），后来发现配置好了&lt;strong&gt;到现在都没用上，没什么用&lt;/strong&gt;。。。我建议如果只是单纯的做项目就不搞这花里胡哨的配置了，真的到现在我都没去用那个配置（主要完一些命令的），不配是可以的，只是一点要记住：&lt;span&gt;JDK版本是1.7以上&lt;/span&gt;。如果你非执着要了解怎么配置，那我就告诉你，其实跟配java环境变量差不多，也是java_HOME类似操作（&lt;span&gt;可以不配制，没毛病&lt;/span&gt;），当然你可以说我庸俗，但你绝对不知道“庸俗”也是俺们乡下人的勋章，啊，情怀懂不懂~&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190912163209872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置本地仓库位置&quot;&gt;配置本地仓库位置&lt;/h2&gt;
&lt;p&gt;当然，这个其实也可以不配制，因为idea会默认给你放到C盘，但是像我这样优秀的人，~家贫，C盘空间小~肯定会去配置一下咯，把本地仓库放到D盘或者F盘（各位别任性，还是配置一下吧，万一你系统那一天炸了呐，jar包可就全没了鸭）~&lt;/p&gt;
&lt;p&gt;配置流程：首先打开maven解压好的文件夹----conf----setting.xml打开加上需要配置位置如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190912165004784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用intellij-idea创建第一个mawen项目&quot;&gt;使用IntelliJ IDEA创建第一个Mawen项目&lt;/h2&gt;
&lt;p&gt;没使用IDEA搭建过的哥几个可以了解一下，我在这篇之前写的&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/100204836&quot;&gt;使用IntelliJ IDEA创建第一个Mawen项目&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实战ssm搭建使用maven&quot;&gt;实战ssm搭建使用Maven&lt;/h2&gt;
&lt;p&gt;我在这篇文章中使用idea搭建过ssm框架基于mawen，具体的使用过maven，哥几个可以了解一下&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/100192558&quot;&gt;如何条理清晰思路使用IDEA整合ssm框架（详细思路+附带源码）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里，妈瘟的基本操作就呸呸呸，咳咳妹文的基本操作就OK了，maven基础就算是完美入门了，我讲的都是maven的核心常规操作只为让一些初学者快速入门，当然这还不够，因为还要学习maven的多模块开发，其实也很简单，今天就先到这里了，挥挥爪~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Nov 2019 00:06:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>曾经有个女孩问我为什么要学Maven，我吧唧嘴就怼：Maven项目没有jar包它不香嘛，照样运行它不香嘛？如果让我一句话形容Maven，我会这样形容：“妈妈再也不用担心小明拿U盘去小红电脑里烤jar包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11930017.html</dc:identifier>
</item>
<item>
<title>图文详解应用登录验证码的多种实现方案 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11955523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11955523.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191129075059248-656676051.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在本号的一系列Spring Security文章中，先后介绍了各种登录验证及授权中的知识点，如：spring-security简介并与shiro对比、 formLogin模式登录认证、动态数据登录验证与权限分配、账户多次登录失败锁定、RememberMe记住我功能，等等文章。笔者觉得以上的这些实际上都很简单，我们没有涉及到分布式应用。本节将以分布式的应用背景，讲解验证码实现的多种方式。本小节先从理论的角度为大家讲解，具体实现笔者还会再写。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;session存储验证码，不适用于分布式应用&lt;/li&gt;
&lt;li&gt;共享session存储验证码，适用于分布式应用&lt;/li&gt;
&lt;li&gt;基于对称算法的验证码，适用于分布式应用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一验证码的组成部分&quot;&gt;一、验证码的组成部分&lt;/h2&gt;
&lt;p&gt;验证码实际上和谜语有点像，分为谜面和谜底。谜面通常是图片，谜底通常为文字。谜面用于展现，谜底用于校验。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于字符型验证码。比如：谜面是显示字符串&quot;ABGH&quot;的图片，谜底是字符串&quot;ABGH&quot;&lt;/li&gt;
&lt;li&gt;对于计算类验证码。比如：谜面是“1+1=”的图片，谜底是“2”&lt;/li&gt;
&lt;li&gt;对于拖拽类的验证码。比如：谜面是一个拖拽式的拼图，谜底是拼图位置的坐标&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，不管什么形式的谜面，最后用户的输入内容要和谜底进行验证。&lt;/p&gt;
&lt;h2 id=&quot;二session存储验证码&quot;&gt;二、session存储验证码&lt;/h2&gt;
&lt;p&gt;图中蓝色为服务端、澄粉色为客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191129075059470-717727353.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一种最典型的验证码实现方式，实现方式也比较简单。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用服务端随机的生成验证码文字&lt;/li&gt;
&lt;li&gt;将验证码文字存到session里面&lt;/li&gt;
&lt;li&gt;根据验证码文字生成验证码图片，响应给客户端&lt;/li&gt;
&lt;li&gt;检查用户输入的内容与验证码谜底是否一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种实现方式的优点就是比较简单，缺点就是：因为一套应用部署一个session，当我们把应用部署多套如：A、B、C，他们各自有一个session并且不共享。导致的结果就是验证码和图片由A生成，但是验证请求发送到了B，这样就不可能验证通过。&lt;/p&gt;
&lt;h2 id=&quot;三共享session存储验证码&quot;&gt;三、共享session存储验证码&lt;/h2&gt;
&lt;p&gt;在第二小节讲到的问题，实际上不是验证码的问题，而是如何保证session唯一性或共享性的问题。主要的解决方案有两种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191129075059687-1950920770.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通常我们实现负载均衡应用的前端都是使用nginx或者haproxy，二者都可以配置负载均衡策略。其中一种策略就是：你的客户端ip上一次请求的是A应用，你的下一次请求还转发给A应用。这样就保证了session的唯一性。但是这种方式有可能会导致A、B、C应用其中一个或两个分配了大量的请求，而另外一个处理很少的请求，导致负载并不均衡。&lt;/li&gt;
&lt;li&gt;另外一种非常通用的方式就是将分布式应用的session统一管理，也就是说原来A、B、C各自的session都存在自己的内存中，现在更改为统一存储到一个地方，大家一起用。这样就实现了session的唯一和共享，是实现分布式应用session管理的有效途径。在Spring框架内，最成熟的解决方案就是spring session + redis 。可自行参考实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四基于对称算法的验证码&quot;&gt;四、基于对称算法的验证码&lt;/h2&gt;
&lt;p&gt;可能出于主机资源的考虑，可能出于系统架构的考量，有些应用是无状态的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是无状态应用：就是不保存用户状态的应用。&lt;/li&gt;
&lt;li&gt;什么是用户状态：比如当你登陆之后，在session中保存的用户的名称、组织等等信息。&lt;/li&gt;
&lt;li&gt;所以可以简单的理解，无状态应用就是无session应用。当然这并不完全准确。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么对于这些无状态的应用，我们就无法使用session，或者换个说法从团队开发规范上就不让使用session。那么我们的验证码该怎么做？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191129075059959-123511417.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同样，首先要生成随机的验证码（谜底），但是不做任何存储操作&lt;/li&gt;
&lt;li&gt;将谜底（验证码文字）加上时间串、应用信息等组成一个字符串进行加密。必须是对称加密，也就是说可以解密的加密算法。&lt;/li&gt;
&lt;li&gt;生成验证码图片，并与加密后的密文，通过cookies一并返回给客户端。&lt;/li&gt;
&lt;li&gt;当用户输入验证码提交登录之后，服务端解密cookies中的密文（主要是验证码文字），与用户的输入进行验证比对。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种做法的缺陷是显而易见的：实际上就是将验证码文字在客户端服务端之间走了一遍。虽然是加密后的验证码文字，但是有加密就必须有解密，否则无法验证。所以更为稳妥的做法是为每一个用户生成密钥，并将密钥保存到数据库里面，在对应的阶段内调用密钥进行加密或者解密。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;从密码学的角度讲，没有一种对称的加密算法是绝对安全的。所以更重要的是保护好你的密钥。正如没有一把锁头是绝对安全的，更重要的是保护好你的钥匙。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Thu, 28 Nov 2019 23:51:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在本号的一系列Spring Security文章中，先后介绍了各种登录验证及授权中的知识点，如：spring security简介并与shiro对比、 formLogin模式登录认证、动态数据登录验证</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11955523.html</dc:identifier>
</item>
<item>
<title>我的程序员之路——2015年和2016年至今 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/10544849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/10544849.html</guid>
<description>&lt;p&gt;　　这次也是创业公司，但与以往不同的是，起点很高，起步资金有1500W，而且给我开的工资破万，对我也很有吸引力。这家公司我待的时间蛮长的，有一年半，而且同事之间的感情也比前面两家要好。我在这家公司主要做PHP，兼顾页面的制作。&lt;/p&gt;

&lt;p&gt;　　刚开始办公是在漕河泾那边，租的办公室还在装修，可以说休息了将近一个月，就帮公司做了个PC主页，其他时间基本都是摸鱼状态。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）吃饭&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　中午是包饭的，由于不差钱，于是买了日本进口的那种米，再买了个5000块钱的电饭锅，中午的米饭都想多吃一碗。点的外卖每天都在变，有时候送过来的不是一次性碗，而是那种陶瓷碗，吃完他们会回收的那种，总之价格是其次的，口感才是重要的，公司处处透露着金元的味道。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）办公环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　公司从各处高薪挖来了各种人才，很多都是外企的。他们比较注重企业文化，强调以人为本。让行政采购了一批健身器材，并且还特地在办公室装了个浴室，本来还说要装备按摩椅、休息室啥的，后面这些都没有实施。新的办公地非常宽敞，是我上班到现在见到的最宽敞的办公室。还建了一条塑胶跑道，供大家休闲用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201903/211606-20190317111947798-1510652684.jpg&quot; alt=&quot;&quot; height=&quot;300&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201903/211606-20190317112023508-6464216.jpg&quot; alt=&quot;&quot; height=&quot;300&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201903/211606-20190317111918060-1391223390.jpg&quot; alt=&quot;&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）开张大吉&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　搬到新地址的时间是老板请风水大师推算的，公司准备了饮料、酒、烤乳猪、甜品等各类食品，那天大家都很开心。开工仪式也很容重，拜天拜地的，一直搞到下午，然后就提前下班了。项目开始前，氛围异常轻松，前景一片光明，似乎已经看到项目成功后的画面了。&lt;/p&gt;

&lt;p&gt;　　紧接着十一月份，项目正式启动，我们要做两个产品，分成两组，每组3个PHP、3个iOS和3个Android，为期两个月，团队规模要比以前大很多，但项目难度也比以前大很多。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）赶进度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　产品的原型已经有了，好多页，异常复杂，但是团队的成员却还没来齐，陆陆续续的才招齐。加班加点是跑不了的了，很多时候都是到凌晨的，同事也很拼，生病了都不去休息直接回来上班，还有个同事爱猫丢了，也只能先来上班。我除了要做后端的开发，例如支付接口对接、搜索引擎coreseek的配置等工作之外，还要布局后台页面，采用了RequireJS模块化开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201903/211606-20190317112313233-1996756306.jpg&quot; alt=&quot;&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虽然从早忙到晚，但项目却没有按预期的计划那样执行，最终不幸夭折了，个中缘由可以浏览我的另一篇《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/4176761.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;最近一个项目的反思&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）裁员&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　12月份的时候，开始大规模的裁员，公司的两个产品砍掉一个，开发、运营、人事、商务、市场等各个职位的人也砍掉好多。后面才知道，裁掉的除了那些倒霉的开发人员之外，还有以另一个同事为首的小团体，那批人都是她挖过来的，这是公司的首次内斗。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）游戏&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　公司规定，每天的三点半要进行半个小数的活动，俗称三三零活动，每天会有一个部门的人来策划活动并主持，有一个同事玩的投入，把脚搞骨折了，最后在医院躺了一年。在加班加点的时候，还是蛮反感这种活动的，打断我的思路。不过现在想想，这种活动还是挺不错的，让你不用久坐，活动活动筋骨，让自己更有活力。&lt;/p&gt;

&lt;p&gt;　　一月份将两条产品线合并成一条后，人员基本就定了，第一次震荡结束。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）开辟新业务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　公司渴望创造营收，于是就开辟了一项能马上带来现金的业务。这次与以往不同的是，需要在微信平台开发，也就是通过微信给出的接口，研发自己的业务。不过又出现了新的问题，具体可以阅读我的另外一篇博文《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/4589951.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;然而这并没有什么卵用&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）再次裁员&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一晃到了9月份，发生了一件比上次更劲爆的事，我们的老板被股东裁掉了。听说他把投资人的钱挪用到了其他地方，让投资人非常的愤怒，解除并起诉了他。这么多年我还是第一次见到老板被裁掉的，一并裁掉的还有老板的心腹。后面公司从外面找了些人回来，负责公司的产品，但大家都不是很待见他们，公司的项目也一度停滞了，我也闲了好几个月，中途做了个H5页面的&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/4942637.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;外包&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，赚了点零花钱。一直到2016年1月份，终于公司再次大裁员，将我们团队的负责人以及他找来的人一并裁掉，我也是其中之一，赔偿了2+1。&lt;/p&gt;
&lt;p&gt;　　2015年也是蛮坑的一年，勤勤恳恳的工作，只有苦劳没有功劳，公司就像是一部清朝宫廷剧，经常有戏剧性的事情发生，人物关系错综复杂。&lt;/p&gt;

&lt;p&gt;　　在被裁员的那一周，正好看到以前的同事在朋友圈发招聘前端的公告。本来自己就对前端感兴趣，于是就联系了那同事。周五就去面试，他那边非常缺人，上一个前端团队都离职了，他也是从其他部门转过去的，每天忙的飞起来，我过来后就能帮他分摊掉很多事情，他也可以早点下班了。这家公司工作到至今还没换过，从事纯前端，后端有专们的人负责。&lt;/p&gt;
&lt;p&gt;　　刚进公司的时候，分在了前端组。后面在2017年6月的时候，公司内部调岗，CTO将我从原先的前端组转到了广告组。　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）技术部&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　公司CTO是从腾讯过来的，挖了很多腾讯的人过来，技术部的规模比以往要大很多，大概有六七十人，其中后端的PHP开发人数最多。前端组重新组建，只有3个人，都是认识的老同事。前端开发也是让我耳目一新，首次接触ES6、gulp、webpack、nodejs、SASS、Jade、React等等新工具新概念，给了我巨大的冲击，原来前端是这么玩的。公司选用的版本控制系统是Git，不再是SVN了。做的页面也从PC端转到移动端，移动端的页面制作起来比PC端的要快一些，毕竟内容要少很多，这段时间的博文创作也是最多的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）职责&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　公司的主营业务都由客户端完成，前端主要做些辅助任务。最多的就是制作活动页面，基本都是一周或两周的时间周期，由产品、运营等部门提出需求，再设计页面。项目都比较小，公司也就没配项目经理，但基本都是按时完成的，与设计、产品、后端等部门的配合都比较默契，从没出现过冲突。记得2016年巴西奥运会的时候，CTO亲自操刀，做个奥运夺金的活动，我们小组的人都参与，前前后后搞了将近一个月，预期日活是100W，不过最终没那么高，只到达了30W。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）读书&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这段时间阅读了大量的前端著作，过去也会读技术书籍，但很多时候都是随便翻翻。现在不同，在读完后，会抽时间做点记录，消化学到的知识，并整理成一篇篇文章，再加点自己的一些体会或实践书中的代码，验证书中所述的是否正确。将这些留作记录，可供自己日后浏览。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）开源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　自己的闲暇的时候也制作了些简单的脚本插件，例如表单验证、提示框等，还上传到了Github上，很有趣。公司里还搞了个简单的内部UI库，封装了一些常见的模块，提升工作效率。关于这个UI库的具体细节，可以浏览《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5536321.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;小身材大用途，用PrimusUI驾驭你的页面&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）活动页面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　转到广告组后，职能相对就比较单一，主要负责与广告业务相关的活动页面。布局方面也比较统一，与以前的活动完全不同，没有各种花哨的特效，以及独特的功能，而广告业务的活动关注的是线索搜集，没啥特别多的特效。但就是工期经常很短，可能今天说要做，后天就要上线，甚至是明天就要上线，很注重效率。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）技术狩猎&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在业余时间，会去研究一些新技术或基础概念。也是在进入这家公司后，我意识到了自己基础的薄弱，需要补一补，于是研读了很多技术基础书籍，为此还做了各种实践，例如重新学习了DOM、CSS的渐变、正则表达式等。&lt;/p&gt;
&lt;p&gt;　　这段时间不仅学习了ES6、HTML5和CSS3等基础知识，还学习了React、性能优化、设计模式等实用技能，不断地弥补自身的不足，期间还加强了对英语的学习。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 23:38:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>这次也是创业公司，但与以往不同的是，起点很高，起步资金有1500W，而且给我开的工资破万，对我也很有吸引力。这家公司我待的时间蛮长的，有一年半，而且同事之间的感情也比前面两家要好。我在这家公司主要做P</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/10544849.html</dc:identifier>
</item>
<item>
<title>Elasticsearch系列---全面了解Document - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/11955515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/11955515.html</guid>
<description>&lt;h3 id=&quot;概要&quot;&gt;概要&lt;/h3&gt;
&lt;p&gt;本篇主要介绍一下document的知识，对document的元数据和基本的语法进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;document核心元数据&quot;&gt;document核心元数据&lt;/h3&gt;
&lt;p&gt;前面入门实战一节有简单介绍过document数据示例，这次我们来详细了解一下它的核心元数据，查询响应报文如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
  &quot;_index&quot;: &quot;music&quot;,
  &quot;_type&quot;: &quot;children&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 1,
  &quot;found&quot;: true,
  &quot;_source&quot;: {
    &quot;name&quot;: &quot;gymbo&quot;,
    &quot;content&quot;: &quot;I hava a friend who loves smile, gymbo is his name&quot;,
    &quot;language&quot;: &quot;english&quot;,
    &quot;length&quot;: &quot;75&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;index元数据-代表一个document存放在哪个index中项目约定结构类似的数据放在一个索引不同数据放不同索引里所以同一个index中document结构基本是类似的个别document多一个或少一个field这样elasticsearch对磁盘存储的利用率最高-每个index有自己独立的shard存储文件与其他index互不影响&quot;&gt;_index元数据&lt;br/&gt;代表一个document存放在哪个index中，项目约定结构类似的数据放在一个索引，不同数据放不同索引里，所以同一个index中document结构基本是类似的，个别document多一个或少一个field，这样Elasticsearch对磁盘存储的利用率最高。&lt;br/&gt;每个index有自己独立的shard存储文件，与其他index互不影响。&lt;/h4&gt;
&lt;p&gt;命名规范：名称小写，不能以'_', '-', 或 '+'开头。&lt;/p&gt;
&lt;h4 id=&quot;type元数据-es-6.0.0之后一个index下面只能有一个type最早指定是啥就是啥&quot;&gt;_type元数据&lt;br/&gt;ES 6.0.0之后一个index下面只能有一个type，最早指定是啥就是啥。&lt;/h4&gt;
&lt;p&gt;命名规范：可以用'_'开头，由于只有一个，官方示例上直接使用'_doc'。&lt;/p&gt;
&lt;h4 id=&quot;id元数据-document的唯一标识与index一起唯一标识和定位一个document可以手动指定也可以由es自动创建&quot;&gt;_id元数据&lt;br/&gt;document的唯一标识，与index一起唯一标识和定位一个document，可以手动指定，也可以由ES自动创建。&lt;/h4&gt;
&lt;h4 id=&quot;version元数据-es内部使用乐观锁对document的写操作进行控制version版本号最初是1更新操作成功后自动1&quot;&gt;_version元数据&lt;br/&gt;ES内部使用乐观锁对document的写操作进行控制，version版本号最初是1，更新操作成功后自动+1。&lt;/h4&gt;
&lt;h4 id=&quot;found元数据&quot;&gt;found元数据&lt;/h4&gt;
&lt;p&gt;document的搜索标志，成功是true，未搜索到是false。&lt;/p&gt;
&lt;h4 id=&quot;source元数据-里面是我们在新增时放在http-request-body的json串内容是保存的业务数据默认get操作时会原封不动地全部返回给客户端&quot;&gt;_source元数据&lt;br/&gt;里面是我们在新增时放在http request body的json串内容，是保存的业务数据，默认Get操作时，会原封不动地全部返回给客户端。&lt;/h4&gt;
&lt;p&gt;用Get命令搜索document时，可以定制返回的结果，在请求的_source中指定想要的field即可，示例命令：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;GET /music/children/_search
{
  &quot;query&quot;: {
    &quot;match_all&quot; : {}
  },
  &quot;_source&quot;: [&quot;name&quot;,&quot;content&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;document-id&quot;&gt;document id&lt;/h3&gt;
&lt;p&gt;document的id手动指定与自动生成两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;手动指定&lt;br/&gt;PUT命令行指定ID时，即手动方式&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;PUT /music/children/id&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自动生成&lt;br/&gt;PUT命令行没指定ID时，此时ES会自动生成的id，长度为20个字符，URI安全，base64编码，GUID，保证不重复。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;PUT /music/children&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们的项目中怎么选择ID生成方式呢？&lt;br/&gt;一般来说，看Elasticsearch在系统里承担的角色，如果是业务系统，本身有关系型数据完成数据的落地，Elasticsearch的价值就是填补关系型数据的全文搜索的短板，Elasticsearch的数据源头，本身在带ID的，这种情况下应该使用手动指定ID的方式，直接用数据库存储数据的ID即可，后续的搜索功能，也很容易与数据库建立对应 关系。例如订单数据，此时的ID直接使用订单ID即可，而订单ID的生成方式，无论是自增ID，雪花ID，对Elasticsearch来讲都不要紧，保证唯一性即可。&lt;/p&gt;
&lt;p&gt;而自动ID生成的场景，比如有些系统，它没有关系型数据库，Elasticsearch可能就是它唯一的数据落地方案，这种数据结构，ID没有太多的重要性，这时让Elasticsearch自动生成一个，可以保存到Elasticsearch即可。&lt;/p&gt;
&lt;p&gt;tips: GUID、UUID、COMB概念&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UUID：是128位整数(16字节)的通用唯一识别码 (Universally Unique Identifier)，它是由开放软件基金会（OSF）定义的一个软件建构的标准。&lt;/li&gt;
&lt;li&gt;GUID：是微软对UUID这个标准的实现。UUID还有其它各种实现，不止GUID一种。&lt;/li&gt;
&lt;li&gt;COMB（combine）型是数据库特有的一种设计思想，可以理解为一种改进的GUID，它通过组合GUID和系统时间，以使其在索引和检索时有更优的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;GUID与UUID的区别，生成的格式不同。&lt;/p&gt;
&lt;h3 id=&quot;document写操作&quot;&gt;document写操作&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;强制创建&lt;br/&gt;强制创建在语法上多了_create参数，或op_type=create，如&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;PUT /music/children/id/_create&lt;/code&gt;&lt;br/&gt;或&lt;br/&gt;&lt;code&gt;PUT /music/children/id?op_type=create&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;强制创建与全量替换的异同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当ID不存在时，二者的效果一样。&lt;/li&gt;
&lt;li&gt;当ID存在时，全量替换做更新操作，强制创建报错，提示&quot;version conflict, document already exists&quot;错误。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;删除document&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果对一个document执行delete操作，ES不会立即进行物理删除，而是先标记为deleted状态，当文件数据变多满足一定条件后，ES再执行物理删除，类似于JVM的垃圾清理。&lt;br/&gt;这个过程叫软删除，也叫lazy delete。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;全量替换&amp;amp;增量更新&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;全量替换&quot;&gt;全量替换&lt;/h5&gt;
&lt;p&gt;全量替换命令可以多次执行，如果ID不存在，执行创建document操作，如果ID存在，执行更新，语法示例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PUT /music/children/id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;全量替换的原理：当全量替换请求发送到ES上时，会将该ID原有的document执行软删除，然后再新建一个document，把request body的内容存储到新的document中，后续的GET查询只关注非deleted状态的document，这样就完成了一次全量替换操作。&lt;/p&gt;
&lt;p&gt;增量更新前必须保证该ID是存在的，存在执行更新操作，若不存在，抛出&quot;document_missing_exception&quot;错误信息。&lt;/p&gt;
&lt;h5 id=&quot;增量更新&quot;&gt;增量更新&lt;/h5&gt;
&lt;p&gt;增量更新的原理，与全量替换基本一致，也有软删除过程，只是创建新的document时，需要将原有的document数据拷贝一份，再用增量的内容进行覆盖，得到一个新的document。&lt;/p&gt;
&lt;p&gt;增量更新比全量替换的优点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询修改写回操作，都发生在一个shard内部，网络带宽更小（有2次网络传输），大大提升了性能&lt;/li&gt;
&lt;li&gt;减少了查询和修改中的时间时隔，可以有效减少并发冲突的情况（毫秒级的更新）&lt;/li&gt;
&lt;li&gt;减轻应用程序拼接全量数据的工作量（如果json field比较多，拼接一个完整的document是很费事的）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本篇主要围绕document的元数据进行了简单的讲解，希望可以加深对document的印象。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201911/1834889-20191129072313196-2094776092.jpg&quot; alt=&quot;Java架构社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 23:23:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>主要介绍document的知识，对document的元数据和基本的语法进行讲解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/11955515.html</dc:identifier>
</item>
<item>
<title>使用 Topshelf 组件一步一步创建 Windows 服务 (2)   使用Quartz.net 调度 - 每天努力进步一点点</title>
<link>http://www.cnblogs.com/peterzhang123/p/11908742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peterzhang123/p/11908742.html</guid>
<description>&lt;p&gt;上一篇说了如何使用 Topshelf 组件快速创建Windows服务，接下来介绍如何使用 Quartz.net&lt;/p&gt;
&lt;p&gt;关于Quartz.net的好处，网上搜索都是一大把一大把的，我就不再多介绍。&lt;/p&gt;
&lt;p&gt;先介绍需要用到的插件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/592073/201911/592073-20191128220438259-973440252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Quartz版本我用的 2.6.2的， 没有用3.0以上的，因为你用了就会知道，会打印出一大堆坑爹的日志文件，&lt;/p&gt;
&lt;p&gt;我是没有找到如何屏蔽的办法，如果你们谁有，欢迎分享出来，我也学习一下，哈哈。&lt;/p&gt;
&lt;p&gt;整个项目结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/592073/201911/592073-20191128221545657-10351605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
AppConfigHelper 文件需要改动一下，增加如下属性
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 程序标识
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         [ConfigurationProperty(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, IsRequired = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; AppKey
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString(); }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; { &lt;span&gt;base&lt;/span&gt;[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 程序集信息
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         [ConfigurationProperty(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TypeInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, IsRequired = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; TypeInfo
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TypeInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString(); }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; { &lt;span&gt;base&lt;/span&gt;[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TypeInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AppConfig文件也做稍微改动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;configuration&amp;gt;
&lt;span&gt; 3&lt;/span&gt;   &amp;lt;!--该节点一定要放在最上边--&amp;gt;
&lt;span&gt; 4&lt;/span&gt;   &amp;lt;configSections&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;section name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppConfigHelper&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Quartz.WinService.AppConfigHelper,Quartz.WinService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;span&gt; 6&lt;/span&gt;   &amp;lt;/configSections&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &amp;lt;!--TopSelf服务配置文件 --&amp;gt;
&lt;span&gt; 9&lt;/span&gt;   &amp;lt;&lt;span&gt;AppConfigHelper
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     ServiceName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProcessPrintLogService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     Desc=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;日志打印服务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     AppKey=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProcessPrintLogService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     TypeInfo=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProcessService.ProcessPrintLogService,ProcessService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   /&amp;gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;   &amp;lt;startup&amp;gt;
&lt;span&gt;17&lt;/span&gt;     &amp;lt;supportedRuntime version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v4.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; sku=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.NETFramework,Version=v4.5.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;18&lt;/span&gt;   &amp;lt;/startup&amp;gt;
&lt;span&gt;19&lt;/span&gt; &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
ProcessPrintLogService 就是Windows服务要执行的逻辑程序文件，可以执行任何你想要的功能
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
ProcessService.ProcessPrintLogService,ProcessService 是 命名空间.类名,类名  的格式，用于后边反射程序集用&lt;p&gt;假如你要执行其他业务逻辑程序，只需要更换这里的配置就行，
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
ProcessPrintLogService 业务逻辑内容如下：这就是我们要执行的业务逻辑，定时打印一段日志内容，可以创建一个类库，里边专门存放你要执行的业务逻辑
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ProcessService
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 日志打印服务
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProcessPrintLogService
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; Logger log =&lt;span&gt; LogManager.GetCurrentClassLogger();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务入口
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DoWork()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;log.Info(&quot;******************排行榜服务开始执行******************&quot;);&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                PrintLogMethod();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 log.Error(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;排行榜服务异常，原因：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ex));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;log.Info(&quot;******************排行榜服务结束执行******************&quot;);&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintLogMethod()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             log.Trace(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是日志:{0}号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后需要新增加两个文件：quartz.config  和  quartz_jobs.xml&lt;/p&gt;
&lt;p&gt;quartz.config文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
# You can configure your scheduler &lt;span&gt;in&lt;/span&gt; either &amp;lt;quartz&amp;gt;&lt;span&gt; configuration section
# or &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; quartz properties file
# Configuration section has precedence

quartz.scheduler.instanceName &lt;/span&gt;=&lt;span&gt; ServiceQuartzScheduler

# configure thread pool info
quartz.threadPool.type &lt;/span&gt;=&lt;span&gt; Quartz.Simpl.SimpleThreadPool, Quartz
quartz.threadPool.threadCount &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
quartz.threadPool.threadPriority &lt;/span&gt;=&lt;span&gt; Normal

# job initialization plugin handles our xml reading, without it defaults are used
quartz.plugin.xml.type &lt;/span&gt;=&lt;span&gt; Quartz.Plugin.Xml.XMLSchedulingDataProcessorPlugin, Quartz
quartz.plugin.xml.fileNames &lt;/span&gt;= ~/&lt;span&gt;quartz_jobs.xml

# &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.0以上用以下配置
# quartz.plugin.xml.type &lt;/span&gt;=&lt;span&gt; Quartz.Plugin.Xml.XMLSchedulingDataProcessorPlugin, Quartz.Plugins
# quartz.plugin.xml.fileNames &lt;/span&gt;= ~/&lt;span&gt;quartz_jobs.xml

# export &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; server to remoting context
# quartz.scheduler.exporter.type &lt;/span&gt;=&lt;span&gt; Quartz.Simpl.RemotingSchedulerExporter, Quartz
# quartz.scheduler.exporter.port &lt;/span&gt;= &lt;span&gt;555&lt;/span&gt;&lt;span&gt;
# quartz.scheduler.exporter.bindName &lt;/span&gt;=&lt;span&gt; QuartzScheduler
# quartz.scheduler.exporter.channelType &lt;/span&gt;=&lt;span&gt; tcp
# quartz.scheduler.exporter.channelName &lt;/span&gt;= httpQuartz
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;quartz.scheduler.instanceName =&lt;span&gt; ServiceQuartzScheduler  是调度的实例名称，可以随意自定义命名&lt;br/&gt;其他的都是固定的，不需要修改&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;quartz_jobs.xml 文件内容如下：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;

&amp;lt;job-scheduling-data xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://quartznet.sourceforge.net/JobSchedulingData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; xmlns:xsi=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;processing-directives&amp;gt;
    &amp;lt;overwrite-existing-data&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/overwrite-existing-data&amp;gt;
  &amp;lt;/processing-directives&amp;gt;
  &amp;lt;schedule&amp;gt;
    &amp;lt;!--调度配置--&amp;gt;
    &amp;lt;job&amp;gt;
      &amp;lt;name&amp;gt;ProcessPrintLogService&amp;lt;/name&amp;gt;
      &amp;lt;group&amp;gt;ProcessPrintLogServiceGroup&amp;lt;/group&amp;gt;
      &amp;lt;description&amp;gt;日志打印服务&amp;lt;/description&amp;gt;
      &amp;lt;job-type&amp;gt;Quartz.WinService.QuartzWork,Quartz.WinService&amp;lt;/job-type&amp;gt;
      &amp;lt;durable&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/durable&amp;gt;
      &amp;lt;recover&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/recover&amp;gt;
    &amp;lt;/job&amp;gt;
    &amp;lt;trigger&amp;gt;
      &amp;lt;cron&amp;gt;
        &amp;lt;name&amp;gt;ProcessPrintLogServiceTrigger&amp;lt;/name&amp;gt;
        &amp;lt;group&amp;gt;ProcessPrintLogServiceTriggerGroup&amp;lt;/group&amp;gt;
        &amp;lt;job-name&amp;gt;ProcessPrintLogService&amp;lt;/job-name&amp;gt;
        &amp;lt;job-group&amp;gt;ProcessPrintLogServiceGroup&amp;lt;/job-group&amp;gt;
        &amp;lt;misfire-instruction&amp;gt;SmartPolicy&amp;lt;/misfire-instruction&amp;gt;
        &amp;lt;cron-expression&amp;gt;&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;3&lt;/span&gt; * * * * ? &amp;lt;/cron-expression&amp;gt;
      &amp;lt;/cron&amp;gt;
    &amp;lt;/trigger&amp;gt;
  &amp;lt;/schedule&amp;gt;
&amp;lt;/job-scheduling-data&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个xml配置文件很重要! 需要重点说下&lt;/p&gt;
&lt;p&gt;首先 job节点 和 trigger节点 都可以定义多个，也就是一个服务可以跑多个不同的业务逻辑程序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;先说 job节点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name(必填) 任务名称，多个job的name不能相同，这里一般使用业务逻辑程序的名称就行了&lt;/li&gt;
&lt;li&gt;group(选填) 任务所属分组，用于标识任务所属分组，一般用业务逻辑程序的名称+Group后缀   如:&amp;lt;group&amp;gt;sampleGroup&amp;lt;/group&amp;gt;&lt;/li&gt;
&lt;li&gt;description(选填) 任务描述，用于描述任务具体内容，如:&amp;lt;description&amp;gt;打印日志服务&amp;lt;/description&amp;gt;&lt;/li&gt;
&lt;li&gt;job-type(必填) 任务类型，任务的具体类型及所属程序集，格式：实现了IJob接口的包含完整命名空间的类名,程序集名称，如:&amp;lt;job-type&amp;gt;Quartz.Server.SampleJob, Quartz.Server&amp;lt;/job-type&amp;gt;&lt;/li&gt;
&lt;li&gt;durable(选填) 具体作用不知，官方示例中默认为true，如:&amp;lt;durable&amp;gt;true&amp;lt;/durable&amp;gt;&lt;/li&gt;
&lt;li&gt;recover(选填) 具体作用不知，官方示例中默认为false，如:&amp;lt;recover&amp;gt;false&amp;lt;/recover&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的 job-type 节点调用的任务类型需要说下，这里设置的就是上边项目结构中的 QuartzWork 类，具体内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Quartz.WinService
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuartzWork : IJob
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger log =&lt;span&gt; LogManager.GetCurrentClassLogger();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ConcurrentDictionary是线程安全的字典集&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Lazy&amp;lt;Delegate&amp;gt;&amp;gt; _dynamicCache = &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Lazy&amp;lt;Delegate&amp;gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录当前工作接口是否已经工作&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt; WorkingNow = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 任务调度执行入口
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实现IJob的Execute方法,在Execute方法里编写要处理的业务逻辑，系统就会按照Quartz的配置，定时处理
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当Job的trigger触发的时候, Execute(..) 方法就会在scheduler的工作线程中执行
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute(IJobExecutionContext context)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Task.Factory.StartNew(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; service =&lt;span&gt; AppConfigHelper.Initity();
                    WorkNow(service);
                });
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                log.Fatal($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行Quartz调度异常，信息：{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return Task.FromResult(true);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个bool类型的Task, Quartz 3.0版本以上需要用到&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; WorkNow(AppConfigHelper service)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; key = service.AppKey;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key值&lt;/span&gt;
            &lt;span&gt;lock&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;WorkingNow.ContainsKey(key))
                {
                    WorkingNow.Add(key, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果执行则跳出&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (WorkingNow[key])
                {
                    log.Trace($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务key:{key} 正在运行,此次服务忽略&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并且设置为执行状态&lt;/span&gt;
                WorkingNow[key] = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; type = Type.GetType(service.TypeInfo);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里通过App.config文件设置&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (type != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建指定类型的实例,相当于通过反射new了一个对象实例&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; provider =&lt;span&gt; Activator.CreateInstance(type);
                    Dynamic(provider, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DoWork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, key);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    log.Error($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务:{key} 实例化失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                log.Fatal($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务:{key} 实例化异常：{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                WorkingNow[key] &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Delegate.CreateDelegate 官方定义:用来动态创建指定类型的委托，该委托可以对指定的类实例调用的指定的方法。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单来说:就是可以调用指定类里边指定的方法,前提是,使用时需要实例化该类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GetOrAdd函数会根据指定key判断是否存在对应内容,存在则返回
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DynamicInvoke 动态调用委托方法
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;obj参数就是指定类的实例化对象,methodName指定类中的方法名&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dynamic(&lt;span&gt;object&lt;/span&gt; obj, &lt;span&gt;string&lt;/span&gt; methodName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dmc = _dynamicCache.GetOrAdd(key, t =&amp;gt; &lt;span&gt;new&lt;/span&gt; Lazy&amp;lt;Delegate&amp;gt;(() =&amp;gt; Delegate.CreateDelegate(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Action), obj, methodName)));
            dmc.Value.DynamicInvoke();   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态调用委托方法&lt;/span&gt;
&lt;span&gt;        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来说 &lt;strong&gt;trigger  节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;trigger 任务触发器，用于定义使用何种方式出发任务(job)，同一个job可以定义多个trigger ，多个trigger 各自独立的执行调度，&lt;/p&gt;
&lt;p&gt;每个trigger 中必须且只能定义一种触发器类型(calendar-interval、simple、cron)&lt;/p&gt;
&lt;p&gt;说白些就是，假如你要一个服务分别在 上午 8:00~18:00   和  凌晨 00:00 ~ 6:00  这两个时间段执行任务，那么你可以设置两个 trigger 触发器，&lt;/p&gt;
&lt;p&gt;分别设置为这两个时间段即可实现你要的结果，怎么样，很牛X吧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name(必填) 触发器名称，一般以 业务逻辑类+Trigger结尾， 如果需要设置多个 trigger节点，该名称不能相同&lt;/li&gt;
&lt;li&gt;group(选填) 触发器组  一般以 业务逻辑类+TriggerGroup结尾，多个 trigger节点，该名称可以相同&lt;/li&gt;
&lt;li&gt;job-name(必填) 要调度的任务名称，该job-name必须和对应job节点中的name名称完全相同&lt;/li&gt;
&lt;li&gt;job-group(选填) 调度任务(job)所属分组，该值必须和job节点中的group名称完全相同&lt;/li&gt;
&lt;li&gt;misfire-instruction 不知道干啥用,这么写就行  &amp;lt;misfire-instruction&amp;gt;SmartPolicy&amp;lt;/misfire-instruction&amp;gt;&lt;/li&gt;
&lt;li&gt;cron-expression(必填) cron表达式，如:&amp;lt;cron-expression&amp;gt;0/10 * * * * ?&amp;lt;/cron-expression&amp;gt;每10秒执行一次&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;需要注意的是修改了quartz_jobs.xml文件后，quartz服务默认不会重新加载该文件，若要让修改后的文件生效需要重启下服务才行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，quartz.config文件 和 &lt;/strong&gt;quartz_jobs.xml文件 都需要在项目中设置，右键--&amp;gt;属性--&amp;gt;复制到输出目录--&amp;gt;始终复制&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务注册文件 RegistService 增加了自动重启功能，完整内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Quartz.WinService
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RegistService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 注册入口
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;config&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;配置文件&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isreg&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否注册&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Regist(AppConfigHelper config, &lt;span&gt;bool&lt;/span&gt; isreg = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里也可以使用HostFactory.Run()代替HostFactory.New()&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; host = HostFactory.New(x =&amp;gt;&lt;span&gt;
            {
                x.Service&lt;/span&gt;&amp;lt;QuartzHost&amp;gt;(s =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过 new QuartzHost() 构建一个服务实例 &lt;/span&gt;
                    s.ConstructUsing(name =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QuartzHost());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当服务启动后执行什么&lt;/span&gt;
                    s.WhenStarted(tc =&amp;gt;&lt;span&gt; tc.Start());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当服务停止后执行什么&lt;/span&gt;
                    s.WhenStopped(tc =&amp;gt;&lt;span&gt; tc.Stop());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当服务暂停后执行什么&lt;/span&gt;
                    s.WhenPaused(w =&amp;gt;&lt;span&gt; w.Stop());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当服务继续后执行什么&lt;/span&gt;
                    s.WhenContinued(w =&amp;gt;&lt;span&gt; w.Start());
                });

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isreg) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false表示不注册

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务用本地系统账号来运行&lt;/span&gt;
&lt;span&gt;                x.RunAsLocalSystem();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用自动重启服务&lt;/span&gt;
                x.EnableServiceRecovery(v =&amp;gt;&lt;span&gt;
                {
                    v.RestartService(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2分钟后重启&lt;/span&gt;
&lt;span&gt;                });

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务的描述信息&lt;/span&gt;
&lt;span&gt;                x.SetDescription(config.Description);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务的显示名称&lt;/span&gt;
&lt;span&gt;                x.SetDisplayName(config.ServiceName);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务的名称（最好不要包含空格或者有空格属性的字符）Windows 服务名称不能重复。&lt;/span&gt;
&lt;span&gt;                x.SetServiceName(config.ServiceName);
            }).Run();   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务  如果使用HostFactory.Run()则不需要该方法&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务注册中调用的 QuartzHost 类内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Quartz.WinService
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuartzHost
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger log =&lt;span&gt; LogManager.GetCurrentClassLogger();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IScheduler scheduler;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; QuartzHost()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化调度服务
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;scheduler = StdSchedulerFactory.GetDefaultScheduler().Result;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.0以上写法&lt;/span&gt;
            scheduler =&lt;span&gt; StdSchedulerFactory.GetDefaultScheduler();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调度开始
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                scheduler.Start();
                log.Info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Quartz调度服务开始工作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                log.Fatal(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Quartz调度服务开始异常！错误信息：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ex));
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调度停止
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Stop()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (scheduler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    scheduler.Shutdown(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                }
                log.Info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Quartz调度服务结束工作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                log.Fatal(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Quartz调度服务停止异常！错误信息：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ex));
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;项目文件地址：https://gitee.com/gitee_zhang/Quartz.WinService.git&lt;p&gt;参考文档：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;https://blog.csdn.net/clb929/article/details/90341485&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/weixin_33948416/article/details/92989386&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/lzrabbit/archive/2012/04/14/2446942.html&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 16:34:00 +0000</pubDate>
<dc:creator>每天努力进步一点点</dc:creator>
<og:description>上一篇说了如何使用&amp;#160;Topshelf 组件快速创建Windows服务，接下来介绍如何使用 Quartz.net 关于Quartz.net的好处，网上搜索都是一大把一大把的，我就不再多介绍。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/peterzhang123/p/11908742.html</dc:identifier>
</item>
<item>
<title>关于JDK源码：我想聊聊如何更高效地阅读 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11955068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11955068.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;大家好，我是彤哥，今天我想和大家再聊聊JDK源码的几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;为什么要看JDK源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK源码的阅读顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK源码的阅读方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;为什么要看jdk源码&quot;&gt;为什么要看JDK源码&lt;/h2&gt;
&lt;p&gt;一，JDK源码是其它所有源码的&lt;strong&gt;基础&lt;/strong&gt;，看懂了JDK源码再看其它的源码会达到事半功倍的效果。&lt;/p&gt;
&lt;p&gt;二，JDK源码中包含大量的&lt;strong&gt;数据结构&lt;/strong&gt;知识，是学习数据结构很好的资料，比如，链表、队列、散列表、红黑树、跳表、桶、堆、双端队列等。&lt;/p&gt;
&lt;p&gt;三、JDK源码中包含大量的&lt;strong&gt;设计模式&lt;/strong&gt;，是学习设计模式很好的资料，比如，适配器模式、模板方法模式、装饰器模式、迭代器模式、代理模式、工厂模式、命令模式、状态模式等。&lt;/p&gt;
&lt;p&gt;三，JDK源码中包含大量Java的&lt;strong&gt;高阶知识&lt;/strong&gt;，比如弱引用、Unsafe、CAS、锁原理、伪共享等，不看源码是很难学会这些知识的。&lt;/p&gt;
&lt;p&gt;四，面试时更好地&lt;strong&gt;收割offer&lt;/strong&gt;，这可能是很多同学最初的想法，其实真正看多了源码，这一点可能并不是太重要了，因为你会发现更广阔的世界。&lt;/p&gt;
&lt;p&gt;五，彤哥认为最重要的，阅读源码是对思维的一种锻炼，是学习优秀设计的&lt;strong&gt;最佳途径&lt;/strong&gt;，本文来源于工从号彤哥读源码。&lt;/p&gt;
&lt;h2 id=&quot;jdk源码的阅读顺序&quot;&gt;JDK源码的阅读顺序&lt;/h2&gt;
&lt;p&gt;首先，JDK源码我分成了以下几个部分：&lt;/p&gt;
&lt;h3 id=&quot;基础类&quot;&gt;基础类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;基础类&lt;/strong&gt;，是指组成JDK源码地基的一部分类。&lt;/p&gt;
&lt;p&gt;比如包装类、反射类、工具类等，这些类有个共同点，就是代码逻辑相对简单，不存在数据结构、复杂运算等问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于基础类&lt;/strong&gt;，彤哥的建议是自己从头到尾浏览一遍，对于看不懂的地方可以写测试用例或者上网查查资料。比如，Integer里面有个IntegerCache内部类你可能不知道干嘛的，这时候光看代码是没用的，只能上网查查资料了，也不能盲目地死磕。&lt;/p&gt;
&lt;h3 id=&quot;简单集合&quot;&gt;简单集合&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简单集合&lt;/strong&gt;，是指不存在多线程安全问题的集合。&lt;/p&gt;
&lt;p&gt;这部分集合一般用在单线程中，或者方法体中，但是他们用到了很多的数据结构，所以需要一定的数据结构知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于简单集合&lt;/strong&gt;，彤哥的建议是先弄明白底层的数据结构知识，再去看源码，这样可能会轻松一些。当然，彤哥后面也会出数据结构系列的。&lt;/p&gt;
&lt;h3 id=&quot;原子类&quot;&gt;原子类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原子类&lt;/strong&gt;，是指在多线程环境下能够保证原子性的类。&lt;/p&gt;
&lt;p&gt;这部分类主要包括Atomic*开头和*Adder结尾的类，位于juc下面的atomic包中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于原子类&lt;/strong&gt;，彤哥的建议是先去了解底层的Unsafe、CAS、伪共享等概念，再去看最简单的AtomicInteger，最后再看LongAdder这种复杂的类。其中，断点调试是不可或缺的手段。&lt;/p&gt;
&lt;p&gt;说句实话，LongAdder这个类能学到很多高阶的知识，非常推荐把这个类研究透彻，后面再去看Disruptor、Netty等源码会事半功倍。&lt;/p&gt;
&lt;h3 id=&quot;同步器&quot;&gt;同步器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;同步器&lt;/strong&gt;，是指为了控制多个线程的竞争关系而存在的类或者关键字等，本文来源于工从号彤哥读源码，它们可以说是Java中最重要的内容，没有它们就无法控制多线程的正常运转。&lt;/p&gt;
&lt;p&gt;这部分内容主要包括synchronized关键字、volatile关键字、重入锁、读写锁、倒计时器、信号量、回环栅栏、阶段器、分布式锁的实现等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于同步器&lt;/strong&gt;，彤哥的建议是先了解内存模型、可见性、原子性、有序性、Happens-Before等基本概念，再尝试阅读这部分的源码，最后再归纳出属于你自己理解的“同步器的原理”。&lt;/p&gt;
&lt;h3 id=&quot;并发集合&quot;&gt;并发集合&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;并发集合&lt;/strong&gt;，是指多线程环境下能够保证数据一致性的集合。&lt;/p&gt;
&lt;p&gt;这部分集合主要是运用在多线程环境下，只有极个别类牵涉到高级的数据结构，更多的是锁、CAS、volatile、自旋等高阶技巧的运用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于并发集合&lt;/strong&gt;，彤哥的建议有三点：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一定要在同步器之后阅读&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据结构先搞透，比如ConcurrentSkipList&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;利用IDEA的Thread级别的断点，不断调试，不断调试，不断调试&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;线程池类&quot;&gt;线程（池）类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;线程（池）类&lt;/strong&gt;，是指跟线程和线程池相关的类。&lt;/p&gt;
&lt;p&gt;这部分类主要包含Thread、ThreadLocal、三种线程池等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于线程（池）类&lt;/strong&gt;，彤哥的建议是先从整体上把握，再分成几个块来看，看哪块的东西就只看那块的东西，不要管其它的代码，即要搞清楚你的重点在哪里，比如，看线程运行的流程就不要管状态的事，凡是牵涉到状态的代码全部跳过，反之亦然，都看完了，再串一起看。&lt;/p&gt;
&lt;h3 id=&quot;ionio类&quot;&gt;IO/NIO类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IO类&lt;/strong&gt;，是指跟输入输出流相关的类，这部分类主要包括文件操作相关的类以及网络IO相关的类。&lt;/p&gt;
&lt;p&gt;对于IO类，彤哥的建议是简单浏览，做到心里有数即可，用到的时候再去查都可以。&lt;/p&gt;
&lt;p&gt;但是对于nio相关的类，还是要好好研究的，这部分类我们放在Netty源码阅读的相关章节中一起学习。&lt;/p&gt;
&lt;h3 id=&quot;其它类&quot;&gt;其它类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;其它类&lt;/strong&gt;，工作中遇到了可以点进去看看，但是不建议抽出时间单独去研究，比如，时间类、awt类，看的必要性不是很大。&lt;/p&gt;
&lt;h2 id=&quot;jdk源码的阅读方法&quot;&gt;JDK源码的阅读方法&lt;/h2&gt;
&lt;p&gt;一，&lt;strong&gt;设定目标&lt;/strong&gt;，目标越明确越好，不要设定得过于虚无缥缈。比如，熟悉HashMap的数据结构，这就是一个很明确的目标；再比如，看懂HashMap的源码，这就很缥缈了。&lt;/p&gt;
&lt;p&gt;二，&lt;strong&gt;尝试自己提出问题&lt;/strong&gt;，先自己根据某个知识点发散提出问题。比如，关于HashMap你能想到哪些知识点，这部分可以借助思维导图无限想象，后面有机会彤哥给大家分享一下思维导图联想法。&lt;/p&gt;
&lt;p&gt;三，&lt;strong&gt;尝试网络查询问题&lt;/strong&gt;，打开度娘，输入你要学习的知识点，把前面几页统统点开，看看别人都遇到了哪些问题，当然，能力强的同学也可以使用Google，这部分查询出来的问题也可以补充到你的思维导图中去。&lt;/p&gt;
&lt;p&gt;四，&lt;strong&gt;尝试阅读源码&lt;/strong&gt;，对于上面的问题，一个一个尝试去源码中寻找答案，由点及面，最后再总结整个大的知识点。&lt;/p&gt;
&lt;p&gt;五，&lt;strong&gt;不断发现问题&lt;/strong&gt;，在阅读源码的过程中可能又会发现新的问题，先跳过去，而是把它加到思维导图中，等当前的问题解决完了再去解决。&lt;/p&gt;
&lt;p&gt;六，&lt;strong&gt;专注你的问题&lt;/strong&gt;，在阅读源码的时候一定要专注于你当前的问题，不要受其它问题的干扰，比如看线程池任务执行的流程，你就不要管线程池状态的事情。&lt;/p&gt;
&lt;p&gt;七，&lt;strong&gt;多做比较&lt;/strong&gt;，横向比较和纵向比较，从多维度去比较，本文来源于工从号彤哥读源码。&lt;/p&gt;
&lt;p&gt;八，&lt;strong&gt;多做实验&lt;/strong&gt;，多多利用IDE的调试模式，不断修改断点，不断调试。&lt;/p&gt;
&lt;p&gt;九，&lt;strong&gt;多与人交流&lt;/strong&gt;，如果条件允许的话，多与周边的人一起交流，当然，也可以来骚扰彤哥。&lt;/p&gt;
&lt;p&gt;十，&lt;strong&gt;多做总结&lt;/strong&gt;，对于自己解决的问题，一定要学会总结，多做学习笔记，当然，也欢迎来彤哥这里投稿。&lt;/p&gt;
&lt;p&gt;十一，&lt;strong&gt;耐心&amp;amp;坚持&lt;/strong&gt;，阅读源码是一件非常枯燥而且枯燥的事情，一定要坚持坚持坚持。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天，我们聊了聊学习JDK源码的几个问题，不小心就写了这么多，都是肺腑之言，希望大家能收下我的膝盖。&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;最后，送上一幅JDK源码的思维导图，标星是彤哥建议必看的部分，对于时间充足的同学，没标星当然最好也看看。&lt;/p&gt;
&lt;p&gt;关于JDK源码的部分彤哥已经全部解析完毕，点击&lt;strong&gt;公众号彤哥读源码左下角“JDK源码”&lt;/strong&gt;可以查看所有源码解析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191129002221321-685979140.png&quot; alt=&quot;jdk_source&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 16:22:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>简介 大家好，我是彤哥，今天我想和大家再聊聊JDK源码的几个问题： 为什么要看JDK源码 JDK源码的阅读顺序 JDK源码的阅读方法 为什么要看JDK源码 一，JDK源码是其它所有源码的 基础 ，看懂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11955068.html</dc:identifier>
</item>
<item>
<title>[FPGA]Verilog利用PWM调制巧妙完成RGB三色彩虹呼吸灯(给简约的题目以美妙的解答) - 方清欢</title>
<link>http://www.cnblogs.com/Clouds42/p/11954337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Clouds42/p/11954337.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;实现彩虹呼吸灯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目就是这么简短,但这是目前我碰到的最有意思的一道题目,因为他有无数种解决方法,并且每一种都是那么高级或者巧妙,比如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以利用3路不同初相的PWM调制信号驱动三颗RGB灯重叠呼吸&lt;/li&gt;
&lt;li&gt;利用1路PWM信号以及状态机,将一个周期分为3个状态,分别是[R降G升B灭],[R灭,G降,B升]和[R升,G灭,B降],依次往复实现重叠呼吸&lt;/li&gt;
&lt;li&gt;将PWM拆分为3段,分别为升,降,灭,在不同时间周期性的输送给RGB实现重叠呼吸&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然,不只这几种,还有更高级的方法或者生成语句也可以更加简练的完成题目,在这里,我将采取上面罗列的几种方法的一种折中方案,采取&quot;拆分PWM&quot;,&quot;三元运算符实现单行条件信号分配&quot;,&quot;监视模块内运行情况并以监视信号作为状态转换的触发条件&quot;来实现彩虹呼吸灯.&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;题目分析&lt;/h2&gt;
&lt;p&gt;题目只有七个字:&quot;实现彩虹呼吸灯&quot;,其中&quot;呼吸两个字&quot;,已经确定了这个实验和脉宽调制扯不开干系,另外&quot;彩虹&quot;也说明这个实验需要很多的色彩,单单靠单色LED是完成不了的,一定需要三色RGB完成,并且只是让R,G,B三个LED交替呼吸,也达不到&quot;彩虹&quot;的效果,所以需要让三色灯按照一定的规律重叠呼吸,这里为了方便,我按照下图示意的样式进行编程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/28/QF84u6.png&quot; alt=&quot;QF84u6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(抱歉画工实在欠缺,咳咳)&lt;/p&gt;
&lt;p&gt;意思就是在R灯最亮时,G灯开始升,R灯开始降,在G灯最亮时,R灯已灭,B灯开始升,G灯开始降,以此类推.&lt;/p&gt;
&lt;p&gt;通过这个图也可以容易的分成三个情况,用以实现状态机.&lt;/p&gt;
&lt;h2 id=&quot;pwm&quot;&gt;PWM&lt;/h2&gt;
&lt;h3 id=&quot;pwm是个啥&quot;&gt;PWM是个啥?&lt;/h3&gt;
&lt;p&gt;PWM( Pulse width modulation )就是脉冲宽度调制,是一种通过数字信号对模拟信号控制的有效技术.简单来说,规律的进行脉宽调制,比如将一束方波的占空比不断减小,那么这束方波的有效值也相应的减小,占空比增大,有效值也增大,借此来对LED的亮度进行控制,加以周期性的增减,即可实现呼吸灯.&lt;/p&gt;
&lt;p&gt;呼吸灯只是PWM的一个具体应用.&lt;/p&gt;
&lt;h3 id=&quot;pwm咋实现&quot;&gt;PWM咋实现?&lt;/h3&gt;
&lt;p&gt;在之前的学习早已接触过PWM调制的实现方法,在这里直接给出代码,可以通过注释回忆PWM实现过程&lt;/p&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;module PWM
(input CLK
,input FLAG//标志位,控制输出的PWM是升还是降(1升0降)
,output STT//监视信号(脉冲)
,output PWM
);

reg[24:0]cnt1;
reg[24:0]cnt2;

parameter freq=2400;//通过这个freq来控制PWM的周期

reg stt;//监视状态
always@(posedge CLK)
    if(cnt2==freq-1)//cnt2满,则状态为1(只持续一个时钟周期)
        stt&amp;lt;=1'b1;
    else
        stt&amp;lt;=1'b0;
assign STT=stt;

always@(posedge CLK)
    if(cnt1&amp;gt;=freq-1)//满则清零
        cnt1&amp;lt;=1'b0;
    else 
        cnt1&amp;lt;=cnt1+1'b1;

always@(posedge CLK)
    if(cnt1==freq-1)//cnt1满,以cnt1从空到满为一个周期执行操作
        if(FLAG)//升的情况
            if(cnt2&amp;gt;=freq-1)
                cnt2&amp;lt;=1'b0;
            else
                cnt2&amp;lt;=cnt2+1'b1;//升
        else//降的情况
            if(cnt2&amp;lt;=0)
                cnt2&amp;lt;=freq-1;
            else 
                cnt2&amp;lt;=cnt2-1'b1;//降
    else
        cnt2&amp;lt;=cnt2;

assign PWM=(cnt1&amp;lt;cnt2)?1'b0:1'b1;//PWM的核心,输出调制好的PWM信号

endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.0689655172414&quot;&gt;
&lt;p&gt;本代码参考&lt;a href=&quot;%20https://www.stepfpga.com/doc/altera_9breath&quot;&gt;此网页&lt;/a&gt;,内有更详细的图片和讲解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码中的&lt;code&gt;stt&lt;/code&gt;和&lt;code&gt;STT&lt;/code&gt;是监视脉冲,不影响PWM输出;输入信号&lt;code&gt;FLAG&lt;/code&gt;控制PWM输出信号是升还是降.二者作用在顶层代码处详细解释.&lt;/p&gt;
&lt;h2 id=&quot;顶层模块&quot;&gt;顶层模块&lt;/h2&gt;
&lt;p&gt;PWM很容易实现,需要动脑子的就是如何通过例化模块来实现交替呼吸.下面给出我的算法.&lt;/p&gt;
&lt;h3 id=&quot;例化模块&quot;&gt;例化模块&lt;/h3&gt;
&lt;p&gt;先看代码&lt;/p&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;wire UP;
wire DW;
wire STT0;
wire STT1;
PWM up(CLK,1,STT0,UP);
PWM dw(CLK,0,STT1,DW);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;up&lt;/code&gt;例化模块中的&lt;code&gt;1&lt;/code&gt;代表&lt;code&gt;FLAG&lt;/code&gt;,在此表示这个&lt;code&gt;up&lt;/code&gt;例化模块是一个&quot;升&quot;模块,即为可以产生控制LED亮度从灭到亮的PWM信号,&lt;code&gt;dw&lt;/code&gt;例化模块则代表可以产生一个可以控制从亮到暗的PWM信号.通过这个设计可以将PWM模块的功能拆分,提供两种模式供主模块灵活调用.&lt;/p&gt;
&lt;p&gt;代码中的&lt;code&gt;UP&lt;/code&gt;和&lt;code&gt;DW&lt;/code&gt;分别为代表亮度升和亮度降的PWM信号.&lt;/p&gt;
&lt;h3 id=&quot;状态分析&quot;&gt;状态分析&lt;/h3&gt;
&lt;p&gt;这里不按照文首的那种状态机思路来写,而是将RGB三色灯分成3路对待,这里先以R为例.&lt;/p&gt;
&lt;p&gt;对R来说,他的亮灭规律为:升(一单位时间),降(一单位时间),灭(一单位时间).然后可以以此来写条件语句进行信号分配,可能第一时间想到的就是直接定义一个分频,不同时间显示不同状态即可,但是这种写法不利于后期拓展,易读性和可维护性也稍差,在这里采用很方便的&quot;三元运算符&quot;解决.先来看这段代码&lt;/p&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;reg[1:0]flag0=2'b00;
always@(posedge STT0)
    if(flag0==2'b10)
        flag0&amp;lt;=1'b0;
    else
        flag0&amp;lt;=flag0+1'b1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了一个标志为&lt;code&gt;flag0&lt;/code&gt;,它是以上文提到过的监视脉冲&lt;code&gt;STT&lt;/code&gt;为触发进行递增计数的,&lt;code&gt;STT&lt;/code&gt;是一个在PWM模块内每一个工作周期完成后就输出一单位时间高电平的监视脉冲,通过这个脉冲可以知道PWM已经工作完一个周期,可以进行下一周期的工作,在顶层代码里则充当了状态转移的触发条件.&lt;/p&gt;
&lt;p&gt;再来看这一行代码&lt;/p&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;assign LED[0]=(flag0==2'b00)?UP:((flag0==2'b01)?DW:1'b1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一行是实现RGB灯工作状态的核心代码,通过(两层)三元运算符在一条表达式内就完成了条件赋值.&lt;/p&gt;
&lt;p&gt;这条代码的意思就是,如果标志位&lt;code&gt;flag0&lt;/code&gt;是&lt;code&gt;2'b00&lt;/code&gt;,则R亮度升,若不是,则检测标志为是否为&lt;code&gt;2'b01&lt;/code&gt;,若是,则R亮度降,如不是,则灭.然后通过上一个代码块中的代码可以知道,每一个PWM周期完成后(表现为R已到达最亮或者最暗),状态发生转移,标志为变为下一个状态,R也就在完成了亮度升之后立刻开始亮度降,宏观表现为&quot;呼吸&quot;的状态.&lt;/p&gt;
&lt;h3 id=&quot;代码整合&quot;&gt;代码整合&lt;/h3&gt;
&lt;p&gt;上文里两个代码块就足以让一个灯完成一个状态的工作,这部分代码如下&lt;/p&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;reg[1:0]flag0=2'b00;
always@(posedge STT0)
    if(flag0==2'b10)
        flag0&amp;lt;=1'b0;
    else
        flag0&amp;lt;=flag0+1'b1;
assign LED[0]=(flag0==2'b00)?UP:((flag0==2'b01)?DW:1'b1);

reg[1:0]flag1=2'b01;
always@(posedge STT0)
    if(flag1==2'b10)
        flag1&amp;lt;=1'b0;
    else
        flag1&amp;lt;=flag1+1'b1;
assign LED[1]=(flag1==2'b00)?UP:((flag1==2'b01)?DW:1'b1);

reg[1:0]flag2=2'b10;
always@(posedge STT0)
    if(flag2==2'b10)
        flag2&amp;lt;=1'b0;
    else
        flag2&amp;lt;=flag2+1'b1;
assign LED[2]=(flag2==2'b00)?UP:((flag2==2'b01)?DW:1'b1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个灯就相当于将这一段代码例化三次,就可以让三色灯分别进行互相不影响的状态转移(呼吸变化),但是我们的目的是让他们按照文首图中的规律重叠呼吸,该怎么实现呢?&lt;/p&gt;
&lt;p&gt;这很简单,很容易想到,三段一样的代码里都分别有一个独立的标志为&lt;code&gt;flag&lt;/code&gt;,他是&lt;code&gt;reg&lt;/code&gt;类型数据,所以可以在定义时给他分配一个初始状态,这样就相当于给三个灯设置了不同的初相,在后面工作的时候由于工作周期相同,就会一直保持最开始的相位差,周期性的进行文首图中的交替呼吸.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此,彩虹呼吸灯已经完成.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;效果&quot;&gt;效果&lt;/h2&gt;
&lt;p&gt;最后的效果图&lt;a href=&quot;https://s2.ax1x.com/2019/11/28/QFrKII.gif&quot;&gt;点此查看&lt;/a&gt;,图片较大,加载可能比较慢.(因为灯实在是太亮了,就蒙了一层纸来观察颜色变化)&lt;/p&gt;
&lt;h2 id=&quot;后话&quot;&gt;后话&lt;/h2&gt;
&lt;p&gt;这篇文章是目前写过的第二费力的了,其中的代码更新了很多很多次,在琢磨更精简更巧妙的算法上和修Bug上花了很多的时间和精力,前前后后烧录上板测试不下50次(不夸张T_T),在本地commit了无数个版本,回滚了无数次,一遍一遍修改,最后才得到了你看到的这些代码.我的水平有限,所以就算如此文中的代码和讲解一定有所缺漏,还请希望大家多多包涵,并指出不足之处,改进这篇文章,来帮助更多的人.&lt;/p&gt;
&lt;p&gt;本项目完整代码存放在&lt;a href=&quot;%20https://github.com/Clouds42/RainbowRGB&quot;&gt;我的Github&lt;/a&gt;中,最新版以Github上为准(顺路给颗Star呗;-)&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 14:36:00 +0000</pubDate>
<dc:creator>方清欢</dc:creator>
<og:description>题目虽然简短,但是蕴藏的知识却很多,解决的方法更是多彩缤纷,这样简约的题目,自然配得上一种美妙的解法.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Clouds42/p/11954337.html</dc:identifier>
</item>
<item>
<title>一篇文章搞定Python多进程(全) - pypypypy</title>
<link>http://www.cnblogs.com/pypypy/p/11954269.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pypypy/p/11954269.html</guid>
<description>&lt;h3 id=&quot;1&quot;&gt;1.Python多进程模块&lt;/h3&gt;
&lt;p&gt;Python中的多进程是通过multiprocessing包来实现的，和多线程的threading.Thread差不多，它可以利用multiprocessing.Process对象来创建一个进程对象。这个进程对象的方法和线程对象的方法差不多也有start(), run(), join()等方法，其中有一个方法不同Thread线程对象中的守护线程方法是setDeamon，而Process进程对象的守护进程是通过设置daemon属性来完成的。&lt;/p&gt;
&lt;p&gt;下面说说Python多进程的实现方法，和多线程类似&lt;/p&gt;
&lt;h3 id=&quot;2&quot;&gt;2.Python多进程实现方法一&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt;  Process

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun1(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试%s多进程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;name)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    process_list &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启5个子进程执行fun1函数&lt;/span&gt;
        p = Process(target=fun1,args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;实例化进程对象&lt;/span&gt;
&lt;span&gt;        p.start()
        process_list.append(p)

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; process_list:
        p.join()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结束测试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i7.6c0473d9zwi2iX&quot;&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;测试Python多进程
测试Python多进程
测试Python多进程
测试Python多进程
测试Python多进程
结束测试

Process finished with exit code 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i9.6c0473d9zwi2iX&quot;&gt;上面的代码开启了5个子进程去执行函数，我们可以观察结果，是同时打印的，这里实现了真正的并行操作，就是多个CPU同时执行任务。我们知道进程是python中最小的资源分配单元，也就是进程中间的数据，内存是不共享的，每启动一个进程，都要独立分配资源和拷贝访问的数据，所以进程的启动和销毁的代价是比较大了，所以在实际中使用多进程，要根据服务器的配置来设定。&lt;/p&gt;
&lt;h3 id=&quot;3&quot;&gt;3.Python多进程实现方法二&lt;/h3&gt;
&lt;p&gt;还记得python多线程的第二种实现方法吗?是通过类继承的方法来实现的，python多进程的第二种实现方式也是一样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt;  Process

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyProcess(Process): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;继承Process类&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        super(MyProcess,self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试%s多进程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.name)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    process_list &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启5个子进程执行fun1函数&lt;/span&gt;
        p = MyProcess(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;实例化进程对象&lt;/span&gt;
&lt;span&gt;        p.start()
        process_list.append(p)

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; process_list:
        p.join()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结束测试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;测试Python多进程
测试Python多进程
测试Python多进程
测试Python多进程
测试Python多进程
结束测试

Process finished with exit code 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果和第一种方式一样。&lt;/p&gt;
&lt;p&gt;我们可以看到Python多进程的实现方式和多线程的实现方式几乎一样。&lt;/p&gt;
&lt;h4 id=&quot;4&quot;&gt;Process类的其他方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;构造方法：

Process([group [, target [, name [, args [, kwargs]]]]])
　　group: 线程组 
　　target: 要执行的方法
　　name: 进程名
　　args&lt;/span&gt;/&lt;span&gt;kwargs: 要传入方法的参数

实例方法：
　　is_alive()：返回进程是否在运行,bool类型。
　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。
　　start()：进程准备就绪，等待CPU调度
　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。
　　terminate()：不管任务是否完成，立即停止工作进程

属性：
　　daemon：和线程的setDeamon功能一样
　　name：进程名字
　　pid：进程号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i14.6c0473d9zwi2iX&quot;&gt;关于join，daemon的使用和python多线程一样，这里就不在复述了，大家可以看看以前的python多线程系列文章。&lt;/p&gt;
&lt;h3 id=&quot;5&quot;&gt;4.Python多线程的通信&lt;/h3&gt;
&lt;p&gt;进程是系统独立调度核分配系统资源（CPU、内存）的基本单位，进程之间是相互独立的，每启动一个新的进程相当于把数据进行了一次克隆，子进程里的数据修改无法影响到主进程中的数据，不同子进程之间的数据也不能共享，这是多进程在使用中与多线程最明显的区别。但是难道Python多进程中间难道就是孤立的吗？当然不是，python也提供了多种方法实现了多进程中间的通信和数据共享（可以修改一份数据）&lt;/p&gt;
&lt;h4 id=&quot;6&quot;&gt;进程对列Queue&lt;/h4&gt;
&lt;p&gt;Queue在多线程中也说到过，在生成者消费者模式中使用，是线程安全的，是生产者和消费者中间的数据管道，那在python多进程中，它其实就是进程之间的数据管道，实现进程通信。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process,Queue


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun1(q,i):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子进程%s 开始put数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;i)
    q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是%s 通过Queue通信&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;i)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    q &lt;/span&gt;=&lt;span&gt; Queue()

    process_list &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
        p &lt;/span&gt;= Process(target=fun1,args=(q,i,))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意args里面要把q对象传给我们要执行的方法，这样子进程才能和主进程用Queue来通信&lt;/span&gt;
&lt;span&gt;        p.start()
        process_list.append(p)

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; process_list:
        p.join()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主进程获取Queue数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结束测试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;子进程0 开始put数据
子进程1 开始put数据
子进程2 开始put数据
主进程获取Queue数据
我是0 通过Queue通信
我是1 通过Queue通信
我是2 通过Queue通信
结束测试

Process finished with exit code 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i19.6c0473d9zwi2iX&quot;&gt;上面的代码结果可以看到我们主进程中可以通过Queue获取子进程中put的数据，实现进程间的通信。&lt;/p&gt;
&lt;h4 id=&quot;7&quot;&gt;管道Pipe&lt;/h4&gt;
&lt;p&gt;管道Pipe和Queue的作用大致差不多，也是实现进程间的通信，下面之间看怎么使用吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Pipe
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun1(conn):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子进程发送消息：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    conn.send(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;你好主进程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子进程接受消息：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(conn.recv())
    conn.close()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    conn1, conn2 &lt;/span&gt;= Pipe() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关键点，pipe实例化生成一个双向管&lt;/span&gt;
    p = Process(target=fun1, args=(conn2,)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;conn2传给子进程&lt;/span&gt;
&lt;span&gt;    p.start()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主进程接受消息：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(conn1.recv())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主进程发送消息：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    conn1.send(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好子进程&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    p.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结束测试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;主进程接受消息：
子进程发送消息：
子进程接受消息：
你好主进程
主进程发送消息：
你好子进程
结束测试

Process finished with exit code 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i23.6c0473d9zwi2iX&quot;&gt;上面可以看到主进程和子进程可以相互发送消息&lt;/p&gt;
&lt;h4 id=&quot;8&quot;&gt;Managers&lt;/h4&gt;
&lt;p&gt;Queue和Pipe只是实现了数据交互，并没实现数据共享，即一个进程去更改另一个进程的数据。那么久要用到Managers&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Manager

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun1(dic,lis,index):

    dic[index] &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    dic[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;    
    lis.append(index)    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;[0,1,2,3,4,0,1,2,3,4,5,6,7,8,9]&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(l)&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    with Manager() as manager:
        dic &lt;/span&gt;= manager.dict()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意字典的声明方式，不能直接通过{}来定义&lt;/span&gt;
        l = manager.list(range(5))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;[0,1,2,3,4]&lt;/span&gt;
&lt;span&gt;
        process_list &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
            p &lt;/span&gt;= Process(target=fun1, args=&lt;span&gt;(dic,l,i))
            p.start()
            process_list.append(p)

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; res &lt;span&gt;in&lt;/span&gt;&lt;span&gt; process_list:
            res.join()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dic)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l)
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i25.6c0473d9zwi2iX&quot;&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
{0: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 4: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 5: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 7: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 6: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 8: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 9: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
[0, &lt;/span&gt;1, 2, 3, 4, 0, 3, 1, 2, 4, 5, 7, 6, 8, 9]
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i28.6c0473d9zwi2iX&quot;&gt;可以看到主进程定义了一个字典和一个列表，在子进程中，可以添加和修改字典的内容，在列表中插入新的数据，实现进程间的数据共享，即可以共同修改同一份数据&lt;/p&gt;
&lt;h3 id=&quot;9&quot; data-spm-anchor-id=&quot;a2c4e.11153940.0.i29.6c0473d9zwi2iX&quot;&gt;5.进程池&lt;/h3&gt;
&lt;p&gt;进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。就是固定有几个进程可以使用。&lt;/p&gt;
&lt;p&gt;进程池中有两个方法：&lt;/p&gt;
&lt;p&gt;apply：同步，一般不使用&lt;/p&gt;
&lt;p&gt;apply_async：异步&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;  multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process,Pool
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os, time, random

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun1(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Run task %s (%s)...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (name, os.getpid()))
    start &lt;/span&gt;=&lt;span&gt; time.time()
    time.sleep(random.random() &lt;/span&gt;* 3&lt;span&gt;)
    end &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Task %s runs %0.2f seconds.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (name, (end -&lt;span&gt; start)))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    pool &lt;/span&gt;= Pool(5) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个5个进程的进程池&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        pool.apply_async(func&lt;/span&gt;=fun1, args=&lt;span&gt;(i,))

    pool.close()
    pool.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结束测试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i31.6c0473d9zwi2iX&quot;&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Run task 0 (37476&lt;span&gt;)...
Run task &lt;/span&gt;1 (4044&lt;span&gt;)...
Task 0 runs &lt;/span&gt;0.03&lt;span&gt; seconds.
Run task &lt;/span&gt;2 (37476&lt;span&gt;)...
Run task &lt;/span&gt;3 (17252&lt;span&gt;)...
Run task &lt;/span&gt;4 (16448&lt;span&gt;)...
Run task &lt;/span&gt;5 (24804&lt;span&gt;)...
Task &lt;/span&gt;2 runs 0.27&lt;span&gt; seconds.
Run task &lt;/span&gt;6 (37476&lt;span&gt;)...
Task &lt;/span&gt;1 runs 0.58&lt;span&gt; seconds.
Run task &lt;/span&gt;7 (4044&lt;span&gt;)...
Task &lt;/span&gt;3 runs 0.98&lt;span&gt; seconds.
Run task &lt;/span&gt;8 (17252&lt;span&gt;)...
Task &lt;/span&gt;5 runs 1.13&lt;span&gt; seconds.
Run task &lt;/span&gt;9 (24804&lt;span&gt;)...
Task &lt;/span&gt;6 runs 1.46&lt;span&gt; seconds.
Task &lt;/span&gt;4 runs 2.73&lt;span&gt; seconds.
Task &lt;/span&gt;8 runs 2.18&lt;span&gt; seconds.
Task &lt;/span&gt;7 runs 2.93&lt;span&gt; seconds.
Task &lt;/span&gt;9 runs 2.93&lt;span&gt; seconds.
结束测试&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i35.6c0473d9zwi2iX&quot;&gt;对&lt;code&gt;Pool&lt;/code&gt;对象调用&lt;code&gt;join()&lt;/code&gt;方法会等待所有子进程执行完毕，调用&lt;code&gt;join()&lt;/code&gt;之前必须先调用&lt;code&gt;close()&lt;/code&gt;，调用&lt;code&gt;close()&lt;/code&gt;之后就不能继续添加新的&lt;code&gt;Process&lt;/code&gt;了。&lt;/p&gt;
&lt;h4 id=&quot;10&quot;&gt;进程池map方法&lt;/h4&gt;
&lt;p&gt;案例来源于网络，侵权请告知，谢谢&lt;/p&gt;
&lt;p&gt;因为网上看到这个例子觉得不错，所以这里就不自己写案例，这个案例比较有说服力&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; PIL 

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pool 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image

SIZE &lt;/span&gt;= (75,75&lt;span&gt;)
SAVE_DIRECTORY &lt;/span&gt;= \&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thumbs\'&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_image_paths(folder):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (os.path.join(folder, f) 
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; f &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.listdir(folder) 
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; \&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jpeg\' in f)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; create_thumbnail(filename): 
    im &lt;/span&gt;=&lt;span&gt; Image.open(filename)
    im.thumbnail(SIZE, Image.ANTIALIAS)
    base, fname &lt;/span&gt;=&lt;span&gt; os.path.split(filename) 
    save_path &lt;/span&gt;=&lt;span&gt; os.path.join(base, SAVE_DIRECTORY, fname)
    im.save(save_path)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == \&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__\':&lt;/span&gt;
    folder =&lt;span&gt; os.path.abspath(
        \&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;11_18_2013_R000_IQM_Big_Sur_Mon__e10d1958e7b766c3e840\')&lt;/span&gt;
&lt;span&gt;    os.mkdir(os.path.join(folder, SAVE_DIRECTORY))

    images &lt;/span&gt;=&lt;span&gt; get_image_paths(folder)

    pool &lt;/span&gt;=&lt;span&gt; Pool()
    pool.map(creat_thumbnail, images) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关键点，images是一个可迭代对象&lt;/span&gt;
&lt;span&gt;    pool.close()
    pool.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i36.6c0473d9zwi2iX&quot;&gt;上边这段代码的主要工作就是将遍历传入的文件夹中的图片文件，一一生成缩略图，并将这些缩略图保存到特定文件夹中。这我的机器上，用这一程序处理 6000 张图片需要花费 27.9 秒。 map 函数并不支持手动线程管理，反而使得相关的 debug 工作也变得异常简单。&lt;/p&gt;
&lt;p&gt;map在爬虫的领域里也可以使用，比如多个URL的内容爬取，可以把URL放入元祖里，然后传给执行函数。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 14:25:00 +0000</pubDate>
<dc:creator>pypypypy</dc:creator>
<og:description>1.Python多进程模块 Python中的多进程是通过multiprocessing包来实现的，和多线程的threading.Thread差不多，它可以利用multiprocessing.Proce</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pypypy/p/11954269.html</dc:identifier>
</item>
<item>
<title>Java类的定义与类的实例化 - sumerday</title>
<link>http://www.cnblogs.com/summerday152/p/11954197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/11954197.html</guid>
<description>&lt;h2 id=&quot;类的定义&quot;&gt;类的定义&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;面向对象的程序设计中，类可以看作是我们自定义的数据类型，那么，如何能更加优美，更加高效地定义它就显得尤为重要。&lt;br/&gt;类中的成员有很多，每一部分都是十分关键的，毕竟“面向对象”在Java学习中真的很重要，许许多多的Java开发者定义出来的类等待着我们去使用，加油！攻克它！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;直接上代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.my.pac02;
/**
 * @author Summerday
 * @date 2019/11/26 21:40
 */
 //类名和文件名一致，且包含main方法
public class CatTest{
    //程序入口
    public static void main(String[] args) {
        //创建对象
        Cat cat = new Cat();
        //为对象的属性赋值
        cat.name = &quot;sink&quot;;
        cat.isMale = true;
        //通过对象调用方法
        cat.sleep();
        cat.jump();
        cat.laughAt(&quot;Susan&quot;);
        System.out.println(cat.isNotMale());
        //打印引用变量的值
        System.out.println(cat);
        //创建一个新的引用变量并指向原先的对象
        Cat otherCat = cat;
        System.out.println(otherCat);
        System.out.println(otherCat.name);//&quot;sink&quot;
        //将cat和实际对象之间的引用消除
        cat = null;
    }
}
//定义一个Cat类
class Cat{
    //构造方法
    Cat() {
        System.out.println(&quot;cat is cute.&quot;);
    }
    //成员变量
    String name;
    int age;
    boolean isMale;
    String color = &quot;Blue&quot;;
    //方法
    void sleep(){
        System.out.println(name+&quot;is sleeping---&quot;);
    }
    public void jump() {
        System.out.println(name+&quot;is jumping---&quot;);
    }
    public void laughAt(String otherName)
    {
        System.out.println(name+&quot;is laughing at &quot;+otherName);
    }
    //返回boolean类型的方法
    boolean isNotMale() {
        return !isMale;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义一个简单的类&quot;&gt;定义一个简单的类&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[修饰符] class 类名
{
    （零个到多个）构造器...
    （零个到多个）成员变量（属性）...
    （零个到多个）方法...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;[修饰符]修饰类时可以是上面代码中的&lt;strong&gt;public&lt;/strong&gt;，或者final，abstract，也可以省略不写，但不建议使用private和protected。参考:&lt;a href=&quot;https://www.cnblogs.com/langren1992/p/9539641.html&quot;&gt;&lt;br/&gt;Java的外部类为什么不能使用private、protected进行修饰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;类名命名规范：要见名知义，意思是需要多个有意义的英文单词组成，&lt;strong&gt;每个单词首字母大写&lt;/strong&gt;，规范这种东西，建议遵守！养成好习惯。&lt;/li&gt;
&lt;li&gt;上面三种成员（构造器，成员变量，方法）都可以定义零个或多个，但是都是零个就变成了空类，没啥意义。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;定义一个成员变量&quot;&gt;定义一个成员变量&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[修饰符] 类型 成员变量名 [=默认值];
//例如
boolean isMale;
String color = &quot;Blue&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;成员变量包括实例变量和类变量&lt;/strong&gt;，&lt;strong&gt;static&lt;/strong&gt;修饰的成员变量称作类变量，关于static之后再细讲。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;定义一个方法&quot;&gt;定义一个方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[修饰符] 返回值类型 方法名（形参列表）
{
    零条到多条可执行语句组成的方法体...
}
//例如
void sleep(){
System.out.println(name+&quot;is sleeping---&quot;);
}
public void jump() {
System.out.println(name+&quot;is jumping---&quot;);
}
public void laughAt(String otherName)
{
System.out.println(name+&quot;is laughing at &quot;+otherName);
}
//返回boolean类型的方法
boolean isNotMale() {
    return !isMale;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义一个构造器&quot;&gt;定义一个构造器&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[修饰符] 构造器名 （形参列表）
{
    （零条到多条可执行语句组成的构造器执行体...
}
//例如
//构造方法
Cat() {
    System.out.println(&quot;cat is cute.&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;构造器用于构造类的实例&lt;/strong&gt;，也就是创建某个类的对象时会自动调用构造方法，之后会讨论。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造器名一定要和类名相同！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;没有定义构造器的话，系统会提供默认的构造器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设计类时的具体细节，接下来将会一一展开，还有未涉及到的&lt;strong&gt;内部类&lt;/strong&gt;和&lt;strong&gt;代码块&lt;/strong&gt;部分，之后将会进行学习，暂且从这三个部分展开探究。&lt;/p&gt;
&lt;h2 id=&quot;类的实例化&quot;&gt;类的实例化&lt;/h2&gt;
&lt;p&gt;通过类构造属于该类对象的过程就叫做类的实例化。对象是具体存在的事物，也称作实例，可以调用类中定义的实例变量以及方法。（不考虑static修饰变量的情况下）&lt;/p&gt;
&lt;h3 id=&quot;创建对象及使用对象&quot;&gt;创建对象及使用对象：&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//使用Cat类创建了Cat类型的对象
//并调用Cat类的构造器，返回Cat的实例，赋值给变量cat
Cat cat = new Cat();
//访问cat的实例变量name和isMale，并为他们赋值
cat.name = &quot;sink&quot;;
cat.isMale = true;
//调用cat的方法
cat.sleep();
cat.jump();
cat.laughAt(&quot;Susan&quot;);
//输出isNotMale（）方法的返回值
System.out.println(cat.isNotMale());&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果访问权限允许的情况下（访问权限涉及到private等关键字，暂且不谈），类中定义的方法和成员变量都可以通过类或实例来调用。&lt;/li&gt;
&lt;li&gt;创建对象：&lt;code&gt;类型 实例名 = new 类型（参数列表）；&lt;/code&gt;例如：&lt;code&gt;Cat cat = new Cat();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用类成员变量或方法：&lt;code&gt;类.类变量或类.方法&lt;/code&gt;或&lt;code&gt;实例.实例变量或实例.方法&lt;/code&gt;，类变量涉及static关键字，也是暂且放一边，之后继续回顾。&lt;br/&gt;可以这么理解：定义类就是为了创建许许多多该类的实例，这些实例具有相同的特征。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建对象的过程在内存中的表现&quot;&gt;创建对象的过程在内存中的表现&lt;/h3&gt;
&lt;p&gt;类是一种&lt;strong&gt;引用数据类型&lt;/strong&gt;：也就是说，在栈内存里的引用变量并不是真正存储对象的成员变量，而是它的引用，实际的成员变量藏在堆内存中，这一点类似于前面提到过的数组类型。而且，可以知道，&lt;u&gt;栈内存中存储的是实际对象在堆内存中的地址值，&lt;/u&gt;可以直接打印引用变量cat的值验证。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;创建对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//创建对象，并初始化
Cat cat = new Cat();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771072/201911/1771072-20191128221102422-1086300478.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;访问实例变量&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//访问实例变量
cat.name = &quot;sink&quot;;
cat.isMale = true;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771072/201911/1771072-20191128221111201-1819440175.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java不允许直接访问堆内存中的对象，只能通过该对象的引用操作该对象。&lt;/p&gt;
&lt;p&gt;另外，堆内存中的同一个对象可以由栈内存中多个引用变量所指向。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//把引用变量cat赋值给另一个引用变量otherCat
Cat otherCat = cat;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，cat和otherCat都在栈内存中被创建，且他们都指向了原先cat所指向的那块堆内存，所以他们操作的是同一个实际对象。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;堆内存的对象没有&lt;strong&gt;任何变量&lt;/strong&gt;指向时，就会在一段时间内作为“垃圾”被Java的&lt;strong&gt;垃圾回收机制回收&lt;/strong&gt;，释放对象所占用的内存区。&lt;br/&gt;所以想让他提前释放，直接给引用变量赋值为null。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考书籍：《疯狂Java讲义》&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 14:12:00 +0000</pubDate>
<dc:creator>sumerday</dc:creator>
<og:description>[toc] Java类的定义与类的实例化 类的定义 面向对象的程序设计中，类可以看作是我们自定义的数据类型，那么，如何能更加优美，更加高效地定义它就显得尤为重要。 类中的成员有很多，每一部分都是十分关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/11954197.html</dc:identifier>
</item>
</channel>
</rss>