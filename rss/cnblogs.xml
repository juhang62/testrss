<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>软件开发者升职加薪的 8 项技能 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12544019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12544019.html</guid>
<description>&lt;p&gt;私下里，经常有一些读者问我：“二哥，作为一名软件开发者，我应该掌握哪些技能，才能被领导赏识呢？”说实话，我心目中很多选项，不少于 20 个，但我斟酌再三，只挑选了其中最能让你受益的 8 个，不仅能让领导赏识你，还能让领导给你升职加薪。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/03/jineng-01.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h01&quot;&gt;&lt;span&gt;01、吃透一门编程语言&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这个技能看起来似乎没有必要强调，毕竟程序员不懂一种编程语言也说不过去啊。我之所以再次强调是怕你“贪心”，以为技多不压身就拼了命的学很多种编程语言。&lt;/p&gt;
&lt;p&gt;有个大二的学生就曾经问我：“你好呀，老哥，有个问题想咨询一下您，我专业学的是 C#，但听说以后不太好就业，所以就自学了一段时间 Python，但感觉越来越混乱了，您有什么好的建议吗？”&lt;/p&gt;
&lt;p&gt;我只能说不混乱才怪。编程语言虽然有相似的语法，但毕竟是不同的编程语言啊，之间还是有很多差异的。对于初级程序员来说，切勿贪多，先把一门编程语言吃透再说，等你有了融会贯通的本领，再去学新的编程语言也不迟。&lt;/p&gt;
&lt;p&gt;我刚刚查了一下（见下图），C# 还是挺热门的编程语言，没到不太好就业的地步，别随便听信别人的话，要学会自己去判断。Python 是门不错的编程语言，增长势头很猛，但远没到那种独霸天下的地步。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/03/jineng-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;学校有不尽人意的地方，但不至于蠢到让学生学一门已经被市场淘汰的编程语言。在这一点上，我宁愿站在支持学校的立场上，否则就太糟糕了。&lt;/p&gt;
&lt;p&gt;我承认，学霸学什么都快，不仅学的快，还比平常人学得好，学得多，因为他有一套自己的学习方法，但大部分学生并不具备这种条件。如果你对自己没有这种认知的话，很可能会陷入泥潭。&lt;/p&gt;
&lt;p&gt;因此，我给出的建议是，深入并且专注于一种编程语言，当你对使用这种编程语言充满信心时，再去学其他的编程语言也不迟。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;&lt;span&gt;02、整洁的代码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;当你学会一门编程语言之后，接下来要考虑的事情就是让你编写的代码变得更整洁，更易于理解，更富有艺术。关于艺术，我想到了一段话，王小波在他的杂文《用一生来学习艺术》说的：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我念过文科，也念过理科。在课堂上听老师提到艺术这个词，还是理科的老师次数更多：化学老师说，做实验有实验艺术；计算机老师说，编程序有编程艺术。老师们说，怎么做对是科学，怎么做好则是艺术；前者有判断真伪的法则，后者则没有；艺术的真谛就是要叫人感到好，甚至是完美无缺；传授科学知识就是告诉你这些法则，而艺术的修养是无法传授的，只能够潜移默化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不得不说，偶像就偶像，把艺术的真谛阐述得很清楚。我见过不少臃肿的代码，它们让我想起“裹脚布”这三个字；我也见过不少整洁的代码，它们让我想起“艺术”这个词，我想创造出它们的程序员一定富有工匠精神。&lt;/p&gt;
&lt;p&gt;Elliot Chance 曾表达过这样一个观点，他说：“要分辨两个程序员的优劣，就是给他们一样的时间，越好的程序员写出来的代码越少（当然是可以运行的）。”&lt;/p&gt;
&lt;p&gt;我同意他的观点。越多的代码并不一定代表着认真，有可能代表的是懒惰，懒得去思考，才会写出臃肿的代码。如果我们程序员没有这种（写更少代码的）追求的话，那我们的编程技艺就只会原地踏步，长此以往的后果就是各种避免重复造轮子的第三方类库就不会出现。&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;&lt;span&gt;03、算法与数据结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;说起来惭愧，在很长的一段时间里，我对算法和数据结构存在着很大的偏见，认为它们就好像悬挂在夜空中的月亮，虽然很美，但却很遥远。&lt;/p&gt;
&lt;p&gt;因为这种偏见，在敲代码的过程中吃了不少的闷亏，经常遇到一些实际的问题，由于无法充分利用数据结构将数据之间的关系通过合适的算法策略进行有效地存储转换，就导致程序的性能很低。&lt;/p&gt;
&lt;p&gt;作为一个吃过亏的男人，我必须要负责任地提醒你，趁有大把的时间和精力，多投入一点到数据结构和算法上面去。基础知识就像是一座大楼的地基，它决定了我们的技术高度。数据结构和算法就是最重要的基础知识，学习它们的过程就像是在打地基。&lt;/p&gt;
&lt;p&gt;举个例子来说，假如你要在一个列表中对元素进行排序，那么可采用的算法就有下图中的这 10 种，每种算法所花费的时间，所占用的内存都不尽相同。换句话说，如果你不能够熟练地掌握算法和数据结构，就很难找出一个优雅的解决方案。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/03/jineng-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;长期来看，大脑思考能力是一个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。有了这项能力，很多别的程序员解决起来很困难的编程问题在你这里就会迎刃而解。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;&lt;span&gt;04、基本的数据库知识&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;虽然软件开发人员更应该专注于程序设计而非编写和优化 SQL（应该交给专业的数据库管理员负责），但在我们国内，只有顶尖的企业才会有数据库专家。扎心了。如果你想要在软件开发这条道路上走得更高更远，懂一些基本的数据库知识是必须的，比如说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如何将业务中的对象属性转化为数据库字段；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何从数据库中检索数据，并将数据集拼接在一起；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何往数据库中插入、修改、删除数据；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;索引的数据结构及原理；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;SQL 语句的优化；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;等等。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果再懂一些数据库分库分表的中间价，那你可能就会成为团队的宝贝了，毕竟所有的应用程序都要与数据库交互，另外，数据库是系统最先出现性能瓶颈的地方——总有你大展身手的时候。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/03/jineng-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h05&quot;&gt;&lt;span&gt;05、技术框架&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;除了要吃透一门编程语言，我强烈建议你再学习一个技术框架。如果你像我一样是个 Java 后端开发人员的话，Spring 的系列框架（Spring MVC、Spring Boot、Spring Cloud）就不得不学了；如果你是一个 C# 开发人员，.NET Framework 就不得不学了。&lt;/p&gt;
&lt;p&gt;技术框架是一组通用类库的集合，它帮助我们让编程任务变得更简单，毕竟轮子替我们造好了。假如说没有技术框架的话，我们就好像坐着马车前行，而不是飞机、高铁和汽车，开发效率就要大大降低了。&lt;/p&gt;
&lt;h3 id=&quot;h06&quot;&gt;&lt;span&gt;06、源代码管理工具&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;记得我刚参加工作那会，用的源代码管理工具叫做 CVS（Concurrent Versions System），估计有不少读者没听说过，非常非常难用。后来迁移到 SVN（Subversion）后，情况总算是有了很大的改善，它不仅支持 Eclipse，还有专属的客户端，除了管理源代码，还可以管理许许多多的文档。&lt;/p&gt;
&lt;p&gt;每天上班的时候先从服务器获取最新的代码，然后开始一天的工作，下班走之前切记要提交一次代码，否则就很容易耽搁团队其他成员的开发进度。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/03/jineng-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;现在呢，有了 Git，它是一套开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。它与 SVN 最大的不同之处，在于每个开发者的电脑上都会有一个本地仓库（Local Repository），即便是没有网络也一样可以提交版本，查看版本，以及比较版本；等到网络连接上之后，再提交到服务器端。&lt;/p&gt;
&lt;p&gt;源代码管理工具最大的好处就在于它可以帮助我们保留不同文件更改的历史记录，并且允许多个开发人员对同一文件的代码进行合并。举个例子来讲，小王完成了一项任务，然后提交了代码；但他觉得有待改进，于是他重新修改了代码并提交到了版本库，谁知道，程序上线后出了 bug，这时候源代码管理工具可以帮助他快速回滚到之前正常的版本。否则的话，小王只能被祭天了。&lt;/p&gt;
&lt;h3 id=&quot;h07&quot;&gt;&lt;span&gt;07、测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;测试真的是太重要了！但并不是所有的开发者都这样认为，这种感觉在我回到洛阳后尤其强烈。竟然有团队成员不经测试就把代码提交到代码库，并且是会报错的那种，我天呐，遇到这种队友我也是醉了。&lt;/p&gt;
&lt;p&gt;在我回来之前，是在一家日企工作，测试是一项非常重要的工作，占用的时间比代码编写的时间多多了。从单元测试到集成测试，所有的测试结果都要整理成册，所有的边界条件都要测试到，哪怕你觉得完全没有必要。但正是这种一丝不苟的态度，成就了日企软件高质量的美誉。&lt;/p&gt;
&lt;p&gt;一个优秀的开发人员绝不允许他的代码在交给别人之前不经测试，我想这是不容置疑的。&lt;/p&gt;
&lt;h3 id=&quot;h08&quot;&gt;&lt;span&gt;08、调试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;说句实在话，在我做程序员的这 10 年里，调试代码的时间比编写代码的时间要多得多。因为解决 bug 的难度要比创造 bug 难得多，首先你要先复现问题的场景（真的是难啊），要复现问题就需要你拥有出神入化的调试技巧，否则只能锤爆鼠标，然后大喊“为什么，为什么，为什么我的代码无法正常运行呢？”&lt;/p&gt;
&lt;p&gt;入门级的调试很简单，你只需要在发生问题的代码处打个断点，然后再跑一跑，就能从堆栈信息和代码的上下文中发现问题。难度再上升点的话，就需要你创造代码执行的条件；再难的话，你甚至需要内网穿透，比如说微信公众号开发；再再难的话，就不是一句半句能说得清楚了。&lt;/p&gt;
&lt;p&gt;总之呢，调试就是为了让你弄清楚代码不能正常运行的真正原因，如果你的调试技巧不过关的话，甚至有可能会被表象蒙骗，从错误的角度去修改 bug，从而引发更多、更大的问题。&lt;/p&gt;
&lt;h3 id=&quot;h09&quot;&gt;&lt;span&gt;09、鸣谢&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;好了，亲爱的读者朋友，以上就是本文的全部内容了，能看到这里的都是最优秀的程序员，我必须要伸出可爱的大拇指为你点个赞。&lt;strong&gt;如果你也觉得自己很棒的话，就无情地点赞吧，我需要你的支持。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、亲爱的读者朋友们，喜欢的话，请关注我的原创微信公众号「&lt;strong&gt;沉默王二&lt;/strong&gt;」，专注于有趣的 Java 技术和有益的程序人生。&lt;/p&gt;
&lt;p&gt;2、给我点个赞呗，你最美你最帅，除此之外，还可以让更多的人看到这篇文章，顺便激励下我，再次感谢。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读，回复【&lt;strong&gt;666&lt;/strong&gt;】【&lt;strong&gt;1024&lt;/strong&gt;】更有我为你精心准备的 500G 高清教学视频（已分门别类），以及大厂技术牛人整理的面经一份。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 22 Mar 2020 00:38:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>私下里，经常有一些读者问我：“二哥，作为一名软件开发者，我应该掌握哪些技能，才能被领导赏识呢？”说实话，我心目中很多选项，不少于 20 个，但我斟酌再三，只挑选了其中最能让你受益的 8 个，不仅能让领</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12544019.html</dc:identifier>
</item>
<item>
<title>qt creator源码全方面分析(3-5) - codeForFamily</title>
<link>http://www.cnblogs.com/codeForFamily/p/qt-creator-ide-source-learn-3-5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codeForFamily/p/qt-creator-ide-source-learn-3-5.html</guid>
<description>&lt;p&gt;上一章节，我们介绍了src.pro，这里乘此机会，把src目录下的所有项目文件都介绍一遍。首先为qtcreatorlibrary.pri。&lt;/p&gt;
&lt;h2 id=&quot;使用实例&quot;&gt;使用实例&lt;/h2&gt;
&lt;p&gt;为了分析这个文件，我们找个使用该pri的例子，源目录\src\libs\cplusplus\cplusplus.pro&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DEFINES += NDEBUG
unix:QMAKE_CXXFLAGS_DEBUG += -O2
win32:QMAKE_CXXFLAGS_DEBUG += -O2

include(../../qtcreatorlibrary.pri)
include(cplusplus-lib.pri)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及依赖项，源目录\src\libs\cplusplus\cplusplus_dependencies.pri&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QTC_LIB_NAME = CPlusPlus
QTC_LIB_DEPENDS += \
    utils
INCLUDEPATH *= $$IDE_SOURCE_TREE/src/libs/3rdparty&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们可以看见，设置了库名QTC_LIB_NAME和依赖的库名QTC_LIB_DEPENDS，这在qtcreator.pri中解析依赖时会用到的。&lt;/p&gt;
&lt;h2 id=&quot;上半部&quot;&gt;上半部&lt;/h2&gt;
&lt;p&gt;下面，我们来分析qtcreatorlibrary.pri，这里分为两部分来介绍。&lt;/p&gt;
&lt;p&gt;上半部分如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;include($$replace(_PRO_FILE_PWD_, ([^/]+$), \\1/\\1_dependencies.pri))
TARGET = $$QTC_LIB_NAME

include(../qtcreator.pri)

# use precompiled header for libraries by default
isEmpty(PRECOMPILED_HEADER):PRECOMPILED_HEADER = $$PWD/shared/qtcreator_pch.h

win32 {
    DLLDESTDIR = $$IDE_APP_PATH
}

DESTDIR = $$IDE_LIBRARY_PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.qt.io/qt-5/qmake-variable-reference.html#dlldestdir&quot;&gt;DLLDESTDIR&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：此变量仅适用于Windows目标。&lt;/p&gt;
&lt;p&gt;指定要将目标dll复制到的位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.qt.io/qt-5/qmake-variable-reference.html#destdir&quot;&gt;DESTDIR&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;指定放置目标文件的位置。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DESTDIR = ../../lib&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：支持的字符列表可能取决于所使用的构建工具。 特别是，括号不适用于make工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;8.7&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;根据pro文件名获取对应的依赖文件，进行包含。&lt;/p&gt;
&lt;p&gt;_PRO_FILE_PWD_为包含该pri的pro所在的文件夹路径，([^/]+$)表示路径中最后一个分隔符后面的字符串，\1为反向引用，代表所获取的第1个匹配的引用。&lt;/p&gt;
&lt;p&gt;示例：_PRO_FILE_PWD_为源目录/src/libs/cplusplus，包含文件为源目录/src/libs/cplusplus/cplusplus_dependencies.pri，匹配项为cplusplus。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置库文件名。&lt;/p&gt;
&lt;p&gt;示例：CPlusPlus。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.7176470588235&quot;&gt;
&lt;p&gt;加载qtcreator.pri。&lt;/p&gt;
&lt;p&gt;具体内容见往期文章&lt;a href=&quot;https://www.cnblogs.com/codeForFamily/p/qt-creator-ide-source-learn-3-2.html&quot;&gt;qt creator源码全方面分析(3-2)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里重点提示下，第一步加载的依赖文件中，设置了QTC_LIB_DEPENDS，那么在qtcreator.pri会进行依赖解析（utils库），并进行包含。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;添加预编译头文件。&lt;/p&gt;
&lt;p&gt;示例：源目录/src/shared/qtcreator_pch.h。内容就是一些常用的统一的Qt头文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;设置DLL目标文件夹。&lt;/p&gt;
&lt;p&gt;如果win32平台，且生成的目标是dll，则把该dll拷贝到IDE_APP_PATH中，即构建目录/bin。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设置目标文件夹。&lt;/p&gt;
&lt;p&gt;把生成的目标，输出到IDE_LIBRARY_PATH，即构建目录/lib/qtcreator。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;下半部&quot;&gt;下半部&lt;/h2&gt;
&lt;p&gt;下半部分如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;osx {
    QMAKE_LFLAGS_SONAME = -Wl,-install_name,@rpath/Frameworks/
    QMAKE_LFLAGS += -compatibility_version $$QTCREATOR_COMPAT_VERSION
}
include(rpath.pri)

TARGET = $$qtLibraryTargetName($$TARGET)

TEMPLATE = lib
CONFIG += shared dll

contains(QT_CONFIG, reduce_exports):CONFIG += hide_symbols

win32 {
    dlltarget.path = $$INSTALL_BIN_PATH
    INSTALLS += dlltarget
} else {
    target.path = $$INSTALL_LIBRARY_PATH
    INSTALLS += target
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;2.2606382978723&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;osx设置和rpath.pri，设置编译选项，略。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.6842105263158&quot;&gt;
&lt;p&gt;设定输出目标的文件名。&lt;/p&gt;
&lt;p&gt;这里调用了qtcreator.pri中定义的qtLibraryTargetName()函数，其实就是在debug模式下添加字符d，以区分release模式。函数分析见&lt;a href=&quot;https://www.cnblogs.com/codeForFamily/p/qt-creator-ide-source-learn-3-2.html&quot;&gt;qt creator源码全方面分析(3-2)&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设定输出类型，为共享lib库。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设置隐藏导出符号选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置安装路径。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;结果&quot;&gt;结果&lt;/h2&gt;
&lt;p&gt;在构建目录中，我们在DLLDESTDIR和DESTDIR指定的两处地方找到了编译得到的库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1921368/202003/1921368-20200322082727874-1157701096.png&quot; alt=&quot;image-20200303205410364&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在cplusplus.pro包含qtcreatorlibrary.pri，在pri中加载cplusplus_dependencies.pri，然后加载qtcreator.pri，并在其中解决依赖，最终加载utils_dependencies.pri，项目目录架构结果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1921368/202003/1921368-20200322082755157-1264318964.png&quot; alt=&quot;image-20200303205704054&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;原创造福大家，共享改变世界&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;献出一片爱心，温暖作者心灵&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1921368/202002/1921368-20200223073938417-815334096.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Sun, 22 Mar 2020 00:29:00 +0000</pubDate>
<dc:creator>codeForFamily</dc:creator>
<og:description>[TOC] qtcreatorlibrary.pri 上一章节，我们介绍了src.pro，这里乘此机会，把src目录下的所有项目文件都介绍一遍。首先为qtcreatorlibrary.pri。 使用实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codeForFamily/p/qt-creator-ide-source-learn-3-5.html</dc:identifier>
</item>
<item>
<title>【分布式锁】04-使用Redisson实现ReadWriteLock原理 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12543108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12543108.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;关于读写锁，大家应该都了解JDK中的&lt;code&gt;ReadWriteLock&lt;/code&gt;， 当然Redisson也有读写锁的实现。&lt;/p&gt;
&lt;p&gt;所谓读写锁，就是多个客户端同时加读锁，是不会互斥的，多个客户端可以同时加这个读锁，读锁和读锁是不互斥的&lt;/p&gt;
&lt;p&gt;Redisson中使用&lt;code&gt;RedissonReadWriteLock&lt;/code&gt;来实现读写锁，它是&lt;code&gt;RReadWriteLock&lt;/code&gt;的子类，具体实现读写锁的类分别是：&lt;code&gt;RedissonReadLock&lt;/code&gt;和&lt;code&gt;RedissonWriteLock&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;hredisson&quot;&gt;Redisson读写锁使用例子&lt;/h3&gt;
&lt;p&gt;还是从官方文档中找的使用案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;1&quot;&gt;RReadWriteLock rwlock = redisson.getReadWriteLock(&lt;span class=&quot;hljs-string&quot; readability=&quot;2&quot;&gt;&quot;tryLock&quot;);&lt;p&gt;RLock lock = rwlock.readLock();&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hredisson-1&quot;&gt;Redisson加读锁逻辑原理&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;RedissonReadLock &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;RedissonLock &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;RLock {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&amp;lt;T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;RFuture&amp;lt;T&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;tryLockInnerAsync&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot; readability=&quot;19.5&quot;&gt;long leaseTime, TimeUnit unit, &lt;span class=&quot;hljs-keyword&quot; readability=&quot;39&quot;&gt;long threadId, RedisStrictCommand&amp;lt;T&amp;gt; command) {&lt;br/&gt;internalLockLeaseTime = unit.toMillis(leaseTime);&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local mode = redis.call('hget', KEYS[1], 'mode'); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (mode == false) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('hset', KEYS[1], 'mode', 'read'); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('hset', KEYS[1], ARGV[2], 1); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('set', KEYS[2] .. ':1', 1); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('pexpire', KEYS[2] .. ':1', ARGV[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return nil; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (mode == 'read') or (mode == 'write' and redis.call('hexists', KEYS[1], ARGV[3]) == 1) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local ind = redis.call('hincrby', KEYS[1], ARGV[2], 1); &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local key = KEYS[2] .. ':' .. ind;&quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('set', key, 1); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('pexpire', key, ARGV[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return nil; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end;&quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return redis.call('pttl', KEYS[1]);&quot;,&lt;br/&gt;Arrays.&amp;lt;Object&amp;gt;asList(getName(), getReadWriteTimeoutNamePrefix(threadId)), &lt;br/&gt;internalLockLeaseTime, getLockName(threadId), getWriteLockName(threadId));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hauuid_01threadid_01&quot;&gt;客户端A（UUID_01:threadId_01）来加读锁&lt;/h4&gt;
&lt;p&gt;注：&lt;br/&gt;以下文章中客户端A用：&lt;strong&gt;UUID_01:threadId_01标识&lt;/strong&gt;&lt;br/&gt;客户端B用：&lt;strong&gt;UUID_02:threadId_02标识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KEYS：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;KEYS&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt;: &lt;code&gt;getName()&lt;/code&gt; = tryLock&lt;/li&gt;
&lt;li&gt;KEYS[2]: &lt;code&gt;getReadWriteTimeoutNamePrefix(threadId)&lt;/code&gt; = {anyLock}:UUID_01:threadId_01:rwlock_timeout&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;ARGV：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ARGV&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt;: internalLockLeaseTime = 30000毫秒&lt;/li&gt;
&lt;li&gt;ARGV[2]: getLockName(threadId) = UUID_01:threadId_01&lt;/li&gt;
&lt;li&gt;ARGV[3]: getWriteLockName(threadId) = UUID_01:threadId_01:write&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着对代码中lua脚本一行行解读:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;hget anyLock mode 第一次加锁时是空的&lt;/li&gt;
&lt;li&gt;mode = false，进入if逻辑&lt;/li&gt;
&lt;li&gt;hset anyLock UUID_01:threadId_01 1&lt;br/&gt;anyLock是hash结构，设置hash的key、value&lt;/li&gt;
&lt;li&gt;set {anyLock}:UUID_01:threadId_01:rwlock_timeout:1 1&lt;br/&gt;设置一个string类型的key value数据&lt;/li&gt;
&lt;li&gt;pexpire {anyLock}:UUID_01:threadId_01:rwlock_timeout:1 30000&lt;br/&gt;设置key value的过期时间&lt;/li&gt;
&lt;li&gt;pexpire anyLock 30000&lt;br/&gt;设置anyLock的过期时间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时redis中存在的数据结构为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;read&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;ha&quot;&gt;客户端A 第二次来加读锁&lt;/h5&gt;
&lt;p&gt;继续分析，客户端A已经加过读锁，此时如果继续加读锁会怎样处理呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;hget anyLock mode 此时mode=read，会进入第二个if判断&lt;/li&gt;
&lt;li&gt;hincrby anyLock UUID_01:threadId_01 1 此时hash中的value会加1，变成2&lt;/li&gt;
&lt;li&gt;set {anyLock}:UUID_01:threadId_01:rwlock_timeout:2 1&lt;br/&gt;ind 为hincrby结果，hincrby返回是2&lt;/li&gt;
&lt;li&gt;pexpire anyLock 30000&lt;/li&gt;
&lt;li&gt;pexpire {anyLock}:UUID_01:threadId_01:rwlock_timeout:2 30000&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时redis中存在的数据结构为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;1&quot;&gt;anyLock: {&lt;br/&gt;“mode”: “read”,&lt;br/&gt;“UUID_01:threadId_01”: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;2&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;2  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hbuuid_02threadid_02&quot;&gt;客户端B （UUID_02:threadId_02）第一次来加读锁&lt;/h4&gt;
&lt;p&gt;基本步骤和上面一直，加锁后redis中数据为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;read&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot;&gt;2,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1.5&quot;&gt;&quot;UUID_02:threadId_02&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;3&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;2  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;{anyLock}:UUID_02:threadId_02:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意一下：&lt;br/&gt;为哈希表 key 中的域 field 的值加上增量 increment，如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。&lt;/p&gt;
&lt;h3 id=&quot;hredisson-2&quot;&gt;Redisson加写锁逻辑原理&lt;/h3&gt;
&lt;p&gt;Redisson中由&lt;code&gt;RedissonWriteLock&lt;/code&gt; 来实现写锁，我们看下写锁的核心逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;RedissonWriteLock &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;RedissonLock &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;RLock {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&amp;lt;T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;RFuture&amp;lt;T&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;tryLockInnerAsync&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot; readability=&quot;15&quot;&gt;long leaseTime, TimeUnit unit, &lt;span class=&quot;hljs-keyword&quot; readability=&quot;30&quot;&gt;long threadId, RedisStrictCommand&amp;lt;T&amp;gt; command) {&lt;br/&gt;internalLockLeaseTime = unit.toMillis(leaseTime);&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local mode = redis.call('hget', KEYS[1], 'mode'); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (mode == false) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('hset', KEYS[1], 'mode', 'write'); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('hset', KEYS[1], ARGV[2], 1); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return nil; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (mode == 'write') then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('hincrby', KEYS[1], ARGV[2], 1); &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local currentExpire = redis.call('pttl', KEYS[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('pexpire', KEYS[1], currentExpire + ARGV[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return nil; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end;&quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return redis.call('pttl', KEYS[1]);&quot;,&lt;br/&gt;Arrays.&amp;lt;Object&amp;gt;asList(getName()), &lt;br/&gt;internalLockLeaseTime, getLockName(threadId));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是像上面一样，一行行来分析每句lua脚本执行语义。&lt;/p&gt;
&lt;h4 id=&quot;ha-1&quot;&gt;客户端A先加读写、再加写锁&lt;/h4&gt;
&lt;p&gt;KEYS和ARGV参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;KEYS&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = anyLock&lt;/li&gt;
&lt;li&gt;ARGV&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = 30000&lt;/li&gt;
&lt;li&gt;ARGV[2] = UUID_01:threadId_01:write&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;hget anyLock mode，此时没人加锁，mode=false&lt;/li&gt;
&lt;li&gt;hset anyLock mode write&lt;/li&gt;
&lt;li&gt;hset anyLock UUID_01:threadId_01:write 1&lt;/li&gt;
&lt;li&gt;pexpire anyLock 30000&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时redis中数据格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;write&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01:write&quot;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时再次来加写锁，直接到另一个if语句中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;hexists anyLock UUID_01:threadId_01:write&lt;/li&gt;
&lt;li&gt;hincrby anyLock UUID_01:threadId_01:write 1&lt;/li&gt;
&lt;li&gt;pexpire anyLock pttl + 30000&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时redis中数据格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;write&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01:write&quot;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;habc&quot;&gt;客户端A和客户端B，先后加读锁，客户端C来加写锁&lt;/h4&gt;
&lt;p&gt;读锁加完后，此时redis数据格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;read&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot;&gt;1,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_02:threadId_02&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;{anyLock}:UUID_02:threadId_02:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端C参数为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;KEYS&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = anyLock&lt;/li&gt;
&lt;li&gt;ARGV&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = 30000&lt;/li&gt;
&lt;li&gt;ARGV[2] = UUID_03:threadId_03:write&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;hget anyLock mode，mode = read，已经有人加了读锁，不是写锁，此时会直接执行：pttl&lt;br/&gt;anyLock，返回一个anyLock的剩余生存时间&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;hget anyLock mode，mode = read，已经有人加了读锁，不是写锁，所以if语句不会成立&lt;/li&gt;
&lt;li&gt;pttl anyLock，返回一个anyLock的剩余生存时间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;客户端C加锁失败，就会不断的尝试重试去加锁&lt;/p&gt;
&lt;h4 id=&quot;hab&quot;&gt;客户端A先加写锁、客户端B接着加读锁&lt;/h4&gt;
&lt;p&gt;加完写锁后此时Redis数据格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;write&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01:write&quot;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端B执行读锁逻辑参数为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;KEYS&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = anyLock&lt;/li&gt;
&lt;li&gt;KEYS[2] = {anyLock}:UUID_02:threadId_02:rwlock_timeout&lt;/li&gt;
&lt;li&gt;ARGV&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = 30000毫秒&lt;/li&gt;
&lt;li&gt;ARGV[2] = UUID_02:threadId_02&lt;/li&gt;
&lt;li&gt;ARGV[3] = UUID_02:threadId_02:write&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着看下加锁逻辑：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/21/mOaNLQdItvCe852.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/h3&gt;
&lt;p&gt;如上图，客户端B加读锁会走到红框中的if逻辑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;hget anyLock mode，mode = write&lt;br/&gt;客户端A已经加了一个写锁&lt;/li&gt;
&lt;li&gt;hexists anyLock UUID_02:threadId_02:write，存在的话，如果客户端B自己之前加过写锁的话，此时才能进入这个分支&lt;/li&gt;
&lt;li&gt;返回pttl anyLock，导致加锁失败&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;haa&quot;&gt;客户端A先加写锁、客户端A接着加读锁&lt;/h4&gt;
&lt;p&gt;还是接着上面的逻辑，继续分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;hget anyLock mode，mode = write&lt;br/&gt;客户端A已经加了一个写锁&lt;/li&gt;
&lt;li&gt;hexists anyLock UUID_01:threadId_01:write，此时存在这个key，所以可以进入if分支&lt;/li&gt;
&lt;li&gt;hincrby anyLock UUID_01:threadId_01 1，也就是说此时，加了一个读锁&lt;/li&gt;
&lt;li&gt;set {anyLock}:UUID_01:threadId_01:rwlock_timeout:1 1,&lt;/li&gt;
&lt;li&gt;pexpire anyLock 30000&lt;/li&gt;
&lt;li&gt;pexpire {anyLock}:UUID_01:threadId_01:rwlock_timeout:1 30000&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时redis中数据格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;write&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01:write&quot;: &lt;span class=&quot;hljs-number&quot;&gt;1,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;haa-1&quot;&gt;客户端A先加读锁、客户端A接着加写锁&lt;/h4&gt;
&lt;p&gt;客户端A加读锁后，redis中数据结构为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;read&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时客户端A再来加写锁，逻辑如下：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/21/4ya5VqohsRlF3tM.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/h3&gt;
&lt;p&gt;此时客户端A先加的读锁，mode=read，所以再次加写锁是不能成功的&lt;/p&gt;
&lt;p&gt;如果是同一个客户端同一个线程，先加了一次写锁，然后加读锁，是可以加成功的，默认是在同一个线程写锁的期间，可以多次加读锁&lt;/p&gt;
&lt;p&gt;而同一个客户端同一个线程，先加了一次读锁，是不允许再被加写锁的&lt;/p&gt;
&lt;h4 id=&quot;h-1&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;显然还有写锁与写锁互斥的逻辑就不分析了，通过上面一些场景的分析，我们可以知道：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读锁与读锁非互斥&lt;/li&gt;
&lt;li&gt;读锁与写锁互斥&lt;/li&gt;
&lt;li&gt;写锁与写锁互斥&lt;/li&gt;
&lt;li&gt;读读、写写 同个客户端同个线程都可重入&lt;/li&gt;
&lt;li&gt;先写锁再加读锁可重入&lt;/li&gt;
&lt;li&gt;先读锁再写锁不可重入&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hredisson-3&quot;&gt;Redisson读写锁释放原理&lt;/h3&gt;
&lt;h4 id=&quot;hredission&quot;&gt;Redission 读锁释放原理&lt;/h4&gt;
&lt;h5 id=&quot;h-2&quot;&gt;不同客户端加了读锁 / 同一个客户端+线程多次可重入加了读锁&lt;/h5&gt;
&lt;p&gt;例如客户端A先加读锁，然后再次加读锁&lt;br/&gt;最后客户端B来加读锁&lt;/p&gt;
&lt;p&gt;此时Redis中数据格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;read&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot;&gt;2,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1.5&quot;&gt;&quot;UUID_02:threadId_02&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;3&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1        &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;2        &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;{anyLock}:UUID_02:threadId_02:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1        &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们看下释放锁的核心代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;RedissonReadLock &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;RedissonLock &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;RLock {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected RFuture&amp;lt;Boolean&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;unlockInnerAsync&lt;span class=&quot;hljs-params&quot; readability=&quot;28.5&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot; readability=&quot;57&quot;&gt;long threadId) {&lt;br/&gt;String timeoutPrefix = getReadWriteTimeoutNamePrefix(threadId);&lt;br/&gt;String keyPrefix = getKeyPrefix(threadId, timeoutPrefix);&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local mode = redis.call('hget', KEYS[1], 'mode'); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (mode == false) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('publish', KEYS[2], ARGV[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return 1; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local lockExists = redis.call('hexists', KEYS[1], ARGV[2]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (lockExists == 0) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return nil;&quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; +&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local counter = redis.call('hincrby', KEYS[1], ARGV[2], -1); &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (counter == 0) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('hdel', KEYS[1], ARGV[2]); &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end;&quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('del', KEYS[3] .. ':' .. (counter+1)); &quot; +&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (redis.call('hlen', KEYS[1]) &amp;gt; 1) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local maxRemainTime = -3; &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local keys = redis.call('hkeys', KEYS[1]); &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;for n, key in ipairs(keys) do &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;counter = tonumber(redis.call('hget', KEYS[1], key)); &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if type(counter) == 'number' then &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;for i=counter, 1, -1 do &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local remainTime = redis.call('pttl', KEYS[4] .. ':' .. key .. ':rwlock_timeout:' .. i); &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;maxRemainTime = math.max(remainTime, maxRemainTime);&quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; +&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if maxRemainTime &amp;gt; 0 then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('pexpire', KEYS[1], maxRemainTime); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return 0; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end;&quot; + &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if mode == 'write' then &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return 0;&quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end; &quot; +&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('del', KEYS[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('publish', KEYS[2], ARGV[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return 1; &quot;,&lt;br/&gt;Arrays.&amp;lt;Object&amp;gt;asList(getName(), getChannelName(), timeoutPrefix, keyPrefix), &lt;br/&gt;LockPubSub.unlockMessage, getLockName(threadId));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端A来释放锁：&lt;/strong&gt;&lt;br/&gt;对应的KEYS和ARGV参数为：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;KEYS&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = anyLock&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;KEYS[2] = redisson_rwlock:{anyLock}&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;KEYS[3] = {anyLock}:UUID_01:threadId_01:rwlock_timeout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KEYS[4] = {anyLock}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ARGV&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = 0&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ARGV[2] = UUID_01:threadId_01&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来开始执行操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;hget anyLock mode，mode = read&lt;/li&gt;
&lt;li&gt;hexists anyLock UUID_01:threadId_01，肯定是存在的，因为这个客户端A加过读锁&lt;/li&gt;
&lt;li&gt;hincrby anyLock UUID_01:threadId_01 -1，将这个客户端对应的加锁次数递减1，现在就是变成1，counter = 1&lt;/li&gt;
&lt;li&gt;del {anyLock}:UUID_01:threadId_01:rwlock_timeout:2，删除了一个timeout key&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时Redis中的数据结构为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;read&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot;&gt;1,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_02:threadId_02&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;{anyLock}:UUID_02:threadId_02:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时继续往下，具体逻辑如图：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/03/21/BTILbtm9Uw2gKVq.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;hlen anyLock &amp;gt; 1，就是hash里面的元素超过1个&lt;/li&gt;
&lt;li&gt;pttl {anyLock}:UUID_01:threadId_01:rwlock_timeout:1，此时获取那个timeout key的剩余生存时间还有多少毫秒，比如说此时这个key的剩余生存时间是20000毫秒&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个for循环的含义是获取到了所有的timeout key的最大的一个剩余生存时间，假设最大的剩余生存时间是25000毫秒&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端A继续来释放锁：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时客户端A执行流程还会和上面一直，执行完成后Redis中数据结构为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;read&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_02:threadId_02&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_02:threadId_02:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为这里会走&lt;code&gt;counter == 0&lt;/code&gt;的逻辑，所以会执行&lt;code&gt;&quot;redis.call('hdel', KEYS[1], ARGV[2]); &quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端B继续来释放锁：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端B流程也和上面一直，执行完后就会删除anyLock这个key&lt;/p&gt;
&lt;h5 id=&quot;h-3&quot;&gt;同一个客户端/线程先加写锁再加读锁&lt;/h5&gt;
&lt;p&gt;上面已经分析过这种情形，操作过后Redis中数据结构为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;write&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01:write&quot;: &lt;span class=&quot;hljs-number&quot;&gt;1,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时客户端A来释放读锁：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;hincrby anyLock UUID_01:threadId_01 -1，将这个客户端对应的加锁次数递减1，现在就是变成1，counter = 0&lt;/li&gt;
&lt;li&gt;hdel anyLock UUID_01:threadId_01，此时就是从hash数据结构中删除客户端A这个加锁的记录&lt;/li&gt;
&lt;li&gt;del {anyLock}:UUID_01:threadId_01:rwlock_timeout:1，删除了一个timeout key&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时Redis中数据变成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;write&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01:write&quot;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hredisson-4&quot;&gt;Redisson写锁释放原理&lt;/h4&gt;
&lt;p&gt;先看下写锁释放的核心逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;RedissonWriteLock &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;RedissonLock &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;RLock {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected RFuture&amp;lt;Boolean&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;unlockInnerAsync&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long threadId) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local mode = redis.call('hget', KEYS[1], 'mode'); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (mode == false) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('publish', KEYS[2], ARGV[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return 1; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;end;&quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (mode == 'write') then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local lockExists = redis.call('hexists', KEYS[1], ARGV[3]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (lockExists == 0) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return nil;&quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;else &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (counter &amp;gt; 0) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('pexpire', KEYS[1], ARGV[2]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;return 0; &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;else &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('hdel', KEYS[1], ARGV[3]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;if (redis.call('hlen', KEYS[1]) == 1) then &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('del', KEYS[1]); &quot; +&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.call('publish', KEYS[2], ARGV[1]); &quot; + &lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;else &quot; +&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;h-4&quot;&gt;同一个客户端多次可重入加写锁 / 同一个客户端先加写锁再加读锁&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;客户端A加两次写锁释放&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;此时Redis中数据为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;write&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;UUID_01:threadId_01:write&quot;: &lt;span class=&quot;hljs-number&quot;&gt;2,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端A来释放锁KEYS和ARGV参数：&lt;/p&gt;
&lt;ul readability=&quot;-0.98230088495575&quot;&gt;&lt;li&gt;
&lt;p&gt;KEYS&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = anyLock&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;KEYS[2] = redisson_rwlock:{anyLock}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ARGV&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;1&lt;/a&gt; = 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ARGV[2] = 30000&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ARGV[3] = UUID_01:threadId_01:write&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;直接分析lua代码：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上面mode=write，后面使用hincrby进行-1操作，此时count=1&lt;/li&gt;
&lt;li&gt;如果count&amp;gt;0，此时使用pexpire然后返回0&lt;/li&gt;
&lt;li&gt;此时客户端A再来释放写锁，count=0&lt;/li&gt;
&lt;li&gt;hdel anyLock UUID_01:threadId_01:write&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时Redis中数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;write&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后续还会接着判断，如果count=0，代表写锁都已经释放完了，此时hlen如果&amp;gt;1，代表加的还有读锁，所以接着执行：&lt;code&gt;hset anyLock mode read&lt;/code&gt;, 将写锁转换为读锁&lt;/p&gt;
&lt;p&gt;最终Redis数据为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;anyLock: {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;mode&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;read&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;UUID_01:threadId_01&quot;: &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1&lt;br/&gt;}&lt;p&gt;{anyLock}:UUID_01:threadId_01:rwlock_timeout:&lt;span class=&quot;hljs-number&quot;&gt;1    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-5&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;Redisson陆续也更新了好几篇了，疫情期间宅在家里一直学习Redisson相关内容，这篇文章写了2天，从早到晚。&lt;/p&gt;
&lt;p&gt;读写锁这块内容真的很多，本篇篇幅很长，如果学习本篇文章最好跟着源码一起读，后续还会继续更新Redisson相关内容，如有不正确的地方，欢迎指正！&lt;/p&gt;
&lt;h3 id=&quot;h-6&quot;&gt;申明&lt;/h3&gt;
&lt;p&gt;本文章首发自本人博客：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;https://www.cnblogs.com/wang-meng&lt;/a&gt; 和公众号：&lt;strong&gt;壹枝花算不算浪漫&lt;/strong&gt;，如若转载请标明来源!&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴可关注个人公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;img title=&quot;22.jpg&quot; src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200113101814097-1897655561.jpg&quot; alt=&quot;22.jpg&quot;/&gt;&lt;/h3&gt;
</description>
<pubDate>Sun, 22 Mar 2020 00:05:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 关于读写锁，大家应该都了解JDK中的ReadWriteLock， 当然Redisson也有读写锁的实现。 所谓读写锁，就是多个客户端同时加读锁，是不会互斥的，多个客户端可以同时加这个读锁，读锁和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12543108.html</dc:identifier>
</item>
<item>
<title>奇思妙想-java实现另类的pipeline模式 - 车干飞</title>
<link>http://www.cnblogs.com/jiefzz/p/12543896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiefzz/p/12543896.html</guid>
<description>&lt;hr/&gt;
&lt;p&gt;在公司做项目是见到前辈们写的一段任务链的代码，大概如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Runnable task = new TaskA(new TaskB(new TaskC(new taskD())));
task.run();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;taskA执行run调用并完成TaskA声明的任务逻辑之后，内部会自动调用构造参数传入的TaskB的run方法，过程类似TaskA，TaskB完成之后一样会调用参数传入的task，直到最后一个没有带下一个task类传入的任务完成，即完成一个管道式调用。&lt;/p&gt;
&lt;p&gt;爱思考的我在想，可用，不好用重用，于是动手改改。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;经过一段时间开发后，有了一个常用的工具类，方便快速开发，但是这里用到的东西很少，还是要说明一下，这里用到一个我称作ecommon的包，当然我只用了两个很基础的额部分。这两个部分完全可以用你自己的实现，是非常简单的。&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;函数接口&lt;/p&gt;
&lt;p&gt;jdk8之后很方便让我们写出lambda，但是我觉得理解起来不直观，于是自己重写了 12 个接口，按参数个数和返回类型可以直接根据函数名直接选出你要的。具体在 https://github.com/kimffy24/EJoker/tree/dev/ejoker-common/src/main/java/pro/jiefzz/ejoker/common/system/functional ， IVoid打头的就是无返回的，后面的数字就是要带多少个参数，参数和返回类型全部都是泛型。1-6个参数已经能包括大部分情况了，需要更多参数的情况完全可以自定义一个上下文传递过去。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;字符串填充类&lt;/p&gt;
&lt;p&gt;类似&lt;code&gt;String.format&lt;/code&gt;，但是我不用正则，而是类似slf4j那种，&lt;code&gt;log.info(&quot;This is a template, keyA={}, keyB={}&quot;, &quot;valueA&quot;, &quot;valueB&quot;)&lt;/code&gt; , 类似这种占位填充。我的实现在 https://github.com/kimffy24/EJoker/blob/dev/ejoker-common/src/main/java/pro/jiefzz/ejoker/common/system/helper/StringHelper.java 的fill方法中。你也可以用 &lt;code&gt;String.format&lt;/code&gt; 代替。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先明确，jdk8以下的情况不作考虑。&lt;/p&gt;
&lt;p&gt;pipeline我更多的印象是来自终端上的应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030753951-253545695.png&quot; alt=&quot;命令终端中使用管道&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pipeline是单向的，上个task的输出作为下个task的输入，直到没有下一个task，最后一个task的作用就应该是你期望的。且&lt;code&gt;后续任务只关心前者的输出结果，对于的他是谁，怎么做的，是不关心的&lt;/code&gt;。记为 &lt;code&gt;Point1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个特点是我视为管道与切面或职责链模式的区别所在。&lt;/p&gt;
&lt;p&gt;首先，我们得有第一推动，让管道流能有个开始，再就是有中间task，他必定是能接收到上一个任务的输出的，并且，可能有自带参数，并且有自己的输出，最后，有latest的task 与中间task区别在于他不用返回了，latest一般是以副作用的形式实现我们的企图的，如上图的 &lt;code&gt;wc -l&lt;/code&gt; 作为最后一个任务是直接把结果打印到屏幕上，而不是返回一个变量给我们读取。根据java的强类型属性，以及刚刚一段的分析，可以得知，有3种类型的任务，开始任务，中间任务，最后任务，并且中间任务的个数是不限的，所有任务至于相邻的任务有一个关联点，那就是 &lt;code&gt;前者的输出类型与后者的输入类型一致&lt;/code&gt; （网文中大部分说自己实现的pipeline的模式都是传递Object类型，到各个子任务中自己强转到需要的类型的，不说好与不好，但我肯定不喜欢）。这个特性记为 &lt;code&gt;Point2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而且，每个子任务，本身是可以带参数的，这是一个需要支持的点。像上图命令中的管道，每个子命令（除第一个）都是同时接受前一个命令的输出作为输入，且自带参数的。但是java在这里其实并不灵活，因此我们约定 &lt;code&gt;后续任务的第一个参数就是前一个任务的输入&lt;/code&gt; ， 这个约定是直接影响到我们的代码实现的。这个特性记为 &lt;code&gt;Point3&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外，管道的入口唯一的，一定是从开始任务往后流的。如果入口不一样，那么就是像个不同的管道，他们的意图以及输入输出的期望都是不同的。这个特性记为 &lt;code&gt;Point4&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，在java中使用，我肯定不能像终端那种，错了重敲命令就是了，所以需要异常控制以及做一些相邻任务承上启下的时刻做点什么，例如日子打印，断言等。这个算附加题。&lt;/p&gt;

&lt;p&gt;（因为我已经写完并测试完了，所以我就反过来解析我是怎么想的了）&lt;/p&gt;
&lt;p&gt;这里以Runnable接口作为基础接口。给出其中一个测试的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030735113-1079892834.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里初始任务是给出一个日期，中间任务是拼接成人类友好的1句话，最终任务是直接打印到屏幕。（现实中要实现这样一句话，当然是直接撸啦。这里只是为了演示），看看Pipeline初始任务的定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030725911-1345377620.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先不看其他属性，看构造方法，传入一个 &lt;code&gt;IFunction&amp;lt;R&amp;gt;&lt;/code&gt; ，按照准备一节的定义，他是一个返回类型为声明泛型R，且无参数输入的闭包函数（或称作lambda表达式）。对照上面PipelineTest中就是那个 &lt;code&gt;() -&amp;gt; { return new Date(); }&lt;/code&gt; ， （得益于jdk8的类型推断，在 &lt;code&gt;new Pipeline&amp;lt;&amp;gt;&lt;/code&gt; 构造时，不用再声明其泛型，编译器能根据闭包函数的return类型推断出这里是个Date类型）。&lt;code&gt;next&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt; 是指明管道的下接任务，这可以看出管道是极其类似于任务链/职责链的（需要注意&lt;code&gt;next&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;同时&lt;code&gt;只能有个一个存在&lt;/code&gt;）。hook是异常管理以及任务间承接时做一个切面方法的，argCxt是记下传递参数，方便hook中的方法使用（这个是因为java需要的，跟管道模式并没有关系）。&lt;/p&gt;
&lt;p&gt;再看add方法的一个重载，添加并返回中间task&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030715837-1066405785.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;add方法传入一个&lt;code&gt;IFunction1&amp;lt;RT, R&amp;gt;&lt;/code&gt;的闭包（lambda），尾数为1，意味着接受一个 &lt;code&gt;R&lt;/code&gt; 类型的输入，并在方法升声明了 &lt;code&gt;RT&lt;/code&gt; ，以 &lt;code&gt;RT&lt;/code&gt; 类型作为输出。其中 &lt;code&gt;R&lt;/code&gt; 的泛型声明在类上，就是与构造方法的 &lt;code&gt;R&lt;/code&gt; 是同一个类型。而 &lt;code&gt;RT&lt;/code&gt; 的具体类型的推断会根据具体的lambda的返回类型决定。这里add方法会返回刚刚构造出来的中间任务的声明对象。add方法需要保证当前任务是没被声明过后续任务的。&lt;/p&gt;
&lt;p&gt;再看MiddlePipeline类的定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030704756-867013562.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先看构造方法，他就是接受add方法传入的闭包。他声明了两个泛型变量 分别是 &lt;code&gt;&amp;lt;C, P&amp;gt;&lt;/code&gt;，其中 &lt;code&gt;C&lt;/code&gt;代表他的输入类型， &lt;code&gt;P&lt;/code&gt;代表的他的产出类型。同初始任务一样，他也有&lt;code&gt;next&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 指明他的管道后接任务（&lt;code&gt;next&lt;/code&gt;）。可以注意到这里的 &lt;code&gt;next&lt;/code&gt; 和初始任务的属性 &lt;code&gt;next&lt;/code&gt; 的产出类型都是被放上了泛型通配符 &lt;code&gt;?&lt;/code&gt; ，是因为任务并没办法知道他的子任务的产出类型的（后面会再说一下这个问题）。&lt;/p&gt;
&lt;p&gt;再看add方法的一个另一个重载，添加并返回最终task&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030648612-1130378346.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类似返回中间态的task，只不过这里用了无返回的闭包。&lt;/p&gt;
&lt;p&gt;再看EndPipeline类的定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030634985-1804044334.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终task的定义清爽很多，他只关心输入，并执行。并且他没有后续任务。&lt;/p&gt;
&lt;p&gt;再来补充下AbstractPipeline的解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030620006-86834999.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个写法是为了实现&lt;code&gt;Point4&lt;/code&gt;所描述的事的，只要是同一个pipeline上的task所有入口都是初始任务上的那个&lt;code&gt;run&lt;/code&gt;方法。（为了省事实现，后续任务的基类和所有派生类都是初始任务的非静态内部类）&lt;/p&gt;
&lt;p&gt;再看看初版版本run方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030606193-856703736.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;逻辑很简单，执行初始任务，得到结果，然后找后续任务，把结果作为输入来执行后续任务，（其中循环时满足上一个输出作为下一个输入），直到有一个管道类的中间态任务为&lt;code&gt;null&lt;/code&gt;，然后判断最终任务是否为&lt;code&gt;null&lt;/code&gt; ，非空则执行它。&lt;/p&gt;
&lt;p&gt;需要说明一下这里用 &lt;code&gt;@SuppressWarnings&lt;/code&gt; 压制了警告，是因为确信java编译器能确保连续两个add进来的task之间的输入输出的类型关系是一致的（这一点，如果不一致，在编写代码时IDE就会报错了）。&lt;/p&gt;
&lt;p&gt;到此，一个简单的java实现的pipeline模式基本可以用，跑最开始那个demoTest是没有问题了。&lt;/p&gt;
&lt;p&gt;再给一个样例demo&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030552930-291087516.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;管道中的3个方法的职责就如他的名字那样（实现上我这里只是简单的new一下），然后同过Pipeline类以及它的add方法串起来，执行结果如红色部分。聪明的人肯定能想到，那么像那个java的stream的？嗯很像，stream是类似把元素放到单个跑到上，按照定义那样的自己跑到终点（这也是使用方代码方便地切换到并行流的原因，因为逻辑一致，当然，并发问题是另一个层面的问题）。&lt;/p&gt;
&lt;p&gt;而pipeline则横向的一阶段一阶段地执行，如果要增加吞吐量怎么搞？聪明的你肯定能想到分片了，这样走下去就跟parallelstream的意图不谋而合了。那么还有别的好处吗？嗯，你想想Mock测试？职责上有没有让你更好切分了（正如这里命令的方法名那这样）？&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上面一节基本上能把 &lt;code&gt;Point1&lt;/code&gt; 、 &lt;code&gt;Point2&lt;/code&gt;的一半 、 &lt;code&gt;Point3&lt;/code&gt; 、 &lt;code&gt;Point4&lt;/code&gt; 实现了，剩下 &lt;code&gt;Point2&lt;/code&gt;中说到的，除了接收前一个任务的输入，还允许管道声明时传入参数的这个功能，以及那个附加题说到的java应用上的妥协。&lt;/p&gt;
&lt;h3 id=&quot;pipeline声明上附带参数&quot;&gt;pipeline声明上附带参数&lt;/h3&gt;
&lt;p&gt;这个时候就要好好用到 &lt;code&gt;准备&lt;/code&gt; 一节中的那些 &lt;code&gt;函数接口&lt;/code&gt; 了。说起来并不好解析，但是如果你了解过curry柯里化这个概念的话，那一看图你就懂了，看图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030537356-556573524.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是把带参数的lambda重新包装一次为不带参数的lambda表达式。后面middlePipeline的带参数部分则是重新封装为一个只接受一个参数且返回类型相同的lambda表达式，这是类似的。&lt;/p&gt;
&lt;p&gt;来一个测试看看，并附上图中说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030515413-664352904.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对java友好支持&quot;&gt;对java友好支持&lt;/h3&gt;
&lt;p&gt;附加题说的这个就跟简单了，找个地方分别设置好两个玩意，在对应的地方执行他们就是了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PipelineHook {
    
    private boolean preventThrow = false;

    // 异常发生时执行此表达式
    public final IVoidFunction3&amp;lt;PipelineHook, Exception, Object[]&amp;gt; exceptionHandler;
    
    // 调用后续任务钱执行此lambda表达式
    public final IVoidFunction1&amp;lt;Object&amp;gt; aspecter;

    public PipelineHook(IVoidFunction3&amp;lt;PipelineHook, Exception, Object[]&amp;gt; exceptionHandler, IVoidFunction1&amp;lt;Object&amp;gt; aspecter) {
        this.exceptionHandler = exceptionHandler;
        this.aspecter = aspecter;
    }

    public PipelineHook(IVoidFunction1&amp;lt;Object&amp;gt; aspecter) {
        this(null, aspecter);
    }

    public PipelineHook(IVoidFunction3&amp;lt;PipelineHook, Exception, Object[]&amp;gt; exceptionHandler) {
        this(exceptionHandler, null);
    }

    // 是否阻止异常抛出
    public boolean isPreventThrow() {
        return preventThrow;
    }

    // 设置标记阻止异常抛出
    public void setPreventThrow() {
        this.preventThrow = true;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过两个lambda变量构造出hook对象，并通过初始任务的的 &lt;code&gt;addPipelineHook&lt;/code&gt; 方法set进去，他们具体在 &lt;code&gt;run&lt;/code&gt; 方法体中发挥作用，现在，run方法更新为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1704011/202003/1704011-20200322030454933-300708278.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;getCxtInfo&lt;/code&gt; 方法会把当前子任务的参数转化是字符串，让异常信息能够被人读懂。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;今天先到这里了，整体下来，觉得跟stream太像了，我发现用stream码起来特爽，读起来特惨（特别是读别人的多重stream的时候），而这个pipeline正好相反耶。总的来说，就是个模式，需要提高吞吐量的话，使用分片配合线程池的话，吞吐量会得到巨量提升哦（把每个分配的大小设置为1不就是我们的parallelStream吗？哈哈）。&lt;/p&gt;
&lt;p&gt;issue在: https://github.com/kimffy24/EJoker/issues/30&lt;/p&gt;
&lt;p&gt;初次提交: https://github.com/kimffy24/EJoker/commit/c71e5d76a0904249b7c1399bd8ba52ec72fe9a0e&lt;/p&gt;
</description>
<pubDate>Sat, 21 Mar 2020 19:09:00 +0000</pubDate>
<dc:creator>车干飞</dc:creator>
<og:description>磕叨 在公司做项目是见到前辈们写的一段任务链的代码，大概如下 taskA执行run调用并完成TaskA声明的任务逻辑之后，内部会自动调用构造参数传入的TaskB的run方法，过程类似TaskA，Tas</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiefzz/p/12543896.html</dc:identifier>
</item>
<item>
<title>MySQL InnoDB表的碎片量化和整理（data free能否用来衡量碎片？） - MSSQL123</title>
<link>http://www.cnblogs.com/wy123/p/12535644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wy123/p/12535644.html</guid>
<description>&lt;p&gt;&lt;br/&gt;网络上有很多MySQL表碎片整理的问题，大多数是通过demo一个表然后参考data free来进行碎片整理，这种方式对myisam引擎或者其他引擎可能有效（本人没有做详细的测试）.&lt;br/&gt;对Innodb引擎是不是准确的，或者data free是不是可以参考，还是值得商榷的。&lt;br/&gt;本文基于MySQL的Innodb存储引擎，数据库版本是8.0.18，对碎片（fragment）做一个简单的分析，来说明如何量化表的碎片化程度。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;涉及的参数&lt;br/&gt;&lt;/strong&gt;1，information_schema_stats_expiry&lt;br/&gt;information_schema是一个基于共享表空间的虚拟数据库，存储的是一些系统元数据信息，某些系统表的数据并不是实时更新的，具体更新是基于参数information_schema_stats_expiry。&lt;br/&gt;information_schema_stats_expiry默认值是86400秒，也就是24小时，意味着24小时刷新一次information_schema中的数据，做测试的时候可以设置为0，实时刷新information_schema中的元数据信息。&lt;br/&gt;2，innodb_fast_shutdown&lt;br/&gt;因为要基于磁盘做一些统计，需要将缓存或者redo log中的数据在重启实例的时候实时刷入磁盘，这里设置为0，在重启数据库的时候将缓存或者redo log实时写入表的物理文件。&lt;br/&gt;3，innodb_stats_persistent_sample_pages&lt;br/&gt;因为涉及一些系统数据更新时对page的采样比例，这里设置为一个较大的值，为100000，尽可能高比例采样来生成系统数据。&lt;br/&gt;4，innodb_flush_log_at_trx_commit sync_binlog &lt;br/&gt;因为涉及大量数据的写操作，为加快测试，关闭double 1模式。&lt;br/&gt;5，innodb_fill_factor&lt;br/&gt;页面填充率保留默认的设置，默认值是100&lt;br/&gt;以上涉及的参数仅针对本测试，并不一定代表最优，同时测试过程中（数据写入或者删除后）会不断地重启实例，以刷新相对应的物理文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;碎片的概念&lt;/strong&gt;&lt;br/&gt;数据存储在文件系统上的时候，总是不能100%利用分配给它的物理空间，比如删除数据会在页面上留下一些”空洞”，或者随机写入（聚集索引非线性增加）会导致页分裂，页分裂会导致页面的利用空间少于50%。&lt;br/&gt;另外对表进行增删改，包括对应的二级索引值的随机的增删改，都会导致数据页面上留下一些“空洞”，虽然这些位置有可能会被重复利用，但终究会导致部分物理空间未被使用，也就是碎片。&lt;br/&gt;即便是设置了填充因子为100%，Innodb也会主动留下page页面1/16的空间作为预留使用（An &lt;a class=&quot;link&quot; href=&quot;https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_fill_factor&quot;&gt;&lt;code class=&quot;literal&quot;&gt;innodb_fill_factor&lt;/code&gt;&lt;/a&gt; setting of 100 leaves 1/16 of the space in clustered index pages free for future index growth.）。&lt;br/&gt;关系数据库的存储结构原理上是类似的，理论上很简单，就不过多啰嗦了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;测试表以及数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做个简单的测试，表结构如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `fragment_test` (
    `id` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
    `c1` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    `c2` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    `c3` &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    `c4` &lt;/span&gt;&lt;span&gt;DATETIME&lt;/span&gt;(&lt;span&gt;6&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`) 
);

&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; idx_c1 &lt;span&gt;ON&lt;/span&gt;&lt;span&gt; fragment_test(c1);
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; idx_c2 &lt;span&gt;ON&lt;/span&gt;&lt;span&gt; fragment_test(c2);
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; idx_c3 &lt;span&gt;ON&lt;/span&gt; fragment_test(c3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成200W测试数据（CALL test_insertdata(2000000);）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; DEFINER&lt;span&gt;=&lt;/span&gt;`root`@`&lt;span&gt;%&lt;/span&gt;` &lt;span&gt;PROCEDURE&lt;/span&gt;&lt;span&gt; `test_insertdata`(
    &lt;/span&gt;&lt;span&gt;IN&lt;/span&gt; `loopcount` &lt;span&gt;INT&lt;/span&gt;&lt;span&gt;
)
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
  &lt;span&gt;declare&lt;/span&gt; v_uuid  &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; loopcount&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; do
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; v_uuid &lt;span&gt;=&lt;/span&gt;&lt;span&gt; uuid();
        &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; fragment_test(c1,c2,c3,c4) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;RAND&lt;/span&gt;()&lt;span&gt;*&lt;/span&gt;&lt;span&gt;200000000&lt;/span&gt;,&lt;span&gt;RAND&lt;/span&gt;()&lt;span&gt;*&lt;/span&gt;&lt;span&gt;200000000&lt;/span&gt;,UUID(),NOW(&lt;span&gt;6&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; loopcount &lt;span&gt;=&lt;/span&gt; loopcount &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;end&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询语句，参考自最后的链接中的文章&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; NAME, 
        TABLE_ROWS,
        UPDATE_TIME, 
            format_bytes(data_length) DATA_SIZE,
       format_bytes(index_length) INDEX_SIZE,
       format_bytes(data_length&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;index_length) TOTAL_SIZE,
       format_bytes(data_free) DATA_FREE,
       format_bytes(FILE_SIZE) FILE_SIZE,
       format_bytes((FILE_SIZE&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; (data_length&lt;span&gt;/&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; 
                           index_length&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;))&lt;span&gt;*&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;) WASTED_SIZE  
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; information_schema.TABLES &lt;span&gt;as&lt;/span&gt;&lt;span&gt; t 
&lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt; information_schema.INNODB_TABLESPACES &lt;span&gt;as&lt;/span&gt;&lt;span&gt; it 
  &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; it.name &lt;span&gt;=&lt;/span&gt; concat(table_schema,&quot;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;,table_name) 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; TABLE_NAME &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fragment_test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;碎片的测试&lt;/strong&gt;&lt;br/&gt;上面说到数据在存储的时候，总是无法100%利用物理存储空间，Innodb甚至会自己主动预留一部分空闲的空间（1/16），那么如何衡量一个表究竟有多少尚未利用的空间？&lt;br/&gt;这里从系统表information_schema.tables和information_schema.innodb_tablespaces，来对比实际使用空间和已分配空间来对比，来间接量化碎片或者说未利用空间的程度。&lt;/p&gt;
&lt;p&gt;然后观察数据空间的分配情况，尽管系统表中的数据不是完全准确的，但是也比较接近实际的200W，系统表显示1971490，暂时抛开这一小点误差。&lt;br/&gt;可以很清楚地看到，数据和索引的空间是329MB，文件空间是344MB，DATA_FREE空间是6MB。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380271/202003/380271-20200321230620363-1882129984.png&quot; alt=&quot;&quot; width=&quot;1020&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随机删除1/4的数据，也就是50W行，然后重启实例，并分析表（analyze table），继续来观察这个空间的分配（DELETE FROM fragment_test ORDER BY RAND() LIMIT 500000;）&lt;br/&gt;这里看到，&lt;br/&gt;1，系统表显示150000行，跟表中的数据完全一致（尽管更多的时候这个值是一个大概的值，并不一定准确，严格说可能非常不准确，这里归因于innodb_stats_persistent_sample_pages的设置）。&lt;br/&gt;2，数据文件空间没有增加（344MB），可以理解，因为这里是删数据操作，所以不用申请空间。&lt;br/&gt;3，删除了1/4的数据，数据和索引的的大小基本上不变，这里就开始有疑问了，为什么没有成比例减少？&lt;br/&gt;4，data_free增加了3MB，显然这不是跟删除的数据成比例增加的&lt;br/&gt;那么怎么理解碎片？DATA_FREE怎么理解？碎片或者说可用空间又怎么衡量？&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380271/202003/380271-20200321233310649-1562602761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从200W数据中随机删除50W，也就是1/4，表的空间没有变化，可以肯定的是现在存在大量的碎片或者说可用空间，但是表的总的大小没变化，data_free也基本上没有变化到这里就有点说不通了。&lt;br/&gt;那么data free到底是怎么计算的，看官方的解释：&lt;/p&gt;
&lt;p&gt;The number of allocated but unused bytes.&lt;br/&gt;InnoDB tables report the free space of the tablespace to which the table belongs. For a table located in the shared tablespace, this is the free space of the shared tablespace.&lt;br/&gt;If you are using multiple tablespaces and the table has its own tablespace, the free space is for only that table.&lt;br/&gt;&lt;span&gt;&lt;span&gt;Free space means the number of bytes in completely free extents minus a safety margin&lt;/span&gt;. Even if free space displays as 0, it may be possible to insert rows as long as new extents need not be allocated.&lt;br/&gt;&lt;/span&gt;&lt;span&gt;data_free的计算方式或者说条件，是完全空闲的区（extents，每个区1MB，64个连续的16 kb 大小的page），只有一个完全没有使用的区，才统计为data_free，因此data_free并不能反映出来真正的空闲空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同时测试中发现，performance_schema.tables中的table_rows会受到innodb_stats_persistent_sample_pages的影响，但是data_length和index_length看起来是不会受innodb_stats_persistent_sample_pages的影响的&lt;br/&gt;这里采样比例已经足够大，尽管table_rows已经是一个完全准确的数字了，但是data_length和index_length却仍旧是一个误差非常大的数字。&lt;br/&gt;说到这里，那么这个碎片问题如何衡量？如果只是看performance_schema.tables或者information_schema.INNODB_TABLESPACES，其实依旧是一个无解的问题，因为无法通过这些信息，得到一个相对准确的碎片化程度。&lt;br/&gt;其实在这里（&lt;a href=&quot;https://lefred.be/content/overview-of-fragmented-mysql-innodb-tables/&quot; target=&quot;_blank&quot;&gt;参考链接&lt;/a&gt;）的评论中也提到这个问题，我是比较赞同的。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380271/202003/380271-20200321235037905-800098351.png&quot; alt=&quot;&quot; width=&quot;723&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要真正得到碎片程度，其实还是需要重建表来对比实现，这里删除了1/4的数据，理论上就有大概1/4的可用空间，但是上面的查询结果并不能给出一个明确的答案，怎么验证这个答案呢？&lt;br/&gt;这里就要粗暴地优化表了（optimize table fragment_test+analyze table），优化表只是“重整”了碎片，但是系统表的数据并没有更新，因此必须要再执行一次分析表 analyze table来更新元数据信息&lt;br/&gt;其实这里也能说明，analyze table只是更新元数据，如果存储空间没有更新（recreated），单纯地analyze table也是没有用的。&lt;br/&gt;对标进行optimize和anlayze之后，这里可以看到，物理空间确实减少了大概1/4的量。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380271/202003/380271-20200322000141493-2113436466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里其实就是为了说明一个问题：Innodb表无法通过data free来判断表的碎片化程度。&lt;/p&gt;
&lt;p&gt;然而这里（&lt;a title=&quot;https://lefred.be/content/mysql-innodb-disk-space/&quot; href=&quot;https://lefred.be/content/mysql-innodb-disk-space/&quot; target=&quot;_blank&quot;&gt;参考链接&lt;/a&gt;）的测试说明删除数据后data free有明显的变化，这个又是为什么，刚特么说无法通过data free来判断表的碎片化程度，现在又说删除数据后data free有明显的变化？？？&lt;br/&gt;其实（&lt;a href=&quot;https://lefred.be/content/overview-of-fragmented-mysql-innodb-tables/&quot; target=&quot;_blank&quot;&gt;参考链接&lt;/a&gt;）中有另外一个比较有意思的测试，相对用随机删除的方式，采用连续删除的时候（或者是整个表的数据全部删除），这个data free确实会相对准确地体现出来删除数据后表size的变化情况。&lt;br/&gt;这又是为什么？其实不难理解，上面已经说了，data free的计算方式，是按照完全“干净”的区（extent）来做统计的，&lt;br/&gt;如果按照聚集索引连续的方式删除（相对随机删除），那些存储连续数据的区（extent）是可以完全释放出来的，这些区的空间释放出来之后，会被认为是data free，所以data free此时又是相对来说准确的。&lt;br/&gt;因此，很多测试，如果想到得到客观的数据，需要尽可能多地考虑到对应的场景和测试数据情况。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;碎片的衡量&lt;/strong&gt;&lt;br/&gt;实际业务中，对标的删除或者增删改，很少是按照聚集索引进行批量删除，或者说一旦存在随机性的删除或者更新（页分裂），都会造成一定程度的碎片，而这个碎片化的程度是无法通过data free来衡量的。&lt;br/&gt;那么又如何衡量这个碎片程度呢？&lt;br/&gt;1，自己根据业务进行预估，在可接受程度内进行optimize table，记录optimize table之后的table size变化程度，来衡量一个表在一定时间操作后的碎片化程度，从而来指导是否，或者多久对该表再次进行optimize table&lt;br/&gt;2，采用上述连接中提到的&lt;a href=&quot;https://github.com/jeremycole/innodb_ruby&quot;&gt;innodb_ruby&lt;/a&gt; 这个工具，直接解析表的物理文件，这种方式相对来说更加直接。不过这个工具本人没来得及测试，理论上是没有问题的。&lt;br/&gt;　这里盗用上述链接中的图片，绿色的是实际使用的空间，中间的黑块就是所谓的碎片或者说是空洞。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/380271/202003/380271-20200322003652307-629408792.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;613&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考链接：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/innodb-file-defragmenting.html&quot;&gt;&lt;br/&gt;https://dev.mysql.com/doc/refman/5.7/en/innodb-file-defragmenting.html&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/tables-table.html&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/tables-table.html&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://lefred.be/content/overview-of-fragmented-mysql-innodb-tables/&quot;&gt;https://lefred.be/content/overview-of-fragmented-mysql-innodb-tables/&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://lefred.be/content/mysql-innodb-disk-space/&quot;&gt;https://lefred.be/content/mysql-innodb-disk-space/&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_fill_factor&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_fill_factor&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 21 Mar 2020 17:07:00 +0000</pubDate>
<dc:creator>MSSQL123</dc:creator>
<og:description>网络上有很多MySQL表碎片整理的问题，大多数是通过demo一个表然后参考data free来进行碎片整理，这种方式对myisam引擎或者其他引擎可能有效（本人没有做详细的测试）.对Innodb引擎是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wy123/p/12535644.html</dc:identifier>
</item>
<item>
<title>Spring扩展：替换IOC容器中的Bean组件 -- @Replace注解 - ocean.wen</title>
<link>http://www.cnblogs.com/ocean234/p/12320633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ocean234/p/12320633.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;1、背景：&lt;/h2&gt;
&lt;p&gt;    工作中是否有这样的场景？一个软件系统会同时有多个不同版本部署，比如我现在做的IM系统，同时又作为公司的技术输出给其他银行，不同的银行有自己的业务实现（比如登陆验证、用户信息查询等）； 又或者你的工程里依赖了公司的二方包A，A又依赖了B...这些jar包里的组件都是通过Spring容器来管理的，如果你想改B中某个类的逻辑，但是又不可能让架构组的人帮你打一份特殊版本的B；怎么办呢？是否可以考虑下直接把Spring容器里的某个组件（Bean）替换成你自己实现的Bean？&lt;/p&gt;
&lt;h2 id=&quot;原理实现&quot;&gt;2、原理&amp;amp;实现&lt;/h2&gt;
&lt;h3 id=&quot;先看看spring开放给我们的扩展&quot;&gt;2.1 先看看Spring开放给我们的扩展&lt;/h3&gt;
&lt;p&gt;    Spring框架超强的扩展性毋庸置疑，我们可以通过BeanPostProcessor来简单替换容器中的Bean。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MyBeanPostProcessor implements ApplicationContextAware, BeanPostProcessor {
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (beanName.equals(&quot;defaultConfig&quot;)) {
            // 如果遇到需要替换的Bean，我们直接换成自己实现的bean
            // 这里的myConfig要继承自defaultConfig，否则引用的地方会报错
            return applicationContext.getBean(&quot;myConfig&quot;);
        }
        return bean;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接利用Spring原生的扩展，可以平滑升级&lt;/li&gt;
&lt;li&gt;实现简单，易操作好理解，对于只需要替换少数几个Bean的情况下推荐这种方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;beanName硬编码在代码里，虽然可以把替换关系配置在properties里，但是在多版本部署，替换Bean较多时，维护这种关系将是一种负担&lt;/li&gt;
&lt;li&gt;仅仅是替换了Bean对象，对于容器中元数据如BeanDefinition等等均是原对象的，存在一定局限性&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;更优雅一点的替换方式&quot;&gt;2.2 更优雅一点的替换方式&lt;/h3&gt;
&lt;p&gt;    Spring实际上就是一个容器，底层其实就是一个ConcurrentHashMap。如果要替换Map中的Entry，再次调用put方法设置相同的key不同的value就可以了。同理，如果要替换Spring容器中的Bean组件，那么我们重新定义一个同名的Bean并注册进去就可以了。当然直接申明两个同名的Bean是过不了Spring中&lt;code&gt;ClassPathBeanDefinitionScanner&lt;/code&gt;的检查的，这时候需要我们做一点点扩展。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/631355/202003/631355-20200311113436887-1896545792.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;实现自己的classpathbeandefinitionscanner&quot;&gt;实现自己的ClassPathBeanDefinitionScanner&lt;/h4&gt;
&lt;p&gt;目前的想法是直接重写&lt;code&gt;checkCandidate&lt;/code&gt;方法，通过判断Bean的类上是否有@Replace注解，来决定是否通过检查。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/631355/202003/631355-20200315182700231-1169329733.png&quot;/&gt;&lt;br/&gt;依次往上扩展就到了&lt;code&gt;ConfigurationClassPostProcessor&lt;/code&gt;，这是Spring中非常重要的一个容器后置处理器BeanFactoryPostProcessor（上面我们用的是Bean后处理器：BeanPostProcessor），重写processConfigBeanDefinitions方法就可以引入自己实现的ClassPathBeanDefinitionScanner。&lt;br/&gt;具体细节可以参考：&lt;a href=&quot;https://github.com/hiccup234/spring-ext.git&quot; class=&quot;uri&quot;&gt;https://github.com/hiccup234/spring-ext.git&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用示例&quot;&gt;3、使用示例&lt;/h2&gt;
&lt;p&gt;    直接在项目中增加如下坐标（Maven中央仓库），目前这个版本是对Spring的5.2.2.RELEASE做扩展，新版本的Spring其相对3.X、4.X有部分代码变动。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;top.hiccup&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-ext&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.2.2.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对Spring Boot中的&lt;code&gt;SpringApplication&lt;/code&gt;做一点扩展，将上面扩展的&lt;code&gt;ConfigurationClassPostProcessor&lt;/code&gt;注册到容器中。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/631355/202003/631355-20200320000634938-1282888581.png&quot;/&gt;&lt;br/&gt;声明一个自己的类，然后继承需要替换的Bean的类型（这样就可以重写原Bean中的某些方法，从而添加自己的处理逻辑），然后用@Replace(&quot;defaultConfig&quot;)修饰，如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/631355/202003/631355-20200320011649108-521562749.png&quot;/&gt;&lt;br/&gt;通过ExtSpringApplication启动，可以看到，实际Spring容器中的Bean已经替换成我们自己实现的Bean组件了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/631355/202003/631355-20200320010734038-1183100123.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Mar 2020 15:59:00 +0000</pubDate>
<dc:creator>ocean.wen</dc:creator>
<og:description>1、背景： 工作中是否有这样的场景？一个软件系统会同时有多个不同版本部署，比如我现在做的IM系统，同时又作为公司的技术输出给其他银行，不同的银行有自己的业务实现（比如登陆验证、用户信息查询等）； 又或</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ocean234/p/12320633.html</dc:identifier>
</item>
<item>
<title>【自制操作系统14】实现键盘输入 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/12490765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/12490765.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;interrupt.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;io.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;global.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ioqueue.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; KBD_BUF_PORT 0x60 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 键盘 buffer 寄存器端口号为 0x60&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; KBD_BUF_PORT 0x60     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 键盘buffer寄存器端口号为0x60&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 键盘中断处理程序&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用转义字符定义部分控制字符 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; esc        '\033'     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 八进制表示字符,也可以用十六进制'\x1b'&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; backspace    '\b'
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; tab        '\t'
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; enter        '\r'
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; delete        '\177'     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 八进制表示字符,十六进制为'\x7f'&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 以上不可见字符一律定义为0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; char_invisible    0
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ctrl_l_char    char_invisible
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ctrl_r_char    char_invisible
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; shift_l_char    char_invisible
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; shift_r_char    char_invisible
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; alt_l_char    char_invisible
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; alt_r_char    char_invisible
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; caps_lock_char    char_invisible
&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 定义控制字符的通码和断码 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; shift_l_make    0x2a
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; shift_r_make     0x36 
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; alt_l_make       0x38
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; alt_r_make       0xe038
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; alt_r_break       0xe0b8
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ctrl_l_make      0x1d
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ctrl_r_make      0xe01d
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ctrl_r_break     0xe09d
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; caps_lock_make     0x3a
&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; ioqueue kbd_buf;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义键盘缓冲区&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 定义以下变量记录相应键是否按下的状态,
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt; * ext_scancode用于记录makecode是否以0xe0开头 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 以通码make_code为索引的二维数组 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; keymap[][&lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 扫描码   未与shift组合  与shift组合&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ---------------------------------- &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x00 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;0&lt;/span&gt;,    &lt;span&gt;0&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x01 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    {esc,    esc},        
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x02 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x03 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x04 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x05 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x06 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x07 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x08 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x09 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x0A &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x0B &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x0C &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x0D &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x0E &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    {backspace, backspace},    
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x0F &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    {tab,    tab},        
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x10 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x11 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;W&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x12 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x13 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x14 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x15 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x16 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x17 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x18 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x19 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x1A &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x1B &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x1C &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    {enter,  enter},
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x1D &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    {ctrl_l_char, ctrl_l_char},
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x1E &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x1F &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x20 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x21 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x22 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x23 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;H&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x24 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x25 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x26 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x27 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x28 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\'&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x29 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x2A &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    {shift_l_char, shift_l_char},    
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x2B &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x2C &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x2D &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x2E &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x2F &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x30 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x31 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x32 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x33 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x34 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x35 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x36    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    {shift_r_char, shift_r_char},    
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x37 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x38 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    {alt_l_char, alt_l_char},
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x39 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    {&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;},        
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 0x3A &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    {caps_lock_char, caps_lock_char}
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;其它按键暂不处理&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 键盘中断处理程序 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; intr_keyboard_handler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     put_char(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;    inb(KBD_BUF_PORT);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这次中断发生前的上一次中断,以下任意三个键是否有按下 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; ctrl_down_last =&lt;span&gt; ctrl_status;      
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; shift_down_last =&lt;span&gt; shift_status;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; caps_lock_last =&lt;span&gt; caps_lock_status;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; break_code;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;    uint16_t scancode =&lt;span&gt; inb(KBD_BUF_PORT);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt; * 所以马上结束此次中断处理函数,等待下一个扫描码进来&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (scancode == &lt;span&gt;0xe0&lt;/span&gt;&lt;span&gt;) { 
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;       ext_scancode = &lt;span&gt;true&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开e0标记&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 如果上次是以0xe0开头,将扫描码合并 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ext_scancode) {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;       scancode = ((&lt;span&gt;0xe000&lt;/span&gt;) |&lt;span&gt; scancode);
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;       ext_scancode = &lt;span&gt;false&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭e0标记&lt;/span&gt;
&lt;span&gt;135&lt;/span&gt; &lt;span&gt;   }   
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;    break_code = ((scancode &amp;amp; &lt;span&gt;0x0080&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取break_code&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;    
&lt;span&gt;139&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (break_code) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若是断码break_code(按键弹起时产生的扫描码)&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 由于ctrl_r 和alt_r的make_code和break_code都是两字节,
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;   所以可用下面的方法取make_code,多字节的扫描码暂不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;       uint16_t make_code = (scancode &amp;amp;= &lt;span&gt;0xff7f&lt;/span&gt;);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到其make_code(按键按下时产生的扫描码)&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 若是任意以下三个键弹起了,将状态置为false &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (make_code == ctrl_l_make || make_code ==&lt;span&gt; ctrl_r_make) {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;      ctrl_status = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (make_code == shift_l_make || make_code ==&lt;span&gt; shift_r_make) {
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;      shift_status = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (make_code == alt_l_make || make_code ==&lt;span&gt; alt_r_make) {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;      alt_status = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;       } &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 由于caps_lock不是弹起后关闭,所以需要单独处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接返回结束此次中断处理程序&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt; 
&lt;span&gt;156&lt;/span&gt; &lt;span&gt;   } 
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((scancode &amp;gt; &lt;span&gt;0x00&lt;/span&gt; &amp;amp;&amp;amp; scancode &amp;lt; &lt;span&gt;0x3b&lt;/span&gt;) ||&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;            (scancode == alt_r_make) ||&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;            (scancode ==&lt;span&gt; ctrl_r_make)) {
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;       &lt;span&gt;bool&lt;/span&gt; shift = &lt;span&gt;false&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否与shift组合,用来在一维数组中索引对应的字符&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; ((scancode &amp;lt; &lt;span&gt;0x0e&lt;/span&gt;) || (scancode == &lt;span&gt;0x29&lt;/span&gt;) ||&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;      (scancode == &lt;span&gt;0x1a&lt;/span&gt;) || (scancode == &lt;span&gt;0x1b&lt;/span&gt;) ||&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;      (scancode == &lt;span&gt;0x2b&lt;/span&gt;) || (scancode == &lt;span&gt;0x27&lt;/span&gt;) ||&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;      (scancode == &lt;span&gt;0x28&lt;/span&gt;) || (scancode == &lt;span&gt;0x33&lt;/span&gt;) ||&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;      (scancode == &lt;span&gt;0x34&lt;/span&gt;) || (scancode == &lt;span&gt;0x35&lt;/span&gt;&lt;span&gt;)) {  
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***** 代表两个字母的键 ********
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;             0x0e 数字'0'~'9',字符'-',字符'='
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;             0x29 字符'`'
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;             0x1a 字符'['
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;             0x1b 字符']'
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;             0x2b 字符'\\'
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;             0x27 字符';'
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;             0x28 字符'\''
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;             0x33 字符','
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;             0x34 字符'.'
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;             0x35 字符'/' 
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;        ******************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt; (shift_down_last) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果同时按下了shift键&lt;/span&gt;
&lt;span&gt;180&lt;/span&gt;         shift = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; {      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认为字母键&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt; (shift_down_last &amp;amp;&amp;amp; caps_lock_last) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果shift和capslock同时按下&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;         shift = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;      } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (shift_down_last || caps_lock_last) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果shift和capslock任意被按下&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt;         shift = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;      } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;         shift = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; 
&lt;span&gt;192&lt;/span&gt;       uint8_t index = (scancode &amp;amp;= &lt;span&gt;0x00ff&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt;       &lt;span&gt;char&lt;/span&gt; cur_char = keymap[index][shift];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在数组中找到对应的字符&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt; 
&lt;span&gt;195&lt;/span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 如果cur_char不为0,也就是ascii码为除'\0'外的字符就加入键盘缓冲区中 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;196&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cur_char) {
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt;      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;****************  快捷键ctrl+l和ctrl+u的处理 *********************
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;      * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;      * cur_char的asc码-字符a的asc码, 此差值比较小,
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;      * 属于asc码表中不可见的字符部分.故不会产生可见字符.
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;      * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt; ((ctrl_down_last &amp;amp;&amp;amp; cur_char == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) || (ctrl_down_last &amp;amp;&amp;amp; cur_char == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;         cur_char -= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;207&lt;/span&gt;       
&lt;span&gt;208&lt;/span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 若kbd_buf中未满并且待加入的cur_char不为0,
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;    * 则将其加入到缓冲区kbd_buf中 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;210&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt; (!ioq_full(&amp;amp;&lt;span&gt;kbd_buf)) {
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;         ioq_putchar(&amp;amp;&lt;span&gt;kbd_buf, cur_char);
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; 
&lt;span&gt;216&lt;/span&gt;       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;217&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (scancode == ctrl_l_make || scancode ==&lt;span&gt; ctrl_r_make) {
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;      ctrl_status = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (scancode == shift_l_make || scancode ==&lt;span&gt; shift_r_make) {
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;      shift_status = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (scancode == alt_l_make || scancode ==&lt;span&gt; alt_r_make) {
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;      alt_status = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (scancode ==&lt;span&gt; caps_lock_make) {
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;226&lt;/span&gt;      caps_lock_status = !&lt;span&gt;caps_lock_status;
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;       put_str(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unknown key\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; 
&lt;span&gt;233&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 键盘初始化&lt;/span&gt;
&lt;span&gt;234&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 键盘初始化 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;235&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; keyboard_init() {
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;     put_str(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keyboard init start\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;     register_handler(&lt;span&gt;0x21&lt;/span&gt;&lt;span&gt;, intr_keyboard_handler);
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;     put_str(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keyboard init done\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;    put_str(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keyboard init start\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;    ioqueue_init(&amp;amp;&lt;span&gt;kbd_buf);
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;    register_handler(&lt;span&gt;0x21&lt;/span&gt;&lt;span&gt;, intr_keyboard_handler);
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;    put_str(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keyboard init done\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Sat, 21 Mar 2020 15:47:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<og:description>一、到目前为止的程序流程图 为了让大家清楚目前的程序进度，画了到目前为止的程序流程图，如下。（红色部分就是我们今天要实现的） 二、简单打通键盘中断 既然要打通键盘中断，那必然需要你回顾一下&amp;#160;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flashsun/p/12490765.html</dc:identifier>
</item>
<item>
<title>Redux的createStore实现 - JobsOfferings</title>
<link>http://www.cnblogs.com/JobsOfferings/p/Redux_createStore.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JobsOfferings/p/Redux_createStore.html</guid>
<description>&lt;h2 id=&quot;redux的createstore实现&quot;&gt;Redux的createStore实现&lt;/h2&gt;
&lt;p&gt;  使用过react的同学应该对Redux这个东西有所了解。他是一种&lt;strong&gt;全局状态管理&lt;/strong&gt;的思想(对, 这里我觉得它是一种思想, 因为对于React来说, 其实Redux内部并没有什么需要与React兼容的东西, react-redux 库里才有), 它信奉的是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;唯一数据仓库&lt;/li&gt;
&lt;li&gt;只能读取&lt;/li&gt;
&lt;li&gt;数据改变只能通过纯函数进行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  这其实对我们是一种约束, 毕竟我们就算引入了Redux, 也能使用&lt;code&gt;this.props&lt;/code&gt;去进行父子组件数据传输, 但是当你需要非父子组件的通信的时候, 里面的数据流动会非常难以捉摸, 所以我们使用Redux。&lt;/p&gt;
&lt;p&gt;在React中集成Redux时, 在程序的入口处,我们可以看到这样的一段代码&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 这里的todoApp是一个Reducer函数,接受的是state和actions
const store = createStore(todoApp)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在我们的react使用单一仓库的时候,能看到一下的一些类似的代码,从中我们能看到,我们本组件的&lt;code&gt;state&lt;/code&gt;是通过&lt;code&gt;this.state = store.getState()&lt;/code&gt;所创建的, 那么我们的&lt;code&gt;store&lt;/code&gt;是一个对象,里面有一个&lt;code&gt;getState&lt;/code&gt;函数能够返回内部的&lt;code&gt;state&lt;/code&gt;,同时这个&lt;code&gt;state&lt;/code&gt;是需要持久保存的,所以我们大概能有一些思路。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React, { Component } from 'react'
import store from '../../store'
import { getIPData } from '../../store/actionCreators'

class Page extends Component {
    // 我的初始化的一个组件,已经能够使用Redux了
    constructor(props) {
        super(props);
        this.state = store.getState()
        store.subscribe(this.storeChange.bind(this));
    }

    componentWillMount() {
        // 获取IP数据,这里是作为一个dispatch的例子
        // 值得注意的是getIPData()返回的是一个带type字段的一个对象。
        const action = getIPData();
        store.dispatch(action);
    }

    render() {
        return (
            &amp;lt;div className=&quot;page&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
        )
    }

    storeChange() {
        this.setState(store.getState())
    }
}
export default Page&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  接下来我将自己写的&lt;code&gt;createStore&lt;/code&gt;函数贴出来, 然后讲解。这个函数实现了大部分功能,但是对于中间件的处理这里并没有能够实现,后面我应该会对其有一些补充。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;
export default function createStore(reducer){
    let state = null;
    const listeners = [];
    const getState = () =&amp;gt; state
    
    const dispatch = (action) =&amp;gt; {
        state = reducer(state, action)
        listeners.forEach(listener =&amp;gt; listener())
    }
    
    const subscribe = (listener) =&amp;gt; listeners.push(listener)
    
    // 这里初始化dispatch的原因是在这之前,state是为null的
    //所以我需要传一个不存在的action去reducer里面,拿到最默认的那个defaultState
    //这个defaultState写在reducer的那个文件里面
    dispatch({});
    return {
        dispatch,
        subscribe,
        getState,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  所以刚才的分析, 我们需要创建一个函数对象&lt;code&gt;createStore&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  1、&lt;code&gt;createStore&lt;/code&gt;里面用闭包的方法储存了一个&lt;code&gt;state&lt;/code&gt;,我们程序用到的仓库就是这个、还储存有一个函数数组&lt;code&gt;listeners&lt;/code&gt;,用于储存用户定义的函数(一般是用更新后的仓库重置&lt;code&gt;this.state&lt;/code&gt;),因为我其实有多个页面都注册了一个订阅函数, 所以使用函数数组, 当需要分发时取出来取出来调用即可。&lt;/p&gt;
&lt;p&gt;  2、&lt;code&gt;createStore&lt;/code&gt;需要定义一个方法&lt;code&gt;getState&lt;/code&gt;能够拿到&lt;code&gt;state&lt;/code&gt;,这样就能够在React中使用&lt;code&gt;this.state = store.getState()&lt;/code&gt;来初始化&lt;code&gt;state&lt;/code&gt;并进行读取了&lt;/p&gt;
&lt;p&gt;  3、&lt;code&gt;createStore&lt;/code&gt;还需要定义一个方法&lt;code&gt;dispatch&lt;/code&gt;, 因为redux不能直接修改&lt;code&gt;state&lt;/code&gt;的值, 所以必须通过&lt;code&gt;dispatch&lt;/code&gt;函数,传入&lt;code&gt;action&lt;/code&gt;, 然后带着&lt;code&gt;state&lt;/code&gt;直接传入&lt;code&gt;reducer&lt;/code&gt;里, &lt;code&gt;reducer&lt;/code&gt;会传回修改后的&lt;code&gt;state&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;  4、&lt;code&gt;createStore&lt;/code&gt;再需要定义一个方法&lt;code&gt;subscribe&lt;/code&gt;, 这是用来监听修改的函数, 在使用时, 绑定一个函数, 这个函数里会在外界获得&lt;code&gt;state&lt;/code&gt;。所以这个函数应该接收一个函数, 然后push入一个队列里, 可是应该实时监听的, 为何要置入队列呢?这里我的理解是, 在一开始就将&quot;外界重新获得state&quot;这个函数置入队列, 类似Promise我承诺会使用这个函数。所以这个函数的使用应该放置在&lt;code&gt;dispatch&lt;/code&gt;里面, 它传回一个&lt;code&gt;state&lt;/code&gt;后, 做的事情是将所有队列中的&quot;外界重新获得state&quot;函数全部拿出来执行一遍。&lt;/p&gt;
&lt;p&gt;  所以这个&lt;code&gt;createStore&lt;/code&gt;函数的效果很明显了,&lt;code&gt;getState&lt;/code&gt;用于获取当前&lt;code&gt;state&lt;/code&gt;, &lt;code&gt;subscribe&lt;/code&gt;用于给外界设置监听并将监听函数储存在&lt;code&gt;createStore&lt;/code&gt;函数的属性中, 每次用户通过&lt;code&gt;dispatch&lt;/code&gt;传&lt;code&gt;action&lt;/code&gt;来修改&lt;code&gt;state&lt;/code&gt;的时候, 将里面所有的监听函数拿出来执行一遍。而&lt;code&gt;dispatch&lt;/code&gt;则是用来执行&lt;code&gt;state&lt;/code&gt;修改的, 毕竟这个函数不允许使用&lt;code&gt;setState&lt;/code&gt;这类的函数。&lt;/p&gt;
&lt;p&gt;  这样, 我们就简单了解并分析了Redux的基本原理并对其进行了重写, 就像我提到的, Redux其实是一种约束的思想而出现, 这意味着在node中, 我们同样也能使用Redux(虽然我觉得可能没有必要)&lt;/p&gt;
</description>
<pubDate>Sat, 21 Mar 2020 15:43:00 +0000</pubDate>
<dc:creator>JobsOfferings</dc:creator>
<og:description>Redux的createStore实现 使用过react的同学应该对Redux这个东西有所了解。他是一种 全局状态管理 的思想(对, 这里我觉得它是一种思想, 因为对于React来说, 其实Redux</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JobsOfferings/p/Redux_createStore.html</dc:identifier>
</item>
<item>
<title>记一次nor flash固件烧录速度优化 - zqb-all</title>
<link>http://www.cnblogs.com/zqb-all/p/12493500.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zqb-all/p/12493500.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;某个方案使用的是spinor作为存储介质，每次烧录新固件都耗时数分钟，为了提高效率，需要对其进行优化。&lt;/p&gt;
&lt;h2 id=&quot;分析流程&quot;&gt;分析流程&lt;/h2&gt;
&lt;h3 id=&quot;基本流程&quot;&gt;基本流程&lt;/h3&gt;
&lt;p&gt;当前烧录流程，有一个可选步骤，全盘擦除，这个步骤耗时达数分钟。不过这是可选的。&lt;/p&gt;
&lt;p&gt;接下来必经的步骤，就是从PC端接收数据写入flash了。&lt;/p&gt;
&lt;h3 id=&quot;已有优化&quot;&gt;已有优化&lt;/h3&gt;
&lt;p&gt;目前倒是已经有一个优化，在收到数据需要写入时，会先读出flash中的数据跟这笔要写入的数据进行比较，如果数据相同就直接跳过，数据不同，才进行擦除和写入。&lt;br/&gt;这个优化的依据是，相对于一次擦除和写入的耗时来说，读出和比较的耗时很少，一旦命中就可节省掉这次写的开销。在平时调试的时候，两次烧录的固件可能有些数据是完全一样的，这种场景下此处的优化就能发挥作用了。&lt;/p&gt;
&lt;h3 id=&quot;优化点&quot;&gt;优化点&lt;/h3&gt;
&lt;p&gt;初步分析，从流程上看没什么问题，最大的耗时在擦除上，但毕竟nor的物理特性就是需要先擦除再写入的。&lt;/p&gt;
&lt;p&gt;但仔细分析，其实还是有优化空间的，这个空间还就在于nor的擦除上。&lt;/p&gt;
&lt;p&gt;nor拥有多条擦除的命令，可以擦除4k,32k,64k或者整片擦除。这些命令的耗时是不同的。&lt;/p&gt;
&lt;p&gt;方案上由于分区规划设置了最小为4k的分区，所以nor就被配置为4k sector，则nor驱动使用的擦除命令就是对应的4k擦除的命令。而这是效率最低的一种擦除方式。&lt;/p&gt;
&lt;p&gt;当前方案在全盘擦除时，是使用循环调用4k擦除实现的，在后续写入数据时也都是以4k为单位进行擦除和写入，在擦除上耗费了大量时间。&lt;/p&gt;
&lt;h2 id=&quot;nor的几种擦除命令&quot;&gt;nor的几种擦除命令&lt;/h2&gt;
&lt;p&gt;这几种擦除方式，差异到底有多大呢?&lt;/p&gt;
&lt;p&gt;找两款16M的norflash规格书看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/908492/202003/908492-20200314174654805-896133943.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比较表格：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;18.75&lt;/td&gt;
&lt;td&gt;26%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;12.5&lt;/td&gt;
&lt;td&gt;17%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;16 * 1024&lt;/td&gt;
&lt;td&gt;3500&lt;/td&gt;
&lt;td&gt;0.85&lt;/td&gt;
&lt;td&gt;1.2%&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;另一款：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/908492/202003/908492-20200314175818373-1299968009.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比较表格：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;140&lt;/td&gt;
&lt;td&gt;17.5&lt;/td&gt;
&lt;td&gt;70%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;15.62&lt;/td&gt;
&lt;td&gt;62%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;16 * 1024&lt;/td&gt;
&lt;td&gt;2600&lt;/td&gt;
&lt;td&gt;0.63&lt;/td&gt;
&lt;td&gt;2.5%&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从以上统计结果看，一次擦除的空间越大，平均速度就越快。&lt;/p&gt;
&lt;p&gt;特别是chip擦除的速度高达到4k擦除的几十倍。&lt;/p&gt;
&lt;h2 id=&quot;优化方案&quot;&gt;优化方案&lt;/h2&gt;
&lt;p&gt;找到了优化点，结合烧录流程就有了以下思路&lt;/p&gt;
&lt;h3 id=&quot;方案一&quot;&gt;方案一&lt;/h3&gt;
&lt;p&gt;设法将4k擦除改为32k,64k擦除。&lt;br/&gt;这种对于分区本身并非4k对齐来说，实现上会比较麻烦，需要代码中维护一个缓冲区进行数据的拼接，并处理一些边界情况。&lt;/p&gt;
&lt;h3 id=&quot;方案二&quot;&gt;方案二&lt;/h3&gt;
&lt;p&gt;在烧录的最开始进行一次chip擦除。并在后续的写入时，跳过擦除步骤，直接写入。&lt;br/&gt;这种方案对于烧录场景来说，非常合适，实现起来也简单。&lt;/p&gt;
&lt;p&gt;最终采用方案二，改动小，效果明显，烧录速度从数分钟降到了1分钟以内。&lt;br/&gt;但这个只适用于烧录场景。如果是要对系统运行时的写性能进行优化，就只能考虑尽量用64k擦除了。&lt;/p&gt;
&lt;p&gt;本文地址: &lt;a href=&quot;https://www.cnblogs.com/zqb-all/p/12493500.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zqb-all/p/12493500.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公众号: &lt;a href=&quot;https://sourl.cn/rgbq6M&quot; class=&quot;uri&quot;&gt;https://sourl.cn/rgbq6M&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Mar 2020 15:42:00 +0000</pubDate>
<dc:creator>zqb-all</dc:creator>
<og:description>背景 某个方案使用的是spinor作为存储介质，每次烧录新固件都耗时数分钟，为了提高效率，需要对其进行优化。 分析流程 基本流程 当前烧录流程，有一个可选步骤，全盘擦除，这个步骤耗时达数分钟。不过这是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zqb-all/p/12493500.html</dc:identifier>
</item>
<item>
<title>等价类计数：Burnside引理 &amp; Polya定理 - sun123zxy</title>
<link>http://www.cnblogs.com/sun123zxy/p/burnsidepolya.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sun123zxy/p/burnsidepolya.html</guid>
<description>&lt;p&gt;提示: 本文并非严谨的数学分析，有很多地方是自己瞎口胡的，仅供参考。有错误请不吝指出 :p&lt;/p&gt;
&lt;h2 id=&quot;群&quot;&gt;1. 群&lt;/h2&gt;
&lt;h3 id=&quot;群的概念&quot;&gt;1.1 群的概念&lt;/h3&gt;
&lt;p&gt;群 &lt;span class=&quot;math inline&quot;&gt;\((S,\circ)\)&lt;/span&gt; 是一个元素集合 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 和一种二元运算 $ \circ $ 的合称，其满足以下性质。&lt;/p&gt;
&lt;h5 id=&quot;封闭性&quot;&gt;封闭性&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall a,b \in S\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(\exist c \in S\)&lt;/span&gt; 使得 &lt;span class=&quot;math inline&quot;&gt;\(c = a \circ b\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;结合律&quot;&gt;结合律&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall a,b,c \in S\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(a \circ (b \circ c) = (a \circ b) \circ c\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;单位元&quot;&gt;单位元&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\exist I \in S\)&lt;/span&gt; ，使得对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall a \in S\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(a \circ I = I \circ a = a\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据定义，单位元具有唯一性，即一个群只有一个单位元。&lt;/p&gt;
&lt;p&gt;证明：设 &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 都是 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的单位元，则 &lt;span class=&quot;math inline&quot;&gt;\(a = a \circ b = b\)&lt;/span&gt; ，两者实质上相同。&lt;/p&gt;
&lt;h5 id=&quot;逆元&quot;&gt;逆元&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall a \in S\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(\exist a^{-1} \in S\)&lt;/span&gt; ，使得 &lt;span class=&quot;math inline&quot;&gt;\(a \circ a^{-1} = a^{-1} \circ a = I\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据定义，逆元具有唯一性，即每个元素有且仅有一个逆元。&lt;/p&gt;
&lt;p&gt;证明：设 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 有两个逆元 &lt;span class=&quot;math inline&quot;&gt;\(b,c\)&lt;/span&gt; ，则 &lt;span class=&quot;math inline&quot;&gt;\(b = b \circ I = b \circ (a \circ c) = (b \circ a) \circ c = I \circ c = c\)&lt;/span&gt; ，两者实质相同。&lt;/p&gt;
&lt;p&gt;这也同时说明了不存在两个元素 &lt;span class=&quot;math inline&quot;&gt;\(a, b\)&lt;/span&gt; 的逆元是同一个元素 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;，因为 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 只有唯一一个逆元。&lt;/p&gt;
&lt;p&gt;即逆元是一一对应的。&lt;/p&gt;
&lt;h3 id=&quot;更抽象的群&quot;&gt;1.2 更抽象的群&lt;/h3&gt;
&lt;p&gt;我们更进一步，将 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 中的每一个元素视为一个函数， 默认 &lt;span class=&quot;math inline&quot;&gt;\(\circ\)&lt;/span&gt; 代表函数的复合，即 &lt;span class=&quot;math inline&quot;&gt;\((f \circ g) (x) = f(g(x))\)&lt;/span&gt;。所以现在一个群可以只用一个函数集合 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 来表示。&lt;/p&gt;
&lt;p&gt;例如，记 &lt;span class=&quot;math inline&quot;&gt;\(r_\theta (x)\)&lt;/span&gt; 表示将 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 旋转 &lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt; 度，那么 &lt;span class=&quot;math inline&quot;&gt;\(S = \{ r_{0^\circ}, r_{90^\circ},r_{180^\circ},r_{270^\circ}\}\)&lt;/span&gt; 就是一个群。&lt;/p&gt;
&lt;p&gt;证明一下，显然有封闭性和结合律。&lt;/p&gt;
&lt;p&gt;单位元是 &lt;span class=&quot;math inline&quot;&gt;\(r_{0^\circ}\)&lt;/span&gt; ，因为 &lt;span class=&quot;math inline&quot;&gt;\(r_{0^\circ} (r_\theta(x)) = r_{\theta^\circ} (r_0 (x)) = r_\theta(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 中元素 $r_\theta $ 的逆元便是 &lt;span class=&quot;math inline&quot;&gt;\(r_{360^\circ - \theta}\)&lt;/span&gt; ，因为他们两个卷起来就是 &lt;span class=&quot;math inline&quot;&gt;\(I = r_{0^{\circ}}\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;提示&quot;&gt;1.3 提示&lt;/h3&gt;
&lt;p&gt;由于群满足封闭性，所以我们在寻找群的时候一定要“找完”所有可能的状态，例如 &lt;span class=&quot;math inline&quot;&gt;\(\{ r_{0^\circ}, r_{90^\circ}\}\)&lt;/span&gt; 就不是一个群。&lt;/p&gt;
&lt;h2 id=&quot;burnside&quot;&gt;2. Burnside&lt;/h2&gt;
&lt;p&gt;首先明确这个定理是用来干什么的——等价类计数。&lt;/p&gt;
&lt;p&gt;注：通常我使用 &lt;span class=&quot;math inline&quot;&gt;\(a,b,c,d \in C\)&lt;/span&gt; 表示计数对象， &lt;span class=&quot;math inline&quot;&gt;\(f,g,h \in G\)&lt;/span&gt; 表示变换。&lt;/p&gt;
&lt;h3 id=&quot;等价&quot;&gt;2.1 等价&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;给定一个作用在计数集合 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 上的变换集合 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;，若 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 中计数对象 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 可以由计数对象 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 通过 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 中变换得到，即 &lt;span class=&quot;math inline&quot;&gt;\(\exist f \in G\)&lt;/span&gt; 使得 &lt;span class=&quot;math inline&quot;&gt;\(d = c \circ f\)&lt;/span&gt;，我们便称 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 等价，记作 &lt;span class=&quot;math inline&quot;&gt;\(c \sim d\)&lt;/span&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 其实就是个函数集合，其中的函数都接受 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 中元素作为参数，输出也是 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 中元素。&lt;/p&gt;
&lt;p&gt;类似的我们记 &lt;span class=&quot;math inline&quot;&gt;\(f(c)\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(c \circ f\)&lt;/span&gt; ，表示对计数对象 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 做变换 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;我们同样可以对一个函数做变换，即 &lt;span class=&quot;math inline&quot;&gt;\(f \circ g\)&lt;/span&gt; 是允许的。请参考上文“1.2 更抽象的群”。&lt;/p&gt;
&lt;p&gt;在Burnside中，&lt;strong&gt;我们要求 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 是一个群&lt;/strong&gt;。这样我们可以导出一些关于等价的性质。&lt;/p&gt;
&lt;h5 id=&quot;自反性&quot;&gt;自反性&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(a \sim a\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 是群，故有单位元 &lt;span class=&quot;math inline&quot;&gt;\(I \in G\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(a \circ I = a\)&lt;/span&gt; ，满足等价定义。&lt;/p&gt;
&lt;h5 id=&quot;对称性&quot;&gt;对称性&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(a \sim b \iff b \sim a\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(a \circ f = b\)&lt;/span&gt; ，因为 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 是群，故存在 &lt;span class=&quot;math inline&quot;&gt;\(f^{-1}\)&lt;/span&gt; 使得 &lt;span class=&quot;math inline&quot;&gt;\(b \circ f^{-1} = a\)&lt;/span&gt; ，满足等价定义。同理反向再证一次即可得出充分完全性。&lt;/p&gt;
&lt;h5 id=&quot;传递性&quot;&gt;传递性&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(a \sim b , b \sim c \Rightarrow a \sim c\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(a \circ f = b, b \circ g = c\)&lt;/span&gt;，因为 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 是群，所以 &lt;span class=&quot;math inline&quot;&gt;\(f \circ g \in G\)&lt;/span&gt;（封闭性），&lt;span class=&quot;math inline&quot;&gt;\(a \circ (f \circ g) = (a \circ f) \circ g = b \circ g = c\)&lt;/span&gt;，满足等价定义。&lt;/p&gt;
&lt;h3 id=&quot;等价类及等价类计数&quot;&gt;2.2 等价类及等价类计数&lt;/h3&gt;
&lt;p&gt;等价类即所有等价的计数元素的集合。计数集合 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 由许多个等价类构成，好比连通块。 统计 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 中有多少个等价类，就是等价类计数。&lt;/p&gt;
&lt;p&gt;如何快速的等价类计数，便是我们接下来所研究的。&lt;/p&gt;
&lt;h3 id=&quot;弱化版&quot;&gt;2.3 弱化版&lt;/h3&gt;
&lt;p&gt;不妨先来研究一个弱化版本，这可以帮助我们捋清思路。&lt;/p&gt;
&lt;h4 id=&quot;引理&quot;&gt;2.3.1 引理&lt;/h4&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;若对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall c \in C,f \in G \quad (f \not= I)\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(c \circ f \not= c\)&lt;/span&gt; 都成立，那么对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall c \in C, f \in G,g \in G \quad (f \not= g)\)&lt;/span&gt; ，都有 &lt;span class=&quot;math inline&quot;&gt;\(c \circ f \not= c \circ g\)&lt;/span&gt; ，即与 &lt;span class=&quot;math inline&quot;&gt;\(\forall c\)&lt;/span&gt; 等价的元素有且仅有 &lt;span class=&quot;math inline&quot;&gt;\(|G|\)&lt;/span&gt; 个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用反证法。若 &lt;span class=&quot;math inline&quot;&gt;\(\exist c,f,g\)&lt;/span&gt; 使得 &lt;span class=&quot;math inline&quot;&gt;\(c \circ f = c \circ g\)&lt;/span&gt; ，那么有 &lt;span class=&quot;math inline&quot;&gt;\(c \circ f \circ g^{-1} = c\)&lt;/span&gt; ，即 &lt;span class=&quot;math inline&quot;&gt;\(c \circ (f \circ g^{-1}) = c\)&lt;/span&gt; 。同时因为 &lt;span class=&quot;math inline&quot;&gt;\(f \not= g\)&lt;/span&gt; ，所以 &lt;span class=&quot;math inline&quot;&gt;\(f \circ g^{-1} \not= I\)&lt;/span&gt; 。于是与假设产生矛盾，故引理成立。&lt;/p&gt;
&lt;p&gt;对 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 做变换得到的元素两两不同，共有 &lt;span class=&quot;math inline&quot;&gt;\(|G|\)&lt;/span&gt; 种变换，故有且仅有 &lt;span class=&quot;math inline&quot;&gt;\(|G|\)&lt;/span&gt; 个元素与 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 等价。&lt;/p&gt;
&lt;h4 id=&quot;弱化版burnside&quot;&gt;2.3.2 弱化版Burnside&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;若对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall c \in C,f \in G \quad (f \not= I)\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(c \circ f \not= c\)&lt;/span&gt; 都成立，那么&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 等价类计数 = \frac{|C|}{|G|} \]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是肉眼可得的结论。由引理，对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall c\)&lt;/span&gt; ，都有且仅有 &lt;span class=&quot;math inline&quot;&gt;\(|G|\)&lt;/span&gt; 个互不相同的元素与其等价。由于等价的传递性，这 &lt;span class=&quot;math inline&quot;&gt;\(|G|\)&lt;/span&gt; 个元素是封闭的，实质上形成了许多个大小为 &lt;span class=&quot;math inline&quot;&gt;\(|G|\)&lt;/span&gt; 的等价类。那么等价类个数自然就是总计数元素个数 &lt;span class=&quot;math inline&quot;&gt;\(|C|\)&lt;/span&gt; 除以每个等价类的大小 &lt;span class=&quot;math inline&quot;&gt;\(|G|\)&lt;/span&gt; 了。&lt;/p&gt;
&lt;h3 id=&quot;标准版&quot;&gt;2.4 标准版&lt;/h3&gt;
&lt;p&gt;弱化版的关键之处在于引理， &lt;span class=&quot;math inline&quot;&gt;\(c \circ f \not= c\)&lt;/span&gt; 让我们知道每个 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 有 &lt;span class=&quot;math inline&quot;&gt;\(|G|\)&lt;/span&gt; 个互不相同的元素与其等价。我们将这个条件和这个引理做一些“推广”。&lt;/p&gt;
&lt;h4 id=&quot;稳定核-不动点&quot;&gt;2.4.1 稳定核 &amp;amp; 不动点&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;稳定核 &lt;span class=&quot;math inline&quot;&gt;\(G(c)\)&lt;/span&gt; ：对于计数对象 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; ，使得 &lt;span class=&quot;math inline&quot;&gt;\(c \circ f = c\)&lt;/span&gt; 的所有变换 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 的集合，即 &lt;span class=&quot;math inline&quot;&gt;\(\{ f \in G | c \circ f = c \}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不动点 &lt;span class=&quot;math inline&quot;&gt;\(C(f)\)&lt;/span&gt; ：对于变换 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; ，使得 &lt;span class=&quot;math inline&quot;&gt;\(c \circ f = c\)&lt;/span&gt; 的所有计数对象 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的集合，即 &lt;span class=&quot;math inline&quot;&gt;\(\{ c \in C | c \circ f = c \}\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意单个字母 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 代表整个变换集合；而 &lt;span class=&quot;math inline&quot;&gt;\(G(c)\)&lt;/span&gt; 是根据计数元素 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 生成的一个被 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 包含的变换集合；&lt;/p&gt;
&lt;p&gt;注意单个字母 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 代表整个计数集合；而 &lt;span class=&quot;math inline&quot;&gt;\(C(f)\)&lt;/span&gt; 是根据变换 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 生成的一个被 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 包含的计数集合。&lt;/p&gt;
&lt;h4 id=&quot;引理1&quot;&gt;2.4.2 引理1&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{c \in C} |G(c)| = \sum_{f \in G} |C(f)| \]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \sum_{c \in C} |G(c)| &amp;amp;= \sum_{c \in C} \sum_{f \in G} [c \circ f = c] \\ &amp;amp;= \sum_{f \in G} \sum_{c \in C} [c \circ f = c] \\ &amp;amp;= \sum_{f \in G} |C(f)| \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实质是更换枚举方式。&lt;/p&gt;
&lt;h4 id=&quot;引理2&quot;&gt;2.4.3 引理2&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall c\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(G(c)\)&lt;/span&gt; 是个群。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分别证明群的四个性质即可。&lt;/p&gt;
&lt;h5 id=&quot;封闭性-1&quot;&gt;封闭性&lt;/h5&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall f,g \in G(c)\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(c \circ (f \circ g) = (c \circ f) \circ g = c \circ g = c\)&lt;/span&gt; ，所以 &lt;span class=&quot;math inline&quot;&gt;\(f \circ g \in G(c)\)&lt;/span&gt; 。封闭性得证。&lt;/p&gt;
&lt;h5 id=&quot;结合律-1&quot;&gt;结合律&lt;/h5&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(G(c) \subseteq G\)&lt;/span&gt; ，结合律直接由 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 给出。&lt;/p&gt;
&lt;h5 id=&quot;单位元-1&quot;&gt;单位元&lt;/h5&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(c \circ I = c\)&lt;/span&gt; ，所以 &lt;span class=&quot;math inline&quot;&gt;\(I \in G(c)\)&lt;/span&gt; 。（这里的 &lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt; 代指 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 的单位元）&lt;/p&gt;
&lt;h5 id=&quot;逆元-1&quot;&gt;逆元&lt;/h5&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall f \in G(c)\)&lt;/span&gt; ， $ c \circ f^{-1} = (c \circ f) \circ f^{-1} = c \circ (f \circ f^{-1}) = c$ ，所以 &lt;span class=&quot;math inline&quot;&gt;\(f^{-1} \in G(c)\)&lt;/span&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;引理3&quot;&gt;2.4.4 引理3&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall c\)&lt;/span&gt; ，记 &lt;span class=&quot;math inline&quot;&gt;\(S(c)\)&lt;/span&gt; 为与 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 等价的计数元素的集合，有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ |S(c)| = \frac{|G|}{|G(c)|} \]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个引理与弱化版引理2.3.1是对应关系。请对比起来理解。&lt;/p&gt;
&lt;p&gt;我们的证明思路是：对于某个计数元素 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; ，求出 对于某个确定的变换 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; ，有多少个变换 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 与其作用效果相同，即 &lt;span class=&quot;math inline&quot;&gt;\(c \circ f = c \circ g\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ c \circ f = c \circ g \iff c \circ f \circ g^{-1} = c \iff (f \circ g^{-1}) \in G(c) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即 &lt;span class=&quot;math inline&quot;&gt;\(f ,g\)&lt;/span&gt; 对 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的作用效果相同 等价于 &lt;span class=&quot;math inline&quot;&gt;\(f \circ g^{-1}\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的稳定核内。&lt;/p&gt;
&lt;p&gt;于是对于一个变换 &lt;span class=&quot;math inline&quot;&gt;\(h \in G(c)\)&lt;/span&gt; ，根据群的基本性质，存在唯一的 &lt;span class=&quot;math inline&quot;&gt;\(g^{-1} = f^{-1} \circ h\)&lt;/span&gt; ，使得 &lt;span class=&quot;math inline&quot;&gt;\(f \circ g^{-1} = h\)&lt;/span&gt; 。变换 &lt;span class=&quot;math inline&quot;&gt;\(h \in G(c)\)&lt;/span&gt; ，所以有 &lt;span class=&quot;math inline&quot;&gt;\(|G(c)|\)&lt;/span&gt; 种取值； &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 是确定的，根据逆元唯一性， &lt;span class=&quot;math inline&quot;&gt;\(f^{-1}\)&lt;/span&gt; 也是确定的；故 &lt;span class=&quot;math inline&quot;&gt;\(g^{-1}\)&lt;/span&gt; 有 &lt;span class=&quot;math inline&quot;&gt;\(|G(c)|\)&lt;/span&gt; 种取值。又由于逆元的一一对应性， &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 有 &lt;span class=&quot;math inline&quot;&gt;\(|G(c)|\)&lt;/span&gt; 种取值。&lt;/p&gt;
&lt;p&gt;即对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall f\)&lt;/span&gt; ，都有且仅有 &lt;span class=&quot;math inline&quot;&gt;\(|G(c)|\)&lt;/span&gt; 个 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 与其作用效果相同。&lt;/p&gt;
&lt;p&gt;这说明了什么？“作用效果相同”也是一种类似等价的关系，容易证明其具有传递性，于是他们是封闭的。作用效果相同的变换实质上形成 &lt;span class=&quot;math inline&quot;&gt;\(\frac{|G|}{|G(c)|}\)&lt;/span&gt; 个大小为 &lt;span class=&quot;math inline&quot;&gt;\(|G(c)|\)&lt;/span&gt; 的两两相连的连通块或者说“作用效果相同等价类”，合起来构成了整个 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 。我们便知道了 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 通过变换可以变出 &lt;span class=&quot;math inline&quot;&gt;\(\frac{|G|}{|G(c)|}\)&lt;/span&gt; 个不同的计数元素，即与 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 等价的元素有 &lt;span class=&quot;math inline&quot;&gt;\(\frac{|G|}{|G(c)|}\)&lt;/span&gt; 个，引理3证毕。&lt;/p&gt;
&lt;h4 id=&quot;burnside-1&quot;&gt;2.4.5 Burnside&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ 等价类计数 = \frac{1}{|G|}\sum_{f \in G} |C(f)| \]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \frac{1}{|G|}\sum_{f \in G} |C(f)| &amp;amp;= \frac{1}{|G|}\sum_{c \in C} |G(c)| \quad &amp;amp;\text{...引理1} \\ &amp;amp;= \frac{1}{|G|}\sum_{c \in C} \frac{|G|}{|S(c)|} \quad &amp;amp;\text{...引理3} \\ &amp;amp;= \sum_{c \in C} \frac{1}{S(c)} \\ &amp;amp;= 等价类计数 \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;倒数第二个式子，每个元素贡献 &lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{S(c)}\)&lt;/span&gt; ，合起来便是等价类计数。这便是等价类计数的本质。&lt;/p&gt;
&lt;h3 id=&quot;burnside的本质&quot;&gt;2.5 Burnside的本质&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1437295/202003/1437295-20200321214711964-1926308585.jpg&quot; alt=&quot;来自zkx学长的课件《Polya计数.pptx》&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;直接除以4不行，因为前四种找不到4个等价的情况&lt;/p&gt;
&lt;p&gt;所以强行把它们补成4个就行了。。。&lt;/p&gt;
&lt;p&gt;Burnside就是“强行补”的过程&lt;/p&gt;
&lt;p&gt;——zkx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Burnside的精髓就在于此。&lt;/p&gt;
&lt;p&gt;Burnside弱化版，实际上是省掉了强行补的部分，使所有有效部分都在 &lt;span class=&quot;math inline&quot;&gt;\(C(I)\)&lt;/span&gt; 。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;可以发现“群”是Burnside的唯一约束&lt;/p&gt;
&lt;p&gt;这个约束几乎就是没有约束。。。&lt;/p&gt;
&lt;p&gt;所以Burnside是非常通用的等价类计数法&lt;/p&gt;
&lt;p&gt;——zkx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;置换群&quot;&gt;3. 置换群&lt;/h2&gt;
&lt;p&gt;（Burnside的内容已经结束，这里开始是Polya了）&lt;/p&gt;
&lt;h3 id=&quot;置换&quot;&gt;3.1 置换&lt;/h3&gt;
&lt;p&gt;一个置换长这样：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ (\begin{aligned} 1&amp;amp;,2,3,...,n \\ a_1&amp;amp;,a_2,a_3,...,a_n \end{aligned}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(a_1,a_2,a_3,...,a_n\)&lt;/span&gt; 是一个 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 排列。置换是一个接受序列，输出序列的函数，它表示对每一个 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; ，将原序列第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个数放到第 &lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt; 个位置上。&lt;/p&gt;
&lt;h3 id=&quot;移位置换&quot;&gt;3.2 移位置换&lt;/h3&gt;
&lt;p&gt;一个普通的移位置换长这样：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tau_n = (\begin{aligned} 1,2,3,...,n&amp;amp;-1,n \\ 2,3,4,...,&amp;amp;n,1 \end{aligned}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即全员右移1位。很自然的可以拓展到 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 位移位置换：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tau_n^k = (\begin{aligned} 1,2,3,...&amp;amp;,n-1,n \\ k,k+1,...,n&amp;amp;,1,...,k-1 \end{aligned}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;容易发现 &lt;span class=&quot;math inline&quot;&gt;\(\tau_n^k\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 个 &lt;span class=&quot;math inline&quot;&gt;\(\tau_n\)&lt;/span&gt; 的复合，所以我们写成乘方的形式。&lt;/p&gt;
&lt;h3 id=&quot;移位置换图&quot;&gt;3.3 移位置换图&lt;/h3&gt;
&lt;p&gt;移位置换 &lt;span class=&quot;math inline&quot;&gt;\(\tau_n^k\)&lt;/span&gt; 所形成的图：考虑将 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个点排成一个圆圈， &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 连 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 连 &lt;span class=&quot;math inline&quot;&gt;\(k+1\)&lt;/span&gt; ，...，&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 连 &lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1437295/202003/1437295-20200321214746101-1332316242.png&quot; alt=&quot;tau_6^2移位置换图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图便是 &lt;span class=&quot;math inline&quot;&gt;\(\tau_6^2\)&lt;/span&gt; 形成的移位置换图，共有两个环。&lt;/p&gt;
&lt;h3 id=&quot;移位置换环个数定理&quot;&gt;3.4 移位置换环个数定理&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\tau_n^k\)&lt;/span&gt; 移位置换图中环的个数为 &lt;span class=&quot;math inline&quot;&gt;\(\gcd(k,n)\)&lt;/span&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明的思路同样是已经使用多次的：求出对于一个数 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; ，有多少个数 &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; 与它在同一个环内。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall a,b\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 在同一个环内的条件为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} a \equiv b + ik \pmod n &amp;amp;\iff \exist i,j \quad s.t. \quad a = b + ik + jn \\ &amp;amp;\iff \exist i,j \quad s.t. \quad ik + jn = a - b \\ &amp;amp;\iff \gcd(k,n) | (a-b) \quad \text{...裴蜀定理} \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后两个式子之间的转化运用了二元整数解不定方程的有解条件，即裴蜀定理。&lt;/p&gt;
&lt;p&gt;那么这样一来，对于 &lt;span class=&quot;math inline&quot;&gt;\(\forall a\)&lt;/span&gt; ，显然有且仅有 &lt;span class=&quot;math inline&quot;&gt;\(\frac{n}{\gcd(k,n)}\)&lt;/span&gt; 个数与它在同一环内，故共有 &lt;span class=&quot;math inline&quot;&gt;\(\gcd(k,n)\)&lt;/span&gt; 个环。（“在同一环内”传递性导出的封闭性，这个方法在上文已经多次使用到）&lt;/p&gt;
&lt;h2 id=&quot;polya&quot;&gt;4. Polya&lt;/h2&gt;
&lt;h3 id=&quot;概念&quot;&gt;4.1 概念&lt;/h3&gt;
&lt;p&gt;Polya是等价类计数的一个特殊版本，它的变换群 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 是一个移位置换群，即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ G = \{ \tau_n^k \ | \ k \in [0,n), k \in Z \} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;显然移位置换群是一个群 &lt;del&gt;废话&lt;/del&gt;，证明很简单，同样是证明群的四个性质，这里不再赘述。&lt;/p&gt;
&lt;p&gt;用人话来说，Polya求解的一类问题计数基于一个环，而通过旋转环能够变得相同的方案算作一种（等价）。&lt;/p&gt;
&lt;p&gt;比如经典的模板题： &lt;a href=&quot;https://www.luogu.com.cn/problem/P4980&quot;&gt;洛谷P4980 Polya定理&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;给定一个 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个点， &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 条边的环，有 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 种颜色，给每个顶点染色，问有多少种本质不同的染色方案，答案对 &lt;span class=&quot;math inline&quot;&gt;\(10^9+7\)&lt;/span&gt; 取模。&lt;/p&gt;
&lt;p&gt;本质不同定义为：只需要不能通过旋转与别的染色方案相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;推导&quot;&gt;4.2 推导&lt;/h3&gt;
&lt;p&gt;有了前面那么多的铺垫，大名鼎鼎的Polya定理现在已经可以自己动手推出来了！&lt;/p&gt;
&lt;p&gt;先写出Burnside引理，并套入移位置换&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} 等价类计数 &amp;amp;= \frac{1}{|G|}\sum_{f \in G} |C(f)| \\ &amp;amp;= \frac{1}{n}\sum_{i=1}^n |C(\tau_n^i)| \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注： &lt;span class=&quot;math inline&quot;&gt;\(\tau_n^n = \tau_n^0\)&lt;/span&gt; ，上面从 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的枚举是对的&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(|C(\tau_n^i)|\)&lt;/span&gt; 是什么？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\tau_n^i\)&lt;/span&gt; 的不动点的个数，即要求 &lt;span class=&quot;math inline&quot;&gt;\(\tau_n^i\)&lt;/span&gt; 移位置换图里同一环上点颜色相同的方案数。（为了做置换后看上去和原来一样）&lt;/p&gt;
&lt;p&gt;根据移位置换环个数定理， &lt;span class=&quot;math inline&quot;&gt;\(\tau_n^i\)&lt;/span&gt; 有 &lt;span class=&quot;math inline&quot;&gt;\(\gcd(n,i)\)&lt;/span&gt; 个环。有 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 种颜色给 &lt;span class=&quot;math inline&quot;&gt;\(\gcd(n,i)\)&lt;/span&gt; 个环去染，显然方案数为 &lt;span class=&quot;math inline&quot;&gt;\(m^{\gcd(n,i)}\)&lt;/span&gt; 。我们不局限于本题推而广之，方案数是一个关于环个数 &lt;span class=&quot;math inline&quot;&gt;\(\gcd(n,i)\)&lt;/span&gt; 的函数 &lt;span class=&quot;math inline&quot;&gt;\(f(\gcd(n,i))\)&lt;/span&gt; 。（也可以是关于环大小 &lt;span class=&quot;math inline&quot;&gt;\(\frac{n}{\gcd(n,i)}\)&lt;/span&gt; 的函数，反正最重要的参数是 &lt;span class=&quot;math inline&quot;&gt;\(\gcd(n,i)\)&lt;/span&gt; ）&lt;/p&gt;
&lt;p&gt;带入原式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{1}{n}\sum_{i=1}^n f(\gcd(n,i)) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;诶！这个式子里面有 &lt;span class=&quot;math inline&quot;&gt;\(\gcd\)&lt;/span&gt; ！&lt;/p&gt;
&lt;p&gt;不用抑制住冲动，我们按照常见的莫反题目套路来。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} 等价类计数 &amp;amp;= \frac{1}{n}\sum_{i=1}^n f(\gcd(n,i)) \\ &amp;amp;= \frac{1}{n} \sum_{d|n} f(d) \sum_{i=1}^n [\gcd(n,i)=d] \quad &amp;amp;\text{...把gcd提出来枚举} \\ &amp;amp;= \frac{1}{n} \sum_{d|n} f(d) \sum_{i=1}^{\frac{n}{d}} [\gcd(\frac{n}{d},i)=1] \\ &amp;amp;= \frac{1}{n} \sum_{d|n} f(d) \varphi(\frac{n}{d}) \quad &amp;amp;\text{...欧拉函数定义} \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;好恭喜你可以在 &lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt n)\)&lt;/span&gt; 的优秀时间复杂度里求得答案了！&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;4.3 实现&lt;/h3&gt;
&lt;p&gt;提示一下实现上的一些细节。&lt;/p&gt;
&lt;p&gt;快速幂作为基本技巧就不提了；&lt;/p&gt;
&lt;p&gt;欧拉函数直接质因数分解求即可。这里会遇到一个小问题：外面一层枚举因数，里面一层分解质因数，这不 &lt;span class=&quot;math inline&quot;&gt;\(O(\sum_{d|n} \sqrt d)\)&lt;/span&gt; 了吗？&lt;/p&gt;
&lt;p&gt;实际上似乎利用数列的放缩之类的黑科技可以证明一个比 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; 更紧的上界是 &lt;span class=&quot;math inline&quot;&gt;\(O(n^{\frac 3 4})\)&lt;/span&gt; ，而且实际上跑起来非常的快。（洛谷 &lt;span class=&quot;math inline&quot;&gt;\(n=10^9\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(10^3\)&lt;/span&gt; 组数据可以随便跑过）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;/*
洛谷P4980 Polya定理
sun123zxy
朴素写法
洛谷共2.08s
2019/12/24
*/
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;ctime&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;map&amp;gt;
#include&amp;lt;set&amp;gt;
using namespace std;
typedef long long ll;
ll Rd(){
    ll ans=0;char c=getchar();
    while(c&amp;lt;'0'||c&amp;gt;'9') c=getchar();
    while(c&amp;gt;='0'&amp;amp;&amp;amp;c&amp;lt;='9') ans=ans*10+c-'0',c=getchar();
    return ans;
}
const ll MOD=1E9+7;
ll QPow(ll x,ll up){
    x%=MOD;
    ll ans=1;
    while(up)
        if(up%2==0) x=x*x%MOD,up/=2;
        else ans=ans*x%MOD,up--;
    return ans;
}
ll Inv(ll x){return QPow(x,MOD-2);}

ll Phi(ll n){
    ll t=n;
    ll ans=1;
    for(ll i=2;i*i&amp;lt;=t;i++){
        ll c=0;
        while(t%i==0) t/=i,c++;
        if(c) ans=ans*(QPow(i,c)-QPow(i,c-1)+MOD)%MOD;
    }
    if(t&amp;gt;1) ans=ans*(t-1)%MOD;
    return ans;
}

ll N;
ll Polya(ll d){
    return QPow(N,d)*Phi(N/d)%MOD;
}
void Solve(){
    ll Ans=0;
    for(ll i=1;i*i&amp;lt;=N;i++){
        if(N%i==0){
            Ans+=Polya(i);
            if(i!=N/i) Ans+=Polya(N/i);
            Ans%=MOD;
        }
    }
    Ans=Ans*Inv(N)%MOD;
    printf(&quot;%lld\n&quot;,Ans);
}
int main(){
    ll T=Rd();while(T--){
        scanf(&quot;%lld&quot;,&amp;amp;N);
        Solve();
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过当然有真正 &lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt n)\)&lt;/span&gt; 的写法。只需在最外层分解质因数，然后DFS的去枚举因数，这样就不用每次去分解 &lt;span class=&quot;math inline&quot;&gt;\(\frac{n}{d}\)&lt;/span&gt; 啦！于是这种写法就当然比上面那种快很多了。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;/*
洛谷P4980 Polya定理
sun123zxy
更优写法
洛谷共125ms
2019/12/24
*/
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;ctime&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;map&amp;gt;
#include&amp;lt;set&amp;gt;
using namespace std;
typedef long long ll;
int Rd(){
    int ans=0;char c=getchar();
    while(c&amp;lt;'0'||c&amp;gt;'9') c=getchar();
    while(c&amp;gt;='0'&amp;amp;&amp;amp;c&amp;lt;='9') ans=ans*10+c-'0',c=getchar();
    return ans;
}
const ll MOD=1E9+7;
ll QPow(ll x,ll up,bool isM=1){
    x%=MOD;
    ll ans=1;
    while(up){
        if(up%2==0) x=x*x,up/=2;
        else ans=ans*x,up--;
        if(isM) x%=MOD,ans%=MOD;
    }
    return ans;
}
ll Inv(ll x){return QPow(x,MOD-2);}

namespace Div{
    int p[30],c[30];
    int pN;
    void Div(int nb){
        pN=0;
        int t=nb;
        for(int i=2;1LL*i*i&amp;lt;=t;i++){
            if(t%i==0){
                p[++pN]=i,c[pN]=0;
                while(t%i==0) t/=i,c[pN]++;
            }
        }if(t&amp;gt;1) p[++pN]=t,c[pN]=1;
    }
}

int N;
ll Ans;
void DFS(int pos,ll d,ll phi){
    using namespace Div;
    if(pos==pN+1){
        Ans=(Ans+QPow(N,d)*phi)%MOD;
        return ;
    }
    ll tpow=1,tphi=QPow(p[pos],c[pos],0)-QPow(p[pos],c[pos]-1,0);
    for(int i=0;i&amp;lt;=c[pos];i++){
        DFS(pos+1,d*tpow,phi*tphi);
        tpow*=p[pos];
        if(i==c[pos]-1) tphi=1;
        else tphi/=p[pos];
    }
}
void Solve(){
    Div::Div(N);
    Ans=0;DFS(1,1,1);
    Ans=Ans*Inv(N)%MOD;
    printf(&quot;%lld\n&quot;,Ans);
}
int main(){
    int T=Rd();while(T--){
        scanf(&quot;%d&quot;,&amp;amp;N);
        Solve();
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;对于大多数题目，Burnside &amp;amp; Polya通常是套在最表面的那一层皮，难点一般在求 &lt;span class=&quot;math inline&quot;&gt;\(|C(f)|\)&lt;/span&gt; 或者 &lt;span class=&quot;math inline&quot;&gt;\(f(\gcd(n,i))\)&lt;/span&gt; 的部分。&lt;/p&gt;
&lt;h2 id=&quot;参考及后记&quot;&gt;6. 参考及后记&lt;/h2&gt;
&lt;h4 id=&quot;zkx-keke-彳亍-学长的-polya计数.pptx&quot;&gt;zkx / keke / 彳亍 学长的 《Polya计数.pptx》&lt;/h4&gt;
&lt;p&gt;整个PPT思路非常清晰，可以看出keke学长对Polya有极其深入的理解。我学Burnside完全是照着这个PPT一点一点的看懂的。&lt;/p&gt;
&lt;p&gt;彳亍来讲课的那个暑假可以说是真正让我在OI数学这一块有很多新的收获。感谢keke学长！&lt;/p&gt;
&lt;h4 id=&quot;算法导论第三版-31.3节-模运算&quot;&gt;《算法导论》第三版 31.3节 模运算&lt;/h4&gt;
&lt;p&gt;初稿写成后，在学习数论时偶然翻到这一节有对群的标准定义，发现自己之前的理解不够优秀。遂做了一些订正。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;我之前把交换群认成群了然后自己yy了一套理论xD&lt;/del&gt;&lt;/p&gt;
&lt;h4 id=&quot;一些想法&quot;&gt;一些想法&lt;/h4&gt;
&lt;p&gt;这大概是我最长的一篇博客了..&lt;/p&gt;
&lt;p&gt;Burnside &amp;amp; Polya 最开始是2019暑假zkx学长为我们讲授。当时云里雾里，半懂不懂。12月的时候有将近一半的同学跑去PKUWC/THUWC了，剩我这个菜鸡在机房瞎颓（（（当时就花了一两天把zkx学长的PPT慢慢看懂了，做了最初的笔记。然后在接下来的几个月里修订完善。现在用一天半的时间把笔记写成了博客，又有了些新的理解，增加了弱化版及其证明。&lt;/p&gt;
&lt;p&gt;概念多，证明绕，很容易掉进思维的陷阱。如果能一步一步把证明过程捋清楚，对思维能力的提升还是很大的。&lt;/p&gt;
&lt;p&gt;任何推导的目的都是由已知得到未知。由哪些性质推得哪些结论，好比图论中的有向边，最后应该形成一个有向无环图。如果把这个DAG搞清楚了，才是真正弄清楚了结论的来龙去脉。&lt;/p&gt;
&lt;p&gt;本文多次用到了“将等价类计数问题转换为有多少个元素与某个确定的元素等价，并利用等价传递性导出封闭性说明形成连通块”这一思想，很具有推广性。&lt;/p&gt;
&lt;p&gt;OI里的数学相关知识，都给人一种人类智慧的感觉，还是满有意思的（&lt;/p&gt;
&lt;p&gt;2020/03/21&lt;/p&gt;
</description>
<pubDate>Sat, 21 Mar 2020 15:27:00 +0000</pubDate>
<dc:creator>sun123zxy</dc:creator>
<og:description>提示: 本文并非严谨的数学分析，有很多地方是自己瞎口胡的，仅供参考。有错误请不吝指出 :p 1. 群 1.1 群的概念 群 $(S,\circ)$ 是一个元素集合 $S$ 和一种二元运算 $ \cir</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sun123zxy/p/burnsidepolya.html</dc:identifier>
</item>
</channel>
</rss>