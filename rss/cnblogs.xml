<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vue中的插槽（slot） - 杨冠标</title>
<link>http://www.cnblogs.com/yanggb/p/12439115.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanggb/p/12439115.html</guid>
<description>&lt;p&gt;vue中的插槽，指的是子组件中提供给父组件使用的一个占位符，用&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;标签表示，父组件可以在这个占位符中填充任何模板代码，比如HTML、组件等，填充的内容会替换掉子组件的&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;标签（替换占位符）。&lt;/p&gt;
&lt;p&gt;vue中的插槽大致可以分为默认插槽、具名插槽和作用域插槽三种。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认插槽&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;默认插槽是最简单的一种插槽，和上面的描述一致，就是通过替换占位符达到在父组件中更改子组件中内容的效果。&lt;/p&gt;
&lt;p&gt;在子组件中放置一个占位符（插槽）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;谁是最可爱的人？&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在父组件中引用这个子组件，并给这个占位符（插槽）填充内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;今日问答：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;当然是yanggb了&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候页面展现的内容就会是【今日问答：谁是最可爱的人？当然是yanggb了】。&lt;/p&gt;
&lt;p&gt;在上面的例子中，如果在子组件中没有放置&amp;lt;slot&amp;gt;&amp;lt;slot&amp;gt;标签占位符，就不会有【当然是yanggb了】这个答案了，问题永远得不到任何回应，这就是插槽因此而存在的意义。事实上，如果子组件中没有使用插槽，父组件要是需要往子组件中填充模板或者html，基本上是没有其他办法能做到的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具名插槽&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来想象一个这样的场景：在子组件中有两个要替换占位符的地方（两个插槽），这时候父组件如果要将相应的内容填充到相应的插槽中，靠默认插槽是没有办法的，因为没有办法判断相应的内容要填充到哪个插槽中。为了应对这样的场景，具名插槽应运而生。&lt;/p&gt;
&lt;p&gt;所谓的具名插槽，其实就是给子组件中的插槽取一个名字，而父组件就可以在引用子组件的时候，根据这个名字对号入座，将相应内容填充到相应的插槽中。&lt;/p&gt;
&lt;p&gt;在子组件中放置两个具名插槽：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;我是第一个插槽&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;slot &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;yanggb1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;我是第二个插槽&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;slot &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;yanggb2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在父组件中引用该子组件，并通过v-slot:[name]的方式将相应的内容填充到相应的插槽中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;两个插槽：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;v-slot:yanggb1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yanggb1，&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;v-slot:yanggb2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yanggb2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候页面展示的内容就会是【两个插槽：第一个插槽yanggb1，第二个插槽yanggb2】。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用默认插槽和具名插槽的注意事项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.如果子组件中存在多个默认插槽，那么父组件中所有指定到默认插槽的填充内容（未指定具名插槽），会全部填充到子组件的每个默认插槽中。&lt;/p&gt;
&lt;p&gt;2.即使在父组件中将具名插槽的填充顺序打乱，只要具名插槽的名字对应上了，填充的内容就能被正确渲染到相应的具名插槽中，一个萝卜一个坑。&lt;/p&gt;
&lt;p&gt;3.如果子组件中同时存在默认插槽和具名插槽，但是在子组件中找不到父组件中指定的具名插槽，那么该内容会被直接丢弃，而不会被填充到默认插槽中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用域插槽&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;作用域插槽的概念和使用，相比于前面的默认插槽和具名插槽，会比较难于理解和运用。前面的两个插槽强调的是填充占位的【位置】，而作用域插槽强调的则是数据作用的【范围】。&lt;/p&gt;
&lt;p&gt;所谓的作用域插槽，其实就是带参数（数据）的插槽，即在子组件的插槽中带入参数（数据）提供给父组件使用，该参数（数据）仅在插槽内有效，父组件可以根据子组件中传过来的插槽参数（数据）对展示内容进行定制。&lt;/p&gt;
&lt;p&gt;在子组件中放置一个带参数（数据）的插槽：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;插槽中的参数值是&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;slot &lt;/span&gt;&lt;span&gt;:name&lt;/span&gt;&lt;span&gt;=&quot;yanggb&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    data() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            yanggb: {
                yanggb1: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yanggb1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                yanggb2: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yanggb2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            }　　
        }
    }
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在父组件中引用该子组件，并通过slot-scope来接受子组件的插槽中传过来的参数和使用该数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;作用域插槽：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;slot-scope&lt;/span&gt;&lt;span&gt;=&quot;yanggb&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                {{ yanggb.yanggb1 }}
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候页面展示的内容就会是【作用域插槽：插槽中参数值是yanggb1】。&lt;/p&gt;
&lt;p&gt;另外，因为在template的{{}}是支持表达式的，这个时候就可以利用子组件传过来的参数值的不同进行页面内容的定制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;作用域插槽：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;slot-scope&lt;/span&gt;&lt;span&gt;=&quot;yanggb&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                {{ yanggb.yanggb1 || '空值' }}
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候，如果子组件中传过来的参数是空值，页面的展示内容就会是【作用域插槽：插槽中参数值是空值】。&lt;/p&gt;
&lt;p&gt;作用域插槽的使用场景多种多样，在各种框架中的应用也是十分广泛，比如ElementUI中的对表格的某一行或某一列进行展示内容的定制，就是作用域插槽的一个典型应用场景。&lt;/p&gt;

&lt;p&gt;&quot;你在池塘里活得很好，泥鳅很丑但会说喜庆话，癞蛤蟆马虎但很有趣，田螺是个温柔的自闭症，小鲫鱼是你们共同的女神。有一天你听说，江河湖海，哪个都要更大，更好。你跳了出去，遇到了美丽的海豚，雄壮的白鲸，婀娜多姿的热带鱼，的确都是好的。就是偶尔，觉得世界很空，生活很咸。&quot;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 23:48:00 +0000</pubDate>
<dc:creator>杨冠标</dc:creator>
<og:description>vue中的插槽，指的是子组件中提供给父组件使用的一个占位符，用&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;标签表示，父组件可以在这个占位符中填充任何模板代码，比如HTML、组件等，填充的内容会替</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanggb/p/12439115.html</dc:identifier>
</item>
<item>
<title>如何提升.NET控制台应用体验？ - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/12453593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/12453593.html</guid>
<description>&lt;blockquote readability=&quot;2.8723404255319&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://khalidabuhakmeh.com/upgraded-dotnet-console-experience&quot;&gt;Upgrade Your .NET Console App Experience&lt;/a&gt;&lt;br/&gt;作者：Khalid Abuhakmeh&lt;br/&gt;译文：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/65831/202003/65831-20200310073033336-141881694.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在.NET生态系统中，控制台程序的表现相对较差。通常来说，这种项目经常作为Demo演示使用。现在是时候让控制台应用程序得到其应有的尊重了。&lt;/p&gt;
&lt;p&gt;终端技术的发展开启了增强用户体验的复兴。 &lt;code&gt;ITerm2&lt;/code&gt;, &lt;code&gt;Hyper&lt;/code&gt;, &lt;code&gt;Windows Terminal&lt;/code&gt;，所有这些工具都为单调的控制台体验增加了一些趣味。 虽然这些工具都允许用户定制自己体验，但是对于开发人员来说，他们还希望向控制台应用程序中添加一些编程风格。&lt;/p&gt;
&lt;p&gt;在本篇博文中，我们将一起看一下如何使用一些出色的开源项目为我们的控制台程序增添趣味。这里说明的顺序并不表明项目的优劣，他们都是改善我们控制台程序体验的优秀方案。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Colorful.Console&lt;/code&gt;是一个Nuget包，它可以增强我们对控制台输出文字样式的控制。我们可以使用&lt;code&gt;System.Drawing.Color&lt;/code&gt;中定义的颜色来定义控制台程序的配色方案。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Drawing;
using Console = Colorful.Console;
...
...
Console.WriteLine(&quot;console in pink&quot;, Color.Pink);
Console.WriteLine(&quot;console in default&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/65831/202003/65831-20200310073108615-1464552182.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，&lt;code&gt;Colorful.Console&lt;/code&gt;还允许我们使用&lt;code&gt;FIGlet&lt;/code&gt;字体编写带颜色的ASCII码输出&lt;/p&gt;
&lt;blockquote readability=&quot;1.3333333333333&quot;&gt;
&lt;p&gt;FIGLet: &lt;a href=&quot;http://www.figlet.org/&quot; class=&quot;uri&quot;&gt;http://www.figlet.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;FigletFont font = FigletFont.Load(&quot;chunky.flf&quot;);
Figlet figlet = new Figlet(font);

Console.WriteLine(figlet.ToAscii(&quot;Belvedere&quot;), ColorTranslator.FromHtml(&quot;#8AFFEF&quot;));
Console.WriteLine(figlet.ToAscii(&quot;ice&quot;), ColorTranslator.FromHtml(&quot;#FAD6FF&quot;));
Console.WriteLine(figlet.ToAscii(&quot;cream.&quot;), ColorTranslator.FromHtml(&quot;#B8DBFF&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个输出的结果完全就是黑客的梦想。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/65831/202003/65831-20200310073128378-2068894522.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我建议你访问一下&lt;code&gt;colorful.console&lt;/code&gt;的官方站点，了解这个库能实现的所有效果，以便更好的改善控制台程序的体验。&lt;/p&gt;
&lt;blockquote readability=&quot;2&quot;&gt;
&lt;p&gt;Colorful.Console: &lt;a href=&quot;http://colorfulconsole.com/&quot; class=&quot;uri&quot;&gt;http://colorfulconsole.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;ConsoleTables&lt;/code&gt;包是我（作者）自己编写的，这里有一点厚颜无耻^.^。 使用这个库，可以让开发人员很轻松的将一组对象以表格的形式展示在控制台中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(String[] args)
{
    var table = new ConsoleTable(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
    table.AddRow(1, 2, 3)
         .AddRow(&quot;this line should be longer&quot;, &quot;yes it is&quot;, &quot;oh&quot;);

    table.Write();
    Console.WriteLine();

    var rows = Enumerable.Repeat(new Something(), 10);

    ConsoleTable
        .From&amp;lt;Something&amp;gt;(rows)
        .Configure(o =&amp;gt; o.NumberAlignment = Alignment.Right)
        .Write(Format.Alternative);

    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以前，谁不希望能在控制台中输出一个表格呢？&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;FORMAT: Default:

 --------------------------------------------------
 | one                        | two       | three |
 --------------------------------------------------
 | 1                          | 2         | 3     |
 --------------------------------------------------
 | this line should be longer | yes it is | oh    |
 --------------------------------------------------

 Count: 2


FORMAT: Alternative:

+----------------------------+-----------+-------+
| one                        | two       | three |
+----------------------------+-----------+-------+
| 1                          | 2         | 3     |
+----------------------------+-----------+-------+
| this line should be longer | yes it is | oh    |
+----------------------------+-----------+-------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自从&lt;code&gt;ConsoleTables&lt;/code&gt;发布以来，许多开发人员已经研发出自己的控制台表格库了。有一些甚至更好，你可以自行去查找一下。&lt;/p&gt;

&lt;p&gt;和需要其他应用程序一样，控制台程序也可以执行长时任务。&lt;code&gt;ShellProgressBar&lt;/code&gt;是一个非常棒的库，使用它，你可以在控制台输出一些非常惊艳的进度条。而且，&lt;code&gt;ShellProgressBar&lt;/code&gt;是可以实现进度条的嵌套使用。例如，如下GIF动画中展示的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/65831/202003/65831-20200310073142245-305801071.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ShellProgressBar&lt;/code&gt;使用起来相当的直接。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;const int totalTicks = 10;
var options = new ProgressBarOptions
{
    ProgressCharacter = '─',
    ProgressBarOnBottom = true
};
using (var pbar = new ProgressBar(totalTicks, &quot;Initial message&quot;, options))
{
    pbar.Tick(); //will advance pbar to 1 out of 10.
    //we can also advance and update the progressbar text
    pbar.Tick(&quot;Step 2 of 10&quot;); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;谢谢你, &lt;code&gt;Martijin Larrman&lt;/code&gt;, 这真的是一个非常好用的库。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GUI.CS&lt;/code&gt;是一个非常棒的控制台UI工具包。它提供了一个功能完善的工具箱，开发人员可以使用它构建早期控制台常见的一种用户界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/65831/202003/65831-20200310073148654-1985903242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个UI工具箱提供了如下控件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Buttons&lt;/li&gt;
&lt;li&gt;Labels&lt;/li&gt;
&lt;li&gt;Text Entry&lt;/li&gt;
&lt;li&gt;Text View&lt;/li&gt;
&lt;li&gt;User Inputs&lt;/li&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;li&gt;Menus&lt;/li&gt;
&lt;li&gt;ScrollBars&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用它，开发人员可以在控制台应用中实现一些令人难以置信的效果。这个库是由&lt;code&gt;Miguel De Icaza&lt;/code&gt;编写的，是控制台技术的巅峰之作，下面让我们一起来看一个实例程序。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Terminal.Gui;

class Demo {
    static void Main ()
    {
        Application.Init ();
        var top = Application.Top;

    // 创建顶级窗体
        var win = new Window (&quot;MyApp&quot;) {
        X = 0,
        Y = 1, // 预留菜单行

        // 使用Dim.Fill(), 它可以自动调整窗体大小，实现自适应，而无需手动敢于
        Width = Dim.Fill (),
        Height = Dim.Fill ()
    };
        top.Add (win);

    // 创建一个菜单
        var menu = new MenuBar (new MenuBarItem [] {
            new MenuBarItem (&quot;_File&quot;, new MenuItem [] {
                new MenuItem (&quot;_New&quot;, &quot;Creates new file&quot;, NewFile),
                new MenuItem (&quot;_Close&quot;, &quot;&quot;, () =&amp;gt; Close ()),
                new MenuItem (&quot;_Quit&quot;, &quot;&quot;, () =&amp;gt; { if (Quit ()) top.Running = false; })
            }),
            new MenuBarItem (&quot;_Edit&quot;, new MenuItem [] {
                new MenuItem (&quot;_Copy&quot;, &quot;&quot;, null),
                new MenuItem (&quot;C_ut&quot;, &quot;&quot;, null),
                new MenuItem (&quot;_Paste&quot;, &quot;&quot;, null)
            })
        });
        top.Add (menu);

    var login = new Label (&quot;Login: &quot;) { X = 3, Y = 2 };
    var password = new Label (&quot;Password: &quot;) {
            X = Pos.Left (login),
        Y = Pos.Top (login) + 1
        };
    var loginText = new TextField (&quot;&quot;) {
                X = Pos.Right (password),
                Y = Pos.Top (login),
                Width = 40
        };
        var passText = new TextField (&quot;&quot;) {
                Secret = true,
                X = Pos.Left (loginText),
                Y = Pos.Top (password),
                Width = Dim.Width (loginText)
        };
    
    // 添加一些其他控件
    win.Add (
        // 这是我最喜欢的布局
        login, password, loginText, passText,

        // 这里使用了绝对定位
            new CheckBox (3, 6, &quot;Remember me&quot;),
            new RadioGroup (3, 8, new [] { &quot;_Personal&quot;, &quot;_Company&quot; }),
            new Button (3, 14, &quot;Ok&quot;),
            new Button (10, 14, &quot;Cancel&quot;),
            new Label (3, 18, &quot;Press F9 or ESC plus 9 to activate the menubar&quot;));

        Application.Run ();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;作为开发人员，我们可以沉迷于GUI, 这是理所当然的，它使我们更有生产力。但是控制台应用程序同样也很强大。下次当你编写控制台程序的时候，你可以考虑使用以上介绍的某些库，以便为你的控制台应用增添色彩。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 23:33:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文： &amp;quot;Upgrade Your .NET Console App Experience&amp;quot; 作者：Khalid Abuhakmeh 译文：Lamond Lu 在.NET生态系统中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/12453593.html</dc:identifier>
</item>
<item>
<title>解决Sprite Atlas打包Asset bundles时重复打包的问题 - 陈嘉栋</title>
<link>http://www.cnblogs.com/murongxiaopifu/p/12453356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/murongxiaopifu/p/12453356.html</guid>
<description>&lt;h2&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;在Unity &lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//unity3d.com/unity/whats-new/2018.4.6&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;2018.4.6&lt;/a&gt;之前的版本，有一个和SpriteAtlas打AB包有关的常见问题。即当给Sprite Atlas打AB包时，Sprite Atlas Texture可能会被重复打包。你可以在这里查看这个issue。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;LinkCard LinkCard--noImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//issuetracker.unity3d.com/issues/android-same-atlas-assets-are-being-included-in-asset-bundle-multiple-times-when-bundle-is-built&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;https://issuetracker.unity3d.com/issues/android-same-atlas-assets-are-being-included-in-asset-bundle-multiple-times-when-bundle-is-built&lt;span class=&quot;LinkCard-meta&quot;&gt;​issuetracker.unity3d.com&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文就来讨论一下如何解决这个问题。&lt;/p&gt;
&lt;h2&gt;0x01 The Issue&lt;/h2&gt;
&lt;p&gt;首先，我会演示一下这个issue。如下图所示，有4个sprite，分别为Icon1, Icon2, Icon3 以及 SF Window（来自&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//assetstore.unity.com/packages/essentials/unity-samples-ui-25468&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;Unity Samples: UI&lt;/a&gt;）。将它们存放到一个叫 new sprite atlas 的新Sprite Atlas中。同时有一个uGUI的Panel使用了其中的一些Sprite来渲染UI元素。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-f34d9fc761b20e695b935ae01ad186ba_1440w.jpg&quot; alt=&quot;&quot; width=&quot;1186&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1186&quot; data-rawheight=&quot;670&quot; data-original=&quot;https://pic3.zhimg.com/v2-f34d9fc761b20e695b935ae01ad186ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-f34d9fc761b20e695b935ae01ad186ba_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-e9a48a5366bae6ca566b467614bbc161_1440w.jpg&quot; alt=&quot;&quot; width=&quot;2646&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2646&quot; data-rawheight=&quot;1148&quot; data-original=&quot;https://pic2.zhimg.com/v2-e9a48a5366bae6ca566b467614bbc161_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e9a48a5366bae6ca566b467614bbc161_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后使用&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//assetstore.unity.com/packages/tools/utilities/asset-bundle-browser-93571&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;AssetBundles-Browser&lt;/a&gt;分别对UI Canvas和Sprite Atlas打包。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-073244c6698e43bfd101e900d2448862_1440w.jpg&quot; alt=&quot;&quot; width=&quot;1763&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1763&quot; data-rawheight=&quot;739&quot; data-original=&quot;https://pic3.zhimg.com/v2-073244c6698e43bfd101e900d2448862_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-073244c6698e43bfd101e900d2448862_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，我们可以继续使用另一个和Assetbundle相关的很赞的工具：&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;LinkCard-backdrop&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;&lt;a href=&quot;https://github.com/faelenor/asset-bundle-analyzer&quot;&gt;https://github.com/faelenor/asset-bundle-analyzer&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来对刚刚打包的Assetbundle的内容进行分析。顺便说一下，这个工具是由一位Developer Relations Engineer 开发的，如果有反馈可以到他的工程仓库提交issue。并且这个工具需要Python2.7来执行，同时由于它的结果会保存到数据库中，因此最好有一个DB工具例如DB Browser for SQLite来查询数据库。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;python analyzer.py /Applications/Unity/Unity.app/Contents/Tools ~/projects/MyGame/AssetBundles&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ok，现在我们来看一下我们得到的数据。主表叫做“objects”，每一行数据都来自Assetbundle中的每一个asset。我们可以通过“object_view”视图来查看其内容。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-f48ed7e99eb2790533130681e3c4797d_1440w.jpg&quot; alt=&quot;&quot; width=&quot;2302&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2302&quot; data-rawheight=&quot;1436&quot; data-original=&quot;https://pic2.zhimg.com/v2-f48ed7e99eb2790533130681e3c4797d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f48ed7e99eb2790533130681e3c4797d_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，canvas和new sprite atlas 这2个Assetbundle都包含了同一个资源——spriteasset texture。我们可以在Editor中找到这张texture。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-3d11f72e2a936afbfd1b10d229f52abf_1440w.jpg&quot; alt=&quot;&quot; width=&quot;870&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;870&quot; data-rawheight=&quot;802&quot; data-original=&quot;https://pic4.zhimg.com/v2-3d11f72e2a936afbfd1b10d229f52abf_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3d11f72e2a936afbfd1b10d229f52abf_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;Editor 中的预览&lt;/p&gt;
&lt;h2&gt;0x02 The Solution&lt;/h2&gt;
&lt;p&gt;那么现在我们要如何解决这个问题呢？这个问题其实是由于所谓的“SpriteAtlas dependencies”所导致的。也就是SpriteAtlas 依赖问题。在SpriteAtlas的inspector编辑器上有一个叫做“Include in Build”的选项。这个选项开启时，会建立具体的sprite和SpriteAtlas的依赖关系，也就是说SpriteAtlas资源会随着具体的sprite走，就像Unity中其他asset之间产生依赖那样。&lt;/p&gt;
&lt;p&gt;相反，如果&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/SpriteAtlasDistribution.html%23Dontinclbuild&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;不勾选该选项&lt;/a&gt;，sprite会解除它和SpriteAtlas的依赖关系。因此，SpriteAtlas也就不会自动添加到sprite所在的ab中。之后或在运行时，就可以使用所谓的“LateBinding”来加载和绑定对应的sprite了。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;LinkCard LinkCard--noImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/LateBinding.html&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;https://docs.unity3d.com/Manual/LateBinding.html&lt;span class=&quot;LinkCard-meta&quot;&gt;​docs.unity3d.com&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体如何做呢？首先不勾选“Include in Build”选项，之后再在C#脚本中注册&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//docs.unity3d.com/ScriptReference/U2D.SpriteAtlasManager-atlasRequested.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;SpriteAtlasManager.atlasRequested&lt;/a&gt; 的回调。在这个回调中加载对应的sprite。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;LinkCard LinkCard--noImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//docs.unity3d.com/ScriptReference/U2D.SpriteAtlasManager-atlasRequested.html&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;https://docs.unity3d.com/ScriptReference/U2D.SpriteAtlasManager-atlasRequested.html&lt;span class=&quot;LinkCard-meta&quot;&gt;​docs.unity3d.com&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-f8a06755e7dfb5661973622aa4bddc49_1440w.jpg&quot; alt=&quot;&quot; width=&quot;861&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;861&quot; data-rawheight=&quot;933&quot; data-original=&quot;https://pic2.zhimg.com/v2-f8a06755e7dfb5661973622aa4bddc49_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f8a06755e7dfb5661973622aa4bddc49_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;    void OnEnable()
    {
        SpriteAtlasManager.atlasRequested += RequestAtlas;
    }

    void OnDisable()
    {
        SpriteAtlasManager.atlasRequested -= RequestAtlas;
    }

    void RequestAtlas(string tag, System.Action&amp;lt;SpriteAtlas&amp;gt; callback)
    {
        var ab = AssetBundle.LoadFromFile(Application.streamingAssetsPath + &quot;/new sprite atlas&quot;);
        var sa = ab.LoadAsset&amp;lt;SpriteAtlas&amp;gt;(tag);
        callback(sa);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，再用AssetBundle Analyzer这个工具来查看一下这次AssetBundle中的数据吧。可以看到此时只有一个spriteatlas的texture打包进了ab中。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-312bcfe8bf84c77ebfd8f8932f19abec_1440w.jpg&quot; alt=&quot;&quot; width=&quot;2256&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2256&quot; data-rawheight=&quot;950&quot; data-original=&quot;https://pic1.zhimg.com/v2-312bcfe8bf84c77ebfd8f8932f19abec_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-312bcfe8bf84c77ebfd8f8932f19abec_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ok，还记得本文一开始时说过的吗？是的，这是一个Unity2018.4.6之前的issue。在Unity 2018.4.6中，Unity已经修复了这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-79f6d50a0260798611d7fd90c8637186_1440w.jpg&quot; alt=&quot;&quot; width=&quot;2476&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2476&quot; data-rawheight=&quot;710&quot; data-original=&quot;https://pic3.zhimg.com/v2-79f6d50a0260798611d7fd90c8637186_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-79f6d50a0260798611d7fd90c8637186_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 21:34:00 +0000</pubDate>
<dc:creator>陈嘉栋</dc:creator>
<og:description>0x00 前言 在Unity&amp;#160;2018.4.6之前的版本，有一个和SpriteAtlas打AB包有关的常见问题。即当给Sprite Atlas打AB包时，Sprite Atlas Textu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/murongxiaopifu/p/12453356.html</dc:identifier>
</item>
<item>
<title>微信小程序转化为uni-app项目 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/12453173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/12453173.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　之前自己做一个uni-app的项目的时候前端需要实现一个比较复杂的动态tab和swiper切换的功能，但是由于自己前端抠脚的原因没有写出来，然后自己在网上搜索的时候发现了有个微信小程序里面的页面及极其的符合我的需求。那么问题来了我该如何将微信小程序转为为uni-app项目呢？搜索了下网上的相关解决方案还真有个将微信小程序转化为uni-app的项目，该项目名称叫做【&lt;a href=&quot;https://github.com/zhangdaren/miniprogram-to-uniapp&quot; data-pjax=&quot;#js-repo-pjax-container&quot;&gt;miniprogram-to-uniapp&lt;/a&gt;】，接下来就看看如何实操吧！&lt;/p&gt;
&lt;h2&gt;miniprogram-to-uniapp项目介绍：&lt;/h2&gt;
&lt;p&gt;概要介绍：是一个能够将微信项目转化为Uni-app项目的开源项目&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/zhangdaren/miniprogram-to-uniapp&quot;&gt;https://github.com/zhangdaren/miniprogram-to-uniapp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用指南：&lt;a href=&quot;https://ask.dcloud.net.cn/article/36037&quot;&gt;https://ask.dcloud.net.cn/article/36037&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;第一步、在window上安装NPM包管理工具：&lt;/h2&gt;
&lt;p&gt;　　由于该项目需要使用NPM包管理工具安装对应的项目包，而NPM是随同NodeJS一起安装的包管理工具，所以接下来我们只需要把node.js安装配置好即可。&lt;/p&gt;
&lt;p&gt;Node.js 安装配置详细教程：&lt;a href=&quot;https://www.runoob.com/nodejs/nodejs-install-setup.html&quot;&gt;https://www.runoob.com/nodejs/nodejs-install-setup.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;第二步、初始化一个NPM模块：&lt;/h2&gt;
&lt;h3&gt;首先查看NPM版本：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200310012406504-2086798176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;在任意盘中新建一个空白文件夹，用于存放NPM初始化模块配置：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
使用CMD进入对应的文件夹输入：npm init命令即可
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200310012914621-1447099513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第三步、使用miniprogram-to-uniapp将微信小程序转化uni-app实例：&lt;/h2&gt;
&lt;h3&gt;首先下载需要转化的微信小程序：&lt;/h3&gt;
&lt;p&gt;为了示范随便下载了一个微信小程序商城，项目地址为：&lt;a href=&quot;https://github.com/hanxue10180/shangcheng&quot;&gt;https://github.com/hanxue10180/shangcheng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下图为微信小程序的基本结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200310020359740-738587572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;安装miniprogram-to-uniapp，并将小程序转化为uni-app项目：&lt;/h3&gt;
&lt;h4&gt;因为这个包是工具，要求全局都能使用，所以需要-g进行全局安装，运行以下命令进行安装：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
npm install miniprogram-to-uniapp -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200310013611468-1254814271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 安装完成，执行以下命令查看工具版本：&lt;/h4&gt;
&lt;p&gt;（wtu -&amp;gt; 取自wx to uni之意，后面都用这个全局命令）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200310013725253-738127298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;运行以下命令将微信小程序转化为uni-app项目：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
在命令行里，输入【wtu -i &quot;你的小程序项目路径&quot;】，注意-i后面有个空格！！！如：【wtu -i &quot;G:\shangcheng&quot;】 ；
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
回车后即可以在源项目同及目录得到一个后缀为_uni的目录，即转换成功。如下图所示：
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200310014849091-295112988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200310014947120-755179805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; 大功告成，顺利转化为uni-app项目结构：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200310015104837-72597657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 17:54:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 之前自己做一个uni-app的项目的时候前端需要实现一个比较复杂的动态tab和swiper切换的功能，但是由于自己前端抠脚的原因没有写出来，然后自己在网上搜索的时候发现了有个微信小程序里面的页</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/12453173.html</dc:identifier>
</item>
<item>
<title>JAVA有关位运算的全套梳理 - 胖虎1993</title>
<link>http://www.cnblogs.com/hama1993/p/12452866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hama1993/p/12452866.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一、在计算机中数据是如何进行计算的？&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.1：java中的byte型数据取值范围&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们最开始学习java的时候知道，byte类型的数据占了8个bit位，每个位上或0或1，左边第一位表示符号位，符号位如果为1表示负数，为0则表示正数，因此要推算byte的取值范围，只需要让数值位每一位上都等于1即可。&lt;/p&gt;
&lt;p&gt;我们来用我们的常规思维来分析下byte类型的取值范围：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200309225724046-110257734.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果按照这种思路来推算，七个1的二进制数转换为十进制是127，算上符号位，取值范围应为：-127~+127，但事实上我们知道，byte的取值范围是-128~127，这里先打个问号，接着往下看。&lt;/p&gt;
&lt;p&gt;现在让我们计算下byte类型的7加上byte类型的-2是多少：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200309230151717-884948148.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;诶？跟我们预想的不一样，因为我们是知道7和-2的和应该是5才对，结果应该表示为：00000101，但事实上通过图2的结果来看确实跟预想的不一样，所以计算机在做计算的时候，肯定不是表面上的符号位+数值位的方式进行的计算的。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.2：原码，反码，补码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们先来看下定义：&lt;/p&gt;
&lt;p&gt;👉 &lt;span&gt;&lt;strong&gt;原码定义：&lt;/strong&gt;&lt;/span&gt;符号位加后面的数值，比如图2里的00000111和10000010都是原码，原码比较简单，就是我们在上面单纯理解上的原值。&lt;/p&gt;
&lt;p&gt;👉 &lt;strong&gt;&lt;span&gt;反码定义：&lt;/span&gt;&lt;/strong&gt;正数的反码就是它的原码，负数的反码符号位不变，其余数值位全部按位取反，例如：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;00000111&lt;/strong&gt;&lt;/span&gt;的反码：&lt;strong&gt;&lt;span&gt;00000111&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;10000010&lt;/span&gt;&lt;/strong&gt;的反码：&lt;strong&gt;&lt;span&gt;11111101&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;👉 &lt;strong&gt;&lt;span&gt;补码定义：&lt;/span&gt;&lt;/strong&gt;同样的，正数的补码仍然等于它的原码本身，负数的补码等于它自己的反码+1，例如：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;00000111&lt;/span&gt;&lt;/strong&gt;的补码：&lt;strong&gt;&lt;span&gt;00000111&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;10000010&lt;/span&gt;&lt;/strong&gt;的补码：&lt;span&gt;&lt;strong&gt;11111110&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;🌴 总结：正数的原码、反码、补码完全一致，负数的反码等于它原码的数值位按位取反，负数的补码等于它的反码+1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在让我们用反码的方式来计算下图2中的式子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200309231150707-1103007191.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图3&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;利用数值的反码计算出的结果已经很接近正确答案了，+4的反码等于它的原码，现在只需要让它+1就是正确答案，还记得补码的定义吗？负数的补码等于它的反码+1，那现在让我们用补码做下计算试试？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200309231312273-1649613964.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ok，我们发现，用它们的补码做加法，得到的数值就是我们想要的正确答案，事实上，计算机并没有减法运算器，所有的减法运算，都是以一个正数加上一个负数的形式来交给加法运算器计算的，由于负数的符号位为1，虽然我们人是知道它的含义，但是作为计算机，它是不知道第一位是符号位的，它要做的就仅仅是让两个数相加而已，正是因为如此，我们才不能简简单单保存负数，通过图4我们知道，两个数的补码相加，可以得到一个准确的数值。&lt;/p&gt;
&lt;p&gt;再举个相加结果为负数的例子，让两个负数相加：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200309231518279-261869021.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果结果为负数的话，也是适用的，只是它仍然是以补码的形式存放的，需要转成原码才符合我们人的理解方式。&lt;/p&gt;
&lt;p&gt;现在回到上面留下的问题，为什么byte的取值范围是-128~127呢？&lt;/p&gt;
&lt;p&gt;我们之前按照图1里的理解，理所应当的以为它应该是-127~127的范围，那是因为我们按照图1的理解方式，数值就是以符号位+数值位的方式理解的（也就是按照原码的方式理解的），但是你可以想一下，如果按照图1那种理解方式，是不是会存在两个0值呢？&lt;/p&gt;
&lt;p&gt;即：&lt;strong&gt;&lt;span&gt;10000000&lt;/span&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;span&gt;00000000&lt;/span&gt;&lt;/strong&gt;，+0和-0；&lt;/p&gt;
&lt;p&gt;其次如果站在机器角度上来说，所有的负数都很大，至少要比所有正数大，因为负数的最高位也就是符号位都是1，显然这是不对的，通过本节我们知道了，所有的数均通过自己的补码完成计算，如果将最后得到的结果转成原码，就是我们人眼可以理解的最终值（符号位+数值位），如果现在利用补码的方式做理解，符号位为0的数没啥好说的，自然取值区间为：0~127，但是符号位为1的负数呢？负数就存在一个特殊值（也就是我们之前片面理解的-0）：10000000，如果按照原码理解它是-0，但我们前面说过，计算机里所有数字，都是以补码的方式参与运算的，而负数的补码不等于其原码，这个10000000在计算机里显然是某个负数的补码，那么问题就变的简单多了，即10000000是谁的补码呢？答案是：-128，这也是为什么负数的取值范围会比正数多一个的原因，byte类型如此，其它类型也是如此，比如int型的负数取值也比正数多1。&lt;/p&gt;
&lt;p&gt;这一块的定义要清晰，对理解后面的位运算会有很大的帮助。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、java中的位运算&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.1：与运算&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;与运算符号：&lt;strong&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与运算特点：&lt;span&gt;&lt;strong&gt;1&amp;amp;1=1、1&amp;amp;0=0、0&amp;amp;1=0、0&amp;amp;0=0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在我们来举一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200309232726140-1412616824.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;让我们再来试试负数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200309234511887-850818850.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2：或、异或&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;跟与运算的运算方式一致，只不过规则不太一样：&lt;/p&gt;
&lt;p&gt;或运算符号：&lt;span&gt;&lt;strong&gt;|&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或运算规则：&lt;span&gt;&lt;strong&gt;1|1=1、1|0=1、0|1=1、0|0=0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;异或运算符号：&lt;span&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;异或运算规则：&lt;strong&gt;&lt;span&gt;1^1=0、1^0=1、0^1=1、0^0=0&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.3：按位取反&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;取反符号：&lt;strong&gt;&lt;span&gt;~&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即一个数对自己取反，例如：&lt;/p&gt;
&lt;p&gt;某个数字&lt;strong&gt;&lt;span&gt;a&lt;/span&gt;&lt;/strong&gt;的二进制为： &lt;strong&gt;&lt;span&gt;1010110&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                  则&lt;strong&gt;&lt;span&gt;~a&lt;/span&gt;&lt;/strong&gt;为： &lt;strong&gt;&lt;span&gt;0101001&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.4：左移运算&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;左移运算符：&amp;lt;&amp;lt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200309235504126-520927340.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;图8&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;位运算越界&amp;amp;数位抛弃：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图8中的116的二进制数的数值位为7位，符号位为0，此时如果左移超过24位，就会出现负数，为什么会这样？因为java中的位移越界时，java会抛弃高位越界部分，我们知道java里int类型的第一位是符号位，如果符号位是1，则表示其为负数，现在将数值位占7bit符号位为0的116左移24位，就会出现下方结果：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;01110100000000000000000000000000&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;正好31位占全，顶至符号位，低位补0，我们称24为116的不越界的最大左移值，若超出这个值，就会越界，比如左移25位：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11101000000000000000000000000000&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;显然左移25位后会把数值位的1移动到符号位，这时它表示为一个负数的补码。根据这个规则，我们如果让其左移28位，则值为：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;01000000000000000000000000000000&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是十进制的1073741824，即：116 &amp;lt;&amp;lt; 28 = 1073741824，那如果越界过多呢？比如int型的数据，左移32位：116 &amp;lt;&amp;lt; 32 = 116&lt;/p&gt;
&lt;p&gt;会发现，如果左移自己位数一样多的位数，那么这个数就等于它本身，因此运算符合以下规则：&lt;/p&gt;
&lt;p&gt;设x为被位移值，y为本次位移的位数，z为x所属类型的最大存储位数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;x &amp;lt;&amp;lt; y = x &amp;lt;&amp;lt; (y%z)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是int型（32位，long型就用64代入计算），符合如下规则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;116 &amp;lt;&amp;lt; 4 = 116 &amp;lt;&amp;lt; (4%32) = 116 &amp;lt;&amp;lt; 4 = 1856&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;116 &amp;lt;&amp;lt; 32 = 116 &amp;lt;&amp;lt; (32%32) = 116 &amp;lt;&amp;lt; 0 = 116&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;116 &amp;lt;&amp;lt; 36 = 116 &amp;lt;&amp;lt; (36%32) = 116 &amp;lt;&amp;lt; 4 = 1856&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.5：有符号右移运算&amp;amp;无符号右移运算&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;有符号右移运算符：&amp;gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无符号右移运算符：&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：a &amp;gt;&amp;gt; b&lt;/span&gt;表示a右移b位，跟上面的左移例子一样，右移也会有越界问题，只是右移越界是从右边开始抛弃越界部分的，右移操作有符号位干扰，如果是正数右移，无此干扰项，因为符号位本就是0右移不会影响值的准确性，但如果是负数，第一位是符号位，且值为1，右移就有影响了，现在仍然以116为例：&lt;/p&gt;
&lt;p&gt;正数右移：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310000941238-1725484043.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述是正数，右移无影响，但是负数，这里以-116为例，我们知道负数在计算机里是以补码的形式存储的，所以图里直接用-116的补码做运算，位移过程如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310001124259-1183259929.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你会发现右移跟左移不一样，左移是不用担心自己符号位存在“补位”问题的，但是右移存在，如图中-116右移4位后，左边第一位，也就是符号位，就面临着补位的问题，那我现在是该补1呢，还是补0呢？这也就是为什么右移操作会存在有符号右移和无符号右移两种移动方式：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;☘️ 有符号右移：&lt;/strong&gt;&lt;/span&gt;依照原符号位，如果原符号位是1，那么图4里需要补位的空位全部补1，如果原符号位为0，则全部补0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;☘️ 无符号右移：&lt;/span&gt;&lt;/strong&gt;无视原符号位，全部补0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在让我们用有符号的方式将-116右移4位，即-116 &amp;gt;&amp;gt; 4，按照有符号的规则，补位符合原符号位，则右边4位全部补1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310001359273-445191265.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图11&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;得到的仍然是个负数，它仍然是一个补码，图里展示不开，它的结果为：&lt;span&gt;&lt;strong&gt;11111111111111111111111111111000&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;经转换可知它是-8的补码，即：&lt;span&gt;&lt;strong&gt;-116 &amp;gt;&amp;gt; 4 = -8&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在再试试用无符号右移，根据无符号的特点，右移后的前四位无脑补0：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310001539303-1096877947.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图12&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图里展示不开，它的结果为：&lt;span&gt;&lt;strong&gt;00001111111111111111111111111000&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可见它是个正数，转换成十进制为：268435448，即：&lt;strong&gt;&lt;span&gt;-116 &amp;gt;&amp;gt;&amp;gt; 4 = 268435448&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后说一下，跟左移一样，右移里不管是有符号还是无符号，也符合取余的方式，计算出位移的最终位数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-116 &amp;gt;&amp;gt; 4 = -116 &amp;gt;&amp;gt; (4%32) = -116 &amp;gt;&amp;gt; 4 = -8&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-116 &amp;gt;&amp;gt; 32 = -116 &amp;gt;&amp;gt; (32%32) = -116 &amp;gt;&amp;gt; 0 = -116&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-116 &amp;gt;&amp;gt; 36 = -116 &amp;gt;&amp;gt; (36%32) = -116 &amp;gt;&amp;gt; 4 = -8&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.6：类型转换溢出&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;了解完位运算，来看一个比较实际的问题，看下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
long a = 8934567890233345621L;
int b = (int) a; //b的值为-1493678507
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终b的值是一个负数，这是由于long型64位，让int型强行接收，会出现位溢出的问题，这个流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310010252434-2090512245.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图13&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、位运算在实际项目中的运用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;位运算的性能是非常好的，相比运算流程，计算机更喜欢这种纯粹的逻辑门和移动位置的运算，但位运算在平常的业务代码里并不太常见，因为它的可读性不太好，但是我们仍然可以利用位运算来解决一些实际项目里的问题。&lt;/p&gt;
&lt;p&gt;比如用来表示开关的功能，比如需求里经常有这种字段：是否允许xx（0不允许，1允许），是否有yy权限（0没有，1有），是否存在zz（0不存在，1存在）&lt;/p&gt;
&lt;p&gt;上面只是举例，类似这种只有两种取值状态的属性，如果当成数据库字段放进去的话，太过浪费，如果之后又有类似的字段，又得新增数据库字段，为了只有两种取值的字段，实在是不太值得。&lt;/p&gt;
&lt;p&gt;这个时候何不用一个字段来表示这些字段呢？你可能已经猜到要怎么做了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310003017281-297687692.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图14&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;顶一个int型或者long型的字段，让它的每一个二进制位拥有特殊含义即可，然后按照位运算将其对应的位置上的数值变成0或1，那如何将某个数的二进制位第x位上的数值变成1或0呢？其实这在位图结构里经常用到，就是利用1这个特殊的值作位移运算后再与原值进行位运算，让我们看下这个过程：&lt;/p&gt;
&lt;p&gt;把一个数的第2位的字符变成1，现在假设这个数初始化为0，int型，我们把它当成二进制展示出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310003407411-572731548.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图15&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在如何把这个数的第二位变成1呢？目前是这样做的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
0 | 1 &amp;lt;&amp;lt; 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即原值跟1左移1位后的值作或运算，先来看看&lt;span&gt;&lt;strong&gt;1 &amp;lt;&amp;lt; 1&lt;/strong&gt;&lt;/span&gt;的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310003716853-1839181294.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图16&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后拿着图16的结果，跟原数（也就是0）进行或运算：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310003811138-1721617180.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图17&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看到，原数的第二位已经被置为1了，它的十进制对应2，其它位的数置为1也大同小异，例如，现在让第6位也变成1只需要：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
2 | 1 &amp;lt;&amp;lt; 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即拿着原值（现在为2）跟1左移5位后的数做或运算，这个流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310004033427-2112183516.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图18&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看完了把某个位置的数值置为1，那如何把某位设置为0呢？我们现在把图18里的结果的第6位重新置回0，目前的做法为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
34 &amp;amp; ~(1 &amp;lt;&amp;lt; 5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即拿着原值（经过上面几步的运算，现在值为32）跟1左移5位按位取反后的数做与运算，来看下这个流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310004339658-957286103.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图19&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过上面的流程，就可以把原值的第6位变成0了。&lt;/p&gt;
&lt;p&gt;那么我们知道了让一个数的二进制位的某位变成0或1的方法，那如何知道一个数的某位上究竟是0还是1呢？毕竟我们业务代码需要知道第几位代表什么意思并且获取到对应位置上的值。&lt;/p&gt;
&lt;p&gt;假如我现在想知道十进制int型数34的第6位是0还是1，写法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
34 &amp;gt;&amp;gt; 5 &amp;amp; 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即让原值（34）右移5位后跟1做与运算，来看下这个流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1569484/202003/1569484-20200310004659368-911662915.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图20&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由图可以看出，想要知道一个数的第几位是1还是0，只需要将其对应位置上的值“逼”到最后一位，然后跟1相与即可，如果对应位置上的值是0，那么与1相与后的结果一定为0，反之一定为1.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;☘️ &lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到这里已经说完了为什么要用一个数表示那么多开关，以及如何给一个开关位设置对应的开关值，以及如何找到对应开关位的值，有了这些操作，我们再也不需要为这种只有0和1取值的字段新增数据库字段了，因为一个int型的数字，就可以表达32个开关属性，如果超了，还可以扩成64位的long型~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 09 Mar 2020 16:51:00 +0000</pubDate>
<dc:creator>胖虎1993</dc:creator>
<og:description>一、在计算机中数据是如何进行计算的？ 1.1：java中的byte型数据取值范围 我们最开始学习java的时候知道，byte类型的数据占了8个bit位，每个位上或0或1，左边第一位表示符号位，符号位如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hama1993/p/12452866.html</dc:identifier>
</item>
<item>
<title>Cinemachine简介 - blueberryzzz</title>
<link>http://www.cnblogs.com/blueberryzzz/p/12452838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blueberryzzz/p/12452838.html</guid>
<description>&lt;p&gt;  先贴一下官方的Cinemachine文档&lt;a href=&quot;https://docs.unity3d.com/Packages/com.unity.cinemachine@2.2/manual/index.html&quot;&gt;Cinemachine Documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;  &lt;strong&gt;我们第一次使用Cinemachine时大概是这样一个流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在需要被控制的Camera上添加一个CinemachineBrain。&lt;/li&gt;
&lt;li&gt;创建一个自己需要的VirtualCamera。&lt;/li&gt;
&lt;li&gt;调整VirturalCamera上的Follow、Look At等参数。&lt;/li&gt;
&lt;li&gt;调整VirtualCamera上Body、Aim对应Component的类型和参数。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;个关键类简介&quot;&gt;3个关键类简介&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;CinemachineBrain&lt;br/&gt;  CinemachineBrain是挂在相机对象上去真正修改相机位置的脚本。负责通过VirtualCamera来计算真实相机的位置。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;VirtualCameraBase&lt;br/&gt;  通过CinemachineCompoent来计算相机位置。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;CinemachineComponentBase&lt;br/&gt;  主要分三大类Body、Aim、Noise,分别计算相机的位置、方向、噪音。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;执行过程&quot;&gt;执行过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200310003350762-636483570.jpg&quot;/&gt;&lt;br/&gt;  简单说就是CinemachineBrain每帧通过VirtualCamera计算真实相机的位置，并同步到真实相机上。&lt;br/&gt;  真正的数据计算又是通过VirtualCamera上的流水线来计算的。&lt;br/&gt;  这里只是一个简化的流程说明，真实计算还有相机切换时的混合、流水线之外的Extension、和CinemachineCore对Cinemachine的全局管理等。&lt;/p&gt;

&lt;p&gt;  简单了解运行流程后，在详细的说一下这几个类的实现与功能。&lt;/p&gt;
&lt;h2 id=&quot;cinemachinebrain&quot;&gt;CinemachineBrain&lt;/h2&gt;
&lt;p&gt;  CinemachineBrain是挂在相机对象上去真正影响相机位置的脚本。主要负责以下三件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;维护虚拟相机的状态（主要包括当前Brain受哪个虚拟相机控制、虚拟相机切换时的切换进度、Timeline对Brain的影响）。&lt;/li&gt;
&lt;li&gt;通过虚拟相机计算State（虚拟相机通过各种参数计算出来的真实相机的状态，包括位置、旋转等）。&lt;/li&gt;
&lt;li&gt;将虚拟相机的State同步到真实相机上，可能是多个虚拟相机的State混合后的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;重要变量&quot;&gt;重要变量&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;UpdateMethed&lt;br/&gt;  更新所有与该Brain相关的虚拟相机，主要是计算每个VirtualCamera的State。
&lt;ul&gt;&lt;li&gt;SmartUpdate:判断在一定时间（具体是通过UpdateTracker实现的。这个一定时间其实是一个固定的帧数：UpdateStatus.kWindowSize,是个常数30）该虚拟相机的target在fixedUpdate移动次数多还是在lateupdate移动的次数多。来判断下一段时间用fixedUpdate还是lateUpdate。&lt;/li&gt;
&lt;li&gt;FixedUpdate:在FixedUpdate之后对虚拟相机进行更新。&lt;/li&gt;
&lt;li&gt;LateUdpate:在LateUpdate时对虚拟相机进行更新。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BlendUpdateMethod:把VirtualCamera计算的结果同步到CinemachineBrain的时机。
&lt;ul&gt;&lt;li&gt;FixedUpdate:在FixedUpdate之后对将计算的数据同步到真实相机。&lt;/li&gt;
&lt;li&gt;LateUdpate:在LateUpdate时计算的数据同步到真实相机。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;重要类&quot;&gt;重要类&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;BrainFrame&lt;/strong&gt;&lt;br/&gt;  更新并记录当前Brain受哪个虚拟相机的的控制、同时计算虚拟相机的切换状态。&lt;br/&gt;  Brain中的mFrameStack是用来处理多Timeline同时生效的情况。&lt;br/&gt;  FrameStack中的第一个Frame是Brain每帧Tick游戏中虚拟相机的结果。其他的是TimeLine的。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CinemachineBlend&lt;/strong&gt;&lt;br/&gt;  相机混合类，用于描述从相机A切换到相机B的过程。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BlendSourceVirtualCamera&lt;/strong&gt;&lt;br/&gt;  将CinemachineBlend封装成一个VirtualCamera，可以让A相机在切换到B相机的过程中又切换到C这种情况有一个平滑的过度。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;tips&quot;&gt;Tips&lt;/h3&gt;
&lt;p&gt;  在做一些相机跟随、3DUI跟随时，要注意一帧中跟随对象位置计算、虚拟相机State的计算、State结果同步、3DUI位置计算的顺序，否则容易出现相机抖动的问题。&lt;br/&gt;  如果确定相机跟随的物体运动的时间点，可以选择LateUpdate或FixedUpdate两种模式。能省去SmartUpdate时对目标物体的追踪开销（就是那个UpdateTracker）。&lt;/p&gt;
&lt;h2 id=&quot;虚拟相机的基类virtualcamerabase&quot;&gt;虚拟相机的基类VirtualCameraBase&lt;/h2&gt;
&lt;p&gt;  通过流水线的方式调用CinemachineComponent，同时在流水线中插入CinemachineExtension来计算相机的位置，具体是通过挂载的CinemachineComponent和CinemachineExtension来流水线式的计算一个CameraState（包含了位置、旋转、视角、额外偏移值等数据），通过CinemachineBrain将其中的数据同步到真实相机上。&lt;/p&gt;
&lt;h2 id=&quot;虚拟相机组件的基类cinemachinecomponentbase&quot;&gt;虚拟相机组件的基类CinemachineComponentBase&lt;/h2&gt;
&lt;p&gt;  通过VirtualCamera来创建、删除、调用，主要分三大类Body、Aim、Noise（还有一个Final，很少用）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Body主要用来计算相机的原始位置，也就是state中的RawPosition。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Aim主要用来计算相机的原始旋转，也就是state中的RawRotation。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Noise主要用来计算相机的额外偏移值，也就是state中的PositionCorrection和RotationCorrection。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;cinemachineextension&quot;&gt;CinemachineExtension&lt;/h2&gt;
&lt;p&gt;  插入在流水线中间调用，也用于维护CameraState。&lt;/p&gt;
&lt;h2 id=&quot;cinemachinecore&quot;&gt;CinemachineCore&lt;/h2&gt;
&lt;p&gt;  一个全局的管理类，保存当前所有有效的CinemachineBrain、VirturalCameraBase对象引用，定义了各种全局类和函数，用于Cinemachine系统的整体调度。&lt;/p&gt;

&lt;h2 id=&quot;cinemachinebrain详细调用流程&quot;&gt;CinemachineBrain详细调用流程&lt;/h2&gt;
&lt;p&gt;  主要可以分为两个时间节点和三件事。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;时间节点
&lt;ul&gt;&lt;li&gt;FixedUpdate之后&lt;/li&gt;
&lt;li&gt;LateUpdate&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;三件事
&lt;ul&gt;&lt;li&gt;维护虚拟相机的状态，永远在LateUpdate。&lt;/li&gt;
&lt;li&gt;通过虚拟相机计算State，根据UpdateMethod的设置，在FixedUpdate之后或LateUpdate。&lt;/li&gt;
&lt;li&gt;将虚拟相机的State同步到真实相机上，根据BlendUpdateMethod的设置，在FixedUpdate之后或LateUpdate。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;流程:&lt;/strong&gt;&lt;br/&gt;  用UpdateMethod和BlendUpdateMethod都为LateUpdate时举例。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200310003421487-395232664.jpg&quot;/&gt;&lt;br/&gt;&lt;strong&gt;Tips&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在更新相机时，会通过UpdateStatus来保证每个相机每帧不会被多次更新。以免造成性能浪费。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;virtualcamera中state计算流程&quot;&gt;VirtualCamera中State计算流程&lt;/h2&gt;
&lt;p&gt;  先看一下这个流水线在Hierarchy里长什么样子。&lt;br/&gt;  把CinemachineCore.sShowHiddenObjects设置为为true，可以看到虚拟相机下有一个cm节点。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200310003442050-1639662295.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200310003450026-690632282.png&quot;/&gt;&lt;br/&gt;  可以看到cm对象上挂了一个CinemachinePipeline脚本和对应的两个CinemechineComponent。&lt;br/&gt;  CinemachinePipeline并没有实际的逻辑作用，只是起一个标记作用，代表这个节点是一个Pipeline节点。&lt;br/&gt;  另外两个CinemachineComponent就是流水线中用于计算State的脚本。&lt;br/&gt;&lt;strong&gt;State计算流程：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200310003504739-1720455891.jpg&quot;/&gt;&lt;br/&gt;  State被一环一环的传递下去，每一步的计算都依赖于上一步计算出的State结果。&lt;br/&gt;  比如在Aim计算旋转角度时，就会依赖上一步Body计算出来的位置，以此位置为基础来计算旋转。&lt;/p&gt;

&lt;p&gt;  这里只是基本的讲了一下Cinemachine的工作流程。没有深入到每个类型的虚拟相机。但是对基本流程有一个大体的把握后，再去看其他部分应该会轻松一点。&lt;br/&gt;  其次我们也了解到Cinemachine的核心工作流并不复杂，就那么几步。代码的复杂度主要集中在各种边界情况和优化上。比如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对相机切换过程中的再次切换，多Timeline情况的处理，使相机的移动总是平滑的。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在Component的基础上加入Extensions来增加灵活度。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;增加SmartUpdate来对相机的更新时机做动态调整。&lt;br/&gt;等等。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 09 Mar 2020 16:41:00 +0000</pubDate>
<dc:creator>blueberryzzz</dc:creator>
<og:description>先贴一下官方的Cinemachine文档 &amp;quot;Cinemachine Documentation&amp;quot; 简介 使用 我们第一次使用Cinemachine时大概是这样一个流程： 1. 在需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blueberryzzz/p/12452838.html</dc:identifier>
</item>
<item>
<title>Python 三程三器的那些事 - Talent、茂ღ茂</title>
<link>http://www.cnblogs.com/yangmaosen/p/12452827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangmaosen/p/12452827.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;装饰器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、什么是装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;装饰器本质是函数，用来给其他函数添加新的功能&lt;/li&gt;
&lt;li&gt;特点：不修改调用方式、不修改源代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、装饰器的作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;装饰器作用&lt;/strong&gt;：本质是函数（装饰其他函数）就是为其他函数添加其他功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装饰器必须准寻得原则&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;不能修改被装饰函数的源代码、不能修改被装饰函数的调用方式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现装饰器知识储备&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;函数即“变量”&lt;/li&gt;
&lt;li&gt;高阶函数&lt;/li&gt;
&lt;li&gt;嵌套函数 高阶函数+潜逃函数=》装饰器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3、使用高阶函数模仿装饰器功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.&lt;strong&gt;定义：&lt;/strong&gt;把一个函数名当做实参传给另一个函数&lt;br/&gt;　　　　2.返回值中包含函数名&lt;br/&gt;　　　　3.下面使用高阶函数虽然可以实现装饰器的一些功能，但是违反了装饰器不能改变调用方式的原则，&lt;br/&gt;　　　　     以前使用bar()现在将调用方式改编成了test1(bar)就是将bar的函数名当做变量传给了test1()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('057fbb49-646c-437c-9bd7-d7c440c956e8')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_057fbb49-646c-437c-9bd7-d7c440c956e8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_057fbb49-646c-437c-9bd7-d7c440c956e8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('057fbb49-646c-437c-9bd7-d7c440c956e8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_057fbb49-646c-437c-9bd7-d7c440c956e8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;! /usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; timer(func):
    start_time &lt;/span&gt;=&lt;span&gt; time.time()
    func()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;函数执行时间为&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, time.time() -&lt;span&gt; start_time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始执行test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test执行结束&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;


timer(test)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
开始执行test
test执行结束
函数执行时间为 3.00332999229
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;改变了调用方式&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　4.高阶函数——不修改高阶函数的调用方式增加新的功能（但是无法传参数）&lt;br/&gt;　　　　注：bar = test2(bar) 等价于：@timer重新将函数名bar赋值，将原函数bar的内存地址当做实参传递该函数test2()，再将test2()赋值给bar&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('06dd9f0b-c2b1-43d1-8011-479222d76153')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_06dd9f0b-c2b1-43d1-8011-479222d76153&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_06dd9f0b-c2b1-43d1-8011-479222d76153&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('06dd9f0b-c2b1-43d1-8011-479222d76153',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_06dd9f0b-c2b1-43d1-8011-479222d76153&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bar():
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in the bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2(func):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(func)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func
bar &lt;/span&gt;=&lt;span&gt; test2(bar)
bar()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;不改变调用方式&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　5.嵌套函数&lt;br/&gt;　　　　　　嵌套函数：在一个函数中嵌套另一个函数，并在函数内部调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c0fe3d8b-41bb-4186-8ef0-1ccbd861c17b')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_c0fe3d8b-41bb-4186-8ef0-1ccbd861c17b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c0fe3d8b-41bb-4186-8ef0-1ccbd861c17b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c0fe3d8b-41bb-4186-8ef0-1ccbd861c17b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c0fe3d8b-41bb-4186-8ef0-1ccbd861c17b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in the foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bar():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in the bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    bar()
foo()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;嵌套函数&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、能够适应90%的业务需求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在装饰器中 @timer等价于 &lt;em&gt;test1=timer(test1)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;在timer()函数中返回值是&lt;strong&gt;return &lt;/strong&gt;deco&lt;/li&gt;
&lt;li&gt;所以&lt;em&gt;timer(test1)&lt;/em&gt;作用是将函数test1内存地址当做参数传递给timer()&lt;/li&gt;
&lt;li&gt;timer() 函数最后将运行后的函数deco内存地址作为返回值返回&lt;/li&gt;
&lt;li&gt;&lt;em&gt;test1=timer(test1)&lt;/em&gt;作用就是将将deco函数内存地址赋值给test1,所以最后运行test1()就相当于运行deco()&lt;/li&gt;
&lt;li&gt;所以最后调用时给test2()传入参数就相当于给deco传入参数&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0c8468bb-a772-4a68-9612-04cd0e22c2a7')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_0c8468bb-a772-4a68-9612-04cd0e22c2a7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0c8468bb-a772-4a68-9612-04cd0e22c2a7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0c8468bb-a772-4a68-9612-04cd0e22c2a7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0c8468bb-a772-4a68-9612-04cd0e22c2a7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; timer(func):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;timer(test1)  func=test1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; deco(*args,**&lt;span&gt;kwargs):
        start_time &lt;/span&gt;=&lt;span&gt; time.time()
        func(&lt;/span&gt;*args,**kwargs)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;run test1&lt;/span&gt;
        stop_time =&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running time is %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(stop_time-&lt;span&gt;start_time))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deco
@timer     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; test1=timer(test1)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in the test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
@timer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in the test2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name)
test1()
test2(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;装饰器1&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5、对特定网页进行身份验证&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b847c3b9-ad8e-486b-b191-6f23c4552601')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_b847c3b9-ad8e-486b-b191-6f23c4552601&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b847c3b9-ad8e-486b-b191-6f23c4552601&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b847c3b9-ad8e-486b-b191-6f23c4552601',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b847c3b9-ad8e-486b-b191-6f23c4552601&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
user,passwd &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; auth(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args,**&lt;span&gt;kwargs):
        username &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Username:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
        password &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Password:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user == username &lt;span&gt;and&lt;/span&gt; password ==&lt;span&gt; passwd:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User has passed authentication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            res &lt;/span&gt;= func(*args,**kwargs)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里执行func()相当于执行调用的函数如home()&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; res          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;为了获得home()函数返回值，可以将执行结果赋值给res然后返回print(home())结果是&quot;from home&quot;而不是&quot;None&quot;了&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            exit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid username or password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
@auth
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; home():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;welcome to home page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
@auth
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bbs():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;welcome to bbs page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
index()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(home())   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在这里调用home()相当于调用wrapper()&lt;/span&gt;
bbs()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;装饰器2&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6、实现对不同网页不同方式的身份认证&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@auth(auth_type=&lt;strong&gt;&quot;local&quot;&lt;/strong&gt;)代码作用&lt;/li&gt;
&lt;li&gt;在上面的代码中使用@auth相当于先将home函数的内存地址当做变量传入auth()函数，执行结果后home()相当于wrapper()&lt;/li&gt;
&lt;li&gt;而在这里验证的时候犹豫@auth(auth_type=&quot;local&quot;)中有()括号，那么就相当于将执行auth()函数而且是将auth_type=&lt;strong&gt;&quot;local&lt;/strong&gt;&lt;strong&gt;当做参数传入到&lt;/strong&gt;&lt;strong&gt;auth()&lt;/strong&gt;&lt;strong&gt;函数执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;所以outer_wrapper函数也会执行，outer_wrapper函数的执行结果返回的就是wrapper()函数的内存地址&lt;/li&gt;
&lt;li&gt;所以最终结果同样是执行home()函数就相当于执行wrapper函数&lt;/li&gt;
&lt;li&gt;但是有所不同的是着这个版本中我们可以在外层的auth函数中传入新的参数帮组我们根据需求判断 &lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('57024d9b-0634-4dab-aaca-d18c7c845196')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_57024d9b-0634-4dab-aaca-d18c7c845196&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_57024d9b-0634-4dab-aaca-d18c7c845196&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('57024d9b-0634-4dab-aaca-d18c7c845196',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_57024d9b-0634-4dab-aaca-d18c7c845196&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
user,passwd &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; auth(auth_type):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auth func:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,auth_type)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; outer_wrapper(func):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrapper func args:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; auth_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                username &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Username:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
                password &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Password:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user == username &lt;span&gt;and&lt;/span&gt; passwd ==&lt;span&gt; password:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[32;1mUser has passed authentication\033[0m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    res &lt;/span&gt;= func(*args, **kwargs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; from home&lt;/span&gt;
                    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---after authenticaion &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    exit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[31;1mInvalid username or password\033[0m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; auth_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ldap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;搞毛线ldap,不会。。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; outer_wrapper

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
@auth(auth_type&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; home = wrapper()&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; home():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;welcome to home  page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

@auth(auth_type&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ldap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bbs():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;welcome to bbs  page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

index()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(home()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;wrapper()&lt;/span&gt;
bbs()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;装饰器3&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5d6ec3cf-e382-4a0f-9414-f3b3230e7a76')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_5d6ec3cf-e382-4a0f-9414-f3b3230e7a76&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5d6ec3cf-e382-4a0f-9414-f3b3230e7a76&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5d6ec3cf-e382-4a0f-9414-f3b3230e7a76',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5d6ec3cf-e382-4a0f-9414-f3b3230e7a76&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;! /usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; auth(auth_type):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auth func:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,auth_type)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; outer_wrapper(func):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrapper func args:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;运行前&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            func(&lt;/span&gt;*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;运行后&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; outer_wrapper

@auth(auth_type&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; home = wrapper()&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; home():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;welcome to home  page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
home()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;三级装饰器简写&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;7、使用闭包实现装饰器功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　闭包概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用，这样就构成了一个闭包&lt;/li&gt;
&lt;li&gt;一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。&lt;/li&gt;
&lt;li&gt;但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('27fe5477-30ed-4622-a337-87d19c2a06d7')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_27fe5477-30ed-4622-a337-87d19c2a06d7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_27fe5477-30ed-4622-a337-87d19c2a06d7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('27fe5477-30ed-4622-a337-87d19c2a06d7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_27fe5477-30ed-4622-a337-87d19c2a06d7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;! /usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; timer(func):                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;timer(test1)  func=test1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; deco(*args,**kwargs):       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 函数嵌套&lt;/span&gt;
        start_time =&lt;span&gt; time.time()
        func(&lt;/span&gt;*args,**kwargs)        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 跨域访问，引用了外部变量func   (func实质是函数内存地址)&lt;/span&gt;
        stop_time =&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running time is %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(stop_time-&lt;span&gt;start_time)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; deco                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 内层函数作为外层函数返回值&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in the test2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name
    time.sleep(&lt;/span&gt;2&lt;span&gt;)

test &lt;/span&gt;= timer(test)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等价于 ==》 @timer语法糖&lt;/span&gt;
test(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
运行结果：
in the test2 tom
running time is 2.00302696228
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;闭包实现装饰器功能&lt;/span&gt;&lt;/div&gt;

&lt;h3 id=&quot;i2&quot;&gt;生成器&lt;a href=&quot;https://www.cnblogs.com/xiaonq/p/7864932.html#i0&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、什么是生成器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成器就是一个特殊的迭代器&lt;/li&gt;
&lt;li&gt;一个有yield关键字的函数就是一个生成器&lt;/li&gt;
&lt;li&gt;生成器是这样一个函数，它记住上一次返回时在函数体中的位置。&lt;/li&gt;
&lt;li&gt;对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、定义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成器，即生成一个容器。&lt;/li&gt;
&lt;li&gt;在Python中，&lt;strong&gt;一边循环，一边计算的机制，称为生成器。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成器可以理解为一种数据类型，这种数据类型自动实现了迭代器协议（其他数据类型需要调用自己的内置iter（）方法或__iter__()的内置函数），&lt;/li&gt;
&lt;li&gt;所以，生成器就是一个可迭代对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3、生成器哪些场景应用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成器是一个概念，我们平常写代码可能用的并不多，但是python源码大量使用&lt;/li&gt;
&lt;li&gt;比如我们tornado框架就是基于 生成器+协程&lt;/li&gt;
&lt;li&gt;在我们代码中使用举例&lt;/li&gt;
&lt;li&gt;比如我们要生成一百万个数据，如果用生成器非常节省空间，用列表浪费大量空间&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
t1 &lt;/span&gt;=&lt;span&gt; time.time()
g &lt;/span&gt;= (i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100000000&lt;span&gt;))
t2 &lt;/span&gt;=&lt;span&gt; time.time()
lst &lt;/span&gt;= [i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100000000&lt;span&gt;)]
t3 &lt;/span&gt;=&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;生成器时间：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,t2 - t1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成器时间： 0.0&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;列表时间：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,t3 - t2)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列表时间： 5.821957349777222&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、生成器的作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的。&lt;/li&gt;
&lt;li&gt;而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。&lt;/li&gt;
&lt;li&gt;所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？&lt;/li&gt;
&lt;li&gt;这样就不必创建完整的list，从而节省大量的空间。&lt;strong&gt;在Python中，这种一边循环一边计算的机制，称为生成器：generator。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;要创建一个generator，有很多种方法，第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;( [i*2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10)] )             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;列表生成式： [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;( (i*2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10)) )             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生  成  器： &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x005A3690&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？&lt;/li&gt;
&lt;li&gt;如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
g = (i*2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( g.&lt;span&gt;__next__&lt;/span&gt;() )               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;( g.&lt;span&gt;__next__&lt;/span&gt;() )               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 5、生成器工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;生成器&lt;/strong&gt;是这样一个函数，它记住上一次返回时在函数体中的位置。&lt;/li&gt;
&lt;li&gt;对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成器&lt;/strong&gt;不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造（在命令式编程中，这种构造不只是数据值）中的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成器&lt;/strong&gt;是一个函数，而且函数的参数都会保留。&lt;/li&gt;
&lt;li&gt;迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;6、yield生成器运行机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;a title=&quot;Python介绍&quot; href=&quot;https://python.csdn.net&quot; target=&quot;_blank&quot;&gt;Python&lt;/a&gt;中，yield就是这样的一个生成器。&lt;/li&gt;
&lt;li&gt;当你问生成器要一个数时，生成器会执行，直至出现 yield 语句，生成器把yield 的参数给你，之后生成器就不会往下继续运行。&lt;/li&gt;
&lt;li&gt;当你问他要下一个数时，他会从上次的状态开始运行，直至出现yield语句，把参数给你，之后停下。如此反复&lt;/li&gt;
&lt;li&gt;在python中，当你定义一个函数，使用了yield关键字时，这个函数就是一个生成器&lt;/li&gt;
&lt;li&gt;它的执行会和其他普通的函数有很多不同，函数返回的是一个对象，而不是你平常所用return语句那样，能得到结果值。如果想取得值，那得调用next()函数&lt;/li&gt;
&lt;li&gt;每当调用一次迭代器的next函数，生成器函数运行到yield之处，返回yield后面的值且在这个地方暂停，所有的状态都会被保持住，直到下次next函数被调用，或者碰到异常循环退出。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e86160f5-e2d0-4901-9f75-d7a8f9452567')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_e86160f5-e2d0-4901-9f75-d7a8f9452567&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e86160f5-e2d0-4901-9f75-d7a8f9452567&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e86160f5-e2d0-4901-9f75-d7a8f9452567',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e86160f5-e2d0-4901-9f75-d7a8f9452567&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(max_num):
    a,b &lt;/span&gt;= 1,1
    &lt;span&gt;while&lt;/span&gt; a &amp;lt;&lt;span&gt; max_num:
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; b
        a,b&lt;/span&gt;=b,a+&lt;span&gt;b

g &lt;/span&gt;= fib(10)               &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成一个生成器：[1，2, 3, 5, 8, 13]&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(g.&lt;span&gt;__next__&lt;/span&gt;())       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一次调用返回：1&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(list(g))            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把剩下元素变成列表：[2, 3, 5, 8, 13]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;yield实现fib数&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;7、yield实现单线程下的并发效果&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;yield相当于 return 返回一个值，并且记住这个返回的位置，下次迭代时，代码从yield的下一条语句开始执行。&lt;/li&gt;
&lt;li&gt;send() 和next()一样，都能让生成器继续往下走一步（下次遇到yield停），但send()能传一个值，这个值作为yield表达式整体的结果&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('94bc8d28-a534-4d13-a694-d941e16d9507')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_94bc8d28-a534-4d13-a694-d941e16d9507&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_94bc8d28-a534-4d13-a694-d941e16d9507&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('94bc8d28-a534-4d13-a694-d941e16d9507',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_94bc8d28-a534-4d13-a694-d941e16d9507&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; consumer(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 准备吃包子啦!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;name)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
       baozi &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt;
       &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;包子[%s]来了,被[%s]吃了!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(baozi,name))
c &lt;/span&gt;= consumer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
c.&lt;/span&gt;&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()
b1 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;韭菜馅包子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
c.send(b1)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; c.send(b1)作用：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; c.send()的作用是给yied的传递一个值，并且每次调用c.send()的同时自动调用一次__next__&lt;/span&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;运行结果：
Tom 准备吃包子啦!
包子[韭菜馅包子]来了,被[Tom]吃了!
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;一次调用&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8c0f8a36-d79a-4bc8-9396-c2d7ebbdb35c')&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_8c0f8a36-d79a-4bc8-9396-c2d7ebbdb35c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8c0f8a36-d79a-4bc8-9396-c2d7ebbdb35c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8c0f8a36-d79a-4bc8-9396-c2d7ebbdb35c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8c0f8a36-d79a-4bc8-9396-c2d7ebbdb35c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; consumer(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 准备吃包子啦!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;name)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
       baozi &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt;
       &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;包子[%s]来了,被[%s]吃了!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(baozi,name))
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; producer(name):
    c &lt;/span&gt;= consumer(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    c2 &lt;/span&gt;= consumer(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    c.&lt;/span&gt;&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()
    c2.&lt;/span&gt;&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老子开始准备做包子啦!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;做了2个包子!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        c.send(i)
        c2.send(i)
producer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;运行结果：
A 准备吃包子啦!
B 准备吃包子啦!
老子开始准备做包子啦!
做了2个包子!
包子[0]来了,被[A]吃了!
包子[0]来了,被[B]吃了!
做了2个包子!
包子[1]来了,被[A]吃了!
包子[1]来了,被[B]吃了!
做了2个包子!
包子[2]来了,被[A]吃了!
包子[2]来了,被[B]吃了!
做了2个包子!
包子[3]来了,被[A]吃了!
包子[3]来了,被[B]吃了!
做了2个包子!
包子[4]来了,被[A]吃了!
包子[4]来了,被[B]吃了!
做了2个包子!
包子[5]来了,被[A]吃了!
包子[5]来了,被[B]吃了!
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;for 循环调用&lt;/span&gt;&lt;/div&gt;

&lt;h3 id=&quot;i3&quot;&gt;迭代器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、什么是迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;迭代器是访问集合内元素的一种方法&lt;/li&gt;
&lt;li&gt;总是从集合内第一个元素访问，直到所有元素都被访问过结束，当调用 __next__而元素返回会引发一个，StopIteration异常&lt;/li&gt;
&lt;li&gt;有两个方法：_iter_ _next_&lt;/li&gt;
&lt;li&gt;_iter_ : 返回迭代器自身&lt;/li&gt;
&lt;li&gt;_next_: 返回下一个元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、定义：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;迭代器是访问集合内元素的一种方式&lt;/strong&gt;。迭代器对象从集合的第一个元素开始访问，直到所有的元素都被访问一遍后结束。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3、迭代器和可迭代对象&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;凡是可作用于&lt;code&gt;for&lt;/code&gt;循环的对象都是可迭代的（Iterable）类型；&lt;/li&gt;
&lt;li&gt;凡是可作用于&lt;code&gt;next()&lt;/code&gt;函数的对象都是迭代器（&lt;code&gt;Iterator）&lt;/code&gt;类型，它们表示一个惰性计算的序列；&lt;/li&gt;
&lt;li&gt;集合数据类型如&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;dict&lt;/code&gt;、&lt;code&gt;str&lt;/code&gt;等是可迭代的但不是迭代器，不过可以通过&lt;code&gt;iter()&lt;/code&gt;函数获得一个&lt;code&gt;Iterator&lt;/code&gt;对象。&lt;/li&gt;
&lt;li&gt;Python的&lt;code&gt;for&lt;/code&gt;循环本质上就是通过不断调用&lt;code&gt;next()&lt;/code&gt;函数实现的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总结：&lt;/strong&gt; 一个实现了__iter__方法的对象是可迭代的，一个实现next方法的对象是迭代器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4、迭代器的两个方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;迭代器仅是一容器对象，它实现了迭代器协议。它有两个基本方法
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;next__&lt;/strong&gt;&lt;strong&gt;方法：&lt;/strong&gt;返回容器的下一个元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;__iter__&lt;/strong&gt;&lt;strong&gt;方法：&lt;/strong&gt;返回迭代器自身&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迭代器是访问集合内元素的一种方式&lt;/strong&gt;。迭代器对象从集合的第一个元素开始访问，直到所有的元素都被访问一遍后结束。&lt;/li&gt;
&lt;li&gt;__iter__方法会返回一个迭代器(iterator)，所谓的迭代器就是具有next方法的对象。&lt;/li&gt;
&lt;li&gt;在调用next方法时，迭代器会返回它的下一个值，如果next方法被调用，但迭代器中没有值可以返就会引发一个StopIteration异常&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
a = iter([1,2,])              &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成一个迭代器&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(a.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a.&lt;span&gt;__next__&lt;/span&gt;())           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在这一步会引发  “StopIteration” 的异常&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5、判断是迭代器和可迭代对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注：&lt;/strong&gt;列表，元组，字典是可迭代的但不是迭代器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d7523343-56c4-47d9-8937-b7fd791c89cf')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_d7523343-56c4-47d9-8937-b7fd791c89cf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d7523343-56c4-47d9-8937-b7fd791c89cf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d7523343-56c4-47d9-8937-b7fd791c89cf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d7523343-56c4-47d9-8937-b7fd791c89cf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(isinstance([],Iterable))                               &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(isinstance({},Iterable))                               &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(isinstance((),Iterable))                               &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(isinstance(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Iterable))                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(isinstance((x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(10)),Iterable))          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;相关代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6、列表不是迭代器，只有生成器是迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('87d830a9-79d3-4173-b13a-f4c61cb9f7b0')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_87d830a9-79d3-4173-b13a-f4c61cb9f7b0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_87d830a9-79d3-4173-b13a-f4c61cb9f7b0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('87d830a9-79d3-4173-b13a-f4c61cb9f7b0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_87d830a9-79d3-4173-b13a-f4c61cb9f7b0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterator
t &lt;/span&gt;= [1,2,3,4&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(isinstance(t,Iterator))           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;
t1 =&lt;span&gt; iter(t)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(isinstance(t1,Iterator))          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;相关代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;7、自定义迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('08614573-25f7-4c66-b6b5-b908218ab9fa')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_08614573-25f7-4c66-b6b5-b908218ab9fa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_08614573-25f7-4c66-b6b5-b908218ab9fa&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('08614573-25f7-4c66-b6b5-b908218ab9fa',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_08614573-25f7-4c66-b6b5-b908218ab9fa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;! /usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyRange(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, n):
        self.idx &lt;/span&gt;=&lt;span&gt; 0
        self.n &lt;/span&gt;=&lt;span&gt; n

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; next(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.idx &amp;lt;&lt;span&gt; self.n:
            val &lt;/span&gt;=&lt;span&gt; self.idx
            self.idx &lt;/span&gt;+= 1
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.n[val]
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopIteration()


l &lt;/span&gt;= [4,5,6,7,8&lt;span&gt;]
obj &lt;/span&gt;=&lt;span&gt; MyRange(l)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; obj.next()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; obj.next()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; obj.next()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;自定义迭代器&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;8、迭代器与生成器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7a3f338e-5255-421f-81ff-b775dbef15ad')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_7a3f338e-5255-421f-81ff-b775dbef15ad&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7a3f338e-5255-421f-81ff-b775dbef15ad&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7a3f338e-5255-421f-81ff-b775dbef15ad',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7a3f338e-5255-421f-81ff-b775dbef15ad&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;! /usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*&lt;/span&gt;
l = [1,2,3,4,5]                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列表是一个可迭代对象，不是一个迭代器&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; dir(l)                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所以 l 中有 __iter__() 方法，没有 __next__()方法&lt;/span&gt;
iter_obj = l.&lt;span&gt;__iter__&lt;/span&gt;()          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; __iter__()方法返回迭代器对象本身(这个迭代器对象就会有 next 方法了)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;###################################\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; iter_obj.next()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; iter_obj.next()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; iter_obj.next()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;相关代码&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;进程与线程的简介&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、什么是进程(process)？（进程是资源集合）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、进程是资源分配的最小单位（ 内存、cpu、网络、io）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、一个运行起来的程序就是一个进程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是程序（程序是我们存储在硬盘里的代码）&lt;/li&gt;
&lt;li&gt;硬盘（256G）、内存条（8G）&lt;/li&gt;
&lt;li&gt;当我们双击图标，打开程序的时候，实际上就是通过I/O操作（读写）内存条里面&lt;/li&gt;
&lt;li&gt;内存条就是我们所指的资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;CPU分时&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU比你的手速快多了，分时处理每个线程，但是由于太快然你觉得每个线程都是独占cpu&lt;/li&gt;
&lt;li&gt;cpu是计算，只有时间片到了，获取cpu，线程真正执行&lt;/li&gt;
&lt;li&gt;当你想使用 网络、磁盘等资源的时候，需要cpu的调度&lt;/li&gt;
&lt;li&gt;进程具有独立的内存空间，所以没有办法相互通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;进程如何通信&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进程queue(父子进程通信)&lt;/li&gt;
&lt;li&gt;pipe（同一程序下两个进程通信）&lt;/li&gt;
&lt;li&gt;managers（同一程序下多个进程通信）&lt;/li&gt;
&lt;li&gt;RabbitMQ、redis等（不同程序间通信）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;为什么需要进程池&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一次性开启指定数量的进程&lt;/li&gt;
&lt;li&gt;如果有十个进程，有一百个任务，一次可以处理多少个（一次性只能处理十个）&lt;/li&gt;
&lt;li&gt;防止进程开启数量过多导致服务器压力过大&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、定义：进程是资源分配最小单位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当一个可执行程序被系统执行（分配内存资源）就变成了一个进程&lt;/li&gt;
&lt;li&gt;程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，这种执行的程序就称之为进程&lt;/li&gt;
&lt;li&gt;程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念&lt;/li&gt;
&lt;li&gt;在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。&lt;/li&gt;
&lt;li&gt;进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。&lt;/li&gt;
&lt;li&gt;进程之间有自己独立的内存，各进程之间不能相互访问&lt;/li&gt;
&lt;li&gt;创建一个新线程很简单，创建新进程需要对父进程进行复制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多道编程：&lt;/strong&gt; 在计算机内存中同时存放几道相互独立的程序，他们共享系统资源，相互穿插运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单道编程：&lt;/strong&gt; 计算机内存中只允许一个的程序运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3、进程并发性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在一个系统中，同时会存在多个进程被加载到内存中，同处于开始到结束之间的状态&lt;/li&gt;
&lt;li&gt;对于一个单CPU系统来说，程序同时处于运行状态只是一种宏观上的概念&lt;/li&gt;
&lt;li&gt;他们虽然都已经开始运行，但就微观而言，任意时刻，CPU上运行的程序只有一个&lt;/li&gt;
&lt;li&gt;由于操作系统分时，让每个进程都觉得自己独占CPU等资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注：&lt;/strong&gt;如果是多核CPU（处理器）实际上是可以实现正在意义的同一时间点有多个线程同时运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4、线程并发性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作系统将时间划分为很多时间段，尽可能的均匀分配给每一个线程。&lt;/li&gt;
&lt;li&gt;获取到时间片的线程被CPU执行，其他则一直在等待，所以微观上是走走停停，宏观上都在运行。
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;多核CPU情况：&lt;/strong&gt;　　　　　　　　　　
&lt;ul&gt;&lt;li&gt;如果你的程序的线程数少于CPU的核心数，且系统此时没有其他进程同时运行，那么这个程序的每个线程会享有一个CPU，&lt;/li&gt;
&lt;li&gt;当同时运行的线程数多于CPU核心数时，CPU会采用一定的调度算法每隔一段时间就将这些线程调入或调出CPU&lt;/li&gt;
&lt;li&gt;以确保每个线程都能分享一部分CPU时间，实现多线程并发。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;5、有了进程为什么还要线程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.进程优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2. 进程的两个重要缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。&lt;/li&gt;
&lt;li&gt;进程在执行的过程中如果阻塞，即使进程中有些工作不依赖于输入的数据，也将无法执行（例如等待输入，整个进程就会挂起）。&lt;/li&gt;
&lt;li&gt;例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、又能监听其它人给你发的消息&lt;/li&gt;
&lt;li&gt;你会说，操作系统不是有分时么？分时是指在不同进程间的分时呀&lt;/li&gt;
&lt;li&gt;即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，你的qq还是只能同时干一件事呀&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;6、什么是线程(thread)（线程是操作系统最小的调度单位）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;定义：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;线程是操作系统调度的最小单位&lt;/li&gt;
&lt;li&gt;它被包含在进程之中，是进程中的实际运作单位&lt;/li&gt;
&lt;li&gt;进程本身是无法自己执行的，要操作cpu，必须创建一个线程，线程是一系列指令的集合&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位&lt;/li&gt;
&lt;li&gt;一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务&lt;/li&gt;
&lt;li&gt; 无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行&lt;/li&gt;
&lt;li&gt;进程本身是无法自己执行的，要操作cpu，必须创建一个线程，线程是一系列指令的集合&lt;/li&gt;
&lt;li&gt;所有在同一个进程里的线程是共享同一块内存空间的，不同进程间内存空间不同&lt;/li&gt;
&lt;li&gt;同一个进程中的各线程可以相互访问资源，线程可以操作同进程中的其他线程，但进程仅能操作子进程&lt;/li&gt;
&lt;li&gt;两个进程想通信，必须要通过一个中间代理&lt;/li&gt;
&lt;li&gt;对主线程的修改可能回影响其他子线程，对主进程修改不会影响其他进程因为进程间内存相互独立，但是同一进程下的线程共享内存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;7、进程和线程的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动一个线程比启动一个进程快，运行速度没有可比性。&lt;/li&gt;
&lt;li&gt;先有一个进程然后才能有线程。
&lt;ul&gt;&lt;li&gt;进程包含线程&lt;/li&gt;
&lt;li&gt;线程共享内存空间&lt;/li&gt;
&lt;li&gt;进程内存是独立的（不可互相访问）&lt;/li&gt;
&lt;li&gt;进程可以生成子进程，子进程之间互相不能互相访问（相当于在父级进程克隆两个子进程）&lt;/li&gt;
&lt;li&gt;在一个进程里面线程之间可以交流。两个进程想通信，必须通过一个中间代理来实现&lt;/li&gt;
&lt;li&gt;创建新线程很简单，创建新进程需要对其父进程进行克隆。&lt;/li&gt;
&lt;li&gt;一个线程可以控制或操作同一个进程里面的其它线程。但进程只能操作子进程。&lt;/li&gt;
&lt;li&gt;父进程可以修改不影响子进程，但不能修改。&lt;/li&gt;
&lt;li&gt;线程可以帮助应用程序同时做几件事&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;8、进程和程序的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序只是一个普通文件，是一个机器代码指令和数据的集合，所以，程序是一个静态的实体&lt;/li&gt;
&lt;li&gt;而进程是程序运行在数据集上的动态过程，进程是一个动态实体，它应创建而产生，应调度执行因等待资 源或事件而被处于等待状态，因完成任务而被撤消&lt;/li&gt;
&lt;li&gt;进程是系统进行资源分配和调度的一个独立单位&lt;/li&gt;
&lt;li&gt;一个程序对应多个进程，一个进程为多个程序服务（两者之间是多对多的关系）&lt;/li&gt;
&lt;li&gt;一个程序执行在不同的数据集上就成为不同的进程，可以用进程控制块来唯一地标识每个进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;多线程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Python多线程编程中常用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;join()方法：&lt;/strong&gt;如果一个线程或者在函数执行的过程中调用另一个线程，并且希望待其完成操作后才能执行，那么在调用线程的时就可以使用被调线程的join方法join([timeout]) timeout：可选参数，线程运行的最长时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;isAlive()方法：&lt;/strong&gt;查看线程是否还在运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getName()方法：&lt;/strong&gt;获得线程名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setDaemon()方法：&lt;/strong&gt;主线程退出时，需要子线程随主线程退出，则设置子线程的setDaemon()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;GIL全局解释器锁：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在python全局解释器下，保证同一时间只有一个线程运行&lt;/li&gt;
&lt;li&gt;防止多个线程都修改数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;线程锁（互斥锁）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GIL锁只能保证同一时间只能有一个线程对某个资源操作，但当上一个线程还未执行完毕时可能就会释放GIL，其他线程就可以操作了&lt;/li&gt;
&lt;li&gt;线程锁本质把线程中的数据加了一把互斥锁&lt;/li&gt;
&lt;li&gt;mysql中共享锁 &amp;amp; 互斥锁
&lt;ul&gt;&lt;li&gt;mysql共享锁：共享锁，所有线程都能读，而不能写&lt;/li&gt;
&lt;li&gt;mysql排它锁：排它，任何线程读取这个这个数据的权利都没有&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;加上线程锁之后所有其他线程，读都不能读这个数据&lt;/li&gt;
&lt;li&gt;有了GIL全局解释器锁为什么还需要线程锁
&lt;ul&gt;&lt;li&gt;因为cpu是分时使用的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1、线程2种调用方式：直接调用， 继承式调用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0455fed7-22a7-4f67-ade3-6fe626e27a73')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_0455fed7-22a7-4f67-ade3-6fe626e27a73&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0455fed7-22a7-4f67-ade3-6fe626e27a73&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0455fed7-22a7-4f67-ade3-6fe626e27a73',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0455fed7-22a7-4f67-ade3-6fe626e27a73&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; sayhi(num):                                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义每个线程要运行的函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running on number:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; num)
    time.sleep(&lt;/span&gt;3&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1、target=sayhi ：sayhi是定义的一个函数的名字&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2、args=(1,)    ： 括号内写的是函数的参数&lt;/span&gt;
t1 = threading.Thread(target=sayhi, args=(1,))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成一个线程实例&lt;/span&gt;
t2 = threading.Thread(target=sayhi, args=(2,))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成另一个线程实例&lt;/span&gt;
&lt;span&gt;
t1.start()                                        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动线程&lt;/span&gt;
t2.start()                                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动另一个线程&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(t1.getName())                               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取线程名&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(t2.getName())
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;直接调用&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1659ed33-0529-43b5-8640-cfdb14cfe098')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_1659ed33-0529-43b5-8640-cfdb14cfe098&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1659ed33-0529-43b5-8640-cfdb14cfe098&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1659ed33-0529-43b5-8640-cfdb14cfe098',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1659ed33-0529-43b5-8640-cfdb14cfe098&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyThread(threading.Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,num):
        threading.Thread.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)
        self.num &lt;/span&gt;=&lt;span&gt; num

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; run(self):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义每个线程要运行的函数&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running on number:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;self.num)
        time.sleep(&lt;/span&gt;3&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t1 &lt;/span&gt;= MyThread(1&lt;span&gt;)
    t2 &lt;/span&gt;= MyThread(2&lt;span&gt;)
    t1.start()
    t2.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;继承式调用&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、for循环同时启动多个线程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;说明：&lt;/strong&gt;下面利用for循环同时启动50个线程并行执行，执行时间是3秒而不是所有线程执行时间的总和&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d431ddcb-76be-44af-b932-21f2038219e9')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_d431ddcb-76be-44af-b932-21f2038219e9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d431ddcb-76be-44af-b932-21f2038219e9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d431ddcb-76be-44af-b932-21f2038219e9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d431ddcb-76be-44af-b932-21f2038219e9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; sayhi(num): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义每个线程要运行的函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running on number:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;num)
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(50&lt;span&gt;):
    t &lt;/span&gt;= threading.Thread(target=sayhi,args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t-%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;i,))
    t.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;for循环启动多个线程&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、t.join()： 实现所有线程都执行结束后再执行主线程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/span&gt;在4中虽然可以实现50个线程同时并发执行，但是主线程不会等待子线程结束在这里我们可以使用t.join()指定等待某个线程结束的结果&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ce0e5d78-762f-4dc4-b016-9193832cb340')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_ce0e5d78-762f-4dc4-b016-9193832cb340&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce0e5d78-762f-4dc4-b016-9193832cb340&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ce0e5d78-762f-4dc4-b016-9193832cb340',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce0e5d78-762f-4dc4-b016-9193832cb340&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
start_time &lt;/span&gt;=&lt;span&gt; time.time()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; sayhi(num): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义每个线程要运行的函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running on number:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;num)
    time.sleep(&lt;/span&gt;3&lt;span&gt;)

t_objs &lt;/span&gt;= []    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将进程实例对象存储在这个列表中&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(50&lt;span&gt;):
    t &lt;/span&gt;= threading.Thread(target=sayhi,args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t-%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;i,))
    t.start()          &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动一个线程，程序不会阻塞&lt;/span&gt;
&lt;span&gt;    t_objs.append(t)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(threading.active_count())    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印当前活跃进程数量&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; t_objs: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用for循环等待上面50个进程全部结束&lt;/span&gt;
    t.join()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;阻塞某个程序&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(threading.current_thread())    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印执行这个命令进程&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----------------all threads has finished.....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(threading.active_count())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cost time:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,time.time() - start_time)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;t.join() 主线程等待子线程&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、setDaemon(): 守护线程，主线程退出时，需要子线程随主线程退出&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e183965d-6b04-4f83-9ca4-6e8d1a685828')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_e183965d-6b04-4f83-9ca4-6e8d1a685828&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e183965d-6b04-4f83-9ca4-6e8d1a685828&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e183965d-6b04-4f83-9ca4-6e8d1a685828',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e183965d-6b04-4f83-9ca4-6e8d1a685828&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
start_time &lt;/span&gt;=&lt;span&gt; time.time()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; sayhi(num): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义每个线程要运行的函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running on number:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;num)
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(50&lt;span&gt;):
    t &lt;/span&gt;= threading.Thread(target=sayhi,args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t-%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;i,))
    t.setDaemon(True)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把当前线程变成守护线程，必须在t.start()前设置&lt;/span&gt;
    t.start()          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动一个线程，程序不会阻塞&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cost time:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,time.time() - start_time)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;守护线程&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注：&lt;/strong&gt;因为刚刚创建的线程是守护线程，所以主线程结束后子线程就结束了，运行时间不是3秒而是0.01秒&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;5、GIL锁和用户锁（Global Interpreter Lock 全局解释器锁）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全局解释器锁：&lt;/strong&gt;保证同一时间仅有一个线程对资源有操作权限
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt;在一个进程内，同一时刻只能有一个线程通过GIL锁 被CUP调用，切换条件：I/O操作、固定时间(系统决定)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;说明：&lt;/strong&gt;python多线程中GIL锁只是在CPU操作时（如：计算）才是串行的，其他都是并行的，所以比串行快很多&lt;/li&gt;
&lt;li&gt;为了解决不同线程同时访问同一资源时，数据保护问题，而产生了GIL&lt;/li&gt;
&lt;li&gt;GIL在解释器的层面限制了程序在同一时间只有一个线程被CPU实际执行，而不管你的程序里实际开了多少条线程&lt;/li&gt;
&lt;li&gt;为了解决这个问题，CPython自己定义了一个全局解释器锁，同一时间仅仅有一个线程可以拿到这个数据&lt;/li&gt;
&lt;li&gt;python之所以会产生这种不好的状况是因为python启用一个线程是调用操作系统原生线程，就是C接口&lt;/li&gt;
&lt;li&gt;但是这仅仅是CPython这个版本的问题，在PyPy，中就没有这种缺陷&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户锁：线程锁(互斥锁Mutex)  ：&lt;/strong&gt;当前线程还未操作完成前其他所有线程都无法对其操作，即使已经释放了GIL锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在有GIL锁时为何还需要用户锁&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;GIL锁只能保证同一时间只能有一个线程对某个资源操作，但当上一个线程还未执行完毕时可能就会释放GIL，其他线程就可以操作了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程锁的原理&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;当一个线程对某个资源进行CPU计算的操作时加一个线程锁，只有当前线程计算完成主动释放锁，其他线程才能对其操作&lt;/li&gt;
&lt;li&gt;这样就可以防止还未计算完成，释放GIL锁后其他线程对这个资源操作导致混乱问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ebdae877-cf92-46bc-830e-057a48531389')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_ebdae877-cf92-46bc-830e-057a48531389&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ebdae877-cf92-46bc-830e-057a48531389&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ebdae877-cf92-46bc-830e-057a48531389',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ebdae877-cf92-46bc-830e-057a48531389&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
lock &lt;/span&gt;= threading.Lock()          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 生成全局锁&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; addNum():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt; num                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2 在每个线程中都获取这个全局变量&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--get num:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,num )
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    lock.acquire()              &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3 修改数据前加锁&lt;/span&gt;
    num  -= 1                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4 对此公共变量进行-1操作&lt;/span&gt;
    lock.release()              &lt;span&gt;#&lt;/span&gt;&lt;span&gt;5 修改后释放&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;用户锁使用举例&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在有GIL的情况下执行 count = count + 1 会出错原因解析，用线程锁解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('dc541ff2-d94b-44e1-85dc-550e144612ab')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_dc541ff2-d94b-44e1-85dc-550e144612ab&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dc541ff2-d94b-44e1-85dc-550e144612ab&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('dc541ff2-d94b-44e1-85dc-550e144612ab',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dc541ff2-d94b-44e1-85dc-550e144612ab&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1）第一步：count = 0   count初始值为0&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2）第二步：线程1要执行对count加1的操作首先申请GIL全局解释器锁&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3）第三步：调用操作系统原生线程在操作系统中执行&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4）第四步：count加1还未执行完毕，时间到了被要求释放GIL&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5）第五步：线程1释放了GIL后线程2此时也要对count进行操作，此时线程1还未执行完，所以count还是0&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6）第六步：线程2此时拿到count = 0后也要对count进行加1操作，假如线程2执行很快，一次就完成了&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;    count加1的操作，那么count此时就从0变成了1&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7）第七步：线程2执行完加1后就赋值count=1并释放GIL&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 8）第八步：线程2执行完后cpu又交给了线程1，线程1根据上下文继续执行count加1操作，先拿到GIL&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;    锁，完成加1操作，由于线程1先拿到的数据count=0，执行完加1后结果还是1&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 9）第九步：线程1将count=1在次赋值给count并释放GIL锁，此时连个线程都对数据加1，但是值最终是1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;报错原因分析&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;使用线程锁解决上面问题的原理&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;在GIL锁中再加一个线程锁，线程锁是用户层面的锁&lt;/li&gt;
&lt;li&gt;线程锁就是一个线程在对数据操作前加一把锁，防止其他线程复制或者操作这个数据&lt;/li&gt;
&lt;li&gt;只有这个线程对数据操作完毕后才会释放这个锁，其他线程才能操作这个数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定义一个线程锁非常简单只用三步&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &amp;gt;&amp;gt; lock = threading.Lock()                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一把锁&lt;/span&gt;
&lt;span&gt;2 &amp;gt;&amp;gt; lock.acquire()                                   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对数据操作前加锁防止数据被另一线程操作&lt;/span&gt;
&lt;span&gt;3 &amp;gt;&amp;gt; lock.release()                                     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对数据操作完成后释放锁&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6、死锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;死锁定义：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象若无外力作用，它们都将无法推进去。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁举例：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;启动5个线程，执行run方法,假如thread1首先抢到了A锁，此时thread1没有释放A锁，紧接着执行代码mutexB.acquire()，抢到了B锁，&lt;/li&gt;
&lt;li&gt;在抢B锁时候，没有其他线程与thread1争抢，因为A锁没有释放，其他线程只能等待&lt;/li&gt;
&lt;li&gt;thread1执行完func1函数，然后执行func2函数，此时thread1拿到B锁，然后执行time.sleep(2)，此时不会释放B锁&lt;/li&gt;
&lt;li&gt;在thread1执行func2的同时thread2开始执行func1获取到了A锁，然后继续要获取B锁&lt;/li&gt;
&lt;li&gt;不幸的是B锁还被thread1占用，thread1占用B锁时还需要同时获取A锁才能向下执行，但是此时发现A锁已经被thread2暂用，这样就死锁了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e3032c8e-30db-4d86-bf94-a4e02503f57b')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_e3032c8e-30db-4d86-bf94-a4e02503f57b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e3032c8e-30db-4d86-bf94-a4e02503f57b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e3032c8e-30db-4d86-bf94-a4e02503f57b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e3032c8e-30db-4d86-bf94-a4e02503f57b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread,Lock
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
mutexA&lt;/span&gt;=&lt;span&gt;Lock()
mutexB&lt;/span&gt;=&lt;span&gt;Lock()

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyThread(Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        self.func1()
        self.func2()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1(self):
        mutexA.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[41m%s 拿到A锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)

        mutexB.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[42m%s 拿到B锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        mutexB.release()

        mutexA.release()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2(self):
        mutexB.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[43m%s 拿到B锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        time.sleep(&lt;/span&gt;2&lt;span&gt;)

        mutexA.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[44m%s 拿到A锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        mutexA.release()

        mutexB.release()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2&lt;span&gt;):
        t&lt;/span&gt;=&lt;span&gt;MyThread()
        t.start()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：输出下面结果后程序卡死，不再向下进行了&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-1 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-1 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-1 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-2 拿到A锁&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;产生死锁代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;7、递归锁：lock = threading.RLock()  解决死锁问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;递归锁的作用是同一线程中多次请求同一资源，但是不会参数死锁。&lt;/li&gt;
&lt;li&gt;这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。&lt;/li&gt;
&lt;li&gt;直到一个线程所有的acquire都被release，其他的线程才能获得资源。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a461c741-315e-4403-97d4-568db36a1bf8')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_a461c741-315e-4403-97d4-568db36a1bf8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a461c741-315e-4403-97d4-568db36a1bf8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a461c741-315e-4403-97d4-568db36a1bf8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a461c741-315e-4403-97d4-568db36a1bf8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread,Lock,RLock
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

mutexA&lt;/span&gt;=mutexB=&lt;span&gt;RLock()

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyThread(Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        self.f1()
        self.f2()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(self):
        mutexA.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 拿到A锁&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)

        mutexB.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 拿到B锁&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        mutexB.release()

        mutexA.release()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f2(self):
        mutexB.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 拿到B锁&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.name)
        time.sleep(&lt;/span&gt;0.1&lt;span&gt;)
        mutexA.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 拿到A锁&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.name)
        mutexA.release()

        mutexB.release()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
        t&lt;/span&gt;=&lt;span&gt;MyThread()
        t.start()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面是运行结果：不会产生死锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-1 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-1 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-1 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-1 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-2 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-2 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-2 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-2 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-4 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-4 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-4 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-4 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-3 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-3 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-3 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-3 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-5 拿到A锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-5 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-5 拿到B锁&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Thread-5 拿到A锁&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;如果使用RLock代替Lock，则不会发生死锁&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;8、Semaphore(信号量)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据&lt;/li&gt;
&lt;li&gt;比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去&lt;/li&gt;
&lt;li&gt;作用就是同一时刻允许运行的线程数量&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('92d03073-41e2-4d4c-809e-1f842fe2ceb1')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_92d03073-41e2-4d4c-809e-1f842fe2ceb1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_92d03073-41e2-4d4c-809e-1f842fe2ceb1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('92d03073-41e2-4d4c-809e-1f842fe2ceb1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_92d03073-41e2-4d4c-809e-1f842fe2ceb1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; import threading,time&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; def run(n):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     semaphore.acquire()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     time.sleep(1)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print(&quot;run the thread: %s\n&quot; %n)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     semaphore.release()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; if __name__ == '__main__':&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     semaphore  = threading.BoundedSemaphore(5) #最多允许5个线程同时运行&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     for i in range(22):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         t = threading.Thread(target=run,args=(i,))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         t.start()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; while threading.active_count() != 1:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     pass #print threading.active_count()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; else:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print('----all threads done---')&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 代码结果说明：这里可以清晰看到运行时0-4是同时运行的没有顺序，而且是前五个，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 表示再semaphore这个信号量的定义下程序同时仅能执行5个线程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;信号量举例&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;9、events总共就只有四个方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1. event.set()          : &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置标志位&lt;/span&gt;
2. event.clear()       : &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 清除标志位&lt;/span&gt;
3. event.wait()        : &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等待标志被设定&lt;/span&gt;
4. event.is_set()     : &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断标志位是否被设定&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9dcdf344-02e4-428b-ae88-ecbb20d47b20')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_9dcdf344-02e4-428b-ae88-ecbb20d47b20&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9dcdf344-02e4-428b-ae88-ecbb20d47b20&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9dcdf344-02e4-428b-ae88-ecbb20d47b20',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9dcdf344-02e4-428b-ae88-ecbb20d47b20&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time,threading

event &lt;/span&gt;=&lt;span&gt; threading.Event()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一：写一个红绿灯的死循环&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; lighter():
    count &lt;/span&gt;=&lt;span&gt; 0
    event.set()               &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1先设置为绿灯&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; count &amp;gt; 5 &lt;span&gt;and&lt;/span&gt; count &amp;lt;10:      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2改成红灯&lt;/span&gt;
            event.clear()          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3把标志位清了&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red light is on.....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; count &amp;gt; 10&lt;span&gt;:
            event.set()            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4再设置标志位，变绿灯&lt;/span&gt;
            count =&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green light is on.....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        count &lt;/span&gt;+= 1

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第二：写一个车的死循环&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; car(name):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.is_set():         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置了标志位代表绿灯&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[%s] is running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;name)
            time.sleep(&lt;/span&gt;1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%s] sees red light, waiting......&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;name)
            event.wait()
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%s] green light is on,start going.....&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;name)

light &lt;/span&gt;= threading.Thread(target=&lt;span&gt;lighter,)
light.start()
car1 &lt;/span&gt;= threading.Thread(target=car,args=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tesla&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))
car1.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;events（红绿灯例子）&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;进程 &lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;多线程和多进程各自应用场景&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;I/O操作不占用CPU（从硬盘，网路读入数据等）&lt;/li&gt;
&lt;li&gt;计算占用CPU，这种情况最好不用多线程&lt;/li&gt;
&lt;li&gt;python多线程不适合CPU密集型的任务，适合I/O密集型的任务&lt;/li&gt;
&lt;li&gt;python的多进程适合CPU密集型任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一次性起多个进程，并在进程中调用线程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('90e05806-35b6-40b7-8a81-f9ebfc4ef06c')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_90e05806-35b6-40b7-8a81-f9ebfc4ef06c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_90e05806-35b6-40b7-8a81-f9ebfc4ef06c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('90e05806-35b6-40b7-8a81-f9ebfc4ef06c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_90e05806-35b6-40b7-8a81-f9ebfc4ef06c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; multiprocessing,time,threading

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3 被多线程调用的函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; thread_run():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(threading.get_ident())   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印线程id号&lt;/span&gt;
    time.sleep(2&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2 被多进程调用的函数，以及在这个函数中起一个进程&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(name):
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name)
    t &lt;/span&gt;= threading.Thread(target=thread_run,)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在进程调用的函数中启用一个线程&lt;/span&gt;
&lt;span&gt;    t.start()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 一次性启动多个进程&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        p &lt;/span&gt;= multiprocessing.Process(target=run,args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bob %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%i,)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启用一个多线程&lt;/span&gt;
        p.start()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;一次性起多个进程，并在进程中调用线程&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程间互相访问数据的三种方法&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注&lt;/strong&gt;：不同进程间内存是不共享的，所以互相之间不能访问对方数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在父进程中定义队列q，使用父进程启用一个子进程，子进程中无法操作父进程的q&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d10fbec8-23b0-45f4-a276-f42d46a6bb2c')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_d10fbec8-23b0-45f4-a276-f42d46a6bb2c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d10fbec8-23b0-45f4-a276-f42d46a6bb2c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d10fbec8-23b0-45f4-a276-f42d46a6bb2c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d10fbec8-23b0-45f4-a276-f42d46a6bb2c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f():
    q.put([&lt;/span&gt;42, None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
 
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    q &lt;/span&gt;= queue.Queue()              &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 在父进程中定义一个队列实例q&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; p = threading.Thread(target=f,)    #在线程程中就可以相互访问，线程中内存共享&lt;/span&gt;
    p = Process(target=f,)        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2 在父进程中起一个子进程 p，在子进程中使用父进程的q会报错&lt;/span&gt;
&lt;span&gt;    p.start()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
    p.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;子进程无法访问父进程数据举例&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;利用Queues实现父进程到子进程（或子进程间）的数据传递&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;我们以前学的queue是线程queue.Queue()只有在同一个进程的线程间才能访问&lt;/li&gt;
&lt;li&gt;如果两个进程间想要通信必须要使用进程Queue，用法和多线程的相同&lt;/li&gt;
&lt;li&gt;queue.Queue()是线程q不可以传递给子进程，但是Queue是进程q，父进程会将进程q克隆了一份给子进程&lt;/li&gt;
&lt;li&gt;既然是两个q为什么在子进程中在q中放入一个数据在父进程中可以取出来呢？ 其实原因是这样的：
&lt;ul&gt;&lt;li&gt;子进程向q中放入数据的时候，用pickle序列化将数据放到一个中间地方（翻译），翻译又把子进程放&lt;/li&gt;
&lt;li&gt;入的数据用pickle反序列化给父进程，父进程就可以访问这个q了，这样就实现了进程间的数据通信了&lt;/li&gt;
&lt;li&gt;在多线程中两个线程可以修改同一份数据，而Queue仅仅实现了进程间的数据传递&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cba32c63-42ad-4a1c-8ab3-9ef8c16102c8')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_cba32c63-42ad-4a1c-8ab3-9ef8c16102c8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cba32c63-42ad-4a1c-8ab3-9ef8c16102c8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cba32c63-42ad-4a1c-8ab3-9ef8c16102c8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cba32c63-42ad-4a1c-8ab3-9ef8c16102c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Queue

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; f(qq):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将符进程中的q传递过来叫qq&lt;/span&gt;
    qq.put([42, None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此时子进程就可以使用符进程中的q&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    q &lt;/span&gt;= Queue()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用Queue()在父进程中定义一个队列实例q&lt;/span&gt;
    p = Process(target=f, args=(q,))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在父进程中起一个子进程 p，将父进程刚定义的q传递给子进程p&lt;/span&gt;
&lt;span&gt;    p.start()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
    p.join()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果： [42, None, 'hello']&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Queues实现父子进程间传递数据&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;使用管道pipe实现两个进程间数据传递&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;说明：&lt;/strong&gt;其实pip实现进程间通信就好像一条电话线一样，一个在电话线这头发送，一个在电话线那头接收&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2b9cc736-8b00-4775-9249-1f80d6eca322')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_2b9cc736-8b00-4775-9249-1f80d6eca322&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2b9cc736-8b00-4775-9249-1f80d6eca322&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2b9cc736-8b00-4775-9249-1f80d6eca322',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2b9cc736-8b00-4775-9249-1f80d6eca322&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Pipe

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(conn):
    conn.send([&lt;/span&gt;42, None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3 子进程发送数据，就像socket一样&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;son process recv:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, conn.recv())
    conn.close()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    parent_conn, child_conn &lt;/span&gt;=&lt;span&gt; Pipe()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1 生成一个管道实例，实例一生成就会生成两个返回对象，一个是管道这头，一个是管道那头&lt;/span&gt;
    p = Process(target=f, args=(child_conn,))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2 启动一个子进程将管道其中一头传递给子进程&lt;/span&gt;
&lt;span&gt;    p.start()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(parent_conn.recv())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4 父进程收消息 # prints &quot;[42, None, 'hello']&quot;&lt;/span&gt;
    parent_conn.send(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i am parent process&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    p.join()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; [42, None, 'hello']&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; son process recv: i am parent process&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;pip实现进程间通信&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Managers实现很多进程间数据共享&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;说明：&lt;/strong&gt;manager实质和Queue一样，启用是个线程其实就是将字典或者列表copy十份&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7f428a59-c8bf-4dc1-ae3c-75c41e8afe51')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_7f428a59-c8bf-4dc1-ae3c-75c41e8afe51&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7f428a59-c8bf-4dc1-ae3c-75c41e8afe51&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7f428a59-c8bf-4dc1-ae3c-75c41e8afe51',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7f428a59-c8bf-4dc1-ae3c-75c41e8afe51&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Manager
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(d, l):
    d[&lt;/span&gt;1] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是个进程对字典放入的是同一个值，所以看上去效果不明显&lt;/span&gt;
    l.append(os.getpid())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将这是个进程的进程id放入列表中&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    with Manager() as manager:  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1 将Manager()赋值给manager&lt;/span&gt;
        d = manager.dict()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2 定义一个可以在多个进程间可以共享的字典&lt;/span&gt;
        l = manager.list(range(5))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3 定义一个可以在多个进程间可以共享的列表，默认写五个数据&lt;/span&gt;
        p_list =&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成是个进程&lt;/span&gt;
            p = Process(target=f, args=(d, l))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将刚刚生成的可共享字典和列表传递给子进程&lt;/span&gt;
&lt;span&gt;            p.start()
            p_list.append(p)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; res &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
            res.join()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;managers实现进程间数据共享&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程之间需要锁的原因&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;说明：&lt;/strong&gt;虽然每个进程是独立运行的，但是他们共享同一块屏幕，如果大家都在屏幕打数据就会打乱了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('535577fc-6a4e-429d-8f51-9873daf88ca0')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_535577fc-6a4e-429d-8f51-9873daf88ca0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_535577fc-6a4e-429d-8f51-9873daf88ca0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('535577fc-6a4e-429d-8f51-9873daf88ca0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_535577fc-6a4e-429d-8f51-9873daf88ca0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Lock
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(l, i):
    l.acquire()                     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;一个进程要打印数据时先锁定&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i)
    l.release()                     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印完毕后就释放这把锁&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    lock &lt;/span&gt;= Lock()                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先生成一把锁&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
        Process(target&lt;/span&gt;=f, args=&lt;span&gt;(lock, num)).start()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello world 4&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello world 0&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello world 2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello world 3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello world 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;进程锁&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程池&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;进程池的作用就是限制同一时间可以启动进程的=数量&lt;/li&gt;
&lt;li&gt;进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进那么程序就会等待，直到进程池中有可用进程为止。&lt;/li&gt;
&lt;li&gt;进程池中有两个方法：
&lt;ul&gt;&lt;li&gt;apply： 多个进程异步执行，一个一个的执行&lt;/li&gt;
&lt;li&gt;apply_async： 多个进程同步执行，同时执行多个进程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4115175f-fe20-43b1-adf1-bb62dc6faad6')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_4115175f-fe20-43b1-adf1-bb62dc6faad6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4115175f-fe20-43b1-adf1-bb62dc6faad6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4115175f-fe20-43b1-adf1-bb62dc6faad6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4115175f-fe20-43b1-adf1-bb62dc6faad6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;  multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process,Pool
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time,os
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo(i):
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in the process&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,os.getpid()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印子进程的pid&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; i+100

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; call(arg):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--&amp;gt;exec done:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,arg,os.getpid())

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    pool &lt;/span&gt;= Pool(3)                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进程池最多允许5个进程放入进程池&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主进程pid：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,os.getpid())     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印父进程的pid&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用法1 callback作用是指定只有当Foo运行结束后就执行callback调用的函数,父进程调用的callback函数&lt;/span&gt;
        pool.apply_async(func=foo, args=(i,),callback=&lt;span&gt;call)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用法2 串行 启动进程不在用Process而是直接用pool.apply()&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pool.apply(func=foo, args=(i,))&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    pool.close()    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭pool&lt;/span&gt;
    pool.join()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;进程池&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;僵尸进程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;僵尸进程定义
&lt;ul&gt;&lt;li&gt;僵尸进程产生的原因就是父进程产生子进程后，子进程先于父进程退出&lt;/li&gt;
&lt;li&gt;但是父进程由于种种原因，并没有处理子进程发送的退出信号，那么这个子进程就会成为僵尸进程。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用python写一个僵尸进程&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('54b90d2c-2e50-45b4-b938-77642573f572')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_54b90d2c-2e50-45b4-b938-77642573f572&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_54b90d2c-2e50-45b4-b938-77642573f572&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('54b90d2c-2e50-45b4-b938-77642573f572',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_54b90d2c-2e50-45b4-b938-77642573f572&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;coding=utf8&lt;/span&gt;
 
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os, sys, time
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;产生子进程&lt;/span&gt;
pid =&lt;span&gt; os.fork()
 
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid ==&lt;span&gt; 0:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子进程退出&lt;/span&gt;
&lt;span&gt;    sys.exit(0)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;父进程休息30秒&lt;/span&gt;
time.sleep(30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先产生一个子进程，子进程退出，父进程休息30秒,那就会产生一个僵尸进程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;defunct.py&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('63178e0c-47ed-45fb-9d1d-a3605c905b93')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_63178e0c-47ed-45fb-9d1d-a3605c905b93&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_63178e0c-47ed-45fb-9d1d-a3605c905b93&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('63178e0c-47ed-45fb-9d1d-a3605c905b93',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_63178e0c-47ed-45fb-9d1d-a3605c905b93&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
[root@linux-node4 ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ps -ef| grep defunct&lt;/span&gt;
root     110401  96083  0 19:11 pts/2    00:00:00&lt;span&gt; python defunct.py
root     &lt;/span&gt;110402 110401  0 19:11 pts/2    00:00:00 [python] &amp;lt;defunct&amp;gt;&lt;span&gt;
root     &lt;/span&gt;110406  96105  0 19:11 pts/3    00:00:00 grep --color=auto defunct
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ps -ef| grep defunct 在linux下查看僵尸进程&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;协程(Coroutine) &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、什么是协程（进入上一次调用的状态）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;协程，又称微线程，纤程，协程是一种用户态的轻量级线程。&lt;/li&gt;
&lt;li&gt;线程的切换会保存到CPU的栈里，协程拥有自己的寄存器上下文和栈，&lt;/li&gt;
&lt;li&gt;协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协程能保留上一次调用时的状态&lt;/strong&gt;（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的&lt;/strong&gt;（像yield一样）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、协程的好处&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无需线程上下文切换的开销（可以理解为协程切换就是在不同函数间切换，不用像线程那样切换上下文CPU）&lt;/li&gt;
&lt;li&gt;不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用法：&lt;/strong&gt;最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3、协程缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无法利用多核资源：&lt;strong&gt;协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上&lt;/strong&gt;,协程需要和进程配合才能运行在多CPU上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程阻塞（Blocking）操作（如IO时）会阻塞掉整个程序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4、使用yield实现协程相同效果&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('313a0307-717e-4aef-b48f-6c78b2d0b399')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_313a0307-717e-4aef-b48f-6c78b2d0b399&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_313a0307-717e-4aef-b48f-6c78b2d0b399&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('313a0307-717e-4aef-b48f-6c78b2d0b399',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_313a0307-717e-4aef-b48f-6c78b2d0b399&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; consumer(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&amp;gt;starting eating baozi...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        new_baozi &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只要遇到yield程序就返回，yield还可以接收数据&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[%s] is eating baozi %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (name, new_baozi))
        time.sleep(&lt;/span&gt;1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; producer():
    r &lt;/span&gt;= con.&lt;span&gt;__next__&lt;/span&gt;()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接调用消费者的__next__方法&lt;/span&gt;
    r = con2.&lt;span&gt;__next__&lt;/span&gt;()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 函数里面有yield第一次加括号调用会变成一个生成器函数不执行，运行next才执行&lt;/span&gt;
    n =&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; n &amp;lt; 5&lt;span&gt;:
        n &lt;/span&gt;+= 1&lt;span&gt;
        con.send(n)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; send恢复生成器同时并传递一个值给yield&lt;/span&gt;
&lt;span&gt;        con2.send(n)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[32;1m[producer]\033[0m is making baozi %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; n)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    con &lt;/span&gt;= consumer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    con2 &lt;/span&gt;= consumer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    p &lt;/span&gt;= producer()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;yield模拟实现协程效果&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5、协程为何能处理大并发1：Greenlet遇到I/O手动切换&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;协程之所以快是因为遇到I/O操作就切换（最后只有CPU运算）&lt;/li&gt;
&lt;li&gt;这里先演示用greenlet实现手动的对各个协程之间切换&lt;/li&gt;
&lt;li&gt;其实Gevent模块仅仅是对greenlet的再封装，将I/O间的手动切换变成自动切换&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('aacd484e-1c15-40a3-9ad1-4f76626d2e97')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_aacd484e-1c15-40a3-9ad1-4f76626d2e97&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aacd484e-1c15-40a3-9ad1-4f76626d2e97&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('aacd484e-1c15-40a3-9ad1-4f76626d2e97',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aacd484e-1c15-40a3-9ad1-4f76626d2e97&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; greenlet &lt;span&gt;import&lt;/span&gt;&lt;span&gt; greenlet

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(12)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4 gr1会调用test1()先打印12&lt;/span&gt;
    gr2.switch()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;5 然后gr2.switch()就会切换到gr2这个协程&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(34)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;8 由于在test2()切换到了gr1，所以gr1又从上次停止的位置开始执行&lt;/span&gt;
    gr2.switch()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;9 在这里又切换到gr2，会再次切换到test2()中执行&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(56)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;6 启动gr2后会调用test2()打印56&lt;/span&gt;
    gr1.switch()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;7 然后又切换到gr1&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(78)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;10 切换到gr2后会接着上次执行，打印78&lt;/span&gt;
&lt;span&gt;
gr1 &lt;/span&gt;= greenlet(test1)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 启动一个协程gr1&lt;/span&gt;
gr2 = greenlet(test2)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2 启动第二个协程gr2&lt;/span&gt;
gr1.switch()             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3 首先gr1.switch() 就会去执行gr1这个协程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Greenlet遇到I/O手动切换&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6、协程为何能处理大并发2：Gevent遇到I/O自动切换&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程&lt;/li&gt;
&lt;li&gt;在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程&lt;/li&gt;
&lt;li&gt;Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。&lt;/li&gt;
&lt;li&gt;Gevent原理是只要遇到I/O操作就会自动切换到下一个协程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;7、Gevent实现简单的自动切换小例子&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注：&lt;/strong&gt;在Gevent模仿I/O切换的时候，只要遇到I/O就会切换，哪怕gevent.sleep(0)也要切换一次&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e3b80a4c-a948-40b0-b3e3-21e247584c53')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_e3b80a4c-a948-40b0-b3e3-21e247584c53&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e3b80a4c-a948-40b0-b3e3-21e247584c53&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e3b80a4c-a948-40b0-b3e3-21e247584c53',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e3b80a4c-a948-40b0-b3e3-21e247584c53&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[31;1m第一次打印\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    gevent.sleep(&lt;/span&gt;2)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为什么用gevent.sleep()而不是time.sleep()因为是为了模仿I/O&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[31;1m第六次打印\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[32;1m第二次打印\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    gevent.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[32;1m第四次打印\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[32;1m第三次打印\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    gevent.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[32;1m第五次打印\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

gevent.joinall([            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将要启动的多个协程放到event.joinall的列表中，即可实现自动切换&lt;/span&gt;
    gevent.spawn(func1),    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; gevent.spawn(func1)启动这个协程&lt;/span&gt;
&lt;span&gt;    gevent.spawn(func2),
    gevent.spawn(func3),
])

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 第一次打印&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 第二次打印&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 第三次打印&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 第四次打印&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 第五次打印&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 第六次打印&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Gevent实现简单的自动切换小例子&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;8、使用Gevent实现并发下载网页与串行下载网页时间比较&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4d924be7-0418-4718-af41-450288d3058d')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_4d924be7-0418-4718-af41-450288d3058d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4d924be7-0418-4718-af41-450288d3058d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4d924be7-0418-4718-af41-450288d3058d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4d924be7-0418-4718-af41-450288d3058d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; urllib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent,time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; gevent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; monkey
monkey.patch_all()      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把当前程序所有的I/O操作给我单独做上标记&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(url):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; url)
    resp &lt;/span&gt;=&lt;span&gt; request.urlopen(url)
    data &lt;/span&gt;=&lt;span&gt; resp.read()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d bytes received from %s.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (len(data), url))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 并发执行部分&lt;/span&gt;
time_binxing =&lt;span&gt; time.time()
gevent.joinall([
        gevent.spawn(f, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.python.org/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        gevent.spawn(f, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.yahoo.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        gevent.spawn(f, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://github.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;并行时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,time.time()-&lt;span&gt;time_binxing)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2 串行部分&lt;/span&gt;
time_chuanxing =&lt;span&gt; time.time()
urls &lt;/span&gt;=&lt;span&gt; [
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.python.org/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.yahoo.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://github.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                                        ]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; urls:
    f(url)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;串行时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,time.time()-&lt;span&gt;time_chuanxing)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注：为什么要在文件开通使用monkey.patch_all()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1. 因为有很多模块在使用I / O操作时Gevent是无法捕获的，所以为了使Gevent能够识别出程序中的I / O操作。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2. 就必须使用Gevent模块的monkey模块，把当前程序所有的I / O操作给我单独做上标记&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 3.使用monkey做标记仅用两步即可：&lt;/span&gt;
      第一步(导入monkey模块)：  &lt;span&gt;from&lt;/span&gt; gevent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; monkey
      第二步(声明做标记)    ：   monkey.patch_all()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;并行串行时间比较&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;说明：&lt;/strong&gt;monkey.patch_all()猴子补丁作用&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;用过gevent就会知道,会在最开头的地方gevent.monkey.patch_all();&lt;/li&gt;
&lt;li&gt;作用是把标准库中的thread/socket等给替换掉.这样我们在后面使用socket的时候可以跟平常一样使用,无需修改任何代码,但是它变成非阻塞的了.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;9、通过gevent自己实现单线程下的多socket并发&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('94f91eb6-411a-4bd5-b8fd-fcc1ba2f596b')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_94f91eb6-411a-4bd5-b8fd-fcc1ba2f596b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_94f91eb6-411a-4bd5-b8fd-fcc1ba2f596b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('94f91eb6-411a-4bd5-b8fd-fcc1ba2f596b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_94f91eb6-411a-4bd5-b8fd-fcc1ba2f596b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; gevent &lt;span&gt;import&lt;/span&gt; socket,monkey     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;下面使用的socket是Gevent的socket，实际测试monkey没用&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; monkey.patch_all()&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; server(port):
    s &lt;/span&gt;=&lt;span&gt; socket.socket()
    s.bind((&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,port))
    s.listen(&lt;/span&gt;5&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        cli,addr &lt;/span&gt;=&lt;span&gt; s.accept()
        gevent.spawn(handle_request,cli)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle_request(conn):
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            data &lt;/span&gt;= conn.recv(1024&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;recv:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,data)
            conn.send(data)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; data:
                conn.shutdown(socket.SHUT_WR)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        conn.close()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    server(&lt;/span&gt;8001)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server端&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ca28cc80-449a-4b01-8a5a-4e33fb53d5e7')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_ca28cc80-449a-4b01-8a5a-4e33fb53d5e7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ca28cc80-449a-4b01-8a5a-4e33fb53d5e7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ca28cc80-449a-4b01-8a5a-4e33fb53d5e7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ca28cc80-449a-4b01-8a5a-4e33fb53d5e7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
HOST &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; The remote host&lt;/span&gt;
PORT = 8001           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; The same port as used by the server&lt;/span&gt;
s =&lt;span&gt; socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg &lt;/span&gt;= bytes(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(msg) == 0:&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
    s.sendall(msg)
    data &lt;/span&gt;= s.recv(1024&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Received&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, repr(data))
s.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client端&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;10、协程本质原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;协程1通过os去读一个file，这个时候就是一个io操作，在调用os的接口前，就会有一个列表&lt;/li&gt;
&lt;li&gt;协程1的这个操作就会被注册到这个列表中，然后就切换到其他协程去处理；&lt;/li&gt;
&lt;li&gt;等待os拿到要读file后，也会把这个文件句柄放在这个列表中&lt;/li&gt;
&lt;li&gt;然后等待在切换到协程1的时候，协程1就可以直接从列表中拿到数据，这样就可以实现不阻塞了&lt;/li&gt;
&lt;li&gt;epoll返回给协程的任务列表在内核态，协程在用户态，用户态协程是不能直接访问内核态的任务列表的，所以需要拷贝整个内核态的任务列表到用户态，供协程去访问和查询&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;11、epoll处理 I/O 请求原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;epoll() 中内核则维护一个链表，epoll_wait 直接检查链表是不是空就知道是否有文件描述符准备好了。&lt;/li&gt;
&lt;li&gt;在内核实现中 epoll 是根据每个 sockfd 上面的与设备驱动程序建立起来的回调函数实现的。&lt;/li&gt;
&lt;li&gt;某个 sockfd 上的事件发生时，与它对应的回调函数就会被调用，来把这个 sockfd 加入链表，其他处于“空闲的”状态的则不会。&lt;/li&gt;
&lt;li&gt;epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术， 避免了复制大量文件描述符带来的开销&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存映射（mmap）&lt;/strong&gt;：内存映射文件，是由一个文件到一块内存的映射，将不必再对文件执行I/O操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;12、select处理协程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拷贝所有的文件描述符给协程，不论这些任务的是否就绪，都会被返回&lt;/li&gt;
&lt;li&gt;那么协程就只能for循环去查找自己的文件描述符，也就是任务列表，select的兼容性非常好，支持linux和windows&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;13、select、epool、pool&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;I/O的实质是什么？&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;I/O的实质是将硬盘中的数据，或收到的数据实现从内核态 copy到 用户态的过程&lt;/li&gt;
&lt;li&gt;本文讨论的背景是Linux环境下的network IO。&lt;/li&gt;
&lt;li&gt;比如微信读取本地硬盘的过程
&lt;ul&gt;&lt;li&gt;微信进程会发送一个读取硬盘的请求----》操作系统&lt;/li&gt;
&lt;li&gt;只有内核才能够读取硬盘中的数据---》数据返回给微信程序（看上去就好像是微信直接读取）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户态 &amp;amp; 内核态&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;系统空间分为两个部分，一部分是内核态，一部分是用户态的部分&lt;/li&gt;
&lt;li&gt;内核态：内核态的空间资源只有操作系统能够访问&lt;/li&gt;
&lt;li&gt;用户态：我们写的普通程序使用的空间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1866130/202003/1866130-20200310001825771-1347495999.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;select&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;只能处理1024个连接（每一个请求都可以理解为一个连接）&lt;/li&gt;
&lt;li&gt;不能告诉用户程序，哪一个连接是活跃的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pool&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;只是取消了最大1024个活跃的限制&lt;/li&gt;
&lt;li&gt;不能告诉用户程序，哪一个连接是活跃的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;epool&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;不仅取消了1024这个最大连接限制&lt;/li&gt;
&lt;li&gt;而且能告诉用户程序哪一个是活跃的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1866130/202003/1866130-20200310002024751-1167482018.png&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;674&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python进程池和线程池(ThreadPoolExecutor&amp;amp;ProcessPoolExecutor) &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;简介 &lt;a title=&quot;Python进程池&quot; href=&quot;https://docs.python.org/3/library/concurrent.futures.html&quot; target=&quot;_blank&quot;&gt;参考官网&lt;/a&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;Python标准库为我们提供了threading和multiprocessing模块编写相应的多线程/多进程代码&lt;/li&gt;
&lt;li&gt;但是当项目达到一定的规模，频繁创建/销毁进程或者线程是非常消耗资源的，这个时候我们就要编写自己的线程池/进程池，以空间换时间。&lt;/li&gt;
&lt;li&gt;但从Python3.2开始，标准库为我们提供了concurrent.futures模块，它提供了ThreadPoolExecutor和ProcessPoolExecutor两个类，&lt;/li&gt;
&lt;li&gt;实现了对threading和multiprocessing的进一步抽象，对编写线程池/进程池提供了直接的支持。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Executor和Future&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;strong&gt;1. Executor&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;concurrent.futures模块的基础是Exectuor，Executor是一个抽象类，它不能被直接使用。&lt;/li&gt;
&lt;li&gt;但是它提供的两个子类ThreadPoolExecutor和ProcessPoolExecutor却是非常有用&lt;/li&gt;
&lt;li&gt;我们可以将相应的tasks直接放入线程池/进程池，不需要维护Queue来操心死锁的问题，线程池/进程池会自动帮我们调度。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;strong&gt;2. Future&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Future你可以把它理解为一个在未来完成的操作，这是异步编程的基础，&lt;/li&gt;
&lt;li&gt;传统编程模式下比如我们操作queue.get的时候，在等待返回结果之前会产生阻塞，cpu不能让出来做其他事情，&lt;/li&gt;
&lt;li&gt;而Future的引入帮助我们在等待的这段时间可以完成其他的操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ThreadPoolExecutor(线程池)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('735c2f85-07aa-4071-b456-8fa736cceb1a')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_735c2f85-07aa-4071-b456-8fa736cceb1a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_735c2f85-07aa-4071-b456-8fa736cceb1a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('735c2f85-07aa-4071-b456-8fa736cceb1a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_735c2f85-07aa-4071-b456-8fa736cceb1a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; return_future_result(message):
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; message
pool &lt;/span&gt;= ThreadPoolExecutor(max_workers=2)                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个最大可容纳2个task的线程池&lt;/span&gt;
future1 = pool.submit(return_future_result, (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 往线程池里面加入一个task&lt;/span&gt;
future2 = pool.submit(return_future_result, (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 往线程池里面加入一个task&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(future1.done())      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断task1是否结束&lt;/span&gt;
time.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(future2.done())      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断task2是否结束&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(future1.result())    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看task1返回的结果&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(future2.result())    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看task2返回的结果&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; False   # 这个False与下面的True会等待3秒&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; True    # 后面三个输出都是一起打出来的&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; world&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;使用submit来操作线程池/进程池&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('785f96ab-3e7d-4ba2-b660-def71cccf7f1')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_785f96ab-3e7d-4ba2-b660-def71cccf7f1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_785f96ab-3e7d-4ba2-b660-def71cccf7f1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('785f96ab-3e7d-4ba2-b660-def71cccf7f1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_785f96ab-3e7d-4ba2-b660-def71cccf7f1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; concurrent.futures
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
URLS &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://example.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://api.github.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; load_url(url, timeout):
    with urllib.request.urlopen(url, timeout&lt;/span&gt;=&lt;span&gt;timeout) as conn:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; conn.read()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; We can use a with statement to ensure threads are cleaned up promptly&lt;/span&gt;
with concurrent.futures.ThreadPoolExecutor(max_workers=3&lt;span&gt;) as executor:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Start the load operations and mark each future with its URL&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}   # 这一句相当于下面for循环获取的字典&lt;/span&gt;
    future_to_url =&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; URLS:
        future_to_url[executor.submit(load_url,url,&lt;/span&gt;60)] = url      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; {'future对象':'url'}   future对象作为key，url作为value&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; future &lt;span&gt;in&lt;/span&gt; concurrent.futures.as_completed(future_to_url): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; as_completed返回已经有返回结果的future对象&lt;/span&gt;
        url = future_to_url[future]                                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过future对象获取对应的url&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            data &lt;/span&gt;= future.result()                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取future对象的返回结果&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as exc:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%r generated an exception: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (url, exc))
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%r page is %d bytes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (url, len(data)))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;使用for循环使用线程池，并将future对象加入字典中&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('58ad4509-6602-46f2-9656-200b81cfef00')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_58ad4509-6602-46f2-9656-200b81cfef00&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_58ad4509-6602-46f2-9656-200b81cfef00&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('58ad4509-6602-46f2-9656-200b81cfef00',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_58ad4509-6602-46f2-9656-200b81cfef00&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建线程池&lt;/span&gt;
executor = ThreadPoolExecutor(10&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_function(num1,num2):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s + %s = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(num1,num2,num1+&lt;span&gt;num2)
result_iterators &lt;/span&gt;= executor.map(test_function,[1,2,3],[5,6,7&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result_iterators:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1 + 5 = 6&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2 + 6 = 8&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 3 + 7 = 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;最简单map举例&lt;/span&gt; &lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('add1239f-5c5e-4140-a49f-65acdbf4fe80')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_add1239f-5c5e-4140-a49f-65acdbf4fe80&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_add1239f-5c5e-4140-a49f-65acdbf4fe80&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('add1239f-5c5e-4140-a49f-65acdbf4fe80',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_add1239f-5c5e-4140-a49f-65acdbf4fe80&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; concurrent.futures
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request

URLS &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://example.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://api.github.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; load_url(url):
    with urllib.request.urlopen(url, timeout&lt;/span&gt;=60&lt;span&gt;) as conn:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; conn.read()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; We can use a with statement to ensure threads are cleaned up promptly&lt;/span&gt;
with concurrent.futures.ThreadPoolExecutor(max_workers=3&lt;span&gt;) as executor:
    future_dic &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; url, data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(URLS, executor.map(load_url, URLS)):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%r page is %d bytes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (url, len(data)))
        future_dic[url] &lt;/span&gt;= data     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; {'url':'执行结果'}   url作为key，执行结果作为value&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'http://httpbin.org' page is 13011 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 'http://example.com/' page is 1270 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 'https://api.github.com/' page is 2039 bytes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;使用map同时获取多个页面中的数据&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用线程池、进程池、协程向多个url并发获取页面数据比较 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程：&lt;/strong&gt;启用进程非常浪费资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程：&lt;/strong&gt;线程多，并且在阻塞过程中无法执行其他任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协程：&lt;/strong&gt;gevent只用起一个线程，当请求发出去后gevent就不管,永远就只有一个线程工作，谁先回来先处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用for循环串行拿取页面数据（第四：性能最差）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('eda9df08-6fa4-43e0-a7da-cd897ef12c04')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_eda9df08-6fa4-43e0-a7da-cd897ef12c04&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eda9df08-6fa4-43e0-a7da-cd897ef12c04&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('eda9df08-6fa4-43e0-a7da-cd897ef12c04',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eda9df08-6fa4-43e0-a7da-cd897ef12c04&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
url_list &lt;/span&gt;=&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://dig.chouti.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; url_list:
    result &lt;/span&gt;=&lt;span&gt; requests.get(url)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result.text)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;使用for循环串行拿取页面数据（效果最差）&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程池实现并发（第三）&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;启用进程非常浪费资源&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1f61afc7-2772-4562-be8b-3bc651660ade')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_1f61afc7-2772-4562-be8b-3bc651660ade&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1f61afc7-2772-4562-be8b-3bc651660ade&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1f61afc7-2772-4562-be8b-3bc651660ade',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1f61afc7-2772-4562-be8b-3bc651660ade&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ProcessPoolExecutor

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch_request(url):
    result &lt;/span&gt;=&lt;span&gt; requests.get(url)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.text)

url_list &lt;/span&gt;=&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.google.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;google页面会卡住，知道页面超时后这个进程才结束&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://dig.chouti.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;chouti页面内容会直接返回，不会等待Google页面的返回&lt;/span&gt;
&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    pool &lt;/span&gt;= ProcessPoolExecutor(10)        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建线程池&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; url_list:
        pool.submit(fetch_request,url)    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去线程池中获取一个进程，进程去执行fetch_request方法&lt;/span&gt;
    pool.shutdown(False)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;使用进程池实现并发&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;线程池实现并发（第二）&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 创建一个新线程将消耗大量的计算资源，并且在阻塞过程中无法执行其他任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例：&lt;/strong&gt; 比如线程池中10个线程同时去10个url获取数据，当数据还没来时这些线程全部都在等待，不做事。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('41d80d91-000b-4f17-86bc-8b6d560890bc')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_41d80d91-000b-4f17-86bc-8b6d560890bc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_41d80d91-000b-4f17-86bc-8b6d560890bc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('41d80d91-000b-4f17-86bc-8b6d560890bc',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_41d80d91-000b-4f17-86bc-8b6d560890bc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch_request(url):
    result &lt;/span&gt;=&lt;span&gt; requests.get(url)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.text)

url_list &lt;/span&gt;=&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.google.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;google页面会卡住，知道页面超时后这个进程才结束&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://dig.chouti.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;chouti页面内容会直接返回，不会等待Google页面的返回&lt;/span&gt;
&lt;span&gt;]

pool &lt;/span&gt;= ThreadPoolExecutor(10)            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个线程池，最多开10个线程&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; url_list:
    pool.submit(fetch_request,url)       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去线程池中获取一个线程，线程去执行fetch_request方法&lt;/span&gt;
&lt;span&gt;
pool.shutdown(True)                      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主线程自己关闭，让子线程自己拿任务执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;使用线程池实现并发&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4665cbf0-5770-4d0e-b14a-772cdc70e4c9')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_4665cbf0-5770-4d0e-b14a-772cdc70e4c9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4665cbf0-5770-4d0e-b14a-772cdc70e4c9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4665cbf0-5770-4d0e-b14a-772cdc70e4c9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4665cbf0-5770-4d0e-b14a-772cdc70e4c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch_async(url):
    response &lt;/span&gt;=&lt;span&gt; requests.get(url)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.text

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(future):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(future.result())

url_list &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.github.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.bing.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
pool &lt;/span&gt;= ThreadPoolExecutor(5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; url_list:
    v &lt;/span&gt;=&lt;span&gt; pool.submit(fetch_async, url)
    v.add_done_callback(callback)
pool.shutdown(wait&lt;/span&gt;=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;多线程+回调函数执行&lt;/span&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;协程：微线程实现异步（第一：性能最好）&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;特点 ：&lt;/strong&gt;gevent只用起一个线程，当请求发出去后gevent就不管,永远就只有一个线程工作，谁先回来先处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d61ad9ef-70db-4976-a063-72d45fe38420')&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_d61ad9ef-70db-4976-a063-72d45fe38420&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d61ad9ef-70db-4976-a063-72d45fe38420&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d61ad9ef-70db-4976-a063-72d45fe38420',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d61ad9ef-70db-4976-a063-72d45fe38420&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; gevent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; monkey

monkey.patch_all()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这些请求谁先回来就先处理谁&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch_async(method, url, req_kwargs):
    response &lt;/span&gt;= requests.request(method=method, url=url, **&lt;span&gt;req_kwargs)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response.url, response.content)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ##### 发送请求 #####&lt;/span&gt;
&lt;span&gt;gevent.joinall([
    gevent.spawn(fetch_async, method&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, url=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.python.org/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, req_kwargs=&lt;span&gt;{}),
    gevent.spawn(fetch_async, method&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, url=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.google.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, req_kwargs=&lt;span&gt;{}),
    gevent.spawn(fetch_async, method&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, url=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://github.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, req_kwargs=&lt;span&gt;{}),
])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;协程：微线程实现异步&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 09 Mar 2020 16:36:00 +0000</pubDate>
<dc:creator>Talent、茂ღ茂</dc:creator>
<og:description>装饰器 1、什么是装饰器 装饰器本质是函数，用来给其他函数添加新的功能 特点：不修改调用方式、不修改源代码 2、装饰器的作用 装饰器作用：本质是函数（装饰其他函数）就是为其他函数添加其他功能 装饰器必</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yangmaosen/p/12452827.html</dc:identifier>
</item>
<item>
<title>矩阵乘法加速器的设计框架 - 暗海风</title>
<link>http://www.cnblogs.com/sea-wind/p/12452725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sea-wind/p/12452725.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;以往我分析了一些AI加速器的设计，包括TPU，FSD，华为达芬奇等，无一例外都是从已经给出的设计出发，去分析其优缺点和应用范围。在之前的文章中，关于这些设计是如何完成的，其背后是否有一定设计原则和理念的内容均没有进行探讨。而这两点，实则是设计一个优秀的，可持续迭代的加速器的基础。本文将从矩阵加速器出发，通过一些简化的模型，给出简单的设计框架。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般来说，矩阵乘法加速器中需要加速的计算可表示为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ C = A\times B + C \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(A\in R^{m\times k}\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(B\in R^{k\times n}\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(C\in R^{m\times n}\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;矩阵乘法加速器，一般至少包括计算单元，缓存（SRAM等构成）和内存（譬如DDR等）。其中缓存的读写速率较高，可以和计算单元的运算速度相匹配，但容量较小；内存的容量相对缓存较大，但读写速率较低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cea-wind/blogs_pictures/master/img20200309214550.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;和一般的处理器相比，特定的加速器可以设计数量巨大的计算单元（譬如Google TPU V1设计了65536个乘法器）；但是DDR的带宽的提升却是有限的。因此，设计目标之一在于优化数据访问，降低DDR的读写带宽。&lt;/p&gt;
&lt;p&gt;假设加速器的总缓存大小为&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;, 在一次计算过程中，用于存储矩阵&lt;span class=&quot;math inline&quot;&gt;\(A,B,C\)&lt;/span&gt;的缓存空间大小分别为&lt;span class=&quot;math inline&quot;&gt;\(M_A,M_B,M_C\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;矩阵乘法加速器的设计目的一般是为了加速大规模的矩阵乘法计算，为了简化分析过程，假设矩阵&lt;span class=&quot;math inline&quot;&gt;\(A,B,C\)&lt;/span&gt;的大小&lt;span class=&quot;math inline&quot;&gt;\(S_A,S_B,S_C\)&lt;/span&gt;均远大于&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;，即计算过程中每次只能在缓存中存放一部分数据，完成子矩阵&lt;span class=&quot;math inline&quot;&gt;\(A_{sub},B_{sub},C_{sub}\)&lt;/span&gt;的计算。显然，存放在缓存中的数据都会参与运算，否在有冗余数据浪费存储和带宽。因此&lt;span class=&quot;math inline&quot;&gt;\(A_{sub},B_{sub},C_{sub}\)&lt;/span&gt;应能够完成一组矩阵计算，即&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[A_{sub}\in R^{p\times s},B_{sub}\in R^{s\times q},C_{sub}\in R^{p\times q}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;据此，为了完成矩阵计算，从DDR到SRAM的总数据读写为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[D_{size} = n/q \times S_A + m/p \times S_B + 2\times S_C\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;据此可以给出优化目标为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{min} : mnk/q + mnk/p +2mn \\ \mathbf{sub.to }: p\times s + s\times q + p\times q \leqslant M\\ p&amp;gt;0,s&amp;gt;0,q&amp;gt;0 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简化为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{min} : 1/q + 1/p \\ \mathbf{sub.to }: p\times s + s\times q + p\times q \leqslant M\\ p&amp;gt;0,s&amp;gt;0,q&amp;gt;0 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;求解得当&lt;span class=&quot;math inline&quot;&gt;\(s=1\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(p=q=\sqrt{M+1}-1\)&lt;/span&gt;时得到最优解。即若要设计一个带宽优化的乘法器，应该尽可能的将缓存用于存储&lt;span class=&quot;math inline&quot;&gt;\(C_{sub}\)&lt;/span&gt;，每次计算的子矩阵为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[C_{sub}^{p\times q} += A_{sub}^{p\times 1} + B_{sub}^{1\times q} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Telsa的FSD的设计和上述讨论结果是一致的（只不过FSD的SRAM对应了上述的DDR，Register对应了上述的SRAM），FSD计算过程中&lt;span class=&quot;math inline&quot;&gt;\(A_{sub}\in R^{96\times 1},B_{sub}\in R^{96\times 96},C_{sub}\in R^{96\times 96}\)&lt;/span&gt;。对应的FSD的设计实际上是以降低SRAM-Register之间的读写为目的进行优化的。&lt;/p&gt;

&lt;p&gt;依据第二节的结果，每次计算的子矩阵为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[C_{sub}^{p\times q} += A_{sub}^{p\times 1} + B_{sub}^{1\times q} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整个计算过程中，其并行度最高为&lt;span class=&quot;math inline&quot;&gt;\({p\times q}\)&lt;/span&gt;（即每个周期完成&lt;span class=&quot;math inline&quot;&gt;\({p\times q}\)&lt;/span&gt;个乘法）。而为了完成一次计算，需要从缓存里读取&lt;span class=&quot;math inline&quot;&gt;\(p+q+q\times q\)&lt;/span&gt;个数据送入到计算阵列中。因此一次读/写的数据位宽宽度极高，随着并行度的增长，数据位宽线性增长。&lt;/p&gt;
&lt;p&gt;数据位宽的问题主要存在&lt;span class=&quot;math inline&quot;&gt;\(C_{sub}\)&lt;/span&gt;上。为了解决这一问题，Telsa FSD采用了移位的方式，在计算完成后，将计算结果依次写回到SRAM中。&lt;/p&gt;
&lt;p&gt;如果设计目的在于计算阵列和缓存之间的优化，参考第二节的设计思路，在一定并行度上，希望尽可能降低缓存的读写带宽，优化目标可以表示为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{min}:x\times y+y\times z+x\times z \\ \mathbf{sub.to }:x\times y\times z=P \\ x&amp;gt;0,y&amp;gt;0,z&amp;gt;0 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;代表计算阵列的并行度，求解得当&lt;span class=&quot;math inline&quot;&gt;\(x=y=z=\sqrt[3]{P}\)&lt;/span&gt;时，此时设计的计算阵列对缓存的访问可以尽可能的低。&lt;/p&gt;
&lt;p&gt;华为的达芬奇架构中计算阵列的设计和上述讨论是一致的，达芬奇中的CUBE Core是一个&lt;span class=&quot;math inline&quot;&gt;\(16\times16\times16\)&lt;/span&gt;的MAC阵列（以Davinci Max为例），可以完成&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[C_{sub}^{16\times 16} += A_{sub}^{16\times 16} + B_{sub}^{16\times 16} \]&lt;/span&gt;&lt;br/&gt;的矩阵计算。&lt;/p&gt;

&lt;p&gt;上述的所有讨论都基于一个最简单的硬件模型，从两个角度分别求解了理论上最优的设计应该是怎么样的。&lt;/p&gt;
&lt;p&gt;实际情况往往会复杂很多，硬件架构方面就会复杂很多。同时优化的目标往往有多个，而优化的限制条件也会有很多。&lt;/p&gt;
&lt;p&gt;但是在我看来，只有采用这样的设计方法，即将问题建模，求解，才能造就一个好的设计。也只有采用这样的设计方法，才能再已有的基础上，进一步增加优化目标和优化条件，进一步的优化架构设计。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 16:09:00 +0000</pubDate>
<dc:creator>暗海风</dc:creator>
<og:description>以往我分析了一些AI加速器的设计，包括TPU，FSD，华为达芬奇等，无一例外都是从已经给出的设计出发，去分析其优缺点和应用范围。在之前的文章中，关于这些设计是如何完成的，其背后是否有一定设计原则和理念</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sea-wind/p/12452725.html</dc:identifier>
</item>
<item>
<title>全面认识HBase架构（建议收藏） - 阿丸</title>
<link>http://www.cnblogs.com/awan-note/p/12452639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/awan-note/p/12452639.html</guid>
<description>&lt;p&gt;在网上看过很多HBaes架构相关的文章，内容深浅不一，直到发现了一篇MapR官网的文章https://mapr.com/blog/in-depth-look-hbase-architecture/#.VdMxvWSqqko，写得实在太sheng dong了。&lt;/p&gt;
&lt;p&gt;因此，以这篇文章作为骨架，翻译了许多原文的内容，同时对一些细节进行自己的扩展，形成本文。&lt;/p&gt;

&lt;p&gt;从物理结构上，HBase包含了三种类型的server，zookeeper、HMaster、region server，采用一种主从模式的结构。&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/bd410ddf88d844a0a937c6662b996f9d&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;region server主要用来服务读和写操作。当用户通过client访问数据时，client会和HBase RegionServer 进行直接通信。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;HMaster主要进行region server的管理、DDL（创建、删除表）操作等。&lt;/li&gt;
&lt;li&gt;Zookeeper是HDFS（Hadoop Distributed File System）的一部分，主要用来维持整个集群的存活，保障了HA，故障自动转移。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而底层的存储，还是依赖于HDFS的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Hadoop的DataNode存储了Region Server所管理的数据，所有HBase的数据都是存在HDFS中的。&lt;/li&gt;
&lt;li&gt;Hadoop的NameNode维护了所有物理数据块的metadata。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HBase 的tables根据rowkey的范围进行水平切分，切分后分配到各个regions。一个region包含一个表在start key和end key所有行。region会被分配到集群中的各个region server，而用户都是跟region server进行读写交互。一个region一般建议大小在5-10G。&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/3baf84ecf8304f959e3dade9dbd3d81b&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;/div&gt;

&lt;p&gt;一般也叫作HMaster，HMaster主要职责包括两个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与region server的交互，对region server进行统一管理：&lt;/li&gt;
&lt;li&gt;启动时region的分配 崩溃后恢复的region重新分配 负载均衡的region重新分配&lt;/li&gt;
&lt;li&gt;Admin相关功能：&lt;/li&gt;
&lt;li&gt;创建、删除、更新表结构等DDL操作&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/9d2f7824b14046a0bbb6734db1f07b10&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;HBase使用Zookeeper作为分布式协调服务，来维护集群内的server状态。&lt;/p&gt;
&lt;p&gt;Zookeeper通过 heartbeat 维护了哪些server是存活并可用的，并提供server的故障通知。同时，使用一致性协议来保证各个分布式节点的一致性。&lt;/p&gt;
&lt;p&gt;这里，需要特别关注，zookeeper负责来HMaster的选举工作，如果一个HMater节点宕机了，就会选择另一个HMaster节点进入active状态。&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/c6eb3fcdbaa645f6a3cd5b3469bdf4e6&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Zookeeper用来共享分布式系统中成员的状态，它会和region server、HMaster（active）保持会话，通过heartbeat维持与这些ephemeral node（zk中的临时节点概念）的活跃会话。&lt;/p&gt;
&lt;p&gt;下面，我们可以看到，zk在其中起到了最核心的作用。&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/5d01911a2bba4dd4bb2df9538434c59f&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;多个HMaster会去竞争成为zookeeper上的临时节点，而zookeeper会将第一个创建成功的HMaster作为唯一当前active的HMaster，其他HMater进入stand by的状态。这个active的HMaster会不断发送heartbeat给zk，其他stand by状态的HMaster节点会监听这个active HMaster的故障信息。一旦发现active HMaster宕机了，就会重新竞争新的active HMaster。这就实现了HMaster的高可用。&lt;/p&gt;
&lt;p&gt;每个region server会创建一个ephemeral node。HMaster会监视这些节点来确认哪些region server是可用的，哪些节点发生了故障宕机了。&lt;/p&gt;
&lt;p&gt;如果一个region server或者active的HMaster 没有发送heatbeat给zk，那么和zk之间的会话将会过期，并且zk上会删掉这个临时节点，认为这个节点发生故障需要下线了。&lt;/p&gt;
&lt;p&gt;其他监听者节点会收到这个故障节点被删除的消息。比如actvie的HMaster会监听region server的消息，如果发现某个region server下线了，那么就会重新分配region server来恢复相应的region数据。再比如，stand by的HMaster节点会监听active 的HMaster节点，一旦收到故障通知，就会竞争上线成为新的active HMaster。&lt;/p&gt;

&lt;p&gt;有一个特殊的HBase目录表，叫做META table，保存了集群中各个region的位置。zookeeper中保存了这个meta table 的位置信息。&lt;/p&gt;
&lt;p&gt;当我们第一次访问HBase集群时，会做以下操作：&lt;/p&gt;
&lt;p&gt;1）客户端从zk中获取保存meta table的位置信息，知道meta table保存在了哪个region server，并在客户端缓存这个位置信息；&lt;/p&gt;
&lt;p&gt;2）client会查询这个保存meta table的特定的region server，查询meta table信息，在table中获取自己想要访问的row key所在的region在哪个region server上。&lt;/p&gt;
&lt;p&gt;3）客户端直接访问目标region server，获取对应的row&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/de74ac21a2344425a207c1f31c7725ed&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;进一步，我们了解一下meta table的存储结构。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Meta table保存了所有region信息的一张表&lt;/li&gt;
&lt;li&gt;Meta table存储的数据形式类似一颗b树&lt;/li&gt;
&lt;li&gt;以keyvalue形式保存数据&lt;/li&gt;
&lt;li&gt;Key: region的table name, start key等信息 Values: region server的相关信息&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/63af76fe222d4599bca0c65722b3e640&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;一个region server运行在一个HDFS的data node上，并且拥有以下组件：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/dd83c3c193544e5b958a16ab4ad6ecad&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;WAL：全称Write Ahead Log， 属于分布式系统上的文件。主要用来存储还未被持久化到磁盘的新数据。如果新数据还未持久化，节点发生宕机，那么就可以用WAL来恢复这些数据。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;BlockCache：是一个读缓存。它存储了被高频访问的数据。当这个缓存满了后，会清除最近最少访问的数据。&lt;/li&gt;
&lt;li&gt;MenStore: 是一个写缓存。它存储了还未被写入磁盘的数据。它会在写入磁盘前，对自身数据进行排序，从而保证数据的顺序写入。每个region的每个colum family会有一份对应的memstore。（没错，如果节点宕机了，存在这个缓存里的数据没有落盘，可以通过WAL保证这些数据不会丢失）&lt;/li&gt;
&lt;li&gt;HFiles：按照字典序存储各个row的键值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个写的过程更加复杂，而与region server的交互式最重要的一部分，这里只介绍跟region server的交互。&lt;/p&gt;
&lt;p&gt;主要分为两个步骤，写WAL 和 写缓存。&lt;/p&gt;
&lt;p&gt;“实际上，这里除了保证数据不丢，还跟提高写入效率有关，具体后续专门写一个相关文档进行展开说明”&lt;/p&gt;
&lt;p&gt;1）写WAL&lt;/p&gt;
&lt;p&gt;当客户端提交了一个put 请求，那么在region server上需要首先写WAL(write-ahead-log)。&lt;/p&gt;
&lt;p&gt;需要注意三点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Hlog是一个region server上一个，并不是一个region一个&lt;/li&gt;
&lt;li&gt;写入数据是添加在log尾部&lt;/li&gt;
&lt;li&gt;log上的数据主要为了保证没有落盘的数据能在server崩溃后不丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/b53a8c07250643e3b46c24303eaea4d3&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;2）写缓存&lt;/p&gt;
&lt;p&gt;数据写入WAL成功，才会继续写入MemStore。&lt;/p&gt;
&lt;p&gt;然后才会返回ack给客户端，表示写入成功了。&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/0e339c7d4d324b9dbccae4b78491a7d8&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;MemStore主要保存数据更新在内存中，以字典序的KeyValue形式，跟HFile里面保存的一样。&lt;/p&gt;
&lt;p&gt;每一个column family会有一个对应的memstore&lt;/p&gt;
&lt;p&gt;更新的数据会在memstore中以key-value形式排好序存储，注意看图，按字典序排，同时按version的倒序排列。&lt;/p&gt;
&lt;p&gt;我们可以看到，key的组成包括rowkey-cf-col-version。&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/1db7dad0f9214ab7b30632a6c6066d57&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;当MemStore存储了足够多的数据，整个有序集会被写入一个新的HFile文件中，保存在HDFS。&lt;/p&gt;
&lt;p&gt;HBase中每个colum family会有多个HFile，用来存储实际的keyValue。&lt;/p&gt;

&lt;p&gt;注意，这里解释了为什么HBase中columfaily的数量是有限制的（具体是多少？）。&lt;/p&gt;
&lt;p&gt;每一个cf有一个对应的MemStore，当一个MemStore满了，所属region的所有memstore都会被flush到磁盘。所以MemStore的flush的最小单位是一个region，而不是一个MemStore。&lt;/p&gt;
&lt;p&gt;flush的同时，它还会存储一些额外的信息，比如最后一个写的序列号，让系统知道它当前持久化到什么位置了。&lt;/p&gt;
&lt;p&gt;最大的序列号作为元数据，会被存储在每个HFile中，表示持久化到哪个位置了，下一次持久化应该从哪里继续。一个region启动时，会读取每个HFile的序列号，然后最大的序列号会被用来作为新的起始序列号。&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/8f5fbbb606334b2794190db7f4505257&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;HBase中，数据以有序KV的形式，存储在HFile中。当MemStore存储了足够的数据，全部kv对被写入HFile存入HDFS。&lt;/p&gt;
&lt;p&gt;这里写文件的过程是顺序写，避免了硬盘大量移动磁头的过程，比随机写高效很多。&lt;/p&gt;
&lt;p&gt;HFile的逻辑结构如图&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/c7ee9581c42341b797339aeb75c23045&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;主要分为四个部分：Scanned block section，Non-scanned block section，Opening-time data section和Trailer。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Scanned block section：表示扫描HFile时，这部分所有数据块都会被读取，包括Leaf Index Block和Bloom Block。&lt;/li&gt;
&lt;li&gt;Non-scanned block section：表示在扫描HFile时不会被读取，主要包括Meta Block和Intermediate Level Data Index Blocks两部分。&lt;/li&gt;
&lt;li&gt;Load-on-open-section：表示在HBase的region server启动时，会被加载到内存中。包括FileInfo、Bloom filter block、data block index和meta block index。&lt;/li&gt;
&lt;li&gt;Trailer：表示HFile的基本信息、各个部分的偏移值和寻址信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文件中采用类似b+树都多层索引：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kv对按递增顺序存储；&lt;/li&gt;
&lt;li&gt;Root index指向非叶子结点&lt;/li&gt;
&lt;li&gt;每个数据块的最后一个key被放入中间索引(b+树的非叶子结点)&lt;/li&gt;
&lt;li&gt;每个数据块有自己的叶子索引（b+树的叶子结点）&lt;/li&gt;
&lt;li&gt;叶子索引通过row key指向64kb的kv数据块&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/294e2ae40fa945eb9d28b4471faa1ec1&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;文件的末尾有个trailer节点，指向了meta block。trailer节点还拥有其他信息，比如布隆过滤器和时间范围信息。&lt;/p&gt;
&lt;p&gt;布隆过滤器帮助我们过滤那些不包含在这个HFilfe中的rowkey。&lt;/p&gt;
&lt;p&gt;时间范围信息用来跳过那些不在这个HFilie时间范围内的row。&lt;/p&gt;

&lt;p&gt;因此，当一个HFile被读取后，HFile的索引信息就会被缓存在BlockCache中，这样使得查询只需要一次磁盘查询操作，后续查找只需要读取blockcache内的索引信息即可。&lt;/p&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/7871784646f549259c8c14acb950ec45&quot; alt=&quot;全面认识HBase架构（建议收藏）&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;region server上的实体结构关系如下：&lt;/p&gt;
&lt;p&gt;regionserver : region = 1 : n，每个region server上有多个region。&lt;/p&gt;
&lt;p&gt;region : store= 1 ： n，每个region里面有多个store&lt;/p&gt;
&lt;p&gt;store : memstore = 1 : 1。&lt;/p&gt;
&lt;p&gt;Memstore:Hfile = 1:n。&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;看到这里了，原创不易，点个关注、点个赞吧，你最好看了～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.030534351145&quot;&gt;
&lt;p&gt;知识碎片重新梳理，构建Java知识图谱：&lt;a href=&quot;https://github.com/saigu/JavaKnowledgeGraph&quot;&gt;https://github.com/saigu/JavaKnowledgeGraph&lt;/a&gt;（历史文章查阅非常方便）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;扫码关注我的公众号“阿丸笔记”，第一时间获取最新更新。同时可以免费获取海量Java技术栈电子书、各个大厂面试题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://img-blog.csdnimg.cn/20200216153626581.jpg&quot; alt=&quot;阿丸笔记&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 09 Mar 2020 15:55:00 +0000</pubDate>
<dc:creator>阿丸</dc:creator>
<og:description>在网上看过很多HBaes架构相关的文章，内容深浅不一，直到发现了一篇MapR官网的文章https://mapr.com/blog/in-depth-look-hbase-architecture/#.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/awan-note/p/12452639.html</dc:identifier>
</item>
<item>
<title>整合Kafka+Flink 实例（第二部分  设计思路） - alex_2008</title>
<link>http://www.cnblogs.com/alexgl2008/p/12452587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alexgl2008/p/12452587.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前     言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;拖了蛮久了，一直说要接着上一部分写设计思路以及代码，因为自己技术底子薄弱，加上人又懒，所以一直没能继续，今天补上设计思路及部分代码，后面有时间我会再补充一些应用性的功能，的确有些忙，希望对大家有用；欢迎大家提意见或者拍砖；&lt;/p&gt;
&lt;p&gt;之前，我说了，网上蛮多例子都是基于WordCount或者基于展示内存使用率来的，也没什么不对，只是我个人觉得没有太大的实用性；毕竟咱们是码农，凡事讲个应用及场景，脱离场景谈开发都是扯淡；&lt;/p&gt;

&lt;h2 align=&quot;center&quot;&gt;第一部分  场景和设计思路&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;场景：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;通过爬虫从网络获取数据，不停的插入Kafka中，Flink及时获取数据，数据打印出来。时间原因，我没有继续做Flink的复杂处理，例如过滤重复、统计数据等，回头再完善，欢迎大家拍砖；&lt;/p&gt;
&lt;p&gt;设计思路：&lt;/p&gt;
&lt;p&gt;逻辑上，三个模块，一个是网络爬虫，提供基础数据，一个插入Kafka，一个Flink接受&lt;em&gt;处理；&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;为了爬数据，我花了点时间。&lt;/p&gt;
&lt;p&gt;爬新闻数据，没意思；没有什么加工的价值，如果要加工，还要做分词拆解，麻烦；&lt;/p&gt;
&lt;p&gt;爬图片数据，更没意思；&lt;/p&gt;
&lt;p&gt;后来突然想起来一个数据：股市交易数据；挺好，一个更新快，大多是数字，加工计算还是有点价值的；&lt;/p&gt;
&lt;p&gt;话不多说，继续；&lt;/p&gt;
&lt;h3&gt;1.1 网络爬虫及基础数据&lt;/h3&gt;
&lt;p&gt;股市交易数据URL如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vip.stock.finance.sina.com.cn/quotes_service/view/cn_bill_all.php?num=100&amp;amp;page=1&amp;amp;sort=ticktime&amp;amp;asc=0&amp;amp;volume=200000&amp;amp;type=0&quot;&gt;http://vip.stock.finance.sina.com.cn/quotes_service/view/cn_bill_all.php?num=100&amp;amp;page=1&amp;amp;sort=ticktime&amp;amp;asc=0&amp;amp;volume=200000&amp;amp;type=0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 这个网页类似如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1912715/202003/1912715-20200309233501999-997898510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它有几个特点：&lt;/p&gt;
&lt;p&gt;（1）       数据条数是不停变化的；&lt;/p&gt;
&lt;p&gt;（2）       数据可能会有重复的；&lt;/p&gt;
&lt;p&gt;（3）       数据总条数还是有些量的，查询条件变化后，数据总条数可以变得更多；&lt;/p&gt;

&lt;p&gt;具体大家自己研究吧；&lt;/p&gt;
&lt;p&gt;如果我不停的抓取这些数据，不就不用for循环10000次了吗，不再像网上那些WordCount的例子咯。&lt;/p&gt;
&lt;p&gt;怎么样不停的抓呢？Quartz啊，每隔几分钟抓一次啊（如果不知道Quartz，请自行补脑）&lt;/p&gt;
&lt;h3&gt;1.2 插入数据进Kafka&lt;/h3&gt;
&lt;p&gt;这个部分，有人不停的插入数据就好了，这里几乎不用做啥，甚至可以与上面的合并在一次了；&lt;/p&gt;
&lt;h3&gt;1.3 Flink处理（打印）数据&lt;/h3&gt;
&lt;p&gt;这个打印的部分，上一篇就有实现了，不赘述；&lt;/p&gt;

&lt;h2 align=&quot;center&quot;&gt;第二部分 开发环境和代码结构&lt;/h2&gt;
&lt;p&gt;开发环境 &lt;/p&gt;

&lt;p&gt;JDK1.8+IDEA+Maven+SpringBoot&lt;/p&gt;
&lt;p&gt;Kafka   版本：kafka_2.12-2.4.0  ； 基于Windows&lt;/p&gt;
&lt;p&gt;Flink   版本：flink-1.9.1  基于Windows&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1912715/202003/1912715-20200309233526224-341286905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 align=&quot;center&quot;&gt;第三部分  部分技术点&lt;/h2&gt;
&lt;h3&gt;3.1 有关Quartz&lt;/h3&gt;
&lt;p&gt;（1）Quartz本身是可以并发的，最初我设计的时候，想通过浏览器发送申请，用于启动或者暂停爬虫抓取，本身技术上实现也不算大，但是我考虑的是，实际应用中，如果多个不同用户发送不同命令，有的人发送开始执行，有的人发送停止执行，而后台其实目前就规定抓一个页面，那么到底该听谁的？难道要做一个每个人启动每个人自己的任务？然后每个人抓的数据只给每个人用？想到这儿，我就暂停了这个部分的实现；&lt;/p&gt;
&lt;p&gt;感觉不是太实用；&lt;/p&gt;
&lt;p&gt;（2）按照设计，我只考虑一个任务进行执行，所以实际执行过程中，建议把间隔时间调的稍微长点，否则，上一个任务还没有完成，下一个任务又启动了，这样下去只会把服务器给玩宕机了；&lt;/p&gt;
&lt;p&gt;（3）我觉得还是需要有个暂停的功能，初步觉得还是用网页参数方式，&lt;/p&gt;
&lt;p&gt;（4）单独写一个Quartz的应用没啥意思，我觉得还是把它放到SpringBoot，随着系统一起启动，这样会比较方便；&lt;/p&gt;
&lt;h3&gt;3.2 有关爬虫&lt;/h3&gt;
&lt;p&gt;爬虫其实没有太多的技术难度，无非就是用HttpClient进行页面数据解析，唯一的小难点，就是要能够自动翻页，如果不能自动翻页，要它何用？&lt;/p&gt;

&lt;h3&gt;3.3 有关Flink&lt;/h3&gt;
&lt;p&gt;（1）flink的使用，我就做了打印，实现方法学习于网络，为什么打印4个文件，而只有第4个文件会被打印出来，还没研究。&lt;/p&gt;
&lt;p&gt;（2）当我把Kafka停止供应数据时，Flink会出现Reblance的异常，所以这段代码可以考虑再优化；&lt;/p&gt;


&lt;h2 align=&quot;center&quot;&gt;第四部分  运行结果&lt;/h2&gt;
&lt;p&gt;目前，我这里仅仅是打印出来，后续我会找时间再做汇总加工的逻辑；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1912715/202003/1912715-20200309233604223-1037297824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;文件内容&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1912715/202003/1912715-20200309233615472-1689025243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;我代码功底若，写的又比较仓促，刚刚开始研究Kafka及Flink就不贴在此处丢脸了。&lt;/p&gt;
&lt;p&gt;如果需要代码，评论区留下邮件地址。我晚上抽空一并发了。&lt;/p&gt;

</description>
<pubDate>Mon, 09 Mar 2020 15:43:00 +0000</pubDate>
<dc:creator>alex_2008</dc:creator>
<og:description>前 言 拖了蛮久了，一直说要接着上一部分写设计思路以及代码，因为自己技术底子薄弱，加上人又懒，所以一直没能继续，今天补上设计思路及部分代码，后面有时间我会再补充一些应用性的功能，的确有些忙，希望对大家</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/alexgl2008/p/12452587.html</dc:identifier>
</item>
</channel>
</rss>