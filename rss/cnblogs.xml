<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python文件操作中的方法：.write()换行 - vacpy</title>
<link>http://www.cnblogs.com/vacpy/p/10089720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vacpy/p/10089720.html</guid>
<description>&lt;pre readability=&quot;7&quot;&gt;
active =True&lt;br/&gt;while active:&lt;br/&gt;message =input(&quot;\nPlease input your name:\n&quot;)&lt;p&gt;if message =='q':&lt;br/&gt;break&lt;/p&gt;&lt;p&gt;print(&quot;welcome &quot; + message + &quot; come to our website!&quot;)&lt;br/&gt;with open('guest_book.txt','a') as vis_list:&lt;br/&gt;vis_list.write(message.title()+&quot;\n&quot;)                   #“\n”为换行符
&lt;/p&gt;&lt;/pre&gt;</description>
<pubDate>Sat, 08 Dec 2018 15:26:00 +0000</pubDate>
<dc:creator>vacpy</dc:creator>
<og:description>active =Truewhile active: message =input(&quot;\nPlease input your name:\n&quot;) if message =='</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vacpy/p/10089720.html</dc:identifier>
</item>
<item>
<title>堆排序优化与几个排序算法时间复杂度 - Tom-shushu</title>
<link>http://www.cnblogs.com/Tom-shushu/p/10067720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tom-shushu/p/10067720.html</guid>
<description>&lt;p&gt;&lt;strong&gt;我们通常所说的堆是指二叉堆，二叉堆又称完全二叉树或者叫近似完全二叉树。二叉堆又分为最大堆和最小堆。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。数组可以根据索引直接获取元素，时间复杂度为O（1），也就是常量，因此对于取值效率极高。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里以最大堆为例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大堆的特性如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父结点的键值总是大于或者等于任何一个子节点的键值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个结点的左子树和右子树都是一个最大堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大堆的算法思想是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于交换后，前R[0…n-2]可能不满足最大堆的性质，因此再调整前R[0…n-2]为最大堆，直到只有R[0]最后一个元素才调整完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大堆排序完成后，其实是升序序列，每次调整堆都是要得到最大的一个元素，然后与当前堆的最后一个元素交换，因此最后所得到的序列是升序序列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建堆：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_06_HEAP_SORT_HEAP_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_06_HEAP_SORT_HEAP_H
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;cassert&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; template&amp;lt;typename Item&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MaxHeap{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     Item *&lt;span&gt;data;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; shiftUp(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;( k &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; data[k/&lt;span&gt;2&lt;/span&gt;] &amp;lt;&lt;span&gt; data[k] ){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             swap( data[k/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;], data[k] );
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             k /= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; shiftDown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;( &lt;span&gt;2&lt;/span&gt;*k &amp;lt;=&lt;span&gt; count ){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;2&lt;/span&gt;*&lt;span&gt;k;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;( j+&lt;span&gt;1&lt;/span&gt; &amp;lt;= count &amp;amp;&amp;amp; data[j+&lt;span&gt;1&lt;/span&gt;] &amp;gt; data[j] ) j ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;( data[k] &amp;gt;= data[j] ) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            swap( data[k] , data[j] );
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             k =&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数, 构造一个空堆, 可容纳capacity个元素&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     MaxHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity){
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         data = &lt;span&gt;new&lt;/span&gt; Item[capacity+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;capacity =&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数, 通过一个给定数组创建一个最大堆
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该构造堆的过程, 时间复杂度为O(n)&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     MaxHeap(Item arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         data = &lt;span&gt;new&lt;/span&gt; Item[n+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         capacity =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i ++&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             data[i+&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; arr[i];
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         count =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = count/&lt;span&gt;2&lt;/span&gt; ; i &amp;gt;= &lt;span&gt;1&lt;/span&gt; ; i --&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            shiftDown(i);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     ~&lt;span&gt;MaxHeap(){
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] data;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回堆中的元素个数&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size(){
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个布尔值, 表示堆中是否为空&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isEmpty(){
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 像最大堆中插入一个新的元素 item&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(Item item){
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         assert( count + &lt;span&gt;1&lt;/span&gt; &amp;lt;=&lt;span&gt; capacity );
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         data[count+&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         shiftUp(count+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         count ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从最大堆中取出堆顶元素, 即堆中所存储的最大数据&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;    Item extractMax(){
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         assert( count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         Item ret = data[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         swap( data[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] , data[count] );
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         count --&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         shiftDown(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; 
&lt;span&gt;82&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取最大堆中的堆顶元素&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    Item getMax(){
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;         assert( count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; data[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; 
&lt;span&gt;89&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;简单堆排序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_06_HEAP_SORT_HEAPSORT_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_06_HEAP_SORT_HEAPSORT_H
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Heap.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 整个堆排序的整体时间复杂度为O(nlogn)&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; template&amp;lt;typename T&amp;gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; heapSort1(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     MaxHeap&amp;lt;T&amp;gt; maxheap = MaxHeap&amp;lt;T&amp;gt;&lt;span&gt;(n);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i ++&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        maxheap.insert(arr[i]);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = n-&lt;span&gt;1&lt;/span&gt; ; i &amp;gt;= &lt;span&gt;0&lt;/span&gt; ; i--&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         arr[i] =&lt;span&gt; maxheap.extractMax();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; heapSort2, 借助我们的heapify过程创建堆
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 实践复杂度为O(nlogn)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; template&amp;lt;typename T&amp;gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; heapSort2(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     MaxHeap&amp;lt;T&amp;gt; maxheap = MaxHeap&amp;lt;T&amp;gt;&lt;span&gt;(arr,n);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = n-&lt;span&gt;1&lt;/span&gt; ; i &amp;gt;= &lt;span&gt;0&lt;/span&gt; ; i--&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         arr[i] =&lt;span&gt; maxheap.extractMax();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;插入排序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_06_HEAP_SORT_INSERTIONSORT_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_06_HEAP_SORT_INSERTIONSORT_H
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; template&amp;lt;typename T&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertionSort(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt; ; i &amp;lt; n ; i ++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         T e =&lt;span&gt; arr[i];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (j = i; j &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; arr[j-&lt;span&gt;1&lt;/span&gt;] &amp;gt; e; j--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             arr[j] = arr[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         arr[j] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对arr[l...r]范围的数组进行插入排序&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; template&amp;lt;typename T&amp;gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertionSort(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = l+&lt;span&gt;1&lt;/span&gt; ; i &amp;lt;= r ; i ++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         T e =&lt;span&gt; arr[i];
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (j = i; j &amp;gt; l &amp;amp;&amp;amp; arr[j-&lt;span&gt;1&lt;/span&gt;] &amp;gt; e; j--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             arr[j] = arr[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         arr[j] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;归并排序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_06_HEAP_SORT_MERGESORT_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_06_HEAP_SORT_MERGESORT_H
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InsertionSort.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将arr[l...mid]和arr[mid+1...r]两部分进行归并
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其中aux为完成merge过程所需要的辅助空间&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; template&amp;lt;typename  T&amp;gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __merge(T arr[], T aux[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; mid, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于aux的大小和arr一样, 所以我们也不需要处理aux索引的偏移量
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进一步节省了计算量:)&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = l ; i &amp;lt;= r; i ++&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         aux[i] =&lt;span&gt; arr[i];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = l, j = mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; k = l ; k &amp;lt;= r; k ++&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;( i &amp;gt; mid ){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果左半部分元素已经全部处理完毕&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             arr[k] = aux[j]; j ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( j &amp;gt; r ){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果右半部分元素已经全部处理完毕&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             arr[k] = aux[i]; i ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( aux[i] &amp;lt; aux[j] ) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左半部分所指元素 &amp;lt; 右半部分所指元素&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             arr[k] = aux[i]; i ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;{  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左半部分所指元素 &amp;gt;= 右半部分所指元素&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             arr[k] = aux[j]; j ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用优化的归并排序算法, 对arr[l...r]的范围进行排序
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其中aux为完成merge过程所需要的辅助空间&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; template&amp;lt;typename T&amp;gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __mergeSort(T arr[], T aux[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于小规模数组, 使用插入排序&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( r - l &amp;lt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        insertionSort(arr, l, r);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; mid = (l+r)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    __mergeSort(arr, aux, l, mid);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     __mergeSort(arr, aux, mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, r);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于arr[mid] &amp;lt;= arr[mid+1]的情况,不进行merge
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( arr[mid] &amp;gt; arr[mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] )
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        __merge(arr, aux, l, mid, r);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt; template&amp;lt;typename T&amp;gt;
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mergeSort(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在 mergeSort中, 我们一次性申请aux空间,
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并将这个辅助空间以参数形式传递给完成归并排序的各个子函数&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;     T *aux = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; T[n];
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; 
&lt;span&gt;70&lt;/span&gt;     __mergeSort( arr , aux, &lt;span&gt;0&lt;/span&gt; , n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;[] aux;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用C++, new出来的空间不要忘记释放掉:)&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;单路快排：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_06_HEAP_SORT_QUICKSORT_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_06_HEAP_SORT_QUICKSORT_H
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;ctime&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InsertionSort.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对arr[l...r]部分进行partition操作
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回p, 使得arr[l...p-1] &amp;lt; arr[p] ; arr[p+1...r] &amp;gt; arr[p]&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; template &amp;lt;typename T&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _partition(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     swap( arr[l] , arr[rand()%(r-l+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;l] );
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     T v =&lt;span&gt; arr[l];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; l;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = l + &lt;span&gt;1&lt;/span&gt; ; i &amp;lt;= r ; i ++&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;( arr[i] &amp;lt;&lt;span&gt; v ){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             j ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            swap( arr[j] , arr[i] );
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    swap( arr[l] , arr[j]);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对arr[l...r]部分进行快速排序&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; template &amp;lt;typename T&amp;gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; _quickSort(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于小规模数组, 使用插入排序进行优化&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( r - l &amp;lt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        insertionSort(arr,l,r);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; p =&lt;span&gt; _partition(arr, l, r);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     _quickSort(arr, l, p-&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     _quickSort(arr, p+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, r);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; template &amp;lt;typename T&amp;gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; quickSort(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    srand(time(NULL));
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     _quickSort(arr, &lt;span&gt;0&lt;/span&gt;, n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;双路快排：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_06_HEAP_SORT_QUICKSORT2WAYS_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_06_HEAP_SORT_QUICKSORT2WAYS_H
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InsertionSort.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双路快速排序的partition
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回p, 使得arr[l...p-1] &amp;lt; arr[p] ; arr[p+1...r] &amp;gt; arr[p]&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; template &amp;lt;typename T&amp;gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _partition2(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     swap( arr[l] , arr[rand()%(r-l+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;l] );
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     T v =&lt;span&gt; arr[l];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; arr[l+1...i) &amp;lt;= v; arr(j...r] &amp;gt;= v&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = l+&lt;span&gt;1&lt;/span&gt;, j =&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;( &lt;span&gt;true&lt;/span&gt;&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意这里的边界, arr[i] &amp;lt; v, 不能是arr[i] &amp;lt;= v
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 思考一下为什么?&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;( i &amp;lt;= r &amp;amp;&amp;amp; arr[i] &amp;lt;&lt;span&gt; v )
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             i ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意这里的边界, arr[j] &amp;gt; v, 不能是arr[j] &amp;gt;= v
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 思考一下为什么?&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;( j &amp;gt;= l+&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; arr[j] &amp;gt;&lt;span&gt; v )
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             j --&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 大家可以参考: &lt;/span&gt;&lt;span&gt;http://coding.imooc.com/learn/questiondetail/4920.html&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;( i &amp;gt;&lt;span&gt; j )
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        swap( arr[i] , arr[j] );
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         i ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         j --&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    swap( arr[l] , arr[j]);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对arr[l...r]部分进行快速排序&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; template &amp;lt;typename T&amp;gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; _quickSort2Ways(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于小规模数组, 使用插入排序进行优化&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( r - l &amp;lt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        insertionSort(arr,l,r);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用双路快速排序的partition&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; p =&lt;span&gt; _partition2(arr, l, r);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     _quickSort2Ways(arr, l, p-&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     _quickSort2Ways(arr, p+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, r);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; template &amp;lt;typename T&amp;gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; quickSort2Ways(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;    srand(time(NULL));
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     _quickSort2Ways(arr, &lt;span&gt;0&lt;/span&gt;, n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三路快排：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_06_HEAP_SORT_QUICKSORT3WAYS_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_06_HEAP_SORT_QUICKSORT3WAYS_H
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InsertionSort.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归的三路快速排序算法&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; template &amp;lt;typename T&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __quickSort3Ways(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于小规模数组, 使用插入排序进行优化&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( r - l &amp;lt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        insertionSort(arr,l,r);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     swap( arr[l], arr[rand()%(r-l+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;l ] );
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     T v =&lt;span&gt; arr[l];
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; lt = l;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; arr[l+1...lt] &amp;lt; v&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; gt = r + &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; arr[gt...r] &amp;gt; v&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = l+&lt;span&gt;1&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; arr[lt+1...i) == v&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;( i &amp;lt;&lt;span&gt; gt ){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;( arr[i] &amp;lt;&lt;span&gt; v ){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             swap( arr[i], arr[lt+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             i ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             lt ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( arr[i] &amp;gt;&lt;span&gt; v ){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             swap( arr[i], arr[gt-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             gt --&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;{ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; arr[i] == v&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             i ++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    swap( arr[l] , arr[lt] );
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     __quickSort3Ways(arr, l, lt-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    __quickSort3Ways(arr, gt, r);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; template &amp;lt;typename T&amp;gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; quickSort3Ways(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    srand(time(NULL));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     __quickSort3Ways( arr, &lt;span&gt;0&lt;/span&gt;, n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试用例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_06_HEAP_SORT_SORTTESTHELPER_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_06_HEAP_SORT_SORTTESTHELPER_H
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;ctime&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;cassert&amp;gt;
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SortTestHelper {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; *generateRandomArray(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; range_l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; range_r) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; *arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        srand(time(NULL));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             arr[i] = rand() % (range_r - range_l + &lt;span&gt;1&lt;/span&gt;) +&lt;span&gt; range_l;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个近乎有序的数组
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先生成一个含有[0...n-1]的完全有序数组, 之后随机交换swapTimes对数据
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; swapTimes定义了数组的无序程度&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; *generateNearlyOrderedArray(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; swapTimes){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; *arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i ++&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             arr[i] =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        srand(time(NULL));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; swapTimes ; i ++&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; posx = rand()%&lt;span&gt;n;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; posy = rand()%&lt;span&gt;n;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            swap( arr[posx] , arr[posy] );
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拷贝整型数组a中的所有元素到一个新的数组, 并返回新的数组&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; *copyIntArray(&lt;span&gt;int&lt;/span&gt; a[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; *arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;* 在VS中, copy函数被认为是不安全的, 请大家手动写一遍for循环:)&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         copy(a, a+&lt;span&gt;n, arr);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印arr数组的所有内容&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     template&amp;lt;typename T&amp;gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; printArray(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         cout &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断arr数组是否有序&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     template&amp;lt;typename T&amp;gt;
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isSorted(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (arr[i] &amp;gt; arr[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将算法的运行时间打印在控制台上&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;     template&amp;lt;typename T&amp;gt;
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; testSort(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &amp;amp;sortName, &lt;span&gt;void&lt;/span&gt; (*sort)(T[], &lt;span&gt;int&lt;/span&gt;), T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;         clock_t startTime =&lt;span&gt; clock();
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        sort(arr, n);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         clock_t endTime =&lt;span&gt; clock();
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         cout &amp;lt;&amp;lt; sortName &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;double&lt;/span&gt;(endTime - startTime) / CLOCKS_PER_SEC &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        assert(isSorted(arr, n));
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将算法的运行时间以double类型返回, 单位为秒(s)&lt;/span&gt;
&lt;span&gt;85&lt;/span&gt;     template&amp;lt;typename T&amp;gt;
&lt;span&gt;86&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt; testSort(&lt;span&gt;void&lt;/span&gt; (*sort)(T[], &lt;span&gt;int&lt;/span&gt;), T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; 
&lt;span&gt;88&lt;/span&gt;         clock_t startTime =&lt;span&gt; clock();
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;        sort(arr, n);
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;         clock_t endTime =&lt;span&gt; clock();
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; 
&lt;span&gt;92&lt;/span&gt; &lt;span&gt;        assert(isSorted(arr, n));
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; 
&lt;span&gt;94&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;(endTime - startTime) /&lt;span&gt; CLOCKS_PER_SEC;
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;96&lt;/span&gt; 
&lt;span&gt;97&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;98&lt;/span&gt; 
&lt;span&gt;99&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201812/1398504-20181204220753863-1839021632.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;平均时间复杂度&lt;/td&gt;
&lt;td&gt;是否是原地排序&lt;/td&gt;
&lt;td&gt;需要额外空间&lt;/td&gt;
&lt;td&gt;稳定排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;插入排序&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;归并排序&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;快速排序&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;O(logn)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;堆排序&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;稳定性解释：排序后的元素相同元素的顺序依然是排序之前的顺序。&lt;/p&gt;
&lt;p&gt; 堆排序的最坏时间复杂度为O(N*logN)，其平均性能较接近于最坏性能。由于初始建堆所需比较的次数较多，所以堆排序不适合记录数较少的文件，其空间复杂度是O(1)，它是一种不稳定的排序算法.&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 15:19:00 +0000</pubDate>
<dc:creator>Tom-shushu</dc:creator>
<og:description>我们通常所说的堆是指二叉堆，二叉堆又称完全二叉树或者叫近似完全二叉树。二叉堆又分为最大堆和最小堆。 堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tom-shushu/p/10067720.html</dc:identifier>
</item>
<item>
<title>AutoCAD 凸度（bulge）的概念及使用WPF函数画图 - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/autocad_bulge.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/autocad_bulge.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;  凸度（bulge）是AutoCAD 中一个非常重要的概念，凸度控制着两点之间弧度大小，弧度的方向。各种复杂的图像有可能就是成百上千的弧线组成的。从AutoCAD中导出的数据也有该值，一般的形式为两个点坐标、一个凸度值。所以理解凸度的概念是处理AutoCAD 文件重要的前提。本文会简要介绍一下凸度的概念，同时会给出如何根据点坐标和凸度划线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;凸度演示程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208212055007-1826644492.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1 凸度的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;凸度有两个作用控制顶点弧度的大小和弧度的方向。如果通过两个坐标点画弧，会有无数种可能性，所以必须引入第三个参数，来确定经过这两点的唯一弧线，这个参数就是凸度。&lt;/p&gt;
&lt;p&gt;凸度反应了两点之间对应弧度的大小，它的具体值为这段弧所包含角度的&lt;span lang=&quot;en-us&quot;&gt;1/4角度的正切值。两点对应的弧度最大值为无限接近360度，凸度对应的值为接近90度的正切值，所以凸度最大值为无穷大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208205538306-904323122.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208210624300-1124327694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细观察上图，图B的弧度大于图A的弧度，但是图B的半径小于图A。&lt;/p&gt;
&lt;p&gt;为什么引入凸度值就能唯一确定弧线了？当凸度确定了，其实弧度对应的半径就确定了。考察一下图C，红线标识的部分为一个等腰三角形，等腰三角形底边长度和顶点角度确定了，就能唯一确定一个三角形大小（属于初中几何知识）。等腰三角形的两个腰长度就是圆的半径。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2 根据凸度计算及画图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208211307983-685455345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同的画图函数需要的参数也不同，我这里根据具体的画图函数来讲解，如何画图。&lt;/p&gt;
&lt;p&gt;WPF绘图上下文类为DrawingContext，这个类有一个绘图函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawGeometry(Brush brush, Pen pen, Geometry geometry);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数很简单，但是这个函数可以画任意图形；因为Geometry 类功能太强大了，这个类可以描述任意几何形状。看一下如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;void&lt;/span&gt; AddArc(PathGeometry pathGeometry, System.Windows.Point point1, System.Windows.Point point2,  &lt;span&gt;double&lt;/span&gt; bulge, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; radius)
        {
            PathFigure pathFigure &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PathFigure();
            pathFigure.StartPoint &lt;/span&gt;= point1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;起点&lt;/span&gt;
&lt;span&gt;
            ArcSegment arcSegment &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArcSegment();
            arcSegment.Point &lt;/span&gt;= point2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;终点
      
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;半径&lt;/span&gt;
            arcSegment.Size = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Size(radius, radius);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应的角度&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; radian = Math.Atan(bulge) * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; angle = radian * &lt;span&gt;180&lt;/span&gt; /&lt;span&gt; Math.PI;
            arcSegment.RotationAngle &lt;/span&gt;=&lt;span&gt;Math.Abs(angle); 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弧度的方向 顺时针还是逆时针&lt;/span&gt;
            arcSegment.SweepDirection = bulge&amp;gt;&lt;span&gt;0&lt;/span&gt;?&lt;span&gt; SweepDirection.Clockwise:SweepDirection.Counterclockwise;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否大于180度&lt;/span&gt;
            arcSegment.IsLargeArc = Math.Abs(bulge) &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            pathFigure.Segments.Add(arcSegment);

            pathGeometry.Figures.Add(pathFigure);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上述代码根据两点、凸度、圆半径来实现画图。（半径是根据前三个计算出来的，后面会讲该算法）&lt;/p&gt;
&lt;p&gt;一个&lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.media.pathgeometry?view=netframework-4.7.2&quot; data-linktype=&quot;relative-path&quot;&gt;PathGeometry&lt;/a&gt;由一个或多个图形暨PathFigure组成。PathFigure 就是一系列封闭或不封闭的线段或弧线组成。ArcSegment 代表一个弧线，将其加入到PathFigure，再将PathFigure加入到Geometry ，这样就可以根据DrawGeometry画出弧线了。函数有注释，非常容易理解。&lt;/p&gt;
&lt;p&gt;ArcSegment 还有一个参数就是圆的半径。其实根据两点、’凸度就可推导出半径，不知道为什么ArcSegment 不替我们计算出来。下面讲一下如何计算半径。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3 根据凸度计算半径&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; CalBulgeRadius(System.Windows.Point point1, System.Windows.Point point2, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; bulge)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算顶点角度&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; cicleAngle = Math.Atan(bulge) * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两点之间的距离&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; pointLen =&lt;span&gt; ImageHelper.CalPointLen(point1, point2);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据正玄值反推&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; radius = (pointLen / &lt;span&gt;2&lt;/span&gt;) / Math.Sin(cicleAngle / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.Abs(radius);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208215051532-1733350881.png&quot; alt=&quot;&quot;/&gt;看左图，可知：顶点对应的角度的一半的正玄值就是 两点之间的长度除以半径。根据这一点就可以算出半径。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3 计算圆点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上述函数虽然可以画出圆弧，但是我们还是不知道圆心坐标。这里将一下如何推导出圆心坐标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208220438277-509831970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里有一个概念就是旋转，将求解圆心坐标分为两个步骤。第一步在两点之间取一点（点3），该点到点1的长度为半径；第二步，将此点旋转一定角度，就得到圆心坐标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;求点3：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两点之间的距离&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; pointLen =&lt;span&gt; ImageHelper.CalPointLen(point1, point2);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;半径与两点之间距离的比值&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; lenRate = radius /&lt;span&gt; pointLen;
            System.Windows.Point midPoint &lt;/span&gt;=&lt;span&gt; ImageHelper.GetMidPoint(point1, point2, lenRate);
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; System.Windows.Point GetMidPoint(System.Windows.Point pt1, System.Windows.Point pt2, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; lenRate)
        {
            Debug.Assert(lenRate&lt;/span&gt;&amp;gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lenRate == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pt2;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lenRate == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pt1;

            System.Windows.Point result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Point();
            result.X &lt;/span&gt;= pt1.X + lenRate * (pt2.X -&lt;span&gt; pt1.X);
            result.Y &lt;/span&gt;= pt1.Y + lenRate * (pt2.Y -&lt;span&gt; pt1.Y);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208221453675-1397661121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据几何知识，可以得知：半径与两点之间的比率与点3的X坐标与两点的X坐标比率一样，这样就能求出X坐标。同理，可以求出Y坐标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;旋转：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点3以点1位圆心，旋转一定角度，点3就落在圆心上了。旋转的角度不难计算，顶点角度已知，又是等腰三角形，所以三角形的底角很容易算出。&lt;/p&gt;
&lt;p&gt;旋转计算涉及二维向量运算，不过.NET为我们提供了类Matrix。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; System.Drawing.Point RotationAt(System.Drawing.Point pointMove, System.Drawing.Point removeAt, 
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; rotateAngle, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; clockwise)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rotateAngle == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pointMove;

            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (matrix)
            {
                matrix.Reset();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置旋转的角度&lt;/span&gt;
                matrix.Rotate((&lt;span&gt;float&lt;/span&gt;)(clockwise ? rotateAngle : -&lt;span&gt;rotateAngle));

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对于removeAt旋转&lt;/span&gt;
                System.Drawing.Point pt2 = &lt;span&gt;new&lt;/span&gt; System.Drawing.Point(pointMove.X - removeAt.X, pointMove.Y -&lt;span&gt; removeAt.Y);
                System.Drawing.Point[] pts &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; System.Drawing.Point[] { &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Drawing.Point(pt2.X, pt2.Y) };
                matrix.TransformPoints(pts);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再变换到圆点位置&lt;/span&gt;
                System.Drawing.Point result = &lt;span&gt;new&lt;/span&gt; System.Drawing.Point(pts[&lt;span&gt;0&lt;/span&gt;].X + removeAt.X, pts[&lt;span&gt;0&lt;/span&gt;].Y +&lt;span&gt; removeAt.Y);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 后记：&lt;/strong&gt;在二维坐标上画图，需要有一定的几何基础和空间想象能力。初始接触这类编程，还是有一定难度的。就需要我们补充一些几何知识，同时多思考，总有一天会感觉豁然开朗。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 14:37:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 凸度（bulge）是AutoCAD 中一个非常重要的概念，凸度控制着两点之间弧度大小，弧度的方向。各种复杂的图像有可能就是成百上千的弧线组成的。从AutoCAD中导出的数据也有该值，一般的形式为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/autocad_bulge.html</dc:identifier>
</item>
<item>
<title>python中的tcp - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-tcp-learn.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-tcp-learn.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;tcp简介&quot;&gt;TCP简介&lt;/h2&gt;
&lt;h3 id=&quot;tcp介绍&quot;&gt;TCP介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）&lt;/strong&gt;是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。&lt;/p&gt;
&lt;p&gt;TCP通信需要经过&lt;strong&gt;创建连接、数据传送、终止连接&lt;/strong&gt;三个步骤。&lt;/p&gt;
&lt;p&gt;TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，&quot;打电话&quot;&quot;&lt;/p&gt;
&lt;h3 id=&quot;tcp特点&quot;&gt;TCP特点&lt;/h3&gt;
&lt;h4 id=&quot;面向连接&quot;&gt;1. 面向连接&lt;/h4&gt;
&lt;p&gt;通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。&lt;/p&gt;
&lt;p&gt;双方间的数据传输都可以通过这一个连接进行。&lt;/p&gt;
&lt;p&gt;完成数据交换后，双方必须断开此连接，以释放系统资源。&lt;/p&gt;
&lt;p&gt;这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。&lt;/p&gt;
&lt;h4 id=&quot;可靠传输&quot;&gt;2. 可靠传输&lt;/h4&gt;
&lt;p&gt;1）&lt;strong&gt;TCP采用发送应答机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;超时重传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。&lt;/p&gt;
&lt;p&gt;TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;错误校验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。&lt;/p&gt;
&lt;p&gt;4) &lt;strong&gt;流量控制和阻塞管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流量控制用来避免主机发送得过快而使接收方来不及完全收下。&lt;/p&gt;
&lt;h3 id=&quot;tcp与udp的不同点&quot;&gt;TCP与UDP的不同点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;面向连接（确认有创建三方交握，连接已创建才作传输。）&lt;/li&gt;
&lt;li&gt;有序数据传输&lt;/li&gt;
&lt;li&gt;重发丢失的数据包&lt;/li&gt;
&lt;li&gt;舍弃重复的数据包&lt;/li&gt;
&lt;li&gt;无差错的数据传输&lt;/li&gt;
&lt;li&gt;阻塞/流量控制&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;udp通信模型&quot;&gt;udp通信模型&lt;/h3&gt;
&lt;p&gt;udp通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，&quot;写信&quot;&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208132247209-1884260035.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tcp通信模型&quot;&gt;TCP通信模型&lt;/h3&gt;
&lt;p&gt;udp通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，&quot;打电话&quot;&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208132327134-1165817946.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tcp客户端&quot;&gt;tcp客户端&lt;/h2&gt;
&lt;p&gt;tcp的客户端要比服务器端简单很多，如果说服务器端是需要自己买手机、查手机卡、设置铃声、等待别人打电话流程的话，那么客户端就只需要找一个电话亭，拿起电话拨打即可，流程要少很多&lt;/p&gt;
&lt;p&gt;python创建tcp客户端的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket


def main():
        # 1.创建套接字socket
        tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # 2.连接服务器
        dest_ip = input(&quot;请输入服务器ip：&quot;)
        dest_port = int(input(&quot;请输入服务器port：&quot;))
        dest_addr = (dest_ip, dest_port)
        tcp_socket.connect(dest_addr)

        # 3. 接收/发送数据
        send_data = input(&quot;请输入要发送的数据：&quot;)
        tcp_socket.send(send_data.encode(&quot;utf-8&quot;))    
    
        # 接收服务器发送的数据
        recv_data = tcp_socket.recv(1024)
        print(recv_data.decode(&quot;utf-8&quot;))    

        # 4. 关闭套接字socket
        tcp_socket.close()

if __name__ == &quot;__main__&quot;:

        main()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ubuntu的终端上执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208135059008-1036457250.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在网络调试助手中启动tcp服务器进行交互：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208135212083-1150520552.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tcp服务器&quot;&gt;tcp服务器&lt;/h2&gt;
&lt;p&gt;在程序中，如果想要完成一个tcp服务器的功能，需要的流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;socket创建一个套接字&lt;/li&gt;
&lt;li&gt;bind绑定ip和port&lt;/li&gt;
&lt;li&gt;listen使套接字变为可以被动链接&lt;/li&gt;
&lt;li&gt;accept等待客户端的链接&lt;/li&gt;
&lt;li&gt;recv/send接收发送数据&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket


def main():
        # 1.创建套接字
        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
        # 2.绑定端口
        addr = (&quot;&quot;, 8866)
        tcp_server_socket.bind(addr)

        # 3.监听链接
        tcp_server_socket.listen(128)

        # 4.接收别人的连接
        # client_socket用来为这个客户端服务
        client_socket, client_addr = tcp_server_socket.accept() 
    
        # 5.接收对方发送的数据
        recv_data = client_socket.recv(1024)    
        print(&quot;接收到的数据：%s&quot; % recv_data.decode(&quot;utf-8&quot;))
    
        # 6.给对方发送数据
        client_socket.send(&quot;hahaha&quot;.encode(&quot;utf-8&quot;))    

        # 7.关闭套接字 
        client_socket.close()
        tcp_server_socket.close()


if __name__ == &quot;__main__&quot;:
        main()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ubuntu的终端上执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208212901839-1290589772.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在网络调试助手中启动tcp服务器进行交互：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208212925845-1369644616.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tcp注意点&quot;&gt;tcp注意点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器&lt;/li&gt;
&lt;li&gt;tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机&lt;/li&gt;
&lt;li&gt;tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的&lt;/li&gt;
&lt;li&gt;当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信&lt;/li&gt;
&lt;li&gt;当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务&lt;/li&gt;
&lt;li&gt;listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的&lt;/li&gt;
&lt;li&gt;关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。&lt;/li&gt;
&lt;li&gt;关闭accept返回的套接字意味着这个客户端已经服务完毕&lt;/li&gt;
&lt;li&gt;当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 08 Dec 2018 14:23:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] TCP简介 TCP介绍 TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-tcp-learn.html</dc:identifier>
</item>
<item>
<title>我是如何从通信转到Java软件开发工程师的？ - 程序员私房菜</title>
<link>http://www.cnblogs.com/eson15/p/10087931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eson15/p/10087931.html</guid>
<description>&lt;p&gt;我的读者里面有绝大部分都是在校学生，有本科的，也有专科的，我在微信里收到很多读者的提问，大部分问题都跟如何学习编程有关，有换专业自学的、有迷茫不知道如何学习的、有报培训班没啥效果的等等，我能感受到他们的诚意和焦虑，所以我觉得我很有必要写下这篇文章。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 本科的脚踏实地&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;高考之后填志愿，那时候其实我也不懂，就觉得电子信息工程好像还不错，于是就填了。在大学四年，除了学校学了C语言之外，我没有学习任何第二门编程语言，而且C语言也只是初级的水平。我在大学都干了啥？&lt;/p&gt;
&lt;p&gt;我在大一，就决定读研，所以我一直在努力学习，高等数学、线性代数、概率论、大学物理、还有一些数电、模电、信号与系统、通信原理等等专业课。老实说，我非常认真，一部分是因为自己的学习习惯，另一部分也是因为自己要读研，所以我每一步都走的很踏实。在我的同龄人里，执行力和毅力能跟我比的，没几个，这点我不吹牛逼。&lt;/p&gt;
&lt;p&gt;大学没少拿奖学金，最起码可以抵消我四年的学费，单片机也玩了不少，51、52到后面的ARM9都玩过，当时还买了好几块板子，写程序跑，那时候对嵌入式还蛮感兴趣的。&lt;/p&gt;
&lt;p&gt;但是毕业后，我有点后悔。为什么呢？我没怎么学编程啊！除了会写一些简单的C代码，其他编程技能为零。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 研究生的觉悟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;考入同济之后，我的专业是电子与通信工程。从研一开始，我很明确我自己想要什么，研究生也是要上课的，基础课、专业课等等。研究生也有课题，需要看各种论文，需要写论文，其实还是蛮忙的。&lt;/p&gt;
&lt;p&gt;我研究生对自己的唯一要求就是提升自己的编程技能。一开始我在看C++，语法看完了之后，看了一点基于C++的数据结构和算法。我真正开始决定学Java是在研一下学期，当时在eBay跟一些大佬们聊了蛮多，倒不是学到了什么牛逼的技术，而是开拓了自己的视野，开始有了自己的一些想法。&lt;/p&gt;
&lt;p&gt;后来我在实验室里闷头苦学了一年左右，从Java语法基础开始，到集合框架源码（那时候还是基于JDK1.7的）、到网络编程（基础）、到数据结构和算法，学完了这些基础知识后，开始学习Servlet/jsp（现在已经不直接用了）、再到Spring、Struts2、Hibernate（SSH框架，现在企业里用的也不多了）、再到Spring、SpringMVC、Mybatis（SSM框架，这个现在还在用）、再到Java并发基础、再到一些中间件等等，再到后面我开始学习微服务相关的东东，学习Spring Boot，Spring Cloud等等。这期间，我做了4个项目实战。我是如何自学的？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 我是如何自学Java的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果要说自学Java，我觉得我有资格说上几句。我一开始看了一个星期左右的书，然后我把书扔在了一边，看不进去啊！我自认为自己的脑袋瓜还算可以，但是我看不进去。这也是初学者的通病，有好多读者也跟我说：武哥，我书也看了，可是感觉还是不会。我TM也是这么过来的，哈哈。&lt;/p&gt;
&lt;p&gt;所以我当时看了视频，我看的是毕向东的Java视频，现在已经有更加新的视频了。找一个好视频，从头到尾认认真真跟着学一遍，做好笔记，那也是我开始写博客的开始。&lt;/p&gt;
&lt;p&gt;人都有个尿性，如果你做一件事情，一直看不到明显的效果，你就会慢慢懈怠，慢慢怀疑自己到底对不对，适不适合。编程也一样，为什么我不建议初学者上来就抱着别人跟你推荐的所谓的经典书籍去啃？什么《Thinking in Java》、《Effective Java》等等，你啃的了吗？你啃不了是对的，否则你就是神了。你啃不了，你就会放弃。我就很讨厌那些贴吧论坛里一上来就给一些初学者推荐很多经典书籍的人，显得自己很博学很牛逼的样子，其实没啥卵用。&lt;/p&gt;
&lt;p&gt;包括Java并发、SSH、SSM框架、组件等等，我全部看的视频。当然，一些源码我是自己啃的。当你有了基础，上路了，你再去看书，不仅仅就是看懂看不懂的问题了，那是真正的提升。&lt;/p&gt;
&lt;p&gt;但是这些还不够，你学了这些东西不能派上用场。必须要项目实战，网上有很多免费的实战视频，但是我觉得不好，因为那时候我已经有基础了，我知道如何去选择我的学习资源了，我在这还是要强调一点，不要吝啬给自己投资，我当时也买了好几个项目实战视频跟着学习，提升很多实战经验。&lt;/p&gt;
&lt;p&gt;当然了，我这边也有很多优质的视频资源，也许已经大家够用了，不用像我当初那样去花钱了，我那时候自学，就没有遇到像我这样懂得分享的人。所以缺视频资源的读者，可以找我要，我就是单纯的分享，为了帮助更多的朋友。&lt;/p&gt;
&lt;p&gt;但是有很多人坚持不下来。我在文章的开头也说了，在同龄人里，执行力和毅力能和我比的没几个，我也是从小白一步步过来的，花了整整一年左右的时间去自学。我做了好几个项目，我敢说我在学校这一年学到的东西，不比别人在外面工作两年的能力差。所以有很多人觉得工作年限长就牛逼，见识多，但是在我看来，这不一定。&lt;/p&gt;
&lt;p&gt;我曾经好几个月直接睡实验室里，每天除了看论文，完成导师的任务，其他时间全部用来学习，晚上搞到十一二点，否则一年时间不可能学那么多东西，而且我大部分还写成了博客，要知道，写博客是很花时间的。如果你能像我这样坚持，这样严格要求自己，我不相信学不会一个东西。你就算今天学不会，你一个月之后呢？一个月不行，你一年总行了吧？就像马云爸爸说的：今天很残酷，明天更残酷，后天很美好。但是很多人都坚持不过明天，他永远看不到美好。就像我考研一样，没有坚持付出，哪来的结果？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 遇到选择，我如何取舍？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我当初研究生刚毕业，是去了华为，我的岗位就是Java软件开发，结果进去之后做通信了。我就纳闷，我研究生读的是通信，我特地自己自学Java，结果又回到做通信，这就很尴尬了。&lt;/p&gt;
&lt;p&gt;所以后来我还是走了，有些读者问我，你为何放弃华为的高薪？我说自己的兴趣不在通信，我有自己的打算，决定从华为离开的，肯定不是为了钱。最起码，我现在过的比在华为好，我相信以后也会。&lt;/p&gt;
&lt;p&gt;职场遇到选择的时候，我个人觉得还是要结合自己的兴趣，人生最重要的几年可能就是刚毕业那几年，那几年也在绝大程度上决定我们以后从事的行业，所以在做选择的时候，需要结合自己的兴趣，综合各方面因素权衡好。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 总结一下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;自学一门技术，首先要会用，要先建立兴趣，再想着去提升，去内化，否则，你坚持不下去。&lt;/p&gt;
&lt;p&gt;自学一门技术，要有规划，最起码要知道你接下来要学哪些东西，不能走一步看一步。有了规划就得有计划，有了计划，就得有执行。&lt;/p&gt;
&lt;p&gt;学习的过程中，永远不要吝啬投资自己，该花钱就花钱，现在是知识付费时代，像CSDN GitChat达人课、极客时间等，里面一些课程还是挺不错的，还有些培训机构的视频也不错。花钱提升自己，本来就没毛病。&lt;/p&gt;
&lt;p&gt;做任何事，离开了坚持二字，那都是扯淡。如果随随便便就能成功的，就能做好的事情，是个人都可以的话，那你也没有什么竞争力。有句话说的好：小聪明不如傻坚持。&lt;/p&gt;
&lt;p&gt;不懂就要多问，不管我们是什么样的人，不管问谁，不管别人比自己牛逼或者弱，都得放低自己的姿态，虚心一点。如果哪天我们有点影响力了，那么尽量以一个低姿态去多帮助那些初学者，帮助更多的人，因为我们也是那样过来的，比自己牛逼的人，满大街都是。人，不要膨胀，要懂得韬光养晦。&lt;/p&gt;
&lt;p&gt;希望这篇文章能够给那些初学者，或者有自学困惑的人带来一点帮助，也希望我的读者能从我这里获得一些正能量。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 14:13:00 +0000</pubDate>
<dc:creator>程序员私房菜</dc:creator>
<og:description>我的读者里面有绝大部分都是在校学生，有本科的，也有专科的，我在微信里收到很多读者的提问，大部分问题都跟如何学习编程有关，有换专业自学的、有迷茫不知道如何学习的、有报培训班没啥效果的等等，我能感受到他们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eson15/p/10087931.html</dc:identifier>
</item>
<item>
<title>使用PrefView监测.NET程序性能（三）：分组 - wyman25</title>
<link>http://www.cnblogs.com/lwhkdash/p/10040052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwhkdash/p/10040052.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/lwhkdash/p/9969215.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;博客中，我们通过Perfview帮助文件中自带的代码来简单使用了Perfview，了解了基本操作。现在来看看Perfview中的分组操作（Grouping）。分组功能都旨将记录到的各种函数调用堆栈以指定的规则进行分组，帮助你组织和找到更关心的数据。&lt;/p&gt;
&lt;h2&gt;为什么需要分组&lt;/h2&gt;
&lt;p&gt; 在实际使用中，PerfView通常会收集到非常多的函数调用栈数据，包括我们关心的程序的函数调用信息，及一大堆我们不关心的其他函数调用信息，例如windows系统的底层函数。这么多有用没用的条目都列出在列表视图上，令人眼花缭乱。如何将我们不需要的数据分组归纳呢？Perfview提供分组功能。&lt;/p&gt;
&lt;p&gt;分组功能使用类似于正则的匹配功能，将函数全名（一个函数的全名包含了程序集，命名空间，类名和函数名，例如&quot;mscorlib.n!System.DateTime.get_Now()&quot;）进行匹配，并替换成自定义的分组名称。例如，可以对所有在Debug目录下的程序集的函数单独显示，而其他函数则分组成“OTHER”，这样，我们就可以只看见我们程序里的函数调用。其实这就是默认的[Just My App]分组规则的作用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208145601157-630711534.png&quot; alt=&quot;&quot; width=&quot;1015&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;通配符&lt;/h2&gt;
&lt;p&gt;那么，分组功能如何使用呢？&lt;/p&gt;
&lt;p&gt;在使用分组之前，先看看PerfView定义的几个&quot;通配符&quot;:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;* :&lt;/span&gt;匹配任意数量的字符&lt;/p&gt;
&lt;p&gt;%：匹配任意数量的数字和英文字母和点号(&quot;.&quot;)，等于.NET正则中的 [\w\d.]*&lt;/p&gt;
&lt;p&gt;^ ：匹配开头&lt;/p&gt;
&lt;p&gt;|：“或”操作&lt;/p&gt;
&lt;p&gt;{}：代表一个分组，等于.NET正则里的小括号&lt;/p&gt;

&lt;h2&gt;分组规则&lt;/h2&gt;
&lt;p&gt;PerfView中有两种分组操作，分别是 PAT-&amp;gt;GROUP 和 PAT=&amp;gt;GROUP。在这里“PAT”代表需要匹配的模式(Pattern)，“GROUP”代表你自定义的组名。 而这两种分组方式区别就在于中间的“-&amp;gt;”和&quot;=&amp;gt;&quot;，前者表示忽略入口函数，后者则会将入口函数显示在分组中。有时我们希望知道一个分组里的函数最初是由哪个函数开始调用的，这时候就可以使用后者了。除此之外，两种分组方式没有其他不同。&lt;/p&gt;
&lt;p&gt; 我们看看具体的分组规则的使用：&lt;/p&gt;
&lt;p&gt;1. PAT-&amp;gt;GROUP形式&lt;/p&gt;
&lt;p&gt;如上述，PAT-&amp;gt;GROUP形式是简单地将一个函数的全名称中包含&quot;PAT&quot;字眼的条目都分到“GROUP”组中，例如，在不分组的情况下，我们收集到的函数调用数据列表是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208151559531-748658494.png&quot; alt=&quot;&quot; width=&quot;1032&quot; height=&quot;596&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面有我们Tutorial.exe的函数，例如，tutorial!Program.SpinForASecond()和tutorial!Program.RecSpin()，同时也有很多.NET的内部函数，例如 mscorlib.n!System.get_Now()和mscorlib.n!System.TimeSpan.get_TotalSeconds()，等等。假设我们只关心tutorial.exe自身的函数，而不希望被.NET内部函数所干扰，我们则可以设置一个分组规则“mscorlib-&amp;gt;.NET”，这样，所有包含“mscorlib”字眼的方法全名称的条目都会被分组进“.NET”组，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208152321502-1656354194.png&quot; alt=&quot;&quot; width=&quot;1031&quot; height=&quot;485&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是清爽了很多？这样的分组能使我们快速地过滤掉mscorlib有关的函数，只剩下tutorial自己的函数（和一些其他函数，当然如果你愿意，也可以将其他的函数&quot;分组&quot;掉）&lt;/p&gt;

&lt;p&gt;2. {*}=&amp;gt;$1&lt;/p&gt;
&lt;p&gt;该形式的规则意思是： 花括号里匹配到的条目会被分组，而组名正是是花括号里的匹配到的内容，“$1”是一个占位符，对应的是花括号“{}”里的内容。假设有两个函数：tutorial!Program.SpinForASecond()和tutorial!Program.RecSpin()， 而应用的规则是“{tutorial!}-&amp;gt;My APP $1”，则分组后，这两个函数被分进一组，并且组名为“My App tutorial!”&lt;/p&gt;
&lt;p&gt;Perfview还支持同时设置多个规则，例如设置规则为“&lt;span&gt;{tutorial!}-&amp;gt;My APP $1&lt;/span&gt;;&lt;span&gt;{mscorlib.ni!}-&amp;gt;Internal $1&lt;/span&gt;”，这里有两个规则，一个是蓝色部分，另一个是红色部分，中间用分号(;)隔开。如果函数全名中有&quot;tutorial!&quot;的就分进名为“My APP tutorial!”组，而有“mscorlib.ni!”字眼的就分进“Internal mscorlib.ni!”组。&lt;/p&gt;

&lt;p&gt;3.PAT=&amp;gt;GROUP&lt;/p&gt;
&lt;p&gt;最后来看看入口点规则分组(Entry Point Grouping)。前边提到过，“PAT=&amp;gt;GROUP”与“PAT-&amp;gt;GROUP”的不同在于，后者会忽略掉该组的入口函数，意味着你很难知道某个分组里的函数是从哪个函数执行进去的，而前者则会包含入口点函数信息。我们通过图例来看看实际效果。&lt;/p&gt;
&lt;p&gt;下图中，使用“mscorlib-&amp;gt;System Functions”规则来对mscorlib的函数进行分组，组名为“System Functions”,但除非你展开这个分组的明细，查找每个函数调用树，否则你不知道是什么函数调用了这组函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208213730850-599436695.png&quot; alt=&quot;&quot; width=&quot;981&quot; height=&quot;410&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而现在使用“mscorlib=&amp;gt;System Functions”，看看有什么不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208214202774-831136545.png&quot; alt=&quot;&quot; width=&quot;980&quot; height=&quot;460&quot;/&gt;&lt;/p&gt;
&lt;p&gt;System Functions组明确指示了该组的函数的入口点是“mscorlib.ni!System.DateTime.get_Now()”函数，即DateTime.Now导致了这些函数的执行。&lt;/p&gt;

&lt;p&gt;以上便是PerfView的分组功能。但其实这只是分组功能中的一部分。通过规则的搭配可以有更强大的效果。而最全面的说明其实是在PerfView自带的F1帮助文件。这里只作一个抛砖引玉的简要说明。因此如果需要了解更全面的分组技巧，可以去帮助文件里搜索相关主题。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 13:54:00 +0000</pubDate>
<dc:creator>wyman25</dc:creator>
<og:description>在上一篇博客中，我们通过Perfview帮助文件中自带的代码来简单使用了Perfview，了解了基本操作。现在来看看Perfview中的分组操作（Grouping）。分组功能都旨将记录到的各种函数调用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwhkdash/p/10040052.html</dc:identifier>
</item>
<item>
<title>F#周报2018年第49期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10089267.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10089267.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;ML.NET 0.8——Machine Learning for .NET&quot; &quot;.NET Core 3预览 1以及开源Windows桌面框架&quot; &quot;.NET Core 2.2&quot; &quot;尝试C 8.0&quot; &quot;.NET Framework 4.8早期可用编译包3694&quot; &quot;WPF，WinForms和Wi</description>
<pubDate>Sat, 08 Dec 2018 13:51:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10089267.html</dc:identifier>
</item>
<item>
<title>ML.NET 示例：回归之价格预测 - feiyun0112</title>
<link>http://www.cnblogs.com/feiyun0112/p/10089175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feiyun0112/p/10089175.html</guid>
<description>&lt;blockquote readability=&quot;5.3004115226337&quot;&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;准备近期将微软的machinelearning-samples翻译成中文，水平有限，如有错漏，请大家多多指正。&lt;br/&gt;如果有朋友对此感兴趣，可以加入我：&lt;a href=&quot;https://github.com/feiyun0112/machinelearning-samples.zh-cn&quot; class=&quot;uri&quot;&gt;https://github.com/feiyun0112/machinelearning-samples.zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;v0.7&lt;/td&gt;
&lt;td&gt;动态 API&lt;/td&gt;
&lt;td&gt;最新版本&lt;/td&gt;
&lt;td&gt;控制台应用程序&lt;/td&gt;
&lt;td&gt;.csv 文件&lt;/td&gt;
&lt;td&gt;价格预测&lt;/td&gt;
&lt;td&gt;回归&lt;/td&gt;
&lt;td&gt;Sdca 回归&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在这个介绍性示例中，您将看到如何使用&lt;a href=&quot;https://www.microsoft.com/net/learn/apps/machine-learning-and-ai/ml-dotnet&quot;&gt;ML.NET&lt;/a&gt;预测出租车费。在机器学习领域，这种类型的预测被称为&lt;strong&gt;回归&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;这个问题主要集中在预测纽约出租车的行程费用。从表面看，它似乎仅仅取决于行程的距离。但是，由于其他因素（比如额外的乘客或使用信用卡而非现金付款），纽约的出租车供应商收费不同。这种预测可用于出租车供应商向用户和司机提供乘车费用的估计。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们将使用下列输入建立一个ML模型:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;供应商ID&lt;/li&gt;
&lt;li&gt;费率代码&lt;/li&gt;
&lt;li&gt;乘客数量&lt;/li&gt;
&lt;li&gt;出行时间&lt;/li&gt;
&lt;li&gt;出行距离&lt;/li&gt;
&lt;li&gt;支付方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并预测乘车的费用。&lt;/p&gt;
&lt;h2 id=&quot;ml-任务---回归&quot;&gt;ML 任务 - 回归&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;回归&lt;/strong&gt;的广义问题是预测给定参数的某些连续值，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据房间的数量、位置、建造年份等预测房子的价格。&lt;/li&gt;
&lt;li&gt;根据燃油类型和汽车参数预测汽车燃油消耗量。&lt;/li&gt;
&lt;li&gt;预测基于问题属性来修复问题的时间估计。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有这些示例的共同特征是我们想要预测的参数可以取特定范围内的任何数值。 换句话说，这个值用&lt;code&gt;integer&lt;/code&gt;或&lt;code&gt;float&lt;/code&gt;/&lt;code&gt;double&lt;/code&gt;表示，而不是由&lt;code&gt;enum&lt;/code&gt;或&lt;code&gt;boolean&lt;/code&gt;类型表示。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;为了解决这个问题，首先我们将建立一个ML模型。然后，我们将在现有数据的基础上训练模型，评估其有多好，最后我们将使用该模型来预测出租车费。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/feiyun0112/machinelearning-samples.zh-cn/master/samples/csharp/getting-started/shared_content/modelpipeline.png&quot; alt=&quot;建立 -&amp;gt; 训练 -&amp;gt; 评估 -&amp;gt; 使用&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;建立模型&quot;&gt;1. 建立模型&lt;/h3&gt;
&lt;p&gt;建立模型包括：上传数据（使用&lt;code&gt;TextLoader&lt;/code&gt;加载&lt;code&gt;taxi-fare-train.csv&lt;/code&gt;），对数据进行转换，以便ML算法（本例中为“StochasticDualCoordinateAscent”）能够有效地使用它：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//Create ML Context with seed for repeteable/deterministic results
MLContext mlContext = new MLContext(seed: 0);

// STEP 1: Common data loading configuration
TextLoader textLoader = mlContext.Data.TextReader(new TextLoader.Arguments()
                                {
                                    Separator = &quot;,&quot;,
                                    HasHeader = true,
                                    Column = new[]
                                                {
                                                    new TextLoader.Column(&quot;VendorId&quot;, DataKind.Text, 0),
                                                    new TextLoader.Column(&quot;RateCode&quot;, DataKind.Text, 1),
                                                    new TextLoader.Column(&quot;PassengerCount&quot;, DataKind.R4, 2),
                                                    new TextLoader.Column(&quot;TripTime&quot;, DataKind.R4, 3),
                                                    new TextLoader.Column(&quot;TripDistance&quot;, DataKind.R4, 4),
                                                    new TextLoader.Column(&quot;PaymentType&quot;, DataKind.Text, 5),
                                                    new TextLoader.Column(&quot;FareAmount&quot;, DataKind.R4, 6)
                                                }
                                });

IDataView baseTrainingDataView = textLoader.Read(TrainDataPath);
IDataView testDataView = textLoader.Read(TestDataPath);

//Sample code of removing extreme data like &quot;outliers&quot; for FareAmounts higher than $150 and lower than $1 which can be error-data 
var cnt = baseTrainingDataView.GetColumn&amp;lt;float&amp;gt;(mlContext, &quot;FareAmount&quot;).Count();
IDataView trainingDataView = mlContext.Data.FilterByColumn(baseTrainingDataView, &quot;FareAmount&quot;, lowerBound: 1, upperBound: 150);
var cnt2 = trainingDataView.GetColumn&amp;lt;float&amp;gt;(mlContext, &quot;FareAmount&quot;).Count();

// STEP 2: Common data process configuration with pipeline data transformations
var dataProcessPipeline = mlContext.Transforms.CopyColumns(&quot;FareAmount&quot;, &quot;Label&quot;)
                .Append(mlContext.Transforms.Categorical.OneHotEncoding(&quot;VendorId&quot;, &quot;VendorIdEncoded&quot;))
                .Append(mlContext.Transforms.Categorical.OneHotEncoding(&quot;RateCode&quot;, &quot;RateCodeEncoded&quot;))
                .Append(mlContext.Transforms.Categorical.OneHotEncoding(&quot;PaymentType&quot;, &quot;PaymentTypeEncoded&quot;))
                .Append(mlContext.Transforms.Normalize(inputName: &quot;PassengerCount&quot;, mode: NormalizerMode.MeanVariance))
                .Append(mlContext.Transforms.Normalize(inputName: &quot;TripTime&quot;, mode: NormalizerMode.MeanVariance))
                .Append(mlContext.Transforms.Normalize(inputName: &quot;TripDistance&quot;, mode: NormalizerMode.MeanVariance))
                .Append(mlContext.Transforms.Concatenate(&quot;Features&quot;, &quot;VendorIdEncoded&quot;, &quot;RateCodeEncoded&quot;, &quot;PaymentTypeEncoded&quot;, &quot;PassengerCount&quot;, &quot;TripTime&quot;, &quot;TripDistance&quot;));

// STEP 3: Set the training algorithm, then create and config the modelBuilder - Selected Trainer (SDCA 回归 algorithm)                            
var trainer = mlContext.Regression.Trainers.StochasticDualCoordinateAscent(labelColumn: &quot;Label&quot;, featureColumn: &quot;Features&quot;);
var trainingPipeline = dataProcessPipeline.Append(trainer);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;训练模型&quot;&gt;2. 训练模型&lt;/h3&gt;
&lt;p&gt;训练模型是在训练数据（具有已知的费用）上运行所选算法以调整模型参数的过程。 它在&lt;code&gt;Fit（）&lt;/code&gt;API中实现。 要执行训练，我们只需在提供DataView时调用该方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var trainedModel = trainingPipeline.Fit(trainingDataView);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;评估模型&quot;&gt;3. 评估模型&lt;/h3&gt;
&lt;p&gt;我们需要这一步来总结我们的模型对新数据的准确性。 为此，上一步中的模型针对另一个未在训练中使用的数据集运行（&lt;code&gt;taxi-fare-test.csv&lt;/code&gt;）。 此数据集也包含已知的费用。 &lt;code&gt;Regression.Evaluate()&lt;/code&gt;计算已知费用和模型预测的费用之间差异的各种指标。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;IDataView predictions = trainedModel.Transform(testDataView);
var metrics = mlContext.Regression.Evaluate(predictions, label: &quot;Label&quot;, score: &quot;Score&quot;);

Common.ConsoleHelper.PrintRegressionMetrics(trainer.ToString(), metrics);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.5471698113208&quot;&gt;
&lt;p&gt;&lt;em&gt;要了解有关如何理解指标的更多信息，请查看&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/machine-learning/&quot;&gt;ML.NET指南&lt;/a&gt;中的机器学习词汇表或使用任何有关数据科学和机器学习的材料&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您对模型的质量不满意，可以采用多种方法对其进行改进，这些方法将在&lt;em&gt;examples&lt;/em&gt;类别中介绍。&lt;/p&gt;
&lt;blockquote readability=&quot;6.8181818181818&quot;&gt;
&lt;p&gt;&lt;em&gt;请记住，对于这个示例，其质量低于可能达到的水平，因为出于性能目的，数据集的大小已减小。您可以使用原始数据集来显著提高质量（原始数据集在数据集&lt;a href=&quot;http://www.cnblogs.com/datasets/README.md&quot;&gt;README&lt;/a&gt;中引用）。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用模型&quot;&gt;4. 使用模型&lt;/h3&gt;
&lt;p&gt;在训练模型之后，我们可以使用&lt;code&gt;Predict()&lt;/code&gt; API来预测指定行程的费用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//Sample: 
//vendor_id,rate_code,passenger_count,trip_time_in_secs,trip_distance,payment_type,fare_amount
//VTS,1,1,1140,3.75,CRD,15.5

var taxiTripSample = new TaxiTrip()
{
    VendorId = &quot;VTS&quot;,
    RateCode = &quot;1&quot;,
    PassengerCount = 1,
    TripTime = 1140,
    TripDistance = 3.75f,
    PaymentType = &quot;CRD&quot;,
    FareAmount = 0 // To predict. Actual/Observed = 15.5
};

ITransformer trainedModel;
using (var stream = new FileStream(ModelPath, FileMode.Open, FileAccess.Read, FileShare.Read))
{
    trainedModel = mlContext.Model.Load(stream);
}

// Create prediction engine related to the loaded trained model
var predFunction = trainedModel.MakePredictionFunction&amp;lt;TaxiTrip, TaxiTripFarePrediction&amp;gt;(mlContext);

//Score
var resultprediction = predFunction.Predict(taxiTripSample);

Console.WriteLine($&quot;**********************************************************************&quot;);
Console.WriteLine($&quot;Predicted fare: {resultprediction.FareAmount:0.####}, actual fare: 15.5&quot;);
Console.WriteLine($&quot;**********************************************************************&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，您可以用方法&lt;code&gt;PlotRegressionChart()&lt;/code&gt;在图表中展现测试预测的分布情况以及回归的执行方式，如下面的屏幕截图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/feiyun0112/machinelearning-samples.zh-cn/master/samples/csharp/getting-started/Regression_TaxiFarePrediction/images/Sample-Regression-Chart.png&quot; alt=&quot;Regression plot-chart&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 13:37:00 +0000</pubDate>
<dc:creator>feiyun0112</dc:creator>
<og:description>写在前面 准备近期将微软的machinelearning samples翻译成中文，水平有限，如有错漏，请大家多多指正。 如果有朋友对此感兴趣，可以加入我：https://github.com/fei</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feiyun0112/p/10089175.html</dc:identifier>
</item>
<item>
<title>第101次提醒：++ 不是线程安全的 - 疯狂创客圈</title>
<link>http://www.cnblogs.com/crazymakercircle/p/10089113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crazymakercircle/p/10089113.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之 -17【 &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;博客园 总入口&lt;/a&gt; 】&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;源码IDEA工程获取链接&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;Java 聊天室 实战 源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;​ 大家好，我是作者尼恩。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;目前正在组织 疯狂创客圈的几个兄弟，从0开始进行高并发的100级流量（不是用户）聊天器的实战。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在设计客户端之前，发现一个非常重要的基础知识点，没有讲到。这个知识点就是Java并发包。&lt;/p&gt;
&lt;p&gt;由于Java并发包将被频繁使用到，所以不得不停下来，先介绍一下。&lt;/p&gt;
&lt;h2 id=&quot;一道简单线程安全题不知道有多少人答不上来&quot;&gt;一道简单线程安全题，不知道有多少人答不上来&lt;/h2&gt;
&lt;p&gt;尼恩作为技术主管，常常组织组织技术面试，而且往往是第二面。&lt;/p&gt;
&lt;p&gt;某次面试，候选人是从重庆一所211大学毕业了一年的初级Java工程师，暂且简称Y君。&lt;/p&gt;
&lt;p&gt;在尼恩面试前，Y君已经过了第一关，通过了PM同事的技术面试，PM同事甚至还反馈说Y君的继承不错。理论上，Y君的offer已经没有什么悬念了。&lt;/p&gt;
&lt;p&gt;于是，尼恩想前面无数次面试一样，首先开始了多线程方面的问题。&lt;/p&gt;
&lt;p&gt;先上来就是砸出一个古老的面试问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序为什么要用多线程，单线程不是很好吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程有什么意义？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程会带来哪些问题，如何解决？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;++操作是线程安全的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;乖乖，Y君的答案，令人出人意料。&lt;/p&gt;
&lt;p&gt;答曰：“我从来没有用过多线，不是太清楚多线程的意义，也不清楚多线程能带来哪些问题”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乖乖&lt;/strong&gt;，看一看Y君的简历，这个又是一个埋头干活，被增删改查坑害了的小兄弟！&lt;/p&gt;
&lt;p&gt;这已经不是第一个了，我已经记不清楚，有多少面试的兄弟，搞不清楚一这些非常基础的并发编程的知识。&lt;/p&gt;
&lt;p&gt;单体WEB应用的时代，已经离我们远去了。 微服务、异步架构的分布式应用时代，已经全面开启。&lt;/p&gt;
&lt;p&gt;对于那些面试失败的兄弟，为了提升他们的水平，尼恩都会给他提一个善意的建议。让他们去做一个简单的并发自增运算的实验，看看自增运算是否线程安全的。&lt;/p&gt;
&lt;h2 id=&quot;实验并发的自增运算&quot;&gt;实验：并发的自增运算&lt;/h2&gt;
&lt;p&gt;使用10条线程，对一个共享的变量，每条线程自增100万次。看看最终的结果，是不是1000万？&lt;/p&gt;
&lt;p&gt;完成这个小实验，就知道++运算是否是线程安全的了。&lt;/p&gt;
&lt;p&gt;实验代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Created by 尼恩 at 疯狂创客圈
 */

package com.crazymakercircle.operator;

import com.crazymakercircle.util.Print;

/**
 * 不安全的自增 运算
 */
public class NotSafePlus
{
    public static final int MAX_TURN = 1000000;

    static class NotSafeCounter implements Runnable {
        public  int amount = 0;

        public void increase() {
            amount++;
        }

        @Override
        public void run() {
            int turn = 0;
            while (turn &amp;lt; MAX_TURN) {
                ++turn;
                increase();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {

        NotSafeCounter counter=new NotSafeCounter();
        for (int i = 0; i &amp;lt; 10; i++) {
            Thread thread = new Thread(counter);
            thread.start();
        }
        Thread.sleep(2000);
        Print.tcfo(&quot;理论结果：&quot; + MAX_TURN * 10);
        Print.tcfo(&quot;实际结果：&quot; + counter.amount);
        Print.tcfo(&quot;差距是：&quot; + (MAX_TURN * 10 - counter.amount));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输出的结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[main|NotSafePlus:main]：理论结果：10000000

[main|NotSafePlus:main]：实际结果：9264046

[main|NotSafePlus:main]：差距是：735954&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，并发执行后，总计自增1000万次，结果少了70多万次，差距是巨大的，在10%左右。&lt;/p&gt;
&lt;p&gt;当然，这只是一次结果，每一次运行，差距都是不同的。大家可以动手运行体验一下。&lt;/p&gt;
&lt;p&gt;从结果可以看出，自增运算符不是线程安全的。&lt;/p&gt;
&lt;h2 id=&quot;运算的原理&quot;&gt;++ 运算的原理&lt;/h2&gt;
&lt;p&gt;自增运算符，至少包括三个JVM指令&lt;/p&gt;
&lt;p&gt;比如：当amount=100是，有三个线程读同一时间取值，读到的都是100，增加1后结果为101，三个线程都存值到amount的内存，amount的结果是101，而不是103。&lt;/p&gt;
&lt;p&gt;JVM内部，从内存取值，寄存器增加1，存值到内存，这三个操作自身是不可以再分的，这三个操作具备原子性，是线程安全的，也叫原子操作。两个、或者两个以上的原子操作合在一起进行，就不在具备原子性。比如先读后写，那么就有可能在读之后，这个变量被修改过，写入后就出现了数据不一致的情况。&lt;/p&gt;
&lt;h2 id=&quot;java-的原子操作类&quot;&gt;Java 的原子操作类&lt;/h2&gt;
&lt;p&gt;对于每一种基本类型，在java 的并发包中，提供了一组线程安全的原子操作类。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;Integer类型&lt;/strong&gt;，对应的原子操作类是&lt;strong&gt;AtomicInteger&lt;/strong&gt; 类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.util.concurrent.atomic.AtomicInteger&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 AtomicInteger类，实现上面的实验，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.concurrent.atomic.AtomicInteger;

/**
 * 安全的 ++ 运算
 */
public class SafePlus
{
    public static final int MAX_TURN = 1000000;

    static class NotSafeCounter implements Runnable {
        public AtomicInteger amount =
                new AtomicInteger(0);

        public void increase() {
            amount.incrementAndGet();
        }

        @Override
        public void run() {
            int turn = 0;
            while (turn &amp;lt; MAX_TURN) {
                ++turn;
                increase();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {

        NotSafeCounter counter=new NotSafeCounter();
        for (int i = 0; i &amp;lt; 10; i++) {
            Thread thread = new Thread(counter);
            thread.start();
        }
        Thread.sleep(2000);
        Print.tcfo(&quot;理论结果：&quot; + MAX_TURN * 10);
        Print.tcfo(&quot;实际结果：&quot; + counter.amount);
        Print.tcfo(&quot;差距是：&quot; + (MAX_TURN * 10 - counter.amount.get()));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行代码，结果如下；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[main|NotSafePlus:main]：理论结果：10000000

[main|NotSafePlus:main]：实际结果：10000000

[main|NotSafePlus:main]：差距是：0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一次，10条线程，累加1000w次，结果是1000w。&lt;/p&gt;
&lt;p&gt;看起来，如果需要线程安全，需要使用Java并发包中的原子类。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​ 下一篇：Netty 中的Future 回调实现与线程池详解。这个也是一个非常重要的基础篇。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;疯狂创客圈-java-死磕系列&quot;&gt;疯狂创客圈 Java 死磕系列&lt;/h2&gt;
&lt;ul readability=&quot;-0.85082872928177&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Java (Netty) 聊天程序【 亿级流量】实战 开源项目实战&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Netty 源码、原理、JAVA NIO 原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java 面试题 一网打尽&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.37209302325581&quot;&gt;
&lt;p&gt;疯狂创客圈 &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;&lt;strong&gt;【 博客园 总入口 】&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;</description>
<pubDate>Sat, 08 Dec 2018 13:16:00 +0000</pubDate>
<dc:creator>疯狂创客圈</dc:creator>
<og:description>疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之 17【</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crazymakercircle/p/10089113.html</dc:identifier>
</item>
<item>
<title>SpringBoot 整合 WebSocket - Architect剑</title>
<link>http://www.cnblogs.com/yi1036943655/p/10089100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yi1036943655/p/10089100.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;SpringBoot 整合 WebSocket（topic广播）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、什么是WebSocket&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　WebSocket为游览器和服务器提供了双工异步通信的功能，即游览器可以向服务器发送消息，服务器也可以向游览器发送消息。WebSocket需游览器的支持，如IE10、Chrome 13+、Firefox 6+，这对我们现在的游览器来说都不是问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　WebSocket是通过一个socket来实现双工异步通讯能力的。但是直接使用WebSocket（或SockJS:WebSocket协议的模拟，增加了当游览器不支持WebSocket的时候的兼容支持）协议开发程序显得特别繁琐， 我们会使用它的子协议STOMP，它是一个更高级别的协议，STOMP协议使用一个基于帧的格式来定义消息，与HTTP的request和reponse类似（具有类似于@RequestMapping的@MassageMapping）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、什么是&lt;span&gt;&lt;span&gt;STOMP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　STOMP，Streaming Text Orientated Message Protocol，是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。&lt;br/&gt;它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理(Broker)进行交互，类似于OpenWire(一种二进制协议)。由于其设计简单，很容易开发客户端，因此在多种语言和多种平台上得到广泛应用。其中最流行的STOMP消息代理是Apache ActiveMQ。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　STOMP协议工作于TCP协议之上，使用了下列命令：&lt;br/&gt;    　　1)、SEND 发送&lt;br/&gt;    　　&lt;span&gt;&lt;span&gt;2)、&lt;/span&gt;&lt;/span&gt;SUBSCRIBE 订阅&lt;br/&gt;    　　&lt;span&gt;&lt;span&gt;3)、&lt;/span&gt;&lt;/span&gt;UNSUBSCRIBE 退订&lt;br/&gt;    　　&lt;span&gt;&lt;span&gt;4)、&lt;/span&gt;&lt;/span&gt;BEGIN 开始&lt;br/&gt;    　　&lt;span&gt;&lt;span&gt;5)、&lt;/span&gt;&lt;/span&gt;COMMIT 提交&lt;br/&gt;    　　&lt;span&gt;&lt;span&gt;6)、&lt;/span&gt;&lt;/span&gt;ABORT 取消&lt;br/&gt;    　　&lt;span&gt;&lt;span&gt;7)、&lt;/span&gt;&lt;/span&gt;ACK 确认&lt;br/&gt;    　　&lt;span&gt;&lt;span&gt;8)、&lt;/span&gt;&lt;/span&gt;DISCONNECT 断开&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、为什么需要&lt;span&gt;&lt;strong&gt;&lt;span&gt;WebSocket&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。&lt;/span&gt;&lt;span&gt;如果想持续从服务的获取消息，则只能使用轮询或建立长连接的方法来实现，但是这样或浪费很多不必要的资源。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;而webSocket则解决了这个问题，通信可由双方发起，只需要建立一次连接，服务的端就可以持续从服务端获得消息。主要用来做消息通知，消息推送等模块&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、SpringBoot使用 &lt;strong&gt;STOMP 消息步骤&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;1)、添加pom文件依赖&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　2)、java方式配置websocket stomp&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　3)、消息实体类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　4)、书写控制层&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　5)、书写页面&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5、P&lt;strong&gt;om 依赖&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-thymeleaf&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-websocket&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6、&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;java方式配置websocket stomp&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.example.demo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

    /**
     * 配置链接端点
     * @param registry
     */
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry){
        registry.addEndpoint(&quot;/endpointWisely&quot;).withSockJS();
    }

    /**
     * 配置消息代理
     * @param registry
     */
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry){
        registry.enableSimpleBroker(&quot;/topic&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7、&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;消息实体类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo.PoJo;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 消息接受
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WiselyMessage {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo.PoJo;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 消息返回
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WiselyResponse {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String responseMessage;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WiselyResponse(String responseMessage){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.responseMessage =&lt;span&gt; responseMessage;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getResponseMessage(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseMessage;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8、&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;书写控制层&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.demo.PoJo.WiselyMessage;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.demo.PoJo.WiselyResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.messaging.handler.annotation.MessageMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.messaging.handler.annotation.SendTo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.messaging.simp.SimpMessagingTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.security.Principal;

@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WsController {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * MessageMapping 类似于 RequestMapping
     * SendTo 订阅地址 类似于 订阅一个URL （我的理解就是 调用了这个方法 在返回的时候会给订阅该url的地址发送数据）
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; message
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @MessageMapping(&lt;/span&gt;&quot;/welcome&quot;&lt;span&gt;)
    @SendTo(&lt;/span&gt;&quot;/topic/getResponse&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; WiselyResponse say(WiselyMessage message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; WiselyResponse(&quot;Welcome,&quot; + message.getName() + &quot;!&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9、&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;书写页面&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns:th&lt;/span&gt;&lt;span&gt;=&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Spring Boot+WebSocket+广播式&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;onload&lt;/span&gt;&lt;span&gt;=&quot;disconnect()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;noscript&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2 &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color: #ff0000&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;貌似你的浏览器不支持websocket&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;noscript&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;connect&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;connect();&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;连接&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;disconnect&quot;&lt;/span&gt;&lt;span&gt; disabled&lt;/span&gt;&lt;span&gt;=&quot;disabled&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;disconnect();&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;断开连接&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;conversationDiv&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;输入你的名字&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;sendName&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;sendName();&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;发送&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;response&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;th:src&lt;/span&gt;&lt;span&gt;=&quot;@{sockjs.min.js}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;th:src&lt;/span&gt;&lt;span&gt;=&quot;@{stomp.min.js}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;th:src&lt;/span&gt;&lt;span&gt;=&quot;@{jquery.js}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; stompClient &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setConnected(connected) {
        document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;connect&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).disabled &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connected;
        document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;disconnect&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).disabled &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;connected;
        document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conversationDiv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).style.visibility &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connected &lt;/span&gt;&lt;span&gt;?&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;visible&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hidden&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#response&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).html();
    }
    
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; connect() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; socket &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SockJS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/endpointWisely&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;        stompClient &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Stomp.over(socket);
        stompClient.connect({}, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(frame) {
            setConnected(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Connected: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; frame);
            stompClient.subscribe(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/topic/getResponse&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(respnose){ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;                showResponse(JSON.parse(respnose.body).responseMessage);
            });
        });
    }
    
    
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; disconnect() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stompClient &lt;/span&gt;&lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            stompClient.disconnect();
        }
        setConnected(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Disconnected&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sendName() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val();
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;        stompClient.send(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/welcome&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {}, JSON.stringify({ &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: name }));
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showResponse(message) {
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; response &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
          response.html(message);
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10、客户端发送和接收消息图解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908364/201812/908364-20181208211231776-579618732.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 08 Dec 2018 13:13:00 +0000</pubDate>
<dc:creator>Architect剑</dc:creator>
<og:description>SpringBoot 整合 WebSocket（topic广播） 1、什么是WebSocket WebSocket为游览器和服务器提供了双工异步通信的功能，即游览器可以向服务器发送消息，服务器也可以向</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yi1036943655/p/10089100.html</dc:identifier>
</item>
</channel>
</rss>