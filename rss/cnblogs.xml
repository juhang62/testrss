<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>LR静态存储/动态存储/指针变量脚本说明 - S-Gavin</title>
<link>http://www.cnblogs.com/zwh-Seeking/p/12030642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwh-Seeking/p/12030642.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;在一次教程学习中，看到该知识点并记录了下来，希望与大家共同探讨学习。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、静态存储与动态存储&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　静态存储变量通常是在变量定义时就分定存储单元并一直保持不变， 直至整个程序结束。动态存储变量是在程序执行过程中，使用它时才分配存储单元，使用完毕立即释放。动态存储变量最典型的例子是函教的形式参数，在函数定义时并不给形参分配存储单元，只是在函数被调用时，才予以分配，调用函数完毕立即释放，如果一个函数被多次调用 ，则反复地分配和释放形参变量的存储单元。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从以上分析可知，静态存储变量是一直存在的 ，而动态存储变是则时而存在时而消失。 我们又把这种由于变量存储方式不同而产生的特性称变量的生存期。( 见以下脚本 )&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;Action()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行函数auto_static 5次&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;5&lt;/span&gt;;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        auto_static();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态动态变量测试函数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; auto_static(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; var_auto=&lt;span&gt;0&lt;/span&gt;;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态变量，每次调用都重新初始化&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; var_static=&lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态局部变量：只初始化1次        &lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         lr_output_message(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var_auto=%d,var_static=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,var_auto,var_static); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出两个变量的值&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         var_auto++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         var_static++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家可以想想，两个变量输出的都是什么值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cc86ac7c-d51d-429c-8976-7fcaf30afb30')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_cc86ac7c-d51d-429c-8976-7fcaf30afb30&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cc86ac7c-d51d-429c-8976-7fcaf30afb30&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cc86ac7c-d51d-429c-8976-7fcaf30afb30',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cc86ac7c-d51d-429c-8976-7fcaf30afb30&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Action.c(&lt;span&gt;38&lt;/span&gt;): var_auto=&lt;span&gt;0&lt;/span&gt;,var_static=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; Action.c(&lt;span&gt;38&lt;/span&gt;): var_auto=&lt;span&gt;0&lt;/span&gt;,var_static=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; Action.c(&lt;span&gt;38&lt;/span&gt;): var_auto=&lt;span&gt;0&lt;/span&gt;,var_static=&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; Action.c(&lt;span&gt;38&lt;/span&gt;): var_auto=&lt;span&gt;0&lt;/span&gt;,var_static=&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; Action.c(&lt;span&gt;38&lt;/span&gt;): var_auto=&lt;span&gt;0&lt;/span&gt;,var_static=&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、指针&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　指针是一个存储计算机内存地址的变量。从指针指向的内存读取数据称作指针的取值。指针可以指向某些具体类型的变量地址，例如int、 long 和double。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据出现的位置不同，操作符 * 既可以用来声明一个指针变量，也可以用作指针的取值。当用在声明一个变量时，表示这里声明了一个指针。其它情况用到 * 表示指针的歌值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&amp;amp; 是地址操作符，用来引用一个内存地址。通过在变量名字前使用&amp;amp;操作符，我们可以得到该变量量的内存地址。(见以下解本)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;Action()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将var1值赋给变量deref&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; *ptr;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生命一个int类型的指针变量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; deref;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; var1 = &lt;span&gt;35&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义变量并复制，此时会分配存储单位，有存储地址&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; = &lt;span&gt;99&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     ptr = &amp;amp;&lt;span&gt;var&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ptr指向变量var的内存地址，但不可以把数值赋给指针变量&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     deref = *ptr;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对指针进行取值，打印存储在指针地址中的内容&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     lr_output_message(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var is %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,deref);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的值为： var is 99&lt;/p&gt;
</description>
<pubDate>Mon, 16 Dec 2019 00:31:00 +0000</pubDate>
<dc:creator>S-Gavin</dc:creator>
<og:description>在一次教程学习中，看到该知识点并记录了下来，希望与大家共同探讨学习。 一、静态存储与动态存储 静态存储变量通常是在变量定义时就分定存储单元并一直保持不变， 直至整个程序结束。动态存储变量是在程序执行过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zwh-Seeking/p/12030642.html</dc:identifier>
</item>
<item>
<title>C#异步编程看这篇就够了 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/12045018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/12045018.html</guid>
<description>&lt;p&gt;随着.NET Core的流行，相信你现在的代码中或多或少的会用到&lt;code&gt;async&lt;/code&gt;以及&lt;code&gt;await&lt;/code&gt;吧！毕竟已成标配。那么我们为什么要用&lt;code&gt;async&lt;/code&gt;以及&lt;code&gt;await&lt;/code&gt;呢？其实这是微软团队为我们提供的一个语法糖，让我们不用996就可以轻松的编写异步代码，并无太过神奇的地方。那么，问题来了，什么是异步？异步到底又是怎样的一个过程呢？&lt;/p&gt;
&lt;h3 id=&quot;从一个故事说起&quot;&gt;从一个故事说起&lt;/h3&gt;
&lt;p&gt;在开始讲异步前我们先从一个生活中的小故事说起吧。话说2019年12月15日周日这一天有位程序猿小祝在这天居然没有加班，选择在家休息了，然后他习惯性的用&lt;code&gt;Microsoft To Do&lt;/code&gt;罗列了一下这天要做的事情，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201912/1377250-20191215164727090-1093328851.png&quot; alt=&quot;image-20191215143106499&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一天这个程序猿小祝计划早上九点起床洗澡，然后吃早餐，洗衣服，分享一篇关于&lt;code&gt;C#异步&lt;/code&gt;相关的文章，晚上在家加下班~~没错，这个苦逼休息的时候也得工作，不然下周的任务有可能完不成要挨批了。&lt;/p&gt;
&lt;p&gt;这个时候这个程序猿小祝可以选择，1.起床洗澡，2.吃早餐，3.洗衣服，4.写文章，5.打会球然后“远程写代码”。这个过程有严格的执行顺序，这个过程可以视为一个同步的过程。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201912/1377250-20191215164726752-85848499.png&quot; alt=&quot;image-20191215144358900&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，这个程序猿小祝却采用了另一种方式来进行：起床后先把衣服换下来用洗衣机洗了，然后开始洗澡，然后吃饭，写了一会文章，然后等衣服洗好后再把衣服给晾好继续回来写文章，最后在晚上的时候远程写代码。在这个过程中这个程序猿在洗衣服的同时就去洗澡，吃饭写了会文章了，这个过程就是一个异步的过程。&lt;/p&gt;
&lt;p&gt;可能这个故事比喻的不恰当，不过大伙将就着看下吧，总结一下同步跟异步吧：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;同步方法：可以认为程序是按照你写这些代码时所采用的顺序执行相关的指令的。&lt;/li&gt;
&lt;li&gt;异步方法：可以在尚未完成所有指令的时候提前返回（如上面的洗衣服过程没执行完就返回去洗澡了），等到该方法等候的那项任务执行完毕后，在令这个方法从早前还没执行完的那个地方继续往下运行（如：衣服洗好晾好后，继续写文章了）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们结合伪代码来进行更加详细的讲解吧。&lt;/p&gt;
&lt;h3 id=&quot;伪代码实例讲解&quot;&gt;伪代码实例讲解&lt;/h3&gt;
&lt;p&gt;这一节我们就用伪代码来分别实现下同步过程及异步过程吧。&lt;/p&gt;
&lt;h4 id=&quot;同步过程&quot;&gt;同步过程&lt;/h4&gt;
&lt;p&gt;下面我们用伪代码来实现上述故事中的过程吧。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; static void Main(string[] args)
        {
            Console.WriteLine(&quot;Main异步演示开始~~~~~&quot;);
            Stopwatch stopwatch = Stopwatch.StartNew();
            Bash();//洗澡
            BreakFast();//吃早餐
            WashClothes();//洗衣服
            WriteArticle();//写文章
            WritingCode();//写代码
            Console.WriteLine(&quot;Main异步演示结束~~~~~共用时{0}秒！&quot;, stopwatch.ElapsedMilliseconds/1000);
            Console.ReadKey();
        }

        private static void Bash()
        {
            Console.WriteLine(&quot;洗澡开始~~~~~&quot;);
            Thread.Sleep(1*1000);//模拟过程
            Console.WriteLine(&quot;洗澡结束~~~~~&quot;);
        }

        private static void BreakFast()
        {
            Console.WriteLine(&quot;吃早餐开始~~~~~&quot;);
            Thread.Sleep(1 * 1000);//模拟过程
            Console.WriteLine(&quot;吃早餐结束~~~~~&quot;);
        }

        private static void WashClothes()
        {
            Console.WriteLine(&quot;洗衣服开始~~~~~&quot;);
            Thread.Sleep(6 * 1000);//模拟过程
            Console.WriteLine(&quot;洗衣服结束~~~~~&quot;);

        }

        private static void WriteArticle()
        {
            Console.WriteLine(&quot;写文章开始~~~~~&quot;);
            Thread.Sleep(20 * 1000);//模拟过程
            Console.WriteLine(&quot;写文章结束~~~~~&quot;);
        }

        private static void WritingCode()
        {
            Console.WriteLine(&quot;写代码开始~~~~~&quot;);
            Thread.Sleep(12 * 1000);//模拟过程
            Console.WriteLine(&quot;写代码结束~~~~~&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码没什么难的，写完代码后我们直接&lt;code&gt;dotnet run&lt;/code&gt;一下代码，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201912/1377250-20191215164726443-1887991979.png&quot; alt=&quot;image-20191215153032564&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到这个代码的执行过程是严格按照我们编码的顺序执行的，即同步运行的代码。这里用时共40秒！&lt;/p&gt;
&lt;h4 id=&quot;异步过程&quot;&gt;异步过程&lt;/h4&gt;
&lt;p&gt;我们只需要稍微改造下使得代码异步执行再来看下效果吧！伪代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; static async Task Main(string[] args)
        {
            Console.WriteLine(&quot;Main异步演示开始~~~~~&quot;);
            Stopwatch stopwatch = Stopwatch.StartNew();
            List&amp;lt;Task&amp;gt; tasks = new List&amp;lt;Task&amp;gt;
            {
                Bash(),//洗澡
            };
            tasks.Add(BreakFast());//吃早餐
            tasks.Add(WashClothes());//洗衣服
            tasks.Add(WriteArticle());//写文章
            tasks.Add(WritingCode());//写代码
            await Task.WhenAll(tasks);
            Console.WriteLine(&quot;Main异步演示结束~~~~~共用时{0}秒！&quot;, stopwatch.ElapsedMilliseconds/1000);
            Console.ReadKey();
        }

        private static async Task Bash()
        {
            Console.WriteLine(&quot;洗澡开始~~~~~&quot;);
            await Task.Delay(1*1000);//模拟过程
            Console.WriteLine(&quot;洗澡结束~~~~~&quot;);
        }

        private static async Task BreakFast()
        {
            Console.WriteLine(&quot;吃早餐开始~~~~~&quot;);
            await Task.Delay(1 * 1000);//模拟过程
            Console.WriteLine(&quot;吃早餐结束~~~~~&quot;);
        }

        private static async Task WashClothes()
        {
            Console.WriteLine(&quot;洗衣服开始~~~~~&quot;);
            await Task.Delay(6 * 1000);//模拟过程
            Console.WriteLine(&quot;洗衣服结束~~~~~&quot;);

        }

        private static async Task WriteArticle()
        {
            Console.WriteLine(&quot;写文章开始~~~~~&quot;);
            await Task.Delay(20 * 1000);//模拟过程
            Console.WriteLine(&quot;写文章结束~~~~~&quot;);
        }

        private static async Task WritingCode()
        {
            Console.WriteLine(&quot;写代码开始~~~~~&quot;);
            await Task.Delay(12 * 1000);//模拟过程
            Console.WriteLine(&quot;写代码结束~~~~~&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再直接&lt;code&gt;dotnet run&lt;/code&gt;一下代码，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201912/1377250-20191215164726090-1590529818.png&quot; alt=&quot;image-20191215154823294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到这个代码的执行过程中遇到&lt;code&gt;await&lt;/code&gt;后就会返回执行了，待await的代码执行完毕后才继续执行接下来的代码的！为了避免有的读者看不懂，我简单分析其中一个方法的执行过程吧。具体的还需要你自己把异步代码拷贝下来，多打几个断点，然后把等待时间*100（时间长点方便我们查看断点的进入顺序，否则时间短，还没来得及进断点可能代码已经执行完了）看看断点的进入步骤吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201912/1377250-20191215164725421-903993822.png&quot; alt=&quot;image-20191215160556885&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我也只列了一部分，具体的你们自行打断点看下吧。&lt;/p&gt;
&lt;h3 id=&quot;异步原理解析&quot;&gt;异步原理解析&lt;/h3&gt;
&lt;p&gt;通过上面的伪代码分析相信你已经对异步有所了解了。接下来我们就来看看系统到底是怎么实现出这样的效果的。下面只是简单地进行下表述，如果不正确的欢迎大家指正。&lt;/p&gt;
&lt;p&gt;编译器在处理异步方法的时候，会构建一种机制，该机制可以启动&lt;code&gt;await&lt;/code&gt; 语句所要等候的那项异步任务，并使得程序在该工作完成之后，能够用某个线程继续执行&lt;code&gt;await&lt;/code&gt;语句后面的那些代码。这个&lt;code&gt;await&lt;/code&gt;语句正是关键所在。编译器会构建相应的数据结构，并把&lt;code&gt;await&lt;/code&gt;之后的指令表示成&lt;code&gt;delegate&lt;/code&gt;，使得程序在处理完那项异步任务之后，能够继续执行下面的那些指令。编译器会把当前方法中的每一个局部变量的值都保存在这个数据结构中，并根据&lt;code&gt;await&lt;/code&gt;语句所要等候的任务来配置相应的逻辑，让程序能够在该任务完成之后指派某个线程，从&lt;code&gt;await&lt;/code&gt;语句的下一条指令开始继续执行。实际上，这相当于编译器生成了一个&lt;code&gt;delegate&lt;/code&gt;，用以表示&lt;code&gt;await&lt;/code&gt;语句之后的那些代码，并写入了相应的状态信息，用以确保&lt;code&gt;await&lt;/code&gt;语句所等候的那项任务执行完毕以后这个&lt;code&gt;delegate&lt;/code&gt;能够正确的得到调用。&lt;/p&gt;
&lt;p&gt;这使得该方法看上去好像是从早前暂停的地方继续往下执行了，也就是所，系统会把状态恢复到早前暂停的样式，并且直接把程序中的某个线程放到适当的语句上，令其能够继续向下运行。&lt;/p&gt;
&lt;p&gt;这个过程实际上是由&lt;code&gt;SynchronizationContext&lt;/code&gt;类来实现的，该类用来保证异步方法能够在它所等候的任务执行完毕时，从早前停下来的地方继续往下运行，并确保该方法此时所处的环境与上下文能够与当初的情况一样。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;通过上面的讲述我们可以知道通过&lt;code&gt;async&lt;/code&gt;与&lt;code&gt;await&lt;/code&gt;关键字写出来的异步方法并没有太过神奇的地方。只不过编译器会针对这种方法生成许多代码，使得调用这个方法的主调方无需等待该方法完工，就可以继续往下执行，并确保该方法所等候的那项任务在执行过程中发生的错误能够适当的得到回报。这样的好处是，如果异步方法执行到await语句时它所要等候的那项任务还没有完成，那么该方法的执行进度就会暂停在那里，直到那项任务完成之后，才回继续往下执行。&lt;/p&gt;
&lt;p&gt;希望这篇文章对你有所帮助，当然光了解异步没用，还要能够高效的编写异步代码才行哦，接下来我会抽时间讲讲进行异步开发的一些建议。当然我以前也写过相关的文章，你可以提前看下。同时欢迎大家加入.net core两千人交流群637326624`交流。当然我不会告诉你，关注公众号会第一时间收到文章推送。&lt;/p&gt;
&lt;p&gt;很久没写文章了，生疏了后多，大家将就着看吧！&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;《More Effective C#》机械工业出版社&lt;/p&gt;
&lt;p&gt;依乐祝自己的理解&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 23:58:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>随着.NET Core的流行，相信你现在的代码中或多或少的会用到 以及 吧！毕竟已成标配。那么我们为什么要用 以及 呢？其实这是微软团队为我们提供的一个语法糖，让我们不用996就可以轻松的编写异步代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/12045018.html</dc:identifier>
</item>
<item>
<title>JavaEE基础(04)：会话跟踪技术，Session和Cookie详解 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12047240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12047240.html</guid>
<description>&lt;blockquote readability=&quot;1.8269230769231&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/java-base-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/java-base-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;场景描述&quot;&gt;1、场景描述&lt;/h2&gt;
&lt;p&gt;比如登录某个购物网站，身份识别成功后，在网站下单，支付 等操作，这些操作中当前登录用户信息必须是共享的，这样这些操作结果才能和登录用户做关联。&lt;/p&gt;
&lt;h2 id=&quot;概念简介&quot;&gt;2、概念简介&lt;/h2&gt;
&lt;p&gt;可以把会话理解为客户端与服务器之间的一次交互，在一次交互中可能会包含多次请求和响应。在JavaWeb中，从客户端向服务器发出第一个请求开始，会话就开始了，直到客户端关闭浏览器会话结束。在一个会话的多个请求中共享数据，这就是会话跟踪技术。&lt;/p&gt;

&lt;h2 id=&quot;cookie简介&quot;&gt;1、Cookie简介&lt;/h2&gt;
&lt;p&gt;Cookie在HTTP中通常是用来辨别用户身份，进行会话跟踪而储存在用户本地终端上的数据，一般会加密处理，由用户客户端计算机暂时或永久保存的信息。其结构就是一个键和一个值构成的。随着服务器端的响应发送给客户端浏览器。然后客户端浏览器会把Cookie保存起来，当下一次再访问服务器时把Cookie再发送给服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201912/1691717-20191216075015945-7388221.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Cookie是由服务器创建，然后通过响应发送给客户端的键值对。客户端会保存Cookie，并会标注出Cookie的来源。当客户端向服务器发出请求时会把Cookie包含在请求中发送给服务器，这样服务器就可以识别客户端。&lt;/p&gt;
&lt;h2 id=&quot;cookie用法&quot;&gt;2、Cookie用法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;创建Cookie&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JavaWeb中，可以基于Servlet创建Cookie，并设置属性。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CookieServletOne extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        // 创建Cookie
        Cookie cookie = new Cookie(&quot;author&quot;,&quot;cicada&quot;);
        // 设置生命周期 1小时
        cookie.setMaxAge(60*60);
        response.addCookie(cookie) ;
        response.getWriter().print(&quot;Hello:Cookie&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问：&lt;code&gt;http://localhost:6002/cookieServletOne&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看响应头：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Response Header
Set-Cookie: author=cicada; Max-Age=3600;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，服务器创建的Cookie在客户端就拿到了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取Cookie&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CookieServletOne extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        System.out.println(&quot;doPost...&quot;);
        Cookie[] cookies = request.getCookies() ;
        for (Cookie cookie:cookies){
            System.out.println(&quot;Name：&quot;+cookie.getName());
            System.out.println(&quot;Value：&quot;+cookie.getValue());
        }
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        String userName = request.getParameter(&quot;userName&quot;) ;
        response.getWriter().print(&quot;Hello:&quot;+userName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过测试，控制台输出：&lt;code&gt;Name：author;Value：cicada&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更新Cookie&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更新就是指Cookie的覆盖，如果服务器端发送重复的Cookie那么会覆盖原有的Cookie。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CookieServletTwo extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        // 创建Cookie
        Cookie cookie = new Cookie(&quot;author&quot;,&quot;smile&quot;);
        // 设置生命周期 2小时
        cookie.setMaxAge(60*60*2);
        response.addCookie(cookie) ;
        response.getWriter().print(&quot;Hello:Cookie&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过上面方法测试Cookie的获取结果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;删除Cookie&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;cookie.setMaxAge(0)：生命等于0是一个特殊的值，它表示cookie被作废。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CookieServletTwo extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        Cookie[] cookies = request.getCookies() ;
        for (Cookie cookie:cookies){
            if (cookie.getName().equals(&quot;author&quot;)){
                cookie.setMaxAge(0);
                response.addCookie(cookie);
            }
        }
        String userName = request.getParameter(&quot;userName&quot;) ;
        response.getWriter().print(&quot;Hello:&quot;+userName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样再测试Cookie的获取方法，发现上面删除的Cookie就没有了。&lt;/p&gt;
&lt;h2 id=&quot;cookie相关api&quot;&gt;3、Cookie相关API&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;setMaxAge()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置 cookie 过期的时间，秒为单位。默认情况cookie 只会在当前 session 会话中有效。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getMaxAge()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;获取 cookie 的最大生存周期。&lt;/p&gt;
&lt;p&gt;获取 cookie 的名称。名称在创建后不能改变。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getValue()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;获取与 cookie 关联的值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setValue(String value)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置与cookie关联的value值。相同的name多次设置会覆盖。&lt;/p&gt;

&lt;h2 id=&quot;session简介&quot;&gt;1、Session简介&lt;/h2&gt;
&lt;p&gt;会话管理，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。Servlet中可以把一个会话内需要共享的数据保存到HttSession对象中。四大域对象：PageContext、ServletRequest、HttpSession、ServletContext。&lt;/p&gt;
&lt;h2 id=&quot;session运行原理&quot;&gt;2、Session运行原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201912/1691717-20191216075043762-584244426.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首次使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首次使用session时，服务器端要创建session，session是保存在服务器端，数据是保存在session中，sessionId通过Cookie发送给客户端，且只在浏览器本次会话中存在，也就是说如果用户关闭了浏览器，那么这个Cookie就丢失。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端访问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端再次访问服务器时，在请求中会带上sessionId，服务器会通过sessionId找到对应的session，而无需再创建新的session。&lt;/p&gt;
&lt;p&gt;当一个session长时间没人使用的话，服务器会把session删除了，这个时长在Tomcat中配置是30分钟，可以在${CATALANA}/conf/web.xml找到这个配置，也可以在的web.xml中覆盖这个配置！&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;session-config&amp;gt;
    &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt;
&amp;lt;/session-config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;相关api用法&quot;&gt;3、相关API用法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;getSesssion()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当前会话已经存在session对象那么直接返回，如果当前会话还不存在，创建session对象并返回 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getAttribute(String name)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;返回该 session 会话中具有指定名称的对象 。&lt;/p&gt;
&lt;p&gt;分配给该 session 会话的唯一标识符的字符串。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setAttribute(String name,Object value)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用指定的名称绑定一个对象到该 session 会话。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;removeAttribute(String name)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从该 session 会话移除指定名称的对象。&lt;/p&gt;
&lt;h2 id=&quot;应用案例&quot;&gt;4、应用案例&lt;/h2&gt;
&lt;p&gt;在网站中，经常可见的一个功能就是上次登录时间，这个功能基于Session可以很便捷的实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SessionServletOne extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        HttpSession session = request.getSession(true) ;
        Date createTime = new Date(session.getCreationTime());
        Date lastAccessTime = new Date(session.getLastAccessedTime());
        session.setAttribute(&quot;author&quot;,&quot;cicada&quot;);
        response.getWriter().print(
                &quot;SessionId：&quot; + session.getId() + &quot;&amp;lt;br/&amp;gt;&quot;+
                &quot;User Author：&quot; + session.getAttribute(&quot;author&quot;)+&quot;&amp;lt;br/&amp;gt;&quot;+
                &quot;Create Time：&quot; + dateFormat.format(createTime)+&quot;&amp;lt;br/&amp;gt;&quot;+
                &quot;Last Access Time：&quot;+dateFormat.format(lastAccessTime));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问&lt;code&gt;http://localhost:6002/sessionServletOne&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;页面打印，多次访问，查看效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SessionId：40C12C367CBFA7469D57E72C5C091300
User Author：cicada
Create Time：2019-12-14 15:34:10
Last Access Time：2019-12-14 15:35:13&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/java-base-parent
GitEE·地址
https://gitee.com/cicadasmile/java-base-parent&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 23:53:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： 'GitHub·点这里' || 'GitEE·点这里' 一、会话跟踪 1、场景描述 比如登录某个购物网站，身份识别成功后，在网站下单，支付 等操作，这些操作中当前登录用户信息必须是共享的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12047240.html</dc:identifier>
</item>
<item>
<title>TypeScript躬行记（2）——接口 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/11654181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/11654181.html</guid>
<description>&lt;p&gt;　　在传统的面向对象语言中，接口（Interface）好比协议，它会列出一系列的规则（即对行为进行抽象），再由类来实现这些规则。而TypeScript中的接口更加灵活，除了包含常规的作用之外，它还能扩展其它的类、为对象的类型命名以及约束值的结构等，大大消除了许多潜在的错误。&lt;/p&gt;

&lt;p&gt;　　TypeScript中的接口可通过声明属性和其类型来限制对象的结构。例如定义一个名为Person的接口，包含一个字符串类型的name属性和一个数字类型的age属性，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
  name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
  age: number;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当声明一个Person类型的对象时，必须将两个属性都定义，并且类型也要与接口中的一致，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let worker: Person =&lt;span&gt; {
  name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  age: &lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一旦在worker对象中少定义某个接口中的属性或多一个在接口中未声明的属性，那么就会在编译阶段报错。注意，TypeScript的类型检查器不会比对属性在接口和对象中的定义顺序，只要名称和类型匹配，就能编译通过。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）可选属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　TypeScript允许接口中的属性定义为可选的，只要在属性名后跟问号（?），就能变为可选属性，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
  school&lt;/span&gt;?: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可选属性既能预定义可能需要的属性，也能在捕获没有的属性时给出带有启发作用的错误提示，例如在创建worker对象时，定义一个schools属性（如下所示），在编译时就会报&quot;'schools' does not exist in type 'Person'. Did you mean to write 'school'?&quot;的错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let worker: Person =&lt;span&gt; {
  schools: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;university&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由此可知，在对象中定义一个未在接口中声明的属性仍然是不允许的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）只读属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果要让对象的某个属性只能在创建时被赋值，那么可以将readonly关键字作用于相应的接口属性，使其变为只读的，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt; gender: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于gender是一个只读属性，因此不能在对象初始化后对其进行修改，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let worker: Person = {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
  gender: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
worker.gender &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）任意属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当接口需要包含任意属性时，可以通过索引的方式实现，如下所示，用方括号将索引名和索引类型包裹起来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
  [prop: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在使用Person类型时，可以传任意多个字符串类型的属性，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let worker: Person =&lt;span&gt; {
  name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  gender: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，一旦声明了任意属性之后，那么必选属性和可选属性都得是其类型的子类型。在下面的示例中，由于可选的age属性的类型是number，不是string的子类型，因此在编译时会报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
  name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
  age?: number;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
  [prop: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　TypeScript除了支持字符串类型的索引之外，还支持数字类型的索引，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
  [prop: number]: number;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有一点需要注意，当在接口中同时定义字符串和数字两种类型的索引时，后者对应的值类型得是前者的子类型。因为这个原因，导致下面的代码无法在编译时通过。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
  [prop: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
  [prop: number]: number;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　TypeScript之所以如此限制，是因为JavaScript会将数字自动转换成字符串后再去索引对象，例如用10和“10”两个值去索引，得到的结果是一样的，所以两种索引对应的值类型要保持一致。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）类继承接口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　与C#、Java等面向对象语言一样，TypeScript中的类也能继承接口，并且接口中的成员会让类强制实现。有了接口之后，它的任何更改都有可能导致编译错误，从而就能保证相关代码的同步。下面通过一个示例来演示类继承接口，首先创建一个名为Person的接口，包含name属性和getName()方法，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
  name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
  getName(): &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后再创建一个名为Member的类，通过implements关键字继承Person接口，如下所示。在编译时，一旦发现类中缺少接口的属性或方法，就会马上报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Member implements Person {
  name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  getName() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　类能继承多个接口，只要在类中实现它的成员，就能编译成功，如下所示，Member类继承了Person和Profile两个接口，限于篇幅原因，在其内部省略了name和getName()两个成员的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Profile {
  school: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Member implements Person, Profile {
  school: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;university&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，类不能实现接口中的所有成员，例如在接口中定义一个构造器，再用一个类通过构造函数来实现这个接口，此时编译将会失败，代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; (name: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Member implements Person {
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) { }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　类包含静态和实例两部分，由于编译器只会对接口的实例部分进行类型检查，而constructor()函数属于类的静态部分，因此会被忽略，从而导致无法在类中找到匹配的成员来实现接口。&lt;/p&gt;
&lt;p&gt;　　如果要实现接口中的构造器，那么有两种方式可供选择。第一种是参数回调，如下代码所示，Member类不再直接继承Person接口，而是作为参数传递给createPerson()函数，并且其第一个参数被声明为Person类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Member {
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) { }
}
function createPerson(ctor: Person, name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ctor(name);
}
createPerson(Member, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二种是类表达式，如下代码所示，将Man变量声明为Person类型，并把Member类赋给它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let Man: Person = &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Member {
  constructor(name: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) { }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）接口继承接口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　接口之间也可相互继承，这样既能更细粒度的分割接口，也能最大化的重用代码。与类不同的是，只需将其它的接口成员复制过来，而不必实现它们。在下面的示例中，Square接口通过extends关键字继承了Shape接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Shape {
  background: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Square extends Shape {
  width: number;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一个接口还可以继承多个其它接口，创建出一个合成接口，如下所示，extends后面跟了Shape和Border两个接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Border {
  color: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Ellipse extends Shape, Border {
  angle: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）接口继承类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当接口继承一个类时，它会继承类的所有成员（包括私有和受保护的成员），但不会去实现它们。以下面的TextBox接口为例，它继承了Control类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Control {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; width: number;
  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; height: number;
}
&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TextBox extends Control {
  type: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tel implements TextBox {
  type: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上例中的Tel类直接继承了TextBox接口，虽然实现了接口中的type属性，但仍然会报“Type 'Tel' is missing the following properties from type 'TextBox': width, height”的错误。因为Button接口继承的width和height两个属性也需要实现。为了避免出现这些错误，可以通过Control的子类来实现TextBox接口，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Password extends Control implements TextBox {
  type: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 15 Dec 2019 23:47:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>在传统的面向对象语言中，接口（Interface）好比协议，它会列出一系列的规则（即对行为进行抽象），再由类来实现这些规则。而TypeScript中的接口更加灵活，除了包含常规的作用之外，它还能扩展其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/11654181.html</dc:identifier>
</item>
<item>
<title>【数据结构05】红-黑树基础----二叉搜索树（Binary Search Tree） - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/12036581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/12036581.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;br/&gt;在&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/100600178&quot;&gt;【算法04】树与二叉树&lt;/a&gt;中，已经介绍过了关于树的一些基本概念以及二叉树的前中后序遍历，而这篇文章将是在二叉树的基础上来展开讲解的二叉搜索树，也就是说二叉搜索树建立在树的基础之上。至于博主为何要花一整篇文章来讲这个二叉搜索树呢？原因很简单，红-黑树是基于二叉搜索树的，如果对二叉搜索树不了解，那还谈何红-黑树？红-黑树的重要性我想各位没吃过佩奇肉也肯定看过宜春跑....是的，jdk1.8的Map 就是散列表+红黑树实现的！&lt;/p&gt;
&lt;p&gt;@&lt;/p&gt;
&lt;p&gt;首先要明确的是&lt;span&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;&lt;/span&gt;又称&lt;span&gt;&lt;strong&gt;二叉排序树&lt;/strong&gt;&lt;/span&gt;、&lt;span&gt;&lt;strong&gt;二叉查找树&lt;/strong&gt;&lt;/span&gt;，简统称&lt;span&gt;&lt;strong&gt;BST&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;二分法引言&quot;&gt;1、二分法引言&lt;/h2&gt;
&lt;p&gt;在正式将二叉搜索树之前，宜春还是想先谈谈人生谈谈生活从而切入二叉搜索树。&lt;/p&gt;
&lt;p&gt;一天，程序员老方给宜春打电话：靓仔，我今天下单了一双皮鞋，老靓了，价格不菲啊！&lt;br/&gt;宜春：得了吧你，啥条件啊我还不知道，还皮鞋，老鼠皮的鞋吧，如果是真牛皮的皮鞋我把它吃喽！！！&lt;br/&gt;老方：你还真别说，这皮鞋还真是比真牛皮还真的假牛皮的皮鞋，老靓了，你猜猜我买它花了多少银子，反正是100以内，看你能不能再最少次数猜出来，要是五次机会之内猜出来就亲自下厨，炖给你吃，嘎嘣脆，嘿嘿...&lt;br/&gt;宜春：你就嘚瑟吧，还是你懂我，知道我好这一口（自黑）....咳咳咳，50块&lt;br/&gt;老方：不对，价格高了&lt;br/&gt;宜春：25&lt;br/&gt;老方：不对，价格还高了&lt;br/&gt;宜春：12.5&lt;br/&gt;....&lt;/p&gt;
&lt;p&gt;一个一个字看这里的估计在座各位个个都是人才，就一个简简单单的二分法猜数字的游戏，通过对猜测数字“大了”、“小了”的情况判断，来猜出最终的数字。当然，本改三言两语就可以描述的，宜春花了这么长串字符串来描述，估计宜春TM也是个人才....实际上呢，宜春就想活跃活跃下气氛，把各位的脑细胞集中一下下，当然耽误了各位时间，属实抱歉，宜春在线挨揍....&lt;/p&gt;
&lt;p&gt;不知各位有没有想过，为何二分法就是有足够的优势呢？如果100以内我直接猜25不行么？这样岂不是更可能定出价格？其实直接猜25或者更小这是一种极端的猜测，如果确实比25小，那范围就是在25以内了，那你有没有想过:如果大于25呢？范围就直接转成了75了！随着这种极端思想的推进，会发现&lt;br/&gt;每次择半查找会更加准确和更好的能应对各种不确定的情景！择半查找复杂度为 O(log_2 n)，即最多需要 O(log_2 n) 次可以猜到最终数字。&lt;/p&gt;
&lt;p&gt;到这里，要开始正式介绍二叉搜索树了，实际上二叉搜索树就类似于上面提到过的二分查找，有类似的韵味。&lt;/p&gt;
&lt;h2 id=&quot;二叉搜索树定义&quot;&gt;2、二叉搜索树定义&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;二叉查找树（Binary Search Tree，BST）是一种特殊的二叉树，一棵二叉搜索树（BST）是一棵二叉树，其中，对于树中每个节点而言：&lt;br/&gt;1、若其左子树存在，则其左子树中每个节点的值都不大于该节点值；&lt;br/&gt;2、若其右子树存在，则其右子树中每个节点的值都不小于该节点值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191212204827850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二叉搜索树的crud&quot;&gt;3、二叉搜索树的CRUD&lt;/h2&gt;
&lt;p&gt;我想提一下的是：我们知道遍历树是使用前中后序遍历方法，但是遍历二叉搜索树最好是使用中序遍历法，如果不理解为何使用中序遍历，那么你有三种选择：&lt;br/&gt;一、自行&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/100600178&quot;&gt;【算法04】树与二叉树&lt;/a&gt;进去补补基础树基础&lt;br/&gt;二、留言提问，宜春看到就回&lt;br/&gt;三、前面二者都拒绝&lt;img src=&quot;https://img-blog.csdnimg.cn/201912130941255.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;，那你就优秀了....&lt;/p&gt;
&lt;h4 id=&quot;查找&quot;&gt;3.1、查找&lt;/h4&gt;
&lt;p&gt;如果要在二叉查找树中查找任意一个节点，假设它是X ，我们可以分为以下几步：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、如果二叉查找树为空，则返回空操作，否则，执行一下操作；&lt;br/&gt;2、先取根节点，如果节点 X 等于根节点，则返回；&lt;br/&gt;3、如果节点小于根节点，则递归查找左子树；&lt;br/&gt;4、如果节点大于根节点，则递归查找右子树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191212213856119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//查找的逻辑代码实现：
    /**
     * @param value 希望查找结点的值
     * @return 如果找到返回该结点，否则返回null
     */
    public Node search(int value) {
        if(value == this.value) { //找到就是该结点
            return this;
        } else if(value &amp;lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找
            //如果左子结点为空
            if(this.left  == null) {
                return null;
            }
            return this.left.search(value);
        } else { //如果查找的值不小于当前结点，向右子树递归查找
            if(this.right == null) {
                return null;
            }
            return this.right.search(value);
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;插入&quot;&gt;3.2、插入&lt;/h4&gt;
&lt;p&gt;在二叉树中插入一个节点，仔细想想，会发现插入某一个节点一般都是插入到叶节点上，所以只需从根结点开始，依次遍历比较要插入的数据和节点的大小关系。&lt;/p&gt;
&lt;p&gt;==二叉查找树有一个很重要的特性就是插入的实现难度和查找差不多==。插入节点其实可以有如下三种情况：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、如果树是空的，则直接将新节点插入，否则，执行下面步骤。&lt;br/&gt;2、要插入的数据比根节点数据大，则到右子树中插入新数据，如果右子树为空，则将新数据直接插入到右子节点的位置；不为空，则继续遍历右子树，查找插入位置。&lt;br/&gt;3、要插入的数据比根节点数据小，则到左子树中插入数据，如果左子树为空，则直接将新数据插入到左子节点的位置；不为空，则继续遍历左子树，查找插入的位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191213083021711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; //添加结点的逻辑代码
    //递归的形式添加结点，注意需要满足二叉排序树的要求
    public void add(Node node) {
        if(node == null) {
            return;
        }
       if(root == null) {
            root = node;//如果root为空则直接让root指向node
        } 
        //判断传入的结点的值，和当前子树的根结点的值关系
      if(node.value &amp;lt; this.value) {
            //如果当前结点左子结点为null
            if(this.left == null) {
                this.left = node;
            } else {
                //递归的向左子树添加
                this.left.add(node);
            }
        } else { //添加的结点的值大于 当前结点的值
            if(this.right == null) {
                this.right = node;
            } else {
                //递归的向右子树添加
                this.right.add(node);
            }

        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除&quot;&gt;3.3、删除&lt;/h4&gt;
&lt;p&gt;可以这么说，删除相对查找和插入来说比较复杂一些，为啥会复杂一些呢？因为要删除某一个节点，首先要查找到这个节点然后将其删除，删除之后还需要将该二叉搜索树还原成一颗二叉搜索树。因此针对要删除节点的子节点位置的不同，同样一般分为三种情况来处理：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、 第一种情况，如果要删除的节点没有子节点，直接将父节点指向要删除节点的指针指向 null。比如途中要删除的节点 0。&lt;br/&gt;2、第二种情况，如果要删除的节点只有一个节点，即只有左子节点或右子节点，则将父节点指向要删除节点的指针指向要删除节点的子节点即可。比如途中要删除的节点1。&lt;br/&gt;3、第三种情况，如果要删除的节点有两个子节点，则需要先找到这个节点右子树中的最小节点或者左子树中的最大节点，将其替换到要删除的节点上。然后删除这个右子树中的最小节点或左子树中的最大节点，比如图中要删除的节点 6。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191213092226286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; //删除结点逻辑代码
    public void delNode(int value) {
        if(root == null) {
            return;
        }else {
            //1.需求先去找到要删除的结点  targetNode
            Node targetNode = search(value);
            //如果没有找到要删除的结点
            if(targetNode == null) {
                return;
            }
            //如果我们发现当前这颗二叉排序树只有一个结点
            if(root.left == null &amp;amp;&amp;amp; root.right == null) {
                root = null;
                return;
            }

            //去找到targetNode的父结点
            Node parent = searchParent(value);
            //如果要删除的结点是叶子结点
            if(targetNode.left == null &amp;amp;&amp;amp; targetNode.right == null) {
                //判断targetNode 是父结点的左子结点，还是右子结点
                if(parent.left != null &amp;amp;&amp;amp; parent.left.value == value) { //是左子结点
                    parent.left = null;
                } else if (parent.right != null &amp;amp;&amp;amp; parent.right.value == value) {//是由子结点
                    parent.right = null;
                }
            } else if (targetNode.left != null &amp;amp;&amp;amp; targetNode.right != null) { //删除有两颗子树的节点
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;


            } else { // 删除只有一颗子树的结点
                //如果要删除的结点有左子结点
                if(targetNode.left != null) {
                    if(parent != null) {
                        //如果 targetNode 是 parent 的左子结点
                        if(parent.left.value == value) {
                            parent.left = targetNode.left;
                        } else { //  targetNode 是 parent 的右子结点
                            parent.right = targetNode.left;
                        }
                    } else {
                        root = targetNode.left;
                    }
                } else { //如果要删除的结点有右子结点
                    if(parent != null) {
                        //如果 targetNode 是 parent 的左子结点
                        if(parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else { //如果 targetNode 是 parent 的右子结点
                            parent.right = targetNode.right;
                        }
                    } else {
                        root = targetNode.right;
                    }
                }

            }

        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;整体代码&quot;&gt;3.4、整体代码&lt;/h4&gt;
&lt;p&gt;为了连贯一下思维，可以自行编辑main方法进行测试！&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package dataStructure;

//创建二叉排序树
class BinarySortTree {
    private Node root;

    public Node getRoot() {
        return root;
    }

    //查找要删除的结点
    public Node search(int value) {
        if(root == null) {
            return null;
        } else {
            return root.search(value);
        }
    }

    //查找父结点
    public Node searchParent(int value) {
        if(root == null) {
            return null;
        } else {
            return root.searchParent(value);
        }
    }

    //编写方法:
    //1. 返回的 以node 为根结点的二叉排序树的最小结点的值
    //2. 删除node 为根结点的二叉排序树的最小结点
    /**
     *
     * @param node 传入的结点(当做二叉排序树的根结点)
     * @return 返回的 以node 为根结点的二叉排序树的最小结点的值
     */
    public int delRightTreeMin(Node node) {
        Node target = node;
        //循环的查找左子节点，就会找到最小值
        while(target.left != null) {
            target = target.left;
        }
        //这时 target就指向了最小结点
        //删除最小结点
        delNode(target.value);
        return target.value;
    }


    //删除结点
    public void delNode(int value) {
        if(root == null) {
            return;
        }else {
            //1.需求先去找到要删除的结点  targetNode
            Node targetNode = search(value);
            //如果没有找到要删除的结点
            if(targetNode == null) {
                return;
            }
            //如果我们发现当前这颗二叉排序树只有一个结点
            if(root.left == null &amp;amp;&amp;amp; root.right == null) {
                root = null;
                return;
            }

            //去找到targetNode的父结点
            Node parent = searchParent(value);
            //如果要删除的结点是叶子结点
            if(targetNode.left == null &amp;amp;&amp;amp; targetNode.right == null) {
                //判断targetNode 是父结点的左子结点，还是右子结点
                if(parent.left != null &amp;amp;&amp;amp; parent.left.value == value) { //是左子结点
                    parent.left = null;
                } else if (parent.right != null &amp;amp;&amp;amp; parent.right.value == value) {//是由子结点
                    parent.right = null;
                }
            } else if (targetNode.left != null &amp;amp;&amp;amp; targetNode.right != null) { //删除有两颗子树的节点
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;


            } else { // 删除只有一颗子树的结点
                //如果要删除的结点有左子结点
                if(targetNode.left != null) {
                    if(parent != null) {
                        //如果 targetNode 是 parent 的左子结点
                        if(parent.left.value == value) {
                            parent.left = targetNode.left;
                        } else { //  targetNode 是 parent 的右子结点
                            parent.right = targetNode.left;
                        }
                    } else {
                        root = targetNode.left;
                    }
                } else { //如果要删除的结点有右子结点
                    if(parent != null) {
                        //如果 targetNode 是 parent 的左子结点
                        if(parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else { //如果 targetNode 是 parent 的右子结点
                            parent.right = targetNode.right;
                        }
                    } else {
                        root = targetNode.right;
                    }
                }

            }

        }
    }

    //添加结点的方法
    public void add(Node node) {
        if(root == null) {
            root = node;//如果root为空则直接让root指向node
        } else {
            root.add(node);
        }
    }
    //中序遍历
    public void infixOrder() {
        if(root != null) {
            root.infixOrder();
        } else {
            System.out.println(&quot;二叉排序树为空，不能遍历&quot;);
        }
    }
}

//创建Node结点
class Node {
    int value;
    Node left;
    Node right;
    public Node(int value) {

        this.value = value;
    }


    //查找要删除的结点
    /**
     *
     * @param value 希望删除的结点的值
     * @return 如果找到返回该结点，否则返回null
     */
    public Node search(int value) {
        if(value == this.value) { //找到就是该结点
            return this;
        } else if(value &amp;lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找
            //如果左子结点为空
            if(this.left  == null) {
                return null;
            }
            return this.left.search(value);
        } else { //如果查找的值不小于当前结点，向右子树递归查找
            if(this.right == null) {
                return null;
            }
            return this.right.search(value);
        }

    }
    //查找要删除结点的父结点
    /**
     *
     * @param value 要找到的结点的值
     * @return 返回的是要删除的结点的父结点，如果没有就返回null
     */
    public Node searchParent(int value) {
        //如果当前结点就是要删除的结点的父结点，就返回
        if((this.left != null &amp;amp;&amp;amp; this.left.value == value) ||
                (this.right != null &amp;amp;&amp;amp; this.right.value == value)) {
            return this;
        } else {
            //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空
            if(value &amp;lt; this.value &amp;amp;&amp;amp; this.left != null) {
                return this.left.searchParent(value); //向左子树递归查找
            } else if (value &amp;gt;= this.value &amp;amp;&amp;amp; this.right != null) {
                return this.right.searchParent(value); //向右子树递归查找
            } else {
                return null; // 没有找到父结点
            }
        }

    }

    @Override
    public String toString() {
        return &quot;Node [value=&quot; + value + &quot;]&quot;;
    }


    //添加结点的方法
    //递归的形式添加结点，注意需要满足二叉排序树的要求
    public void add(Node node) {
        if(node == null) {
            return;
        }

        //判断传入的结点的值，和当前子树的根结点的值关系
        if(node.value &amp;lt; this.value) {
            //如果当前结点左子结点为null
            if(this.left == null) {
                this.left = node;
            } else {
                //递归的向左子树添加
                this.left.add(node);
            }
        } else { //添加的结点的值大于 当前结点的值
            if(this.right == null) {
                this.right = node;
            } else {
                //递归的向右子树添加
                this.right.add(node);
            }

        }
    }

    //中序遍历
    public void infixOrder() {
        if(this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null) {
            this.right.infixOrder();
        }
    }

}


public class BinarySortTreeDemo { //==========至于main方法的测试代码可自行调整测试！！！！！！！！！
    public static void main(String[] args) {
        int[] arr = {4,7, 2, 13, 11, 5, 1, 9, 3};
        BinarySortTree binarySortTree = new BinarySortTree();
        for(int i = 0; i&amp;lt; arr.length; i++) {
            binarySortTree.add(new Node(arr[i]));
        }
        binarySortTree.add(new Node(4));

        System.out.println(&quot;中序遍历二叉排序树~&quot;);
        binarySortTree.infixOrder(); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二叉搜索树的两种极端情况&quot;&gt;4、二叉搜索树的两种极端情况&lt;/h2&gt;
&lt;p&gt;1、变成一颗 &lt;span&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;&lt;/span&gt;，所有节点尽量填满树的每一层，上一层填满后还有剩余节点的话，则由左向右尽量填满下一层。如下图所示，即为一颗完全二叉树；&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019121309472386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;2、每一层只有一个节点的二叉树。如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191213094910887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我敲，这不是蛇皮怪单链表吗，是的，给我们的感觉就是树形怪退化为蛇皮怪单链表了！在这种情况下，树中每层只有一个节点，该状态的树结构更倾向于一种线性结构，节点的查询类似于数组的遍历，复杂度为 O(n)。&lt;/p&gt;
&lt;p&gt;也正是因此，后面就出现了平衡二叉树，就涉及到了左旋右旋花里胡哨的蛇皮操作，当然这只是提一下，并不在本文的范畴之内，不过后续应该会写这方面的文章，尽量吧.....&lt;/p&gt;
&lt;h2 id=&quot;二叉搜索树总结&quot;&gt;5、二叉搜索树总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;&lt;/span&gt;又称&lt;span&gt;&lt;strong&gt;二叉排序树&lt;/strong&gt;&lt;/span&gt;、&lt;span&gt;&lt;strong&gt;二叉查找树&lt;/strong&gt;&lt;/span&gt;，简统称&lt;span&gt;&lt;strong&gt;BST&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据二叉搜索树的特性，==可知比较次数等于给定值节点在二叉排序树中的层数==。遍历的话使用&lt;strong&gt;中序遍历&lt;/strong&gt;。如果二叉排序树是平衡的，则n个节点的二叉排序树的高度为&lt;code&gt;Log2n+1&lt;/code&gt;,其查找效率为&lt;code&gt;O(Log2n)&lt;/code&gt;，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为&lt;code&gt;O(n)&lt;/code&gt;，退化为顺序查找。一般的，&lt;span&gt;&lt;strong&gt;二叉排序树的查找性能在&lt;code&gt;O(Log2n)&lt;/code&gt;到&lt;code&gt;O(n)&lt;/code&gt;之间&lt;/strong&gt;&lt;/span&gt;。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。而平衡二叉树可能又要涉及到了左旋右旋花里胡哨的蛇皮操作，当然这只是提一下，并不在本文的范畴之内，不过后续应该会写这方面的文章，尽量吧.....&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，里面有一些java学习资料和一大波java电子书籍，比如说周志明老师的深入java虚拟机、java编程思想、核心技术卷、大话设计模式、java并发编程实战.....都是java的圣经，不说了快上Tomcat车，咋们走！最主要的是一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 23:40:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>前言 在 '【算法04】树与二叉树' 中，已经介绍过了关于树的一些基本概念以及二叉树的前中后序遍历，而这篇文章将是在二叉树的基础上来展开讲解的二叉搜索树，也就是说二叉搜索树建立在树的基础之上。至于博主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/12036581.html</dc:identifier>
</item>
<item>
<title>Mybatis代码生成器Mybatis-Generator使用详解 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/12046848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/12046848.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;最近在做创业项目的时候因为有比较多的新需求，需要频繁基于&lt;code&gt;DDL&lt;/code&gt;生成&lt;code&gt;Mybatis&lt;/code&gt;适合的实体、&lt;code&gt;Mapper&lt;/code&gt;接口和映射文件。其中，代码生成器是&lt;code&gt;MyBatis Generator(MBG)&lt;/code&gt;，用到了&lt;code&gt;Mybatis-Generator-Core&lt;/code&gt;相关依赖，这里通过一篇文章详细地分析这个代码生成器的使用方式。本文编写的时候使用的&lt;code&gt;Mybatis-Generator&lt;/code&gt;版本为&lt;code&gt;1.4.0&lt;/code&gt;，其他版本没有进行过调研。&lt;/p&gt;
&lt;h2 id=&quot;引入插件&quot;&gt;引入插件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Mybatis-Generator&lt;/code&gt;的运行方式有很多种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于&lt;code&gt;mybatis-generator-core-x.x.x.jar&lt;/code&gt;和其&lt;code&gt;XML&lt;/code&gt;配置文件，通过命令行运行。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Ant&lt;/code&gt;的&lt;code&gt;Task&lt;/code&gt;结合其&lt;code&gt;XML&lt;/code&gt;配置文件运行。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Maven&lt;/code&gt;插件运行。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Java&lt;/code&gt;代码和其&lt;code&gt;XML&lt;/code&gt;配置文件运行。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Java&lt;/code&gt;代码和编程式配置运行。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Eclipse Feature&lt;/code&gt;运行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里只介绍通过&lt;code&gt;Maven&lt;/code&gt;插件运行和通过&lt;code&gt;Java&lt;/code&gt;代码和其&lt;code&gt;XML&lt;/code&gt;配置文件运行这两种方式，两种方式有个特点：都要提前编写好&lt;code&gt;XML&lt;/code&gt;配置文件。个人感觉&lt;code&gt;XML&lt;/code&gt;配置文件相对直观，后文会花大量篇幅去说明&lt;code&gt;XML&lt;/code&gt;配置文件中的配置项及其作用。这里先注意一点：默认的配置文件为&lt;code&gt;ClassPath:generatorConfig.xml&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;通过编码和配置文件运行&quot;&gt;通过编码和配置文件运行&lt;/h3&gt;
&lt;p&gt;通过编码方式去运行插件先需要引入&lt;code&gt;mybatis-generator-core&lt;/code&gt;依赖，编写本文的时候最新的版本为：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-generator-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设编写好的&lt;code&gt;XML&lt;/code&gt;配置文件是&lt;code&gt;ClassPath&lt;/code&gt;下的&lt;code&gt;generator-configuration.xml&lt;/code&gt;，那么使用代码生成器的编码方式大致如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; warnings = new ArrayList&amp;lt;&amp;gt;();
// 如果已经存在生成过的文件是否进行覆盖
boolean overwrite = true;
File configFile = new File(&quot;ClassPath路径/generator-configuration.xml&quot;);
ConfigurationParser cp = new ConfigurationParser(warnings);
Configuration config = cp.parseConfiguration(configFile);
DefaultShellCallback callback = new DefaultShellCallback(overwrite);
MyBatisGenerator generator = new MyBatisGenerator(config, callback, warnings);
generator.generate(null);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过maven插件运行&quot;&gt;通过Maven插件运行&lt;/h3&gt;
&lt;p&gt;如果使用&lt;code&gt;Maven&lt;/code&gt;插件，那么&lt;strong&gt;不需要&lt;/strong&gt;引入&lt;code&gt;mybatis-generator-core&lt;/code&gt;依赖，只需要引入一个&lt;code&gt;Maven&lt;/code&gt;的插件&lt;code&gt;mybatis-generator-maven-plugin&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;plugins&amp;gt;
    &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.4.0&amp;lt;/version&amp;gt;
        &amp;lt;executions&amp;gt;
            &amp;lt;execution&amp;gt;
                &amp;lt;id&amp;gt;Generate MyBatis Artifacts&amp;lt;/id&amp;gt;
                &amp;lt;goals&amp;gt;
                    &amp;lt;goal&amp;gt;generate&amp;lt;/goal&amp;gt;
                &amp;lt;/goals&amp;gt;
            &amp;lt;/execution&amp;gt;
        &amp;lt;/executions&amp;gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;!-- 输出详细信息 --&amp;gt;
            &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;
            &amp;lt;!-- 覆盖生成文件 --&amp;gt;
            &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
            &amp;lt;!-- 定义配置文件 --&amp;gt;
            &amp;lt;configurationFile&amp;gt;${basedir}/src/main/resources/generator-configuration.xml&amp;lt;/configurationFile&amp;gt;
        &amp;lt;/configuration&amp;gt;
    &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mybatis-generator-maven-plugin&lt;/code&gt;的更详细配置和可选参数可以参考：&lt;a href=&quot;http://mybatis.org/generator/running/runningWithMaven.html&quot;&gt;Running With Maven&lt;/a&gt;。插件配置完毕之后，使用下面的命令即可运行：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mvn mybatis-generator:generate&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;xml配置文件详解&quot;&gt;XML配置文件详解&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;XML&lt;/code&gt;配置文件才是&lt;code&gt;Mybatis-Generator&lt;/code&gt;的核心，它用于控制代码生成的所有行为。所有非标签独有的公共配置的&lt;code&gt;Key&lt;/code&gt;可以在&lt;code&gt;mybatis-generator-core&lt;/code&gt;的&lt;code&gt;PropertyRegistry&lt;/code&gt;类中找到。下面是一个相对完整的配置文件的模板：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&amp;gt;

&amp;lt;generatorConfiguration&amp;gt;

  &amp;lt;properties resource=&quot;db.properties&quot;/&amp;gt;

  &amp;lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&amp;gt;

  &amp;lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&amp;gt;

    &amp;lt;jdbcConnection driverClass=&quot;COM.ibm.db2.jdbc.app.DB2Driver&quot;
        connectionURL=&quot;jdbc:db2:TEST&quot;
        userId=&quot;db2admin&quot;
        password=&quot;db2admin&quot;&amp;gt;
    &amp;lt;/jdbcConnection&amp;gt;

    &amp;lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&amp;gt;

    &amp;lt;commentGenerator&amp;gt;
        &amp;lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;/commentGenerator&amp;gt;

    &amp;lt;javaTypeResolver&amp;gt;
      &amp;lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&amp;gt;
    &amp;lt;/javaTypeResolver&amp;gt;

    &amp;lt;javaModelGenerator targetPackage=&quot;test.model&quot; targetProject=&quot;\MBGTestProject\src&quot;&amp;gt;
      &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&amp;gt;
      &amp;lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&amp;gt;
    &amp;lt;/javaModelGenerator&amp;gt;

    &amp;lt;sqlMapGenerator targetPackage=&quot;test.xml&quot;  targetProject=&quot;\MBGTestProject\src&quot;&amp;gt;
      &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&amp;gt;
    &amp;lt;/sqlMapGenerator&amp;gt;

    &amp;lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;test.dao&quot;  targetProject=&quot;\MBGTestProject\src&quot;&amp;gt;
      &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&amp;gt;
    &amp;lt;/javaClientGenerator&amp;gt;

    &amp;lt;table schema=&quot;DB2ADMIN&quot; tableName=&quot;ALLTYPES&quot; domainObjectName=&quot;Customer&quot; &amp;gt;
      &amp;lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&amp;gt;
      &amp;lt;generatedKey column=&quot;ID&quot; sqlStatement=&quot;DB2&quot; identity=&quot;true&quot; /&amp;gt;
      &amp;lt;columnOverride column=&quot;DATE_FIELD&quot; property=&quot;startDate&quot; /&amp;gt;
      &amp;lt;ignoreColumn column=&quot;FRED&quot; /&amp;gt;
      &amp;lt;columnOverride column=&quot;LONG_VARCHAR_FIELD&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
    &amp;lt;/table&amp;gt;

  &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件中，最外层的标签为&lt;code&gt;&amp;lt;generatorConfiguration&amp;gt;&lt;/code&gt;，它的子标签包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0或者1个&lt;code&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;标签，用于指定全局配置文件，下面可以通过占位符的形式读取&lt;code&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;指定文件中的值。&lt;/li&gt;
&lt;li&gt;0或者N个&lt;code&gt;&amp;lt;classPathEntry&amp;gt;&lt;/code&gt;标签，&lt;code&gt;&amp;lt;classPathEntry&amp;gt;&lt;/code&gt;只有一个&lt;code&gt;location&lt;/code&gt;属性，用于指定数据源驱动包（&lt;code&gt;jar&lt;/code&gt;或者&lt;code&gt;zip&lt;/code&gt;）的绝对路径，具体选择什么驱动包取决于连接什么类型的数据源。&lt;/li&gt;
&lt;li&gt;1或者N个&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;标签，用于运行时的解析模式和具体的代码生成行为，所以这个标签里面的配置是最重要的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面分别列举和分析一下&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;标签和它的主要子标签的一些属性配置和功能。&lt;/p&gt;
&lt;h3 id=&quot;context标签&quot;&gt;context标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;标签在&lt;code&gt;mybatis-generator-core&lt;/code&gt;中对应的实现类为&lt;code&gt;org.mybatis.generator.config.Context&lt;/code&gt;，它除了大量的子标签配置之外，比较主要的属性是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;id&lt;/code&gt;：&lt;code&gt;Context&lt;/code&gt;示例的唯一&lt;code&gt;ID&lt;/code&gt;，用于输出错误信息时候作为唯一标记。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;targetRuntime&lt;/code&gt;：用于执行代码生成模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defaultModelType&lt;/code&gt;：控制&lt;code&gt;Domain&lt;/code&gt;类的生成行为。执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置，可选值：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;conditional&lt;/code&gt;：默认值，类似&lt;code&gt;hierarchical&lt;/code&gt;，但是只有一个主键的时候会合并所有属性生成在同一个类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flat&lt;/code&gt;：所有内容全部生成在一个对象中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hierarchical&lt;/code&gt;：键生成一个XXKey对象，Blob等单独生成一个对象，其他简单属性在一个对象中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;targetRuntime&lt;/code&gt;属性的可选值比较多，这里做个简单的小结：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值，兼容&lt;code&gt;JDK8+&lt;/code&gt;和&lt;code&gt;MyBatis 3.4.2+&lt;/code&gt;，不会生成&lt;code&gt;XML&lt;/code&gt;映射文件，忽略&lt;code&gt;&amp;lt;sqlMapGenerator&amp;gt;&lt;/code&gt;的配置项，也就是&lt;code&gt;Mapper&lt;/code&gt;全部注解化，依赖于&lt;code&gt;MyBatis Dynamic SQL&lt;/code&gt;类库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行为类似于&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;，不过兼容&lt;code&gt;Kotlin&lt;/code&gt;的代码生成&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;MyBatis3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;提供基本的基于动态&lt;code&gt;SQL&lt;/code&gt;的&lt;code&gt;CRUD&lt;/code&gt;方法和&lt;code&gt;XXXByExample&lt;/code&gt;方法，会生成&lt;code&gt;XML&lt;/code&gt;映射文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;MyBatis3Simple&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;提供基本的基于动态&lt;code&gt;SQL&lt;/code&gt;的&lt;code&gt;CRUD&lt;/code&gt;方法，会生成&lt;code&gt;XML&lt;/code&gt;映射文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;MyBatis3DynamicSqlV1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;已经过时，不推荐使用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;笔者偏向于把&lt;code&gt;SQL&lt;/code&gt;文件和代码分离，所以一般选用&lt;code&gt;MyBatis3&lt;/code&gt;或者&lt;code&gt;MyBatis3Simple&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;标签支持0或N个&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;标签，&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;的可选属性有：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;autoDelimitKeywords&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否使用分隔符号括住数据库关键字&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;code&gt;MySQL&lt;/code&gt;中会使用反引号括住关键字&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;beginningDelimiter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;分隔符号的开始符号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&quot;&lt;/code&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;endingDelimiter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;分隔符号的结束号&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&quot;&lt;/code&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;javaFileEncoding&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文件的编码&lt;/td&gt;
&lt;td&gt;&lt;code&gt;系统默认值&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;来源于&lt;code&gt;java.nio.charset.Charset&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;javaFormatter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;类名和文件格式化器&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DefaultJavaFormatter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;见&lt;code&gt;JavaFormatter&lt;/code&gt;和&lt;code&gt;DefaultJavaFormatter&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;targetJava8&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否JDK8和启动其特性&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;kotlinFileEncoding&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Kotlin&lt;/code&gt;文件编码&lt;/td&gt;
&lt;td&gt;&lt;code&gt;系统默认值&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;来源于&lt;code&gt;java.nio.charset.Charset&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;kotlinFormatter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Kotlin&lt;/code&gt;类名和文件格式化器&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DefaultKotlinFormatter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;见&lt;code&gt;KotlinFormatter&lt;/code&gt;和&lt;code&gt;DefaultKotlinFormatter&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;xmlFormatter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;XML&lt;/code&gt;文件格式化器&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DefaultXmlFormatter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;见&lt;code&gt;XmlFormatter&lt;/code&gt;和&lt;code&gt;DefaultXmlFormatter&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;jdbcconnection标签&quot;&gt;jdbcConnection标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;jdbcConnection&amp;gt;&lt;/code&gt;标签用于&lt;strong&gt;指定数据源的连接信息&lt;/strong&gt;，它在&lt;code&gt;mybatis-generator-core&lt;/code&gt;中对应的实现类为&lt;code&gt;org.mybatis.generator.config.JDBCConnectionConfiguration&lt;/code&gt;，主要属性包括：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;driverClass&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数据源驱动的全类名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;connectionURL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;JDBC&lt;/code&gt;的连接&lt;code&gt;URL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;userId&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;连接到数据源的用户名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;password&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;连接到数据源的密码&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;commentGenerator&amp;gt;&lt;/code&gt;标签是可选的，用于&lt;strong&gt;控制生成的实体的注释内容&lt;/strong&gt;。它在&lt;code&gt;mybatis-generator-core&lt;/code&gt;中对应的实现类为&lt;code&gt;org.mybatis.generator.internal.DefaultCommentGenerator&lt;/code&gt;，可以通过可选的&lt;code&gt;type&lt;/code&gt;属性指定一个自定义的&lt;code&gt;CommentGenerator&lt;/code&gt;实现。&lt;code&gt;&amp;lt;commentGenerator&amp;gt;&lt;/code&gt;标签支持0或N个&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;标签，&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;的可选属性有：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;suppressAllComments&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否生成注释&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;suppressDate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否在注释中添加生成的时间戳&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;dateFormat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;配合&lt;code&gt;suppressDate&lt;/code&gt;使用，指定输出时间戳的格式&lt;/td&gt;
&lt;td&gt;&lt;code&gt;java.util.Date#toString()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;addRemarkComments&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否输出表和列的&lt;code&gt;Comment&lt;/code&gt;信息&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;笔者建议保持默认值，也就是什么注释都不输出，生成代码干净的实体。&lt;/p&gt;
&lt;h3 id=&quot;javatyperesolver标签&quot;&gt;javaTypeResolver标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;javaTypeResolver&amp;gt;&lt;/code&gt;标签是&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;的子标签，用于解析和计算数据库列类型和&lt;code&gt;Java&lt;/code&gt;类型的映射关系，该标签只包含一个&lt;code&gt;type&lt;/code&gt;属性，用于指定&lt;code&gt;org.mybatis.generator.api.JavaTypeResolver&lt;/code&gt;接口的实现类。&lt;code&gt;&amp;lt;javaTypeResolver&amp;gt;&lt;/code&gt;标签支持0或N个&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;标签，&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;的可选属性有：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;forceBigDecimals&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否强制把所有的数字类型强制使用&lt;code&gt;java.math.BigDecimal&lt;/code&gt;类型表示&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;useJSR310Types&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否支持&lt;code&gt;JSR310&lt;/code&gt;，主要是&lt;code&gt;JSR310&lt;/code&gt;的新日期类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果&lt;code&gt;useJSR310Types&lt;/code&gt;属性设置为&lt;code&gt;true&lt;/code&gt;，那么生成代码的时候类型映射关系如下（主要针对日期时间类型）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;DATE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;java.time.LocalDate&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;TIME&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;java.time.LocalTime&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;java.time.LocalDateTime&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;TIME_WITH_TIMEZONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;java.time.OffsetTime&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;TIMESTAMP_WITH_TIMEZONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;java.time.OffsetDateTime&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;引入&lt;code&gt;mybatis-generator-core&lt;/code&gt;后，可以查看&lt;code&gt;JavaTypeResolver&lt;/code&gt;的默认实现为&lt;code&gt;JavaTypeResolverDefaultImpl&lt;/code&gt;，从它的源码可以得知一些映射关系：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;BIGINT --&amp;gt; Long
BIT --&amp;gt; Boolean
INTEGER --&amp;gt; Integer
SMALLINT --&amp;gt; Short
TINYINT --&amp;gt; Byte
......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有些时候，我们希望&lt;code&gt;INTEGER&lt;/code&gt;、&lt;code&gt;SMALLINT&lt;/code&gt;和&lt;code&gt;TINYINT&lt;/code&gt;都映射为&lt;code&gt;Integer&lt;/code&gt;，那么我们需要覆盖&lt;code&gt;JavaTypeResolverDefaultImpl&lt;/code&gt;的构造方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DefaultJavaTypeResolver extends JavaTypeResolverDefaultImpl {

    public DefaultJavaTypeResolver() {
        super();
        typeMap.put(Types.SMALLINT, new JdbcTypeInformation(&quot;SMALLINT&quot;,
                new FullyQualifiedJavaType(Integer.class.getName())));
        typeMap.put(Types.TINYINT, new JdbcTypeInformation(&quot;TINYINT&quot;,
                new FullyQualifiedJavaType(Integer.class.getName())));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意一点的是这种自定义实现&lt;code&gt;JavaTypeResolver&lt;/code&gt;接口的方式使用编程式运行&lt;code&gt;MBG&lt;/code&gt;会相对方便，如果需要使用&lt;code&gt;Maven&lt;/code&gt;插件运行，那么需要把上面的&lt;code&gt;DefaultJavaTypeResolver&lt;/code&gt;类打包到插件中。&lt;/p&gt;
&lt;h3 id=&quot;javamodelgenerator标签&quot;&gt;javaModelGenerator标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;javaModelGenerator标签&amp;gt;&lt;/code&gt;标签是&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;的子标签，主要用于控制实体（&lt;code&gt;Model&lt;/code&gt;）类的代码生成行为。它支持的属性如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;targetPackage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生成的实体类的包名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;code&gt;club.throwable.model&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;targetProject&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生成的实体类文件相对于项目（根目录）的位置&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;code&gt;src/main/java&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;&amp;lt;javaModelGenerator标签&amp;gt;&lt;/code&gt;标签支持0或N个&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;标签，&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;的可选属性有：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;constructorBased&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否生成一个带有所有字段属性的构造函数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;模式下忽略此属性配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;enableSubPackages&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许通过&lt;code&gt;Schema&lt;/code&gt;生成子包&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果为&lt;code&gt;true&lt;/code&gt;，例如包名为&lt;code&gt;club.throwable&lt;/code&gt;，如果&lt;code&gt;Schema&lt;/code&gt;为&lt;code&gt;xyz&lt;/code&gt;，那么实体类文件最终会生成在&lt;code&gt;club.throwable.xyz&lt;/code&gt;目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;exampleTargetPackage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生成的伴随实体类的&lt;code&gt;Example&lt;/code&gt;类的包名&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;exampleTargetProject&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生成的伴随实体类的&lt;code&gt;Example&lt;/code&gt;类文件相对于项目（根目录）的位置&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否不可变&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果为&lt;code&gt;true&lt;/code&gt;，则不会生成&lt;code&gt;Setter&lt;/code&gt;方法，所有字段都使用&lt;code&gt;final&lt;/code&gt;修饰，提供一个带有所有字段属性的构造函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;rootClass&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;为生成的实体类添加父类&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;通过&lt;code&gt;value&lt;/code&gt;指定父类的全类名即可&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;trimStrings&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Setter&lt;/code&gt;方法是否对字符串类型进行一次&lt;code&gt;trim&lt;/code&gt;操作&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;javaclientgenerator标签&quot;&gt;javaClientGenerator标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;javaClientGenerator&amp;gt;&lt;/code&gt;标签是&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;的子标签，主要用于控制&lt;code&gt;Mapper&lt;/code&gt;接口的代码生成行为。它支持的属性如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Mapper&lt;/code&gt;接口生成策略&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;标签的&lt;code&gt;targetRuntime&lt;/code&gt;属性为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时此属性配置忽略&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;targetPackage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生成的&lt;code&gt;Mapper&lt;/code&gt;接口的包名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;code&gt;club.throwable.mapper&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;targetProject&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生成的&lt;code&gt;Mapper&lt;/code&gt;接口文件相对于项目（根目录）的位置&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;code&gt;src/main/java&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;type&lt;/code&gt;属性的可选值如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ANNOTATEDMAPPER&lt;/code&gt;：&lt;code&gt;Mapper&lt;/code&gt;接口生成的时候依赖于注解和&lt;code&gt;SqlProviders&lt;/code&gt;（也就是纯注解实现），不会生成&lt;code&gt;XML&lt;/code&gt;映射文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XMLMAPPER&lt;/code&gt;：&lt;code&gt;Mapper&lt;/code&gt;接口生成接口方法，对应的实现代码生成在&lt;code&gt;XML&lt;/code&gt;映射文件中（也就是纯映射文件实现）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MIXEDMAPPER&lt;/code&gt;：&lt;code&gt;Mapper&lt;/code&gt;接口生成的时候复杂的方法实现生成在&lt;code&gt;XML&lt;/code&gt;映射文件中，而简单的实现通过注解和&lt;code&gt;SqlProviders&lt;/code&gt;实现（也就是注解和映射文件混合实现）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;标签的&lt;code&gt;targetRuntime&lt;/code&gt;属性指定为&lt;code&gt;MyBatis3Simple&lt;/code&gt;的时候，&lt;code&gt;type&lt;/code&gt;只能选用&lt;code&gt;ANNOTATEDMAPPER&lt;/code&gt;或者&lt;code&gt;XMLMAPPER&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;标签的&lt;code&gt;targetRuntime&lt;/code&gt;属性指定为&lt;code&gt;MyBatis3&lt;/code&gt;的时候，&lt;code&gt;type&lt;/code&gt;可以选用&lt;code&gt;ANNOTATEDMAPPER&lt;/code&gt;、&lt;code&gt;XMLMAPPER&lt;/code&gt;或者&lt;code&gt;MIXEDMAPPER&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;&amp;lt;javaClientGenerator&amp;gt;&lt;/code&gt;标签支持0或N个&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;标签，&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;的可选属性有：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;enableSubPackages&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许通过&lt;code&gt;Schema&lt;/code&gt;生成子包&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果为&lt;code&gt;true&lt;/code&gt;，例如包名为&lt;code&gt;club.throwable&lt;/code&gt;，如果&lt;code&gt;Schema&lt;/code&gt;为&lt;code&gt;xyz&lt;/code&gt;，那么&lt;code&gt;Mapper&lt;/code&gt;接口文件最终会生成在&lt;code&gt;club.throwable.xyz&lt;/code&gt;目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;useLegacyBuilder&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否通过&lt;code&gt;SQL Builder&lt;/code&gt;生成动态&lt;code&gt;SQL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;rootInterface&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;为生成的&lt;code&gt;Mapper&lt;/code&gt;接口添加父接口&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;通过&lt;code&gt;value&lt;/code&gt;指定父接口的全类名即可&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;sqlmapgenerator标签&quot;&gt;sqlMapGenerator标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;sqlMapGenerator&amp;gt;&lt;/code&gt;标签是&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;的子标签，主要用于控制&lt;code&gt;XML&lt;/code&gt;映射文件的代码生成行为。它支持的属性如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;targetPackage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生成的&lt;code&gt;XML&lt;/code&gt;映射文件的包名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;code&gt;mappings&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;targetProject&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生成的&lt;code&gt;XML&lt;/code&gt;映射文件相对于项目（根目录）的位置&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;code&gt;src/main/resources&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;&amp;lt;sqlMapGenerator&amp;gt;&lt;/code&gt;标签支持0或N个&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;标签，&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;的可选属性有：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;enableSubPackages&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许通过&lt;code&gt;Schema&lt;/code&gt;生成子包&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;plugin标签&quot;&gt;plugin标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;plugin&amp;gt;&lt;/code&gt;标签是&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;的子标签，用于引入一些插件对代码生成的一些特性进行扩展，该标签只包含一个&lt;code&gt;type&lt;/code&gt;属性，用于指定&lt;code&gt;org.mybatis.generator.api.Plugin&lt;/code&gt;接口的实现类。内置的插件实现见&lt;a href=&quot;http://mybatis.org/generator/reference/plugins.html&quot;&gt;Supplied Plugins&lt;/a&gt;。例如：引入&lt;code&gt;org.mybatis.generator.plugins.SerializablePlugin&lt;/code&gt;插件会让生成的实体类自动实现&lt;code&gt;java.io.Serializable&lt;/code&gt;接口并且添加&lt;code&gt;serialVersionUID&lt;/code&gt;属性。&lt;/p&gt;
&lt;h3 id=&quot;table标签&quot;&gt;table标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;标签是&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;的子标签，主要用于配置要生成代码的数据库表格，定制一些代码生成行为等等。它支持的属性众多，列举如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;33&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;tableName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数据库表名称&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;code&gt;t_order&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;schema&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数据库&lt;code&gt;Schema&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;catalog&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数据库&lt;code&gt;Catalog&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;alias&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表名称标签&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果指定了此值，则查询列的时候结果格式为&lt;code&gt;alias_column&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;domainObjectName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表对应的实体类名称，可以通过&lt;code&gt;.&lt;/code&gt;指定包路径&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果指定了&lt;code&gt;bar.User&lt;/code&gt;，则包名为&lt;code&gt;bar&lt;/code&gt;，实体类名称为&lt;code&gt;User&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;mapperName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表对应的&lt;code&gt;Mapper&lt;/code&gt;接口类名称，可以通过&lt;code&gt;.&lt;/code&gt;指定包路径&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果指定了&lt;code&gt;bar.UserMapper&lt;/code&gt;，则包名为&lt;code&gt;bar&lt;/code&gt;，&lt;code&gt;Mapper&lt;/code&gt;接口类名称为&lt;code&gt;UserMapper&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;sqlProviderName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;动态&lt;code&gt;SQL&lt;/code&gt;提供类&lt;code&gt;SqlProvider&lt;/code&gt;的类名称&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;enableInsert&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许生成&lt;code&gt;insert&lt;/code&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值为&lt;code&gt;true&lt;/code&gt;，执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;enableSelectByPrimaryKey&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许生成&lt;code&gt;selectByPrimaryKey&lt;/code&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值为&lt;code&gt;true&lt;/code&gt;，执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;enableSelectByExample&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许生成&lt;code&gt;selectByExample&lt;/code&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值为&lt;code&gt;true&lt;/code&gt;，执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;enableUpdateByPrimaryKey&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许生成&lt;code&gt;updateByPrimaryKey&lt;/code&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值为&lt;code&gt;true&lt;/code&gt;，执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;enableDeleteByPrimaryKey&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许生成&lt;code&gt;deleteByPrimaryKey&lt;/code&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值为&lt;code&gt;true&lt;/code&gt;，执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;enableDeleteByExample&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许生成&lt;code&gt;deleteByExample&lt;/code&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值为&lt;code&gt;true&lt;/code&gt;，执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;enableCountByExample&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许生成&lt;code&gt;countByExample&lt;/code&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值为&lt;code&gt;true&lt;/code&gt;，执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;enableUpdateByExample&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许生成&lt;code&gt;updateByExample&lt;/code&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值为&lt;code&gt;true&lt;/code&gt;，执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;code&gt;selectByPrimaryKeyQueryId&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;value&lt;/code&gt;指定对应的主键列提供列表查询功能&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;selectByExampleQueryId&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;value&lt;/code&gt;指定对应的查询&lt;code&gt;ID&lt;/code&gt;提供列表查询功能&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行引擎为&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;或者&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;时忽略此配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;modelType&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;覆盖&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;的&lt;code&gt;defaultModelType&lt;/code&gt;属性&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;见&lt;code&gt;&amp;lt;context&amp;gt;&lt;/code&gt;的&lt;code&gt;defaultModelType&lt;/code&gt;属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;escapeWildcards&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否对通配符进行转义&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;delimitIdentifiers&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标记匹配表名称的时候是否需要使用分隔符去标记生成的SQL&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;delimitAllColumns&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否所有的列都添加分隔符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认值为&lt;code&gt;false&lt;/code&gt;，如果设置为&lt;code&gt;true&lt;/code&gt;，所有列名会添加起始和结束分隔符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;标签支持0或N个&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;标签，&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;的可选属性有：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;24&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;constructorBased&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否为实体类生成一个带有所有字段的构造函数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行引擎为&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;的时候此属性忽略&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;code&gt;ignoreQualifiersAtRuntime&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否在运行时忽略别名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果为&lt;code&gt;true&lt;/code&gt;，则不会在生成表的时候把&lt;code&gt;schema&lt;/code&gt;和&lt;code&gt;catalog&lt;/code&gt;作为表的前缀&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;实体类是否不可变&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行引擎为&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;的时候此属性忽略&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;modelOnly&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否仅仅生成实体类&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;rootClass&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果配置此属性，则实体类会继承此指定的超类&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果有主键属性会把主键属性在超类生成&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;rootInterface&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果配置此属性，则实体类会实现此指定的接口&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行引擎为&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;或者&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;的时候此属性忽略&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;runtimeCatalog&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定运行时的&lt;code&gt;Catalog&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当生成表和运行时的表的&lt;code&gt;Catalog&lt;/code&gt;不一样的时候可以使用该属性进行配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;runtimeSchema&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定运行时的&lt;code&gt;Schema&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当生成表和运行时的表的&lt;code&gt;Schema&lt;/code&gt;不一样的时候可以使用该属性进行配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;runtimeTableName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定运行时的表名称&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当生成表和运行时的表的表名称不一样的时候可以使用该属性进行配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;selectAllOrderByClause&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定字句内容添加到&lt;code&gt;selectAll()&lt;/code&gt;方法的&lt;code&gt;order by&lt;/code&gt;子句之中&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行引擎为&lt;code&gt;MyBatis3Simple&lt;/code&gt;的时候此属性才适用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;trimStrings&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;实体类的字符串类型属性会做&lt;code&gt;trim&lt;/code&gt;处理&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行引擎为&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;的时候此属性忽略&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;useActualColumnNames&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否使用列名作为实体类的属性名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;useColumnIndexes&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;XML&lt;/code&gt;映射文件中生成的&lt;code&gt;ResultMap&lt;/code&gt;使用列索引定义而不是列名称&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行引擎为&lt;code&gt;MyBatis3Kotlin&lt;/code&gt;或者&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt;的时候此属性忽略&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;useCompoundPropertyNames&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否把列名和列备注拼接起来生成实体类属性名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;标签还支持众多的&lt;strong&gt;非&lt;/strong&gt;&lt;code&gt;property&lt;/code&gt;的子标签：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0或1个&lt;code&gt;&amp;lt;generatedKey&amp;gt;&lt;/code&gt;用于指定主键生成的规则，指定此标签后会生成一个&lt;code&gt;&amp;lt;selectKey&amp;gt;&lt;/code&gt;标签：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- column：指定主键列 --&amp;gt;
&amp;lt;!-- sqlStatement：查询主键的SQL语句，例如填写了MySql，则使用SELECT LAST_INSERT_ID() --&amp;gt;
&amp;lt;!-- type：可选值为pre或者post，pre指定selectKey标签的order为BEFORE，post指定selectKey标签的order为AFTER --&amp;gt;
&amp;lt;!-- identity：true的时候，指定selectKey标签的order为AFTER --&amp;gt;
&amp;lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; type=&quot;post&quot; identity=&quot;true&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;0或1个&lt;code&gt;&amp;lt;domainObjectRenamingRule&amp;gt;&lt;/code&gt;用于指定实体类重命名规则：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- searchString中正则命中的实体类名部分会替换为replaceString --&amp;gt;
&amp;lt;domainObjectRenamingRule searchString=&quot;^Sys&quot; replaceString=&quot;&quot;/&amp;gt;
&amp;lt;!-- 例如 SysUser会变成User --&amp;gt;
&amp;lt;!-- 例如 SysUserMapper会变成UserMapper --&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;0或1个&lt;code&gt;&amp;lt;columnRenamingRule&amp;gt;&lt;/code&gt;用于指定列重命名规则：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- searchString中正则命中的列名部分会替换为replaceString --&amp;gt;
&amp;lt;columnRenamingRule searchString=&quot;^CUST_&quot; replaceString=&quot;&quot;/&amp;gt;
&amp;lt;!-- 例如 CUST_BUSINESS_NAME会变成BUSINESS_NAME（useActualColumnNames=true） --&amp;gt;
&amp;lt;!-- 例如 CUST_BUSINESS_NAME会变成businessName（useActualColumnNames=false） --&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;0或N个&lt;code&gt;&amp;lt;columnOverride&amp;gt;&lt;/code&gt;用于指定具体列的覆盖映射规则：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- column：指定要覆盖配置的列 --&amp;gt;
&amp;lt;!-- property：指定要覆盖配置的属性 --&amp;gt;
&amp;lt;!-- delimitedColumnName：是否为列名添加定界符，例如`{column}` --&amp;gt;
&amp;lt;!-- isGeneratedAlways：是否一定生成此列 --&amp;gt;
&amp;lt;columnOverride column=&quot;customer_name&quot; property=&quot;customerName&quot; javaType=&quot;&quot; jdbcType=&quot;&quot; typeHandler=&quot;&quot; delimitedColumnName=&quot;&quot; isGeneratedAlways=&quot;&quot;&amp;gt;
   &amp;lt;!-- 覆盖table或者javaModelGenerator级别的trimStrings属性配置 --&amp;gt;
   &amp;lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&amp;gt;
&amp;lt;columnOverride/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;0或N个&lt;code&gt;&amp;lt;ignoreColumn&amp;gt;&lt;/code&gt;用于指定忽略生成的列：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;ignoreColumn column=&quot;version&quot; delimitedColumnName=&quot;false&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战&quot;&gt;实战&lt;/h2&gt;
&lt;p&gt;如果需要深度定制一些代码生成行为，建议引入&lt;code&gt;mybatis-generator-core&lt;/code&gt;并且通过编程式执行代码生成方法，否则可以选用&lt;code&gt;Maven&lt;/code&gt;插件。假设我们在本地数据&lt;code&gt;local&lt;/code&gt;有一张&lt;code&gt;t_order&lt;/code&gt;表如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `t_order`
(
    id           BIGINT UNSIGNED PRIMARY KEY COMMENT '主键',
    order_id     VARCHAR(64)    NOT NULL COMMENT '订单ID',
    create_time  DATETIME       NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    amount       DECIMAL(10, 2) NOT NULL DEFAULT 0 COMMENT '金额',
    order_status TINYINT        NOT NULL DEFAULT 0 COMMENT '订单状态',
    UNIQUE uniq_order_id (`order_id`)
) COMMENT '订单表';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设项目的结构如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mbg-sample
  - main
   - java
    - club
     - throwable
   - resources&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面会基于此前提举三个例子。编写基础的&lt;code&gt;XML&lt;/code&gt;配置文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&amp;gt;
&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;!-- 驱动包绝对路径 --&amp;gt;
    &amp;lt;classPathEntry
            location=&quot;I:\Develop\Maven-Repository\mysql\mysql-connector-java\5.1.48\mysql-connector-java-5.1.48.jar&quot;/&amp;gt;

    &amp;lt;context id=&quot;default&quot; targetRuntime=&quot;这里选择合适的引擎&quot;&amp;gt;

        &amp;lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&amp;gt;

        &amp;lt;!-- 不输出注释 --&amp;gt;
        &amp;lt;commentGenerator&amp;gt;
            &amp;lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&amp;gt;
            &amp;lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;/commentGenerator&amp;gt;

        &amp;lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/local&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&amp;gt;
        &amp;lt;/jdbcConnection&amp;gt;


        &amp;lt;!-- 不强制把所有的数字类型转化为BigDecimal --&amp;gt;
        &amp;lt;javaTypeResolver&amp;gt;
            &amp;lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&amp;gt;
        &amp;lt;/javaTypeResolver&amp;gt;

        &amp;lt;javaModelGenerator targetPackage=&quot;club.throwable.entity&quot; targetProject=&quot;src/main/java&quot;&amp;gt;
            &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;/javaModelGenerator&amp;gt;

        &amp;lt;sqlMapGenerator targetPackage=&quot;mappings&quot; targetProject=&quot;src/main/resources&quot;&amp;gt;
            &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;/sqlMapGenerator&amp;gt;

        &amp;lt;javaClientGenerator type=&quot;这里选择合适的Mapper类型&quot; targetPackage=&quot;club.throwable.dao&quot; targetProject=&quot;src/main/java&quot;&amp;gt;
            &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;/javaClientGenerator&amp;gt;

        &amp;lt;table tableName=&quot;t_order&quot;
               enableCountByExample=&quot;false&quot;
               enableDeleteByExample=&quot;false&quot;
               enableSelectByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot;
               domainObjectName=&quot;Order&quot;
               mapperName=&quot;OrderMapper&quot;&amp;gt;
            &amp;lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot;/&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;纯注解&quot;&gt;纯注解&lt;/h3&gt;
&lt;p&gt;使用纯注解需要引入&lt;code&gt;mybatis-dynamic-sql&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.dynamic-sql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-dynamic-sql&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要修改两个位置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3DynamicSql&quot;&amp;gt;
...

&amp;lt;javaClientGenerator type=&quot;ANNOTATEDMAPPER&quot;
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果会生成三个类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// club.throwable.entity
public class Order {
    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    private Long id;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    private String orderId;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    private Date createTime;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    private BigDecimal amount;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    private Byte orderStatus;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public Long getId() {
        return id;
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public void setId(Long id) {
        this.id = id;
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public String getOrderId() {
        return orderId;
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public void setOrderId(String orderId) {
        this.orderId = orderId;
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public Date getCreateTime() {
        return createTime;
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public BigDecimal getAmount() {
        return amount;
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public void setAmount(BigDecimal amount) {
        this.amount = amount;
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public Byte getOrderStatus() {
        return orderStatus;
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public void setOrderStatus(Byte orderStatus) {
        this.orderStatus = orderStatus;
    }
}

// club.throwable.dao
public final class OrderDynamicSqlSupport {
    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public static final Order order = new Order();

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public static final SqlColumn&amp;lt;Long&amp;gt; id = order.id;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public static final SqlColumn&amp;lt;String&amp;gt; orderId = order.orderId;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public static final SqlColumn&amp;lt;Date&amp;gt; createTime = order.createTime;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public static final SqlColumn&amp;lt;BigDecimal&amp;gt; amount = order.amount;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public static final SqlColumn&amp;lt;Byte&amp;gt; orderStatus = order.orderStatus;

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    public static final class Order extends SqlTable {
        public final SqlColumn&amp;lt;Long&amp;gt; id = column(&quot;id&quot;, JDBCType.BIGINT);

        public final SqlColumn&amp;lt;String&amp;gt; orderId = column(&quot;order_id&quot;, JDBCType.VARCHAR);

        public final SqlColumn&amp;lt;Date&amp;gt; createTime = column(&quot;create_time&quot;, JDBCType.TIMESTAMP);

        public final SqlColumn&amp;lt;BigDecimal&amp;gt; amount = column(&quot;amount&quot;, JDBCType.DECIMAL);

        public final SqlColumn&amp;lt;Byte&amp;gt; orderStatus = column(&quot;order_status&quot;, JDBCType.TINYINT);

        public Order() {
            super(&quot;t_order&quot;);
        }
    }
}

@Mapper
public interface OrderMapper {
    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    BasicColumn[] selectList = BasicColumn.columnList(id, orderId, createTime, amount, orderStatus);

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    @SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
    long count(SelectStatementProvider selectStatement);

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    @DeleteProvider(type=SqlProviderAdapter.class, method=&quot;delete&quot;)
    int delete(DeleteStatementProvider deleteStatement);

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    @InsertProvider(type=SqlProviderAdapter.class, method=&quot;insert&quot;)
    @SelectKey(statement=&quot;SELECT LAST_INSERT_ID()&quot;, keyProperty=&quot;record.id&quot;, before=true, resultType=Long.class)
    int insert(InsertStatementProvider&amp;lt;Order&amp;gt; insertStatement);

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    @SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
    @Results(id=&quot;OrderResult&quot;, value = {
        @Result(column=&quot;id&quot;, property=&quot;id&quot;, jdbcType=JdbcType.BIGINT, id=true),
        @Result(column=&quot;order_id&quot;, property=&quot;orderId&quot;, jdbcType=JdbcType.VARCHAR),
        @Result(column=&quot;create_time&quot;, property=&quot;createTime&quot;, jdbcType=JdbcType.TIMESTAMP),
        @Result(column=&quot;amount&quot;, property=&quot;amount&quot;, jdbcType=JdbcType.DECIMAL),
        @Result(column=&quot;order_status&quot;, property=&quot;orderStatus&quot;, jdbcType=JdbcType.TINYINT)
    })
    Optional&amp;lt;Order&amp;gt; selectOne(SelectStatementProvider selectStatement);

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    @SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
    @Results(id=&quot;OrderResult&quot;, value = {
        @Result(column=&quot;id&quot;, property=&quot;id&quot;, jdbcType=JdbcType.BIGINT, id=true),
        @Result(column=&quot;order_id&quot;, property=&quot;orderId&quot;, jdbcType=JdbcType.VARCHAR),
        @Result(column=&quot;create_time&quot;, property=&quot;createTime&quot;, jdbcType=JdbcType.TIMESTAMP),
        @Result(column=&quot;amount&quot;, property=&quot;amount&quot;, jdbcType=JdbcType.DECIMAL),
        @Result(column=&quot;order_status&quot;, property=&quot;orderStatus&quot;, jdbcType=JdbcType.TINYINT)
    })
    List&amp;lt;Order&amp;gt; selectMany(SelectStatementProvider selectStatement);

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    @UpdateProvider(type=SqlProviderAdapter.class, method=&quot;update&quot;)
    int update(UpdateStatementProvider updateStatement);

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default long count(CountDSLCompleter completer) {
        return MyBatis3Utils.countFrom(this::count, order, completer);
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default int delete(DeleteDSLCompleter completer) {
        return MyBatis3Utils.deleteFrom(this::delete, order, completer);
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default int deleteByPrimaryKey(Long id_) {
        return delete(c -&amp;gt; 
            c.where(id, isEqualTo(id_))
        );
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default int insert(Order record) {
        return MyBatis3Utils.insert(this::insert, record, order, c -&amp;gt;
            c.map(id).toProperty(&quot;id&quot;)
            .map(orderId).toProperty(&quot;orderId&quot;)
            .map(createTime).toProperty(&quot;createTime&quot;)
            .map(amount).toProperty(&quot;amount&quot;)
            .map(orderStatus).toProperty(&quot;orderStatus&quot;)
        );
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default int insertSelective(Order record) {
        return MyBatis3Utils.insert(this::insert, record, order, c -&amp;gt;
            c.map(id).toProperty(&quot;id&quot;)
            .map(orderId).toPropertyWhenPresent(&quot;orderId&quot;, record::getOrderId)
            .map(createTime).toPropertyWhenPresent(&quot;createTime&quot;, record::getCreateTime)
            .map(amount).toPropertyWhenPresent(&quot;amount&quot;, record::getAmount)
            .map(orderStatus).toPropertyWhenPresent(&quot;orderStatus&quot;, record::getOrderStatus)
        );
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default Optional&amp;lt;Order&amp;gt; selectOne(SelectDSLCompleter completer) {
        return MyBatis3Utils.selectOne(this::selectOne, selectList, order, completer);
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default List&amp;lt;Order&amp;gt; select(SelectDSLCompleter completer) {
        return MyBatis3Utils.selectList(this::selectMany, selectList, order, completer);
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default List&amp;lt;Order&amp;gt; selectDistinct(SelectDSLCompleter completer) {
        return MyBatis3Utils.selectDistinct(this::selectMany, selectList, order, completer);
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default Optional&amp;lt;Order&amp;gt; selectByPrimaryKey(Long id_) {
        return selectOne(c -&amp;gt;
            c.where(id, isEqualTo(id_))
        );
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default int update(UpdateDSLCompleter completer) {
        return MyBatis3Utils.update(this::update, order, completer);
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    static UpdateDSL&amp;lt;UpdateModel&amp;gt; updateAllColumns(Order record, UpdateDSL&amp;lt;UpdateModel&amp;gt; dsl) {
        return dsl.set(id).equalTo(record::getId)
                .set(orderId).equalTo(record::getOrderId)
                .set(createTime).equalTo(record::getCreateTime)
                .set(amount).equalTo(record::getAmount)
                .set(orderStatus).equalTo(record::getOrderStatus);
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    static UpdateDSL&amp;lt;UpdateModel&amp;gt; updateSelectiveColumns(Order record, UpdateDSL&amp;lt;UpdateModel&amp;gt; dsl) {
        return dsl.set(id).equalToWhenPresent(record::getId)
                .set(orderId).equalToWhenPresent(record::getOrderId)
                .set(createTime).equalToWhenPresent(record::getCreateTime)
                .set(amount).equalToWhenPresent(record::getAmount)
                .set(orderStatus).equalToWhenPresent(record::getOrderStatus);
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default int updateByPrimaryKey(Order record) {
        return update(c -&amp;gt;
            c.set(orderId).equalTo(record::getOrderId)
            .set(createTime).equalTo(record::getCreateTime)
            .set(amount).equalTo(record::getAmount)
            .set(orderStatus).equalTo(record::getOrderStatus)
            .where(id, isEqualTo(record::getId))
        );
    }

    @Generated(&quot;org.mybatis.generator.api.MyBatisGenerator&quot;)
    default int updateByPrimaryKeySelective(Order record) {
        return update(c -&amp;gt;
            c.set(orderId).equalToWhenPresent(record::getOrderId)
            .set(createTime).equalToWhenPresent(record::getCreateTime)
            .set(amount).equalToWhenPresent(record::getAmount)
            .set(orderStatus).equalToWhenPresent(record::getOrderStatus)
            .where(id, isEqualTo(record::getId))
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;极简xml映射文件&quot;&gt;极简XML映射文件&lt;/h3&gt;
&lt;p&gt;极简&lt;code&gt;XML&lt;/code&gt;映射文件生成只需要简单修改配置文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3Simple&quot;&amp;gt;
...

&amp;lt;javaClientGenerator type=&quot;XMLMAPPER&quot;
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成三个文件：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// club.throwable.entity
public class Order {
    private Long id;

    private String orderId;

    private Date createTime;

    private BigDecimal amount;

    private Byte orderStatus;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getOrderId() {
        return orderId;
    }

    public void setOrderId(String orderId) {
        this.orderId = orderId;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    public BigDecimal getAmount() {
        return amount;
    }

    public void setAmount(BigDecimal amount) {
        this.amount = amount;
    }

    public Byte getOrderStatus() {
        return orderStatus;
    }

    public void setOrderStatus(Byte orderStatus) {
        this.orderStatus = orderStatus;
    }
}

// club.throwable.dao
public interface OrderMapper {
    int deleteByPrimaryKey(Long id);

    int insert(Order record);

    Order selectByPrimaryKey(Long id);

    List&amp;lt;Order&amp;gt; selectAll();

    int updateByPrimaryKey(Order record);
}

// mappings
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;club.throwable.dao.OrderMapper&quot;&amp;gt;
    &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;club.throwable.entity.Order&quot;&amp;gt;
        &amp;lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot;/&amp;gt;
        &amp;lt;result column=&quot;order_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderId&quot;/&amp;gt;
        &amp;lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot;/&amp;gt;
        &amp;lt;result column=&quot;amount&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;amount&quot;/&amp;gt;
        &amp;lt;result column=&quot;order_status&quot; jdbcType=&quot;TINYINT&quot; property=&quot;orderStatus&quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot;&amp;gt;
        delete
        from t_order
        where id = #{id,jdbcType=BIGINT}
    &amp;lt;/delete&amp;gt;
    &amp;lt;insert id=&quot;insert&quot; parameterType=&quot;club.throwable.entity.Order&quot;&amp;gt;
        &amp;lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Long&quot;&amp;gt;
            SELECT LAST_INSERT_ID()
        &amp;lt;/selectKey&amp;gt;
        insert into t_order (order_id, create_time, amount,
        order_status)
        values (#{orderId,jdbcType=VARCHAR}, #{createTime,jdbcType=TIMESTAMP}, #{amount,jdbcType=DECIMAL},
        #{orderStatus,jdbcType=TINYINT})
    &amp;lt;/insert&amp;gt;
    &amp;lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;club.throwable.entity.Order&quot;&amp;gt;
        update t_order
        set order_id     = #{orderId,jdbcType=VARCHAR},
            create_time  = #{createTime,jdbcType=TIMESTAMP},
            amount       = #{amount,jdbcType=DECIMAL},
            order_status = #{orderStatus,jdbcType=TINYINT}
        where id = #{id,jdbcType=BIGINT}
    &amp;lt;/update&amp;gt;
    &amp;lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot;&amp;gt;
        select id, order_id, create_time, amount, order_status
        from t_order
        where id = #{id,jdbcType=BIGINT}
    &amp;lt;/select&amp;gt;
    &amp;lt;select id=&quot;selectAll&quot; resultMap=&quot;BaseResultMap&quot;&amp;gt;
        select id, order_id, create_time, amount, order_status
        from t_order
    &amp;lt;/select&amp;gt;
    &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;club.throwable.entity.Order&quot;&amp;gt;
        &amp;lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot;/&amp;gt;
        &amp;lt;result column=&quot;order_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderId&quot;/&amp;gt;
        &amp;lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot;/&amp;gt;
        &amp;lt;result column=&quot;amount&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;amount&quot;/&amp;gt;
        &amp;lt;result column=&quot;order_status&quot; jdbcType=&quot;TINYINT&quot; property=&quot;orderStatus&quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot;&amp;gt;
        delete
        from t_order
        where id = #{id,jdbcType=BIGINT}
    &amp;lt;/delete&amp;gt;
    &amp;lt;insert id=&quot;insert&quot; parameterType=&quot;club.throwable.entity.Order&quot;&amp;gt;
        &amp;lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.Long&quot;&amp;gt;
            SELECT LAST_INSERT_ID()
        &amp;lt;/selectKey&amp;gt;
        insert into t_order (id, order_id, create_time,
        amount, order_status)
        values (#{id,jdbcType=BIGINT}, #{orderId,jdbcType=VARCHAR}, #{createTime,jdbcType=TIMESTAMP},
        #{amount,jdbcType=DECIMAL}, #{orderStatus,jdbcType=TINYINT})
    &amp;lt;/insert&amp;gt;
    &amp;lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;club.throwable.entity.Order&quot;&amp;gt;
        update t_order
        set order_id     = #{orderId,jdbcType=VARCHAR},
            create_time  = #{createTime,jdbcType=TIMESTAMP},
            amount       = #{amount,jdbcType=DECIMAL},
            order_status = #{orderStatus,jdbcType=TINYINT}
        where id = #{id,jdbcType=BIGINT}
    &amp;lt;/update&amp;gt;
    &amp;lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot;&amp;gt;
        select id, order_id, create_time, amount, order_status
        from t_order
        where id = #{id,jdbcType=BIGINT}
    &amp;lt;/select&amp;gt;
    &amp;lt;select id=&quot;selectAll&quot; resultMap=&quot;BaseResultMap&quot;&amp;gt;
        select id, order_id, create_time, amount, order_status
        from t_order
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编程式自定义类型映射&quot;&gt;编程式自定义类型映射&lt;/h3&gt;
&lt;p&gt;笔者喜欢把所有的非长整型的数字，统一使用&lt;code&gt;Integer&lt;/code&gt;接收，因此需要自定义类型映射。编写映射器如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DefaultJavaTypeResolver extends JavaTypeResolverDefaultImpl {

    public DefaultJavaTypeResolver() {
        super();
        typeMap.put(Types.SMALLINT, new JdbcTypeInformation(&quot;SMALLINT&quot;,
                new FullyQualifiedJavaType(Integer.class.getName())));
        typeMap.put(Types.TINYINT, new JdbcTypeInformation(&quot;TINYINT&quot;,
                new FullyQualifiedJavaType(Integer.class.getName())));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时最好使用编程式运行代码生成器，修改&lt;code&gt;XML&lt;/code&gt;配置文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;javaTypeResolver type=&quot;club.throwable.mbg.DefaultJavaTypeResolver&quot;&amp;gt;
        &amp;lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&amp;gt;
&amp;lt;/javaTypeResolver&amp;gt;
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Main {

    public static void main(String[] args) throws Exception {
        List&amp;lt;String&amp;gt; warnings = new ArrayList&amp;lt;&amp;gt;();
        // 如果已经存在生成过的文件是否进行覆盖
        boolean overwrite = true;
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(Main.class.getResourceAsStream(&quot;/generator-configuration.xml&quot;));
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator generator = new MyBatisGenerator(config, callback, warnings);
        generator.generate(null);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库的&lt;code&gt;order_status&lt;/code&gt;是&lt;code&gt;TINYINT&lt;/code&gt;类型，生成出来的文件中的&lt;code&gt;orderStatus&lt;/code&gt;字段全部替换使用&lt;code&gt;Integer&lt;/code&gt;类型定义。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文相对详尽地介绍了&lt;code&gt;Mybatis Generator&lt;/code&gt;的使用方式，具体分析了&lt;code&gt;XML&lt;/code&gt;配置文件中主要标签以及标签属性的功能。因为&lt;code&gt;Mybatis&lt;/code&gt;在&lt;code&gt;Java&lt;/code&gt;的&lt;code&gt;ORM&lt;/code&gt;框架体系中还会有一段很长的时间处于主流地位，了解&lt;code&gt;Mybatis Generator&lt;/code&gt;可以简化&lt;code&gt;CRUD&lt;/code&gt;方法模板代码、实体以及&lt;code&gt;Mapper&lt;/code&gt;接口代码生成，从而解放大量生产力。&lt;code&gt;Mybatis Generator&lt;/code&gt;有不少第三方的扩展，例如&lt;code&gt;tk.mapper&lt;/code&gt;或者&lt;code&gt;mybatis-plus&lt;/code&gt;自身的扩展，可能附加的功能不一样，但是基本的使用是一致的。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h2 id=&quot;原文链接&quot;&gt;原文链接&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Github Page：http://throwable.club/2019/12/16/mybatis-generator-usage&lt;/li&gt;
&lt;li&gt;Coding Page：http://throwable.coding.me/2019/12/16/mybatis-generator-usage&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（本文完 c-5-d e-a-20191216 1:00）&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 17:11:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 最近在做创业项目的时候因为有比较多的新需求，需要频繁基于 生成 适合的实体、 接口和映射文件。其中，代码生成器是 ，用到了 相关依赖，这里通过一篇文章详细地分析这个代码生成器的使用方式。本文编写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/12046848.html</dc:identifier>
</item>
<item>
<title>使用SQL计算宝宝每次吃奶的时间间隔(续) - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/12046838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/12046838.html</guid>
<description>&lt;p&gt;本文是《&lt;a href=&quot;https://www.cnblogs.com/jyzhao/p/12036186.html&quot;&gt;使用SQL计算宝宝每次吃奶的时间间隔&lt;/a&gt;》的续篇，因为我工作繁忙，时常不能及时帮助媳妇儿记录，为了让不懂数据库的媳妇儿也可以自己用手机熟练操作。我继续做了一些修正和封装：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.给媳妇儿的手机下载一个terminal终端软件termius，实现只需打开app就可以连接到环境；&lt;/li&gt;
&lt;li&gt;2.跟媳妇儿进一步沟通需求，按她能够接受的使用习惯来修正并封装程序，原则是尽可能的简化操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先来看下改进后最终的使用效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--1.手机上打开termius软件，点击进入到终端，输入 h 可以看到所有命令的说明：
[oracle@jystdrac1 ~]$ h
**Command for Baby's feed_time:**
Usage:
 v                      - View Today's Result.
 vv &amp;lt;'mmdd'&amp;gt;            - View one day's Result.
 i                      - Insert a row using current time.
 ii &amp;lt;'mmdd hh24:mi'&amp;gt;    - Insert a row using input time.
 d &amp;lt;id&amp;gt;                 - Delete a mistake row by id. 
 u &amp;lt;label&amp;gt; &amp;lt;id&amp;gt;         - Update a mistake row by id.
 h                      - Help

--2.输入 v 可以看到今天的喂奶时间和间隔：
[oracle@jystdrac1 ~]$ v
View Today's Result:

        ID FEED_TIME   L   LAG(min)     LAG(h)
---------- ----------- - ---------- ----------
        53 12-15 01:00 N        140       2.33
        54 12-15 04:08 N        188       3.13
        55 12-15 07:35 N        207       3.45
        56 12-15 10:40 N        185       3.08
        69 12-15 13:16 N        156        2.6
        70 12-15 14:32 N         76       1.27
        82 12-15 17:14 N        163       2.71
        83 12-15 19:15 N        121       2.01

8 rows selected.

--3.输入 i 可以直接以当前系统时间插入一条数据，并显示插入后的结果：
[oracle@jystdrac1 ~]$ i
Insert a row using current time:

1 row created.


Commit complete.

View Today's Result:

        ID FEED_TIME   L   LAG(min)     LAG(h)
---------- ----------- - ---------- ----------
        53 12-15 01:00 N        140       2.33
        54 12-15 04:08 N        188       3.13
        55 12-15 07:35 N        207       3.45
        56 12-15 10:40 N        185       3.08
        69 12-15 13:16 N        156        2.6
        70 12-15 14:32 N         76       1.27
        82 12-15 17:14 N        163       2.71
        83 12-15 19:15 N        121       2.01
        94 12-15 23:02 N        227       3.78

9 rows selected.

--4.输入 d &amp;lt;id&amp;gt; 可以删除id对应的那行记录，并显示删除后的结果：
[oracle@jystdrac1 ~]$ d 94
Delete a mistake row by id:
Enter value for id: old   1: delete from t_baby where id = &amp;amp;id
new   1: delete from t_baby where id = 94

1 row deleted.


Commit complete.

View Today's Result:

        ID FEED_TIME   L   LAG(min)     LAG(h)
---------- ----------- - ---------- ----------
        53 12-15 01:00 N        140       2.33
        54 12-15 04:08 N        188       3.13
        55 12-15 07:35 N        207       3.45
        56 12-15 10:40 N        185       3.08
        69 12-15 13:16 N        156        2.6
        70 12-15 14:32 N         76       1.27
        82 12-15 17:14 N        163       2.71
        83 12-15 19:15 N        121       2.01

8 rows selected.

--5.输入 u &amp;lt;label&amp;gt; &amp;lt;id&amp;gt; 可以更新指定id的label值，比如将id=55的记录label值修改为'L'，代表这次喂奶量很少，不参与计算
[oracle@jystdrac1 ~]$ u l 55
Update a mistake row by id:
Enter value for label: Enter value for id: old   1: update t_baby set label = upper('&amp;amp;label') where id = &amp;amp;id
new   1: update t_baby set label = upper('l') where id = 55

1 row updated.


Commit complete.

View Today's Result:

        ID FEED_TIME   L   LAG(min)     LAG(h)
---------- ----------- - ---------- ----------
        53 12-15 01:00 N        140       2.33
        54 12-15 04:08 N        188       3.13
        56 12-15 10:40 N        392       6.53
        69 12-15 13:16 N        156        2.6
        70 12-15 14:32 N         76       1.27
        82 12-15 17:14 N        163       2.71
        83 12-15 19:15 N        121       2.01

7 rows selected.

--6.输入 u &amp;lt;label&amp;gt; &amp;lt;id&amp;gt; 可以更新指定id的label值，比如将id=55的记录label值修改回'N',代表这次喂奶量正常，参与计算
[oracle@jystdrac1 ~]$ u n 55
Update a mistake row by id:
Enter value for label: Enter value for id: old   1: update t_baby set label = upper('&amp;amp;label') where id = &amp;amp;id
new   1: update t_baby set label = upper('n') where id = 55

1 row updated.


Commit complete.

View Today's Result:

        ID FEED_TIME   L   LAG(min)     LAG(h)
---------- ----------- - ---------- ----------
        53 12-15 01:00 N        140       2.33
        54 12-15 04:08 N        188       3.13
        55 12-15 07:35 N        207       3.45
        56 12-15 10:40 N        185       3.08
        69 12-15 13:16 N        156        2.6
        70 12-15 14:32 N         76       1.27
        82 12-15 17:14 N        163       2.71
        83 12-15 19:15 N        121       2.01

8 rows selected.

--7.输入 ii &amp;lt;'mmdd hh24:mi'&amp;gt; 可以插入指定日期和时间
[oracle@jystdrac1 ~]$ ii '1215 23:00'
Insert a row using input time(mmdd mi:ss) eg: 1215 10:00
Enter value for feed_time: old   1: insert into t_baby(id,feed_time) values(s1.nextval,to_date('&amp;amp;feed_time','mmdd hh24:mi'))
new   1: insert into t_baby(id,feed_time) values(s1.nextval,to_date('1215 23:00','mmdd hh24:mi'))

1 row created.


Commit complete.

View Today's Result:

        ID FEED_TIME   L   LAG(min)     LAG(h)
---------- ----------- - ---------- ----------
        53 12-15 01:00 N        140       2.33
        54 12-15 04:08 N        188       3.13
        55 12-15 07:35 N        207       3.45
        56 12-15 10:40 N        185       3.08
        69 12-15 13:16 N        156        2.6
        70 12-15 14:32 N         76       1.27
        82 12-15 17:14 N        163       2.71
        83 12-15 19:15 N        121       2.01
        95 12-15 23:00 N        225       3.74

9 rows selected.

--8.删除id=95的这条测试记录
[oracle@jystdrac1 ~]$ d 95
Delete a mistake row by id:
Enter value for id: old   1: delete from t_baby where id = &amp;amp;id
new   1: delete from t_baby where id = 95

1 row deleted.


Commit complete.

View Today's Result:

        ID FEED_TIME   L   LAG(min)     LAG(h)
---------- ----------- - ---------- ----------
        53 12-15 01:00 N        140       2.33
        54 12-15 04:08 N        188       3.13
        55 12-15 07:35 N        207       3.45
        56 12-15 10:40 N        185       3.08
        69 12-15 13:16 N        156        2.6
        70 12-15 14:32 N         76       1.27
        82 12-15 17:14 N        163       2.71
        83 12-15 19:15 N        121       2.01

8 rows selected.

--9.使用 vv 'mmdd' 可以显示指定日期的喂奶间隔情况：
[oracle@jystdrac1 ~]$ vv 1214
View Today's Result:
Enter value for feed_time: Enter value for feed_time: old   2: from (select t.*, lag(feed_time) over(order by id) l_time from t_baby t where label &amp;lt;&amp;gt; 'L') where feed_time &amp;gt;= to_date('&amp;amp;feed_time','mmdd') and feed_time &amp;lt; to_date('&amp;amp;feed_time','mmdd') + 1
new   2: from (select t.*, lag(feed_time) over(order by id) l_time from t_baby t where label &amp;lt;&amp;gt; 'L') where feed_time &amp;gt;= to_date('1214','mmdd') and feed_time &amp;lt; to_date('1214','mmdd') + 1

        ID FEED_TIME   L   LAG(min)     LAG(h)
---------- ----------- - ---------- ----------
        41 12-14 01:55 N        265       4.42
        42 12-14 04:58 N        183       3.05
        43 12-14 08:25 N        207       3.45
        44 12-14 11:23 N        178       2.97
        45 12-14 12:23 N         60          1
        46 12-14 15:00 N        157       2.62
        47 12-14 17:22 N        142       2.37
        48 12-14 18:45 N         83       1.38
        49 12-14 22:40 N        235       3.92

9 rows selected.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过一番演示，媳妇儿的反馈是非常满意的，实际她最常用的还是v和i，非常方便，其他命令偶尔使用，其实只需记住h可以获取到帮助即可。下面将本次的修正和封装过程记录一下：&lt;/p&gt;

&lt;p&gt;为了简化操作，我将环境变量设置一些别名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@jystdrac1 ~]$ cat ~/.bash_profile 
# 这里省略原有环境变量内容,下面为在源文件基础上追加的内容：
# Alias for baby's feed_time:
alias h=/home/oracle/baby_readme.sh
alias v=/home/oracle/baby_view.sh
alias i=/home/oracle/baby_insert.sh
alias d=/home/oracle/baby_delete.sh
alias u=/home/oracle/baby_update.sh
alias ii=/home/oracle/baby_insert_diy.sh
alias vv=/home/oracle/baby_view_diy.sh&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;baby_readme.sh&quot;&gt;baby_readme.sh&lt;/h2&gt;
&lt;p&gt;vi baby_readme.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
# script:baby_readme.sh
# version:1.01
#-------------------------------------------------------------
echo &quot;**Command for Baby's feed_time:**&quot;
echo &quot;Usage:&quot;
echo &quot; v            - View Today's Result.&quot;
echo &quot; vv &amp;lt;'mmdd'&amp;gt;      - View one day's Result.&quot;
echo &quot; i            - Insert a row using current time.&quot;
echo &quot; ii &amp;lt;'mmdd hh24:mi'&amp;gt;  - Insert a row using input time.&quot;
echo &quot; d &amp;lt;id&amp;gt;       - Delete a mistake row by id.&quot;
echo &quot; u &amp;lt;label&amp;gt; &amp;lt;id&amp;gt;   - Update a mistake row by id.&quot;
echo &quot; h - Help&quot;
#-------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;baby_view.sh&quot;&gt;baby_view.sh&lt;/h2&gt;
&lt;p&gt;vi baby_view.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
# script:baby_view.sh
# version:1.01
#-------------------------------------------------------------
sqlplus -S test/test &amp;lt;&amp;lt;EOF
PROMPT View Today's Result:
@v3

EOF
#-------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;baby_insert.sh&quot;&gt;baby_insert.sh&lt;/h2&gt;
&lt;p&gt;vi baby_insert.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
# script:baby_insert.sh
# version:1.01
#-------------------------------------------------------------
sqlplus -S test/test &amp;lt;&amp;lt;EOF
PROMPT Insert a row using current time:
@i1

PROMPT View Today's Result:
@v3

EOF
#-------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;baby_delete.sh&quot;&gt;baby_delete.sh&lt;/h2&gt;
&lt;p&gt;vi baby_delete.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
# script:baby_delete.sh
# version:1.01
#-------------------------------------------------------------
sqlplus -S test/test &amp;lt;&amp;lt;EOF
PROMPT Delete a mistake row by id:
@d1
$1
commit;

PROMPT View Today's Result:
@v3

EOF
#-------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;baby_insert_diy.sh&quot;&gt;baby_insert_diy.sh&lt;/h2&gt;
&lt;p&gt;vi baby_insert_diy.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
# script:baby_insert_diy.sh
# version:1.01
#-------------------------------------------------------------
sqlplus -S test/test &amp;lt;&amp;lt;EOF
PROMPT Insert a row using input time(mmdd mi:ss) eg: 1215 10:00
@i2
$1
commit;

PROMPT View Today's Result:
@v3

EOF
#-------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;baby_update.sh&quot;&gt;baby_update.sh&lt;/h2&gt;
&lt;p&gt;vi baby_update.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
# script:baby_update.sh
# version:1.01
#-------------------------------------------------------------
sqlplus -S test/test &amp;lt;&amp;lt;EOF
PROMPT Update a mistake row by id:
@u1
$1
$2
commit;

PROMPT View Today's Result:
@v3

EOF
#-------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;baby_view_diy.sh&quot;&gt;baby_view_diy.sh&lt;/h2&gt;
&lt;p&gt;vi baby_view_diy.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
# script:baby_view.sh
# version:1.01
#-------------------------------------------------------------
sqlplus -S test/test &amp;lt;&amp;lt;EOF
PROMPT View one day's Result:
@v4
$1
$1

EOF
#-------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;--echo &quot;v - View Today's Result.&quot;
[oracle@jystdrac1 ~]$ cat v3.sql
select id, to_char(feed_time,'mm-dd hh24:mi') &quot;FEED_TIME&quot;, label, round((feed_time - l_time) * 24 * 60) &quot;LAG(min)&quot;, round((feed_time - l_time) * 24, 2) &quot;LAG(h)&quot;
from (select t.*, lag(feed_time) over(order by id) l_time from t_baby t where label &amp;lt;&amp;gt; 'L') where feed_time &amp;gt;= trunc(sysdate)
/

-- echo &quot; vv &amp;lt;'mmdd'&amp;gt;       - View one day's Result.&quot;
[oracle@jystdrac1 ~]$ cat v4.sql 
select id, to_char(feed_time,'mm-dd hh24:mi') &quot;FEED_TIME&quot;, label, round((feed_time - l_time) * 24 * 60) &quot;LAG(min)&quot;, round((feed_time - l_time) * 24, 2) &quot;LAG(h)&quot;
from (select t.*, lag(feed_time) over(order by id) l_time from t_baby t where label &amp;lt;&amp;gt; 'L') where feed_time &amp;gt;= to_date('&amp;amp;feed_time','mmdd') and feed_time &amp;lt; to_date('&amp;amp;feed_time','mmdd') + 1
/

--echo &quot;i - Insert a row using current time.&quot;
[oracle@jystdrac1 ~]$ cat i1.sql 
insert into t_baby(id,feed_time) values(s1.nextval,sysdate)
/
commit
/

--echo &quot;ii - Insert a row using input time.&quot;
[oracle@jystdrac1 ~]$ cat i2.sql 
insert into t_baby(id,feed_time) values(s1.nextval,to_date('&amp;amp;feed_time','mmdd hh24:mi'))
/

--echo &quot;d - Delete a mistake row by id. &quot;
[oracle@jystdrac1 ~]$ cat d1.sql 
delete from t_baby where id = &amp;amp;id
/

--echo &quot;u - Update a mistake row by id.&quot;
[oracle@jystdrac1 ~]$ cat u1.sql 
update t_baby set label = upper('&amp;amp;label') where id = &amp;amp;id
/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQL文本独立出来也方便后续需求有变化时快速更改。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 17:10:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>本文是《 '使用SQL计算宝宝每次吃奶的时间间隔' 》的续篇，因为我工作繁忙，时常不能及时帮助媳妇儿记录，为了让不懂数据库的媳妇儿也可以自己用手机熟练操作。我继续做了一些修正和封装： 1.给媳妇儿的手</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jyzhao/p/12046838.html</dc:identifier>
</item>
<item>
<title>uni-app微信小程序开发之引入腾讯视频小程序播放插件 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/12046831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/12046831.html</guid>
<description>&lt;h2&gt;登录微信小程序管理后台添加腾讯视频播放插件：&lt;/h2&gt;
&lt;p&gt;　　正式开始使用腾讯视频小程序插件之前需先在微信公众平台 -&amp;gt; 第三方设置 -&amp;gt; 插件管理处添加插件，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1336199/201912/1336199-20191215234558421-1520011578.png&quot; alt=&quot;&quot; width=&quot;1183&quot; height=&quot;704&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 在uni-app中引入插件代码：&lt;/h2&gt;
&lt;p&gt;　　注意在使用uni-app开发微信小程序时与直接会用微信网页开发工具开发微信小程序是有很大的差别的，因为uni-app可开发多平台的原因，因此不同平台的开发相应的配置需要放到指定的位置才能够生效。而uni-app引入腾讯视频小程序有两种方式一种是整个小程序可使用（小程序中所有的分包可以使用），第二种是指定对应的分包可使用。&lt;/p&gt;
&lt;h3&gt;指定整个小程序可使用：&lt;/h3&gt;
&lt;p&gt;使用插件之前需要在manifest.json中的mp-weixin内声明使用的插件，具体配置参照所用插件的开发文档：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&quot;mp-weixin&quot;: {
                /* 小程序相关配置 */
                &quot;usingComponents&quot;: true,//是否启用自定义组件模式
                &quot;appid&quot;: &quot;小程序AppID&quot;,
                &quot;plugins&quot;: {
                        &quot;tencentvideo&quot;: {
                                &quot;version&quot;: &quot;1.3.6&quot;,
                                &quot;provider&quot;: &quot;腾讯视频小程序AppID&quot;
                        }
                }
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;指定到对应的分包中使用：&lt;/h3&gt;
&lt;p&gt;如果插件只在（同一个插件不能被多个分包同时引用）一个分包用到，可以单独配置到分包中，这样插件不会随主包加载，可以在&lt;code&gt;pages.json&lt;/code&gt;的&lt;a href=&quot;https://uniapp.dcloud.io/collocation/pages?id=subpackages&quot;&gt;subPackages&lt;/a&gt;中声明插件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
  &quot;subpackages&quot;: [
    {
      &quot;root&quot;: &quot;package1&quot;,//分包名称
      &quot;pages&quot;: [
        &quot;pages/cat&quot;,
        &quot;pages/dog&quot;
      ],
      &quot;plugins&quot;: {
        &quot;tencentvideo&quot;: {
          &quot;version&quot;: &quot;1.3.6&quot;,
          &quot;provider&quot;: &quot;腾讯视频小程序AppID&quot;
        }
      }
    }
  ]
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;在pages.json全局配置文件中对要使用插件的页面配置如下条件编译代码：　　&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&quot;usingComponents&quot;: {
        // #ifdef  MP-WEIXIN 
           &quot;txv-video&quot;: &quot;plugin://tencentvideo/video&quot;
        // #endif
},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1336199/201912/1336199-20191216002629828-2007943876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 在.vue页面中使用腾讯视频播放组件：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;view&amp;gt;
           &amp;lt;!--vid中的腾讯视频id最好为动态的数据，方便管理--&amp;gt;
          &amp;lt;txv-video :vid=&quot;VideoId&quot; playerid=&quot;txv1&quot;&amp;gt;&amp;lt;/txv-video&amp;gt;
&amp;lt;/view&amp;gt;


&amp;lt;script&amp;gt;
export default {
        data() {
                return {
                        VideoId:'c3029q7tdnp'
                };
        }
}
&amp;lt;/script&amp;gt;　　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;关于如何获取腾讯视频vid问题：&lt;/h2&gt;
&lt;p&gt;打开网页腾讯视频=&amp;gt;随便找到一个视频点击鼠标右键=&amp;gt;赋值链接地址（仅供参考）如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1336199/201912/1336199-20191216003947514-2095264152.png&quot; alt=&quot;&quot; width=&quot;1240&quot; height=&quot;702&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后取视频连接地址.html前面的那一小串英文数字编号即可，下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1336199/201912/1336199-20191216004127465-2006307444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 参考资料：&lt;/h2&gt;
&lt;h3&gt;腾讯视频小程序播放插件开发文档：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wxa75efa648b60994b&amp;amp;token=&amp;amp;lang=zh_CN&quot;&gt;https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wxa75efa648b60994b&amp;amp;token=&amp;amp;lang=zh_CN&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;decloud uni-app相关配置：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://uniapp.dcloud.io/component/mp-weixin-plugin&quot;&gt;https://uniapp.dcloud.io/component/mp-weixin-plugin&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;微信小程序特有配置:&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://uniapp.dcloud.io/collocation/manifest?id=mp-weixin&quot;&gt;https://uniapp.dcloud.io/collocation/manifest?id=mp-weixin&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 16:55:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>登录微信小程序管理后台添加腾讯视频播放插件： 正式开始使用腾讯视频小程序插件之前需先在微信公众平台 -&amp;gt; 第三方设置 -&amp;gt; 插件管理处添加插件，如下图所示： 在uni-app中引入插件代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/12046831.html</dc:identifier>
</item>
<item>
<title>Java多态之向上转型 - sumerday</title>
<link>http://www.cnblogs.com/summerday152/p/12046777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/12046777.html</guid>
<description>&lt;p&gt;&lt;strong&gt;多态性是面向对象的第三大特征。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;多态的优点&quot;&gt;多态的优点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;改善代码的组织结构和可读性。&lt;/li&gt;
&lt;li&gt;能够创建可扩展的程序。（&lt;strong&gt;随时可以加入新功能&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;消除类型之间的&lt;strong&gt;耦合&lt;/strong&gt;关系。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说实话，作为小白的我，并不太能够理解上面三个优点。随着深入学习，理解应该会越来越深吧，共勉。&lt;/p&gt;
&lt;h2 id=&quot;向上转型&quot;&gt;向上转型&lt;/h2&gt;
&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Java允许把子类对象赋值给父类的引用变量，不用做任何强制转换，系统自动完成&lt;/strong&gt;。向上转型来自于自下而上的继承关系，子类继承父类，子类是一种特殊的父类，所以向上转型的操作其实是情理之中的。&lt;/p&gt;
&lt;p&gt;下面依照简单的代码，来试着理解向上转型的概念与好处。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.my.pac14;

/**
 * @auther Summerday
 */
public class DynamicBinding {
    //Object是所有类的超类，根据向上转型，该方法可以接受任何类型的对象
    public static void test(Object x) {
        System.out.println(x.toString());
    }

    public static void main(String[] args) {
        test(new PrimaryStudent());//Student
        test(new Student());//Student
        test(new Person());//Person
        test(new Object());//java.lang.Object@1b6d3586
    }
}

class Person extends Object {
    @Override
    public String toString() {
        return &quot;Person&quot;;
    }
}

class Student extends Person {
    @Override
    public String toString() {
        return &quot;Student&quot;;
    }
}

class PrimaryStudent extends Student {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们可以看到，下面的方法接收一个&lt;code&gt;Object&lt;/code&gt;类型的对象，并调用该对象的&lt;code&gt;toString()&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void test(Object x) {
        System.out.println(x.toString());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;下面是调用语句，除了第四句，其他的传入对象都看起来与形参类型不符,但当然是可以运行的，这里面就蕴含着我们说的&lt;strong&gt;向上转型&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    test(new PrimaryStudent());//Student
    test(new Student());//Student
    test(new Person());//Person
    test(new Object());//java.lang.Object@1b6d3586
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;就拿传入Student类型的对象来说吧，拆解一下，是以下的表达式：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Object x = new Student();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Object类是所有类的超类，上式中将创建的子类类型对象直接赋给父类类型的引用变量，这在Java中是允许的，这就是所谓的向上转型。能够实现的原因，也是&lt;u&gt;因为子类在向上转型的过程中，也许会缩小接口，但至少不会比父类中有的接口还要窄&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;举个简单的例子，假设人类可以分为很多很多种，我们可以说&lt;u&gt;学生是人类的一种，却不能说人类是学生的一种&lt;/u&gt;。向上转型一定程度上允许子类扩展超类的部分丢失，通过父类引用变量只能调用父类中的方法来实现，&lt;u&gt;我们去操作人类的时候，只能在人类具有的行为属性中做选择，而不能直接以学生类的标准去操作它，因为我们并不知道他是哪一类，万一不是学生呢&lt;/u&gt;，对吧，用人类总没错，因为我人类有的东西，你学生类一定有。这就是我所理解的向上转型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;向上转型好在哪&quot;&gt;向上转型好在哪&lt;/h3&gt;
&lt;p&gt;如果没有向上转型机制，我们想要达到原来的效果，就需要增加许多重载的&lt;code&gt;test&lt;/code&gt;方法，这样就显得过于繁琐。如果要增加类似&lt;code&gt;test()&lt;/code&gt;的方法或者添加从&lt;code&gt;Object&lt;/code&gt;导出的新类，还会做更多复杂的操作，不利于扩展，不可取不可取。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 原来的情况：需要创建很多很多的测试方法。
    public static void test(Object x) {
        System.out.println(x.toString());
    }
    public static void test(Person x) {
        System.out.println(x.toString());
    }
    public static void test(Student x) {
        System.out.println(x.toString());
    }
    public static void test(PrimaryStudent x) {
        System.out.println(x.toString());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多态的存在正好解决了这个棘手的问题，为了利于扩展，&lt;strong&gt;只需要写一个仅接收基类作为参数的简单方法，不管导出类如何，在运行时自动选择调用对应导出类的方法&lt;/strong&gt;，真的就很舒服。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;那么，编译器又是如何确定应该调用哪个方法呢？这就涉及到所谓的“绑定”啦，这个呢，我们在下片总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考书籍：《Thinking in Java》&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 16:27:00 +0000</pubDate>
<dc:creator>sumerday</dc:creator>
<og:description>[toc] Java多态之向上转型 多态性是面向对象的第三大特征。 多态的优点 改善代码的组织结构和可读性。 能够创建可扩展的程序。（ 随时可以加入新功能 ） 消除类型之间的 耦合 关系。 说实话，作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/12046777.html</dc:identifier>
</item>
<item>
<title>面试官问你编码相关的面试题，把这篇甩给他就完事！ - 程序员乔戈里</title>
<link>http://www.cnblogs.com/qiaogeli/p/12046731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiaogeli/p/12046731.html</guid>
<description>&lt;p&gt;前情回顾：&lt;a href=&quot;https://mp.weixin.qq.com/s/IWSFXURQQfo8zQaz4U9WnQ&quot;&gt;Java中一个字符占两字节 但为什么new String(&quot;字&quot;).getBytes().length 返回3个字节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000656815-1057862883.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000657843-1574515557.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天主要聊一聊：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字节&lt;/li&gt;
&lt;li&gt;字符&lt;/li&gt;
&lt;li&gt;字符集&lt;/li&gt;
&lt;li&gt;编码&lt;/li&gt;
&lt;li&gt;字符编码&lt;/li&gt;
&lt;li&gt;Java 内码和外码&lt;/li&gt;
&lt;li&gt;Unicode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如 ：00001111 这个8位二进制数就占了一个字节的存储容量。&lt;/p&gt;
&lt;p&gt;字节（英语：Byte），通常用作计算机信息计量单位，不分数据类型。 一个字节代表八个比特（英语：Bit）。这个是最基本的概念了，字节是计算存储容量的一种计量单位，计算机只能识别1和0组成的二进制位。一个数就是1位（bit），为了方便计算，我们规定8位就是一个字节。&lt;/p&gt;
&lt;p&gt;例如 ：00001111 这个8位二进制数就占了一个字节的存储容量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000658038-661320521.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;字符和字节不太一样，任何一个文字或符号都是一个字符，但所占字节不一定，不同的编码导致一个字符所占的内存不同。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 也就是说，一个数字是一个字符，一个文字是一个字符，一个标点符号也是一个字符。&lt;/p&gt;
&lt;p&gt;1 是 字符，“汉” 是字符，“！”感叹号是字符。&lt;/p&gt;

&lt;p&gt;　　charset 是 character set 的简写，即字符集。字符的集合就叫字符集。ASCII字符集就是下表中的&lt;strong&gt;字符那一列的所有字符的集合&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000658177-1520755644.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;编码是一个非常宽泛的概念！虽然我们一直用&lt;strong&gt;编码&lt;/strong&gt;特指&lt;strong&gt;字符集编码&lt;/strong&gt;，但这只是一种狭义的理解，广义的理解则有很多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文字是对声音的编码&lt;/li&gt;
&lt;li&gt;照相机，摄像机把光信号编码成图像及视频&lt;/li&gt;
&lt;li&gt;我们还经常能看到条形码，二维码，这些都是编码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;著名的摩尔斯电码其实也是一种编码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000658584-1221418125.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在图片中，M的编码就是“━ ━”，其它类似。&lt;/p&gt;
&lt;p&gt;字符编码 是 编码的一种情况，不过我们学计算机的说到编码就是字符编码。&lt;/p&gt;

&lt;p&gt;encoding 是 charset encoding 的简写，即字符集编码，简称编码。定义字符集中的字符如何编码为特定的二进制数，以便在计算机中存储（就是将字符在字符集中的对应位置化为二进制）。&lt;/p&gt;
&lt;p&gt;字符集和字符编码一般一 一对应，Unicode字符集例外，因为Unicode字符集有三种编码方式（utf-8,utf-16,utf-32）&lt;/p&gt;

&lt;h3 id=&quot;与接口及接口实现的对比&quot;&gt;与接口及接口实现的对比&lt;/h3&gt;
&lt;p&gt;可以把这两者与&lt;strong&gt;接口&lt;/strong&gt;及&lt;strong&gt;接口实现&lt;/strong&gt;做个对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000658731-1842060738.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这里可以很清楚地看到，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编码是依赖于字符集的，就像代码中的接口实现依赖于接口一样；&lt;/li&gt;
&lt;li&gt;一个字符集可以有多个编码实现，就像一个接口可以有多个实现类一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单来说&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内码：char或String在内存里使用的编码方式。&lt;/li&gt;
&lt;li&gt;外码：除了内码都可以认为是“外码”。（包括class文件的编码）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;java内码：unicode（utf-16）&lt;/p&gt;
&lt;p&gt;jvm默认外码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;windows——gbk&lt;/li&gt;
&lt;li&gt;Linux——utf-8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;人们弄出新的字符集标准，驱动力无外乎是旧的字符集里的字符不够用了。&lt;/p&gt;
&lt;p&gt;Unicode 的目标是统一所有的字符集，囊括所有的字符，粗略估算为 17×6万=102 万,所以字符集发展到它这里就到头了，再去整什么新的字符集就没必要也不应该了,102万目前已经完全够用了。&lt;/p&gt;
&lt;p&gt;但如果觉得它现有的编码方案不太好呢？在不能弄出新的字符集情况下，只能在编码方面做文章了，于是就有了多个实现，这样一来传统的一一对应关系就打破了。&lt;/p&gt;
&lt;p&gt;比如说UTF-32编码，哪怕是00000000 00000000 00000000 00001111这种其实只占了1个字节的字符，我们也要为他分配4个字节的空间，这就导致一个可以用1G保存的文件，现在需要4G才能保存，这是极其浪费的做法。&lt;/p&gt;
&lt;p&gt;于是某位大牛觉得UTF-32编码太浪费空间了吧，于是大牛就做出了UTF-8、UTF-16编码方案（这里就是举个例子，可能大牛就是搞出来玩，具体原因无从考究）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000659445-619227380.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000700203-1402696003.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/FZVaMuvikFWlzhs29EWD1g&quot;&gt;浅谈Unicode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000700902-1355623447.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000701062-413242457.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文首发于微信公众号：程序员乔戈里&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果是头条用户，可以在我的头条号&lt;strong&gt;程序员乔戈里&lt;/strong&gt;后台回复 资源获取价值59998元的编程和考研资料&lt;br/&gt;觉得文章不错的欢迎关注我的WX公众号：&lt;strong&gt;程序员乔戈里&lt;/strong&gt;&lt;br/&gt;我是BAT大厂后台开发工程师，，专注分享技术干货/编程资源/求职面试/成长感悟等,关注送5000G编程资源和自己整理的一份帮助不少人拿下java的offer的面经附答案，免费下载CSDN资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191216000701241-1820607272.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 16:07:00 +0000</pubDate>
<dc:creator>程序员乔戈里</dc:creator>
<og:description>前情回顾： 'Java中一个字符占两字节 但为什么new String('字').getBytes().length 返回3个字节' 今天主要聊一聊： 字节 字符 字符集 编码 字符编码 Java 内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiaogeli/p/12046731.html</dc:identifier>
</item>
</channel>
</rss>